ROUND_UP_COUNT(pCacheEntry->SidLength, sizeof(ULONG))
                ;
    sidLength = pCacheEntry->LogonDomainIdLength;



    //
    // length is the required amount of buffer in which to build a working
    // NETLOGON_VALIDATION_SAM_INFO4 structure
    //

    length = ROUND_UP_COUNT(sizeof(NETLOGON_VALIDATION_SAM_INFO4), sizeof(ULONG))
                + commonBits
                + sidLength
                + computerNameLength * sizeof(WCHAR)
                ;
#if DBG
    if (DumpCacheInfo) {
        DbgPrint("NlpBuildAccountInfo: %d bytes required\n", length);
    }
#endif

    // MIDL_user_allocate zeros the buffer.  This routine depends on that.
    pSamInfo = (PNETLOGON_VALIDATION_SAM_INFO4)MIDL_user_allocate(length);
    if (pSamInfo == NULL) {
        return STATUS_NO_MEMORY;
    }

    //
    // point dest at the first (aligned) byte at the start of the variable data
    // area at the end of the sam info structure
    //

    dest = (PUCHAR)(pSamInfo + 1);


    //
    // point source at the first string to be copied out of the variable length
    // data area at the end of the cache entry
    //

    ASSERT(pCacheEntry->Revision >= NLP_CACHE_REVISION_NT_1_0B );

    if( pCacheEntry->Revision >= NLP_CACHE_REVISION_NT_5_0 ) {
        source = (PUCHAR)(pCacheEntry + 1);
    } else {
        source = (PUCHAR)( (PLOGON_CACHE_ENTRY_NT_4_SP4)pCacheEntry + 1 );
    }

    source +=   ROUND_UP_COUNT(pCacheEntry->UserNameLength, sizeof(ULONG))
              + ROUND_UP_COUNT(pCacheEntry->DomainNameLength, sizeof(ULONG)) ;


    if( pCacheEntry->Revision >= NLP_CACHE_REVISION_NT_5_0 )
    {

        NlpCopyAndUpdateAccountInfo(pCacheEntry->DnsDomainNameLength,
                                    &pSamInfo->DnsLogonDomainName,
                                    &source,
                                    &dest
                                    );

        NlpCopyAndUpdateAccountInfo(pCacheEntry->UpnLength,
                                    &pSamInfo->Upn,
                                    &source,
                                    &dest
                                    );

    } else {
        //
        // Fill in the new field for the PNETLOGON_VALIDATION_SAM_INFO4 structure
        //

        RtlInitUnicodeString( &pSamInfo->DnsLogonDomainName, NULL );
        RtlInitUnicodeString( &pSamInfo->Upn, NULL );

        source += ROUND_UP_COUNT(pCacheEntry->DnsDomainNameLength, sizeof(ULONG))
                + ROUND_UP_COUNT(pCacheEntry->UpnLength, sizeof(ULONG));

    }



    //
    // pull out the variable length data from the end of the LOGON_CACHE_ENTRY
    // and stick them at the end of the NETLOGON_VALIDATION_SAM_INFO4 structure.
    // These must be copied out IN THE SAME ORDER as NlpBuildCacheEntry put them
    // in. If we want to change the order of things in the buffer, the order
    // must be changed in both routines (this & NlpBuildCacheEntry)
    //

    //
    // create the UNICODE_STRING structures in the NETLOGON_VALIDATION_SAM_INFO4
    // structure and copy the strings to the end of the buffer. 0 length strings
    // will get a pointer which should be ignored
    //

    NlpCopyAndUpdateAccountInfo(pCacheEntry->EffectiveNameLength,
                                &pSamInfo->EffectiveName,
                                &source,
                                &dest
                                );

    NlpCopyAndUpdateAccountInfo(pCacheEntry->FullNameLength,
                                &pSamInfo->FullName,
                                &source,
                                &dest
                                );

    NlpCopyAndUpdateAccountInfo(pCacheEntry->LogonScriptLength,
                                &pSamInfo->LogonScript,
                                &source,
                                &dest
                                );

    NlpCopyAndUpdateAccountInfo(pCacheEntry->ProfilePathLength,
                                &pSamInfo->ProfilePath,
                                &source,
                                &dest
                                );

    NlpCopyAndUpdateAccountInfo(pCacheEntry->HomeDirectoryLength,
                                &pSamInfo->HomeDirectory,
                                &source,
                                &dest
                                );

    NlpCopyAndUpdateAccountInfo(pCacheEntry->HomeDirectoryDriveLength,
                                &pSamInfo->HomeDirectoryDrive,
                                &source,
                                &dest
                                );

    //
    // copy the group membership array
    //

    pSamInfo->GroupIds = (PGROUP_MEMBERSHIP)dest;
    length = pCacheEntry->GroupCount * sizeof(GROUP_MEMBERSHIP);
    RtlCopyMemory(dest, source, length);
    dest = ROUND_UP_POINTER(dest + length, sizeof(ULONG));
    source = ROUND_UP_POINTER(source + length, sizeof(ULONG));

    //
    // final UNICODE_STRING from LOGON_CACHE_ENTRY. Reorganize this to:
    // strings, groups, SID?
    //

    NlpCopyAndUpdateAccountInfo(pCacheEntry->LogonDomainNameLength,
                                &pSamInfo->LogonDomainName,
                                &source,
                                &dest
                                );


    //
    // Copy all the SIDs
    //

    if (pCacheEntry->Revision >= NLP_CACHE_REVISION_NT_1_0B ) {
        pSamInfo->SidCount = pCacheEntry->SidCount;

        if (pCacheEntry->SidCount) {
            ULONG i, sidLength;
            PULONG SidAttributes = (PULONG) source;
            source = ROUND_UP_POINTER(source + pCacheEntry->SidCount * sizeof(ULONG), sizeof(ULONG));

            //
            // Structures containing pointers must start on 8-byte boundries
            //
            dest = ROUND_UP_POINTER(dest, sizeof(PVOID));
            
            pSamInfo->ExtraSids = (PNETLOGON_SID_AND_ATTRIBUTES) dest;
            dest = ROUND_UP_POINTER(dest + pCacheEntry->SidCount * sizeof(NETLOGON_SID_AND_ATTRIBUTES), sizeof(ULONG));

            for (i = 0; i < pCacheEntry->SidCount ; i++ ) {
                pSamInfo->ExtraSids[i].Attributes = SidAttributes[i];
                sidLength = RtlLengthSid((PSID) source);
                RtlCopySid(sidLength, (PSID) dest, (PSID) source);
                pSamInfo->ExtraSids[i].Sid = (PSID) dest;
                dest = ROUND_UP_POINTER(dest + sidLength, sizeof(ULONG));
                source = ROUND_UP_POINTER(source + sidLength, sizeof(ULONG));
            }

            ASSERT((ULONG) (source - (PCHAR) SidAttributes) == pCacheEntry->SidLength);

        } else {
            pSamInfo->ExtraSids = NULL;
        }
    } else {
        pSamInfo->ExtraSids = NULL;
        pSamInfo->SidCount = 0;
    }


    //
    // copy the LogonDomainId SID
    //

    RtlCopySid(sidLength, (PSID)dest, (PSID)source);
    pSamInfo->LogonDomainId = (PSID)dest;
    dest = ROUND_UP_POINTER(dest + sidLength, sizeof(ULONG));
    source = ROUND_UP_POINTER(source + sidLength, sizeof(ULONG));

    if( computerName != NULL )
    {
        //
        // final UNICODE_STRING. This one from stack. Note that we have finished
        // with source
        //

        source = (PUCHAR)computerName;
        NlpCopyAndUpdateAccountInfo((USHORT)(computerNameLength * sizeof(WCHAR)),
                                    &pSamInfo->LogonServer,
                                    &source,
                                    &dest
                                    );
    } else {

        //
        // Sanity check that we have a proper cache revision.
        //

        if( pCacheEntry->Revision >= NLP_CACHE_REVISION_NT_5_0 )
        {
            //
            // final UNICODE_STRING from LOGON_CACHE_ENTRY.
            //

            NlpCopyAndUpdateAccountInfo((USHORT)pCacheEntry->LogonServerLength,
                                        &pSamInfo->LogonServer,
                                        &source,
                                        &dest
                                        );
        }
    }


    //
    // copy the non-variable fields
    //

    pSamInfo->UserId = pCacheEntry->UserId;
    pSamInfo->PrimaryGroupId = pCacheEntry->PrimaryGroupId;
    pSamInfo->GroupCount = pCacheEntry->GroupCount;

    //
    // finally, invent some fields
    //

    NlpSetTimeField(&pSamInfo->LogonTime, NLP_NOW_TIME);
    NlpSetTimeField(&pSamInfo->LogoffTime, NLP_BIG_TIME);
    NlpSetTimeField(&pSamInfo->KickOffTime, NLP_BIG_TIME);
    NlpSetTimeField(&pSamInfo->PasswordLastSet, NLP_SMALL_TIME);
    NlpSetTimeField(&pSamInfo->PasswordCanChange, NLP_BIG_TIME);
    NlpSetTimeField(&pSamInfo->PasswordMustChange, NLP_BIG_TIME);

    pSamInfo->LogonCount = 0;
    pSamInfo->BadPasswordCount = 0;
    pSamInfo->UserFlags = LOGON_EXTRA_SIDS;
    if (pCacheEntry->LogonPackage != 0) {
        pSamInfo->UserFlags |= pCacheEntry->LogonPackage << PRIMARY_CRED_LOGON_PACKAGE_SHIFT;
    }

    // RtlZeroMemory(&pSamInfo->UserSessionKey, sizeof(pSamInfo->UserSessionKey));



#if DBG
    if (DumpCacheInfo) {
        DbgPrint("NlpBuildAccountInfo:\n");
        DumpAccountInfo(pSamInfo);
    }
#endif

    *AccountInfo = pSamInfo;
    return STATUS_SUCCESS;
    UNREFERENCED_PARAMETER( EntryLength );
}


NTSTATUS
NlpGetCacheControlInfo( VOID )

/*++

Routine Description:

    This function retrieves the cache control information from the
    registry.  This information is placed in global data for use
    throughout this module.  The Cache Table Entry table will also
    be initialized.

    If this routine returns success, then it may be assumed that
    everything completed successfully.

Arguments:

    None.

Return Value:



--*/

{
    NTSTATUS
        NtStatus;

    UNICODE_STRING
        CacheControlValueName;

    ULONG
        RequiredSize;

    PKEY_VALUE_PARTIAL_INFORMATION
        RegInfo = NULL;


    //
    // read the current control info, if it is there.
    // If it is not there, then we may be dealing with a down-level
    // system and might have a single cache entry in the registry.
    //

    RtlInitUnicodeString( &CacheControlValueName, L"NL$Control" );
    NtStatus = NtQueryValueKey(NlpCacheHandle,
                               &CacheControlValueName,
                               KeyValuePartialInformation,
                               NULL,
                               0,
                               &RequiredSize
                               );

    if (NT_SUCCESS(NtStatus) || NtStatus == STATUS_OBJECT_NAME_NOT_FOUND) {
        NTSTATUS TempStatus;

        //
        // Hmmm - no entry, that means we are dealing with a
        //        first release system here (that didn't have
        //        this value).
        //


        //
        // Set up for 1 cache entry.
        // create the secret and cache key entry
        //

        TempStatus = NlpMakeNewCacheEntry( 0 );

        if ( NT_SUCCESS(TempStatus) ) {
            //
            // Now flush out the control information
            //


            NlpCacheControl.Revision = NLP_CACHE_REVISION;
            NlpCacheControl.Entries  = 1;
            TempStatus = NlpWriteCacheControl();

            if ( NT_SUCCESS(TempStatus) ) {

                //
                // If a version 1.0 entry exists,
                //  copy the old form of cache entry to the new structure.
                //

//                if (NT_SUCCESS(NtStatus)) {
//                    TempStatus = NlpConvert1_0To1_0B();
//                }
            }
        }

        NtStatus = TempStatus;

    } else if ( NtStatus == STATUS_BUFFER_TOO_SMALL ) {

        //
        // allocate buffer then do query again, this time receiving data
        //

        RegInfo = (PKEY_VALUE_PARTIAL_INFORMATION)AllocateFromHeap(RequiredSize);
        if (RegInfo == NULL) {
            NtStatus = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        NtStatus = NtQueryValueKey(NlpCacheHandle,
                                   &CacheControlValueName,
                                   KeyValuePartialInformation,
                                   (PVOID)RegInfo,
                                   RequiredSize,
                                   &RequiredSize
                                   );

        if (!NT_SUCCESS(NtStatus)) {
            goto Cleanup;
        }

        //
        // check the revision - we can't deal with up-level revisions.
        //

        if (RegInfo->DataLength < sizeof(NLP_CACHE_CONTROL)) {
            NtStatus = STATUS_UNKNOWN_REVISION;
            goto Cleanup;
        }

        RtlCopyMemory( &NlpCacheControl, &(RegInfo->Data[0]), sizeof(NLP_CACHE_CONTROL) );
        if (NlpCacheControl.Revision > NLP_CACHE_REVISION) {
            NtStatus = STATUS_UNKNOWN_REVISION;
            goto Cleanup;
        }


        //
        // If this is an older cache, update it with the latest revision
        //

        if (NlpCacheControl.Revision != NLP_CACHE_REVISION) {

            // There is no conversion. All the version of cache control have
            //  been the same.
            NlpCacheControl.Revision = NLP_CACHE_REVISION;
            NtStatus = NlpWriteCacheControl();

            if (!NT_SUCCESS(NtStatus)) {
                goto Cleanup;
            }
        }

        NtStatus = STATUS_SUCCESS;
    }

Cleanup:

    if (!NT_SUCCESS(NtStatus)) {
        NlpCacheControl.Entries = 0;    // Disable logon cache
    }

    if( RegInfo ) {
        FreeToHeap( RegInfo );
    }

    return(NtStatus);
}


NTSTATUS
NlpBuildCteTable( VOID )

/*++

Routine Description:

    This function initializes the CTE table from the contents of
    the cache in the registry.


Arguments:

    None.

Return Value:

    STATUS_SUCCESS - the cache is initialized.

    Other - The cache has been disabled.

--*/

{
    NTSTATUS
        NtStatus = STATUS_SUCCESS;

    PLOGON_CACHE_ENTRY
        CacheEntry;

    ULONG
        EntrySize,
        i;


    //
    // Initialize the active and inactive CTE lists
    //

    InitializeListHead( &NlpActiveCtes );
    InitializeListHead( &NlpInactiveCtes );


    //
    // Allocate a CTE table
    //

    NlpCteTable = AllocateFromHeap( sizeof( NLP_CTE ) *
                                    NlpCacheControl.Entries );
    if (NlpCteTable == NULL) {

        //
        // Can't allocate table, disable caching
        //

        NlpCacheControl.Entries = 0;    // Disable cache
        return(STATUS_NO_MEMORY);
    }

    for (i=0; i<NlpCacheControl.Entries; i++) {

        NtStatus = NlpReadCacheEntryByIndex( i,
                                             &CacheEntry,
                                             &EntrySize);
        if (!NT_SUCCESS(NtStatus) ) {
            NlpCacheControl.Entries = 0;    // Disable cache
            return(NtStatus);
        }

        //
        //
        if (EntrySize < sizeof(LOGON_CACHE_ENTRY_NT_4_SP4)) {

            //
            // Hmmm, something is bad.
            // disable caching and return an error
            //

            NlpCacheControl.Entries = 0;    // Disable cache
            FreeToHeap( CacheEntry );
            return( STATUS_INTERNAL_DB_CORRUPTION );
        }

        if (CacheEntry->Revision > NLP_CACHE_REVISION) {
            NlpCacheControl.Entries = 0;  // Disable cache
            FreeToHeap( CacheEntry );
            return(STATUS_UNKNOWN_REVISION);
        }

        NlpCteTable[i].Index  = i;
        NlpCteTable[i].Active = CacheEntry->Valid;
        NlpCteTable[i].Time   = CacheEntry->Time;

        InsertTailList( &NlpInactiveCtes, &NlpCteTable[i].Link );

        if (NlpCteTable[i].Active) {
            NlpAddEntryToActiveList( i );
        }

        FreeToHeap( CacheEntry );

    }
    return(NtStatus);
}


NTSTATUS
NlpChangeCacheSizeIfNecessary( VOID )

/*++

Routine Description:

    This function checks to see if the user has requested a
    different cache size than what we currently have.

    If so, then we try to grow or shrink our cache appropriately.
    If this succeeds, then the global cache control information is
    updated appropriately.  If it fails then one of two things will
    happen:

        1) If the user was trying to shrink the cache, then it will
           be disabled (entries set to zero).

        2) If the user was trying to grow the cache, then we will leave
           it as it is.

    In either of these two failure conditions, an error is returned.


Arguments:

    None.

Return Value:

    STATUS_SUCCESS

--*/

{

    NTSTATUS
        NtStatus;

    UINT
        CachedLogonsCount;

    PNLP_CTE
        NewCteTable,
        Next;

    LIST_ENTRY
        NewActive,
        NewInactive;

    PNLP_CACHE_AND_SECRETS
        CacheAndSecrets;


    ULONG
        ErrorCacheSize,
        EntrySize,
        i,
        j;


    // Find out how many logons to cache.
    // This is a user setable value and it may be different than
    // the last time we booted.
    //

    CachedLogonsCount = GetProfileInt(
                               TEXT("Winlogon"),
                               TEXT("CachedLogonsCount"),
                               NLP_DEFAULT_LOGON_CACHE_COUNT      // Default value
                               );

    //
    // Minimize the user-supplied value with the maximum allowable
    // value.
    //

    if (CachedLogonsCount > NLP_MAX_LOGON_CACHE_COUNT) {
        CachedLogonsCount = NLP_MAX_LOGON_CACHE_COUNT;
    }


    //
    // Compare it to what we already have and see if we need
    // to change the size of the cache
    //

    if (CachedLogonsCount == NlpCacheControl.Entries) {

        //
        // No change
        //

        return(STATUS_SUCCESS);
    }

    //
    // Set the size of the cache to be used in case of error
    // changing the size.  If we are trying to grow the cache,
    // then use the existing cache on error.  If we are trying
    // to shrink the cache, then disable caching on error.
    //

    if (CachedLogonsCount > NlpCacheControl.Entries) {
        ErrorCacheSize = NlpCacheControl.Entries;
    } else {
        ErrorCacheSize = 0;
    }

    //
    // Allocate a CTE table the size of the new table
    //

    NewCteTable = AllocateFromHeap( sizeof( NLP_CTE ) *
                                    CachedLogonsCount );
    if (NewCteTable == NULL) {

        //
        // Can't shrink table, disable caching
        //

        NlpCacheControl.Entries = ErrorCacheSize;
        return(STATUS_NO_MEMORY);
    }



    //
    // Now the tricky parts ...
    //

    if (CachedLogonsCount > NlpCacheControl.Entries) {


        //
        // Try to grow the cache -
        // Create additional secrets and cache entries.
        //
        // Copy time fields and set index
        //

        for (i=0;   i < NlpCacheControl.Entries;   i++) {
            NewCteTable[i].Index = i;
            NewCteTable[i].Time  = NlpCteTable[i].Time;
        }

        //
        // Place existing entries on either the active or inactive list
        //

        InitializeListHead( &NewActive );
        for (Next  = (PNLP_CTE)NlpActiveCtes.Flink;
             Next != (PNLP_CTE)(&NlpActiveCtes);
             Next  = (PNLP_CTE)Next->Link.Flink
             ) {

            InsertTailList( &NewActive, &NewCteTable[Next->Index].Link );
            NewCteTable[Next->Index].Active = TRUE;
        }


        InitializeListHead( &NewInactive );
        for (Next  = (PNLP_CTE)NlpInactiveCtes.Flink;
             Next != (PNLP_CTE)(&NlpInactiveCtes);
             Next  = (PNLP_CTE)Next->Link.Flink
             ) {

            InsertTailList( &NewInactive, &NewCteTable[Next->Index].Link );
            NewCteTable[Next->Index].Active = FALSE;
        }


        //
        // Make all the new table entries.
        // Mark them as invalid.
        //

        for (i=NlpCacheControl.Entries; i<CachedLogonsCount; i++) {

            //
            // Add the CTE entry to the inactive list
            //

            InsertTailList( &NewInactive, &NewCteTable[i].Link );
            NewCteTable[i].Active = FALSE;
            NewCteTable[i].Index  = i;

            NtStatus = NlpMakeNewCacheEntry( i );

            if (!NT_SUCCESS(NtStatus)) {
                FreeToHeap( NewCteTable );
                return(NtStatus);
            }
        }




    } else {


        //
        // Try to shrink the cache.
        //

        if (CachedLogonsCount != 0) {

            //
            // 0 size implies disabling the cache.
            // That is a degenerate case of shrinking that
            // requires only the last few steps of shrinking.
            //


            //
            // Allocate an array of pointers for reading registry and secret
            // info into.  Clear it to assist in cleanup.
            //

            CacheAndSecrets = (PNLP_CACHE_AND_SECRETS)
                              AllocateFromHeap( sizeof( NLP_CACHE_AND_SECRETS ) *
                                                CachedLogonsCount );

            if (CacheAndSecrets == NULL) {
                FreeToHeap( NlpCteTable );
                NlpCacheControl.Entries = ErrorCacheSize;
                return(STATUS_NO_MEMORY);
            }
            RtlZeroMemory( CacheAndSecrets,
                           (sizeof( NLP_CACHE_AND_SECRETS ) * CachedLogonsCount) );


            //
            // Set up the new CTE table to be inactive
            //

            InitializeListHead( &NewActive );
            InitializeListHead( &NewInactive );
            for (i=0; i<CachedLogonsCount; i++) {
                InsertTailList( &NewInactive, &NewCteTable[i].Link );
                NewCteTable[i].Index  = i;
                NewCteTable[i].Active = FALSE;
            }


            //
            // Walk the current active list, reading
            // entries and copying information into the new CTE table.
            //

            i = 0;
            Next = (PNLP_CTE)NlpActiveCtes.Flink;
            while (Next != (PNLP_CTE)&NlpActiveCtes && i<CachedLogonsCount) {

                NtStatus = NlpReadCacheEntryByIndex( Next->Index,
                                                     &CacheAndSecrets[i].CacheEntry,
                                                     &CacheAndSecrets[i].EntrySize
                                                     // &EntrySize
                                                     );
                if (NT_SUCCESS(NtStatus)) {

                    //
                    // for pre-Win2000 cache entries, read the associated secret.
                    //

                    if( CacheAndSecrets[i].CacheEntry->Revision < NLP_CACHE_REVISION_NT_5_0 ) {

                        NtStatus = NlpOpenSecret( Next->Index );
                        if (NT_SUCCESS(NtStatus)) {
                            NtStatus = NlpReadSecret( &CacheAndSecrets[i].NewSecret,
                                                      &CacheAndSecrets[i].OldSecret);

                            NlpCloseSecret();
                        }
                    }

                    if (NT_SUCCESS(NtStatus)) {
                        //
                        // Only make this entry active if everything was
                        // successfully read in.
                        //

                        CacheAndSecrets[i].Active = TRUE;
                        i++;    // advance our new CTE table index

                    }
                }

                Next = (PNLP_CTE)(Next->Link.Flink);

            } // end-while

            //
            // At this point "i" indicates how many CacheAndSecrets entries
            // are active.  Furthermore, the entries were assembled
            // in the CacheAndSecrets array in ascending time order, which
            // is the order they need to be placed in the new CTE table.
            //

            for ( j=0; j<i; j++) {

                Next = &NewCteTable[j];

                //
                // The Time field in the original cache entry is not aligned
                // properly, so copy each field individually.
                //

                Next->Time.LowPart = CacheAndSecrets[j].CacheEntry->Time.LowPart;
                Next->Time.HighPart = CacheAndSecrets[j].CacheEntry->Time.HighPart;

                //
                // Try writing out the new entry's information
                //

                NtStatus = NlpWriteCacheEntry( j,
                                               CacheAndSecrets[j].CacheEntry,
                                               CacheAndSecrets[j].EntrySize
                                               );
                if (NT_SUCCESS(NtStatus)) {

                    if( CacheAndSecrets[j].CacheEntry->Revision < NLP_CACHE_REVISION_NT_5_0 ) {

                        //
                        // for pre-Win2000 cache entries, write the secret back out.
                        // note: we don't bother to try to migrate pre-win2000 -> Win2000
                        // here, because this will happen later, as a side-effect
                        // of updating cache entry during successful DC validated logon.
                        //

                        NtStatus = NlpOpenSecret( j );

                        if (NT_SUCCESS(NtStatus)) {
                            NtStatus = NlpWriteSecret(CacheAndSecrets[j].NewSecret,
                                                      CacheAndSecrets[j].OldSecret);

                        }
                    }

                    if (NT_SUCCESS(NtStatus)) {

                        //
                        // move the corresponding entry into the new CTEs
                        // active list.
                        //

                        Next->Active = TRUE;
                        RemoveEntryList( &Next->Link );
                        InsertTailList( &NewActive, &Next->Link );
                    }
                }

                //
                // Free the CacheEntry and secret information
                //

                if (CacheAndSecrets[j].CacheEntry != NULL) {
                    FreeToHeap( CacheAndSecrets[j].CacheEntry );
                }
                if (CacheAndSecrets[j].NewSecret != NULL) {
                    MIDL_user_free( CacheAndSecrets[j].NewSecret );
                }
                if (CacheAndSecrets[j].OldSecret != NULL) {
                    MIDL_user_free( CacheAndSecrets[j].OldSecret );
                }
            }

            //
            // Free the CacheAndSecrets array
            // (everything in it has already been freed)
            //

            if (CacheAndSecrets != NULL) {
                FreeToHeap( CacheAndSecrets );
            }

            //
            // Change remaining entries to invalid (on disk)
            //

            for ( j=i; j<CachedLogonsCount; j++) {
                NlpMakeNewCacheEntry( j );
            }

        } // end-if (CachedLogonsCount != 0)


        //
        // Now get rid of extra (no longer needed) entries
        //

        for ( j=CachedLogonsCount; j<NlpCacheControl.Entries; j++) {
            NlpEliminateCacheEntry( j );
        }


    }

    //
    // We have successfully:
    //
    //      Allocated the new CTE table.
    //
    //      Filled the CTE table with copies of the currently
    //      active CTEs (including putting each CTE on an active
    //      or inactive list).
    //
    //      Established new CTE entries, including the corresponding
    //      secrets and cache keys in the registry, for the
    //      new CTEs.
    //
    //
    // All we have left to do is:
    //
    //
    //      Update the cache control structure in the registry
    //      to indicate we have a new length
    //
    //      move the new CTE over to the real Active and Inactive
    //      list heads (rather than the local ones we've used so far)
    //
    //      deallocate the old CTE table.
    //
    //      Re-set the entries count in the in-memory
    //      cache-control structure NlpCacheControl.
    //


    NlpCacheControl.Entries = CachedLogonsCount;
    NtStatus = NlpWriteCacheControl();

    if (CachedLogonsCount > 0) {  // Only necessary if there is a new CTE table
        if (!NT_SUCCESS(NtStatus)) {
            FreeToHeap( NewCteTable );
            NlpCacheControl.Entries = ErrorCacheSize;
            return(NtStatus);
        }

        InsertHeadList( &NewActive, &NlpActiveCtes );
        RemoveEntryList( &NewActive );
        InsertHeadList( &NewInactive, &NlpInactiveCtes );
        RemoveEntryList( &NewInactive );

        FreeToHeap( NlpCteTable );
        NlpCteTable = NewCteTable;
    }

    return(NtStatus);

}



NTSTATUS
NlpWriteCacheControl( VOID )

/*++

Routine Description:

    This function writes a new cache length out to the
    cache control structure stored in the registry.

    Note:
        When lengthening the cache, call this routine after the cache
        entries and corresponding secrets have been established for
        the new length.

        When shortening the cache, call this routine before the cache
        entries and corresponding secrets being discarded have actually
        been discarded.

        This ensures that if the system crashes during the resizing
        operation, it will be in a valid state when the system comes
        back up.


Arguments:

    None.

Return Value:

    STATUS_SUCCESS

--*/

{

    NTSTATUS
        NtStatus;

    UNICODE_STRING
        CacheControlValueName;


    RtlInitUnicodeString( &CacheControlValueName, L"NL$Control" );
    NtStatus = NtSetValueKey( NlpCacheHandle,
                              &CacheControlValueName,       // Name
                              0,                            // TitleIndex
                              REG_BINARY,                   // Type
                              &NlpCacheControl,             // Data
                              sizeof(NLP_CACHE_CONTROL)    // DataLength
                              );
    return(NtStatus);
}


VOID
NlpMakeCacheEntryName(
    IN  ULONG               EntryIndex,
    OUT PUNICODE_STRING     Name
    )

/*++

Routine Description:

    This function builds a name of a cache entry value or secret name
    for a cached entry.  The name is based upon the index of the cache
    entry.

    Names are of the form:

            "NLP1" through "NLPnnn"

    where "nnn" is the largest allowable entry count (see
    NLP_MAX_LOGON_CACHE_COUNT).

    The output UNICODE_STRING buffer is expected to be large enough
    to accept this string with a null termination on it.


Arguments:

    EntryIndex - The index of the cache entry whose name is desired.

    Name - A unicode string large enough to accept the name.


Return Value:

    STATUS_SUCCESS

--*/

{
    NTSTATUS
        NtStatus;

    UNICODE_STRING
        TmpString;

    WCHAR
        TmpStringBuffer[17];

    ASSERT(Name->MaximumLength >= 7*sizeof(WCHAR) );
    ASSERT( EntryIndex <= NLP_MAX_LOGON_CACHE_COUNT );

    Name->Length = 0;
    RtlAppendUnicodeToString( Name, L"NL$" );

    TmpString.MaximumLength = 16;
    TmpString.Length = 0;
    TmpString.Buffer = TmpStringBuffer;
    NtStatus = RtlIntegerToUnicodeString ( (EntryIndex+1),      // make 1 based index
                                           10,           // Base 10
                                           &TmpString
                                           );
    ASSERT(NT_SUCCESS(NtStatus));

    RtlAppendUnicodeStringToString( Name, &TmpString );


    return;
}


NTSTATUS
NlpMakeNewCacheEntry(
    ULONG           Index
    )

/*++

Routine Description:

    This routine creates a secret and a cache entry value for a
    new cache entry with the specified index.

    The secret handle is NOT left open.


Arguments:

    Index - The index of the cache entry whose name is desired.

    Name - A unicode string large enough to accept the name.


Return Value:

    STATUS_SUCCESS

--*/

{
    NTSTATUS
        NtStatus;

    LOGON_CACHE_ENTRY
        Entry;

    UNICODE_STRING
        ValueName;

    WCHAR
        NameBuffer[32];

    LSAPR_HANDLE
        SecretHandle;

    ValueName.Length = 0;
    ValueName.MaximumLength = 32;
    ValueName.Buffer = &NameBuffer[0];

    NlpMakeCacheEntryName( Index, &ValueName );

    NtStatus = I_LsarOpenSecret( NtLmGlobalPolicyHandle,
                                    (PLSAPR_UNICODE_STRING) &ValueName,
                                    DELETE,
                                    &SecretHandle
                                    );

    if( NT_SUCCESS( NtStatus ) ) {

        //
        // for Windows2000, we remove old style cache entry related
        // LSA secrets.
        //


        //
        // Deleting and object causes its handle to be closed
        //

        I_LsarDelete( SecretHandle );

//        I_LsarClose( &SecretHandle );
    }


    //
    // Create the cache entry marked as invalid
    //

    RtlZeroMemory( &Entry, sizeof(Entry) );
    Entry.Revision = NLP_CACHE_REVISION;
    Entry.Valid = FALSE;

    NtStatus = NtSetValueKey( NlpCacheHandle,
                              &ValueName,                   // Name
                              0,                            // TitleIndex
                              REG_BINARY,                   // Type
                              &Entry,                       // Data
                              sizeof(LOGON_CACHE_ENTRY)     // DataLength
                              );

    return(NtStatus);
}


NTSTATUS
NlpEliminateCacheEntry(
    IN  ULONG               Index
    )

/*++

Routine Description:

    Delete the registry value and secret object related to a
    CTE entry.

Arguments:

    Index - The index of the entry whose value and secret are to
        be deleted.  This value is used only to build a name with
        (not to reference the CTE table).


Return Value:


--*/

{
    NTSTATUS
        NtStatus;

    UNICODE_STRING
        ValueName;

    WCHAR
        NameBuffer[32];

    LSAPR_HANDLE
        SecretHandle;


    ValueName.Buffer = &NameBuffer[0];
    ValueName.MaximumLength = 32;
    ValueName.Length = 0;
    NlpMakeCacheEntryName( Index, &ValueName );

    NtStatus = I_LsarOpenSecret(NtLmGlobalPolicyHandle,
                             (PLSAPR_UNICODE_STRING) &ValueName,
                             DELETE,
                             &SecretHandle
                             );

    if (NT_SUCCESS(NtStatus)) {

        //
        // Deleting and object causes its handle to be closed
        //

        NtStatus = I_LsarDelete( SecretHandle );
    }

    //
    // Now delete the registry value
    //

    NtStatus = NtDeleteValueKey( NlpCacheHandle, &ValueName );

    return(NtStatus);
}



NTSTATUS
NlpReadCacheEntryByIndex(
    IN  ULONG               Index,
    OUT PLOGON_CACHE_ENTRY* CacheEntry,
    OUT PULONG EntrySize
    )

/*++

Routine Description:

    Reads a cache entry from registry

Arguments:

    Index - CTE table index of the entry to open.
            This is used to build the entry's value and secret names.

    CacheEntry          - pointer to place to return pointer to LOGON_CACHE_ENTRY

    EntrySize           - size of returned LOGON_CACHE_ENTRY


Return Value:

    NTSTATUS
        Success = STATUS_SUCCESS
                    *ppEntry points to allocated LOGON_CACHE_ENTRY
                    *EntrySize is size of returned data

        Failure = STATUS_NO_MEMORY
                    Couldn't allocate buffer for LOGON_CACHE_ENTRY

--*/

{
    NTSTATUS
        NtStatus;

    UNICODE_STRING
        ValueName;

    WCHAR
        NameBuffer[32];

    ULONG
        RequiredSize;

    PKEY_VALUE_FULL_INFORMATION
        RegInfo;

    PLOGON_CACHE_ENTRY
        RCacheEntry;   // CacheEntry in registry buffer

    BYTE FastBuffer[ 512 ];
    PBYTE SlowBuffer = NULL;

    ValueName.Buffer = &NameBuffer[0];
    ValueName.MaximumLength = 32;
    ValueName.Length = 0;
    NlpMakeCacheEntryName( Index, &ValueName );


    RegInfo = (PKEY_VALUE_FULL_INFORMATION)FastBuffer;
    RequiredSize = sizeof(FastBuffer);

    //
    // perform first query to find out how much buffer to allocate
    //

    NtStatus = NtQueryValueKey(NlpCacheHandle,
                               &ValueName,
                               KeyValueFullInformation,
                               (PVOID)RegInfo,
                               RequiredSize,
                               &RequiredSize
                               );

    if( (NtStatus == STATUS_BUFFER_TOO_SMALL) ||
        (NtStatus == STATUS_BUFFER_OVERFLOW) ) {

        //
        // allocate buffer then do query again, this time receiving data
        //

        SlowBuffer = (PBYTE)AllocateFromHeap(RequiredSize);
        if (SlowBuffer == NULL) {
            return(STATUS_NO_MEMORY);
        }

        RegInfo = (PKEY_VALUE_FULL_INFORMATION)SlowBuffer;

        NtStatus = NtQueryValueKey(NlpCacheHandle,
                                   &ValueName,
                                   KeyValueFullInformation,
                                   (PVOID)RegInfo,
                                   RequiredSize,
                                   &RequiredSize
                                   );
    }


    if (NT_SUCCESS(NtStatus)) {

#if DBG
        if (DumpCacheInfo) {
            DbgPrint("NlpReadCacheEntryByIndex: Index                  : %d\n"
                     "                          NtQueryValueKey returns: %d bytes\n"
                     "                                                      DataOffset=%d\n"
                     "                                                      DataLength=%d\n",
                    Index, RequiredSize, RegInfo->DataOffset, RegInfo->DataLength);
        }
#endif

        if( RegInfo->DataLength == 0 ) {
            NtStatus = STATUS_INTERNAL_DB_CORRUPTION;
            *CacheEntry = NULL;
            *EntrySize = 0;
        } else {

            RCacheEntry = (PLOGON_CACHE_ENTRY)((PCHAR)RegInfo + RegInfo->DataOffset);
            *EntrySize = RegInfo->DataLength;

            (*CacheEntry) = (PLOGON_CACHE_ENTRY)AllocateFromHeap( (*EntrySize) );
            if ((*CacheEntry) == NULL) {
                NtStatus = STATUS_NO_MEMORY;
            } else {
                RtlCopyMemory( (*CacheEntry),
                                RCacheEntry,
                                (*EntrySize) );

            }

        }
    }

    if( SlowBuffer )
        FreeToHeap( SlowBuffer );

    return(NtStatus);
}


VOID
NlpAddEntryToActiveList(
    IN  ULONG   Index
    )

/*++

Routine Description:

    Place a CTE entry in the active CTE list.
    This requires placing the entry in the right location in
    the list chronologically.  The beginning of the list is
    the most recently updated (or referenced) cache entry.
    The end of the list is the oldest active cache entry.


    Note - The entry may be already in the active list (but
           in the wrong place), or may be on the inactive list.
           It will be removed from whichever list it is on.

Arguments:

    Index - CTE table index of the entry to make active..

Return Value:

    None.

--*/

{
    PNLP_CTE
        Next;

    //
    // Remove the entry from its current list, and then place it
    // in the active list.
    //


    RemoveEntryList( &NlpCteTable[Index].Link );


    //
    // Now walk the active list until we find a place to insert
    // the entry.  It must follow all entries with more recent
    // time stamps.
    //

    Next = (PNLP_CTE)NlpActiveCtes.Flink;

    while (Next != (PNLP_CTE)&NlpActiveCtes) {

        if ( NlpCteTable[Index].Time.QuadPart > Next->Time.QuadPart ) {

            //
            // More recent than this entry - add it here
            //

            break; // out of while-loop

        }

        Next = (PNLP_CTE)(Next->Link.Flink);  // Advance to next entry
    }


    //
    // Use the preceding entry as the list head.
    //

    InsertHeadList( Next->Link.Blink, &NlpCteTable[Index].Link );

    //
    // Mark the entry as valid
    //

    NlpCteTable[Index].Active = TRUE;

    return;
}


VOID
NlpAddEntryToInactiveList(
    IN  ULONG   Index
    )

/*++

Routine Description:

    Move the CTE entry to the inactive list.

    It doesn't matter if the entry is already inactive.

Arguments:

    Index - CTE table index of the entry to make inactive.

Return Value:

    None.

--*/

{

    //
    // Remove the entry from its current list, and then place it
    // in the inactive list.
    //


    RemoveEntryList( &NlpCteTable[Index].Link );
    InsertTailList( &NlpInactiveCtes, &NlpCteTable[Index].Link );


    //
    // Mark the entry as invalid
    //

    NlpCteTable[Index].Active = FALSE;

    return;
}


VOID
NlpGetFreeEntryIndex(
    OUT PULONG  Index
    )

/*++

Routine Description:

    This routine returns the index of either a free entry,
    or, lacking any free entries, the oldest active entry.

    The entry is left on the list it is already on.  If it
    is used by the caller, then the caller must ensure it is
    re-assigned to the active list (using NlpAddEntryToActiveList()).

    This routine is only callable if the cache is enabled (that is,
    NlpCacheControl.Entries != 0).

Arguments:

    Index - Receives the index of the next available entry.

Return Value:

    None.

--*/

{
    //
    // See if the Inactive list is empty.
    //

    if (NlpInactiveCtes.Flink != &NlpInactiveCtes) {
        (*Index) = ((PNLP_CTE)(NlpInactiveCtes.Flink))->Index;
    } else {

        //
        // Have to return the oldest active entry.
        //

        (*Index) = ((PNLP_CTE)(NlpActiveCtes.Blink))->Index;
    }

    return;
}

/////////////////////////////////////////////////////////////////////////
//                                                                     //
//          Diagnostic support services                                //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

//
// diagnostic dump routines
//

#if DBG

PCHAR
DumpOwfPasswordToString(
    OUT PCHAR Buffer,
    IN  PLM_OWF_PASSWORD Password
    )
{
    int i;
    PCHAR bufptr;

    for (i = 0, bufptr = Buffer; i < sizeof(*Password); ++i) {
        sprintf(bufptr, "%02.2x ", ((PCHAR)Password)[i] & 0xff);
        bufptr += 3;
    }
    return Buffer;
}


VOID
DumpLogonInfo(
    IN  PNETLOGON_LOGON_IDENTITY_INFO LogonInfo
    )
{

    DbgPrint(   "\n"
                "NETLOGON_INTERACTIVE_INFO:\n"
                "DomainName  : \"%*.*ws\"\n"
                "UserName    : \"%*.*ws\"\n"
                "Parm Ctrl   : %u (%x)\n"
                "LogonId     : %u.%u (%x.%x)\n"
                "Workstation : \"%*.*ws\"\n",
                LogonInfo->LogonDomainName.Length/sizeof(WCHAR),
                LogonInfo->LogonDomainName.Length/sizeof(WCHAR),
                LogonInfo->LogonDomainName.Buffer,
                LogonInfo->UserName.Length/sizeof(WCHAR),
                LogonInfo->UserName.Length/sizeof(WCHAR),
                LogonInfo->UserName.Buffer,
                LogonInfo->ParameterControl,
                LogonInfo->ParameterControl,
                LogonInfo->LogonId.HighPart,
                LogonInfo->LogonId.LowPart,
                LogonInfo->LogonId.HighPart,
                LogonInfo->LogonId.LowPart,
                LogonInfo->Workstation.Length/sizeof(WCHAR),
                LogonInfo->Workstation.Length/sizeof(WCHAR),
                LogonInfo->Workstation.Buffer
                );
}


char*
MapWeekday(
    IN  CSHORT  Weekday
    )
{
    switch (Weekday) {
    case 0: return "Sunday";
    case 1: return "Monday";
    case 2: return "Tuesday";
    case 3: return "Wednesday";
    case 4: return "Thursday";
    case 5: return "Friday";
    case 6: return "Saturday";
    }
    return "???";
}


VOID
DumpTime(
    IN  LPSTR   String,
    IN  POLD_LARGE_INTEGER OldTime
    )
{
    TIME_FIELDS tf;
    LARGE_INTEGER Time;

    OLD_TO_NEW_LARGE_INTEGER( (*OldTime), Time );

    RtlTimeToTimeFields(&Time, &tf);
    DbgPrint("%s%02d:%02d:%02d.%03d %02d/%02d/%d (%s [%d])\n",
            String,
            tf.Hour,
            tf.Minute,
            tf.Second,
            tf.Milliseconds,
            tf.Month,
            tf.Day,
            tf.Year,
            MapWeekday(tf.Weekday),
            tf.Weekday
            );
}


VOID
DumpGroupIds(
    IN  LPSTR   String,
    IN  ULONG   Count,
    IN  PGROUP_MEMBERSHIP GroupIds
    )
{
    DbgPrint(String);
    if (!Count) {
        DbgPrint("No group IDs!\n");
    } else {
        char tab[80];

        memset(tab, ' ', strlen(String));
//        tab[strcspn(String, "%")] = 0;
        tab[strlen(String)] = 0;
        while (Count--) {
            DbgPrint("%d, %d\n", GroupIds->RelativeId, GroupIds->Attributes);
            if (Count) {
                DbgPrint(tab);
            }
            ++GroupIds;
        }
    }
}


VOID
DumpSessKey(
    IN  LPSTR   String,
    IN  PUSER_SESSION_KEY Key
    )
{
    int     len;
    DbgPrint(String);
    DbgPrint("%02.2x-%02.2x-%02.2x-%02.2x-%02.2x-%02.2x-%02.2x-%02.2x\n",
            ((PUCHAR)&Key->data[0])[0],
            ((PUCHAR)&Key->data[0])[1],
            ((PUCHAR)&Key->data[0])[2],
            ((PUCHAR)&Key->data[0])[3],
            ((PUCHAR)&Key->data[0])[4],
            ((PUCHAR)&Key->data[0])[5],
            ((PUCHAR)&Key->data[0])[6],
            ((PUCHAR)&Key->data[0])[7]
            );
    len = strlen(String);
    DbgPrint("%-*.*s", len, len, "");
    DbgPrint("%02.2x-%02.2x-%02.2x-%02.2x-%02.2x-%02.2x-%02.2x-%02.2x\n",
            ((PUCHAR)&Key->data[1])[0],
            ((PUCHAR)&Key->data[1])[1],
            ((PUCHAR)&Key->data[1])[2],
            ((PUCHAR)&Key->data[1])[3],
            ((PUCHAR)&Key->data[1])[4],
            ((PUCHAR)&Key->data[1])[5],
            ((PUCHAR)&Key->data[1])[6],
            ((PUCHAR)&Key->data[1])[7]
            );
}


VOID
DumpSid(
    LPSTR   String,
    PISID   Sid
    )
{
    DbgPrint(String);

    if ( Sid == NULL ) {
        DbgPrint(0, "(null)\n");
    } else {
        UNICODE_STRING SidString;
        NTSTATUS Status;

        Status = RtlConvertSidToUnicodeString( &SidString, Sid, TRUE );

        if ( !NT_SUCCESS(Status) ) {
            DbgPrint("Invalid 0x%lX\n", Status );
        } else {
            DbgPrint( "%wZ\n", &SidString );
            RtlFreeUnicodeString( &SidString );
        }
    }
}


VOID
DumpAccountInfo(
    IN  PNETLOGON_VALIDATION_SAM_INFO4 AccountInfo
    )
{
    DbgPrint(   "\n"
                "NETLOGON_VALIDATION_SAM_INFO:\n");

    DumpTime(   "LogonTime          : ", &AccountInfo->LogonTime);

    DumpTime(   "LogoffTime         : ", &AccountInfo->LogoffTime);

    DumpTime(   "KickOffTime        : ", &AccountInfo->KickOffTime);

    DumpTime(   "PasswordLastSet    : ", &AccountInfo->PasswordLastSet);

    DumpTime(   "PasswordCanChange  : ", &AccountInfo->PasswordCanChange);

    DumpTime(   "PasswordMustChange : ", &AccountInfo->PasswordMustChange);

    DbgPrint(   "EffectiveName      : \"%*.*ws\"\n"
                "Upn                : \"%*.*ws\"\n"
                "FullName           : \"%*.*ws\"\n"
                "LogonScript        : \"%*.*ws\"\n"
                "ProfilePath        : \"%*.*ws\"\n"
                "HomeDirectory      : \"%*.*ws\"\n"
                "HomeDirectoryDrive : \"%*.*ws\"\n"
                "LogonCount         : %d\n"
                "BadPasswordCount   : %d\n"
                "UserId             : %d\n"
                "PrimaryGroupId     : %d\n"
                "GroupCount         : %d\n",
                AccountInfo->EffectiveName.Length/sizeof(WCHAR),
                AccountInfo->EffectiveName.Length/sizeof(WCHAR),
                AccountInfo->EffectiveName.Buffer,
                AccountInfo->Upn.Length/sizeof(WCHAR),
                AccountInfo->Upn.Length/sizeof(WCHAR),
                AccountInfo->Upn.Buffer,
                AccountInfo->FullName.Length/sizeof(WCHAR),
                AccountInfo->FullName.Length/sizeof(WCHAR),
                AccountInfo->FullName.Buffer,
                AccountInfo->LogonScript.Length/sizeof(WCHAR),
                AccountInfo->LogonScript.Length/sizeof(WCHAR),
                AccountInfo->LogonScript.Buffer,
                AccountInfo->ProfilePath.Length/sizeof(WCHAR),
                AccountInfo->ProfilePath.Length/sizeof(WCHAR),
                AccountInfo->ProfilePath.Buffer,
                AccountInfo->HomeDirectory.Length/sizeof(WCHAR),
                AccountInfo->HomeDirectory.Length/sizeof(WCHAR),
                AccountInfo->HomeDirectory.Buffer,
                AccountInfo->HomeDirectoryDrive.Length/sizeof(WCHAR),
                AccountInfo->HomeDirectoryDrive.Length/sizeof(WCHAR),
                AccountInfo->HomeDirectoryDrive.Buffer,
                AccountInfo->LogonCount,
                AccountInfo->BadPasswordCount,
                AccountInfo->UserId,
                AccountInfo->PrimaryGroupId,
                AccountInfo->GroupCount
                );

    DumpGroupIds("GroupIds           : ",
                AccountInfo->GroupCount,
                AccountInfo->GroupIds
                );

    DbgPrint(   "UserFlags          : 0x%08x\n",
                AccountInfo->UserFlags
                );

    DumpSessKey("UserSessionKey     : ", &AccountInfo->UserSessionKey);

    DbgPrint(   "LogonServer        : \"%*.*ws\"\n"
                "LogonDomainName    : \"%*.*ws\"\n"
                "DnsLogonDomainName : \"%*.*ws\"\n",
                AccountInfo->LogonServer.Length/sizeof(WCHAR),
                AccountInfo->LogonServer.Length/sizeof(WCHAR),
                AccountInfo->LogonServer.Buffer,
                AccountInfo->LogonDomainName.Length/sizeof(WCHAR),
                AccountInfo->LogonDomainName.Length/sizeof(WCHAR),
                AccountInfo->LogonDomainName.Buffer,
                AccountInfo->DnsLogonDomainName.Length/sizeof(WCHAR),
                AccountInfo->DnsLogonDomainName.Length/sizeof(WCHAR),
                AccountInfo->DnsLogonDomainName.Buffer
                );

    DumpSid(    "LogonDomainId      : ", (PISID)AccountInfo->LogonDomainId);
}


VOID
DumpCacheEntry(
    IN  ULONG              Index,
    IN  PLOGON_CACHE_ENTRY pEntry
    )
{
    PUCHAR dataptr;
    ULONG length;

    DbgPrint(   "\n"
                "LOGON_CACHE_ENTRY:\n"
                "CTE Index          : %d\n", Index);

    if (pEntry->Valid != TRUE) {
        DbgPrint(   "State              : INVALID\n");
        return;
    }

    dataptr = (PUCHAR)(pEntry+1);

    length = pEntry->UserNameLength;

    DbgPrint(   "State              : VALID\n");
    DbgPrint(   "UserName           : \"%*.*ws\"\n", length/2, length/2, dataptr);
    dataptr = ROUND_UP_POINTER(dataptr+length, sizeof(ULONG));

    length = pEntry->DomainNameLength;
    DbgPrint(   "DomainName         : \"%*.*ws\"\n", length/2, length/2, dataptr);
    dataptr = ROUND_UP_POINTER(dataptr+length, sizeof(ULONG));

    length = pEntry->DnsDomainNameLength;
    DbgPrint(   "DnsDomainname      : \"%*.*ws\"\n", length/2, length/2, dataptr);
    dataptr = ROUND_UP_POINTER(dataptr+length, sizeof(ULONG));

    length = pEntry->UpnLength;
    DbgPrint(   "Upn                : \"%*.*ws\"\n", length/2, length/2, dataptr);
    dataptr = ROUND_UP_POINTER(dataptr+length, sizeof(ULONG));

    length = pEntry->EffectiveNameLength;
    DbgPrint(   "EffectiveName      : \"%*.*ws\"\n", length/2, length/2, dataptr);
    dataptr = ROUND_UP_POINTER(dataptr+length, sizeof(ULONG));

    length = pEntry->FullNameLength;
    DbgPrint(   "FullName           : \"%*.*ws\"\n", length/2, length/2, dataptr);
    dataptr = ROUND_UP_POINTER(dataptr+length, sizeof(ULONG));

    length = pEntry->LogonScriptLength;
    DbgPrint(   "LogonScript        : \"%*.*ws\"\n", length/2, length/2, dataptr);
    dataptr = ROUND_UP_POINTER(dataptr+length, sizeof(ULONG));

    length = pEntry->ProfilePathLength;
    DbgPrint(   "ProfilePath        : \"%*.*ws\"\n", length/2, length/2, dataptr);
    dataptr = ROUND_UP_POINTER(dataptr+length, sizeof(ULONG));

    length = pEntry->HomeDirectoryLength;
    DbgPrint(   "HomeDirectory      : \"%*.*ws\"\n", length/2, length/2, dataptr);
    dataptr = ROUND_UP_POINTER(dataptr+length, sizeof(ULONG));

    length = pEntry->HomeDirectoryDriveLength;
    DbgPrint(   "HomeDirectoryDrive : \"%*.*ws\"\n", length/2, length/2, dataptr);
    dataptr = ROUND_UP_POINTER(dataptr+length, sizeof(ULONG));

    DbgPrint(   "UserId             : %d\n"
                "PrimaryGroupId     : %d\n"
                "GroupCount         : %d\n",
                pEntry->UserId,
                pEntry->PrimaryGroupId,
                pEntry->GroupCount
                );

    DumpGroupIds(
                "GroupIds           : ",
                pEntry->GroupCount,
                (PGROUP_MEMBERSHIP)dataptr
                );

    dataptr = ROUND_UP_POINTER((dataptr+pEntry->GroupCount * sizeof(GROUP_MEMBERSHIP)), sizeof(ULONG));

    length = pEntry->LogonDomainNameLength;
    DbgPrint(   "LogonDomainName    : \"%*.*ws\"\n", length/2, length/2, dataptr);
    dataptr = ROUND_UP_POINTER(dataptr+length, sizeof(ULONG));


    if (pEntry->SidCount) {
        ULONG i, sidLength;
        PULONG SidAttributes = (PULONG) dataptr;

        dataptr = ROUND_UP_POINTER(dataptr + pEntry->SidCount * sizeof(ULONG), sizeof(ULONG));
        for (i = 0; i < pEntry->SidCount ; i++ ) {
            sidLength = RtlLengthSid ((PSID) dataptr);
            DumpSid("Sid    : ",(PISID) dataptr);
            DbgPrint("\tAttributes = 0x%x\n",SidAttributes[i]);
            dataptr = ROUND_UP_POINTER(dataptr + sidLength, sizeof(ULONG));
        }

    }

    DumpSid(    "LogonDomainId      : ", (PISID)dataptr);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\ntlmcomn.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    ntlmcomn.h

Abstract:

    Header file describing the interface to code common to the
    NT Lanman Security Support Provider (NtLmSsp) Service and the DLL.

Author:

    Cliff Van Dyke (CliffV) 17-Sep-1993

Revision History:
    ChandanS  03-Aug-1996 Stolen from net\svcdlls\ntlmssp\ntlmcomn.h

--*/

#ifndef _NTLMCOMN_INCLUDED_
#define _NTLMCOMN_INCLUDED_

////////////////////////////////////////////////////////////////////////////
//
// Common include files needed by ALL NtLmSsp files
//
////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <winsvc.h>     // Needed for service controller APIs
#include <ntmsv1_0.h>   // MSV 1.0 Authentication Package

#include <security.h>   // General definition of a Security Support Provider
#include <spseal.h>     // Prototypes for Seal & Unseal

#include <ntlmssp.h>    // External definition of the NtLmSsp service
#include <lmcons.h>
#include <debug.h>      // NtLmSsp debugging


////////////////////////////////////////////////////////////////////////
//
// Global Definitions
//
////////////////////////////////////////////////////////////////////////

#define NTLMSSP_KEY_SALT    0xbd


//
// Procedure forwards from utility.cxx
//

#if DBG

NTSTATUS
SspNtStatusToSecStatus(
    IN NTSTATUS NtStatus,
    IN SECURITY_STATUS DefaultStatus
    );
#else
#define SspNtStatusToSecStatus( x, y ) (x)
#endif


BOOLEAN
SspTimeHasElapsed(
    IN LARGE_INTEGER StartTime,
    IN DWORD Timeout
    );

NTSTATUS
SspDuplicateToken(
    IN HANDLE OriginalToken,
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    OUT PHANDLE DuplicatedToken
    );

LPWSTR
SspAllocWStrFromWStr(
    IN LPWSTR Unicode
    );

VOID
SspHidePassword(
    IN OUT PUNICODE_STRING Password
    );

VOID
SspRevealPassword(
    IN OUT PUNICODE_STRING HiddenPassword
    );

BOOLEAN
SspGetTokenBuffer(
    IN PSecBufferDesc TokenDescriptor OPTIONAL,
    IN ULONG BufferIndex,
    OUT PSecBuffer * Token,
    IN BOOLEAN ReadonlyOK
    );

//
// Procedure forwards from credhand.cxx
//

NTSTATUS
SsprAcquireCredentialHandle(
    IN PLUID LogonId,
    IN PSECPKG_CLIENT_INFO ClientInfo,
    IN ULONG CredentialUseFlags,
    OUT PULONG_PTR CredentialHandle,
    OUT PTimeStamp Lifetime,
    IN OPTIONAL PUNICODE_STRING DomainName,
    IN OPTIONAL PUNICODE_STRING UserName,
    IN OPTIONAL PUNICODE_STRING Password
    );

//
// Procedure forwards from context.cxx
//

PSSP_CONTEXT
SspContextAllocateContext(
    VOID
    );

NTSTATUS
SspContextGetMessage(
    IN PVOID InputMessage,
    IN ULONG InputMessageSize,
    IN NTLM_MESSAGE_TYPE ExpectedMessageType,
    OUT PVOID* OutputMessage
    );

BOOLEAN
SspConvertRelativeToAbsolute (
    IN PVOID MessageBase,
    IN ULONG MessageSize,
    IN PSTRING32 StringToRelocate,
    IN PSTRING OutputString,
    IN BOOLEAN AlignToWchar,
    IN BOOLEAN AllowNullString
    );

VOID
SspContextCopyString(
    IN PVOID MessageBuffer,
    OUT PSTRING32 OutString,
    IN PSTRING InString,
    IN OUT PCHAR *Where
    );

BOOL
SsprCheckMinimumSecurity(
    IN ULONG NegotiateFlags,
    IN ULONG MinimumSecurityFlags
    );

SECURITY_STATUS
SspContextReferenceContext(
    IN ULONG_PTR ContextHandle,
    IN BOOLEAN RemoveContext,
    OUT PSSP_CONTEXT *ContextResult
    );

VOID
SspContextDereferenceContext(
    PSSP_CONTEXT Context
    );

VOID
SspContextCopyStringAbsolute(
    IN PVOID MessageBuffer,
    OUT PSTRING OutString,
    IN PSTRING InString,
    IN OUT PCHAR *Where
    );

SECURITY_STATUS
SsprMakeSessionKey(
    IN  PSSP_CONTEXT Context,
    IN  PSTRING LmChallengeResponse,
    IN  UCHAR NtUserSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH], // from the DC or GetChalResp
    IN  UCHAR LanmanSessionKey[MSV1_0_LANMAN_SESSION_KEY_LENGTH],     // from the DC of GetChalResp
    IN  PSTRING DatagramSessionKey
    );

NTSTATUS
SsprQueryTreeName(
    OUT  PUNICODE_STRING TreeName
    );

NTSTATUS
SsprUpdateTargetInfo(
    VOID
    );

TimeStamp
SspContextGetTimeStamp(
    IN PSSP_CONTEXT Context,
    IN BOOLEAN GetExpirationTime
    );

VOID
SspContextSetTimeStamp(
    IN PSSP_CONTEXT Context,
    IN LARGE_INTEGER ExpirationTime
    );

//
// Procedure forwards from ctxtcli.cxx
//

NTSTATUS
SsprHandleFirstCall(
    IN ULONG_PTR CredentialHandle,
    IN OUT PULONG_PTR ContextHandle,
    IN ULONG ContextReqFlags,
    IN ULONG InputTokenSize,
    IN PVOID InputToken,
    IN PUNICODE_STRING TargetServerName OPTIONAL,
    IN OUT PULONG OutputTokenSize,
    OUT PVOID *OutputToken,
    OUT PULONG ContextAttributes,
    OUT PTimeStamp ExpirationTime,
    OUT PUCHAR SessionKey,
    OUT PULONG NegotiateFlags
    );


NTSTATUS
SsprHandleNegotiateMessage(
    IN ULONG_PTR CredentialHandle,
    IN OUT PULONG_PTR ContextHandle,
    IN ULONG ContextReqFlags,
    IN ULONG InputTokenSize,
    IN PVOID InputToken,
    IN OUT PULONG OutputTokenSize,
    OUT PVOID *OutputToken,
    OUT PULONG ContextAttributes,
    OUT PTimeStamp ExpirationTime
    );

//
// Procedure forwards from ctxtsrv.cxx
//

NTSTATUS
SsprHandleChallengeMessage(
    IN ULONG_PTR CredentialHandle,
    IN OUT PULONG_PTR ContextHandle,
    IN ULONG ContextReqFlags,
    IN ULONG InputTokenSize,
    IN PVOID InputToken,
    IN ULONG SecondInputTokenSize,
    IN PVOID SecondInputToken,
	IN PUNICODE_STRING TargetServerName, OPTIONAL
    IN OUT PULONG OutputTokenSize,
    OUT PVOID *OutputToken,
    IN OUT PULONG SecondOutputTokenSize,
    OUT PVOID *SecondOutputToken,
    OUT PULONG ContextAttributes,
    OUT PTimeStamp ExpirationTime,
    OUT PUCHAR SessionKey,
    OUT PULONG NegotiateFlags
    );

NTSTATUS
SsprHandleAuthenticateMessage(
    IN ULONG_PTR CredentialHandle,
    IN OUT PULONG_PTR ContextHandle,
    IN ULONG ContextReqFlags,
    IN ULONG InputTokenSize,
    IN PVOID InputToken,
    IN ULONG SecondInputTokenSize,
    IN PVOID SecondInputToken,
    IN OUT PULONG OutputTokenSize,
    OUT PVOID *OutputToken,
    OUT PULONG ContextAttributes,
    OUT PTimeStamp ExpirationTime,
    OUT PUCHAR SessionKey,
    OUT PULONG NegotiateFlags,
    OUT PHANDLE TokenHandle,
    OUT PNTSTATUS SubStatus,
    OUT PTimeStamp PasswordExpiry,
    OUT PULONG UserFlags
    );

NTSTATUS
SsprDeleteSecurityContext (
    ULONG_PTR ContextHandle
    );

BOOL
SspEnableAllPrivilegesToken(
    IN  HANDLE ClientTokenHandle
    );

//
// Procedure forwards from encrypt.cxx
//

BOOLEAN
IsEncryptionPermitted(VOID);

//
// Procedure forwards from userapi.cxx
//

NTSTATUS
SspMapContext(
    IN PULONG_PTR phContext,
    IN PUCHAR pSessionKey,
    IN ULONG NegotiateFlags,
    IN HANDLE TokenHandle,
    IN PTimeStamp PasswordExpiry OPTIONAL,
    IN ULONG UserFlags,
    OUT PSecBuffer ContextData
    );

//
// procedure forwards from nlmain.c
//

NTSTATUS
SspAcceptCredentials(
    IN SECURITY_LOGON_TYPE LogonType,
    IN PSECPKG_PRIMARY_CRED PrimaryCredentials,
    IN PSECPKG_SUPPLEMENTAL_CRED SupplementalCredentials
    );

#endif // ifndef _NTLMCOMN_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\ntlmfunc.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        ntlmfunc.h
//
// Contents:    prototypes for export functions as in secpkg.h
//
//
// History:     ChandanS  26-Jul-96   Stolen from kerberos\client2\kerbfunc.h
//
//------------------------------------------------------------------------

#ifndef __NTLMFUNC_H__
#define __NTLMFUNC_H__

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

SpInitializeFn                  SpInitialize;
SpGetInfoFn                     SpGetInfo;
LSA_AP_LOGON_USER_EX2           LsaApLogonUserEx2;

SpAcceptCredentialsFn           SpAcceptCredentials;
SpAcquireCredentialsHandleFn    SpAcquireCredentialsHandle;
SpFreeCredentialsHandleFn       SpFreeCredentialsHandle;
SpQueryCredentialsAttributesFn  SpQueryCredentialsAttributes;
SpSaveCredentialsFn             SpSaveCredentials;
SpGetCredentialsFn              SpGetCredentials;
SpDeleteCredentialsFn           SpDeleteCredentials;

SpInitLsaModeContextFn          SpInitLsaModeContext;
SpDeleteContextFn               SpDeleteContext;
SpAcceptLsaModeContextFn        SpAcceptLsaModeContext;

LSA_AP_LOGON_TERMINATED         LsaApLogonTerminated;
SpApplyControlTokenFn           SpApplyControlToken;
LSA_AP_CALL_PACKAGE             LsaApCallPackage;
LSA_AP_CALL_PACKAGE             LsaApCallPackageUntrusted;
LSA_AP_CALL_PACKAGE_PASSTHROUGH LsaApCallPackagePassthrough;
SpShutdownFn                    SpShutdown;
SpGetUserInfoFn                 SpGetUserInfo;

SpInstanceInitFn                SpInstanceInit;
SpInitUserModeContextFn         SpInitUserModeContext;
SpMakeSignatureFn               SpMakeSignature;
SpVerifySignatureFn             SpVerifySignature;
SpSealMessageFn                 SpSealMessage;
SpUnsealMessageFn               SpUnsealMessage;
SpGetContextTokenFn             SpGetContextToken;
SpQueryContextAttributesFn      SpQueryContextAttributes;
SpDeleteContextFn               SpDeleteUserModeContext;
SpCompleteAuthTokenFn           SpCompleteAuthToken;
SpFormatCredentialsFn           SpFormatCredentials;
SpMarshallSupplementalCredsFn   SpMarshallSupplementalCreds;
SpExportSecurityContextFn       SpExportSecurityContext;
SpImportSecurityContextFn       SpImportSecurityContext;
SpGetExtendedInformationFn      SpGetExtendedInformation ;
SpSetExtendedInformationFn      SpSetExtendedInformation ;
SpQueryContextAttributesFn      SpQueryLsaModeContextAttributes;
SpSetContextAttributesFn        SpSetContextAttributes;
SpQueryCredentialsAttributesFn  SpQueryCredentialsAttributes ;

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __NTLMFUNC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\ntlmsspi.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    ntlmsspi.h

Abstract:

    Header file describing the interface to code common to the
    NT Lanman Security Support Provider (NtLmSsp) Service and the DLL.

Author:

    Cliff Van Dyke (CliffV) 17-Sep-1993

Revision History:
    ChandanS  03-Aug-1996  Stolen from net\svcdlls\ntlmssp\common\ntlmsspi.h

--*/

#ifndef _NTLMSSPI_INCLUDED_
#define _NTLMSSPI_INCLUDED_

//
// init.c will #include this file with NTLMCOMN_ALLOCATE defined.
// That will cause each of these variables to be allocated.
//
#ifdef NTLMSSPI_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif


////////////////////////////////////////////////////////////////////////
//
// Global Definitions
//
////////////////////////////////////////////////////////////////////////

//
// Description of a credential.
//

#define SSP_CREDENTIAL_TAG_ACTIVE  (ULONG)('AdrC')
#define SSP_CREDENTIAL_TAG_DELETE  (ULONG)('DdrC')

#define SSP_CREDENTIAL_FLAG_WAS_NETWORK_SERVICE 0x1

typedef struct _SSP_CREDENTIAL {

    //
    // Global list of all Credentials.
    //  (Serialized by SspCredentialCritSect)
    //

    LIST_ENTRY Next;

    //
    // Used to prevent this Credential from being deleted prematurely.
    //  (Serialized by SspCredentialCritSect)
    //

    ULONG References;

    //
    // Flag of how credential may be used.
    //
    // SECPKG_CRED_* flags
    //

    ULONG CredentialUseFlags;

    //
    // Logon ID of the client
    //

    LUID LogonId;

    //
    // Process Id of client
    //

    ULONG ClientProcessID;

    //
    // Tag indicating credential is valid for fast reference.
    //

    ULONG CredentialTag;

    //
    // Impersonation level of caller at time of AcquireCredentialsHandle
    //

    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;

    //
    // Default credentials on client context, on server context UserName
    // holds a full user name (domain\user) and the other two should be
    // NULL.
    //

    UNICODE_STRING DomainName;
    UNICODE_STRING UserName;
    UNICODE_STRING Password;


    //
    // This flag should be set when the credential is unlinked
    // from the list.
    //

    BOOLEAN Unlinked;

    //
    // This flag is set when the credential was granted to a 
    // kernel mode caller
    //

    BOOLEAN KernelClient ;

    //
    // ntlm specific credential usage flags
    //

    ULONG MutableCredFlags;

} SSP_CREDENTIAL, *PSSP_CREDENTIAL;

typedef enum {
    IdleState,
    NegotiateSentState,    // Outbound context only
    ChallengeSentState,    // Inbound context only
    AuthenticateSentState, // Outbound context only
    AuthenticatedState,    // Inbound context only
    PassedToServiceState   // Outbound context only
} SSP_CONTEXT_STATE, *PSSP_CONTEXT_STATE;


//
// Description of a Context
//

#define SSP_CONTEXT_TAG_ACTIVE  (ULONG64)('AxtC')
#define SSP_CONTEXT_TAG_DELETE  (ULONG64)('DxtC')

typedef struct _SSP_CONTEXT {

    //
    // Tag indicating context is valid.
    //

    ULONG64 ContextTag;


    //
    // Timeout the context after awhile.
    //

    LARGE_INTEGER StartTime;
    ULONG Interval;

    //
    // Used to prevent this Context from being deleted prematurely.
    //  (Serialized by SspContextCritSect)
    //

    ULONG References;



    //
    // Maintain the Negotiated protocol
    //

    ULONG NegotiateFlags;

    //
    // Maintain the context requirements
    //

    ULONG ContextFlags;

    //
    // State of the context
    //

    SSP_CONTEXT_STATE State;

    //
    // Token Handle of authenticated user
    //  Only valid when in AuthenticatedState.
    //

    HANDLE TokenHandle;

    //
    // Referenced pointer to the credential used to create this
    // context.
    //

    PSSP_CREDENTIAL Credential;

    //
    // The challenge passed to the client.
    //  Only valid when in ChallengeSentState.
    //

    UCHAR Challenge[MSV1_0_CHALLENGE_LENGTH];

    //
    // The session key calculated by the LSA
    //

    UCHAR SessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];

    //
    // Default credentials.
    //

    UNICODE_STRING DomainName;
    UNICODE_STRING UserName;
    UNICODE_STRING Password;

    //
    // optional marshalled targetinfo for credential manager.
    //

    PCREDENTIAL_TARGET_INFORMATIONW TargetInfo;

    //
    // marshalled target info for DFS/RDR.
    //

    PBYTE       pbMarshalledTargetInfo;
    ULONG       cbMarshalledTargetInfo;

    //
    // context handle referenced to validate loopback operations.
    //

    ULONG_PTR ServerContextHandle;

    //
    // Process Id of client
    //

    ULONG ClientProcessID;
    NTSTATUS LastStatus;

    BOOLEAN Server;         // client or server ? (can be implied by other fields...)

    BOOLEAN DownLevel;      // downlevel RDR/SRV ?

    //
    // This flag is set when the context was granted to a
    // kernel mode caller
    //

    BOOLEAN KernelClient;

} SSP_CONTEXT, *PSSP_CONTEXT;

//
// Maximum lifetime of a context
//

#if DBG
#define NTLMSSP_MAX_LIFETIME (2*60*60*1000)    // 2 hours
#else
// used to be 2 minutes, changed to 5 minutes to allow negotiation in
// wide-area networks which can have long retry timeouts
#define NTLMSSP_MAX_LIFETIME (5*60*1000)    // 5 minutes
#endif // DBG



typedef struct _SSP_PROCESSOPTIONS {

    //
    // Global list of all process options.
    //  (Serialized by NtLmGlobalProcessOptionsLock
    //

    LIST_ENTRY Next;

    //
    // Process Id of client
    //

    ULONG ClientProcessID;

    //
    // options bitmask.
    //

    ULONG ProcessOptions;

} SSP_PROCESSOPTIONS, *PSSP_PROCESSOPTIONS;



////////////////////////////////////////////////////////////////////////
//
// Procedure Forwards
//
////////////////////////////////////////////////////////////////////////


//
// Procedure forwards from credhand.cxx
//

NTSTATUS
SspCredentialInitialize(
    VOID
    );

VOID
SspCredentialTerminate(
    VOID
    );

NTSTATUS
SspCredentialReferenceCredential(
    IN ULONG_PTR CredentialHandle,
    IN BOOLEAN DereferenceCredential,
    OUT PSSP_CREDENTIAL * UserCredential
    );

VOID
SspCredentialDereferenceCredential(
    PSSP_CREDENTIAL Credential
    );

NTSTATUS
SspCredentialGetPassword(
    IN PSSP_CREDENTIAL Credential,
    OUT PUNICODE_STRING Password
    );

//
// Procedure forwards from context.cxx
//

NTSTATUS
SspContextInitialize(
    VOID
    );

VOID
SspContextTerminate(
    VOID
    );

//
// from ctxtcli.cxx
//

NTSTATUS
CredpParseUserName(
    IN OUT LPWSTR ParseName,
    OUT LPWSTR* pUserName,
    OUT LPWSTR* pDomainName
    );

NTSTATUS
CopyCredManCredentials(
    IN PLUID LogonId,
    CREDENTIAL_TARGET_INFORMATIONW* pTargetInfo,
    IN OUT PSSP_CONTEXT Context,
    IN BOOLEAN fShareLevel
    );

NTSTATUS
CredpExtractMarshalledTargetInfo(
    IN  PUNICODE_STRING TargetServerName,
    OUT CREDENTIAL_TARGET_INFORMATIONW **pTargetInfo
    );

NTSTATUS
CredpProcessUserNameCredential(
    IN  PUNICODE_STRING MarshalledUserName,
    OUT PUNICODE_STRING UserName,
    OUT PUNICODE_STRING DomainName,
    OUT PUNICODE_STRING Password
    );

//
// random number generator.
//

NTSTATUS
SspGenerateRandomBits(
    VOID        *pRandomData,
    ULONG       cRandomData
    );

//
// Procedure forwards from ntlm.cxx
//
VOID
NtLmCheckLmCompatibility(
    );

VOID
NtLmQueryMappedDomains(
    VOID
    );

VOID
NtLmFreeMappedDomains(
    VOID
    );


VOID
NTAPI
NtLmQueryDynamicGlobals(
    PVOID pvContext,
    BOOLEAN f
    );

ULONG
NtLmCheckProcessOption(
    IN  ULONG OptionRequest
    );

BOOLEAN
NtLmSetProcessOption(
    IN  ULONG OptionRequest,
    IN  BOOLEAN DisableOption
    );


//
// Procedure forwards from rng.cxx
//

VOID
NtLmCleanupRNG(VOID);

BOOL
NtLmInitializeRNG(VOID);


/*++

Brief description of the challenge/response algorithms for LM, NTLM, and NTLM3

  The basic outline is the same for all versions, just the OWF, RESP, and SESSKEY
  funcs are different:

1. Compute a "response key" (Kr) from the user's name (U), domain (UD) and password (P):

    Kr = OWF(U, UD, P)

2. Compute a response using the response key, server challenge (NS),
    client challenge (NC), timestamp (T), version (V), highest version
    client understands (HV), and the server's principal name (S)

    R = RESP(Kr, NS, NC, T, V, HV, S)

3. Compute a session key from Kr, U, UD

    Kx = SESSKEY(Kr, R, U, UD)


The are the OWF, RESP, and SESSKEY funcs for NTLM3

    OWF(U, UD, P) = MD5(MD4(P), U, UD)
    RESP(Kr, NS, NC, T, V, HV, S) = (V, HV, R, T, NC, HMAC(Kr, (NS, V, HV, T, NC, S)), S)
    SESSKEY(Ku, R, U, UD) = HMAC(Kr, R)

--*/



PMSV1_0_AV_PAIR
MsvpAvlInit(
    IN void * pAvList
    );

PMSV1_0_AV_PAIR
MsvpAvlGet(
    IN PMSV1_0_AV_PAIR pAvList,             // first pair of AV pair list
    IN MSV1_0_AVID AvId,                    // AV pair to find
    IN LONG cAvList                         // size of AV list
    );

ULONG
MsvpAvlLen(
    IN PMSV1_0_AV_PAIR pAvList,            // first pair of AV pair list
    IN LONG cAvList                        // max size of AV list
    );

PMSV1_0_AV_PAIR
MsvpAvlAdd(
    IN PMSV1_0_AV_PAIR pAvList,             // first pair of AV pair list
    IN MSV1_0_AVID AvId,                    // AV pair to add
    IN PUNICODE_STRING pString,             // value of pair
    IN LONG cAvList                         // max size of AV list
    );


ULONG
MsvpAvlSize(
    IN ULONG iPairs,            // number of AV pairs response will include
    IN ULONG iPairsLen          // total size of values for the pairs
    );

NTSTATUS
MsvpAvlToString(
    IN      PUNICODE_STRING AvlString,
    IN      MSV1_0_AVID AvId,
    IN OUT  LPWSTR *szAvlString
    );

NTSTATUS
MsvpAvlToFlag(
    IN      PUNICODE_STRING AvlString,
    IN      MSV1_0_AVID AvId,
    IN OUT  ULONG *ulAvlFlag
    );


VOID
MsvpCalculateNtlm2Challenge (
    IN UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH],
    IN UCHAR ChallengeFromClient[MSV1_0_CHALLENGE_LENGTH],
    OUT UCHAR Challenge[MSV1_0_CHALLENGE_LENGTH]
    );

VOID
MsvpCalculateNtlm2SessionKeys (
    IN PUSER_SESSION_KEY NtUserSessionKey,
    IN UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH],
    IN UCHAR ChallengeFromClient[MSV1_0_CHALLENGE_LENGTH],
    OUT PUSER_SESSION_KEY LocalUserSessionKey,
    OUT PLM_SESSION_KEY LocalLmSessionKey
    );


//
// calculate NTLM3 response from credentials and server name
// called with pNtlm3Response filled in with version, client challenge, timestamp
//

VOID
MsvpNtlm3Response (
    IN PNT_OWF_PASSWORD pNtOwfPassword,
    IN PUNICODE_STRING pUserName,
    IN PUNICODE_STRING pLogonDomainName,
    IN ULONG ServerNameLength,
    IN UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH],
    IN PMSV1_0_NTLM3_RESPONSE pNtlm3Response,
    OUT UCHAR Response[MSV1_0_NTLM3_RESPONSE_LENGTH],
    OUT PUSER_SESSION_KEY UserSessionKey,
    OUT PLM_SESSION_KEY LmSessionKey
    );

typedef struct {
        UCHAR Response[MSV1_0_NTLM3_RESPONSE_LENGTH];
        UCHAR ChallengeFromClient[MSV1_0_CHALLENGE_LENGTH];
} MSV1_0_LM3_RESPONSE, *PMSV1_0_LM3_RESPONSE;

//
// calculate LM3 response from credentials
//

VOID
MsvpLm3Response (
    IN PNT_OWF_PASSWORD pNtOwfPassword,
    IN PUNICODE_STRING pUserName,
    IN PUNICODE_STRING pLogonDomainName,
    IN UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH],
    IN PMSV1_0_LM3_RESPONSE pLm3Response,
    OUT UCHAR Response[MSV1_0_NTLM3_RESPONSE_LENGTH]
    );


NTSTATUS
MsvpLm20GetNtlm3ChallengeResponse (
    IN PNT_OWF_PASSWORD pNtOwfPassword,
    IN PUNICODE_STRING pUserName,
    IN PUNICODE_STRING pLogonDomainName,
    IN PUNICODE_STRING pServerName,
    IN UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH],
    OUT PMSV1_0_NTLM3_RESPONSE pNtlm3Response,
    OUT PMSV1_0_LM3_RESPONSE pLm3Response,
    OUT PUSER_SESSION_KEY UserSessionKey,
    OUT PLM_SESSION_KEY LmSessionKey
    );


#endif // ifndef _NTLMSSPI_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\ntlmssp.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    nllmssp.h

Abstract:

    Externally visible definition of the NT Lanman Security Support Provider
    (NtLmSsp) Service.

Author:

    Cliff Van Dyke (cliffv) 01-Jul-1993

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    Borrowed from the Ciaro's ntlmssp.h by PeterWi.

    ChandanS  03-Aug-1996  Stolen from net\svcdlls\ntlmssp\ntlmssp.h
--*/

#ifndef _NTLMSSP_
#define _NTLMSSP_

//
// Defines for SecPkgInfo structure returned by SpGetInfo
//

#define NTLMSP_NAME           L"NTLM"
#define NTLMSP_COMMENT        L"NTLM Security Package"
#define NTLMSP_CAPS           (SECPKG_FLAG_TOKEN_ONLY | \
                               SECPKG_FLAG_MULTI_REQUIRED | \
                               SECPKG_FLAG_CONNECTION | \
                               SECPKG_FLAG_INTEGRITY | \
                               SECPKG_FLAG_PRIVACY | \
                               SECPKG_FLAG_IMPERSONATION | \
                               SECPKG_FLAG_ACCEPT_WIN32_NAME | \
                               SECPKG_FLAG_NEGOTIABLE | \
                               SECPKG_FLAG_LOGON )

#define NTLMSP_MAX_TOKEN_SIZE  0x770
#define NTLM_CRED_NULLSESSION  SECPKG_CRED_RESERVED

// includes that should go elsewhere.

//
// Move to secscode.h
//

#define SEC_E_PACKAGE_UNKNOWN SEC_E_SECPKG_NOT_FOUND
#define SEC_E_INVALID_CONTEXT_REQ SEC_E_NOT_SUPPORTED
#define SEC_E_INVALID_CREDENTIAL_USE SEC_E_NOT_SUPPORTED
#define SEC_I_CALL_NTLMSSP_SERVICE 0xFFFFFFFF

//
// Could be in sspi.h
//

#define SSP_RET_REAUTHENTICATION 0x8000000

#endif // _NTLMSSP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\ntlm.cxx ===
//+--------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:       ntlm.cxx
//
// Contents:   main entrypoints for the ntlm security package
//               SpLsaModeInitialize
//               SpInitialize
//               SpShutdown
//               SpGetInfo
//
//             Helper functions:
//               NtLmSetPolicyInfo
//               NtLmPolicyChangeCallback
//               NtLmRegisterForPolicyChange
//               NtLmUnregisterForPolicyChange
//
// History:    ChandanS  26-Jul-1996   Stolen from kerberos\client2\kerberos.cxx
//             ChandanS  16-Apr-1998   No reboot on domain name change
//             JClark    28-Jun-2000   Added WMI Trace Logging Support
//
//---------------------------------------------------------------------


// Variables with the EXTERN storage class are declared here
#define NTLM_GLOBAL
#define DEBUG_ALLOCATE

#include <global.h>
#include <wow64t.h>
#include "trace.h"

extern "C"
{

NTSTATUS
LsaApInitializePackage(
    IN ULONG AuthenticationPackageId,
    IN PLSA_DISPATCH_TABLE LsaDispatchTable,
    IN PSTRING Database OPTIONAL,
    IN PSTRING Confidentiality OPTIONAL,
    OUT PSTRING *AuthenticationPackageName
    );
}

BOOLEAN NtLmCredentialInitialized;
BOOLEAN NtLmContextInitialized;
BOOLEAN NtLmRNGInitialized;

LIST_ENTRY      NtLmProcessOptionsList;
RTL_RESOURCE    NtLmProcessOptionsLock;



//+--------------------------------------------------------------------
//
//  Function:   SpLsaModeInitialize
//
//  Synopsis:   This function is called by the LSA when this DLL is loaded.
//              It returns security package function tables for all
//              security packages in the DLL.
//
//  Arguments:  LsaVersion - Version number of the LSA
//              PackageVersion - Returns version number of the package
//              Tables - Returns array of function tables for the package
//              TableCount - Returns number of entries in array of
//                      function tables.
//
//  Returns:    PackageVersion (as above)
//              Tables (as above)
//              TableCount (as above)
//
//  Notes:
//
//---------------------------------------------------------------------
NTSTATUS NTAPI
SpLsaModeInitialize(
    IN ULONG LsaVersion,
    OUT PULONG PackageVersion,
    OUT PSECPKG_FUNCTION_TABLE * Tables,
    OUT PULONG TableCount
    )
{
#if DBG
//     SspGlobalDbflag = SSP_CRITICAL| SSP_API| SSP_API_MORE |SSP_INIT| SSP_MISC | SSP_NO_LOCAL;
    SspGlobalDbflag = SSP_CRITICAL ;
    InitializeCriticalSection(&SspGlobalLogFileCritSect);
#endif
    SspPrint((SSP_API, "Entering SpLsaModeInitialize\n"));

    SECURITY_STATUS Status = SEC_E_OK;

    if (LsaVersion != SECPKG_INTERFACE_VERSION)
    {
        SspPrint((SSP_CRITICAL, "Invalid LSA version: %d\n", LsaVersion));
        Status = STATUS_INVALID_PARAMETER;
        goto CleanUp;
    }

    NtLmFunctionTable.InitializePackage        = NULL;
    NtLmFunctionTable.LogonUser                = NULL;
    NtLmFunctionTable.CallPackage              = LsaApCallPackage;
    NtLmFunctionTable.LogonTerminated          = LsaApLogonTerminated;
    NtLmFunctionTable.CallPackageUntrusted     = LsaApCallPackageUntrusted;
    NtLmFunctionTable.LogonUserEx              = NULL;
    NtLmFunctionTable.LogonUserEx2             = LsaApLogonUserEx2;
    NtLmFunctionTable.Initialize               = SpInitialize;
    NtLmFunctionTable.Shutdown                 = SpShutdown;
    NtLmFunctionTable.GetInfo                  = SpGetInfo;
    NtLmFunctionTable.AcceptCredentials        = SpAcceptCredentials;
    NtLmFunctionTable.AcquireCredentialsHandle = SpAcquireCredentialsHandle;
    NtLmFunctionTable.FreeCredentialsHandle    = SpFreeCredentialsHandle;
    NtLmFunctionTable.SaveCredentials          = SpSaveCredentials;
    NtLmFunctionTable.GetCredentials           = SpGetCredentials;
    NtLmFunctionTable.DeleteCredentials        = SpDeleteCredentials;
    NtLmFunctionTable.InitLsaModeContext       = SpInitLsaModeContext;
    NtLmFunctionTable.AcceptLsaModeContext     = SpAcceptLsaModeContext;
    NtLmFunctionTable.DeleteContext            = SpDeleteContext;
    NtLmFunctionTable.ApplyControlToken        = SpApplyControlToken;
    NtLmFunctionTable.GetUserInfo              = SpGetUserInfo;
    NtLmFunctionTable.QueryCredentialsAttributes = SpQueryCredentialsAttributes ;
    NtLmFunctionTable.GetExtendedInformation   = SpGetExtendedInformation ;
    NtLmFunctionTable.SetExtendedInformation   = SpSetExtendedInformation ;
    NtLmFunctionTable.CallPackagePassthrough   = LsaApCallPackagePassthrough;
#if 0
    NtLmFunctionTable.QueryContextAttributes   = SpQueryLsaModeContextAttributes;
    NtLmFunctionTable.SetContextAttributes     = SpSetContextAttributes;

    *PackageVersion = SECPKG_INTERFACE_VERSION_2;
#else
    *PackageVersion = SECPKG_INTERFACE_VERSION;
#endif

    *Tables = &NtLmFunctionTable;
    *TableCount = 1;

    //
    // Get the Event Trace logging on board
    //
    NtlmInitializeTrace();

    SafeAllocaInitialize(SAFEALLOCA_USE_DEFAULT,
                         SAFEALLOCA_USE_DEFAULT,
                         NtLmAllocate,
                         NtLmFree);

CleanUp:

    SspPrint((SSP_API, "Leaving SpLsaModeInitialize\n"));

    return(SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));
}


//+-------------------------------------------------------------------------
//
//  Function:   NtLmSetPolicyInfo
//
//  Synopsis:   Function to be called when policy changes
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//        if fInit is TRUE, this is called by the init routine in ntlm
//
//
//+-------------------------------------------------------------------------
NTSTATUS
NtLmSetPolicyInfo(
    IN PUNICODE_STRING DnsComputerName,
    IN PUNICODE_STRING ComputerName,
    IN PUNICODE_STRING DnsDomainName,
    IN PUNICODE_STRING DomainName,
    IN PSID DomainSid,
    IN POLICY_NOTIFICATION_INFORMATION_CLASS ChangedInfoClass,
    IN BOOLEAN fInit
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    // Buffers to delete on cleanup

    STRING ComputerNameAnsiString;
    STRING DomainNameAnsiString;

    UNICODE_STRING DnsTreeName = {0};

    ComputerNameAnsiString.Buffer = NULL;
    DomainNameAnsiString.Buffer = NULL;


    //
    // grab the treename.  don't do this during Init, because the SAM
    // isn't initialized yet.
    //

    if(!fInit)
    {
        Status = SsprQueryTreeName( &DnsTreeName );
    }


    RtlAcquireResourceExclusive(&NtLmGlobalCritSect, TRUE);



    if(!fInit && NT_SUCCESS( Status ))
    {
        if( NtLmGlobalUnicodeDnsTreeName.Buffer != NULL )
        {
            NtLmFree( NtLmGlobalUnicodeDnsTreeName.Buffer );
        }

        RtlCopyMemory(&NtLmGlobalUnicodeDnsTreeName, &DnsTreeName, sizeof(DnsTreeName));
    }



    //
    // Do this only if this is package init
    //

    if (fInit)
    {
        if (ComputerName && ComputerName->Buffer != NULL)
        {
            ULONG cLength = ComputerName->Length / sizeof(WCHAR);

            if ((ComputerName->Length + sizeof(WCHAR)) > sizeof(NtLmGlobalUnicodeComputerName))
            {
                // Bad ComputerName
                Status = STATUS_INVALID_COMPUTER_NAME;
                SspPrint((SSP_CRITICAL, "NtLmSetPolicyInfo, Bad computer name length is %d\n", cLength));
                goto CleanUp;
            }

            wcsncpy(NtLmGlobalUnicodeComputerName,
               ComputerName->Buffer,
               cLength);

            NtLmGlobalUnicodeComputerName[cLength] = UNICODE_NULL;

            // make NtlmGlobalUnicodeComputerNameString a string form

            RtlInitUnicodeString(  &NtLmGlobalUnicodeComputerNameString,
                                   NtLmGlobalUnicodeComputerName );

            // Save old buffers for deleting
            ComputerNameAnsiString = NtLmGlobalOemComputerNameString;

            Status = RtlUpcaseUnicodeStringToOemString(
                        &NtLmGlobalOemComputerNameString,
                        &NtLmGlobalUnicodeComputerNameString,
                        TRUE );

            if ( !NT_SUCCESS(Status) ) {
                Status = STATUS_SUCCESS;
                //SspPrint((SSP_CRITICAL, "NtLmSetPolicyInfo, Error from RtlUpcaseUnicodeStringToOemString is %d\n", Status));
                ComputerNameAnsiString.Buffer = NULL;
                // goto CleanUp;
            }

        }
    }

    //
    // Initialize various forms of the primary domain name of the local system
    // Do this only if this is package init or it's DnsDomain info
    //

    if (fInit || (ChangedInfoClass == PolicyNotifyDnsDomainInformation))
    {
        if (DnsComputerName && DnsComputerName->Buffer != NULL ) {
            ULONG cLength = DnsComputerName->Length / sizeof(WCHAR);

            if((DnsComputerName->Length + sizeof(WCHAR)) > sizeof(NtLmGlobalUnicodeDnsComputerName))
            {
                // Bad ComputerName
                Status = STATUS_INVALID_COMPUTER_NAME;
                SspPrint((SSP_CRITICAL, "NtLmSetPolicyInfo, Bad computer name length is %d\n", cLength));
                goto CleanUp;
            }

            wcsncpy(NtLmGlobalUnicodeDnsComputerName,
               DnsComputerName->Buffer,
               cLength);

            NtLmGlobalUnicodeDnsComputerName[cLength] = UNICODE_NULL;

            // make NtlmGlobalUnicodeDnsComputerNameString a string form

            RtlInitUnicodeString(  &NtLmGlobalUnicodeDnsComputerNameString,
                                   NtLmGlobalUnicodeDnsComputerName );
        }

        if (DnsDomainName && DnsDomainName->Buffer != NULL ) {
            ULONG cLength = DnsDomainName->Length / sizeof(WCHAR);

            if((DnsDomainName->Length + sizeof(WCHAR)) > sizeof(NtLmGlobalUnicodeDnsDomainName))
            {
                // Bad ComputerName
                Status = STATUS_INVALID_COMPUTER_NAME;
                SspPrint((SSP_CRITICAL, "NtLmSetPolicyInfo, Bad domain name length is %d\n", cLength));
                goto CleanUp;
            }

            wcsncpy(NtLmGlobalUnicodeDnsDomainName,
               DnsDomainName->Buffer,
               cLength);

            NtLmGlobalUnicodeDnsDomainName[cLength] = UNICODE_NULL;

            // make NtlmGlobalUnicodeDnsDomainNameString a string form

            RtlInitUnicodeString(  &NtLmGlobalUnicodeDnsDomainNameString,
                                   NtLmGlobalUnicodeDnsDomainName );
        }

        if (DomainName && DomainName->Buffer != NULL)
        {
            ULONG cLength = DomainName->Length / sizeof(WCHAR);

            if ((DomainName->Length + sizeof(WCHAR)) > sizeof(NtLmGlobalUnicodePrimaryDomainName))
            {
                Status = STATUS_NAME_TOO_LONG;
                SspPrint((SSP_CRITICAL, "NtLmSetPolicyInfo, Bad domain name length is %d\n", cLength));
                goto CleanUp;
            }
            wcsncpy(NtLmGlobalUnicodePrimaryDomainName,
               DomainName->Buffer,
               cLength);
            NtLmGlobalUnicodePrimaryDomainName[cLength] = UNICODE_NULL;

            // make NtlmGlobalUnicodePrimaryDomainNameString a string form

            RtlInitUnicodeString(  &NtLmGlobalUnicodePrimaryDomainNameString,
                                   NtLmGlobalUnicodePrimaryDomainName );

            // Save old buffers for deleting
            DomainNameAnsiString = NtLmGlobalOemPrimaryDomainNameString;

            Status = RtlUpcaseUnicodeStringToOemString(
                        &NtLmGlobalOemPrimaryDomainNameString,
                        &NtLmGlobalUnicodePrimaryDomainNameString,
                        TRUE );

            if ( !NT_SUCCESS(Status) ) {
                // SspPrint((SSP_CRITICAL, "NtLmSetPolicyInfo, Error from RtlUpcaseUnicodeStringToOemString is %d\n", Status));
                DomainNameAnsiString.Buffer = NULL;
                // goto CleanUp;
                Status = STATUS_SUCCESS;
            }
        }
    }

    //
    // If this is a standalone windows NT workstation,
    // use the computer name as the Target name.
    //

    if ( DomainSid != NULL)
    {
        NtLmGlobalUnicodeTargetName = NtLmGlobalUnicodePrimaryDomainNameString;
        NtLmGlobalOemTargetName = NtLmGlobalOemPrimaryDomainNameString;
        NtLmGlobalTargetFlags = NTLMSSP_TARGET_TYPE_DOMAIN;
        NtLmGlobalDomainJoined = TRUE;
    }
    else
    {
        NtLmGlobalUnicodeTargetName = NtLmGlobalUnicodeComputerNameString;
        NtLmGlobalOemTargetName = NtLmGlobalOemComputerNameString;
        NtLmGlobalTargetFlags = NTLMSSP_TARGET_TYPE_SERVER;
        NtLmGlobalDomainJoined = FALSE;
    }

    //
    // update the GlobalNtlm3 targetinfo.
    //

    Status = SsprUpdateTargetInfo();

CleanUp:

    RtlReleaseResource(&NtLmGlobalCritSect);

    if (ComputerNameAnsiString.Buffer)
    {
        RtlFreeOemString(&ComputerNameAnsiString);
    }

    if (DomainNameAnsiString.Buffer)
    {
        RtlFreeOemString(&DomainNameAnsiString);
    }


    return Status;
}

NET_API_STATUS
NtLmFlushLogonCache (
   VOID
   )
/*++

Routine Description:

    This function flushes the logon cache.  This is done on unjoin.

    If the cache were not flushed, a user could logon to cached credentials after the unjoin.
    That is especially bad since Winlogon now tries a cached logon to improve boot times.

Return Value:

    NERR_Success -- Success

--*/
{
    NET_API_STATUS NetStatus;
    HKEY hKey = NULL;

#define NETSETUPP_LOGON_CACHE_PATH   L"SECURITY\\Cache"
#define NETSETUPP_LOGON_CACHE_VALUE  L"NL$Control"


    //
    // Open the key containing the cache
    //

    NetStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                              NETSETUPP_LOGON_CACHE_PATH,
                              0,
                              KEY_SET_VALUE,
                              &hKey );

    if ( NetStatus == ERROR_SUCCESS ) {

        //
        // Delete the value describing the size of the cache
        //  This ensures the values cannot be used
        //

        RegDeleteValue( hKey, NETSETUPP_LOGON_CACHE_VALUE );

        RegCloseKey( hKey );
    }

    return NetStatus;
}


//+-------------------------------------------------------------------------
//
//  Function:   NtLmPolicyChangeCallback
//
//  Synopsis:   Function to be called when domain policy changes
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID NTAPI
NtLmPolicyChangeCallback(
    IN POLICY_NOTIFICATION_INFORMATION_CLASS ChangedInfoClass
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAPR_POLICY_INFORMATION Policy = NULL;


    switch (ChangedInfoClass)
    {
        case PolicyNotifyDnsDomainInformation:
        {

            WCHAR UnicodeDnsComputerName[DNS_MAX_NAME_LENGTH + 1];
            UNICODE_STRING UnicodeDnsComputerNameString;
            ULONG DnsComputerNameLength = sizeof(UnicodeDnsComputerName) / sizeof(WCHAR);

            //
            // Get the new domain information
            //


            Status = I_LsaIQueryInformationPolicyTrusted(
                        PolicyDnsDomainInformation,
                        &Policy
                        );

            if (!NT_SUCCESS(Status))
            {
                SspPrint((SSP_CRITICAL, "NtLmPolicyChangeCallback, Error from I_LsaIQueryInformationPolicyTrusted is %d\n", Status));
                goto Cleanup;
            }

            //
            // get the new DNS computer name
            //

            if ( !GetComputerNameExW( ComputerNameDnsFullyQualified,
                                      UnicodeDnsComputerName,
                                      &DnsComputerNameLength ) )
            {
                UnicodeDnsComputerName[ 0 ] = L'\0';
            }

            RtlInitUnicodeString(  &UnicodeDnsComputerNameString,
                               UnicodeDnsComputerName);


            Status = NtLmSetPolicyInfo(
                        &UnicodeDnsComputerNameString,
                        NULL,
                        (PUNICODE_STRING) &Policy->PolicyDnsDomainInfo.DnsDomainName,
                        (PUNICODE_STRING) &Policy->PolicyDnsDomainInfo.Name,
                        (PSID) Policy->PolicyDnsDomainInfo.Sid,
                        ChangedInfoClass,
                        FALSE);

            if (!NT_SUCCESS(Status))
            {
                SspPrint((SSP_CRITICAL, "NtLmPolicyChangeCallback, Error from NtLmSetDomainName is %d\n", Status));
                goto Cleanup;
            }

            {
                BOOLEAN FlushLogonCache = FALSE;

                if( NtLmSecPkg.DomainSid == NULL &&
                    Policy->PolicyDnsDomainInfo.Sid != NULL
                    )
                {
                    FlushLogonCache = TRUE;
                }

                if( NtLmSecPkg.DomainSid != NULL &&
                    Policy->PolicyDnsDomainInfo.Sid == NULL
                    )
                {
                    FlushLogonCache = TRUE;
                }

                if( NtLmSecPkg.DomainSid != NULL &&
                    Policy->PolicyDnsDomainInfo.Sid != NULL
                    )
                {
                    if(!RtlEqualSid( NtLmSecPkg.DomainSid, Policy->PolicyDnsDomainInfo.Sid ))
                    {
                        FlushLogonCache = TRUE;
                    }
                }

                if( FlushLogonCache )
                {
                    //
                    // flush the logon cache...
                    //

                    NtLmFlushLogonCache();
                }
            }

        }
        break;
        default:
        break;
    }


Cleanup:

    if (Policy != NULL)
    {
        switch (ChangedInfoClass)
        {
            case PolicyNotifyDnsDomainInformation:
            {
                I_LsaIFree_LSAPR_POLICY_INFORMATION(
                    PolicyDnsDomainInformation,
                    Policy
                    );
            }
            break;
            default:
            break;
        }
    }
    return;

}


//+-------------------------------------------------------------------------
//
//  Function:   NtLmRegisterForPolicyChange
//
//  Synopsis:   Register with the LSA to be notified of policy changes
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
NtLmRegisterForPolicyChange(
    IN POLICY_NOTIFICATION_INFORMATION_CLASS ChangedInfoClass
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    Status = I_LsaIRegisterPolicyChangeNotificationCallback(
                NtLmPolicyChangeCallback,
                ChangedInfoClass
                );
    if (!NT_SUCCESS(Status))
    {
        SspPrint((SSP_CRITICAL, "NtLmRegisterForPolicyChange, Error from I_LsaIRegisterPolicyChangeNotificationCallback is %d\n", Status));
    }
    SspPrint((SSP_MISC, "I_LsaIRegisterPolicyChangeNotificationCallback called with %d\n", ChangedInfoClass));
    return(Status);

}

//+-------------------------------------------------------------------------
//
//  Function:   NtLmUnregisterForPolicyChange
//
//  Synopsis:   Unregister for policy change notification
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
NtLmUnregisterForPolicyChange(
    IN POLICY_NOTIFICATION_INFORMATION_CLASS ChangedInfoClass
    )
{
    (VOID) I_LsaIUnregisterPolicyChangeNotificationCallback(
                NtLmPolicyChangeCallback,
                ChangedInfoClass
                );

}


//+--------------------------------------------------------------------
//
//  Function:   SpInitialize
//
//  Synopsis:   Initializes the Security package
//
//  Arguments:  PackageId - Contains ID for this package assigned by LSA
//              Parameters - Contains machine-specific information
//              FunctionTable - Contains table of LSA helper routines
//
//  Returns: None
//
//  Notes: Everything that was done in LsaApInitializePackage
//         should be done here. Lsa assures us that only
//         one thread is executing this at a time. Don't
//         have to worry about concurrency problems.
//         Most of the stuff was taken from SspCommonInitialize()
//         from svcdlls\ntlmssp\common\initcomn.c
//
//---------------------------------------------------------------------
NTSTATUS NTAPI
SpInitialize(
    IN ULONG_PTR PackageId,
    IN PSECPKG_PARAMETERS Parameters,
    IN PLSA_SECPKG_FUNCTION_TABLE FunctionTable
    )
{
    SspPrint((SSP_API, "Entering SpInitialize\n"));

    SECURITY_STATUS Status = SEC_E_OK;
    WCHAR UnicodeComputerName[CNLEN + 1];
    UNICODE_STRING UnicodeComputerNameString;
    ULONG ComputerNameLength =
        (sizeof(UnicodeComputerName)/sizeof(WCHAR));

    WCHAR UnicodeDnsComputerName[DNS_MAX_NAME_LENGTH + 1];
    UNICODE_STRING UnicodeDnsComputerNameString;
    ULONG DnsComputerNameLength = sizeof(UnicodeDnsComputerName) / sizeof(WCHAR);

    //
    // Init the global crit section
    //

    RtlInitializeResource(&NtLmGlobalCritSect);

    RtlInitializeResource(&NtLmProcessOptionsLock);
    InitializeListHead( &NtLmProcessOptionsList );

    //
    // All the following are global
    //

    NtLmState                  = NtLmLsaMode;
    NtLmPackageId              = PackageId;

    // We really need this to be a day less than maxtime so when callers
    // of sspi convert to utc, they won't get time in the past.

    NtLmGlobalForever.HighPart = 0x7FFFFF36;
    NtLmGlobalForever.LowPart  = 0xD5969FFF;

    //
    // Following are local
    //

    NtLmCredentialInitialized = FALSE;
    NtLmContextInitialized    = FALSE;
    NtLmRNGInitialized        = FALSE;

    //
    // Save away the Lsa functions
    //

    LsaFunctions    = FunctionTable;

    //
    // Save the Parameters info
    //

    NtLmSecPkg.MachineState = Parameters->MachineState;
    NtLmSecPkg.SetupMode    = Parameters->SetupMode;

    //
    // allocate a locally unique ID rereferencing the machine logon.
    //

    Status = NtAllocateLocallyUniqueId( &NtLmGlobalLuidMachineLogon );

    if (!NT_SUCCESS (Status))
    {
        SspPrint((SSP_CRITICAL, "SpInitialize, Error from NtAllocateLocallyUniqueId is %d\n", Status));
        goto CleanUp;
    }

    //
    // create a logon session for the machine logon.
    //
    Status = LsaFunctions->CreateLogonSession( &NtLmGlobalLuidMachineLogon );
    if( !NT_SUCCESS(Status) ) {
        SspPrint((SSP_CRITICAL, "SpInitialize, Error from CreateLogonSession is %d\n", Status));
        goto CleanUp;
    }

    Status = NtLmDuplicateUnicodeString(
                                 &NtLmSecPkg.DomainName,
                                 &Parameters->DomainName);

    if (!NT_SUCCESS (Status))
    {
        SspPrint((SSP_CRITICAL, "SpInitialize, Error from NtLmDuplicateUnicodeString is %d\n", Status));
        goto CleanUp;
    }

    Status = NtLmDuplicateUnicodeString(
                                 &NtLmSecPkg.DnsDomainName,
                                 &Parameters->DnsDomainName);

    if (!NT_SUCCESS (Status))
    {
        SspPrint((SSP_CRITICAL, "SpInitialize, Error from NtLmDuplicateUnicodeString is %d\n", Status));
        goto CleanUp;
    }

    if (Parameters->DomainSid != NULL) {
        Status = NtLmDuplicateSid( &NtLmSecPkg.DomainSid,
                                   Parameters->DomainSid );


        if (!NT_SUCCESS (Status))
        {
            SspPrint((SSP_CRITICAL, "SpInitialize, Error from NtLmDuplicateSid is %d\n", Status));
            goto CleanUp;
        }
    }

    //
    // Determine if this machine is running NT Workstation or NT Server
    //

    if (!RtlGetNtProductType (&NtLmGlobalNtProductType))
    {
        SspPrint((SSP_API_MORE, "RtlGetNtProductType defaults to NtProductWinNt\n"));
    }

    //
    // Determine if we are running Personal SKU
    //

    {
        OSVERSIONINFOEXW osvi;

        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXW);
        if(GetVersionExW((OSVERSIONINFOW*)&osvi))
        {
            NtLmGlobalPersonalSKU = ( osvi.wProductType == VER_NT_WORKSTATION && (osvi.wSuiteMask & VER_SUITE_PERSONAL));
        } else {
            SspPrint((SSP_API_MORE, "GetVersionEx defaults to non-personal\n"));
        }
    }


    Status = I_LsaIOpenPolicyTrusted(&NtLmGlobalPolicyHandle);

    if ( !NT_SUCCESS(Status) ) {
        SspPrint((SSP_CRITICAL, "SpInitialize, Error from I_LsaIOpenPolicyTrusted is %d\n", Status));
        goto CleanUp;
    }

    if ( !GetComputerNameW( UnicodeComputerName,
                            &ComputerNameLength ) ) {
        Status = STATUS_INVALID_COMPUTER_NAME;
        SspPrint((SSP_CRITICAL, "SpInitialize, Error from GetComputerNameW is %d\n", Status));
        goto CleanUp;
    }

    if ( !GetComputerNameExW( ComputerNameDnsFullyQualified,
                              UnicodeDnsComputerName,
                              &DnsComputerNameLength ) )
    {

        //
        // per CliffV, failure is legal.
        //

        UnicodeDnsComputerName[ 0 ] = L'\0';
    }


    {
        SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;

        (VOID)AllocateAndInitializeSid(
                                &siaNtAuthority,
                                1,
                                SECURITY_ANONYMOUS_LOGON_RID,
                                0, 0, 0, 0, 0, 0, 0,
                                &NtLmGlobalAnonymousSid
                                );
    }



    //
    // pickup a copy of the Local System access token.
    //

    {
        HANDLE hProcessToken;
        NTSTATUS StatusToken;

        StatusToken = NtOpenProcessToken(
                        NtCurrentProcess(),
                        TOKEN_QUERY | TOKEN_DUPLICATE,
                        &hProcessToken
                        );

        if( NT_SUCCESS( StatusToken ) ) {

            TOKEN_STATISTICS LocalTokenStatistics;
            DWORD TokenStatisticsSize = sizeof(LocalTokenStatistics);
            LUID LogonIdSystem = SYSTEM_LUID;

            Status = NtQueryInformationToken(
                            hProcessToken,
                            TokenStatistics,
                            &LocalTokenStatistics,
                            TokenStatisticsSize,
                            &TokenStatisticsSize
                            );

            if( NT_SUCCESS( Status ) ) {

                //
                // see if it's SYSTEM.
                //

                if(RtlEqualLuid(
                                &LogonIdSystem,
                                &(LocalTokenStatistics.AuthenticationId)
                                )) {


                    Status = SspDuplicateToken(
                                    hProcessToken,
                                    SecurityImpersonation,
                                    &NtLmGlobalAccessTokenSystem
                                    );
                }
            }

            NtClose( hProcessToken );
        }
    }

    if (!NT_SUCCESS (Status))
    {
        SspPrint((SSP_CRITICAL, "SpInitialize, could not acquire SYSTEM token %d\n", Status));
        goto CleanUp;
    }


    //
    // Init the Credential stuff
    //

    Status = SspCredentialInitialize();
    if (!NT_SUCCESS (Status))
    {
        SspPrint((SSP_CRITICAL, "SpInitialize, Error from SspCredentialInitializeis %d\n", Status));
        goto CleanUp;
    }
    NtLmCredentialInitialized = TRUE;

    //
    // Init the Context stuff
    //
    Status = SspContextInitialize();
    if (!NT_SUCCESS (Status))
    {
        SspPrint((SSP_CRITICAL, "SpInitialize, Error from SspContextInitializeis %d\n", Status));
        goto CleanUp;
    }
    NtLmContextInitialized = TRUE;

    //
    // Get the locale and check if it is FRANCE, which doesn't allow
    // encryption
    //

    NtLmGlobalEncryptionEnabled = IsEncryptionPermitted();

    //
    // Init the random number generator stuff
    //

    if( !NtLmInitializeRNG() ) {
        SspPrint((SSP_CRITICAL, "SpInitialize, Error from NtLmInitializeRNG\n"));
        Status = STATUS_UNSUCCESSFUL;
        goto CleanUp;
    }
    NtLmRNGInitialized = TRUE;

    NtLmCheckLmCompatibility();

    if( NtLmSecPkg.DomainSid != NULL )
    {
        NtLmGlobalDomainJoined = TRUE;
    }

    NtLmQueryMappedDomains();


    //
    // Set all the globals relating to computer name, domain name, sid etc.
    // This routine is also used by the callback for notifications from the lsa
    //

    RtlInitUnicodeString(  &UnicodeComputerNameString,
                           UnicodeComputerName);

    RtlInitUnicodeString(  &UnicodeDnsComputerNameString,
                           UnicodeDnsComputerName);

    Status = NtLmSetPolicyInfo( &UnicodeDnsComputerNameString,
                                &UnicodeComputerNameString,
                                &NtLmSecPkg.DnsDomainName,
                                &NtLmSecPkg.DomainName,
                                NtLmSecPkg.DomainSid,
                                PolicyNotifyAuditEventsInformation, // Ignored
                                TRUE ); // yes, package init

    if (!NT_SUCCESS (Status))
    {
        SspPrint((SSP_CRITICAL, "SpInitialize, Error from NtLmSetDomainInfo %d\n", Status));
        goto CleanUp;
    }


    // Do the Init stuff for the MSV authentication package
    // Passing FunctionTable as a (PLSA_DISPATCH_TABLE).
    // Well, the first 11 entries are the same. Cheating a
    // bit.

    Status = LsaApInitializePackage(
                      (ULONG) PackageId,
                      (PLSA_DISPATCH_TABLE)FunctionTable,
                      NULL,
                      NULL,
                      NULL);

    if (!NT_SUCCESS (Status))
    {
        SspPrint((SSP_CRITICAL, "SpInitialize, Error from LsaApInitializePackage is %d\n", Status));
        goto CleanUp;
    }

    Status = NtLmRegisterForPolicyChange(PolicyNotifyDnsDomainInformation);
    if (!NT_SUCCESS (Status))
    {
        SspPrint((SSP_CRITICAL, "SpInitialize, Error from NtLmRegisterForPolicyChange is %d\n", Status));
        goto CleanUp;
    }


CleanUp:

    if (!NT_SUCCESS (Status))
    {
        SpShutdown();
    }

    SspPrint((SSP_API, "Leaving SpInitialize\n"));

    return(SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));
}

//+--------------------------------------------------------------------
//
//  Function:   SpShutdown
//
//  Synopsis:   Exported function to shutdown the Security package.
//
//  Effects:    Forces the freeing of all credentials, contexts
//              and frees all global data
//
//  Arguments:  none
//
//  Returns:
//
//  Notes:      SEC_E_OK in all cases
//         Most of the stuff was taken from SspCommonShutdown()
//         from svcdlls\ntlmssp\common\initcomn.c
//
//
//---------------------------------------------------------------------
NTSTATUS NTAPI
SpShutdown(
    VOID
    )
{
    SspPrint((SSP_API, "Entering SpShutdown\n"));

    //
    // comment out LSA mode cleanup code, per NTBUG 400026,
    // which can result in access violations during shutdown when
    // calls into package are still occuring during shutdown.
    //

#if 0

    if (NtLmContextInitialized)
    {
        SspContextTerminate();
        NtLmContextInitialized = FALSE;
    }

    if (NtLmCredentialInitialized)
    {
        SspCredentialTerminate();
        NtLmCredentialInitialized = FALSE;
    }

    if (NtLmGlobalOemComputerNameString.Buffer != NULL)
    {
        RtlFreeOemString(&NtLmGlobalOemComputerNameString);
        NtLmGlobalOemComputerNameString.Buffer = NULL;
    }

    if (NtLmGlobalOemPrimaryDomainNameString.Buffer != NULL)
    {
        RtlFreeOemString(&NtLmGlobalOemPrimaryDomainNameString);
        NtLmGlobalOemPrimaryDomainNameString.Buffer = NULL;
    }

    if (NtLmGlobalNtLm3TargetInfo.Buffer != NULL)
    {
        NtLmFree (NtLmGlobalNtLm3TargetInfo.Buffer);
        NtLmGlobalNtLm3TargetInfo.Buffer = NULL;
    }

    if ( NtLmSecPkg.DomainName.Buffer != NULL )
    {
        NtLmFree (NtLmSecPkg.DomainName.Buffer);
    }

    if ( NtLmSecPkg.DnsDomainName.Buffer != NULL )
    {
        NtLmFree (NtLmSecPkg.DnsDomainName.Buffer);
    }

    if ( NtLmSecPkg.DomainSid != NULL )
    {
        NtLmFree (NtLmSecPkg.DomainSid);
    }

    if (NtLmGlobalLocalSystemSid != NULL)
    {
        FreeSid( NtLmGlobalLocalSystemSid);
        NtLmGlobalLocalSystemSid = NULL;
    }

    if (NtLmGlobalAliasAdminsSid != NULL)
    {
        FreeSid( NtLmGlobalAliasAdminsSid);
        NtLmGlobalAliasAdminsSid = NULL;
    }

    if (NtLmGlobalProcessUserSid != NULL)
    {
        NtLmFree( NtLmGlobalProcessUserSid );
        NtLmGlobalProcessUserSid = NULL;
    }

    if( NtLmGlobalAnonymousSid )
    {
        FreeSid( NtLmGlobalAnonymousSid );
        NtLmGlobalAnonymousSid = NULL;
    }


    if (NtLmRNGInitialized)
    {
        NtLmCleanupRNG();
        NtLmRNGInitialized = FALSE;
    }

    NtLmFreeMappedDomains();

    NtLmUnregisterForPolicyChange(PolicyNotifyDnsDomainInformation);

    if (NtLmGlobalAccessTokenSystem != NULL) {
        NtClose( NtLmGlobalAccessTokenSystem );
        NtLmGlobalAccessTokenSystem = NULL;
    }

    RtlDeleteResource(&NtLmGlobalCritSect);

    if (NtLmGlobalPolicyHandle != NULL) {
        (VOID) I_LsarClose( &NtLmGlobalPolicyHandle );
    }

    SspPrint((SSP_API, "Leaving SpShutdown\n"));
#if DBG
    DeleteCriticalSection(&SspGlobalLogFileCritSect);
#endif

#endif  // NTBUG 400026

    return(SEC_E_OK);
}

//+--------------------------------------------------------------------
//
//  Function:   SpGetInfo
//
//  Synopsis:   Returns information about the package
//
//  Effects:    returns pointers to global data
//
//  Arguments:  PackageInfo - Receives security package information
//
//  Returns:    SEC_E_OK in all cases
//
//  Notes:      Pointers to constants ok. Lsa will copy the data
//              before sending it to someone else
//
//---------------------------------------------------------------------
NTSTATUS NTAPI
SpGetInfo(
    OUT PSecPkgInfo PackageInfo
    )
{
    SspPrint((SSP_API, "Entering SpGetInfo\n"));

    PackageInfo->fCapabilities    = NTLMSP_CAPS;
    PackageInfo->wVersion         = SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION;
    PackageInfo->wRPCID           = RPC_C_AUTHN_WINNT;
    PackageInfo->cbMaxToken       = NTLMSP_MAX_TOKEN_SIZE;
    PackageInfo->Name             = NTLMSP_NAME;
    PackageInfo->Comment          = NTLMSP_COMMENT;

    SspPrint((SSP_API, "Leaving SpGetInfo\n"));

    return(SEC_E_OK);
}

NTSTATUS
NTAPI
SpGetExtendedInformation(
    IN  SECPKG_EXTENDED_INFORMATION_CLASS Class,
    OUT PSECPKG_EXTENDED_INFORMATION * ppInformation
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PSECPKG_EXTENDED_INFORMATION Information = NULL;
    ULONG Size ;

    switch ( Class )
    {
        case SecpkgContextThunks:

            Information = (PSECPKG_EXTENDED_INFORMATION)
                                NtLmAllocate(sizeof(SECPKG_EXTENDED_INFORMATION) + sizeof(DWORD));
            if (Information == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }
            Information->Class = SecpkgContextThunks;
            Information->Info.ContextThunks.InfoLevelCount = 1;
            Information->Info.ContextThunks.Levels[0] = SECPKG_ATTR_CREDENTIAL_NAME;
            *ppInformation = Information;
            Information = NULL;
            break;

        case SecpkgWowClientDll:

            //
            // This indicates that we're smart enough to handle wow client processes
            //

            Information = (PSECPKG_EXTENDED_INFORMATION)
                                NtLmAllocate( sizeof( SECPKG_EXTENDED_INFORMATION ) +
                                              (MAX_PATH * sizeof(WCHAR) ) );

            if ( Information == NULL )
            {
                Status = STATUS_INSUFFICIENT_RESOURCES ;
                goto Cleanup ;
            }

            Information->Class = SecpkgWowClientDll ;
            Information->Info.WowClientDll.WowClientDllPath.Buffer = (PWSTR) (Information + 1);
            Size = ExpandEnvironmentStrings(
                        L"%SystemRoot%\\" WOW64_SYSTEM_DIRECTORY_U L"\\msv1_0.DLL",
                        Information->Info.WowClientDll.WowClientDllPath.Buffer,
                        MAX_PATH );
            Information->Info.WowClientDll.WowClientDllPath.Length = (USHORT) (Size * sizeof(WCHAR));
            Information->Info.WowClientDll.WowClientDllPath.MaximumLength = (USHORT) ((Size + 1) * sizeof(WCHAR) );
            *ppInformation = Information ;
            Information = NULL ;

            break;

        default:
            Status = SEC_E_UNSUPPORTED_FUNCTION ;
    }

Cleanup:

    if ( Information != NULL )
    {
        NtLmFree( Information );
    }

    return Status ;
}

NTSTATUS
NTAPI
SpSetExtendedInformation(
    IN SECPKG_EXTENDED_INFORMATION_CLASS Class,
    IN PSECPKG_EXTENDED_INFORMATION Info
    )
{
    NTSTATUS Status ;


    switch ( Class )
    {
        case SecpkgMutualAuthLevel:
            NtLmGlobalMutualAuthLevel = Info->Info.MutualAuthLevel.MutualAuthLevel ;
            Status = SEC_E_OK ;
            break;

        default:
            Status = SEC_E_UNSUPPORTED_FUNCTION ;
            break;
    }

    return Status ;
}



VOID
NtLmCheckLmCompatibility(
    )
/*++

Routine Description:

    This routine checks to see if we should support the LM challenge
    response protocol by looking in the registry under
    system\currentcontrolset\Control\Lsa\LmCompatibilityLevel. The level
    indicates whether to send the LM reponse by default and whether to
    ever send the LM response

Arguments:

    none.

Return Value:

    None

--*/
{
    NTSTATUS NtStatus;
    UNICODE_STRING KeyName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE KeyHandle;

    //
    // initialize defaults
    // Assume that LM is supported.
    //

    NtLmGlobalLmProtocolSupported = 0;
    NtLmGlobalRequireNtlm2 = FALSE;
    NtLmGlobalDatagramUse128BitEncryption = FALSE;
    NtLmGlobalDatagramUse56BitEncryption = FALSE;


    //
    // Open the Lsa key in the registry
    //

    RtlInitUnicodeString(
        &KeyName,
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Lsa"
        );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyName,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL
        );

    NtStatus = NtOpenKey(
                &KeyHandle,
                KEY_READ,
                &ObjectAttributes
                );

    if (!NT_SUCCESS(NtStatus)) {
        return;
    }

    //
    // save away registry key so we can use it for notification events.
    //

    NtLmGlobalLsaKey = (HKEY)KeyHandle;



    // now open the MSV1_0 subkey...

    RtlInitUnicodeString(
        &KeyName,
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Lsa\\Msv1_0"
        );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyName,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL
        );

    NtStatus = NtOpenKey(
                &KeyHandle,
                KEY_READ,
                &ObjectAttributes
                );

    if (!NT_SUCCESS(NtStatus)) {
        return;
    }

    //
    // save away registry key so we can use it for notification events.
    //

    NtLmGlobalLsaMsv1_0Key = (HKEY)KeyHandle;



}

ULONG
NtLmValidMinimumSecurityFlagsMask(
    IN  ULONG   MinimumSecurity
    )
/*++

    This routine takes a NtLmMinimumClientSec or NtLmMinimumServerSec registry
    value and masks off the bits that are not relevant for enforcing the
    supported options.

--*/
{

    return (MinimumSecurity & (
                    NTLMSSP_NEGOTIATE_UNICODE |
                    NTLMSSP_NEGOTIATE_SIGN |
                    NTLMSSP_NEGOTIATE_SEAL |
                    NTLMSSP_NEGOTIATE_NTLM2 |
                    NTLMSSP_NEGOTIATE_128 |
                    NTLMSSP_NEGOTIATE_KEY_EXCH |
                    NTLMSSP_NEGOTIATE_56
                    ));

}

VOID
NTAPI
NtLmQueryDynamicGlobals(
    PVOID pvContext,
    BOOLEAN f
    )
{
    SspPrint((SSP_API, "Entering NtLmQueryDynamicGlobals\n"));

    HKEY KeyHandle;     // open registry key to Lsa\MSV1_0
    LONG RegStatus;

    DWORD RegValueType;
    DWORD RegValue;
    DWORD RegValueSize;

    KeyHandle = NtLmGlobalLsaKey;

    if( KeyHandle != NULL )
    {
        //
        // lm compatibility level.
        //

        RegValueSize = sizeof( RegValue );

        RegStatus = RegQueryValueExW(
                        KeyHandle,
                        L"LmCompatibilityLevel",
                        NULL,
                        &RegValueType,
                        (PUCHAR)&RegValue,
                        &RegValueSize
                        );


        if ( RegStatus == ERROR_SUCCESS ) {

            //
            // Check that the data is the correct size and type - a ULONG.
            //

            if ((RegValueSize >= sizeof(ULONG)) &&
                (RegValueType == REG_DWORD)) {

                NtLmGlobalLmProtocolSupported = (ULONG)RegValue;
            }
        } else if( RegStatus == ERROR_FILE_NOT_FOUND ) {

            //
            // value was deleted - resort to default.
            //

            NtLmGlobalLmProtocolSupported = 0;
        }

        //
        // handle ForceGuest
        //

        if( NtLmGlobalNtProductType != NtProductLanManNt )
        {
            RegValueSize = sizeof( RegValue );

            if( NtLmGlobalPersonalSKU )
            {
                //
                // personal product always has ForceGuest turned on.
                //

                RegValueSize = sizeof(ULONG);
                RegValueType = REG_DWORD;
                RegValue = 1;
                RegStatus = ERROR_SUCCESS;

            } else {

                if( NtLmGlobalDomainJoined )
                {
                    //
                    // joined product always has ForceGuest turned off.
                    //

                    RegValueSize = sizeof(ULONG);
                    RegValueType = REG_DWORD;
                    RegValue = 0;
                    RegStatus = ERROR_SUCCESS;

                } else {

                    RegStatus = RegQueryValueExW(
                                    KeyHandle,
                                    L"ForceGuest",
                                    NULL,
                                    &RegValueType,
                                    (PUCHAR)&RegValue,
                                    &RegValueSize
                                    );
                }
            }

        } else {

            //
            // insure ForceGuest is disabled for domain controllers.
            //

            RegStatus = ERROR_FILE_NOT_FOUND;
        }

        if ( RegStatus == ERROR_SUCCESS ) {

            //
            // Check that the data is the correct size and type - a ULONG.
            //

            if ( (RegValueSize >= sizeof(ULONG)) &&
                 (RegValueType == REG_DWORD) )
            {
                if( RegValue == 1 )
                {
                    NtLmGlobalForceGuest = TRUE;
                } else {
                    NtLmGlobalForceGuest = FALSE;
                }
            }
        } else if( RegStatus == ERROR_FILE_NOT_FOUND ) {

            //
            // value was deleted - resort to default.
            //

            NtLmGlobalForceGuest = FALSE;
        }

        //
        // handle LimitBlankPasswordUse
        //

        if( NtLmGlobalNtProductType != NtProductLanManNt )
        {
            RegValueSize = sizeof( RegValue );

            RegStatus = RegQueryValueExW(
                            KeyHandle,
                            L"LimitBlankPasswordUse",
                            NULL,
                            &RegValueType,
                            (PUCHAR)&RegValue,
                            &RegValueSize
                            );

        } else {
            
            //
            // domain controllers always allow blank.
            //

            NtLmGlobalAllowBlankPassword = TRUE;
            
            RegStatus = ERROR_INVALID_PARAMETER;
        }

        if ( RegStatus == ERROR_SUCCESS ) {

            //
            // Check that the data is the correct size and type - a ULONG.
            //

            if ( (RegValueSize >= sizeof(ULONG)) &&
                 (RegValueType == REG_DWORD) )
            {
                if( RegValue == 0 )
                {
                    NtLmGlobalAllowBlankPassword = TRUE;
                } else {
                    NtLmGlobalAllowBlankPassword = FALSE;
                }
            }
        } else if( RegStatus == ERROR_FILE_NOT_FOUND ) {

            //
            // value was deleted - resort to default.
            //

            NtLmGlobalAllowBlankPassword = FALSE;
        }

    }



    KeyHandle = NtLmGlobalLsaMsv1_0Key;

    if( KeyHandle != NULL )
    {
        //
        // get minimum client security flag.
        //

        RegValueSize = sizeof( RegValue );

        RegStatus = RegQueryValueExW(
                        KeyHandle,
                        L"NtlmMinClientSec",
                        NULL,
                        &RegValueType,
                        (PUCHAR)&RegValue,
                        &RegValueSize
                        );


        if ( RegStatus == ERROR_SUCCESS ) {

            //
            // Check that the data is the correct size and type - a ULONG.
            //

            if ((RegValueSize >= sizeof(ULONG)) &&
                (RegValueType == REG_DWORD)) {

                NtLmGlobalMinimumClientSecurity =
                    NtLmValidMinimumSecurityFlagsMask( (ULONG)RegValue );
            }
        } else if( RegStatus == ERROR_FILE_NOT_FOUND ) {

            //
            // value was deleted - resort to default.
            //

            NtLmGlobalMinimumClientSecurity = 0 ;
        }

        //
        // get minimum server security flags.
        //

        RegValueSize = sizeof( RegValueSize );

        RegStatus = RegQueryValueExW(
                        KeyHandle,
                        L"NtlmMinServerSec",
                        NULL,
                        &RegValueType,
                        (PUCHAR)&RegValue,
                        &RegValueSize
                        );


        if ( RegStatus == ERROR_SUCCESS ) {

            //
            // Check that the data is the correct size and type - a ULONG.
            //

            if ((RegValueSize >= sizeof(ULONG)) &&
                (RegValueType == REG_DWORD)) {

                NtLmGlobalMinimumServerSecurity =
                    NtLmValidMinimumSecurityFlagsMask( (ULONG)RegValue );
            }

        } else if( RegStatus == ERROR_FILE_NOT_FOUND ) {

            //
            // value was deleted - resort to default.
            //

            NtLmGlobalMinimumServerSecurity = 0;
        }

        //
        // All datagram related flags need to be set.
        //

        if (NtLmGlobalMinimumClientSecurity & NTLMSSP_NEGOTIATE_NTLM2)
        {
            NtLmGlobalRequireNtlm2 = TRUE;
        }

        if ((NtLmGlobalMinimumClientSecurity & NTLMSSP_NEGOTIATE_128) &&
            (NtLmSecPkg.MachineState & SECPKG_STATE_STRONG_ENCRYPTION_PERMITTED))
        {
            NtLmGlobalDatagramUse128BitEncryption = TRUE;
        } else if (NtLmGlobalMinimumClientSecurity & NTLMSSP_NEGOTIATE_56) {
            NtLmGlobalDatagramUse56BitEncryption = TRUE;
        }

#if DBG


        //
        // get the debugging flag
        //


        RegValueSize = sizeof( RegValueSize );

        RegStatus = RegQueryValueExW(
                        KeyHandle,
                        L"DBFlag",
                        NULL,
                        &RegValueType,
                        (PUCHAR)&RegValue,
                        &RegValueSize
                        );


        if ( RegStatus == ERROR_SUCCESS ) {

            //
            // Check that the data is the correct size and type - a ULONG.
            //

            if ((RegValueSize >= sizeof(ULONG)) &&
                (RegValueType == REG_DWORD)) {

                SspGlobalDbflag = (ULONG)RegValue;
            }

        }

#endif

    }



    //
    // (re)register the wait events.
    //

    if( NtLmGlobalRegChangeNotifyEvent )
    {
        if( NtLmGlobalLsaKey )
        {
            RegNotifyChangeKeyValue(
                            NtLmGlobalLsaKey,
                            FALSE,
                            REG_NOTIFY_CHANGE_LAST_SET,
                            NtLmGlobalRegChangeNotifyEvent,
                            TRUE
                            );
        }

#if DBG
        if( NtLmGlobalLsaMsv1_0Key )
        {
            RegNotifyChangeKeyValue(
                            NtLmGlobalLsaMsv1_0Key,
                            FALSE,
                            REG_NOTIFY_CHANGE_LAST_SET,
                            NtLmGlobalRegChangeNotifyEvent,
                            TRUE
                            );
        }
#endif

    }


    SspPrint((SSP_API, "Leaving NtLmQueryDynamicGlobals\n"));

    return;
}


VOID
NtLmQueryMappedDomains(
    VOID
    )
{
    HKEY KeyHandle;     // open registry key to Lsa\MSV1_0
    LONG RegStatus;
    DWORD RegValueType;
    WCHAR RegDomainName[DNS_MAX_NAME_LENGTH+1];
    DWORD RegDomainSize;


    //
    // register the workitem that waits for the RegChangeNotifyEvent
    // to be signalled.  This supports dynamic refresh of configuration
    // parameters.
    //

    NtLmGlobalRegChangeNotifyEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

    //
    // query the globals once prior to registering the wait
    // if a registry change occurs, the globals will be re-read by the worker
    // thread.
    //

    NtLmQueryDynamicGlobals( NULL, FALSE );

    NtLmGlobalRegWaitObject = RegisterWaitForSingleObjectEx(
                                    NtLmGlobalRegChangeNotifyEvent,
                                    NtLmQueryDynamicGlobals,
                                    NULL,
                                    INFINITE,
                                    0 // dwFlags
                                    );

    KeyHandle = NtLmGlobalLsaMsv1_0Key;

    if( KeyHandle == NULL )
        return;


    //
    // we only support loading the following globals once during initialization;
    // they are not re-read until next reboot.
    //



    //
    // Check the registry for a domain name to map
    //

    RegDomainSize = sizeof( RegDomainName );
    RegStatus = RegQueryValueExW(
                    KeyHandle,
                    L"MappedDomain",
                    NULL,
                    &RegValueType,
                    (PUCHAR) RegDomainName,
                    &RegDomainSize
                    );

    if (RegStatus == ERROR_SUCCESS && RegDomainSize <= 0xFFFF) {

        NtLmLocklessGlobalMappedDomainString.Length = (USHORT)(RegDomainSize - sizeof(WCHAR));
        NtLmLocklessGlobalMappedDomainString.MaximumLength = (USHORT)RegDomainSize;
        NtLmLocklessGlobalMappedDomainString.Buffer = (PWSTR)NtLmAllocate( RegDomainSize );

        if( NtLmLocklessGlobalMappedDomainString.Buffer != NULL )
            CopyMemory( NtLmLocklessGlobalMappedDomainString.Buffer,
                        RegDomainName,
                        RegDomainSize );
    } else {
        RtlInitUnicodeString(
            &NtLmLocklessGlobalMappedDomainString,
            NULL
            );
    }


    //
    // Check the registry for a domain name to use
    //

    RegDomainSize = sizeof( RegDomainName );
    RegStatus = RegQueryValueExW(
                    KeyHandle,
                    L"PreferredDomain",
                    NULL,
                    &RegValueType,
                    (PUCHAR) RegDomainName,
                    &RegDomainSize
                    );

    if (RegStatus == ERROR_SUCCESS && RegDomainSize <= 0xFFFF) {

        NtLmLocklessGlobalPreferredDomainString.Length = (USHORT)(RegDomainSize - sizeof(WCHAR));
        NtLmLocklessGlobalPreferredDomainString.MaximumLength = (USHORT)RegDomainSize;
        NtLmLocklessGlobalPreferredDomainString.Buffer = (PWSTR)NtLmAllocate( RegDomainSize );

        if( NtLmLocklessGlobalPreferredDomainString.Buffer != NULL )
            CopyMemory( NtLmLocklessGlobalPreferredDomainString.Buffer,
                        RegDomainName,
                        RegDomainSize );
    } else {
        RtlInitUnicodeString(
            &NtLmLocklessGlobalPreferredDomainString,
            NULL
            );
    }


    return;
}


VOID
NtLmFreeMappedDomains(
    VOID
    )
{
    if( NtLmGlobalRegWaitObject )
        UnregisterWait( NtLmGlobalRegWaitObject );

    if( NtLmGlobalRegChangeNotifyEvent )
        CloseHandle( NtLmGlobalRegChangeNotifyEvent );

    if( NtLmLocklessGlobalMappedDomainString.Buffer ) {
        NtLmFree( NtLmLocklessGlobalMappedDomainString.Buffer );
        NtLmLocklessGlobalMappedDomainString.Buffer = NULL;
    }

    if( NtLmLocklessGlobalPreferredDomainString.Buffer ) {
        NtLmFree( NtLmLocklessGlobalPreferredDomainString.Buffer );
        NtLmLocklessGlobalPreferredDomainString.Buffer = NULL;
    }
}

ULONG
NtLmCheckProcessOption(
    IN  ULONG OptionRequest
    )
{
    SECPKG_CALL_INFO CallInfo;
    ULONG OptionMask = 0;
    PLIST_ENTRY ListHead;
    PLIST_ENTRY ListEntry;

    if(!LsaFunctions->GetCallInfo(&CallInfo))
    {
        goto Cleanup;
    }

    RtlAcquireResourceShared( &NtLmProcessOptionsLock, TRUE );
    
    ListHead = &NtLmProcessOptionsList;
    
    //
    // Now walk the list looking for a match.
    //

    for ( ListEntry = ListHead->Flink;
          ListEntry != ListHead;
          ListEntry = ListEntry->Flink )
    {
        PSSP_PROCESSOPTIONS ProcessOptions;
        
        ProcessOptions = CONTAINING_RECORD( ListEntry, SSP_PROCESSOPTIONS, Next );
        
        if( ProcessOptions->ClientProcessID == CallInfo.ProcessId )
        {
            OptionMask = ProcessOptions->ProcessOptions;
            break;
        }
    }
    
    RtlReleaseResource( &NtLmProcessOptionsLock );

Cleanup:

    return OptionMask;
}

BOOLEAN
NtLmSetProcessOption(
    IN  ULONG OptionRequest,
    IN  BOOLEAN DisableOption
    )
{
    SECPKG_CALL_INFO CallInfo;
    PSSP_PROCESSOPTIONS pProcessOption = NULL;
    PLIST_ENTRY ListHead;
    PLIST_ENTRY ListEntry;
    BOOLEAN fExisting = FALSE;
    BOOLEAN fSuccess = FALSE;

    if(!LsaFunctions->GetCallInfo(&CallInfo))
    {
        goto Cleanup;
    }

    pProcessOption = (PSSP_PROCESSOPTIONS)NtLmAllocate( sizeof(*pProcessOption) );
    if( pProcessOption == NULL )
    {
        goto Cleanup;
    }

    pProcessOption->ClientProcessID = CallInfo.ProcessId;
    pProcessOption->ProcessOptions = OptionRequest;

    RtlAcquireResourceExclusive( &NtLmProcessOptionsLock, TRUE );
    
    ListHead = &NtLmProcessOptionsList;
    
    //
    // Now walk the list looking for a match.
    //

    for ( ListEntry = ListHead->Flink;
          ListEntry != ListHead;
          ListEntry = ListEntry->Flink )
    {
        PSSP_PROCESSOPTIONS ProcessOptions;
        
        ProcessOptions = CONTAINING_RECORD( ListEntry, SSP_PROCESSOPTIONS, Next );
        
        if( ProcessOptions->ClientProcessID == CallInfo.ProcessId )
        {
            if( DisableOption )
            {
                ProcessOptions->ProcessOptions &= ~OptionRequest;
            } else {
                ProcessOptions->ProcessOptions |= OptionRequest;
            }
            
            fExisting = TRUE;
            break;
        }
    }

    if( !fExisting && !DisableOption )
    {
        InsertHeadList( &NtLmProcessOptionsList, &pProcessOption->Next );
        pProcessOption = NULL;
    }

    RtlReleaseResource( &NtLmProcessOptionsLock );

    fSuccess = TRUE;

Cleanup:

    if( pProcessOption != NULL )
    {
        NtLmFree( pProcessOption );
    }

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\ntlmutil.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        ntlmutil.h
//
// Contents:    prototypes for NtLm utility functions
//
//
// History:     ChandanS 25-Jul-1996   Stolen from kerberos\client2\kerbutil.h
//
//------------------------------------------------------------------------

#ifndef __NTLMUTIL_H__
#define __NTLMUTIL_H__

#include <malloc.h>

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Miscellaneous macros                                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
extern "C"
{
#endif

NTSTATUS
NtLmDuplicateUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN OPTIONAL PUNICODE_STRING SourceString
    );

NTSTATUS
NtLmDuplicateString(
    OUT PSTRING DestinationString,
    IN OPTIONAL PSTRING SourceString
    );

NTSTATUS
NtLmDuplicatePassword(
    OUT PUNICODE_STRING DestinationString,
    IN OPTIONAL PUNICODE_STRING SourceString
    );

NTSTATUS
NtLmDuplicateSid(
    OUT PSID *DestinationSid,
    IN PSID SourceSid
    );

VOID
NtLmFree(
    IN PVOID Buffer
    );

PVOID
NtLmAllocate(
    IN SIZE_T BufferSize
    );

PVOID
NtLmAllocateLsaHeap(
    IN ULONG BufferSize
    );

VOID
NtLmFreeLsaHeap(
    IN PVOID Buffer
    );


//
// internal versions for use when code only executed in LSA.
//

#if DBG

PVOID
NtLmAllocatePrivateHeap(
    IN SIZE_T BufferSize
    );

VOID
NtLmFreePrivateHeap(
    IN PVOID Buffer
    );

PVOID
I_NtLmAllocate(
    IN SIZE_T BufferSize
    );

VOID
I_NtLmFree(
    IN PVOID Buffer
    );

#else

//
// routines that use LsaHeap - necessary for buffers which
// LSA frees outside of package from LsaHeap
//

//
// routines that use LsaPrivateHeap.
//

#define NtLmAllocatePrivateHeap(x)  LsaFunctions->AllocatePrivateHeap(x)
#define NtLmFreePrivateHeap(x)      LsaFunctions->FreePrivateHeap(x)

#define I_NtLmAllocate(x)           Lsa.AllocatePrivateHeap(x)
#define I_NtLmFree(x)               Lsa.FreePrivateHeap(x)

#endif

#ifdef __cplusplus
}
#endif

#endif // __NTLMUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\ntlmutil.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        ntlmutil.cxx
//
// Contents:    Utility functions for NtLm package:
//                NtLmDuplicateUnicodeString
//                NtLmDuplicateSid
//                NtLmAllocate
//                NtLmFree
//
//
// History:     ChandanS  25-Jul-1996   Stolen from kerberos\client2\kerbutil.cxx
//
//------------------------------------------------------------------------
#include <global.h>



//+-------------------------------------------------------------------------
//
//  Function:   NtLmDuplicateUnicodeString
//
//  Synopsis:   Duplicates a UNICODE_STRING. If the source string buffer is
//              NULL the destionation will be too.
//
//  Effects:    allocates memory with LsaFunctions.AllocateLsaHeap
//
//  Arguments:  DestinationString - Receives a copy of the source string
//              SourceString - String to copy
//
//  Requires:
//
//  Returns:    SEC_E_OK - the copy succeeded
//              SEC_E_INSUFFICIENT_MEMORY - the call to allocate
//                  memory failed.
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
NtLmDuplicateUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN OPTIONAL PUNICODE_STRING SourceString
    )
{
    SspPrint((SSP_MISC, "Entering NtLmDuplicateUnicodeString\n"));

    NTSTATUS Status = STATUS_SUCCESS;

    DestinationString->Buffer = NULL;
    DestinationString->Length =
                        DestinationString->MaximumLength =
                        0;

    if ((ARGUMENT_PRESENT(SourceString)) &&
        (SourceString->Buffer != NULL))
    {

        DestinationString->Buffer = (LPWSTR) NtLmAllocatePrivateHeap(
                       SourceString->Length + sizeof(WCHAR));
        if (DestinationString->Buffer != NULL)
        {

            DestinationString->Length = SourceString->Length;
            DestinationString->MaximumLength = SourceString->Length + sizeof(WCHAR);
            RtlCopyMemory(
                DestinationString->Buffer,
                SourceString->Buffer,
                SourceString->Length
                );

            DestinationString->Buffer[SourceString->Length/sizeof(WCHAR)] = L'\0';
        }
        else
        {
            Status = STATUS_NO_MEMORY;
            SspPrint((SSP_CRITICAL, "NtLmDuplicateUnicodeString, NtLmAllocate returns NULL\n"));
            goto CleanUp;
        }
    }

CleanUp:

    SspPrint((SSP_MISC, "Leaving NtLmDuplicateUnicodeString\n"));
    return(Status);

}

//+-------------------------------------------------------------------------
//
//  Function:   NtLmDuplicateString
//
//  Synopsis:   Duplicates a STRING. If the source string buffer is
//              NULL the destionation will be too.
//
//  Effects:    allocates memory with LsaFunctions.AllocatePrivateHeap
//
//  Arguments:  DestinationString - Receives a copy of the source string
//              SourceString - String to copy
//
//  Requires:
//
//  Returns:    SEC_E_OK - the copy succeeded
//              SEC_E_INSUFFICIENT_MEMORY - the call to allocate
//                  memory failed.
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
NtLmDuplicateString(
    OUT PSTRING DestinationString,
    IN OPTIONAL PSTRING SourceString
    )
{
    SspPrint((SSP_MISC, "Entering NtLmDuplicateString\n"));

    NTSTATUS Status = STATUS_SUCCESS;

    DestinationString->Buffer = NULL;
    DestinationString->Length =
                        DestinationString->MaximumLength =
                        0;

    if ((ARGUMENT_PRESENT(SourceString)) &&
        (SourceString->Buffer != NULL))
    {

        DestinationString->Buffer = (LPSTR) NtLmAllocatePrivateHeap(
                       SourceString->Length + sizeof(CHAR));
        if (DestinationString->Buffer != NULL)
        {

            DestinationString->Length = SourceString->Length;
            DestinationString->MaximumLength = SourceString->Length + sizeof(CHAR);
            RtlCopyMemory(
                DestinationString->Buffer,
                SourceString->Buffer,
                SourceString->Length
                );

            DestinationString->Buffer[SourceString->Length/sizeof(CHAR)] = '\0';
        }
        else
        {
            Status = STATUS_NO_MEMORY;
            SspPrint((SSP_CRITICAL, "NtLmDuplicateString, NtLmAllocate returns NULL\n"));
            goto CleanUp;
        }
    }

CleanUp:

    SspPrint((SSP_MISC, "Leaving NtLmDuplicateString\n"));
    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   NtLmDuplicatePassword
//
//  Synopsis:   Duplicates a UNICODE_STRING. If the source string buffer is
//              NULL the destionation will be too.  The MaximumLength contains
//              room for encryption padding data.
//
//  Effects:    allocates memory with LsaFunctions.AllocatePrivateHeap
//
//  Arguments:  DestinationString - Receives a copy of the source string
//              SourceString - String to copy
//
//  Requires:
//
//  Returns:    SEC_E_OK - the copy succeeded
//              SEC_E_INSUFFICIENT_MEMORY - the call to allocate
//                  memory failed.
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
NtLmDuplicatePassword(
    OUT PUNICODE_STRING DestinationString,
    IN OPTIONAL PUNICODE_STRING SourceString
    )
{
    SspPrint((SSP_MISC, "Entering NtLmDuplicatePassword\n"));

    NTSTATUS Status = STATUS_SUCCESS;

    DestinationString->Buffer = NULL;
    DestinationString->Length =
                        DestinationString->MaximumLength =
                        0;

    if ((ARGUMENT_PRESENT(SourceString)) &&
        (SourceString->Buffer != NULL))
    {
        USHORT PaddingLength;

        PaddingLength = DESX_BLOCKLEN - (SourceString->Length % DESX_BLOCKLEN);

        if( PaddingLength == DESX_BLOCKLEN )
        {
            PaddingLength = 0;
        }

        DestinationString->Buffer = (LPWSTR) NtLmAllocatePrivateHeap(
                                                    SourceString->Length +
                                                    PaddingLength
                                                    );

        if (DestinationString->Buffer != NULL)
        {

            DestinationString->Length = SourceString->Length;
            DestinationString->MaximumLength = SourceString->Length + PaddingLength;

            if( DestinationString->MaximumLength == SourceString->MaximumLength )
            {
                //
                // duplicating an already padded buffer -- pickup the original
                // pad.
                //

                RtlCopyMemory(
                    DestinationString->Buffer,
                    SourceString->Buffer,
                    SourceString->MaximumLength
                    );
            } else {

                //
                // duplicating an unpadded buffer -- pickup only the string
                // and fill the rest with the boot time pad.
                //

                RtlCopyMemory(
                    DestinationString->Buffer,
                    SourceString->Buffer,
                    SourceString->Length
                    );

                //
                // CRYPTNOTE: consideration for ultra-paranoid:
                // use a boot time random pad for fill.
                //

            }

        }
        else
        {
            Status = STATUS_NO_MEMORY;
            SspPrint((SSP_CRITICAL, "NtLmDuplicatePassword, NtLmAllocate returns NULL\n"));
        }
    }


    SspPrint((SSP_MISC, "Leaving NtLmDuplicatePassword\n"));
    return(Status);
}




//+-------------------------------------------------------------------------
//
//  Function:   NtLmDuplicateSid
//
//  Synopsis:   Duplicates a SID
//
//  Effects:    allocates memory with LsaFunctions.AllocatePrivateHeap
//
//  Arguments:  DestinationSid - Receives a copy of the SourceSid
//              SourceSid - SID to copy
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS - the copy succeeded
//              STATUS_INSUFFICIENT_RESOURCES - the call to allocate memory
//                  failed
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
NtLmDuplicateSid(
    OUT PSID * DestinationSid,
    IN PSID SourceSid
    )
{
    SspPrint((SSP_MISC, "Entering NtLmDuplicateSid\n"));

    NTSTATUS Status = STATUS_SUCCESS;
    ULONG SidSize;

    ASSERT(RtlValidSid(SourceSid));

    SidSize = RtlLengthSid(SourceSid);

    *DestinationSid = (PSID) NtLmAllocatePrivateHeap( SidSize );

    if (ARGUMENT_PRESENT(*DestinationSid))
    {
        RtlCopyMemory(
            *DestinationSid,
            SourceSid,
            SidSize
            );
    }
    else
    {
        Status =  STATUS_INSUFFICIENT_RESOURCES;
        SspPrint((SSP_CRITICAL, "NtLmDuplicateSid, NtLmAllocate returns NULL\n"));
        goto CleanUp;
    }

CleanUp:
    SspPrint((SSP_MISC, "Leaving NtLmDuplicateSid\n"));
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   NtLmAllocate
//
//  Synopsis:   Allocate memory in either lsa mode or user mode
//
//  Effects:    Allocated chunk is zeroed out
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


PVOID
NtLmAllocate(
    IN SIZE_T BufferSize
    )
{
    PVOID Buffer;

    if (NtLmState == NtLmLsaMode)
    {
        ASSERT ((LsaFunctions->AllocatePrivateHeap));
        Buffer = LsaFunctions->AllocatePrivateHeap(BufferSize);
        // note: Lsa allocator zeroes the memory for us.
    }
    else
    {
        ASSERT(NtLmState == NtLmUserMode);
        Buffer = LocalAlloc(LPTR, BufferSize);
//        Buffer = CryptMemoryAlloc(BufferSize);
    }


    return Buffer;
}


//+-------------------------------------------------------------------------
//
//  Function:   NtLmFree
//
//  Synopsis:   Free memory in either lsa mode or user mode
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
NtLmFree(
    IN PVOID Buffer
    )
{

    if (ARGUMENT_PRESENT(Buffer))
    {
        if (NtLmState == NtLmLsaMode)
        {
            ASSERT ((LsaFunctions->FreePrivateHeap));
            LsaFunctions->FreePrivateHeap(Buffer);
        }
        else
        {
            ASSERT(NtLmState == NtLmUserMode);
            LocalFree(Buffer);
//            CryptMemoryFree(Buffer);
        }
    }

}



PVOID
NtLmAllocateLsaHeap(
    IN ULONG BufferSize // should update to SIZE_T once lsa allocator def updated
    )
{
    PVOID Buffer;

    if (NtLmState == NtLmLsaMode)
    {
        ASSERT ((LsaFunctions->AllocateLsaHeap));
        Buffer = LsaFunctions->AllocateLsaHeap(BufferSize);
        // note: Lsa allocator zeroes the memory for us.
    }
    else
    {
        ASSERT(NtLmState == NtLmUserMode);
        Buffer = LocalAlloc(LPTR, BufferSize);
//        Buffer = CryptMemoryAlloc(BufferSize);
    }

    return Buffer;
}

VOID
NtLmFreeLsaHeap(
    IN PVOID Buffer
    )
{

    if (ARGUMENT_PRESENT(Buffer))
    {
        if (NtLmState == NtLmLsaMode)
        {
            ASSERT ((LsaFunctions->FreeLsaHeap));
            LsaFunctions->FreeLsaHeap(Buffer);
        }
        else
        {
            ASSERT(NtLmState == NtLmUserMode);
            LocalFree(Buffer);
//            CryptMemoryFree(Buffer);
        }
    }
}




#if DBG

PVOID
NtLmAllocatePrivateHeap(
    IN SIZE_T BufferSize
    )
{
    ASSERT (NtLmState == NtLmLsaMode);
    ASSERT ((LsaFunctions->AllocatePrivateHeap));

    // note: Lsa allocator zeroes the memory for us.
    return LsaFunctions->AllocatePrivateHeap(BufferSize);
}

VOID
NtLmFreePrivateHeap(
    IN PVOID Buffer
    )
{
    ASSERT (NtLmState == NtLmLsaMode);
    ASSERT ((LsaFunctions->FreePrivateHeap));

    if (ARGUMENT_PRESENT(Buffer))
    {
        LsaFunctions->FreePrivateHeap(Buffer);
    }
}

PVOID
I_NtLmAllocate(
    IN SIZE_T BufferSize
    )
{
    ASSERT (NtLmState == NtLmLsaMode);
    ASSERT ((Lsa.AllocatePrivateHeap));

    // note: Lsa allocator zeroes the memory for us.
    return Lsa.AllocatePrivateHeap(BufferSize);
}

VOID
I_NtLmFree(
    IN PVOID Buffer
    )
{
    ASSERT (NtLmState == NtLmLsaMode);
    ASSERT ((Lsa.FreePrivateHeap));

    if (ARGUMENT_PRESENT(Buffer))
    {
        Lsa.FreePrivateHeap(Buffer);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\proxyapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        proxyapi.cxx
//
// Contents:    Code for Proxy support in NtLM
//              Main entry points in the dll:
//                SpGrantProxy
//                SpRevokeProxy
//                SpInvokeProxy
//                SpRenewProxy
//
//
// History:     ChandanS  25-Jul-1996   Stolen from kerberos\client2\proxyapi.cxx
//
//------------------------------------------------------------------------

#include <global.h>

NTSTATUS NTAPI
SpGrantProxy(
    IN ULONG_PTR CredentialHandle,
    IN OPTIONAL PUNICODE_STRING ProxyName,
    IN PROXY_CLASS ProxyClass,
    IN OPTIONAL PUNICODE_STRING TargetName,
    IN ACCESS_MASK ContainerMask,
    IN ACCESS_MASK ObjectMask,
    IN PTimeStamp ExpirationTime,
    IN PSecBuffer AccessInformation,
    OUT PPROXY_REFERENCE ProxyReference
    )
{
    SspPrint((SSP_API, "Entering SpGrantProxy\n"));

    UNREFERENCED_PARAMETER (CredentialHandle);
    UNREFERENCED_PARAMETER (ProxyName);
    UNREFERENCED_PARAMETER (ProxyClass);
    UNREFERENCED_PARAMETER (TargetName);
    UNREFERENCED_PARAMETER (ContainerMask);
    UNREFERENCED_PARAMETER (ObjectMask);
    UNREFERENCED_PARAMETER (ExpirationTime);
    UNREFERENCED_PARAMETER (AccessInformation);
    UNREFERENCED_PARAMETER (ProxyReference);

    SspPrint((SSP_API, "Leaving SpGrantProxy\n"));
    return(STATUS_NOT_SUPPORTED);
}

NTSTATUS NTAPI
SpRevokeProxy(
    IN ULONG_PTR CredentialHandle,
    IN OPTIONAL PPROXY_REFERENCE ProxyReference,
    IN OPTIONAL PUNICODE_STRING ProxyName
    )
{
    SspPrint((SSP_API, "Entering SpRevokeProxy\n"));

    UNREFERENCED_PARAMETER (CredentialHandle);
    UNREFERENCED_PARAMETER (ProxyReference);
    UNREFERENCED_PARAMETER (ProxyName);

    SspPrint((SSP_API, "Leaving SpRevokeProxy\n"));
    return(STATUS_NOT_SUPPORTED);
}

NTSTATUS NTAPI
SpInvokeProxy(
    IN ULONG_PTR CredentialHandle,
    IN OPTIONAL PPROXY_REFERENCE ProxyReference,
    IN OPTIONAL PUNICODE_STRING ProxyName,
    OUT PULONG_PTR ContextHandle,
    OUT PLUID LogonId,
    OUT PULONG CachedCredentialCount,
    OUT PSECPKG_SUPPLEMENTAL_CRED * CachedCredentials,
    OUT PSecBuffer ContextData
    )
{
    SspPrint((SSP_API, "Entering SpInvokeProxy\n"));

    UNREFERENCED_PARAMETER (CredentialHandle);
    UNREFERENCED_PARAMETER (ProxyReference);
    UNREFERENCED_PARAMETER (ProxyName);
    UNREFERENCED_PARAMETER (ContextHandle);
    UNREFERENCED_PARAMETER (LogonId);
    UNREFERENCED_PARAMETER (CachedCredentialCount);
    UNREFERENCED_PARAMETER (CachedCredentials);
    UNREFERENCED_PARAMETER (ContextData);

    SspPrint((SSP_API, "Leaving SpInvokeProxy\n"));
    return(STATUS_NOT_SUPPORTED);
}


NTSTATUS NTAPI
SpRenewProxy(
    IN ULONG_PTR CredentialHandle,
    IN OPTIONAL PPROXY_REFERENCE ProxyReference,
    IN OPTIONAL PUNICODE_STRING ProxyName,
    IN PTimeStamp ExpirationTime
    )
{
    SspPrint((SSP_API, "Entering SpRenewProxy\n"));

    UNREFERENCED_PARAMETER (CredentialHandle);
    UNREFERENCED_PARAMETER (ProxyReference);
    UNREFERENCED_PARAMETER (ProxyName);
    UNREFERENCED_PARAMETER (ExpirationTime);

    SspPrint((SSP_API, "Leaving SpRenewProxy\n"));
    return(STATUS_NOT_SUPPORTED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\rng.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       rng.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8-15-95   RichardW   Created
//              2-8-96    MikeSw     Copied to NTLMSSP from SSL
//              03-Aug-1996 ChandanS  Stolen from net\svcdlls\ntlmssp\common\rng.c
//              8-Dec-1997 SField    Use crypto group RNG
//
//----------------------------------------------------------------------------

#include <global.h>



NTSTATUS
SspGenerateRandomBits(
    VOID        *pRandomData,
    ULONG       cRandomData
    )
{
    NTSTATUS Status;

    if( RtlGenRandom( pRandomData, cRandomData ) )
    {
        return STATUS_SUCCESS;
    }

    //
    // return a nebulous error message.  this is better than returning
    // success which could compromise security with non-random key.
    //

    ASSERT( (STATUS_SUCCESS == STATUS_UNSUCCESSFUL) );

    return STATUS_UNSUCCESSFUL;
}


BOOL
NtLmInitializeRNG(VOID)
{
    return TRUE;
}

VOID
NtLmCleanupRNG(VOID)
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\support.cxx ===
/*++

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    debug.cxx

Abstract:

    Support routines allowing the NtLmSsp DLL side use the common routines
    shared between the DLL and the SERVICE.

    These routines exist in the DLL side.  They are different implementations
    of the same routines that exist on the SERVICE side.  These implementations
    are significantly simpler because they run in the address space of the
    caller.

Author:

    Cliff Van Dyke (CliffV) 22-Sep-1993

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:
    ChandanS  03-Aug-1996 Stolen from net\svcdlls\ntlmssp\client\support.c

--*/

//
// Common include files.
//

#include <global.h>


#if DBG
#include <stdio.h>
#define MAX_PRINTF_LEN 1024        // Arbitrary.


VOID
SspPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    )

{
    va_list arglist;
    char OutputBuffer[MAX_PRINTF_LEN];
    ULONG length;
    static BeginningOfLine = TRUE;
    static LineCount = 0;

    //
    // If we aren't debugging this functionality, just return.
    //
    if ( DebugFlag != 0 && (SspGlobalDbflag & DebugFlag) == 0 ) {
        return;
    }

    //
    // vsprintf isn't multithreaded + we don't want to intermingle output
    // from different threads.
    //

    EnterCriticalSection( &SspGlobalLogFileCritSect );
    length = 0;

    //
    // Handle the beginning of a new line.
    //
    //

    if ( BeginningOfLine ) {

        //
        // If we're writing to the debug terminal,
        //  indicate this is an NtLmSsp message.
        //

        length += (ULONG) sprintf( &OutputBuffer[length], "[MSV1_0.dll] " );

        //
        // Put the timestamp at the begining of the line.
        //
        IF_DEBUG( TIMESTAMP ) {
            SYSTEMTIME SystemTime;
            GetLocalTime( &SystemTime );
            length += (ULONG) sprintf( &OutputBuffer[length],
                                  "%02u/%02u %02u:%02u:%02u ",
                                  SystemTime.wMonth,
                                  SystemTime.wDay,
                                  SystemTime.wHour,
                                  SystemTime.wMinute,
                                  SystemTime.wSecond );
        }

        //
        // Indicate the type of message on the line
        //
        {
            char *Text;

            switch (DebugFlag) {
            case SSP_INIT:
                Text = "INIT"; break;
            case SSP_MISC:
                Text = "MISC"; break;
            case SSP_CRITICAL:
                Text = "CRITICAL"; break;
            case SSP_LPC:
            case SSP_LPC_MORE:
                Text = "LPC"; break;
            case SSP_API:
            case SSP_API_MORE:
                Text = "API"; break;

            default:
                Text = "UNKNOWN"; break;

            case 0:
                Text = NULL;
            }
            if ( Text != NULL ) {
                length += (ULONG) sprintf( &OutputBuffer[length], "[%s] ", Text );
            }
        }
    }
    //
    // Put a the information requested by the caller onto the line
    //

    va_start(arglist, Format);

    length += (ULONG) vsprintf(&OutputBuffer[length], Format, arglist);
    BeginningOfLine = (length > 0 && OutputBuffer[length-1] == '\n' );

    va_end(arglist);

    ASSERT(length <= MAX_PRINTF_LEN);


    //
    //  just output to the debug terminal
    //

    (void) DbgPrint( (PCH) OutputBuffer);

    LeaveCriticalSection( &SspGlobalLogFileCritSect );

} // SspPrintRoutine

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\trace.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    trace.c

Abstract:

    Contains the initialization function for event tracing, the callback function
    which enables and disables tracing, plus the handles and trace flag.

Author:

    15-June-2000  Jason Clark

Revision History:

--*/


//
//
//
#define INITGUID
#include <Global.h>
#include "trace.h"

#define IMAGE_PATH L"Msv1_0.dll"
#define RESOURCE_NAME L"MofResource"

BOOL             NtlmGlobalEventTraceFlag = FALSE;
TRACEHANDLE      NtlmGlobalTraceRegistrationHandle = (TRACEHANDLE) 0;
TRACEHANDLE      NtlmGlobalTraceLoggerHandle = (TRACEHANDLE) 0;


ULONG
NtlmTraceControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID RequestContext,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
    );

TRACE_GUID_REGISTRATION NtlmTraceGuids[] =
{
    { &NtlmAcceptGuid,
      NULL
    },
    { &NtlmInitializeGuid,
      NULL
    },
    { &NtlmLogonGuid,
      NULL
    },
    { &NtlmValidateGuid,
      NULL
    },
    { &NtlmGenericPassthroughGuid,
      NULL
    }   
};

#define NtlmGuidCount (sizeof(NtlmTraceGuids) / sizeof(TRACE_GUID_REGISTRATION))

ULONG
NtlmInitializeTrace(
    VOID
    )
{
    ULONG status;
    HMODULE hModule;
    TCHAR FileName[MAX_PATH+1];
    DWORD nLen = 0;

    hModule = GetModuleHandle(IMAGE_PATH);
    if (hModule != NULL) {
        nLen = GetModuleFileName(hModule, FileName, MAX_PATH);
    }
    if (nLen == 0) {
        lstrcpy(FileName, IMAGE_PATH);
    }

    status = RegisterTraceGuids(
                NtlmTraceControlCallback,
                NULL,
                &NtlmControlGuid,
                NtlmGuidCount,
                NtlmTraceGuids,
                (LPCWSTR) FileName,
                (LPCWSTR) RESOURCE_NAME,
                &NtlmGlobalTraceRegistrationHandle);

    if (status != ERROR_SUCCESS) {
       SspPrint((SSP_API, "Trace registration failed with %x\n",status));
        //DebugLog((DEB_ERROR,"Trace registration failed with %x\n",status));
    }
    return status;
}


ULONG
NtlmTraceControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID RequestContext,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
    )
{
    PWNODE_HEADER Wnode = (PWNODE_HEADER)Buffer;
    ULONG Status;
    ULONG RetSize;

    Status = ERROR_SUCCESS;
    
    SspPrint((SSP_API,"NtlmTrace callback\n"));

    switch (RequestCode)
    {
        case WMI_ENABLE_EVENTS:
        {
            NtlmGlobalTraceLoggerHandle =
                GetTraceLoggerHandle(Buffer);
            NtlmGlobalEventTraceFlag = TRUE;
            RetSize = 0;
            break;
        }

        case WMI_DISABLE_EVENTS:
        {
            NtlmGlobalEventTraceFlag = FALSE;
            RetSize = 0;
            NtlmGlobalTraceLoggerHandle = (TRACEHANDLE) 0;
            break;
        }
        default:
        {
            RetSize = 0;
            Status = ERROR_INVALID_PARAMETER;
            break;
        }

    }

    *InOutBufferSize = RetSize;
    return Status;
} // NtlmTraceControlCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\subauth.c ===
/*++

Copyright (c) 1987-1994  Microsoft Corporation

Module Name:

    subauth.c

Abstract:

    Interface to SubAuthentication Package.

Author:

    Cliff Van Dyke (cliffv) 23-May-1994

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:
 Chandana Surlu         21-Jul-96      Stolen from \\kernel\razzle3\src\security\msv1_0\subauth.c

--*/

#include <global.h>

#include "msp.h"
#include "nlp.h"
#include <winreg.h>
#include <kerberos.h>

//
// Prototype for subauthentication routines.
//
// the pre NT 5.0 Subauth routine
typedef NTSTATUS
(*PSUBAUTHENTICATION_ROUTINE)(
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG Flags,
    IN PUSER_ALL_INFORMATION UserAll,
    OUT PULONG WhichFields,
    OUT PULONG UserFlags,
    OUT PBOOLEAN Authoritative,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
);

// the NT 5.0 Subauth routine
typedef NTSTATUS
(*PSUBAUTHENTICATION_ROUTINEEX)(
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG Flags,
    IN PUSER_ALL_INFORMATION UserAll,
    IN SAM_HANDLE UserHandle,
    IN OUT PMSV1_0_VALIDATION_INFO ValidationInfo,
    OUT PULONG ActionsPerfomed
);

// the NT 5.0 Generic Subauth routine
typedef NTSTATUS
(*PSUBAUTHENTICATION_ROUTINEGENERIC)(
    IN PVOID SubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PULONG ReturnBufferLength,
    OUT PVOID *ReturnBuffer
);
typedef enum _SUBAUTH_TYPE {
    SubAuth = 1,   // Pre NT 5.0 subAuth called using LogonUser
    SubAuthEx,     // NT 5.0 subAuth called during LogonUser
    SubAuthGeneric // NT 5.0 subAuth called during LaCallAuthenticationPackage
} SUBAUTH_TYPE;
//
// Structure describing a loaded SubAuthentication DLL.
//

typedef struct _SUBAUTHENTICATION_DLL {
    LIST_ENTRY Next;
    ULONG DllNumber;
    PSUBAUTHENTICATION_ROUTINE SubAuthenticationRoutine;
    PSUBAUTHENTICATION_ROUTINEEX SubAuthenticationRoutineEx;
    PSUBAUTHENTICATION_ROUTINEGENERIC SubAuthenticationRoutineGeneric;
} SUBAUTHENTICATION_DLL, *PSUBAUTHENTICATION_DLL;

//
// Global list of all loaded subauthentication DLLs
//

LIST_ENTRY SubAuthenticationDlls;
RTL_RESOURCE SubAuthenticationCritSect;




VOID
Msv1_0SubAuthenticationInitialization(
    VOID
)
/*++

Routine Description:

    Initialization routine for this source file.

Arguments:

    None.

Return Value:

    None.

--*/
{
    RtlInitializeResource( &SubAuthenticationCritSect );
    InitializeListHead( &SubAuthenticationDlls );
}

PSUBAUTHENTICATION_DLL
ReferenceSubAuth (
    IN ULONG DllNumber,
    OUT PNTSTATUS SubStatus)
{
    LONG RegStatus;

    PSUBAUTHENTICATION_DLL SubAuthenticationDll = NULL;

    HKEY ParmHandle = NULL;
    HINSTANCE DllHandle = NULL;

    CHAR ValueName[sizeof(MSV1_0_SUBAUTHENTICATION_VALUE)+3];
    CHAR DllName[MAXIMUM_FILENAME_LENGTH+1];
    DWORD DllNameSize;
    DWORD DllNameType;
    PSUBAUTHENTICATION_ROUTINE SubAuthenticationRoutine = NULL;
    PSUBAUTHENTICATION_ROUTINEEX SubAuthenticationRoutineEx = NULL;
    PSUBAUTHENTICATION_ROUTINEGENERIC SubAuthenticationRoutineGeneric = NULL;

    PLIST_ENTRY ListEntry;

    *SubStatus = STATUS_SUCCESS;
    DllName[0] = 0;

    // See if the SubAuthentication Dll is already loaded.
    //

    RtlAcquireResourceShared(&SubAuthenticationCritSect, TRUE);

    for ( ListEntry = SubAuthenticationDlls.Flink ;
          ListEntry != &SubAuthenticationDlls ;
          ListEntry = ListEntry->Flink) {

        SubAuthenticationDll = CONTAINING_RECORD( ListEntry,
                                                  SUBAUTHENTICATION_DLL,
                                                  Next );

        if ( SubAuthenticationDll->DllNumber == DllNumber ) {
            break;
        }

        SubAuthenticationDll = NULL;

    }

    RtlReleaseResource(&SubAuthenticationCritSect);

    //
    // If the Dll is not already loaded,
    // load it.
    //

    if ( SubAuthenticationDll != NULL ) {
        goto Cleanup;
    }

    //
    // Build the name of the registry value.
    //

    RtlCopyMemory( ValueName,
                   MSV1_0_SUBAUTHENTICATION_VALUE,
                   sizeof(MSV1_0_SUBAUTHENTICATION_VALUE) );

    *SubStatus = RtlIntegerToChar(
                DllNumber & KERB_SUBAUTHENTICATION_MASK,
                10,          // Base
                4,           // Length of buffer
                &ValueName[sizeof(MSV1_0_SUBAUTHENTICATION_VALUE)-1] );

    if ( !NT_SUCCESS(*SubStatus) ) {
        goto Cleanup;
    }


    //
    // Open the MSV1_0_SUBAUTHENTICATION_KEY registry key.
    //


    if ((DllNumber & KERB_SUBAUTHENTICATION_FLAG) == 0) {
        RegStatus = RegOpenKeyExA(
                        HKEY_LOCAL_MACHINE,
                        MSV1_0_SUBAUTHENTICATION_KEY,
                        0,      //Reserved
                        KEY_QUERY_VALUE,
                        &ParmHandle );
    } else {
        RegStatus = RegOpenKeyExA(
                        HKEY_LOCAL_MACHINE,
                        KERB_SUBAUTHENTICATION_KEY,
                        0,      //Reserved
                        KEY_QUERY_VALUE,
                        &ParmHandle );

    }

    if ( RegStatus != ERROR_SUCCESS ) {
        SspPrint((SSP_MISC, "Cannot open registry key %s %ld.\n",
                  MSV1_0_SUBAUTHENTICATION_KEY,
                  RegStatus ));
    }
    else
    {

        //
        // Get the registry value.
        //

        DllNameSize = sizeof(DllName);

        RegStatus = RegQueryValueExA(
                    ParmHandle,
                    ValueName,
                    NULL,     // Reserved
                    &DllNameType,
                    DllName,
                    &DllNameSize );

        if ( RegStatus == ERROR_SUCCESS ) {

            if ( DllNameType != REG_SZ ) {
                SspPrint((SSP_MISC, "Registry value %s isn't REG_SZ.\n",
                      ValueName ));
                *SubStatus = STATUS_DLL_NOT_FOUND;
                goto Cleanup;
            }

            //
            // Load the DLL
            //

            DllHandle = LoadLibraryA( DllName );

            if ( DllHandle == NULL ) {
                SspPrint((SSP_MISC, "MSV1_0: Cannot load dll %s %ld.\n",
                  DllName,
                  GetLastError() ));
                *SubStatus = STATUS_DLL_NOT_FOUND;
                goto Cleanup;
            }

            //
            // Find the SubAuthenticationRoutine. For packages other than
            // zero, this will be Msv1_0SubauthenticationRoutine. For packge
            // zero it will be Msv1_0SubauthenticationFilter.
            //

            if ((DllNumber & KERB_SUBAUTHENTICATION_MASK) == 0)
            {
                SubAuthenticationRoutine = (PSUBAUTHENTICATION_ROUTINE)
                GetProcAddress(DllHandle, "Msv1_0SubAuthenticationFilter");
            }
            else
            {
                SubAuthenticationRoutine = (PSUBAUTHENTICATION_ROUTINE)
                GetProcAddress(DllHandle, "Msv1_0SubAuthenticationRoutine");
            }

            //
            // Find the SubAuthenticationRoutine
            //

            SubAuthenticationRoutineEx = (PSUBAUTHENTICATION_ROUTINEEX)
            GetProcAddress(DllHandle, "Msv1_0SubAuthenticationRoutineEx");

            //
            // Find the SubAuthenticationRoutineGeneric
            //

            SubAuthenticationRoutineGeneric = (PSUBAUTHENTICATION_ROUTINEGENERIC)
            GetProcAddress(DllHandle, "Msv1_0SubAuthenticationRoutineGeneric");

        }
    }

    //
    // If we didn't find the DLL or any routines, bail out now.
    //

    if ((DllHandle == NULL) ||
        ((SubAuthenticationRoutine == NULL) &&
        (SubAuthenticationRoutineEx == NULL) &&
        (SubAuthenticationRoutineGeneric == NULL))) {

        SspPrint((SSP_MISC, "Cannot find any of the subauth entry points in %s %ld.\n",
           DllName,
           GetLastError() ));
        *SubStatus = STATUS_PROCEDURE_NOT_FOUND;
        goto Cleanup;
    }

    //
    // Cache the address of the procedure.
    //

    SubAuthenticationDll =
        I_NtLmAllocate(sizeof(SUBAUTHENTICATION_DLL));

    if ( SubAuthenticationDll == NULL ) {
        *SubStatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    SubAuthenticationDll->DllNumber = DllNumber;
    SubAuthenticationDll->SubAuthenticationRoutine = SubAuthenticationRoutine;
    SubAuthenticationDll->SubAuthenticationRoutineEx = SubAuthenticationRoutineEx;
    SubAuthenticationDll->SubAuthenticationRoutineGeneric = SubAuthenticationRoutineGeneric;

    RtlAcquireResourceExclusive(&SubAuthenticationCritSect, TRUE);
    InsertHeadList( &SubAuthenticationDlls, &SubAuthenticationDll->Next );
    RtlReleaseResource(&SubAuthenticationCritSect);

    DllHandle = NULL;

    //
    // Cleanup up before returning.
    //

Cleanup:


    if ( ParmHandle != NULL ) {
        RegCloseKey( ParmHandle );
    }

    if ( !NT_SUCCESS( *SubStatus) ) {
        if ( DllHandle != NULL ) {
            FreeLibrary( DllHandle );
        }
    }

    return SubAuthenticationDll;
}


BOOLEAN
Msv1_0SubAuthenticationPresent(
    IN ULONG DllNumber
)
/*++

Routine Description:

    Returns TRUE if there is a subauthentication package with the given number

Arguments:

    DllNumber - the number of the DLL to check

Return Value:

    TRUE if there is a subauthentication DLL, otherwise FALSE.

--*/
{
    NTSTATUS SubStatus;
    BOOLEAN Present;

    if(ReferenceSubAuth( DllNumber, &SubStatus) != NULL) {
        Present = TRUE;
    } else {
        Present = FALSE;
    }

    return Present;
}


NTSTATUS
Msv1_0SubAuthenticationRoutineZero(
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG Flags,
    IN PUSER_ALL_INFORMATION UserAll,
    OUT PULONG WhichFields,
    OUT PULONG UserFlags,
    OUT PBOOLEAN Authoritative,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
    )
{
    PNETLOGON_LOGON_IDENTITY_INFO LogonInfo;
    ULONG DllNumber;

    LogonInfo = (PNETLOGON_LOGON_IDENTITY_INFO) LogonInformation;
    DllNumber = LogonInfo->ParameterControl >> MSV1_0_SUBAUTHENTICATION_DLL_SHIFT;

    if( DllNumber != 0 ) {
        return STATUS_SUCCESS;
    }

    return Msv1_0SubAuthenticationRoutine(
                    LogonLevel,
                    LogonInformation,
                    Flags,
                    UserAll,
                    WhichFields,
                    UserFlags,
                    Authoritative,
                    LogoffTime,
                    KickoffTime
                    );
}



NTSTATUS
Msv1_0SubAuthenticationRoutine(
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG Flags,
    IN PUSER_ALL_INFORMATION UserAll,
    OUT PULONG WhichFields,
    OUT PULONG UserFlags,
    OUT PBOOLEAN Authoritative,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
)
/*++

Routine Description:

    The subauthentication routine does client/server specific authentication
    of a user.  This stub routine loads the appropriate subauthentication
    package DLL and calls out to that DLL to do the actuall validation.

Arguments:

    LogonLevel -- Specifies the level of information given in
        LogonInformation.

    LogonInformation -- Specifies the description for the user
        logging on.  The LogonDomainName field should be ignored.

    Flags - Flags describing the circumstances of the logon.

        MSV1_0_PASSTHRU -- This is a PassThru authenication.  (i.e., the
            user isn't connecting to this machine.)
        MSV1_0_GUEST_LOGON -- This is a retry of the logon using the GUEST
            user account.

    UserAll -- The description of the user as returned from SAM.

    WhichFields -- Returns which fields from UserAllInfo are to be written
        back to SAM.  The fields will only be written if MSV returns success
        to it's caller.  Only the following bits are valid.

        USER_ALL_PARAMETERS - Write UserAllInfo->Parameters back to SAM.  If
            the size of the buffer is changed, Msv1_0SubAuthenticationRoutine
            must delete the old buffer using MIDL_user_free() and reallocate the
            buffer using MIDL_user_allocate().

    UserFlags -- Returns UserFlags to be returned from LsaLogonUser in the
        LogonProfile.  The following bits are currently defined:


            LOGON_GUEST -- This was a guest logon
            LOGON_NOENCRYPTION -- The caller didn't specify encrypted credentials
            LOGON_GRACE_LOGON -- The caller's password has expired but logon
                was allowed during a grace period following the expiration.

        SubAuthentication packages should restrict themselves to returning
        bits in the high order byte of UserFlags.  However, this convention
        isn't enforced giving the SubAuthentication package more flexibility.

    Authoritative -- Returns whether the status returned is an
        authoritative status which should be returned to the original
        caller.  If not, this logon request may be tried again on another
        domain controller.  This parameter is returned regardless of the
        status code.

    LogoffTime - Receives the time at which the user should logoff the
        system.  This time is specified as a GMT relative NT system time.

    KickoffTime - Receives the time at which the user should be kicked
        off the system. This time is specified as a GMT relative NT system
        time.  Specify, a full scale positive number if the user isn't to
        be kicked off.

Return Value:

    STATUS_SUCCESS: if there was no error.

    STATUS_NO_SUCH_USER: The specified user has no account.
    STATUS_WRONG_PASSWORD: The password was invalid.

    STATUS_INVALID_INFO_CLASS: LogonLevel is invalid.
    STATUS_ACCOUNT_LOCKED_OUT: The account is locked out
    STATUS_ACCOUNT_DISABLED: The account is disabled
    STATUS_ACCOUNT_EXPIRED: The account has expired.
    STATUS_PASSWORD_MUST_CHANGE: Account is marked as Password must change
        on next logon.
    STATUS_PASSWORD_EXPIRED: The Password is expired.
    STATUS_INVALID_LOGON_HOURS - The user is not authorized to logon at
        this time.
    STATUS_INVALID_WORKSTATION - The user is not authorized to logon to
        the specified workstation.

--*/
{
    NTSTATUS Status;
    NTSTATUS SubStatus;

    ULONG DllNumber;
    PSUBAUTHENTICATION_DLL SubAuthenticationDll;
    PSUBAUTHENTICATION_ROUTINE SubAuthenticationRoutine;

    PNETLOGON_LOGON_IDENTITY_INFO LogonInfo;


    //
    // Initialization
    //

    LogonInfo = (PNETLOGON_LOGON_IDENTITY_INFO) LogonInformation;

    DllNumber = LogonInfo->ParameterControl >> MSV1_0_SUBAUTHENTICATION_DLL_SHIFT;
    *Authoritative = TRUE;

    //
    // Find the SubAuthentication Dll.
    //

    SubAuthenticationDll = ReferenceSubAuth ( DllNumber, &SubStatus);

    //
    // If this was package zero and we didn't find it, remember it for
    // next time.
    //

    if ( (DllNumber == 0) && (SubAuthenticationDll == NULL) ) {
        NlpSubAuthZeroExists = FALSE;
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }


    if (SubStatus != STATUS_SUCCESS)
    {
        SspPrint((SSP_MISC, "SubAuth Error value is %ld.\n", SubStatus));
        Status = SubStatus;
        goto Cleanup;
    }


    //
    // Leave the crit sect while calling the DLL
    //

    SubAuthenticationRoutine = SubAuthenticationDll->SubAuthenticationRoutine;

    if (SubAuthenticationRoutine == NULL)
    {
        if( DllNumber == 0 ) {

            //
            // If this was package zero and we didn't find it, remember it for
            // next time.
            //

            NlpSubAuthZeroExists = FALSE;
            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_PROCEDURE_NOT_FOUND;
        }
        goto Cleanup;
    }

    //
    // Call the actual authentication routine.
    //

    Status = (*SubAuthenticationRoutine)(
                   LogonLevel,
                   LogonInformation,
                   Flags,
                   UserAll,
                   WhichFields,
                   UserFlags,
                   Authoritative,
                   LogoffTime,
                   KickoffTime );

    //
    // Cleanup up before returning.
    //

Cleanup:

    return Status;
}


NTSTATUS
Msv1_0ExportSubAuthenticationRoutine(
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG Flags,
    IN ULONG DllNumber,
    IN PUSER_ALL_INFORMATION UserAll,
    OUT PULONG WhichFields,
    OUT PULONG UserFlags,
    OUT PBOOLEAN Authoritative,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
)
/*++

Routine Description:

    The subauthentication routine does client/server specific authentication
    of a user.  This stub routine loads the appropriate subauthentication
    package DLL and calls out to that DLL to do the actuall validation.

Arguments:

    LogonLevel -- Specifies the level of information given in
        LogonInformation.

    LogonInformation -- Specifies the description for the user
        logging on.  The LogonDomainName field should be ignored.

    Flags -- Flags describing the circumstances of the logon.

        MSV1_0_PASSTHRU -- This is a PassThru authenication.  (i.e., the
            user isn't connecting to this machine.)
        MSV1_0_GUEST_LOGON -- This is a retry of the logon using the GUEST
            user account.

    DllNumber - The number of the subauthentication DLL to call.

    UserAll -- The description of the user as returned from SAM.

    WhichFields -- Returns which fields from UserAllInfo are to be written
        back to SAM.  The fields will only be written if MSV returns success
        to it's caller.  Only the following bits are valid.

        USER_ALL_PARAMETERS - Write UserAllInfo->Parameters back to SAM.  If
            the size of the buffer is changed, Msv1_0SubAuthenticationRoutine
            must delete the old buffer using MIDL_user_free() and reallocate the
            buffer using MIDL_user_allocate().

    UserFlags -- Returns UserFlags to be returned from LsaLogonUser in the
        LogonProfile.  The following bits are currently defined:


            LOGON_GUEST -- This was a guest logon
            LOGON_NOENCRYPTION -- The caller didn't specify encrypted credentials
            LOGON_GRACE_LOGON -- The caller's password has expired but logon
                was allowed during a grace period following the expiration.

        SubAuthentication packages should restrict themselves to returning
        bits in the high order byte of UserFlags.  However, this convention
        isn't enforced giving the SubAuthentication package more flexibility.

    Authoritative -- Returns whether the status returned is an
        authoritative status which should be returned to the original
        caller.  If not, this logon request may be tried again on another
        domain controller.  This parameter is returned regardless of the
        status code.

    LogoffTime - Receives the time at which the user should logoff the
        system.  This time is specified as a GMT relative NT system time.

    KickoffTime - Receives the time at which the user should be kicked
        off the system. This time is specified as a GMT relative NT system
        time.  Specify, a full scale positive number if the user isn't to
        be kicked off.

Return Value:

    STATUS_SUCCESS: if there was no error.

    STATUS_NO_SUCH_USER: The specified user has no account.
    STATUS_WRONG_PASSWORD: The password was invalid.

    STATUS_INVALID_INFO_CLASS: LogonLevel is invalid.
    STATUS_ACCOUNT_LOCKED_OUT: The account is locked out
    STATUS_ACCOUNT_DISABLED: The account is disabled
    STATUS_ACCOUNT_EXPIRED: The account has expired.
    STATUS_PASSWORD_MUST_CHANGE: Account is marked as Password must change
        on next logon.
    STATUS_PASSWORD_EXPIRED: The Password is expired.
    STATUS_INVALID_LOGON_HOURS - The user is not authorized to logon at
        this time.
    STATUS_INVALID_WORKSTATION - The user is not authorized to logon to
        the specified workstation.

--*/
{
    NTSTATUS Status;
    NTSTATUS SubStatus;

    PSUBAUTHENTICATION_DLL SubAuthenticationDll;
    PSUBAUTHENTICATION_ROUTINE SubAuthenticationRoutine;

    PNETLOGON_LOGON_IDENTITY_INFO LogonInfo;


    //
    // Initialization
    //

    LogonInfo = (PNETLOGON_LOGON_IDENTITY_INFO) LogonInformation;

    *Authoritative = TRUE;

    //
    // Find the SubAuthentication Dll.
    //

    SubAuthenticationDll = ReferenceSubAuth ( DllNumber, &SubStatus);

    if (SubStatus != STATUS_SUCCESS)
    {
        SspPrint((SSP_MISC, "SubAuth Error value is %ld.\n", SubStatus));
        Status = SubStatus;
        goto Cleanup;
    }

    //
    // Leave the crit sect while calling the DLL
    //

    SubAuthenticationRoutine = SubAuthenticationDll->SubAuthenticationRoutine;

    if (SubAuthenticationRoutine == NULL)
    {
        Status = STATUS_PROCEDURE_NOT_FOUND;
        goto Cleanup;
    }

    //
    // Call the actual authentication routine.
    //

    Status = (*SubAuthenticationRoutine)(
                   LogonLevel,
                   LogonInformation,
                   Flags,
                   UserAll,
                   WhichFields,
                   UserFlags,
                   Authoritative,
                   LogoffTime,
                   KickoffTime );

    //
    // Cleanup up before returning.
    //

Cleanup:

    return Status;
}



NTSTATUS
Msv1_0SubAuthenticationRoutineEx(
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG Flags,
    IN PUSER_ALL_INFORMATION UserAll,
    IN SAM_HANDLE UserHandle,
    IN OUT PMSV1_0_VALIDATION_INFO ValidationInfo,
    OUT PULONG ActionsPerformed
)
/*++

Routine Description:

    The subauthentication routine does client/server specific authentication
    of a user.  This stub routine loads the appropriate subauthentication
    package DLL and calls out to that DLL to do the actuall validation.

Arguments:

    LogonLevel -- Specifies the level of information given in
        LogonInformation.

    LogonInformation -- Specifies the description for the user
        logging on.  The LogonDomainName field should be ignored.

    Flags - Flags describing the circumstances of the logon.

        MSV1_0_PASSTHRU -- This is a PassThru authenication.  (i.e., the
            user isn't connecting to this machine.)
        MSV1_0_GUEST_LOGON -- This is a retry of the logon using the GUEST
            user account.

    UserAll -- The description of the user as returned from SAM.

    WhichFields -- Returns which fields from UserAllInfo are to be written
        back to SAM.  The fields will only be written if MSV returns success
        to it's caller.  Only the following bits are valid.

        USER_ALL_PARAMETERS - Write UserAllInfo->Parameters back to SAM.  If
            the size of the buffer is changed, Msv1_0SubAuthenticationRoutine
            must delete the old buffer using MIDL_user_free() and reallocate the
            buffer using MIDL_user_allocate().

    UserFlags -- Returns UserFlags to be returned from LsaLogonUser in the
        LogonProfile.  The following bits are currently defined:


            LOGON_GUEST -- This was a guest logon
            LOGON_NOENCRYPTION -- The caller didn't specify encrypted credentials
            LOGON_GRACE_LOGON -- The caller's password has expired but logon
                was allowed during a grace period following the expiration.

        SubAuthentication packages should restrict themselves to returning
        bits in the high order byte of UserFlags.  However, this convention
        isn't enforced giving the SubAuthentication package more flexibility.

    Authoritative -- Returns whether the status returned is an
        authoritative status which should be returned to the original
        caller.  If not, this logon request may be tried again on another
        domain controller.  This parameter is returned regardless of the
        status code.

    LogoffTime - Receives the time at which the user should logoff the
        system.  This time is specified as a GMT relative NT system time.

    KickoffTime - Receives the time at which the user should be kicked
        off the system. This time is specified as a GMT relative NT system
        time.  Specify, a full scale positive number if the user isn't to
        be kicked off.

Return Value:

    STATUS_SUCCESS: if there was no error.

    STATUS_NO_SUCH_USER: The specified user has no account.
    STATUS_WRONG_PASSWORD: The password was invalid.

    STATUS_INVALID_INFO_CLASS: LogonLevel is invalid.
    STATUS_ACCOUNT_LOCKED_OUT: The account is locked out
    STATUS_ACCOUNT_DISABLED: The account is disabled
    STATUS_ACCOUNT_EXPIRED: The account has expired.
    STATUS_PASSWORD_MUST_CHANGE: Account is marked as Password must change
        on next logon.
    STATUS_PASSWORD_EXPIRED: The Password is expired.
    STATUS_INVALID_LOGON_HOURS - The user is not authorized to logon at
        this time.
    STATUS_INVALID_WORKSTATION - The user is not authorized to logon to
        the specified workstation.

--*/
{
    NTSTATUS Status;
    NTSTATUS SubStatus;

    ULONG DllNumber;
    PSUBAUTHENTICATION_DLL SubAuthenticationDll;
    PSUBAUTHENTICATION_ROUTINEEX SubAuthenticationRoutineEx;

    PNETLOGON_LOGON_IDENTITY_INFO LogonInfo;

    //
    // Initialization
    //

    LogonInfo = (PNETLOGON_LOGON_IDENTITY_INFO) LogonInformation;

    DllNumber = LogonInfo->ParameterControl >> MSV1_0_SUBAUTHENTICATION_DLL_SHIFT;


    //
    // Find the SubAuthentication Dll.
    //

    SubAuthenticationDll = ReferenceSubAuth (DllNumber, &SubStatus);;


    if (SubStatus != STATUS_SUCCESS)
    {
        SspPrint((SSP_MISC, "SubAuth Error value is %ld.\n", SubStatus));
        Status = SubStatus;
        goto Cleanup;
    }

    //
    // Leave the crit sect while calling the DLL
    //

    SubAuthenticationRoutineEx = SubAuthenticationDll->SubAuthenticationRoutineEx;

    if (SubAuthenticationRoutineEx == NULL)
    {
        Status = STATUS_PROCEDURE_NOT_FOUND;
        goto Cleanup;
    }
    //
    // Call the actual authentication routine.
    //

    Status = (*SubAuthenticationRoutineEx)(
                   LogonLevel,
                   LogonInformation,
                   Flags,
                   UserAll,
                   UserHandle,
                   ValidationInfo,
                   ActionsPerformed
                   );

    //
    // Cleanup up before returning.
    //

Cleanup:

    return Status;
}

NTSTATUS
MspNtSubAuth(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    )

/*++

Routine Description:

    This routine is the dispatch routine for LsaCallAuthenticationPackage()
    with a message type of MsV1_0SubAuthInfo.

Arguments:

    The arguments to this routine are identical to those of LsaApCallPackage.
    Only the special attributes of these parameters as they apply to
    this routine are mentioned here.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the logon
        could not be completed because the client does not have
        sufficient quota to allocate the return buffer.


--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SubStatus = STATUS_SUCCESS;
    PMSV1_0_SUBAUTH_REQUEST SubAuthRequest;
    PMSV1_0_SUBAUTH_RESPONSE SubAuthResponse;
    CLIENT_BUFFER_DESC ClientBufferDesc;
    ULONG ReturnDataLength = 0;
    PVOID ReturnDataBuffer = NULL;

    PSUBAUTHENTICATION_DLL SubAuthenticationDll;
    PSUBAUTHENTICATION_ROUTINEGENERIC SubAuthenticationRoutineGeneric;

    NlpInitClientBuffer( &ClientBufferDesc, ClientRequest );
    *ProtocolStatus = STATUS_SUCCESS;

    //
    // Ensure the specified Submit Buffer is of reasonable size and
    // relocate all of the pointers to be relative to the LSA allocated
    // buffer.
    //

    if ( SubmitBufferSize < sizeof(MSV1_0_SUBAUTH_REQUEST) ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    SubAuthRequest = (PMSV1_0_SUBAUTH_REQUEST) ProtocolSubmitBuffer;

    //
    // Make sure the buffer fits in the supplied size
    //

    if (SubAuthRequest->SubAuthSubmitBuffer != NULL) {
        if (SubAuthRequest->SubAuthSubmitBuffer + SubAuthRequest->SubAuthInfoLength >
            (PUCHAR) ClientBufferBase + SubmitBufferSize) {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        //
        // Reset the pointers for the validation data
        //

        SubAuthRequest->SubAuthSubmitBuffer =
                (PUCHAR) SubAuthRequest -
                (ULONG_PTR) ClientBufferBase +
                (ULONG_PTR) SubAuthRequest->SubAuthSubmitBuffer;

    }

    // If subauth package found, call the routine,


    //
    // Find the SubAuthentication Dll.
    //

    SubAuthenticationDll = ReferenceSubAuth (SubAuthRequest->SubAuthPackageId, &SubStatus);;


    if (SubStatus != STATUS_SUCCESS)
    {
        SspPrint((SSP_MISC, "SubAuth Error value is %ld.\n", SubStatus));
        Status = SubStatus;
        goto Cleanup;
    }

    //
    // Leave the crit sect while calling the DLL
    //

    SubAuthenticationRoutineGeneric = SubAuthenticationDll->SubAuthenticationRoutineGeneric;

    if (SubAuthenticationRoutineGeneric == NULL)
    {
        Status = STATUS_PROCEDURE_NOT_FOUND;
        goto Cleanup;
    }
    Status = (*SubAuthenticationRoutineGeneric)(
                           (PVOID) SubAuthRequest->SubAuthSubmitBuffer,
                           SubAuthRequest->SubAuthInfoLength,
                           &ReturnDataLength,
                           &ReturnDataBuffer);

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Allocate a buffer to return to the caller.
    //

    *ReturnBufferSize = sizeof(MSV1_0_SUBAUTH_RESPONSE) +
                        ReturnDataLength;

    Status = NlpAllocateClientBuffer( &ClientBufferDesc,
                                      sizeof(MSV1_0_SUBAUTH_RESPONSE),
                                      *ReturnBufferSize );


    if ( !NT_SUCCESS( Status ) ) {
        goto Cleanup;
    }

    SubAuthResponse = (PMSV1_0_SUBAUTH_RESPONSE) ClientBufferDesc.MsvBuffer;

    //
    // Fill in the return buffer.
    //

    SubAuthResponse->MessageType = MsV1_0SubAuth;
    SubAuthResponse->SubAuthInfoLength = ReturnDataLength;

    if (ReturnDataLength > 0)
    {
        SubAuthResponse->SubAuthReturnBuffer = ClientBufferDesc.UserBuffer + sizeof(MSV1_0_SUBAUTH_RESPONSE);

        if (ReturnDataBuffer)
        {
            RtlCopyMemory(
                SubAuthResponse + 1,
                ReturnDataBuffer,
                ReturnDataLength
                );

            // Make relative pointers
            SubAuthResponse->SubAuthReturnBuffer = (PUCHAR) sizeof(MSV1_0_SUBAUTH_RESPONSE);
        }
        else
        {
            SubAuthResponse->SubAuthReturnBuffer = NULL;
            SubStatus = STATUS_NO_MEMORY;
        }
    }
    else
    {
        SubAuthResponse->SubAuthReturnBuffer = 0;
    }


    //
    // Flush the buffer to the client's address space.
    //

    Status = NlpFlushClientBuffer( &ClientBufferDesc,
                                   ProtocolReturnBuffer );


Cleanup:

    if (ReturnDataBuffer != NULL) {
        MIDL_user_free(ReturnDataBuffer);
    }

    if ( !NT_SUCCESS(Status)) {
        NlpFreeClientBuffer( &ClientBufferDesc );
    }

    *ProtocolStatus = SubStatus;
    return(Status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\trace.h ===
#ifndef _TRACE_H
#define _TRACE_H
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    trace.h

Abstract:

    Include file to contain variables required for event tracing 
    for NTLM

Author:

    15-June-2000  Jason Clark

Revision History:

--*/

//
//
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wtypes.h>

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

#include <wmistr.h>
#include <evntrace.h>

#ifdef __cplusplus
}
#endif // __cplusplus

EXTERN_C BOOL             NtlmGlobalEventTraceFlag;
EXTERN_C TRACEHANDLE      NtlmGlobalTraceRegistrationHandle;
EXTERN_C TRACEHANDLE      NtlmGlobalTraceLoggerHandle;

EXTERN_C
ULONG
NtlmInitializeTrace();

// Helper macros for populating the trace
#define SET_TRACE_DATA(TraceVar, MofNum, Data) \
    {   \
        TraceVar.eventInfo[MofNum].DataPtr = (ULONGLONG) &Data; \
        TraceVar.eventInfo[MofNum].Length = sizeof(Data); \
    }
    
#define SET_TRACE_DATAPTR(TraceVar, MofNum, Data) \
    {   \
        TraceVar.eventInfo[MofNum].DataPtr = (ULONGLONG) Data; \
        TraceVar.eventInfo[MofNum].Length = sizeof(*Data); \
    }
    
#define SET_TRACE_USTRING(TraceVar, MofNum, UString) \
    {   \
        TraceVar.eventInfo[MofNum].DataPtr = (ULONGLONG) &UString.Length; \
        TraceVar.eventInfo[MofNum].Length = sizeof(UString.Length) ; \
        TraceVar.eventInfo[MofNum+1].DataPtr = (ULONGLONG) UString.Buffer; \
        TraceVar.eventInfo[MofNum+1].Length = UString.Length ; \
    }
    
#define SET_TRACE_HEADER(TraceVar, TheGuid, TheType, TheFlags, NumMofs) \
    { \
        TraceVar.EventTrace.Guid = TheGuid; \
        TraceVar.EventTrace.Class.Type = TheType; \
        TraceVar.EventTrace.Flags = TheFlags; \
        TraceVar.EventTrace.Size = sizeof(EVENT_TRACE_HEADER)+ \
            sizeof(MOF_FIELD) * NumMofs ; \
    }
    
// Helper defines for populating the Init/Accept trace
#define TRACE_INITACC_STAGEHINT      0
#define TRACE_INITACC_INCONTEXT      1
#define TRACE_INITACC_OUTCONTEXT     2
#define TRACE_INITACC_STATUS         3
#define TRACE_INITACC_CLIENTNAME     4
#define TRACE_INITACC_CLIENTDOMAIN   6
#define TRACE_INITACC_WORKSTATION    8

// Helper defines for populating the Logon trace
#define TRACE_LOGON_STATUS          0
#define TRACE_LOGON_TYPE            1
#define TRACE_LOGON_USERNAME        2
#define TRACE_LOGON_DOMAINNAME      4

// Helper defines for populating the Validate trace
#define TRACE_VALIDATE_SUCCESS      0
#define TRACE_VALIDATE_SERVER       1
#define TRACE_VALIDATE_DOMAIN       3
#define TRACE_VALIDATE_USERNAME     5
#define TRACE_VALIDATE_WORKSTATION  7

// Helper defines for populating the Passthrough trace
#define TRACE_PASSTHROUGH_DOMAIN    0
#define TRACE_PASSTHROUGH_PACKAGE   2

// Accept stage hints
#define TRACE_ACCEPT_NEGOTIATE 1
#define TRACE_ACCEPT_AUTHENTICATE 2
#define TRACE_ACCEPT_INFO 3

// Init stage hints
#define TRACE_INIT_FIRST 1
#define TRACE_INIT_CHALLENGE 2

// The current limit is 16 MOF fields.
// Each UNICODE strings needs two MOF fields.

typedef struct _NTLM_TRACE_INFO
{
    EVENT_TRACE_HEADER EventTrace;
   
    MOF_FIELD eventInfo[MAX_MOF_FIELDS];
} NTLM_TRACE_INFO, *PNTLM_TRACE_INFO;


//
// This is the control Guid for the group of Guids traced below
//

DEFINE_GUID( // {C92CF544-91B3-4dc0-8E11-C580339A0BF8}
    NtlmControlGuid,  
    0xc92cf544, 
    0x91b3, 
    0x4dc0, 
    0x8e, 0x11, 0xc5, 0x80, 0x33, 0x9a, 0xb, 0xf8);

//
// This is the Accept guid
//
   
DEFINE_GUID( // {94D4C9EB-0D01-41ae-99E8-15B26B593A83}
    NtlmAcceptGuid, 
    0x94d4c9eb, 
    0xd01, 
    0x41ae, 
    0x99, 0xe8, 0x15, 0xb2, 0x6b, 0x59, 0x3a, 0x83);

//
// This is the Initialize guid
//

DEFINE_GUID( // {6DF28B22-73BE-45cc-BA80-8B332B35A21D}
    NtlmInitializeGuid, 
    0x6df28b22, 
    0x73be, 
    0x45cc, 
    0xba, 0x80, 0x8b, 0x33, 0x2b, 0x35, 0xa2, 0x1d);


//
// This is the LogonUser guid
//

DEFINE_GUID( // {19196B33-A302-4c12-9D5A-EAC149E93C46}
    NtlmLogonGuid, 
    0x19196b33, 
    0xa302, 
    0x4c12, 
    0x9d, 0x5a, 0xea, 0xc1, 0x49, 0xe9, 0x3c, 0x46);

//
// This is the NTLM Password Validate
//

DEFINE_GUID( // {34D84181-C28A-41d8-BB9E-995190DF83DF}
    NtlmValidateGuid,
    0x34d84181, 
    0xc28a, 
    0x41d8, 
    0xbb, 0x9e, 0x99, 0x51, 0x90, 0xdf, 0x83, 0xdf);
    
//    
// This is the GenericPassthrough Trace Guid
//

DEFINE_GUID( // {21ABB5D9-8EEC-46e4-9D1C-F09DD57CF70B}
    NtlmGenericPassthroughGuid, 
    0x21abb5d9, 
    0x8eec, 
    0x46e4, 
    0x9d, 0x1c, 0xf0, 0x9d, 0xd5, 0x7c, 0xf7, 0xb);




#endif /* _TRACE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\pwdtest.c ===
/*--

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    pwdtest.c

Abstract:

    Test program for the changing passwords.

Author:

    30-Apr-1993 (cliffv)

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:
 Chandana Surlu         21-Jul-96      Stolen from \\kernel\razzle3\src\security\msv1_0\pwdtest.c


--*/


//
// Common include files.
//

#include <msp.h>
#define NLP_ALLOCATE
#include <nlp.h>
#include <lsarpc.h>     // Lsar routines
#include <lsaisrv.h>    // LsaIFree and Trusted Client Routines
#include <stdio.h>


//
// Dummy routines from LSA
//

NTSTATUS
LsapAllocateClientBuffer (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN ULONG LengthRequired,
    OUT PVOID *ClientBaseAddress
    )

{

    UNREFERENCED_PARAMETER (ClientRequest);
    *ClientBaseAddress = RtlAllocateHeap( MspHeap, 0, LengthRequired );

    if ( *ClientBaseAddress == NULL ) {
        return(STATUS_QUOTA_EXCEEDED);
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
LsapFreeClientBuffer (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ClientBaseAddress OPTIONAL
    )
{
    UNREFERENCED_PARAMETER (ClientRequest);
    UNREFERENCED_PARAMETER (ClientBaseAddress);

    return(STATUS_SUCCESS);
}


NTSTATUS
LsapCopyToClientBuffer (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN ULONG Length,
    IN PVOID ClientBaseAddress,
    IN PVOID BufferToCopy
    )

{
    UNREFERENCED_PARAMETER (ClientRequest);
    RtlMoveMemory( ClientBaseAddress, BufferToCopy, Length );
    return(STATUS_SUCCESS);
}


int __cdecl
main(
    IN int argc,
    IN char ** argv
    )
/*++

Routine Description:

    Drive the password changing.

Arguments:

    argc - the number of command-line arguments.

    argv - an array of pointers to the arguments.

Return Value:

    Exit status

--*/
{
    NTSTATUS Status;
    MSV1_0_CHANGEPASSWORD_REQUEST Request;
    PMSV1_0_CHANGEPASSWORD_RESPONSE ReturnBuffer;
    ULONG ReturnBufferSize;
    NTSTATUS ProtocolStatus;
    OBJECT_ATTRIBUTES LSAObjectAttributes;
    UNICODE_STRING LocalComputerName = { 0, 0, NULL };
    PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomainInfo = NULL;

    if ( argc < 5 ) {
        fprintf( stderr,
            "Usage: pwdtest DomainName UserName OldPassword NewPassword\n" );
        return(1);
    }

    //
    // Set up MSV1_0.dll environment.
    //

    MspHeap = RtlProcessHeap();

    Status = NlInitialize();

    if ( !NT_SUCCESS( Status ) ) {
        printf("pwdtest: NlInitialize failed, status %x\n", Status);
        return(1);
    }

    Lsa.AllocateClientBuffer = LsapAllocateClientBuffer;
    Lsa.FreeClientBuffer = LsapFreeClientBuffer;
    Lsa.CopyToClientBuffer = LsapCopyToClientBuffer;



    //
    // Open the LSA policy database in case change password needs it
    //

    InitializeObjectAttributes( &LSAObjectAttributes,
                                  NULL,             // Name
                                  0,                // Attributes
                                  NULL,             // Root
                                  NULL );           // Security Descriptor

    Status = LsaOpenPolicy( &LocalComputerName,
                            &LSAObjectAttributes,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            &NlpPolicyHandle );

    if( !NT_SUCCESS(Status) ) {
        printf("pwdtest: LsaOpenPolicy failed, status %x\n", Status);
        return(1);
    }


    //
    // Get the name of our domain.
    //

    Status = LsaQueryInformationPolicy(
                    NlpPolicyHandle,
                    PolicyPrimaryDomainInformation,
                    (PVOID *) &PrimaryDomainInfo );

    if( !NT_SUCCESS(Status) ) {
        KdPrint(("pwdtest: LsaQueryInformationPolicy failed, status %x\n",
                 Status));
        return(1);
    }

    NlpSamDomainName = PrimaryDomainInfo->Name;



    //
    // Build the request message
    //

    Request.MessageType = MsV1_0ChangePassword;
    RtlCreateUnicodeStringFromAsciiz( &Request.DomainName, argv[1] );
    RtlCreateUnicodeStringFromAsciiz( &Request.AccountName, argv[2] );
    RtlCreateUnicodeStringFromAsciiz( &Request.OldPassword, argv[3] );
    RtlCreateUnicodeStringFromAsciiz( &Request.NewPassword, argv[4] );

    Status = MspLm20ChangePassword( NULL,
                                    &Request,
                                    &Request,
                                    0x7FFFFFFF,
                                    (PVOID *) &ReturnBuffer,
                                    &ReturnBufferSize,
                                    &ProtocolStatus );

    printf( "Status = 0x%lx  0x%lx\n", Status, ProtocolStatus );

    if ( ProtocolStatus == STATUS_CANT_DISABLE_MANDATORY ) {
        printf( "Are you running as SYSTEM?\n" );
    }

    if ( ReturnBufferSize != 0 ) {
        printf( "PasswordInfoValid %ld\n", ReturnBuffer->PasswordInfoValid );
        if ( ReturnBuffer->PasswordInfoValid ) {
            printf( "Min length: %ld  PasswordHistory: %ld  Prop 0x%lx\n",
                ReturnBuffer->DomainPasswordInfo.MinPasswordLength,
                ReturnBuffer->DomainPasswordInfo.PasswordHistoryLength,
                ReturnBuffer->DomainPasswordInfo.PasswordProperties );
        }
    }
    return 0;


}


//
// Stub routines needed by msvpaswd.c
//

NTSTATUS
LsarQueryInformationPolicy(
    IN LSAPR_HANDLE PolicyHandle,
    IN POLICY_INFORMATION_CLASS InfoClass,
    OUT PLSAPR_POLICY_INFORMATION *Buffer
    )
{
    return( LsaQueryInformationPolicy( PolicyHandle,
                                       InfoClass,
                                       Buffer ) );
}

VOID
LsaIFree_LSAPR_POLICY_INFORMATION (
    POLICY_INFORMATION_CLASS InfoClass,
    PLSAPR_POLICY_INFORMATION Buffer
    )
{
    UNREFERENCED_PARAMETER (InfoClass);
    UNREFERENCED_PARAMETER (Buffer);
}

NTSTATUS
NlpChangePassword(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING UserName,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PNT_OWF_PASSWORD NtOwfPassword
    )
{
    UNREFERENCED_PARAMETER (DomainName);
    UNREFERENCED_PARAMETER (UserName);
    UNREFERENCED_PARAMETER (LmOwfPassword);
    UNREFERENCED_PARAMETER (NtOwfPassword);
    return(STATUS_SUCCESS);
}



NTSTATUS
NlInitialize(
    VOID
    )

/*++

Routine Description:

    Initialize NETLOGON portion of msv1_0 authentication package.

Arguments:

    None.

Return Status:

    STATUS_SUCCESS - Indicates NETLOGON successfully initialized.

--*/

{
    NTSTATUS Status;
    LPWSTR ComputerName;
    DWORD ComputerNameLength = MAX_COMPUTERNAME_LENGTH + 1;
    NT_PRODUCT_TYPE NtProductType;
    UNICODE_STRING TempUnicodeString;

    //
    // Initialize global data
    //

    NlpEnumerationHandle = 0;
    NlpSessionCount = 0;

    NlpComputerName.Buffer = NULL;
    NlpSamDomainName.Buffer = NULL;
    NlpSamDomainId = NULL;
    NlpSamDomainHandle = NULL;



    //
    // Get the name of this machine.
    //

    ComputerName = RtlAllocateHeap(
                        MspHeap, 0,
                        ComputerNameLength * sizeof(WCHAR) );

    if (ComputerName == NULL ||
        !GetComputerNameW( ComputerName, &ComputerNameLength )) {

        KdPrint(( "MsV1_0: Cannot get computername %lX\n", GetLastError() ));

        NlpLanmanInstalled = FALSE;
        RtlFreeHeap( MspHeap, 0, ComputerName );
        ComputerName = NULL;
    } else {

        NlpLanmanInstalled = TRUE;
    }

    RtlInitUnicodeString( &NlpComputerName, ComputerName );

    //
    // Determine if this machine is running Windows NT or Lanman NT.
    //  LanMan NT runs on a domain controller.
    //

    if ( !RtlGetNtProductType( &NtProductType ) ) {
        KdPrint(( "MsV1_0: Nt Product Type undefined (WinNt assumed)\n" ));
        NtProductType = NtProductWinNt;
    }

    NlpWorkstation = (BOOLEAN)(NtProductType != NtProductLanManNt);


#ifdef notdef

    //
    // Initialize any locks.
    //

    RtlInitializeCriticalSection(&NlpActiveLogonLock);
    RtlInitializeCriticalSection(&NlpSessionCountLock);

    //
    // initialize the cache - creates a critical section is all
    //

    NlpCacheInitialize();
#endif // notdef


    //
    // Attempt to load Netapi.dll
    //

    NlpLoadNetapiDll();

#ifdef COMPILED_BY_DEVELOPER
    KdPrint(("msv1_0: COMPILED_BY_DEVELOPER breakpoint.\n"));
    DbgBreakPoint();
#endif // COMPILED_BY_DEVELOPER



    //
    // Initialize useful encryption constants
    //

    Status = RtlCalculateLmOwfPassword( "", &NlpNullLmOwfPassword );
    ASSERT( NT_SUCCESS(Status) );

    RtlInitUnicodeString(&TempUnicodeString, NULL);
    Status = RtlCalculateNtOwfPassword(&TempUnicodeString,
                                       &NlpNullNtOwfPassword);
    ASSERT( NT_SUCCESS(Status) );




#ifdef notdef
    //
    // If we weren't successful,
    //  Clean up global resources we intended to initialize.
    //

    if ( !NT_SUCCESS(Status) ) {
        if ( NlpComputerName.Buffer != NULL ) {
            MIDL_user_free( NlpComputerName.Buffer );
        }

    }
#endif // notdef

    return STATUS_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\userapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1999
//
// File:        userapi.cxx
//
// Contents:    User-mode APIs to the NtLm security package
//
//              Main user mode entry points into this dll:
//                SpUserModeInitialize
//                SpInstanceInit
//                SpDeleteUserModeContext
//                SpInitUserModeContext
//                SpMakeSignature
//                SpVerifySignature
//                SpSealMessage
//                SpUnsealMessage
//                SpGetContextToken
//                SpQueryContextAttributes
//                SpCompleteAuthToken
//                SpFormatCredentials
//                SpMarshallSupplementalCreds
//                SpExportSecurityContext
//                SpImportSecurityContext
//
//              Helper functions:
//                ReferenceUserContext
//                FreeUserContext
//                DereferenceUserContext
//                SspGenCheckSum
//                SspEncryptBuffer
//                NtLmMakePackedContext(this is called in the client's process)
//                NtLmCreateUserModeContext
//                SspGetTokenUser
//                SspCreateTokenDacl
//                SspMapContext (this is called in Lsa mode)
//
// History:     ChandanS 26-Jul-1996   Stolen from kerberos\client2\userapi.cxx
//
//------------------------------------------------------------------------
#include <global.h> // Globals!
#include "crc32.h"  // How to use crc32

extern "C"
{
#include <nlp.h>
}

// Keep this is sync with NTLM_KERNEL_CONTEXT defined in
// security\msv_sspi\kernel\krnlapi.cxx

typedef struct _NTLM_CLIENT_CONTEXT{
    union {
    LIST_ENTRY           Next;
    KSEC_LIST_ENTRY      KernelNext;
    };
    ULONG_PTR            LsaContext;
    ULONG                NegotiateFlags;
    HANDLE               ClientTokenHandle;
    PACCESS_TOKEN        AccessToken;
    PULONG                  pSendNonce;      // ptr to nonce to use for send
    PULONG                  pRecvNonce;      // ptr to nonce to use for receive
    struct RC4_KEYSTRUCT *  pSealRc4Sched;   // ptr to key sched used for Seal
    struct RC4_KEYSTRUCT *  pUnsealRc4Sched; // ptr to key sched used to Unseal
    ULONG                   SendNonce;
    ULONG                   RecvNonce;
    LPWSTR                  ContextNames;
    PUCHAR                  pbMarshalledTargetInfo;
    ULONG                   cbMarshalledTargetInfo;
    UCHAR                SessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];
    ULONG                ContextSignature;
    ULONG                References ;
    TimeStamp            PasswordExpiry;
    ULONG                UserFlags;
    UCHAR                   SignSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];
    UCHAR                   VerifySessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];
    UCHAR                   SealSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];
    UCHAR                   UnsealSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];

    ULONG64                 Pad1;           // pad keystructs to 64.
    struct RC4_KEYSTRUCT    SealRc4Sched;   // key struct used for Seal
    ULONG64                 Pad2;           // pad keystructs to 64.
    struct RC4_KEYSTRUCT    UnsealRc4Sched; // key struct used to Unseal
} NTLM_CLIENT_CONTEXT, * PNTLM_CLIENT_CONTEXT;

typedef struct _NTLM_PACKED_CONTEXT {
    ULONG   Tag ;
    ULONG   NegotiateFlags ;
    ULONG   ClientTokenHandle ;
    ULONG   SendNonce ;
    ULONG   RecvNonce ;
    UCHAR   SessionKey[ MSV1_0_USER_SESSION_KEY_LENGTH ];
    ULONG   ContextSignature ;
    TimeStamp   PasswordExpiry ;
    ULONG   UserFlags ;
    ULONG   ContextNames ;
    ULONG   ContextNameLength ;
    ULONG   MarshalledTargetInfo;       // offset
    ULONG   MarshalledTargetInfoLength;
    UCHAR   SignSessionKey[ MSV1_0_USER_SESSION_KEY_LENGTH ];
    UCHAR   VerifySessionKey[ MSV1_0_USER_SESSION_KEY_LENGTH ];
    UCHAR   SealSessionKey[ MSV1_0_USER_SESSION_KEY_LENGTH ];
    UCHAR   UnsealSessionKey[ MSV1_0_USER_SESSION_KEY_LENGTH ];
    struct RC4_KEYSTRUCT    SealRc4Sched;   
    struct RC4_KEYSTRUCT    UnsealRc4Sched;
} NTLM_PACKED_CONTEXT, * PNTLM_PACKED_CONTEXT ;

#define NTLM_PACKED_CONTEXT_MAP     0
#define NTLM_PACKED_CONTEXT_EXPORT  1

#define CSSEALMAGIC "session key to client-to-server sealing key magic constant"
#define SCSEALMAGIC "session key to server-to-client sealing key magic constant"
#define CSSIGNMAGIC "session key to client-to-server signing key magic constant"
#define SCSIGNMAGIC "session key to server-to-client signing key magic constant"



#define             NTLM_USERLIST_COUNT         (16)    // count of lists
#define             NTLM_USERLIST_LOCK_COUNT    (2)     // count of locks

LIST_ENTRY          NtLmUserContextList[ NTLM_USERLIST_COUNT ];         // list array.
ULONG               NtLmUserContextCount[ NTLM_USERLIST_COUNT ];        // count of active contexts
RTL_RESOURCE        NtLmUserContextLock[ NTLM_USERLIST_LOCK_COUNT ];    // lock array


// Counter for exported handles;never de-refed
// Should probably do a GetSystemInfo and get a space of handles that cannot
// be valid in the Lsa process
ULONG_PTR ExportedContext = 0;

NTSTATUS
SspCreateTokenDacl(
    HANDLE Token
    );

ULONG
HandleToListIndex(
    ULONG_PTR ContextHandle
    );

ULONG
__inline
ListIndexToLockIndex(
    ULONG ListIndex
    );


//+-------------------------------------------------------------------------
//
//  Function:   SpUserModeInitialize
//
//  Synopsis:   Initialize an the MSV1_0 DLL in  a client's
//              address space
//
//  Effects:
//
//  Arguments:  LsaVersion - Version of the security dll loading the package
//              PackageVersion - Version of the MSV1_0 package
//              UserFunctionTable - Receives a copy of Kerberos's user mode
//                  function table
//              pcTables - Receives count of tables returned.
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS
//
//  Notes: we do what was done in SspInitLocalContexts()
//         from net\svcdlls\ntlmssp\client\sign.c and more.
//
//
//--------------------------------------------------------------------------
NTSTATUS
SEC_ENTRY
SpUserModeInitialize(
    IN ULONG    LsaVersion,
    OUT PULONG  PackageVersion,
    OUT PSECPKG_USER_FUNCTION_TABLE * UserFunctionTable,
    OUT PULONG  pcTables
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

#if DBG
    SspGlobalDbflag = SSP_CRITICAL;
    if( NtLmState != NtLmLsaMode )
    {
        InitializeCriticalSection(&SspGlobalLogFileCritSect);
    }
#endif

    if (LsaVersion != SECPKG_INTERFACE_VERSION)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    *PackageVersion = SECPKG_INTERFACE_VERSION;

    NtLmUserFunctionTable.InstanceInit = SpInstanceInit;
    NtLmUserFunctionTable.MakeSignature = SpMakeSignature;
    NtLmUserFunctionTable.VerifySignature = SpVerifySignature;
    NtLmUserFunctionTable.SealMessage = SpSealMessage;
    NtLmUserFunctionTable.UnsealMessage = SpUnsealMessage;
    NtLmUserFunctionTable.GetContextToken = SpGetContextToken;
    NtLmUserFunctionTable.QueryContextAttributes = SpQueryContextAttributes;
    NtLmUserFunctionTable.CompleteAuthToken = SpCompleteAuthToken;
    NtLmUserFunctionTable.InitUserModeContext = SpInitUserModeContext;
    NtLmUserFunctionTable.DeleteUserModeContext = SpDeleteUserModeContext;
    NtLmUserFunctionTable.FormatCredentials = SpFormatCredentials;
    NtLmUserFunctionTable.MarshallSupplementalCreds = SpMarshallSupplementalCreds;
    NtLmUserFunctionTable.ExportContext = SpExportSecurityContext;
    NtLmUserFunctionTable.ImportContext = SpImportSecurityContext;

    *UserFunctionTable = &NtLmUserFunctionTable;
    *pcTables = 1;


    if ( NtLmState != NtLmLsaMode)
    {
        //
        // SafeAllocaInitialize was already called in SpLsaModeInitialize
        //

        SafeAllocaInitialize(SAFEALLOCA_USE_DEFAULT,
                             SAFEALLOCA_USE_DEFAULT,
                             NtLmAllocate,
                             NtLmFree);
    }

Cleanup:

    return(SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));
}



//+-------------------------------------------------------------------------
//
//  Function:   ReferenceUserContext
//
//  Synopsis:   locates a user context in the list, refrences it
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:    the context, if it is found, else NULL
//
//  Notes: This was SspContextReferenceContext() in
//         net\svcdlls\ntlmssp\common\context.c
//
//
//--------------------------------------------------------------------------
PNTLM_CLIENT_CONTEXT
ReferenceUserContext(
    IN ULONG_PTR ContextHandle,
    IN BOOLEAN RemoveContext )
{
    SspPrint(( SSP_API_MORE, "Entering ReferenceUserContext for 0x%x\n", ContextHandle ));
    PLIST_ENTRY ListEntry;
    PNTLM_CLIENT_CONTEXT pContext = NULL;
    ULONG ListIndex;
    ULONG LockIndex;

    ListIndex = HandleToListIndex( ContextHandle );
    LockIndex = ListIndexToLockIndex( ListIndex );

    RtlAcquireResourceShared(&NtLmUserContextLock[LockIndex], TRUE);

    //
    // Look for a match for the LsaContext, not user context
    //

    for (ListEntry = NtLmUserContextList[ListIndex].Flink;
         ListEntry != &NtLmUserContextList[ListIndex];
         ListEntry = ListEntry->Flink ) {

        pContext = CONTAINING_RECORD(ListEntry, NTLM_CLIENT_CONTEXT, Next );


        if (pContext->LsaContext != ContextHandle)
        {
            continue;
        }

        //
        // Found it!
        //

        if (!RemoveContext)
        {
            InterlockedIncrement( (PLONG)&pContext->References );
            RtlReleaseResource(&NtLmUserContextLock[LockIndex]);
        }
        else
        {
            RtlConvertSharedToExclusive(&NtLmUserContextLock[LockIndex]);
            
            RemoveEntryList (&pContext->Next);
            NtLmUserContextCount[ListIndex]--;
            
            RtlReleaseResource(&NtLmUserContextLock[LockIndex]);

            SspPrint(( SSP_API_MORE, "Delinked Context 0x%lx\n", pContext ));
        }

        SspPrint(( SSP_API_MORE, "Leaving ReferenceUserContext for 0x%x\n", ContextHandle));
        return pContext;
    }


    // No match found

    RtlReleaseResource(&NtLmUserContextLock[LockIndex]);
    SspPrint(( SSP_API_MORE, "Leaving ReferenceUserContext for 0x%x\n", ContextHandle ));
    return NULL;
}

//+-------------------------------------------------------------------------
//
//  Function:   FreeUserContext
//
//  Synopsis:   frees alloced pointers in this context and
//              then frees the context
//
//  Arguments:  lContext  - the unlinked user context
//
//  Returns:    STATUS_SUCCESS on success
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
FreeUserContext (
    PNTLM_CLIENT_CONTEXT UserContext
    )
{
    SspPrint(( SSP_API_MORE, "Entering FreeUserContext for context 0x%x\n", UserContext ));

    NTSTATUS Status = STATUS_SUCCESS;

    if (UserContext->ContextNames != NULL)
    {
        NtLmFree (UserContext->ContextNames);
    }

    if (UserContext->ClientTokenHandle != NULL)
    {
        NTSTATUS IgnoreStatus;
        IgnoreStatus = NtClose(UserContext->ClientTokenHandle);
        ASSERT (NT_SUCCESS (IgnoreStatus));
    }

    SspPrint(( SSP_API_MORE, "Deleting Context 0x%x\n", UserContext));

    ZeroMemory( UserContext, sizeof(*UserContext) );
    NtLmFree (UserContext);

    SspPrint(( SSP_API_MORE, "Leaving FreeUserContext for context 0x%x, status = 0x%x\n", Status ));

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   DereferenceUserContext
//
//  Synopsis:   frees alloced elements in the context, frees context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:     None
//
//  Notes: This was SspContextDereferenceContext() in
//         net\svcdlls\ntlmssp\common\context.c
//
//
//--------------------------------------------------------------------------
NTSTATUS
DereferenceUserContext (
    PNTLM_CLIENT_CONTEXT pContext
    )
{
    SspPrint(( SSP_API_MORE, "Entering DereferenceUserContext 0x%lx\n", pContext ));
    NTSTATUS Status = STATUS_SUCCESS;

    LONG References;

    //
    // Decrement the reference count
    //

///    RtlAcquireResourceShared(&NtLmUserContextLock, TRUE);
////    ASSERT (pContext->References >= 1);
////    References = -- pContext->References;
    References = InterlockedDecrement( (PLONG)&pContext->References );
    ASSERT( References >= 0 );
////    RtlReleaseResource(&NtLmUserContextLock);

    //
    // If the count has dropped to zero, then free all alloced stuff
    //

    if (References == 0)
    {
        Status = FreeUserContext(pContext);
    }
    SspPrint(( SSP_API_MORE, "Leaving DereferenceUserContext\n" ));
    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   SpInstanceInit
//
//  Synopsis:   Initialize an instance of the NtLm package in a client's
//              address space
//
//  Effects:
//
//  Arguments:  Version - Version of the security dll loading the package
//              FunctionTable - Contains helper routines for use by NtLm
//              UserFunctions - Receives a copy of NtLm's user mode
//                  function table
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS
//
//  Notes: we do what was done in SspInitLocalContexts()
//         from net\svcdlls\ntlmssp\client\sign.c and more.
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpInstanceInit(
    IN ULONG Version,
    IN PSECPKG_DLL_FUNCTIONS DllFunctionTable,
    OUT PVOID * UserFunctionTable
    )
{
    SspPrint(( SSP_API, "Entering SpInstanceInit\n" ));
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Index;


    // Save the Alloc/Free functions
    if( NtLmState != NtLmLsaMode )
    {
        NtLmState = NtLmUserMode;
    }

    UserFunctions = DllFunctionTable;

    for( Index=0 ; Index < NTLM_USERLIST_COUNT ; Index++ )
    {
        InitializeListHead (&NtLmUserContextList[Index]);
    }
    
    for( Index=0 ; Index < NTLM_USERLIST_LOCK_COUNT ; Index++ )
    {
        __try {
            RtlInitializeResource (&NtLmUserContextLock[Index]);
        } __except(EXCEPTION_EXECUTE_HANDLER)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }
    }

    SspPrint(( SSP_API, "Leaving SpInstanceInit: 0x%lx\n", Status ));
    return(SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));
}



//+-------------------------------------------------------------------------
//
//  Function:   SpDeleteUserModeContext
//
//  Synopsis:   Deletes a user mode context by unlinking it and then
//              dereferencing it.
//
//  Effects:
//
//  Arguments:  ContextHandle - Lsa context handle of the context to delete
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success, STATUS_INVALID_HANDLE if the
//              context can't be located
//
//  Notes:
//        If this is an exported context, send a flag back to the LSA so that
//        Lsa does not call the SecpDeleteSecurityContext in the lsa process
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpDeleteUserModeContext(
    IN ULONG_PTR ContextHandle
    )
{
    SspPrint(( SSP_API, "Entering SpDeleteUserModeContext 0x%lx\n", ContextHandle ));
    PNTLM_CLIENT_CONTEXT pContext = NULL;
    NTSTATUS Status = STATUS_SUCCESS, SaveStatus = STATUS_SUCCESS;

    //
    // Find the currently existing user context and delink it
    // so that another context cannot Reference it before we
    // Dereference this one.
    //

    pContext = ReferenceUserContext(ContextHandle, TRUE);

    if (pContext == NULL)
    {
        //
        // pContext is legally NULL when we are dealing with an incomplete
        // context.  This can often be the case when the second call to
        // InitializeSecurityContext() fails.
        //
///        Status = STATUS_INVALID_HANDLE;
        Status = STATUS_SUCCESS;
        SspPrint(( SSP_API_MORE, "SpDeleteUserModeContext, local pContext is NULL\n" ));
        goto CleanUp;
    }


    if ((pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_EXPORTED_CONTEXT) != 0)
    {
        // Ignore all other errors and pass back
        SaveStatus = SEC_I_NO_LSA_CONTEXT;
    }


CleanUp:

    if (pContext != NULL)
    {
        Status = DereferenceUserContext(pContext);
    }

    if (SaveStatus == SEC_I_NO_LSA_CONTEXT)
    {
        Status = SaveStatus;
    }

    SspPrint(( SSP_API, "Leaving SpDeleteUserModeContext: 0x%lx\n", Status ));
    return(SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));
}


VOID
SspRc4Key(
    IN ULONG                NegotiateFlags,
    OUT struct RC4_KEYSTRUCT *pRc4Key,
    IN PUCHAR               pSessionKey
    )
/*++

RoutineDescription:

    Create an RC4 key schedule, making sure key length is OK for export

Arguments:

    NegotiateFlags  negotiate feature flags; NTLM2 bit is only one looked at
    pRc4Key         pointer to RC4 key schedule structure; filled in by this routine
    pSessionKey     pointer to session key -- must be full 16 bytes

Return Value:

--*/
{
    //
    // For NTLM2, effective length was already cut down
    //

    if ((NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2) != 0) {

        rc4_key(pRc4Key, MSV1_0_USER_SESSION_KEY_LENGTH, pSessionKey);

    } else if( NegotiateFlags & NTLMSSP_NEGOTIATE_LM_KEY ) {
        UCHAR Key[MSV1_0_LANMAN_SESSION_KEY_LENGTH];
        ULONG KeyLen;

        ASSERT(MSV1_0_LANMAN_SESSION_KEY_LENGTH == 8);

        // prior to Win2k, negotiated key strength had no bearing on
        // key size.  So, to allow proper interop to NT4, we don't
        // worry about 128bit.  56bit and 40bit are the only supported options.
        // 56bit is enabled because this was introduced in Win2k, and
        // Win2k -> Win2k interops correctly.
        //
#if 0
        if( NegotiateFlags & NTLMSSP_NEGOTIATE_128 ) {
            KeyLen = 8;

        } else
#endif
        if( NegotiateFlags & NTLMSSP_NEGOTIATE_56 ) {
            KeyLen = 7;

            //
            // Put a well-known salt at the end of the key to
            // limit the changing part to 56 bits.
            //

            Key[7] = 0xa0;
        } else {
            KeyLen = 5;

            //
            // Put a well-known salt at the end of the key to
            // limit the changing part to 40 bits.
            //

            Key[5] = 0xe5;
            Key[6] = 0x38;
            Key[7] = 0xb0;
        }

        RtlCopyMemory(Key,pSessionKey,KeyLen);

        SspPrint(( SSP_SESSION_KEYS, "Non NTLMv2 LM_KEY session key size: %lu key=%lx%lx\n",
                    KeyLen,
                    ((DWORD*)Key)[0],
                    ((DWORD*)Key)[1]
                    ));

        rc4_key(pRc4Key, MSV1_0_LANMAN_SESSION_KEY_LENGTH, Key);

    } else {

        SspPrint(( SSP_SESSION_KEYS, "Non NTLMv2 (not LM_KEY) session key size: %lu\n", 16));
        rc4_key(pRc4Key, MSV1_0_USER_SESSION_KEY_LENGTH, pSessionKey);
    }
}



//+-------------------------------------------------------------------------
//
//  Function:   SpInitUserModeContext
//
//  Synopsis:   Creates a user-mode context from a packed LSA mode context
//
//  Effects:
//
//  Arguments:  ContextHandle - Lsa mode context handle for the context
//              PackedContext - A marshalled buffer containing the LSA
//                  mode context.
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpInitUserModeContext(
    IN ULONG_PTR ContextHandle,
    IN PSecBuffer PackedContext
    )
{
    ASSERT(PackedContext);


    SspPrint(( SSP_API, "Entering SpInitUserModeContext 0x%lx\n", ContextHandle ));
    NTSTATUS Status = STATUS_SUCCESS;
    PNTLM_CLIENT_CONTEXT pContext = NULL;
    UINT Length = 0;
    PNTLM_PACKED_CONTEXT pTmpContext  = (PNTLM_PACKED_CONTEXT) PackedContext->pvBuffer;
    ULONG ListIndex;
    ULONG LockIndex;

    if (PackedContext->cbBuffer < sizeof(NTLM_PACKED_CONTEXT))
    {
        Status = STATUS_INVALID_PARAMETER;
        SspPrint(( SSP_CRITICAL, "SpInitUserModeContext, ContextData size < NTLM_CLIENT_CONTEXT\n" ));
        goto Cleanup;
    }

    pContext = (PNTLM_CLIENT_CONTEXT) NtLmAllocate( sizeof(NTLM_CLIENT_CONTEXT) );

    if (!pContext)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        SspPrint(( SSP_CRITICAL, "SpInitUserModeContext, NtLmAllocate returns NULL\n" ));
        goto Cleanup;
    }

    //
    // If ClientTokenHandle is NULL, we are being called as
    // as an effect of InitializeSecurityContext, else we are
    // being called because of AcceptSecurityContext
    //

    if (pTmpContext->ClientTokenHandle != NULL )
    {
        pContext->ClientTokenHandle = (HANDLE) ULongToPtr(pTmpContext->ClientTokenHandle);
        if (FAILED(SspCreateTokenDacl(pContext->ClientTokenHandle)))
        {
            Status = STATUS_INVALID_HANDLE;
            SspPrint(( SSP_CRITICAL, "SpInitUserModeContext, SspCreateTokenDacl failed\n" ));
            goto Cleanup;
        }
    }

    // Copy contents of PackedContext->pvBuffer to pContext

    pContext->LsaContext = ContextHandle;
    pContext->NegotiateFlags = pTmpContext->NegotiateFlags;


    SspPrint((SSP_NEGOTIATE_FLAGS, "SpInitUserModeContext NegotiateFlags: %lx\n", pContext->NegotiateFlags));

    pContext->References = 1;


    //
    // keep all 128 bits here, so signing can be strong even if encrypt can't be
    //

    RtlCopyMemory(  pContext->SessionKey,
                        pTmpContext->SessionKey,
                        MSV1_0_USER_SESSION_KEY_LENGTH);

    //
    // if doing full duplex as part of NTLM2, generate different sign
    // and seal keys for each direction
    //  all we do is MD5 the base session key with a different magic constant
    //

    if ( pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2 ) {
        MD5_CTX Md5Context;
        ULONG KeyLen;

        ASSERT(MD5DIGESTLEN == MSV1_0_USER_SESSION_KEY_LENGTH);

        if( pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_128 )
            KeyLen = 16;
        else if( pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_56 )
            KeyLen = 7;
        else
            KeyLen = 5;

        SspPrint(( SSP_SESSION_KEYS, "NTLMv2 session key size: %lu\n", KeyLen));

        //
        // make client to server encryption key
        //

        MD5Init(&Md5Context);
        MD5Update(&Md5Context, pContext->SessionKey, KeyLen);
        MD5Update(&Md5Context, (unsigned char*)CSSEALMAGIC, sizeof(CSSEALMAGIC));
        MD5Final(&Md5Context);

        //
        // if TokenHandle == NULL, this is the client side
        //  put key in the right place: for client it's seal, for server it's unseal
        //

        if (pContext->ClientTokenHandle == NULL)
            RtlCopyMemory(pContext->SealSessionKey, Md5Context.digest, MSV1_0_USER_SESSION_KEY_LENGTH);
        else
            RtlCopyMemory(pContext->UnsealSessionKey, Md5Context.digest, MSV1_0_USER_SESSION_KEY_LENGTH);

        //
        // make server to client encryption key
        //

        MD5Init(&Md5Context);
        MD5Update(&Md5Context, pContext->SessionKey, KeyLen);
        MD5Update(&Md5Context, (unsigned char*)SCSEALMAGIC, sizeof(SCSEALMAGIC));
        MD5Final(&Md5Context);
        ASSERT(MD5DIGESTLEN == MSV1_0_USER_SESSION_KEY_LENGTH);
        if (pContext->ClientTokenHandle == NULL)
            RtlCopyMemory(pContext->UnsealSessionKey, Md5Context.digest, MSV1_0_USER_SESSION_KEY_LENGTH);
        else
            RtlCopyMemory(pContext->SealSessionKey, Md5Context.digest, MSV1_0_USER_SESSION_KEY_LENGTH);

        //
        // make client to server signing key -- always 128 bits!
        //

        MD5Init(&Md5Context);
        MD5Update(&Md5Context, pContext->SessionKey, MSV1_0_USER_SESSION_KEY_LENGTH);
        MD5Update(&Md5Context, (unsigned char*)CSSIGNMAGIC, sizeof(CSSIGNMAGIC));
        MD5Final(&Md5Context);
        if (pContext->ClientTokenHandle == NULL)
            RtlCopyMemory(pContext->SignSessionKey, Md5Context.digest, MSV1_0_USER_SESSION_KEY_LENGTH);
        else
            RtlCopyMemory(pContext->VerifySessionKey, Md5Context.digest, MSV1_0_USER_SESSION_KEY_LENGTH);

        //
        // make server to client signing key
        //

        MD5Init(&Md5Context);
        MD5Update(&Md5Context, pContext->SessionKey, MSV1_0_USER_SESSION_KEY_LENGTH);
        MD5Update(&Md5Context, (unsigned char*)SCSIGNMAGIC, sizeof(SCSIGNMAGIC));
        MD5Final(&Md5Context);
        if (pContext->ClientTokenHandle == NULL)
            RtlCopyMemory(pContext->VerifySessionKey, Md5Context.digest, MSV1_0_USER_SESSION_KEY_LENGTH);
        else
            RtlCopyMemory(pContext->SignSessionKey, Md5Context.digest, MSV1_0_USER_SESSION_KEY_LENGTH);

        //
        // set pointers to different key schedule and nonce for each direction
        //  key schedule will be filled in later...
        //

        pContext->pSealRc4Sched = &pContext->SealRc4Sched;
        pContext->pUnsealRc4Sched = &pContext->UnsealRc4Sched;
        pContext->pSendNonce = &pContext->SendNonce;
        pContext->pRecvNonce = &pContext->RecvNonce;
   } else {

        //
        // just copy session key to all four keys
        //  leave them 128 bits -- they get cut to 40 bits later
        //

        RtlCopyMemory(  pContext->SealSessionKey,
                        pContext->SessionKey,
                        MSV1_0_USER_SESSION_KEY_LENGTH);
        RtlCopyMemory(  pContext->UnsealSessionKey,
                        pContext->SessionKey,
                        MSV1_0_USER_SESSION_KEY_LENGTH);
        RtlCopyMemory(  pContext->SignSessionKey,
                        pContext->SessionKey,
                        MSV1_0_USER_SESSION_KEY_LENGTH);
        RtlCopyMemory(  pContext->VerifySessionKey,
                        pContext->SessionKey,
                        MSV1_0_USER_SESSION_KEY_LENGTH);

        //
        // set pointers to share a key schedule and nonce for each direction
        //  (OK because half duplex!)
        //

        pContext->pSealRc4Sched = &pContext->SealRc4Sched;
        pContext->pUnsealRc4Sched = &pContext->SealRc4Sched;
        pContext->pSendNonce = &pContext->SendNonce;
        pContext->pRecvNonce = &pContext->SendNonce;
    }

    if ( pTmpContext->ContextNames )
    {
       pContext->ContextNames = (PWSTR) NtLmAllocate( pTmpContext->ContextNameLength );

       if ( pContext->ContextNames == NULL )
       {
           Status = STATUS_INSUFFICIENT_RESOURCES ;
           goto Cleanup ;
       }

       RtlCopyMemory( 
           pContext->ContextNames,
           ((PUCHAR) pTmpContext) + pTmpContext->ContextNames,
           pTmpContext->ContextNameLength );
    }
    else 
    {
        pContext->ContextNames = NULL ;
    }

    pContext->SendNonce = pTmpContext->SendNonce;
    pContext->RecvNonce = pTmpContext->RecvNonce;

    SspRc4Key(pContext->NegotiateFlags, &pContext->SealRc4Sched, pContext->SealSessionKey);
    SspRc4Key(pContext->NegotiateFlags, &pContext->UnsealRc4Sched, pContext->UnsealSessionKey);


    pContext->PasswordExpiry = pTmpContext->PasswordExpiry;
    pContext->UserFlags = pTmpContext->UserFlags;


    ListIndex = HandleToListIndex( pContext->LsaContext );
    LockIndex = ListIndexToLockIndex( ListIndex );
    
    RtlAcquireResourceExclusive(&NtLmUserContextLock[LockIndex], TRUE);

    InsertHeadList ( &NtLmUserContextList[ListIndex], &pContext->Next );
    NtLmUserContextCount[ListIndex]++;

    RtlReleaseResource(&NtLmUserContextLock[LockIndex]);


Cleanup:

    if (!NT_SUCCESS(Status))
    {
        if (pContext != NULL)
        {
            FreeUserContext(pContext);
        }
    }

    // Let FreeContextBuffer handle freeing the virtual allocs

    if (PackedContext->pvBuffer != NULL)
    {
        FreeContextBuffer(PackedContext->pvBuffer);
        PackedContext->pvBuffer = NULL;
    }

    SspPrint(( SSP_API, "Leaving SpInitUserModeContext: 0x%lx\n", Status ));
    return(SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));
}


//
// Bogus add-shift check sum
//

void
SspGenCheckSum(
    IN  PSecBuffer  pMessage,
    OUT PNTLMSSP_MESSAGE_SIGNATURE  pSig
    )

/*++

RoutineDescription:

    Generate a crc-32 checksum for a buffer

Arguments:

Return Value:
Notes: This was stolen from net\svcdlls\ntlmssp\client\sign.c ,
       routine SspGenCheckSum. It's possible that
       bugs got copied too

--*/

{
    Crc32(pSig->CheckSum,pMessage->cbBuffer,pMessage->pvBuffer,&pSig->CheckSum);
}


VOID
SspEncryptBuffer(
    IN PNTLM_CLIENT_CONTEXT pContext,
    IN struct RC4_KEYSTRUCT * pRc4Key,
    IN ULONG BufferSize,
    IN OUT PVOID Buffer
    )

/*++

RoutineDescription:

    Encrypts a buffer with the RC4 key in the context.  If the context
    is for a datagram session, then the key is copied before being used
    to encrypt the buffer.

Arguments:

    pContext - Context containing the key to encrypt the data

    BufferSize - Length of buffer in bytes

    Buffer - Buffer to encrypt.
    Notes: This was stolen from net\svcdlls\ntlmssp\client\sign.c ,
           routine SspEncryptBuffer. It's possible that
           bugs got copied too

Return Value:

--*/

{
    struct RC4_KEYSTRUCT TemporaryKey;
///    struct RC4_KEYSTRUCT * EncryptionKey = &pContext->Rc4Key;
    struct RC4_KEYSTRUCT * EncryptionKey = pRc4Key;

    if (BufferSize == 0)
    {
        return;
    }

    //
    // For datagram (application supplied sequence numbers) before NTLM2
    // we used to copy the key before encrypting so we don't
    // have a changing key; but that reused the key stream. Now we only
    // do that when backwards compatibility is explicitly called for.
    //

    if (((pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_DATAGRAM) != 0) &&
        ((pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2) == 0) ) {

        RtlCopyMemory(
            &TemporaryKey,
            EncryptionKey,
            sizeof(struct RC4_KEYSTRUCT)
            );
        EncryptionKey = &TemporaryKey;

    }

    rc4(
        EncryptionKey,
        BufferSize,
        (PUCHAR) Buffer
        );
}


typedef enum _eSignSealOp {
    eSign,      // MakeSignature is calling
    eVerify,    // VerifySignature is calling
    eSeal,      // SealMessage is calling
    eUnseal     // UnsealMessage is calling
} eSignSealOp;

SECURITY_STATUS
SspSignSealHelper(
    IN PNTLM_CLIENT_CONTEXT pContext,
    IN eSignSealOp Op,
    IN OUT PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo,
    OUT PNTLMSSP_MESSAGE_SIGNATURE pSig,
    OUT PNTLMSSP_MESSAGE_SIGNATURE * ppSig
    )
/*++

RoutineDescription:

    Handle signing a message

Arguments:

Return Value:

--*/

{

    HMACMD5_CTX HMACMD5Context;
    UCHAR TempSig[MD5DIGESTLEN];
    NTLMSSP_MESSAGE_SIGNATURE  Sig;
    int Signature;
    ULONG i;
    PUCHAR pKey;                            // ptr to key to use for encryption
    PUCHAR pSignKey;                        // ptr to key to use for signing
    PULONG pNonce;                          // ptr to nonce to use
    struct RC4_KEYSTRUCT * pRc4Sched;       // ptr to key schedule to use

    NTLMSSP_MESSAGE_SIGNATURE  AlignedSig;  // aligned copy of input sig data



    Signature = -1;
    for (i = 0; i < pMessage->cBuffers; i++)
    {
        if ((pMessage->pBuffers[i].BufferType & 0xFF) == SECBUFFER_TOKEN)
        {
            Signature = i;
            break;
        }
    }
    if (Signature == -1)
    {
        return(SEC_E_INVALID_TOKEN);
    }

    if (pMessage->pBuffers[Signature].cbBuffer < NTLMSSP_MESSAGE_SIGNATURE_SIZE)
    {
        return(SEC_E_INVALID_TOKEN);
    }

    *ppSig = (NTLMSSP_MESSAGE_SIGNATURE*)pMessage->pBuffers[Signature].pvBuffer;

    RtlCopyMemory( &AlignedSig, *ppSig, sizeof(AlignedSig) );

    //
    // If sequence detect wasn't requested, put on an empty
    // security token . Don't do the check if Seal/Unseal is called.
    //

    if (!(pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_SIGN) &&
       (Op == eSign || Op == eVerify))
    {
        RtlZeroMemory(pSig,NTLMSSP_MESSAGE_SIGNATURE_SIZE);
        pSig->Version = NTLM_SIGN_VERSION;
        return(SEC_E_OK);
    }

    // figure out which key, key schedule, and nonce to use
    //  depends on the op. SspAddLocalContext set up so that code on client
    //  and server just (un)seals with (un)seal key or key schedule, etc.
    //  and also sets pointers to share sending/receiving key schedule/nonce
    //  when in half duplex mode. Hence, this code gets to act as if it were
    //  always in full duplex mode.
    switch (Op) {
    case eSeal:
        pSignKey = pContext->SignSessionKey;    // if NTLM2
        pKey = pContext->SealSessionKey;
        pRc4Sched = pContext->pSealRc4Sched;
        pNonce = pContext->pSendNonce;
        break;
    case eUnseal:
        pSignKey = pContext->VerifySessionKey;  // if NTLM2
        pKey = pContext->UnsealSessionKey;
        pRc4Sched = pContext->pUnsealRc4Sched;
        pNonce = pContext->pRecvNonce;
        break;
    case eSign:
        pSignKey = pContext->SignSessionKey;    // if NTLM2
        pKey = pContext->SealSessionKey;        // might be used to encrypt the signature
        pRc4Sched = pContext->pSealRc4Sched;
        pNonce = pContext->pSendNonce;
        break;
    case eVerify:
        pSignKey = pContext->VerifySessionKey;  // if NTLM2
        pKey = pContext->UnsealSessionKey;      // might be used to decrypt the signature
        pRc4Sched = pContext->pUnsealRc4Sched;
        pNonce = pContext->pRecvNonce;
        break;
    }

    //
    // Either we can supply the sequence number, or
    // the application can supply the message sequence number.
    //

    Sig.Version = NTLM_SIGN_VERSION;

    // if we're doing the new NTLM2 version:
    if (pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2) {

        if ((pContext->NegotiateFlags & NTLMSSP_APP_SEQ) == 0)
        {
            Sig.Nonce = *pNonce;    // use our sequence number
            (*pNonce) += 1;
        }
        else {

            if (Op == eSeal || Op == eSign || MessageSeqNo != 0)
                Sig.Nonce = MessageSeqNo;
            else
                Sig.Nonce = AlignedSig.Nonce;

            //   if using RC4, must rekey for each packet
            //   RC4 is used for seal, unseal; and for encrypting the HMAC hash if
            //   key exchange was negotiated (we use just HMAC if no key exchange,
            //   so that a good signing option exists with no RC4 encryption needed)

            if (Op == eSeal || Op == eUnseal || pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH)
            {
                MD5_CTX Md5ContextReKey;

                MD5Init(&Md5ContextReKey);
                MD5Update(&Md5ContextReKey, pKey, MSV1_0_USER_SESSION_KEY_LENGTH);
                MD5Update(&Md5ContextReKey, (unsigned char*)&Sig.Nonce, sizeof(Sig.Nonce));
                MD5Final(&Md5ContextReKey);
                ASSERT(MD5DIGESTLEN == MSV1_0_USER_SESSION_KEY_LENGTH);
                SspRc4Key(pContext->NegotiateFlags, pRc4Sched, Md5ContextReKey.digest);
            }
        }

        //
        // using HMAC hash, init it with the key
        //

        HMACMD5Init(&HMACMD5Context, pSignKey, MSV1_0_USER_SESSION_KEY_LENGTH);

        //
        // include the message sequence number
        //

        HMACMD5Update(&HMACMD5Context, (unsigned char*)&Sig.Nonce, sizeof(Sig.Nonce));

        for (i = 0; i < pMessage->cBuffers ; i++ )
        {
            if (((pMessage->pBuffers[i].BufferType & 0xFF) == SECBUFFER_DATA) &&
                (pMessage->pBuffers[i].cbBuffer != 0))
            {
                // decrypt (before checksum...) if it's not READ_ONLY
                if ((Op==eUnseal)
                    && !(pMessage->pBuffers[i].BufferType & SECBUFFER_READONLY)
                )
                {
                    SspEncryptBuffer(
                        pContext,
                        pRc4Sched,
                        pMessage->pBuffers[i].cbBuffer,
                        pMessage->pBuffers[i].pvBuffer
                        );
                }

                HMACMD5Update(
                            &HMACMD5Context,
                            (unsigned char*)pMessage->pBuffers[i].pvBuffer,
                            pMessage->pBuffers[i].cbBuffer);

                //
                // Encrypt if its not READ_ONLY
                //

                if ((Op==eSeal)
                    && !(pMessage->pBuffers[i].BufferType & SECBUFFER_READONLY)
                )
                {
                    SspEncryptBuffer(
                        pContext,
                        pRc4Sched,
                        pMessage->pBuffers[i].cbBuffer,
                        pMessage->pBuffers[i].pvBuffer
                        );
                }
            }
        }

        HMACMD5Final(&HMACMD5Context, TempSig);

        //
        // use RandomPad and Checksum fields for 8 bytes of MD5 hash
        //

        RtlCopyMemory(&Sig.RandomPad, TempSig, 8);

        //
        // if we're using crypto for KEY_EXCH, may as well use it for signing too...
        //

        if (pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH)
            SspEncryptBuffer(
                pContext,
                pRc4Sched,
                8,
                &Sig.RandomPad
                );
    }
    //
    // pre-NTLM2 methods
    //
    else {

        //
        // required by CRC-32 algorithm
        //
        Sig.CheckSum = 0xffffffff;

        for (i = 0; i < pMessage->cBuffers ; i++ )
        {
            if (((pMessage->pBuffers[i].BufferType & 0xFF) == SECBUFFER_DATA) &&
                !(pMessage->pBuffers[i].BufferType & SECBUFFER_READONLY) &&
                (pMessage->pBuffers[i].cbBuffer != 0))
            {
                // decrypt (before checksum...)
                if (Op==eUnseal)
                {
                    SspEncryptBuffer(
                        pContext,
                        pRc4Sched,
                        pMessage->pBuffers[i].cbBuffer,
                        pMessage->pBuffers[i].pvBuffer
                        );
                }

                SspGenCheckSum(&pMessage->pBuffers[i], &Sig);


                // Encrypt
                if (Op==eSeal)
                {
                    SspEncryptBuffer(
                        pContext,
                        pRc4Sched,
                        pMessage->pBuffers[i].cbBuffer,
                        pMessage->pBuffers[i].pvBuffer
                        );
                }
            }
        }

        //
        // Required by CRC-32 algorithm
        //

        Sig.CheckSum ^= 0xffffffff;

        // when we encrypt 0, we will get the cipher stream for the nonce!
        Sig.Nonce = 0;

        SspEncryptBuffer(
            pContext,
            pRc4Sched,
            sizeof(NTLMSSP_MESSAGE_SIGNATURE) - sizeof(ULONG),
            &Sig.RandomPad
            );

        if ((pContext->NegotiateFlags & NTLMSSP_APP_SEQ) == 0)
        {
            Sig.Nonce ^= *pNonce;    // use our sequence number and encrypt it
            (*pNonce) += 1;
        }
        else if (Op == eSeal || Op == eSign || MessageSeqNo != 0)
            Sig.Nonce ^= MessageSeqNo;   // use caller's sequence number and encrypt it
        else
            Sig.Nonce = AlignedSig.Nonce;    // use sender's sequence number

        //
        // for SignMessage calling, does nothing (copies garbage)
        // For VerifyMessage calling, allows it to compare sig block
        // upon return to Verify without knowing whether its MD5 or CRC32
        //

        Sig.RandomPad = AlignedSig.RandomPad;
    }

    pMessage->pBuffers[Signature].cbBuffer = sizeof(NTLMSSP_MESSAGE_SIGNATURE);

    RtlCopyMemory(
        pSig,
        &Sig,
        NTLMSSP_MESSAGE_SIGNATURE_SIZE
        );

    return(SEC_E_OK);
}



//+-------------------------------------------------------------------------
//
//  Function:   SpMakeSignature
//
//  Synopsis:   Signs a message buffer by calculatinga checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  ContextHandle - Handle of the context to use to sign the
//                      message.
//              QualityOfProtection - Unused flags.
//              MessageBuffers - Contains an array of buffers to sign and
//                      to store the signature.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found.
//              STATUS_BUFFER_TOO_SMALL - the signature buffer is too small
//                      to hold the signature
//
//  Returns:
//
//  Notes: This was stolen from net\svcdlls\ntlmssp\client\sign.c ,
//         routine SspHandleSignMessage. It's possible that
//         bugs got copied too
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpMakeSignature(
    IN ULONG_PTR ContextHandle,
    IN ULONG fQOP,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo
    )
{
    SspPrint(( SSP_API, "Entering SpMakeSignature\n" ));
    NTSTATUS Status = S_OK;
    NTSTATUS SubStatus = S_OK;

    PNTLM_CLIENT_CONTEXT pContext;
    NTLMSSP_MESSAGE_SIGNATURE  Sig;
    NTLMSSP_MESSAGE_SIGNATURE  *pSig;

    UNREFERENCED_PARAMETER(fQOP);

    pContext = ReferenceUserContext(ContextHandle, FALSE);

    if (pContext == NULL)
    {
        Status = STATUS_INVALID_HANDLE;
        SspPrint(( SSP_CRITICAL, "SpMakeSignature, ReferenceUserContext returns NULL\n" ));
        goto CleanUp;
    }


    Status = SspSignSealHelper(
                        pContext,
                        eSign,
                        pMessage,
                        MessageSeqNo,
                        &Sig,
                        &pSig
                        );

    if( !NT_SUCCESS(Status) ) {
        SspPrint(( SSP_CRITICAL, "SpMakeSignature, SspSignSealHelper returns %lx\n", Status ));
        goto CleanUp;
    }

    RtlCopyMemory(
        pSig,
        &Sig,
        NTLMSSP_MESSAGE_SIGNATURE_SIZE
        );


CleanUp:

    if (pContext != NULL)
    {
        SubStatus = DereferenceUserContext(pContext);

        // Don't destroy real status

        if (NT_SUCCESS(Status))
        {
            Status = SubStatus;
        }
    }

    SspPrint(( SSP_API, "Leaving SpMakeSignature: 0x%lx\n", Status ));
    return(SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));
}

//+-------------------------------------------------------------------------
//
//  Function:   SpVerifySignature
//
//  Synopsis:   Verifies a signed message buffer by calculating a checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  ContextHandle - Handle of the context to use to sign the
//                      message.
//              MessageBuffers - Contains an array of signed buffers  and
//                      a signature buffer.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//              QualityOfProtection - Unused flags.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found or was too small.
//
//  Returns:
//
//  Notes: This was stolen from net\svcdlls\ntlmssp\client\sign.c ,
//         routine SspHandleVerifyMessage. It's possible that
//         bugs got copied too
//
//
//--------------------------------------------------------------------------



NTSTATUS NTAPI
SpVerifySignature(
    IN ULONG_PTR ContextHandle,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo,
    OUT PULONG pfQOP
    )
{
    SspPrint(( SSP_API, "Entering SpVerifySignature\n" ));
    NTSTATUS Status = S_OK;
    NTSTATUS SubStatus = S_OK;
    PNTLM_CLIENT_CONTEXT pContext;
    NTLMSSP_MESSAGE_SIGNATURE   Sig;
    PNTLMSSP_MESSAGE_SIGNATURE  pSig;       // pointer to buffer with sig in it
    NTLMSSP_MESSAGE_SIGNATURE   AlignedSig; // Aligned sig buffer.

    UNREFERENCED_PARAMETER(pfQOP);

    pContext = ReferenceUserContext(ContextHandle, FALSE);

    if (!pContext)
    {
        Status = STATUS_INVALID_HANDLE;
        SspPrint(( SSP_CRITICAL, "SpVerifySignature, ReferenceUserContext returns NULL\n" ));
        goto CleanUp;
    }

    Status = SspSignSealHelper(
                        pContext,
                        eVerify,
                        pMessage,
                        MessageSeqNo,
                        &Sig,
                        &pSig
                        );

    if (!NT_SUCCESS(Status))
    {
        SspPrint(( SSP_CRITICAL, "SpVerifySignature, SspSignSealHelper returns %lx\n", Status ));
        goto CleanUp;
    }


    RtlCopyMemory( &AlignedSig, pSig, sizeof( AlignedSig ) );

    if (AlignedSig.Version != NTLM_SIGN_VERSION) {
        SspPrint(( SSP_CRITICAL, "SpVerifySignature, unknown Version wanted=%lx got=%lx\n",
                    NTLM_SIGN_VERSION,
                    AlignedSig.Version
                    ));
        Status = SEC_E_INVALID_TOKEN;
        goto CleanUp;
    }

    // validate the signature...
    if (AlignedSig.CheckSum != Sig.CheckSum)
    {
        SspPrint(( SSP_CRITICAL, "SpVerifySignature, CheckSum mis-match wanted=%lx got=%lx\n",
                    Sig.CheckSum,
                    AlignedSig.CheckSum
                    ));
        Status = SEC_E_MESSAGE_ALTERED;
        goto CleanUp;
    }

    // with MD5 sig, this now matters!
    if (AlignedSig.RandomPad != Sig.RandomPad)
    {
        SspPrint(( SSP_CRITICAL, "SpVerifySignature, RandomPad mis-match wanted=%lx got=%lx\n",
                    Sig.RandomPad,
                    AlignedSig.RandomPad
                    ));
        Status = SEC_E_MESSAGE_ALTERED;
        goto CleanUp;
    }

    if (AlignedSig.Nonce != Sig.Nonce)
    {
        SspPrint(( SSP_CRITICAL, "SpVerifySignature, Nonce mis-match wanted=%lx got=%lx\n",
                    Sig.Nonce,
                    AlignedSig.Nonce
                    ));

        Status = SEC_E_OUT_OF_SEQUENCE;
        goto CleanUp;
    }


CleanUp:

    if (pContext != NULL)
    {
        SubStatus = DereferenceUserContext(pContext);

        // Don't destroy real status

        if (NT_SUCCESS(Status))
        {
            Status = SubStatus;
        }
    }

    SspPrint(( SSP_API, "Leaving SpVerifySignature: 0x%lx\n", Status ));
    return(SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));

}


//+-------------------------------------------------------------------------
//
//  Function:   SpSealMessage
//
//  Synopsis:   Verifies a signed message buffer by calculating a checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  ContextHandle - Handle of the context to use to sign the
//                      message.
//              MessageBuffers - Contains an array of signed buffers  and
//                      a signature buffer.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//              QualityOfProtection - Unused flags.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found or was too small.
//
//  Returns:
//
//  Notes: This was stolen from net\svcdlls\ntlmssp\client\sign.c ,
//         routine SspHandleSealMessage. It's possible that
//         bugs got copied too
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
SpSealMessage(
    IN ULONG_PTR ContextHandle,
    IN ULONG fQOP,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo
    )
{
    SspPrint(( SSP_API, "Entering SpSealMessage\n" ));
    NTSTATUS Status = S_OK;
    NTSTATUS SubStatus = S_OK;
    PNTLM_CLIENT_CONTEXT pContext;
    NTLMSSP_MESSAGE_SIGNATURE  Sig;
    PNTLMSSP_MESSAGE_SIGNATURE  pSig;    // pointer to buffer where sig goes

    ULONG i;

    UNREFERENCED_PARAMETER(fQOP);

    pContext = ReferenceUserContext(ContextHandle, FALSE);

    if (!pContext)
    {
        Status = STATUS_INVALID_HANDLE;
        SspPrint(( SSP_CRITICAL, "SpSealMessage, ReferenceUserContext returns NULL\n" ));
        goto CleanUp;
    }


    Status = SspSignSealHelper(
                    pContext,
                    eSeal,
                    pMessage,
                    MessageSeqNo,
                    &Sig,
                    &pSig
                    );

    if (!NT_SUCCESS(Status))
    {
        SspPrint(( SSP_CRITICAL, "SpVerifySignature, SspSignSealHelper returns %lx\n", Status ));
        goto CleanUp;
    }

    RtlCopyMemory(
        pSig,
        &Sig,
        NTLMSSP_MESSAGE_SIGNATURE_SIZE
        );


    //
    // for gss style sign/seal, strip the padding as RC4 requires none.
    // (in fact, we rely on this to simplify the size computation in DecryptMessage).
    // if we support some other block cipher, need to rev the NTLM_ token version to make blocksize
    //

    for (i = 0; i < pMessage->cBuffers; i++)
    {
        if ((pMessage->pBuffers[i].BufferType & 0xFF) == SECBUFFER_PADDING)
        {
            //
            // no padding required!
            //

            pMessage->pBuffers[i].cbBuffer = 0;
            break;
        }
    }


CleanUp:

    if (pContext != NULL)
    {
        SubStatus = DereferenceUserContext(pContext);

        // Don't destroy real status

        if (NT_SUCCESS(Status))
        {
            Status = SubStatus;
        }
    }

    SspPrint(( SSP_API, "Leaving SpSealMessage: 0x%lx\n", Status ));
    return(SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));

}

//+-------------------------------------------------------------------------
//
//  Function:   SpUnsealMessage
//
//  Synopsis:   Verifies a signed message buffer by calculating a checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  ContextHandle - Handle of the context to use to sign the
//                      message.
//              MessageBuffers - Contains an array of signed buffers  and
//                      a signature buffer.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//              QualityOfProtection - Unused flags.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found or was too small.
//
//  Returns:
//
//  Notes: This was stolen from net\svcdlls\ntlmssp\client\sign.c ,
//         routine SspHandleUnsealMessage. It's possible that
//         bugs got copied too
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpUnsealMessage(
    IN ULONG_PTR ContextHandle,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo,
    OUT PULONG pfQOP
    )
{
    SspPrint(( SSP_API, "Entering SpUnsealMessage\n" ));
    NTSTATUS Status = S_OK;
    NTSTATUS SubStatus = S_OK;
    PNTLM_CLIENT_CONTEXT pContext;
    NTLMSSP_MESSAGE_SIGNATURE  Sig;
    PNTLMSSP_MESSAGE_SIGNATURE  pSig;       // pointer to buffer where sig goes
    NTLMSSP_MESSAGE_SIGNATURE   AlignedSig; // aligned buffer.

    PSecBufferDesc MessageBuffers = pMessage;
    ULONG Index;
    PSecBuffer SignatureBuffer = NULL;
    PSecBuffer StreamBuffer = NULL;
    PSecBuffer DataBuffer = NULL;
    SecBufferDesc ProcessBuffers;
    SecBuffer wrap_bufs[2];

    UNREFERENCED_PARAMETER(pfQOP);

    pContext = ReferenceUserContext(ContextHandle, FALSE);

    if (!pContext)
    {
        Status = STATUS_INVALID_HANDLE;
        SspPrint(( SSP_CRITICAL, "SpUnsealMessage, ReferenceUserContext returns NULL\n" ));
        goto CleanUp;
    }


    //
    // Find the body and signature SecBuffers from pMessage
    //

    for (Index = 0; Index < MessageBuffers->cBuffers ; Index++ )
    {
        if ((MessageBuffers->pBuffers[Index].BufferType & ~SECBUFFER_ATTRMASK) == SECBUFFER_TOKEN)
        {
            SignatureBuffer = &MessageBuffers->pBuffers[Index];
        }
        else if ((MessageBuffers->pBuffers[Index].BufferType & ~SECBUFFER_ATTRMASK) == SECBUFFER_STREAM)
        {
            StreamBuffer = &MessageBuffers->pBuffers[Index];
        }
        else if ((MessageBuffers->pBuffers[Index].BufferType & ~SECBUFFER_ATTRMASK) == SECBUFFER_DATA)
        {
            DataBuffer = &MessageBuffers->pBuffers[Index];
        }
    }
    
    if( StreamBuffer != NULL )
    {

        if( SignatureBuffer != NULL )
        {
            Status = SEC_E_INVALID_TOKEN;
            SspPrint(( SSP_CRITICAL, "SpUnsealMessage, Both stream and signature buffer present.\n"));
            goto CleanUp;
        }

        //
        // for version 1 NTLM blobs, padding is never present, since RC4 is stream cipher.
        //

        wrap_bufs[0].cbBuffer = NTLMSSP_MESSAGE_SIGNATURE_SIZE;
        wrap_bufs[1].cbBuffer = StreamBuffer->cbBuffer - NTLMSSP_MESSAGE_SIGNATURE_SIZE;

        if( StreamBuffer->cbBuffer < wrap_bufs[0].cbBuffer )
        {
            Status = SEC_E_INVALID_TOKEN;
            SspPrint(( SSP_CRITICAL, "SpUnsealMessage, invalid buffer present in STREAM.\n"));
            goto CleanUp;
        }


        wrap_bufs[0].BufferType = SECBUFFER_TOKEN;
        wrap_bufs[0].pvBuffer = StreamBuffer->pvBuffer;

        wrap_bufs[1].BufferType = SECBUFFER_DATA;
        wrap_bufs[1].pvBuffer = (PBYTE)wrap_bufs[0].pvBuffer + wrap_bufs[0].cbBuffer;

        if( DataBuffer == NULL )
        {
            Status = SEC_E_INVALID_TOKEN;
            SspPrint(( SSP_CRITICAL, "SpUnsealMessage, gss missing SECBUFFER_DATA.\n"));
            goto CleanUp;
        }

        DataBuffer->cbBuffer = wrap_bufs[1].cbBuffer;
        DataBuffer->pvBuffer = wrap_bufs[1].pvBuffer;

        ProcessBuffers.cBuffers = 2;
        ProcessBuffers.pBuffers = wrap_bufs;
        ProcessBuffers.ulVersion = SECBUFFER_VERSION;

    } else {
        ProcessBuffers = *MessageBuffers;
    }
    
    Status = SspSignSealHelper(
                    pContext,
                    eUnseal,
                    &ProcessBuffers,
                    MessageSeqNo,
                    &Sig,
                    &pSig
                    );

    if (!NT_SUCCESS(Status))
    {
        SspPrint(( SSP_CRITICAL, "SpUnsealMessage, SspSignSealHelper returns %lx\n", Status ));
        goto CleanUp;
    }

    RtlCopyMemory( &AlignedSig, pSig, sizeof(AlignedSig) );

    if (AlignedSig.Version != NTLM_SIGN_VERSION) {
        SspPrint(( SSP_CRITICAL, "SpUnsealMessage, unknown Version wanted=%lx got=%lx\n",
                    NTLM_SIGN_VERSION,
                    AlignedSig.Version
                    ));
        Status = SEC_E_INVALID_TOKEN;
        goto CleanUp;
    }

    // validate the signature...
    if (AlignedSig.CheckSum != Sig.CheckSum)
    {
        SspPrint(( SSP_CRITICAL, "SpUnsealMessage, CheckSum mis-match wanted=%lx got=%lx\n",
                    Sig.CheckSum,
                    AlignedSig.CheckSum
                    ));
        Status = SEC_E_MESSAGE_ALTERED;
        goto CleanUp;
    }

    if (AlignedSig.RandomPad != Sig.RandomPad)
    {
        SspPrint(( SSP_CRITICAL, "SpUnsealMessage, RandomPad mis-match wanted=%lx got=%lx\n",
                    Sig.RandomPad,
                    AlignedSig.RandomPad
                    ));
        Status = SEC_E_MESSAGE_ALTERED;
        goto CleanUp;
    }

    if (AlignedSig.Nonce != Sig.Nonce)
    {
        SspPrint(( SSP_CRITICAL, "SpUnsealMessage, Nonce mis-match wanted=%lx got=%lx\n",
                    Sig.Nonce,
                    AlignedSig.Nonce
                    ));
        Status = SEC_E_OUT_OF_SEQUENCE;
        goto CleanUp;
    }

CleanUp:

    if (pContext != NULL)
    {
        SubStatus = DereferenceUserContext(pContext);

        // Don't destroy real status

        if (NT_SUCCESS(Status))
        {
            Status = SubStatus;
        }
    }

    SspPrint(( SSP_API, "Leaving SpUnsealMessage: 0x%lx\n", Status ));
    return(SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));
}



//+-------------------------------------------------------------------------
//
//  Function:   SpGetContextToken
//
//  Synopsis:   returns a pointer to the token for a server-side context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpGetContextToken(
    IN ULONG_PTR ContextHandle,
    OUT PHANDLE ImpersonationToken
    )
{
    SspPrint(( SSP_API, "Entering SpGetContextToken\n" ));
    NTSTATUS Status = S_OK;
    PNTLM_CLIENT_CONTEXT pContext;

    pContext = ReferenceUserContext(ContextHandle, FALSE);

    if (pContext && pContext->ClientTokenHandle)
    {
        *ImpersonationToken = pContext->ClientTokenHandle;
        Status= S_OK;
        goto CleanUp;
    }

    Status = STATUS_INVALID_HANDLE;
    SspPrint(( SSP_CRITICAL, "SpGetContextToken, no token handle\n" ));

CleanUp:

    if (pContext != NULL)
    {
        Status = DereferenceUserContext(pContext);
    }

    SspPrint(( SSP_API, "Leaving SpGetContextToken: 0x%lx\n", Status ));
    return(SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));
}



//+-------------------------------------------------------------------------
//
//  Function:   SpQueryContextAttributes
//
//  Synopsis:   Querys attributes of the specified context
//              This API allows a customer of the security
//              services to determine certain attributes of
//              the context.  These are: sizes, names, and lifespan.
//
//  Effects:
//
//  Arguments:
//
//    ContextHandle - Handle to the context to query.
//
//    Attribute - Attribute to query.
//
//        #define SECPKG_ATTR_SIZES    0
//        #define SECPKG_ATTR_NAMES    1
//        #define SECPKG_ATTR_LIFESPAN 2
//
//    Buffer - Buffer to copy the data into.  The buffer must
//             be large enough to fit the queried attribute.
//
//
//  Requires:
//
//  Returns:
//
//        STATUS_SUCCESS - Call completed successfully
//
//        STATUS_INVALID_HANDLE -- Credential/Context Handle is invalid
//        STATUS_NOT_SUPPORTED -- Function code is not supported
//
//  Notes:
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpQueryContextAttributes(
    IN ULONG_PTR ContextHandle,
    IN ULONG Attribute,
    IN OUT PVOID Buffer
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PNTLM_CLIENT_CONTEXT pContext = NULL;
    PSecPkgContext_Sizes ContextSizes;
    PSecPkgContext_Flags ContextFlags;
    PSecPkgContext_DceInfo ContextDceInfo = NULL;
    PSecPkgContext_Names ContextNames = NULL;
    PSecPkgContext_PackageInfo PackageInfo;
    PSecPkgContext_NegotiationInfo NegInfo ;
    PSecPkgContext_PasswordExpiry PasswordExpires;
    PSecPkgContext_UserFlags UserFlags;
    PSecPkgContext_SessionKey  SessionKeyInfo;
	PSecPkgContext_AccessToken AccessToken;
    ULONG PackageInfoSize = 0;

    SspPrint(( SSP_API, "Entering SpQueryContextAttributes\n" ));

    pContext = ReferenceUserContext(ContextHandle, FALSE);

    if (pContext == NULL) {
        Status = STATUS_INVALID_HANDLE;
        SspPrint(( SSP_API_MORE, "SpQueryContextAttributes, ReferenceUserContext returns NULL (possible incomplete context)\n" ));
        goto Cleanup;
    }

    //
    // Handle each of the various queried attributes
    //

    SspPrint(( SSP_API_MORE, "SpQueryContextAttributes : 0x%lx\n", Attribute ));
    switch ( Attribute) {
    case SECPKG_ATTR_SIZES:

        ContextSizes = (PSecPkgContext_Sizes) Buffer;
        ContextSizes->cbMaxToken = NTLMSP_MAX_TOKEN_SIZE;

        if (pContext->NegotiateFlags & (NTLMSSP_NEGOTIATE_ALWAYS_SIGN |
                                       NTLMSSP_NEGOTIATE_SIGN |
                                       NTLMSSP_NEGOTIATE_SEAL) ) {
            ContextSizes->cbMaxSignature = NTLMSSP_MESSAGE_SIGNATURE_SIZE;
        } else {
            ContextSizes->cbMaxSignature = 0;
        }

        if (pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_SEAL) {
            ContextSizes->cbBlockSize = 1;
            ContextSizes->cbSecurityTrailer = NTLMSSP_MESSAGE_SIGNATURE_SIZE;
        }
        else
        {
            ContextSizes->cbBlockSize = 0;
            if((pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_SIGN) ||
               (pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_ALWAYS_SIGN))
            {
                ContextSizes->cbSecurityTrailer = NTLMSSP_MESSAGE_SIGNATURE_SIZE;
            } else {
                ContextSizes->cbSecurityTrailer = 0;
            }
        }

        break;

    case SECPKG_ATTR_DCE_INFO:

        ContextDceInfo = (PSecPkgContext_DceInfo) Buffer;

        if (pContext->ContextNames)
        {
            UINT Length = wcslen(pContext->ContextNames);
            ContextDceInfo->pPac = (LPWSTR)UserFunctions->AllocateHeap((Length + 1) * sizeof(WCHAR));
            if (ContextDceInfo->pPac == NULL) {
                Status = STATUS_NO_MEMORY;
                SspPrint(( SSP_CRITICAL, "SpQueryContextAttributes, NtLmAllocate returns NULL\n" ));
                goto Cleanup;
            }

            RtlCopyMemory(
                (LPWSTR) ContextDceInfo->pPac,
                pContext->ContextNames,
                Length * sizeof(WCHAR)
                );
            *((LPWSTR)(ContextDceInfo->pPac) + Length) = L'\0';
        }
        else
        {
            SspPrint(( SSP_API_MORE, "SpQueryContextAttributes no ContextNames\n" ));
            ContextDceInfo->pPac = (LPWSTR) UserFunctions->AllocateHeap(sizeof(WCHAR));
            *((LPWSTR)(ContextDceInfo->pPac)) = L'\0';
        }

        ContextDceInfo->AuthzSvc = 0;

        break;

    case SECPKG_ATTR_SESSION_KEY:
    {
        if (NtLmState != NtLmLsaMode)
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        SessionKeyInfo = (PSecPkgContext_SessionKey) Buffer;
        SessionKeyInfo->SessionKeyLength = sizeof(pContext->SessionKey);

        SessionKeyInfo->SessionKey = (PUCHAR) UserFunctions->AllocateHeap(
                                                    SessionKeyInfo->SessionKeyLength
                                                    );
        if (SessionKeyInfo->SessionKey != NULL)
        {
            RtlCopyMemory(
                SessionKeyInfo->SessionKey,
                pContext->SessionKey,
                SessionKeyInfo->SessionKeyLength
                );
        }
        else
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        break;
    }

    case SECPKG_ATTR_NAMES:

        ContextNames = (PSecPkgContext_Names) Buffer;

        if (pContext->ContextNames)
        {
            UINT Length = wcslen(pContext->ContextNames);
            ContextNames->sUserName = (LPWSTR) UserFunctions->AllocateHeap((Length+1) * sizeof(WCHAR));
            if (ContextNames->sUserName == NULL) {
                Status = STATUS_NO_MEMORY;
                SspPrint(( SSP_CRITICAL, "SpQueryContextAttributes, NtLmAllocate returns NULL\n" ));
                goto Cleanup;
            }
            RtlCopyMemory(
                ContextNames->sUserName,
                pContext->ContextNames,
                Length * sizeof(WCHAR)
                );
            *(ContextNames->sUserName + Length) = L'\0';
        }
        else
        {
            SspPrint(( SSP_API_MORE, "SpQueryContextAttributes no ContextNames\n" ));
            ContextNames->sUserName = (LPWSTR) UserFunctions->AllocateHeap(sizeof(WCHAR));
            *(ContextNames->sUserName) = L'\0';
        }

        break;
    case SECPKG_ATTR_PACKAGE_INFO:
    case SECPKG_ATTR_NEGOTIATION_INFO:
        //
        // Return the information about this package. This is useful for
        // callers who used SPNEGO and don't know what package they got.
        //

        PackageInfo = (PSecPkgContext_PackageInfo) Buffer;
        PackageInfoSize = sizeof(SecPkgInfoW) + sizeof(NTLMSP_NAME) + sizeof(NTLMSP_COMMENT);
        PackageInfo->PackageInfo = (PSecPkgInfoW) UserFunctions->AllocateHeap(PackageInfoSize);
        if (PackageInfo->PackageInfo == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        PackageInfo->PackageInfo->Name = (LPWSTR) (PackageInfo->PackageInfo + 1);
        PackageInfo->PackageInfo->Comment = (LPWSTR) ((((PBYTE) PackageInfo->PackageInfo->Name)) + sizeof(NTLMSP_NAME));
        wcscpy(
            PackageInfo->PackageInfo->Name,
            NTLMSP_NAME
            );

        wcscpy(
            PackageInfo->PackageInfo->Comment,
            NTLMSP_COMMENT
            );
        PackageInfo->PackageInfo->wVersion      = SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION;
        PackageInfo->PackageInfo->wRPCID        = RPC_C_AUTHN_WINNT;
        PackageInfo->PackageInfo->fCapabilities = NTLMSP_CAPS;
        PackageInfo->PackageInfo->cbMaxToken    = NTLMSP_MAX_TOKEN_SIZE;

        if ( Attribute == SECPKG_ATTR_NEGOTIATION_INFO )
        {
            NegInfo = (PSecPkgContext_NegotiationInfo) PackageInfo ;
            NegInfo->NegotiationState = SECPKG_NEGOTIATION_COMPLETE ;
        }
        break;

    case SECPKG_ATTR_PASSWORD_EXPIRY:
        PasswordExpires = (PSecPkgContext_PasswordExpiry) Buffer;
        if(pContext->PasswordExpiry.QuadPart != 0) {
            PasswordExpires->tsPasswordExpires = pContext->PasswordExpiry;
        } else {
            Status = SEC_E_UNSUPPORTED_FUNCTION;
        }
        break;

    case SECPKG_ATTR_USER_FLAGS:
        UserFlags = (PSecPkgContext_UserFlags) Buffer;
        UserFlags->UserFlags = pContext->UserFlags;
        break;

    case SECPKG_ATTR_FLAGS:
    {
        BOOLEAN Client = (pContext->ClientTokenHandle == 0);
        ULONG Flags = 0;

        //
        // note: doesn't return all flags; by design.
        //
        ContextFlags = (PSecPkgContext_Flags) Buffer;
        ContextFlags->Flags = 0;

        if (pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_SEAL) {
            if( Client )
            {
                Flags |= ISC_RET_CONFIDENTIALITY;
            } else {
                Flags |= ASC_RET_CONFIDENTIALITY;
            }
        }

        if (pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_SIGN) {
            if( Client )
            {
                Flags |= ISC_RET_SEQUENCE_DETECT | ISC_RET_REPLAY_DETECT | ISC_RET_INTEGRITY;
            } else {
                Flags |= ASC_RET_SEQUENCE_DETECT | ASC_RET_REPLAY_DETECT | ASC_RET_INTEGRITY;
            }
        }

        if (pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_NULL_SESSION) {
            if( Client )
            {
                Flags |= ISC_RET_NULL_SESSION;
            } else {
                Flags |= ASC_RET_NULL_SESSION;
            }
        }

        if (pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_DATAGRAM) {
            if( Client )
            {
                Flags |= ISC_RET_DATAGRAM;
            } else {
                Flags |= ASC_RET_DATAGRAM;
            }
        }

        if (pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_IDENTIFY) {
            if( Client )
            {
                Flags |= ISC_RET_IDENTIFY;
            } else {
                Flags |= ASC_RET_IDENTIFY;
            }
        }

        ContextFlags->Flags |= Flags;

        break;
    }
	case SECPKG_ATTR_ACCESS_TOKEN:    
        AccessToken = (PSecPkgContext_AccessToken) Buffer;
        //
        // ClientTokenHandle can be NULL, for instance:
        // 1. client side context.
        // 2. incomplete server context.
        //
		if(pContext->ClientTokenHandle)
			AccessToken->AccessToken = pContext->ClientTokenHandle;
		else
			Status = SEC_E_NO_IMPERSONATION;        
        break;
    
    case SECPKG_ATTR_LIFESPAN:
    default:
        Status = STATUS_NOT_SUPPORTED;
        break;
    }


Cleanup:

    if (!NT_SUCCESS(Status))
    {
        switch (Attribute) {

        case SECPKG_ATTR_NAMES:

            if (ContextNames != NULL && ContextNames->sUserName )
            {
                NtLmFree(ContextNames->sUserName);
            }
            break;

        case SECPKG_ATTR_DCE_INFO:

            if (ContextDceInfo != NULL && ContextDceInfo->pPac)
            {
                NtLmFree(ContextDceInfo->pPac);
            }
            break;
        }
    }

    if (pContext != NULL)
    {
        (VOID) DereferenceUserContext(pContext);
    }

    SspPrint(( SSP_API, "Leaving SpQueryContextAttributes: 0x%lx\n", Status ));
    return(SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));
}



//+-------------------------------------------------------------------------
//
//  Function:   SpCompleteAuthToken
//
//  Synopsis:   Completes a context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpCompleteAuthToken(
    IN ULONG_PTR ContextHandle,
    IN PSecBufferDesc InputBuffer
    )
{
    UNREFERENCED_PARAMETER (ContextHandle);
    UNREFERENCED_PARAMETER (InputBuffer);
    SspPrint(( SSP_API, "Entering SpCompleteAuthToken\n" ));
    SspPrint(( SSP_API, "Leaving SpCompleteAuthToken\n" ));
    return(SEC_E_UNSUPPORTED_FUNCTION);
}


NTSTATUS NTAPI
SpFormatCredentials(
    IN PSecBuffer Credentials,
    OUT PSecBuffer FormattedCredentials
    )
{
    UNREFERENCED_PARAMETER (Credentials);
    UNREFERENCED_PARAMETER (FormattedCredentials);
    SspPrint(( SSP_API, "Entering SpFormatCredentials\n" ));
    SspPrint(( SSP_API, "Leaving SpFormatCredentials\n" ));
    return(SEC_E_UNSUPPORTED_FUNCTION);
}

NTSTATUS NTAPI
SpMarshallSupplementalCreds(
    IN ULONG CredentialSize,
    IN PUCHAR Credentials,
    OUT PULONG MarshalledCredSize,
    OUT PVOID * MarshalledCreds
    )
{
    UNREFERENCED_PARAMETER (CredentialSize);
    UNREFERENCED_PARAMETER (Credentials);
    UNREFERENCED_PARAMETER (MarshalledCredSize);
    UNREFERENCED_PARAMETER (MarshalledCreds);
    SspPrint(( SSP_API, "Entering SpMarshallSupplementalCreds\n" ));
    SspPrint(( SSP_API, "Leaving SpMarshallSupplementalCreds\n" ));
    return(SEC_E_UNSUPPORTED_FUNCTION);
}

//+-------------------------------------------------------------------------
//
//  Function:   NtLmMakePackedContext
//
//  Synopsis:   Maps a context to the caller's address space
//
//  Effects:
//
//  Arguments:  Context - The context to map
//              MappedContext - Set to TRUE on success
//              ContextData - Receives a buffer in the caller's address space
//                      with the mapped context.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
NtLmMakePackedContext(
    IN PNTLM_CLIENT_CONTEXT Context,
    OUT PBOOLEAN MappedContext,
    OUT PSecBuffer ContextData,
    IN ULONG Flags
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PNTLM_PACKED_CONTEXT PackedContext = NULL;
    ULONG ContextSize, ContextNameSize = 0;


    if (Context->ContextNames)
    {
        ContextNameSize = wcslen(Context->ContextNames);
    }

    ContextSize =  sizeof(NTLM_CLIENT_CONTEXT) +
                   ContextNameSize * sizeof(WCHAR) + sizeof( WCHAR );

    PackedContext = (PNTLM_PACKED_CONTEXT) NtLmAllocateLsaHeap( ContextSize );

    if (PackedContext == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    // Copy all fields of the old context

    PackedContext->Tag = NTLM_PACKED_CONTEXT_MAP ;
    PackedContext->NegotiateFlags = Context->NegotiateFlags ;
    PackedContext->SendNonce = Context->SendNonce ;
    PackedContext->RecvNonce = Context->RecvNonce ;
    RtlCopyMemory(
        PackedContext->SessionKey,
        Context->SessionKey,
        MSV1_0_USER_SESSION_KEY_LENGTH );

    PackedContext->ContextSignature = Context->ContextSignature ;
    PackedContext->PasswordExpiry = Context->PasswordExpiry ;
    PackedContext->UserFlags = Context->UserFlags ;
    if ( ContextNameSize )
    {
        PackedContext->ContextNames = sizeof( NTLM_PACKED_CONTEXT );
        PackedContext->ContextNameLength = (ContextNameSize + 1) * sizeof( WCHAR ) ;

        RtlCopyMemory(
            (PackedContext + 1),
            Context->ContextNames,
            PackedContext->ContextNameLength );

    }
    else 
    {
        PackedContext->ContextNames = 0 ;
    }

    RtlCopyMemory(
        PackedContext->SignSessionKey,
        Context->SignSessionKey,
        MSV1_0_USER_SESSION_KEY_LENGTH );

    RtlCopyMemory(
        PackedContext->VerifySessionKey,
        Context->VerifySessionKey,
        MSV1_0_USER_SESSION_KEY_LENGTH );

    RtlCopyMemory(
        PackedContext->SealSessionKey,
        Context->SealSessionKey,
        MSV1_0_USER_SESSION_KEY_LENGTH );

    RtlCopyMemory(
        PackedContext->UnsealSessionKey,
        Context->SealSessionKey,
        MSV1_0_USER_SESSION_KEY_LENGTH );

    RtlCopyMemory(
        &PackedContext->SealRc4Sched,
        &Context->SealRc4Sched,
        sizeof( struct RC4_KEYSTRUCT ) );

    RtlCopyMemory(
        &PackedContext->UnsealRc4Sched,
        &Context->UnsealRc4Sched,
        sizeof( struct RC4_KEYSTRUCT ) );


    // Replace some fields


    //
    // Token will be returned by the caller of this routine
    //

    PackedContext->ClientTokenHandle = 0 ;

    // Save the fact that it's exported
    PackedContext->NegotiateFlags |= NTLMSSP_NEGOTIATE_EXPORTED_CONTEXT;

    ContextData->pvBuffer = PackedContext;
    ContextData->cbBuffer = ContextSize;


    *MappedContext = TRUE;


    Status = STATUS_SUCCESS;

Cleanup:


    if (!NT_SUCCESS(Status))
    {
        if (PackedContext != NULL)
        {
            NtLmFreeLsaHeap(PackedContext);
        }
    }

    return(Status);

}

//+-------------------------------------------------------------------------
//
//  Function:   SpExportSecurityContext
//
//  Synopsis:   Exports a security context to another process
//
//  Effects:    Allocates memory for output
//
//  Arguments:  ContextHandle - handle to context to export
//              Flags - Flags concerning duplication. Allowable flags:
//                      SECPKG_CONTEXT_EXPORT_DELETE_OLD - causes old context
//                              to be deleted.
//              PackedContext - Receives serialized context to be freed with
//                      FreeContextBuffer
//              TokenHandle - Optionally receives handle to context's token.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
SpExportSecurityContext(
    IN ULONG_PTR ContextHandle,
    IN ULONG Flags,
    OUT PSecBuffer PackedContext,
    OUT PHANDLE TokenHandle
    )
{
    PNTLM_CLIENT_CONTEXT Context = NULL ;
    PNTLM_PACKED_CONTEXT pvContext = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SubStatus = STATUS_SUCCESS;
    ULONG ContextSize = 0;
    BOOLEAN MappedContext = FALSE;


    SspPrint(( SSP_API,"Entering SpExportSecurityContext for context 0x%x\n", ContextHandle ));

    if (ARGUMENT_PRESENT(TokenHandle))
    {
        *TokenHandle = NULL;
    }

    PackedContext->pvBuffer = NULL;
    PackedContext->cbBuffer = 0;
    PackedContext->BufferType = 0;

    Context = ReferenceUserContext(
                ContextHandle,
                FALSE           // don't unlink
                );

    if (Context == NULL)
    {
        SspPrint((SSP_CRITICAL, "SpExportSecurityContext: Invalid handle supplied (0x%x)\n",
            ContextHandle));
        Status = STATUS_INVALID_HANDLE;
        goto Cleanup;
    }

    Status = NtLmMakePackedContext(
                Context,
                &MappedContext,
                PackedContext,
                Flags
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    ASSERT(MappedContext);


    //
    // Now either duplicate the token or copy it.
    //

    if (ARGUMENT_PRESENT(TokenHandle))
    {
        ULONG LockIndex;

        LockIndex = ListIndexToLockIndex( HandleToListIndex( ContextHandle ) );

        RtlAcquireResourceShared( &NtLmUserContextLock[LockIndex], TRUE );

        if ((Flags & SECPKG_CONTEXT_EXPORT_DELETE_OLD) != 0)
        {
            RtlConvertSharedToExclusive( &NtLmUserContextLock[LockIndex] );

            *TokenHandle = Context->ClientTokenHandle;
            Context->ClientTokenHandle = NULL;
        }
        else
        {
            Status = NtDuplicateObject(
                        NtCurrentProcess(),
                        Context->ClientTokenHandle,
                        NULL,
                        TokenHandle,
                        0,              // no new access
                        0,              // no handle attributes
                        DUPLICATE_SAME_ACCESS
                        );
        }

        RtlReleaseResource( &NtLmUserContextLock[LockIndex] );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

    }

    pvContext = (PNTLM_PACKED_CONTEXT) PackedContext->pvBuffer;

    // Semantics of this flag: Export from here, but reset the Nonce.
    // We zero out the session key, since all we need is the rc4 key.

    if ((Flags & SECPKG_CONTEXT_EXPORT_RESET_NEW) != 0)
    {
        pvContext->SendNonce = (ULONG) -1;
        pvContext->RecvNonce = (ULONG) -1;
    }

    RtlZeroMemory(
        &pvContext->SessionKey,
        MSV1_0_USER_SESSION_KEY_LENGTH
        );

Cleanup:

    if (Context != NULL)
    {
        SubStatus = DereferenceUserContext(Context);

        // Don't destroy real status

        if (NT_SUCCESS(Status))
        {
            Status = SubStatus;
        }
    }

    SspPrint(( SSP_API,"Leaving SpExportContext: 0x%lx\n", Status ));
    return(SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));
}


//+-------------------------------------------------------------------------
//
//  Function:   NtLmCreateUserModeContext
//
//  Synopsis:   Creates a user-mode context to support impersonation and
//              message integrity and privacy
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
NtLmCreateUserModeContext(
    IN ULONG_PTR ContextHandle,
    IN HANDLE Token,
    IN PSecBuffer MarshalledContext,
    OUT PNTLM_CLIENT_CONTEXT * NewContext
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PNTLM_CLIENT_CONTEXT Context = NULL;
    PNTLM_PACKED_CONTEXT PackedContext;
    UINT Length = 0;
    ULONG ListIndex;
    ULONG LockIndex;

    if (MarshalledContext->cbBuffer < sizeof(NTLM_PACKED_CONTEXT))
    {
        SspPrint((SSP_CRITICAL,"NtLmCreateUserModeContext: Invalid buffer size for marshalled context: was 0x%x, needed 0x%x\n",
            MarshalledContext->cbBuffer, sizeof(NTLM_PACKED_CONTEXT)));
        return(STATUS_INVALID_PARAMETER);
    }

    PackedContext = (PNTLM_PACKED_CONTEXT) MarshalledContext->pvBuffer;

    Context = (PNTLM_CLIENT_CONTEXT)NtLmAllocate ( sizeof(NTLM_CLIENT_CONTEXT));

    if (Context == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Context->NegotiateFlags = PackedContext->NegotiateFlags ;
    Context->SendNonce = PackedContext->SendNonce ;
    Context->RecvNonce = PackedContext->RecvNonce ;
    RtlCopyMemory(
        Context->SessionKey,
        PackedContext->SessionKey,
        MSV1_0_USER_SESSION_KEY_LENGTH );

    Context->ContextSignature = PackedContext->ContextSignature ;
    Context->PasswordExpiry = PackedContext->PasswordExpiry ;
    Context->UserFlags = PackedContext->UserFlags ;

    if ( PackedContext->ContextNames )
    {
        Context->ContextNames = (PWSTR) NtLmAllocate( PackedContext->ContextNameLength );
        if ( Context->ContextNames == NULL )
        {
            Status = STATUS_INSUFFICIENT_RESOURCES ;
            goto Cleanup ;
        }

        RtlCopyMemory(
            Context->ContextNames,
            ((PUCHAR) PackedContext) + PackedContext->ContextNames,
            PackedContext->ContextNameLength );

    }
    else 
    {
        Context->ContextNames = NULL ;
    }

    RtlCopyMemory(
        Context->SignSessionKey,
        PackedContext->SignSessionKey,
        MSV1_0_USER_SESSION_KEY_LENGTH );

    RtlCopyMemory(
        Context->VerifySessionKey,
        PackedContext->VerifySessionKey,
        MSV1_0_USER_SESSION_KEY_LENGTH );

    RtlCopyMemory(
        Context->SealSessionKey,
        PackedContext->SealSessionKey,
        MSV1_0_USER_SESSION_KEY_LENGTH );
    RtlCopyMemory(
        Context->UnsealSessionKey,
        PackedContext->UnsealSessionKey,
        MSV1_0_USER_SESSION_KEY_LENGTH );

    RtlCopyMemory(
        &Context->SealRc4Sched,
        &PackedContext->SealRc4Sched,
        sizeof( struct RC4_KEYSTRUCT ) );

    RtlCopyMemory(
        &Context->UnsealRc4Sched,
        &PackedContext->UnsealRc4Sched,
        sizeof( struct RC4_KEYSTRUCT ) );

    
    // These need to be changed

    Context->ClientTokenHandle = Token;

    if (Context->SendNonce == (ULONG) -1)
    {
        Context->SendNonce = 0;
    }

    if (Context->RecvNonce == (ULONG) -1)
    {
        Context->RecvNonce = 0;
    }

    if ( Context->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2 )
    {
        Context->pSealRc4Sched = &Context->SealRc4Sched;
        Context->pUnsealRc4Sched = &Context->UnsealRc4Sched;
        Context->pSendNonce = &Context->SendNonce;
        Context->pRecvNonce = &Context->RecvNonce;
    } else {
        Context->pSealRc4Sched = &Context->SealRc4Sched;
        Context->pUnsealRc4Sched = &Context->SealRc4Sched;
        Context->pSendNonce = &Context->SendNonce;
        Context->pRecvNonce = &Context->SendNonce;
    }




    Context->References = 2;

    //
    // Modify the DACL on the token to grant access to the caller
    //

    if (Context->ClientTokenHandle != NULL)
    {
        Status = SspCreateTokenDacl(
                    Context->ClientTokenHandle
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    // Dummy up an lsa handle by incrementing a global variable. This
    // will ensure that each imported context has a unique handle.
    // Skip over values that could be interpreted as an aligned pointer,
    // so that they won't get mixed up with real lsa handles.
    Context->LsaContext = InterlockedIncrement((PLONG)&ExportedContext);
    while(Context->LsaContext % MAX_NATURAL_ALIGNMENT == 0)
    {
        Context->LsaContext = InterlockedIncrement((PLONG)&ExportedContext);
    }


    ListIndex = HandleToListIndex( Context->LsaContext );
    LockIndex = ListIndexToLockIndex( ListIndex );
    
    RtlAcquireResourceExclusive(&NtLmUserContextLock[LockIndex], TRUE);

    InsertHeadList ( &NtLmUserContextList[ListIndex], &Context->Next );
    NtLmUserContextCount[ListIndex]++;

    RtlReleaseResource(&NtLmUserContextLock[LockIndex]);

    *NewContext = Context;

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        if (Context != NULL)
        {
            FreeUserContext(Context);
        }
    }
    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   SpImportSecurityContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
SpImportSecurityContext(
    IN PSecBuffer PackedContext,
    IN HANDLE Token,
    OUT PULONG_PTR ContextHandle
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SubStatus = STATUS_SUCCESS;
    PNTLM_CLIENT_CONTEXT Context = NULL;

    SspPrint(( SSP_API,"Entering SpImportSecurityContext\n"));

    Status = NtLmCreateUserModeContext(
                0,              // no lsa context
                Token,
                PackedContext,
                &Context
                );
    if (!NT_SUCCESS(Status))
    {
        SspPrint((SSP_CRITICAL,"SpImportSecurityContext: Failed to create user mode context: 0x%x\n",
            Status));
        goto Cleanup;
    }

    *ContextHandle = Context->LsaContext;

Cleanup:

    if (Context != NULL)
    {
        SubStatus = DereferenceUserContext(Context);

        // Don't destroy real status

        if (NT_SUCCESS(Status))
        {
            Status = SubStatus;
        }
    }

    SspPrint(( SSP_API,"Leaving SpImportSecurityContext: 0x%lx\n", Status));

    return(SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR));
}



NTSTATUS
SspGetTokenUser(
    HANDLE Token,
    PTOKEN_USER pTokenUser,
    PULONG TokenUserSize
    )
/*++

RoutineDescription:

    Gets the TOKEN_USER from an open token

Arguments:

    Token - Handle to a token open for TOKEN_QUERY access

Return Value:

    STATUS_INSUFFICIENT_RESOURCES - not enough memory to complete the
        function.

    Errors from NtQueryInformationToken.

--*/

{
    NTSTATUS Status;

    Status = NtQueryInformationToken(
                Token,
                TokenUser,
                pTokenUser,
                *TokenUserSize,
                TokenUserSize
                );

    return(Status);
}


NTSTATUS
SspCreateTokenDacl(
    HANDLE Token
    )
/*++

RoutineDescription:

    Creates a new DACL for the token granting the server and client
    all access to the token.

Arguments:

    Token - Handle to an impersonation token open for TOKEN_QUERY and
        WRITE_DAC

Return Value:

    STATUS_INSUFFICIENT_RESOURCES - insufficient memory to complete
        the function.

    Errors from NtSetSecurityObject

--*/
{
    NTSTATUS Status;

    PTOKEN_USER ThreadTokenUser;
    PTOKEN_USER ImpersonationTokenUser = NULL;

    PTOKEN_USER SlowProcessTokenUser = NULL;
    PTOKEN_USER SlowThreadTokenUser = NULL;
    PTOKEN_USER SlowImpersonationTokenUser = NULL;

    ULONG_PTR FastThreadTokenUser[ 128/sizeof(ULONG_PTR) ];
    ULONG_PTR FastImpersonationTokenUser[ 128/sizeof(ULONG_PTR) ];
    ULONG TokenUserSize;

    HANDLE ProcessToken = NULL;
    HANDLE ImpersonationToken = NULL;
    BOOL fInsertImpersonatingUser = FALSE;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    ULONG AclLength;

    PACL NewDacl;
    PACL SlowNewDacl = NULL;
    ULONG_PTR FastNewDacl[ 512/sizeof(ULONG_PTR) ];

    SECURITY_DESCRIPTOR SecurityDescriptor;

    //
    // Build the two well known sids we need.
    //

    if (NtLmGlobalLocalSystemSid == NULL)
    {
        PSID pLocalSidSystem;
        PSID pOldSid;

        Status = RtlAllocateAndInitializeSid(
                    &NtAuthority,
                    1,
                    SECURITY_LOCAL_SYSTEM_RID,
                    0,0,0,0,0,0,0,
                    &pLocalSidSystem
                    );
        if (!NT_SUCCESS(Status))
        {
            SspPrint(( SSP_CRITICAL, "SspCreateTokenDacl, RtlAllocateAndInitializeSid returns 0x%lx\n", Status ));
            goto Cleanup;
        }

        pOldSid = InterlockedCompareExchangePointer(
                        &NtLmGlobalLocalSystemSid,
                        pLocalSidSystem,
                        NULL
                        );
        if( pOldSid )
        {
            RtlFreeSid( pLocalSidSystem );
        }
    }

    if (NtLmGlobalAliasAdminsSid == NULL)
    {
        PSID pLocalSidAdmins;
        PSID pOldSid;

        Status = RtlAllocateAndInitializeSid(
                    &NtAuthority,
                    2,
                    SECURITY_BUILTIN_DOMAIN_RID,
                    DOMAIN_ALIAS_RID_ADMINS,
                    0,0,0,0,0,0,
                    &pLocalSidAdmins
                    );
        if (!NT_SUCCESS(Status))
        {
            SspPrint(( SSP_CRITICAL, "SspCreateTokenDacl, RtlAllocateAndInitializeSid returns 0x%lx\n", Status ));
            goto Cleanup;
        }

        pOldSid = InterlockedCompareExchangePointer(
                        &NtLmGlobalAliasAdminsSid,
                        pLocalSidAdmins,
                        NULL
                        );
        if( pOldSid )
        {
            RtlFreeSid( pLocalSidAdmins );
        }
    }

    //
    // it's possible that the current thread is impersonating a user.
    // if that's the case, get it's token user, and revert to insure we
    // can open the process token.
    //

    Status = NtOpenThreadToken(
                            NtCurrentThread(),
                            TOKEN_QUERY | TOKEN_IMPERSONATE,
                            TRUE,
                            &ImpersonationToken
                            );

    if( NT_SUCCESS(Status) )
    {
        //
        // stop impersonating.
        //

        RevertToSelf();

        //
        // get the token user for the impersonating user.
        //

        ImpersonationTokenUser = (PTOKEN_USER)FastImpersonationTokenUser;
        TokenUserSize = sizeof(FastImpersonationTokenUser);

        Status = SspGetTokenUser(
                    ImpersonationToken,
                    ImpersonationTokenUser,
                    &TokenUserSize
                    );

        if( Status == STATUS_BUFFER_TOO_SMALL )
        {
            SlowImpersonationTokenUser = (PTOKEN_USER)NtLmAllocate( TokenUserSize );
            if(SlowImpersonationTokenUser == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            ImpersonationTokenUser = SlowImpersonationTokenUser;

            Status = SspGetTokenUser(
                        ImpersonationToken,
                        ImpersonationTokenUser,
                        &TokenUserSize
                        );

        }

        if (!NT_SUCCESS(Status))
        {
            SspPrint(( SSP_CRITICAL, "SspCreateTokenDacl, SspGetTokenUser returns 0x%lx\n", Status ));
            goto Cleanup;
        }
    }


    if( NtLmGlobalProcessUserSid == NULL )
    {
        PTOKEN_USER ProcessTokenUser;
        ULONG_PTR FastProcessTokenUser[ 128/sizeof(ULONG_PTR) ];
        PSID pOldSid;
        PSID pNewSid;
        ULONG cbNewSid;

        //
        // Open the process token to find out the user sid
        //

        Status = NtOpenProcessToken(
                    NtCurrentProcess(),
                    TOKEN_QUERY,
                    &ProcessToken
                    );

        if(!NT_SUCCESS(Status))
        {
            SspPrint(( SSP_CRITICAL, "SspCreateTokenDacl, NtOpenProcessToken returns 0x%lx\n", Status ));
            goto Cleanup;
        }

        //
        // get the token user for the process token.
        //

        ProcessTokenUser = (PTOKEN_USER)FastProcessTokenUser;
        TokenUserSize = sizeof(FastProcessTokenUser);

        Status = SspGetTokenUser(
                    ProcessToken,
                    ProcessTokenUser,
                    &TokenUserSize
                    );

        if( Status == STATUS_BUFFER_TOO_SMALL )
        {
            SlowProcessTokenUser = (PTOKEN_USER)NtLmAllocate( TokenUserSize );
            if(SlowProcessTokenUser == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            ProcessTokenUser = SlowProcessTokenUser;

            Status = SspGetTokenUser(
                        ProcessToken,
                        ProcessTokenUser,
                        &TokenUserSize
                        );

        }

        if (!NT_SUCCESS(Status))
        {
            SspPrint(( SSP_CRITICAL, "SspCreateTokenDacl, SspGetTokenUser returns 0x%lx\n", Status ));
            goto Cleanup;
        }

        cbNewSid = RtlLengthSid( ProcessTokenUser->User.Sid );
        pNewSid = NtLmAllocate( cbNewSid );
        if( pNewSid == NULL )
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        CopyMemory( pNewSid, ProcessTokenUser->User.Sid, cbNewSid );

        pOldSid = InterlockedCompareExchangePointer(
                        &NtLmGlobalProcessUserSid,
                        pNewSid,
                        NULL
                        );
        if( pOldSid )
        {
            NtLmFree( pNewSid );
        }

    }



    //
    // Now get the token user for the thread.
    //

    ThreadTokenUser = (PTOKEN_USER)FastThreadTokenUser;
    TokenUserSize = sizeof(FastThreadTokenUser);

    Status = SspGetTokenUser(
                Token,
                ThreadTokenUser,
                &TokenUserSize
                );

    if( Status == STATUS_BUFFER_TOO_SMALL )
    {
        SlowThreadTokenUser = (PTOKEN_USER)NtLmAllocate( TokenUserSize );
        if(SlowThreadTokenUser == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        ThreadTokenUser = SlowThreadTokenUser;

        Status = SspGetTokenUser(
                    Token,
                    ThreadTokenUser,
                    &TokenUserSize
                    );
    }

    if (!NT_SUCCESS(Status))
    {
        SspPrint(( SSP_CRITICAL, "SspCreateTokenDacl, SspGetTokenUser returns 0x%lx\n", Status ));
        goto Cleanup;
    }



    AclLength = 4 * sizeof( ACCESS_ALLOWED_ACE ) - 4 * sizeof( ULONG ) +
                RtlLengthSid( NtLmGlobalProcessUserSid ) +
                RtlLengthSid( ThreadTokenUser->User.Sid ) +
                RtlLengthSid( NtLmGlobalLocalSystemSid ) +
                RtlLengthSid( NtLmGlobalAliasAdminsSid ) +
                sizeof( ACL );

    //
    // determine if we need to add impersonation token sid onto the token Dacl.
    //

    if( ImpersonationTokenUser &&
        !RtlEqualSid( ImpersonationTokenUser->User.Sid, NtLmGlobalProcessUserSid ) &&
        !RtlEqualSid( ImpersonationTokenUser->User.Sid, ThreadTokenUser->User.Sid )
        )
    {
        AclLength += (sizeof(ACCESS_ALLOWED_ACE) - sizeof( ULONG )) +
                RtlLengthSid( ImpersonationTokenUser->User.Sid );

        fInsertImpersonatingUser = TRUE;
    }


    if( AclLength <= sizeof(FastNewDacl) )
    {
        NewDacl = (PACL)FastNewDacl;
    } else {

        SlowNewDacl = (PACL)NtLmAllocate(AclLength );

        NewDacl = SlowNewDacl;

        if (SlowNewDacl == NULL) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            SspPrint(( SSP_CRITICAL, "SspCreateTokenDacl, NtLmallocate returns 0x%lx\n", NewDacl));
            goto Cleanup;
        }


    }

    Status = RtlCreateAcl( NewDacl, AclLength, ACL_REVISION2 );
    ASSERT(NT_SUCCESS( Status ));

    Status = RtlAddAccessAllowedAce (
                 NewDacl,
                 ACL_REVISION2,
                 TOKEN_ALL_ACCESS,
                 NtLmGlobalProcessUserSid
                 );
    ASSERT( NT_SUCCESS( Status ));

    Status = RtlAddAccessAllowedAce (
                 NewDacl,
                 ACL_REVISION2,
                 TOKEN_ALL_ACCESS,
                 ThreadTokenUser->User.Sid
                 );
    ASSERT( NT_SUCCESS( Status ));

    if( fInsertImpersonatingUser )
    {
        Status = RtlAddAccessAllowedAce (
                     NewDacl,
                     ACL_REVISION2,
                     TOKEN_ALL_ACCESS,
                     ImpersonationTokenUser->User.Sid
                     );
        ASSERT( NT_SUCCESS( Status ));
    }

    Status = RtlAddAccessAllowedAce (
                 NewDacl,
                 ACL_REVISION2,
                 TOKEN_ALL_ACCESS,
                 NtLmGlobalAliasAdminsSid
                 );
    ASSERT( NT_SUCCESS( Status ));

    Status = RtlAddAccessAllowedAce (
                 NewDacl,
                 ACL_REVISION2,
                 TOKEN_ALL_ACCESS,
                 NtLmGlobalLocalSystemSid
                 );
    ASSERT( NT_SUCCESS( Status ));

    Status = RtlCreateSecurityDescriptor (
                 &SecurityDescriptor,
                 SECURITY_DESCRIPTOR_REVISION
                 );
    ASSERT( NT_SUCCESS( Status ));

    Status = RtlSetDaclSecurityDescriptor(
                 &SecurityDescriptor,
                 TRUE,
                 NewDacl,
                 FALSE
                 );

    ASSERT( NT_SUCCESS( Status ));

    Status = NtSetSecurityObject(
                 Token,
                 DACL_SECURITY_INFORMATION,
                 &SecurityDescriptor
                 );

    ASSERT( NT_SUCCESS( Status ));


Cleanup:

    if (ImpersonationToken != NULL)
    {
        //
        // put the thread token back if we were impersonating.
        //

        SetThreadToken( NULL, ImpersonationToken );
        NtClose(ImpersonationToken);
    }


    if (SlowThreadTokenUser != NULL) {
        NtLmFree( SlowThreadTokenUser );
    }

    if (SlowProcessTokenUser != NULL) {
        NtLmFree( SlowProcessTokenUser );
    }

    if (SlowImpersonationTokenUser != NULL) {

        NtLmFree( SlowImpersonationTokenUser );
    }

    if (SlowNewDacl != NULL) {
        NtLmFree( SlowNewDacl );
    }

    if (ProcessToken != NULL)
    {
        NtClose(ProcessToken);
    }

    return( Status );
}



NTSTATUS
SspMapContext(
    IN PULONG_PTR   phContext,
    IN PUCHAR       pSessionKey,
    IN ULONG        NegotiateFlags,
    IN HANDLE       TokenHandle,
    IN PTimeStamp   PasswordExpiry OPTIONAL,
    IN ULONG        UserFlags,
    OUT PSecBuffer  ContextData
    )

/*++

RoutineDescription:

    Create a local context for a real context
    Don't link it to out list of local contexts.

Arguments:

Return Value:

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PNTLM_PACKED_CONTEXT pContext = NULL;
    ULONG cbContextData;

    WCHAR ContextNames[(UNLEN + DNS_MAX_NAME_LENGTH + 2 + 1) *sizeof (WCHAR)];

    PLUID pLogonId = NULL;
    TOKEN_STATISTICS TokenStats;

    PSSP_CONTEXT pTempContext = (PSSP_CONTEXT)*phContext;
    PACTIVE_LOGON *ActiveLogon = NULL, Logon = NULL;
    LPWSTR UserName = NULL;
    UINT Length = 0;
    BOOLEAN ActiveLogonsAreLocked = FALSE;

    if (pTempContext == NULL)
    {
        Status = STATUS_INVALID_HANDLE;
        SspPrint(( SSP_CRITICAL, "SspMapContext, pTempContext is 0x%lx\n", pTempContext));
        goto Cleanup;
    }

    if( pTempContext->Credential != NULL ) {
        pLogonId = &(pTempContext->Credential->LogonId);
    } else {

        //
        // if it was a local call where the default creds were used, lookup
        // the username and domain name based on the AuthenticationId of the
        // access token.  The local call gets a duplicated access token
        // associated with the original client, so information on this logon
        // should be found in the active logon list.
        //

        if( NegotiateFlags & NTLMSSP_NEGOTIATE_LOCAL_CALL &&
            pTempContext->UserName.Length == 0 &&
            pTempContext->UserName.Buffer == NULL &&
            pTempContext->DomainName.Length == 0 &&
            pTempContext->DomainName.Buffer == NULL &&
            TokenHandle ) {

            DWORD TokenInfoLength = sizeof( TokenStats );

            if( GetTokenInformation(
                        TokenHandle,
                        TokenStatistics,
                        &TokenStats,
                        TokenInfoLength,
                        &TokenInfoLength
                        )) {

                pLogonId = &(TokenStats.AuthenticationId);

            }

        }

    }

    if( pLogonId )
    {
        NlpLockActiveLogonsRead();
        ActiveLogonsAreLocked = TRUE;
        if (!NlpFindActiveLogon (
                 pLogonId,
                 &ActiveLogon))
        {
//            Status = STATUS_NO_SUCH_LOGON_SESSION;
            SspPrint(( SSP_API_MORE, "SspMapContext, NlpFindActiveLogon returns FALSE\n"));
//            SspPrint(( SSP_CRITICAL, "SspMapContext, NlpFindActiveLogon returns FALSE\n"));
//            goto Cleanup;
        }
    }

    if (ActiveLogon != NULL)
    {
        Logon = *ActiveLogon;
    }

    ContextNames[0] = L'\0';

    if (Logon != NULL)
    {
        if ( (Logon->UserName.Length > 0)  &&
             (Logon->LogonDomainName.Length > 0))
        {
            RtlCopyMemory (ContextNames,
                           Logon->LogonDomainName.Buffer,
                           Logon->LogonDomainName.Length);

            Length = (Logon->LogonDomainName.Length)/sizeof(WCHAR);

            ContextNames[Length] = L'\\';
            Length += 1;
            UserName = &ContextNames[Length];

            RtlCopyMemory (UserName,
                           Logon->UserName.Buffer,
                           Logon->UserName.Length);

            Length += (Logon->UserName.Length)/sizeof(WCHAR);

            ContextNames[Length] = L'\0';

        }
    }
    else
    {
        // We don't store network logons, but in the case of server side
        // mapping, the client has sent us the Context Names, so use that.
        // Also, handle the case where we don't have domainnames, just usernames
        // Must handle the valid case where both domainname & username are NULL (rdr)

        if ((pTempContext->DomainName.Length > 0)  &&
            (pTempContext->UserName.Length > 0))
        {
            RtlCopyMemory (ContextNames,
                           pTempContext->DomainName.Buffer,
                           pTempContext->DomainName.Length);

            Length = (pTempContext->DomainName.Length)/sizeof(WCHAR);

            ContextNames[Length] = L'\\';
            Length += 1;
            UserName = &ContextNames[Length];

            RtlCopyMemory (UserName,
                           pTempContext->UserName.Buffer,
                           pTempContext->UserName.Length);

            Length += (pTempContext->UserName.Length)/sizeof(WCHAR);

            ContextNames[Length] = L'\0';

        }
        else if ((pTempContext->DomainName.Length == 0) &&
                 (pTempContext->UserName.Length >0))
        {
            RtlCopyMemory (ContextNames + Length,
                           pTempContext->UserName.Buffer,
                           pTempContext->UserName.Length);

            Length = (pTempContext->UserName.Length)/sizeof(WCHAR);

            ContextNames[Length] = L'\0';
        }
    }

    //
    // when domain is present, don't supply domain\UPN, supply domain\user
    //

    if( UserName ) {
        DWORD cchUserName = wcslen(UserName);
        DWORD i;

        for( i = 0 ; i < cchUserName ; i++ ) {

            if( UserName[ i ] == L'@' ) {
                UserName[ i ] = L'\0';
                break;
            }
        }
    }

    Length = wcslen(ContextNames) * sizeof(WCHAR);

    cbContextData =
                    sizeof(NTLM_PACKED_CONTEXT) +
                    Length +
                    sizeof(WCHAR);

    cbContextData += pTempContext->cbMarshalledTargetInfo;

     // the first sizeof (NTLM_CLIENT_CONTEXT) bytes can be
     // casted to pContext anyway.

    pContext = (PNTLM_PACKED_CONTEXT)NtLmAllocateLsaHeap( cbContextData );

    if (!pContext)
    {
        SspPrint(( SSP_CRITICAL, "SspMapContext, NtLmAllocate returns NULL\n"));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

//    ZeroMemory( pContext, cbContextData );

    pContext->NegotiateFlags = NegotiateFlags;


    RtlCopyMemory(  pContext->SessionKey,
                    pSessionKey,
                    MSV1_0_USER_SESSION_KEY_LENGTH);


    // Save away the LsaContextHandle
//    pContext->LsaContext = *phContext;

    // dup token if it exists

    pContext->ClientTokenHandle = 0 ;

    if (TokenHandle != NULL)
    {
        HANDLE Tmp ;
        Status = LsaFunctions->DuplicateHandle(
                           TokenHandle,
                           &Tmp );

        if (!NT_SUCCESS(Status))
        {
            if (pContext)
            {
                NtLmFreeLsaHeap(pContext);
            }
            SspPrint(( SSP_CRITICAL, "SspMapContext, DuplicateHandle returns 0x%lx\n", Status));
            goto Cleanup;
        }

        pContext->ClientTokenHandle = (ULONG) ((ULONG_PTR) Tmp) ;
    }

    if (cbContextData > sizeof(NTLM_PACKED_CONTEXT) )
    {
        pContext->ContextNames = sizeof(NTLM_PACKED_CONTEXT);
        pContext->ContextNameLength = Length;

        RtlCopyMemory(pContext+1,
                      ContextNames,
                      pContext->ContextNameLength
                      );


        pContext->ContextNameLength += sizeof(WCHAR);
    }
    else
    {
        pContext->ContextNames = 0;
        pContext->ContextNameLength = 0;
    }


    if( pTempContext->pbMarshalledTargetInfo )
    {
        pContext->MarshalledTargetInfo = (ULONG)pContext->ContextNameLength + sizeof(NTLM_PACKED_CONTEXT) ;
        pContext->MarshalledTargetInfoLength = pTempContext->cbMarshalledTargetInfo;

        RtlCopyMemory( (PBYTE)pContext+pContext->MarshalledTargetInfo,
                        pTempContext->pbMarshalledTargetInfo,
                        pContext->MarshalledTargetInfoLength
                        );

    }

    pContext->SendNonce = 0;
    pContext->RecvNonce = 0;


    ContextData->pvBuffer = pContext;
    ContextData->cbBuffer = cbContextData;


    if(ARGUMENT_PRESENT(PasswordExpiry)) {
        pContext->PasswordExpiry = *PasswordExpiry;
    } else {
        pContext->PasswordExpiry.QuadPart = 0;
    }

    pContext->UserFlags = UserFlags;

Cleanup:
    if (ActiveLogonsAreLocked)
    {
        NlpUnlockActiveLogons();
    }
    return(Status);
}


ULONG
HandleToListIndex(
    ULONG_PTR ContextHandle
    )
{
    ASSERT( (NTLM_USERLIST_COUNT != 0) );
    ASSERT( (NTLM_USERLIST_COUNT & 1) == 0 );
    
    ULONG Number ;
    ULONG Hash;
    ULONG HashFinal;

    Number       = (ULONG)ContextHandle;

    Hash         = Number;
    Hash        += Number >> 8;
    Hash        += Number >> 16;
    Hash        += Number >> 24;

    HashFinal    = Hash;
    HashFinal   += Hash >> 4;

    //
    // insure power of two if not one.
    //

    return ( HashFinal & (NTLM_USERLIST_COUNT-1) ) ;
}

ULONG
__inline
ListIndexToLockIndex(
    ULONG ListIndex
    )
{
    ASSERT( (NTLM_USERLIST_LOCK_COUNT) != 0 );
    ASSERT( (NTLM_USERLIST_LOCK_COUNT & 1) == 0 );

    //
    // insure power of two if not one.
    //
    
    return ( ListIndex & (NTLM_USERLIST_LOCK_COUNT-1) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\utility.cxx ===
/*++

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    utility.cxx

Abstract:

    Private NtLmSsp service utility routines.

Author:

    Cliff Van Dyke (cliffv) 9-Jun-1993

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:
    ChandanS  06-Aug-1996 Stolen from net\svcdlls\ntlmssp\common\utility.c

--*/

//
// Common include files.
//

#include <global.h>

//
// Include files specific to this .c file
//

#include <netlib.h>     // NetpMemoryFree()
#include <secobj.h>     // ACE_DATA ...
#include <stdio.h>      // vsprintf().
#include <tstr.h>       // TCHAR_ equates.

#define SSP_TOKEN_ACCESS (READ_CONTROL              |\
                          WRITE_DAC                 |\
                          TOKEN_DUPLICATE           |\
                          TOKEN_IMPERSONATE         |\
                          TOKEN_QUERY               |\
                          TOKEN_QUERY_SOURCE        |\
                          TOKEN_ADJUST_PRIVILEGES   |\
                          TOKEN_ADJUST_GROUPS       |\
                          TOKEN_ADJUST_DEFAULT)


#if DBG


SECURITY_STATUS
SspNtStatusToSecStatus(
    IN NTSTATUS NtStatus,
    IN SECURITY_STATUS DefaultStatus
    )
/*++

Routine Description:

    Convert an NtStatus code to the corresponding Security status code. For
    particular errors that are required to be returned as is (for setup code)
    don't map the errors.


Arguments:

    NtStatus - NT status to convert

Return Value:

    Returns security status code.

--*/
{
    //
    // this routine is left here for DBG builds to enable the developer
    // to ASSERT on status codes, etc.
    //

    return(NtStatus);
}

#endif


BOOLEAN
SspTimeHasElapsed(
    IN LARGE_INTEGER StartTime,
    IN DWORD Timeout
    )
/*++

Routine Description:

    Determine if "Timeout" milliseconds have elapsed since StartTime.

Arguments:

    StartTime - Specifies an absolute time when the event started (100ns units).

    Timeout - Specifies a relative time in milliseconds.  0xFFFFFFFF indicates
        that the time will never expire.

Return Value:

    TRUE -- iff Timeout milliseconds have elapsed since StartTime.

--*/
{
    LARGE_INTEGER TimeNow;
    LARGE_INTEGER ElapsedTime;
    LARGE_INTEGER Period;

    //
    // If the period to too large to handle (i.e., 0xffffffff is forever),
    //  just indicate that the timer has not expired.
    //
    // (0x7fffffff is a little over 24 days).
    //

    if ( Timeout> 0x7fffffff ) {
        return FALSE;
    }

    //
    // Compute the elapsed time
    //

    NtQuerySystemTime( &TimeNow );
    ElapsedTime.QuadPart = TimeNow.QuadPart - StartTime.QuadPart;

    //
    // Convert Timeout from milliseconds into 100ns units.
    //

    Period.QuadPart = Int32x32To64( (LONG)Timeout, 10000 );


    //
    // If the elapsed time is negative (totally bogus),
    //  or greater than the maximum allowed,
    //  indicate the period has elapsed.
    //

    if ( ElapsedTime.QuadPart < 0 || ElapsedTime.QuadPart > Period.QuadPart ) {
        return TRUE;
    }

    return FALSE;
}


SECURITY_STATUS
SspDuplicateToken(
    IN HANDLE OriginalToken,
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    OUT PHANDLE DuplicatedToken
    )
/*++

Routine Description:

    Duplicates a token

Arguments:

    OriginalToken - Token to duplicate
    DuplicatedToken - Receives handle to duplicated token

Return Value:

    Any error from NtDuplicateToken

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE QualityOfService;

    InitializeObjectAttributes(
        &ObjectAttributes,
        NULL,
        0,
        NULL,
        NULL
        );

    QualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    QualityOfService.EffectiveOnly = FALSE;
    QualityOfService.ContextTrackingMode = SECURITY_STATIC_TRACKING;
    QualityOfService.ImpersonationLevel = ImpersonationLevel;
    ObjectAttributes.SecurityQualityOfService = &QualityOfService;

    Status = NtDuplicateToken(
                OriginalToken,
                SSP_TOKEN_ACCESS,
                &ObjectAttributes,
                FALSE,
                TokenImpersonation,
                DuplicatedToken
                );

    return(SspNtStatusToSecStatus(Status, SEC_E_NO_IMPERSONATION));
}


LPWSTR
SspAllocWStrFromWStr(
    IN LPWSTR Unicode
    )

/*++

Routine Description:

    Allocate and copy unicode string (wide character strdup)

Arguments:

    Unicode - pointer to wide character string to make copy of

Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated UNICODE string in
    an allocated buffer.  The buffer must be freed using NtLmFree.

--*/

{
    DWORD   Size;
    LPWSTR  ptr;

    Size = WCSSIZE(Unicode);
    ptr = (LPWSTR)NtLmAllocate(Size);
    if ( ptr != NULL) {
        RtlCopyMemory(ptr, Unicode, Size);
    }
    return ptr;
}


VOID
SspHidePassword(
    IN OUT PUNICODE_STRING Password
    )
/*++

Routine Description:

    Run-encodes the password so that it is not very visually
    distinguishable.  This is so that if it makes it to a
    paging file, it wont be obvious.


    WARNING - This routine will use the upper portion of the
    password's length field to store the seed used in encoding
    password.  Be careful you don't pass such a string to
    a routine that looks at the length (like and RPC routine).

Arguments:

    Seed - The seed to use to hide the password.

    PasswordSource - Contains password to hide.

Return Value:


--*/
{
    SspPrint((SSP_API_MORE, "Entering SspHidePassword\n"));

    if( (Password->Length != 0) && (Password->MaximumLength != 0) )
    {
        LsaFunctions->LsaProtectMemory( Password->Buffer, (ULONG)Password->MaximumLength );
    }

    SspPrint((SSP_API_MORE, "Leaving SspHidePassword\n"));
}


VOID
SspRevealPassword(
    IN OUT PUNICODE_STRING HiddenPassword
    )
/*++

Routine Description

    Reveals a previously hidden password so that it
    is plain text once again.

Arguments:

    HiddenPassword - Contains the password to reveal

Return Value

--*/
{
    SspPrint((SSP_API_MORE, "Entering SspRevealPassword\n"));

    if( (HiddenPassword->Length != 0) && (HiddenPassword->MaximumLength != 0) )
    {
        LsaFunctions->LsaUnprotectMemory( HiddenPassword->Buffer, (ULONG)HiddenPassword->MaximumLength );
    }

    SspPrint((SSP_API_MORE, "Leaving SspRevealPassword\n"));
}


BOOLEAN
SspGetTokenBuffer(
    IN PSecBufferDesc TokenDescriptor OPTIONAL,
    IN ULONG BufferIndex,
    OUT PSecBuffer * Token,
    IN BOOLEAN ReadonlyOK
    )

/*++

Routine Description:

    This routine parses a Token Descriptor and pulls out the useful
    information.

Arguments:

    TokenDescriptor - Descriptor of the buffer containing (or to contain) the
        token. If not specified, TokenBuffer and TokenSize will be returned
        as NULL.

    TokenBuffer - Returns a pointer to the buffer for the token.

    TokenSize - Returns a pointer to the location of the size of the buffer.

    ReadonlyOK - TRUE if the token buffer may be readonly.

Return Value:

    TRUE - If token buffer was properly found.

--*/

{
    ULONG i, Index = 0;

    //
    // If there is no TokenDescriptor passed in,
    //  just pass out NULL to our caller.
    //

    ASSERT(*Token != NULL);
    if ( !ARGUMENT_PRESENT( TokenDescriptor) ) {
        return TRUE;
    }

    if (TokenDescriptor->ulVersion != SECBUFFER_VERSION)
    {
        return FALSE;
    }

    //
    // Loop through each described buffer.
    //

    for ( i=0; i<TokenDescriptor->cBuffers ; i++ ) {
        PSecBuffer Buffer = &TokenDescriptor->pBuffers[i];
        if ( (Buffer->BufferType & (~SECBUFFER_ATTRMASK)) == SECBUFFER_TOKEN ) {

            //
            // If the buffer is readonly and readonly isn't OK,
            // reject the buffer.
            //

            if (!ReadonlyOK && (Buffer->BufferType & SECBUFFER_READONLY))
            {
                return  FALSE;
            }

            //
            // It is possible that there are > 1 buffers of type SECBUFFER_TOKEN
            // eg, the rdr
            //

            if (Index != BufferIndex)
            {
                Index++;
                continue;
            }

            //
            // Return the requested information
            //

            if (!NT_SUCCESS(LsaFunctions->MapBuffer(Buffer, Buffer)))
            {
                return FALSE;
            }
            *Token = Buffer;
            return TRUE;
        }

    }

    //
    // If we didn't have a buffer, fine.
    //

    SspPrint((SSP_API_MORE, "SspGetTokenBuffer: No token passed in\n"));

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\kernel\krnlapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1999
//
// File:        krnlapi.cxx
//
// Contents:    Kernel-mode APIs to the NTLM package
//
//
// History:     07-Sep-1996   Created         ChandanS
//
//------------------------------------------------------------------------

#include <ntlmkrnl.h>
extern "C"
{
#include <cryptdll.h>
#include <zwapi.h>
}

#include "crc32.h"  // How to use crc32

extern "C"
{
#include <rc4.h>    // How to use RC4 routine
#include <md5.h>
#include <hmac.h>
}

#define DEFENSIVE_HANDLES


// Context Signatures

#define NTLM_CONTEXT_SIGNATURE 'MLTN'
#define NTLM_CONTEXT_DELETED_SIGNATURE 'XXXX'

// Keep this is sync with NTLM_KERNEL_CONTEXT defined in
// security\msv_sspi\userapi.cxx

typedef struct _NTLM_KERNEL_CONTEXT{
    KSEC_LIST_ENTRY      List;
    ULONG_PTR            LsaContext;
    ULONG                NegotiateFlags;
    HANDLE               ClientTokenHandle;
    PACCESS_TOKEN        AccessToken;

    PULONG                  pSendNonce;      // ptr to nonce to use for send
    PULONG                  pRecvNonce;      // ptr to nonce to use for receive
    struct RC4_KEYSTRUCT *  pSealRc4Sched;   // ptr to key sched used for Seal
    struct RC4_KEYSTRUCT *  pUnsealRc4Sched; // ptr to key sched used to Unseal

    ULONG                   SendNonce;
    ULONG                   RecvNonce;
    LPWSTR                  ContextNames;
    PUCHAR                  pbMarshalledTargetInfo;
    ULONG                   cbMarshalledTargetInfo;
    UCHAR                SessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];
    ULONG                ContextSignature;
    ULONG                References ;
    TimeStamp            PasswordExpiry;
    ULONG                UserFlags;
    UCHAR                   SignSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];
    UCHAR                   VerifySessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];
    UCHAR                   SealSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];
    UCHAR                   UnsealSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];

    ULONG64                 Pad1;           // pad keystructs to 64.
    struct RC4_KEYSTRUCT    SealRc4Sched;   // key struct used for Seal
    ULONG64                 Pad2;           // pad keystructs to 64.
    struct RC4_KEYSTRUCT    UnsealRc4Sched; // key struct used to Unseal
} NTLM_KERNEL_CONTEXT, * PNTLM_KERNEL_CONTEXT;

typedef struct _NTLM_PACKED_CONTEXT {
    ULONG   Tag ;
    ULONG   NegotiateFlags ;
    ULONG   ClientTokenHandle ;
    ULONG   SendNonce ;
    ULONG   RecvNonce ;
    UCHAR   SessionKey[ MSV1_0_USER_SESSION_KEY_LENGTH ];
    ULONG   ContextSignature ;
    TimeStamp   PasswordExpiry ;
    ULONG   UserFlags ;
    ULONG   ContextNames ;
    ULONG   ContextNameLength ;
    ULONG   MarshalledTargetInfo;       // offset
    ULONG   MarshalledTargetInfoLength;
    UCHAR   SignSessionKey[ MSV1_0_USER_SESSION_KEY_LENGTH ];
    UCHAR   VerifySessionKey[ MSV1_0_USER_SESSION_KEY_LENGTH ];
    UCHAR   SealSessionKey[ MSV1_0_USER_SESSION_KEY_LENGTH ];
    UCHAR   UnsealSessionKey[ MSV1_0_USER_SESSION_KEY_LENGTH ];
    struct RC4_KEYSTRUCT    SealRc4Sched;   
    struct RC4_KEYSTRUCT    UnsealRc4Sched;
} NTLM_PACKED_CONTEXT, * PNTLM_PACKED_CONTEXT ;


#define NTLM_PACKED_CONTEXT_MAP     0

#define CSSEALMAGIC "session key to client-to-server sealing key magic constant"
#define SCSEALMAGIC "session key to server-to-client sealing key magic constant"
#define CSSIGNMAGIC "session key to client-to-server signing key magic constant"
#define SCSIGNMAGIC "session key to server-to-client signing key magic constant"

typedef enum _eSignSealOp {
    eSign,      // MakeSignature is calling
    eVerify,    // VerifySignature is calling
    eSeal,      // SealMessage is calling
    eUnseal     // UnsealMessage is calling
} eSignSealOp;


//
// Make these extern "C" to allow them to be pageable.
//

extern "C"
{
KspInitPackageFn       NtLmInitKernelPackage;
KspDeleteContextFn     NtLmDeleteKernelContext;
KspInitContextFn       NtLmInitKernelContext;
KspMapHandleFn         NtLmMapKernelHandle;
KspMakeSignatureFn     NtLmMakeSignature;
KspVerifySignatureFn   NtLmVerifySignature;
KspSealMessageFn       NtLmSealMessage;
KspUnsealMessageFn     NtLmUnsealMessage;
KspGetTokenFn          NtLmGetContextToken;
KspQueryAttributesFn   NtLmQueryContextAttributes;
KspCompleteTokenFn     NtLmCompleteToken;
SpExportSecurityContextFn NtLmExportSecurityContext;
SpImportSecurityContextFn NtLmImportSecurityContext;
KspSetPagingModeFn     NtlmSetPagingMode ;

//
// Local prototypes:
//

NTSTATUS
NtLmCreateKernelModeContext(
    IN ULONG ContextHandle,
    IN PSecBuffer MarshalledContext,
    OUT PNTLM_KERNEL_CONTEXT * NewContext
    );

NTSTATUS
NtLmMakePackedContext(
    IN PNTLM_KERNEL_CONTEXT Context,
    OUT PBOOLEAN MappedContext,
    OUT PSecBuffer ContextData,
    IN ULONG Flags
    );

NTSTATUS
NtlmFreeKernelContext (
    PNTLM_KERNEL_CONTEXT KernelContext
    );

#define NtlmReferenceContext( Context, Remove ) \
            KSecReferenceListEntry( (PKSEC_LIST_ENTRY) Context, \
                                    NTLM_CONTEXT_SIGNATURE, \
                                    Remove )

VOID
NtlmDerefContext(
    PNTLM_KERNEL_CONTEXT Context
    );

void
SspGenCheckSum(
    IN  PSecBuffer  pMessage,
    OUT PNTLMSSP_MESSAGE_SIGNATURE  pSig
    );

VOID
SspEncryptBuffer(
    IN PNTLM_KERNEL_CONTEXT pContext,
    IN struct RC4_KEYSTRUCT * pRc4Key,
    IN ULONG BufferSize,
    IN OUT PVOID Buffer
    );

VOID
SspRc4Key(
    IN ULONG                NegotiateFlags,
    OUT struct RC4_KEYSTRUCT *pRc4Key,
    IN PUCHAR               pSessionKey
    );

SECURITY_STATUS
SspSignSealHelper(
    IN PNTLM_KERNEL_CONTEXT pContext,
    IN eSignSealOp Op,
    IN OUT PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo,
    OUT PNTLMSSP_MESSAGE_SIGNATURE pSig,
    OUT PNTLMSSP_MESSAGE_SIGNATURE * ppSig
    );

} // extern "C"




#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtLmInitKernelPackage)
#pragma alloc_text(PAGE, NtLmDeleteKernelContext)
#pragma alloc_text(PAGE, NtLmInitKernelContext)
#pragma alloc_text(PAGE, NtLmMapKernelHandle)
#pragma alloc_text(PAGEMSG, NtLmMakeSignature)
#pragma alloc_text(PAGEMSG, NtLmVerifySignature)
#pragma alloc_text(PAGEMSG, NtLmSealMessage)
#pragma alloc_text(PAGEMSG, NtLmUnsealMessage)
#pragma alloc_text(PAGEMSG, NtLmGetContextToken)
#pragma alloc_text(PAGEMSG, NtLmQueryContextAttributes)
#pragma alloc_text(PAGEMSG, NtlmDerefContext )
#pragma alloc_text(PAGE, NtLmCompleteToken)
#pragma alloc_text(PAGE, NtLmExportSecurityContext)
#pragma alloc_text(PAGE, NtLmImportSecurityContext)
#pragma alloc_text(PAGEMSG, NtlmFreeKernelContext )

#pragma alloc_text(PAGE, NtLmCreateKernelModeContext )
#pragma alloc_text(PAGE, NtLmMakePackedContext )

#pragma alloc_text(PAGEMSG, SspGenCheckSum)
#pragma alloc_text(PAGEMSG, SspEncryptBuffer)
#pragma alloc_text(PAGE, SspRc4Key)
#pragma alloc_text(PAGEMSG, SspSignSealHelper)

#endif

SECPKG_KERNEL_FUNCTION_TABLE NtLmFunctionTable = {
    NtLmInitKernelPackage,
    NtLmDeleteKernelContext,
    NtLmInitKernelContext,
    NtLmMapKernelHandle,
    NtLmMakeSignature,
    NtLmVerifySignature,
    NtLmSealMessage,
    NtLmUnsealMessage,
    NtLmGetContextToken,
    NtLmQueryContextAttributes,
    NtLmCompleteToken,
    NtLmExportSecurityContext,
    NtLmImportSecurityContext,
    NtlmSetPagingMode
};

PSECPKG_KERNEL_FUNCTIONS LsaKernelFunctions;
POOL_TYPE NtlmPoolType ;
PVOID NtlmPagedList ;
PVOID NtlmNonPagedList ;
PVOID NtlmActiveList ;

#define MAYBE_PAGED_CODE() \
    if ( NtlmPoolType == PagedPool )    \
    {                                   \
        PAGED_CODE();                   \
    }



//+-------------------------------------------------------------------------
//
//  Function:   FreeKernelContext
//
//  Synopsis:   frees alloced pointers in this context and
//              then frees the context
//
//  Arguments:  KernelContext  - the unlinked kernel context
//
//  Returns:    STATUS_SUCCESS on success
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
NtlmFreeKernelContext (
    PNTLM_KERNEL_CONTEXT KernelContext
    )
{

    NTSTATUS Status = STATUS_SUCCESS;

    MAYBE_PAGED_CODE();

    DebugLog(( DEB_TRACE, "Entering FreeKernelContext\n" ));

    if (KernelContext->ContextNames != NULL)
    {
        NtLmFree (KernelContext->ContextNames);
    }

    if (KernelContext->ClientTokenHandle != NULL)
    {
        NTSTATUS IgnoreStatus;

#ifdef DEFENSIVE_HANDLES
        OBJECT_HANDLE_FLAG_INFORMATION HandleInfo ;

        HandleInfo.Inherit = FALSE ;
        HandleInfo.ProtectFromClose = FALSE ;

        IgnoreStatus = ZwSetInformationObject( 
                            KernelContext->ClientTokenHandle, 
                            ObjectHandleFlagInformation,
                            &HandleInfo,
                            sizeof(HandleInfo) );

        ASSERT( NT_SUCCESS( IgnoreStatus ) );
#endif 
        IgnoreStatus = NtClose( KernelContext->ClientTokenHandle);
        ASSERT (NT_SUCCESS (IgnoreStatus));
    }

    if (KernelContext->AccessToken != NULL)
    {
        ObDereferenceObject (KernelContext->AccessToken);
    }

    DebugLog(( DEB_TRACE, "Deleting Context 0x%lx\n", KernelContext));

    NtLmFree (KernelContext);

    DebugLog(( DEB_TRACE, "Leaving FreeKernelContext: 0x%lx\n", Status ));

    return Status;
}

//+---------------------------------------------------------------------------
//
//  Function:   NtlmDerefContext
//
//  Synopsis:   Dereference a kernel context
//
//  Arguments:  [Context] --
//
//  History:    7-07-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
NtlmDerefContext(
    PNTLM_KERNEL_CONTEXT Context
    )
{
    BOOLEAN Delete ;

    MAYBE_PAGED_CODE();

    KSecDereferenceListEntry(
                    &Context->List,
                    &Delete );

    if ( Delete )
    {
        NtlmFreeKernelContext( Context );
    }

}

//+-------------------------------------------------------------------------
//
//  Function:   NtLmInitKernelPackage
//
//  Synopsis:   Initialize an instance of the NtLm package in
//              a client's (kernel) address space
//
//  Arguments:  None
//
//  Returns:    STATUS_SUCCESS or
//              returns from ExInitializeResource
//
//  Notes:      we do what was done in SpInstanceInit()
//              from security\msv_sspi\userapi.cxx
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
NtLmInitKernelPackage(
    IN PSECPKG_KERNEL_FUNCTIONS KernelFunctions
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    DebugLog(( DEB_TRACE, "Entering NtLmInitKernelPackage\n" ));

    LsaKernelFunctions = KernelFunctions;
    //
    // Set up Context list support:
    //

    NtlmPoolType = PagedPool ;
    NtlmPagedList = LsaKernelFunctions->CreateContextList( KSecPaged );
    NtlmActiveList = NtlmPagedList ;


    DebugLog(( DEB_TRACE, "Leaving NtLmInitKernelPackage 0x%lx\n", Status ));
    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   NtLmDeleteKernelContext
//
//  Synopsis:   Deletes a kernel mode context by unlinking it and then
//              dereferencing it.
//
//  Effects:
//
//  Arguments:  KernelContextHandle - Kernel context handle of the context to delete
//              LsaContextHandle    - The Lsa mode handle
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success, STATUS_INVALID_HANDLE if the
//              context can't be located
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
NtLmDeleteKernelContext(
    IN ULONG_PTR KernelContextHandle,
    OUT PULONG_PTR LsaContextHandle
    )
{

    PNTLM_KERNEL_CONTEXT pContext = NULL;
    NTSTATUS Status = STATUS_SUCCESS, SaveStatus = STATUS_SUCCESS;
    BOOLEAN Delete ;

    PAGED_CODE();

    DebugLog(( DEB_TRACE, "Entering NtLmDeleteKernelContext\n" ));


    Status = NtlmReferenceContext( KernelContextHandle, TRUE );

    if ( NT_SUCCESS( Status ) )
    {
        pContext = (PNTLM_KERNEL_CONTEXT) KernelContextHandle ;

    }
    else
    {
        *LsaContextHandle = KernelContextHandle;
        DebugLog(( DEB_ERROR,
          "Bad kernel context 0x%lx\n", KernelContextHandle));
        goto CleanUp;

    }

    *LsaContextHandle = pContext->LsaContext;
    if ((pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_EXPORTED_CONTEXT) != 0)
    {
        // Ignore all other errors and pass back
        SaveStatus = SEC_I_NO_LSA_CONTEXT;
    }


CleanUp:


    if (pContext != NULL)
    {
        NtlmDerefContext( pContext );

    }

    if (SaveStatus == SEC_I_NO_LSA_CONTEXT)
    {
        Status = SaveStatus;
    }

    DebugLog(( DEB_TRACE, "Leaving NtLmDeleteKernelContext 0x%lx\n", Status ));
    return(Status);
}





//+-------------------------------------------------------------------------
//
//  Function:   NtLmInitKernelContext
//
//  Synopsis:   Creates a kernel-mode context from a packed LSA mode context
//
//  Arguments:  LsaContextHandle - Lsa mode context handle for the context
//              PackedContext - A marshalled buffer containing the LSA
//                  mode context.
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
NtLmInitKernelContext(
    IN ULONG_PTR LsaContextHandle,
    IN PSecBuffer PackedContext,
    OUT PULONG_PTR NewContextHandle
    )
{

    NTSTATUS Status = STATUS_SUCCESS;
    PNTLM_KERNEL_CONTEXT pContext = NULL;
    unsigned int Length = 0;

    PNTLM_PACKED_CONTEXT pTmpContext  = (PNTLM_PACKED_CONTEXT) PackedContext->pvBuffer;

    PAGED_CODE();

    DebugLog(( DEB_TRACE, "Entering NtLmInitKernelContext\n" ));

    *NewContextHandle = NULL;

    if (PackedContext->cbBuffer < sizeof(NTLM_PACKED_CONTEXT))
    {
        Status = STATUS_INVALID_PARAMETER;
        DebugLog(( DEB_ERROR,
          "Bad size of Packed context 0x%lx\n", PackedContext->cbBuffer));
        goto Cleanup;
    }

    pContext = (PNTLM_KERNEL_CONTEXT) NtLmAllocate(
                                            sizeof(NTLM_KERNEL_CONTEXT) +
                                            pTmpContext->MarshalledTargetInfoLength
                                            );

    if (!pContext)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        DebugLog(( DEB_ERROR, "Allocation error for pContext\n"));
        goto Cleanup;
    }

    RtlZeroMemory(
        pContext,
        sizeof(NTLM_KERNEL_CONTEXT)
        );

    KsecInitializeListEntry( &pContext->List, NTLM_CONTEXT_SIGNATURE );

    // Copy contents of PackedContext->pvBuffer to pContext

    pContext->ClientTokenHandle = (HANDLE) ULongToPtr(pTmpContext->ClientTokenHandle);
#ifdef DEFENSIVE_HANDLES
    if ( pContext->ClientTokenHandle )
    {
        OBJECT_HANDLE_FLAG_INFORMATION HandleInfo ;
        POBJECT_TYPE_INFORMATION TypeInfo ;
        NTSTATUS IgnoreStatus = STATUS_SUCCESS ;
        UNICODE_STRING TokenTypeName ;


        TypeInfo = (POBJECT_TYPE_INFORMATION) ExAllocatePool( PagedPool, sizeof( OBJECT_TYPE_INFORMATION ) + 16 );

        if ( TypeInfo )
        {
            IgnoreStatus = ZwQueryObject(pContext->ClientTokenHandle,
                                ObjectTypeInformation, 
                                TypeInfo, 
                                (sizeof( OBJECT_TYPE_INFORMATION ) + 16 ), 
                                NULL );

            if ( NT_SUCCESS( IgnoreStatus ) )
            {
                RtlInitUnicodeString( &TokenTypeName, L"Token" );

                if ( !RtlEqualUnicodeString( &TypeInfo->TypeName, &TokenTypeName, FALSE ))
                {
                    IgnoreStatus = STATUS_INVALID_HANDLE ;
                }
                
            }
            else if ( IgnoreStatus != STATUS_INVALID_HANDLE )
            {
                IgnoreStatus = STATUS_SUCCESS ;
            }

            ExFreePool( TypeInfo );
            
        }

        if ( !NT_SUCCESS( IgnoreStatus ) )
        {
            ASSERT( NT_SUCCESS( IgnoreStatus ) );
            Status = IgnoreStatus ;
            DebugLog(( DEB_ERROR, "Bad token handle from LSA: %p\n", pContext->ClientTokenHandle ));
            goto Cleanup;
            
        }

        HandleInfo.Inherit = FALSE ;
        HandleInfo.ProtectFromClose = TRUE ;

        IgnoreStatus = ZwSetInformationObject(
                            pContext->ClientTokenHandle,
                            ObjectHandleFlagInformation,
                            &HandleInfo,
                            sizeof( HandleInfo ) );

    }
#endif 
    pContext->LsaContext = LsaContextHandle;
    pContext->NegotiateFlags = pTmpContext->NegotiateFlags;

    //
    // keep all 128 bits here, so signing can be strong even if encrypt can't be
    //

    RtlCopyMemory(  pContext->SessionKey,
                        pTmpContext->SessionKey,
                        MSV1_0_USER_SESSION_KEY_LENGTH);

    //
    // if doing full duplex as part of NTLM2, generate different sign
    // and seal keys for each direction
    //  all we do is MD5 the base session key with a different magic constant
    //

    if ( pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2 ) {
        MD5_CTX Md5Context;
        ULONG KeyLen;

        ASSERT(MD5DIGESTLEN == MSV1_0_USER_SESSION_KEY_LENGTH);

        if( pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_128 )
            KeyLen = 16;
        else if( pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_56 )
            KeyLen = 7;
        else
            KeyLen = 5;

//        DebugLog(( SSP_SESSION_KEYS, "NTLMv2 session key size: %lu\n", KeyLen));

        //
        // make client to server encryption key
        //

        MD5Init(&Md5Context);
        MD5Update(&Md5Context, pContext->SessionKey, KeyLen);
        MD5Update(&Md5Context, (unsigned char*)CSSEALMAGIC, sizeof(CSSEALMAGIC));
        MD5Final(&Md5Context);

        //
        // if TokenHandle == NULL, this is the client side
        //  put key in the right place: for client it's seal, for server it's unseal
        //

        if (pContext->ClientTokenHandle == NULL)
            RtlCopyMemory(pContext->SealSessionKey, Md5Context.digest, MSV1_0_USER_SESSION_KEY_LENGTH);
        else
            RtlCopyMemory(pContext->UnsealSessionKey, Md5Context.digest, MSV1_0_USER_SESSION_KEY_LENGTH);

        //
        // make server to client encryption key
        //

        MD5Init(&Md5Context);
        MD5Update(&Md5Context, pContext->SessionKey, KeyLen);
        MD5Update(&Md5Context, (unsigned char*)SCSEALMAGIC, sizeof(SCSEALMAGIC));
        MD5Final(&Md5Context);
        ASSERT(MD5DIGESTLEN == MSV1_0_USER_SESSION_KEY_LENGTH);
        if (pContext->ClientTokenHandle == NULL)
            RtlCopyMemory(pContext->UnsealSessionKey, Md5Context.digest, MSV1_0_USER_SESSION_KEY_LENGTH);
        else
            RtlCopyMemory(pContext->SealSessionKey, Md5Context.digest, MSV1_0_USER_SESSION_KEY_LENGTH);

        //
        // make client to server signing key -- always 128 bits!
        //

        MD5Init(&Md5Context);
        MD5Update(&Md5Context, pContext->SessionKey, MSV1_0_USER_SESSION_KEY_LENGTH);
        MD5Update(&Md5Context, (unsigned char*)CSSIGNMAGIC, sizeof(CSSIGNMAGIC));
        MD5Final(&Md5Context);
        if (pContext->ClientTokenHandle == NULL)
            RtlCopyMemory(pContext->SignSessionKey, Md5Context.digest, MSV1_0_USER_SESSION_KEY_LENGTH);
        else
            RtlCopyMemory(pContext->VerifySessionKey, Md5Context.digest, MSV1_0_USER_SESSION_KEY_LENGTH);

        //
        // make server to client signing key
        //

        MD5Init(&Md5Context);
        MD5Update(&Md5Context, pContext->SessionKey, MSV1_0_USER_SESSION_KEY_LENGTH);
        MD5Update(&Md5Context, (unsigned char*)SCSIGNMAGIC, sizeof(SCSIGNMAGIC));
        MD5Final(&Md5Context);
        if (pContext->ClientTokenHandle == NULL)
            RtlCopyMemory(pContext->VerifySessionKey, Md5Context.digest, MSV1_0_USER_SESSION_KEY_LENGTH);
        else
            RtlCopyMemory(pContext->SignSessionKey, Md5Context.digest, MSV1_0_USER_SESSION_KEY_LENGTH);

        //
        // set pointers to different key schedule and nonce for each direction
        //  key schedule will be filled in later...
        //

        pContext->pSealRc4Sched = &pContext->SealRc4Sched;
        pContext->pUnsealRc4Sched = &pContext->UnsealRc4Sched;
        pContext->pSendNonce = &pContext->SendNonce;
        pContext->pRecvNonce = &pContext->RecvNonce;
   } else {

        //
        // just copy session key to all four keys
        //  leave them 128 bits -- they get cut to 40 bits later
        //

        RtlCopyMemory(  pContext->SealSessionKey,
                        pContext->SessionKey,
                        MSV1_0_USER_SESSION_KEY_LENGTH);
        RtlCopyMemory(  pContext->UnsealSessionKey,
                        pContext->SessionKey,
                        MSV1_0_USER_SESSION_KEY_LENGTH);
        RtlCopyMemory(  pContext->SignSessionKey,
                        pContext->SessionKey,
                        MSV1_0_USER_SESSION_KEY_LENGTH);
        RtlCopyMemory(  pContext->VerifySessionKey,
                        pContext->SessionKey,
                        MSV1_0_USER_SESSION_KEY_LENGTH);

        //
        // set pointers to share a key schedule and nonce for each direction
        //  (OK because half duplex!)
        //

        pContext->pSealRc4Sched = &pContext->SealRc4Sched;
        pContext->pUnsealRc4Sched = &pContext->SealRc4Sched;
        pContext->pSendNonce = &pContext->SendNonce;
        pContext->pRecvNonce = &pContext->SendNonce;
    }


    
    if ( pTmpContext->ContextNameLength == 0 )
    {
        //There's no string after the NTLM_KERNEL_CONTEXT struct
        pContext->ContextNames = NULL;
    }
    else
    {
        pContext->ContextNames = (LPWSTR) NtLmAllocate( pTmpContext->ContextNameLength );

        if (!pContext->ContextNames)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        RtlCopyMemory(pContext->ContextNames,
                      (PUCHAR) pTmpContext + pTmpContext->ContextNames,
                      pTmpContext->ContextNameLength );

    }

    if( pTmpContext->MarshalledTargetInfo )
    {
        pContext->pbMarshalledTargetInfo = (PUCHAR)(pContext+1);
        pContext->cbMarshalledTargetInfo = pTmpContext->MarshalledTargetInfoLength;

        RtlCopyMemory(  pContext->pbMarshalledTargetInfo,
                        (PUCHAR) pTmpContext + pTmpContext->MarshalledTargetInfo,
                        pTmpContext->MarshalledTargetInfoLength );
    }


    pContext->SendNonce = pTmpContext->SendNonce;
    pContext->RecvNonce = pTmpContext->RecvNonce;

    SspRc4Key(pContext->NegotiateFlags, &pContext->SealRc4Sched, pContext->SealSessionKey);
    SspRc4Key(pContext->NegotiateFlags, &pContext->UnsealRc4Sched, pContext->UnsealSessionKey);


    pContext->PasswordExpiry = pTmpContext->PasswordExpiry;
    pContext->UserFlags = pTmpContext->UserFlags;

    KSecInsertListEntry(
            NtlmActiveList,
            &pContext->List );

    NtlmDerefContext( pContext );

    *NewContextHandle = (ULONG_PTR) pContext;

Cleanup:

    if (!NT_SUCCESS(Status))
    {
        if (pContext != NULL)
        {
            NtlmFreeKernelContext( pContext );
        }
    }

    if (PackedContext->pvBuffer != NULL)
    {
        LsaKernelFunctions->FreeHeap(PackedContext->pvBuffer);
        PackedContext->pvBuffer = NULL;
    }

    DebugLog(( DEB_TRACE, "Leaving NtLmInitKernelContext 0x%lx\n", Status ));
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   NtLmMapKernelHandle
//
//  Synopsis:   Maps a kernel handle into an LSA handle
//
//  Arguments:  KernelContextHandle - Kernel context handle of the context to map
//              LsaContextHandle - Receives LSA context handle of the context
//                      to map
//
//  Returns:    STATUS_SUCCESS on success
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
NtLmMapKernelHandle(
    IN ULONG_PTR KernelContextHandle,
    OUT PULONG_PTR LsaContextHandle
    )
{

    NTSTATUS Status = STATUS_SUCCESS;
    PNTLM_KERNEL_CONTEXT Context = NULL;

    PAGED_CODE();

    DebugLog((DEB_TRACE,"Entering NtLmMapKernelhandle\n"));

    Status = NtlmReferenceContext( KernelContextHandle, FALSE );

    if ( NT_SUCCESS( Status ) )
    {
        Context = (PNTLM_KERNEL_CONTEXT) KernelContextHandle ;

        *LsaContextHandle = Context->LsaContext ;

        NtlmDerefContext( Context );

    }
    else
    {
        DebugLog(( DEB_WARN, "Invalid context handle - %x\n",
                    KernelContextHandle ));
        *LsaContextHandle = KernelContextHandle ;
    }

    DebugLog((DEB_TRACE,"Leaving NtLmMapKernelhandle 0x%lx\n", Status));

    return (Status);
}


//
// Bogus add-shift check sum
//

void
SspGenCheckSum(
    IN  PSecBuffer  pMessage,
    OUT PNTLMSSP_MESSAGE_SIGNATURE  pSig
    )

/*++

RoutineDescription:

    Generate a crc-32 checksum for a buffer

Arguments:

Return Value:
Notes: This was stolen from net\svcdlls\ntlmssp\client\sign.c ,
       routine SspGenCheckSum. It's possible that
       bugs got copied too

--*/

{
    MAYBE_PAGED_CODE();

    Crc32(pSig->CheckSum,pMessage->cbBuffer,pMessage->pvBuffer,&pSig->CheckSum);
}


VOID
SspEncryptBuffer(
    IN PNTLM_KERNEL_CONTEXT pContext,
    IN struct RC4_KEYSTRUCT * pRc4Key,
    IN ULONG BufferSize,
    IN OUT PVOID Buffer
    )

/*++

RoutineDescription:

    Encrypts a buffer with the RC4 key in the context.  If the context
    is for a datagram session, then the key is copied before being used
    to encrypt the buffer.

Arguments:

    pContext - Context containing the key to encrypt the data

    BufferSize - Length of buffer in bytes

    Buffer - Buffer to encrypt.
    Notes: This was stolen from net\svcdlls\ntlmssp\client\sign.c ,
           routine SspEncryptBuffer. It's possible that
           bugs got copied too

Return Value:

--*/

{
    MAYBE_PAGED_CODE();

    struct RC4_KEYSTRUCT TemporaryKey;
    struct RC4_KEYSTRUCT * EncryptionKey = pRc4Key;

    if (BufferSize == 0)
    {
        return;
    }

    //
    // For datagram (application supplied sequence numbers) before NTLM2
    // we used to copy the key before encrypting so we don't
    // have a changing key; but that reused the key stream. Now we only
    // do that when backwards compatibility is explicitly called for.
    //

    if (((pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_DATAGRAM) != 0) &&
        ((pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2) == 0) ) {

        RtlCopyMemory(
            &TemporaryKey,
            EncryptionKey,
            sizeof(TemporaryKey)
            );
        EncryptionKey = &TemporaryKey;

    }

    rc4(
        EncryptionKey,
        BufferSize,
        (PUCHAR) Buffer
        );

}


VOID
SspRc4Key(
    IN ULONG                NegotiateFlags,
    OUT struct RC4_KEYSTRUCT *pRc4Key,
    IN PUCHAR               pSessionKey
    )
/*++

RoutineDescription:

    Create an RC4 key schedule, making sure key length is OK for export

Arguments:

    NegotiateFlags  negotiate feature flags; NTLM2 bit is only one looked at
    pRc4Key         pointer to RC4 key schedule structure; filled in by this routine
    pSessionKey     pointer to session key -- must be full 16 bytes

Return Value:

--*/
{
    PAGED_CODE();

    //
    // For NTLM2, effective length was already cut down
    //

    if ((NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2) != 0) {

        rc4_key(pRc4Key, MSV1_0_USER_SESSION_KEY_LENGTH, pSessionKey);

    } else if( NegotiateFlags & NTLMSSP_NEGOTIATE_LM_KEY ) {
        UCHAR Key[MSV1_0_LANMAN_SESSION_KEY_LENGTH];
        ULONG KeyLen;

        ASSERT(MSV1_0_LANMAN_SESSION_KEY_LENGTH == 8);

        // prior to Win2k, negotiated key strength had no bearing on
        // key size.  So, to allow proper interop to NT4, we don't
        // worry about 128bit.  56bit and 40bit are the only supported options.
        // 56bit is enabled because this was introduced in Win2k, and
        // Win2k -> Win2k interops correctly.
        //
#if 0
        if( NegotiateFlags & NTLMSSP_NEGOTIATE_128 ) {
            KeyLen = 8;

        } else
#endif
        if( NegotiateFlags & NTLMSSP_NEGOTIATE_56 ) {
            KeyLen = 7;

            //
            // Put a well-known salt at the end of the key to
            // limit the changing part to 56 bits.
            //

            Key[7] = 0xa0;
        } else {
            KeyLen = 5;

            //
            // Put a well-known salt at the end of the key to
            // limit the changing part to 40 bits.
            //

            Key[5] = 0xe5;
            Key[6] = 0x38;
            Key[7] = 0xb0;
        }

///        DebugLog(( SSP_SESSION_KEYS, "Non NTLMv2 session key size: %lu\n", KeyLen));

        RtlCopyMemory(Key,pSessionKey,KeyLen);

        rc4_key(pRc4Key, MSV1_0_LANMAN_SESSION_KEY_LENGTH, Key);
    } else {
        rc4_key(pRc4Key, MSV1_0_USER_SESSION_KEY_LENGTH, pSessionKey);
    }
}



SECURITY_STATUS
SspSignSealHelper(
    IN PNTLM_KERNEL_CONTEXT pContext,
    IN eSignSealOp Op,
    IN OUT PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo,
    OUT PNTLMSSP_MESSAGE_SIGNATURE pSig,
    OUT PNTLMSSP_MESSAGE_SIGNATURE * ppSig
    )
/*++

RoutineDescription:

    Handle signing a message

Arguments:

Return Value:

--*/

{

    HMACMD5_CTX HMACMD5Context;
    UCHAR TempSig[MD5DIGESTLEN];
    NTLMSSP_MESSAGE_SIGNATURE  Sig;
    int Signature;
    ULONG i;
    PUCHAR pKey;                            // ptr to key to use for encryption
    PUCHAR pSignKey;                        // ptr to key to use for signing
    PULONG pNonce;                          // ptr to nonce to use
    struct RC4_KEYSTRUCT * pRc4Sched;       // ptr to key schedule to use

    NTLMSSP_MESSAGE_SIGNATURE  AlignedSig;


    MAYBE_PAGED_CODE();



    Signature = -1;
    for (i = 0; i < pMessage->cBuffers; i++)
    {
        if ((pMessage->pBuffers[i].BufferType & 0xFF) == SECBUFFER_TOKEN)
        {
            Signature = i;
            break;
        }
    }
    if (Signature == -1)
    {
        return(SEC_E_INVALID_TOKEN);
    }

    if (pMessage->pBuffers[Signature].cbBuffer < NTLMSSP_MESSAGE_SIGNATURE_SIZE)
    {
        return(SEC_E_INVALID_TOKEN);
    }

    *ppSig = (NTLMSSP_MESSAGE_SIGNATURE*)pMessage->pBuffers[Signature].pvBuffer;

    RtlCopyMemory( &AlignedSig, *ppSig, sizeof(AlignedSig) );

    //
    // If sequence detect wasn't requested, put on an empty
    // security token . Don't do the check if Seal/Unseal is called.
    //

    if (!(pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_SIGN) &&
       (Op == eSign || Op == eVerify))
    {
        RtlZeroMemory(pSig,NTLMSSP_MESSAGE_SIGNATURE_SIZE);
        pSig->Version = NTLM_SIGN_VERSION;
        return(SEC_E_OK);
    }

    // figure out which key, key schedule, and nonce to use
    //  depends on the op. SspAddLocalContext set up so that code on client
    //  and server just (un)seals with (un)seal key or key schedule, etc.
    //  and also sets pointers to share sending/receiving key schedule/nonce
    //  when in half duplex mode. Hence, this code gets to act as if it were
    //  always in full duplex mode.
    switch (Op) {
    case eSeal:
        pSignKey = pContext->SignSessionKey;    // if NTLM2
        pKey = pContext->SealSessionKey;
        pRc4Sched = pContext->pSealRc4Sched;
        pNonce = pContext->pSendNonce;
        break;
    case eUnseal:
        pSignKey = pContext->VerifySessionKey;  // if NTLM2
        pKey = pContext->UnsealSessionKey;
        pRc4Sched = pContext->pUnsealRc4Sched;
        pNonce = pContext->pRecvNonce;
        break;
    case eSign:
        pSignKey = pContext->SignSessionKey;    // if NTLM2
        pKey = pContext->SealSessionKey;        // might be used to encrypt the signature
        pRc4Sched = pContext->pSealRc4Sched;
        pNonce = pContext->pSendNonce;
        break;
    case eVerify:
        pSignKey = pContext->VerifySessionKey;  // if NTLM2
        pKey = pContext->UnsealSessionKey;      // might be used to decrypt the signature
        pRc4Sched = pContext->pUnsealRc4Sched;
        pNonce = pContext->pRecvNonce;
        break;
    }

    //
    // Either we can supply the sequence number, or
    // the application can supply the message sequence number.
    //

    Sig.Version = NTLM_SIGN_VERSION;

    // if we're doing the new NTLM2 version:
    if (pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2) {

        if ((pContext->NegotiateFlags & NTLMSSP_APP_SEQ) == 0)
        {
            Sig.Nonce = *pNonce;    // use our sequence number
            (*pNonce) += 1;
        }
        else {

            if (Op == eSeal || Op == eSign || MessageSeqNo != 0)
                Sig.Nonce = MessageSeqNo;
            else
                Sig.Nonce = AlignedSig.Nonce;

            //   if using RC4, must rekey for each packet
            //   RC4 is used for seal, unseal; and for encrypting the HMAC hash if
            //   key exchange was negotiated (we use just HMAC if no key exchange,
            //   so that a good signing option exists with no RC4 encryption needed)

            if (Op == eSeal || Op == eUnseal || pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH)
            {
                MD5_CTX Md5ContextReKey;

                MD5Init(&Md5ContextReKey);
                MD5Update(&Md5ContextReKey, pKey, MSV1_0_USER_SESSION_KEY_LENGTH);
                MD5Update(&Md5ContextReKey, (unsigned char*)&Sig.Nonce, sizeof(Sig.Nonce));
                MD5Final(&Md5ContextReKey);
                ASSERT(MD5DIGESTLEN == MSV1_0_USER_SESSION_KEY_LENGTH);
                SspRc4Key(pContext->NegotiateFlags, pRc4Sched, Md5ContextReKey.digest);
            }
        }

        //
        // using HMAC hash, init it with the key
        //

        HMACMD5Init(&HMACMD5Context, pSignKey, MSV1_0_USER_SESSION_KEY_LENGTH);

        //
        // include the message sequence number
        //

        HMACMD5Update(&HMACMD5Context, (unsigned char*)&Sig.Nonce, sizeof(Sig.Nonce));

        for (i = 0; i < pMessage->cBuffers ; i++ )
        {
            if (((pMessage->pBuffers[i].BufferType & 0xFF) == SECBUFFER_DATA) &&
                (pMessage->pBuffers[i].cbBuffer != 0))
            {
                // decrypt (before checksum...) if it's not READ_ONLY
                if ((Op==eUnseal)
                    && !(pMessage->pBuffers[i].BufferType & SECBUFFER_READONLY)
                )
                {
                    SspEncryptBuffer(
                        pContext,
                        pRc4Sched,
                        pMessage->pBuffers[i].cbBuffer,
                        pMessage->pBuffers[i].pvBuffer
                        );
                }

                HMACMD5Update(
                            &HMACMD5Context,
                            (unsigned char*)pMessage->pBuffers[i].pvBuffer,
                            pMessage->pBuffers[i].cbBuffer);

                //
                // Encrypt if its not READ_ONLY
                //

                if ((Op==eSeal)
                    && !(pMessage->pBuffers[i].BufferType & SECBUFFER_READONLY)
                )
                {
                    SspEncryptBuffer(
                        pContext,
                        pRc4Sched,
                        pMessage->pBuffers[i].cbBuffer,
                        pMessage->pBuffers[i].pvBuffer
                        );
                }
            }
        }

        HMACMD5Final(&HMACMD5Context, TempSig);

        //
        // use RandomPad and Checksum fields for 8 bytes of MD5 hash
        //

        RtlCopyMemory(&Sig.RandomPad, TempSig, 8);

        //
        // if we're using crypto for KEY_EXCH, may as well use it for signing too...
        //

        if (pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH)
            SspEncryptBuffer(
                pContext,
                pRc4Sched,
                8,
                &Sig.RandomPad
                );
    }
    //
    // pre-NTLM2 methods
    //
    else {

        //
        // required by CRC-32 algorithm
        //
        Sig.CheckSum = 0xffffffff;

        for (i = 0; i < pMessage->cBuffers ; i++ )
        {
            if (((pMessage->pBuffers[i].BufferType & 0xFF) == SECBUFFER_DATA) &&
                !(pMessage->pBuffers[i].BufferType & SECBUFFER_READONLY) &&
                (pMessage->pBuffers[i].cbBuffer != 0))
            {
                // decrypt (before checksum...)
                if (Op==eUnseal)
                {
                    SspEncryptBuffer(
                        pContext,
                        pRc4Sched,
                        pMessage->pBuffers[i].cbBuffer,
                        pMessage->pBuffers[i].pvBuffer
                        );
                }

                SspGenCheckSum(&pMessage->pBuffers[i], &Sig);

                // Encrypt
                if (Op==eSeal)
                {
                    SspEncryptBuffer(
                        pContext,
                        pRc4Sched,
                        pMessage->pBuffers[i].cbBuffer,
                        pMessage->pBuffers[i].pvBuffer
                        );
                }
            }
        }

        //
        // Required by CRC-32 algorithm
        //

        Sig.CheckSum ^= 0xffffffff;

        // when we encrypt 0, we will get the cipher stream for the nonce!
        Sig.Nonce = 0;

        SspEncryptBuffer(
            pContext,
            pRc4Sched,
            sizeof(NTLMSSP_MESSAGE_SIGNATURE) - sizeof(ULONG),
            &Sig.RandomPad
            );


        if ((pContext->NegotiateFlags & NTLMSSP_APP_SEQ) == 0)
        {
            Sig.Nonce ^= *pNonce;    // use our sequence number and encrypt it
            (*pNonce) += 1;
        }
        else if (Op == eSeal || Op == eSign || MessageSeqNo != 0)
            Sig.Nonce ^= MessageSeqNo;   // use caller's sequence number and encrypt it
        else
            Sig.Nonce = AlignedSig.Nonce;    // use sender's sequence number

        //
        // for SignMessage calling, does nothing (copies garbage)
        // For VerifyMessage calling, allows it to compare sig block
        // upon return to Verify without knowing whether its MD5 or CRC32
        //

        Sig.RandomPad = AlignedSig.RandomPad;
    }

    pMessage->pBuffers[Signature].cbBuffer = sizeof(NTLMSSP_MESSAGE_SIGNATURE);

    RtlCopyMemory(
        pSig,
        &Sig,
        NTLMSSP_MESSAGE_SIGNATURE_SIZE
        );

    return(SEC_E_OK);
}



//+-------------------------------------------------------------------------
//
//  Function:   NtLmMakeSignature
//
//  Synopsis:   Signs a message buffer by calculatinga checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  KernelContextHandle - Handle of the context to use to sign the
//                      message.
//              QualityOfProtection - Unused flags.
//              MessageBuffers - Contains an array of buffers to sign and
//                      to store the signature.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found.
//              STATUS_BUFFER_TOO_SMALL - the signature buffer is too small
//                      to hold the signature
//
//  Returns:
//
//  Notes: This was stolen from net\svcdlls\ntlmssp\client\sign.c ,
//         routine SspHandleSignMessage. It's possible that
//         bugs got copied too
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
NtLmMakeSignature(
    IN ULONG_PTR KernelContextHandle,
    IN ULONG fQOP,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    PNTLM_KERNEL_CONTEXT pContext;
    NTLMSSP_MESSAGE_SIGNATURE  Sig;
    NTLMSSP_MESSAGE_SIGNATURE  *pSig;

    MAYBE_PAGED_CODE();

    DebugLog(( DEB_TRACE, "Entering NtLmMakeSignature\n" ));

    UNREFERENCED_PARAMETER(fQOP);

    Status = NtlmReferenceContext( KernelContextHandle, FALSE );

    if ( NT_SUCCESS( Status ) )
    {
        pContext = (PNTLM_KERNEL_CONTEXT) KernelContextHandle ;
    }
    else
    {
        DebugLog(( DEB_ERROR,
          "Bad kernel context 0x%lx\n", KernelContextHandle));
        goto CleanUp_NoDeref;

    }


    Status = SspSignSealHelper(
                        pContext,
                        eSign,
                        pMessage,
                        MessageSeqNo,
                        &Sig,
                        &pSig
                        );


    if( !NT_SUCCESS( Status ) )
    {
        DebugLog(( DEB_ERROR, "NtLmMakeSignature, SspSignSealHelper returns %lx\n", Status ));
        goto CleanUp;
    }

    RtlCopyMemory(
        pSig,
        &Sig,
        NTLMSSP_MESSAGE_SIGNATURE_SIZE
        );

CleanUp:

    NtlmDerefContext( pContext );

CleanUp_NoDeref:

    DebugLog(( DEB_TRACE, "Leaving NtLmMakeSignature 0x%lx\n", Status ));
    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   NtLmVerifySignature
//
//  Synopsis:   Verifies a signed message buffer by calculating a checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  KernelContextHandle - Handle of the context to use to sign the
//                      message.
//              MessageBuffers - Contains an array of signed buffers  and
//                      a signature buffer.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//              QualityOfProtection - Unused flags.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found or was too small.
//
//  Returns:
//
//  Notes: This was stolen from net\svcdlls\ntlmssp\client\sign.c ,
//         routine SspHandleVerifyMessage. It's possible that
//         bugs got copied too
//
//
//--------------------------------------------------------------------------



NTSTATUS NTAPI
NtLmVerifySignature(
    IN ULONG_PTR KernelContextHandle,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo,
    OUT PULONG pfQOP
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PNTLM_KERNEL_CONTEXT pContext;

    NTLMSSP_MESSAGE_SIGNATURE   Sig;
    PNTLMSSP_MESSAGE_SIGNATURE  pSig;       // pointer to buffer with sig in it
    NTLMSSP_MESSAGE_SIGNATURE   AlignedSig; // Aligned sig buffer.

    MAYBE_PAGED_CODE();

    DebugLog(( DEB_TRACE, "Entering NtLmVerifySignature\n" ));

    UNREFERENCED_PARAMETER(pfQOP);

    Status = NtlmReferenceContext( KernelContextHandle, FALSE );

    if ( NT_SUCCESS( Status ) )
    {
        pContext = (PNTLM_KERNEL_CONTEXT) KernelContextHandle ;
    }
    else
    {
        DebugLog(( DEB_ERROR,
          "Bad kernel context 0x%lx\n", KernelContextHandle));
        goto CleanUp_NoDeref;

    }


    Status = SspSignSealHelper(
                        pContext,
                        eVerify,
                        pMessage,
                        MessageSeqNo,
                        &Sig,
                        &pSig
                        );


    if( !NT_SUCCESS( Status ) )
    {
        DebugLog(( DEB_ERROR, "NtLmVerifySignature, SspSignSealHelper returns %lx\n", Status ));
        goto CleanUp;
    }

    RtlCopyMemory( &AlignedSig, pSig, sizeof( AlignedSig ) );

    if (AlignedSig.Version != NTLM_SIGN_VERSION) {
        Status = SEC_E_INVALID_TOKEN;
        goto CleanUp;
    }

    // validate the signature...
    if (AlignedSig.CheckSum != Sig.CheckSum)
    {
        Status = SEC_E_MESSAGE_ALTERED;
        goto CleanUp;
    }

    // with MD5 sig, this now matters!
    if (AlignedSig.RandomPad != Sig.RandomPad)
    {
        Status = SEC_E_MESSAGE_ALTERED;
        goto CleanUp;
    }

    if (AlignedSig.Nonce != Sig.Nonce)
    {
        Status = SEC_E_OUT_OF_SEQUENCE;
        goto CleanUp;
    }

CleanUp:

    NtlmDerefContext( pContext );

CleanUp_NoDeref:


    DebugLog(( DEB_TRACE, "Leaving NtLmVerifySignature 0x%lx\n", Status ));
    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   NtLmSealMessage
//
//  Synopsis:   Verifies a signed message buffer by calculating a checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  KernelContextHandle - Handle of the context to use to sign the
//                      message.
//              MessageBuffers - Contains an array of signed buffers  and
//                      a signature buffer.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//              QualityOfProtection - Unused flags.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found or was too small.
//
//  Returns:
//
//  Notes: This was stolen from net\svcdlls\ntlmssp\client\sign.c ,
//         routine SspHandleSealMessage. It's possible that
//         bugs got copied too
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
NtLmSealMessage(
    IN ULONG_PTR KernelContextHandle,
    IN ULONG fQOP,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PNTLM_KERNEL_CONTEXT pContext;
    NTLMSSP_MESSAGE_SIGNATURE  Sig;
    PNTLMSSP_MESSAGE_SIGNATURE  pSig;    // pointer to buffer where sig goes

    MAYBE_PAGED_CODE();

    DebugLog(( DEB_TRACE, "Entering NtLmSealMessage\n" ));

    UNREFERENCED_PARAMETER(fQOP);

    Status = NtlmReferenceContext( KernelContextHandle, FALSE );

    if ( NT_SUCCESS( Status ) )
    {
        pContext = (PNTLM_KERNEL_CONTEXT) KernelContextHandle ;
    }
    else
    {
        DebugLog(( DEB_ERROR,
          "Bad kernel context 0x%lx\n", KernelContextHandle));
        goto CleanUp_NoDeref;

    }


    Status = SspSignSealHelper(
                    pContext,
                    eSeal,
                    pMessage,
                    MessageSeqNo,
                    &Sig,
                    &pSig
                    );

    if (!NT_SUCCESS(Status))
    {
        DebugLog(( DEB_ERROR, "SpSealMessage, SspSignSealHelper returns %lx\n", Status ));
        goto CleanUp;
    }

    RtlCopyMemory(
        pSig,
        &Sig,
        NTLMSSP_MESSAGE_SIGNATURE_SIZE
        );


CleanUp:

    NtlmDerefContext( pContext );

CleanUp_NoDeref:


    DebugLog(( DEB_TRACE, "Leaving NtLmSealMessage 0x%lx\n", Status ));
    return(Status);

}

//+-------------------------------------------------------------------------
//
//  Function:   NtLmUnsealMessage
//
//  Synopsis:   Verifies a signed message buffer by calculating a checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  KernelContextHandle - Handle of the context to use to sign the
//                      message.
//              MessageBuffers - Contains an array of signed buffers  and
//                      a signature buffer.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//              QualityOfProtection - Unused flags.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found or was too small.
//
//  Returns:
//
//  Notes: This was stolen from net\svcdlls\ntlmssp\client\sign.c ,
//         routine SspHandleUnsealMessage. It's possible that
//         bugs got copied too
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
NtLmUnsealMessage(
    IN ULONG_PTR KernelContextHandle,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo,
    OUT PULONG pfQOP
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PNTLM_KERNEL_CONTEXT pContext;

    NTLMSSP_MESSAGE_SIGNATURE   Sig;
    PNTLMSSP_MESSAGE_SIGNATURE  pSig;       // pointer to buffer where sig goes
    NTLMSSP_MESSAGE_SIGNATURE   AlignedSig; // aligned buffer.

    MAYBE_PAGED_CODE();

    DebugLog(( DEB_TRACE, "Entering NtLmUnsealMessage\n" ));

    UNREFERENCED_PARAMETER(pfQOP);

    Status = NtlmReferenceContext( KernelContextHandle, FALSE );

    if ( NT_SUCCESS( Status ) )
    {
        pContext = (PNTLM_KERNEL_CONTEXT) KernelContextHandle ;
    }
    else
    {
        DebugLog(( DEB_ERROR,
          "Bad kernel context 0x%lx\n", KernelContextHandle));
        goto CleanUp_NoDeref;

    }

    Status = SspSignSealHelper(
                    pContext,
                    eUnseal,
                    pMessage,
                    MessageSeqNo,
                    &Sig,
                    &pSig
                    );

    if (!NT_SUCCESS(Status))
    {
        DebugLog(( DEB_ERROR, "SpUnsealMessage, SspSignSealHelper returns %lx\n", Status ));
        goto CleanUp;
    }

    RtlCopyMemory( &AlignedSig, pSig, sizeof(AlignedSig) );

    if (AlignedSig.Version != NTLM_SIGN_VERSION) {
        Status = SEC_E_INVALID_TOKEN;
        goto CleanUp;
    }

    // validate the signature...
    if (AlignedSig.CheckSum != Sig.CheckSum)
    {
        Status = SEC_E_MESSAGE_ALTERED;
        goto CleanUp;
    }

    if (AlignedSig.RandomPad != Sig.RandomPad)
    {
        Status = SEC_E_MESSAGE_ALTERED;
        goto CleanUp;
    }

    if (AlignedSig.Nonce != Sig.Nonce)
    {
        Status = SEC_E_OUT_OF_SEQUENCE;
        goto CleanUp;
    }


CleanUp:

    NtlmDerefContext( pContext );

CleanUp_NoDeref:

    DebugLog(( DEB_TRACE, "Leaving NtLmUnsealMessage 0x%lx\n", Status ));
    return (Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   NtLmGetContextToken
//
//  Synopsis:   returns a pointer to the token for a server-side context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
NtLmGetContextToken(
    IN ULONG_PTR KernelContextHandle,
    OUT PHANDLE ImpersonationToken,
    OUT OPTIONAL PACCESS_TOKEN *RawToken
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PNTLM_KERNEL_CONTEXT pContext = NULL;

    MAYBE_PAGED_CODE();

    DebugLog(( DEB_TRACE, "Entering NtLmGetContextToken\n" ));

    Status = NtlmReferenceContext( KernelContextHandle, FALSE );

    if ( NT_SUCCESS( Status ) )
    {
        pContext = (PNTLM_KERNEL_CONTEXT) KernelContextHandle ;
    }
    else
    {
        DebugLog(( DEB_ERROR,
          "Bad kernel context 0x%lx\n", KernelContextHandle));
        goto CleanUp_NoDeref;

    }

    if (pContext->ClientTokenHandle == NULL)
    {
        DebugLog(( DEB_ERROR, "Invalid TokenHandle for context 0x%lx\n", pContext ));
        Status= SEC_E_NO_IMPERSONATION;
        goto CleanUp;
    }

    if (ARGUMENT_PRESENT(ImpersonationToken))
    {
        *ImpersonationToken = pContext->ClientTokenHandle;
    }

    if (ARGUMENT_PRESENT(RawToken))
    {
        if (pContext->ClientTokenHandle != NULL)
        {
            if (pContext->AccessToken == NULL)
            {
                Status = ObReferenceObjectByHandle(
                             pContext->ClientTokenHandle,
                             TOKEN_IMPERSONATE | TOKEN_QUERY,
                             NULL,
                             ExGetPreviousMode(),
                             (PVOID *) &pContext->AccessToken,
                             NULL);


            }
        }

        if (NT_SUCCESS(Status))
        {
            ASSERT(pContext->AccessToken != NULL);
            *RawToken = pContext->AccessToken;
        }
    }


CleanUp:

    NtlmDerefContext( pContext );

CleanUp_NoDeref:
    DebugLog(( DEB_TRACE, "Leaving NtLmGetContextToken 0x%lx\n", Status ));
    return (Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   NtLmQueryContextAttributes
//
//  Synopsis:   Querys attributes of the specified context
//              This API allows a customer of the security
//              services to determine certain attributes of
//              the context.  These are: sizes, names, and lifespan.
//
//  Effects:
//
//  Arguments:
//
//    ContextHandle - Handle to the context to query.
//
//    Attribute - Attribute to query.
//
//        #define SECPKG_ATTR_SIZES    0
//        #define SECPKG_ATTR_NAMES    1
//        #define SECPKG_ATTR_LIFESPAN 2
//
//    Buffer - Buffer to copy the data into.  The buffer must
//             be large enough to fit the queried attribute.
//
//
//  Requires:
//
//  Returns:
//
//        STATUS_SUCCESS - Call completed successfully
//
//        STATUS_INVALID_HANDLE -- Credential/Context Handle is invalid
//        STATUS_UNSUPPORTED_FUNCTION -- Function code is not supported
//
//  Notes:
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
NtLmQueryContextAttributes(
    IN ULONG_PTR KernelContextHandle,
    IN ULONG Attribute,
    IN OUT PVOID Buffer
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PSecPkgContext_NamesW ContextNames = NULL;
    PSecPkgContext_DceInfo ContextDceInfo = NULL;
    PSecPkgContext_SessionKey ContextSessionKeyInfo = NULL;
    PSecPkgContext_Sizes ContextSizes = NULL;
    PSecPkgContext_Flags ContextFlags = NULL;
    PSecPkgContext_PasswordExpiry PasswordExpires;
    PSecPkgContext_UserFlags UserFlags;
    PSecPkgContext_PackageInfo PackageInfo = NULL;
    PSecPkgContext_TargetInformation TargetInformation = NULL;

    PNTLM_KERNEL_CONTEXT pContext = NULL;
    unsigned int Length = 0;

    MAYBE_PAGED_CODE();

    DebugLog(( DEB_TRACE, "Entering NtLmQueryContextAttributes\n" ));



    Status = NtlmReferenceContext( KernelContextHandle, FALSE );

    if ( NT_SUCCESS( Status ) )
    {
        pContext = (PNTLM_KERNEL_CONTEXT) KernelContextHandle ;
    } else {

        //
        // for PACKAGE_INFO or NEGOTIATION_INFO, don't require a completed
        // context.
        //

        if( (Attribute != SECPKG_ATTR_PACKAGE_INFO) &&
            (Attribute != SECPKG_ATTR_NEGOTIATION_INFO)
            )
        {
            DebugLog(( DEB_ERROR,
            "Bad kernel context 0x%lx\n", KernelContextHandle));
            goto CleanUp_NoDeref;
        }

        Status = STATUS_SUCCESS;
    }

    //
    // Handle each of the various queried attributes
    //

    switch ( Attribute ) {
    case SECPKG_ATTR_SIZES:

        ContextSizes = (PSecPkgContext_Sizes) Buffer;
        ContextSizes->cbMaxToken = NTLMSP_MAX_TOKEN_SIZE;

        if (pContext->NegotiateFlags & (NTLMSSP_NEGOTIATE_ALWAYS_SIGN |
                                       NTLMSSP_NEGOTIATE_SIGN |
                                       NTLMSSP_NEGOTIATE_SEAL) ) {
            ContextSizes->cbMaxSignature = NTLMSSP_MESSAGE_SIGNATURE_SIZE;
        } else {
            ContextSizes->cbMaxSignature = 0;
        }

        if (pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_SEAL) {
            ContextSizes->cbBlockSize = 1;
            ContextSizes->cbSecurityTrailer = NTLMSSP_MESSAGE_SIGNATURE_SIZE;
        }
        else
        {
            ContextSizes->cbBlockSize = 0;
            ContextSizes->cbSecurityTrailer = 0;
        }

        break;

    //
    // No one uses the function so don't go to the overhead of maintaining
    // the username in the context structure.
    //

    case SECPKG_ATTR_DCE_INFO:

        ContextDceInfo = (PSecPkgContext_DceInfo) Buffer;

        if (ContextDceInfo == NULL)
        {
            DebugLog(( DEB_ERROR, "Null buffer SECPKG_ATTR_DCE_INFO.\n" ));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        if (pContext->ContextNames)
        {
            Length = wcslen(pContext->ContextNames);
        }

        ContextDceInfo->pPac = (LPWSTR) LsaKernelFunctions->AllocateHeap(
                 (Length + 1) * sizeof(WCHAR));

        if (ContextDceInfo->pPac != NULL)
        {
            RtlCopyMemory(
                ContextDceInfo->pPac,
                pContext->ContextNames,
                Length * sizeof(WCHAR));

            LPWSTR Temp =  (LPWSTR)ContextDceInfo->pPac;
            Temp[Length] = L'\0';
        }
        else
        {
            DebugLog(( DEB_ERROR, "Bad Context->pPac in SECPKG_ATTR_DCE_INFO.\n" ));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        ContextDceInfo->AuthzSvc = 0;

        break;

    case SECPKG_ATTR_NAMES:

        ContextNames = (PSecPkgContext_Names) Buffer;

        if (ContextNames == NULL)
        {
            DebugLog(( DEB_ERROR, "Null buffer SECPKG_ATTR_NAMES.\n" ));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        if (pContext->ContextNames)
        {
            Length = wcslen(pContext->ContextNames);
            DebugLog(( DEB_TRACE, "NtLmQueryContextAttributes: ContextNames length is 0x%lx\n", Length));
        }

        ContextNames->sUserName = (LPWSTR) LsaKernelFunctions->AllocateHeap(
                 (Length + 1) * sizeof(WCHAR));

        if (ContextNames->sUserName != NULL)
        {
            RtlCopyMemory(
                ContextNames->sUserName,
                pContext->ContextNames,
                Length * sizeof(WCHAR));

            ContextNames->sUserName[Length] = L'\0';
        }
        else
        {
            DebugLog(( DEB_ERROR, "Bad Context->sUserName in SECPKG_ATTR_NAMES.\n" ));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        break;

    case SECPKG_ATTR_TARGET_INFORMATION:

        TargetInformation = (PSecPkgContext_TargetInformation) Buffer;

        if (TargetInformation == NULL)
        {
            DebugLog(( DEB_ERROR, "Null buffer SECPKG_ATTR_TARGET_INFORMATION.\n" ));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        TargetInformation->MarshalledTargetInfo = NULL;

        if (pContext->pbMarshalledTargetInfo == NULL)
        {
            Status = STATUS_NOT_FOUND;
            goto Cleanup;
        }

        Length = pContext->cbMarshalledTargetInfo;
        DebugLog(( DEB_TRACE, "NtLmQueryContextAttributes: TargetInformation length is 0x%lx\n", Length));

        TargetInformation->MarshalledTargetInfo = (PUCHAR) LsaKernelFunctions->AllocateHeap(
                                                                    Length
                                                                    );

        if (TargetInformation->MarshalledTargetInfo != NULL)
        {
            RtlCopyMemory(
                TargetInformation->MarshalledTargetInfo,
                pContext->pbMarshalledTargetInfo,
                Length
                );

            TargetInformation->MarshalledTargetInfoLength = Length;
        }
        else
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        break;

    case SECPKG_ATTR_SESSION_KEY:
       ContextSessionKeyInfo = (PSecPkgContext_SessionKey) Buffer;
       ContextSessionKeyInfo->SessionKeyLength = MSV1_0_USER_SESSION_KEY_LENGTH;
       ContextSessionKeyInfo->SessionKey =
           (PUCHAR) LsaKernelFunctions->AllocateHeap(
               ContextSessionKeyInfo->SessionKeyLength);
       if (ContextSessionKeyInfo->SessionKey != NULL)
       {
           RtlCopyMemory(
               ContextSessionKeyInfo->SessionKey,
               pContext->SessionKey,
               MSV1_0_USER_SESSION_KEY_LENGTH);
       }
       else
       {
           Status = STATUS_INSUFFICIENT_RESOURCES;
       }

       break;

    case SECPKG_ATTR_PASSWORD_EXPIRY:
        PasswordExpires = (PSecPkgContext_PasswordExpiry) Buffer;
        if(pContext->PasswordExpiry.QuadPart != 0) {
            PasswordExpires->tsPasswordExpires = pContext->PasswordExpiry;
        } else {
            Status = SEC_E_UNSUPPORTED_FUNCTION;
        }
        break;

    case SECPKG_ATTR_USER_FLAGS:
        UserFlags = (PSecPkgContext_UserFlags) Buffer;
        UserFlags->UserFlags = pContext->UserFlags;
        break;

    case SECPKG_ATTR_FLAGS:
    {
        BOOLEAN Client = (pContext->ClientTokenHandle == 0);
        ULONG Flags = 0;

        ContextFlags = (PSecPkgContext_Flags) Buffer;
        ContextFlags->Flags = 0;

        if (pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_SEAL) {
            if( Client )
            {
                Flags |= ISC_RET_CONFIDENTIALITY;
            } else {
                Flags |= ASC_RET_CONFIDENTIALITY;
            }
        }

        if (pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_SIGN) {
            if( Client )
            {
                Flags |= ISC_RET_SEQUENCE_DETECT | ISC_RET_REPLAY_DETECT | ISC_RET_INTEGRITY;
            } else {
                Flags |= ASC_RET_SEQUENCE_DETECT | ASC_RET_REPLAY_DETECT | ASC_RET_INTEGRITY;
            }
        }

        if (pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_NULL_SESSION) {
            if( Client )
            {
                Flags |= ISC_RET_NULL_SESSION;
            } else {
                Flags |= ASC_RET_NULL_SESSION;
            }
        }

        if (pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_DATAGRAM) {
            if( Client )
            {
                Flags |= ISC_RET_DATAGRAM;
            } else {
                Flags |= ASC_RET_DATAGRAM;
            }
        }

        if (pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_IDENTIFY) {
            if( Client )
            {
                Flags |= ISC_RET_IDENTIFY;
            } else {
                Flags |= ASC_RET_IDENTIFY;
            }
        }

        ContextFlags->Flags |= Flags;

        break;
    }

    case SECPKG_ATTR_PACKAGE_INFO:
    case SECPKG_ATTR_NEGOTIATION_INFO:
        //
        // Return the information about this package. This is useful for
        // callers who used SPNEGO and don't know what package they got.
        //

        PackageInfo = (PSecPkgContext_PackageInfo) Buffer;

        PackageInfo->PackageInfo = (PSecPkgInfoW) LsaKernelFunctions->AllocateHeap(
                                                    sizeof(SecPkgInfoW) +
                                                    sizeof(NTLMSP_NAME) +
                                                    sizeof(NTLMSP_COMMENT)
                                                    );

        if (PackageInfo->PackageInfo == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        PackageInfo->PackageInfo->Name = (LPWSTR) (PackageInfo->PackageInfo + 1);
        PackageInfo->PackageInfo->Comment = (LPWSTR) ((((PCHAR) PackageInfo->PackageInfo->Name)) + sizeof(NTLMSP_NAME));
        wcscpy(
            PackageInfo->PackageInfo->Name,
            NTLMSP_NAME
            );

        wcscpy(
            PackageInfo->PackageInfo->Comment,
            NTLMSP_COMMENT
            );
        PackageInfo->PackageInfo->wVersion      = SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION;
        PackageInfo->PackageInfo->wRPCID        = NTLMSP_RPCID;
        PackageInfo->PackageInfo->fCapabilities = NTLMSP_CAPS;
        PackageInfo->PackageInfo->cbMaxToken    = NTLMSP_MAX_TOKEN_SIZE;

        if ( Attribute == SECPKG_ATTR_NEGOTIATION_INFO )
        {
            PSecPkgContext_NegotiationInfo NegInfo ;

            NegInfo = (PSecPkgContext_NegotiationInfo) PackageInfo ;
            if( pContext ) {
                NegInfo->NegotiationState = SECPKG_NEGOTIATION_COMPLETE ;
            } else {
                NegInfo->NegotiationState = 0;
            }
        }
        break;

    case SECPKG_ATTR_LIFESPAN:
    default:

        Status = STATUS_NOT_SUPPORTED;
        break;
    }

Cleanup:

    if (!NT_SUCCESS(Status)) {

        switch ( Attribute) {

          case SECPKG_ATTR_NAMES:

              if (ContextNames && ContextNames->sUserName)
              {
                  LsaKernelFunctions->FreeHeap(ContextNames->sUserName);
                  ContextNames->sUserName = NULL;
              }
          break;

          case SECPKG_ATTR_DCE_INFO:

              if (ContextDceInfo && ContextDceInfo->pPac)
              {
                  LsaKernelFunctions->FreeHeap(ContextDceInfo->pPac);
                  ContextDceInfo->pPac = NULL;
              }
          break;

          case SECPKG_ATTR_SESSION_KEY:

              if(ContextSessionKeyInfo && ContextSessionKeyInfo->SessionKey)
              {
                  LsaKernelFunctions->FreeHeap(ContextSessionKeyInfo->SessionKey);
                  ContextSessionKeyInfo->SessionKey = NULL;
              }
          break;

          case SECPKG_ATTR_NEGOTIATION_INFO:

              if(PackageInfo && PackageInfo->PackageInfo)
              {
                  LsaKernelFunctions->FreeHeap(PackageInfo->PackageInfo);
                  PackageInfo->PackageInfo = NULL;
              }
          break;

        }
    }

    if( pContext ) {
        NtlmDerefContext( pContext );
    }

CleanUp_NoDeref:
    DebugLog(( DEB_TRACE, "Leaving NtLmQueryContextAttributes 0x%lx\n", Status ));
    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   NtLmCompleteToken
//
//  Synopsis:   Completes a context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
NtLmCompleteToken(
    IN ULONG_PTR ContextHandle,
    IN PSecBufferDesc InputBuffer
    )
{
    UNREFERENCED_PARAMETER (ContextHandle);
    UNREFERENCED_PARAMETER (InputBuffer);
    PAGED_CODE();
    DebugLog(( DEB_TRACE, "Entering NtLmCompleteToken\n" ));
    DebugLog(( DEB_TRACE, "Leaving NtLmCompleteToken\n" ));
    return(STATUS_NOT_SUPPORTED);
}

//+-------------------------------------------------------------------------
//
//  Function:   NtLmMakePackedContext
//
//  Synopsis:   Maps a context to the caller's address space
//
//  Effects:
//
//  Arguments:  Context - The context to map
//              MappedContext - Set to TRUE on success
//              ContextData - Receives a buffer in the caller's address space
//                      with the mapped context.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
NtLmMakePackedContext(
    IN PNTLM_KERNEL_CONTEXT Context,
    OUT PBOOLEAN MappedContext,
    OUT PSecBuffer ContextData,
    IN ULONG Flags
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PNTLM_PACKED_CONTEXT PackedContext = NULL;
    ULONG ContextSize, ContextNameSize = 0;

    PAGED_CODE();


    if (Context->ContextNames)
    {
        ContextNameSize = wcslen(Context->ContextNames);
    }


    ContextSize =  sizeof(NTLM_PACKED_CONTEXT) +
                   ContextNameSize * sizeof(WCHAR);

    PackedContext = (PNTLM_PACKED_CONTEXT) NtLmAllocate(ContextSize);

    if (PackedContext == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlZeroMemory( PackedContext, ContextSize );

#if 0
    // Copy all fields of the old context


    RtlCopyMemory(
        PackedContext,
        Context,
        sizeof(NTLM_KERNEL_CONTEXT)
        );


    if (ContextNameSize > 0)
    {
        PackedContext->ContextNames = (LPWSTR) sizeof(NTLM_PACKED_CONTEXT);

        RtlCopyMemory(
            PackedContext+1,
            Context->ContextNames,
            ContextNameSize * sizeof(WCHAR));
    }
    else
    {
        PackedContext->ContextNames=NULL;
    }



    // Replace some fields

    //
    // Token will be returned by the caller of this routine
    //

    PackedContext->ClientTokenHandle = NULL;

    PackedContext->NegotiateFlags |= NTLMSSP_NEGOTIATE_EXPORTED_CONTEXT;

    if ((Flags & SECPKG_CONTEXT_EXPORT_RESET_NEW) != 0)
    {
        PackedContext->SendNonce = (ULONG) -1;
        PackedContext->RecvNonce = (ULONG) -1;
    }

    RtlZeroMemory(
        &PackedContext->SessionKey,
        MSV1_0_USER_SESSION_KEY_LENGTH
        );
#endif




    PackedContext->Tag = NTLM_PACKED_CONTEXT_MAP ;
    PackedContext->NegotiateFlags = Context->NegotiateFlags ;
    PackedContext->SendNonce = Context->SendNonce ;
    PackedContext->RecvNonce = Context->RecvNonce ;
    RtlCopyMemory(
        PackedContext->SessionKey,
        Context->SessionKey,
        MSV1_0_USER_SESSION_KEY_LENGTH );

    PackedContext->ContextSignature = Context->ContextSignature ;
    PackedContext->PasswordExpiry = Context->PasswordExpiry ;
    PackedContext->UserFlags = Context->UserFlags ;
    if ( ContextNameSize )
    {
        PackedContext->ContextNames = sizeof( NTLM_PACKED_CONTEXT );
        PackedContext->ContextNameLength = (ContextNameSize + 1) * sizeof( WCHAR ) ;

        RtlCopyMemory(
            (PackedContext + 1),
            Context->ContextNames,
            PackedContext->ContextNameLength );

    }
    else 
    {
        PackedContext->ContextNames = 0 ;
    }

    RtlCopyMemory(
        PackedContext->SignSessionKey,
        Context->SignSessionKey,
        MSV1_0_USER_SESSION_KEY_LENGTH );

    RtlCopyMemory(
        PackedContext->VerifySessionKey,
        Context->VerifySessionKey,
        MSV1_0_USER_SESSION_KEY_LENGTH );

    RtlCopyMemory(
        PackedContext->SealSessionKey,
        Context->SealSessionKey,
        MSV1_0_USER_SESSION_KEY_LENGTH );

    RtlCopyMemory(
        PackedContext->UnsealSessionKey,
        Context->SealSessionKey,
        MSV1_0_USER_SESSION_KEY_LENGTH );

    RtlCopyMemory(
        &PackedContext->SealRc4Sched,
        &Context->SealRc4Sched,
        sizeof( struct RC4_KEYSTRUCT ) );

    RtlCopyMemory(
        &PackedContext->UnsealRc4Sched,
        &Context->UnsealRc4Sched,
        sizeof( struct RC4_KEYSTRUCT ) );


    // Replace some fields


    //
    // Token will be returned by the caller of this routine
    //

    PackedContext->ClientTokenHandle = 0 ;

    // Save the fact that it's exported
    PackedContext->NegotiateFlags |= NTLMSSP_NEGOTIATE_EXPORTED_CONTEXT;

    if ((Flags & SECPKG_CONTEXT_EXPORT_RESET_NEW) != 0)
    {
        PackedContext->SendNonce = (ULONG) -1;
        PackedContext->RecvNonce = (ULONG) -1;
    }



    ContextData->pvBuffer = PackedContext;
    ContextData->cbBuffer = ContextSize;



    *MappedContext = TRUE;

Cleanup:

    if (!NT_SUCCESS(Status))
    {
        if (PackedContext != NULL)
        {
            NtLmFree(PackedContext);
        }
    }

    return(Status);

}

//+-------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
NtLmExportSecurityContext(
    IN ULONG_PTR ContextHandle,
    IN ULONG Flags,
    OUT PSecBuffer PackedContext,
    IN OUT PHANDLE TokenHandle
    )
{
    PNTLM_KERNEL_CONTEXT Context = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG ContextSize = 0;
    BOOLEAN MappedContext = FALSE;

    PAGED_CODE();

    DebugLog(( DEB_TRACE, "Entering NtLmExportSecurityContext\n" ));

    if (ARGUMENT_PRESENT(TokenHandle))
    {
        *TokenHandle = NULL;
    }

    PackedContext->pvBuffer = NULL;
    PackedContext->cbBuffer = 0;
    PackedContext->BufferType = 0;

    Status = NtlmReferenceContext( ContextHandle, FALSE );

    if ( NT_SUCCESS( Status ) )
    {
        Context = (PNTLM_KERNEL_CONTEXT) ContextHandle ;
    }
    else
    {
        goto Cleanup_NoDeref ;
    }

    Status = NtLmMakePackedContext(
                Context,
                &MappedContext,
                PackedContext,
                Flags
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    ASSERT(MappedContext);

    //
    // Now either duplicate the token or copy it.
    //

    if (ARGUMENT_PRESENT(TokenHandle))
    {
        if ((Flags & SECPKG_CONTEXT_EXPORT_DELETE_OLD) != 0)
        {
            *TokenHandle = Context->ClientTokenHandle;
            Context->ClientTokenHandle = NULL;
        }
        else
        {
            Status = NtDuplicateObject(
                        NtCurrentProcess(),
                        Context->ClientTokenHandle,
                        NULL,
                        TokenHandle,
                        0,              // no new access
                        0,              // no handle attributes
                        DUPLICATE_SAME_ACCESS
                        );
        }

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

    }

Cleanup:

    NtlmDerefContext( Context );

Cleanup_NoDeref:

    return (Status);

}

//+-------------------------------------------------------------------------
//
//  Function:   NtLmCreateKernelModeContext
//
//  Synopsis:   Creates a kernel-mode context to support impersonation and
//              message integrity and privacy
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
NtLmCreateKernelModeContext(
    IN ULONG_PTR ContextHandle,
    IN OPTIONAL HANDLE TokenHandle,
    IN PSecBuffer MarshalledContext,
    OUT PNTLM_KERNEL_CONTEXT * NewContext
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PNTLM_KERNEL_CONTEXT Context = NULL;
    PNTLM_PACKED_CONTEXT PackedContext;
    PUCHAR Where;
    unsigned int Length = 0;

    PAGED_CODE();

    if (MarshalledContext->cbBuffer < sizeof(NTLM_PACKED_CONTEXT))
    {
        DebugLog((DEB_ERROR,"NtLmCreateKernelModeContext: Invalid buffer size for marshalled context: was 0x%x, needed 0x%x\n",
            MarshalledContext->cbBuffer, sizeof(NTLM_PACKED_CONTEXT)));
        return(STATUS_INVALID_PARAMETER);
    }

    PackedContext = (PNTLM_PACKED_CONTEXT) MarshalledContext->pvBuffer;

    Context = (PNTLM_KERNEL_CONTEXT) NtLmAllocate( sizeof(NTLM_KERNEL_CONTEXT));
    if (!Context)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        DebugLog((DEB_ERROR,"NtLmCreateKernelModeContext: Allocation error for Context\n"));
        goto Cleanup;
    }

    RtlZeroMemory(
            Context,
            sizeof(NTLM_KERNEL_CONTEXT));

    // Copy contenets of PackedContext->pvBuffer to Context
////    *Context = *PackedContext;

    Context->NegotiateFlags = PackedContext->NegotiateFlags;
////    Context->ClientTokenHandle = (HANDLE)PackedContext->ClientTokenHandle;
    Context->ContextSignature = PackedContext->ContextSignature;


    RtlCopyMemory( Context->SessionKey, PackedContext->SessionKey, sizeof(PackedContext->SessionKey) );

    RtlCopyMemory( Context->SignSessionKey, PackedContext->SignSessionKey, sizeof(PackedContext->SignSessionKey) );
    RtlCopyMemory( Context->VerifySessionKey, PackedContext->VerifySessionKey, sizeof(PackedContext->VerifySessionKey) );
    RtlCopyMemory( Context->SealSessionKey, PackedContext->SealSessionKey, sizeof(PackedContext->SealSessionKey) );
    RtlCopyMemory( Context->UnsealSessionKey, PackedContext->UnsealSessionKey, sizeof(PackedContext->UnsealSessionKey) );

    RtlCopyMemory( &Context->SealRc4Sched, &PackedContext->SealRc4Sched, sizeof(PackedContext->SealRc4Sched) );
    RtlCopyMemory( &Context->UnsealRc4Sched, &PackedContext->UnsealRc4Sched, sizeof(PackedContext->UnsealRc4Sched) );


    KsecInitializeListEntry( &Context->List, NTLM_CONTEXT_SIGNATURE );


    // These need to be changed

    Context->ClientTokenHandle = TokenHandle;

    if (Context->SendNonce == (ULONG) -1)
    {
        // The context was exported with the reset flag
        Context->SendNonce = 0;
    }

    if (Context->RecvNonce == (ULONG) -1)
    {
        // The context was exported with the reset flag
        Context->RecvNonce = 0;
    }

    if( Context->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2 ) {

        Context->pSealRc4Sched = &Context->SealRc4Sched;
        Context->pUnsealRc4Sched = &Context->UnsealRc4Sched;
        Context->pSendNonce = &Context->SendNonce;
        Context->pRecvNonce = &Context->RecvNonce;
    } else {

        Context->pSealRc4Sched = &Context->SealRc4Sched;
        Context->pUnsealRc4Sched = &Context->SealRc4Sched;
        Context->pSendNonce = &Context->SendNonce;
        Context->pRecvNonce = &Context->SendNonce;
    }


    Context->ContextNames = NULL;

    Length = (MarshalledContext->cbBuffer - sizeof(NTLM_PACKED_CONTEXT));
    if (Length > 0)
    {
        Context->ContextNames = (LPWSTR) NtLmAllocate(Length + sizeof(WCHAR));
        if (!Context->ContextNames)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        RtlCopyMemory(Context->ContextNames, PackedContext + 1, Length);
        // null terminate the string
        *(Context->ContextNames + (Length/2)) = UNICODE_NULL;
    }

    Context->PasswordExpiry = PackedContext->PasswordExpiry;
    Context->UserFlags = PackedContext->UserFlags;

    KSecInsertListEntry(
            NtlmActiveList,
            &Context->List );

    *NewContext = Context;

Cleanup:

    if (!NT_SUCCESS(Status))
    {
        if (Context != NULL)
        {
            NtlmFreeKernelContext(Context);
        }
    }

    DebugLog(( DEB_TRACE, "Leaving NtLmCreateKernelContext 0x%lx\n", Status ));
    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
NtLmImportSecurityContext(
    IN PSecBuffer PackedContext,
    IN OPTIONAL HANDLE TokenHandle,
    OUT PULONG_PTR ContextHandle
    )
{
    NTSTATUS Status;
    PNTLM_KERNEL_CONTEXT Context = NULL;

    PAGED_CODE();
    DebugLog((DEB_TRACE,"Entering NtLmImportSecurityContext\n"));

    Status = NtLmCreateKernelModeContext(
                0,              // LsaContextHandle not present
                TokenHandle,
                PackedContext,
                &Context
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"NtLmImportSecurityContext: Failed to create kernel mode context: 0x%x\n",
            Status));
        goto Cleanup;
    }

    *ContextHandle = (ULONG_PTR) Context;

Cleanup:
    if (Context != NULL)
    {
        NtlmDerefContext( Context );
    }

    return(Status);
}


//+---------------------------------------------------------------------------
//
//  Function:   NtlmSetPagingMode
//
//  Synopsis:   Switch the paging mode for cluster support
//
//  Arguments:  [Pagable] --
//
//  History:    7-07-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
NtlmSetPagingMode(
    BOOLEAN Pagable
    )
{
    if ( Pagable )
    {
        NtlmPoolType = PagedPool ;
        NtlmActiveList = NtlmPagedList ;
    }
    else
    {
        if ( NtlmNonPagedList == NULL )
        {
            NtlmNonPagedList = LsaKernelFunctions->CreateContextList( KSecNonPaged );
            if ( NtlmNonPagedList == NULL )
            {
                return STATUS_NO_MEMORY ;
            }
        }

        NtlmActiveList = NtlmNonPagedList ;

        NtlmPoolType = NonPagedPool ;
    }
    return STATUS_SUCCESS ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\kernel\ntlmkrnl.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        ntlmkrnl.h
//
// Contents:    global include file for kernel mode NTLM security package
//
//
// History:     16-April-1996       Created     MikeSw
//
//------------------------------------------------------------------------

#ifndef __NTLMKRNL_H__
#define __NTLMKRNL_H__

#ifndef UNICODE
#define UNICODE
#endif // UNICODE

extern "C"
{
#include <ntosp.h>
#include <ntlsa.h>
#include <ntsam.h>
#include <winerror.h>
#ifndef SECURITY_WIN32
#define SECURITY_WIN32
#endif // SECURITY_WIN32
#define SECURITY_KERNEL
#define SECURITY_PACKAGE
#define SECURITY_NTLM
#include <security.h>
#include <secint.h>
#include <..\ntlmssp.h>
}

//
// Global state variables
//

ULONG NtLmPackageId;
extern PSECPKG_KERNEL_FUNCTIONS KernelFunctions;
extern POOL_TYPE NtlmPoolType ;

//
// Useful macros
//

//
// Macro to return the type field of a SecBuffer
//

#define BUFFERTYPE(_x_) ((_x_).BufferType & ~SECBUFFER_ATTRMASK)

#define NtLmAllocate( _x_ ) ExAllocatePoolWithTag( NtlmPoolType, (_x_) ,  'CvsM')
#define NtLmFree( _x_ ) ExFreePool(_x_)


#if DBG


#define DEB_ERROR               0x00000001
#define DEB_WARN                0x00000002
#define DEB_TRACE               0x00000004
#define DEB_TRACE_LOCKS         0x00010000

extern "C"
{
void KsecDebugOut(ULONG, const char *, ...);
}

#define DebugLog(x) KsecDebugOut x

#else // DBG

#define DebugLog(x)

#endif // DBG

#endif // __NTLMKRNL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\rpctest\client\helloc.c ===
/****************************************************************************
           Microsoft RPC Version 1`1
         Copyright Microsoft Corp. 1992
                Hello Example

    FILE:   helloc.c
    USAGE:   client    -n network_address
          -p protocol_sequence
          -e endpoint
          -o options
          -u uuid

    PURPOSE:   Client side of RPC distributed application
    FUNCTIONS:   main() - binds to server and calls remote procedure
    COMMENTS:
    This distributed application prints a string such as "hello, world"
    on the server. The client manages its connection to the server.
    The client uses the binding handle hello_IfHandle defined in the
    file hello.h.

****************************************************************************/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <rpc.h>       // RPC API functions, types
#include "hello.h"     // header file generated by MIDL compiler

void Usage(char * pszProgramName)
{
    fprintf(stderr, "Usage:  %s\n", pszProgramName);
    fprintf(stderr, " -i security package name (ntlm, kerberos or negotiate)\n");
    fprintf(stderr, " -c target principal name (necessary for kerberos or negotiate). For e.g, domainname\\username\n");
    fprintf(stderr, " -p protocol_sequence\n");
    fprintf(stderr, " -n network_address\n");
    fprintf(stderr, " -e endpoint\n");
    fprintf(stderr, " -o options\n");
    fprintf(stderr, " -u uuid\n");
    fprintf(stderr, " -s string\n");
    fprintf(stderr, " -w password\n");
    fprintf(stderr, " -a user account name\n");
    fprintf(stderr, " -d user account domain\n");
    exit(1);
}

int __cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    RPC_STATUS status;             // returned by RPC API function
    unsigned char * pszUuid = "12345678-1234-1234-1234-123456789ABC";
    unsigned char * pszProtocolSequence = "ncacn_np";
    unsigned char * pszSecPackage = "negotiate";
    unsigned char * pszPrincipalName = NULL;
    unsigned char * pszNetworkAddress   = NULL;
    unsigned char * pszEndpoint    = "\\pipe\\hello";
    unsigned char * pszOptions          = NULL;
    unsigned char * pszStringBinding   = NULL;
    unsigned char * pszString      = "hello, world";
    unsigned char * pszUserName = NULL;
    unsigned char * pszPassword;
    unsigned char * pszDomain;
    SEC_WINNT_AUTH_IDENTITY sID;
    unsigned long SecPackageId = RPC_C_AUTHN_WINNT;
    int i;

    sID.User = NULL;
    sID.UserLength = 0;
    sID.Domain = NULL;
    sID.DomainLength = 0;
    sID.Password = NULL;
    sID.PasswordLength = 0;
    sID.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;

    // allow the user to override settings with command line switches
    for (i = 1; i < argc; i++) {
        if ((*argv[i] == '-') || (*argv[i] == '/')) {
            switch (tolower(*(argv[i]+1))) {
            case 'i':  // secpackage 
                pszSecPackage = argv[++i];
                break;
            case 'p':  // protocol sequence
                pszProtocolSequence = argv[++i];
                break;
            case 'c':  // principal name
                pszPrincipalName = argv[++i];
                break;
            case 'n':  // network address
                pszNetworkAddress = argv[++i];
                break;
            case 'e':
                pszEndpoint = argv[++i];
                break;
            case 'o':
                pszOptions = argv[++i];
                break;
            case 'u':
                pszUuid = argv[++i];
                break;
            case 's':
                pszString = argv[++i];
                break;
            case 'a':
                sID.User = argv[++i];
                sID.UserLength = strlen(sID.User);
                break;
            case 'w':
                sID.Password = argv[++i];
                sID.PasswordLength = strlen(sID.Password);
                break;
            case 'd':
                sID.Domain = argv[++i];
                sID.DomainLength = strlen(sID.Domain);
                break;
            case 'h':
            case '?':
            default:
                Usage(argv[0]);
            }
        } else {
            Usage(argv[0]);
        }
    }


    // Use a convenience function to concatenate the elements of
    // the string binding into the proper sequence.

    status = RpcStringBindingCompose(pszUuid,
                                     pszProtocolSequence,
                                     pszNetworkAddress,
                                     pszEndpoint,
                                     pszOptions,
                                     &pszStringBinding);

    if (status) {
        printf("RpcStringBindingCompose returned 0x%x\n", status);
        exit(2);
    }
    printf("pszStringBinding = %s\n", pszStringBinding);



    //
    // Set the binding handle that will be used to bind to the server.
    //

    status = RpcBindingFromStringBinding(pszStringBinding,
                &hello_IfHandle);
    if (status) {
        printf("RpcBindingFromStringBinding returned 0x%x\n", status);
        exit(2);
    }


    // default package is ntlm

    if ( lstrcmpi(pszSecPackage, "ntlm") == 0)
    {
        SecPackageId = RPC_C_AUTHN_WINNT;
    }
    else if ( lstrcmpi(pszSecPackage, "kerberos") == 0)
    {
        SecPackageId = RPC_C_AUTHN_GSS_KERBEROS;
    }
    else if ( lstrcmpi(pszSecPackage, "negotiate") == 0)
    {
        SecPackageId = RPC_C_AUTHN_GSS_NEGOTIATE;
    }

    //
    // Tell RPC to do the security thing.
    //

    status = RpcBindingSetAuthInfo(
                    hello_IfHandle,
                    pszPrincipalName,
                    RPC_C_AUTHN_LEVEL_CONNECT,
                    SecPackageId,
                    &sID,
                    RPC_C_AUTHZ_NAME );

    if ( status ) {
        printf("RpcBindingSetAuthInfo returned %ld\n", status);
        exit(2);
    }


    //
    // Do the actual RPC calls to the server.
    //

    printf("  print the string '%s' on the server\n", pszString);

    RpcTryExcept {
        int i;
        for ( i=0; i<100 ; i++ ) {
            HelloProc(pszString);    // make call with user message
        }
        Shutdown();              // shut down the server side
    } RpcExcept(1) {
        printf("Runtime library reported an exception 0x%lx\n",
               RpcExceptionCode());
    } RpcEndExcept



    // The calls to the remote procedures are complete.
    // Free the string and the binding handle

    status = RpcStringFree(&pszStringBinding);   // remote calls done; unbind
    if (status) {
        printf("RpcStringFree returned 0x%x\n", status);
        exit(2);
    }

    status = RpcBindingFree(&hello_IfHandle);  // remote calls done; unbind
    if (status) {
        printf("RpcBindingFree returned 0x%x\n", status);
        exit(2);
    }


    return 0;

}

// ====================================================================
//                MIDL allocate and free
// ====================================================================


void __RPC_FAR * __RPC_API MIDL_user_allocate(size_t len)
{
    return(malloc(len));
}

void __RPC_API MIDL_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}

/* end file helloc.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\rpctest\server\hellos.c ===
/****************************************************************************
			  Microsoft RPC Version 1.0
			 Copyright Microsoft Corp. 1992
				Hello Example

    FILE:	hellos.c
    USAGE:	hellos
    PURPOSE:	Server side of RPC distributed application hello
    FUNCTIONS:  main() - registers server as RPC server
    COMMENTS:
    This distributed application prints "hello, world" on the server.
    This version features a client that manages its connection to
    the server. It uses the binding handle hello_IfHandle that is defined
    in the generated header file hello.h.
****************************************************************************/
#include <stdlib.h>
#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>
#include <rpc.h>    // RPC data structures and APIs
// #include <secext.h>
#include "hello.h"    // header file generated by MIDL compiler

void Usage(char * pszProgramName)
{
    fprintf(stderr, "Usage:  %s\n", pszProgramName);
    fprintf(stderr, " -p protocol_sequence\n");
    fprintf(stderr, " -i security package (ntlm, kerberos or negotiate)\n");
    fprintf(stderr, " -n network_address\n");
    fprintf(stderr, " -e endpoint\n");
    fprintf(stderr, " -o options\n");
    fprintf(stderr, " -u uuid\n");
    exit(1);
}

HANDLE TerminateEvent;

int __cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    RPC_STATUS status;
    unsigned char * pszUuid = "12345678-1234-1234-1234-123456789ABC";
    unsigned char * pszProtocolSequence = "ncacn_np";
    unsigned char * pszSecPackage       = "negotiate";
    unsigned char * pszNetworkAddress   = NULL;
    unsigned char * pszEndpoint 	= "\\pipe\\hello";
    unsigned char * pszOptions          = NULL;
    unsigned char * pszStringBinding    = NULL;
    int i;
    unsigned long SecPackageId = RPC_C_AUTHN_WINNT;
    DWORD WaitStatus;

    // allow the user to override settings with command line switches
    for (i = 1; i < argc; i++) {
	if ((*argv[i] == '-') || (*argv[i] == '/')) {
	    switch (tolower(*(argv[i]+1))) {
		case 'p':  // protocol sequence
		    pszProtocolSequence = argv[++i];
		    break;
		case 'i':  // security package
		    pszSecPackage = argv[++i];
		    break;
		case 'n':  // network address
		    pszNetworkAddress = argv[++i];
		    break;
		case 'e':
		    pszEndpoint = argv[++i];
		    break;
		case 'o':
		    pszOptions = argv[++i];
		    break;
		case 'u':
		    pszUuid = argv[++i];
		    break;
		case 'h':
		case '?':
		default:
		    Usage(argv[0]);
	    }
	}
	else
	    Usage(argv[0]);
    }

    //
    // Create an event to wait on
    //

    TerminateEvent = CreateEvent( NULL,     // No security attributes
                                  TRUE,     // Must be manually reset
                                  FALSE,    // Initially not signaled
                                  NULL );   // No name

    if ( TerminateEvent == NULL ) {
        printf( "Couldn't CreateEvent %ld\n", GetLastError() );
        return 2;
    }


    status = RpcServerUseProtseqEp(pszProtocolSequence,
                                   1, // maximum concurrent calls
                                   pszEndpoint,
				   0);
    if (status) {
        printf("RpcServerUseProtseqEp returned 0x%x\n", status);
        exit(2);
    }

    status = RpcServerRegisterIf(hello_v1_0_s_ifspec, 0, 0);
    if (status) {
        printf("RpcServerRegisterIf returned 0x%x\n", status);
        exit(2);
    }

    // default package is ntlm

    if ( lstrcmpi(pszSecPackage, "ntlm") == 0)
    {
        SecPackageId = RPC_C_AUTHN_WINNT;
    }
    else if ( lstrcmpi(pszSecPackage, "kerberos") == 0)
    {
        SecPackageId = RPC_C_AUTHN_GSS_KERBEROS;
    }
    else if ( lstrcmpi(pszSecPackage, "negotiate") == 0)
    {
        SecPackageId = RPC_C_AUTHN_GSS_NEGOTIATE;
    }

    status = RpcServerRegisterAuthInfo( "HelloS", SecPackageId, NULL, NULL );
    if (status) {
        printf("RpcServerRegisterAuthInfo returned 0x%x\n", status);
        exit(2);
    }

    printf("Calling RpcServerListen\n");
    status = RpcServerListen(1,12345,1);
    if (status) {
        printf("RpcServerListen returned: 0x%x\n", status);
        exit(2);
    }

    WaitStatus = WaitForSingleObject( TerminateEvent, INFINITE );

    if ( WaitStatus != WAIT_OBJECT_0 ) {
        printf( "Couldn't WaitForSingleObject %ld %ld\n", WaitStatus, GetLastError() );
        return 2;
    }

    return 0;

} /* end main() */


// ====================================================================
//                MIDL allocate and free
// ====================================================================


void __RPC_FAR * __RPC_API MIDL_user_allocate(size_t len)
{
    return(malloc(len));
}

void __RPC_API MIDL_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}

/*
    PURPOSE:    Remote procedures that are linked with the server
		side of RPC distributed application
    FUNCTIONS:	HelloProc() - prints "hello, world" or other string
		sent by client to server
    COMMENTS:
    This version of the distributed application that prints
    "hello, world" (or other string) on the server features a client
    that manages its connection to the server. It uses the binding
    handle hello_IfHandle, defined in the file hello.h.
****************************************************************************/

void HelloProc(unsigned char * pszString)
{
    RPC_STATUS RpcStatus;
    char szUser[256];
    DWORD iSize;

    RpcStatus = RpcImpersonateClient( NULL );

    if ( RpcStatus != RPC_S_OK ) {
        printf( "RpcImpersonateClient Failed %ld\n", RpcStatus );
    };

//    GetUserNameEx(NameUserPrincipal, szUser, sizeof(szUser)-1);
    iSize = sizeof(szUser)-1;
    GetUserName(szUser, &iSize);
    printf("User '%s' says '%s'\n", szUser, pszString);

    RpcStatus = RpcRevertToSelf();

    if ( RpcStatus != RPC_S_OK ) {
        printf( "RpcRevertToSelf Failed %ld\n", RpcStatus );
    }


}

void Shutdown(void)
{
    RPC_STATUS status;

    printf("Calling RpcMgmtStopServerListening\n");
    status = RpcMgmtStopServerListening(NULL);
    if (status) {
        printf("RpcMgmtStopServerListening returned: 0x%x\n", status);
        exit(2);
    }

    printf("Calling RpcServerUnregisterIf\n");
    status = RpcServerUnregisterIf(NULL, NULL, FALSE);
    if (status) {
        printf("RpcServerUnregisterIf returned 0x%x\n", status);
        exit(2);
    }

    if ( !SetEvent( TerminateEvent) ) {
        printf( "Couldn't SetEvent %ld\n", GetLastError() );
    }

}

/* end hellos.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\rpctesta\server\hellos.c ===
/****************************************************************************
			  Microsoft RPC Version 1.0
			 Copyright Microsoft Corp. 1992
				Hello Example

    FILE:	hellos.c
    USAGE:	hellos
    PURPOSE:	Server side of RPC distributed application hello
    FUNCTIONS:  main() - registers server as RPC server
    COMMENTS:
    This distributed application prints "hello, world" on the server.
    This version features a client that manages its connection to
    the server. It uses the binding handle hello_IfHandle that is defined
    in the generated header file hello.h.
****************************************************************************/
#include <stdlib.h>
#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>
#include <rpc.h>    // RPC data structures and APIs
#include "hello.h"    // header file generated by MIDL compiler

void Usage(char * pszProgramName)
{
    fprintf(stderr, "Usage:  %s\n", pszProgramName);
    fprintf(stderr, " -p protocol_sequence\n");
    fprintf(stderr, " -n network_address\n");
    fprintf(stderr, " -e endpoint\n");
    fprintf(stderr, " -o options\n");
    fprintf(stderr, " -u uuid\n");
    exit(1);
}

HANDLE TerminateEvent;

int __cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    RPC_STATUS status;
    unsigned char * pszUuid = "12345678-1234-1234-1234-123456789ABC";
    unsigned char * pszProtocolSequence = "ncacn_np";
    unsigned char * pszNetworkAddress   = NULL;
    unsigned char * pszEndpoint 	= "\\pipe\\hello";
    unsigned char * pszOptions          = NULL;
    unsigned char * pszStringBinding    = NULL;
    int i;
    DWORD WaitStatus;

    // allow the user to override settings with command line switches
    for (i = 1; i < argc; i++) {
	if ((*argv[i] == '-') || (*argv[i] == '/')) {
	    switch (tolower(*(argv[i]+1))) {
		case 'p':  // protocol sequence
		    pszProtocolSequence = argv[++i];
		    break;
		case 'n':  // network address
		    pszNetworkAddress = argv[++i];
		    break;
		case 'e':
		    pszEndpoint = argv[++i];
		    break;
		case 'o':
		    pszOptions = argv[++i];
		    break;
		case 'u':
		    pszUuid = argv[++i];
		    break;
		case 'h':
		case '?':
		default:
		    Usage(argv[0]);
	    }
	}
	else
	    Usage(argv[0]);
    }

    //
    // Create an event to wait on
    //

    TerminateEvent = CreateEvent( NULL,     // No security attributes
                                  TRUE,     // Must be manually reset
                                  FALSE,    // Initially not signaled
                                  NULL );   // No name

    if ( TerminateEvent == NULL ) {
        printf( "Couldn't CreateEvent %ld\n", GetLastError() );
        return 2;
    }


    status = RpcServerUseProtseqEp(pszProtocolSequence,
                                   1, // maximum concurrent calls
                                   pszEndpoint,
				   0);
    if (status) {
        printf("RpcServerUseProtseqEp returned 0x%x\n", status);
        exit(2);
    }

    status = RpcServerRegisterIf(hello_v1_0_s_ifspec, 0, 0);
    if (status) {
        printf("RpcServerRegisterIf returned 0x%x\n", status);
        exit(2);
    }

    status = RpcServerRegisterAuthInfo( "HelloS", 18, NULL, NULL );
    if (status) {
        printf("RpcServerRegisterAuthInfo returned 0x%x\n", status);
        exit(2);
    }

    printf("Calling RpcServerListen\n");
    status = RpcServerListen(1,12345,1);
    if (status) {
        printf("RpcServerListen returned: 0x%x\n", status);
        exit(2);
    }

    WaitStatus = WaitForSingleObject( TerminateEvent, INFINITE );

    if ( WaitStatus != WAIT_OBJECT_0 ) {
        printf( "Couldn't WaitForSingleObject %ld %ld\n", WaitStatus, GetLastError() );
        return 2;
    }

    return 0;

} /* end main() */


// ====================================================================
//                MIDL allocate and free
// ====================================================================


void __RPC_FAR * __RPC_API MIDL_user_allocate(size_t len)
{
    return(malloc(len));
}

void __RPC_API MIDL_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}

/*
    PURPOSE:    Remote procedures that are linked with the server
		side of RPC distributed application
    FUNCTIONS:	HelloProc() - prints "hello, world" or other string
		sent by client to server
    COMMENTS:
    This version of the distributed application that prints
    "hello, world" (or other string) on the server features a client
    that manages its connection to the server. It uses the binding
    handle hello_IfHandle, defined in the file hello.h.
****************************************************************************/

void HelloProc(unsigned char * pszString)
{
    RPC_STATUS RpcStatus;

    RpcStatus = RpcImpersonateClient( NULL );

    if ( RpcStatus != RPC_S_OK ) {
        printf( "RpcImpersonateClient Failed %ld\n", RpcStatus );
    }
    printf("%s\n", pszString);

    RpcStatus = RpcRevertToSelf();

    if ( RpcStatus != RPC_S_OK ) {
        printf( "RpcRevertToSelf Failed %ld\n", RpcStatus );
    }


}

void Shutdown(void)
{
    RPC_STATUS status;

    printf("Calling RpcMgmtStopServerListening\n");
    status = RpcMgmtStopServerListening(NULL);
    if (status) {
        printf("RpcMgmtStopServerListening returned: 0x%x\n", status);
        exit(2);
    }

    printf("Calling RpcServerUnregisterIf\n");
    status = RpcServerUnregisterIf(NULL, NULL, FALSE);
    if (status) {
        printf("RpcServerUnregisterIf returned 0x%x\n", status);
        exit(2);
    }

    if ( !SetEvent( TerminateEvent) ) {
        printf( "Couldn't SetEvent %ld\n", GetLastError() );
    }

}

/* end hellos.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\utest\ssptest.c ===
/*--

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    ssptest.c

Abstract:

    Test program for the NtLmSsp service.

Author:

    28-Jun-1993 (cliffv)

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/


//
// Common include files.
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <winsvc.h>     // Needed for service controller APIs
#include <lmcons.h>
#include <lmerr.h>
#include <lmsname.h>
#include <rpc.h>
#include <stdio.h>      // printf
#include <stdlib.h>     // strtoul
#include <tstring.h>    // NetpAllocWStrFromWStr


#include <security.h>   // General definition of a Security Support Provider
#include <ntmsv1_0.h>
#include <ntlmsp.h>
#include <ntlmssp.h>    // External definition of the NtLmSsp service
#include <dsgetdc.h>    // External definition of the NtLmSsp service

BOOLEAN QuietMode = FALSE; // Don't be verbose
extern BOOLEAN TestExt;

// BUGBUG Should be in the SDK?
#define MSV1_0_PACKAGE_NAMEW     L"MICROSOFT_AUTHENTICATION_PACKAGE_V1_0"

VOID
DumpBuffer(
    PVOID Buffer,
    DWORD BufferSize
    )
/*++

Routine Description:

    Dumps the buffer content on to the debugger output.

Arguments:

    Buffer: buffer pointer.

    BufferSize: size of the buffer.

Return Value:

    none

--*/
{
#define NUM_CHARS 16

    DWORD i, limit;
    CHAR TextBuffer[NUM_CHARS + 1];
    LPBYTE BufferPtr = Buffer;


    printf("------------------------------------\n");

    //
    // Hex dump of the bytes
    //
    limit = ((BufferSize - 1) / NUM_CHARS + 1) * NUM_CHARS;

    for (i = 0; i < limit; i++) {

        if (i < BufferSize) {

            printf("%02x ", BufferPtr[i]);

            if (BufferPtr[i] < 31 ) {
                TextBuffer[i % NUM_CHARS] = '.';
            } else if (BufferPtr[i] == '\0') {
                TextBuffer[i % NUM_CHARS] = ' ';
            } else {
                TextBuffer[i % NUM_CHARS] = (CHAR) BufferPtr[i];
            }

        } else {

            printf("  ");
            TextBuffer[i % NUM_CHARS] = ' ';

        }

        if ((i + 1) % NUM_CHARS == 0) {
            TextBuffer[NUM_CHARS] = 0;
            printf("  %s\n", TextBuffer);
        }

    }

    printf("------------------------------------\n");
}


VOID
PrintTime(
    LPSTR Comment,
    TimeStamp ConvertTime
    )
/*++

Routine Description:

    Print the specified time

Arguments:

    Comment - Comment to print in front of the time

    Time - Local time to print

Return Value:

    None

--*/
{
    LARGE_INTEGER LocalTime;

    LocalTime.HighPart = ConvertTime.HighPart;
    LocalTime.LowPart = ConvertTime.LowPart;

    printf( "%s", Comment );

    //
    // If the time is infinite,
    //  just say so.
    //

    if ( LocalTime.HighPart == 0x7FFFFFFF && LocalTime.LowPart == 0xFFFFFFFF ) {
        printf( "Infinite\n" );

    //
    // Otherwise print it more clearly
    //

    } else {

        TIME_FIELDS TimeFields;

        RtlTimeToTimeFields( &LocalTime, &TimeFields );

        printf( "%ld/%ld/%ld %ld:%2.2ld:%2.2ld\n",
                TimeFields.Month,
                TimeFields.Day,
                TimeFields.Year,
                TimeFields.Hour,
                TimeFields.Minute,
                TimeFields.Second );
    }

}

VOID
PrintStatus(
    NET_API_STATUS NetStatus
    )
/*++

Routine Description:

    Print a net status code.

Arguments:

    NetStatus - The net status code to print.

Return Value:

    None

--*/
{
    printf( "Status = %lu 0x%lx", NetStatus, NetStatus );

    switch (NetStatus) {
    case NERR_Success:
        printf( " NERR_Success" );
        break;

    case NERR_DCNotFound:
        printf( " NERR_DCNotFound" );
        break;

    case ERROR_LOGON_FAILURE:
        printf( " ERROR_LOGON_FAILURE" );
        break;

    case ERROR_ACCESS_DENIED:
        printf( " ERROR_ACCESS_DENIED" );
        break;

    case ERROR_NOT_SUPPORTED:
        printf( " ERROR_NOT_SUPPORTED" );
        break;

    case ERROR_NO_LOGON_SERVERS:
        printf( " ERROR_NO_LOGON_SERVERS" );
        break;

    case ERROR_NO_SUCH_DOMAIN:
        printf( " ERROR_NO_SUCH_DOMAIN" );
        break;

    case ERROR_NO_TRUST_LSA_SECRET:
        printf( " ERROR_NO_TRUST_LSA_SECRET" );
        break;

    case ERROR_NO_TRUST_SAM_ACCOUNT:
        printf( " ERROR_NO_TRUST_SAM_ACCOUNT" );
        break;

    case ERROR_DOMAIN_TRUST_INCONSISTENT:
        printf( " ERROR_DOMAIN_TRUST_INCONSISTENT" );
        break;

    case ERROR_BAD_NETPATH:
        printf( " ERROR_BAD_NETPATH" );
        break;

    case ERROR_FILE_NOT_FOUND:
        printf( " ERROR_FILE_NOT_FOUND" );
        break;

    case NERR_NetNotStarted:
        printf( " NERR_NetNotStarted" );
        break;

    case NERR_WkstaNotStarted:
        printf( " NERR_WkstaNotStarted" );
        break;

    case NERR_ServerNotStarted:
        printf( " NERR_ServerNotStarted" );
        break;

    case NERR_BrowserNotStarted:
        printf( " NERR_BrowserNotStarted" );
        break;

    case NERR_ServiceNotInstalled:
        printf( " NERR_ServiceNotInstalled" );
        break;

    case NERR_BadTransactConfig:
        printf( " NERR_BadTransactConfig" );
        break;

    case SEC_E_NO_SPM:
        printf( " SEC_E_NO_SPM" );
        break;
    case SEC_E_BAD_PKGID:
        printf( " SEC_E_BAD_PKGID" ); break;
    case SEC_E_NOT_OWNER:
        printf( " SEC_E_NOT_OWNER" ); break;
    case SEC_E_CANNOT_INSTALL:
        printf( " SEC_E_CANNOT_INSTALL" ); break;
    case SEC_E_INVALID_TOKEN:
        printf( " SEC_E_INVALID_TOKEN" ); break;
    case SEC_E_CANNOT_PACK:
        printf( " SEC_E_CANNOT_PACK" ); break;
    case SEC_E_QOP_NOT_SUPPORTED:
        printf( " SEC_E_QOP_NOT_SUPPORTED" ); break;
    case SEC_E_NO_IMPERSONATION:
        printf( " SEC_E_NO_IMPERSONATION" ); break;
    case SEC_E_LOGON_DENIED:
        printf( " SEC_E_LOGON_DENIED" ); break;
    case SEC_E_UNKNOWN_CREDENTIALS:
        printf( " SEC_E_UNKNOWN_CREDENTIALS" ); break;
    case SEC_E_NO_CREDENTIALS:
        printf( " SEC_E_NO_CREDENTIALS" ); break;
    case SEC_E_MESSAGE_ALTERED:
        printf( " SEC_E_MESSAGE_ALTERED" ); break;
    case SEC_E_OUT_OF_SEQUENCE:
        printf( " SEC_E_OUT_OF_SEQUENCE" ); break;
    case SEC_E_INSUFFICIENT_MEMORY:
        printf( " SEC_E_INSUFFICIENT_MEMORY" ); break;
    case SEC_E_INVALID_HANDLE:
        printf( " SEC_E_INVALID_HANDLE" ); break;
    case SEC_E_NOT_SUPPORTED:
        printf( " SEC_E_NOT_SUPPORTED" ); break;

    case SEC_I_CONTINUE_NEEDED:
        printf( " SEC_I_CONTINUE_NEEDED" ); break;

    }

    printf( "\n" );
}

VOID
TestSspRoutine(
    LPWSTR DomainName,
    LPWSTR UserName,
    LPWSTR Password
    )
/*++

Routine Description:

    Test base SSPI functionality

Arguments:

    None

Return Value:

    None

--*/
{
    SECURITY_STATUS SecStatus, TmpStatus;
    CredHandle CredentialHandle1;
    CredHandle CredentialHandle2;
    CtxtHandle ClientContextHandle, NewClientContextHandle;
    CtxtHandle ServerContextHandle, NewServerContextHandle;
    TimeStamp Lifetime;
    ULONG ContextAttributes;
    ULONG PackageCount,i;
    PSecPkgInfo PackageInfo;
    PSecPkgInfo pTmp;

    SEC_WINNT_AUTH_IDENTITY AuthIdentity;

    SecBufferDesc NegotiateDesc;
    SecBuffer NegotiateBuffer;

    SecBufferDesc ChallengeDesc;
    SecBuffer ChallengeBuffer;

    SecBufferDesc AuthenticateDesc;
    SecBuffer AuthenticateBuffer;

    SecPkgContext_Sizes ContextSizes;
    SecPkgContext_Lifespan ContextLifespan;
    UCHAR ContextNamesBuffer[sizeof(SecPkgContext_Names)+UNLEN*sizeof(WCHAR)];
    PSecPkgContext_Names ContextNames = (PSecPkgContext_Names) ContextNamesBuffer;

    SecBufferDesc SignMessage;
    SecBuffer SigBuffers[2];
    BYTE    bDataBuffer[20];
    BYTE    bSigBuffer[100];
    SecBuffer ExportedBuffer;

#if 0
    DWORD (WINAPI *pDsGetDcNameA)( LPCSTR, LPCSTR, GUID *, LPCSTR, ULONG, PDOMAIN_CONTROLLER_INFOA *);
    do {
        char szBuf[256];
        HINSTANCE  hLogonsrv = LoadLibraryA("logonsrv");
        PDOMAIN_CONTROLLER_INFOA ControllerInfo = NULL;
        ULONG NetStatus = 0;

        if (hLogonsrv == NULL)
        {
            wsprintfA(szBuf, "MSNP32: Logonsrv does not exist\n");
            OutputDebugStringA(szBuf);
            break;
        }

        pDsGetDcNameA = (DWORD (WINAPI *)(LPCSTR, LPCSTR, GUID *, 
                                                  LPCSTR, ULONG,
                                                  PDOMAIN_CONTROLLER_INFOA *))
                                GetProcAddress(hLogonsrv, "DsGetDcNameA");

        if (pDsGetDcNameA == NULL)
        {
            wsprintfA(szBuf, "MSNP32: Entrypoint DsGetDcNameA does not exist in Logonsrv.dll\n");
            OutputDebugStringA(szBuf);
            break;
        }

        NetStatus = (*pDsGetDcNameA)(NULL,
                             "NTDEV",
                             NULL,
                             NULL,
                             DS_DIRECTORY_SERVICE_REQUIRED | DS_RETURN_FLAT_NAME,
                             &ControllerInfo);

        if (hLogonsrv) FreeLibrary(hLogonsrv);

        if (NetStatus != 0)
        {
            wsprintfA(szBuf, "MSNP32: DsGetDcNameA returned 0x%x\n", NetStatus);
            OutputDebugStringA(szBuf);
            break;
        }

        if (ControllerInfo->DomainName != NULL)
        {
            wsprintfA(szBuf, "MSNP32: DsGetDcName returned DomainControllerName: \"%s\"\n", ControllerInfo->DomainControllerName );
            OutputDebugStringA(szBuf);
        }
        else
        {
            OutputDebugStringA("MSNP32: DsGetDcName returned NULL DomainName\n");
        }
    }while (FALSE);
#endif // #if 0

    NegotiateBuffer.pvBuffer = NULL;
    ChallengeBuffer.pvBuffer = NULL;
    AuthenticateBuffer.pvBuffer = NULL;

    SigBuffers[1].pvBuffer = bSigBuffer;
    SigBuffers[1].cbBuffer = sizeof(bSigBuffer);
    SigBuffers[1].BufferType = SECBUFFER_TOKEN;

    SigBuffers[0].pvBuffer = bDataBuffer;
    SigBuffers[0].cbBuffer = sizeof(bDataBuffer);
    SigBuffers[0].BufferType = SECBUFFER_DATA;
    memset(bDataBuffer,0xeb,sizeof(bDataBuffer));

    SignMessage.pBuffers = SigBuffers;
    SignMessage.cBuffers = 2;
    SignMessage.ulVersion = 0;

    //
    // Get info about the security packages.
    //

    SecStatus = EnumerateSecurityPackages( &PackageCount, &PackageInfo );
    TmpStatus = GetLastError();

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "EnumerateSecurityPackages failed:" );
        PrintStatus( SecStatus );
        return;
    }

    if ( !QuietMode ) {
      printf( "PackageCount: %ld\n", PackageCount );
      for ( i= 0; i< PackageCount; i++)
      {
        pTmp = (PackageInfo + i);
        printf( "Name: %ws Comment: %ws\n", pTmp->Name, pTmp->Comment );
        printf( "Cap: %ld Version: %ld RPCid: %ld MaxToken: %ld\n\n",
                pTmp->fCapabilities,
                pTmp->wVersion,
                pTmp->wRPCID,
                pTmp->cbMaxToken );
      }
    }

    //
    // Get info about the security packages.
    //

    SecStatus = QuerySecurityPackageInfo( NTLMSP_NAME, &PackageInfo );
    TmpStatus = GetLastError();

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QuerySecurityPackageInfo failed:" );
        PrintStatus( SecStatus );
        return;
    }

    if ( !QuietMode ) {
        printf( "Name: %ws Comment: %ws\n", PackageInfo->Name, PackageInfo->Comment );
        printf( "Cap: %ld Version: %ld RPCid: %ld MaxToken: %ld\n\n",
                PackageInfo->fCapabilities,
                PackageInfo->wVersion,
                PackageInfo->wRPCID,
                PackageInfo->cbMaxToken );
    }



    //
    // Acquire a credential handle for the server side
    //

    SecStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    NTLMSP_NAME, // Package Name
                    SECPKG_CRED_INBOUND,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    &CredentialHandle1,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "AcquireCredentialsHandle failed: ");
        TmpStatus = GetLastError();
        PrintStatus( SecStatus );
        return;
    }

    if ( !QuietMode ) {
        printf( "CredentialHandle1: 0x%lx 0x%lx   ",
                CredentialHandle1.dwLower, CredentialHandle1.dwUpper );
        PrintTime( "Lifetime: ", Lifetime );
    }


    //
    // Acquire a credential handle for the client side
    //


    RtlZeroMemory( &AuthIdentity, sizeof(AuthIdentity) );
// #define DO_OEM 1
#ifndef DO_OEM
    if ( DomainName != NULL ) {
        AuthIdentity.Domain = DomainName;
        AuthIdentity.DomainLength = wcslen(DomainName);
    }
    if ( UserName != NULL ) {
        AuthIdentity.User = UserName;
        AuthIdentity.UserLength = wcslen(UserName);
    }
    if ( Password != NULL ) {
        AuthIdentity.Password = Password;
        AuthIdentity.PasswordLength = wcslen(Password);
    }
    AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
#else
    //
    // BUGBUG: memory leak here
    //

    if ( DomainName != NULL ) {
        AuthIdentity.Domain = (LPWSTR) NetpAllocStrFromWStr(DomainName);
        AuthIdentity.DomainLength = wcslen(DomainName);
    }
    if ( UserName != NULL ) {
        AuthIdentity.User = (LPWSTR) NetpAllocStrFromWStr(UserName);
        AuthIdentity.UserLength = wcslen(UserName);
    }
    if ( Password != NULL ) {
        AuthIdentity.Password = (LPWSTR) NetpAllocStrFromWStr(Password);
        AuthIdentity.PasswordLength = wcslen(Password);
    }
    AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
#endif

    SecStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    NTLMSP_NAME, // Package Name
                    SECPKG_CRED_OUTBOUND,
                    NULL,
                    (DomainName == NULL && UserName == NULL && Password == NULL) ?
                        NULL : &AuthIdentity,
                    NULL,
                    NULL,
                    &CredentialHandle2,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "AcquireCredentialsHandle failed: " );
        TmpStatus = GetLastError();
        PrintStatus( SecStatus );
        return;
    }


    if ( !QuietMode ) {
        printf( "CredentialHandle2: 0x%lx 0x%lx   ",
                CredentialHandle2.dwLower, CredentialHandle2.dwUpper );
        PrintTime( "Lifetime: ", Lifetime );
    }



    //
    // Get the NegotiateMessage (ClientSide)
    //

    NegotiateDesc.ulVersion = 0;
    NegotiateDesc.cBuffers = 1;
    NegotiateDesc.pBuffers = &NegotiateBuffer;

    NegotiateBuffer.cbBuffer = PackageInfo->cbMaxToken;
    NegotiateBuffer.BufferType = SECBUFFER_TOKEN;
    NegotiateBuffer.pvBuffer = LocalAlloc( 0, NegotiateBuffer.cbBuffer );
    if ( NegotiateBuffer.pvBuffer == NULL ) {
        printf( "Allocate NegotiateMessage failed: 0x%ld\n", GetLastError() );
        return;
    }

    SecStatus = InitializeSecurityContext(
                    &CredentialHandle2,
                    NULL,               // No Client context yet
                    L"\\\\Frank\\IPC$",  // Faked target name
                    ISC_REQ_SEQUENCE_DETECT | ISC_REQ_DATAGRAM,
                    0,                  // Reserved 1
                    SECURITY_NATIVE_DREP,
                    NULL,                  // No initial input token
                    0,                  // Reserved 2
                    &ClientContextHandle,
                    &NegotiateDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        TmpStatus = GetLastError();
        if ( !QuietMode || !NT_SUCCESS(SecStatus) ) {
            printf( "InitializeSecurityContext (negotiate): " );
            PrintStatus( SecStatus );
        }
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "\n\nNegotiate Message:\n" );

        printf( "ClientContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                ClientContextHandle.dwLower, ClientContextHandle.dwUpper,
                ContextAttributes );
        PrintTime( "Lifetime: ", Lifetime );

        DumpBuffer( NegotiateBuffer.pvBuffer, NegotiateBuffer.cbBuffer );
    }


    //
    // Get the ChallengeMessage (ServerSide)
    //

    NegotiateBuffer.BufferType |= SECBUFFER_READONLY;
    ChallengeDesc.ulVersion = 0;
    ChallengeDesc.cBuffers = 1;
    ChallengeDesc.pBuffers = &ChallengeBuffer;

    ChallengeBuffer.cbBuffer = PackageInfo->cbMaxToken;
    ChallengeBuffer.BufferType = SECBUFFER_TOKEN;
    ChallengeBuffer.pvBuffer = LocalAlloc( 0, ChallengeBuffer.cbBuffer );
    if ( ChallengeBuffer.pvBuffer == NULL ) {
        printf( "Allocate ChallengeMessage failed: 0x%ld\n", GetLastError() );
        return;
    }

    SecStatus = AcceptSecurityContext(
                    &CredentialHandle1,
                    NULL,               // No Server context yet
                    &NegotiateDesc,
                    ISC_REQ_SEQUENCE_DETECT  | ISC_REQ_DATAGRAM,
                    SECURITY_NATIVE_DREP,
                    &ServerContextHandle,
                    &ChallengeDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        TmpStatus = GetLastError();
        if ( !QuietMode || !NT_SUCCESS(SecStatus) ) {
            printf( "AcceptSecurityContext (Challenge): " );
            PrintStatus( SecStatus );
        }
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "\n\nChallenge Message:\n" );

        printf( "ServerContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                ServerContextHandle.dwLower, ServerContextHandle.dwUpper,
                ContextAttributes );
        PrintTime( "Lifetime: ", Lifetime );

        DumpBuffer( ChallengeBuffer.pvBuffer, ChallengeBuffer.cbBuffer );
    }


    //
    // Get the AuthenticateMessage (ClientSide)
    //

    ChallengeBuffer.BufferType |= SECBUFFER_READONLY;
    AuthenticateDesc.ulVersion = 0;
    AuthenticateDesc.cBuffers = 1;
    AuthenticateDesc.pBuffers = &AuthenticateBuffer;

    AuthenticateBuffer.cbBuffer = PackageInfo->cbMaxToken;
    AuthenticateBuffer.BufferType = SECBUFFER_TOKEN;
    AuthenticateBuffer.pvBuffer = LocalAlloc( 0, AuthenticateBuffer.cbBuffer );
    if ( AuthenticateBuffer.pvBuffer == NULL ) {
        printf( "Allocate AuthenticateMessage failed: 0x%ld\n", GetLastError() );
        return;
    }

    SecStatus = InitializeSecurityContext(
                    NULL,
                    &ClientContextHandle,
                    L"\\\\Frank\\IPC$",     // Faked target name
                    0,
                    0,                      // Reserved 1
                    SECURITY_NATIVE_DREP,
                    &ChallengeDesc,
                    0,                  // Reserved 2
                    &ClientContextHandle,
                    &AuthenticateDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        TmpStatus = GetLastError();
        printf( "InitializeSecurityContext (Authenticate): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "\n\nAuthenticate Message:\n" );

        printf( "ClientContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                ClientContextHandle.dwLower, ClientContextHandle.dwUpper,
                ContextAttributes );
        PrintTime( "Lifetime: ", Lifetime );

        DumpBuffer( AuthenticateBuffer.pvBuffer, AuthenticateBuffer.cbBuffer );
    }

    //
    // Finally authenticate the user (ServerSide)
    //

    AuthenticateBuffer.BufferType |= SECBUFFER_READONLY;

    SecStatus = AcceptSecurityContext(
                    NULL,
                    &ServerContextHandle,
                    &AuthenticateDesc,
                    0,
                    SECURITY_NATIVE_DREP,
                    &ServerContextHandle,
                    NULL,
                    &ContextAttributes,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        TmpStatus = GetLastError();
        printf( "AcceptSecurityContext (Challenge): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "\n\nFinal Authentication:\n" );

        printf( "ServerContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                ServerContextHandle.dwLower, ServerContextHandle.dwUpper,
                ContextAttributes );
        PrintTime( "Lifetime: ", Lifetime );
        printf(" \n" );
    }


    //
    // Query as many attributes as possible
    //


    SecStatus = QueryContextAttributes(
                    &ClientContextHandle,
                    SECPKG_ATTR_SIZES,
                    &ContextSizes );

    if ( SecStatus != STATUS_SUCCESS ) {
        TmpStatus = GetLastError();
        printf( "QueryContextAttributes (sizes): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "QuerySizes: %ld %ld %ld %ld\n",
                    ContextSizes.cbMaxToken,
                    ContextSizes.cbMaxSignature,
                    ContextSizes.cbBlockSize,
                    ContextSizes.cbSecurityTrailer );
    }

    SecStatus = QueryContextAttributes(
                    &ClientContextHandle,
                    SECPKG_ATTR_NAMES,
                    ContextNamesBuffer );

    if ( SecStatus != STATUS_SUCCESS ) {
        TmpStatus = GetLastError();
        printf( "QueryContextAttributes (names): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "QueryNames: %ws\n", ContextNames->sUserName );
    }


    SecStatus = QueryContextAttributes(
                    &ClientContextHandle,
                    SECPKG_ATTR_LIFESPAN,
                    &ContextLifespan );

    if ( SecStatus != STATUS_SUCCESS ) {
        TmpStatus = GetLastError();
        printf( "QueryContextAttributes (lifespan): " );
        PrintStatus( SecStatus );
    }

    if ( NT_SUCCESS(SecStatus) )
    {
        if ( !QuietMode )
        {
            PrintTime("   Start:", ContextLifespan.tsStart );
            PrintTime("  Expiry:", ContextLifespan.tsExpiry );
        }
    }


    //
    // Get the ChallengeMessage (ServerSide)
    //
    // Now make a third call to Initialize to check that RPC can
    // reauthenticate.
    //

    AuthenticateBuffer.BufferType = SECBUFFER_TOKEN;


    SecStatus = InitializeSecurityContext(
                    NULL,
                    &ClientContextHandle,
                    L"\\\\Frank\\IPC$",     // Faked target name
                    0,
                    0,                      // Reserved 1
                    SECURITY_NATIVE_DREP,
                    NULL,
                    0,                  // Reserved 2
                    &ClientContextHandle,
                    &AuthenticateDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        TmpStatus = GetLastError();
        printf( "InitializeSecurityContext (Re-Authenticate): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }



    //
    // Now try to re-authenticate the user (ServerSide)
    //

    AuthenticateBuffer.BufferType |= SECBUFFER_READONLY;

    SecStatus = AcceptSecurityContext(
                    NULL,
                    &ServerContextHandle,
                    &AuthenticateDesc,
                    0,
                    SECURITY_NATIVE_DREP,
                    &ServerContextHandle,
                    NULL,
                    &ContextAttributes,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        TmpStatus = GetLastError();
        printf( "AcceptSecurityContext (Re-authenticate): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }


    //
    // Impersonate the client (ServerSide)
    //

    SecStatus = ImpersonateSecurityContext( &ServerContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        TmpStatus = GetLastError();
        printf( "ImpersonateSecurityContext: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    //
    // Do something while impersonating (Access the token)
    //

    {
        NTSTATUS Status;
        HANDLE TokenHandle = NULL;

        //
        // Open the token,
        //

        Status = NtOpenThreadToken(
                    NtCurrentThread(),
                    TOKEN_QUERY,
                    (BOOLEAN) TRUE, // Not really using the impersonation token
                    &TokenHandle );

        if ( !NT_SUCCESS(Status) ) {
            printf( "Access Thread token while impersonating: " );
            PrintStatus( Status );
            return;
        } else {
            (VOID) NtClose( TokenHandle );
        }
    }


    //
    // RevertToSelf (ServerSide)
    //

    SecStatus = RevertSecurityContext( &ServerContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "RevertSecurityContext: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    //
    // Sign a message
    //

    SecStatus = MakeSignature(
                        &ClientContextHandle,
                        0,
                        &SignMessage,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "MakeSignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {

        printf("\n Signature: \n");
        DumpBuffer(SigBuffers[1].pvBuffer,SigBuffers[1].cbBuffer);

    }


    //
    // Verify the signature
    //

    SecStatus = VerifySignature(
                        &ServerContextHandle,
                        &SignMessage,
                        0,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "VerifySignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }



    //
    // Sign a message, this time to check if it can detect a change in the
    // message
    //

    SecStatus = MakeSignature(
                        &ClientContextHandle,
                        0,
                        &SignMessage,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "MakeSignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {

        printf("\n Signature: \n");
        DumpBuffer(SigBuffers[1].pvBuffer,SigBuffers[1].cbBuffer);

    }

    //
    // Mess up the message to see if VerifySignature works
    //

    bDataBuffer[10] = 0xec;

    //
    // Verify the signature
    //

    SecStatus = VerifySignature(
                        &ServerContextHandle,
                        &SignMessage,
                        0,
                        0 );

    if ( SecStatus != SEC_E_MESSAGE_ALTERED ) {
        printf( "VerifySignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    // Export client context without deleting the old one.

    SecStatus = ExportSecurityContext(
                       &ClientContextHandle,
                       0,
                       &ExportedBuffer, 
                       NULL);

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "ExportSecurityContext: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    SecStatus = ImportSecurityContext(
                        NTLMSP_NAME, // Package Name
                        &ExportedBuffer,
                        NULL,
                        &NewClientContextHandle);

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "ImportSecurityContext: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    SecStatus = FreeContextBuffer(ExportedBuffer.pvBuffer);

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "FreeContextBuffer: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    SecStatus = QueryContextAttributes(
                    &NewClientContextHandle,
                    SECPKG_ATTR_NAMES,
                    ContextNamesBuffer );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (names): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "QueryNames: %ws\n", ContextNames->sUserName );
    }

    // Export client context while deleting the old one.

    SecStatus = ExportSecurityContext(
                       &ServerContextHandle,
                       SECPKG_CONTEXT_EXPORT_DELETE_OLD,
                       &ExportedBuffer, 
                       NULL);

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "ExportSecurityContext: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    SecStatus = ImportSecurityContext(
                        NTLMSP_NAME, // Package Name
                        &ExportedBuffer,
                        NULL,
                        &NewServerContextHandle);

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "ImportSecurityContext: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    SecStatus = FreeContextBuffer(ExportedBuffer.pvBuffer);

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "FreeContextBuffer: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    SecStatus = QueryContextAttributes(
                    &NewServerContextHandle,
                    SECPKG_ATTR_NAMES,
                    ContextNamesBuffer );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (names): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "QueryNames: %ws\n", ContextNames->sUserName );
    }

    //
    // Delete only the client context. The server context has already been deleted.
    //

    SecStatus = DeleteSecurityContext( &ClientContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "DeleteSecurityContext failed: " );
        PrintStatus( SecStatus );
        return;
    }

    //
    // Delete imported contexts
    //

    SecStatus = DeleteSecurityContext( &NewClientContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "DeleteSecurityContext failed: " );
        PrintStatus( SecStatus );
        return;
    }

    SecStatus = DeleteSecurityContext( &NewServerContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "DeleteSecurityContext failed: " );
        PrintStatus( SecStatus );
        return;
    }

    //
    // Free both credential handles
    //

    SecStatus = FreeCredentialsHandle( &CredentialHandle1 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "FreeCredentialsHandle failed: " );
        PrintStatus( SecStatus );
        return;
    }

    SecStatus = FreeCredentialsHandle( &CredentialHandle2 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "FreeCredentialsHandle failed: " );
        PrintStatus( SecStatus );
        return;
    }


    //
    // Final Cleanup
    //

    if ( NegotiateBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( NegotiateBuffer.pvBuffer );
    }

    if ( ChallengeBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( ChallengeBuffer.pvBuffer );
    }

    if ( AuthenticateBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( AuthenticateBuffer.pvBuffer );
    }
}

VOID
TestLogonRoutine(
    IN LPWSTR UserName,
    IN LPWSTR DomainName,
    IN LPWSTR Password
    )
{
    NTSTATUS Status;
    PMSV1_0_INTERACTIVE_LOGON LogonInfo;
    ULONG LogonInfoSize = sizeof(MSV1_0_INTERACTIVE_LOGON);
    BOOLEAN WasEnabled;
    UNICODE_STRING Name;
    STRING TempName;
    ULONG Dummy;
    HANDLE LogonHandle = NULL;
    ULONG PackageId;
    TOKEN_SOURCE SourceContext;
    PMSV1_0_INTERACTIVE_PROFILE Profile = NULL;
    ULONG ProfileSize;
    LUID LogonId;
    HANDLE TokenHandle = NULL;
    QUOTA_LIMITS Quotas;
    NTSTATUS SubStatus;
    WCHAR UserNameString[100];
    ULONG NameLength = 100;
    PUCHAR Where;

    LogonInfoSize += (wcslen(UserName) + ((DomainName == NULL)? 0 : wcslen(DomainName)) + wcslen(Password) + 3 ) * sizeof(WCHAR);

    LogonInfo = (PMSV1_0_INTERACTIVE_LOGON) LocalAlloc(LMEM_ZEROINIT, LogonInfoSize);

    LogonInfo->MessageType = MsV1_0InteractiveLogon;

    RtlInitUnicodeString(
        &Name,
        UserName
        );

    Where = (PUCHAR) (LogonInfo + 1);

    LogonInfo->UserName.Buffer = (LPWSTR) Where;
    LogonInfo->UserName.Length = Name.Length;
    LogonInfo->UserName.MaximumLength = Name.MaximumLength;
    RtlCopyMemory(
        Where,
        Name.Buffer,
        Name.Length
        );
    Where += LogonInfo->UserName.Length + sizeof(WCHAR);

    RtlInitUnicodeString(
        &Name,
        DomainName
        );

    LogonInfo->LogonDomainName.Buffer = (LPWSTR) Where;
    LogonInfo->LogonDomainName.Length = Name.Length;
    LogonInfo->LogonDomainName.MaximumLength = Name.MaximumLength;
    RtlCopyMemory(
        Where,
        Name.Buffer,
        Name.Length
        );
    Where += LogonInfo->LogonDomainName.Length + sizeof(WCHAR);

    RtlInitUnicodeString(
        &Name,
        Password
        );

    LogonInfo->Password.Buffer = (LPWSTR) Where;
    LogonInfo->Password.Length = Name.Length;
    LogonInfo->Password.Length = Name.MaximumLength;
    RtlCopyMemory(
        Where,
        Name.Buffer,
        Name.Length
        );
    Where += LogonInfo->Password.Length + sizeof(WCHAR);

    LogonInfo->MessageType = MsV1_0InteractiveLogon;

    //
    // Turn on the TCB privilege
    //

    Status = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, FALSE, &WasEnabled);
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to adjust privilege: GetLastError = 0x%x\n",GetLastError());
        printf("Failed to adjust privilege: 0x%x\n",Status);
        return;
    }
    RtlInitString(
        &TempName,
        "SspTest"
        );
    Status = LsaRegisterLogonProcess(
                &TempName,
                &LogonHandle,
                &Dummy
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to register as a logon process: 0x%x\n",Status);
        return;
    }

    strncpy(
        SourceContext.SourceName,
        "ssptest        ",sizeof(SourceContext.SourceName)
        );
    NtAllocateLocallyUniqueId(
        &SourceContext.SourceIdentifier
        );


    RtlInitString(
        &TempName,
        NTLMSP_NAME_A
        );
    Status = LsaLookupAuthenticationPackage(
                LogonHandle,
                &TempName,
                &PackageId
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to lookup package %Z: 0x%x\n",&TempName, Status);
        return;
    }

    //
    // Now call LsaLogonUser
    //

    RtlInitString(
        &TempName,
        "ssptest"
        );

    Status = LsaLogonUser(
                LogonHandle,
                &TempName,
                Interactive,
                PackageId,
                LogonInfo,
                LogonInfoSize,
                NULL,           // no token groups
                &SourceContext,
                (PVOID *) &Profile,
                &ProfileSize,
                &LogonId,
                &TokenHandle,
                &Quotas,
                &SubStatus
                );
    if (!NT_SUCCESS(Status))
    {
        printf("lsalogonuser failed: 0x%x\n",Status);
        return;
    }
    if (!NT_SUCCESS(SubStatus))
    {
        printf("LsalogonUser failed: substatus = 0x%x\n",SubStatus);
        return;
    }

    ImpersonateLoggedOnUser( TokenHandle );
    GetUserName(UserNameString,&NameLength);
    printf("Username = %ws\n",UserNameString);
    RevertToSelf();
    NtClose(TokenHandle);



}

DWORD
JunkTest()
{
    return 1;
}


int __cdecl
main(
    IN int argc,
    IN char ** argv
    )
/*++

Routine Description:

    Drive the NtLmSsp service

Arguments:



int __cdecl
main(
    IN int argc,
    IN char ** argv
    )
/*++

Routine Description:

    Drive the NtLmSsp service

Arguments:

    argc - the number of command-line arguments.

    argv - an array of pointers to the arguments.

Return Value:

    Exit status

--*/
{
    LPSTR argument;
    int i;
    ULONG j;
    ULONG Iterations = 0;

    LPWSTR DomainName = NULL;
    LPWSTR UserName = NULL;
    LPWSTR Password = NULL;

    enum {
        NoAction,
        ConfigureService,
#define CONFIG_PARAM "/ConfigureService"
        TestSsp,
#define TESTSSP_PARAM "/TestSsp"
#define TESTSSP2_PARAM "/TestSsp:"
#define LOGON_PARAM "/TestLogon"
        TestLogon,
    } Action = NoAction;
#define QUIET_PARAM "/Q"





    //
    // Loop through the arguments handle each in turn
    //

    for ( i=1; i<argc; i++ ) {

        argument = argv[i];

        //
        // Handle /TestSsp
        //

        if ( _stricmp( argument, TESTSSP_PARAM ) == 0 ) {
            if ( Action != NoAction ) {
                goto Usage;
            }

            Action = TestSsp;
            Iterations = 1;

        //
        // Handle /TestSsp:
        //

        } else if ( _strnicmp( argument,
                              TESTSSP2_PARAM,
                              sizeof(TESTSSP2_PARAM)-1 ) == 0 ){
            char *end;
            if ( Action != NoAction ) {
                goto Usage;
            }

            Action = TestSsp;

            Iterations = strtoul( &argument[sizeof(TESTSSP2_PARAM)-1], &end, 10 );

            i++;
            if ( i < argc ) {
                argument = argv[i];
                DomainName = NetpAllocWStrFromStr( argument );

                i++;
                if ( i < argc ) {
                    argument = argv[i];
                    UserName = NetpAllocWStrFromStr( argument );

                    i++;
                    if ( i < argc ) {
                        argument = argv[i];
                        Password = NetpAllocWStrFromStr( argument );
                    }
                }
            }


        } else if ( _strnicmp( argument,
                              LOGON_PARAM,
                              sizeof(LOGON_PARAM)-1 ) == 0 ){
        //
        // Handle /TestLogon
        //
            if ( Action != NoAction ) {
                goto Usage;
            }

            Action = TestLogon;
            Iterations = 1;
            
            if (argc < i + 2)
            {
                goto Usage;
            }
            argument = argv[++i];
            Password = NetpAllocWStrFromStr( argument );
            argument = argv[++i];
            UserName = NetpAllocWStrFromStr( argument );
            if (i < argc)
            {
                argument = argv[++i];
                DomainName = NetpAllocWStrFromStr( argument );
            }
            else
            {
                DomainName = NULL;
            }

        } else {
        //
        // Handle all other parameters
        //

Usage:
            fprintf( stderr, "Usage: ssptest [/OPTIONS]\n\n" );

            fprintf(
                stderr,
                "\n"
                "    " TESTSSP_PARAM "[:<iterations> <DomainName> <UserName> <Password>] - Test basic SSPI.\n"
                "    " LOGON_PARAM "<Password> <UserName> [<DomainName>] - Test LogonUser.\n"
                "    " QUIET_PARAM " - Don't be so verbose\n"
                "\n"
                "\n" );
            return(1);
        }
    }

    //
    // Perform the action requested
    //

    switch ( Action ) 
    {
        case TestSsp: 
        {
            for ( j=0; j<Iterations ; j++ ) {
                TestSspRoutine( DomainName, UserName, Password );
            }
            break;
        }
        case TestLogon: 
        {
            TestLogonRoutine( UserName, DomainName, Password );
        }
    }

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\utesta\ssptest.c ===
/*--

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    ssptest.c

Abstract:

    Test program for the NtLmSsp service.

Author:

    28-Jun-1993 (cliffv)

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/


//
// Common include files.
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <winsvc.h>     // Needed for service controller APIs
#include <lmcons.h>
#include <lmerr.h>
#include <lmsname.h>
#include <rpc.h>
#include <stdio.h>      // printf
#include <stdlib.h>     // strtoul
#include <tstring.h>    // NetpAllocWStrFromWStr

#include <security.h>   // General definition of a Security Support Provider
#include <ntmsv1_0.h>
#include <ntlmsp.h>    // External definition of the NtLmSsp service

BOOLEAN QuietMode = FALSE; // Don't be verbose

// BUGBUG Should be in the SDK?
#define MSV1_0_PACKAGE_NAMEW     L"MICROSOFT_AUTHENTICATION_PACKAGE_V1_0"
#define KERBEROS_PACKAGE_NAME "Kerberos"

VOID
DumpBuffer(
    PVOID Buffer,
    DWORD BufferSize
    )
/*++

Routine Description:

    Dumps the buffer content on to the debugger output.

Arguments:

    Buffer: buffer pointer.

    BufferSize: size of the buffer.

Return Value:

    none

--*/
{
#define NUM_CHARS 16

    DWORD i, limit;
    CHAR TextBuffer[NUM_CHARS + 1];
    LPBYTE BufferPtr = Buffer;


    printf("------------------------------------\n");

    //
    // Hex dump of the bytes
    //
    limit = ((BufferSize - 1) / NUM_CHARS + 1) * NUM_CHARS;

    for (i = 0; i < limit; i++) {

        if (i < BufferSize) {

            printf("%02x ", BufferPtr[i]);

            if (BufferPtr[i] < 31 ) {
                TextBuffer[i % NUM_CHARS] = '.';
            } else if (BufferPtr[i] == '\0') {
                TextBuffer[i % NUM_CHARS] = ' ';
            } else {
                TextBuffer[i % NUM_CHARS] = (CHAR) BufferPtr[i];
            }

        } else {

            printf("  ");
            TextBuffer[i % NUM_CHARS] = ' ';

        }

        if ((i + 1) % NUM_CHARS == 0) {
            TextBuffer[NUM_CHARS] = 0;
            printf("  %s\n", TextBuffer);
        }

    }

    printf("------------------------------------\n");
}


VOID
PrintTime(
    LPSTR Comment,
    TimeStamp ConvertTime
    )
/*++

Routine Description:

    Print the specified time

Arguments:

    Comment - Comment to print in front of the time

    Time - Local time to print

Return Value:

    None

--*/
{
    LARGE_INTEGER LocalTime;

    LocalTime.HighPart = ConvertTime.HighPart;
    LocalTime.LowPart = ConvertTime.LowPart;

    printf( "%s", Comment );

    //
    // If the time is infinite,
    //  just say so.
    //

    if ( LocalTime.HighPart == 0x7FFFFFFF && LocalTime.LowPart == 0xFFFFFFFF ) {
        printf( "Infinite\n" );

    //
    // Otherwise print it more clearly
    //

    } else {

        TIME_FIELDS TimeFields = {0};

/*
        RtlTimeToTimeFields( &LocalTime, &TimeFields );
*/

        printf( "%ld/%ld/%ld %ld:%2.2ld:%2.2ld\n",
                TimeFields.Month,
                TimeFields.Day,
                TimeFields.Year,
                TimeFields.Hour,
                TimeFields.Minute,
                TimeFields.Second );
    }

}

VOID
PrintStatus(
    NET_API_STATUS NetStatus
    )
/*++

Routine Description:

    Print a net status code.

Arguments:

    NetStatus - The net status code to print.

Return Value:

    None

--*/
{
    printf( "Status = %lu 0x%lx", NetStatus, NetStatus );

    switch (NetStatus) {
    case NERR_Success:
        printf( " NERR_Success" );
        break;

    case NERR_DCNotFound:
        printf( " NERR_DCNotFound" );
        break;

    case ERROR_LOGON_FAILURE:
        printf( " ERROR_LOGON_FAILURE" );
        break;

    case ERROR_ACCESS_DENIED:
        printf( " ERROR_ACCESS_DENIED" );
        break;

    case ERROR_NOT_SUPPORTED:
        printf( " ERROR_NOT_SUPPORTED" );
        break;

    case ERROR_NO_LOGON_SERVERS:
        printf( " ERROR_NO_LOGON_SERVERS" );
        break;

    case ERROR_NO_SUCH_DOMAIN:
        printf( " ERROR_NO_SUCH_DOMAIN" );
        break;

    case ERROR_NO_TRUST_LSA_SECRET:
        printf( " ERROR_NO_TRUST_LSA_SECRET" );
        break;

    case ERROR_NO_TRUST_SAM_ACCOUNT:
        printf( " ERROR_NO_TRUST_SAM_ACCOUNT" );
        break;

    case ERROR_DOMAIN_TRUST_INCONSISTENT:
        printf( " ERROR_DOMAIN_TRUST_INCONSISTENT" );
        break;

    case ERROR_BAD_NETPATH:
        printf( " ERROR_BAD_NETPATH" );
        break;

    case ERROR_FILE_NOT_FOUND:
        printf( " ERROR_FILE_NOT_FOUND" );
        break;

    case NERR_NetNotStarted:
        printf( " NERR_NetNotStarted" );
        break;

    case NERR_WkstaNotStarted:
        printf( " NERR_WkstaNotStarted" );
        break;

    case NERR_ServerNotStarted:
        printf( " NERR_ServerNotStarted" );
        break;

    case NERR_BrowserNotStarted:
        printf( " NERR_BrowserNotStarted" );
        break;

    case NERR_ServiceNotInstalled:
        printf( " NERR_ServiceNotInstalled" );
        break;

    case NERR_BadTransactConfig:
        printf( " NERR_BadTransactConfig" );
        break;

    case SEC_E_NO_SPM:
        printf( " SEC_E_NO_SPM" );
        break;
    case SEC_E_BAD_PKGID:
        printf( " SEC_E_BAD_PKGID" ); break;
    case SEC_E_NOT_OWNER:
        printf( " SEC_E_NOT_OWNER" ); break;
    case SEC_E_CANNOT_INSTALL:
        printf( " SEC_E_CANNOT_INSTALL" ); break;
    case SEC_E_INVALID_TOKEN:
        printf( " SEC_E_INVALID_TOKEN" ); break;
    case SEC_E_CANNOT_PACK:
        printf( " SEC_E_CANNOT_PACK" ); break;
    case SEC_E_QOP_NOT_SUPPORTED:
        printf( " SEC_E_QOP_NOT_SUPPORTED" ); break;
    case SEC_E_NO_IMPERSONATION:
        printf( " SEC_E_NO_IMPERSONATION" ); break;
    case SEC_E_LOGON_DENIED:
        printf( " SEC_E_LOGON_DENIED" ); break;
    case SEC_E_UNKNOWN_CREDENTIALS:
        printf( " SEC_E_UNKNOWN_CREDENTIALS" ); break;
    case SEC_E_NO_CREDENTIALS:
        printf( " SEC_E_NO_CREDENTIALS" ); break;
    case SEC_E_MESSAGE_ALTERED:
        printf( " SEC_E_MESSAGE_ALTERED" ); break;
    case SEC_E_OUT_OF_SEQUENCE:
        printf( " SEC_E_OUT_OF_SEQUENCE" ); break;
    case SEC_E_INSUFFICIENT_MEMORY:
        printf( " SEC_E_INSUFFICIENT_MEMORY" ); break;
    case SEC_E_INVALID_HANDLE:
        printf( " SEC_E_INVALID_HANDLE" ); break;
    case SEC_E_NOT_SUPPORTED:
        printf( " SEC_E_NOT_SUPPORTED" ); break;

    case SEC_I_CONTINUE_NEEDED:
        printf( " SEC_I_CONTINUE_NEEDED" ); break;

    }

    printf( "\n" );
}

VOID
TestLpcRoutine(
    LPWSTR DomainName,
    LPWSTR UserName,
    LPWSTR Password
    )
/*++

Routine Description:

    Test base LPC functionality

Arguments:

    None

Return Value:

    None

--*/
{
    SECURITY_STATUS SecStatus;
    CredHandle CredentialHandle1;
    CredHandle CredentialHandle2;
    CtxtHandle ClientContextHandle;
    CtxtHandle ServerContextHandle;
    TimeStamp Lifetime;
    ULONG ContextAttributes;
    ULONG PackageCount,i;
    PSecPkgInfo PackageInfo;
    PSecPkgInfo pTmp;

    SEC_WINNT_AUTH_IDENTITY AuthIdentity;

    SecBufferDesc NegotiateDesc;
    SecBuffer NegotiateBuffer;

    SecBufferDesc ChallengeDesc;
    SecBuffer ChallengeBuffer;

    SecBufferDesc AuthenticateDesc;
    SecBuffer AuthenticateBuffer;

    SecPkgContext_Sizes ContextSizes;
    SecPkgContext_Lifespan ContextLifespan;
    UCHAR ContextNamesBuffer[sizeof(SecPkgContext_Names)+UNLEN*sizeof(WCHAR)];
    PSecPkgContext_Names ContextNames = (PSecPkgContext_Names) ContextNamesBuffer;

    SecBufferDesc SignMessage;
    SecBuffer SigBuffers[2];
    BYTE    bDataBuffer[20];
    BYTE    bSigBuffer[100];

    NegotiateBuffer.pvBuffer = NULL;
    ChallengeBuffer.pvBuffer = NULL;
    AuthenticateBuffer.pvBuffer = NULL;

    SigBuffers[1].pvBuffer = bSigBuffer;
    SigBuffers[1].cbBuffer = sizeof(bSigBuffer);
    SigBuffers[1].BufferType = SECBUFFER_TOKEN;

    SigBuffers[0].pvBuffer = bDataBuffer;
    SigBuffers[0].cbBuffer = sizeof(bDataBuffer);
    SigBuffers[0].BufferType = SECBUFFER_DATA;
    memset(bDataBuffer,0xeb,sizeof(bDataBuffer));

    SignMessage.pBuffers = SigBuffers;
    SignMessage.cBuffers = 2;
    SignMessage.ulVersion = 0;

    //
    // Get info about the security packages.
    //

    SecStatus = EnumerateSecurityPackages( &PackageCount, &PackageInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "EnumerateSecurityPackages failed:" );
        PrintStatus( SecStatus );
        return;
    }

    if ( !QuietMode ) {
      printf( "PackageCount: %ld\n", PackageCount );
      for ( i= 0; i< PackageCount; i++)
      {
        pTmp = (PackageInfo + i);
        printf( "Name: %ws Comment: %ws\n", pTmp->Name, pTmp->Comment );
        printf( "Cap: %ld Version: %ld RPCid: %ld MaxToken: %ld\n\n",
                pTmp->fCapabilities,
                pTmp->wVersion,
                pTmp->wRPCID,
                pTmp->cbMaxToken );
      }
    }

    //
    // Get info about the security packages.
    //

    SecStatus = QuerySecurityPackageInfo( KERBEROS_PACKAGE_NAME, &PackageInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QuerySecurityPackageInfo failed:" );
        PrintStatus( SecStatus );
        return;
    }

    if ( !QuietMode ) {
        printf( "Name: %ws Comment: %ws\n", PackageInfo->Name, PackageInfo->Comment );
        printf( "Cap: %ld Version: %ld RPCid: %ld MaxToken: %ld\n\n",
                PackageInfo->fCapabilities,
                PackageInfo->wVersion,
                PackageInfo->wRPCID,
                PackageInfo->cbMaxToken );
    }



    //
    // Acquire a credential handle for the server side
    //

    SecStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    KERBEROS_PACKAGE_NAME, // Package Name
                    SECPKG_CRED_INBOUND,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    &CredentialHandle1,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "AcquireCredentialsHandle failed: ");
        PrintStatus( SecStatus );
        return;
    }

    if ( !QuietMode ) {
        printf( "CredentialHandle1: 0x%lx 0x%lx   ",
                CredentialHandle1.dwLower, CredentialHandle1.dwUpper );
        PrintTime( "Lifetime: ", Lifetime );
    }


    //
    // Acquire a credential handle for the client side
    //


    RtlZeroMemory( &AuthIdentity, sizeof(AuthIdentity) );
#define DO_OEM 1
#ifndef DO_OEM
    if ( DomainName != NULL ) {
        AuthIdentity.Domain = DomainName;
        AuthIdentity.DomainLength = wcslen(DomainName);
    }
    if ( UserName != NULL ) {
        AuthIdentity.User = UserName;
        AuthIdentity.UserLength = wcslen(UserName);
    }
    if ( Password != NULL ) {
        AuthIdentity.Password = Password;
        AuthIdentity.PasswordLength = wcslen(Password);
    }
    AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
#else
    //
    // BUGBUG: memory leak here
    //

    if ( DomainName != NULL ) {
        AuthIdentity.Domain = (LPWSTR) NetpAllocStrFromWStr(DomainName);
        AuthIdentity.DomainLength = wcslen(DomainName);
    }
    if ( UserName != NULL ) {
        AuthIdentity.User = (LPWSTR) NetpAllocStrFromWStr(UserName);
        AuthIdentity.UserLength = wcslen(UserName);
    }
    if ( Password != NULL ) {
        AuthIdentity.Password = (LPWSTR) NetpAllocStrFromWStr(Password);
        AuthIdentity.PasswordLength = wcslen(Password);
    }
    AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
#endif

    SecStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    KERBEROS_PACKAGE_NAME, // Package Name
                    SECPKG_CRED_OUTBOUND,
                    NULL,
                    (DomainName == NULL && UserName == NULL && Password == NULL) ?
                        NULL : &AuthIdentity,
                    NULL,
                    NULL,
                    &CredentialHandle2,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "AcquireCredentialsHandle failed: " );
        PrintStatus( SecStatus );
        return;
    }


    if ( !QuietMode ) {
        printf( "CredentialHandle2: 0x%lx 0x%lx   ",
                CredentialHandle2.dwLower, CredentialHandle2.dwUpper );
        PrintTime( "Lifetime: ", Lifetime );
    }



    //
    // Get the NegotiateMessage (ClientSide)
    //

    NegotiateDesc.ulVersion = 0;
    NegotiateDesc.cBuffers = 1;
    NegotiateDesc.pBuffers = &NegotiateBuffer;

    NegotiateBuffer.cbBuffer = PackageInfo->cbMaxToken;
    NegotiateBuffer.BufferType = SECBUFFER_TOKEN;
    NegotiateBuffer.pvBuffer = LocalAlloc( 0, NegotiateBuffer.cbBuffer );
    if ( NegotiateBuffer.pvBuffer == NULL ) {
        printf( "Allocate NegotiateMessage failed: 0x%ld\n", GetLastError() );
        return;
    }

    SecStatus = InitializeSecurityContext(
                    &CredentialHandle2,
                    NULL,               // No Client context yet
                    "\\\\Frank\\IPC$",  // Faked target name
                    ISC_REQ_SEQUENCE_DETECT,
                    0,                  // Reserved 1
                    SECURITY_NATIVE_DREP,
                    NULL,                  // No initial input token
                    0,                  // Reserved 2
                    &ClientContextHandle,
                    &NegotiateDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        if ( !QuietMode || !NT_SUCCESS(SecStatus) ) {
            printf( "InitializeSecurityContext (negotiate): " );
            PrintStatus( SecStatus );
        }
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "\n\nNegotiate Message:\n" );

        printf( "ClientContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                ClientContextHandle.dwLower, ClientContextHandle.dwUpper,
                ContextAttributes );
        PrintTime( "Lifetime: ", Lifetime );

        DumpBuffer( NegotiateBuffer.pvBuffer, NegotiateBuffer.cbBuffer );
    }


    //
    // Get the ChallengeMessage (ServerSide)
    //

    NegotiateBuffer.BufferType |= SECBUFFER_READONLY;
    ChallengeDesc.ulVersion = 0;
    ChallengeDesc.cBuffers = 1;
    ChallengeDesc.pBuffers = &ChallengeBuffer;

    ChallengeBuffer.cbBuffer = PackageInfo->cbMaxToken;
    ChallengeBuffer.BufferType = SECBUFFER_TOKEN;
    ChallengeBuffer.pvBuffer = LocalAlloc( 0, ChallengeBuffer.cbBuffer );
    if ( ChallengeBuffer.pvBuffer == NULL ) {
        printf( "Allocate ChallengeMessage failed: 0x%ld\n", GetLastError() );
        return;
    }

    SecStatus = AcceptSecurityContext(
                    &CredentialHandle1,
                    NULL,               // No Server context yet
                    &NegotiateDesc,
                    ISC_REQ_SEQUENCE_DETECT,
                    SECURITY_NATIVE_DREP,
                    &ServerContextHandle,
                    &ChallengeDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        if ( !QuietMode || !NT_SUCCESS(SecStatus) ) {
            printf( "AcceptSecurityContext (Challenge): " );
            PrintStatus( SecStatus );
        }
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "\n\nChallenge Message:\n" );

        printf( "ServerContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                ServerContextHandle.dwLower, ServerContextHandle.dwUpper,
                ContextAttributes );
        PrintTime( "Lifetime: ", Lifetime );

        DumpBuffer( ChallengeBuffer.pvBuffer, ChallengeBuffer.cbBuffer );
    }


    //
    // Get the AuthenticateMessage (ClientSide)
    //

    ChallengeBuffer.BufferType |= SECBUFFER_READONLY;
    AuthenticateDesc.ulVersion = 0;
    AuthenticateDesc.cBuffers = 1;
    AuthenticateDesc.pBuffers = &AuthenticateBuffer;

    AuthenticateBuffer.cbBuffer = PackageInfo->cbMaxToken;
    AuthenticateBuffer.BufferType = SECBUFFER_TOKEN;
    AuthenticateBuffer.pvBuffer = LocalAlloc( 0, AuthenticateBuffer.cbBuffer );
    if ( AuthenticateBuffer.pvBuffer == NULL ) {
        printf( "Allocate AuthenticateMessage failed: 0x%ld\n", GetLastError() );
        return;
    }

    SecStatus = InitializeSecurityContext(
                    NULL,
                    &ClientContextHandle,
                    "\\\\Frank\\IPC$",     // Faked target name
                    0,
                    0,                      // Reserved 1
                    SECURITY_NATIVE_DREP,
                    &ChallengeDesc,
                    0,                  // Reserved 2
                    &ClientContextHandle,
                    &AuthenticateDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "InitializeSecurityContext (Authenticate): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "\n\nAuthenticate Message:\n" );

        printf( "ClientContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                ClientContextHandle.dwLower, ClientContextHandle.dwUpper,
                ContextAttributes );
        PrintTime( "Lifetime: ", Lifetime );

        DumpBuffer( AuthenticateBuffer.pvBuffer, AuthenticateBuffer.cbBuffer );
    }

    //
    // Finally authenticate the user (ServerSide)
    //

    AuthenticateBuffer.BufferType |= SECBUFFER_READONLY;

    SecStatus = AcceptSecurityContext(
                    NULL,
                    &ServerContextHandle,
                    &AuthenticateDesc,
                    0,
                    SECURITY_NATIVE_DREP,
                    &ServerContextHandle,
                    NULL,
                    &ContextAttributes,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "AcceptSecurityContext (Challenge): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "\n\nFinal Authentication:\n" );

        printf( "ServerContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                ServerContextHandle.dwLower, ServerContextHandle.dwUpper,
                ContextAttributes );
        PrintTime( "Lifetime: ", Lifetime );
        printf(" \n" );
    }


    //
    // Query as many attributes as possible
    //


    SecStatus = QueryContextAttributes(
                    &ClientContextHandle,
                    SECPKG_ATTR_SIZES,
                    &ContextSizes );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (sizes): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "QuerySizes: %ld %ld %ld %ld\n",
                    ContextSizes.cbMaxToken,
                    ContextSizes.cbMaxSignature,
                    ContextSizes.cbBlockSize,
                    ContextSizes.cbSecurityTrailer );
    }

    SecStatus = QueryContextAttributes(
                    &ClientContextHandle,
                    SECPKG_ATTR_NAMES,
                    ContextNamesBuffer );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (names): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "QueryNames: %ws\n", ContextNames->sUserName );
    }


    SecStatus = QueryContextAttributes(
                    &ClientContextHandle,
                    SECPKG_ATTR_LIFESPAN,
                    &ContextLifespan );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (lifespan): " );
        PrintStatus( SecStatus );
    }

    if ( NT_SUCCESS(SecStatus) )
    {
        if ( !QuietMode )
        {
            PrintTime("   Start:", ContextLifespan.tsStart );
            PrintTime("  Expiry:", ContextLifespan.tsExpiry );
        }
    }


    //
    // Get the ChallengeMessage (ServerSide)
    //
    // Now make a third call to Initialize to check that RPC can
    // reauthenticate.
    //

    AuthenticateBuffer.BufferType = SECBUFFER_TOKEN;


    SecStatus = InitializeSecurityContext(
                    NULL,
                    &ClientContextHandle,
                    "\\\\Frank\\IPC$",     // Faked target name
                    0,
                    0,                      // Reserved 1
                    SECURITY_NATIVE_DREP,
                    NULL,
                    0,                  // Reserved 2
                    &ClientContextHandle,
                    &AuthenticateDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "InitializeSecurityContext (Re-Authenticate): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }



    //
    // Now try to re-authenticate the user (ServerSide)
    //

    AuthenticateBuffer.BufferType |= SECBUFFER_READONLY;

    SecStatus = AcceptSecurityContext(
                    NULL,
                    &ServerContextHandle,
                    &AuthenticateDesc,
                    0,
                    SECURITY_NATIVE_DREP,
                    &ServerContextHandle,
                    NULL,
                    &ContextAttributes,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "AcceptSecurityContext (Re-authenticate): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }


    //
    // Impersonate the client (ServerSide)
    //

    SecStatus = ImpersonateSecurityContext( &ServerContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "ImpersonateSecurityContext: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    //
    // Do something while impersonating (Access the token)
    //

/*
    {
        NTSTATUS Status;
        HANDLE TokenHandle = NULL;

        //
        // Open the token,
        //

        Status = NtOpenThreadToken(
                    NtCurrentThread(),
                    TOKEN_QUERY,
                    (BOOLEAN) TRUE, // Not really using the impersonation token
                    &TokenHandle );

        if ( !NT_SUCCESS(Status) ) {
            printf( "Access Thread token while impersonating: " );
            PrintStatus( Status );
            return;
        } else {
            (VOID) NtClose( TokenHandle );
        }
    }
*/


    //
    // RevertToSelf (ServerSide)
    //

    SecStatus = RevertSecurityContext( &ServerContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "RevertSecurityContext: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    //
    // Sign a message
    //

    SecStatus = MakeSignature(
                        &ClientContextHandle,
                        0,
                        &SignMessage,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "MakeSignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {

        printf("\n Signature: \n");
        DumpBuffer(SigBuffers[1].pvBuffer,SigBuffers[1].cbBuffer);

    }


    //
    // Verify the signature
    //

    SecStatus = VerifySignature(
                        &ServerContextHandle,
                        &SignMessage,
                        0,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "VerifySignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }



    //
    // Sign a message, this time to check if it can detect a change in the
    // message
    //

    SecStatus = MakeSignature(
                        &ClientContextHandle,
                        0,
                        &SignMessage,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "MakeSignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {

        printf("\n Signature: \n");
        DumpBuffer(SigBuffers[1].pvBuffer,SigBuffers[1].cbBuffer);

    }

    //
    // Mess up the message to see if VerifySignature works
    //

    bDataBuffer[10] = 0xec;

    //
    // Verify the signature
    //

    SecStatus = VerifySignature(
                        &ServerContextHandle,
                        &SignMessage,
                        0,
                        0 );

    if ( SecStatus != SEC_E_MESSAGE_ALTERED ) {
        printf( "VerifySignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    //
    // Delete both contexts.
    //


    SecStatus = DeleteSecurityContext( &ClientContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "DeleteSecurityContext failed: " );
        PrintStatus( SecStatus );
        return;
    }

    SecStatus = DeleteSecurityContext( &ServerContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "DeleteSecurityContext failed: " );
        PrintStatus( SecStatus );
        return;
    }



    //
    // Free both credential handles
    //

    SecStatus = FreeCredentialsHandle( &CredentialHandle1 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "FreeCredentialsHandle failed: " );
        PrintStatus( SecStatus );
        return;
    }

    SecStatus = FreeCredentialsHandle( &CredentialHandle2 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "FreeCredentialsHandle failed: " );
        PrintStatus( SecStatus );
        return;
    }


    //
    // Final Cleanup
    //

    if ( NegotiateBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( NegotiateBuffer.pvBuffer );
    }

    if ( ChallengeBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( ChallengeBuffer.pvBuffer );
    }

    if ( AuthenticateBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( AuthenticateBuffer.pvBuffer );
    }
}



int __cdecl
main(
    IN int argc,
    IN char ** argv
    )
/*++

Routine Description:

    Drive the NtLmSsp service

Arguments:

    argc - the number of command-line arguments.

    argv - an array of pointers to the arguments.

Return Value:

    Exit status

--*/
{
    LPSTR argument;
    int i;
    ULONG j;
    ULONG Iterations;

    LPWSTR DomainName = NULL;
    LPWSTR UserName = NULL;
    LPWSTR Password = NULL;

    enum {
        NoAction,
        ConfigureService,
#define CONFIG_PARAM "/ConfigureService"
        TestLpc,
#define TESTLPC_PARAM "/TestLpc"
#define TESTLPC2_PARAM "/TestLpc:"
    } Action = NoAction;
#define QUIET_PARAM "/Q"





    //
    // Loop through the arguments handle each in turn
    //

    for ( i=1; i<argc; i++ ) {

        argument = argv[i];

        //
        // Handle /TestLpc
        //

        if ( _stricmp( argument, TESTLPC_PARAM ) == 0 ) {
            if ( Action != NoAction ) {
                goto Usage;
            }

            Action = TestLpc;
            Iterations = 1;

        //
        // Handle /TestLpc:
        //

        } else if ( _strnicmp( argument,
                              TESTLPC2_PARAM,
                              sizeof(TESTLPC2_PARAM)-1 ) == 0 ){
            char *end;
            if ( Action != NoAction ) {
                goto Usage;
            }

            Action = TestLpc;

            Iterations = strtoul( &argument[sizeof(TESTLPC2_PARAM)-1], &end, 10 );

            i++;
            if ( i < argc ) {
                argument = argv[i];
                DomainName = NetpAllocWStrFromStr( argument );

                i++;
                if ( i < argc ) {
                    argument = argv[i];
                    UserName = NetpAllocWStrFromStr( argument );

                    i++;
                    if ( i < argc ) {
                        argument = argv[i];
                        Password = NetpAllocWStrFromStr( argument );
                    }
                }
            }


        } else {
        //
        // Handle all other parameters
        //

Usage:
            fprintf( stderr, "Usage: ssptest [/OPTIONS]\n\n" );

            fprintf(
                stderr,
                "\n"
                "    " TESTLPC_PARAM "[:<iterations> <DomainName> <UserName> <Password>] - Test basic LPC to NtLmSsp service.\n"
                "    " QUIET_PARAM " - Don't be so verbose\n"
                "\n"
                "\n" );
            return(1);
        }
    }

    //
    // Perform the action requested
    //

    switch ( Action ) {
    case TestLpc: {
        for ( j=0; j<Iterations ; j++ ) {
            TestLpcRoutine( DomainName, UserName, Password );
        }
        break;
    }
    }

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\pwdssp\pwdssp.h ===
#ifndef __PWDSSP_H__
#define __PWDSSP_H__

#define PWDSSP_NAME_A   "PWDSSP"
#define PWDSSP_NAME_W   L"PWDSSP"

#ifdef UNICODE
#define PWDSSP_NAME PWDSSP_NAME_W
#else
#define PWDSSP_NAME PWDSSP_NAME_A
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\pwdssp\crack.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       crack.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    9-07-97   RichardW   Created
//
//----------------------------------------------------------------------------

#include "pwdsspp.h"



BOOL
CacheInitialize(
    VOID
    )
{
    return TRUE ;
}


BOOL
PwdCrackName(
    PWSTR DN,
    PWSTR FlatDomain,
    PWSTR FlatUser
    )
{
    WCHAR FlatName[ 128 ];
    WCHAR DnsDomain[ 256 ];
    DWORD DnsSize ;
    DWORD Size ;
    NTSTATUS Status ;
    DWORD DsError ;
    PWSTR Scan ;
    PVOID DsContext ;

    Size = sizeof( FlatName ) / sizeof(WCHAR) ;
    DnsSize = sizeof( DnsDomain ) / sizeof( WCHAR );

    DsContext = THSave();

    __try
    {
        Status = CrackSingleName(
                        DS_UNKNOWN_NAME,
                        0,
                        DN,
                        DS_NT4_ACCOUNT_NAME,
                        &DnsSize,
                        DnsDomain,
                        &Size,
                        FlatName,
                        &DsError );

    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        Status = GetExceptionCode();
    }

    if ( !NT_SUCCESS( Status ) )
    {
        THRestore( DsContext );

        return FALSE ;
    }

    if ( DsError == DS_NAME_ERROR_DOMAIN_ONLY )
    {
        Size = sizeof( FlatName ) / sizeof( WCHAR ) ;

        DnsSize = sizeof( DnsDomain ) / sizeof( WCHAR );

        Status = CrackSingleName(
                            DS_UNKNOWN_NAME,
                            DS_NAME_FLAG_GCVERIFY,
                            DN,
                            DS_NT4_ACCOUNT_NAME,
                            &DnsSize,
                            DnsDomain,
                            &Size,
                            FlatName,
                            &DsError );

    }

    THRestore( DsContext );

    if ( !NT_SUCCESS( Status ) )
    {
        return FALSE ;
    }

    if ( DsError == DS_NAME_NO_ERROR )
    {
        Scan = wcschr( FlatName, L'\\' );

        if ( Scan )
        {
            *Scan++ = L'\0' ;
            wcscpy(FlatDomain, FlatName );
            wcscpy(FlatUser, Scan );
        }
        else
        {
            wcscpy(FlatUser, FlatName );
            FlatDomain[0] = L'\0';
        }

        return TRUE ;

    }

    return FALSE ;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\msv_sspi\rpctesta\client\helloc.c ===
/****************************************************************************
           Microsoft RPC Version 1`1
         Copyright Microsoft Corp. 1992
                Hello Example

    FILE:   helloc.c
    USAGE:   client    -n network_address
          -p protocol_sequence
          -e endpoint
          -o options
          -u uuid

    PURPOSE:   Client side of RPC distributed application
    FUNCTIONS:   main() - binds to server and calls remote procedure
    COMMENTS:
    This distributed application prints a string such as "hello, world"
    on the server. The client manages its connection to the server.
    The client uses the binding handle hello_IfHandle defined in the
    file hello.h.

****************************************************************************/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <rpc.h>       // RPC API functions, types
#include "hello.h"     // header file generated by MIDL compiler

void Usage(char * pszProgramName)
{
    fprintf(stderr, "Usage:  %s\n", pszProgramName);
    fprintf(stderr, " -p protocol_sequence\n");
    fprintf(stderr, " -n network_address\n");
    fprintf(stderr, " -e endpoint\n");
    fprintf(stderr, " -o options\n");
    fprintf(stderr, " -u uuid\n");
    fprintf(stderr, " -s string\n");
    exit(1);
}

int __cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    RPC_STATUS status;             // returned by RPC API function
    unsigned char * pszUuid = "12345678-1234-1234-1234-123456789ABC";
    unsigned char * pszProtocolSequence = "ncacn_np";
    unsigned char * pszNetworkAddress   = NULL;
    unsigned char * pszEndpoint    = "\\pipe\\hello";
    unsigned char * pszOptions          = NULL;
    unsigned char * pszStringBinding   = NULL;
    unsigned char * pszString      = "hello, world";
    int i;

    // allow the user to override settings with command line switches
    for (i = 1; i < argc; i++) {
        if ((*argv[i] == '-') || (*argv[i] == '/')) {
            switch (tolower(*(argv[i]+1))) {
            case 'p':  // protocol sequence
                pszProtocolSequence = argv[++i];
                break;
            case 'n':  // network address
                pszNetworkAddress = argv[++i];
                break;
            case 'e':
                pszEndpoint = argv[++i];
                break;
            case 'o':
                pszOptions = argv[++i];
                break;
            case 'u':
                pszUuid = argv[++i];
                break;
            case 's':
                pszString = argv[++i];
                break;
            case 'h':
            case '?':
            default:
                Usage(argv[0]);
            }
        } else {
            Usage(argv[0]);
        }
    }


    // Use a convenience function to concatenate the elements of
    // the string binding into the proper sequence.

    status = RpcStringBindingCompose(pszUuid,
                                     pszProtocolSequence,
                                     pszNetworkAddress,
                                     pszEndpoint,
                                     pszOptions,
                                     &pszStringBinding);

    if (status) {
        printf("RpcStringBindingCompose returned 0x%x\n", status);
        exit(2);
    }
    printf("pszStringBinding = %s\n", pszStringBinding);



    //
    // Set the binding handle that will be used to bind to the server.
    //

    status = RpcBindingFromStringBinding(pszStringBinding,
                &hello_IfHandle);
    if (status) {
        printf("RpcBindingFromStringBinding returned 0x%x\n", status);
        exit(2);
    }


    //
    // Tell RPC to do the security thing.
    //

    status = RpcBindingSetAuthInfo(
                    hello_IfHandle,
                    "ntdev\\chandans",
                    RPC_C_AUTHN_LEVEL_CONNECT,
                    18,
                    NULL,
                    RPC_C_AUTHZ_NAME );

    if ( status ) {
        printf("RpcBindingSetAuthInfo returned %ld\n", status);
        exit(2);
    }


    //
    // Do the actual RPC calls to the server.
    //

    printf("  print the string '%s' on the server\n", pszString);

    RpcTryExcept {
        int i;
        for ( i=0; i<100 ; i++ ) {
            HelloProc(pszString);    // make call with user message
        }
        Shutdown();              // shut down the server side
    } RpcExcept(1) {
        printf("Runtime library reported an exception 0x%lx\n",
               RpcExceptionCode());
    } RpcEndExcept



    // The calls to the remote procedures are complete.
    // Free the string and the binding handle

    status = RpcStringFree(&pszStringBinding);   // remote calls done; unbind
    if (status) {
        printf("RpcStringFree returned 0x%x\n", status);
        exit(2);
    }

    status = RpcBindingFree(&hello_IfHandle);  // remote calls done; unbind
    if (status) {
        printf("RpcBindingFree returned 0x%x\n", status);
        exit(2);
    }


    return 0;

}

// ====================================================================
//                MIDL allocate and free
// ====================================================================


void __RPC_FAR * __RPC_API MIDL_user_allocate(size_t len)
{
    return(malloc(len));
}

void __RPC_API MIDL_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}

/* end file helloc.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\pwdssp\pwdssp.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       pwdssp.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    9-07-97   RichardW   Created
//
//----------------------------------------------------------------------------


#include "pwdsspp.h"

typedef struct _PWD_CRED {
    DWORD   Ref;
} PWD_CRED, * PPWD_CRED;

typedef struct _PWD_CONTEXT {
    DWORD   Tag;
    HANDLE  Token;
} PWD_CONTEXT, *PPWD_CONTEXT ;

PWD_CRED            PwdGlobalAnsi;
PWD_CRED            PwdGlobalUnicode;

#define CONTEXT_TAG 'txtC'
#define ANONYMOUS_TOKEN ((HANDLE) 1)

SecPkgInfoA PwdInfoA = {    SECPKG_FLAG_CONNECTION |
                                SECPKG_FLAG_ACCEPT_WIN32_NAME,
                            1,
                            (WORD) -1,
                            768,
                            PWDSSP_NAME_A,
                            "Microsoft Clear Text Password Security Provider" };

SecPkgInfoW PwdInfoW = {    SECPKG_FLAG_CONNECTION |
                                SECPKG_FLAG_ACCEPT_WIN32_NAME,
                            1,
                            (WORD) -1,
                            768,
                            PWDSSP_NAME_W,
                            L"Microsoft Clear Text Password Security Provider" };




SecurityFunctionTableA  PwdTableA = {
        SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION,
        EnumerateSecurityPackagesA,
        NULL,
        AcquireCredentialsHandleA,
        FreeCredentialsHandle,
        NULL,
        InitializeSecurityContextA,
        AcceptSecurityContext,
        CompleteAuthToken,
        DeleteSecurityContext,
        ApplyControlToken,
        QueryContextAttributesA,
        ImpersonateSecurityContext,
        RevertSecurityContext,
        MakeSignature,
        VerifySignature,
        FreeContextBuffer,
        QuerySecurityPackageInfoA,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        QuerySecurityContextToken
        };

SecurityFunctionTableW  PwdTableW = {
        SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION,
        EnumerateSecurityPackagesW,
        NULL,
        AcquireCredentialsHandleW,
        FreeCredentialsHandle,
        NULL,
        InitializeSecurityContextW,
        AcceptSecurityContext,
        CompleteAuthToken,
        DeleteSecurityContext,
        ApplyControlToken,
        QueryContextAttributesW,
        ImpersonateSecurityContext,
        RevertSecurityContext,
        MakeSignature,
        VerifySignature,
        FreeContextBuffer,
        QuerySecurityPackageInfoW,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        QuerySecurityContextToken
        };


//#define PwdAlloc(x) LsaIAllocateHeap(x)
//#define PwdFree(x)  LsaIFreeHeap(x)
#define PwdAlloc(x) LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT,x)
#define PwdFree(x)  LocalFree(x)

NTSTATUS
VerifyCredentials(
    IN PWSTR UserName,
    IN PWSTR DomainName,
    IN PWSTR Password,
    IN ULONG VerifyFlags
    );

UNICODE_STRING AuthenticationPackage;

//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   Entry point
//
//  Arguments:  [hInstance]  --
//              [dwReason]   --
//              [lpReserved] --
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
WINAPI
DllMain(
    HINSTANCE       hInstance,
    DWORD           dwReason,
    LPVOID          lpReserved)
{

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls( hInstance );
        RtlInitUnicodeString(&AuthenticationPackage, MICROSOFT_KERBEROS_NAME_W);

        if ( !CacheInitialize() ) {
            return FALSE;
        }
    }

    return(TRUE);
}

//+---------------------------------------------------------------------------
//
//  Function:   PwdpParseBuffers
//
//  Synopsis:   Parse out right buffer descriptor
//
//  Arguments:  [pMessage] --
//              [pToken]   --
//              [pEmpty]   --
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
PwdpParseBuffers(
    PSecBufferDesc  pMessage,
    PSecBuffer *    pToken,
    PSecBuffer *    pEmpty)
{
    ULONG       i;
    PSecBuffer  pFirstBlank = NULL;
    PSecBuffer  pWholeMessage = NULL;


    for (i = 0 ; i < pMessage->cBuffers ; i++ )
    {
        if ( (pMessage->pBuffers[i].BufferType & (~SECBUFFER_ATTRMASK)) == SECBUFFER_TOKEN )
        {
            pWholeMessage = &pMessage->pBuffers[i];
            if (pFirstBlank)
            {
                break;
            }
        }
        else if ( (pMessage->pBuffers[i].BufferType & (~SECBUFFER_ATTRMASK)) == SECBUFFER_EMPTY )
        {
            pFirstBlank = &pMessage->pBuffers[i];
            if (pWholeMessage)
            {
                break;
            }
        }
    }

    if (pToken)
    {
        *pToken = pWholeMessage;
    }

    if (pEmpty)
    {
        *pEmpty = pFirstBlank;
    }

}

//+---------------------------------------------------------------------------
//
//  Function:   AcquireCredentialsHandleW
//
//  Synopsis:   Get the credential handle
//
//  Arguments:  [pszPrincipal]     --
//              [pszPackageName]   --
//              [fCredentialUse]   --
//              [pvLogonId]        --
//              [pAuthData]        --
//              [pGetKeyFn]        --
//              [GetKey]           --
//              [pvGetKeyArgument] --
//              [GetKey]           --
//              [phCredential]     --
//              [PTimeStamp]       --
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
AcquireCredentialsHandleW(
    SEC_WCHAR SEC_FAR *         pszPrincipal,       // Name of principal
    SEC_WCHAR SEC_FAR *         pszPackageName,     // Name of package
    unsigned long               fCredentialUse,     // Flags indicating use
    void SEC_FAR *              pvLogonId,          // Pointer to logon ID
    void SEC_FAR *              pAuthData,          // Package specific data
    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func
    void SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey()
    PCredHandle                 phCredential,       // (out) Cred Handle
    PTimeStamp                  ptsExpiry           // (out) Lifetime (optional)
    )
{
    if (_wcsicmp(pszPackageName, PWDSSP_NAME_W))
    {
        return( SEC_E_SECPKG_NOT_FOUND );
    }

    if ( fCredentialUse & SECPKG_CRED_OUTBOUND )
    {
        return( SEC_E_NO_CREDENTIALS );
    }

    InterlockedIncrement( &PwdGlobalUnicode.Ref );

    phCredential->dwUpper = (ULONG_PTR) &PwdGlobalUnicode ;

    if ( ptsExpiry )
    {
        ptsExpiry->LowPart = (DWORD) 0xFFFFFFFF;
        ptsExpiry->HighPart = (DWORD) 0x7FFFFFFF;
    }

    return( SEC_E_OK );
}

//+---------------------------------------------------------------------------
//
//  Function:   AcquireCredentialsHandleA
//
//  Synopsis:   ANSI entry
//
//  Arguments:  [pszPrincipal]     --
//              [pszPackageName]   --
//              [fCredentialUse]   --
//              [pvLogonId]        --
//              [pAuthData]        --
//              [pGetKeyFn]        --
//              [GetKey]           --
//              [pvGetKeyArgument] --
//              [GetKey]           --
//              [phCredential]     --
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
AcquireCredentialsHandleA(
    SEC_CHAR SEC_FAR *          pszPrincipal,       // Name of principal
    SEC_CHAR SEC_FAR *          pszPackageName,     // Name of package
    unsigned long               fCredentialUse,     // Flags indicating use
    void SEC_FAR *              pvLogonId,          // Pointer to logon ID
    void SEC_FAR *              pAuthData,          // Package specific data
    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func
    void SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey()
    PCredHandle                 phCredential,       // (out) Cred Handle
    PTimeStamp                  ptsExpiry           // (out) Lifetime (optional)
    )
{

    if (_stricmp(pszPackageName, PWDSSP_NAME_A))
    {
        return( SEC_E_SECPKG_NOT_FOUND );
    }

    if ( fCredentialUse & SECPKG_CRED_OUTBOUND )
    {
        return( SEC_E_NO_CREDENTIALS );
    }

    InterlockedIncrement( &PwdGlobalAnsi.Ref );

    phCredential->dwUpper = (ULONG_PTR) &PwdGlobalAnsi ;

    if ( ptsExpiry )
    {
        ptsExpiry->LowPart = (DWORD) 0xFFFFFFFF;
        ptsExpiry->HighPart = (DWORD) 0x7FFFFFFF;
    }


    return(SEC_E_OK);

}

//+---------------------------------------------------------------------------
//
//  Function:   FreeCredentialHandle
//
//  Synopsis:   Free a credential handle
//
//  Arguments:  [free] --
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
FreeCredentialsHandle(
    PCredHandle                 phCredential        // Handle to free
    )
{
    PPWD_CRED Cred;

    if ( (phCredential->dwUpper != (ULONG_PTR) &PwdGlobalAnsi ) &&
         (phCredential->dwUpper != (ULONG_PTR) &PwdGlobalUnicode ) )
    {
        return( SEC_E_INVALID_HANDLE );
    }

    Cred = (PPWD_CRED) phCredential->dwUpper ;

    InterlockedDecrement( &Cred->Ref );

    return( SEC_E_OK );

}

//+---------------------------------------------------------------------------
//
//  Function:   InitializeSecurityContextW
//
//  Synopsis:   Initialize a security context (outbound) NOT SUPPORTED
//
//  Arguments:  [phCredential]  --
//              [phContext]     --
//              [pszTargetName] --
//              [fContextReq]   --
//              [Reserved1]     --
//              [Reserved]      --
//              [TargetDataRep] --
//              [pInput]        --
//              [Reserved2]     --
//              [Reserved]      --
//              [phNewContext]  --
//              [pOutput]       --
//              [pfContextAttr] --
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
InitializeSecurityContextW(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    SEC_WCHAR SEC_FAR *          pszTargetName,      // Name of target
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               Reserved1,          // Reserved, MBZ
    unsigned long               TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    unsigned long               Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    )
{
    return( SEC_E_UNSUPPORTED_FUNCTION );

}


//+---------------------------------------------------------------------------
//
//  Function:   InitializeSecurityContextA
//
//  Synopsis:   NOT SUPPORTED
//
//  Arguments:  [phCredential]  --
//              [phContext]     --
//              [pszTargetName] --
//              [fContextReq]   --
//              [Reserved1]     --
//              [TargetDataRep] --
//              [pInput]        --
//              [Reserved2]     --
//              [phNewContext]  --
//              [pOutput]       --
//              [pfContextAttr] --
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
InitializeSecurityContextA(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    SEC_CHAR SEC_FAR *          pszTargetName,      // Name of target
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               Reserved1,          // Reserved, MBZ
    unsigned long               TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    unsigned long               Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    )
{
    return( SEC_E_UNSUPPORTED_FUNCTION );
}

PSEC_WINNT_AUTH_IDENTITY_A
PwdpMakeAnsiCopy(
    PSEC_WINNT_AUTH_IDENTITY_A  Ansi
    )
{
    PSEC_WINNT_AUTH_IDENTITY_A  New ;

    New = PwdAlloc( sizeof( SEC_WINNT_AUTH_IDENTITY_A ) +
                            Ansi->UserLength + 1 +
                            Ansi->DomainLength + 1 +
                            Ansi->PasswordLength + 1 );

    if ( New )
    {
        New->User = (PSTR) (New + 1);
        CopyMemory( New->User, Ansi->User, Ansi->UserLength );
        New->User[ Ansi->UserLength ] = '\0';

        New->Domain = New->User + Ansi->UserLength + 1 ;
        CopyMemory( New->Domain, Ansi->Domain, Ansi->DomainLength );
        New->Domain[ Ansi->DomainLength ] = '\0';

        New->Password = New->Domain + Ansi->DomainLength + 1 ;
        CopyMemory( New->Password, Ansi->Password, Ansi->PasswordLength );
        New->Password[ Ansi->PasswordLength ] = '\0';

    }

    return( New );
}

PSEC_WINNT_AUTH_IDENTITY_W
PwdpMakeWideCopy(
    PSEC_WINNT_AUTH_IDENTITY_W  Wide,
    BOOLEAN ValidateOnly
    )
{
    PSEC_WINNT_AUTH_IDENTITY_W  New ;
    ULONG FlatUserLength ;
    PWSTR FlatUser = NULL;
    WCHAR FlatDomain[ DNLEN + 2 ];
    SEC_WINNT_AUTH_IDENTITY_W Local ;

    if ( (Wide->Domain == NULL) )
    {
        if( ValidateOnly )
        {
            ULONG Index;

            Local = *Wide ;

            FlatUserLength = wcslen( Wide->User );

            for( Index = 0 ; Index < FlatUserLength ; Index++ )
            {
                if( Wide->User[ Index ] == '\\' )
                {
                    Local.Domain = Wide->User;
                    Local.DomainLength = Index;

                    Local.User = &(Wide->User[Index+1]);
                    Local.UserLength = FlatUserLength - Index - 1;
                    break;
                }
            }

        } else {

            FlatUserLength = wcslen( Wide->User ) + 1;
            if ( FlatUserLength < UNLEN+2 )
            {
                FlatUserLength = UNLEN + 2;
            }

            FlatUser = PwdAlloc(FlatUserLength * sizeof( WCHAR ));
            if ( FlatUser == NULL )
            {
                return NULL ;
            }
            if ( ! PwdCrackName( Wide->User,
                          FlatDomain,
                          FlatUser ) )
            {
                PwdFree( FlatUser );
                SetLastError( ERROR_NO_SUCH_USER );
                return NULL ;
            }

            Local = *Wide ;
            Local.User = FlatUser ;
            Local.Domain = FlatDomain ;
            Local.UserLength = wcslen( FlatUser );
            Local.DomainLength = wcslen( FlatDomain );
        }

        Wide = &Local ;

    }

    New = PwdAlloc( sizeof( SEC_WINNT_AUTH_IDENTITY_W ) +
                            (Wide->UserLength + 1) * sizeof(WCHAR) +
                            (Wide->DomainLength + 1) * sizeof(WCHAR) +
                            (Wide->PasswordLength + 1) * sizeof(WCHAR) );

    if ( New )
    {
        New->User = (PWSTR) (New + 1);
        CopyMemory( New->User, Wide->User, Wide->UserLength * 2 );
        New->User[ Wide->UserLength ] = L'\0';

        New->UserLength = Wide->UserLength;

        New->Domain = New->User + Wide->UserLength + 1 ;
        CopyMemory( New->Domain, Wide->Domain, Wide->DomainLength * 2 );
        New->Domain[ Wide->DomainLength ] = L'\0';

        New->DomainLength = Wide->DomainLength;

        New->Password = New->Domain + Wide->DomainLength + 1 ;
        CopyMemory( New->Password, Wide->Password, Wide->PasswordLength * 2);
        New->Password[ Wide->PasswordLength ] = '\0';

        New->PasswordLength = Wide->PasswordLength;

    }

    if ( Wide == &Local )
    {
        if( FlatUser != NULL )
        {
            PwdFree( FlatUser );
        }
    }

    return( New );

}



//+---------------------------------------------------------------------------
//
//  Function:   AcceptSecurityContext
//
//  Synopsis:   Server side accept security context
//
//  Arguments:  [phCredential]  --
//              [phContext]     --
//              [pInput]        --
//              [fContextReq]   --
//              [TargetDataRep] --
//              [phNewContext]  --
//              [pOutput]       --
//              [pfContextAttr] --
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
AcceptSecurityContext(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    PSecBufferDesc              pInput,             // Input buffer
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               TargetDataRep,      // Target Data Rep
    PCtxtHandle                 phNewContext,       // (out) New context handle
    PSecBufferDesc              pOutput,            // (inout) Output buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attributes
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    )
{
    PPWD_CONTEXT    Context ;
    PSecBuffer      Buffer ;
    DWORD           Type;
    PSEC_WINNT_AUTH_IDENTITY_W  Unknown ;
    PSEC_WINNT_AUTH_IDENTITY_A  Ansi;
    PSEC_WINNT_AUTH_IDENTITY_W  Unicode;
    HANDLE          Token;
    BOOL            Ret;

    if ( phCredential->dwUpper == (ULONG_PTR) &PwdGlobalAnsi )
    {
        Type = 1;
    }
    else
    {
        if ( phCredential->dwUpper == (ULONG_PTR) &PwdGlobalUnicode )
        {
            Type = 2;
        }
        else
        {
            return( SEC_E_INVALID_HANDLE );
        }
    }


    PwdpParseBuffers( pInput, &Buffer, NULL );

    if ( !Buffer )
    {
        return( SEC_E_INVALID_TOKEN );
    }

    Unknown = (PSEC_WINNT_AUTH_IDENTITY_W) Buffer->pvBuffer ;

    if ( Unknown->Flags & SEC_WINNT_AUTH_IDENTITY_UNICODE )
    {
        Type = 2 ;
    }

    if ( Type == 1 )
    {
        //
        // ANSI:
        //

        Ansi = PwdpMakeAnsiCopy( (PSEC_WINNT_AUTH_IDENTITY_A) Buffer->pvBuffer);

        if ( Ansi )
        {
            Ret = LogonUserA( Ansi->User, Ansi->Domain, Ansi->Password,
                             LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT,
                             &Token ) ;

            PwdFree( Ansi );
        }
        else
        {
            Ret = FALSE ;
        }
    }
    else
    {
        BOOLEAN ValidateOnly = ((fContextReq & ASC_REQ_ALLOW_NON_USER_LOGONS) != 0);

        Unicode = PwdpMakeWideCopy(
                        (PSEC_WINNT_AUTH_IDENTITY_W) Buffer->pvBuffer,
                        ValidateOnly
                        );

        if ( Unicode )
        {
            if( ValidateOnly )
            {
                PVOID DsContext = THSave();
                NTSTATUS Status;

                Status = VerifyCredentials(
                            Unicode->User,
                            Unicode->Domain,
                            Unicode->Password,
                            0
                            );

                THRestore( DsContext );

                if( NT_SUCCESS(Status) )
                {
                    Ret = TRUE;

                    Token = ANONYMOUS_TOKEN ;

                } else {
                    Ret = FALSE;
                }

            } else {
                Ret = LogonUserW(
                        Unicode->User,
                        Unicode->Domain,
                        Unicode->Password,
                        LOGON32_LOGON_NETWORK,
                        LOGON32_PROVIDER_DEFAULT,
                        &Token
                        );
            }


            PwdFree( Unicode );
        }
        else
        {
            Ret = FALSE ;

            if ( GetLastError() == ERROR_NO_SUCH_USER )
            {
                Unicode = (PSEC_WINNT_AUTH_IDENTITY_W) Buffer->pvBuffer ;

                __try 
                {
                    if ( Unicode->PasswordLength == 0 )
                    {
                        Ret = TRUE ;
                        Token = ANONYMOUS_TOKEN ;
                    }
                }
                __except( EXCEPTION_EXECUTE_HANDLER )
                {
                    NOTHING ;
                }
            }
        }
    }

    if ( Ret )
    {
        Context = (PPWD_CONTEXT) PwdAlloc( sizeof( PWD_CONTEXT ) );

        if ( Context )
        {
            Context->Tag = CONTEXT_TAG ;

            Context->Token = Token ;

            phNewContext->dwUpper = (ULONG_PTR) Context ;

            return( SEC_E_OK );
        }

        if ( Token != ANONYMOUS_TOKEN )
        {
            CloseHandle( Token );
        }


        return( SEC_E_INSUFFICIENT_MEMORY );
    }

    return( SEC_E_INVALID_TOKEN );
}


//+---------------------------------------------------------------------------
//
//  Function:   DeleteSecurityContext
//
//  Synopsis:   Deletes a security context
//
//  Arguments:  [phContext] --
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
DeleteSecurityContext(
    PCtxtHandle  phContext )
{
    PPWD_CONTEXT    Context;

    Context = (PPWD_CONTEXT) phContext->dwUpper ;

#if DBG
    // What is the appropriate assert model?  This dll does not seem to
    // nt specific, win32 does not provide a model, and the crt requires
    // NDEBUG to set, which is not always the case.
    if (!Context) {
        OutputDebugStringA("[PWDSSP]: !!Error!! - Context is NULL\n");
        DebugBreak();
    }
#endif

    if ( Context->Tag == CONTEXT_TAG )
    {
        if ( Context->Token != ANONYMOUS_TOKEN )
        {
            CloseHandle( Context->Token );
        }

        PwdFree( Context );

        return( SEC_E_OK );
    }

    return( SEC_E_INVALID_HANDLE );

}

//+---------------------------------------------------------------------------
//
//  Function:   ImpersonateSecurityContext
//
//  Synopsis:   Impersonate the security context
//
//  Arguments:  [impersonate] --
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
ImpersonateSecurityContext(
    PCtxtHandle                 phContext           // Context to impersonate
    )
{
    PPWD_CONTEXT    Context;
    HANDLE  hThread;
    NTSTATUS Status ;

    Context = (PPWD_CONTEXT) phContext->dwUpper ;

    if ( Context->Tag == CONTEXT_TAG )
    {
        if ( Context->Token != ANONYMOUS_TOKEN )
        {
            hThread = GetCurrentThread();

            SetThreadToken( &hThread, Context->Token );

            Status = SEC_E_OK ;
        }
        else 
        {
            Status = NtImpersonateAnonymousToken(
                            NtCurrentThread() );

        }

        return( Status );

    }

    return( SEC_E_INVALID_HANDLE );
}



//+---------------------------------------------------------------------------
//
//  Function:   RevertSecurityContext
//
//  Synopsis:   Revert the security context
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
RevertSecurityContext(
    PCtxtHandle                 phContext           // Context from which to re
    )
{
    PPWD_CONTEXT    Context;

    Context = (PPWD_CONTEXT) phContext->dwUpper ;

    if ( Context->Tag == CONTEXT_TAG )
    {
        RevertToSelf();

        return( SEC_E_OK );

    }

    return( SEC_E_INVALID_HANDLE );

}

SECURITY_STATUS
SEC_ENTRY
QueryContextAttributesA(
    PCtxtHandle                 phContext,          // Context to query
    unsigned long               ulAttribute,        // Attribute to query
    void SEC_FAR *              pBuffer             // Buffer for attributes
    )
{
    return( SEC_E_UNSUPPORTED_FUNCTION );
}


SECURITY_STATUS
SEC_ENTRY
QueryContextAttributesW(
    PCtxtHandle                 phContext,          // Context to query
    unsigned long               ulAttribute,        // Attribute to query
    void SEC_FAR *              pBuffer             // Buffer for attributes
    )
{
    return( SEC_E_UNSUPPORTED_FUNCTION );
}


//+---------------------------------------------------------------------------
//
//  Function:   PwdpCopyInfoW
//
//  Synopsis:   Helper - copy package info around
//
//  Arguments:  [ppPackageInfo] --
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
PwdpCopyInfoW(
    PSecPkgInfoW *  ppPackageInfo)
{
    DWORD           cbTotal;
    PSecPkgInfoW    pInfo;
    PWSTR           pszCopy;

    cbTotal = sizeof(SecPkgInfoW) +
              (wcslen(PwdInfoW.Name) + wcslen(PwdInfoW.Comment) + 2) * 2;

    pInfo = PwdAlloc( cbTotal );

    if (pInfo)
    {
        *pInfo = PwdInfoW;

        pszCopy = (PWSTR) (pInfo + 1);

        pInfo->Name = pszCopy;

        wcscpy(pszCopy, PwdInfoW.Name);

        pszCopy += wcslen(PwdInfoW.Name) + 1;

        pInfo->Comment = pszCopy;

        wcscpy(pszCopy, PwdInfoW.Comment);

        *ppPackageInfo = pInfo;

        return(SEC_E_OK);

    }

    return(SEC_E_INSUFFICIENT_MEMORY);

}

//+---------------------------------------------------------------------------
//
//  Function:   PwdpCopyInfoA
//
//  Synopsis:   copy ansi package info around
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
PwdpCopyInfoA(
    PSecPkgInfoA *  ppPackageInfo)
{
    DWORD           cbTotal;
    PSecPkgInfoA    pInfo;
    PSTR            pszCopy;

    cbTotal = sizeof(SecPkgInfoA) +
              (strlen(PwdInfoA.Name) + strlen(PwdInfoA.Comment) + 2) * 2;

    pInfo = PwdAlloc( cbTotal );

    if (pInfo)
    {
        *pInfo = PwdInfoA;

        pszCopy = (PSTR) (pInfo + 1);

        pInfo->Name = pszCopy;

        strcpy(pszCopy, PwdInfoA.Name);

        pszCopy += strlen(PwdInfoA.Name) + 1;

        pInfo->Comment = pszCopy;

        strcpy(pszCopy, PwdInfoA.Comment);

        *ppPackageInfo = pInfo;

        return(SEC_E_OK);

    }

    return(SEC_E_INSUFFICIENT_MEMORY);

}


//+---------------------------------------------------------------------------
//
//  Function:   EnumerateSecurityPackagesW
//
//  Synopsis:   Enumerate packages in this DLL
//
//  Arguments:  [pcPackages] --
//              [info]       --
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
EnumerateSecurityPackagesW(
    unsigned long SEC_FAR *     pcPackages,         // Receives num. packages
    PSecPkgInfoW SEC_FAR *       ppPackageInfo       // Receives array of info
    )
{
    SECURITY_STATUS scRet;

    *ppPackageInfo = NULL;

    scRet = PwdpCopyInfoW(ppPackageInfo);
    if (SUCCEEDED(scRet))
    {
        *pcPackages = 1;
        return(scRet);
    }

    *pcPackages = 0;

    return(scRet);

}
//+---------------------------------------------------------------------------
//
//  Function:   EnumerateSecurityPackagesA
//
//  Synopsis:   Enumerate
//
//  Arguments:  [pcPackages] --
//              [info]       --
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
EnumerateSecurityPackagesA(
    unsigned long SEC_FAR *     pcPackages,         // Receives num. packages
    PSecPkgInfoA SEC_FAR *       ppPackageInfo       // Receives array of info
    )
{
    SECURITY_STATUS scRet;

    *ppPackageInfo = NULL;

    scRet = PwdpCopyInfoA(ppPackageInfo);
    if (SUCCEEDED(scRet))
    {
        *pcPackages = 1;
        return(scRet);
    }

    *pcPackages = 0;

    return(scRet);
}

//+---------------------------------------------------------------------------
//
//  Function:   QuerySecurityPackageInfoW
//
//  Synopsis:   Query individual package info
//
//  Arguments:  [pszPackageName] --
//              [info]           --
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
QuerySecurityPackageInfoW(
    SEC_WCHAR SEC_FAR *         pszPackageName,     // Name of package
    PSecPkgInfoW *               ppPackageInfo       // Receives package info
    )
{
    if (_wcsicmp(pszPackageName, PWDSSP_NAME_W))
    {
        return(SEC_E_SECPKG_NOT_FOUND);
    }

    return(PwdpCopyInfoW(ppPackageInfo));
}

//+---------------------------------------------------------------------------
//
//  Function:   QuerySecurityPackageInfoA
//
//  Synopsis:   Same, ansi
//
//  Arguments:  [pszPackageName] --
//              [info]           --
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
QuerySecurityPackageInfoA(
    SEC_CHAR SEC_FAR *         pszPackageName,     // Name of package
    PSecPkgInfoA *               ppPackageInfo       // Receives package info
    )
{
    if (_stricmp(pszPackageName, PWDSSP_NAME_A))
    {
        return(SEC_E_SECPKG_NOT_FOUND);
    }

    return(PwdpCopyInfoA(ppPackageInfo));
}


SECURITY_STATUS
SEC_ENTRY
MakeSignature(PCtxtHandle         phContext,
                DWORD               fQOP,
                PSecBufferDesc      pMessage,
                ULONG               MessageSeqNo)
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}

SECURITY_STATUS SEC_ENTRY
VerifySignature(PCtxtHandle     phContext,
                PSecBufferDesc  pMessage,
                ULONG           MessageSeqNo,
                DWORD *         pfQOP)
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}

SECURITY_STATUS
SEC_ENTRY
SealMessage(PCtxtHandle         phContext,
                DWORD               fQOP,
                PSecBufferDesc      pMessage,
                ULONG               MessageSeqNo)
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}

SECURITY_STATUS SEC_ENTRY
UnsealMessage(PCtxtHandle     phContext,
                PSecBufferDesc  pMessage,
                ULONG           MessageSeqNo,
                DWORD *         pfQOP)
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}


SECURITY_STATUS SEC_ENTRY
ApplyControlToken(
    PCtxtHandle phContext,              // Context to modify
    PSecBufferDesc pInput               // Input token to apply
    )
{
    return( SEC_E_UNSUPPORTED_FUNCTION );
}

SECURITY_STATUS
SEC_ENTRY
FreeContextBuffer(
    PVOID   p)
{
    if( p != NULL )
    {
        PwdFree( p );
    }

    return( SEC_E_OK );
}

SECURITY_STATUS
SEC_ENTRY
QuerySecurityContextToken(
    PCtxtHandle phContext,
    PHANDLE Token)
{
    PPWD_CONTEXT    Context;

    Context = (PPWD_CONTEXT) phContext->dwUpper ;

    if ( Context->Tag == CONTEXT_TAG )
    {
        *Token = Context->Token ;

        return( SEC_E_OK );

    }

    return( SEC_E_INVALID_HANDLE );

}


SECURITY_STATUS SEC_ENTRY
CompleteAuthToken(
    PCtxtHandle phContext,              // Context to complete
    PSecBufferDesc pToken               // Token to complete
    )
{
    return( SEC_E_UNSUPPORTED_FUNCTION );
}


PSecurityFunctionTableA
SEC_ENTRY
InitSecurityInterfaceA( VOID )
{
    return( &PwdTableA );
}

PSecurityFunctionTableW
SEC_ENTRY
InitSecurityInterfaceW( VOID )
{
    return( &PwdTableW );
}


NTSTATUS
VerifyCredentials(
    IN PWSTR UserName,
    IN PWSTR DomainName,
    IN PWSTR Password,
    IN ULONG VerifyFlags
    )
{
    PKERB_VERIFY_CREDENTIALS_REQUEST pVerifyRequest;
    KERB_VERIFY_CREDENTIALS_REQUEST VerifyRequest;

    ULONG cbVerifyRequest;

    PVOID pResponse = NULL;
    ULONG cbResponse;

    USHORT cbUserName;
    USHORT cbDomainName;
    USHORT cbPassword;

    NTSTATUS ProtocolStatus = STATUS_LOGON_FAILURE;
    NTSTATUS Status;

    cbUserName = (USHORT)(lstrlenW(UserName) * sizeof(WCHAR)) ;
    cbDomainName = (USHORT)(lstrlenW(DomainName) * sizeof(WCHAR)) ;
    cbPassword = (USHORT)(lstrlenW(Password) * sizeof(WCHAR)) ;



    cbVerifyRequest = sizeof(VerifyRequest) +
                        cbUserName +
                        cbDomainName +
                        cbPassword ;

    pVerifyRequest = &VerifyRequest;
    ZeroMemory( &VerifyRequest, sizeof(VerifyRequest) );


    pVerifyRequest->MessageType = KerbVerifyCredentialsMessage ;

    //
    // do the length, buffers, copy,  marshall dance.
    //

    pVerifyRequest->UserName.Length = cbUserName;
    pVerifyRequest->UserName.MaximumLength = cbUserName;
    pVerifyRequest->UserName.Buffer = UserName;

    pVerifyRequest->DomainName.Length = cbDomainName;
    pVerifyRequest->DomainName.MaximumLength = cbDomainName;
    pVerifyRequest->DomainName.Buffer = DomainName;

    pVerifyRequest->Password.Length = cbPassword;
    pVerifyRequest->Password.MaximumLength = cbPassword;
    pVerifyRequest->Password.Buffer = Password;

    pVerifyRequest->VerifyFlags = VerifyFlags;

    Status = I_LsaICallPackage(
                &AuthenticationPackage,
                pVerifyRequest,
                cbVerifyRequest,
                &pResponse,
                &cbResponse,
                &ProtocolStatus
                );

    if(!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    Status = ProtocolStatus;

Cleanup:

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\pwdssp\pwdsspp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       pwdsspp.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    9-08-97   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __PWDSSPP_H__
#define __PWDSSPP_H__

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <rpc.h>
#include <lm.h>
#include <dsgetdc.h>
#include <ntdsapi.h>
#include <dnsapi.h>
#include <ntdsa.h>

#define SECURITY_WIN32
#define SECURITY_PACKAGE
#include <security.h>
#include <secint.h>

#include <samrpc.h>
#include <samisrv.h>
#include <lsarpc.h>
#include <lsaisrv.h>
#include <lsaitf.h>

#include <kerberos.h>

#include "pwdssp.h"


BOOL
CacheInitialize(
    VOID
    );

BOOL
PwdCrackName(
    PWSTR DN,
    PWSTR FlatDomain,
    PWSTR FlatUser
    );

#ifdef __cplusplus
}
#endif // __cplusplus
#endif // __PWDSSPP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\inc\cert.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cert.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   Ported over SGC stuff from NT 4 tree.
//              01-05-98   jbanes   Use WinVerifyTrust to validate certs.
//
//----------------------------------------------------------------------------

#define SERIALNUMBER_LENGTH 16


DWORD 
MapOidToKeyExch(LPSTR szOid);

DWORD 
MapOidToCertType(LPSTR szOid);


SP_STATUS
SPLoadCertificate(
    DWORD      fProtocol,
    DWORD      dwCertEncodingType,
    PUCHAR     pCertificate,
    DWORD      cbCertificate,
    PCCERT_CONTEXT *ppCertContext);

SP_STATUS
MapWinTrustError(
    DWORD Status, 
    DWORD DefaultError, 
    DWORD dwIgnoreErrors);

NTSTATUS
VerifyClientCertificate(
    PCCERT_CONTEXT  pCertContext,
    DWORD           dwCertFlags,
    DWORD           dwIgnoreErrors,
    LPCSTR          pszPolicyOID,
    PCCERT_CHAIN_CONTEXT *ppChainContext);   // optional

NTSTATUS
AutoVerifyServerCertificate(
    PSPContext      pContext);

NTSTATUS
VerifyServerCertificate(
    PSPContext  pContext,
    DWORD       dwCertFlags,
    DWORD       dwIgnoreErrors);

SECURITY_STATUS
SPCheckKeyUsage(
    PCCERT_CONTEXT  pCertContext, 
    PSTR            pszUsage,
    BOOL            fOnCertOnly,
    PBOOL           pfIsAllowed);

SP_STATUS  
SPPublicKeyFromCert(
    PCCERT_CONTEXT  pCert, 
    PUBLICKEY **    ppKey,
    ExchSpec *      pdwExchSpec);

SP_STATUS
RsaPublicKeyFromCert(
    PCERT_PUBLIC_KEY_INFO pPublicKeyInfo,
    BLOBHEADER *pBlob,
    PDWORD      pcbBlob);

SP_STATUS
DssPublicKeyFromCert(
    PCERT_PUBLIC_KEY_INFO pPublicKeyInfo,
    BLOBHEADER *pBlob,
    PDWORD      pcbBlob);

SP_STATUS
SPSerializeCertificate(
    DWORD           dwProtocol,         // in
    BOOL            fBuildChain,        // in
    PBYTE *         ppCertChain,        // out
    DWORD *         pcbCertChain,       // out
    PCCERT_CONTEXT  pCertContext,       // in
    DWORD           dwChainingFlags);   // in

SP_STATUS 
ExtractIssuerNamesFromStore(
    HCERTSTORE  hStore,
    PBYTE       pbIssuers,
    DWORD       *pcbIssuers);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\pwdssp\tpwd.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       tpwd.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    9-08-97   RichardW   Created
//
//----------------------------------------------------------------------------

#include <windows.h>
#include <rpc.h>
#include <wchar.h>
#include <stdio.h>
#include <stdlib.h>

#define SECURITY_WIN32
#include <security.h>
#include <pwdssp.h>

VOID
wgets(
    PWSTR s
    )
{
    CHAR Buffer[MAX_PATH ];

    gets(Buffer);
    MultiByteToWideChar(
        CP_ACP, 0,
        Buffer, -1,
        s, MAX_PATH );

}

void __cdecl main (int argc, char *argv[])
{
    SEC_WINNT_AUTH_IDENTITY_W Wide ;
    CredHandle Cred ;
    CtxtHandle Ctxt ;
    WCHAR Name[ MAX_PATH ];
    WCHAR Password[ 64 ];
    WCHAR Domain[ MAX_PATH ];
    SECURITY_STATUS scRet ;
    TimeStamp ts ;
    SecBufferDesc Input ;
    SecBuffer InputBuffer ;
    SecBufferDesc Output ;
    ULONG Flags ;
    CHAR Buffer[ MAX_PATH ];

    scRet = AcquireCredentialsHandleW(
                    NULL,
                    PWDSSP_NAME_W,
                    SECPKG_CRED_INBOUND,
                    NULL, NULL, NULL, NULL,
                    &Cred, &ts );

    if ( scRet != 0 )
    {
        printf("AcquireCredentialsHandleW failed with %x\n", scRet );
        exit(0);
    }


    do
    {
        ZeroMemory(Name, sizeof(Name));
        ZeroMemory(Password, sizeof(Password));
        ZeroMemory(Domain, sizeof(Domain));


        printf("Enter name, or 'quit' to quit>");
        wgets( Name );
        if ( wcscmp( Name, L"quit") == 0 )
        {
            break;
        }

        printf("Enter password>" );
        wgets( Password );

        printf("Enter domain>");
        wgets( Domain );

        //
        // Format "blob"
        //

        ZeroMemory( &Wide, sizeof( Wide ) );

        Wide.User = Name ;
        Wide.UserLength = wcslen( Name );
        if ( Domain[0] )
        {
            Wide.Domain = Domain ;
            Wide.DomainLength = wcslen( Domain );
        }
        else
        {
            Wide.Domain = NULL ;
            Wide.DomainLength = 0 ;
        }
        Wide.Password = Password ;
        Wide.PasswordLength = wcslen( Password );
        Wide.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE ;

        InputBuffer.BufferType = SECBUFFER_TOKEN ;
        InputBuffer.pvBuffer = &Wide ;
        InputBuffer.cbBuffer = sizeof( Wide );

        Input.pBuffers = &InputBuffer;
        Input.cBuffers = 1;
        Input.ulVersion = 0;

        scRet = AcceptSecurityContext(
                    &Cred,
                    NULL,
                    &Input,
                    0,
                    SECURITY_NATIVE_DREP,
                    &Ctxt,
                    &Output,
                    &Flags,
                    &ts );

        if ( scRet != 0 )
        {
            printf(" FAILED, %x\n", scRet );
        }
        else
        {
            printf(" SUCCESS\n" );
            DeleteSecurityContext( &Ctxt );
        }



    } while ( 1 );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\inc\ber.h ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology 
* reference implementation, version 1.0
* 
* The Private Communication Technology reference implementation, version 1.0 
* ("PCTRef"), is being provided by Microsoft to encourage the development and 
* enhancement of an open standard for secure general-purpose business and 
* personal communications on open networks.  Microsoft is distributing PCTRef 
* at no charge irrespective of whether you use PCTRef for non-commercial or 
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without 
* warranty of any kind, either express or implied, including, without 
* limitation, the implied warranties or merchantability, fitness for a 
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out 
* of use or performance of PCTRef remains with you.
* 
* Please see the file LICENSE.txt, 
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
* 
* Please see http://pct.microsoft.com/pct/pct.htm for The Private 
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/ 

#ifndef __BER_H__
#define __BER_H__


#define BER_UNIVERSAL           0x00
#define BER_APPLICATION         0x40
#define BER_CONTEXT_SPECIFIC    0x80
#define BER_PRIVATE             0xC0

#define BER_PRIMITIVE           0x00
#define BER_CONSTRUCTED         0x20

#define BER_BOOL                1
#define BER_INTEGER             2
#define BER_BIT_STRING          3
#define BER_OCTET_STRING        4
#define BER_NULL                5
#define BER_OBJECT_ID           6
#define BER_OBJECT_DESC         7
#define BER_EXTERNAL            8
#define BER_REAL                9
#define BER_ENUMERATED          10

#define BER_SEQUENCE            (16 | BER_CONSTRUCTED)
#define BER_SET                 (17 | BER_CONSTRUCTED)

#define BER_NUMERIC_STRING      0x12
#define BER_PRINTABLE_STRING    0x13
#define BER_TELETEX_STRING      0x14
#define BER_VIDEOTEX_STRING     0x15
#define BER_IA5STRING           0x16
#define BER_GRAPHIC_STRING      0x19

#define BER_UTC_TIME            23

typedef int (* OutputFn)(char *, ...);
typedef BOOL (* StopFn)(void);

int
ber_decode(
    OutputFn Out,
    StopFn  Stop,
    LPBYTE  pBuffer,
    int   Indent,
    int   Offset,
    int   TotalLength,
    int   BarDepth);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\inc\cache.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cache.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   Ported over SGC stuff from NT 4 tree.
//
//----------------------------------------------------------------------------

#include <sslcache.h>

#define SP_CACHE_MAGIC     0xCACE

#define SP_CACHE_FLAG_EMPTY                         0x00000001
#define SP_CACHE_FLAG_READONLY                      0x00000002
#define SP_CACHE_FLAG_MASTER_EPHEM                  0x00000004
#define SP_CACHE_FLAG_USE_VALIDATED                 0x00000010  // Whether user has validated client credential.

struct _SPContext;

typedef struct _SessCacheItem {

    DWORD               Magic;
    DWORD               dwFlags;

    LONG                cRef; 

    DWORD               ZombieJuju;
    DWORD               fProtocol;
    DWORD               CreationTime;
    DWORD               Lifespan;
    DWORD               DeferredJuju;

    // List of cache entries assigned to a particular cache index.
    LIST_ENTRY          IndexEntryList;

    // Global list of cache entries sorted by creation time.
    LIST_ENTRY          EntryList;

    // Process ID of process that owns this cache entry.
    ULONG               ProcessID;


    HMAPPER *           phMapper;

    // Handle to "Schannel" key container used to store the server's master 
    // secret. This will either be the one corresponding to the server's
    // credentials or the 512-bit ephemeral key.
    HCRYPTPROV          hMasterProv;

    // Whether 'hMasterProv' is an actual CSP or a static library.
    DWORD               dwCapiFlags;
    
    // Master secret, from which all session keys are derived.
    HCRYPTKEY           hMasterKey;

    ALG_ID              aiCipher;
    DWORD               dwStrength;
    ALG_ID              aiHash;
    DWORD               dwCipherSuiteIndex;     // used for managing reconnects

    ExchSpec            SessExchSpec;
    DWORD               dwExchStrength;

    PCERT_CONTEXT       pRemoteCert;
    PUBLICKEY *         pRemotePublic;

    struct _SessCacheItem *pClonedItem;


    // Server Side Client Auth related items
    /* HLOCATOR */ 
    HLOCATOR            hLocator;
    SECURITY_STATUS     LocatorStatus;

    // Local credentials.
    PSPCredentialGroup  pServerCred; 
    PSPCredential       pActiveServerCred;
    CRED_THUMBPRINT     CredThumbprint;         // credential group
    CRED_THUMBPRINT     CertThumbprint;         // local certificate

    // Cipher level (domestic, export, sgc, etc);
    DWORD               dwCF;

    // Server certificate (pct only)
    DWORD               cbServerCertificate;
    PBYTE               pbServerCertificate;

    // cache ID (usually machine name or ip address)
    LPWSTR              szCacheID;
    LUID                LogonId; 

    // Session ID for this session
    DWORD               cbSessionID;    
    UCHAR               SessionID[SP_MAX_SESSION_ID];

    // Clear key (pct only)
    DWORD               cbClearKey;
    UCHAR               pClearKey[SP_MAX_MASTER_KEY];

    DWORD               cbKeyArgs;
    UCHAR               pKeyArgs[SP_MAX_KEY_ARGS];

    // This contains the client certificate that was sent to the server.
    PCCERT_CONTEXT      pClientCert;

    // When a client credential is created automatically, the credential
    // information is stored here.
    PSPCredential       pClientCred;

    DWORD               cbAppData;
    PBYTE               pbAppData;

} SessCacheItem, *PSessCacheItem;


typedef struct
{
    PLIST_ENTRY     SessionCache;

    DWORD           dwClientLifespan;
    DWORD           dwServerLifespan;
    DWORD           dwCleanupInterval;
    DWORD           dwCacheSize;
    DWORD           dwMaximumEntries;
    DWORD           dwUsedEntries;

    LIST_ENTRY      EntryList;
    RTL_RESOURCE    Lock;
    BOOL            LockInitialized;

} SCHANNEL_CACHE;

extern SCHANNEL_CACHE SchannelCache;

#define SP_CACHE_CLIENT_LIFESPAN    (10 * 3600 * 1000)  // 10 hours
#define SP_CACHE_SERVER_LIFESPAN    (10 * 3600 * 1000)  // 10 hours
#define SP_CACHE_CLEANUP_INTERVAL   (5 * 60 * 1000)     // 5 minutes
#define SP_MAXIMUM_CACHE_ELEMENTS   10000
#define SP_MASTER_KEY_CS_COUNT      50

extern BOOL g_fMultipleProcessClientCache;
extern BOOL g_fCacheInitialized;

// Perf counter values.
extern DWORD g_cClientHandshakes;
extern DWORD g_cServerHandshakes;
extern DWORD g_cClientReconnects;
extern DWORD g_cServerReconnects;


#define HasTimeElapsed(StartTime, CurrentTime, Interval)                \
            (((CurrentTime) > (StartTime) &&                            \
              (CurrentTime) - (StartTime) > (Interval)) ||              \
             ((CurrentTime) < (StartTime) &&                            \
              (CurrentTime) + (MAXULONG - (StartTime)) >= (Interval)))


/* SPInitSessionCache() */
/*  inits the internal cache to CacheSize items */
SP_STATUS SPInitSessionCache(VOID);

SP_STATUS
SPShutdownSessionCache(VOID);

// Reference and dereference cache items
LONG SPCacheReference(PSessCacheItem pItem);

LONG SPCacheDereference(PSessCacheItem pItem);

void
SPCachePurgeCredential(
    PSPCredentialGroup pCred);

void 
SPCachePurgeProcessId(
    ULONG ProcessId);

NTSTATUS
SPCachePurgeEntries(
    LUID *LoginId,
    ULONG ProcessID,
    LPWSTR pwszTargetName,
    DWORD Flags);

NTSTATUS
SPCacheGetInfo(
    LUID *  LogonId,
    LPWSTR  pszTargetName,
    DWORD   dwFlags,
    PSSL_SESSION_CACHE_INFO_RESPONSE pCacheInfo);

NTSTATUS
SPCacheGetPerfmonInfo(
    DWORD   dwFlags,
    PSSL_PERFMON_INFO_RESPONSE pPerfmonInfo);

/* Retrieve item from cache by SessionID.  
 * Auto-Reference the item if successful */
BOOL SPCacheRetrieveBySession(
    struct _SPContext * pContext, 
    PBYTE pbSessionID, 
    DWORD cbSessionID, 
    PSessCacheItem *ppRetItem);

/* Retrieve item from cache by ID.  
 * Auto-Reference the item if successful */
BOOL 
SPCacheRetrieveByName(
    LPWSTR pwszName,
    PSPCredentialGroup pCredGroup,
    PSessCacheItem *ppRetItem);

/* find an empty cache item for use by a context */
BOOL
SPCacheRetrieveNew(
    BOOL                fServer,
    LPWSTR              pszTargetName,
    PSessCacheItem *   ppRetItem);

/* Locks a recently retrieved item into the cache */
BOOL 
SPCacheAdd(
    struct _SPContext * pContext);


/* Helper for REDO sessions */
BOOL
SPCacheClone(PSessCacheItem *ppRetItem);

NTSTATUS
SetCacheAppData(
    PSessCacheItem pItem,
    PBYTE pbAppData,
    DWORD cbAppData);

NTSTATUS
GetCacheAppData(
    PSessCacheItem pItem,
    PBYTE *ppbAppData,
    DWORD *pcbAppData);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\inc\callback.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       callback.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   Created
//
//----------------------------------------------------------------------------
#define SECURITY_PACKAGE
#include <secint.h>

#define SCH_FLAG_READ_KEY       1
#define SCH_FLAG_WRITE_KEY      2

// Application process callbacks
#define SCH_SIGNATURE_CALLBACK              1
#define SCH_UPLOAD_CREDENTIAL_CALLBACK      2
#define SCH_UPLOAD_CERT_STORE_CALLBACK      3
#define SCH_ACQUIRE_CONTEXT_CALLBACK        4
#define SCH_RELEASE_CONTEXT_CALLBACK        5
#define SCH_DOWNLOAD_CERT_CALLBACK          6
#define SCH_GET_USER_KEYS                   7

#define SCH_REFERENCE_MAPPER_CALLBACK       20
#define SCH_GET_MAPPER_ISSUER_LIST_CALLBACK 21
#define SCH_MAP_CREDENTIAL_CALLBACK         23
#define SCH_CLOSE_LOCATOR_CALLBACK          25 
#define SCH_GET_MAPPER_ATTRIBUTES_CALLBACK  26


typedef struct _SCH_CALLBACK_LIST
{
    DWORD                   dwTag;
    PLSA_CALLBACK_FUNCTION  pFunction;
} SCH_CALLBACK_LIST;

extern SCH_CALLBACK_LIST g_SchannelCallbacks[];
extern DWORD g_cSchannelCallbacks;

SECURITY_STATUS
PerformApplicationCallback(
    DWORD dwCallback,
    ULONG_PTR dwArg1,
    ULONG_PTR dwArg2,
    SecBuffer *pInput,
    SecBuffer *pOutput,
    BOOL fExpectOutput);

BOOL
DuplicateApplicationHandle(
    HANDLE   hAppHandle,
    LPHANDLE phLsaHandle);

SECURITY_STATUS
SerializeCertContext(
    PCCERT_CONTEXT pCertContext,
    PBYTE          pbBuffer,
    PDWORD         pcbBuffer);

SECURITY_STATUS
DeserializeCertContext(
    PCCERT_CONTEXT *ppCertContext,
    PBYTE           pbBuffer,
    DWORD           cbBuffer);

NTSTATUS
RemoteCryptAcquireContextW(
    HCRYPTPROV *phProv,
    LPCWSTR     pwszContainer,
    LPCWSTR     pwszProvider,
    DWORD       dwProvType,
    DWORD       dwFlags,
    DWORD       dwCapiFlags);

BOOL
RemoteCryptReleaseContext(
    HCRYPTPROV  hProv,
    DWORD       dwFlags,
    DWORD       dwCapiFlags);

SP_STATUS
SignHashUsingCallback(
    HCRYPTPROV  hProv,
    DWORD       dwKeySpec,
    ALG_ID      aiHash,
    PBYTE       pbHash,
    DWORD       cbHash,
    PBYTE       pbSignature,
    PDWORD      pcbSignature,
    DWORD       fHashData);

SP_STATUS
SPGetUserKeys(
    PSPContext  pContext,
    DWORD       dwFlags);

SECURITY_STATUS
GetClientAuthCertsCallback(
    ULONG_PTR Argument1,
    ULONG_PTR Argument2,
    SecBuffer *pInput,
    SecBuffer *pOutput);

SECURITY_STATUS
ReferenceMapperCallback(
    ULONG_PTR fReference,
    ULONG_PTR dwArg2,
    SecBuffer *pInput,
    SecBuffer *pOutput);

SECURITY_STATUS
GetMapperIssuerListCallback(
    ULONG_PTR pOutputBuffer,
    ULONG_PTR cbOutputBuffer,
    SecBuffer *pInput,
    SecBuffer *pOutput);

SECURITY_STATUS
MapCredentialCallback(
    ULONG_PTR dwCredentialType,
    ULONG_PTR dwArg2,
    SecBuffer *pInput,
    SecBuffer *pOutput);

SECURITY_STATUS
GetAccessTokenCallback(
    ULONG_PTR hLocator,
    ULONG_PTR dwArg2,
    SecBuffer *pInput,
    SecBuffer *pOutput);

SECURITY_STATUS
CloseLocatorCallback(
    ULONG_PTR hLocator,
    ULONG_PTR dwArg2,
    SecBuffer *pInput,
    SecBuffer *pOutput);

VOID *
PvExtVirtualAlloc(DWORD cb);

SECURITY_STATUS
FreeExtVirtualAlloc(PVOID pv, SIZE_T cbMem);

SECURITY_STATUS
SPFreeUserAllocMemory(PVOID pv, SIZE_T cbMem);

SECURITY_STATUS
QueryMappedCredAttributesCallback(
    ULONG_PTR hLocator,
    ULONG_PTR dwAttribute,
    SecBuffer *pInput,
    SecBuffer *pOutput);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\inc\capi.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       capi.h
//
//  Contents:   
//
//  Classes:
//
//  Functions:
//
//  History:    11-04-97   jbanes   Created.
//
//----------------------------------------------------------------------------

#define SCH_CAPI_USE_CSP        0
#define SCH_CAPI_STATIC_RSA     1
#define SCH_CAPI_STATIC_DH      2

BOOL
WINAPI
SchCryptAcquireContextA(
    HCRYPTPROV *phProv,
    LPCSTR pszContainer,
    LPCSTR pszProvider,
    DWORD dwProvType,
    DWORD dwFlags,
    DWORD dwSchFlags);

BOOL
WINAPI
SchCryptAcquireContextW(
    HCRYPTPROV *phProv,
    LPCWSTR pszContainer,
    LPCWSTR pszProvider,
    DWORD dwProvType,
    DWORD dwFlags,
    DWORD dwSchFlags);

BOOL
WINAPI
SchCryptCreateHash(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    HCRYPTKEY hKey,
    DWORD dwFlags,
    HCRYPTHASH *phHash,
    DWORD dwSchFlags);

BOOL
WINAPI
SchCryptDecrypt(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwSchFlags);

BOOL
WINAPI
SchCryptDeriveKey(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    HCRYPTHASH hBaseData,
    DWORD dwFlags,
    HCRYPTKEY *phKey,
    DWORD dwSchFlags);

BOOL
WINAPI
SchCryptDestroyHash(
    HCRYPTHASH hHash,
    DWORD dwSchFlags);

BOOL
WINAPI
SchCryptDestroyKey(
    HCRYPTKEY hKey,
    DWORD dwSchFlags);

BOOL
WINAPI 
SchCryptDuplicateHash(
    HCRYPTHASH hHash,
    DWORD *pdwReserved,
    DWORD dwFlags,
    HCRYPTHASH * phHash,
    DWORD dwSchFlags);

BOOL
WINAPI 
SchCryptDuplicateKey(
    HCRYPTKEY hKey,
    DWORD *pdwReserved,
    DWORD dwFlags,
    HCRYPTKEY * phKey,
    DWORD dwSchFlags);

BOOL
WINAPI
SchCryptEncrypt(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwBufLen,
    DWORD dwSchFlags);

BOOL
WINAPI
SchCryptExportKey(
    HCRYPTKEY hKey,
    HCRYPTKEY hExpKey,
    DWORD dwBlobType,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwSchFlags);

BOOL
WINAPI
SchCryptGenKey(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    DWORD dwFlags,
    HCRYPTKEY *phKey,
    DWORD dwSchFlags);

BOOL
WINAPI
SchCryptGenRandom(
    HCRYPTPROV hProv,
    DWORD dwLen,
    BYTE *pbBuffer,
    DWORD dwSchFlags);

BOOL
WINAPI
SchCryptGetHashParam(
    HCRYPTHASH hHash,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags,
    DWORD dwSchFlags);

BOOL
WINAPI
SchCryptGetKeyParam(
    HCRYPTKEY hKey,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags,
    DWORD dwSchFlags);

BOOL
WINAPI
SchCryptGetProvParam(
    HCRYPTPROV hProv,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags,
    DWORD dwSchFlags);

BOOL
WINAPI
SchCryptGetUserKey(
    HCRYPTPROV hProv,
    DWORD dwKeySpec,
    HCRYPTKEY *phUserKey,
    DWORD dwSchFlags);

BOOL
WINAPI
SchCryptHashData(
    HCRYPTHASH hHash,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    DWORD dwFlags,
    DWORD dwSchFlags);

BOOL
WINAPI
SchCryptHashSessionKey(
    HCRYPTHASH hHash,
    HCRYPTKEY hKey,
    DWORD dwFlags,
    DWORD dwSchFlags);

BOOL
WINAPI
SchCryptImportKey(
    HCRYPTPROV hProv,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    HCRYPTKEY hPubKey,
    DWORD dwFlags,
    HCRYPTKEY *phKey,
    DWORD dwSchFlags);

BOOL
WINAPI
SchCryptReleaseContext(
    HCRYPTPROV hProv,
    DWORD dwFlags,
    DWORD dwSchFlags);

BOOL
WINAPI
SchCryptSetHashParam(
    HCRYPTHASH hHash,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags,
    DWORD dwSchFlags);

BOOL
WINAPI
SchCryptSetKeyParam(
    HCRYPTKEY hKey,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags,
    DWORD dwSchFlags);

BOOL
WINAPI
SchCryptSetProvParam(
    HCRYPTPROV hProv,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags,
    DWORD dwSchFlags);

BOOL
WINAPI
SchCryptSignHash(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCSTR sDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen,
    DWORD dwSchFlags);

BOOL
WINAPI
SchCryptVerifySignature(
    HCRYPTHASH hHash,
    CONST BYTE *pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCSTR sDescription,
    DWORD dwFlags,
    DWORD dwSchFlags);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\inc\cert509.h ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology 
* reference implementation, version 1.0
* 
* The Private Communication Technology reference implementation, version 1.0 
* ("PCTRef"), is being provided by Microsoft to encourage the development and 
* enhancement of an open standard for secure general-purpose business and 
* personal communications on open networks.  Microsoft is distributing PCTRef 
* at no charge irrespective of whether you use PCTRef for non-commercial or 
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without 
* warranty of any kind, either express or implied, including, without 
* limitation, the implied warranties or merchantability, fitness for a 
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out 
* of use or performance of PCTRef remains with you.
* 
* Please see the file LICENSE.txt, 
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
* 
* Please see http://pct.microsoft.com/pct/pct.htm for The Private 
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/ 



#define SERIALNUMBER_LENGTH 16

#define CF_VERIFY_SIG           1
#define CF_CERT_FROM_FILE       2

#define CERT_HEADER_LEN         17


BOOL
CrackCertificate(
    PBYTE               pbCertificate,
    DWORD               cbCertificate,
    PX509Certificate *  ppCertificate);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\inc\context.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       context.h
//
//  Contents:   Schannel context declarations.
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   Ported over SGC stuff from NT 4 tree.
//
//----------------------------------------------------------------------------

#include <sha.h>
#include <md5.h>
#include <ssl3.h>

#define SP_CONTEXT_MAGIC   *(DWORD *)"!Tcp"

typedef struct _SPContext 
{
    DWORD               Magic;          /* tags structure */

    DWORD               State;          /* the current state the connection is in */

    DWORD               Flags;

    /* data for the context that can be used
     * to start a new session */
    PSessCacheItem      RipeZombie;   /* cacheable context that is being used  */
    PSPCredentialGroup  pCredGroup;
    PSPCredential       pActiveClientCred;
    LPWSTR              pszTarget;
    LPWSTR              pszCredentialName;

    DWORD               dwProtocol;
    DWORD               dwClientEnabledProtocols;

    CRED_THUMBPRINT     ContextThumbprint;

    //  Pointers to cipher info used
    // during transmission of bulk data.

    PCipherInfo         pCipherInfo;
    PCipherInfo         pReadCipherInfo;
    PCipherInfo         pWriteCipherInfo;
    PHashInfo           pHashInfo;
    PHashInfo           pReadHashInfo;
    PHashInfo           pWriteHashInfo;
    PKeyExchangeInfo    pKeyExchInfo;
 
    /* functions pointing to the various handlers for this protocol */
    SPDecryptMessageFn  Decrypt;
    SPEncryptMessageFn  Encrypt;
    SPProtocolHandlerFn ProtocolHandler;
    SPDecryptHandlerFn  DecryptHandler;
    SPInitiateHelloFn   InitiateHello;
    SPGetHeaderSizeFn   GetHeaderSize;

    /* session crypto state */

    // encryption key size.
    DWORD               KeySize;

    // Encryption states
    HCRYPTPROV          hReadProv;
    HCRYPTPROV          hWriteProv;
    HCRYPTKEY           hReadKey;
    HCRYPTKEY           hWriteKey;
    HCRYPTKEY           hPendingReadKey;
    HCRYPTKEY           hPendingWriteKey;

    HCRYPTKEY           hReadMAC;
    HCRYPTKEY           hWriteMAC;
    HCRYPTKEY           hPendingReadMAC;
    HCRYPTKEY           hPendingWriteMAC;

    // Packet Sequence counters.
    DWORD               ReadCounter;
    DWORD               WriteCounter;


    DWORD               cbConnectionID;
    UCHAR               pConnectionID[SP_MAX_CONNECTION_ID]; 
    
    DWORD               cbChallenge;
    UCHAR               pChallenge[SP_MAX_CHALLENGE];


    // Save copy of client hello to hash for verification.
    DWORD               cbClientHello;
    PUCHAR              pClientHello;
    DWORD               dwClientHelloProtocol;


    // Pending cipher info, used to generate keys
    PCipherInfo         pPendingCipherInfo;
    PHashInfo           pPendingHashInfo;
        

    // SSL3 specific items.
    
    UCHAR               bAlertLevel;        // Used for SSL3 & TLS1 alert messages
    UCHAR               bAlertNumber;

    BOOL                fAppProcess;
    BOOL                fExchKey; // Did we sent a Exchnage key message
    BOOL                fCertReq; //Did we request a certificatefor server and Should I need to send a cert for client
    BOOL                fInsufficientCred; //This will be TRUE when the pCred inside
                                            //pContext doesn't match the CR list. from the server.

    HCRYPTHASH          hMd5Handshake;
    HCRYPTHASH          hShaHandshake;

    PUCHAR              pbIssuerList;
    DWORD               cbIssuerList;


    PUCHAR              pbEncryptedKey;
    DWORD               cbEncryptedKey;

    PUCHAR              pbServerKeyExchange;        
    DWORD               cbServerKeyExchange;
    
    WORD                wS3CipherSuiteClient;
    WORD                wS3CipherSuiteServer;
    DWORD               dwPendingCipherSuiteIndex;

    UCHAR               rgbS3CRandom[CB_SSL3_RANDOM];
    UCHAR               rgbS3SRandom[CB_SSL3_RANDOM];

    DWORD               cSsl3ClientCertTypes;
    DWORD               Ssl3ClientCertTypes[SSL3_MAX_CLIENT_CERTS];

    // Server Gated Crypto
    DWORD           dwRequestedCF;

    // Allow cert chains for PCT1
    BOOL            fCertChainsAllowed; 

} SPContext, * PSPContext;


typedef struct _SPPackedContext 
{
    DWORD               Magic;
    DWORD               State;
    DWORD               Flags;
    DWORD               dwProtocol;

    CRED_THUMBPRINT     ContextThumbprint;

    DWORD               dwCipherInfo;
    DWORD               dwHashInfo;
    DWORD               dwKeyExchInfo;

    DWORD               dwExchStrength;

    DWORD               ReadCounter;
    DWORD               WriteCounter;

    ULARGE_INTEGER      hMasterProv;
    ULARGE_INTEGER      hReadKey;
    ULARGE_INTEGER      hWriteKey;
    ULARGE_INTEGER      hReadMAC;
    ULARGE_INTEGER      hWriteMAC;

    ULARGE_INTEGER      hLocator;
    DWORD               LocatorStatus;

    DWORD               cbSessionID;    
    UCHAR               SessionID[SP_MAX_SESSION_ID];

} SPPackedContext, *PSPPackedContext;


/* Flags */
#define CONTEXT_FLAG_CLIENT                 0x00000001
#define CONTEXT_FLAG_USE_SUPPLIED_CREDS     0x00000080  // Don't search for default credential.
#define CONTEXT_FLAG_MUTUAL_AUTH            0x00000100
#define CONTEXT_FLAG_EXT_ERR                0x00000200  /* Generate error message on error */
#define CONTEXT_FLAG_NO_INCOMPLETE_CRED_MSG 0x00000400  /* don't generate an INCOMPLETE CREDS message */
#define CONTEXT_FLAG_CONNECTION_MODE        0x00001000  /* as opposed to stream mode */
#define CONTEXT_FLAG_NOCACHE                0x00002000  /* do not look things up in the cache */
#define CONTEXT_FLAG_MANUAL_CRED_VALIDATION 0x00004000  // Don't validate server cert.
#define CONTEXT_FLAG_FULL_HANDSHAKE         0x00008000
#define CONTEXT_FLAG_MAPPED                 0x40000000
#define CONTEXT_FLAG_SERIALIZED             0x80000000


#ifdef DBG
PSTR DbgGetNameOfCrypto(DWORD x);
#endif

PSPContext SPContextCreate(LPWSTR pszTarget);

BOOL
SPContextClean(PSPContext pContext);

BOOL SPContextDelete(PSPContext pContext);

SP_STATUS 
SPContextSetCredentials(
    PSPContext          pContext, 
    PSPCredentialGroup  pCred);

SP_STATUS
ContextInitCiphersFromCache(
    SPContext *pContext);

SP_STATUS
ContextInitCiphers(
    SPContext *pContext,
    BOOL fRead,
    BOOL fWrite);

SP_STATUS 
SPContextDoMapping(
    PSPContext pContext);

SP_STATUS
RemoveDuplicateIssuers(
    PBYTE  pbIssuers,
    PDWORD pcbIssuers);

SP_STATUS
SPContextGetIssuers(
    PSPCredentialGroup pCredGroup);

BOOL FGetServerIssuer(
    PBYTE pbIssuer, 
    DWORD *pdwIssuer);

SP_STATUS
SPPickClientCertificate(
    PSPContext  pContext,
    DWORD       dwExchSpec);

SP_STATUS
SPPickServerCertificate(
    PSPContext  pContext,
    DWORD       dwExchSpec);

SP_STATUS DetermineClientCSP(PSPContext pContext);

typedef BOOL
(WINAPI * SERIALIZE_LOCATOR_FN)(
    HLOCATOR    Locator,
    HLOCATOR *  NewLocator);

SP_STATUS
SPContextSerialize(
    PSPContext  pContext,
    SERIALIZE_LOCATOR_FN LocatorMove,
    PBYTE *     ppBuffer,
    PDWORD      pcbBuffer,
    BOOL        fDestroyKeys);

SP_STATUS
SPContextDeserialize(
    PBYTE pbBuffer,
    PSPContext *ppContext);

BOOL
LsaContextDelete(PSPContext pContext);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\inc\crypttls.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       crypttls.h
//
//  Contents:   Crypt Thread Local Storage (TLS) and Asn1 Module
//              installation and allocation functions
//
//  APIs:
//              I_CryptAllocTls
//              I_CryptFreeTls
//              I_CryptGetTls
//              I_CryptSetTls
//              I_CryptDetachTls
//
//              I_CryptInstallAsn1Module
//              I_CryptUninstallAsn1Module
//              I_CryptGetAsn1Encoder
//              I_CryptGetAsn1Decoder
//
//
//  History:    17-Nov-96    philh   created
//--------------------------------------------------------------------------

#ifndef __CRYPTTLS_H__
#define __CRYPTTLS_H__

#include "msasn1.h"
#include <wincrypt.h>

#ifdef __cplusplus
extern "C" {
#endif


// Handle to an allocated Crypt TLS entry
typedef DWORD HCRYPTTLS;

// Handle to an installed Asn1 module
typedef DWORD HCRYPTASN1MODULE;

//+-------------------------------------------------------------------------
//  Install a thread local storage entry and return a handle for future access.
//--------------------------------------------------------------------------
HCRYPTTLS
WINAPI
I_CryptAllocTls();

//+-------------------------------------------------------------------------
//  Called at DLL_PROCESS_DETACH to free a thread local storage entry.
//  Optionally, calls the callback for each thread having a non-NULL pvTls.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptFreeTls(
    IN HCRYPTTLS hCryptTls,
    IN OPTIONAL PFN_CRYPT_FREE pfnFree
    );

//+-------------------------------------------------------------------------
//  Get the thread specific pointer specified by the
//  hCryptTls returned by I_CryptAllocTls().
//
//  Returns NULL for an error or uninitialized pointer.
//--------------------------------------------------------------------------
void *
WINAPI
I_CryptGetTls(
    IN HCRYPTTLS hCryptTls
    );

//+-------------------------------------------------------------------------
//  Set the thread specific pointer specified by the
//  hCryptTls returned by I_CryptAllocTls().
//
//  Returns FALSE for an invalid handle or unable to allocate memory.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptSetTls(
    IN HCRYPTTLS hCryptTls,
    IN void *pvTls
    );

//+-------------------------------------------------------------------------
//  Called at DLL_THREAD_DETACH to free the thread's
//  TLS entry specified by the hCryptTls. Returns the thread specific pointer
//  to be freed by the caller.
//
//  Note, at DLL_PROCESS_DETACH, I_CryptFreeTls should be called instead.
//--------------------------------------------------------------------------
void *
WINAPI
I_CryptDetachTls(
    IN HCRYPTTLS hCryptTls
    );

//+-------------------------------------------------------------------------
//  Install an Asn1 module entry and return a handle for future access.
//
//  Each thread has its own copy of the decoder and encoder associated
//  with the Asn1 module. Creation is deferred until first referenced by
//  the thread.
//
//  I_CryptGetAsn1Encoder or I_CryptGetAsn1Decoder must be called with the
//  handle returned by I_CryptInstallAsn1Module to get the thread specific
//  Asn1 encoder or decoder.
//
//  Currently, dwFlags and pvReserved aren't used and must be set to 0.
//--------------------------------------------------------------------------
HCRYPTASN1MODULE
WINAPI
I_CryptInstallAsn1Module(
    IN ASN1module_t pMod,
    IN DWORD dwFlags,
    IN void *pvReserved
    );

//+-------------------------------------------------------------------------
//  Called at DLL_PROCESS_DETACH to uninstall an hAsn1Module entry. Iterates
//  through the threads and frees their created Asn1 encoders and decoders.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptUninstallAsn1Module(
    IN HCRYPTASN1MODULE hAsn1Module
    );

//+-------------------------------------------------------------------------
//  Get the thread specific pointer to the Asn1 encoder specified by the
//  hAsn1Module returned by CryptInstallAsn1Module. If the
//  encoder doesn't exist, then, its created using the Asn1 module
//  associated with hAsn1Module.
//--------------------------------------------------------------------------
ASN1encoding_t
WINAPI
I_CryptGetAsn1Encoder(
    IN HCRYPTASN1MODULE hAsn1Module
    );

//+-------------------------------------------------------------------------
//  Get the thread specific pointer to the Asn1 decoder specified by the
//  hAsn1Module returned by CryptInstallAsn1Module. If the
//  decoder doesn't exist, then, its created using the Asn1 module
//  associated with hAsn1Module.
//--------------------------------------------------------------------------
ASN1decoding_t
WINAPI
I_CryptGetAsn1Decoder(
    IN HCRYPTASN1MODULE hAsn1Module
    );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\inc\cred.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cred.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   LSA integration stuff.
//
//----------------------------------------------------------------------------

#ifndef __CRED_H__
#define __CRED_H__

#define PCT_CRED_MAGIC  *(DWORD *)"CtcP"

typedef struct _CRED_THUMBPRINT
{
    DWORD LowPart;
    DWORD HighPart;
} CRED_THUMBPRINT, *PCRED_THUMBPRINT;

typedef struct _SPCredential
{
    PCCERT_CONTEXT      pCert;
    CRED_THUMBPRINT     CertThumbprint;

    HCRYPTPROV          hProv;
    HCRYPTPROV          hEphem512Prov;
    HCRYPTPROV          hEphem1024Prov;
    HCRYPTPROV          hRemoteProv;

    PROV_ENUMALGS_EX *  pCapiAlgs;      // Algs supported by hProv (server only)
    DWORD               cCapiAlgs;
    DWORD               dwCapiFlags;    // Whether hProv is static or csp
    DWORD               fAppRemoteProv; // Does application own hRemoteProv?

    DWORD           dwCF;               // Is this a server SGC cert?

    DWORD           dwKeySpec;
    ExchSpec        dwExchSpec;

    PPUBLICKEY      pPublicKey;

    PBYTE           pbSsl3SerializedChain;
    DWORD           cbSsl3SerializedChain;

    HCRYPTKEY       hTek;               // Ephemeral DH
} SPCredential, *PSPCredential;
          

typedef struct _SPCredentialGroup {
    DWORD               Magic;
    DWORD               grbitProtocol;
    DWORD               grbitEnabledProtocols;
    DWORD               dwFlags;
    RTL_CRITICAL_SECTION csLock;
    DWORD               dwMinStrength;
    DWORD               dwMaxStrength;
    DWORD               cSupportedAlgs;
    ALG_ID *            palgSupportedAlgs;
    DWORD               dwSessionLifespan;
    ULONG               ProcessId; 

    // server-side only
    LONG                cMappers;
    HMAPPER **          pahMappers;
    HCERTSTORE          hApplicationRoots;  // Specified by application.
    HCERTSTORE          hUserRoots;         // Current user ROOT - monitored for changes
    PBYTE               pbTrustedIssuers;
    DWORD               cbTrustedIssuers;

    CRED_THUMBPRINT     CredThumbprint;     // Used when purging server cache entries.
    LONG                RefCount;
    LIST_ENTRY          ListEntry;
    PSPCredential       pCredList;
    DWORD               cCredList;
} SPCredentialGroup, * PSPCredentialGroup;


typedef struct _LSA_SCHANNEL_SUB_CRED
{
    PCCERT_CONTEXT      pCert;
    LPWSTR              pszPin;
    HCRYPTPROV          hRemoteProv;
    PVOID               pPrivateKey;
    DWORD               cbPrivateKey;
    LPSTR               pszPassword;
} LSA_SCHANNEL_SUB_CRED, *PLSA_SCHANNEL_SUB_CRED;

typedef struct _LSA_SCHANNEL_CRED
{
    DWORD           dwVersion;
    DWORD           cSubCreds;
    PLSA_SCHANNEL_SUB_CRED paSubCred;
    HCERTSTORE      hRootStore;

    DWORD           cMappers;
    struct _HMAPPER **aphMappers;

    DWORD           cSupportedAlgs;
    ALG_ID *        palgSupportedAlgs;

    DWORD           grbitEnabledProtocols;
    DWORD           dwMinimumCipherStrength;
    DWORD           dwMaximumCipherStrength;
    DWORD           dwSessionLifespan;
    DWORD           dwFlags;
    DWORD           reserved;
} LSA_SCHANNEL_CRED, *PLSA_SCHANNEL_CRED;


#define LockCredential(p)   RtlEnterCriticalSection(&(p)->csLock)
#define UnlockCredential(p) RtlLeaveCriticalSection(&(p)->csLock)

BOOL
SslInitCredentialManager(VOID);

BOOL
SslFreeCredentialManager(VOID);

BOOL
SslCheckForGPEvent(void);

BOOL
IsValidThumbprint(
    PCRED_THUMBPRINT Thumbprint);

BOOL
IsSameThumbprint(
    PCRED_THUMBPRINT Thumbprint1,
    PCRED_THUMBPRINT Thumbprint2);

void
GenerateCertThumbprint(
    PCCERT_CONTEXT pCertContext,
    PCRED_THUMBPRINT Thumbprint);

void
GenerateRandomThumbprint(
    PCRED_THUMBPRINT Thumbprint);

BOOL
DoesCredThumbprintMatch(
    PSPCredentialGroup pCredGroup,
    PCRED_THUMBPRINT pThumbprint);

SP_STATUS
SPCreateCred(
    DWORD           dwProtocol,
    PLSA_SCHANNEL_SUB_CRED pSubCred,
    PSPCredential   pCurrentCred,
    BOOL *          pfEventLogged);

SP_STATUS
SPCreateCredential(
   PSPCredentialGroup *ppCred,
   DWORD grbitProtocol,
   PLSA_SCHANNEL_CRED pSchannelCred);

SP_STATUS
AddCredentialToGroup(
    PSPCredentialGroup  pCredGroup, 
    PSPCredential       pCred);

SP_STATUS
IsCredentialInGroup(
    PSPCredentialGroup  pCredGroup, 
    PCCERT_CONTEXT      pCertContext,
    PBOOL               pfInGroup);

SECURITY_STATUS
UpdateCredentialFormat(
    PSCH_CRED pSchCred,         // in
    PLSA_SCHANNEL_CRED pCred);  // out

DWORD
GetCredentialKeySize(
    PSPCredential pCred);

NTSTATUS
FindDefaultMachineCred(
    PSPCredentialGroup *ppCred,
    DWORD dwProtocol);

BOOL
SPReferenceCredential(
    PSPCredentialGroup  pCred);

BOOL
SPDereferenceCredential(
    PSPCredentialGroup  pCred);

void
SPDeleteCred(
    PSPCredential pCred);

BOOL 
SPDeleteCredential(PSPCredentialGroup pCred);

// Downlevel credential versions
#define SSL_CREDENTIAL_VERSION      0

// flag bit definitions
#define CRED_FLAG_NO_SYSTEM_MAPPER          0x00000004  // client cert mapping
#define CRED_FLAG_NO_SERVERNAME_CHECK       0x00000008  // server cert validation
#define CRED_FLAG_MANUAL_CRED_VALIDATION    0x00000010  // server cert validation
#define CRED_FLAG_NO_DEFAULT_CREDS          0x00000020  // client certificate selection
#define CRED_FLAG_UPDATE_ISSUER_LIST        0x00000040  // new setting have been downloaded from GPO
#define CRED_FLAG_DELETED                   0x00000080  // credential has been deleted by application.

#define CRED_FLAG_REVCHECK_END_CERT              0x00000100 
#define CRED_FLAG_REVCHECK_CHAIN                 0x00000200 
#define CRED_FLAG_REVCHECK_CHAIN_EXCLUDE_ROOT    0x00000400 
#define CRED_FLAG_IGNORE_NO_REVOCATION_CHECK     0x00000800
#define CRED_FLAG_IGNORE_REVOCATION_OFFLINE      0x00001000

#define CRED_FLAG_DISABLE_RECONNECTS            0x00004000  

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\inc\keyexch.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       keyexch.h
//
//  Contents:   
//
//  Classes:
//
//  Functions:
//
//  History:    10-21-97   jbanes   CAPI integration.
//
//----------------------------------------------------------------------------

#ifndef __KEYEXCH_H__
#define __KEYEXCH_H__

typedef struct _SPContext SPContext;

typedef struct _PUBLICKEY
{
    BLOBHEADER *     pPublic;
    DWORD            cbPublic;
//    CRYPT_OBJID_BLOB Parameters;

} PUBLICKEY, *PPUBLICKEY;


SP_STATUS
MakeSessionKeys(
    SPContext * pContext,
    HCRYPTPROV  hProv, 
    HCRYPTKEY   hMasterKey);
 
VOID
ReverseMemCopy(
    PUCHAR      Dest,
    PUCHAR      Source,
    ULONG       Size) ;

void ReverseInPlace(PUCHAR pByte, DWORD cbByte);


typedef 
SP_STATUS 
 (WINAPI * GenerateServerExchangeValueFn)(
    SPContext     * pContext,               // in
    PUCHAR          pServerExchangeValue,   // out 
    DWORD *         pcbServerExchangeValue  // in/out
    );

typedef
SP_STATUS 
  (WINAPI * GenerateClientExchangeValueFn)(
    SPContext     * pContext,               // in / out
    PUCHAR          pServerExchangeValue,   // in 
    DWORD           pcbServerExchangeValue, // in
    PUCHAR          pClientClearValue,      // out 
    DWORD *         pcbClientClearValue,    // in/out
    PUCHAR          pClientExchangeValue,   // out 
    DWORD *         pcbClientExchangeValue  // in/out
    );

typedef
SP_STATUS
  (WINAPI * GenerateServerMasterKeyFn)(
    SPContext     * pContext,               // in
    PUCHAR          pClientClearValue,      // in
    DWORD           cbClientClearValue,     // in
    PUCHAR          pClientExchangeValue,   // in
    DWORD           cbClientExchangeValue   // in
    );


typedef struct _KeyExchangeSystem {
    DWORD           Type;
    PSTR            pszName;
//    PrivateFromBlobFn               PrivateFromBlob;
    GenerateServerExchangeValueFn   GenerateServerExchangeValue;
    GenerateClientExchangeValueFn   GenerateClientExchangeValue;
    GenerateServerMasterKeyFn       GenerateServerMasterKey;
} KeyExchangeSystem, * PKeyExchangeSystem;


typedef struct kexchtoalg {
    ALG_ID  idAlg;
    KeyExchangeSystem *System;
} AlgToExch;

extern AlgToExch g_AlgToExchMapping[];
extern int g_iAlgToExchMappings;


#define DSA_SIGNATURE_SIZE      40
#define MAX_DSA_ENCODED_SIGNATURE_SIZE (DSA_SIGNATURE_SIZE + 100)

#define MAGIC_DSS1 ((DWORD)'D' + ((DWORD)'S'<<8) + ((DWORD)'S'<<16) + ((DWORD)'1'<<24))
#define MAGIC_DSS2 ((DWORD)'D' + ((DWORD)'S'<<8) + ((DWORD)'S'<<16) + ((DWORD)'2'<<24))
#define MAGIC_DSS3 ((DWORD)'D' + ((DWORD)'S'<<8) + ((DWORD)'S'<<16) + ((DWORD)'3'<<24))
#define MAGIC_DH1  (             ((DWORD)'D'<<8) + ((DWORD)'H'<<16) + ((DWORD)'1'<<24))


/*
 * instantiations of systems
 */

extern KeyExchangeSystem keyexchPKCS;
extern KeyExchangeSystem keyexchDH;


// PROV_RSA_SCHANNEL handle used when building ClientHello messages.
extern HCRYPTPROV           g_hRsaSchannel;
extern PROV_ENUMALGS_EX *   g_pRsaSchannelAlgs;
extern DWORD                g_cRsaSchannelAlgs;

// PROV_DH_SCHANNEL handle used for client and server operations. This is 
// where the schannel ephemeral DH key lives.
extern HCRYPTPROV           g_hDhSchannelProv;
extern PROV_ENUMALGS_EX *   g_pDhSchannelAlgs;
extern DWORD                g_cDhSchannelAlgs;


#endif /* __KEYEXCH_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\inc\encode.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       encode.h
//
//  Contents:   
//
//  Classes:
//
//  Functions:
//
//  History:    10-21-97   jbanes   Removed obsolete declarations.
//
//----------------------------------------------------------------------------

#ifndef _ENCODE_H_
#define _ENCODE_H_

/* tag definitions for ASN.1 encoding decoding */
#define INTEGER_TAG             0x02
#define CHAR_STRING_TAG         0x16
#define OCTET_STRING_TAG        0x04
#define BIT_STRING_TAG          0x03
#define UTCTIME_TAG             0x17
#define SEQUENCE_TAG            0x30
#define SET_OF_TAG              0x11
#define OBJECT_ID_TAG           0x06
#define NULL_TAG                0x05
#define PRINTABLE_STRING_TAG    0x13
#define TELETEX_STRING_TAG      0x14
#define ATTRIBUTE_TAG           0xa0

/* definitions of maximum lengths needed for the ASN.1 encoded
   form of some of the common fields in a certificate */
#define MAXVALIDITYLEN          0x24
#define MAXKEYINFOLEN           0x50
#define MAXALGIDLEN             0x0A
#define MAXOBJIDLEN             0x0A
#define MAXNAMEVALUELEN         0x40
#define UTCTIMELEN              0x0F
#define MAXPUBKEYDATALEN        0x30
#define VERSIONLEN              0x03
#define MAXENCODEDSIGLEN        0x30
#define MAXHEADERLEN            0x08
#define MINHEADERLEN            0x03
#define MAXTIMELEN              0x20
#define MAXNAMELEN              0x60

/* definitions for scrubbing memory */
#define ALLBITSOFF              0x00
#define ALLBITSON               0xFF

/* prototypes for the functions in encode.c */
long EncodeLength(BYTE *pbEncoded, DWORD dwLen, BOOL Writeflag);
long EncodeAlgid(BYTE *pbEncoded, DWORD Algid, BOOL Writeflag);
long EncodeInteger(BYTE *pbEncoded, BYTE *pbInt, DWORD dwLen, BOOL Writeflag);
long EncodeString(BYTE *pbEncoded, BYTE *pbStr, DWORD dwLen, BOOL Writeflag);
long EncodeOctetString(BYTE *pbEncoded, BYTE *pbStr, DWORD dwLen, BOOL Writeflag);
long EncodeBitString(BYTE *pbEncoded, BYTE *pbStr, DWORD dwLen, BOOL Writeflag);
//long EncodeUTCTime(BYTE *pbEncoded, time_t Time, BOOL Writeflag);
long EncodeHeader(BYTE *pbEncoded, DWORD dwLen, BOOL Writeflag);
long EncodeSetOfHeader(BYTE *pbEncoded, DWORD dwLen, BOOL Writeflag);
long EncodeAttributeHeader(BYTE *pbEncoded, DWORD dwLen, BOOL Writeflag);
long EncodeName(BYTE *pbEncoded, BYTE *pbName, DWORD dwLen, BOOL Writeflag);


long DecodeLength(DWORD *pdwLen, BYTE *pbEncoded, DWORD cEncoded);
long DecodeAlgid(DWORD *pAlgid, BYTE *pbEncoded, DWORD cEncoded, BOOL Writeflag);
long DecodeHeader(DWORD *pdwLen, BYTE *pbEncoded, DWORD cEncoded);
long DecodeSetOfHeader(DWORD *pdwLen, BYTE *pbEncoded, DWORD cEncoded);
long DecodeInteger(BYTE *pbInt, DWORD cbBuff, DWORD *pdwLen, BYTE *pbEncoded, DWORD cEncoded, BOOL Writeflag);
long DecodeString(BYTE *pbStr, DWORD *pdwLen, BYTE *pbEncoded, DWORD cEncoded,BOOL Writeflag);
long DecodeOctetString(BYTE *pbStr, DWORD *pdwLen, BYTE *pbEncoded, DWORD cEncoded, BOOL Writeflag);
long DecodeBitString(BYTE *pbStr, DWORD *pdwLen, BYTE *pbEncoded, DWORD cEncoded, BOOL Writeflag);
long DecodeName(BYTE *pbName, DWORD *pdwLen, BYTE *pbEncoded, DWORD cEncoded, BOOL Writeflag);

long
EncodeAlgorithm(
    BYTE *  pbEncoded,
    DWORD   AlgId,
    BOOL    WriteFlag);

#define ALGTYPE_SIG_RSA_MD5      0x01
#define ALGTYPE_KEYEXCH_RSA_MD5  0x02
#define ALGTYPE_CIPHER_RC4_MD5   0x03
#define ALGTYPE_KEYEXCH_DH       0x04


long
EncodeDN(
    BYTE *  pbEncoded,
    PSTR    pszDN,
    BOOL    WriteFlag);


#ifndef SECURITY_LINUX
long
EncodeFileTime(
    BYTE *      pbEncoded,
    FILETIME    Time,
    BOOL        UTC,
    BOOL        WriteFlag);
#else /* SECURITY_LINUX */
long EncodeUTCTime(BYTE *pbEncoded, time_t Time, BOOL Writeflag);
#endif /* SECURITY_LINUX */

#ifndef SECURITY_LINUX
long
DecodeFileTime(
    FILETIME *  pTime,
    BYTE *      pbEncoded,
    DWORD       cEncoded,
    BOOL        WriteFlag);
#else /* SECURITY_LINUX */
long DecodeUTCTime(time_t *pTime, BYTE *pbEncoded, DWORD cEncoded, BOOL Writeflag);

#define DecodeFileTime DecodeUTCTime
#endif /* SECURITY_LINUX */

long
DecodeNull(
    BYTE *  pbEncoded, DWORD cEncoded);

long
DecodeDN(
    PSTR    pName,
    DWORD * pdwLen,
    BYTE *  pbEncoded,
    DWORD   cEncoded,
    BOOL    WriteFlag);

long
DecodeSigAlg(
    DWORD *         pAlgId,
    PBYTE           pbEncoded,
    DWORD           cEncoded,
    BOOL            WriteFlag);

long
DecodeCryptAlg(
    DWORD *         pAlgId,
    DWORD *         pHashid,
    PBYTE           pbEncoded,
    DWORD           cEncoded,
    BOOL            WriteFlag);

long
DecodeKeyType(
    DWORD *         pKeyType,
    PBYTE           pbEncoded,
    DWORD           cEncoded,
    BOOL            WriteFlag);


#endif  /* _ENCODE_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\inc\events.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1999
//
// File:        events.h
//
// Contents:    Schannel event log function declarations.
//
// History:     03-05-99   jbanes    Created
//
//------------------------------------------------------------------------

BOOL
SchInitializeEvents(void);

void
SchShutdownEvents(void);


void
LogSchannelStartedEvent(void);

void
LogGlobalAcquireContextFailedEvent(
    LPWSTR pwszName,
    DWORD Status);

void
LogCreateCredEvent(
    DWORD dwProtocol, 
    PLSA_SCHANNEL_CRED pSchannelCred);

void
LogCredPropertiesEvent(
    DWORD dwProtocol,
    PCRYPT_KEY_PROV_INFO pProvInfo,
    PCCERT_CONTEXT pCertContext);

void
LogNoPrivateKeyEvent(
    DWORD dwProtocol);

void
LogCredAcquireContextFailedEvent(
    DWORD dwProtocol, 
    DWORD Status);

void
LogCreateCredFailedEvent(
    DWORD dwProtocol);

void
LogNoDefaultServerCredEvent(void);

void
LogNoCiphersSupportedEvent(void);

void
LogCipherMismatchEvent(void);

void
LogNoClientCertFoundEvent(void);

void
LogBogusServerCertEvent(
    PCCERT_CONTEXT pCertContext,
    LPWSTR pszServername,
    DWORD Status);

void
LogBogusClientCertEvent(
    PCCERT_CONTEXT pCertContext,
    DWORD Status);

void
LogFastMappingFailureEvent(
    PCCERT_CONTEXT pCertContext,
    DWORD Status);

void
LogCertMappingFailureEvent(
    DWORD Status);

void
LogHandshakeInfoEvent(
    DWORD dwProtocol,
    PCipherInfo pCipherInfo,
    PHashInfo pHashInfo,
    PKeyExchangeInfo pExchangeInfo,
    DWORD dwExchangeStrength);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\inc\debug.h ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology 
* reference implementation, version 1.0
* 
* The Private Communication Technology reference implementation, version 1.0 
* ("PCTRef"), is being provided by Microsoft to encourage the development and 
* enhancement of an open standard for secure general-purpose business and 
* personal communications on open networks.  Microsoft is distributing PCTRef 
* at no charge irrespective of whether you use PCTRef for non-commercial or 
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without 
* warranty of any kind, either express or implied, including, without 
* limitation, the implied warranties or merchantability, fitness for a 
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out 
* of use or performance of PCTRef remains with you.
* 
* Please see the file LICENSE.txt, 
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
* 
* Please see http://pct.microsoft.com/pct/pct.htm for The Private 
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/ 

#ifndef __DEBUG_H__
#define __DEBUG_H__

extern DWORD   g_dwEventLogging;

#if DBG

extern DWORD   PctInfoLevel;
extern DWORD   PctTraceIndent;

extern DWORD   g_dwInfoLevel;
extern DWORD   g_dwDebugBreak;
extern HANDLE  g_hfLogFile;

#define DEB_ERROR           SP_LOG_ERROR
#define DEB_WARN            SP_LOG_WARNING
#define DEB_TRACE           SP_LOG_TRACE
#define DEB_BUFFERS         SP_LOG_BUFFERS

#define DebugLog(x) SPDebugLog x
#define SP_BEGIN(x) SPDebugLog(DEB_TRACE,"BEGIN:" x "\n"); PctTraceIndent++;
#define SP_RETURN(x) { PctTraceIndent--; SPDebugLog(DEB_TRACE, "END  Line %d\n", __LINE__); return (x); }
#define SP_LOG_RESULT(x) SPLogErrorCode((x), __FILE__, __LINE__)
#define SP_END()    { PctTraceIndent--; SPDebugLog(DEB_TRACE, "END:Line %d\n",  __LINE__); }
#define SP_BREAK()  { SPDebugLog(DEB_TRACE, "BREAK  Line %d\n",  __LINE__); }
#define LogDistinguishedName(a,b,c,d) SPLogDistinguishedName(a,b,c,d)

long    SPLogErrorCode(long, const char *, long);
void    SPDebugLog(long, const char *, ...);

void
InitDebugSupport(
    HKEY hGlobalKey);


void    DbgDumpHexString(const unsigned char*, DWORD);

#define DBG_HEX_STRING(l,p,c) if(g_dwInfoLevel & (l)) DbgDumpHexString((p), (c))

#define LOG_RESULT(x) SPLogErrorCode((x), __FILE__, __LINE__)

void
SPLogDistinguishedName(
    DWORD LogLevel,
    LPSTR pszLabel,
    PBYTE pbName,
    DWORD cbName);

#else

#define DebugLog(x)
#define SP_BEGIN(x) 
#define SP_RETURN(x) return (x)
#define SP_LOG_RESULT(x) x
#define SP_END()
#define SP_BREAK()
#define LOG_RESULT(x)
#define LogDistinguishedName(a,b,c,d) 

#endif



#endif /* __DEBUG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\inc\defcreds.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       defcreds.h
//
//  Contents:   Declarations for schannel default credentials routines.
//
//  Classes:
//
//  Functions:
//
//  History:    12-06-97   jbanes   Created.
//
//----------------------------------------------------------------------------

NTSTATUS
AcquireDefaultClientCredential(
    PSPContext  pContext,
    BOOL        fCredManagerOnly);


NTSTATUS
QueryCredentialManagerForCert(
    PSPContext          pContext,
    LPWSTR              pszTarget);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\inc\mapper.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       mapper.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10-15-96   RichardW     Created
//              12-23-97   jbanes       Added support for application mappers
//
//----------------------------------------------------------------------------

#ifndef __MAPPER_H__
#define __MAPPER_H__


HMAPPER *
SslGetMapper(
    BOOL    fDC);


DWORD
WINAPI
SslReferenceMapper(
    HMAPPER *   phMapper);          // in

DWORD
WINAPI
SslDereferenceMapper(
    HMAPPER *   phMapper);          // in

SECURITY_STATUS
WINAPI
SslGetMapperIssuerList(
    HMAPPER *   phMapper,           // in
    BYTE **     ppIssuerList,       // out
    DWORD *     pcbIssuerList);     // out

SECURITY_STATUS 
WINAPI
SslGetMapperChallenge(
    HMAPPER *   phMapper,           // in
    BYTE *      pAuthenticatorId,   // in
    DWORD       cbAuthenticatorId,  // in
    BYTE *      pChallenge,         // out
    DWORD *     pcbChallenge);      // out

SECURITY_STATUS 
WINAPI 
SslMapCredential(
    HMAPPER *   phMapper,           // in
    DWORD       dwCredentialType,   // in
    PCCERT_CONTEXT pCredential,     // in
    PCCERT_CONTEXT pAuthority,      // in
    HLOCATOR *  phLocator);         // out

SECURITY_STATUS 
WINAPI 
SslGetAccessToken(
    HMAPPER *   phMapper,           // in
    HLOCATOR    hLocator,           // in
    HANDLE *    phToken);           // out

SECURITY_STATUS 
WINAPI 
SslCloseLocator(
    HMAPPER *   phMapper,           // in
    HLOCATOR    hLocator);          // in

SECURITY_STATUS
WINAPI
SslQueryMappedCredentialAttributes(
    HMAPPER *   phMapper,           // in
    HLOCATOR    hLocator,           // in
    DWORD       dwAttribute,        // in
    PVOID *     ppBuffer);          // out

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\inc\pct1comp.h ===
#ifndef _PCT1COMP_H_
#define _PCT1COMP_H_

#ifdef DO_PCT_COMPAT

SP_STATUS PctCompatHandler(PPctContext pContext,
			   PSPBuffer  pCommInput,
			   PSsl2_Client_Hello pHello,
                           PSPBuffer  pCommOutput);

#endif

#endif /* _PCT1COMP_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\inc\pct1msg.h ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/

#ifndef __PCT1MSG_H__
#define __PCT1MSG_H__

#define PCT_CH_OFFSET_V1		(WORD)10
#define PCT_VERSION_1			(WORD)0x8001

/* message type codes */
#define PCT1_MSG_NOMSG               0x00
#define PCT1_MSG_CLIENT_HELLO		0x01
#define PCT1_MSG_SERVER_HELLO		0x02
#define PCT1_MSG_CLIENT_MASTER_KEY	0x03
#define PCT1_MSG_SERVER_VERIFY		0x04
#define PCT1_MSG_ERROR				0x05

#define PCT1_ET_OOB_DATA             0x01
#define PCT1_ET_REDO_CONN            0x02



#define PCT1_SESSION_ID_SIZE         32
#define PCT1_CHALLENGE_SIZE          32
#define PCT1_MASTER_KEY_SIZE         16
#define PCT1_RESPONSE_SIZE           32
#define PCT1_MAX_MESSAGE_LENGTH      0x3f00
#define PCT1_MAX_CLIENT_HELLO        256


#define PCT1_CERT_TYPE_FROM_CAPI2(s) X509_ASN_ENCODING
/*
 *
 * Useful Macros
 *
 */

#define LSBOF(x)    ((UCHAR) ((x) & 0xFF))
#define MSBOF(x)    ((UCHAR) (((x) >> 8) & 0xFF) )

#define COMBINEBYTES(Msb, Lsb)  ((DWORD) (((DWORD) (Msb) << 8) | (DWORD) (Lsb)))

/* external representations of algorithm specs */

typedef DWORD   ExtCipherSpec, *PExtCipherSpec;
typedef WORD    ExtHashSpec,   *PExtHashSpec;
typedef WORD    ExtCertSpec,   *PExtCertSpec;
typedef WORD    ExtExchSpec,   *PExtExchSpec;
typedef WORD    ExtSigSpec,    *PExtSigSpec;

typedef struct _Pct1CipherMap
{
    ALG_ID      aiCipher;
    DWORD       dwStrength;
    CipherSpec  Spec;
} Pct1CipherMap, *PPct1CipherMap;

typedef struct _Pct1HashMap
{
    ALG_ID      aiHash;
    CipherSpec  Spec;
} Pct1HashMap, *PPct1HashMap;

extern Pct1CipherMap Pct1CipherRank[];
extern DWORD Pct1NumCipher;

/* available hashes, in order of preference */
extern Pct1HashMap Pct1HashRank[];
extern DWORD Pct1NumHash;

extern CertTypeMap aPct1CertEncodingPref[];
extern DWORD cPct1CertEncodingPref;

extern KeyTypeMap aPct1LocalExchKeyPref[];

extern DWORD cPct1LocalExchKeyPref;

extern KeyTypeMap aPct1LocalSigKeyPref[];
extern DWORD cPct1LocalSigKeyPref;



typedef struct _PCT1_MESSAGE_HEADER {
    UCHAR   Byte0;
    UCHAR   Byte1;
} PCT1_MESSAGE_HEADER, * PPCT1_MESSAGE_HEADER;

typedef struct _PCT1_MESSAGE_HEADER_EX {
    UCHAR   Byte0;
    UCHAR   Byte1;
    UCHAR   PaddingSize;
} PCT1_MESSAGE_HEADER_EX, * PPCT1_MESSAGE_HEADER_EX;


typedef struct _PCT1_ERROR {
    PCT1_MESSAGE_HEADER   Header;
    UCHAR               MessageId;
    UCHAR               ErrorMsb;
    UCHAR               ErrorLsb;
    UCHAR               ErrorInfoMsb;
    UCHAR               ErrorInfoLsb;
    UCHAR               VariantData[1];
} PCT1_ERROR, * PPCT1_ERROR;


typedef struct _PCT1_CLIENT_HELLO {
    PCT1_MESSAGE_HEADER   Header;
    UCHAR               MessageId;
    UCHAR               VersionMsb;
    UCHAR               VersionLsb;
    UCHAR               Pad;
    UCHAR               SessionIdData[PCT1_SESSION_ID_SIZE];
    UCHAR               ChallengeData[PCT1_CHALLENGE_SIZE];
    UCHAR               OffsetMsb;
    UCHAR               OffsetLsb;
    UCHAR               CipherSpecsLenMsb;
    UCHAR               CipherSpecsLenLsb;
    UCHAR               HashSpecsLenMsb;
    UCHAR               HashSpecsLenLsb;
    UCHAR               CertSpecsLenMsb;
    UCHAR               CertSpecsLenLsb;
    UCHAR               ExchSpecsLenMsb;
    UCHAR               ExchSpecsLenLsb;
    UCHAR               KeyArgLenMsb;
    UCHAR               KeyArgLenLsb;
    UCHAR               VariantData[1];
} PCT1_CLIENT_HELLO, * PPCT1_CLIENT_HELLO;


typedef struct _PCT1_SERVER_HELLO {
    PCT1_MESSAGE_HEADER   Header;
    UCHAR               MessageId;
    UCHAR               Pad;
    UCHAR               ServerVersionMsb;
    UCHAR               ServerVersionLsb;
    UCHAR               RestartSessionOK;
    UCHAR               ClientAuthReq;
    ExtCipherSpec       CipherSpecData;
    ExtHashSpec         HashSpecData;
    ExtCertSpec         CertSpecData;
    ExtExchSpec         ExchSpecData;
    UCHAR               ConnectionIdData[PCT1_SESSION_ID_SIZE];
    UCHAR               CertificateLenMsb;
    UCHAR               CertificateLenLsb;
    UCHAR               CertSpecsLenMsb;
    UCHAR               CertSpecsLenLsb;
    UCHAR               ClientSigSpecsLenMsb;
    UCHAR               ClientSigSpecsLenLsb;
    UCHAR               ResponseLenMsb;
    UCHAR               ResponseLenLsb;
    UCHAR               VariantData[1];
} PCT1_SERVER_HELLO, * PPCT1_SERVER_HELLO;

typedef struct _PCT1_CLIENT_MASTER_KEY {
    PCT1_MESSAGE_HEADER   Header;
    UCHAR               MessageId;
    UCHAR               Pad;
    ExtCertSpec         ClientCertSpecData;
    ExtSigSpec          ClientSigSpecData;
    UCHAR               ClearKeyLenMsb;
    UCHAR               ClearKeyLenLsb;
    UCHAR               EncryptedKeyLenMsb;
    UCHAR               EncryptedKeyLenLsb;
    UCHAR               KeyArgLenMsb;
    UCHAR               KeyArgLenLsb;
    UCHAR               VerifyPreludeLenMsb;
    UCHAR               VerifyPreludeLenLsb;
    UCHAR               ClientCertLenMsb;
    UCHAR               ClientCertLenLsb;
    UCHAR               ResponseLenMsb;
    UCHAR               ResponseLenLsb;
    UCHAR               VariantData[1];
} PCT1_CLIENT_MASTER_KEY, * PPCT1_CLIENT_MASTER_KEY;


typedef struct _PCT1_SERVER_VERIFY {
    PCT1_MESSAGE_HEADER   Header;
    UCHAR               MessageId;
    UCHAR               Pad;
    UCHAR               SessionIdData[PCT1_SESSION_ID_SIZE];
    UCHAR               ResponseLenMsb;
    UCHAR               ResponseLenLsb;
    UCHAR               VariantData[1];
} PCT1_SERVER_VERIFY, * PPCT1_SERVER_VERIFY;



/*
 *
 * Expanded Form Messages:
 *
 */

typedef struct _Pct1_Error {
	DWORD			Error;
	DWORD			ErrInfoLen;
	BYTE			*ErrInfo;
} Pct1Error, *PPct1_Error;

typedef struct _Pct1_Client_Hello {
    DWORD           cCipherSpecs;
    DWORD           cHashSpecs;
    DWORD           cCertSpecs;
    DWORD           cExchSpecs;
    DWORD           cbKeyArgSize;
	DWORD           cbSessionID;
	DWORD           cbChallenge;
    PUCHAR          pKeyArg;
    CipherSpec      * pCipherSpecs;
    HashSpec        * pHashSpecs;
    CertSpec        * pCertSpecs;
    ExchSpec        * pExchSpecs;
    UCHAR           SessionID[PCT1_SESSION_ID_SIZE];
	UCHAR           Challenge[PCT1_CHALLENGE_SIZE];
} Pct1_Client_Hello, * PPct1_Client_Hello;


typedef struct _Pct1_Server_Hello {
    DWORD           RestartOk;
    DWORD           ClientAuthReq;
    DWORD           CertificateLen;
    DWORD           ResponseLen;
    DWORD           cSigSpecs;
    DWORD           cCertSpecs;
	DWORD           cbConnectionID;
    UCHAR *         pCertificate;
    CipherSpec      SrvCipherSpec;
    HashSpec        SrvHashSpec;
    CertSpec        SrvCertSpec;
    ExchSpec        SrvExchSpec;
    SigSpec         * pClientSigSpecs;
    CertSpec        * pClientCertSpecs;
    UCHAR           ConnectionID[PCT1_SESSION_ID_SIZE];
    UCHAR           Response[PCT1_RESPONSE_SIZE];
} Pct1_Server_Hello, * PPct1_Server_Hello;

typedef struct _Pct1_Client_Master_Key {
    DWORD           ClearKeyLen;
    DWORD           EncryptedKeyLen;
    DWORD           KeyArgLen;
    DWORD           VerifyPreludeLen;
    DWORD           ClientCertLen;
    DWORD           ResponseLen;
    CertSpec        ClientCertSpec;
    SigSpec         ClientSigSpec;
    UCHAR           ClearKey[PCT1_MASTER_KEY_SIZE];
    PBYTE           pbEncryptedKey;
    UCHAR           KeyArg[PCT1_MASTER_KEY_SIZE];
    PUCHAR          pClientCert;
    PBYTE           pbResponse;
    UCHAR           VerifyPrelude[PCT1_RESPONSE_SIZE];
} Pct1_Client_Master_Key, * PPct1_Client_Master_Key;

typedef struct _Pct1_Server_Verify {
    UCHAR           SessionIdData[PCT1_SESSION_ID_SIZE];
    DWORD           ResponseLen;
    UCHAR           Response[PCT1_RESPONSE_SIZE];
} Pct1_Server_Verify, * PPct1_Server_Verify;

/*
 *
 * Pickling Prototypes
 *
 */

SP_STATUS
Pct1PackClientHello(
    PPct1_Client_Hello       pCanonical,
    PSPBuffer          pCommOutput);

SP_STATUS
Pct1UnpackClientHello(
    PSPBuffer          pInput,
    PPct1_Client_Hello *     ppClient);

SP_STATUS
Pct1PackServerHello(
    PPct1_Server_Hello       pCanonical,
    PSPBuffer          pCommOutput);

SP_STATUS
Pct1UnpackServerHello(
    PSPBuffer          pInput,
    PPct1_Server_Hello *     ppServer);

SP_STATUS
Pct1PackClientMasterKey(
    PPct1_Client_Master_Key      pCanonical,
    PSPBuffer              pCommOutput);

SP_STATUS
Pct1UnpackClientMasterKey(
    PSPBuffer              pInput,
    PPct1_Client_Master_Key *    ppClient);

SP_STATUS
Pct1PackServerVerify(
    PPct1_Server_Verify          pCanonical,
    PSPBuffer              pCommOutput);

SP_STATUS
Pct1UnpackServerVerify(
    PSPBuffer              pInput,
    PPct1_Server_Verify *        ppServer);

SP_STATUS
Pct1PackError(
    PPct1_Error               pCanonical,
    PSPBuffer              pCommOutput);

#endif /* __PCT1MSG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\inc\pct1prot.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       pct1prot.h
//
//  Contents:   
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   LSA integration stuff.
//
//----------------------------------------------------------------------------

#ifndef _PCT1PROT_H_
#define _PCT1PROT_H_

/* keyexchange algs */
#define PCT1_EXCH_RSA_PKCS1          0x0001
#define PCT1_EXCH_RSA_PKCS1_TOKEN_DES     0x0002
#define PCT1_EXCH_RSA_PKCS1_TOKEN_DES3    0x0003
#define PCT1_EXCH_RSA_PKCS1_TOKEN_RC2     0x0004
#define PCT1_EXCH_RSA_PKCS1_TOKEN_RC4     0x0005

#define PCT1_EXCH_DH_PKCS3                0x0006
#define PCT1_EXCH_DH_PKCS3_TOKEN_DES      0x0007
#define PCT1_EXCH_DH_PKCS3_TOKEN_DES3     0x0008
#define PCT1_EXCH_FORTEZZA_TOKEN          0x0009

#define PCT1_EXCH_UNKNOWN                 0xffff


/* data encryption algs */
/* encryption alg masks */
#define PCT1_CIPHER_ALG           0xffff0000
#define PCT1_CIPHER_STRENGTH                0x0000ff00
#define PCT1_CSTR_POS                     8
#define PCT1_CIPHER_MAC           0x000000ff

/* specific algs */
#define PCT1_CIPHER_DES           0x00010000
#define PCT1_CIPHER_IDEA                    0x00020000
#define PCT1_CIPHER_RC2           0x00030000
#define PCT1_CIPHER_RC4           0x00040000
#define PCT1_CIPHER_2DES                  0x00050000
#define PCT1_CIPHER_3DES                  0x00060000
#define PCT1_CIPHER_SKIPJACK              0x01000000
#define PCT1_CIPHER_NONE                  0x00000000

#define PCT1_CIPHER_UNKNOWN               0xffffffff

/* data encryption strength specs */
#define PCT1_ENC_BITS_40                    0x00002800
#define PCT1_ENC_BITS_56                    0x00003800
#define PCT1_ENC_BITS_64                    0x00004000
#define PCT1_ENC_BITS_80                    0x00005000
#define PCT1_ENC_BITS_128                  0x00008000
#define PCT1_ENC_BITS_168                  0x0000a800
#define PCT1_ENC_BITS_192                  0x0000c000
/* mac strength specs */
#define PCT1_MAC_BITS_128                  0x00000040

/* hashing algs */
#define PCT1_HASH_MD5                     0x0001
#define PCT1_HASH_MD5_TRUNC_64          0x0002
#define PCT1_HASH_SHA                     0x0003
#define PCT1_HASH_SHA_TRUNC_80            0x0004
#define PCT1_HASH_DES_DM                  0x0005
#define PCT1_HASH_MD2                     0x0006
#define PCT1_HASH_UNKNOWN                 0xffff

/* certificate types */
#define PCT1_CERT_NONE                  0x0000
#define PCT1_CERT_X509                  0x0001
#define PCT1_CERT_PKCS7                 0x0002
#define PCT1_CERT_X509_CHAIN            0x0003

/* signature algorithms */
#define PCT1_SIG_NONE                     0x0000
#define PCT1_SIG_RSA_MD5                    0x0001
#define PCT1_SIG_RSA_SHA                  0x0002
#define PCT1_SIG_DSA_SHA                  0x0003

/* these are for internal use only */
#define PCT1_SIG_RSA_MD2                    0x0004
#define PCT1_SIG_RSA                0x0005
#define PCT1_SIG_RSA_SHAMD5               0x0006
#define PCT1_SIG_FORTEZZA_TOKEN           0x0007



/* key derivation separators */

#define PCT_CONST_CWK         "cwcwcwcwcw"
#define PCT_CONST_CWK_LEN      2

#define PCT_CONST_SWK         "svwsvwsvwsvwsvw"
#define PCT_CONST_SWK_LEN      3

#define PCT_CONST_CMK         "cmaccmaccmaccmaccmac"
#define PCT_CONST_CMK_LEN      4

#define PCT_CONST_SMK         "svmacsvmacsvmacsvmacsvmac"
#define PCT_CONST_SMK_LEN      5

#define PCT_CONST_SR            "svsvsvsvsv"
#define PCT_CONST_SR_LEN        2

#define PCT_CONST_SLK         "slslslslsl"
#define PCT_CONST_SLK_LEN      2

#define PCT_CONST_RESP      "srsrsrsrsr"
#define PCT_CONST_RESP_LEN    2

#define PCT_CONST_VP            "cvp"
#define PCT_CONST_VP_LEN        3
#define PCT_USE_CERT                    1
#define PCT_MAKE_MAC                    2

#define DERIVATION_BUFFER_SIZE      1024

/* data structs */

/* message constants and types */
#define PCT_MASTER_KEY_SIZE     16
#define PCT_SESSION_ID_SIZE     32
#define PCT_CHALLENGE_SIZE      32

#define PCT1_MAX_KEY_ARGS        8

#define RESPONSE_SIZE       32      /* allows for hash output growth */

#define PCT_MAX_SHAKE_LEN   32768    /* longest handshake message len */
/* implementation constants */

#define PCT_MAX_NUM_SEP   5
#define PCT_MAX_SEP_LEN   5

#define PCT1_MAX_CERT_SPECS     5
#define PCT1_MAX_SIG_SPECS      5
#define PCT1_MAX_EXCH_SPECS     5
#define PCT1_MAX_CIPH_SPECS     16
#define PCT1_MAX_HASH_SPECS     16

/* mismatch vector */

#define PCT_NUM_MISMATCHES    6

#define PCT_IMIS_CIPHER   1
#define PCT_IMIS_HASH         2
#define PCT_IMIS_CERT         4
#define PCT_IMIS_EXCH         8
#define PCT_IMIS_CL_CERT        16
#define PCT_IMIS_CL_SIG   32


SP_STATUS WINAPI
Pct1ServerProtocolHandler(
    PSPContext pContext,
    PSPBuffer pCommInput,
    PSPBuffer pCommOutput);

SP_STATUS WINAPI
Pct1ClientProtocolHandler(
    PSPContext pContext,
    PSPBuffer pCommInput,
    PSPBuffer pCommOutput);

SP_STATUS WINAPI 
Pct1DecryptHandler(
    PSPContext pContext,
    PSPBuffer  pCommInput,
    PSPBuffer  pAppOutput);

SP_STATUS WINAPI
Pct1GetHeaderSize(
    PSPContext pContext,
    PSPBuffer pCommInput,
    DWORD * pcbHeaderSize);


SP_STATUS WINAPI Pct1DecryptMessage(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pAppOutput);

SP_STATUS WINAPI Pct1EncryptRaw(PSPContext  pContext,
                             PSPBuffer      pAppInput,
                             PSPBuffer      pCommOutput,
                             DWORD          dwFlags);

#define PCT1_ENCRYPT_ESCAPE 0x00000001


SP_STATUS WINAPI Pct1EncryptMessage(PSPContext pContext,
                             PSPBuffer  pAppInput,
                             PSPBuffer  pCommOutput);



SP_STATUS Pct1SrvHandleClientHello(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PPct1_Client_Hello pHello,
                              PSPBuffer  pCommOutput);

SP_STATUS Pct1SrvHandleCMKey(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pCommOutput);

SP_STATUS Pct1CliHandleServerHello(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PPct1_Server_Hello  pHello,
                              PSPBuffer  pCommOutput);

SP_STATUS Pct1CliHandleServerVerify(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pCommOutput);

SP_STATUS Pct1HandleError(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pCommOutput);

SP_STATUS Pct1GenerateError(PSPContext pContext,
                              PSPBuffer  pCommOutput,
                              SP_STATUS  pError,
                              PSPBuffer  pErrData);


SP_STATUS
WINAPI
GeneratePct1StyleHello(
    PSPContext              pContext,
    PSPBuffer               pOutput);

SP_STATUS
Pct1CliRestart(PSPContext  pContext, 
              PPct1_Server_Hello pHello, 
              PSPBuffer pCommOutput);

SP_STATUS
Pct1SrvRestart(PSPContext           pContext, 
               PPct1_Client_Hello   pHello,
               PSPBuffer            pCommOutput);

VOID
Pct1ActivateSessionKeys(PSPContext pContext);

SP_STATUS
Pct1MakeSessionKeys(PSPContext pContext);

SP_STATUS Pct1EndVerifyPrelude(PSPContext pContext,
                               PUCHAR     VerifyPrelude,
                               DWORD *    pcbVerifyPrelude
                               );

SP_STATUS Pct1BeginVerifyPrelude(PSPContext pContext,
                                 PUCHAR     pClientHello,
                                 DWORD      cbClientHello,
                                 PUCHAR     pServerHello,
                                 DWORD      cbServerHello);

SP_STATUS
Pct1ComputeResponse(
    PSPContext pContext,      
    PBYTE      pbChallenge,   
    DWORD      cbChallenge,   
    PBYTE      pbConnectionID,
    DWORD      cbConnectionID,
    PBYTE      pbSessionID,   
    DWORD      cbSessionID,   
    PBYTE      pbResponse,    
    PDWORD     pcbResponse);


#endif /* _PCT1PROT_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\inc\oidenc.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       context.h
//
//  Contents:   Schannel context declarations.
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   Ported over SGC stuff from NT 4 tree.
//
//----------------------------------------------------------------------------

#ifndef __OIDENC_H__
#define __OIDENC_H__

#define szPublicTag   ".public"
#define szParamTag    ".params"
#define szPrivateTag  ".private"

#define MAX_OID_SIZE  64


#define szOID_RSA_RSA_Public szOID_RSA_RSA szPublicTag

#define szOID_INFOSEC_mosaicUpdatedSig_Public  szOID_INFOSEC_mosaicUpdatedSig  szPublicTag
#define szOID_INFOSEC_mosaicUpdatedSig_Params  szOID_INFOSEC_mosaicUpdatedSig  szParamTag
#define szOID_INFOSEC_mosaicKMandUpdSig_Public szOID_INFOSEC_mosaicKMandUpdSig szPublicTag
#define szOID_INFOSEC_mosaicKMandUpdSig_Params szOID_INFOSEC_mosaicKMandUpdSig szParamTag

#define szOID_DSA_Public      szOID_OIWSEC_dsa szPublicTag
#define szOID_DSA_Params      szOID_OIWSEC_dsa szParamTag
#define szOID_X957_DSA_Public szOID_X957_DSA   szPublicTag
#define szOID_X957_DSA_Params szOID_X957_DSA   szParamTag


#define szOID_RSA_ENCRYPT_RC4_MD5  szOID_RSA_ENCRYPT ".4"

#define szPrivateKeyFileEncode "PrivateKeyFileEncode"
#define szPrivateKeyInfoEncode "PrivateKeyInfoEncode"

#ifndef X509_ENHANCED_KEY_USAGE
#define X509_ENHANCED_KEY_USAGE             ((LPCSTR) 36)

typedef struct _CTL_USAGE {
    DWORD               cUsageIdentifier;
    LPSTR               *rgpszUsageIdentifier;      // array of pszObjId
} CTL_USAGE, *PCTL_USAGE,
  CERT_ENHKEY_USAGE, *PCERT_ENHKEY_USAGE;


#endif

#ifndef szOID_ENHANCED_KEY_USAGE
#define szOID_ENHANCED_KEY_USAGE        "2.5.29.37"
#endif

#ifndef szOID_SERVER_GATED_CRYPTO
#define szOID_SERVER_GATED_CRYPTO       "1.3.6.1.4.1.311.10.3.3"
#endif

#define szOID_NETSCAPE_SGC              "2.16.840.1.113730.4.1"


BOOL
WINAPI
InitSchannelAsn1(
        HMODULE hModule);
BOOL
WINAPI
ShutdownSchannelAsn1();

typedef struct _PRIVATE_KEY_FILE_ENCODE
{
    CRYPT_BIT_BLOB              EncryptedBlob;
    CRYPT_ALGORITHM_IDENTIFIER  Alg; 
} PRIVATE_KEY_FILE_ENCODE, *PPRIVATE_KEY_FILE_ENCODE;


#endif // __OIDENC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\inc\protocol.h ===
#ifndef _PROTOCOL_H_
#define _PROTOCOL_H_


typedef struct _SPContext SPContext, *PSPContext;


typedef struct _UNICipherMap {
    DWORD             CipherKind;
    DWORD             fProt;
    ALG_ID            aiHash;
    ALG_ID            aiCipher;
    DWORD             dwStrength;
    ExchSpec          KeyExch;
    ALG_ID            aiExch;
    DWORD             dwFlags;
} UNICipherMap, *PUNICipherMap;

// cipher map flag values
#define DOMESTIC_CIPHER_SUITE   0x00000001
#define EXPORT40_CIPHER_SUITE   0x00000002
#define EXPORT56_CIPHER_SUITE   0x00000004


extern DWORD g_ProtEnabled;

extern UNICipherMap UniAvailableCiphers[];
extern DWORD UniNumCiphers;

SP_STATUS WINAPI
ServerProtocolHandler(PSPContext pContext,
    PSPBuffer  pCommInput,
    PSPBuffer  pCommOutput);

SP_STATUS WINAPI
ClientProtocolHandler(PSPContext pContext,
    PSPBuffer  pCommInput,
    PSPBuffer  pCommOutput);

SP_STATUS
GetSupportedCapiAlgs(
    HCRYPTPROV          hProv,
    DWORD               dwCapiFlags,
    PROV_ENUMALGS_EX ** ppAlgInfo,
    DWORD *             pcAlgInfo);

SP_STATUS WINAPI
GenerateHello(
    PSPContext              pContext,
    PSPBuffer               pOutput,
    BOOL                    fCache);

SP_STATUS WINAPI
GenerateUniHello(
    PSPContext             pContext,
    PSPBuffer               pOutput,
    DWORD                   fProtocol
    );



typedef SP_STATUS ( WINAPI * SPInitiateHelloFn)(
                    PSPContext             pContext,
                    PSPBuffer              pOutput,
                    BOOL                   fCache);

typedef SP_STATUS ( WINAPI * SPProtocolHandlerFn)(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pCommOutput);

typedef SP_STATUS ( WINAPI * SPDecryptHandlerFn)(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pAppOutput);


typedef SP_STATUS ( WINAPI * SPDecryptMessageFn)(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pAppOutput);

typedef SP_STATUS ( WINAPI * SPEncryptMessageFn)(PSPContext pContext,
                             PSPBuffer  pAppInput,
                             PSPBuffer  pCommOutput);

typedef SP_STATUS ( WINAPI * SPGetHeaderSizeFn)(PSPContext pContext,
                                                PSPBuffer  pCommInput,
                                                DWORD *    pcbHeader);


/* State machine states */

#define SP_STATE_NONE                   0x00
#define PCT1_STATE_CLIENT_HELLO         0x01
#define PCT1_STATE_SERVER_HELLO         0x02
#define PCT1_STATE_CLIENT_MASTER_KEY    0x03
#define PCT1_STATE_SERVER_VERIFY        0x04
#define PCT1_STATE_ERROR                0x05
#define PCT1_STATE_RENEGOTIATE          0x06

#define SSL2_STATE_CLIENT_HELLO         0x11
#define SSL2_STATE_SERVER_HELLO         0x12
#define SSL2_STATE_CLIENT_MASTER_KEY    0x13
#define SSL2_STATE_CLIENT_FINISH        0x14
#define SSL2_STATE_SERVER_VERIFY        0x15
#define SSL2_STATE_SERVER_FINISH        0x16
#define SSL2_STATE_REQUEST_CERTIFICATE  0x17
#define SSL2_STATE_CLIENT_CERTIFICATE   0x18
#define SSL2_STATE_SERVER_RESTART       0x19
#define SSL2_STATE_CLIENT_RESTART       0x1a
#define SSL3_STATE_CLIENT_HELLO         0x1b
#define SSL3_STATE_CHANGE_CIPHER_SPEC   0x1c
#define SSL3_STATE_RESTART_CCS          0x1d
#define SSL3_STATE_RESTART_SERVER_FINISH 0x1e
#define SSL3_STATE_SERVER_FINISH        0x1f
#define UNI_STATE_RECVD_UNIHELLO        0xfe
#define UNI_STATE_CLIENT_HELLO          0xff
#define SSL3_STATE_CLIENT_FINISH        0x21
#define SSL3_STATE_RESTART_CLI_FINISH   0x22
#define SSL3_STATE_REDO_RESTART         0x24
#define SSL3_STATE_SERVER_CERTIFICATE   0x25
#define SSL3_STATE_SERVER_KEY_XCHANGE   0x26
#define SSL3_STATE_SERVER_CERTREQ       0x27
#define SSL3_STATE_SERVER_HELLO         0x29
#define SSL3_STATE_CLIENT_KEY_XCHANGE   0x31
#define SSL3_STATE_CERT_VERIFY          0x32
#define SSL3_STATE_FINISHED             0x33
#define SSL3_STATE_RESTART_SER_HELLO    0x36
#define SSL3_STATE_SER_RESTART_CHANGE_CIPHER_SPEC 0x37
#define SSL3_STATE_CHANGE_CIPHER_SPEC_CLIENT 0x38
#define SSL3_STATE_CHANGE_CIPHER_SPEC_SERVER 0x39
#define SSL3_STATE_NO_CERT_ALERT        0x3a
#define SSL3_STATE_RENEGOTIATE           0x3b
#define SSL3_STATE_SGC_CERTIFICATE      0x3c


//these defines must not be touched... Please do not in this section...
// PROTECTED BY SSL3 SPECEFIC states
#define SSL3_STATE_GEN_START                0x80
#define SSL3_STATE_GEN_SERVER_HELLORESP     (SSL3_STATE_GEN_START + 1)
#define SSL3_STATE_GEN_SERVER_HELLO         (SSL3_STATE_GEN_START + 2)
#define SSL3_STATE_GEN_SERVER_HELLO_RESTART (SSL3_STATE_GEN_START + 3)
#define SSL3_STATE_GEN_SERVER_FINISH        (SSL3_STATE_GEN_START + 4)
#define SSL3_STATE_GEN_CLIENT_FINISH        (SSL3_STATE_GEN_START + 5)
#define SSL3_STATE_GEN_REDO                 (SSL3_STATE_GEN_START + 6)  
#define SSL3_STATE_GEN_HELLO_REQUEST        (SSL3_STATE_GEN_START + 7)
#define SSL3_STATE_CONNECTED_SERVER         (SSL3_STATE_GEN_START + 8)
#define TLS1_STATE_ERROR                    (SSL3_STATE_GEN_START + 9)
#define SSL3_STATE_GEN_END                  (SSL3_STATE_GEN_START + 10)

//PROTECTED AREA ENDS.................

#define SP_STATE_SHUTDOWN_PENDING   0x0000fffd  // We're building a CloseNotify alert. 
#define SP_STATE_SHUTDOWN           0x0000fffe  // We're shutting down.

#define SP_STATE_CONNECTED      0x0000ffff  /* We are connected, and are 
                                             * expecting data packets, otherwise
                                             * we are performing a protocol 
                                             * negotiation lower word contains
                                             * last message sent, implying what
                                             * the next word will be */


// UNIHELLO codes.

#define PCT_SSL_COMPAT                  0x8f
#define PCT_SSL_CERT_TYPE               0x80
#define PCT_SSL_HASH_TYPE               0x81
#define PCT_SSL_EXCH_TYPE               0x82
#define PCT_SSL_CIPHER_TYPE_1ST_HALF    0x83
#define PCT_SSL_CIPHER_TYPE_2ND_HALF    0x84

#define UNI_CK_PCT  SSL_MKFAST(PCT_SSL_COMPAT, MSBOF(PCT_VERSION_1), LSBOF(PCT_VERSION_1))
#define PCT_SSL_CERT_X509  SSL_MKFAST(0x80, 0x00, 0x00)
#define PCT_SSL_CERT_PKCS7 SSL_MKFAST(0x80, 0x00, 0x01)


#endif /* _PROTOCOL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\inc\pkiasn1.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1998
//
//  File:       pkiasn1.h
//
//  Contents:   PKI ASN.1 support functions.
//
//  APIs:       PkiAsn1ErrToHr
//              PkiAsn1Encode
//              PkiAsn1FreeEncoded
//              PkiAsn1Encode2
//              PkiAsn1Decode
//              PkiAsn1Decode2
//              PkiAsn1FreeDecoded
//              PkiAsn1SetEncodingRule
//              PkiAsn1GetEncodingRule
//              PkiAsn1EncodedOidToDotVal
//              PkiAsn1FreeDotVal
//              PkiAsn1DotValToEncodedOid
//              PkiAsn1FreeEncodedOid
//
//              PkiAsn1ReverseBytes
//
//              PkiAsn1EncodeInfo
//              PkiAsn1DecodeAndAllocInfo
//              PkiAsn1FreeInfo
//              PkiAsn1EncodeInfoEx
//              PkiAsn1DecodeAndAllocInfo
//              PkiAsn1AllocStructInfoEx
//              PkiAsn1DecodeAndAllocInfoEx
//
//              PkiAsn1ToObjectIdentifier
//              PkiAsn1FromObjectIdentifier
//
//  History:    23-Oct-98    philh   created
//--------------------------------------------------------------------------

#ifndef __PKIASN1_H__
#define __PKIASN1_H__

#include <msber.h>
#include <msasn1.h>
#include <winerror.h>


#ifdef __cplusplus
extern "C" {
#endif



//+-------------------------------------------------------------------------
//  Convert Asn1 error to a HRESULT.
//--------------------------------------------------------------------------
__inline
HRESULT
WINAPI
PkiAsn1ErrToHr(ASN1error_e Asn1Err) {
    if (0 > Asn1Err)
        return CRYPT_E_ASN1_ERROR + (-Asn1Err -1000);
    else
        return CRYPT_E_ASN1_ERROR + 0x100 + (Asn1Err -1000);
}

//+-------------------------------------------------------------------------
//  Asn1 Encode function. The encoded output is allocated and must be freed
//  by calling PkiAsn1FreeEncoded().
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Encode(
    IN ASN1encoding_t pEnc,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    );

//+-------------------------------------------------------------------------
//  Free encoded output returned by PkiAsn1Encode().
//--------------------------------------------------------------------------
__inline
void
WINAPI
PkiAsn1FreeEncoded(
    IN ASN1encoding_t pEnc,
    IN void *pvEncoded
    )
{
    if (pvEncoded)
        ASN1_FreeEncoded(pEnc, pvEncoded);
}

//+-------------------------------------------------------------------------
//  Asn1 Encode function. The encoded output isn't allocated.
//
//  If pbEncoded is NULL, does a length only calculation.
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Encode2(
    IN ASN1encoding_t pEnc,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id,
    OUT OPTIONAL BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded
    );

//+-------------------------------------------------------------------------
//  Asn1 Decode function. The allocated, decoded structure, **pvAsn1Info, must
//  be freed by calling PkiAsn1FreeDecoded().
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Decode(
    IN ASN1decoding_t pDec,
    OUT void **ppvAsn1Info,
    IN ASN1uint32_t id,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded
    );

//+-------------------------------------------------------------------------
//  Asn1 Decode function. The allocated, decoded structure, **pvAsn1Info, must
//  be freed by calling PkiAsn1FreeDecoded().
//
//  For a successful decode, *ppbEncoded is advanced
//  past the decoded bytes and *pcbDecoded is decremented by the number
//  of decoded bytes.
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Decode2(
    IN ASN1decoding_t pDec,
    OUT void **ppvAsn1Info,
    IN ASN1uint32_t id,
    IN OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    );

//+-------------------------------------------------------------------------
//  Free decoded structure returned by PkiAsn1Decode() or PkiAsn1Decode2().
//--------------------------------------------------------------------------
__inline
void
WINAPI
PkiAsn1FreeDecoded(
    IN ASN1decoding_t pDec,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id
    )
{
    if (pvAsn1Info)
        ASN1_FreeDecoded(pDec, pvAsn1Info, id);
}

//+-------------------------------------------------------------------------
//  Asn1 Set/Get encoding rule functions
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1SetEncodingRule(
    IN ASN1encoding_t pEnc,
    IN ASN1encodingrule_e eRule
    );

ASN1encodingrule_e
WINAPI
PkiAsn1GetEncodingRule(
    IN ASN1encoding_t pEnc
    );

//+-------------------------------------------------------------------------
//  Asn1 EncodedOid To/From DotVal functions
//--------------------------------------------------------------------------
__inline
LPSTR
WINAPI
PkiAsn1EncodedOidToDotVal(
    IN ASN1decoding_t pDec,
    IN ASN1encodedOID_t *pEncodedOid
    )
{
    LPSTR pszDotVal = NULL;
    if (ASN1BEREoid2DotVal(pDec, pEncodedOid, &pszDotVal))
        return pszDotVal;
    else
        return NULL;
}

__inline
void
WINAPI
PkiAsn1FreeDotVal(
    IN ASN1decoding_t pDec,
    IN LPSTR pszDotVal
    )
{
    if (pszDotVal)
        ASN1Free(pszDotVal);
}

// Returns nonzero for success
__inline
int
WINAPI
PkiAsn1DotValToEncodedOid(
    IN ASN1encoding_t pEnc,
    IN LPSTR pszDotVal,
    OUT ASN1encodedOID_t *pEncodedOid
    )
{
    return ASN1BERDotVal2Eoid(pEnc, pszDotVal, pEncodedOid);
}

__inline
void
WINAPI
PkiAsn1FreeEncodedOid(
    IN ASN1encoding_t pEnc,
    IN ASN1encodedOID_t *pEncodedOid
    )
{
    if (pEncodedOid->value)
        ASN1_FreeEncoded(pEnc, pEncodedOid->value);
}

//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes in place
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1ReverseBytes(
			IN OUT PBYTE pbIn,
			IN DWORD cbIn
            );


//+-------------------------------------------------------------------------
//  Encode an ASN1 formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1EncodeInfo(
        IN ASN1encoding_t pEnc,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info,
        OUT OPTIONAL BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );

//+-------------------------------------------------------------------------
//  Decode into an allocated, ASN1 formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1DecodeAndAllocInfo(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT void **ppvAsn1Info
        );

//+-------------------------------------------------------------------------
//  Free an allocated, ASN1 formatted info structure
//--------------------------------------------------------------------------
__inline
void
WINAPI
PkiAsn1FreeInfo(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info
        )
{
    if (pvAsn1Info)
        ASN1_FreeDecoded(pDec, pvAsn1Info, id);
}

//+-------------------------------------------------------------------------
//  Encode an ASN1 formatted info structure.
//
//  If CRYPT_ENCODE_ALLOC_FLAG is set, allocate memory for pbEncoded and
//  return *((BYTE **) pvEncoded) = pbAllocEncoded. Otherwise,
//  pvEncoded points to byte array to be updated.
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1EncodeInfoEx(
        IN ASN1encoding_t pEnc,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );

typedef BOOL (WINAPI *PFN_PKI_ASN1_DECODE_EX_CALLBACK)(
    IN void *pvAsn1Info,
    IN DWORD dwFlags,
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
    OUT OPTIONAL void *pvStructInfo,
    IN OUT LONG *plRemainExtra
    );

//+-------------------------------------------------------------------------
//  Call the callback to convert the ASN1 structure into the 'C' structure.
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1AllocStructInfoEx(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

//+-------------------------------------------------------------------------
//  Decode the ASN1 formatted info structure and call the callback
//  function to convert the ASN1 structure to the 'C' structure.
//
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1DecodeAndAllocInfoEx(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

//+-------------------------------------------------------------------------
//  Convert the ascii string ("1.2.9999") to ASN1's Object Identifier
//  represented as an array of unsigned longs.
//
//  Returns TRUE for a successful conversion. 
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1ToObjectIdentifier(
    IN LPCSTR pszObjId,
    IN OUT ASN1uint16_t *pCount,
    OUT ASN1uint32_t rgulValue[]
    );

//+-------------------------------------------------------------------------
//  Convert from OSS's Object Identifier represented as an array of
//  unsigned longs to an ascii string ("1.2.9999").
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1FromObjectIdentifier(
    IN ASN1uint16_t Count,
    IN ASN1uint32_t rgulValue[],
    OUT LPSTR pszObjId,
    IN OUT DWORD *pcbObjId
    );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\inc\pkialloc.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1998
//
//  File:       pkialloc.h
//
//  Contents:   PKI Allocation Functions
//
//  APIs: 
//              PkiAlloc
//
//  History:    19-Jan-98    philh   created
//--------------------------------------------------------------------------

#ifndef __PKIALLOC_H__
#define __PKIALLOC_H__

#include <wincrypt.h>

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  The following functions use the 'C' runtime's allocation functions
//  when DBG is defined.  Otherwise, use LocalAlloc, LocalReAlloc or
//  LocalFree Win32 APIs.
//--------------------------------------------------------------------------

// Calls malloc when DBG is defined. Otherwise, does a
// ZEROINIT LocalAlloc.
LPVOID
WINAPI
PkiAlloc(
    IN UINT cbBytes
    );

// Calls malloc and does a memory clear when DBG is defined.
// Otherwise, does a ZEROINIT LocalAlloc.
LPVOID
WINAPI
PkiZeroAlloc(
    IN UINT cbBytes
    );

// Calls malloc when DBG is defined. Otherwise, does a
// LocalAlloc without ZEOINIT.
LPVOID
WINAPI
PkiNonzeroAlloc(
    IN UINT cbBytes
    );

LPVOID
WINAPI
PkiRealloc(
    IN LPVOID pvOrg,
    IN UINT cbBytes
    );

VOID
WINAPI
PkiFree(
    IN LPVOID pv
    );

//+-------------------------------------------------------------------------
//  The following functions always use LocalAlloc and LocalFree Win32 APIs.
//--------------------------------------------------------------------------
LPVOID
WINAPI
PkiDefaultCryptAlloc(
    IN UINT cbSize
    );
VOID
WINAPI
PkiDefaultCryptFree(
    IN LPVOID pv
    );

//+-------------------------------------------------------------------------
//  The following data structure's pfnAlloc and pfnFree are set to
//  PkiNonzeroAlloc and PkiFree.
//--------------------------------------------------------------------------
extern CRYPT_ENCODE_PARA PkiEncodePara;

//+-------------------------------------------------------------------------
//  If pfnAlloc isn't defined, returns PkiDefaultCryptAlloc
//--------------------------------------------------------------------------
PFN_CRYPT_ALLOC
WINAPI
PkiGetEncodeAllocFunction(
    IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara
    );

//+-------------------------------------------------------------------------
//  If pfnFree isn't defined, returns PkiDefaultCryptFree
//--------------------------------------------------------------------------
PFN_CRYPT_FREE
WINAPI
PkiGetEncodeFreeFunction(
    IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara
    );

//+-------------------------------------------------------------------------
//  The following data structure's pfnAlloc and pfnFree are set to
//  PkiNonzeroAlloc and PkiFree.
//--------------------------------------------------------------------------
extern CRYPT_DECODE_PARA PkiDecodePara;

//+-------------------------------------------------------------------------
//  If pfnAlloc isn't defined, returns PkiDefaultCryptAlloc
//--------------------------------------------------------------------------
PFN_CRYPT_ALLOC
WINAPI
PkiGetDecodeAllocFunction(
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara
    );

//+-------------------------------------------------------------------------
//  If pfnFree isn't defined, returns PkiDefaultCryptFree
//--------------------------------------------------------------------------
PFN_CRYPT_FREE
WINAPI
PkiGetDecodeFreeFunction(
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara
    );


#ifdef __cplusplus
}       // Balance extern "C" above
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\inc\protos.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       protos.h
//
//  Contents:   
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   LSA integration stuff.
//
//----------------------------------------------------------------------------

SP_STATUS GetDefaultIssuers(
    PBYTE pbIssuers,        // out
    DWORD *pcbIssuers);     // in, out

BOOL GenerateKeyPair(
    PSSL_CREDENTIAL_CERTIFICATE pCert,
    PSTR pszDN,
    PSTR pszPassword,
    DWORD Bits );

BOOL LoadCertificate(
    PUCHAR      pbCertificate,
    DWORD       cbCertificate,
    BOOL        AddToWellKnownKeys);

BOOL SchannelInit(BOOL fAppProcess);
BOOL SchannelShutdown(VOID);

BOOL
SslGetClientProcess(ULONG *pProcessID);

BOOL
SslGetClientThread(ULONG *pThreadID);

BOOL
SslImpersonateClient(void);

NTSTATUS
SslGetClientLogonId(LUID *pLogonId);

PVOID SPExternalAlloc(DWORD cbLength);
VOID  SPExternalFree(PVOID pMemory);

extern HANDLE               g_hInstance;
extern RTL_CRITICAL_SECTION g_InitCritSec;
extern BOOL                 g_fSchannelInitialized;

extern BOOL SslGlobalStrongEncryptionPermitted;

// Pointer to FreeContextBuffer:SECUR32.DLL
extern FREE_CONTEXT_BUFFER_FN g_pFreeContextBuffer;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\inc\scrypt.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       scrypt.h
//
//  Contents:
//
//	Definition of public key and other defines for selective financial
//	application crypto.
//
//  Classes:
//
//  Functions:
//
//  History:    5-12-96
//
//----------------------------------------------------------------------------

#ifdef ENABLE_SELECTIVE_CRYPTO

#ifndef __SCCRYPT_H__
#define __SCCRYPT_H__

#define MAX_PATH_LEN		256
#define MAX_CERT_LEN		256

#define SC_REG_KEY_BASE		TEXT("System\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\ApprovedApps")

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\inc\sigsys.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       sigsys.h
//
//  Contents:   
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   LSA integration stuff.
//              10-21-96   jbanes   CAPI integration.
//
//----------------------------------------------------------------------------

#ifndef __SIGSYS_H__
#define __SIGSYS_H__

SP_STATUS 
SPVerifySignature(
    HCRYPTPROV  hProv,
    DWORD       dwCapiFlags,
    PPUBLICKEY  pPublic,
    ALG_ID      aiHash,
    PBYTE       pbData, 
    DWORD       cbData, 
    PBYTE       pbSig, 
    DWORD       cbSig,
    BOOL        fHashData);

SP_STATUS
SignHashUsingCred(
    PSPCredential pCred,
    ALG_ID        aiHash,
    PBYTE         pbHash,
    DWORD         cbHash,
    PBYTE         pbSignature,
    PDWORD        pcbSignature);

#endif /* __SIGSYS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\inc\specmap.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       specmap.h
//
//  Contents:   
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   Ported over SGC stuff from NT 4 tree.
//
//----------------------------------------------------------------------------

struct _SPContext;

typedef struct csel 
{
    DWORD               fProtocol;
    DWORD               fDefault;
    PSTR                szName;
    ALG_ID              aiCipher;
    DWORD               dwBlockSize;        // bytes
    DWORD               dwStrength;         // key strength in bits
    DWORD               cbKey;              // required key material
    DWORD               cbSecret;           // bytes of secret key material
    DWORD               dwFlags;            // See flags field
} CipherInfo, *PCipherInfo;

#define CF_EXPORT       0x00000001          // This cipher is allowed for export use
#define CF_DOMESTIC     0x00000002          // This cipher is for domestic use only
#define CF_SGC          0x00000004          // This cipher is allowed with Server Gated Crypto
#define CF_FINANCE      0x00000008          // This cipher is allowed with SELECTIVE CRYPTO
#define CF_FASTSGC      0x00000010          // This indicates that the SGC type is fast


typedef struct hsel 
{
    DWORD               fProtocol;
    DWORD               fDefault;
    PSTR                szName;
    ALG_ID              aiHash;
    DWORD               cbCheckSum;         // bytes
} HashInfo, *PHashInfo;

typedef struct sigsel 
{
    DWORD               fProtocol;
    DWORD               fDefault;
    SigSpec             Spec;
    PSTR                szName;

    ALG_ID              aiHash;
    ALG_ID              aiSig;
} SigInfo, *PSigInfo;


typedef struct kexch 
{
    ALG_ID              aiExch;
    DWORD               fProtocol;
    DWORD               fDefault;
    ExchSpec            Spec;
    PSTR                szName;
    KeyExchangeSystem * System;

} KeyExchangeInfo, *PKeyExchangeInfo;

typedef struct certsel 
{
    DWORD               fProtocol;
    DWORD               fDefault;
    CertSpec            Spec;
    PSTR                szName;
} CertSysInfo, *PCertSysInfo;



PCipherInfo         GetCipherInfo(ALG_ID aiCipher, DWORD dwStrength);

PHashInfo           GetHashInfo(ALG_ID aiHash);

PKeyExchangeInfo    GetKeyExchangeInfo(ExchSpec Spec);

PKeyExchangeInfo    GetKeyExchangeInfoByAlg(ALG_ID aiExch);

PCertSysInfo        GetCertSysInfo(CertSpec Spec);

PSigInfo            GetSigInfo(SigSpec Spec);


KeyExchangeSystem * KeyExchangeFromSpec(ExchSpec Spec, DWORD fProtocol);

BOOL GetBaseCipherSizes(DWORD *dwMin, DWORD *dwMax);

void 
GetDisplayCipherSizes(
    PSPCredentialGroup pCredGroup,
    DWORD *dwMin, 
    DWORD *dwMax);

BOOL IsCipherAllowed(
    SPContext * pContext, 
    PCipherInfo pCipher, 
    DWORD       dwProtocol,
    DWORD       dwFlags);

BOOL 
IsCipherSuiteAllowed(
    PSPContext  pContext, 
    PCipherInfo pCipher, 
    DWORD       dwProtocol,
    DWORD       dwFlags,
    DWORD       dwSuiteFlags);

BOOL IsHashAllowed(
    SPContext * pContext, 
    PHashInfo   pHash,
    DWORD       dwProtocol);

BOOL IsExchAllowed(
    SPContext *      pContext, 
    PKeyExchangeInfo pExch,
    DWORD            dwProtocol);

BOOL IsAlgAllowed(
    PSPCredentialGroup pCred, 
    ALG_ID aiAlg);

BOOL BuildAlgList(PSPCredentialGroup pCred, ALG_ID *aalgRequestedAlgs, DWORD cRequestedAlgs);

BOOL
IsAlgSupportedCapi(
    DWORD               dwProtocol, 
    UNICipherMap *      pCipherMap,
    PROV_ENUMALGS_EX *  pCapiAlgs,
    DWORD               cCapiAlgs);

extern CipherInfo  g_AvailableCiphers[];
extern DWORD       g_cAvailableCiphers;

extern HashInfo    g_AvailableHashes[];
extern DWORD       g_cAvailableHashes;

extern CertSysInfo g_AvailableCerts[];
extern DWORD       g_cAvailableCerts;

extern SigInfo     g_AvailableSigs[];
extern DWORD       g_cAvailableSigs;

extern KeyExchangeInfo g_AvailableExch[];
extern DWORD           g_cAvailableExch;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\inc\spbasei.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       spbase.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   LSA integration stuff.
//
//----------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <winsock2.h>
#include <wchar.h>
#include <wincrypt.h>
#include <lmcons.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

#define SECURITY_PACKAGE
#define _SSL_WSP_
#define MULTI_THREADED
#define SECURITY_WIN32
#include "schannel.h"
#include <security.h>
#include <spseal.h>
#include <sspi.h>
#include <wincred.h>
#include <secint.h>

/*
///////////////////////////////////////////////////////
//
// Private Headers
//
///////////////////////////////////////////////////////
*/

#include "spreg.h"
#include "debug.h"

#include "sperr.h"
#include "spdefs.h"

#include "keyexch.h"

#include <certmap.h>
#include "cred.h"
#include "sigsys.h"
#include "protocol.h"
#include "specmap.h"
#include "cache.h"
#include "context.h"
#include "cert.h"
#include "defcreds.h"
#include "protos.h"
#include "rng.h"
#include "callback.h"
#include "capi.h"
#include "events.h"

#include "encode.h"

#include <ssl2msg.h>
#include <pct1msg.h>
#include <ssl3msg.h>
#include <ssl3key.h>
#include <tls1key.h>
#include <pct1prot.h>
#include <ssl2prot.h>

#include <sha.h>
#include <md2.h>
#include <rc2.h>
#include <rc4.h>

extern PLSA_SECPKG_FUNCTION_TABLE LsaTable;

#define PCT_INVALID_MAGIC       *(DWORD *)"eerF"

#if DBG

    void SPAssert(
        void *FailedAssertion,
        void *FileName,
        unsigned long LineNumber,
        char * Message);

    #define SP_ASSERT(x) \
            if (!(x)) \
            SPAssert(#x, __FILE__, __LINE__, NULL); else

#else // DBG

    #define SP_ASSERT(x)

#endif // DBG

#ifdef __cplusplus
}
#endif


#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\inc\rng.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       rng.h
//
//  Contents:   
//
//  Classes:
//
//  Functions:
//
//  History:    11-05-97   jbanes   Modified to use static rsaenh.dll.
//
//----------------------------------------------------------------------------

VOID
GenerateRandomBits(
    PUCHAR      pRandomData,
    ULONG       cRandomData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\inc\spdefs.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       spdefs.h
//
//  Contents:   
//
//  Classes:
//
//  Functions:
//
//  History:    10-23-97   jbanes   Added hash lengths.
//
//----------------------------------------------------------------------------

#define CALG_NULLCIPHER     (ALG_CLASS_DATA_ENCRYPT | ALG_TYPE_ANY | 0)

/* keyexchange algs */
#define SP_EXCH_RSA_PKCS1              0x0001
#define SP_EXCH_RSA_PKCS1_TOKEN_DES     0x0002
#define SP_EXCH_RSA_PKCS1_TOKEN_DES3    0x0003
#define SP_EXCH_RSA_PKCS1_TOKEN_RC2     0x0004
#define SP_EXCH_RSA_PKCS1_TOKEN_RC4     0x0005

#define SP_EXCH_DH_PKCS3                0x0006
#define SP_EXCH_DH_PKCS3_TOKEN_DES      0x0007
#define SP_EXCH_DH_PKCS3_TOKEN_DES3     0x0008
#define SP_EXCH_FORTEZZA_TOKEN          0x0009

#define SP_EXCH_UNKNOWN                 0xffff

/* certificate types */
#define PCT1_CERT_NONE                  0x0000
#define PCT1_CERT_X509                  0x0001
#define PCT1_CERT_PKCS7                 0x0002

/* signature algorithms */
#define SP_SIG_NONE               0x0000
#define SP_SIG_RSA_MD5                0x0001
#define SP_SIG_RSA_SHA                  0x0002
#define SP_SIG_DSA_SHA                  0x0003

/* these are for internal use only */
#define SP_SIG_RSA_MD2              0x0004
#define SP_SIG_RSA                      0x0005
#define SP_SIG_RSA_SHAMD5               0x0006
#define SP_SIG_FORTEZZA_TOKEN           0x0007


/* sizing of local structures */
#define SP_MAX_SESSION_ID           32
#define SP_MAX_MASTER_KEY           48
#define SP_MAX_MAC_KEY              48
#define SP_MAX_CACHE_ID             64
#define SP_MAX_CHALLENGE            32
#define SP_MAX_CONNECTION_ID        32
#define SP_MAX_KEY_ARGS             32
#define SP_MAX_BLOCKCIPHER_SIZE     16      // 16 bytes required for SSL3/Fortezza.
#define SP_MAX_DIGEST_LEN           32
#define SP_MAX_CREDS                20

#define SP_OFFSET_OF(t, v) (DWORD)&(((t)NULL)->v)
/* tuning constants */

#define SP_DEF_SERVER_CACHE_SIZE        100
#define SP_DEF_CLIENT_CACHE_SIZE        10

#define SP_MIN_PRIVATE_KEY_FILE_SIZE    80

typedef DWORD SP_STATUS;

#define CB_MD5_DIGEST_LEN   16
#define CB_SHA_DIGEST_LEN   20

#define SP_MAX_CAPI_ALGS    40


/* internal representations of algorithm specs */

typedef DWORD   CipherSpec, *PCipherSpec;
typedef DWORD   KeyExchangeSpec, *PKeyExchangeSpec;
typedef DWORD   HashSpec,   *PHashSpec;
typedef DWORD   CertSpec,   *PCertSpec;
typedef DWORD   ExchSpec,   *PExchSpec;
typedef DWORD   SigSpec,    *PSigSpec;


typedef struct _KeyTypeMap
{
    ALG_ID aiKeyAlg;             // CAPI2 Key type
    DWORD  Spec;     // Protocol Specific Type
} KeyTypeMap, *PKeyTypeMap;

typedef struct _CertTypeMap
{
    DWORD  dwCertEncodingType;             // CAPI2 Cert Encoding Type
    DWORD  Spec;     // Protocol Specific Type
} CertTypeMap, *PCertTypeMap;


typedef struct _SPBuffer {
    unsigned long cbBuffer;             /* Size of the buffer, in bytes */
    unsigned long cbData;               /* size of the actual data in the 
                                         * buffer, in bytes */
    void * pvBuffer;                    /* Pointer to the buffer */
} SPBuffer, * PSPBuffer;

#define SGC_KEY_SALT "SGCKEYSALT"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\inc\spreg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       spreg.h
//
//  Contents:   
//
//  Classes:
//
//  Functions:
//
//  History:    12-02-97   jbanes   Remove CertificateAuthorities entry.
//
//----------------------------------------------------------------------------

#ifndef _SPREG_H_
#define _SPREG_H_

/*
 *[HKEY_LOCAL_MACHINE]
 *   [System]
 *       [CurrentControlSet]
 *           [Control]
 *               [SecurityProviders]
 *                   [SCHANNEL]
 *                       EventLogging:REG_DWORD:   - Flag specifing event logging level
 *                       LogFile:REG_SZ:           - debug logfile name (Not published)
 *                       LogLevel:REG_SZ:          - debug logging level flags.
 *                       DebugBreak:REG_DWORD:     - Flag specifing what type of errors cause a debug break (Not published)
 *                       MaximumCacheSize:REG_DWORD - maximum number of cache elements
 *                       ClientCacheTime:REG_DWORD - time to expire client side cache elements
 *                       ServerCacheTime:REG_DWORD - time to expire server side cache elements
 *                       MultipleProcessClientCache:REG_DWORD - whether to support multi-process caching
 *
 *                       [Protocols]
 *                           [Unified Hello
 *                               [Client]
 *                                  Enabled:REG_DWORD: - Is this protocol enabled
 *                               [Server]
 *                                  Enabled:REG_DWORD: - Is this protocol enabled                          [SSL2]
 *                           [SSL2]
 *                               [Client]
 *                                  Enabled:REG_DWORD: - Is this protocol enabled
 *                               [Server]
 *                                  Enabled:REG_DWORD: - Is this protocol enabled                          [SSL2]
 *                           [SSL3]
 *                               [Client]
 *                                  Enabled:REG_DWORD: - Is this protocol enabled
 *                               [Server]
 *                                  Enabled:REG_DWORD: - Is this protocol enabled
 *                           [PCT1]
 *                               [Client]
 *                                  Enabled:REG_DWORD: - Is this protocol enabled
 *                               [Server]
 *                                  Enabled:REG_DWORD: - Is this protocol enabled
 *
 *                       [Ciphers]
 *                           [Cipher Name]
 *                               Enabled:REG_DWORD: - Enable Mask
 *                           [RC4_128]
 *                               Enabled:REG_DWORD: - Is this Ciphers enabled
 *                       [Hashes]
 *                           [Hash Name]
 *                               Enabled:REG_DWORD: - Enable Mask
 *                       [KeyExchangeAlgorithms]
 *                           [Exch Name]
 *                               Enabled:REG_DWORD: - Enable Mask
 *
 */

// FIPS registry entries
#define SP_REG_FIPS_BASE_KEY    TEXT("System\\CurrentControlSet\\Control\\Lsa")
#define SP_REG_FIPS_POLICY      TEXT("FipsAlgorithmPolicy")

/* Key Names */
#define SP_REG_KEY_BASE     TEXT("System\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL")
#define SP_REG_KEY_PROTOCOL TEXT("Protocols")
#define SP_REG_KEY_CIPHERS  TEXT("Ciphers")
#define SP_REG_KEY_HASHES   TEXT("Hashes")
#define SP_REG_KEY_KEYEXCH  TEXT("KeyExchangeAlgorithms")

/* Value Names */
#define SP_REG_VAL_EVENTLOG  TEXT("EventLogging")
#define SP_REG_VAL_LOGFILE   "LogFile"
#define SP_REG_VAL_LOGLEVEL  TEXT("LogLevel")
#define SP_REG_VAL_BREAK     TEXT("DebugBreak")
#define SP_REG_VAL_MANUAL_CRED_VALIDATION TEXT("ManualCredValidation")
#define SP_REG_VAL_DISABLED_BY_DEFAULT TEXT("DisabledByDefault")
#define SP_REG_VAL_MULTI_PROC_CLIENT_CACHE TEXT("MultipleProcessClientCache")

#define SP_REG_VAL_MAXUMUM_CACHE_SIZE  TEXT("MaximumCacheSize")
#define SP_REG_VAL_CLIENT_CACHE_TIME   TEXT("ClientCacheTime")
#define SP_REG_VAL_SERVER_CACHE_TIME   TEXT("ServerCacheTime")
#define SP_REG_VAL_RNG_SEED            TEXT("RNGSeed")

#define SP_REG_VAL_ENABLED   TEXT("Enabled")
#define SP_REG_VAL_CACERT    TEXT("CACert")
#define SP_REG_VAL_CERT_TYPE TEXT("Type")

#define SP_REG_VAL_SERVER_TIMEOUT   TEXT("ServerHandshakeTimeout")

#define SP_REG_KEY_CLIENT    TEXT("Client")
#define SP_REG_KEY_SERVER    TEXT("Server")

#define SP_REG_KEY_PCT1      TEXT("PCT 1.0")
#define SP_REG_KEY_SSL2      TEXT("SSL 2.0")
#define SP_REG_KEY_SSL3      TEXT("SSL 3.0")
#define SP_REG_KEY_TLS1      TEXT("TLS 1.0")
#define SP_REG_KEY_UNIHELLO  TEXT("Multi-Protocol Unified Hello") 

#define MANUAL_CRED_VALIDATION_SETTING      FALSE
#define PCT_CLIENT_DISABLED_SETTING         TRUE
#define SSL2_CLIENT_DISABLED_SETTING        FALSE
#define DEFAULT_EVENT_LOGGING_SETTING       DEB_ERROR
#define DEFAULT_ENABLED_PROTOCOLS_SETTING   SP_PROT_ALL

extern BOOL g_fManualCredValidation;

extern BOOL g_PctClientDisabledByDefault;
extern BOOL g_Ssl2ClientDisabledByDefault;

extern BOOL g_fFranceLocale;

BOOL SPLoadRegOptions(void);
void SPUnloadRegOptions(void);


/* Event Logging Definitions */
#define SP_EVLOG_RESOURCE           0x0001
#define SP_EVLOG_ASSERT             0x0002
#define SP_EVLOG_ILLEGAL_MESSAGE    0x0004
#define SP_EVLOG_SECAUDIT           0x0008


#define SP_LOG_ERROR                0x0001
#define SP_LOG_WARNING              0x0002
#define SP_LOG_TRACE                0x0004
#define SP_LOG_ALLOC                0x0008
#define SP_LOG_RES                  0x0010

#define SP_LOG_TIMESTAMP            0x20000000
#define SP_LOG_BUFFERS              0x40000000
#define SP_LOG_FILE                 0x80000000

#define SP_BREAK_ERROR              0x0001
#define SP_BREAK_WARNING            0x0002
#define SP_BREAK_ENTRY              0x0004

#endif // _SPREG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\inc\spverp.h ===
#define VER_SCHANNEL 1600
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\inc\sperr.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       sperr.c
//
//  Contents:   Schannel internal error codes.
//
//  Classes:
//
//  Functions:
//
//  History:    
//
//----------------------------------------------------------------------------


/* We really have to straighten out
 * the error message situation */
/* basic error codes, for transmission over the 
 * communications channel */
#define PCT_ERR_OK                      0x0000
#define PCT_ERR_BAD_CERTIFICATE         0x0001
#define PCT_ERR_CLIENT_AUTH_FAILED      0x0002
#define PCT_ERR_ILLEGAL_MESSAGE         0x0003
#define PCT_ERR_INTEGRITY_CHECK_FAILED  0x0004
#define PCT_ERR_SERVER_AUTH_FAILED      0x0005
#define PCT_ERR_SPECS_MISMATCH          0x0006
#define PCT_ERR_SSL_STYLE_MSG           0x00ff
#define PCT_ERR_RENEGOTIATE             0x0008
#define PCT_ERR_UNKNOWN_CREDENTIAL      0x0009
#define PCT_ERR_EXPIRED                 0x000a

/* internal error codes, for communications with
 * the application */
#define PCT_INT_BUFF_TOO_SMALL          0x40000000
#define PCT_INT_INCOMPLETE_MSG          0x40000001  /* this specifies to the comm layer to pass
                                                     * more data */

#define PCT_INT_DROP_CONNECTION    0x80000000
#define PCT_INT_BAD_CERT           (PCT_INT_DROP_CONNECTION | PCT_ERR_BAD_CERTIFICATE)
#define PCT_INT_CLI_AUTH           (PCT_INT_DROP_CONNECTION | PCT_ERR_CLIENT_AUTH_FAILED)
#define PCT_INT_ILLEGAL_MSG        (PCT_INT_DROP_CONNECTION | PCT_ERR_ILLEGAL_MESSAGE)
#define PCT_INT_MSG_ALTERED        0x80000101
#define PCT_INT_INTERNAL_ERROR     0xffffffff
#define PCT_INT_DATA_OVERFLOW      0x80000102
#define PCT_INT_SPECS_MISMATCH     (PCT_INT_DROP_CONNECTION | PCT_ERR_SPECS_MISMATCH)
#define PCT_INT_RENEGOTIATE        (PCT_INT_DROP_CONNECTION | PCT_ERR_RENEGOTIATE)
#define PCT_INT_UNKNOWN_CREDENTIAL (PCT_INT_DROP_CONNECTION | PCT_ERR_UNKNOWN_CREDENTIAL)
#define PCT_INT_EXPIRED            (PCT_INT_DROP_CONNECTION | PCT_ERR_EXPIRED)

#define SP_FATAL(s) (PCT_INT_DROP_CONNECTION & (s))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\inc\ssl2msg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       msgs.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8-02-95   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __SSL2MSG_H__
#define __SSL2MSG_H__

typedef struct _Ssl2_Cipher_Tuple {
    UCHAR   C1;
    UCHAR   C2;
    UCHAR   C3;
} Ssl2_Cipher_Tuple, * PSsl2_Cipher_Tuple;

///////////////////////////////////////////////////////////////////
//
// Useful Macros
//
///////////////////////////////////////////////////////////////////

#define LSBOF(x)    ((UCHAR) ((x) & 0xFF))
#define MSBOF(x)    ((UCHAR) (((x) >> 8) & 0xFF) )

#define COMBINEBYTES(Msb, Lsb)  ((DWORD) (((DWORD) (Msb) << 8) | (DWORD) (Lsb)))



///////////////////////////////////////////////////////////////////
//
// Message Constants
//
///////////////////////////////////////////////////////////////////

#define SSL2_CLIENT_VERSION          0x0002
#define SSL2_SERVER_VERSION          0x0002

#define SSL2_CLIENT_VERSION_MSB      0x00
#define SSL2_CLIENT_VERSION_LSB      0x02

#define SSL2_SERVER_VERSION_MSB      0x00
#define SSL2_SERVER_VERSION_LSB      0x02

#ifdef DO_PCT_COMPAT
#define PCT_COMPAT_VERSION_MSB    0x83
#define PCT_COMPAT_VERSION_LSB    0x01
#endif

#define SSL2_MT_ERROR                0
#define SSL2_MT_CLIENT_HELLO         1
#define SSL2_MT_CLIENT_MASTER_KEY    2
#define SSL2_MT_CLIENT_FINISHED_V2   3
#define SSL2_MT_SERVER_HELLO         4
#define SSL2_MT_SERVER_VERIFY        5
#define SSL2_MT_SERVER_FINISHED_V2   6
#define SSL2_MT_REQUEST_CERTIFICATE  7
#define SSL2_MT_CLIENT_CERTIFICATE   8
#define SSL2_MT_CLIENT_DH_KEY        9
#define SSL2_MT_CLIENT_SESSION_KEY   10
#define SSL2_MT_CLIENT_FINISHED      11
#define SSL2_MT_SERVER_FINISHED      12

#define SSL_PE_NO_CIPHER            0x0001
#define SSL_PE_NO_CERTIFICATE       0x0002
#define SSL_PE_BAD_CERTIFICATE      0x0004
#define SSL_PE_UNSUPPORTED_CERTIFICATE_TYPE 0x0006


#define SSL_CT_X509_CERTIFICATE     0x01
#define SSL_CT_PKCS7_CERTIFICATE    0x02

#if DBG
#define SSL_CT_DEBUG_CERT           0x80
#endif

#define SSL2_MAX_CHALLENGE_LEN       32  /* max accepted challenge size */
#define SSL2_CHALLENGE_SIZE          16  /* default generated challenge size */
#define SSL2_SESSION_ID_LEN          16
#define SSL2_GEN_CONNECTION_ID_LEN   16  /* Dont change this, netscape requires 16 byte
                                          * id's */
#define SSL2_MAX_CONNECTION_ID_LEN   32
#define SSL3_SESSION_ID_LEN    32
#define SSL2_MAC_LENGTH              16
#define SSL2_MASTER_KEY_SIZE         16
#define SSL2_MAX_KEY_ARGS            8
#define SSL2_MAX_MESSAGE_LENGTH     32768
#define MAX_UNI_CIPHERS             64

#define SSL_MKFAST(a, b, c) (DWORD)(((a)<<16) | ((b)<<8) | (c))

#define SSL_MKSLOW(a) (UCHAR)((a>>16)& 0xff), (UCHAR)((a>>8)& 0xff), (UCHAR)((a)& 0xff)

#define SSL_RSA_WITH_RC4_128_MD5                SSL_MKFAST(0x00, 0x00,  0x04)
#define SSL_RSA_EXPORT_WITH_RC4_40_MD5          SSL_MKFAST(0x00, 0x00,  0x03)

#define SSL_CK_RC4_128_WITH_MD5                 SSL_MKFAST(0x01, 0x00,  0x80)
#define SSL_CK_RC4_128_EXPORT40_WITH_MD5        SSL_MKFAST(0x02, 0x00,  0x80)
#define SSL_CK_RC2_128_CBC_WITH_MD5             SSL_MKFAST(0x03, 0x00,  0x80)
#define SSL_CK_RC2_128_CBC_EXPORT40_WITH_MD5    SSL_MKFAST(0x04, 0x00,  0x80)
#define SSL_CK_IDEA_128_CBC_WITH_MD5            SSL_MKFAST(0x05, 0x00,  0x80)
#define SSL_CK_DES_64_CBC_WITH_MD5              SSL_MKFAST(0x06, 0x00,  0x40)
#define SSL_CK_DES_192_EDE3_CBC_WITH_MD5        SSL_MKFAST(0x07, 0x00,  0xC0)
#define SSL_CK_NULL_WITH_MD5                    SSL_MKFAST(0x00, 0x00,  0x00)
#define SSL_CK_DES_64_CBC_WITH_SHA              SSL_MKFAST(0x06, 0x01,  0x40)
#define SSL_CK_DES_192_EDE3_WITH_SHA            SSL_MKFAST(0x07, 0x01,  0xC0)

#define SSL_CK_RC4_128_FINANCE64_WITH_MD5       SSL_MKFAST(0x08, 0x00, 0x80)

#ifdef ENABLE_NONE_CIPHER
#define SSL_CK_NONE                             SSL_MKFAST(0x09, 0x00,  0x00)
#endif



#define SSL_KEA_RSA                             {(UCHAR) 0x10, (UCHAR) 0x00, (UCHAR) 0x00}
#define SSL_KEA_RSA_TOKEN_WITH_DES              {(UCHAR) 0x10, (UCHAR) 0x01, (UCHAR) 0x00}
#define SSL_KEA_RSA_TOKEN_WITH_DES_EDE3         {(UCHAR) 0x10, (UCHAR) 0x01, (UCHAR) 0x01}
#define SSL_KEA_RSA_TOKEN_WITH_RC4              {(UCHAR) 0x10, (UCHAR) 0x01, (UCHAR) 0x02}
#define SSL_KEA_DH                              {(UCHAR) 0x11, (UCHAR) 0x00, (UCHAR) 0x00}
#define SSL_KEA_DH_TOKEN_WITH_DES               {(UCHAR) 0x11, (UCHAR) 0x01, (UCHAR) 0x00}
#define SSL_KEA_DH_TOKEN_WITH_DES_EDE3          {(UCHAR) 0x11, (UCHAR) 0x01, (UCHAR) 0x01}
#define SSL_KEA_DH_ANON                         {(UCHAR) 0x12, (UCHAR) 0x00, (UCHAR) 0x00}

#define CRYPTO_RC4_128  0x00010080
#define CRYPTO_RC4_40   0x00020080
#define CRYPTO_RC2_128  0x00030080
#define CRYPTO_RC2_40   0x00040080
#define CRYPTO_IDEA_128 0x00050080
#define CRYPTO_NULL     0x00000000
#define CRYPTO_DES_64   0x00060040
#define CRYPTO_3DES_192 0x000700C0


extern CertTypeMap aSsl2CertEncodingPref[];
extern DWORD cSsl2CertEncodingPref;


typedef DWORD Ssl2_Cipher_Kind;

//typedef struct _Ssl2CipherMap {
//    Ssl2_Cipher_Kind  Kind;
//    ALG_ID            aiHash;
//    ALG_ID            aiCipher;
//    DWORD             dwStrength;
//    ExchSpec          KeyExch;
//    ALG_ID            aiKeyAlg;
//} Ssl2CipherMap, *PSsl2CipherMap;


typedef struct _SSL2_MESSAGE_HEADER {
    UCHAR   Byte0;
    UCHAR   Byte1;
} SSL2_MESSAGE_HEADER, * PSSL2_MESSAGE_HEADER;

typedef struct _SSL2_MESSAGE_HEADER_EX {
    UCHAR   Byte0;
    UCHAR   Byte1;
    UCHAR   PaddingSize;
} SSL2_MESSAGE_HEADER_EX, * PSSL2_MESSAGE_HEADER_EX;


typedef struct _SSL2_ERROR {
    SSL2_MESSAGE_HEADER   Header;
    UCHAR               MessageId;
    UCHAR               ErrorMsb;
    UCHAR               ErrorLsb;
} SSL2_ERROR, * PSSL2_ERROR;


typedef struct _SSL2_CLIENT_HELLO {
    SSL2_MESSAGE_HEADER   Header;
    UCHAR               MessageId;
    UCHAR               VersionMsb;
    UCHAR               VersionLsb;
    UCHAR               CipherSpecsLenMsb;
    UCHAR               CipherSpecsLenLsb;
    UCHAR               SessionIdLenMsb;
    UCHAR               SessionIdLenLsb;
    UCHAR               ChallengeLenMsb;
    UCHAR               ChallengeLenLsb;
    UCHAR               VariantData[1];
} SSL2_CLIENT_HELLO, * PSSL2_CLIENT_HELLO;


typedef struct _SSL2_SERVER_HELLO {
    SSL2_MESSAGE_HEADER   Header;
    UCHAR               MessageId;
    UCHAR               SessionIdHit;
    UCHAR               CertificateType;
    UCHAR               ServerVersionMsb;
    UCHAR               ServerVersionLsb;
    UCHAR               CertificateLenMsb;
    UCHAR               CertificateLenLsb;
    UCHAR               CipherSpecsLenMsb;
    UCHAR               CipherSpecsLenLsb;
    UCHAR               ConnectionIdLenMsb;
    UCHAR               ConnectionIdLenLsb;
    UCHAR               VariantData[1];
} SSL2_SERVER_HELLO, * PSSL2_SERVER_HELLO;

typedef struct _SSL2_CLIENT_MASTER_KEY {
    SSL2_MESSAGE_HEADER   Header;
    UCHAR               MessageId;
    Ssl2_Cipher_Tuple    CipherKind;
    UCHAR               ClearKeyLenMsb;
    UCHAR               ClearKeyLenLsb;
    UCHAR               EncryptedKeyLenMsb;
    UCHAR               EncryptedKeyLenLsb;
    UCHAR               KeyArgLenMsb;
    UCHAR               KeyArgLenLsb;
    UCHAR               VariantData[1];
} SSL2_CLIENT_MASTER_KEY, * PSSL2_CLIENT_MASTER_KEY;


typedef struct _SSL2_SERVER_VERIFY {
    UCHAR               MessageId;
    UCHAR               ChallengeData[SSL2_MAX_CHALLENGE_LEN];
} SSL2_SERVER_VERIFY, * PSSL2_SERVER_VERIFY;

typedef struct _SSL2_CLIENT_FINISHED {
    UCHAR               MessageId;
    UCHAR               ConnectionID[SSL2_MAX_CONNECTION_ID_LEN];
} SSL2_CLIENT_FINISHED, * PSSL2_CLIENT_FINISHED;

typedef struct _SSL2_SERVER_FINISHED {
    UCHAR               MessageId;
    UCHAR               SessionID[SSL2_SESSION_ID_LEN];
} SSL2_SERVER_FINISHED, * PSSL2_SERVER_FINISHED;



////////////////////////////////////////////////////
//
// Expanded Form Messages:
//
////////////////////////////////////////////////////

/* Rules for buffer in expanded form */
/* Only things which are going to be allocated
 * anyway, or are created statically are not created
 * as arrays */

typedef DWORD   CipherSpec;
typedef DWORD * PCipherSpec;

typedef struct _Ssl2_Client_Hello {
    DWORD         dwVer;
    DWORD           cCipherSpecs;
    DWORD           cbSessionID;
    DWORD           cbChallenge;
    UCHAR           SessionID[SSL3_SESSION_ID_LEN];   //NOTE: changed to 32 bytes long....
    UCHAR           Challenge[SSL2_MAX_CHALLENGE_LEN];
    Ssl2_Cipher_Kind CipherSpecs[MAX_UNI_CIPHERS]; /* points to static array */
} Ssl2_Client_Hello, * PSsl2_Client_Hello;

typedef struct _Ssl2_Server_Hello {
    DWORD           SessionIdHit;
    DWORD           CertificateType;
    DWORD           cbCertificate;
    DWORD           cCipherSpecs;
    DWORD           cbConnectionID;
    UCHAR           ConnectionID[SSL2_MAX_CONNECTION_ID_LEN];
    PUCHAR          pCertificate;       /* points to pre-created cert */
    Ssl2_Cipher_Kind *    pCipherSpecs; /* points to static array */
} Ssl2_Server_Hello, * PSsl2_Server_Hello;


typedef struct _Ssl2_Client_Master_Key {
    DWORD               ClearKeyLen;
    DWORD               EncryptedKeyLen;
    DWORD               KeyArgLen;
    Ssl2_Cipher_Kind    CipherKind;
    UCHAR               ClearKey[SSL2_MASTER_KEY_SIZE];
    UCHAR  *            pbEncryptedKey;
    UCHAR               KeyArg[SSL2_MASTER_KEY_SIZE];
} Ssl2_Client_Master_Key, * PSsl2_Client_Master_Key;

///////////////////////////////////////////////////
//
// Pickling Prototypes
//
///////////////////////////////////////////////////
SP_STATUS
Ssl2PackClientHello(
    PSsl2_Client_Hello      pCanonical,
    PSPBuffer               pCommOutput);

SP_STATUS
Ssl2UnpackClientHello(
    PSPBuffer          pInput,
    PSsl2_Client_Hello *     ppClient);

SP_STATUS
Ssl2PackServerHello(
    PSsl2_Server_Hello       pCanonical,
    PSPBuffer          pCommOutput);

SP_STATUS
Ssl2UnpackServerHello(
    PSPBuffer          pInput,
    PSsl2_Server_Hello *     ppServer);

SP_STATUS
Ssl2PackClientMasterKey(
    PSsl2_Client_Master_Key      pCanonical,
    PSPBuffer              pCommOutput);

SP_STATUS
Ssl2UnpackClientMasterKey(
    PSPBuffer              pInput,
    PSsl2_Client_Master_Key *    ppClient);



#endif /* __SSL2MSG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\inc\ssl2prot.h ===
#ifndef _SSL2PROT_H_
#define _SSL2PROT_H_

SP_STATUS WINAPI
Ssl2ClientProtocolHandler(
    PSPContext pContext,
    PSPBuffer pCommInput,
    PSPBuffer pCommOutput);

SP_STATUS WINAPI
Ssl2ServerProtocolHandler(
    PSPContext pContext,
    PSPBuffer pCommInput,
    PSPBuffer pCommOutput);

SP_STATUS WINAPI
Ssl3ProtocolHandler(
    PSPContext pContext,
    PSPBuffer pCommInput,
    PSPBuffer pCommOutput);

SP_STATUS WINAPI
Ssl2DecryptHandler(
    PSPContext pContext,
    PSPBuffer pCommInput,
    PSPBuffer pCommOutput);

SP_STATUS WINAPI
GenerateUniHelloMessage(
    PSPContext              pContext,
    Ssl2_Client_Hello *     pHelloMessage,
    DWORD                   fProtocol
    );

SP_STATUS WINAPI
Ssl2GetHeaderSize(
    PSPContext pContext,
    PSPBuffer pCommInput,
    DWORD * pcbHeaderSize);


SP_STATUS WINAPI Ssl2DecryptMessage(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pAppOutput);

SP_STATUS WINAPI Ssl2EncryptMessage(PSPContext pContext,
                             PSPBuffer  pAppInput,
                             PSPBuffer  pCommOutput);

SP_STATUS WINAPI Ssl3DecryptMessage(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pAppOutput);

SP_STATUS WINAPI Ssl3EncryptMessage(PSPContext pContext,
                             PSPBuffer  pAppInput,
                             PSPBuffer  pCommOutput);


SP_STATUS Ssl2SrvHandleClientHello(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSsl2_Client_Hello pHello,
                              PSPBuffer  pCommOutput);


SP_STATUS Ssl2SrvHandleCMKey(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pCommOutput);

SP_STATUS Ssl3SrvHandleCMKey(PSPContext pContext,
                              PUCHAR  pCommInput,
                              DWORD cbMsg,
                              PSPBuffer  pCommOutput);

SP_STATUS Ssl3SrvHandleCMKey(PSPContext pContext,
                              PUCHAR  pCommInput,
                              DWORD cbMsg,
                              PSPBuffer  pCommOutput);

SP_STATUS Ssl2SrvHandleClientFinish(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pCommOutput);

SP_STATUS Ssl2CliHandleServerHello(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSsl2_Server_Hello  pHello,
                              PSPBuffer  pCommOutput);
SP_STATUS Ssl3CliHandleServerHello(PSPContext pContext,
                              PUCHAR  pSrvHello,
                              DWORD cbMessage,
                              PSPBuffer  pCommOutput);

SP_STATUS Ssl2CliHandleServerVerify(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pCommOutput);

SP_STATUS Ssl2CliHandleServerFinish(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pCommOutput);

SP_STATUS Ssl2SrvGenRestart(PSPContext pContext,
                              PSsl2_Client_Hello pHello,
                              PSPBuffer  pCommOutput);


SP_STATUS Ssl2SrvFinishClientRestart(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pCommOutput);

SP_STATUS Ssl2CliHandleServerRestart(PSPContext pContext,
                                   PSPBuffer  pCommInput,
                                   PSsl2_Server_Hello pHello,
                                   PSPBuffer  pCommOutput);

SP_STATUS Ssl2CliFinishRestart(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pCommOutput);

SP_STATUS Ssl2GenCliFinished(PSPContext pContext,
                              PSPBuffer  pCommOutput);

SP_STATUS
Ssl2MakeSessionKeys(PSPContext pContext);


#endif /* _SSL2PROT_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\inc\ssl3key.h ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
*	Owner 			:ramas
*	Date			:4/16/96
*	description		: Main Crypto functions for SSL3
*----------------------------------------------------------------------------*/
#ifndef _SSL3KEY_H_
#define _SSL3KEY_H_

#define CB_SSL3_MAX_MAC_PAD 48
#define CB_SSL3_MD5_MAC_PAD 48
#define CB_SSL3_SHA_MAC_PAD 40

#define PAD1_CONSTANT 0x36
#define PAD2_CONSTANT 0x5c


void 
Ssl3BuildMasterKeys(
    PSPContext pContext, 
    PUCHAR pbPreMaster,
    DWORD  cbPreMaster
);

SP_STATUS
Ssl3MakeMasterKeyBlock(PSPContext pContext);

SP_STATUS
Ssl3MakeWriteSessionKeys(PSPContext pContext);

SP_STATUS
Ssl3MakeReadSessionKeys(PSPContext pContext);


#endif _SSL3KEY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\inc\tls1key.h ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
*   Owner    :ramas
*   Date         :5/03/97
*   description        : Main Crypto functions for TLS1
*----------------------------------------------------------------------------*/
#ifndef _TLS1KEY_H_
#define _TLS1KEY_H_


SP_STATUS
SPBuildTls1FinalFinish(PSPContext pContext, PSPBuffer pBuffer, BOOL fClient);

SP_STATUS
Tls1ComputeMac(
    PSPContext  pContext,
    BOOL        fReadMac,
    PSPBuffer   pClean,
    CHAR        cContentType,
    PBYTE       pbMac,
    DWORD       cbMac);

void
Tls1BuildMasterKeys(
    PSPContext pContext, 
    PUCHAR pbPreMaster,
    DWORD  cbPreMaster
);

SP_STATUS
Tls1MakeMasterKeyBlock(PSPContext pContext);

SP_STATUS
Tls1MakeWriteSessionKeys(PSPContext pContext);

SP_STATUS
Tls1MakeReadSessionKeys(PSPContext pContext);


#define TLS1_LABEL_SERVER_WRITE_KEY     "server write key"
#define TLS1_LABEL_CLIENT_WRITE_KEY     "client write key"
#define CB_TLS1_WRITEKEY                16
#define TLS1_LABEL_MASTERSECRET         "master secret"
#define CB_TLS1_MASTERSECRET            13
#define TLS1_LABEL_KEYEXPANSION         "key expansion"
#define CB_TLS1_KEYEXPANSION            13 
#define TLS1_LABEL_IVBLOCK              "IV block"
#define CB_TLS1_IVBLOCK                 8
#define TLS1_LABEL_CLIENTFINISHED       "client finished"
#define TLS1_LABEL_SERVERFINISHED       "server finished"
#define CB_TLS1_LABEL_FINISHED          15
#define CB_TLS1_VERIFYDATA              12

#define TLS1_LABEL_EAP_KEYS             "client EAP encryption"
#define CB_TLS1_LABEL_EAP_KEYS          21

#define CBMD5DIGEST    16
#define CBSHADIGEST    20
#define CBBLOCKSIZE    64   //same for MD5 and SHA
#define CHIPAD         0x36
#define CHOPAD         0x5c

static VOID 
ComputeTls1ExportIV(
    PSPContext pContext,
    BOOL fClientWriteIV,
    PBYTE pbIV,
    PDWORD pcbIV);

BOOL PRF(
    PBYTE  pbSecret,
    DWORD  cbSecret, 

    PBYTE  pbLabel,  
    DWORD  cbLabel,
    
    PBYTE  pbSeed,  
    DWORD  cbSeed,  

    PBYTE  pbKeyOut, //Buffer to copy the result...
    DWORD  cbKeyOut  //# of bytes of key length they want as output.
    );

#endif //_TLS1KEY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\inc\sslcache.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-2000.
//
//  File:       sslcache.h
//
//  Contents:   Definitions of functions and data types that can be used 
//              to view and purge the schannel session cache.
//
//  Classes:
//
//  Functions:
//
//----------------------------------------------------------------------------


#ifndef __SSLCACHE_H__
#define __SSLCACHE_H__

//
//  SCHANNEL LsaCallAuthenticationPackage() submission and response
//  message types.
//

#define SSL_PURGE_CLIENT_ENTRIES                    0x00000001
#define SSL_PURGE_SERVER_ENTRIES                    0x00000002
#define SSL_PURGE_CLIENT_ALL_ENTRIES                0x00010000  // test use only
#define SSL_PURGE_SERVER_ALL_ENTRIES                0x00020000  // test use only
#define SSL_PURGE_SERVER_ENTRIES_DISCARD_LOCATORS   0x00040000  // test use only

#define SSL_RETRIEVE_CLIENT_ENTRIES                 0x00000001
#define SSL_RETRIEVE_SERVER_ENTRIES                 0x00000002

typedef struct _UNICODE_STRING_WOW64 
{
    USHORT Length;
    USHORT MaximumLength;
    DWORD  Buffer;
} UNICODE_STRING_WOW64;

// Used to purge entries from the session cache
typedef struct _SSL_PURGE_SESSION_CACHE_REQUEST 
{
    ULONG MessageType;
    LUID LogonId;
    UNICODE_STRING ServerName;
    DWORD Flags;
} SSL_PURGE_SESSION_CACHE_REQUEST, *PSSL_PURGE_SESSION_CACHE_REQUEST;

typedef struct _SSL_PURGE_SESSION_CACHE_REQUEST_WOW64 
{
    ULONG MessageType;
    LUID LogonId;
    UNICODE_STRING_WOW64 ServerName;
    DWORD Flags;
} SSL_PURGE_SESSION_CACHE_REQUEST_WOW64, *PSSL_PURGE_SESSION_CACHE_REQUEST_WOW64;


// Used to request session cache info
typedef struct _SSL_SESSION_CACHE_INFO_REQUEST
{
    ULONG MessageType;
    LUID LogonId;
    UNICODE_STRING ServerName;
    DWORD Flags;
} SSL_SESSION_CACHE_INFO_REQUEST, *PSSL_SESSION_CACHE_INFO_REQUEST;

typedef struct _SSL_SESSION_CACHE_INFO_REQUEST_WOW64
{
    ULONG MessageType;
    LUID LogonId;
    UNICODE_STRING_WOW64 ServerName;
    DWORD Flags;
} SSL_SESSION_CACHE_INFO_REQUEST_WOW64, *PSSL_SESSION_CACHE_INFO_REQUEST_WOW64;

// Used to respond to session cache info request
typedef struct _SSL_SESSION_CACHE_INFO_RESPONSE
{
    DWORD   CacheSize;
    DWORD   Entries;
    DWORD   ActiveEntries;
    DWORD   Zombies;
    DWORD   ExpiredZombies;
    DWORD   AbortedZombies;
    DWORD   DeletedZombies;
} SSL_SESSION_CACHE_INFO_RESPONSE, *PSSL_SESSION_CACHE_INFO_RESPONSE;


// Used to request information for perfmon
typedef struct _SSL_PERFMON_INFO_REQUEST
{
    ULONG MessageType;
    DWORD Flags;
} SSL_PERFMON_INFO_REQUEST, *PSSL_PERFMON_INFO_REQUEST;

// Used to respond to perfmon info request
typedef struct _SSL_PERFMON_INFO_RESPONSE
{
    DWORD   ClientCacheEntries;
    DWORD   ServerCacheEntries;
    DWORD   ClientActiveEntries;
    DWORD   ServerActiveEntries;
    DWORD   ClientHandshakesPerSecond;
    DWORD   ServerHandshakesPerSecond;
    DWORD   ClientReconnectsPerSecond;
    DWORD   ServerReconnectsPerSecond;
} SSL_PERFMON_INFO_RESPONSE, *PSSL_PERFMON_INFO_RESPONSE;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\inc\ssl3.h ===
//+---------------------------------------------------------------------------
//  
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ssl3.h
//
//  Contents:   SSL 3 protocol constants
//
//  Classes:
//
//  Functions:
//
//  History:    11-19-97   jbanes    Created
//
//----------------------------------------------------------------------------

#ifndef __SSL3_H__
#define __SSL3_H__


#define CB_SSL3_SESSION_ID              32
#define CB_SSL3_RANDOM                  32
#define CB_SSL3_PRE_MASTER_SECRET       48
#define CB_SSL3_PROTOCOL                2
#define CB_SSL3_HEADER_SIZE             5
#define CB_SSL3_16_VECTOR               2

#define CB_SSL3_ISSUER_LENGTH           2
#define CB_SSL3_MASTER_KEY_BLOCK        112
#define SSL3_MAX_CLIENT_CERTS           4


#define SSL3_NULL_WITH_NULL_NULL                0x0000
#define SSL3_RSA_WITH_NULL_MD5                  0x0001
#define SSL3_RSA_WITH_NULL_SHA                  0x0002
#define SSL3_RSA_EXPORT_WITH_RC4_40_MD5         0x0003
#define SSL3_RSA_WITH_RC4_128_MD5               0x0004
#define SSL3_RSA_WITH_RC4_128_SHA               0x0005
#define SSL3_RSA_EXPORT_WITH_RC2_CBC_40_MD5     0x0006  
#define SSL3_RSA_WITH_DES_CBC_SHA               0x0009  
#define SSL3_RSA_WITH_3DES_EDE_CBC_SHA          0x000A  
#define SSL3_FORTEZZA_DMS_WITH_FORTEZZA_CBC_SHA 0x001D

#define SSL3_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA  0x0011
#define SSL3_DHE_DSS_WITH_DES_CBC_SHA           0x0012
#define SSL3_DHE_DSS_WITH_3DES_EDE_CBC_SHA      0x0013

#define TLS_RSA_EXPORT1024_WITH_DES_CBC_SHA     0x0062
#define TLS_RSA_EXPORT1024_WITH_RC4_56_SHA      0x0064
#define TLS_DHE_DSS_EXPORT1024_WITH_DES_CBC_SHA 0x0063
#define TLS_DHE_DSS_EXPORT1024_WITH_RC4_56_SHA  0x0065
#define TLS_DHE_DSS_WITH_RC4_128_SHA            0x0066

#define SSL_RSA_FINANCE64_WITH_RC4_64_MD5       0x0080
#define SSL_RSA_FINANCE64_WITH_RC4_64_SHA       0x0081


#define SSL3_CERTTYPE_RSA_SIGN          1
#define SSL3_CERTTYPE_DSS_SIGN          2
#define SSL3_CERTTYPE_RSA_FIXED_DH      3
#define SSL3_CERTTYPE_DSS_FIXED_DH      4
#define SSL3_CERTTYPE_RSA_EPHEMERAL_DH  5
#define SSL3_CERTTYPE_DSS_EPHEMERAL_DH  6
#define SSL3_CERTTYPE_FORTEZZA_KEA      20


#define SSL3_HS_HELLO_REQUEST           0x00
#define SSL3_HS_CLIENT_HELLO            0x01
#define SSL3_HS_SERVER_HELLO            0x02
#define SSL3_HS_CERTIFICATE             0x0B
#define SSL3_HS_SERVER_KEY_EXCHANGE     0x0C
#define SSL3_HS_CERTIFICATE_REQUEST     0x0D
#define SSL3_HS_SERVER_HELLO_DONE       0x0E
#define SSL3_HS_CERTIFICATE_VERIFY      0x0F
#define SSL3_HS_CLIENT_KEY_EXCHANGE     0x10
#define SSL3_HS_FINISHED                0x14
#define SSL3_HS_SGC_CERTIFICATE         0x32

#define SSL3_CT_CHANGE_CIPHER_SPEC      20
#define SSL3_CT_ALERT                   21
#define SSL3_CT_HANDSHAKE               22 
#define SSL3_CT_APPLICATIONDATA         23
#define SSL3_NULL_WRAP                  15
#define SSL3_CLIENT_VERSION_MSB         0x03
#define SSL3_CLIENT_VERSION_LSB         0x00
#define TLS1_CLIENT_VERSION_LSB         0x01
#define CB_SSL3_CERT_VECTOR             3

// Alert levels
#define SSL3_ALERT_WARNING              1
#define SSL3_ALERT_FATAL                2

// Alert message types
#define SSL3_ALERT_CLOSE_NOTIFY         0
#define SSL3_ALERT_UNEXPECTED_MESSAGE   10
#define SSL3_ALERT_BAD_RECORD_MAC       20
#define SSL3_ALERT_DECOMPRESSION_FAIL   30
#define SSL3_ALERT_HANDSHAKE_FAILURE    40
#define SSL3_ALERT_NO_CERTIFICATE       41
#define SSL3_ALERT_BAD_CERTIFICATE      42
#define SSL3_ALERT_UNSUPPORTED_CERT     43
#define SSL3_ALERT_CERTIFICATE_REVOKED  44
#define SSL3_ALERT_CERTIFICATE_EXPIRED  45
#define SSL3_ALERT_CERTIFICATE_UNKNOWN  46
#define SSL3_ALERT_ILLEGAL_PARAMETER    47


#define SSL3_MAX_MESSAGE_LENGTH         (16384 - CB_SSL3_HEADER_SIZE)
#define SSL3_CLIENT_VERSION             0x0300
#define TLS1_CLIENT_VERSION             0x0301


#endif //__SSL3_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\inc\ssl3msg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ssl3msg.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8-02-95   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __SSL3MSG_H__
#define __SSL3MSG_H__

#define CB_SSL3_CHANGE_CIPHER_SPEC      (sizeof(SWRAP) + 1)
#define CB_SSL3_CHANGE_CIPHER_SPEC_ONLY 1

#define CB_SSL3_FINISHED_MSG        (sizeof(FMWIRE))
#define CB_SSL3_FINISHED_MSG_ONLY   (sizeof(SHSH) + CB_MD5_DIGEST_LEN + CB_SHA_DIGEST_LEN)

#define CB_SSL3_ALERT                   (sizeof(SWRAP) +2)
#define CB_SSL3_ALERT_ONLY              2


#define SSL3_CHANGE_CIPHER_MSG  { 0x14, 0x03, 0x00, 0x00, 0x01, 0x01 }


#define FSsl3CipherClient() (0 != pContext->wS3CipherSuiteClient)
#define FSsl3CipherServer() (0 != pContext->wS3CipherSuiteServer)

#define FSsl3Cipher(fClient) ((fClient ? pContext->wS3CipherSuiteClient : pContext->wS3CipherSuiteServer))

#define MS24BOF(x)    ((UCHAR) ((x >> 16) & 0xFF) )

//#define CbChecksum(f, cb)  (cb + (FSsl3Cipher(f) ? pContext->pCheck->cbCheckSum : 0))

#define CHECK_PCT_RET(Ret) if (PCT_ERR_OK != Ret) \
                                        LOG_RESULT(Ret);

#define CHECK_PCT_RET_BREAK(Ret) if(PCT_ERR_OK != Ret)  \
                                 {                      \
                                     LOG_RESULT(Ret);   \
                                     break;             \
                                 }

typedef struct _OIDPROVMAP
{
    LPSTR   szOid;
    DWORD   dwExchSpec;
    DWORD   dwCertType;         // used for SSL 3.0 client auth
}  OIDPROVMAP, *POIDPROVMAP;

extern OIDPROVMAP g_CertTypes[];
extern DWORD g_cCertTypes;


typedef struct _shsh  //Structure hand shake header
{
    UCHAR   typHS;
    UCHAR   bcb24;
    UCHAR   bcbMSB;
    UCHAR   bcbLSB;
} SHSH;


typedef struct _swrap
{
    UCHAR  bCType;
    UCHAR  bMajor;
    UCHAR  bMinor;
    UCHAR  bcbMSBSize;
    UCHAR  bcbLSBSize;
//  UCHAR  rgb[];
} SWRAP;

typedef struct _ssh
{
    SHSH;
    UCHAR   bMajor;
    UCHAR   bMinor;
    UCHAR   rgbRandom[CB_SSL3_RANDOM];
    UCHAR   cbSessionId;
    UCHAR   rgbSessionId[CB_SSL3_SESSION_ID];
    UCHAR   wCipherSelectedMSB;
    UCHAR   wCipherSelectedLSB;
    UCHAR   bCMSelected;
} SSH;


typedef struct _alrt
{
    SWRAP;
    UCHAR bAlertLevel;
    UCHAR bAlertDesc;
} ALRT;


typedef struct _fm
{
    UCHAR   rgbMD5[CB_MD5_DIGEST_LEN];
    UCHAR   rgbSHA[CB_SHA_DIGEST_LEN];
} FM; //finished message

typedef struct _fmwire
{
    SWRAP;
    SHSH;
    FM;
} FMWIRE;

typedef struct _clh
{
    SHSH;
    UCHAR   bMajor;
    UCHAR   bMinor;
    UCHAR   rgbRandom[CB_SSL3_RANDOM];
    UCHAR   cbSessionId;
    UCHAR   rgbSessionId[CB_SSL3_SESSION_ID];
    UCHAR   bMSBCipher;
    UCHAR   bLSBCipher;
    // short   rgbCipher[0];  // ALignment problem, but never used.
    //UCHAR bCM;
    //UCHAR rgbCM[bCM];
} CLH ; //CLient Hello


typedef struct _cert
{
    SHSH;
    UCHAR bcbClist24;
    UCHAR bcbMSBClist;
    UCHAR bcbLSBClist;
    UCHAR bcbCert24;
    UCHAR bcbMSBCert;
    UCHAR bcbLSBCert;
    UCHAR rgbCert[];
    /* followed by the real cert */
} CERT;


typedef struct _certReq
{
    SHSH;
    UCHAR bcbCertType; //This value be just 1 byte
    UCHAR bCertType;  //This will be Only one for quite sometime
    UCHAR bcbMSBList;
    UCHAR bcbLSBList;
    UCHAR rgbIss[];
} CERTREQ;

typedef struct _shwire
{
    PUCHAR  pcbCipher;
    PUCHAR  pCiperSpec;
    PUCHAR  pcbCompM;
    PUCHAR  pCompM;
    PUCHAR  pcbCert;
    PUCHAR  pCert;
    PUCHAR  pHelloDone;
} SHWIRE ;


SP_STATUS WINAPI
Ssl3DecryptHandler(
    PSPContext pContext,
    PSPBuffer pCommInput,
    PSPBuffer pAppOutput);

SP_STATUS WINAPI
Ssl3GetHeaderSize(
    PSPContext pContext,
    PSPBuffer pCommInput,
    DWORD * pcbHeaderSize);


SP_STATUS WINAPI
GenerateSsl3ClientHello(
    PSPContext             pContext,
    PSPBuffer               pOutput);

SP_STATUS WINAPI
GenerateTls1ClientHello(
    PSPContext              pContext,
    PSPBuffer               pOutput,
    DWORD                   dwProtocol);


SP_STATUS
Ssl3PackClientHello(PSPContext pContext,
    PSsl2_Client_Hello       pCanonical,
    PSPBuffer          pCommOutput);



SP_STATUS Ssl3CliHandleServerHello(PSPContext pContext,
                                   PUCHAR pSrvHello,
                                   DWORD cbMessage,
                                   PSPBuffer  pCommOutput);
SP_STATUS Ssl3HandleServerFinish(PSPContext pContext,
                                   PUCHAR pSrvHello );


SP_STATUS Ssl3SrvHandleCMKey(PSPContext pContext,
                              PUCHAR  pCommInput,
                              DWORD cbMsg,
                              PSPBuffer  pCommOutput);

BOOL FVerifyFinishedMessage(PSPContext  pContext, PUCHAR pb, BOOL fClient);

SP_STATUS
ParseAlertMessage
(
PSPContext pContext,
PUCHAR pSrvHello,
DWORD cbMessage
);

SP_STATUS SPAllocOutMemChk(DWORD cbMessage, PSPBuffer  pCommOutput);

SP_STATUS
Ssl3SelectCipher    (
    PSPContext pContext,
    WORD       wCipher
);

SP_STATUS
Ssl3SelectCipherEx(
    PSPContext pContext,
    DWORD *pCipherSpecs,
    DWORD cCipherSpecs);

void BuildAlertMessage(PBYTE pb, UCHAR bAlertLevel, UCHAR bAlertDesc);

SP_STATUS
Ssl3BuildFinishMessage(
    PSPContext pContext,
    BYTE *pbMd5Digest,
    BYTE *pbSHADigest,
    BOOL fClient);

SP_STATUS
Tls1BuildFinishMessage(
    PSPContext  pContext,       // in
    PBYTE       pbVerifyData,   // out
    DWORD       cbVerifyData,   // in
    BOOL        fClient);       // in

SP_STATUS
SPSetWrap(PSPContext pContext, PUCHAR pb, UCHAR bCType, DWORD wT, BOOL fClient, DWORD *pcbMessage);
void SetHandshake(PUCHAR pb, BYTE bHandshake, PUCHAR pbData, DWORD dwSize);

SP_STATUS
UpdateHandshakeHash(
    PSPContext pContext,
    PUCHAR pb,
    DWORD dwcb,
    BOOL fInit);

SP_STATUS
SPBuildS3FinalFinish(PSPContext pContext, PSPBuffer pBuffer, BOOL fClient);

SP_STATUS
VerifyCCSAndFinishMsg(PSPContext pContext, PBYTE pbMsg, DWORD cbMessage, BOOL fClient);

SP_STATUS SPAllocOutMem(DWORD cbMessage, PSPBuffer  pCommOutput);

SP_STATUS
Ssl3ComputeCertVerifyHashes(
    PSPContext  pContext,   // in
    PBYTE       pbMD5,      // out
    PBYTE       pbSHA);     // out

SP_STATUS
Tls1ComputeCertVerifyHashes(
    PSPContext  pContext,   // in
    PBYTE       pbMD5,      // out
    PBYTE       pbSHA);     // out

void BuildCertificateMessage(PBYTE pb, PBYTE rgbCert, DWORD dwCert);

SP_STATUS
BuildCCSAndFinishMessage(
    PSPContext pContext,
    PSPBuffer pBuffer,
    BOOL fClient);

SP_STATUS
ProcessCertificateMessage(
    PSPContext  pContext,
    BOOL        fServer,
    DWORD       dwCipher,
    CERT *      pcert,
    DWORD       dwCert,
    Ssl2_Client_Master_Key *pKey);

void Ssl3GetCipherSpec(
    short  wCipherSuite, // in
    PINT pwKeySize,    // out
    PINT pwMacSize) ; // out

VOID ComputeServerExchangeHashes(
    PSPContext pContext,
    PBYTE pbServerParams,      // in
    INT   iServerParamsLen,    // in
    PBYTE pbMd5HashVal,        // out
    PBYTE pbShaHashVal) ;       // out

DWORD Ssl3CiphertextLen(
    PSPContext pContext,
    DWORD cbMessage,
    BOOL fClientIsSender);

DWORD Ssl3PendingCiphertextLen(
    PSPContext pContext,
    DWORD cbMessage,
    BOOL fClientIsSender);

SP_STATUS
UnwrapSsl3Message
(
PSPContext pContext,
PSPBuffer MsgInput
);


DWORD Ssl3CiphertextLen(
    PSPContext pContext,
    DWORD cbMessage,
    BOOL fClientIsSender);

DWORD Ssl3PendingCiphertextLen(
    PSPContext pContext,
    DWORD cbMessage,
    BOOL fClientIsSender);

void SetWrapNoEncrypt(PUCHAR pb, UCHAR bCType, DWORD wT);

SP_STATUS Ssl3HandleCCS(PSPContext pContext,
                   PUCHAR pb,
                   DWORD cbMessage);
SP_STATUS
VerifyFinishMsg(PSPContext pContext, PBYTE pbMsg, DWORD cbMessage, BOOL fClient);

BOOL Ssl3ParseClientHello(
    PSPContext  pContext,
    PBYTE       pbMessage,
    INT         iMessageLen,
    BOOL        fAttemptRestart,
    BOOL *      pfRestart);

SP_STATUS
SPBuildTlsAlertMessage(
    PSPContext  pContext,
    PSPBuffer   pCommOutput);

void
SetTls1Alert(
    PSPContext  pContext,
    BYTE        bAlertLevel,
    BYTE        bAlertNumber);

SP_STATUS
Ssl3CheckForExistingCred(PSPContext pContext);

#endif //__SSL3MSG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\inc\sslwow64.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       sslwow64.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    05-25-2000   jbanes   Created.
//
//----------------------------------------------------------------------------

typedef DWORD   SSLWOW64_PVOID;
typedef DWORD   SSLWOW64_PDWORD;
typedef DWORD   SSLWOW64_PCCERT_CONTEXT;
typedef DWORD   SSLWOW64_HCERTSTORE;
typedef DWORD   SSLWOW64_HCRYPTPROV;

typedef struct _SSLWOW64_SCHANNEL3_CRED
{
    DWORD               dwVersion;
    DWORD               cCreds;
    SSLWOW64_PVOID      paCred;
    SSLWOW64_HCERTSTORE hRootStore;

    DWORD               cMappers;
    SSLWOW64_PVOID      aphMappers;

    DWORD               cSupportedAlgs;
    SSLWOW64_PDWORD     palgSupportedAlgs;

    DWORD               grbitEnabledProtocols;
    DWORD               dwMinimumCipherStrength;
    DWORD               dwMaximumCipherStrength;
    DWORD               dwSessionLifespan;
} SSLWOW64_SCHANNEL3_CRED;

typedef struct _SSLWOW64_SCHANNEL_CRED
{
    DWORD               dwVersion;
    DWORD               cCreds;
    SSLWOW64_PVOID      paCred;
    SSLWOW64_HCERTSTORE hRootStore;

    DWORD               cMappers;
    SSLWOW64_PVOID      aphMappers;

    DWORD               cSupportedAlgs;
    SSLWOW64_PDWORD     palgSupportedAlgs;

    DWORD               grbitEnabledProtocols;
    DWORD               dwMinimumCipherStrength;
    DWORD               dwMaximumCipherStrength;
    DWORD               dwSessionLifespan;
    DWORD               dwFlags;
    DWORD               reserved;
} SSLWOW64_SCHANNEL_CRED;


typedef struct _SSLWOW64_SCH_CRED
{
    DWORD               dwVersion;
    DWORD               cCreds;
    SSLWOW64_PVOID      paSecret;
    SSLWOW64_PVOID      paPublic;
    DWORD               cMappers;
    SSLWOW64_PVOID      aphMappers;
} SSLWOW64_SCH_CRED;

typedef struct _SSLWOW64_SCH_CRED_SECRET_PRIVKEY
{
    DWORD               dwType;
    SSLWOW64_PVOID      pPrivateKey;
    DWORD               cbPrivateKey;
    SSLWOW64_PVOID      pszPassword;
} SSLWOW64_SCH_CRED_SECRET_PRIVKEY;

typedef struct _SSLWOW64_SCH_CRED_PUBLIC_CERTCHAIN
{
    DWORD               dwType;
    DWORD               cbCertChain;
    SSLWOW64_PVOID      pCertChain;
} SSLWOW64_SCH_CRED_PUBLIC_CERTCHAIN;

typedef struct _SSLWOW64_CREDENTIAL_CERTIFICATE 
{
    DWORD               cbPrivateKey;
    SSLWOW64_PVOID      pPrivateKey;
    DWORD               cbCertificate;
    SSLWOW64_PVOID      pCertificate;
    SSLWOW64_PVOID      pszPassword;
} SSLWOW64_CREDENTIAL_CERTIFICATE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\inc\_ssl3cli.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       _ssl3cli.h
//
//  Contents:   SSL3 function prototypes.
//
//  Classes:
//
//  Functions:
//
//  History:    
//
//----------------------------------------------------------------------------


SP_STATUS
SPVerifyFinishMsgCli(
    PSPContext pContext, 
    PBYTE       pbMsg, 
    BOOL        fClient
    );



void Ssl3StateConnected(PSPContext pContext);

SP_STATUS
BuildCertVerify(
    PSPContext      pContext,
    PBYTE           pb,
    DWORD *         pdwcbCertVerify
);

SP_STATUS SPProcessMessage
(
PSPContext  pContext,
BYTE bContentType,
PBYTE pbMsg,
DWORD cbMsg
);


SP_STATUS Ssl3HandleCCSCli(PSPContext pContext,
                   PUCHAR pb,
                   DWORD cbMessage,
                   BOOL fClient);


SP_STATUS 
FormatIssuerList(
    PBYTE       pbInput,
    DWORD       cbInput,
    PBYTE       pbIssuerList,
    DWORD *     pcbIssuerList);

SP_STATUS SPGenerateResponse(
PSPContext pContext, 
PSPBuffer pCommOutput
);

DWORD  CbLenOfEncode(DWORD dw, PBYTE pbDst);

SP_STATUS SPGenerateSHResponse(PSPContext  pContext, PSPBuffer pOut);

SP_STATUS SPProcessHandshake(PSPContext pContext, PBYTE pb, DWORD cb);

SP_STATUS SPDigestSrvKeyX
(
PSPContext  pContext, 
PUCHAR pb, 
DWORD dwSrvHello
);


 SP_STATUS 
 SpDigestSrvCertificate
 (
 PSPContext  pContext, 
 PUCHAR pb, 
 DWORD dwSrvHello
 );


#define PbSessionid(pssh)  (((BYTE *)&pssh->cbSessionId) + 1)


SP_STATUS
ParseCertificateRequest
(
    PSPContext          pContext,
    PBYTE               pb,
    DWORD               dwcb
);


BOOL FNoInputState(DWORD dwState);

SP_STATUS
UnwrapSsl3MessageEx
(
PSPContext pContext,
PSPBuffer pMsgInput
);


SP_STATUS
Ssl3SrvHandleUniHello(PSPContext  pContext,
                        PBYTE pb,
                        DWORD cbMsg
                        );


SP_STATUS
Ssl3SrvGenServerHello(
    PSPContext         pContext,
    PSPBuffer          pCommOutput);

SP_STATUS SPPacketSplit(BYTE bContentType, PSPBuffer pPlain) ;



SP_STATUS
ParseKeyExchgMsg(PSPContext  pContext, PBYTE pb);

BOOL Ssl3ParseCertificateVerify(PSPContext  pContext, PBYTE pbMessage, INT iMessageLen);

SP_STATUS
SPBuildHelloRequest
(
PSPContext  pContext,
PSPBuffer  pCommOutput
);

SP_STATUS
SPSsl3SrvGenServerHello(
    PSPContext         pContext,
    PSPBuffer          pCommOutput);


SP_STATUS
SPSsl3SrvGenRestart(
    PSPContext          pContext,
    PSPBuffer           pCommOutput);


void
Ssl3BuildServerHello(PSPContext pContext, PBYTE pb);

void BuildServerHelloDone(PBYTE pb, DWORD cb);

SP_STATUS Ssl3BuildServerKeyExchange(
    PSPContext  pContext,
    PBYTE pbMessage,            // out
    PINT  piMessageLen) ;       // out

SP_STATUS BuildCCSAndFinishForServer
(
PSPContext  pContext,
PSPBuffer  pCommOutput,
BOOL fDone
);

SP_STATUS
Ssl3BuildCertificateRequest(
    PSPContext pContext,
    PBYTE pbIssuerList,         // in
    DWORD cbIssuerList,         // in
    PBYTE pbMessage,            // out
    DWORD *pdwMessageLen);      // out


SP_STATUS
SPSsl3SrvHandleClientHello(
    PSPContext pContext,
    PBYTE pb,
    BOOL fAttemptReconnect);


SP_STATUS
SPBuildCCSAndFinish
(
PSPContext  pContext,
PSPBuffer  pCommOutput
);

#define     F_RESPONSE(State) (State > SSL3_STATE_GEN_START && State < SSL3_STATE_GEN_END)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\lsa\callback.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       callback.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   Created
//
//----------------------------------------------------------------------------
#include "sslp.h"

SECURITY_STATUS
NTAPI
SPSignatureCallback(
    ULONG_PTR hProv,
    ULONG_PTR aiHash,
    SecBuffer *pInput,
    SecBuffer *pOutput);

SECURITY_STATUS
NTAPI
UploadCertContextCallback(
    ULONG_PTR Argument1,
    ULONG_PTR Argument2,
    SecBuffer *pInput,
    SecBuffer *pOutput);

SECURITY_STATUS
NTAPI
UploadCertStoreCallback(
    ULONG_PTR Argument1,
    ULONG_PTR Argument2,
    SecBuffer *pInput,
    SecBuffer *pOutput);

SECURITY_STATUS
NTAPI
RemoteCryptAcquireContextCallback(
    ULONG_PTR dwProvType,
    ULONG_PTR dwFlags,
    SecBuffer *pInput,
    SecBuffer *pOutput);

SECURITY_STATUS
RemoteCryptReleaseContextCallback(
    ULONG_PTR hProv,
    ULONG_PTR dwFlags,
    SecBuffer *pInput,
    SecBuffer *pOutput);

SECURITY_STATUS
DownloadCertContextCallback(
    ULONG_PTR Argument1,
    ULONG_PTR Argument2,
    SecBuffer *pInput,
    SecBuffer *pOutput);

SECURITY_STATUS
NTAPI
GetUserKeysCallback(
    ULONG_PTR dwLsaContext,
    ULONG_PTR dwFlags,
    SecBuffer *pInput,
    SecBuffer *pOutput);

SCH_CALLBACK_LIST g_SchannelCallbacks[] =
{
    { SCH_SIGNATURE_CALLBACK,               SPSignatureCallback               },
    { SCH_UPLOAD_CREDENTIAL_CALLBACK,       UploadCertContextCallback         },
    { SCH_UPLOAD_CERT_STORE_CALLBACK,       UploadCertStoreCallback           },
    { SCH_ACQUIRE_CONTEXT_CALLBACK,         RemoteCryptAcquireContextCallback },
    { SCH_RELEASE_CONTEXT_CALLBACK,         RemoteCryptReleaseContextCallback },
    { SCH_DOWNLOAD_CERT_CALLBACK,           DownloadCertContextCallback       },
    { SCH_GET_USER_KEYS,                    GetUserKeysCallback               },

    { SCH_REFERENCE_MAPPER_CALLBACK,        ReferenceMapperCallback           },
    { SCH_GET_MAPPER_ISSUER_LIST_CALLBACK,  GetMapperIssuerListCallback       },
    { SCH_MAP_CREDENTIAL_CALLBACK,          MapCredentialCallback             },
    { SCH_CLOSE_LOCATOR_CALLBACK,           CloseLocatorCallback              },
    { SCH_GET_MAPPER_ATTRIBUTES_CALLBACK,   QueryMappedCredAttributesCallback }

};

DWORD g_cSchannelCallbacks = sizeof(g_SchannelCallbacks) / sizeof(SCH_CALLBACK_LIST);

//+---------------------------------------------------------------------------
//
//  Function:   PerformApplicationCallback
//
//  Synopsis:   Call back to the application process.
//
//  Arguments:  [dwCallback]    --  Callback function number.
//              [dwArg1]        --
//              [dwArg2]        --
//              [pInput]        --
//              [pOutput]       --
//
//  History:    09-23-97   jbanes   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
PerformApplicationCallback(
    DWORD dwCallback,
    ULONG_PTR dwArg1,
    ULONG_PTR dwArg2,
    SecBuffer *pInput,
    SecBuffer *pOutput,
    BOOL fExpectOutput)
{
    SECURITY_STATUS Status;
    PVOID pvBuffer;

    if(LsaTable == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
    }

    pOutput->BufferType = SECBUFFER_EMPTY;
    pOutput->pvBuffer   = NULL;
    pOutput->cbBuffer   = 0;

    try
    {
        Status = LsaTable->ClientCallback((PCHAR)ULongToPtr(dwCallback), // Sundown: dwCallback is a function number.
                                          dwArg1,
                                          dwArg2,
                                          pInput,
                                          pOutput);
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        Status = SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
    }
    if ( !NT_SUCCESS( Status ) )
    {
        return SP_LOG_RESULT( Status );
    }
    if(Status != SEC_E_OK)
    {
        SP_LOG_RESULT( Status );
        return SEC_E_INTERNAL_ERROR;
    }

    if(pOutput->pvBuffer && pOutput->cbBuffer)
    {
        pvBuffer = SPExternalAlloc(pOutput->cbBuffer);
        if(pvBuffer == NULL)
        {
            return SP_LOG_RESULT( SEC_E_INSUFFICIENT_MEMORY );
        }

        Status = LsaTable->CopyFromClientBuffer(NULL,
                                                pOutput->cbBuffer,
                                                pvBuffer,
                                                pOutput->pvBuffer );

        if ( !NT_SUCCESS( Status ) )
        {
            SPExternalFree(pvBuffer);
            return SP_LOG_RESULT( Status );
        }

        Status = SPFreeUserAllocMemory(pOutput->pvBuffer, pOutput->cbBuffer);

        if ( !NT_SUCCESS( Status ) )
        {
            SPExternalFree(pvBuffer);
            return SP_LOG_RESULT( Status );
        }

        pOutput->pvBuffer = pvBuffer;
    } 
    else if(fExpectOutput)
    {
        return SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
    }

    return Status;
}


// This helper function is called by the LSA process in order to duplicate
// a handle belonging to the application process.
BOOL
DuplicateApplicationHandle(
    HANDLE   hAppHandle,
    LPHANDLE phLsaHandle)
{
    SECPKG_CALL_INFO CallInfo;
    HANDLE  hAppProcess;
    HANDLE  hLsaProcess;
    BOOL    fResult;

    // Get handle to application process.
    if(!LsaTable->GetCallInfo(&CallInfo))
    {
        return FALSE;
    }
    hAppProcess = OpenProcess(PROCESS_DUP_HANDLE,
                              FALSE,
                              CallInfo.ProcessId);
    if(hAppProcess == NULL)
    {
        return FALSE;
    }

    // Get handle to lsa process.
    hLsaProcess = GetCurrentProcess();


    // Duplicate handle
    fResult = DuplicateHandle(hAppProcess,
                              hAppHandle,
                              hLsaProcess,
                              phLsaHandle,
                              0, FALSE,
                              DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE);

    CloseHandle(hAppProcess);
    CloseHandle(hLsaProcess);

    return fResult;
}


//+---------------------------------------------------------------------------
//
//  Function:   RemoteCryptAcquireContextCallback
//
//  Synopsis:   Obtain a CSP context handle, using the information passed
//              in the input buffer.
//
//  Arguments:  [dwProvType]    --  Provider type.
//              [dwFlags]       --  Flags.
//              [pInput]        --  Buffer containing provider info.
//              [pOutput]       --  Buffer containing CSP context handle.
//
//  History:    09-24-97   jbanes   Created
//
//  Notes:      The structure of the input buffer is as follows:
//
//                  cbContainerName
//                  cbProvName
//                  dwCapiFlags
//                  wszContainerName
//                  wszProvName
//
//        This function always uses an actual CSP.
//
//----------------------------------------------------------------------------
SECURITY_STATUS
RemoteCryptAcquireContextCallback(
    ULONG_PTR dwProvType,       // in
    ULONG_PTR dwFlags,          // in
    SecBuffer *pInput,          // in
    SecBuffer *pOutput)         // out
{
    LPWSTR      pwszContainerName;
    DWORD       cbContainerName;
    LPWSTR      pwszProvName;
    DWORD       cbProvName;
    HCRYPTPROV  hProv;
    LPBYTE      pbBuffer;
    DWORD       cbBuffer;
    DWORD       dwCapiFlags;

    if(!SchannelInit(TRUE))
    {
        return SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
    }

    DebugLog((DEB_TRACE, "RemoteCryptAcquireContextCallback\n"));

    pOutput->BufferType = SECBUFFER_DATA;
    pOutput->cbBuffer   = 0;
    pOutput->pvBuffer   = NULL;

    if(pInput->pvBuffer == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
    }

    // Parse input buffer.
    pbBuffer = pInput->pvBuffer;
    cbBuffer = pInput->cbBuffer;

    if(cbBuffer < sizeof(DWORD) * 3)
    {
        return SP_LOG_RESULT(SEC_E_INCOMPLETE_MESSAGE);
    }

    cbContainerName = *(DWORD *)pbBuffer;
    pbBuffer += sizeof(DWORD);

    cbProvName = *(DWORD *)pbBuffer;
    pbBuffer += sizeof(DWORD);

    dwCapiFlags = *(DWORD *)pbBuffer;
    pbBuffer += sizeof(DWORD);

    if(cbBuffer < sizeof(DWORD) * 3 + cbContainerName + cbProvName)
    {
        return SP_LOG_RESULT(SEC_E_INCOMPLETE_MESSAGE);
    }

    if(cbContainerName)
    {
        pwszContainerName = (LPWSTR)pbBuffer;
    }
    else
    {
        pwszContainerName = NULL;
    }
    pbBuffer += cbContainerName;

    if(cbProvName)
    {
        pwszProvName = (LPWSTR)pbBuffer;
    }
    else
    {
        pwszProvName = NULL;
    }


    // HACKHACK - clear the smart-card specific flag.
    dwFlags &= ~CERT_SET_KEY_CONTEXT_PROP_ID;


    DebugLog((SP_LOG_TRACE, "Container:%ls\n",     pwszContainerName));
    DebugLog((SP_LOG_TRACE, "Provider: %ls\n",     pwszProvName));
    DebugLog((SP_LOG_TRACE, "Type:     0x%8.8x\n", dwProvType));
    DebugLog((SP_LOG_TRACE, "Flags:    0x%8.8x\n", dwFlags));
    DebugLog((SP_LOG_TRACE, "CapiFlags:0x%8.8x\n", dwCapiFlags));

    // Attempt to get CSP context handle.
    if(!SchCryptAcquireContextW(&hProv,
                                pwszContainerName,
                                pwszProvName,
                                (DWORD) dwProvType,
                                (DWORD) dwFlags,
                                dwCapiFlags))
    {
        return SP_LOG_RESULT(GetLastError());
    }

    // Allocate memory for the output buffer.
    pOutput->BufferType = SECBUFFER_DATA;
    pOutput->cbBuffer   = sizeof(HCRYPTPROV);
    pOutput->pvBuffer   = PvExtVirtualAlloc(pOutput->cbBuffer);
    if(pOutput->pvBuffer == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }

    // Place hProv in output buffer.
    *(HCRYPTPROV *)pOutput->pvBuffer = hProv;

    return SEC_E_OK;
}


NTSTATUS
RemoteCryptAcquireContextW(
    HCRYPTPROV *phProv,
    LPCWSTR     pwszContainerName,
    LPCWSTR     pwszProvName,
    DWORD       dwProvType,
    DWORD       dwFlags,
    DWORD       dwCapiFlags)
{
    SecBuffer Input;
    SecBuffer Output;
    DWORD cbContainerName;
    DWORD cbProvName;
    PBYTE pbBuffer;
    SECURITY_STATUS scRet;

    // Build input buffer.
    if(pwszContainerName)
    {
        cbContainerName = (lstrlenW(pwszContainerName) + 1) * sizeof(WCHAR);
    }
    else
    {
        cbContainerName = 0;
    }
    if(pwszProvName)
    {
        cbProvName = (lstrlenW(pwszProvName) + 1) * sizeof(WCHAR);
    }
    else
    {
        cbProvName = 0;
    }

    Input.BufferType  = SECBUFFER_DATA;
    Input.cbBuffer    = sizeof(DWORD) + cbContainerName +
                        sizeof(DWORD) + cbProvName +
                        sizeof(DWORD);
    Input.pvBuffer    = SPExternalAlloc(Input.cbBuffer);
    if(Input.pvBuffer == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }

    pbBuffer = Input.pvBuffer;

    *(DWORD *)pbBuffer = cbContainerName;
    pbBuffer += sizeof(DWORD);
    *(DWORD *)pbBuffer = cbProvName;
    pbBuffer += sizeof(DWORD);
    *(DWORD *)pbBuffer = dwCapiFlags;
    pbBuffer += sizeof(DWORD);

    CopyMemory(pbBuffer, pwszContainerName, cbContainerName);
    pbBuffer += cbContainerName;

    CopyMemory(pbBuffer, pwszProvName, cbProvName);
    pbBuffer += cbProvName;


    // Do callback.
    scRet = PerformApplicationCallback( SCH_ACQUIRE_CONTEXT_CALLBACK,
                                        dwProvType,
                                        dwFlags,
                                        &Input,
                                        &Output,
                                        TRUE);
    if(!NT_SUCCESS(scRet))
    {
        DebugLog((SP_LOG_ERROR, "Error 0x%x calling remote CryptAcquireContext\n", scRet));
        SPExternalFree(Input.pvBuffer);
        return scRet;
    }

    // Get hProv from output buffer.
    *phProv = *(HCRYPTPROV *)Output.pvBuffer;

    DebugLog((SP_LOG_TRACE, "Remote CSP handle retrieved (0x%x)\n", *phProv));

    SPExternalFree(Input.pvBuffer);
    SPExternalFree(Output.pvBuffer);

    return SEC_E_OK;
}


SECURITY_STATUS
RemoteCryptReleaseContextCallback(
    ULONG_PTR hProv,        // in
    ULONG_PTR dwFlags,      // in
    SecBuffer *pInput,      // in
    SecBuffer *pOutput)     // out
{
    DWORD dwCapiFlags;

    if(!SchannelInit(TRUE))
    {
        return SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
    }

    DebugLog((DEB_TRACE, "RemoteCryptReleaseContextCallback\n"));

    pOutput->BufferType = SECBUFFER_DATA;
    pOutput->cbBuffer   = 0;
    pOutput->pvBuffer   = NULL;

    if(!CryptReleaseContext((HCRYPTPROV)hProv, (DWORD)dwFlags))
    {
        return SP_LOG_RESULT(GetLastError());
    }

    return SEC_E_OK;
}


BOOL
RemoteCryptReleaseContext(
    HCRYPTPROV  hProv,
    DWORD       dwFlags,
    DWORD       dwCapiFlags)
{
    SecBuffer Input;
    SecBuffer Output;
    DWORD Status;

    Input.BufferType = SECBUFFER_DATA;
    Input.cbBuffer   = 0;
    Input.pvBuffer   = NULL;

    Status = PerformApplicationCallback(SCH_RELEASE_CONTEXT_CALLBACK,
                                        (ULONG_PTR) hProv,
                                        (ULONG_PTR) dwFlags,
                                        &Input,
                                        &Output,
                                        FALSE);
    if(!NT_SUCCESS(Status))
    {
        DebugLog((SP_LOG_ERROR, "Error 0x%x releasing crypto context!\n", Status));
        SetLastError(Status);
        return FALSE;
    }

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:   UploadCertContextCallback
//
//  Synopsis:   Transfer a cert context structure from the application
//              process to the LSA process.
//
//  Arguments:  [Argument1] -- Not used.
//              [Argument2] -- Not used.
//
//              [pInput]    -- Buffer containing a cert context structure.
//
//              [pOutput]   -- Buffer containing the serialized certificate
//                             context, etc.
//
//  History:    09-23-97   jbanes   Created
//
//  Notes:      The structure of the output buffer is as follows:
//
//                  HCRYPTPROV  hProv;
//                  DWORD       cbSerializedCertContext;
//                  PVOID       pvSerializedCertContext;
//
//        This function always uses an actual CSP.
//
//----------------------------------------------------------------------------
SECURITY_STATUS
UploadCertContextCallback(
    ULONG_PTR Argument1,        // in
    ULONG_PTR Argument2,        // in
    SecBuffer *pInput,      // in
    SecBuffer *pOutput)     // out
{
    PCCERT_CONTEXT  pCertContext;
    CRYPT_DATA_BLOB SaveBlob;
    HCRYPTPROV      hProv;

    DWORD           cbProvHandle;
    DWORD           cbCertContext;
    PBYTE           pbBuffer;
    DWORD           dwFlags;
    SECURITY_STATUS scRet = SEC_E_UNKNOWN_CREDENTIALS;

    if(!SchannelInit(TRUE))
    {
        return SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
    }

    DebugLog((DEB_TRACE, "UploadCertContextCallback\n"));

    if(pInput->cbBuffer == 0 || pInput->pvBuffer == NULL)
    {
        pOutput->cbBuffer = 0;
        pOutput->pvBuffer = NULL;

        return SEC_E_OK;
    }
    else
    {
        pCertContext = *(PCCERT_CONTEXT *)pInput->pvBuffer;
    }

    pOutput->cbBuffer   = 0;
    pOutput->pvBuffer   = NULL;
    pOutput->BufferType = SECBUFFER_DATA;

    // Attempt to read the hProv associated with the cert context.
    cbProvHandle = sizeof(HCRYPTPROV);
    if(!CertGetCertificateContextProperty(pCertContext,
                                          CERT_KEY_PROV_HANDLE_PROP_ID,
                                          (PVOID)&hProv,
                                          &cbProvHandle))
    {
        hProv = 0;
        cbProvHandle = sizeof(HCRYPTPROV);
    }

    // Determine the size of the serialized cert context.
    if(!CertSerializeCertificateStoreElement(
                    pCertContext,
                    0,
                    NULL,
                    &cbCertContext))
    {
        scRet = SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
        goto Return;
    }


    //
    // Build output buffer.
    //

    // Allocate memory for the output buffer.
    pOutput->cbBuffer = sizeof(HCRYPTPROV) +
                        sizeof(DWORD) + cbCertContext;
    pOutput->pvBuffer = PvExtVirtualAlloc(pOutput->cbBuffer);
    if(pOutput->pvBuffer == NULL)
    {
        scRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto Return;
    }
    pbBuffer = pOutput->pvBuffer;

    // Place hProv in output buffer.
    *(HCRYPTPROV *)pbBuffer = hProv;
    pbBuffer += sizeof(HCRYPTPROV);

    // Place certificate context in output buffer.
    *(DWORD *)pbBuffer = cbCertContext;
    if(!CertSerializeCertificateStoreElement(
                    pCertContext,
                    0,
                    pbBuffer + sizeof(DWORD),
                    &cbCertContext))
    {
        scRet = SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
        goto Return;
    }

    scRet = SEC_E_OK;


Return:

    if(!NT_SUCCESS(scRet) && (NULL != pOutput->pvBuffer))
    {
        SECURITY_STATUS Status;

        Status = FreeExtVirtualAlloc(pOutput->pvBuffer, pOutput->cbBuffer);
        SP_ASSERT(NT_SUCCESS(Status));
    }

    return scRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   UploadCertStoreCallback
//
//  Synopsis:   Transfer a cert store from the application
//              process to the LSA process, in the form of a serialized
//              certificate store.
//
//  Arguments:  [Argument1] -- Not used.
//              [Argument2] -- Not used.
//
//              [pInput]    -- Buffer containing a HCERTSTORE handle.
//
//              [pOutput]   -- Buffer containing the serialized cert store.
//
//  History:    02-03-98   jbanes   Created
//
//  Notes:      The structure of the output buffer is as follows:
//
//                  DWORD       cbSerializedCertStore;
//                  PVOID       pvSerializedCertStore;
//
//        This function always uses an actual CSP.
//
//----------------------------------------------------------------------------
SECURITY_STATUS
UploadCertStoreCallback(
    ULONG_PTR Argument1,        // in
    ULONG_PTR Argument2,        // in
    SecBuffer *pInput,      // in
    SecBuffer *pOutput)     // out
{
    HCERTSTORE      hStore;
    PCCERT_CONTEXT  pCertContext;
    PCCERT_CONTEXT  pIssuer;
    PCCERT_CONTEXT  pPrevIssuer;
    CRYPT_DATA_BLOB SaveBlob;
    HCRYPTPROV      hProv;

    DWORD           cbProvHandle;
    DWORD           cbCertContext;
    DWORD           cbCertStore;
    PBYTE           pbBuffer;
    DWORD           dwFlags;

    if(!SchannelInit(TRUE))
    {
        return SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
    }

    DebugLog((DEB_TRACE, "UploadCertStoreCallback\n"));

    pOutput->cbBuffer = 0;
    pOutput->pvBuffer = NULL;
    pOutput->BufferType = SECBUFFER_DATA;

    if(pInput->cbBuffer != sizeof(HCERTSTORE) || pInput->pvBuffer == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
    }

    hStore = *(HCERTSTORE *)pInput->pvBuffer;


    // Determine the size of the serialized store.
    SaveBlob.cbData = 0;
    SaveBlob.pbData = NULL;
    if(!CertSaveStore(hStore,
                      X509_ASN_ENCODING,
                      CERT_STORE_SAVE_AS_STORE,
                      CERT_STORE_SAVE_TO_MEMORY,
                      (PVOID)&SaveBlob,
                      0))
    {
        return SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
    }
    cbCertStore = SaveBlob.cbData;


    //
    // Build output buffer.
    //

    // Allocate memory for the output buffer.
    pOutput->cbBuffer = sizeof(DWORD) + cbCertStore;
    pOutput->pvBuffer = PvExtVirtualAlloc(pOutput->cbBuffer);
    if(pOutput->pvBuffer == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }
    pbBuffer = pOutput->pvBuffer;

    // Place certificate store in output buffer.
    *(DWORD *)pbBuffer = cbCertStore;
    SaveBlob.cbData = cbCertStore;
    SaveBlob.pbData = pbBuffer + sizeof(DWORD);
    if(!CertSaveStore(hStore,
                      X509_ASN_ENCODING,
                      CERT_STORE_SAVE_AS_STORE,
                      CERT_STORE_SAVE_TO_MEMORY,
                      (PVOID)&SaveBlob,
                      0))
    {
        FreeExtVirtualAlloc(pOutput->pvBuffer, pOutput->cbBuffer);
        return SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
    }

    return SEC_E_OK;
}


SP_STATUS
SignHashUsingCallback(
    HCRYPTPROV  hProv,
    DWORD       dwKeySpec,
    ALG_ID      aiHash,
    PBYTE       pbHash,
    DWORD       cbHash,
    PBYTE       pbSignature,
    PDWORD      pcbSignature,
    DWORD       fHashData)
{
    SecBuffer Input;
    SecBuffer Output;
    SP_STATUS pctRet;

    //
    // Build input buffer.
    //

    Input.BufferType  = SECBUFFER_DATA;
    Input.cbBuffer    = sizeof(DWORD) * 2 + cbHash;
    Input.pvBuffer    = SPExternalAlloc(Input.cbBuffer);
    if(Input.pvBuffer == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }

    memcpy(Input.pvBuffer, (PBYTE)&dwKeySpec, sizeof(DWORD));
    memcpy((PBYTE)Input.pvBuffer + sizeof(DWORD), (PBYTE)&fHashData, sizeof(DWORD));
    memcpy((PBYTE)Input.pvBuffer + sizeof(DWORD) * 2,
           pbHash,
           cbHash);


    //
    // Callback into application process.
    //

    pctRet = PerformApplicationCallback(SCH_SIGNATURE_CALLBACK,
                                        hProv,
                                        aiHash,
                                        &Input,
                                        &Output,
                                        TRUE);

    SPExternalFree(Input.pvBuffer);

    if(pctRet != PCT_ERR_OK)
    {
        return pctRet;
    }

    if(Output.cbBuffer > *pcbSignature)
    {
        *pcbSignature = Output.cbBuffer;
        SPExternalFree(Output.pvBuffer);
        return SP_LOG_RESULT(SEC_E_BUFFER_TOO_SMALL);
    }

    *pcbSignature = Output.cbBuffer;
    memcpy(pbSignature, Output.pvBuffer, Output.cbBuffer);

    SPExternalFree(Output.pvBuffer);

    return PCT_ERR_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   SPSignatureCallback
//
//  Synopsis:   Perform signature, using application's hProv
//
//  Arguments:  [hProv]     --
//              [aiHash]    --
//              [pInput]    --
//              [pOutput]   --
//
//  History:    09-23-97   jbanes   Created
//
//  Notes:    This function always uses an actual CSP.
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SPSignatureCallback(ULONG_PTR hProv,            // in
                    ULONG_PTR aiHash,           // in
                    SecBuffer *pInput,      // in
                    SecBuffer *pOutput)     // out
{
    HCRYPTHASH  hHash;
    DWORD       dwKeySpec;
    DWORD       fHashData;
    PBYTE       pbHash;
    DWORD       cbHash;
    SP_STATUS   pctRet;

    if(!SchannelInit(TRUE))
    {
        return SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
    }

    DebugLog((DEB_TRACE, "SPSignatureCallback\n"));

    //
    // Parse input buffer.
    //

    if(pInput->cbBuffer < sizeof(DWORD) * 2)
    {
        return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

    memcpy(&dwKeySpec, pInput->pvBuffer, sizeof(DWORD));
    memcpy(&fHashData, (PBYTE)pInput->pvBuffer + sizeof(DWORD), sizeof(DWORD));

    pbHash = (PBYTE)pInput->pvBuffer + sizeof(DWORD) * 2;
    cbHash = pInput->cbBuffer - sizeof(DWORD) * 2;


    //
    // Prepare hash object.
    //

    if(!CryptCreateHash(hProv, (ALG_ID)aiHash, 0, 0, &hHash))
    {
        SP_LOG_RESULT( GetLastError() );
        return PCT_ERR_ILLEGAL_MESSAGE;
    }
    if(!fHashData)
    {
        // set hash value
        if(!CryptSetHashParam(hHash, HP_HASHVAL, pbHash, 0))
        {
            SP_LOG_RESULT( GetLastError() );
            CryptDestroyHash(hHash);
            return PCT_ERR_ILLEGAL_MESSAGE;
        }
    }
    else
    {
        if(!CryptHashData(hHash, pbHash, cbHash, 0))
        {
            SP_LOG_RESULT( GetLastError() );
            CryptDestroyHash(hHash);
            return PCT_ERR_ILLEGAL_MESSAGE;
        }
    }


    //
    // Sign hash.
    //

    pOutput->BufferType = SECBUFFER_DATA;

    // Get size of signature
    if(!CryptSignHash(hHash, dwKeySpec, NULL, 0, NULL, &pOutput->cbBuffer))
    {
        pctRet = SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        return pctRet;
    }

    // Allocate memory
    pOutput->pvBuffer = PvExtVirtualAlloc(pOutput->cbBuffer);
    if(pOutput->pvBuffer == NULL)
    {
        CryptDestroyHash(hHash);
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }

    // Sign hash.
    if(!CryptSignHash(hHash, dwKeySpec, NULL, 0, pOutput->pvBuffer, &pOutput->cbBuffer))
    {
        pctRet = SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        FreeExtVirtualAlloc(pOutput->pvBuffer, pOutput->cbBuffer);
        return pctRet;
    }

    CryptDestroyHash(hHash);

    return PCT_ERR_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   DownloadCertContextCallBack
//
//  Synopsis:   Transfer a cert context structure from the application
//              process to the LSA process, in the form of a serialized
//              certificate store.
//
//  Arguments:  [Argument1] -- Not used.
//              [Argument2] -- Not used.
//              [pInput]    --
//              [pOutput]   --
//
//  History:    09-26-97   jbanes   Created
//
//  Notes:      The structure of the input buffer is as follows:
//
//                  DWORD       cbSerializedCertStore;
//                  PVOID       pvSerializedCertStore;
//                  DWORD       cbSerializedCertContext;
//                  PVOID       pvSerializedCertContext;
//
//        This function always uses an actual CSP.
//
//----------------------------------------------------------------------------
SECURITY_STATUS
DownloadCertContextCallback(
    ULONG_PTR Argument1,        // in
    ULONG_PTR Argument2,        // in
    SecBuffer *pInput,      // in
    SecBuffer *pOutput)     // out
{
    PCCERT_CONTEXT  pCertContext;
    SECURITY_STATUS scRet;

    if(!SchannelInit(TRUE))
    {
        return SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
    }

    DebugLog((DEB_TRACE, "DownloadCertContextCallback\n"));

    // Allocate memory for output buffer.
    pOutput->BufferType = SECBUFFER_DATA;
    pOutput->cbBuffer   = sizeof(PVOID);
    pOutput->pvBuffer   = PvExtVirtualAlloc(pOutput->cbBuffer);
    if(pOutput->pvBuffer == NULL)
    {
        return SP_LOG_RESULT( SEC_E_INSUFFICIENT_MEMORY );
    }

    // Deserialize buffer.
    scRet = DeserializeCertContext(&pCertContext,
                                   pInput->pvBuffer,
                                   pInput->cbBuffer);
    if(FAILED(scRet))
    {
        FreeExtVirtualAlloc(pOutput->pvBuffer, pOutput->cbBuffer);
        return SP_LOG_RESULT( scRet );
    }

    // Place cert context pointer in output buffer.
    *(PCCERT_CONTEXT *)pOutput->pvBuffer = pCertContext;


    return SEC_E_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:   SerializeCertContext
//
//  Synopsis:   Serialize the specified certificate context, along with its
//              associated certificate store.
//
//  Arguments:  [pCertContext]  --
//              [pbBuffer]      --
//              [pcbBuffer]     --
//
//  History:    09-26-97   jbanes   Created
//
//  Notes:      The structure of the output buffer is as follows:
//
//                  DWORD       cbSerializedCertStore
//                  PVOID       pvSerializedCertStore
//                  DWORD       cbSerializedCertContext
//                  PVOID       pvSerializedCertContext
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SerializeCertContext(
    PCCERT_CONTEXT pCertContext,    // in
    PBYTE          pbBuffer,        // out
    PDWORD         pcbBuffer)       // out
{
    CRYPT_DATA_BLOB SaveBlob;
    DWORD           cbCertContext;
    DWORD           cbCertStore;
    DWORD           cbBuffer;

    if(pCertContext == NULL)
    {
        *pcbBuffer = 0;
        return SEC_E_OK;
    }

    // Determine the size of the serialized cert context.
    if(!CertSerializeCertificateStoreElement(
                    pCertContext,
                    0,
                    NULL,
                    &cbCertContext))
    {
        return SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
    }

    // Determine the size of the serialized store.
    if(pCertContext->hCertStore)
    {
        SaveBlob.cbData = 0;
        SaveBlob.pbData = NULL;
        if(!CertSaveStore(pCertContext->hCertStore,
                          X509_ASN_ENCODING,
                          CERT_STORE_SAVE_AS_STORE,
                          CERT_STORE_SAVE_TO_MEMORY,
                          (PVOID)&SaveBlob,
                          0))
        {
            return SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
        }
        cbCertStore = SaveBlob.cbData;
    }
    else
    {
        cbCertStore = 0;
    }

    cbBuffer = sizeof(DWORD) + cbCertContext +
               sizeof(DWORD) + cbCertStore;

    if(pbBuffer == NULL)
    {
        *pcbBuffer = cbBuffer;
        return SEC_E_OK;
    }

    if(*pcbBuffer < cbBuffer)
    {
        return SP_LOG_RESULT(SEC_E_BUFFER_TOO_SMALL);
    }

    // Set output values.
    *pcbBuffer = cbBuffer;


    // Place certificate store in output buffer.
    *(DWORD *)pbBuffer = cbCertStore;
    if(pCertContext->hCertStore)
    {
        SaveBlob.cbData = cbCertStore;
        SaveBlob.pbData = pbBuffer + sizeof(DWORD);
        if(!CertSaveStore(pCertContext->hCertStore,
                          X509_ASN_ENCODING,
                          CERT_STORE_SAVE_AS_STORE,
                          CERT_STORE_SAVE_TO_MEMORY,
                          (PVOID)&SaveBlob,
                          0))
        {
            return SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
        }
    }
    pbBuffer += sizeof(DWORD) + cbCertStore;

    // Place certificate context in output buffer.
    *(DWORD UNALIGNED *)pbBuffer = cbCertContext;
    if(!CertSerializeCertificateStoreElement(
                    pCertContext,
                    0,
                    pbBuffer + sizeof(DWORD),
                    &cbCertContext))
    {
        return SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
    }

    return SEC_E_OK;
}

SECURITY_STATUS
DeserializeCertContext(
    PCCERT_CONTEXT *ppCertContext,  // out
    PBYTE           pbBuffer,       // in
    DWORD           cbBuffer)       // in
{
    CRYPT_DATA_BLOB Serialized;
    HCERTSTORE  hStore;

    // Deserialize certificate store.
    Serialized.cbData = *(DWORD *)pbBuffer;
    Serialized.pbData = pbBuffer + sizeof(DWORD);
    hStore = CertOpenStore( CERT_STORE_PROV_SERIALIZED,
                            X509_ASN_ENCODING,
                            0,
                            CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
                            &Serialized);
    if(hStore == NULL)
    {
        return SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
    }
    pbBuffer += sizeof(DWORD) + Serialized.cbData;

    // Deserialize certificate context.
    if(!CertAddSerializedElementToStore(hStore,
                                        pbBuffer + sizeof(DWORD),
                                        *(DWORD UNALIGNED *)pbBuffer,
                                        CERT_STORE_ADD_USE_EXISTING,
                                        0,
                                        CERT_STORE_CERTIFICATE_CONTEXT_FLAG,
                                        NULL,
                                        ppCertContext))
    {
        CertCloseStore(hStore, 0);
        return SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
    }

    if(!CertCloseStore(hStore, 0))
    {
        SP_LOG_RESULT(GetLastError());
    }

    return SEC_E_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   SPGetApplicationKeys
//
//  Synopsis:   Callback to the user process and retrieve the user encryption
//              keys.
//
//  Arguments:  [pContext]  --  Schannel context.
//              [dwFlags]   --  SCH_FLAG_READ_KEY, SCH_FLAG_WRITE_KEY
//
//  History:    10-17-97   jbanes   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SP_STATUS
SPGetUserKeys(
    PSPContext  pContext,
    DWORD       dwFlags)
{
    PBYTE pbBuffer;
    PBYTE pbReadKey;
    DWORD cbReadKey;
    PBYTE pbWriteKey;
    DWORD cbWriteKey;
    SecBuffer Input;
    SecBuffer Output;
    SECURITY_STATUS scRet;
    SECPKG_CALL_INFO CallInfo;
    BOOL fWow64Client = FALSE;

    //
    // Call back into the application process and get the keys, in the
    // form of 2 opaque blobs.
    //

    DebugLog((SP_LOG_TRACE, "SPGetUserKeys: 0x%p, %d\n", pContext, dwFlags));

#ifdef _WIN64
    if(!LsaTable->GetCallInfo(&CallInfo))
    {
        scRet = STATUS_INTERNAL_ERROR;
        return SP_LOG_RESULT(scRet);
    }
    fWow64Client = (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT) != 0;
#endif

    if(fWow64Client)
    {
        Input.BufferType = SECBUFFER_DATA;
        Input.cbBuffer   = sizeof(pContext->ContextThumbprint);
        Input.pvBuffer   = &pContext->ContextThumbprint;
    }
    else
    {
        Input.BufferType = SECBUFFER_DATA;
        Input.cbBuffer   = 0;
        Input.pvBuffer   = NULL;
    }

    scRet = PerformApplicationCallback( SCH_GET_USER_KEYS,
                                        (ULONG_PTR) pContext,
                                        (ULONG_PTR) dwFlags,
                                        &Input,
                                        &Output,
                                        TRUE);
    if(!NT_SUCCESS(scRet))
    {
        DebugLog((SP_LOG_ERROR, "Error 0x%x retrieving user keys\n", scRet));
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    //
    // Parse output buffer
    //

    pbBuffer = Output.pvBuffer;

    if(dwFlags & SCH_FLAG_READ_KEY)
    {
        pContext->ReadCounter = *(PDWORD)pbBuffer;
    }
    pbBuffer += sizeof(DWORD);

    if(dwFlags & SCH_FLAG_WRITE_KEY)
    {
        pContext->WriteCounter = *(PDWORD)pbBuffer;
    }
    pbBuffer += sizeof(DWORD);

    cbReadKey = *(PDWORD)pbBuffer;
    pbBuffer += sizeof(DWORD);

    cbWriteKey = *(PDWORD)pbBuffer;
    pbBuffer += sizeof(DWORD);

    pbReadKey = pbBuffer;
    pbBuffer += cbReadKey;

    pbWriteKey = pbBuffer;
    pbBuffer += cbWriteKey;

    SP_ASSERT(pbBuffer - (PBYTE)Output.pvBuffer == (INT)Output.cbBuffer);

    //
    // Place keys into context structure.
    //

    if(dwFlags & SCH_FLAG_READ_KEY)
    {
        if(cbReadKey)
        {
            if(!SchCryptImportKey(pContext->RipeZombie->hMasterProv,
                                  pbReadKey,
                                  cbReadKey,
                                  0,
                                  CRYPT_EXPORTABLE,
                                  &pContext->hReadKey,
                                  0))
            {
                SP_LOG_RESULT(GetLastError());
                scRet = PCT_INT_INTERNAL_ERROR;
                goto done;
            }
        }
        else
        {
            pContext->hReadKey = 0;
        }
    }

    if(dwFlags & SCH_FLAG_WRITE_KEY)
    {
        if(cbWriteKey)
        {
            if(!SchCryptImportKey(pContext->RipeZombie->hMasterProv,
                                  pbWriteKey,
                                  cbWriteKey,
                                  0,
                                  CRYPT_EXPORTABLE,
                                  &pContext->hWriteKey,
                                  0))
            {
                SP_LOG_RESULT(GetLastError());
                scRet = PCT_INT_INTERNAL_ERROR;
                goto done;
            }
        }
        else
        {
            pContext->hWriteKey = 0;
        }
    }

done:

    SPExternalFree(Output.pvBuffer);

    return scRet;
}


//+---------------------------------------------------------------------------
//
//  Function:   GetUserKeysCallback
//
//  Synopsis:   Find the user context that corresponds to the passed in LSA
//              context, serialize the encryption keys, and return them in
//              the output buffer.
//
//  Arguments:  [dwLsaContext]  --  Pointer to LSA Schannel context.
//              [dwFlags]       --  SCH_FLAG_READ_KEY, SCH_FLAG_WRITE_KEY
//              [pInput]        --  Not used.
//              [pOutput]       --  (output) Serialized keys.
//
//  History:    10-17-97   jbanes   Created
//
//  Notes:      The structure of the output buffer is as follows:
//
//                  DWORD   dwReadSequence;
//                  DWORD   dwWriteSequence;
//                  DWORD   cbReadKey;
//                  BYTE    rgbReadKey[];
//                  DWORD   cbWriteKey;
//                  BYTE    rgbWriteKey[];
//
//----------------------------------------------------------------------------
SECURITY_STATUS
GetUserKeysCallback(
    ULONG_PTR dwLsaContext,
    ULONG_PTR dwFlags,
    SecBuffer *pInput,
    SecBuffer *pOutput)
{
    DWORD       cbReadKey  = 0;
    DWORD       cbWriteKey = 0;
    DWORD       cbData;
    PBYTE       pbBuffer;
    DWORD       cbBuffer;
    PSPContext  pContext;
    SECURITY_STATUS scRet;
    PSSL_USER_CONTEXT pUserContext;

    if(!SchannelInit(TRUE))
    {
        return SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
    }

    DebugLog((DEB_TRACE, "GetUserKeysCallback\n"));

    //
    // Find the user context.
    //

    if(pInput->pvBuffer != NULL &&
       pInput->cbBuffer == sizeof(CRED_THUMBPRINT))
    {
        // Search for matching context thumbprint.
        pUserContext = SslFindUserContextEx((PCRED_THUMBPRINT)pInput->pvBuffer);
        if(pUserContext == NULL)
        {
            return SP_LOG_RESULT( SEC_E_INVALID_HANDLE );
        }
    }
    else
    {
        // Search for matching lsa context
        pUserContext = SslFindUserContext(dwLsaContext);
        if(pUserContext == NULL)
        {
            return SP_LOG_RESULT( SEC_E_INVALID_HANDLE );
        }
    }

    pContext = pUserContext->pContext;
    if(pContext == NULL)
    {
        return SP_LOG_RESULT( SEC_E_INTERNAL_ERROR );
    }

    //
    // Compute size of output buffer.
    //

    if(dwFlags & SCH_FLAG_READ_KEY)
    {
        if(pContext->pReadCipherInfo->aiCipher != CALG_NULLCIPHER)
        {
            if(!pContext->hReadKey)
            {
                return SP_LOG_RESULT( SEC_E_INVALID_HANDLE );
            }
            if(!SchCryptExportKey(pContext->hReadKey,
                                  0, OPAQUEKEYBLOB, 0,
                                  NULL,
                                  &cbReadKey,
                                  0))
            {
                SP_LOG_RESULT(GetLastError());
                return SEC_E_INTERNAL_ERROR;
            }
        }
        else
        {
            cbReadKey = 0;
        }
    }

    if(dwFlags & SCH_FLAG_WRITE_KEY)
    {
        if(pContext->pWriteCipherInfo->aiCipher != CALG_NULLCIPHER)
        {
            if(!pContext->hWriteKey)
            {
                return SP_LOG_RESULT( SEC_E_INVALID_HANDLE );
            }
            if(!SchCryptExportKey(pContext->hWriteKey,
                                  0, OPAQUEKEYBLOB, 0,
                                  NULL,
                                  &cbWriteKey,
                                  0))
            {
                SP_LOG_RESULT(GetLastError());
                return SEC_E_INTERNAL_ERROR;
            }
        }
        else
        {
            cbWriteKey = 0;
        }
    }

    cbBuffer = sizeof(DWORD) +
               sizeof(DWORD) +
               sizeof(DWORD) + cbReadKey +
               sizeof(DWORD) + cbWriteKey;

    // Allocate memory for output buffer.
    pbBuffer = PvExtVirtualAlloc( cbBuffer);
    if(pbBuffer == NULL)
    {
        return SP_LOG_RESULT( SEC_E_INSUFFICIENT_MEMORY );
    }
    pOutput->BufferType = SECBUFFER_DATA;
    pOutput->cbBuffer   = cbBuffer;
    pOutput->pvBuffer   = pbBuffer;

    //
    // Serialize keys.
    //

    *(PDWORD)pbBuffer = pContext->ReadCounter;
    pbBuffer += sizeof(DWORD);

    *(PDWORD)pbBuffer = pContext->WriteCounter;
    pbBuffer += sizeof(DWORD);

    *(PDWORD)pbBuffer = cbReadKey;
    pbBuffer += sizeof(DWORD);

    *(PDWORD)pbBuffer = cbWriteKey;
    pbBuffer += sizeof(DWORD);

    if(dwFlags & SCH_FLAG_READ_KEY)
    {
        if(pContext->pReadCipherInfo->aiCipher != CALG_NULLCIPHER)
        {
            cbData = cbReadKey;
            if(!SchCryptExportKey(pContext->hReadKey,
                                  0, OPAQUEKEYBLOB, 0,
                                  pbBuffer,
                                  &cbData,
                                  0))
            {
                FreeExtVirtualAlloc(pOutput->pvBuffer, pOutput->cbBuffer);
                SP_LOG_RESULT(GetLastError());
                return SEC_E_INTERNAL_ERROR;
            }
            if(!SchCryptDestroyKey(pContext->hReadKey, 0))
            {
                SP_LOG_RESULT(GetLastError());
            }
        }
        pContext->hReadKey = 0;
    }
    pbBuffer += cbReadKey;


    if(dwFlags & SCH_FLAG_WRITE_KEY)
    {
        if(pContext->pWriteCipherInfo->aiCipher != CALG_NULLCIPHER)
        {
            cbData = cbWriteKey;
            if(!SchCryptExportKey(pContext->hWriteKey,
                                  0, OPAQUEKEYBLOB, 0,
                                  pbBuffer,
                                  &cbData,
                                  0))
            {
                FreeExtVirtualAlloc(pOutput->pvBuffer, pOutput->cbBuffer);
                SP_LOG_RESULT(GetLastError());
                return SEC_E_INTERNAL_ERROR;
            }
            if(!SchCryptDestroyKey(pContext->hWriteKey, 0))
            {
                SP_LOG_RESULT(GetLastError());
            }
        }
        pContext->hWriteKey = 0;
    }
    pbBuffer += cbWriteKey;

    return SEC_E_OK;
}


// Always called from callback routine (in the application process).
VOID *
PvExtVirtualAlloc(DWORD cb)
{
    SECURITY_STATUS Status;
    PVOID pv = NULL;
    SIZE_T Size = cb;

    Status = NtAllocateVirtualMemory(
                            GetCurrentProcess(),
                            &pv,
                            0,
                            &Size,
                            MEM_COMMIT,
                            PAGE_READWRITE);
    if(!NT_SUCCESS(Status))
    {
        pv = NULL;
    }

    DebugLog((DEB_TRACE, "SslCallbackVirtualAlloc: 0x%x bytes at 0x%x\n", cb, pv));

    return(pv);
}

// Always called from callback routine (in the application process),
// typically when an error occurs and we're cleaning up.
SECURITY_STATUS
FreeExtVirtualAlloc(PVOID pv, SIZE_T cbMem)
{
    cbMem = 0;
    return(NtFreeVirtualMemory(GetCurrentProcess(),
                                &pv,
                                &cbMem,
                                MEM_RELEASE));
}

// Always called from the LSA process, when freeing memory allocated
// by a callback function.
SECURITY_STATUS
SPFreeUserAllocMemory(PVOID pv, SIZE_T cbMem)
{
    SECPKG_CALL_INFO CallInfo;

    if(LsaTable->GetCallInfo(&CallInfo))
    {
        SECURITY_STATUS Status;
        HANDLE hProcess;

        hProcess = OpenProcess(PROCESS_VM_OPERATION,
                               FALSE,
                               CallInfo.ProcessId);
        if(hProcess == NULL)
        {
            return SP_LOG_RESULT(GetLastError());
        }

        cbMem = 0;
        Status = NtFreeVirtualMemory(hProcess,
                                     &pv,
                                     &cbMem,
                                     MEM_RELEASE);
        if(!NT_SUCCESS(Status))
        {
            SP_LOG_RESULT(Status);
        }

        CloseHandle(hProcess);
    }

    DebugLog((DEB_TRACE, "SslCallbackVirtualFree: 0x%x bytes at 0x%x\n", cbMem, pv));

    return SEC_E_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\lsa\debug.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       debug.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10-02-96   RichardW   Created
//
//----------------------------------------------------------------------------

#include "sslp.h"




#if DBG         // NOTE:  This file not compiled for retail builds





DEBUG_KEY   SslDebugKeys[] = { {DEB_ERROR,            "Error"},
                               {DEB_WARN,             "Warning"},
                               {DEB_TRACE,            "Trace"},
                               {DEB_TRACE_FUNC,       "Func"},
                               {DEB_TRACE_CRED,       "Cred"},
                               {DEB_TRACE_CTXT,       "Ctxt"},
                               {DEB_TRACE_MAPPER,     "Mapper"},
                               {0, NULL}
                             };

DEFINE_DEBUG2( Ssl );

void
InitDebugSupport(
    HKEY hGlobalKey)
{
    BYTE  szFileName[MAX_PATH];
    BYTE  szDirectoryName[MAX_PATH];
    DWORD dwSize;
    DWORD dwType;
    DWORD err;
    DWORD fVal;
    SYSTEMTIME stTime;
    HKEY hkBase;
    DWORD disp;

    SslInitDebug(SslDebugKeys);

//    SslInfoLevel |= DEB_TRACE_MAPPER ;

    if(hGlobalKey)
    {
        // We're running in the lsass.exe process.
        hkBase = hGlobalKey;
    }
    else
    {
        err = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                             SP_REG_KEY_BASE,
                             0,
                             TEXT(""),
                             REG_OPTION_NON_VOLATILE,
                             KEY_READ,
                             NULL,
                             &hkBase,
                             &disp);
        if(err)
        {
            DebugLog((DEB_WARN,"Failed to open SCHANNEL key: 0x%x\n", err));
            return;
        }
    }

    dwSize = sizeof(DWORD);
    err = RegQueryValueEx(hkBase, SP_REG_VAL_LOGLEVEL, NULL, &dwType, (PUCHAR)&fVal, &dwSize);
    if(!err) 
    {
        g_dwInfoLevel = fVal;
    }


    dwSize = sizeof(DWORD);
    err = RegQueryValueEx(hkBase, SP_REG_VAL_BREAK, NULL, &dwType, (PUCHAR)&fVal, &dwSize);
    if(!err) 
    {
        g_dwDebugBreak = fVal;
    }

    if(g_hfLogFile)
    {
        CloseHandle(g_hfLogFile);
        g_hfLogFile = NULL;
    }
    dwSize = 255;
    err = RegQueryValueExA(hkBase, SP_REG_VAL_LOGFILE, NULL, &dwType, szDirectoryName, &dwSize);
    
    if(!err)
    {
        if(hGlobalKey)
        {
            strcpy(szFileName, szDirectoryName);
            strcat(szFileName, "\\Schannel.log");
        }
        else
        {
            sprintf(szFileName,"%s\\Schannel_%d.log",szDirectoryName,GetCurrentProcessId());
        }

        g_hfLogFile = CreateFileA(szFileName,
                                  GENERIC_WRITE,
                                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  NULL, OPEN_ALWAYS,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL);
        if(g_hfLogFile)
        {
            SetFilePointer(g_hfLogFile, 0, 0, FILE_END);
        }

        GetLocalTime(&stTime);

        DebugLog((SP_LOG_ERROR, "==== SCHANNEL LOG INITIATED %d/%d/%d %02d:%02d:%02d ====\n",
                        stTime.wMonth, stTime.wDay, stTime.wYear,
                        stTime.wHour, stTime.wMinute, stTime.wSecond));

        dwSize = sizeof(szFileName);
        if(GetModuleFileNameA(NULL, szFileName, dwSize) != 0)
        {
            DebugLog((SP_LOG_ERROR, "Module name:%s\n", szFileName));
        }
    }

    if(hGlobalKey == NULL)
    {
        RegCloseKey(hkBase);
    }
}

VOID
UnloadDebugSupport(
    VOID
    )
{
    SslUnloadDebug();
}
#else // DBG

#pragma warning(disable:4206)   // Disable the empty translation unit
                                // warning/error

#endif  // NOTE:  This file not compiled for retail builds
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\lsa\ctxtapi.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ctxtapi.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10-02-96   RichardW   Created
//
//----------------------------------------------------------------------------

#include "sslp.h"

#include <ssl2msg.h>
#include <ssl3msg.h>
#include <ssl2prot.h>
#include <sslcache.h>
#include <lsasecpk.h>

NTSTATUS NTAPI
SslPurgeSessionCache(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus);

NTSTATUS NTAPI
SslSessionCacheInfo(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus);

NTSTATUS NTAPI
SslGetPerfmonInfo(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus);


SECURITY_STATUS SEC_ENTRY
SpInitLsaModeContext(
    LSA_SEC_HANDLE      dwCredHandle,
    LSA_SEC_HANDLE      dwCtxtHandle,
    PSECURITY_STRING    pszTargetName,
    ULONG               fContextReq,
    ULONG               TargetDataRep,
    PSecBufferDesc      pInput,
    PLSA_SEC_HANDLE     pdwNewContext,
    PSecBufferDesc      pOutput,
    PULONG              pfContextAttr,
    PTimeStamp          ptsExpiry,
    PBYTE               pfMapContext,
    PSecBuffer          pContextData)
{
    PSPContext          pContext = NULL;
    PSPCredentialGroup  pCred = NULL;
    SPBuffer            CommOut;
    SPBuffer            CommIn;
    PSecBuffer          pInToken = NULL;
    PSecBuffer          pOutToken = NULL;
    PSecBuffer          pExtra = NULL;

    DWORD       fAttr = ISC_RET_REPLAY_DETECT   |
                        ISC_RET_SEQUENCE_DETECT |
                        ISC_RET_CONFIDENTIALITY |
                        ISC_RET_STREAM;

    DWORD       fSchContext = CONTEXT_FLAG_CLIENT;

    NTSTATUS    Status;
    ANSI_STRING String;
    int         i;

    SP_STATUS   pctRet = PCT_ERR_OK;

    #if DBG
        DebugLog((DEB_TRACE, "SpInitLsaModeContext(0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x)\n",
            dwCredHandle, dwCtxtHandle, pszTargetName, fContextReq, TargetDataRep,
            pInput, pdwNewContext, pOutput, pfContextAttr, ptsExpiry, pfMapContext,
            pContextData));
        if(pszTargetName)
        {
            DebugLog((DEB_TRACE, "pszTargetName:<%ls>\n",pszTargetName->Buffer));
        }
    #endif


    /* These flags are never allowed */
    if (fContextReq & (ISC_REQ_DELEGATE | ISC_REQ_PROMPT_FOR_CREDS ))
    {
        TRACE_EXIT( SpInitLsaModeContext, SEC_E_UNSUPPORTED_FUNCTION );

        return SP_LOG_RESULT( SEC_E_UNSUPPORTED_FUNCTION );
    }


    /* Initialize output buffer locations */
    for (i = 0; i < (int)pOutput->cBuffers; i++ )
    {
        switch( ( pOutput->pBuffers[i].BufferType ) & (~(SECBUFFER_ATTRMASK)))
        {
            case SECBUFFER_EMPTY:
                if(!pOutToken && (fContextReq & ISC_REQ_ALLOCATE_MEMORY))
                    pOutToken = &pOutput->pBuffers[i];
                break;

            case SECBUFFER_TOKEN:
                    pOutToken = &pOutput->pBuffers[i];
                break;
            case SECBUFFER_DATA:
            case SECBUFFER_STREAM_HEADER:
            case SECBUFFER_STREAM_TRAILER:
            default:
                break;
        }
    }

    if ( pOutToken == NULL )
    {
        TRACE_EXIT( SpInitLsaModeContext, SEC_E_INVALID_TOKEN );

        return SP_LOG_RESULT( SEC_E_INVALID_TOKEN );
    }

    pOutToken->BufferType = SECBUFFER_TOKEN;

    if ( fContextReq & ISC_REQ_ALLOCATE_MEMORY )
    {
        CommOut.pvBuffer = NULL;
        CommOut.cbBuffer = 0;
        CommOut.cbData = 0;

        fAttr |= ISC_RET_ALLOCATED_MEMORY;

        pOutToken->pvBuffer = NULL;
        pOutToken->cbBuffer = 0;
    }
    else
    {

        if ( pOutToken->pvBuffer == NULL )
        {
            TRACE_EXIT( SpInitLsaModeContext, SEC_E_INSUFFICIENT_MEMORY );

            return SP_LOG_RESULT( SEC_E_INSUFFICIENT_MEMORY );
        }

    }

    CommOut.pvBuffer = pOutToken->pvBuffer;
    CommOut.cbBuffer = pOutToken->cbBuffer;
    CommOut.cbData = 0;

    if ( fContextReq & (ISC_REQ_EXTENDED_ERROR) )
    {
        fAttr       |= ISC_RET_EXTENDED_ERROR;
        fSchContext |= CONTEXT_FLAG_EXT_ERR;
    }

    if ( fContextReq & (ISC_REQ_CONNECTION) )
    {
        fAttr       |= ISC_REQ_CONNECTION;
        fSchContext |= CONTEXT_FLAG_CONNECTION_MODE;
    }

    if ( fContextReq & (ISC_REQ_MUTUAL_AUTH) )
    {
        // Validate the server certificate.
        fAttr       |= ISC_RET_MUTUAL_AUTH;
        fSchContext |= CONTEXT_FLAG_MUTUAL_AUTH;
        fSchContext &= ~CONTEXT_FLAG_MANUAL_CRED_VALIDATION;

        if ( fContextReq & (ISC_REQ_MANUAL_CRED_VALIDATION))
        {
            // These flags are mutually exclusive
            return SP_LOG_RESULT( SEC_E_UNSUPPORTED_FUNCTION );
        }
    }
    else
    {
        if ( fContextReq & (ISC_REQ_MANUAL_CRED_VALIDATION))
        {
            fAttr       |= ISC_RET_MANUAL_CRED_VALIDATION;
            fSchContext |= CONTEXT_FLAG_MANUAL_CRED_VALIDATION;
        }

        // Turn off automatic credential validation if so specified in registry.
        if(g_fManualCredValidation)
        {
            fSchContext |= CONTEXT_FLAG_MANUAL_CRED_VALIDATION;
        }
    }

    if ( fContextReq & (ISC_REQ_USE_SUPPLIED_CREDS))
    {
        fAttr       |= ISC_REQ_USE_SUPPLIED_CREDS;
        fSchContext |= CONTEXT_FLAG_NO_INCOMPLETE_CRED_MSG;
    }


    if( pfContextAttr )
    {
        *pfContextAttr = fAttr;
    }

    if ( dwCtxtHandle == 0 )
    {
        pContext = SPContextCreate( pszTargetName->Buffer );

        if(pContext == NULL)
        {
            TRACE_EXIT( SpInitLsaModeContext, SEC_E_INSUFFICIENT_MEMORY );

            return SP_LOG_RESULT( SEC_E_INSUFFICIENT_MEMORY );
        }
        pContext->Flags |= fSchContext;

        pCred = (PSPCredentialGroup) dwCredHandle ;

        if(pctRet == PCT_ERR_OK)
        {
            pctRet = SPContextSetCredentials(pContext, pCred);
        }

        if(pctRet != PCT_ERR_OK)
        {

            SPContextDelete(pContext);

            *pdwNewContext = 0;

            TRACE_EXIT( SpInitLsaModeContext, PctTranslateError( pctRet ));

            return SP_LOG_RESULT( PctTranslateError(pctRet) );
        }


        pctRet = pContext->InitiateHello( pContext, &CommOut, TRUE);

        if ( (CommOut.cbBuffer == 0) &&
             (pctRet == PCT_INT_BUFF_TOO_SMALL) )
        {
            SPContextDelete(pContext);

            TRACE_EXIT( SpInitLsaModeContext, SEC_E_INSUFFICIENT_MEMORY );
            return SP_LOG_RESULT( SEC_E_INSUFFICIENT_MEMORY );
        }

        if ( pctRet != PCT_ERR_OK )
        {
            SPContextDelete(pContext);

            *pdwNewContext = 0;

            TRACE_EXIT( SpInitLsaModeContext, PctTranslateError( pctRet) );

            return SP_LOG_RESULT( PctTranslateError(pctRet) );
        }

        if ( fContextReq & ISC_REQ_ALLOCATE_MEMORY )
        {
            //
            // Easy:  The caller asked for us to allocate memory for them, so
            // let the LSA do it.
            //

            pOutToken->pvBuffer = CommOut.pvBuffer ;

        }
        else
        {
            //
            // The caller has a buffer that we're supposed to use.  Make sure we
            // can fit.
            //

            if ( (ULONG) CommOut.cbBuffer <= pOutToken->cbBuffer  )
            {
                RtlCopyMemory(  pOutToken->pvBuffer,
                                CommOut.pvBuffer,
                                CommOut.cbBuffer );
            }
            else
            {
                DebugLog(( DEB_TRACE, "Supplied buffer is too small\n" ));

                SPContextDelete( pContext );

                TRACE_EXIT( SpInitLsaModeContext, SEC_E_INSUFFICIENT_MEMORY );
                return SP_LOG_RESULT( SEC_E_INSUFFICIENT_MEMORY );
            }

        }

        *pdwNewContext = (LSA_SEC_HANDLE) pContext ;

        pOutToken->pvBuffer = CommOut.pvBuffer;
        pOutToken->cbBuffer = CommOut.cbData;

        #if DBG
            DebugLog((
                DEB_TRACE,
                "Output:  type:0x%8.8x, pv:0x%8.8x, cb:0x%x\n",
                pOutToken->BufferType,
                pOutToken->pvBuffer,
                pOutToken->cbBuffer));

            if(pOutToken->pvBuffer)
            {
                DBG_HEX_STRING(DEB_BUFFERS, pOutToken->pvBuffer, pOutToken->cbBuffer);
            }
        #endif

    }
    else
    {
        /* Initialize input buffer locations */
        for (i = 0; i < (int)pInput->cBuffers; i++ )
        {
            switch( (pInput->pBuffers[i].BufferType & (~SECBUFFER_ATTRMASK)) )
            {
                case SECBUFFER_TOKEN:
                case SECBUFFER_TOKEN | SECBUFFER_READONLY:
                    pInToken = &pInput->pBuffers[i];
                    break;

                case SECBUFFER_EMPTY:
                    if(!pInToken)
                    {
                        pInToken = &pInput->pBuffers[i];
                    }
                    else if(!pExtra)
                    {
                        pExtra = &pInput->pBuffers[i];
                    }
                break;

                case SECBUFFER_DATA:
                case SECBUFFER_STREAM_HEADER:
                case SECBUFFER_STREAM_TRAILER:
                default:
                    break;
            }
        }

        #if DBG
            if(pInToken)
            {
                DebugLog((
                    DEB_TRACE,
                    "Input:  type:0x%8.8x, pv:0x%8.8x, cb:0x%x\n",
                    pInToken->BufferType,
                    pInToken->pvBuffer,
                    pInToken->cbBuffer));

                if(pInToken->pvBuffer)
                {
                    DBG_HEX_STRING(DEB_BUFFERS, pInToken->pvBuffer, pInToken->cbBuffer);
                }
            }
            if(pExtra)
            {
                DebugLog((
                    DEB_TRACE,
                    "Extra:  type:0x%8.8x, pv:0x%8.8x, cb:0x%x\n",
                    pExtra->BufferType,
                    pExtra->pvBuffer,
                    pExtra->cbBuffer));
            }
        #endif

        if(pInToken == NULL)
        {
            CommIn.pvBuffer = NULL;
            CommIn.cbBuffer = 0;
            CommIn.cbData   = 0;
        }
        else
        {
            CommIn.pvBuffer = pInToken->pvBuffer;
            CommIn.cbBuffer = pInToken->cbBuffer;
            CommIn.cbData   = pInToken->cbBuffer;
        }

        pContext = (PSPContext) dwCtxtHandle ;
        if ( dwCredHandle )
        {
            pCred = (PSPCredentialGroup) dwCredHandle ;
        }

        if( pContext == NULL || pCred == NULL )
        {
            TRACE_EXIT( SpInitLsaModeContext, SEC_E_INVALID_HANDLE );

            return SP_LOG_RESULT( SEC_E_INVALID_HANDLE );
        }

        pContext->Flags |= fSchContext;

        pctRet = SPContextSetCredentials(pContext, pCred);

        if(pctRet == PCT_ERR_OK)
        {
            // HACKHACK - adjust SSL3/TLS1 state
            if(pContext->State == SSL3_STATE_RENEGOTIATE)
            {
                pContext->State = SSL3_STATE_GEN_HELLO_REQUEST;
            }

            pctRet = pContext->ProtocolHandler( pContext,
                                                &CommIn,
                                                &CommOut);
        }


        if(pctRet == PCT_INT_INCOMPLETE_MSG)
        {
            if(pExtra)
            {
                pExtra->BufferType = SECBUFFER_MISSING | SECBUFFER_UNMAPPED ;
                pExtra->cbBuffer = CommIn.cbData -  pInToken->cbBuffer;
                pExtra->pvBuffer = NULL ;
            }
        }
        else
        {
            pOutToken->pvBuffer = CommOut.pvBuffer;
            pOutToken->cbBuffer = CommOut.cbData;
        }

        if(pctRet == PCT_INT_BUFF_TOO_SMALL)
        {
            pOutToken->BufferType |= SECBUFFER_UNMAPPED;
        }

        #if DBG
            if(pOutToken)
            {
                DebugLog((
                    DEB_TRACE,
                    "Output:  type:0x%8.8x, pv:0x%8.8x, cb:0x%x\n",
                    pOutToken->BufferType,
                    pOutToken->pvBuffer,
                    pOutToken->cbBuffer));

                if(pOutToken->pvBuffer)
                {
                    DBG_HEX_STRING(DEB_BUFFERS, pOutToken->pvBuffer, pOutToken->cbBuffer);
                }
            }
            if(pExtra)
            {
                DebugLog((
                    DEB_TRACE,
                    "Extra:  type:0x%8.8x, pv:0x%8.8x, cb:0x%x\n",
                    pExtra->BufferType,
                    pExtra->pvBuffer,
                    pExtra->cbBuffer));
            }
        #endif


        if(!SP_FATAL(pctRet))
        {
            *pdwNewContext = dwCtxtHandle ;
        }

        if(PCT_ERR_OK != pctRet)
        {
            TRACE_EXIT( SpInitLsaModeContext, PctTranslateError( pctRet ));

            return SP_LOG_RESULT( PctTranslateError(pctRet) );
        }

        if(pInToken)
        {
            if(CommIn.cbData < pInToken->cbBuffer && pExtra)
            {
                pExtra->BufferType = SECBUFFER_EXTRA | SECBUFFER_UNMAPPED ;
                pExtra->cbBuffer = pInToken->cbBuffer - CommIn.cbData;
                pExtra->pvBuffer = NULL ;
            }
        }
    }

    if ( (pContext->State == SP_STATE_CONNECTED) &&
         ( (pContext->Flags & CONTEXT_FLAG_MAPPED) == 0 ) )
    {
        //
        // Need to map the context back down to the user process.  It
        // doesn't get any scarier than this:
        //

        *pfMapContext = TRUE ;

        DebugOut(( DEB_TRACE, "Mapping context to usermode\n" ));

        pctRet = SPContextSerialize(pContext,
                                    SslRelocateToken,
                                    (PUCHAR *) &pContextData->pvBuffer,
                                    &pContextData->cbBuffer,
                                    TRUE);
        if(PCT_ERR_OK != pctRet)
        {
            return SP_LOG_RESULT( PctTranslateError(pctRet) );
        }

        pContext->Flags |= CONTEXT_FLAG_MAPPED ;

        LogHandshakeInfoEvent(pContext->RipeZombie->fProtocol,
                              pContext->pCipherInfo,
                              pContext->pHashInfo,
                              pContext->pKeyExchInfo,
                              pContext->RipeZombie->dwExchStrength);
    }

    if(ptsExpiry != NULL)
    {
        if(pContext->RipeZombie->pRemoteCert != NULL)
        {
            ptsExpiry->QuadPart = *((LONGLONG *)&pContext->RipeZombie->pRemoteCert->pCertInfo->NotAfter);
        }
        else
        {
            ptsExpiry->QuadPart = MAXTIMEQUADPART;
        }
    }

    if(pContext->State == SP_STATE_CONNECTED ||
       pContext->State == SP_STATE_SHUTDOWN)
    {
        return SEC_E_OK;
    }
    else
    {
        return SEC_I_CONTINUE_NEEDED;
    }
}


SECURITY_STATUS SEC_ENTRY
SpMoveContextToUser(    ULONG       dwCtxtHandle,
                        PSecBuffer  pContextBuffer)
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}

SECURITY_STATUS
SEC_ENTRY
SpDeleteContext(
    LSA_SEC_HANDLE dwCtxtHandle)
{
    PSPContext  pContext ;

    DebugLog((DEB_TRACE, "SpDeleteContext(0x%x)\n", dwCtxtHandle));

    pContext = (PSPContext) dwCtxtHandle ;

    SPContextDelete( pContext );

    return( SEC_E_OK );
}


SECURITY_STATUS
SEC_ENTRY
SpApplyControlToken(
    LSA_SEC_HANDLE  dwCtxtHandle,
    PSecBufferDesc  pInput)
{
    PSPContext pContext;
    PSecBuffer Buffer ;
    DWORD cbState;

    DebugLog((DEB_TRACE, "SpApplyControlToken(0x%x, 0x%x)\n", dwCtxtHandle, pInput));

    pContext = (PSPContext) dwCtxtHandle ;

    if ( pInput->cBuffers != 1 )
    {
        return SP_LOG_RESULT(SEC_E_INVALID_TOKEN);
    }

    Buffer = pInput->pBuffers ;

    if(Buffer->cbBuffer < sizeof(DWORD))
    {
        return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
    }

    switch(*(DWORD *)Buffer->pvBuffer)
    {
        case SCHANNEL_RENEGOTIATE:
        {
            PDWORD  RedoData;
            PBYTE   pbReadKey;
            DWORD   cbReadKey;

            DebugLog((DEB_TRACE, "SCHANNEL_RENEGOTIATE\n"));

            if(Buffer->cbBuffer < sizeof(DWORD) * 2)
            {
                return SP_LOG_RESULT(SEC_E_INVALID_TOKEN);
            }

            RedoData = (DWORD *)Buffer->pvBuffer;

            if(RedoData[1] != SSL3_STATE_RENEGOTIATE &&
               RedoData[1] != PCT1_STATE_RENEGOTIATE)
            {
                return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
            }

            pContext->State       = RedoData[1];

            return SEC_E_OK;
        }

        case SCHANNEL_SHUTDOWN:
            DebugLog((DEB_TRACE, "SCHANNEL_SHUTDOWN\n"));
            pContext->State = SP_STATE_SHUTDOWN_PENDING;
            return SEC_E_OK;

        case SCHANNEL_ALERT:
        {
            SCHANNEL_ALERT_TOKEN *pAlertToken;

            DebugLog((DEB_TRACE, "SCHANNEL_TLS1_ALERT\n"));

            if(Buffer->cbBuffer < sizeof(SCHANNEL_ALERT_TOKEN))
            {
                return SP_LOG_RESULT(SEC_E_INVALID_TOKEN);
            }
            pAlertToken = (SCHANNEL_ALERT_TOKEN *)Buffer->pvBuffer;

            // Alerts are only supported in SSL3 and TLS1
            if(!(pContext->RipeZombie->fProtocol & SP_PROT_SSL3TLS1))
            {
                return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
            }

            // Reality check alert values.
            if(pAlertToken->dwAlertType   >= 0x100 || 
               pAlertToken->dwAlertNumber >= 0x100)
            {
                return SP_LOG_RESULT(SEC_E_INVALID_TOKEN);
            }

            SetTls1Alert(pContext, 
                         (BYTE)pAlertToken->dwAlertType,
                         (BYTE)pAlertToken->dwAlertNumber);

            #if DBG
                DebugLog((DEB_TRACE,
                          "AlertLevel:0x%x, AlertNumber:0x%x\n",
                          pAlertToken->dwAlertType,
                          pAlertToken->dwAlertNumber));
            #endif

            return SEC_E_OK;
        }

        case SCHANNEL_SESSION:
        {
            SCHANNEL_SESSION_TOKEN *pSessionToken;
            SECURITY_STATUS Status = SEC_E_UNSUPPORTED_FUNCTION;
    
            DebugLog((DEB_TRACE, "SCHANNEL_SESSION\n"));
    
            if(pContext->RipeZombie == NULL)
            {
                return SP_LOG_RESULT(SEC_E_INVALID_HANDLE);
            }
    
            if(Buffer->cbBuffer < sizeof(SCHANNEL_SESSION_TOKEN))
            {
                return SP_LOG_RESULT(SEC_E_INVALID_TOKEN);
            }
            pSessionToken = (SCHANNEL_SESSION_TOKEN *)Buffer->pvBuffer;
    
            if(pSessionToken->dwFlags & SSL_SESSION_DISABLE_RECONNECTS)
            {
                // Disable reconnects
                pContext->RipeZombie->ZombieJuju = FALSE;
                Status = SEC_E_OK;
            }
    
            if(pSessionToken->dwFlags & SSL_SESSION_ENABLE_RECONNECTS)
            {
                // Enable reconnects
                if(pContext->RipeZombie->DeferredJuju)
                {
                    pContext->RipeZombie->ZombieJuju = TRUE;
                    pContext->RipeZombie->DeferredJuju = FALSE;
                    Status = SEC_E_OK;
                }
            }
    
            return Status;
        }

        default:
            return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
    }
}


VOID
SEC_ENTRY
SpLogonTerminated(PLUID  pLogonId)
{
    return;
}


SECURITY_STATUS SEC_ENTRY
SpAcceptLsaModeContext(
                            LSA_SEC_HANDLE  dwCredHandle,
                            LSA_SEC_HANDLE  dwCtxtHandle,
                            PSecBufferDesc  pInput,
                            ULONG           fContextReq,
                            ULONG           TargetDataRep,
                            PLSA_SEC_HANDLE pdwNewContext,
                            PSecBufferDesc  pOutput,
                            PULONG          pfContextAttr,
                            PTimeStamp      ptsExpiry,
                            PBYTE           pfMapContext,
                            PSecBuffer      pContextData)
{
    PSPContext  pContext = NULL;
    PSPCredentialGroup pCred = NULL;
    SPBuffer CommOut;
    SPBuffer CommIn;
    PSecBuffer pInToken = NULL;
    PSecBuffer pOutToken = NULL;
    PSecBuffer pExtra = NULL;
    unsigned long fAttr = ASC_RET_REPLAY_DETECT | 
                          ASC_RET_SEQUENCE_DETECT | 
                          ASC_RET_CONFIDENTIALITY |
                          ASC_RET_STREAM;

    DWORD         fSchContext = 0;
    int i;
    SP_STATUS pctRet = PCT_ERR_OK;

    TRACE_ENTER( SpAcceptLsaModeContext );

#if DBG
        DebugLog((DEB_TRACE, "SpAcceptLsaModeContext(0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x)\n",
            dwCredHandle, dwCtxtHandle, pInput, fContextReq, TargetDataRep, pdwNewContext,
            pOutput, pfContextAttr, ptsExpiry, pfMapContext, pContextData));
#endif


    // This flag is never allowed
    if(fContextReq & ASC_REQ_DELEGATE)
    {
        TRACE_EXIT( SpAcceptLsaModeContext, SEC_E_UNSUPPORTED_FUNCTION );
        return SEC_E_UNSUPPORTED_FUNCTION;
    }

    if ( fContextReq & ASC_REQ_MUTUAL_AUTH )
    {
        fSchContext |= CONTEXT_FLAG_MUTUAL_AUTH;
    }

    /* Initialize input buffer locations */
    for (i = 0; i < (int)pInput->cBuffers; i++ )
    {
        switch( pInput->pBuffers[i].BufferType & (~(SECBUFFER_ATTRMASK)) )
        {
            case SECBUFFER_TOKEN:
            case SECBUFFER_TOKEN | SECBUFFER_READONLY:
                pInToken = &pInput->pBuffers[i];
                break;

            case SECBUFFER_EMPTY:
                if(!pInToken)
                {
                    pInToken = &pInput->pBuffers[i];
                }
                else if(!pExtra)
                {
                    pExtra = &pInput->pBuffers[i];
                }
                break;

            case SECBUFFER_DATA:
            case SECBUFFER_STREAM_HEADER:
            case SECBUFFER_STREAM_TRAILER:
            default:
                break;
        }
    }

    #if DBG
        if(pInToken)
        {
            DebugLog((
                DEB_TRACE,
                "Input:  type:0x%8.8x, pv:0x%8.8x, cb:0x%x\n",
                pInToken->BufferType,
                pInToken->pvBuffer,
                pInToken->cbBuffer));

            if(pInToken->pvBuffer)
            {
                DBG_HEX_STRING(DEB_BUFFERS, pInToken->pvBuffer, pInToken->cbBuffer);
            }
        }
        if(pExtra)
        {
            DebugLog((
                DEB_TRACE,
                "Extra:  type:0x%8.8x, pv:0x%8.8x, cb:0x%x\n",
                pExtra->BufferType,
                pExtra->pvBuffer,
                pExtra->cbBuffer));
        }
    #endif


    /* Initialize output buffer locations */

    for (i = 0; i < (int) pOutput->cBuffers; i++ )
    {
        switch( pOutput->pBuffers[i].BufferType & (~(SECBUFFER_ATTRMASK)) )
        {
            case SECBUFFER_EMPTY:
                if(!pOutToken && (fContextReq & ASC_REQ_ALLOCATE_MEMORY))
                    pOutToken = &pOutput->pBuffers[i];
                break;
            case SECBUFFER_TOKEN:
                    pOutToken = &pOutput->pBuffers[i];
                break;
            case SECBUFFER_DATA:
            case SECBUFFER_STREAM_HEADER:
            case SECBUFFER_STREAM_TRAILER:
            default:
                break;
        }
    }

    if(pOutToken == NULL)
    {
        TRACE_EXIT( SpAcceptLsaModeContext, SEC_E_INVALID_TOKEN );

        return SEC_E_INVALID_TOKEN;
    }

    if ( !pExtra )
    {
        DebugOut(( DEB_TRACE, " Warning - no Empty security buffer\n"));
    }

    pOutToken->BufferType = SECBUFFER_TOKEN;

    if(pInToken && pInToken->BufferType == SECBUFFER_TOKEN)
    {
        CommIn.pvBuffer = pInToken->pvBuffer;
        CommIn.cbBuffer = pInToken->cbBuffer;
        CommIn.cbData   = pInToken->cbBuffer;
    }
    else
    {
        CommIn.pvBuffer = NULL;
        CommIn.cbBuffer = 0;
        CommIn.cbData = 0;
    }

    if (fContextReq & ASC_REQ_ALLOCATE_MEMORY)
    {
        fAttr |= ASC_RET_ALLOCATED_MEMORY;
        pOutToken->pvBuffer = NULL;
        pOutToken->cbBuffer = 0;
    }

    CommOut.pvBuffer = pOutToken->pvBuffer;
    CommOut.cbBuffer = pOutToken->cbBuffer;
    CommOut.cbData = 0;

    if (fContextReq & (ASC_REQ_EXTENDED_ERROR))
    {
        fAttr       |= ASC_RET_EXTENDED_ERROR;
        fSchContext |= CONTEXT_FLAG_EXT_ERR;
    }

    if ( fContextReq & (ASC_REQ_CONNECTION) )
    {
        fAttr       |= ASC_RET_CONNECTION;
        fSchContext |= CONTEXT_FLAG_CONNECTION_MODE;
    }

    if (pfContextAttr)
    {
        *pfContextAttr = fAttr;
    }

    if ( dwCtxtHandle == 0 )
    {
        pContext = SPContextCreate(NULL);
        if (pContext == NULL)
        {
            TRACE_EXIT( SpAcceptLsaModeContext, SEC_E_INSUFFICIENT_MEMORY );

            return SEC_E_INSUFFICIENT_MEMORY;
        }

    }
    else
    {
        pContext = (PSPContext) dwCtxtHandle ;
    }

    if ( dwCredHandle == 0 )
    {
        pCred = NULL ;
    }
    else
    {
        pCred = (PSPCredentialGroup) dwCredHandle ;
    }

    if ( (pContext == NULL) || (pCred == NULL) )
    {
        if ( dwCtxtHandle == 0 )
        {
            SPContextDelete( pContext );
        }

        TRACE_EXIT( SpAcceptLsaModeContext, SEC_E_INVALID_HANDLE );

        return( SEC_E_INVALID_HANDLE );
    }

    pctRet = SPContextSetCredentials(pContext, pCred);

    pContext->Flags |= fSchContext;

    if ( pctRet == PCT_ERR_OK )
    {
        pctRet = pContext->ProtocolHandler( pContext, &CommIn, &CommOut);
    }

    if ( dwCtxtHandle == 0 )
    {
        if ( pctRet != PCT_ERR_OK )
        {
            SPContextDelete( pContext );
        }
        else
        {
            *pdwNewContext = (LSA_SEC_HANDLE) pContext ;
        }
    }
    else
    {
        *pdwNewContext = (LSA_SEC_HANDLE) pContext ;
    }

    if (CommOut.cbData == 0 && pctRet == PCT_INT_BUFF_TOO_SMALL)
    {
        TRACE_EXIT( SpAcceptLsaModeContext, SEC_E_INSUFFICIENT_MEMORY );

        return SEC_E_INSUFFICIENT_MEMORY;
    }

    if (pctRet == PCT_INT_INCOMPLETE_MSG)
    {
        if(pExtra)
        {
            pExtra->BufferType = SECBUFFER_MISSING | SECBUFFER_UNMAPPED ;
            pExtra->cbBuffer = CommIn.cbData -  pInToken->cbBuffer;
            pExtra->pvBuffer = NULL ;

            DebugOut(( DEB_TRACE, "Incomplete message, needs %d more bytes\n",
                            pExtra->cbBuffer ));

        }
        else
        {
            DebugOut(( DEB_TRACE, "No Empty buffer for returning missing info!\n" ));
        }
    }
    else
    {
        pOutToken->pvBuffer = CommOut.pvBuffer;
        pOutToken->cbBuffer = CommOut.cbData;
    }

    if(pctRet == PCT_INT_BUFF_TOO_SMALL)
    {
        pOutToken->BufferType |= SECBUFFER_UNMAPPED;
    }

    if(pOutToken->cbBuffer == 0)
    {
        // Don't return an output token if the output buffer is
        // empty. Also, make sure that the extended error flag is
        // turned off.
        pOutToken->BufferType = SECBUFFER_EMPTY;

        if(pfContextAttr)
        {
            *pfContextAttr &= ~ASC_RET_EXTENDED_ERROR;
        }
    }

    if (PCT_ERR_OK != pctRet)
    {
        TRACE_EXIT( SpAcceptLsaModeContext, PctTranslateError( pctRet ) );

        return PctTranslateError(pctRet);
    }

    if(pInToken)
    {
        if (CommIn.cbData < pInToken->cbBuffer && pExtra)
        {
            pExtra->BufferType = SECBUFFER_EXTRA | SECBUFFER_UNMAPPED ;
            pExtra->cbBuffer = pInToken->cbBuffer - CommIn.cbData;
            pExtra->pvBuffer = NULL ;

            DebugOut(( DEB_TRACE, "Extra data, needs to be mapped back: %d\n", pExtra->cbBuffer ));
        }
    }

    if ( (pContext->State == SP_STATE_CONNECTED) &&
         ( (pContext->Flags & CONTEXT_FLAG_MAPPED) == 0 ) )
    {
        //
        // Need to map the context back down to the user process.  It
        // doesn't get any scarier than this:
        //

        *pfMapContext = TRUE ;

        DebugOut(( DEB_TRACE, "Mapping context to usermode\n" ));

        pctRet = SPContextSerialize(pContext,
                                    SslRelocateToken,
                                    (PUCHAR *) &pContextData->pvBuffer,
                                    &pContextData->cbBuffer,
                                    TRUE);

        if (PCT_ERR_OK != pctRet)
        {
            TRACE_EXIT( SpAcceptLsaModeContext, PctTranslateError( pctRet ) );

            return PctTranslateError(pctRet);
        }

        pContext->Flags |= CONTEXT_FLAG_MAPPED ;

        LogHandshakeInfoEvent(pContext->RipeZombie->fProtocol,
                              pContext->pCipherInfo,
                              pContext->pHashInfo,
                              pContext->pKeyExchInfo,
                              pContext->RipeZombie->dwExchStrength);
    }


    #if DBG
        if(pOutToken)
        {
            DebugLog((
                DEB_TRACE,
                "Output:  type:0x%8.8x, pv:0x%8.8x, cb:0x%x\n",
                pOutToken->BufferType,
                pOutToken->pvBuffer,
                pOutToken->cbBuffer));

            if(pOutToken->pvBuffer)
            {
                DBG_HEX_STRING(DEB_BUFFERS, pOutToken->pvBuffer, pOutToken->cbBuffer);
            }
        }
        if(pExtra)
        {
            DebugLog((
                DEB_TRACE,
                "Extra:  type:0x%8.8x, pv:0x%8.8x, cb:0x%x\n",
                pExtra->BufferType,
                pExtra->pvBuffer,
                pExtra->cbBuffer));
        }

        if(pContext->State == SP_STATE_CONNECTED)
        {
            DebugLog((DEB_TRACE, "Server handshake complete\n"));
        }
    #endif

    if(ptsExpiry != NULL)
    {
        if(pContext->RipeZombie->pRemoteCert != NULL)
        {
            ptsExpiry->QuadPart = *((LONGLONG *)&pContext->RipeZombie->pRemoteCert->pCertInfo->NotAfter);
        }
        else
        {
            ptsExpiry->QuadPart = MAXTIMEQUADPART;
        }
    }

    if(pContext->State == SP_STATE_CONNECTED &&
       pContext->RipeZombie->hLocator)
    {
        // Certificate mapping was successful.
        *pfContextAttr |= ASC_RET_MUTUAL_AUTH;
    }

    if(pContext->State == SP_STATE_CONNECTED ||
       pContext->State == SP_STATE_SHUTDOWN)
    {
        return SEC_E_OK;
    }
    else
    {
        return SEC_I_CONTINUE_NEEDED;
    }
}


NTSTATUS
SpCallPackage(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    PULONG Request ;

    if ( !ProtocolSubmitBuffer )
    {
        return SEC_E_UNSUPPORTED_FUNCTION ;
    }

    if(!SchannelInit(FALSE))
    {
        return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
    }

    Request = (PULONG) ProtocolSubmitBuffer ;

    if ( *Request == SSL_LOOKUP_CERT_MESSAGE )
    {
        return SslDoClientRequest(
                    ClientRequest,
                    ProtocolSubmitBuffer,
                    ClientBufferBase,
                    SubmitBufferLength,
                    ProtocolReturnBuffer,
                    ReturnBufferLength,
                    ProtocolStatus );
    } 

    else if ( *Request == SSL_LOOKUP_EXTERNAL_CERT_MESSAGE &&
              ClientBufferBase == ProtocolSubmitBuffer)
    {
        // This function is only allowed to be called from the 
        // lsass.exe process.
        return SslMapExternalCredential(
                    ClientRequest,
                    ProtocolSubmitBuffer,
                    ClientBufferBase,
                    SubmitBufferLength,
                    ProtocolReturnBuffer,
                    ReturnBufferLength,
                    ProtocolStatus );
    } 

    else if( *Request == SSL_CACHE_INFO_MESSAGE )
    {
        return SslSessionCacheInfo(
                    ClientRequest,
                    ProtocolSubmitBuffer,
                    ClientBufferBase,
                    SubmitBufferLength,
                    ProtocolReturnBuffer,
                    ReturnBufferLength,
                    ProtocolStatus );
    }

    else if( *Request == SSL_PURGE_CACHE_MESSAGE )
    {
        return SslPurgeSessionCache(
                    ClientRequest,
                    ProtocolSubmitBuffer,
                    ClientBufferBase,
                    SubmitBufferLength,
                    ProtocolReturnBuffer,
                    ReturnBufferLength,
                    ProtocolStatus );
    }

    return( SEC_E_UNSUPPORTED_FUNCTION );
}

NTSTATUS
SpCallPackageUntrusted(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    ULONG MessageType;

    //
    // Get the messsage type from the protocol submit buffer.
    //

    if(SubmitBufferLength < sizeof(ULONG))
    {
        return STATUS_INVALID_PARAMETER;
    }

    MessageType = *((ULONG *)(ProtocolSubmitBuffer));


    if(!SchannelInit(FALSE))
    {
        return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
    }


    //
    // Allow the dispatch routines to only set the return buffer information
    // on success conditions.
    //

    *ProtocolReturnBuffer = NULL;
    *ReturnBufferLength = 0;


    //
    // Process message as appropriate.
    //

    switch(MessageType)
    {
    case SSL_PURGE_CACHE_MESSAGE:
        return SslPurgeSessionCache(
                            ClientRequest,
                            ProtocolSubmitBuffer,
                            ClientBufferBase,
                            SubmitBufferLength,
                            ProtocolReturnBuffer,
                            ReturnBufferLength,
                            ProtocolStatus);

    case SSL_CACHE_INFO_MESSAGE:
        return SslSessionCacheInfo(
                            ClientRequest,
                            ProtocolSubmitBuffer,
                            ClientBufferBase,
                            SubmitBufferLength,
                            ProtocolReturnBuffer,
                            ReturnBufferLength,
                            ProtocolStatus);

    case SSL_PERFMON_INFO_MESSAGE:
        return SslGetPerfmonInfo(
                            ClientRequest,
                            ProtocolSubmitBuffer,
                            ClientBufferBase,
                            SubmitBufferLength,
                            ProtocolReturnBuffer,
                            ReturnBufferLength,
                            ProtocolStatus);

    default:
        return( SEC_E_UNSUPPORTED_FUNCTION );
    }
}


NTSTATUS NTAPI
SslPurgeSessionCache(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus)
{
    NTSTATUS Status;
    SECPKG_CALL_INFO CallInfo;
    SECPKG_CLIENT_INFO ClientInfo;
    PLUID LogonId;
    SSL_PURGE_SESSION_CACHE_REQUEST PurgeRequest;
    PSSL_PURGE_SESSION_CACHE_REQUEST pPurgeRequest;

    //
    // Verify the request.
    //

    DebugLog((DEB_TRACE, "Purging session cache\n"));

    if(!LsaTable->GetCallInfo(&CallInfo))
    {
        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

    if(CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
    {
        PSSL_PURGE_SESSION_CACHE_REQUEST_WOW64 pRequest;

        if(SubmitBufferSize < sizeof(SSL_PURGE_SESSION_CACHE_REQUEST_WOW64))
        {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        pRequest = (PSSL_PURGE_SESSION_CACHE_REQUEST_WOW64)ProtocolSubmitBuffer;

        memset(&PurgeRequest, 0, sizeof(PurgeRequest));
        PurgeRequest.MessageType = pRequest->MessageType;
        PurgeRequest.LogonId     = pRequest->LogonId;
        PurgeRequest.Flags       = pRequest->Flags;

        PurgeRequest.ServerName.Length = pRequest->ServerName.Length;
        PurgeRequest.ServerName.MaximumLength = pRequest->ServerName.MaximumLength;
        PurgeRequest.ServerName.Buffer = (PVOID) UlongToPtr(pRequest->ServerName.Buffer);

        pPurgeRequest = &PurgeRequest;
    }
    else
    {
        if (SubmitBufferSize < sizeof(SSL_PURGE_SESSION_CACHE_REQUEST))
        {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        pPurgeRequest = (PSSL_PURGE_SESSION_CACHE_REQUEST) ProtocolSubmitBuffer;
    }



    //
    // Normalize the strings
    //

    NULL_RELOCATE_ONE(&pPurgeRequest->ServerName);


    //
    // Find the callers logon id & TCB status
    //

    Status = LsaTable->GetClientInfo(&ClientInfo);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    //
    // Verify the caller has TCB privilege if they want to purge someone
    // else's session cache entries.
    //

    if(!RtlIsZeroLuid(&pPurgeRequest->LogonId) ||
       (pPurgeRequest->Flags & SSL_PURGE_CLIENT_ALL_ENTRIES) ||
       (pPurgeRequest->Flags & SSL_PURGE_SERVER_ALL_ENTRIES))
    {
        if(!ClientInfo.HasTcbPrivilege)
        {
            Status = STATUS_PRIVILEGE_NOT_HELD;
            goto Cleanup;
        }
    }


    //
    // If the caller did not provide a logon id, use the caller's logon id.
    //

    if(RtlIsZeroLuid(&pPurgeRequest->LogonId))
    {
        LogonId = &ClientInfo.LogonId;
    }
    else
    {
        LogonId = &pPurgeRequest->LogonId;
    }


    //
    // Purge the requested cache entries.
    //

    Status = SPCachePurgeEntries(LogonId,
                                 ClientInfo.ProcessID,
                                 pPurgeRequest->ServerName.Buffer,
                                 pPurgeRequest->Flags);


    *ProtocolReturnBuffer = NULL;
    *ReturnBufferLength = 0;

Cleanup:

    *ProtocolStatus = Status;
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
SslSessionCacheInfo(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus)
{
    NTSTATUS Status;
    SECPKG_CALL_INFO CallInfo;
    SECPKG_CLIENT_INFO ClientInfo;
    PLUID LogonId;
    SSL_SESSION_CACHE_INFO_REQUEST InfoRequest;
    PSSL_SESSION_CACHE_INFO_REQUEST pInfoRequest;
    PSSL_SESSION_CACHE_INFO_RESPONSE pInfoResponse = NULL;
    DWORD cbInfoResponse;
    PVOID pvClient;

    *ProtocolReturnBuffer = NULL;
    *ReturnBufferLength = 0;



    //
    // Verify the request.
    //

    if(!LsaTable->GetCallInfo(&CallInfo))
    {
        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

    if(CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
    {
        PSSL_SESSION_CACHE_INFO_REQUEST_WOW64 pRequest;

        if(SubmitBufferSize < sizeof(SSL_SESSION_CACHE_INFO_REQUEST_WOW64))
        {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        pRequest = (PSSL_SESSION_CACHE_INFO_REQUEST_WOW64)ProtocolSubmitBuffer;

        memset(&InfoRequest, 0, sizeof(InfoRequest));
        InfoRequest.MessageType = pRequest->MessageType;
        InfoRequest.LogonId     = pRequest->LogonId;
        InfoRequest.Flags       = pRequest->Flags;

        InfoRequest.ServerName.Length = pRequest->ServerName.Length;
        InfoRequest.ServerName.MaximumLength = pRequest->ServerName.MaximumLength;
        InfoRequest.ServerName.Buffer = (PVOID) UlongToPtr(pRequest->ServerName.Buffer);

        pInfoRequest = &InfoRequest;
    }
    else
    {
        if (SubmitBufferSize < sizeof(SSL_SESSION_CACHE_INFO_REQUEST))
        {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        pInfoRequest = (PSSL_SESSION_CACHE_INFO_REQUEST)ProtocolSubmitBuffer;
    }


    //
    // Normalize the strings
    //

    NULL_RELOCATE_ONE(&pInfoRequest->ServerName);


    //
    // Find the callers logon id & TCB status
    // 

    Status = LsaTable->GetClientInfo(&ClientInfo);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // If the caller did not provide a logon id, use the caller's logon id.
    //

    if ( RtlIsZeroLuid( &pInfoRequest->LogonId ) )
    {
        LogonId = &ClientInfo.LogonId;
    }
    else
    {
        //
        // Verify the caller has TCB privilege if they want access to someone
        // else's session cache.
        //

        if (!ClientInfo.HasTcbPrivilege)
        {
            Status = STATUS_PRIVILEGE_NOT_HELD;
            goto Cleanup;
        }

        LogonId = &pInfoRequest->LogonId;
    }

    pInfoResponse = SPExternalAlloc(sizeof(SSL_SESSION_CACHE_INFO_RESPONSE));
    if(pInfoResponse == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    Status = SPCacheGetInfo(LogonId,
                            pInfoRequest->ServerName.Buffer,
                            pInfoRequest->Flags,
                            pInfoResponse);
    if(!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    cbInfoResponse = sizeof(SSL_SESSION_CACHE_INFO_RESPONSE);

    //
    // Copy the response data to the client process.
    //

    Status = LsaTable->AllocateClientBuffer(
                NULL,
                cbInfoResponse,
                &pvClient);

    if(!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = LsaTable->CopyToClientBuffer(
                            NULL,
                            cbInfoResponse,
                            pvClient,
                            pInfoResponse);
    if(!NT_SUCCESS(Status))
    {
        LsaTable->FreeClientBuffer(NULL, pvClient);
        goto Cleanup;
    }

    *ProtocolReturnBuffer = pvClient;
    *ReturnBufferLength   = cbInfoResponse;


Cleanup:

    if(pInfoResponse)
    {
        SPExternalFree(pInfoResponse);
    }

    *ProtocolStatus = Status;
    return(STATUS_SUCCESS);
}


NTSTATUS NTAPI
SslGetPerfmonInfo(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus)
{
    NTSTATUS Status;
    PSSL_PERFMON_INFO_REQUEST pInfoRequest;
    PSSL_PERFMON_INFO_RESPONSE pInfoResponse = NULL;
    DWORD cbInfoResponse;
    PVOID pvClient;

    *ProtocolReturnBuffer = NULL;
    *ReturnBufferLength = 0;

    //
    // Verify the request.
    //

    if (SubmitBufferSize < sizeof(SSL_PERFMON_INFO_REQUEST))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    pInfoRequest = (PSSL_PERFMON_INFO_REQUEST)ProtocolSubmitBuffer;

    pInfoResponse = SPExternalAlloc(sizeof(SSL_PERFMON_INFO_RESPONSE));
    if(pInfoResponse == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    Status = SPCacheGetPerfmonInfo(pInfoRequest->Flags,
                                   pInfoResponse);
    if(!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    cbInfoResponse = sizeof(SSL_PERFMON_INFO_RESPONSE);

    //
    // Copy the response data to the client process.
    //

    Status = LsaTable->AllocateClientBuffer(
                NULL,
                cbInfoResponse,
                &pvClient);

    if(!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = LsaTable->CopyToClientBuffer(
                            NULL,
                            cbInfoResponse,
                            pvClient,
                            pInfoResponse);
    if(!NT_SUCCESS(Status))
    {
        LsaTable->FreeClientBuffer(NULL, pvClient);
        goto Cleanup;
    }

    *ProtocolReturnBuffer = pvClient;
    *ReturnBufferLength   = cbInfoResponse;


Cleanup:

    if(pInfoResponse)
    {
        SPExternalFree(pInfoResponse);
    }

    *ProtocolStatus = Status;
    return(STATUS_SUCCESS);
}


NTSTATUS
SpCallPackagePassthrough(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{


    //
    // NOTE: if other sensitive request types are to be supported,
    // this routine should filter them out prior to calling SpCallPackage.
    // This is required because untrusted code has the opportunity for
    // making genericpassthrough requests.
    //

    PULONG Request ;

    if ( !ProtocolSubmitBuffer )
    {
        return SEC_E_UNSUPPORTED_FUNCTION ;
    }

    Request = (PULONG) ProtocolSubmitBuffer ;

    if ( *Request != SSL_LOOKUP_CERT_MESSAGE )
        return SEC_E_UNSUPPORTED_FUNCTION;

    return SpCallPackage(
                    ClientRequest,
                    ProtocolSubmitBuffer,
                    ClientBufferBase,
                    SubmitBufferLength,
                    ProtocolReturnBuffer,
                    ReturnBufferLength,
                    ProtocolStatus
                    );
}



SECURITY_STATUS SEC_ENTRY
SpShutdown(void)
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}

SECURITY_STATUS SEC_ENTRY
SpSystemLogon( PSECURITY_STRING    pName,
               DWORD               cbKey,
               PBYTE               pbKey,
               DWORD *             pdwHandle,
               PTimeStamp          ptsExpiry)
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}

SECURITY_STATUS SEC_ENTRY
SpGetUserInfo(  PLUID                   pLogonId,
                ULONG                   fFlags,
                PSecurityUserData *     ppUserInfo)
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}





//+---------------------------------------------------------------------------
//
//  Function:   SpSaveCredentials
//
//  Synopsis:   Store credentials (not supported)
//
//  Arguments:  [dwCredHandle] --
//              [CredType]     --
//              [pCredentials] --
//
//
//  History:    7-26-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
SpSaveCredentials(  LSA_SEC_HANDLE    dwCredHandle,
                    PSecBuffer        pCredentials)
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}


//+---------------------------------------------------------------------------
//
//  Function:   SpGetCredentials
//
//  Synopsis:   Get Credentials (not supported)
//
//  Arguments:  [dwCredHandle] --
//              [CredType]     --
//              [pCredentials] --
//
//  History:    7-26-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
SpGetCredentials(   LSA_SEC_HANDLE    dwCredHandle,
                    PSecBuffer        pCredentials)
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}

//+---------------------------------------------------------------------------
//
//  Function:   SpDeleteCredentials
//
//  Synopsis:   Delete stored creds (not supported)
//
//  Arguments:  [dwCredHandle] --
//              [CredType]     --
//              [pKey]         --
//
//  History:    7-26-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
SpDeleteCredentials(LSA_SEC_HANDLE    dwCredHandle,
                    PSecBuffer        pKey)
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\lsa\init.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       init.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8-01-95   RichardW   Created
//              8-13-95   TerenceS   Mutated to PCT
//
//----------------------------------------------------------------------------

#include "sslp.h"
#include <basetyps.h>
#include <oidenc.h>
#include <userenv.h>
#include <alloca.h>

RTL_CRITICAL_SECTION    g_InitCritSec;
BOOL                    g_fSchannelInitialized = FALSE;

void LoadSecurityDll(void);
void UnloadSecurityDll(void);


// MyStrToL
//      Can't use CRT routines, so steal from the C runtime sources

DWORD MyStrToL(CHAR *InStr)
{
    DWORD dwVal = 0;

    while(*InStr)
    {
        dwVal = (10 * dwVal) + (*InStr - '0');
        InStr++;
    }

    return dwVal;
}

/*++

Routine Description:

    This routine checks whether encryption is getting the system default
    LCID and checking whether the country code is CTRY_FRANCE.

--*/
void
IsSchEncryptionPermitted(VOID)
{
    LCID DefaultLcid;
    CHAR CountryCode[10];
    ULONG CountryValue;
    BOOL fAllowed = TRUE;

    DefaultLcid = GetSystemDefaultLCID();

    //
    // Check if the default language is Standard French
    //

    if (LANGIDFROMLCID(DefaultLcid) == 0x40c)
    {
        fAllowed = FALSE;
        goto Ret;
    }

    //
    // Check if the users's country is set to FRANCE
    //

    if (GetLocaleInfoA(DefaultLcid,LOCALE_ICOUNTRY,CountryCode,10) == 0)
    {
        fAllowed = FALSE;
        goto Ret;
    }

    CountryValue = (ULONG) MyStrToL(CountryCode);

    if (CountryValue == CTRY_FRANCE)
    {
        fAllowed = FALSE;
    }      
Ret:

    if(FALSE == fAllowed)  
    {
        // Disable PCT in France.
        g_ProtEnabled &= ~(SP_PROT_PCT1);
        g_fFranceLocale = TRUE;
    }
}


/*****************************************************************************/
BOOL 
SchannelInit(BOOL fAppProcess)
{
    DWORD Status;

    if(g_fSchannelInitialized) return TRUE;

    RtlEnterCriticalSection(&g_InitCritSec);

    if(g_fSchannelInitialized)
    {
        RtlLeaveCriticalSection(&g_InitCritSec);
        return TRUE;
    }

    DisableThreadLibraryCalls( g_hInstance );

    SafeAllocaInitialize(0, 0, NULL, NULL);

    // Read configuration parameters from registry.
    if(!fAppProcess)
    {
        IsSchEncryptionPermitted();
        SPLoadRegOptions();
    }
#if DBG
    else
    {
        InitDebugSupport(NULL);
    }
#endif

    if(!fAppProcess)
    {
        SchInitializeEvents();
    }

    if(!CryptAcquireContextA(&g_hRsaSchannel,
                             NULL,
                             NULL,
                             PROV_RSA_SCHANNEL,
                             CRYPT_VERIFYCONTEXT))
    {
        g_hRsaSchannel = 0;
        Status = GetLastError();
        DebugLog((DEB_ERROR, "Could not open static PROV_RSA_SCHANNEL: %x\n", Status));

        if(!fAppProcess)
        {
            LogGlobalAcquireContextFailedEvent(L"RSA", Status);
        }

        RtlLeaveCriticalSection(&g_InitCritSec);
        return FALSE;
    }
    if(!fAppProcess && g_hRsaSchannel)
    {
        GetSupportedCapiAlgs(g_hRsaSchannel,
                             SCH_CAPI_USE_CSP,
                             &g_pRsaSchannelAlgs,
                             &g_cRsaSchannelAlgs);
    }

    if(!CryptAcquireContext(&g_hDhSchannelProv,
                            NULL,
                            NULL,
                            PROV_DH_SCHANNEL,
                            CRYPT_VERIFYCONTEXT))
    {
        g_hDhSchannelProv = 0;
        Status = GetLastError();
        DebugLog((DEB_WARN, "Could not open PROV_DH_SCHANNEL: %x\n", Status));

        if(!fAppProcess)
        {
            LogGlobalAcquireContextFailedEvent(L"DSS", Status);
        }

        CryptReleaseContext(g_hRsaSchannel, 0);
        RtlLeaveCriticalSection(&g_InitCritSec);
        return FALSE;
    }
    if(!fAppProcess && g_hDhSchannelProv)
    {
        GetSupportedCapiAlgs(g_hDhSchannelProv,
                             SCH_CAPI_USE_CSP,
                             &g_pDhSchannelAlgs,
                             &g_cDhSchannelAlgs);
    }

    InitSchannelAsn1(g_hInstance);

    LoadSecurityDll();

    if(!fAppProcess)
    {
        SPInitSessionCache();
        SslInitCredentialManager();
    }

    g_fSchannelInitialized = TRUE;

    if(!fAppProcess)
    {
        LogSchannelStartedEvent();
    }

    RtlLeaveCriticalSection(&g_InitCritSec);

    return TRUE;
}

BOOL SchannelShutdown(VOID)
{
    RtlEnterCriticalSection(&g_InitCritSec);

    if(!g_fSchannelInitialized)
    {
        RtlLeaveCriticalSection(&g_InitCritSec);
        return TRUE;
    }

    SPShutdownSessionCache();

    UnloadSecurityDll();

    SslFreeCredentialManager();

    ShutdownSchannelAsn1();

    SchShutdownEvents();

    SPUnloadRegOptions();

    g_fSchannelInitialized = FALSE;

    RtlLeaveCriticalSection(&g_InitCritSec);

    return TRUE;
}


HINSTANCE g_hSecur32;
FREE_CONTEXT_BUFFER_FN g_pFreeContextBuffer;

void LoadSecurityDll(void)
{
    g_hSecur32 = LoadLibrary(TEXT("secur32.dll"));
    if(g_hSecur32)
    {
        g_pFreeContextBuffer = (FREE_CONTEXT_BUFFER_FN)GetProcAddress(
                                    g_hSecur32, 
                                    "FreeContextBuffer");
    }
    else
    {
        g_pFreeContextBuffer = NULL;
    }
}

void UnloadSecurityDll(void)
{
    if(g_hSecur32)
    {
        FreeLibrary(g_hSecur32);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\lsa\events.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1999
//
// File:        events.c
//
// Contents:    Schannel event log functions.
//
// Functions:   SchInitializeEvents
//              SchReportEvent
//              SchShutdownEvents
//
// History:     03-05-99   jbanes    Created
//
//------------------------------------------------------------------------
#include "sslp.h"
#include <lsapmsgs.h>
#include <netlib.h>

HANDLE g_hEventLog = NULL;
HANDLE g_hDiscardDupEventLog = NULL;

WCHAR   EventSourceName[] = TEXT("Schannel");

#define MAX_EVENT_STRINGS       8

#define SCH_MESSAGE_FILENAME    TEXT("%SystemRoot%\\system32\\lsasrv.dll")

LPWSTR pszClientString = NULL;
LPWSTR pszServerString = NULL;

NTSTATUS
SchGetMessageString(
    LPVOID   Resource,
    DWORD    Index,
    LPWSTR * pRetString);


//+---------------------------------------------------------------------------
//
//  Function:   SchInitializeEvents
//
//  Synopsis:   Connects to event log service.
//
//  Arguments:  (none)
//
//  History:    03-05-99   jbanes    Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
SchInitializeEvents(void)
{
    HKEY     hKey;
    int      err;
    DWORD    disp;
    HMODULE  hResource;

    //
    // Create registry entries, whether event logging is currently
    // enabled or not.
    //

    err = RegCreateKeyEx(   HKEY_LOCAL_MACHINE,
                            TEXT("System\\CurrentControlSet\\Services\\EventLog\\System\\Schannel"),
                            0,
                            TEXT(""),
                            REG_OPTION_NON_VOLATILE,
                            KEY_WRITE,
                            NULL,
                            &hKey,
                            &disp);
    if(err)
    {
        return(FALSE);
    }

    if (disp == REG_CREATED_NEW_KEY)
    {
        RegSetValueEx(  hKey,
                        TEXT("EventMessageFile"),
                        0,
                        REG_EXPAND_SZ,
                        (PBYTE)SCH_MESSAGE_FILENAME,
                        sizeof(SCH_MESSAGE_FILENAME) );

//        RegSetValueEx(  hKey,
//                        TEXT("CategoryMessageFile"),
//                        0,
//                        REG_EXPAND_SZ,
//                        (PBYTE)SCH_MESSAGE_FILENAME,
//                        sizeof(SCH_MESSAGE_FILENAME) );

        disp = 7;
        RegSetValueEx(  hKey,
                        TEXT("TypesSupported"),
                        0,
                        REG_DWORD,
                        (PBYTE) &disp,
                        sizeof(DWORD) );

//        disp = CATEGORY_MAX_CATEGORY - 1;
//        RegSetValueEx(  hKey,
//                        TEXT("CategoryCount"),
//                        0,
//                        REG_DWORD,
//                        (PBYTE) &disp,
//                        sizeof(DWORD) );

        RegFlushKey(hKey);
    }

    RegCloseKey(hKey);


    //
    // Read the event text strings from the resource file.
    //

    hResource = (HMODULE)LoadLibrary(TEXT("lsasrv.dll"));
    if(hResource == NULL) 
    {
        return(FALSE);
    }

    SchGetMessageString(hResource,
                        SSLEVENTTEXT_CLIENT,
                        &pszClientString);

    SchGetMessageString(hResource,
                        SSLEVENTTEXT_SERVER,
                        &pszServerString);

    FreeLibrary(hResource);

    return(TRUE);
}


//+---------------------------------------------------------------------------
//
//  Function:   SchReportEvent
//
//  Synopsis:   Reports an event to the event log
//
//  Arguments:  [EventType]       -- EventType (ERROR, WARNING, etc.)
//              [EventId]         -- Event ID
//              [SizeOfRawData]   -- Size of raw data
//              [RawData]         -- Raw data
//              [NumberOfStrings] -- number of strings
//              ...               -- PWSTRs to string data
//
//  History:    03-05-99   jbanes    Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
SchReportEvent(
    IN DWORD LogLevel,
    IN DWORD EventType,
    IN DWORD EventId,
    IN DWORD Category,
    IN DWORD SizeOfRawData,
    IN PVOID RawData,
    IN DWORD NumberOfStrings,
    ...
    )
{
    va_list arglist;
    ULONG i;
    PWSTR Strings[ MAX_EVENT_STRINGS ];
    PSTR StringsA[ MAX_EVENT_STRINGS ];
    DWORD Status;
    BOOL fDiscardDuplicates = TRUE;
    BOOL fSuccess;


    //
    // Is this event supposed to be logged?
    //

    if ((g_dwEventLogging & LogLevel) == 0)
    {
        return ERROR_SUCCESS;
    }

    
    //
    // Open the event log if necessary. 
    //

    if(g_dwEventLogging == DEFAULT_EVENT_LOGGING_SETTING)
    {
        // Only log identical event once per hour.
        if(g_hDiscardDupEventLog == NULL)
        {
            g_hDiscardDupEventLog = NetpEventlogOpen(EventSourceName, 60000*60);
            if(g_hDiscardDupEventLog == NULL)
            {
                Status = GetLastError();
                DebugLog((DEB_ERROR, "Could not open duplicate discard event log, error %d\n", Status));
                return Status;
            }
        }
    }
    else
    {
        // Log all events.
        if(g_hEventLog == NULL)
        {
            g_hEventLog = RegisterEventSource(NULL, EventSourceName);
            if(g_hEventLog == NULL)
            {
                Status = GetLastError();
                DebugLog((DEB_ERROR, "Could not open duplicate discard event log, error %d\n", Status));
                return Status;
            }
        }

        fDiscardDuplicates = FALSE;
    }

    
    //
    // Look at the strings, if they were provided
    //
    va_start( arglist, NumberOfStrings );

    if (NumberOfStrings > MAX_EVENT_STRINGS) {
        NumberOfStrings = MAX_EVENT_STRINGS;
    }

    for (i=0; i<NumberOfStrings; i++) 
    {
        Strings[ i ] = va_arg( arglist, PWSTR );
    }


    //
    // Report the event to the eventlog service
    //

    if(fDiscardDuplicates)
    {
        fSuccess = NetpEventlogWriteEx(   
                        g_hDiscardDupEventLog,
                        (WORD) EventType,
                        (WORD) Category,
                        EventId,
                        (WORD)NumberOfStrings,
                        SizeOfRawData,
                        Strings,
                        RawData);
    }
    else
    {
        fSuccess = ReportEvent(   
                        g_hEventLog,
                        (WORD) EventType,
                        (WORD) Category,
                        EventId,
                        NULL,
                        (WORD)NumberOfStrings,
                        SizeOfRawData,
                        Strings,
                        RawData);
    }

    if(!fSuccess)
    {
        Status = GetLastError();
        DebugLog((DEB_ERROR,  "ReportEvent( %u ) failed - %u\n", EventId, Status));
    }
    else
    {
        Status = ERROR_SUCCESS;
    }

    return Status;
}

void
SchShutdownEvents(void)
{
    if(g_hDiscardDupEventLog != NULL)
    {
        NetpEventlogClose(g_hDiscardDupEventLog);
        g_hDiscardDupEventLog = NULL;
    }
    if(g_hEventLog != NULL)
    {
        DeregisterEventSource(g_hEventLog);
        g_hEventLog = NULL;
    }

    if(pszClientString)
    {
        LocalFree(pszClientString);
        pszClientString = NULL;
    }
    if(pszServerString)
    {
        LocalFree(pszServerString);
        pszServerString = NULL;
    }
}


void
LogSchannelStartedEvent(void)
{    
    SchReportEvent( DEB_TRACE,
                    EVENTLOG_INFORMATION_TYPE,
                    SSLEVENT_SCHANNEL_STARTED,
                    0,
                    0,
                    NULL,
                    0,
                    NULL );
}

void
LogGlobalAcquireContextFailedEvent(
    LPWSTR pwszName,
    DWORD Status)
{
    WCHAR wszStatus[20];

    _ltow(Status, wszStatus, 16);

    SchReportEvent( DEB_ERROR,
                    EVENTLOG_ERROR_TYPE,
                    SSLEVENT_GLOBAL_ACQUIRE_CONTEXT_FAILED,
                    0,
                    0,
                    NULL,
                    2,
                    pwszName,
                    wszStatus);
}

void
LogCreateCredEvent(
    DWORD dwProtocol, 
    PLSA_SCHANNEL_CRED pSchannelCred)
{
    SchReportEvent(DEB_TRACE,
                   EVENTLOG_INFORMATION_TYPE,
                   SSLEVENT_CREATE_CRED,
                   0,
                   sizeof(SCHANNEL_CRED),
                   pSchannelCred,
                   1,
                   (dwProtocol & SP_PROT_SERVERS) ? pszServerString : pszClientString);
}

void
LogCredPropertiesEvent(
    DWORD dwProtocol,
    PCRYPT_KEY_PROV_INFO pProvInfo,
    PCCERT_CONTEXT pCertContext)
{
    WCHAR wszType[20];
    WCHAR wszFlags[20];
    LPWSTR pwszKeySpec;

    if(!(g_dwEventLogging & DEB_TRACE))
    {
        return;
    }

    _ltow(pProvInfo->dwProvType, wszType,    10);
    _ltow(pProvInfo->dwFlags,    wszFlags,   16);

    switch(pProvInfo->dwKeySpec)
    {
    case AT_KEYEXCHANGE:
        pwszKeySpec = L"key exchange";
        break;
    case AT_SIGNATURE:
        pwszKeySpec = L"signature";
        break;
    default:
        pwszKeySpec = L"unknown";
    }

    SchReportEvent( DEB_TRACE,
                    EVENTLOG_INFORMATION_TYPE,
                    SSLEVENT_CRED_PROPERTIES,
                    0,
                    pCertContext->cbCertEncoded,
                    pCertContext->pbCertEncoded,
                    6,
                    (dwProtocol & SP_PROT_SERVERS) ? pszServerString : pszClientString,
                    pProvInfo->pwszProvName,
                    wszType,
                    pProvInfo->pwszContainerName,
                    pwszKeySpec,
                    wszFlags);
}

void
LogNoPrivateKeyEvent(
    DWORD dwProtocol)
{
    SchReportEvent( DEB_ERROR,
                    EVENTLOG_ERROR_TYPE,
                    SSLEVENT_NO_PRIVATE_KEY,
                    0,
                    0,
                    NULL,
                    1,
                    (dwProtocol & SP_PROT_SERVERS) ? pszServerString : pszClientString);
}

void
LogCredAcquireContextFailedEvent(
    DWORD dwProtocol, 
    DWORD Status)
{
    WCHAR wszStatus[20];

    _ltow(Status, wszStatus, 16);

    SchReportEvent( DEB_ERROR,
                    EVENTLOG_ERROR_TYPE,
                    SSLEVENT_CRED_ACQUIRE_CONTEXT_FAILED,
                    0,
                    0,
                    NULL,
                    2,
                    (dwProtocol & SP_PROT_SERVERS) ? pszServerString : pszClientString,
                    wszStatus);
}

void
LogCreateCredFailedEvent(
    DWORD dwProtocol)
{
    SchReportEvent(DEB_ERROR,
                   EVENTLOG_ERROR_TYPE,
                   SSLEVENT_CREATE_CRED_FAILED,
                   0,
                   0,
                   NULL,
                   1,
                   (dwProtocol & SP_PROT_SERVERS) ? pszServerString : pszClientString);
}

void
LogNoDefaultServerCredEvent(void)
{
    SchReportEvent(DEB_ERROR,
                   EVENTLOG_WARNING_TYPE,
                   SSLEVENT_NO_DEFAULT_SERVER_CRED,
                   0,
                   0,
                   NULL,
                   0,
                   NULL);
}

           
void
LogNoCiphersSupportedEvent(void)
{
    SchReportEvent(DEB_ERROR,
                   EVENTLOG_ERROR_TYPE,
                   SSLEVENT_NO_CIPHERS_SUPPORTED,
                   0,
                   0,
                   NULL,
                   0,
                   NULL);
}

void
LogCipherMismatchEvent(void)
{
    SchReportEvent(DEB_ERROR,
                   EVENTLOG_ERROR_TYPE,
                   SSLEVENT_CIPHER_MISMATCH,
                   0,
                   0,
                   NULL,
                   0,
                   NULL);
}

void
LogNoClientCertFoundEvent(void)
{
    SchReportEvent(DEB_WARN,
                   EVENTLOG_WARNING_TYPE,
                   SSLEVENT_NO_CLIENT_CERT_FOUND,
                   0,
                   0,
                   NULL,
                   0,
                   NULL);
}

void
LogBogusServerCertEvent(
    PCCERT_CONTEXT pCertContext,
    LPWSTR pwszServerName,
    DWORD Status)
{
    WCHAR wszStatus[20];

    if(!(g_dwEventLogging & DEB_ERROR))
    {
        return;
    }

    switch(Status)
    {
    case SEC_E_CERT_EXPIRED:
        SchReportEvent( DEB_ERROR,
                        EVENTLOG_ERROR_TYPE,
                        SSLEVENT_EXPIRED_SERVER_CERT,
                        0,
                        pCertContext->cbCertEncoded,
                        pCertContext->pbCertEncoded,
                        0,
                        NULL);
        break;

    case SEC_E_UNTRUSTED_ROOT:
        SchReportEvent( DEB_ERROR,
                        EVENTLOG_ERROR_TYPE,
                        SSLEVENT_UNTRUSTED_SERVER_CERT,
                        0,
                        pCertContext->cbCertEncoded,
                        pCertContext->pbCertEncoded,
                        0,
                        NULL);
        break;

    case CRYPT_E_REVOKED:
        SchReportEvent( DEB_ERROR,
                        EVENTLOG_ERROR_TYPE,
                        SSLEVENT_REVOKED_SERVER_CERT,
                        0,
                        pCertContext->cbCertEncoded,
                        pCertContext->pbCertEncoded,
                        0,
                        NULL);
        break;

    case SEC_E_WRONG_PRINCIPAL:
        SchReportEvent( DEB_ERROR,
                        EVENTLOG_ERROR_TYPE,
                        SSLEVENT_NAME_MISMATCHED_SERVER_CERT,
                        0,
                        pCertContext->cbCertEncoded,
                        pCertContext->pbCertEncoded,
                        1,
                        pwszServerName);
        break;
       
    default:
        _ltow(Status, wszStatus, 16);

        SchReportEvent( DEB_ERROR,
                        EVENTLOG_ERROR_TYPE,
                        SSLEVENT_BOGUS_SERVER_CERT,
                        0,
                        pCertContext->cbCertEncoded,
                        pCertContext->pbCertEncoded,
                        1,
                        wszStatus);
    }
}

void
LogBogusClientCertEvent(
    PCCERT_CONTEXT pCertContext,
    DWORD Status)
{
    WCHAR wszStatus[20];

    if(!(g_dwEventLogging & DEB_WARN))
    {
        return;
    }

    _ltow(Status, wszStatus, 16);

    SchReportEvent( DEB_WARN,
                    EVENTLOG_WARNING_TYPE,
                    SSLEVENT_BOGUS_CLIENT_CERT,
                    0,
                    pCertContext->cbCertEncoded,
                    pCertContext->pbCertEncoded,
                    1,
                    wszStatus);
}

void
LogFastMappingFailureEvent(
    PCCERT_CONTEXT pCertContext,
    DWORD Status)
{
    WCHAR wszStatus[20];

    if(!(g_dwEventLogging & DEB_WARN))
    {
        return;
    }

    _ltow(Status, wszStatus, 16);

    SchReportEvent( DEB_WARN,
                    EVENTLOG_WARNING_TYPE,
                    SSLEVENT_FAST_MAPPING_FAILURE,
                    0,
                    pCertContext->cbCertEncoded,
                    pCertContext->pbCertEncoded,
                    1,
                    wszStatus);
}

void
LogCertMappingFailureEvent(
    DWORD Status)
{
    WCHAR wszStatus[20];

    if(!(g_dwEventLogging & DEB_WARN))
    {
        return;
    }

    _ltow(Status, wszStatus, 16);

    SchReportEvent( DEB_WARN,
                    EVENTLOG_WARNING_TYPE,
                    SSLEVENT_CERT_MAPPING_FAILURE,
                    0,
                    0,
                    NULL,
                    1,
                    wszStatus);
}

void
LogHandshakeInfoEvent(
    DWORD dwProtocol,
    PCipherInfo pCipherInfo,
    PHashInfo pHashInfo,
    PKeyExchangeInfo pExchangeInfo,
    DWORD dwExchangeStrength)
{
    WCHAR wszCipherStrength[20];
    WCHAR wszExchangeStrength[20];
    LPWSTR pwszProtocol;
    LPWSTR pwszCipher;
    LPWSTR pwszHash;
    LPWSTR pwszExchange;

    if(!(g_dwEventLogging & DEB_TRACE))
    {
        return;
    }

    switch(dwProtocol)
    {
    case SP_PROT_PCT1_SERVER:
    case SP_PROT_PCT1_CLIENT:
        pwszProtocol = L"PCT";
        break;
    case SP_PROT_SSL2_SERVER:
    case SP_PROT_SSL2_CLIENT:
        pwszProtocol = L"SSL 2.0";
        break;
    case SP_PROT_SSL3_SERVER:
    case SP_PROT_SSL3_CLIENT:
        pwszProtocol = L"SSL 3.0";
        break;
    case SP_PROT_TLS1_SERVER:
    case SP_PROT_TLS1_CLIENT:
        pwszProtocol = L"TLS (SSL 3.1)";
        break;
    default:
        pwszProtocol = L"unknown";
    }

    switch(pCipherInfo->aiCipher)
    {
    case CALG_RC4:
        pwszCipher = L"RC4";
        break;
    case CALG_3DES:
        pwszCipher = L"Triple-DES";
        break;
    case CALG_RC2:
        pwszCipher = L"RC2";
        break;
    case CALG_DES:
        pwszCipher = L"DES";
        break;
    case CALG_SKIPJACK:
        pwszCipher = L"Skipjack";
        break;
    default:
        pwszCipher = L"unknown";
    }

    _ltow(pCipherInfo->dwStrength, wszCipherStrength, 10);

    switch(pHashInfo->aiHash)
    {
    case CALG_MD5:
        pwszHash = L"MD5";
        break;
    case CALG_SHA:
        pwszHash = L"SHA";
        break;
    default:
        pwszHash = L"unknown";
    }

    switch(pExchangeInfo->aiExch)
    {
    case CALG_RSA_SIGN:
    case CALG_RSA_KEYX:
        pwszExchange = L"RSA";
        break;
    case CALG_KEA_KEYX:
        pwszExchange = L"KEA";
        break;
    case CALG_DH_EPHEM:
        pwszExchange = L"Ephemeral DH";
        break;
    default:
        pwszExchange = L"unknown";
    }

    _ltow(dwExchangeStrength, wszExchangeStrength, 10);

    SchReportEvent( DEB_TRACE,
                    EVENTLOG_INFORMATION_TYPE,
                    SSLEVENT_HANDSHAKE_INFO,
                    0,
                    0,
                    NULL,
                    7,
                    (dwProtocol & SP_PROT_SERVERS) ? pszServerString : pszClientString,
                    pwszProtocol,
                    pwszCipher,
                    wszCipherStrength,
                    pwszHash,
                    pwszExchange,
                    wszExchangeStrength);
}

NTSTATUS
SchGetMessageString(
    LPVOID   Resource,
    DWORD    Index,
    LPWSTR * pRetString)
{
    DWORD Length;

    *pRetString = NULL;

    Length = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                           FORMAT_MESSAGE_ALLOCATE_BUFFER,
                           Resource,
                           Index,
                           0,                 // Use caller's language
                           (LPWSTR)pRetString,
                           0,
                           NULL);

    if(Length == 0 || *pRetString == NULL)
    {
        return(STATUS_RESOURCE_DATA_NOT_FOUND);
    }

    //
    // Note that we are retrieving a message from a message file.
    // This message will have a cr/lf tacked on the end of it
    // (0x0d 0x0a) that we don't want to be part of our returned
    // strings.  However, we do need to null terminate our string
    // so we will convert the 0x0d into a null terminator.
    //
    // Also note that FormatMessage() returns a character count,
    // not a byte count.  So, we have to do some adjusting to make
    // the string lengths correct.
    //

    ASSERT(Length >= 2);    // We always expect cr/lf on our strings

    //
    // Adjust character count
    //

    Length -=  1; // For the lf - we'll convert the cr.

    //
    // Set null terminator
    //

    (*pRetString)[Length - 1] = 0;

    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\lsa\credapi.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       credapi.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    9-18-96   RichardW   Created
//
//----------------------------------------------------------------------------

#include "sslp.h"
#include "mapper.h"
#include "rpc.h"
#include <sslwow64.h>

typedef struct _SCH_CRED_SECRET {
    union {
        SCH_CRED_SECRET_CAPI        Capi;
        SCH_CRED_SECRET_PRIVKEY     PrivKey;
    } u;
} SCH_CRED_SECRET, * PSCH_CRED_SECRET ;

extern CHAR CertTag[ 13 ];

//+-------------------------------------------------------------------------
//
//  Function:   CopyClientString
//
//  Synopsis:   copies a client string to local memory, including
//              allocating space for it locally.
//
//  Arguments:
//              SourceString  - Could be Ansi or Wchar in client process
//              SourceLength  - bytes
//              DoUnicode     - whether the string is Wchar
//
//  Returns:
//              DestinationString - Unicode String in Lsa Process
//
//  Notes:
//
//--------------------------------------------------------------------------
HRESULT
CopyClientString(
    IN PWSTR SourceString,
    IN ULONG SourceLength,
    IN BOOLEAN DoUnicode,
    OUT PUNICODE_STRING DestinationString
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    STRING TemporaryString;
    ULONG SourceSize = 0;
    ULONG CharacterSize = sizeof(CHAR);

    //
    // First initialize the string to zero, in case the source is a null
    // string
    //

    DestinationString->Length = DestinationString->MaximumLength = 0;
    DestinationString->Buffer = NULL;
    TemporaryString.Buffer = NULL;


    if (SourceString != NULL)
    {

        //
        // If the length is zero, allocate one byte for a "\0" terminator
        //

        if (SourceLength == 0)
        {
            DestinationString->Buffer = (LPWSTR) LocalAlloc(LPTR, sizeof(WCHAR));
            if (DestinationString->Buffer == NULL)
            {
                Status = SP_LOG_RESULT(STATUS_NO_MEMORY);
                goto Cleanup;
            }
            DestinationString->MaximumLength = sizeof(WCHAR);
            *DestinationString->Buffer = L'\0';

        }
        else
        {
            //
            // Allocate a temporary buffer to hold the client string. We may
            // then create a buffer for the unicode version. The length
            // is the length in characters, so  possible expand to hold unicode
            // characters and a null terminator.
            //

            if (DoUnicode)
            {
                CharacterSize = sizeof(WCHAR);
            }

            SourceSize = (SourceLength + 1) * CharacterSize;

            //
            // insure no overflow aggainst UNICODE_STRING
            //

            if ( (SourceSize > 0xFFFF) ||
                 ((SourceSize - CharacterSize) > 0xFFFF)
                 )
            {
                Status = SP_LOG_RESULT(STATUS_INVALID_PARAMETER);
                goto Cleanup;
            }


            TemporaryString.Buffer = (LPSTR) LocalAlloc(LPTR, SourceSize);
            if (TemporaryString.Buffer == NULL)
            {
                Status = SP_LOG_RESULT(STATUS_NO_MEMORY);
                goto Cleanup;
            }
            TemporaryString.Length = (USHORT) (SourceSize - CharacterSize);
            TemporaryString.MaximumLength = (USHORT) SourceSize;


            //
            // Finally copy the string from the client
            //

            Status = LsaTable->CopyFromClientBuffer(
                            NULL,
                            SourceSize - CharacterSize,
                            TemporaryString.Buffer,
                            SourceString
                            );

            if (!NT_SUCCESS(Status))
            {
                SP_LOG_RESULT(Status);
                goto Cleanup;
            }

            //
            // If we are doing unicode, finish up now
            //
            if (DoUnicode)
            {
                DestinationString->Buffer = (LPWSTR) TemporaryString.Buffer;
                DestinationString->Length = (USHORT) (SourceSize - CharacterSize);
                DestinationString->MaximumLength = (USHORT) SourceSize;
            }
            else
            {
                NTSTATUS Status1;
                Status1 = RtlAnsiStringToUnicodeString(
                            DestinationString,
                            &TemporaryString,
                            TRUE
                            );      // allocate destination
                if (!NT_SUCCESS(Status1))
                {
                    Status = SP_LOG_RESULT(STATUS_NO_MEMORY);
                    goto Cleanup;
                }
            }
        }
    }

Cleanup:

    if (TemporaryString.Buffer != NULL)
    {
        //
        // Free this if we failed and were doing unicode or if we weren't
        // doing unicode
        //

        if ((DoUnicode && !NT_SUCCESS(Status)) || !DoUnicode)
        {
            LocalFree(TemporaryString.Buffer);
        }
    }

    return(Status);
}


//+---------------------------------------------------------------------------
//
//  Function:   SpAcceptCredentials
//
//  Synopsis:   Accept Credentials - logon notification
//
//  Arguments:  [LogonType]         --
//              [UserName]          --
//              [PrimaryCred]       --
//              [SupplementalCreds] --
//
//  History:    10-04-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
SpAcceptCredentials(
    IN SECURITY_LOGON_TYPE LogonType,
    IN PUNICODE_STRING UserName,
    IN PSECPKG_PRIMARY_CRED PrimaryCred,
    IN PSECPKG_SUPPLEMENTAL_CRED SupplementalCreds)
{
    return( SEC_E_OK );
}

//+---------------------------------------------------------------------------
//
//  Function:   SpMapSchPublic
//
//  Synopsis:   Maps a public key credential into LSA memory
//
//  Arguments:  [pRemotePubs] --
//
//  History:    10-06-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PVOID
SpMapSchPublic(
    PVOID   pRemotePubs
    )
{
    SECURITY_STATUS Status ;
    SCH_CRED_PUBLIC_CERTCHAIN Pub, * pPub ;

    Status = LsaTable->CopyFromClientBuffer( NULL,
                                             sizeof( SCH_CRED_PUBLIC_CERTCHAIN ),
                                             &Pub,
                                             pRemotePubs );

    if ( !NT_SUCCESS( Status ) )
    {
        return( NULL );
    }

    // Reality check
    if(Pub.cbCertChain > 0x00100000)
    {
        return( NULL );
    }

    pPub = SPExternalAlloc( sizeof( SCH_CRED_PUBLIC_CERTCHAIN ) +
                            Pub.cbCertChain );

    if ( pPub )
    {
        pPub->dwType = Pub.dwType ;
        pPub->cbCertChain = Pub.cbCertChain ;
        pPub->pCertChain = (PUCHAR) ( pPub + 1 );

        Status = LsaTable->CopyFromClientBuffer( NULL,
                                                 Pub.cbCertChain,
                                                 pPub->pCertChain,
                                                 Pub.pCertChain );
    }
    else
    {
        Status = SEC_E_INSUFFICIENT_MEMORY ;
    }

    if ( NT_SUCCESS( Status ) )
    {
        return( pPub );
    }

    if ( pPub )
    {
        SPExternalFree( pPub );
    }

    return( NULL );
}

#ifdef _WIN64
PVOID
SpWow64MapSchPublic(
    SSLWOW64_PVOID pRemotePubs)
{
    SECURITY_STATUS Status;
    SSLWOW64_SCH_CRED_PUBLIC_CERTCHAIN Pub;
    SCH_CRED_PUBLIC_CERTCHAIN * pPub;

    Status = LsaTable->CopyFromClientBuffer( NULL,
                                             sizeof( SSLWOW64_SCH_CRED_PUBLIC_CERTCHAIN ),
                                             &Pub,
                                             ULongToPtr(pRemotePubs));
    if ( !NT_SUCCESS( Status ) )
    {
        return( NULL );
    }

    // Reality check
    if(Pub.cbCertChain > 0x00100000)
    {
        return( NULL );
    }

    pPub = SPExternalAlloc( sizeof( SCH_CRED_PUBLIC_CERTCHAIN ) +
                            Pub.cbCertChain );

    if ( pPub )
    {
        pPub->dwType = Pub.dwType ;
        pPub->cbCertChain = Pub.cbCertChain ;
        pPub->pCertChain = (PUCHAR) ( pPub + 1 );

        Status = LsaTable->CopyFromClientBuffer( NULL,
                                                 Pub.cbCertChain,
                                                 pPub->pCertChain,
                                                 ULongToPtr(Pub.pCertChain));
    }
    else
    {
        Status = SEC_E_INSUFFICIENT_MEMORY ;
    }

    if ( NT_SUCCESS( Status ) )
    {
        return( pPub );
    }

    if ( pPub )
    {
        SPExternalFree( pPub );
    }

    return( NULL );
}
#endif // _WIN64


PVOID
SpMapSchCred(
    PVOID   pRemoteCred )
{
    SCH_CRED_SECRET Cred ;
    SECURITY_STATUS Status ;
    DWORD   Size ;
    DWORD   dwType;

    Status = LsaTable->CopyFromClientBuffer( NULL,
                                             sizeof( DWORD ),
                                             &Cred,
                                             pRemoteCred );

    if ( !NT_SUCCESS( Status ) )
    {
        return( NULL );
    }

    dwType = Cred.u.Capi.dwType;

    switch ( dwType )
    {
        case SCHANNEL_SECRET_TYPE_CAPI:
            Size = sizeof( SCH_CRED_SECRET_CAPI );
            break;

        case SCHANNEL_SECRET_PRIVKEY:
            Size = sizeof( SCH_CRED_SECRET_PRIVKEY );
            break;

        default:
            DebugOut(( DEB_ERROR, "Caller specified an unknown cred type\n" ));
            return( NULL );
    }

    if ( Size )
    {
        Status = LsaTable->CopyFromClientBuffer(NULL,
                                                Size,
                                                &Cred,
                                                pRemoteCred );
    }
    else
    {
        Status = SEC_E_INVALID_HANDLE ;
    }
    if(dwType != Cred.u.Capi.dwType)
    {
        Status = SEC_E_INVALID_HANDLE ;
    }

    if ( !NT_SUCCESS( Status ) )
    {
        return( NULL );
    }

    if(Cred.u.Capi.dwType == SCHANNEL_SECRET_TYPE_CAPI)
    {
        SCH_CRED_SECRET_CAPI *pCapiCred;

        pCapiCred = SPExternalAlloc( Size );
        if ( !pCapiCred )
        {
            return( NULL );
        }

        pCapiCred->dwType = Cred.u.Capi.dwType;
        pCapiCred->hProv  = Cred.u.Capi.hProv;

        return( pCapiCred );
    }

    if(Cred.u.Capi.dwType == SCHANNEL_SECRET_PRIVKEY)
    {
        UCHAR   Password[ MAX_PATH + 1 ];
        DWORD   PasswordLen = 0;
        SCH_CRED_SECRET_PRIVKEY *pCred;

        //
        //  The password is the painful part.  Since it is a string, we don't know
        //  how long it is.  So, we have to take a stab at it:
        //

        Status = LsaTable->CopyFromClientBuffer( NULL,
                                                 MAX_PATH,
                                                 Password,
                                                 Cred.u.PrivKey.pszPassword );

        if ( !NT_SUCCESS( Status ) )
        {
            return( NULL );
        }

        Password[ MAX_PATH ] = '\0';

        PasswordLen = strlen( Password );

        // Reality check private key length.
        if(Cred.u.PrivKey.cbPrivateKey > 0x10000)
        {
            return( NULL );
        }

        Size = PasswordLen + 1 + Cred.u.PrivKey.cbPrivateKey +
                sizeof( SCH_CRED_SECRET_PRIVKEY ) ;

        pCred = SPExternalAlloc(  Size );

        if ( !pCred )
        {
            return( NULL );
        }

        pCred->dwType = Cred.u.PrivKey.dwType ;
        pCred->cbPrivateKey = Cred.u.PrivKey.cbPrivateKey ;
        pCred->pPrivateKey = (PBYTE) ( pCred + 1 );
        pCred->pszPassword = (PBYTE) (pCred->pPrivateKey + pCred->cbPrivateKey );

        RtlCopyMemory( pCred->pszPassword, Password, PasswordLen + 1 );

        Status = LsaTable->CopyFromClientBuffer( NULL,
                                                 pCred->cbPrivateKey,
                                                 pCred->pPrivateKey,
                                                 Cred.u.PrivKey.pPrivateKey );

        if ( !NT_SUCCESS( Status ) )
        {
            SPExternalFree( pCred );
            return( NULL );
        }

        return( pCred );
    }

    return( NULL );
}

#ifdef _WIN64
PVOID
SpWow64MapSchCred(
    SSLWOW64_PVOID pRemoteCred )
{
    SSLWOW64_SCH_CRED_SECRET_PRIVKEY LocalCred;
    SCH_CRED_SECRET_PRIVKEY *pCred;
    UCHAR Password[MAX_PATH + 1];
    DWORD PasswordLen = 0;
    SECURITY_STATUS Status ;
    DWORD dwType;
    DWORD Size;

    Status = LsaTable->CopyFromClientBuffer( NULL,
                                             sizeof( DWORD ),
                                             &dwType,
                                             ULongToPtr(pRemoteCred));

    if ( !NT_SUCCESS( Status ) )
    {
        return( NULL );
    }

    if(dwType != SCHANNEL_SECRET_PRIVKEY)
    {
        DebugOut(( DEB_ERROR, "Caller specified an unknown cred type\n" ));
        return( NULL );
    }

    Status = LsaTable->CopyFromClientBuffer(NULL,
                                            sizeof(SSLWOW64_SCH_CRED_SECRET_PRIVKEY),
                                            &LocalCred,
                                            ULongToPtr(pRemoteCred));
    if ( !NT_SUCCESS( Status ) )
    {
        return( NULL );
    }

    //
    //  The password is the painful part.  Since it is a string, we don't know
    //  how long it is.  So, we have to take a stab at it:
    //

    Status = LsaTable->CopyFromClientBuffer( NULL,
                                             MAX_PATH,
                                             Password,
                                             ULongToPtr(LocalCred.pszPassword));

    if ( !NT_SUCCESS( Status ) )
    {
        return( NULL );
    }

    Password[ MAX_PATH ] = '\0';

    PasswordLen = strlen( Password );

    // Reality check private key length.
    if(LocalCred.cbPrivateKey > 0x10000)
    {
        return( NULL );
    }

    Size = PasswordLen + 1 + LocalCred.cbPrivateKey +
            sizeof( SCH_CRED_SECRET_PRIVKEY ) ;

    pCred = SPExternalAlloc(  Size );

    if ( !pCred )
    {
        return( NULL );
    }

    pCred->dwType = SCHANNEL_SECRET_PRIVKEY;
    pCred->cbPrivateKey = LocalCred.cbPrivateKey ;
    pCred->pPrivateKey = (PBYTE) ( pCred + 1 );
    pCred->pszPassword = (PBYTE) (pCred->pPrivateKey + pCred->cbPrivateKey );

    RtlCopyMemory( pCred->pszPassword, Password, PasswordLen + 1 );

    Status = LsaTable->CopyFromClientBuffer( NULL,
                                             pCred->cbPrivateKey,
                                             pCred->pPrivateKey,
                                             ULongToPtr(LocalCred.pPrivateKey));

    if ( !NT_SUCCESS( Status ) )
    {
        SPExternalFree( pCred );
        return( NULL );
    }

    return( pCred );
}
#endif // _WIN64


VOID
SpFreeVersion2Certificate(
    SCH_CRED *  pCred
    )
{
    DWORD i;

    for ( i = 0 ; i < pCred->cCreds ; i++ )
    {
        if ( pCred->paSecret[ i ] )
        {
            SPExternalFree( pCred->paSecret[ i ] );
        }

        if ( pCred->paPublic[ i ] )
        {
            SPExternalFree( pCred->paPublic[ i ] );
        }
    }

    SPExternalFree( pCred );
}

VOID
SpFreeVersion3Certificate(
    PLSA_SCHANNEL_CRED pSchannelCred)
{
    DWORD i;

    if(pSchannelCred->paSubCred)
    {
        for(i = 0; i < pSchannelCred->cSubCreds; i++)
        {
            PLSA_SCHANNEL_SUB_CRED pSubCred = pSchannelCred->paSubCred + i;

            if(pSubCred->pCert)
            {
                CertFreeCertificateContext(pSubCred->pCert);
            }
            if(pSubCred->pszPin)
            {
                SPExternalFree(pSubCred->pszPin);
            }
            if(pSubCred->pPrivateKey)
            {
                SPExternalFree(pSubCred->pPrivateKey);
            }
            if(pSubCred->pszPassword)
            {
                SPExternalFree(pSubCred->pszPassword);
            }
            memset(pSubCred, 0, sizeof(LSA_SCHANNEL_SUB_CRED));
        }
        SPExternalFree((PVOID)pSchannelCred->paSubCred);
        pSchannelCred->paSubCred = NULL;
    }

    if(pSchannelCred->hRootStore)
    {
        CertCloseStore(pSchannelCred->hRootStore, 0);
        pSchannelCred->hRootStore = 0;
    }

    if(pSchannelCred->aphMappers)
    {
        for(i = 0; i < pSchannelCred->cMappers; i++)
        {
            if(pSchannelCred->aphMappers[i])
            {
                SPExternalFree(pSchannelCred->aphMappers[i]);
            }
        }
        SPExternalFree(pSchannelCred->aphMappers);
        pSchannelCred->aphMappers = 0;
    }

    if(pSchannelCred->palgSupportedAlgs)
    {
        SPExternalFree(pSchannelCred->palgSupportedAlgs);
        pSchannelCred->palgSupportedAlgs = 0;
    }

    ZeroMemory(pSchannelCred, sizeof(SCHANNEL_CRED));
}


SECURITY_STATUS
SpMapProtoCredential(
    SSL_CREDENTIAL_CERTIFICATE *pSslCert,
    PSCH_CRED *ppSchCred)
{
    SCH_CRED *                  pCred = NULL;
    SCH_CRED_PUBLIC_CERTCHAIN * pPub  = NULL;
    SCH_CRED_SECRET_PRIVKEY *   pPriv = NULL;
    UCHAR   Password[ MAX_PATH + 1 ];
    DWORD   PasswordLen = 0;
    SECURITY_STATUS Status ;
    DWORD Size;

#if DBG
    DebugLog((DEB_TRACE, "SpMapProtoCredential\n"));
    DBG_HEX_STRING(DEB_TRACE, (PBYTE)pSslCert, sizeof(SSL_CREDENTIAL_CERTIFICATE));
#endif


    //
    // Map over the certificate.
    // 

    // Reality check
    if(pSslCert->cbCertificate > 0x00100000)
    {
        Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto error;
    }

    pPub = SPExternalAlloc( sizeof( SCH_CRED_PUBLIC_CERTCHAIN ) +
                            pSslCert->cbCertificate );

    if ( pPub == NULL)
    {
        Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto error;
    }

    pPub->dwType      = SCH_CRED_X509_CERTCHAIN;
    pPub->cbCertChain = pSslCert->cbCertificate;
    pPub->pCertChain  = (PUCHAR) ( pPub + 1 );

    Status = LsaTable->CopyFromClientBuffer( NULL,
                                             pSslCert->cbCertificate,
                                             pPub->pCertChain,
                                             pSslCert->pCertificate );
    if ( !NT_SUCCESS( Status ) )
    {
        goto error;
    }


    //
    // Map over the private key and password.
    //
    //

    //  The password is the painful part.  Since it is a string, we don't know
    //  how long it is.  So, we have to take a stab at it:
    //

    Status = LsaTable->CopyFromClientBuffer( NULL,
                                             MAX_PATH,
                                             Password,
                                             pSslCert->pszPassword );

    if ( !NT_SUCCESS( Status ) )
    {
        goto error;
    }

    Password[ MAX_PATH ] = '\0';

    PasswordLen = strlen( Password );

    // Reality check private key length.
    if(pSslCert->cbPrivateKey > 0x100000)
    {
        Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto error;
    }

    Size = PasswordLen + 1 + pSslCert->cbPrivateKey +
            sizeof( SCH_CRED_SECRET_PRIVKEY ) ;

    pPriv = SPExternalAlloc(  Size );

    if(pPriv == NULL)
    {
        Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto error;
    }

    pPriv->dwType       = SCHANNEL_SECRET_PRIVKEY;
    pPriv->cbPrivateKey = pSslCert->cbPrivateKey ;
    pPriv->pPrivateKey  = (PBYTE) ( pPriv + 1 );
    pPriv->pszPassword  = (PBYTE) (pPriv->pPrivateKey + pPriv->cbPrivateKey );

    RtlCopyMemory( pPriv->pszPassword, Password, PasswordLen + 1 );

    Status = LsaTable->CopyFromClientBuffer( NULL,
                                             pSslCert->cbPrivateKey,
                                             pPriv->pPrivateKey,
                                             pSslCert->pPrivateKey );

    if ( !NT_SUCCESS( Status ) )
    {
        goto error;
    }


    //
    // Allocate SCH_CRED structure.
    //

    pCred = SPExternalAlloc(sizeof(SCH_CRED) + 2 * sizeof(PVOID));
    if(pCred == NULL)
    {
        Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto error;
    }

    pCred->dwVersion = SCH_CRED_VERSION ;
    pCred->cCreds    = 1 ;
    pCred->paSecret  = (PVOID) ( pCred + 1 );
    pCred->paPublic  = (PVOID) ( pCred->paSecret + 1 );

    pCred->paSecret[0] = pPriv;
    pCred->paPublic[0] = pPub;

    *ppSchCred = pCred;

    return SEC_E_OK;

error:
    if(pCred) SPExternalFree(pCred);
    if(pPub)  SPExternalFree(pPub);
    if(pPriv) SPExternalFree(pPriv);

    return Status;
}


#ifdef _WIN64
SECURITY_STATUS
SpWow64MapProtoCredential(
    SSLWOW64_CREDENTIAL_CERTIFICATE *pSslCert,
    PSCH_CRED *ppSchCred)
{
    SCH_CRED *                  pCred = NULL;
    SCH_CRED_PUBLIC_CERTCHAIN * pPub  = NULL;
    SCH_CRED_SECRET_PRIVKEY *   pPriv = NULL;
    UCHAR   Password[ MAX_PATH + 1 ];
    DWORD   PasswordLen = 0;
    SECURITY_STATUS Status ;
    DWORD Size;

#if DBG
    DebugLog((DEB_TRACE, "SpWow64MapProtoCredential\n"));
    DBG_HEX_STRING(DEB_TRACE, (PBYTE)pSslCert, sizeof(SSLWOW64_CREDENTIAL_CERTIFICATE));
#endif


    //
    // Map over the certificate.
    // 

    // Reality check
    if(pSslCert->cbCertificate > 0x00100000)
    {
        Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto error;
    }

    pPub = SPExternalAlloc( sizeof( SCH_CRED_PUBLIC_CERTCHAIN ) +
                            pSslCert->cbCertificate );

    if ( pPub == NULL)
    {
        Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto error;
    }

    pPub->dwType      = SCH_CRED_X509_CERTCHAIN;
    pPub->cbCertChain = pSslCert->cbCertificate;
    pPub->pCertChain  = (PUCHAR) ( pPub + 1 );

    Status = LsaTable->CopyFromClientBuffer( NULL,
                                             pSslCert->cbCertificate,
                                             pPub->pCertChain,
                                             ULongToPtr(pSslCert->pCertificate));
    if ( !NT_SUCCESS( Status ) )
    {
        goto error;
    }


    //
    // Map over the private key and password.
    //
    //

    //  The password is the painful part.  Since it is a string, we don't know
    //  how long it is.  So, we have to take a stab at it:
    //

    Status = LsaTable->CopyFromClientBuffer( NULL,
                                             MAX_PATH,
                                             Password,
                                             ULongToPtr(pSslCert->pszPassword));

    if ( !NT_SUCCESS( Status ) )
    {
        goto error;
    }

    Password[ MAX_PATH ] = '\0';

    PasswordLen = strlen( Password );

    // Reality check private key length.
    if(pSslCert->cbPrivateKey > 0x100000)
    {
        Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto error;
    }

    Size = PasswordLen + 1 + pSslCert->cbPrivateKey +
            sizeof( SCH_CRED_SECRET_PRIVKEY ) ;

    pPriv = SPExternalAlloc(  Size );

    if(pPriv == NULL)
    {
        Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto error;
    }

    pPriv->dwType       = SCHANNEL_SECRET_PRIVKEY;
    pPriv->cbPrivateKey = pSslCert->cbPrivateKey ;
    pPriv->pPrivateKey  = (PBYTE) ( pPriv + 1 );
    pPriv->pszPassword  = (PBYTE) (pPriv->pPrivateKey + pPriv->cbPrivateKey );

    RtlCopyMemory( pPriv->pszPassword, Password, PasswordLen + 1 );

    Status = LsaTable->CopyFromClientBuffer( NULL,
                                             pSslCert->cbPrivateKey,
                                             pPriv->pPrivateKey,
                                             ULongToPtr(pSslCert->pPrivateKey));

    if ( !NT_SUCCESS( Status ) )
    {
        goto error;
    }


    //
    // Allocate SCH_CRED structure.
    //

    pCred = SPExternalAlloc(sizeof(SCH_CRED) + 2 * sizeof(PVOID));
    if(pCred == NULL)
    {
        Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto error;
    }

    pCred->dwVersion = SCH_CRED_VERSION ;
    pCred->cCreds    = 1 ;
    pCred->paSecret  = (PVOID) ( pCred + 1 );
    pCred->paPublic  = (PVOID) ( pCred->paSecret + 1 );

    pCred->paSecret[0] = pPriv;
    pCred->paPublic[0] = pPub;

    *ppSchCred = pCred;

    return SEC_E_OK;

error:
    if(pCred) SPExternalFree(pCred);
    if(pPub)  SPExternalFree(pPub);
    if(pPriv) SPExternalFree(pPriv);

    return Status;
}
#endif // _WIN64


SECURITY_STATUS
SpMapVersion2Certificate(
    PVOID       pvAuthData,
    SCH_CRED * *ppCred
    )
{
    SECURITY_STATUS Status ;
    SCH_CRED    Cred;
    PSCH_CRED   pCred;
    DWORD       Size;
    DWORD       i;
    BOOL        Failed = FALSE ;

    Status = LsaTable->CopyFromClientBuffer( NULL,
                                            sizeof( SCH_CRED ),
                                            &Cred,
                                            pvAuthData );

    if ( !NT_SUCCESS( Status ) )
    {
        return( Status );
    }

#if DBG
    DebugLog((DEB_TRACE, "SpMapVersion2Certificate: %d certificates in cred\n", Cred.cCreds));
    DBG_HEX_STRING(DEB_TRACE, (PBYTE)&Cred, sizeof(SCH_CRED));
#endif

    // Reality check credential count.
    if(Cred.cCreds > 100)
    {
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }

    Size = sizeof( SCH_CRED ) + (2 * Cred.cCreds * sizeof( PVOID ) );

    pCred = SPExternalAlloc( Size );
    if(pCred == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }

    pCred->dwVersion = Cred.dwVersion ;
    pCred->cCreds = Cred.cCreds ;
    pCred->paSecret = (PVOID) ( pCred + 1 );
    pCred->paPublic = (PVOID) ( pCred->paSecret + Cred.cCreds );

    Status = LsaTable->CopyFromClientBuffer( NULL,
                                             sizeof( PVOID ) * Cred.cCreds,
                                             pCred->paSecret,
                                             Cred.paSecret );

    if ( NT_SUCCESS( Status ) )
    {
        Status = LsaTable->CopyFromClientBuffer( NULL,
                                                 sizeof( PVOID ) * Cred.cCreds,
                                                 pCred->paPublic,
                                                 Cred.paPublic );
    }

    if ( !NT_SUCCESS( Status ) )
    {
        SPExternalFree( pCred );

        return( Status );
    }

    //
    // Ok.  We have pCred in local memory, with a chain of cert/private key
    // stuff hanging off of it.  We now have to map in each one.  Happy, happy.
    //

    for ( i = 0 ; i < Cred.cCreds ; i++ )
    {
        pCred->paSecret[i] = SpMapSchCred( pCred->paSecret[i] );

        if ( pCred->paSecret[i] == NULL )
        {
            Failed = TRUE ;
        }
    }

    for ( i = 0 ; i < Cred.cCreds ; i++ )
    {
        pCred->paPublic[i] = SpMapSchPublic( pCred->paPublic[i] );

        if ( pCred->paPublic[i] == NULL )
        {
            Failed = TRUE ;
        }
    }

    if ( Failed )
    {
        SpFreeVersion2Certificate( pCred );

        pCred = NULL ;

        Status = SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS) ;
    }

    *ppCred = pCred ;

    return( Status );
}


#ifdef _WIN64
SECURITY_STATUS
SpWow64MapVersion2Certificate(
    PVOID       pvAuthData,
    SCH_CRED * *ppCred
    )
{
    SECURITY_STATUS Status ;
    SSLWOW64_SCH_CRED Cred;
    PSCH_CRED   pCred;
    DWORD       Size;
    BOOL        Failed = FALSE ;

    Status = LsaTable->CopyFromClientBuffer( NULL,
                                            sizeof( SSLWOW64_SCH_CRED ),
                                            &Cred,
                                            pvAuthData );

    if ( !NT_SUCCESS( Status ) )
    {
        return( Status );
    }

#if DBG
    DebugLog((DEB_TRACE, "SpMapVersion2Certificate: %d certificates in cred\n", Cred.cCreds));
    DBG_HEX_STRING(DEB_TRACE, (PBYTE)&Cred, sizeof(SCH_CRED));
#endif

    if(Cred.cCreds > 100)
    {
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }
    if(Cred.cCreds > 1)
    {
        // Only support a single certificate, which is all that anyone
        // ever uses anyway.
        Cred.cCreds = 1;
    }

    Size = sizeof( SCH_CRED ) + (2 * Cred.cCreds * sizeof( PVOID ) );

    pCred = SPExternalAlloc( Size );
    if(pCred == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }

    pCred->dwVersion = Cred.dwVersion;
    pCred->cCreds    = Cred.cCreds;

    if(pCred->cCreds > 0)
    {
        SSLWOW64_PVOID ClientSecret;
        SSLWOW64_PVOID ClientPublic;

        pCred->paSecret = (PVOID) ( pCred + 1 );
        pCred->paPublic = (PVOID) ( pCred->paSecret + Cred.cCreds );

        Status = LsaTable->CopyFromClientBuffer( NULL,
                                                 sizeof(SSLWOW64_PVOID),
                                                 &ClientSecret,
                                                 ULongToPtr(Cred.paSecret));

        if ( NT_SUCCESS( Status ) )
        {
            Status = LsaTable->CopyFromClientBuffer( NULL,
                                                     sizeof(SSLWOW64_PVOID),
                                                     &ClientPublic,
                                                     ULongToPtr(Cred.paPublic));
        }

        if ( !NT_SUCCESS( Status ) )
        {
            SPExternalFree( pCred );

            return( Status );
        }

        pCred->paSecret[0] = SpWow64MapSchCred(ClientSecret);

        if ( pCred->paSecret[0] == NULL )
        {
            Failed = TRUE ;
        }

        pCred->paPublic[0] = SpWow64MapSchPublic(ClientPublic);

        if ( pCred->paPublic[0] == NULL )
        {
            Failed = TRUE ;
        }
    }

    if ( Failed )
    {
        SpFreeVersion2Certificate( pCred );

        pCred = NULL ;

        Status = SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS) ;
    }

    *ppCred = pCred ;

    return( Status );
}
#endif // _WIN64


// Selectively enable the unified protocol.
DWORD
EnableUnifiedProtocol(DWORD dwPackageType, DWORD dwProtocol)
{
    DWORD cProts = 0;

    // Disable unified.
    dwProtocol &= ~SP_PROT_UNI;

    if(dwPackageType & SP_PROT_UNI)
    {
        // Count enabled protocols.
        if(dwProtocol & SP_PROT_PCT1) cProts++;
        if(dwProtocol & SP_PROT_SSL2) cProts++;
        if(dwProtocol & (SP_PROT_SSL3 | SP_PROT_TLS1)) cProts++;

        // Enable unified if multiple protocols enabled.
        if(cProts > 1)
        {
            if(dwPackageType & SP_PROT_CLIENTS)
            {
                dwProtocol |= SP_PROT_UNI_CLIENT;
            }
            else
            {
                dwProtocol |= SP_PROT_UNI_SERVER;
            }
        }
    }

    return dwProtocol;
}


SECURITY_STATUS
SpMapMapperList(
    HMAPPER **  apMappers,   // in
    DWORD       cMappers,    // in
    HMAPPER *** papMappers)  // out
{
    HMAPPER **  MapperList;
    HMAPPER **  ClientMapperList;
    DWORD       cbMapperList;
    SECURITY_STATUS scRet;
    DWORD i;

    if(cMappers == 0)
    {
        return SEC_E_OK;
    }

    // Allocate memory for mapper pointer list.
    cbMapperList = cMappers * sizeof(PVOID);
    MapperList = SPExternalAlloc(cbMapperList * 2);
    if(MapperList == NULL)
    {
        return SEC_E_INSUFFICIENT_MEMORY;
    }
    ClientMapperList = MapperList + cMappers;

    // Copy mapper list over from client memory.
    scRet = LsaTable->CopyFromClientBuffer(
                                NULL,
                                cbMapperList,
                                ClientMapperList,
                                apMappers);
    if(!NT_SUCCESS(scRet))
    {
        goto error;
    }

    // Make local copies of the mapper structures.
    for(i = 0; i < cMappers; i++)
    {
        MapperList[i] = SPExternalAlloc(sizeof(HMAPPER));
        if(MapperList[i] == NULL)
        {
            scRet = SEC_E_INSUFFICIENT_MEMORY;
            goto error;
        }

        // Copy HMAPPER structure over from client memory.
        scRet = LsaTable->CopyFromClientBuffer(
                                    NULL,
                                    sizeof(HMAPPER),
                                    MapperList[i],
                                    ClientMapperList[i]);
        if(!NT_SUCCESS(scRet))
        {
            goto error;
        }

        // Save original application HMAPPER pointer.
        MapperList[i]->m_Reserved1 = ClientMapperList[i];
    }

    *papMappers = MapperList;

    return SEC_E_OK;


error:

    for(i = 0; i < cMappers; i++)
    {
        if(MapperList[i])
        {
            SPExternalFree(MapperList[i]);
        }
    }
    SPExternalFree(MapperList);

    return scRet;
}


typedef struct _V3_SCHANNEL_CRED
{
    DWORD           dwVersion;      // always SCHANNEL_CRED_VERSION
    DWORD           cCreds;
    PCCERT_CONTEXT *paCred;
    HCERTSTORE      hRootStore;

    DWORD           cMappers;
    struct _HMAPPER **aphMappers;

    DWORD           cSupportedAlgs;
    ALG_ID *        palgSupportedAlgs;

    DWORD           grbitEnabledProtocols;
    DWORD           dwMinimumCipherStrength;
    DWORD           dwMaximumCipherStrength;
    DWORD           dwSessionLifespan;
} V3_SCHANNEL_CRED;


//+---------------------------------------------------------------------------
//
//  Function:   SpMapVersion3Certificate
//
//  Synopsis:   Maps a version 3 schannel credential into LSA memory
//
//  Arguments:  [pvAuthData] -- pointer to cred in application process
//              [pCred]      -- pointer to cred in LSA process
//
//  History:    09-23-97   jbanes   Created
//
//  Notes:      The credential consists of the following structure. Note
//              that all CryptoAPI 2.0 handles must be mapped over as well,
//              via the callback mechanism.
//
//              typedef struct _SCHANNEL_CRED
//              {
//                  DWORD           dwVersion;
//                  DWORD           cCreds;
//                  PCCERT_CONTEXT  *paCred;
//                  HCERTSTORE      hRootStore;
//
//                  DWORD            cMappers;
//                  struct _HMAPPER  **aphMappers;
//
//                  DWORD           cSupportedAlgs;
//                  ALG_ID          *palgSupportedAlgs;
//
//                  DWORD           grbitEnabledProtocols;
//                  DWORD           dwMinimumCipherStrength;
//                  DWORD           dwMaximumCipherStrength;
//                  DWORD           dwSessionLifespan;
//
//              } SCHANNEL_CRED, *PSCHANNEL_CRED;
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SpMapVersion3Certificate(
    PVOID pvAuthData,           // in
    DWORD dwVersion,            // in
    PLSA_SCHANNEL_CRED pCred)   // out
{
    PCERT_CONTEXT * pLocalCredList = NULL;
    HCERTSTORE      hStore = NULL;
    CRYPT_DATA_BLOB Serialized;
    CRYPT_DATA_BLOB DataBlob;
    SCHANNEL_CRED   LocalCred;
    SecBuffer       Input;
    SecBuffer       Output;
    PBYTE           pbBuffer;
    DWORD           cbBuffer;
    DWORD           cbData;
    SECURITY_STATUS scRet;
    DWORD           Size;
    DWORD           iCred;

    Output.pvBuffer = NULL;

    //
    // Copy over the SCHANNEL_CRED structure.
    //

    if(dwVersion == SCH_CRED_V3)
    {
        scRet = LsaTable->CopyFromClientBuffer(NULL,
                                               sizeof(V3_SCHANNEL_CRED),
                                               &LocalCred,
                                               pvAuthData);
        if(!NT_SUCCESS(scRet))
        {
            goto cleanup;
        }

        LocalCred.dwFlags  = 0;
        LocalCred.reserved = 0;

#if DBG
        DebugLog((DEB_TRACE, "SpMapVersion3Certificate: %d certificates in cred\n", LocalCred.cCreds));
        DBG_HEX_STRING(DEB_TRACE, (PBYTE)&LocalCred, sizeof(V3_SCHANNEL_CRED));
#endif
    }
    else
    {
        scRet = LsaTable->CopyFromClientBuffer(NULL,
                                               sizeof(SCHANNEL_CRED),
                                               &LocalCred,
                                               pvAuthData);
        if(!NT_SUCCESS(scRet))
        {
            goto cleanup;
        }

#if DBG
        DebugLog((DEB_TRACE, "SpMapVersion4Certificate: %d certificates in cred\n", LocalCred.cCreds));
        DBG_HEX_STRING(DEB_TRACE, (PBYTE)&LocalCred, sizeof(SCHANNEL_CRED));
#endif
    }


    //
    // DWORD           dwVersion;
    //

    memset(pCred, 0, sizeof(LSA_SCHANNEL_CRED));

    pCred->dwVersion = LocalCred.dwVersion;


    //
    // DWORD           cCreds;
    // PCCERT_CONTEXT  *paCred;
    //

    if(LocalCred.cCreds && LocalCred.paCred)
    {
        Size = LocalCred.cCreds * sizeof(PVOID);

        // Reality check credential count.
        if(LocalCred.cCreds > 1000)
        {
            scRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            goto cleanup;
        }

        // Make local copy of application cred list.
        pLocalCredList = SPExternalAlloc(Size);
        if(pLocalCredList == NULL)
        {
            scRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            goto cleanup;
        }
        scRet = LsaTable->CopyFromClientBuffer(
                                    NULL,
                                    Size,
                                    pLocalCredList,
                                    (PCERT_CONTEXT *)LocalCred.paCred);
        if(!NT_SUCCESS(scRet))
        {
            goto cleanup;
        }

        // Allocate memory for our cred list.
        pCred->cSubCreds = LocalCred.cCreds;
        pCred->paSubCred = SPExternalAlloc(pCred->cSubCreds * sizeof(LSA_SCHANNEL_SUB_CRED));
        if(pCred->paSubCred == NULL)
        {
            scRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            goto cleanup;
        }

        // Create an in-memory certificate store.
        hStore = CertOpenStore(CERT_STORE_PROV_MEMORY,
                               0, 0,
                               CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
                               0);
        if(hStore == NULL)
        {
            SP_LOG_RESULT(GetLastError());
            scRet = SEC_E_INSUFFICIENT_MEMORY;
            goto cleanup;
        }

        // Copy over each certificate context.
        for(iCred = 0; iCred < LocalCred.cCreds; iCred++)
        {
            PLSA_SCHANNEL_SUB_CRED pSubCred;

            pSubCred = pCred->paSubCred + iCred;

            Input.BufferType  = SECBUFFER_DATA;
            Input.cbBuffer    = sizeof(PVOID);
            Input.pvBuffer    = (PVOID)&pLocalCredList[iCred];

            scRet = PerformApplicationCallback(SCH_UPLOAD_CREDENTIAL_CALLBACK,
                                               0, 0,
                                               &Input,
                                               &Output,
                                               TRUE);
            if(!NT_SUCCESS(scRet))
            {
                Output.pvBuffer = NULL;
                goto cleanup;
            }

            pbBuffer = Output.pvBuffer;
            cbBuffer = Output.cbBuffer;

            if(pbBuffer == NULL ||
               cbBuffer < sizeof(HCRYPTPROV) + sizeof(DWORD))
            {
                scRet = SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
                goto cleanup;
            }

            // Parse hProv.
            pSubCred->hRemoteProv = *(HCRYPTPROV *)pbBuffer;
            pbBuffer += sizeof(HCRYPTPROV);
            cbBuffer -= sizeof(HCRYPTPROV);

            // Parse certificate context length.
            cbData = *(DWORD *)pbBuffer;
            pbBuffer += sizeof(DWORD);
            cbBuffer -= sizeof(DWORD);

            // Parse certificate context.
            if(cbBuffer < cbData)
            {
                scRet = SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
                goto cleanup;
            }
            if(!CertAddSerializedElementToStore(hStore,
                                                pbBuffer,
                                                cbData,
                                                CERT_STORE_ADD_ALWAYS,
                                                0,
                                                CERT_STORE_CERTIFICATE_CONTEXT_FLAG,
                                                NULL,
                                                &pSubCred->pCert))
            {
                scRet = SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
                goto cleanup;
            }

            // Free the output buffer.
            SPExternalFree(Output.pvBuffer);
            Output.pvBuffer = NULL;
        }
    }


    //
    // HCERTSTORE      hRootStore;
    //

    if(LocalCred.hRootStore != NULL)
    {
        Input.BufferType  = SECBUFFER_DATA;
        Input.cbBuffer    = sizeof(HCERTSTORE);
        Input.pvBuffer    = (PVOID)&LocalCred.hRootStore;

        scRet = PerformApplicationCallback(SCH_UPLOAD_CERT_STORE_CALLBACK,
                                           0, 0,
                                           &Input,
                                           &Output,
                                           TRUE);
        if(scRet != SEC_E_OK)
        {
            goto cleanup;
        }

        pbBuffer = Output.pvBuffer;
        cbBuffer = Output.cbBuffer;

        if(pbBuffer == NULL || cbBuffer < sizeof(DWORD))
        {
            scRet = SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
            goto cleanup;
        }

        // Parse certificate store.
        Serialized.cbData = *(DWORD *)pbBuffer;
        Serialized.pbData = pbBuffer + sizeof(DWORD);
        if(cbBuffer - sizeof(DWORD) < Serialized.cbData)
        {
            scRet = SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
            goto cleanup;
        }
        pCred->hRootStore = CertOpenStore( CERT_STORE_PROV_SERIALIZED,
                                           X509_ASN_ENCODING,
                                           0, 0,
                                           &Serialized);
        if(pCred->hRootStore == NULL)
        {
            scRet = SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
            goto cleanup;
        }

        // Free the output buffer.
        SPExternalFree(Output.pvBuffer);
        Output.pvBuffer = NULL;
    }


    //
    // DWORD            cMappers;
    // struct _HMAPPER  **aphMappers;
    //

    if(LocalCred.cMappers && LocalCred.aphMappers)
    {
        // Reality check.
        if(LocalCred.cMappers > 100)
        {
            scRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        }

        pCred->cMappers = LocalCred.cMappers;

        scRet = SpMapMapperList(LocalCred.aphMappers,
                                LocalCred.cMappers,
                                &pCred->aphMappers);
        if(!NT_SUCCESS(scRet))
        {
            SP_LOG_RESULT(scRet);
            goto cleanup;
        }
    }


    //
    // DWORD           cSupportedAlgs;
    // ALG_ID          *palgSupportedAlgs;
    //

    if(LocalCred.cSupportedAlgs && LocalCred.palgSupportedAlgs)
    {
        // Reality check.
        if(LocalCred.cSupportedAlgs > 1000)
        {
            scRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            goto cleanup;
        }

        Size = LocalCred.cSupportedAlgs * sizeof(ALG_ID);

        pCred->cSupportedAlgs    = LocalCred.cSupportedAlgs;
        pCred->palgSupportedAlgs = SPExternalAlloc(Size);
        if(pCred->palgSupportedAlgs == NULL)
        {
            scRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            goto cleanup;
        }

        scRet = LsaTable->CopyFromClientBuffer(NULL,
                                               Size,
                                               pCred->palgSupportedAlgs,
                                               LocalCred.palgSupportedAlgs);
        if(!NT_SUCCESS(scRet))
        {
            goto cleanup;
        }
    }


    //
    // DWORD           grbitEnabledProtocols;
    // DWORD           dwMinimumCipherStrength;
    // DWORD           dwMaximumCipherStrength;
    // DWORD           dwSessionLifespan;
    // DWORD           dwFlags;
    // DWORD           reserved;
    //

    pCred->grbitEnabledProtocols   = LocalCred.grbitEnabledProtocols;
    pCred->dwMinimumCipherStrength = LocalCred.dwMinimumCipherStrength;
    pCred->dwMaximumCipherStrength = LocalCred.dwMaximumCipherStrength;
    pCred->dwSessionLifespan       = LocalCred.dwSessionLifespan;
    pCred->dwFlags                 = LocalCred.dwFlags;
    pCred->reserved                = LocalCred.reserved;


    scRet = SEC_E_OK;

cleanup:

    if(Output.pvBuffer)
    {
        SPExternalFree(Output.pvBuffer);
    }
    if(pLocalCredList)
    {
        SPExternalFree(pLocalCredList);
    }
    if(hStore)
    {
        CertCloseStore(hStore, 0);
    }

    if(!NT_SUCCESS(scRet))
    {
        SpFreeVersion3Certificate(pCred);
    }

    return scRet;
}

#ifdef _WIN64
SECURITY_STATUS
SpWow64MapVersion3Certificate(
    PVOID pvAuthData,           // in
    DWORD dwVersion,            // in
    PLSA_SCHANNEL_CRED pCred)   // out
{
    SSLWOW64_PCCERT_CONTEXT *pLocalCredList = NULL;
    HCERTSTORE      hStore = NULL;
    CRYPT_DATA_BLOB Serialized;
    CRYPT_DATA_BLOB DataBlob;
    SSLWOW64_SCHANNEL_CRED LocalCred;
    SecBuffer       Input;
    SecBuffer       Output;
    PBYTE           pbBuffer;
    DWORD           cbBuffer;
    DWORD           cbData;
    SECURITY_STATUS scRet;
    DWORD           Size;
    DWORD           iCred;

    Output.pvBuffer = NULL;

    //
    // Copy over the SCHANNEL_CRED structure.
    //

    if(dwVersion == SCH_CRED_V3)
    {
        scRet = LsaTable->CopyFromClientBuffer(NULL,
                                               sizeof(SSLWOW64_SCHANNEL3_CRED),
                                               &LocalCred,
                                               pvAuthData);
        if(!NT_SUCCESS(scRet))
        {
            goto cleanup;
        }

        LocalCred.dwFlags  = 0;
        LocalCred.reserved = 0;

#if DBG
        DebugLog((DEB_TRACE, "SpMapVersion3Certificate: %d certificates in cred\n", LocalCred.cCreds));
        DBG_HEX_STRING(DEB_TRACE, (PBYTE)&LocalCred, sizeof(SSLWOW64_SCHANNEL_CRED));
#endif
    }
    else
    {
        scRet = LsaTable->CopyFromClientBuffer(NULL,
                                               sizeof(SSLWOW64_SCHANNEL_CRED),
                                               &LocalCred,
                                               pvAuthData);
        if(!NT_SUCCESS(scRet))
        {
            goto cleanup;
        }

#if DBG
        DebugLog((DEB_TRACE, "SpMapVersion4Certificate: %d certificates in cred\n", LocalCred.cCreds));
        DBG_HEX_STRING(DEB_TRACE, (PBYTE)&LocalCred, sizeof(SSLWOW64_SCHANNEL_CRED));
#endif
    }


    //
    // DWORD           dwVersion;
    //

    memset(pCred, 0, sizeof(LSA_SCHANNEL_CRED));

    pCred->dwVersion = LocalCred.dwVersion;


    //
    // DWORD           cCreds;
    // PCCERT_CONTEXT  *paCred;
    //

    if(LocalCred.cCreds && LocalCred.paCred)
    {
        Size = LocalCred.cCreds * sizeof(SSLWOW64_PCCERT_CONTEXT);

        // Reality check credential count.
        if(LocalCred.cCreds > 1000)
        {
            scRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            goto cleanup;
        }

        // Make local copy of application cred list.
        pLocalCredList = SPExternalAlloc(Size);
        if(pLocalCredList == NULL)
        {
            scRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            goto cleanup;
        }
        scRet = LsaTable->CopyFromClientBuffer(
                                    NULL,
                                    Size,
                                    pLocalCredList,
                                    ULongToPtr(LocalCred.paCred));
        if(!NT_SUCCESS(scRet))
        {
            goto cleanup;
        }

        // Allocate memory for our cred list.
        pCred->cSubCreds = LocalCred.cCreds;
        pCred->paSubCred = SPExternalAlloc(pCred->cSubCreds * sizeof(LSA_SCHANNEL_SUB_CRED));
        if(pCred->paSubCred == NULL)
        {
            scRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            goto cleanup;
        }

        // Create an in-memory certificate store.
        hStore = CertOpenStore(CERT_STORE_PROV_MEMORY,
                               0, 0,
                               CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
                               0);
        if(hStore == NULL)
        {
            SP_LOG_RESULT(GetLastError());
            scRet = SEC_E_INSUFFICIENT_MEMORY;
            goto cleanup;
        }

        // Copy over each certificate context.
        for(iCred = 0; iCred < LocalCred.cCreds; iCred++)
        {
            PLSA_SCHANNEL_SUB_CRED pSubCred;

            pSubCred = pCred->paSubCred + iCred;

            Input.BufferType  = SECBUFFER_DATA;
            Input.cbBuffer    = sizeof(SSLWOW64_PCCERT_CONTEXT);
            Input.pvBuffer    = (PVOID)&pLocalCredList[iCred];

            scRet = PerformApplicationCallback(SCH_UPLOAD_CREDENTIAL_CALLBACK,
                                               0, 0,
                                               &Input,
                                               &Output,
                                               TRUE);
            if(!NT_SUCCESS(scRet))
            {
                Output.pvBuffer = NULL;
                goto cleanup;
            }

            pbBuffer = Output.pvBuffer;
            cbBuffer = Output.cbBuffer;

            if(pbBuffer == NULL ||
               cbBuffer < sizeof(HCRYPTPROV) + sizeof(DWORD))
            {
                scRet = SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
                goto cleanup;
            }

            // Parse hProv.
            pSubCred->hRemoteProv = *(SSLWOW64_HCRYPTPROV *)pbBuffer;
            pbBuffer += sizeof(SSLWOW64_HCRYPTPROV);
            cbBuffer -= sizeof(SSLWOW64_HCRYPTPROV);

            // Parse certificate context length.
            cbData = *(DWORD *)pbBuffer;
            pbBuffer += sizeof(DWORD);
            cbBuffer -= sizeof(DWORD);

            // Parse certificate context.
            if(cbBuffer < cbData)
            {
                scRet = SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
                goto cleanup;
            }
            if(!CertAddSerializedElementToStore(hStore,
                                                pbBuffer,
                                                cbData,
                                                CERT_STORE_ADD_ALWAYS,
                                                0,
                                                CERT_STORE_CERTIFICATE_CONTEXT_FLAG,
                                                NULL,
                                                &pSubCred->pCert))
            {
                SP_LOG_RESULT(GetLastError());
                scRet = SEC_E_UNKNOWN_CREDENTIALS;
                goto cleanup;
            }

            // Free the output buffer.
            SPExternalFree(Output.pvBuffer);
            Output.pvBuffer = NULL;
        }
    }


    //
    // HCERTSTORE      hRootStore;
    //

    if(LocalCred.hRootStore)
    {
        Input.BufferType  = SECBUFFER_DATA;
        Input.cbBuffer    = sizeof(SSLWOW64_HCERTSTORE);
        Input.pvBuffer    = (PVOID)&LocalCred.hRootStore;

        scRet = PerformApplicationCallback(SCH_UPLOAD_CERT_STORE_CALLBACK,
                                           0, 0,
                                           &Input,
                                           &Output,
                                           TRUE);
        if(scRet != SEC_E_OK)
        {
            goto cleanup;
        }

        pbBuffer = Output.pvBuffer;
        cbBuffer = Output.cbBuffer;

        if(pbBuffer == NULL || cbBuffer < sizeof(DWORD))
        {
            scRet = SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
            goto cleanup;
        }

        // Parse certificate store.
        Serialized.cbData = *(DWORD *)pbBuffer;
        Serialized.pbData = pbBuffer + sizeof(DWORD);
        if(cbBuffer - sizeof(DWORD) < Serialized.cbData)
        {
            scRet = SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
            goto cleanup;
        }
        pCred->hRootStore = CertOpenStore( CERT_STORE_PROV_SERIALIZED,
                                           X509_ASN_ENCODING,
                                           0, 0,
                                           &Serialized);
        if(pCred->hRootStore == NULL)
        {
            scRet = SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
            goto cleanup;
        }

        // Free the output buffer.
        SPExternalFree(Output.pvBuffer);
        Output.pvBuffer = NULL;
    }


    //
    // DWORD            cMappers;
    // struct _HMAPPER  **aphMappers;
    //

    if(LocalCred.cMappers && LocalCred.aphMappers)
    {
        // We don't support WOW64 application certificate mappers.
        pCred->cMappers = 0;
        pCred->aphMappers = NULL;
    }


    //
    // DWORD           cSupportedAlgs;
    // ALG_ID          *palgSupportedAlgs;
    //

    if(LocalCred.cSupportedAlgs && LocalCred.palgSupportedAlgs)
    {
        // Reality check.
        if(LocalCred.cSupportedAlgs > 1000)
        {
            scRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            goto cleanup;
        }

        Size = LocalCred.cSupportedAlgs * sizeof(ALG_ID);

        pCred->cSupportedAlgs    = LocalCred.cSupportedAlgs;
        pCred->palgSupportedAlgs = SPExternalAlloc(Size);
        if(pCred->palgSupportedAlgs == NULL)
        {
            scRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            goto cleanup;
        }

        scRet = LsaTable->CopyFromClientBuffer(NULL,
                                               Size,
                                               pCred->palgSupportedAlgs,
                                               ULongToPtr(LocalCred.palgSupportedAlgs));
        if(!NT_SUCCESS(scRet))
        {
            goto cleanup;
        }
    }


    //
    // DWORD           grbitEnabledProtocols;
    // DWORD           dwMinimumCipherStrength;
    // DWORD           dwMaximumCipherStrength;
    // DWORD           dwSessionLifespan;
    // DWORD           dwFlags;
    // DWORD           reserved;
    //

    pCred->grbitEnabledProtocols   = LocalCred.grbitEnabledProtocols;
    pCred->dwMinimumCipherStrength = LocalCred.dwMinimumCipherStrength;
    pCred->dwMaximumCipherStrength = LocalCred.dwMaximumCipherStrength;
    pCred->dwSessionLifespan       = LocalCred.dwSessionLifespan;
    pCred->dwFlags                 = LocalCred.dwFlags;
    pCred->reserved                = LocalCred.reserved;


    scRet = SEC_E_OK;

cleanup:

    if(Output.pvBuffer)
    {
        SPExternalFree(Output.pvBuffer);
    }
    if(pLocalCredList)
    {
        SPExternalFree(pLocalCredList);
    }
    if(hStore)
    {
        CertCloseStore(hStore, 0);
    }

    if(!NT_SUCCESS(scRet))
    {
        SpFreeVersion3Certificate(pCred);
    }

    return scRet;
}
#endif // _WIN64


SECURITY_STATUS
SpMapAuthIdentity(
    PVOID pAuthData,
    PLSA_SCHANNEL_CRED pSchannelCred)
{
    PSEC_WINNT_AUTH_IDENTITY_EXW pAuthIdentity = NULL;
    SEC_WINNT_AUTH_IDENTITY_EX32 AuthIdentity32 = {0};
    BOOLEAN DoUnicode = TRUE;
    UNICODE_STRING UserName;
    UNICODE_STRING Password;
    NTSTATUS Status;
    CRED_MARSHAL_TYPE CredType;
    PCERT_CREDENTIAL_INFO pCertInfo = NULL;
    PCCERT_CONTEXT pCertContext = NULL;
    HCERTSTORE hStore = 0;
    CRYPT_HASH_BLOB HashBlob;
    BOOL fImpersonating = FALSE;
    SECPKG_CALL_INFO CallInfo;
    BOOL fWow64Client = FALSE;

    DebugLog((DEB_TRACE, "SpMapAuthIdentity\n"));

#ifdef _WIN64
    if(!LsaTable->GetCallInfo(&CallInfo))
    {
        Status = STATUS_INTERNAL_ERROR;
        return SP_LOG_RESULT(Status);
    }
    fWow64Client = (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT) != 0;
#endif


    //
    // Initialize.
    //

    RtlInitUnicodeString(
        &UserName,
        NULL);

    RtlInitUnicodeString(
        &Password,
        NULL);


    // 
    // Copy over the SEC_WINNT_AUTH_IDENTITY_EX structure from client memory.
    //

    pAuthIdentity = (PSEC_WINNT_AUTH_IDENTITY_EXW)SPExternalAlloc(sizeof(SEC_WINNT_AUTH_IDENTITY_EXW));
    if(pAuthIdentity == NULL)
    {
        Status = SEC_E_INSUFFICIENT_MEMORY;
        goto cleanup;
    }
 
    if(fWow64Client)
    {
        Status = LsaTable->CopyFromClientBuffer(
                    NULL,
                    sizeof(SEC_WINNT_AUTH_IDENTITY_EX32),
                    &AuthIdentity32,
                    pAuthData);

        if (!NT_SUCCESS(Status))
        {
            SP_LOG_RESULT(Status);
            goto cleanup;
        }

        pAuthIdentity->Version = AuthIdentity32.Version;
        pAuthIdentity->Length = (AuthIdentity32.Length < sizeof(SEC_WINNT_AUTH_IDENTITY_EX) ?
                              sizeof(SEC_WINNT_AUTH_IDENTITY_EX) : AuthIdentity32.Length);

        pAuthIdentity->UserLength = AuthIdentity32.UserLength;
        pAuthIdentity->User = (PWSTR) UlongToPtr(AuthIdentity32.User);
        pAuthIdentity->DomainLength = AuthIdentity32.DomainLength ;
        pAuthIdentity->Domain = (PWSTR) UlongToPtr( AuthIdentity32.Domain );
        pAuthIdentity->PasswordLength = AuthIdentity32.PasswordLength ;
        pAuthIdentity->Password = (PWSTR) UlongToPtr( AuthIdentity32.Password );
        pAuthIdentity->Flags = AuthIdentity32.Flags ;
        pAuthIdentity->PackageListLength = AuthIdentity32.PackageListLength ;
        pAuthIdentity->PackageList = (PWSTR) UlongToPtr( AuthIdentity32.PackageList );
    }
    else
    {
        Status = LsaTable->CopyFromClientBuffer(
                    NULL,
                    sizeof(SEC_WINNT_AUTH_IDENTITY_EXW),
                    pAuthIdentity,
                    pAuthData);

        if (!NT_SUCCESS(Status))
        {
            SP_LOG_RESULT(Status);
            goto cleanup;
        }
    }

    if ((pAuthIdentity->Flags & SEC_WINNT_AUTH_IDENTITY_ANSI) != 0)
    {
        DoUnicode = FALSE;
    }


    //
    // Copy over the user name and password.
    //

    if (pAuthIdentity->User != NULL)
    {
        Status = CopyClientString(
                        pAuthIdentity->User,
                        pAuthIdentity->UserLength,
                        DoUnicode,
                        &UserName);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle, Error from CopyClientString is 0x%lx\n", Status));
            goto cleanup;
        }
    }

    if (pAuthIdentity->Password != NULL)
    {
        Status = CopyClientString(
                        pAuthIdentity->Password,
                        pAuthIdentity->PasswordLength,
                        DoUnicode,
                        &Password);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle, Error from CopyClientString is 0x%lx\n", Status));
            goto cleanup;
        }
    }


    //
    // Extract the certificate thumbprint.
    //

    if(!CredIsMarshaledCredentialW(UserName.Buffer))
    {
        Status = SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
        goto cleanup;
    }

    if(!CredUnmarshalCredentialW(UserName.Buffer,
                                 &CredType,
                                 &pCertInfo))
    {
        Status = SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
        goto cleanup;
    }
    if(CredType != CertCredential)
    {
        Status = SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
        goto cleanup;
    }


    //
    // Look up the certificate in the MY certificate store.
    //

    fImpersonating = SslImpersonateClient();

    hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_W, 
                           X509_ASN_ENCODING, 0,
                           CERT_SYSTEM_STORE_CURRENT_USER |
                           CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
                           L"MY");
    if(!hStore)
    {
        SP_LOG_RESULT(GetLastError());
        Status = SEC_E_NO_CREDENTIALS; 
        goto cleanup;
    }

    HashBlob.cbData = sizeof(pCertInfo->rgbHashOfCert);
    HashBlob.pbData = pCertInfo->rgbHashOfCert;

    pCertContext = CertFindCertificateInStore(hStore, 
                                              X509_ASN_ENCODING, 
                                              0,
                                              CERT_FIND_HASH,
                                              &HashBlob,
                                              NULL);
    if(pCertContext == NULL)
    {
        DebugLog((DEB_ERROR, "Certificate designated by authority info was not found in certificate store (0x%x).\n", GetLastError()));
        Status = SEC_E_NO_CREDENTIALS;
        goto cleanup;
    }

    //
    // Build sub cred structure and attach it to the credential.
    //

    pSchannelCred->paSubCred = SPExternalAlloc(sizeof(LSA_SCHANNEL_SUB_CRED));
    if(pSchannelCred->paSubCred == NULL)
    {
        Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto cleanup;
    }

    pSchannelCred->paSubCred[0].pCert = pCertContext;

    pSchannelCred->paSubCred[0].pszPin = Password.Buffer;
    Password.Buffer = NULL;

    pSchannelCred->cSubCreds = 1;

    Status = STATUS_SUCCESS;

cleanup:

    if(pAuthIdentity)
    {
        SPExternalFree(pAuthIdentity);
    }

    if(UserName.Buffer)
    {
        LocalFree(UserName.Buffer);
    }
    if(Password.Buffer)
    {
        LocalFree(Password.Buffer);
    }

    if(pCertInfo)
    {
        CredFree(pCertInfo);
    }

    if(hStore)
    {
        CertCloseStore(hStore, 0);
    }

    if(fImpersonating)
    {
        RevertToSelf();
    }

    return Status;
}

//+---------------------------------------------------------------------------
//
//  Function:   SpCommonAcquireCredentialsHandle
//
//  Synopsis:   Common AcquireCredentialsHandle function.
//
//  Arguments:  [Type]             -- Type expected (Unified v. specific)
//              [pLogonID]         --
//              [pvAuthData]       --
//              [pvGetKeyFn]       --
//              [pvGetKeyArgument] --
//              [pdwHandle]        --
//              [ptsExpiry]        --
//
//  History:    10-06-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

SECURITY_STATUS
SpCommonAcquireCredentialsHandle(
    ULONG            Type,
    PLUID            pLogonID,
    PVOID            pvAuthData,
    PVOID            pvGetKeyFn,
    PVOID            pvGetKeyArgument,
    PLSA_SEC_HANDLE  pdwHandle,
    PTimeStamp       ptsExpiry)
{
    SP_STATUS           pctRet;
    PSPCredentialGroup  pCredGroup;
    LSA_SCHANNEL_CRED   SchannelCred;
    PSCH_CRED           pSchCred;
    SECURITY_STATUS     Status;
    SSL_CREDENTIAL_CERTIFICATE SslCert;
    DWORD               dwVersion;
    SECPKG_CALL_INFO    CallInfo;
    BOOL                fWow64Client = FALSE;

    TRACE_ENTER( SpCommonAcquireCredentialsHandle );

    if(!SchannelInit(FALSE))
    {
        return SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
    }

#ifdef _WIN64
    if(!LsaTable->GetCallInfo(&CallInfo))
    {
        Status = STATUS_INTERNAL_ERROR;
        return SP_LOG_RESULT(Status);
    }
    fWow64Client = (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT) != 0;
#endif

    __try
    {
        // Default to null credential
        memset(&SchannelCred, 0, sizeof(SchannelCred));
        SchannelCred.dwVersion = SCHANNEL_CRED_VERSION;


        if ( pvAuthData )
        {
            //
            // Read in the first few bytes of data so we can see what's there.
            //

            Status = LsaTable->CopyFromClientBuffer( NULL,
                                                sizeof( SSL_CREDENTIAL_CERTIFICATE ),
                                                &SslCert,
                                                pvAuthData );

            if ( !NT_SUCCESS( Status ) )
            {
                return( Status );
            }

            dwVersion = SslCert.cbPrivateKey;


            //
            // Ok, see what kind of blob we got:
            //

            switch(dwVersion)
            {
            case SEC_WINNT_AUTH_IDENTITY_VERSION:

                //
                // The application passed in a SEC_WINNT_AUTH_IDENTITY_EXW 
                // structure. 
                //

                Status = SpMapAuthIdentity(pvAuthData, &SchannelCred);

                if(!NT_SUCCESS(Status))
                {
                    return Status;
                }
                break;


            case SCH_CRED_V3:
            case SCHANNEL_CRED_VERSION:

                //
                // The application is using modern (version 3) credentials.
                //

#ifdef _WIN64
                if(fWow64Client)
                {
                    Status = SpWow64MapVersion3Certificate(pvAuthData, dwVersion, &SchannelCred);
                }
                else
#endif
                {
                    Status = SpMapVersion3Certificate(pvAuthData, dwVersion, &SchannelCred);
                }

                if(!NT_SUCCESS(Status))
                {
                    return Status;
                }

                // Selectively enable the unified protocol.
                SchannelCred.grbitEnabledProtocols = EnableUnifiedProtocol(
                                                            Type,
                                                            SchannelCred.grbitEnabledProtocols);
                break;


            case SCH_CRED_V1:
            case SCH_CRED_V2:

                //
                // Okay, it's a V1 or V2 style request.  Map it in, following
                // its scary chains.
                //

#ifdef _WIN64
                if(fWow64Client)
                {
                    Status = SpWow64MapVersion2Certificate(pvAuthData, &pSchCred);
                }
                else
#endif
                {
                    Status = SpMapVersion2Certificate(pvAuthData, &pSchCred);
                }

                if(!NT_SUCCESS(Status))
                {
                    return Status;
                }


                //
                // Convert this version 2 credential to a version 3 credential.
                //

                Status = UpdateCredentialFormat(pSchCred, &SchannelCred);

                SpFreeVersion2Certificate( pSchCred );

                if(!NT_SUCCESS(Status))
                {
                    return Status;
                }

                break;


            default:

                //
                // A really old-style credential.
                //

#ifdef _WIN64
                if(fWow64Client)
                {
                    Status = SpWow64MapProtoCredential((SSLWOW64_CREDENTIAL_CERTIFICATE *)&SslCert, &pSchCred);
                }
                else
#endif
                {
                    Status = SpMapProtoCredential(&SslCert, &pSchCred);
                }

                if(!NT_SUCCESS(Status))
                {
                    return Status;
                }


                //
                // Convert this version 2 credential to a version 3 credential.
                //

                Status = UpdateCredentialFormat(pSchCred, &SchannelCred);

                SpFreeVersion2Certificate( pSchCred );

                if(!NT_SUCCESS(Status))
                {
                    return Status;
                }

                break;
            }

            // Set the legacy flags if this is an old-style credential.
            if(dwVersion != SCHANNEL_CRED_VERSION && 
               dwVersion != SEC_WINNT_AUTH_IDENTITY_VERSION)
            {
                SchannelCred.dwFlags |= SCH_CRED_MANUAL_CRED_VALIDATION;
                SchannelCred.dwFlags |= SCH_CRED_NO_DEFAULT_CREDS;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
    }

    if(pvAuthData == NULL && (Type & SP_PROT_SERVERS))
    {
        //
        // A server is creating credential without specifying any
        // authentication data, so attempt to acquire a default
        // machine credential.
        //

        Status = FindDefaultMachineCred(&pCredGroup, Type);
        if(!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "Unable to create default server credential (0x%x)\n", Status));
            return Status;
        }

        *pdwHandle = (LSA_SEC_HANDLE) pCredGroup;

        return SEC_E_OK;
    }


    pctRet = SPCreateCredential( &pCredGroup,
                                 Type,
                                 &SchannelCred );

    SpFreeVersion3Certificate( &SchannelCred );

    if (PCT_ERR_OK == pctRet)
    {
        *pdwHandle = (LSA_SEC_HANDLE) pCredGroup;

        return SEC_E_OK;
    }

    return PctTranslateError(pctRet);
}


SECURITY_STATUS
SEC_ENTRY
SpUniAcquireCredentialsHandle(
            PSECURITY_STRING    psPrincipal,
            ULONG               fCredentials,
            PLUID               pLogonID,
            PVOID               pvAuthData,
            PVOID               pvGetKeyFn,
            PVOID               pvGetKeyArgument,
            PLSA_SEC_HANDLE     pdwHandle,
            PTimeStamp          ptsExpiry)
{
    DWORD Type;

    DebugLog((DEB_TRACE, "SpUniAcquireCredentialsHandle(0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x)\n",
        psPrincipal, fCredentials, pLogonID, pvAuthData,
        pvGetKeyFn, pvGetKeyArgument, pdwHandle, ptsExpiry));


    if ( fCredentials & SECPKG_CRED_INBOUND )
    {
        Type = SP_PROT_UNI_SERVER ;
    }
    else if ( fCredentials & SECPKG_CRED_OUTBOUND )
    {
        Type = SP_PROT_UNI_CLIENT ;
    }
    else
    {
        return SP_LOG_RESULT(SEC_E_NO_CREDENTIALS);
    }
    return( SpCommonAcquireCredentialsHandle(   Type,
                                                pLogonID,
                                                pvAuthData,
                                                pvGetKeyFn,
                                                pvGetKeyArgument,
                                                pdwHandle,
                                                ptsExpiry ) );
}


SECURITY_STATUS
SEC_ENTRY
SpQueryCredentialsAttributes(
    LSA_SEC_HANDLE dwCredHandle,
    ULONG   dwAttribute,
    PVOID   Buffer)
{
    PSPCredentialGroup  pCred;
    ULONG Size;
    PVOID pvClient = NULL;
    DWORD cbClient;
    SECURITY_STATUS Status;
    SECPKG_CALL_INFO CallInfo;
    BOOL fWow64Client = FALSE;

    typedef struct _SecPkgCred_SupportedAlgsWow64
    {
        DWORD           cSupportedAlgs;
        SSLWOW64_PVOID  palgSupportedAlgs;
    } SecPkgCred_SupportedAlgsWow64, *PSecPkgCred_SupportedAlgsWow64;

    union {
        SecPkgCred_SupportedAlgs        SupportedAlgs;
        SecPkgCred_SupportedAlgsWow64   SupportedAlgsWow64;
        SecPkgCred_CipherStrengths      CipherStrengths;
        SecPkgCred_SupportedProtocols   SupportedProtocols;
    } LocalBuffer;

    pCred = (PSPCredentialGroup)dwCredHandle;

    if(pCred == NULL)
    {
        return(SEC_E_INVALID_HANDLE);
    }


#ifdef _WIN64
    if(!LsaTable->GetCallInfo(&CallInfo))
    {
        Status = STATUS_INTERNAL_ERROR;
        return SP_LOG_RESULT(Status);
    }
    fWow64Client = (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT) != 0;
#endif

    __try
    {
        switch (dwAttribute)
        {
            case SECPKG_ATTR_SUPPORTED_ALGS:
                DebugLog((DEB_TRACE, "QueryCredentialsAttributes(SECPKG_ATTR_SUPPORTED_ALGS)\n"));
                if(fWow64Client)
                {
                    Size = sizeof(SecPkgCred_SupportedAlgsWow64);
                }
                else
                {
                    Size = sizeof(SecPkgCred_SupportedAlgs);
                }
                break;

            case SECPKG_ATTR_CIPHER_STRENGTHS:
                DebugLog((DEB_TRACE, "QueryCredentialsAttributes(SECPKG_ATTR_CIPHER_STRENGTHS)\n"));
                Size = sizeof(SecPkgCred_CipherStrengths);
                break;

            case SECPKG_ATTR_SUPPORTED_PROTOCOLS:
                DebugLog((DEB_TRACE, "QueryCredentialsAttributes(SECPKG_ATTR_SUPPORTED_PROTOCOLS)\n"));
                Size = sizeof(SecPkgCred_SupportedProtocols);
                break;

            default:
                DebugLog((DEB_WARN, "QueryCredentialsAttributes(unsupported function %d)\n", dwAttribute));

                return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
        }


        // Copy structure from client memory, just in case any of this
        // stuff is in/out.
        Status = LsaTable->CopyFromClientBuffer( NULL,
                                                 Size,
                                                 &LocalBuffer,
                                                 Buffer );
        if(FAILED(Status))
        {
            return Status;
        }


        switch (dwAttribute)
        {
            case SECPKG_ATTR_SUPPORTED_ALGS:
            {
                cbClient = pCred->cSupportedAlgs * sizeof(ALG_ID);

                // Allocate client memory for algorithm list.
                Status = LsaTable->AllocateClientBuffer(NULL, cbClient, &pvClient);
                if(FAILED(Status))
                {
                    return Status;
                }

                if(fWow64Client)
                {
                    LocalBuffer.SupportedAlgsWow64.cSupportedAlgs = pCred->cSupportedAlgs;
                    LocalBuffer.SupportedAlgsWow64.palgSupportedAlgs = PtrToUlong(pvClient);
                }
                else
                {
                    LocalBuffer.SupportedAlgs.cSupportedAlgs = pCred->cSupportedAlgs;
                    LocalBuffer.SupportedAlgs.palgSupportedAlgs = pvClient;
                }

                // Copy algorithm list to client memory.
                Status = LsaTable->CopyToClientBuffer(
                                        NULL,
                                        cbClient,
                                        pvClient,
                                        pCred->palgSupportedAlgs);
                if(FAILED(Status))
                {
                    LsaTable->FreeClientBuffer(NULL, pvClient);
                    return Status;
                }
                break;
            }

            case SECPKG_ATTR_CIPHER_STRENGTHS:
                GetDisplayCipherSizes(pCred,
                                      &LocalBuffer.CipherStrengths.dwMinimumCipherStrength,
                                      &LocalBuffer.CipherStrengths.dwMaximumCipherStrength);
                break;

            case SECPKG_ATTR_SUPPORTED_PROTOCOLS:
                LocalBuffer.SupportedProtocols.grbitProtocol = pCred->grbitEnabledProtocols;
                break;

        }

        // Copy structure back to client memory.
        Status = LsaTable->CopyToClientBuffer( NULL,
                                               Size,
                                               Buffer,
                                               &LocalBuffer );
        if(FAILED(Status))
        {
            if(pvClient) LsaTable->FreeClientBuffer(NULL, pvClient);
            return Status;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
    }

    return SEC_E_OK;
}


SECURITY_STATUS
SEC_ENTRY
SpFreeCredentialsHandle(LSA_SEC_HANDLE dwHandle)
{
    PSPCredentialGroup  pCred;
    SECPKG_CALL_INFO CallInfo;
    DWORD Status;

    DebugLog((DEB_TRACE, "SpFreeCredentialsHandle(0x%x)\n", dwHandle));

    pCred = (PSPCredentialGroup) dwHandle ;

    __try
    {
        if (pCred)
        {
            // Delete all mention of this credential from the cache.
            SPCachePurgeCredential(pCred);

            // Was this call made from the LSA cleanup code? In other
            // words, did the application terminate without cleaning up
            // properly? If so, then throw away all unreferenced zombies
            // associated with that process.
            if(LsaTable->GetCallInfo(&CallInfo))
            {
                if(CallInfo.Attributes & SECPKG_CALL_CLEANUP)
                {
                    SPCachePurgeProcessId(pCred->ProcessId);
                }
            }

            pCred->dwFlags |= CRED_FLAG_DELETED;

            SPDereferenceCredential(pCred);

            return(SEC_E_OK);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
    }

    return SP_LOG_RESULT(SEC_E_INVALID_HANDLE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\lsa\ctxtattr.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ctxtattr.c
//
//  Contents:   QueryContextAttribute and related functions.
//
//  Classes:
//
//  Functions:
//
//  History:    09-30-97   jbanes   Created
//
//----------------------------------------------------------------------------

#include "sslp.h"
#include <ssl2msg.h>
#include <ssl3msg.h>
#include <pct1msg.h>
#include <tls1key.h>
#include <mapper.h>
#include <lsasecpk.h>

typedef struct {
    DWORD dwProtoId;
    LPCTSTR szProto;
    DWORD dwMajor;
    DWORD dwMinor;
} PROTO_ID;

const PROTO_ID rgProts[] = {
    { SP_PROT_SSL2_CLIENT, TEXT("SSL"), 2, 0 },
    { SP_PROT_SSL2_SERVER, TEXT("SSL"), 2, 0 },
    { SP_PROT_PCT1_CLIENT, TEXT("PCT"), 1, 0 },
    { SP_PROT_PCT1_SERVER, TEXT("PCT"), 1, 0 },
    { SP_PROT_SSL3_CLIENT, TEXT("SSL"), 3, 0 },
    { SP_PROT_SSL3_SERVER, TEXT("SSL"), 3, 0 },
    { SP_PROT_TLS1_CLIENT, TEXT("TLS"), 1, 0 },
    { SP_PROT_TLS1_SERVER, TEXT("TLS"), 1, 0 }
};

//+-------------------------------------------------------------------------
//
//  Function:   SpQueryAccessToken
//
//  Synopsis:   Retrieves the SECPKG_ATTR_ACCESS_TOKEN context attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer returned contains the following structure:
//
//              typedef struct _SecPkgContext_AccessToken
//              {
//                  void SEC_FAR * AccessToken;
//              } SecPkgContext_AccessToken, SEC_FAR * PSecPkgContext_AccessToken;
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SpQueryAccessToken(
    PSPContext pContext,
    PSecPkgContext_AccessToken pAccessToken)
{
    PSessCacheItem pZombie;

    DebugLog((DEB_TRACE, "QueryContextAttributes(SECPKG_ATTR_ACCESS_TOKEN)\n"));

    pZombie  = pContext->RipeZombie;

    if(pZombie == NULL || 
       pZombie->hLocator == 0)
    {
        if(pZombie->LocatorStatus)
        {
            return(SP_LOG_RESULT(pZombie->LocatorStatus));
        }
        else
        {
            return(SP_LOG_RESULT(SEC_E_NO_IMPERSONATION));
        }
    }

    pAccessToken->AccessToken = (VOID *)pZombie->hLocator;

    return SEC_E_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:   SpQueryAuthority
//
//  Synopsis:   Retrieves the SECPKG_ATTR_AUTHORITY context attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer returned contains the following structure:
//
//              typedef struct _SecPkgContext_AuthorityW
//              {
//                  SEC_WCHAR SEC_FAR * sAuthorityName;
//              } SecPkgContext_AuthorityW, * PSecPkgContext_AuthorityW;
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SpQueryAuthority(
    LSA_SEC_HANDLE ContextHandle,
    PVOID Buffer)
{
    SecPkgContext_Authority Authority;
    DWORD           Size;
    PSPContext      pContext;
    SECURITY_STATUS Status;
    PVOID           pvClient = NULL;

    CERT_CONTEXT *  pCert;
    DWORD           cchIssuer;
    DWORD           cbIssuer;

    DebugLog((DEB_TRACE, "QueryContextAttributes(SECPKG_ATTR_AUTHORITY)\n"));

    pContext = (PSPContext)ContextHandle;
    Size     = sizeof( SecPkgContext_Authority );

    //
    // Obtain data from Schannel.
    //

    pCert = pContext->RipeZombie->pRemoteCert;
    if(NULL == pCert)
    {
        return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
    }

    if(pCert->pCertInfo->Issuer.cbData == 0 ||
       pCert->pCertInfo->Issuer.pbData == NULL)
    {
        return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
    }

    if(0 >= (cchIssuer = CertNameToStr(pCert->dwCertEncodingType,
                                       &pCert->pCertInfo->Issuer,
                                       CERT_X500_NAME_STR | CERT_NAME_STR_NO_PLUS_FLAG,
                                       NULL,
                                       0)))
    {
        return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
    }
    cbIssuer = (cchIssuer + 1) * sizeof(TCHAR);

    Authority.sAuthorityName = SPExternalAlloc(cbIssuer);
    if(Authority.sAuthorityName == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }

    if(0 >= CertNameToStr(pCert->dwCertEncodingType,
                          &pCert->pCertInfo->Issuer,
                          CERT_X500_NAME_STR | CERT_NAME_STR_NO_PLUS_FLAG,
                          Authority.sAuthorityName,
                          cchIssuer))
    {
        SPExternalFree(Authority.sAuthorityName);
        return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
    }


    //
    // Copy buffers to client memory.
    //

    Status = LsaTable->AllocateClientBuffer(
                            NULL,
                            cbIssuer,
                            &pvClient);
    if(FAILED(Status))
    {
        SPExternalFree(Authority.sAuthorityName);
        return SP_LOG_RESULT(Status);
    }

    Status = LsaTable->CopyToClientBuffer(
                            NULL,
                            cbIssuer,
                            pvClient,
                            Authority.sAuthorityName);
    if(FAILED(Status))
    {
        SPExternalFree(Authority.sAuthorityName);
        LsaTable->FreeClientBuffer(NULL, pvClient);
        return SP_LOG_RESULT(Status);
    }

    SPExternalFree(Authority.sAuthorityName);

    Authority.sAuthorityName = pvClient;


    //
    // Copy structure back to client memory.
    //

    Status = LsaTable->CopyToClientBuffer( NULL,
                                           Size,
                                           Buffer,
                                           &Authority );
    if(FAILED(Status))
    {
        LsaTable->FreeClientBuffer(NULL, pvClient);
        return SP_LOG_RESULT(Status);
    }

    return SEC_E_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:   SpQueryConnectionInfo
//
//  Synopsis:   Retrieves the SECPKG_ATTR_CONNECTION_INFO context attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer returned contains the following structure:
//
//              typedef struct _SecPkgContext_ConnectionInfo
//              {
//                  DWORD    dwProtocol;
//                  ALG_ID   aiCipher;
//                  DWORD    dwCipherStrength;
//                  ALG_ID   aiHash;
//                  DWORD    dwHashStrength;
//                  ALG_ID   aiExch;
//                  DWORD    dwExchStrength;
//              } SecPkgContext_ConnectionInfo;
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SpQueryConnectionInfo(
    PSPContext pContext,
    SecPkgContext_ConnectionInfo *pConnectionInfo)
{
    DebugLog((DEB_TRACE, "QueryContextAttributes(SECPKG_ATTR_CONNECTION_INFO)\n"));

    if (NULL == pContext->pCipherInfo ||
        NULL == pContext->pHashInfo   ||
        NULL == pContext->pKeyExchInfo)
    {
        return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
    }

    ZeroMemory(pConnectionInfo, sizeof(SecPkgContext_ConnectionInfo));

    pConnectionInfo->dwProtocol       = pContext->RipeZombie->fProtocol;
    if(pContext->pCipherInfo->aiCipher != CALG_NULLCIPHER)
    {
        pConnectionInfo->aiCipher         = pContext->pCipherInfo->aiCipher;
        pConnectionInfo->dwCipherStrength = pContext->pCipherInfo->dwStrength;
    }
    pConnectionInfo->aiHash           = pContext->pHashInfo->aiHash;
    pConnectionInfo->dwHashStrength   = pContext->pHashInfo->cbCheckSum * 8;
    pConnectionInfo->aiExch           = pContext->pKeyExchInfo->aiExch;
    pConnectionInfo->dwExchStrength   = pContext->RipeZombie->dwExchStrength;

    return SEC_E_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:   SpQueryIssuerList
//
//  Synopsis:   Retrieves the SECPKG_ATTR_ISSUER_LIST context attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer returned contains the following structure:
//
//              typedef struct _SecPkgContext_IssuerListInfo
//              {
//                  DWORD   cbIssuerList;
//                  PBYTE   pIssuerList;
//              } SecPkgContext_IssuerListInfo;
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SpQueryIssuerList(
    LSA_SEC_HANDLE ContextHandle,
    PVOID Buffer)
{
    SecPkgContext_IssuerListInfo IssuerList;
    DWORD           Size;
    PSPContext      pContext;
    SECURITY_STATUS Status;
    PVOID           pvClient = NULL;

    DebugLog((DEB_TRACE, "QueryContextAttributes(SECPKG_ATTR_ISSUER_LIST)\n"));

    pContext = (PSPContext)ContextHandle;
    Size     = sizeof( SecPkgContext_IssuerListInfo );

    //
    // Obtain data from Schannel.
    //

    // The issuer list is returned in the SSL3 wire format, which
    // consists of a bunch of issuer names, each prepended
    // with a two byte size (in big endian). Additionally, the list
    // is also prepended with a two byte list size (also in big
    // endian).
    IssuerList.cbIssuerList = pContext->cbIssuerList;
    IssuerList.pIssuerList  = pContext->pbIssuerList;


    //
    // Copy buffers to client memory.
    //

    if(IssuerList.cbIssuerList && IssuerList.pIssuerList)
    {
        Status = LsaTable->AllocateClientBuffer(
                                NULL,
                                IssuerList.cbIssuerList,
                                &pvClient);
        if(FAILED(Status))
        {
            return SP_LOG_RESULT(Status);
        }

        Status = LsaTable->CopyToClientBuffer(
                                NULL,
                                IssuerList.cbIssuerList,
                                pvClient,
                                IssuerList.pIssuerList);
        if(FAILED(Status))
        {
            LsaTable->FreeClientBuffer(NULL, pvClient);
            return SP_LOG_RESULT(Status);
        }

        IssuerList.pIssuerList = pvClient;
    }


    //
    // Copy structure back to client memory.
    //

    Status = LsaTable->CopyToClientBuffer( NULL,
                                           Size,
                                           Buffer,
                                           &IssuerList );
    if(FAILED(Status))
    {
        LsaTable->FreeClientBuffer(NULL, pvClient);
        return SP_LOG_RESULT(Status);
    }

    return SEC_E_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:   SpQueryIssuerListEx
//
//  Synopsis:   Retrieves the SECPKG_ATTR_ISSUER_LIST_EX context attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer returned contains the following structure:
//
//              typedef struct _SecPkgContext_IssuerListInfoEx
//              {
//                  PCERT_NAME_BLOB   	aIssuers;
//                  DWORD           	cIssuers;
//              } SecPkgContext_IssuerListInfoEx;
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SpQueryIssuerListEx(
    LSA_SEC_HANDLE ContextHandle,
    PVOID Buffer)
{
    SecPkgContext_IssuerListInfoEx IssuerListEx;
    DWORD           Size;
    PSPContext      pContext;
    SECURITY_STATUS Status;
    PVOID           pvClient = NULL;
    DWORD           cIssuers;

    PBYTE           pbIssuerList;
    DWORD           cbIssuerList;
    PBYTE           pbIssuer;
    DWORD           cbIssuer;
    PBYTE           pbClientIssuer;
    PCERT_NAME_BLOB paIssuerBlobs;
    DWORD           cbIssuerBlobs;
    DWORD           i;

    DebugLog((DEB_TRACE, "QueryContextAttributes(SECPKG_ATTR_ISSUER_LIST_EX)\n"));

    pContext = (PSPContext)ContextHandle;
    Size     = sizeof( SecPkgContext_IssuerListInfoEx );

    //
    // Obtain data from Schannel.
    //

    IssuerListEx.cIssuers = 0;
    IssuerListEx.aIssuers = NULL;

    if(pContext->pbIssuerList && pContext->cbIssuerList > 2)
    {
        pbIssuerList = pContext->pbIssuerList + 2;
        cbIssuerList = pContext->cbIssuerList - 2;

        // Count issuers.
        cIssuers = 0;
        pbIssuer = pbIssuerList;
        while(pbIssuer + 1 < pbIssuerList + cbIssuerList)
        {
            cbIssuer = COMBINEBYTES(pbIssuer[0], pbIssuer[1]);
            pbIssuer += 2 + cbIssuer;
            cIssuers++;
        }

        // Allocate memory for list of blobs.
        cbIssuerBlobs = cIssuers * sizeof(CERT_NAME_BLOB);
        paIssuerBlobs = SPExternalAlloc(cbIssuerBlobs);
        if(paIssuerBlobs == NULL)
        {
            return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        }

        // Allocate memory for issuer list.
        Status = LsaTable->AllocateClientBuffer(
                                NULL,
                                cbIssuerBlobs + cbIssuerList,
                                &pvClient);
        if(FAILED(Status))
        {
            SPExternalFree(paIssuerBlobs);
            return SP_LOG_RESULT(Status);
        }

        // Copy the raw issuer list into client memory.
        Status = LsaTable->CopyToClientBuffer(
                                NULL,
                                cbIssuerList,
                                (PBYTE)pvClient + cbIssuerBlobs,
                                pbIssuerList );
        if(FAILED(Status))
        {
            SPExternalFree(paIssuerBlobs);
            LsaTable->FreeClientBuffer(NULL, pvClient);
            return SP_LOG_RESULT(Status);
        }

        // Build the issuer blob list.
        pbIssuer       = pbIssuerList;
        pbClientIssuer = (PBYTE)pvClient + cbIssuerBlobs;

        for(i = 0; i < cIssuers; i++)
        {
            paIssuerBlobs[i].pbData = pbClientIssuer + 2;
            paIssuerBlobs[i].cbData = COMBINEBYTES(pbIssuer[0], pbIssuer[1]);

            pbIssuer       += 2 + paIssuerBlobs[i].cbData;
            pbClientIssuer += 2 + paIssuerBlobs[i].cbData;
        }

        // Copy the blob list into client memory.
        Status = LsaTable->CopyToClientBuffer(
                                NULL,
                                cbIssuerBlobs,
                                pvClient,
                                paIssuerBlobs );
        if(FAILED(Status))
        {
            SPExternalFree(paIssuerBlobs);
            LsaTable->FreeClientBuffer(NULL, pvClient);
            return SP_LOG_RESULT(Status);
        }

        SPExternalFree(paIssuerBlobs);

        IssuerListEx.cIssuers = cIssuers;
        IssuerListEx.aIssuers = pvClient;
    }


    //
    // Copy structure back to client memory.
    //

    Status = LsaTable->CopyToClientBuffer( NULL,
                                           Size,
                                           Buffer,
                                           &IssuerListEx );
    if(FAILED(Status))
    {
        if(pvClient) LsaTable->FreeClientBuffer(NULL, pvClient);
        return SP_LOG_RESULT(Status);
    }

    return SEC_E_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:   SpQueryKeyInfo
//
//  Synopsis:   Retrieves the SECPKG_ATTR_KEY_INFO context attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer returned contains the following structure:
//
//              typedef struct _SecPkgContext_KeyInfoW
//              {
//                  SEC_WCHAR SEC_FAR * sSignatureAlgorithmName;
//                  SEC_WCHAR SEC_FAR * sEncryptAlgorithmName;
//                  unsigned long       KeySize;
//                  unsigned long       SignatureAlgorithm;
//                  unsigned long       EncryptAlgorithm;
//              } SecPkgContext_KeyInfoW;
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SpQueryKeyInfo(
    PSPContext pContext,
    PVOID Buffer)
{
    SecPkgContext_KeyInfo *pKeyInfo;
    DWORD cchSigName;
    DWORD cbSigName;
    DWORD cchCipherName;
    DWORD cbCipherName;

    UNICODE_STRING UniString;
    ANSI_STRING AnsiString;

    DWORD Status;

    DebugLog((DEB_TRACE, "QueryContextAttributes(SECPKG_ATTR_KEY_INFO)\n"));

    if (NULL == pContext->pCipherInfo ||
        NULL == pContext->pHashInfo   ||
        NULL == pContext->pKeyExchInfo)
    {
        return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
    }
    if (NULL == pContext->pCipherInfo->szName)
    {
        return SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
    }


    pKeyInfo = (SecPkgContext_KeyInfo *)Buffer;

    ZeroMemory(pKeyInfo, sizeof(*pKeyInfo));

    pKeyInfo->KeySize            = pContext->pCipherInfo->dwStrength;
    pKeyInfo->EncryptAlgorithm   = pContext->pCipherInfo->aiCipher;
    pKeyInfo->SignatureAlgorithm = 0;


    cchSigName = strlen(pContext->pKeyExchInfo->szName);
    cbSigName  = (cchSigName + 1) * sizeof(WCHAR);
    pKeyInfo->sSignatureAlgorithmName = LocalAlloc(LPTR, cbSigName);
    if(pKeyInfo->sSignatureAlgorithmName == NULL)
    {
        Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto done;
    }

    RtlInitAnsiString(&AnsiString,
                      pContext->pKeyExchInfo->szName);

    UniString.Length = 0;
    UniString.MaximumLength = (USHORT)cbSigName;
    UniString.Buffer = pKeyInfo->sSignatureAlgorithmName;

    RtlAnsiStringToUnicodeString(&UniString,
                                 &AnsiString,
                                 FALSE);
    

    cchCipherName = strlen(pContext->pCipherInfo->szName);
    cbCipherName  = (cchCipherName + 1) * sizeof(WCHAR);
    pKeyInfo->sEncryptAlgorithmName = LocalAlloc(LPTR, cbCipherName);
    if(pKeyInfo->sEncryptAlgorithmName == NULL)
    {
        Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto done;
    }

    RtlInitAnsiString(&AnsiString,
                      pContext->pCipherInfo->szName);

    UniString.Length = 0;
    UniString.MaximumLength = (USHORT)cbCipherName;
    UniString.Buffer = pKeyInfo->sEncryptAlgorithmName;

    RtlAnsiStringToUnicodeString(&UniString,
                                 &AnsiString,
                                 FALSE);

    Status = PCT_ERR_OK;

done:

    if(Status != PCT_ERR_OK)
    {
        if(pKeyInfo->sSignatureAlgorithmName)
        {
            LocalFree(pKeyInfo->sSignatureAlgorithmName);
            pKeyInfo->sSignatureAlgorithmName = NULL;
        }
        if(pKeyInfo->sEncryptAlgorithmName)
        {
            LocalFree(pKeyInfo->sEncryptAlgorithmName);
            pKeyInfo->sEncryptAlgorithmName = NULL;
        }
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   SpQueryLifespan
//
//  Synopsis:   Retrieves the SECPKG_ATTR_LIFESPAN context attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer returned contains the following structure:
//
//              typedef struct _SecPkgContext_Lifespan
//              {
//                  TimeStamp tsStart;
//                  TimeStamp tsExpiry;
//              } SecPkgContext_Lifespan;
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SpQueryLifespan(
    PSPContext pContext,
    SecPkgContext_Lifespan *pLifespan)
{
    PCCERT_CONTEXT pCertContext;
    NTSTATUS Status;

    DebugLog((DEB_TRACE, "QueryContextAttributes(SECPKG_ATTR_LIFESPAN)\n"));

    if(pContext->RipeZombie->pbServerCertificate)
    {
        Status = DeserializeCertContext(&pCertContext,
                                        pContext->RipeZombie->pbServerCertificate,
                                        pContext->RipeZombie->cbServerCertificate);
        if(Status != PCT_ERR_OK)
        {
            SP_LOG_RESULT(Status);
            return SEC_E_INSUFFICIENT_MEMORY;
        }

        pLifespan->tsStart.QuadPart  = *((LONGLONG *)&pCertContext->pCertInfo->NotBefore);
        pLifespan->tsExpiry.QuadPart = *((LONGLONG *)&pCertContext->pCertInfo->NotAfter);

        CertFreeCertificateContext(pCertContext);
    }
    else
    {
        pLifespan->tsStart.QuadPart  = 0;
        pLifespan->tsExpiry.QuadPart = MAXTIMEQUADPART;
    }

    return SEC_E_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:   SpQueryLocalCertContext
//
//  Synopsis:   Retrieves the SECPKG_ATTR_LOCAL_CERT_CONTEXT 
//              context attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer returned contains a pointer to a CERT_CONTEXT
//              structure.
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SpQueryLocalCertContext(
    LSA_SEC_HANDLE ContextHandle,
    PVOID Buffer)
{
    DWORD           Size;
    PSPContext      pContext;
    SECURITY_STATUS Status;
    PVOID           pvClient = NULL;

    PCCERT_CONTEXT  pCertContext = NULL;
    SecBuffer       Input;
    SecBuffer       Output;

    DebugLog((DEB_TRACE, "QueryContextAttributes(SECPKG_ATTR_LOCAL_CERT_CONTEXT)\n"));

    pContext = (PSPContext)ContextHandle;
    Size     = sizeof( PCCERT_CONTEXT );

    //
    // Obtain data from Schannel.
    //

    if(pContext->dwProtocol & SP_PROT_CLIENTS)
    {
        pCertContext = pContext->RipeZombie->pClientCert;
    }
    else
    {
        pCertContext = pContext->RipeZombie->pActiveServerCred->pCert;
    }


    //
    // Copy buffers to client memory.
    //

    if(pCertContext)
    {
        // Serialize the certificate context, as well as the associated
        // certificate store.
        Status = SerializeCertContext(pCertContext,
                                      NULL,
                                      &Input.cbBuffer);
        if(FAILED(Status))
        {
            return SP_LOG_RESULT(Status);
        }
        Input.pvBuffer = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, Input.cbBuffer);
        if(Input.pvBuffer == NULL)
        {
            return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        }
        Status = SerializeCertContext(pCertContext,
                                      Input.pvBuffer,
                                      &Input.cbBuffer);
        if(FAILED(Status))
        {
            LocalFree(Input.pvBuffer);
            return SP_LOG_RESULT(Status);
        }

        // Call back into the user process in order to replicate the
        // certificate context and store over there.
        Input.BufferType = SECBUFFER_DATA;

        Status = PerformApplicationCallback(SCH_DOWNLOAD_CERT_CALLBACK,
                                            0,
                                            0,
                                            &Input,
                                            &Output,
                                            TRUE);
        LocalFree(Input.pvBuffer);
        if(FAILED(Status))
        {
            return SP_LOG_RESULT(Status);
        }

        pCertContext = *(PCCERT_CONTEXT *)(Output.pvBuffer);
        SPExternalFree(Output.pvBuffer);
    }

    //
    // Copy structure back to client memory.
    //

    if(pCertContext)
    {
        Status = LsaTable->CopyToClientBuffer( NULL,
                                               Size,
                                               Buffer,
                                               (PVOID)&pCertContext );
        if(FAILED(Status))
        {
            return SP_LOG_RESULT(Status);
        }
    }
    else
    {
        return SP_LOG_RESULT(SEC_E_NO_CREDENTIALS);
    }

    return SEC_E_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   SpQueryRemoteCertContext
//
//  Synopsis:   Retrieves the SECPKG_ATTR_REMOTE_CERT_CONTEXT 
//              context attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer returned contains a pointer to a CERT_CONTEXT
//              structure.
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SpQueryRemoteCertContext(
    PSPContext pContext,
    PVOID Buffer)
{
    PCCERT_CONTEXT pCertContext;
    SP_STATUS pctRet;

    DebugLog((DEB_TRACE, "QueryContextAttributes(SECPKG_ATTR_REMOTE_CERT_CONTEXT)\n"));

    if(pContext->RipeZombie->pbServerCertificate)
    {
        pctRet = DeserializeCertContext(&pCertContext,
                                        pContext->RipeZombie->pbServerCertificate,
                                        pContext->RipeZombie->cbServerCertificate);
        if(pctRet != PCT_ERR_OK)
        {
            return SP_LOG_RESULT(pctRet);
        }
        
        *(PCCERT_CONTEXT *)Buffer = pCertContext;

        return SEC_E_OK;
    }
    else
    {
        return SP_LOG_RESULT(SEC_E_NO_CREDENTIALS);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   SpQueryLocalCred
//
//  Synopsis:   Retrieves the SECPKG_ATTR_LOCAL_CRED context attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer returned contains the following structure:
//
//              typedef struct _SecPkgContext_LocalCredentialInfo
//              {
//                  DWORD   cbCertificateChain;
//                  PBYTE   pbCertificateChain;
//                  DWORD   cCertificates;
//                  DWORD   fFlags;
//                  DWORD   dwBits;
//              } SecPkgContext_LocalCredentialInfo;
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SpQueryLocalCred(
    LSA_SEC_HANDLE ContextHandle,
    PVOID Buffer)
{
    SecPkgContext_LocalCredentialInfo CredInfo;
    DWORD           Size;
    PSPContext      pContext;
    SECURITY_STATUS Status;
    PVOID           pvClient = NULL;
    SP_STATUS       pctRet;

    PCCERT_CONTEXT  pCert = NULL;
    PUBLICKEY *     pKey  = NULL;
    DWORD           fVerified = FALSE;
    RSAPUBKEY *     pk = NULL;
    PSPCredential   pCred;

    DebugLog((DEB_TRACE, "QueryContextAttributes(SECPKG_ATTR_LOCAL_CRED)\n"));

    pContext = (PSPContext)ContextHandle;
    Size     = sizeof( SecPkgContext_LocalCredentialInfo );

    //
    // Obtain data from Schannel.
    //

    ZeroMemory(&CredInfo, Size);

    if(pContext->dwProtocol & SP_PROT_CLIENTS)
    {
        pCred = pContext->pActiveClientCred;
    }
    else
    {
        pCred = pContext->RipeZombie->pActiveServerCred;
    }
    if(pCred)
    {
        pCert = pCred->pCert;
        pKey  = pCred->pPublicKey;
    }

    if(pCert)
    {
        CredInfo.fFlags |= LCRED_CRED_EXISTS;

        CredInfo.pbCertificateChain = pCert->pbCertEncoded;
        CredInfo.cbCertificateChain = pCert->cbCertEncoded;
        CredInfo.cCertificates = 1;

        // Compute number of bits in the certificate's public key.
        CredInfo.dwBits = 0;
        pk = (RSAPUBKEY *)((pKey->pPublic) + 1);
        if(pk)
        {
            CredInfo.dwBits = pk->bitlen;
        }
    }

    //
    // Copy buffers to client memory.
    //

    if(CredInfo.pbCertificateChain)
    {
        Status = LsaTable->AllocateClientBuffer(
                                NULL,
                                CredInfo.cbCertificateChain,
                                &pvClient);
        if(FAILED(Status))
        {
            return SP_LOG_RESULT(Status);
        }

        Status = LsaTable->CopyToClientBuffer(
                                NULL,
                                CredInfo.cbCertificateChain,
                                pvClient,
                                CredInfo.pbCertificateChain);
        if(FAILED(Status))
        {
            LsaTable->FreeClientBuffer(NULL, pvClient);
            return SP_LOG_RESULT(Status);
        }

        CredInfo.pbCertificateChain = pvClient;
    }

    //
    // Copy structure back to client memory.
    //

    Status = LsaTable->CopyToClientBuffer( NULL,
                                           Size,
                                           Buffer,
                                           &CredInfo );
    if(FAILED(Status))
    {
        LsaTable->FreeClientBuffer(NULL, pvClient);
        return SP_LOG_RESULT(Status);
    }

    return SEC_E_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   SpQueryRemoteCred
//
//  Synopsis:   Retrieves the SECPKG_ATTR_REMOTE_CRED context attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer returned contains the following structure:
//
//              typedef struct _SecPkgContext_LocalCredentialInfo
//              {
//                  DWORD   cbCertificateChain;
//                  PBYTE   pbCertificateChain;
//                  DWORD   cCertificates;
//                  DWORD   fFlags;
//                  DWORD   dwBits;
//              } SecPkgContext_LocalCredentialInfo;
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SpQueryRemoteCred(
    PSPContext pContext,
    PVOID Buffer)
{
    SecPkgContext_LocalCredentialInfo *pCredInfo;
    PCCERT_CONTEXT  pCertContext = NULL;
    PUBLICKEY *     pKey  = NULL;
    RSAPUBKEY *     pk    = NULL;
    SP_STATUS       pctRet;
    PBYTE           pbCert;
    
    DebugLog((DEB_TRACE, "QueryContextAttributes(SECPKG_ATTR_REMOTE_CRED)\n"));

    pCredInfo = (SecPkgContext_LocalCredentialInfo *)Buffer;

    ZeroMemory(pCredInfo, sizeof(*pCredInfo));

    if(pContext->RipeZombie->pbServerCertificate)
    {
        pctRet = DeserializeCertContext(&pCertContext,
                                        pContext->RipeZombie->pbServerCertificate,
                                        pContext->RipeZombie->cbServerCertificate);
        if(pctRet != PCT_ERR_OK)
        {
            return SP_LOG_RESULT(pctRet);
        }
    }

    if(pCertContext)
    {
        pbCert = LocalAlloc(LPTR, pCertContext->cbCertEncoded);
        if(pbCert == NULL)
        {
            return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        }
        memcpy(pbCert, pCertContext->pbCertEncoded, pCertContext->cbCertEncoded);

        pCredInfo->fFlags |= LCRED_CRED_EXISTS;

        pCredInfo->pbCertificateChain = pbCert;
        pCredInfo->cbCertificateChain = pCertContext->cbCertEncoded;
        pCredInfo->cCertificates = 1;
        pCredInfo->dwBits = 0;

        // Compute number of bits in the certificate's public key.
        pctRet = SPPublicKeyFromCert(pCertContext, &pKey, NULL);
        if(pctRet == PCT_ERR_OK)
        {
            pk = (RSAPUBKEY *)((pKey->pPublic) + 1);
            if(pk)
            {
                pCredInfo->dwBits = pk->bitlen;
            }

            SPExternalFree(pKey);
        }

        CertFreeCertificateContext(pCertContext);
    }

    return SEC_E_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   SpQueryNames
//
//  Synopsis:   Retrieves the SECPKG_ATTR_NAMES context attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer returned contains the following structure:
//
//              typedef struct _SecPkgContext_NamesW
//              {
//                  SEC_WCHAR SEC_FAR * sUserName;
//              } SecPkgContext_NamesW;
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SpQueryNames(
    PSPContext pContext,
    SecPkgContext_Names *pNames)
{
    SECURITY_STATUS Status;
    PCCERT_CONTEXT  pCert = NULL;
    DWORD           cchSubject;
    DWORD           cbSubject;

    DebugLog((DEB_TRACE, "QueryContextAttributes(SECPKG_ATTR_NAMES)\n"));

    //
    // Obtain data from Schannel.
    //

    if(pContext->RipeZombie->pbServerCertificate == NULL)
    {
        return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
    }

    Status = DeserializeCertContext(&pCert,
                                    pContext->RipeZombie->pbServerCertificate,
                                    pContext->RipeZombie->cbServerCertificate);
    if(Status != PCT_ERR_OK)
    {
        return SP_LOG_RESULT(Status);
    }
        
    //
    // Build name string.
    //

    if(0 >= (cchSubject = CertNameToStr(pCert->dwCertEncodingType,
                                       &pCert->pCertInfo->Subject,
                                       CERT_X500_NAME_STR | CERT_NAME_STR_NO_PLUS_FLAG,
                                       NULL,
                                       0)))
    {
        CertFreeCertificateContext(pCert);
        return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
    }
    cbSubject = (cchSubject + 1) * sizeof(TCHAR);

    pNames->sUserName = LocalAlloc(LPTR, cbSubject);
    if(pNames->sUserName == NULL)
    {
        CertFreeCertificateContext(pCert);
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }

    if(0 >= CertNameToStr(pCert->dwCertEncodingType,
                          &pCert->pCertInfo->Subject,
                          CERT_X500_NAME_STR | CERT_NAME_STR_NO_PLUS_FLAG,
                          pNames->sUserName,
                          cchSubject))
    {
        CertFreeCertificateContext(pCert);
        LocalFree(pNames->sUserName);
        return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
    }

    CertFreeCertificateContext(pCert);

    return SEC_E_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   SpQueryPackageInfo
//
//  Synopsis:   Retrieves the SECPKG_ATTR_PACKAGE_INFO context attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer returned contains the following structure:
//
//              typedef struct _SecPkgContext_PackageInfoW
//              {
//                  PSecPkgInfoW PackageInfo;
//              } SecPkgContext_PackageInfoW, SEC_FAR * PSecPkgContext_PackageInfoW;
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SpQueryPackageInfo(
    PSPContext pContext,
    PVOID Buffer)
{
    PSecPkgContext_PackageInfoW pPackageInfo;
    SecPkgInfoW Info;
    DWORD cbName;
    DWORD cbComment;

    DebugLog((DEB_TRACE, "QueryContextAttributes(SECPKG_ATTR_PACKAGE_INFO)\n"));

    SpSslGetInfo(&Info);

    pPackageInfo = (PSecPkgContext_PackageInfoW)Buffer;

    cbName    = (lstrlen(Info.Name) + 1) * sizeof(WCHAR);
    cbComment = (lstrlen(Info.Comment) + 1) * sizeof(WCHAR);

    pPackageInfo->PackageInfo = LocalAlloc(LPTR, sizeof(SecPkgInfo) + cbName + cbComment);

    if(pPackageInfo->PackageInfo == NULL)
    {
        return SP_LOG_RESULT(STATUS_INSUFFICIENT_RESOURCES);
    }

    pPackageInfo->PackageInfo->wVersion      = Info.wVersion;
    pPackageInfo->PackageInfo->wRPCID        = Info.wRPCID;
    pPackageInfo->PackageInfo->fCapabilities = Info.fCapabilities;
    pPackageInfo->PackageInfo->cbMaxToken    = Info.cbMaxToken;

    pPackageInfo->PackageInfo->Name    = (LPWSTR)(pPackageInfo->PackageInfo + 1);
    pPackageInfo->PackageInfo->Comment = (LPWSTR)((PBYTE)pPackageInfo->PackageInfo->Name + cbName);

    lstrcpy(
        pPackageInfo->PackageInfo->Name,
        Info.Name);

    lstrcpy(
        pPackageInfo->PackageInfo->Comment,
        Info.Comment);

    return SEC_E_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   SpQueryProtoInfo
//
//  Synopsis:   Retrieves the SECPKG_ATTR_PROTO_INFO context attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer returned contains the following structure:
//
//              typedef struct _SecPkgContext_ProtoInfoW
//              {
//                  SEC_WCHAR SEC_FAR * sProtocolName;
//                  unsigned long       majorVersion;
//                  unsigned long       minorVersion;
//              } SecPkgContext_ProtoInfoW;
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SpQueryProtoInfo(
    PSPContext pContext,
    PVOID Buffer)
{
    SecPkgContext_ProtoInfo *pProtoInfo;
    DWORD           index;
    DWORD           cbName;

    DebugLog((DEB_TRACE, "QueryContextAttributes(SECPKG_ATTR_PROTO_INFO)\n"));

    pProtoInfo = (SecPkgContext_ProtoInfo *)Buffer;

    for(index = 0;
        index < sizeof(rgProts) / sizeof(PROTO_ID);
        index += 1)
    {
        if(pContext->RipeZombie->fProtocol == rgProts[index].dwProtoId)
        {
            break;
        }
    }
    if(index >= sizeof(rgProts) / sizeof(PROTO_ID))
    {
        return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
    }

    cbName = (lstrlen(rgProts[index].szProto) + 1) * sizeof(WCHAR);

    pProtoInfo->sProtocolName = LocalAlloc(LPTR, cbName);
    if(pProtoInfo->sProtocolName == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }
    lstrcpy(pProtoInfo->sProtocolName, rgProts[index].szProto);

    pProtoInfo->majorVersion  = rgProts[index].dwMajor;
    pProtoInfo->minorVersion  = rgProts[index].dwMinor;

    return SEC_E_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   SpQuerySizes
//
//  Synopsis:   Retrieves the SECPKG_ATTR_SIZES context attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer returned contains the following structure:
//
//              typedef struct _SecPkgContext_Sizes
//              {
//                  unsigned long cbMaxToken;
//                  unsigned long cbMaxSignature;
//                  unsigned long cbBlockSize;
//                  unsigned long cbSecurityTrailer;
//              } SecPkgContext_Sizes;
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SpQuerySizes(
    PSPContext pContext,
    SecPkgContext_Sizes *pSizes)
{
    DebugLog((DEB_TRACE, "QueryContextAttributes(SECPKG_ATTR_SIZES)\n"));

    if (NULL == pContext->pCipherInfo ||
        NULL == pContext->pHashInfo)
    {
        return SP_LOG_RESULT(SEC_E_INVALID_HANDLE);
    }

    switch(pContext->RipeZombie->fProtocol)
    {
        case SP_PROT_SSL2_CLIENT:
        case SP_PROT_SSL2_SERVER:
            pSizes->cbMaxToken = SSL2_MAX_MESSAGE_LENGTH;
            pSizes->cbSecurityTrailer = 2 + pContext->pHashInfo->cbCheckSum;
            if(pContext->pCipherInfo->dwBlockSize > 1)
            {
                pSizes->cbSecurityTrailer += 1 + pContext->pCipherInfo->dwBlockSize; // 3 byte header
            }
            break;

        case SP_PROT_PCT1_CLIENT:
        case SP_PROT_PCT1_SERVER:
            pSizes->cbMaxToken = PCT1_MAX_MESSAGE_LENGTH;
            pSizes->cbSecurityTrailer = 2 + pContext->pHashInfo->cbCheckSum;
            if(pContext->pCipherInfo->dwBlockSize > 1)
            {
                pSizes->cbSecurityTrailer += 1 + pContext->pCipherInfo->dwBlockSize; // 3 byte header
            }
            break;

        case SP_PROT_SSL3_CLIENT:
        case SP_PROT_SSL3_SERVER:
        case SP_PROT_TLS1_CLIENT:
        case SP_PROT_TLS1_SERVER:
            pSizes->cbMaxToken = SSL3_MAX_MESSAGE_LENGTH;
            pSizes->cbSecurityTrailer = 5 + pContext->pHashInfo->cbCheckSum;
            if(pContext->pCipherInfo->dwBlockSize > 1)
            {
                pSizes->cbSecurityTrailer += pContext->pCipherInfo->dwBlockSize;
            }
            break;

        default:
            pSizes->cbMaxToken = SSL3_MAX_MESSAGE_LENGTH;
            pSizes->cbSecurityTrailer = 0;
   }

    pSizes->cbMaxSignature = pContext->pHashInfo->cbCheckSum;
    pSizes->cbBlockSize    = pContext->pCipherInfo->dwBlockSize;

    return SEC_E_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   SpQueryStreamSizes
//
//  Synopsis:   Retrieves the SECPKG_ATTR_STREAM_SIZES context attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer returned contains the following structure:
//
//              typedef struct _SecPkgContext_StreamSizes
//              {
//                  unsigned long   cbHeader;
//                  unsigned long   cbTrailer;
//                  unsigned long   cbMaximumMessage;
//                  unsigned long   cBuffers;
//                  unsigned long   cbBlockSize;
//              } SecPkgContext_StreamSizes;
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SpQueryStreamSizes(
    PSPContext pContext,
    SecPkgContext_StreamSizes *pStreamSizes)
{
    DebugLog((DEB_TRACE, "QueryContextAttributes(SECPKG_ATTR_STREAM_SIZES)\n"));

    if (NULL == pContext->pCipherInfo ||
        NULL == pContext->pHashInfo)
    {
        return SP_LOG_RESULT(SEC_E_INVALID_HANDLE);
    }

    switch(pContext->RipeZombie->fProtocol)
    {
        case SP_PROT_SSL2_CLIENT:
        case SP_PROT_SSL2_SERVER:
            pStreamSizes->cbMaximumMessage = SSL2_MAX_MESSAGE_LENGTH;
            pStreamSizes->cbHeader = 2 + pContext->pHashInfo->cbCheckSum;
            pStreamSizes->cbTrailer = 0;
            if(pContext->pCipherInfo->dwBlockSize > 1)
            {
                pStreamSizes->cbHeader += 1; // 3 byte header
                pStreamSizes->cbTrailer += pContext->pCipherInfo->dwBlockSize;
            }
            break;

        case SP_PROT_PCT1_CLIENT:
        case SP_PROT_PCT1_SERVER:
            pStreamSizes->cbMaximumMessage = PCT1_MAX_MESSAGE_LENGTH;
            pStreamSizes->cbHeader = 2;
            pStreamSizes->cbTrailer = pContext->pHashInfo->cbCheckSum;
            if(pContext->pCipherInfo->dwBlockSize > 1)
            {
                pStreamSizes->cbHeader += 1; // 3 byte header
                pStreamSizes->cbTrailer += pContext->pCipherInfo->dwBlockSize;
            }
            break;

        case SP_PROT_TLS1_CLIENT:
        case SP_PROT_TLS1_SERVER:
        case SP_PROT_SSL3_CLIENT:
        case SP_PROT_SSL3_SERVER:
            pStreamSizes->cbMaximumMessage = SSL3_MAX_MESSAGE_LENGTH;
            pStreamSizes->cbHeader = 5;
            pStreamSizes->cbTrailer = pContext->pHashInfo->cbCheckSum;
            if(pContext->pCipherInfo->dwBlockSize > 1)
            {
                pStreamSizes->cbTrailer += pContext->pCipherInfo->dwBlockSize;
            }
            break;

        default:
            pStreamSizes->cbMaximumMessage = SSL3_MAX_MESSAGE_LENGTH;
            pStreamSizes->cbHeader = 0;
            pStreamSizes->cbTrailer = 0;
    }

    pStreamSizes->cbBlockSize = pContext->pCipherInfo->dwBlockSize;

    pStreamSizes->cBuffers = 4;

    return SEC_E_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   SpQueryEapKeyBlock
//
//  Synopsis:   Retrieves the SECPKG_ATTR_EAP_KEY_BLOCK context attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer returned contains the following structure:
//
//              typedef struct _SecPkgContext_EapKeyBlock
//              {
//                  BYTE    rgbKeys[128];
//                  BYTE    rgbIVs[64];
//              } SecPkgContext_EapKeyBlock, *PSecPkgContext_EapKeyBlock;
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SpQueryEapKeyBlock(
    LSA_SEC_HANDLE ContextHandle,
    PVOID Buffer)
{
    SecPkgContext_EapKeyBlock KeyBlock;
    DWORD           Size;
    PSPContext      pContext;
    SECURITY_STATUS Status;

    HCRYPTHASH hHash;
    CRYPT_DATA_BLOB Data;
    UCHAR rgbRandom[CB_SSL3_RANDOM + CB_SSL3_RANDOM];
    DWORD cbRandom;
    DWORD cbData;

    DebugLog((DEB_TRACE, "QueryContextAttributes(SECPKG_ATTR_EAP_KEY_BLOCK)\n"));

    pContext = (PSPContext)ContextHandle;
    Size     = sizeof( SecPkgContext_EapKeyBlock );

    //
    // Obtain data from Schannel.
    //

    if(!(pContext->RipeZombie->fProtocol & SP_PROT_TLS1))
    {
        // This attribute is defined for TLS only.
        return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
    }

    if(!pContext->RipeZombie->hMasterKey)
    {
        return SP_LOG_RESULT(SEC_E_INVALID_HANDLE);
    }

    // Build random buffer.
    CopyMemory(rgbRandom, pContext->rgbS3CRandom, CB_SSL3_RANDOM);
    CopyMemory(rgbRandom + CB_SSL3_RANDOM, pContext->rgbS3SRandom, CB_SSL3_RANDOM);
    cbRandom = CB_SSL3_RANDOM + CB_SSL3_RANDOM;

    // rgbKeys = PRF(master_secret, "client EAP encryption", client_random + server_random);

    // Compute the PRF
    if(!CryptCreateHash(pContext->RipeZombie->hMasterProv,
                        CALG_TLS1PRF,
                        pContext->RipeZombie->hMasterKey,
                        0,
                        &hHash))
    {
        SP_LOG_RESULT(GetLastError());
        return SEC_E_INTERNAL_ERROR;
    }

    Data.pbData = TLS1_LABEL_EAP_KEYS;
    Data.cbData = CB_TLS1_LABEL_EAP_KEYS;
    if(!CryptSetHashParam(hHash,
                          HP_TLS1PRF_LABEL,
                          (PBYTE)&Data,
                          0))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        return SEC_E_INTERNAL_ERROR;
    }

    Data.pbData = rgbRandom;
    Data.cbData = cbRandom;
    if(!CryptSetHashParam(hHash,
                          HP_TLS1PRF_SEED,
                          (PBYTE)&Data,
                          0))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        return SEC_E_INTERNAL_ERROR;
    }

    cbData = sizeof(KeyBlock.rgbKeys);
    if(!CryptGetHashParam(hHash,
                          HP_HASHVAL,
                          KeyBlock.rgbKeys,
                          &cbData,
                          0))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        return SEC_E_INTERNAL_ERROR;
    }
    SP_ASSERT(cbData == sizeof(KeyBlock.rgbKeys));

    CryptDestroyHash(hHash);


    // IVs = PRF("", "client EAP encryption", client_random + server_random)

    if(!PRF(NULL, 0,
            TLS1_LABEL_EAP_KEYS, CB_TLS1_LABEL_EAP_KEYS,
            rgbRandom, sizeof(rgbRandom),
            KeyBlock.rgbIVs, sizeof(KeyBlock.rgbIVs)))
    {
        return SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
    }

    //
    // Copy structure back to client memory.
    //

    Status = LsaTable->CopyToClientBuffer( NULL,
                                           Size,
                                           Buffer,
                                           &KeyBlock );
    if(FAILED(Status))
    {
        return SP_LOG_RESULT(Status);
    }

    return SEC_E_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:   SpQueryMappedCredProp
//
//  Synopsis:   Retrieves the SECPKG_ATTR_MAPPED_CRED_PROP context
//              attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer returned contains the following structure:
//
//              typedef struct _SecPkgContext_MappedCredProp
//              {
//                  DWORD   dwProperty;
//                  PBYTE   pbBuffer;
//              } SecPkgContext_MappedCredProp;
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SpQueryMappedCredAttr(
    PSPContext pContext,
    PVOID Buffer)
{
    SecPkgContext_MappedCredAttr *pMappedCredAttr;
    HMAPPER *phMapper;
    DWORD cbBuffer;
    SECURITY_STATUS Status;

    pMappedCredAttr = (SecPkgContext_MappedCredAttr *)Buffer;

    DebugLog((DEB_TRACE, "QueryContextAttributes(SECPKG_ATTR_MAPPED_CRED_ATTR %d)\n", pMappedCredAttr->dwAttribute));

    if(pContext->RipeZombie == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INVALID_HANDLE);
    }

    phMapper = pContext->RipeZombie->phMapper;
    if(phMapper == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INVALID_HANDLE);
    }

    if(phMapper->m_dwFlags & SCH_FLAG_SYSTEM_MAPPER)
    {
        // System mapper.
        return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
    }
    else
    {
        // Application mapper.
        Status = phMapper->m_vtable->QueryMappedCredentialAttributes(
                                phMapper,
                                pContext->RipeZombie->hLocator,
                                pMappedCredAttr->dwAttribute,
                                NULL,
                                &cbBuffer);
        if(FAILED(Status))
        {
            return SP_LOG_RESULT(Status);
        }

        pMappedCredAttr->pvBuffer = LocalAlloc(LPTR, cbBuffer);
        if(pMappedCredAttr->pvBuffer == NULL)
        {
            return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        }

        Status = phMapper->m_vtable->QueryMappedCredentialAttributes(
                                phMapper,
                                pContext->RipeZombie->hLocator,
                                pMappedCredAttr->dwAttribute,
                                pMappedCredAttr->pvBuffer,
                                &cbBuffer);
        if(FAILED(Status))
        {
            LocalFree(pMappedCredAttr->pvBuffer);
            return SP_LOG_RESULT(Status);
        }
    }

    return SEC_E_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   SpQueryApplicationData
//
//  Synopsis:   Retrieves the SECPKG_ATTR_APP_DATA context attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer returned contains the following structure:
//
//              typedef struct _SecPkgContext_SessionAppData
//              {
//                  DWORD dwFlags;
//                  DWORD cbAppData;
//                  PBYTE pbAppData;
//              } SecPkgContext_SessionAppData, *PSecPkgContext_SessionAppData;
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SpQueryApplicationData(
    LSA_SEC_HANDLE ContextHandle,
    PVOID Buffer)
{
    SecPkgContext_SessionAppData AppData;
    PBYTE pbAppData = NULL;
    DWORD cbAppData = 0;
    PSPContext      pContext;
    SECURITY_STATUS Status;
    PVOID pvClient = NULL;

    DebugLog((DEB_TRACE, "QueryContextAttributes(SECPKG_ATTR_APP_DATA)\n"));

    pContext = (PSPContext)ContextHandle;

    if(pContext == NULL || pContext->RipeZombie == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INVALID_HANDLE);
    }

    //
    // Get application data from cache.
    //

    Status = GetCacheAppData(pContext->RipeZombie, &pbAppData, &cbAppData);

    if(FAILED(Status))
    {
        SP_LOG_RESULT(Status);
        goto cleanup;
    }

    //
    // Allocate memory for application data in application process.
    //

    if(pbAppData != NULL)
    {
        Status = LsaTable->AllocateClientBuffer(
                                NULL,
                                cbAppData,
                                &pvClient);
        if(FAILED(Status))
        {
            SP_LOG_RESULT(Status);
            goto cleanup;
        }

        Status = LsaTable->CopyToClientBuffer(
                                NULL,
                                cbAppData,
                                pvClient,
                                pbAppData);
        if(FAILED(Status))
        {
            SP_LOG_RESULT(Status);
            goto cleanup;
        }
    }


    //
    // Build output structure.
    //

    ZeroMemory(&AppData, sizeof(AppData));

    AppData.cbAppData = cbAppData;
    AppData.pbAppData = pvClient;


    //
    // Copy output structure back to client memory.
    //

    Status = LsaTable->CopyToClientBuffer( NULL,
                                           sizeof(SecPkgContext_SessionAppData),
                                           Buffer,
                                           &AppData);
    if(FAILED(Status))
    {
        SP_LOG_RESULT(Status);
        goto cleanup;
    }

    // Operation has succeeded, so consume this buffer.
    pvClient = NULL;


cleanup:

    if(pvClient)
    {
        LsaTable->FreeClientBuffer(NULL, pvClient);
    }

    if(pbAppData)
    {
        SPExternalFree(pbAppData);
    }

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   SpQuerySessionInfo
//
//  Synopsis:   Retrieves the SECPKG_ATTR_SESSION_INFO context attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer returned contains the following structure:
//
//              typedef struct _SecPkgContext_SessionInfo
//              {
//                  DWORD dwFlags;
//                  DWORD cbSessionId;
//                  BYTE  rgbSessionId[32];
//              } SecPkgContext_SessionInfo, *PSecPkgContext_SessionInfo;
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SpQuerySessionInfo(
    PSPContext pContext,
    SecPkgContext_SessionInfo *pSessionInfo)
{
    DebugLog((DEB_TRACE, "QueryContextAttributes(SECPKG_ATTR_SESSION_INFO)\n"));

    if (NULL == pContext->RipeZombie)
    {
        return SP_LOG_RESULT(SEC_E_INVALID_HANDLE);
    }

    ZeroMemory(pSessionInfo, sizeof(SecPkgContext_SessionInfo));

    if(!(pContext->Flags & CONTEXT_FLAG_FULL_HANDSHAKE))
    {
        pSessionInfo->dwFlags = SSL_SESSION_RECONNECT;
    }

    pSessionInfo->cbSessionId = pContext->RipeZombie->cbSessionID;

    memcpy(pSessionInfo->rgbSessionId, pContext->RipeZombie->SessionID, pContext->RipeZombie->cbSessionID);

    return SEC_E_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:   SpQueryContextAttributes
//
//  Synopsis:   Querys attributes of the specified context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      The following attributes are supported by the Schannel
//              package:
//
//                  SECPKG_ATTR_AUTHORITY
//                  SECPKG_ATTR_CONNECTION_INFO
//                  SECPKG_ATTR_ISSUER_LIST
//                  SECPKG_ATTR_ISSUER_LIST_EX
//                  SECPKG_ATTR_KEY_INFO
//                  SECPKG_ATTR_LIFESPAN
//                  SECPKG_ATTR_LOCAL_CERT_CONTEXT
//                  SECPKG_ATTR_LOCAL_CRED
//                  SECPKG_ATTR_NAMES
//                  SECPKG_ATTR_PROTO_INFO
//                  SECPKG_ATTR_REMOTE_CERT_CONTEXT
//                  SECPKG_ATTR_REMOTE_CRED
//                  SECPKG_ATTR_SIZES
//                  SECPKG_ATTR_STREAM_SIZES
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
SpLsaQueryContextAttributes(
    LSA_SEC_HANDLE Context,
    ULONG Attribute,
    PVOID Buffer)
{
    SECURITY_STATUS Status;
    PSPContext      pContext;

    pContext = (PSPContext)Context;

    switch(Attribute)
    {
        case SECPKG_ATTR_AUTHORITY :
            Status = SpQueryAuthority(Context, Buffer);
            break;

        case SECPKG_ATTR_ISSUER_LIST :
            Status = SpQueryIssuerList(Context, Buffer);
            break;

        case SECPKG_ATTR_ISSUER_LIST_EX:
            Status = SpQueryIssuerListEx(Context, Buffer);
            break;

//        case SECPKG_ATTR_KEY_INFO :
//            Status = SpQueryKeyInfo(Context, Buffer);
//            break;

//        case SECPKG_ATTR_LIFESPAN :
//            Status = SpQueryLifespan(Context, Buffer);
//            break;

        case SECPKG_ATTR_LOCAL_CERT_CONTEXT:
            Status = SpQueryLocalCertContext(Context, Buffer);
            break;

        case SECPKG_ATTR_LOCAL_CRED:
            Status = SpQueryLocalCred(Context, Buffer);
            break;

//        case SECPKG_ATTR_NAMES :
//            Status = SpQueryNames(Context, Buffer);
//            break;

//        case SECPKG_ATTR_PROTO_INFO:
//            Status = SpQueryProtoInfo(Context, Buffer);
//            break;

//        case SECPKG_ATTR_REMOTE_CERT_CONTEXT:
//            Status = SpQueryCertContext(Context, Buffer, FALSE);
//            break;

//        case SECPKG_ATTR_REMOTE_CRED:
//            Status = SpQueryRemoteCred(Context, Buffer);
//            break;

//        case SECPKG_ATTR_SIZES:
//            Status = SpQuerySizes(Context, Buffer);
//            break;

//        case SECPKG_ATTR_STREAM_SIZES:
//            Status = SpQueryStreamSizes(Context, Buffer);
//            break;

        case SECPKG_ATTR_EAP_KEY_BLOCK:
            Status = SpQueryEapKeyBlock(Context, Buffer);
            break;

//        case SECPKG_ATTR_MAPPED_CRED_ATTR:
//            Status = SpQueryMappedCredAttr(Context, Buffer);
//            break;

        case SECPKG_ATTR_APP_DATA:
            Status = SpQueryApplicationData(Context, Buffer);
            break;

        default:
            DebugLog((DEB_ERROR, "QueryContextAttributes(unsupported function %d)\n", Attribute));

            return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
    }

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   SpUserQueryContextAttributes
//
//  Synopsis:   User mode QueryContextAttribute.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
SpUserQueryContextAttributes(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG ContextAttribute,
    IN OUT PVOID pBuffer
    )
{
    PSSL_USER_CONTEXT Context;
    PSPContext pContext;
    SECURITY_STATUS Status;

    Context = SslFindUserContext( ContextHandle );

    if(Context == NULL)
    {
        return(SEC_E_INVALID_HANDLE);
    }

    pContext = Context->pContext;
    if(!pContext)
    {
        return(SEC_E_INVALID_HANDLE);
    }

    switch(ContextAttribute)
    {
        case SECPKG_ATTR_CONNECTION_INFO:
            Status = SpQueryConnectionInfo(pContext, pBuffer);
            break;

        case SECPKG_ATTR_KEY_INFO:
            Status = SpQueryKeyInfo(pContext, pBuffer);
            break;

        case SECPKG_ATTR_LIFESPAN:
            Status = SpQueryLifespan(pContext, pBuffer);
            break;

        case SECPKG_ATTR_NAMES :
            Status = SpQueryNames(pContext, pBuffer);
            break;

        case SECPKG_ATTR_PACKAGE_INFO:
            Status = SpQueryPackageInfo(pContext, pBuffer);
            break;

        case SECPKG_ATTR_PROTO_INFO:
            Status = SpQueryProtoInfo(pContext, pBuffer);
            break;

        case SECPKG_ATTR_REMOTE_CERT_CONTEXT:
            Status = SpQueryRemoteCertContext(pContext, pBuffer);
            break;

        case SECPKG_ATTR_REMOTE_CRED:
            Status = SpQueryRemoteCred(pContext, pBuffer);
            break;

        case SECPKG_ATTR_SIZES:
            Status = SpQuerySizes(pContext, pBuffer);
            break;

        case SECPKG_ATTR_STREAM_SIZES:
            Status = SpQueryStreamSizes(pContext, pBuffer);
            break;

        case SECPKG_ATTR_MAPPED_CRED_ATTR:
            Status = SpQueryMappedCredAttr(pContext, pBuffer);
            break;

        case SECPKG_ATTR_ACCESS_TOKEN:
            Status = SpQueryAccessToken(pContext, pBuffer);
            break;

        case SECPKG_ATTR_SESSION_INFO:
            Status = SpQuerySessionInfo(pContext, pBuffer);
            break;
    
        default:
            DebugLog((DEB_ERROR, "QueryContextAttributes(unsupported function %d)\n", ContextAttribute));

            return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   SpSetUseValidatedProp
//
//  Synopsis:   Sets the SECPKG_ATTR_USE_VALIDATED context attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer must contain a DWORD indicating whether the 
//              credential currently associated with the context has been
//              validated for use.
//
//--------------------------------------------------------------------------
NTSTATUS
SpSetUseValidatedProp(
    IN PSPContext pContext,
    IN PVOID Buffer,
    IN ULONG BufferSize)
{
    DWORD dwUseValidated;
    NTSTATUS Status;

    DebugLog((DEB_TRACE, "SetContextAttributes(SECPKG_ATTR_USE_VALIDATED)\n"));

    if(BufferSize < sizeof(DWORD))
    {
        Status = SP_LOG_RESULT(STATUS_INVALID_PARAMETER);
        goto cleanup;
    }

    Status = LsaTable->CopyFromClientBuffer( NULL,
                                             sizeof(DWORD),
                                             &dwUseValidated,
                                             Buffer );
    if(FAILED(Status))
    {
        SP_LOG_RESULT(Status);
        goto cleanup;
    }

    DebugLog((DEB_TRACE, "Use validated:%d\n", dwUseValidated));
    
    if(pContext->RipeZombie == NULL)
    {
        Status = SP_LOG_RESULT(STATUS_INVALID_PARAMETER);
        goto cleanup;
    }

    if(dwUseValidated)
    {
        pContext->RipeZombie->dwFlags |= SP_CACHE_FLAG_USE_VALIDATED;
    }
    else
    {
        pContext->RipeZombie->dwFlags &= ~SP_CACHE_FLAG_USE_VALIDATED;
    }

cleanup:

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   SpSetCredentialNameProp
//
//  Synopsis:   Sets the SECPKG_ATTR_CREDENTIAL_NAME context attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer must contain the following structure:
//
//              typedef struct _SecPkgContext_CredentialNameW
//               {
//                  unsigned long CredentialType;
//                   SEC_WCHAR SEC_FAR *sCredentialName;
//              } SecPkgContext_CredentialNameW, SEC_FAR * PSecPkgContext_CredentialNameW;
//
//--------------------------------------------------------------------------
NTSTATUS
SpSetCredentialNameProp(
    IN PSPContext pContext,
    IN PVOID Buffer,
    IN ULONG BufferSize)
{
    PSecPkgContext_CredentialNameW pCredentialName = NULL;
    DWORD_PTR Offset;
    NTSTATUS Status;

    DebugLog((DEB_TRACE, "SetContextAttributes(SECPKG_ATTR_CREDENTIAL_NAME)\n"));

    //
    // Marshal over the credential name from the client address space.
    //

    if(BufferSize < sizeof(SecPkgContext_CredentialNameW))
    {
        Status = SP_LOG_RESULT(STATUS_INVALID_PARAMETER);
        goto cleanup;
    }

    pCredentialName = SPExternalAlloc(BufferSize + sizeof(WCHAR));

    if(pCredentialName == NULL)
    {
        Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto cleanup;
    }

    Status = LsaTable->CopyFromClientBuffer( NULL,
                                             BufferSize,
                                             pCredentialName,
                                             Buffer );
    if(FAILED(Status))
    {
        SP_LOG_RESULT(Status);
        goto cleanup;
    }

    if(pCredentialName->CredentialType != CRED_TYPE_DOMAIN_CERTIFICATE)
    {
        DebugLog((DEB_ERROR, "Unexpected credential type %d\n", pCredentialName->CredentialType));
        Status = SEC_E_UNKNOWN_CREDENTIALS;
    }

    if((PVOID)pCredentialName->sCredentialName < Buffer ||
       (PBYTE)pCredentialName->sCredentialName >= (PBYTE)Buffer + BufferSize)
    {
        Status = SP_LOG_RESULT(STATUS_INVALID_PARAMETER);
        goto cleanup;
    }
    Offset = (PBYTE)pCredentialName->sCredentialName - (PBYTE)Buffer;

    pCredentialName->sCredentialName = (LPWSTR)((PBYTE)pCredentialName + Offset);

    DebugLog((DEB_TRACE, "Set client credential to '%ls'.\n", pCredentialName->sCredentialName));


    //
    // Associate the specified credential with the current context.
    //

    pContext->pszCredentialName = SPExternalAlloc((lstrlenW(pCredentialName->sCredentialName) + 1) * sizeof(WCHAR));
    if(pContext->pszCredentialName == NULL)
    {
        Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto cleanup;
    }
    lstrcpyW(pContext->pszCredentialName, pCredentialName->sCredentialName);


    Status = QueryCredentialManagerForCert(pContext,
                                           pCredentialName->sCredentialName);

    if(FAILED(Status))
    {
        SP_LOG_RESULT(Status);
        goto cleanup;
    }

    DebugLog((DEB_TRACE, "Credential assigned to context successfully.\n"));


cleanup:
    if(pCredentialName)
    {
        SPExternalFree(pCredentialName);
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   SpSetApplicationData
//
//  Synopsis:   Sets the SECPKG_ATTR_APP_DATA context attribute.
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The buffer must contain the following structure:
//
//              typedef struct _SecPkgContext_SessionAppData
//              {
//                  DWORD dwFlags;
//                  DWORD cbAppData;
//                  PBYTE pbAppData;
//              } SecPkgContext_SessionAppData, *PSecPkgContext_SessionAppData;
//
//--------------------------------------------------------------------------
NTSTATUS
SpSetApplicationData(
    IN PSPContext pContext,
    IN PVOID Buffer,
    IN ULONG BufferSize)
{
    SecPkgContext_SessionAppData AppData;
    PBYTE pbAppData = NULL;
    NTSTATUS Status;

    DebugLog((DEB_TRACE, "SetContextAttributes(SECPKG_ATTR_APP_DATA)\n"));

    if(pContext->RipeZombie == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INVALID_HANDLE);
    }


    //
    // Marshal over the input structure from the client address space.
    //

    if(BufferSize < sizeof(SecPkgContext_SessionAppData))
    {
        Status = SP_LOG_RESULT(STATUS_INVALID_PARAMETER);
        goto cleanup;
    }

    Status = LsaTable->CopyFromClientBuffer( NULL,
                                             sizeof(SecPkgContext_SessionAppData),
                                             &AppData,
                                             Buffer );
    if(FAILED(Status))
    {
        SP_LOG_RESULT(Status);
        goto cleanup;
    }


    //
    // Marshal over the application data from the client address space.
    //

    // Limit application data size to 64k.
    if(AppData.cbAppData > 0x10000)
    {
        Status = SP_LOG_RESULT(STATUS_INVALID_PARAMETER);
        goto cleanup;
    }

    if(AppData.cbAppData == 0 || AppData.pbAppData == NULL)
    {
        Status = SP_LOG_RESULT(STATUS_INVALID_PARAMETER);
        goto cleanup;
    }

    pbAppData = SPExternalAlloc(AppData.cbAppData);

    if(pbAppData == NULL)
    {
        Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto cleanup;
    }

    Status = LsaTable->CopyFromClientBuffer( NULL,
                                             AppData.cbAppData,
                                             pbAppData,
                                             AppData.pbAppData );
    if(FAILED(Status))
    {
        SP_LOG_RESULT(Status);
        goto cleanup;
    }


    //
    // Assign application data to cache entry.
    //

    Status = SetCacheAppData(pContext->RipeZombie,
                             pbAppData,
                             AppData.cbAppData);

    if(!FAILED(Status))
    {
        // The operation succeeded, so consume the application data.
        pbAppData = NULL;
    }


cleanup:
    if(pbAppData)
    {
        SPExternalFree(pbAppData);
    }

    return Status;
}


NTSTATUS
NTAPI 
SpSetContextAttributes(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG ContextAttribute,
    IN PVOID Buffer,
    IN ULONG BufferSize)
{
    NTSTATUS    Status;
    PSPContext  pContext;

    pContext = (PSPContext)ContextHandle;

    switch(ContextAttribute)
    {
        case SECPKG_ATTR_USE_VALIDATED:
            DebugLog((DEB_TRACE, "SetContextAttributes(SECPKG_ATTR_USE_VALIDATED)\n"));

            Status = STATUS_SUCCESS;
            break;

        case SECPKG_ATTR_CREDENTIAL_NAME:
            Status = SpSetCredentialNameProp(pContext, Buffer, BufferSize);
            break;

        case SECPKG_ATTR_TARGET_INFORMATION:
            DebugLog((DEB_TRACE, "SetContextAttributes(SECPKG_ATTR_TARGET_INFORMATION)\n"));

            Status = STATUS_SUCCESS;
            break;

        case SECPKG_ATTR_APP_DATA:
            Status = SpSetApplicationData(pContext, Buffer, BufferSize);
            break;

        default:
            DebugLog((DEB_ERROR, "SetContextAttributes(unsupported function %d)\n", ContextAttribute));

            Status = SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\lsa\mapper.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       mapper.c
//
//  Contents:   Implements the DS Mapping Layer
//
//  Classes:
//
//  Functions:
//
//  History:    10-15-96   RichardW   Created
//
//  Notes:      The code here has two forks.  One, the direct path, for when
//              the DLL is running on a DC, and the second, for when we're
//              running elsewhere and remoting through the generic channel
//              to the DC.
//
//----------------------------------------------------------------------------

#include "sslp.h"
#include <crypt.h>
#include <lmcons.h>
#include <ntsam.h>
#include <samrpc.h>
#include <samisrv.h>
#include <lsarpc.h>
#include <lsaisrv.h>
#include <dnsapi.h>
#include <certmap.h>
#include <align.h>
#include <ntmsv1_0.h>
#include <ntdsapi.h>
#include <ntdsapip.h>
#include "mapsam.h"
#include "wincrypt.h"
#include <msaudite.h>


 LONG WINAPI
SslLocalRefMapper(
    PHMAPPER    Mapper);

 LONG WINAPI
SslLocalDerefMapper(
    PHMAPPER    Mapper);

 DWORD WINAPI
SslLocalGetIssuerList(
    IN PHMAPPER Mapper,
    IN PVOID    Reserved,
    OUT PBYTE   pIssuerList,
    OUT PDWORD  IssuerListLength);

 DWORD WINAPI
SslLocalGetChallenge(
    IN PHMAPPER Mapper,
    IN PUCHAR   AuthenticatorId,
    IN DWORD    AuthenticatorIdLength,
    OUT PUCHAR  Challenge,
    OUT DWORD * ChallengeLength);

 DWORD WINAPI
SslLocalMapCredential(
    IN PHMAPPER Mapper,
    IN DWORD    CredentialType,
    VOID const *pCredential,
    VOID const *pAuthority,
    OUT HLOCATOR * phLocator);

 DWORD WINAPI
SslRemoteMapCredential(
    IN PHMAPPER Mapper,
    IN DWORD    CredentialType,
    VOID const *pCredential,
    VOID const *pAuthority,
    OUT HLOCATOR * phLocator);

 DWORD WINAPI
SslLocalCloseLocator(
    IN PHMAPPER Mapper,
    IN HLOCATOR Locator);

 DWORD WINAPI
SslLocalGetAccessToken(
    IN PHMAPPER Mapper,
    IN HLOCATOR Locator,
    OUT HANDLE *Token);

MAPPER_VTABLE   SslLocalTable = { SslLocalRefMapper,
                                  SslLocalDerefMapper,
                                  SslLocalGetIssuerList,
                                  SslLocalGetChallenge,
                                  SslLocalMapCredential,
                                  SslLocalGetAccessToken,
                                  SslLocalCloseLocator
                                };

MAPPER_VTABLE   SslRemoteTable = {SslLocalRefMapper,
                                  SslLocalDerefMapper,
                                  SslLocalGetIssuerList,
                                  SslLocalGetChallenge,
                                  SslRemoteMapCredential,
                                  SslLocalGetAccessToken,
                                  SslLocalCloseLocator
                                };


MAPPER_VTABLE   SslUserModeTable = {
                                  SslLocalRefMapper,
                                  SslLocalDerefMapper,
                                  NULL,
                                  NULL,
                                  NULL,
                                  SslLocalGetAccessToken,
                                  SslLocalCloseLocator
                                    };


typedef struct _SSL_MAPPER_CONTEXT {
    HMAPPER     Mapper ;
    LONG        Ref ;

} SSL_MAPPER_CONTEXT, * PSSL_MAPPER_CONTEXT ;


NTSTATUS
WINAPI
SslBuildCertLogonRequest(
    PCCERT_CHAIN_CONTEXT pChainContext,
    DWORD dwMethods,
    PSSL_CERT_LOGON_REQ *ppRequest,
    PDWORD pcbRequest);

NTSTATUS
WINAPI
SslMapCertAtDC(
    PUNICODE_STRING DomainName,
    VOID const *pCredential,
    DWORD cbCredential,
    PMSV1_0_PASSTHROUGH_RESPONSE * DcResponse 
    );

PWSTR SslDnsDomainName ;
SECURITY_STRING SslNullString = { 0, sizeof( WCHAR ), L"" };


PHMAPPER
SslGetMapper(
    BOOL Ignored
    )
{
    PSSL_MAPPER_CONTEXT Context ;
    NTSTATUS Status ;
    NT_PRODUCT_TYPE ProductType ;
    BOOL DC ;

    if ( RtlGetNtProductType( &ProductType ) )
    {
        DC = (ProductType == NtProductLanManNt );
    }
    else
    {
        return NULL ;
    }

    Context = (PSSL_MAPPER_CONTEXT) SPExternalAlloc( sizeof( SSL_MAPPER_CONTEXT ) );

    if ( Context )
    {
        Context->Mapper.m_dwMapperVersion = MAPPER_INTERFACE_VER ;
        Context->Mapper.m_dwFlags         = SCH_FLAG_SYSTEM_MAPPER ;
        Context->Mapper.m_Reserved1       = NULL ;

        Context->Ref = 0;


        if ( DC )
        {
            Context->Mapper.m_vtable = &SslLocalTable ;
        }
        else
        {
            Context->Mapper.m_vtable = &SslRemoteTable ;
        }

        return &Context->Mapper ;
    }
    else
    {
        return NULL ;
    }
}


LONG
WINAPI
SslLocalRefMapper(
    PHMAPPER    Mapper
    )
{
    PSSL_MAPPER_CONTEXT Context ;

    Context = (PSSL_MAPPER_CONTEXT) Mapper ;

    if ( Context == NULL )
    {
        return( -1 );
    }

    DebugLog(( DEB_TRACE_MAPPER, "Ref of Context %x\n", Mapper ));

    return( InterlockedIncrement( &Context->Ref ) );

}

LONG
WINAPI
SslLocalDerefMapper(
    PHMAPPER    Mapper
    )
{
    PSSL_MAPPER_CONTEXT Context ;
    DWORD RefCount;

    Context = (PSSL_MAPPER_CONTEXT) Mapper ;

    if ( Context == NULL )
    {
        return( -1 );
    }

    DebugLog(( DEB_TRACE_MAPPER, "Deref of Context %x\n", Mapper ));

    RefCount = InterlockedDecrement( &Context->Ref );

    if(RefCount == 0)
    {
        SPExternalFree(Context);
    }

    return RefCount;
}

DWORD
WINAPI
SslLocalGetIssuerList(
    IN PHMAPPER Mapper,
    IN PVOID    Reserved,
    OUT PBYTE   pIssuerList,
    OUT PDWORD  IssuerListLength
    )
{
    DebugLog(( DEB_TRACE_MAPPER, "GetIssuerList, context %x\n", Mapper ));

    return( GetDefaultIssuers(pIssuerList, IssuerListLength) );
}


DWORD
WINAPI
SslLocalGetChallenge(
    IN PHMAPPER Mapper,
    IN PUCHAR   AuthenticatorId,
    IN DWORD    AuthenticatorIdLength,
    OUT PUCHAR  Challenge,
    OUT DWORD * ChallengeLength
    )
{
    DebugLog(( DEB_TRACE_MAPPER, "GetChallenge, context %x\n", Mapper ));

    return SEC_E_UNSUPPORTED_FUNCTION;
}


SECURITY_STATUS
SslCreateTokenFromPac(
    PUCHAR  AuthInfo,
    ULONG   AuthInfoLength,
    PUNICODE_STRING Domain,
    PLUID   NewLogonId,
    PHANDLE NewToken
    )
{
    NTSTATUS Status ;
    PVOID   TokenInfo ;
    LSA_TOKEN_INFORMATION_TYPE TokenInfoType ;
    PLSA_TOKEN_INFORMATION_V1 TokenV1 ;
    PLSA_TOKEN_INFORMATION_NULL TokenNull ;
    LUID LogonId ;
    HANDLE TokenHandle ;
    NTSTATUS SubStatus ;
    SECURITY_STRING PacUserName ;

    //
    // Get the marshalled blob into a more useful form:
    //

    PacUserName.Buffer = NULL ;

    Status = LsaTable->ConvertAuthDataToToken(
                            AuthInfo,
                            AuthInfoLength,
                            SecurityImpersonation,
                            &SslTokenSource,
                            Network,
                            Domain,
                            &TokenHandle,
                            &LogonId,
                            &PacUserName,
                            &SubStatus
                            );

    if ( NT_SUCCESS( Status ) )
    {
        LsaTable->AuditLogon(
                        STATUS_SUCCESS,
                        STATUS_SUCCESS,
                        &PacUserName,
                        Domain,
                        NULL,
                        NULL,
                        Network,
                        &SslTokenSource,
                        &LogonId );
    }
    else 
    {
        LsaTable->AuditLogon(
                        Status,
                        Status,
                        &SslNullString,
                        &SslNullString,
                        NULL,
                        NULL,
                        Network,
                        &SslTokenSource,
                        &LogonId );

    }

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }


    *NewToken = TokenHandle ;
    *NewLogonId = LogonId ;


    if ( PacUserName.Buffer )
    {
        LsaTable->FreeLsaHeap( PacUserName.Buffer );
    }

    return Status ;
}

#define ISSUER_HEADER       L"<I>"
#define CCH_ISSUER_HEADER   3
#define SUBJECT_HEADER      L"<S>"
#define CCH_SUBJECT_HEADER  3


//+---------------------------------------------------------------------------
//
//  Function:   SslGetNameFromCertificate
//
//  Synopsis:   Extracts the UPN name from the certificate
//
//  Arguments:  [pCert]         --
//              [ppszName]      --
//              [pfMachineCert] --
//
//  History:    8-8-2000   jbanes   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
SslGetNameFromCertificate(
    PCCERT_CONTEXT  pCert,
    PWSTR *         ppszName,
    BOOL *          pfMachineCert)
{
    ULONG ExtensionIndex;
    PWSTR pszName;
    DWORD cbName;

    *pfMachineCert = FALSE;

    //
    // See if cert has UPN in AltSubjectName->otherName
    //

    pszName = NULL;

    for(ExtensionIndex = 0; 
        ExtensionIndex < pCert->pCertInfo->cExtension; 
        ExtensionIndex++)
    {
        if(strcmp(pCert->pCertInfo->rgExtension[ExtensionIndex].pszObjId,
                  szOID_SUBJECT_ALT_NAME2) == 0)
        {
            PCERT_ALT_NAME_INFO AltName = NULL;
            DWORD               AltNameStructSize = 0;
            ULONG               CertAltNameIndex = 0;
            
            if(CryptDecodeObjectEx(pCert->dwCertEncodingType,
                                X509_ALTERNATE_NAME,
                                pCert->pCertInfo->rgExtension[ExtensionIndex].Value.pbData,
                                pCert->pCertInfo->rgExtension[ExtensionIndex].Value.cbData,
                                CRYPT_DECODE_ALLOC_FLAG,
                                NULL,
                                (PVOID)&AltName,
                                &AltNameStructSize))
            {

                for(CertAltNameIndex = 0; CertAltNameIndex < AltName->cAltEntry; CertAltNameIndex++)
                {
                    PCERT_ALT_NAME_ENTRY AltNameEntry = &AltName->rgAltEntry[CertAltNameIndex];

                    if((CERT_ALT_NAME_OTHER_NAME == AltNameEntry->dwAltNameChoice) &&
                       (NULL != AltNameEntry->pOtherName) &&
                       (0 == strcmp(szOID_NT_PRINCIPAL_NAME, AltNameEntry->pOtherName->pszObjId)))
                    {
                        PCERT_NAME_VALUE PrincipalNameBlob = NULL;
                        DWORD            PrincipalNameBlobSize = 0;

                        // We found a UPN!
                        if(CryptDecodeObjectEx(pCert->dwCertEncodingType,
                                            X509_UNICODE_ANY_STRING,
                                            AltNameEntry->pOtherName->Value.pbData,
                                            AltNameEntry->pOtherName->Value.cbData,
                                            CRYPT_DECODE_ALLOC_FLAG,
                                            NULL,
                                            (PVOID)&PrincipalNameBlob,
                                            &PrincipalNameBlobSize))
                        {
                            pszName = LocalAlloc(LPTR, PrincipalNameBlob->Value.cbData + sizeof(WCHAR));
                            if(pszName != NULL)
                            {
                                CopyMemory(pszName, PrincipalNameBlob->Value.pbData, PrincipalNameBlob->Value.cbData);
                            }

                            LocalFree(PrincipalNameBlob);
                            PrincipalNameBlob = NULL;

                            if(pszName == NULL)
                            {
                                LocalFree(AltName);
                                return STATUS_NO_MEMORY;
                            }
                        }
                        if(pszName)
                        {
                            break;
                        }
                    }
                }
                LocalFree(AltName);
                AltName = NULL;

                if(pszName)
                {
                    break;
                }
            }
        }
    }


    //
    // See if cert has DNS in AltSubjectName->pwszDNSName
    //

    if(pszName == NULL)
    {
        for(ExtensionIndex = 0; 
            ExtensionIndex < pCert->pCertInfo->cExtension; 
            ExtensionIndex++)
        {
            if(strcmp(pCert->pCertInfo->rgExtension[ExtensionIndex].pszObjId,
                      szOID_SUBJECT_ALT_NAME2) == 0)
            {
                PCERT_ALT_NAME_INFO AltName = NULL;
                DWORD               AltNameStructSize = 0;
                ULONG               CertAltNameIndex = 0;
            
                if(CryptDecodeObjectEx(pCert->dwCertEncodingType,
                                    X509_ALTERNATE_NAME,
                                    pCert->pCertInfo->rgExtension[ExtensionIndex].Value.pbData,
                                    pCert->pCertInfo->rgExtension[ExtensionIndex].Value.cbData,
                                    CRYPT_DECODE_ALLOC_FLAG,
                                    NULL,
                                    (PVOID)&AltName,
                                    &AltNameStructSize))
                {

                    for(CertAltNameIndex = 0; CertAltNameIndex < AltName->cAltEntry; CertAltNameIndex++)
                    {
                        PCERT_ALT_NAME_ENTRY AltNameEntry = &AltName->rgAltEntry[CertAltNameIndex];

                        if((CERT_ALT_NAME_DNS_NAME == AltNameEntry->dwAltNameChoice) &&
                           (NULL != AltNameEntry->pwszDNSName))
                        {
                            PCERT_NAME_VALUE PrincipalNameBlob = NULL;
                            DWORD            PrincipalNameBlobSize = 0;

                            // We found a DNS!
                            cbName = (wcslen(AltNameEntry->pwszDNSName) + 1) * sizeof(WCHAR);

                            pszName = LocalAlloc(LPTR, cbName);
                            if(pszName == NULL)
                            {
                                LocalFree(AltName);
                                return STATUS_NO_MEMORY;
                            }

                            CopyMemory(pszName, AltNameEntry->pwszDNSName, cbName);
                            *pfMachineCert = TRUE;
                            break;
                        }
                    }
                    LocalFree(AltName);
                    AltName = NULL;

                    if(pszName)
                    {
                        break;
                    }
                }
            }
        }
    }


    //
    // There was no UPN in the AltSubjectName, so look for
    // one in the Subject Name, in case this is a B3 compatability
    // cert.
    //

    if(pszName == NULL)
    {
        ULONG Length;

        Length = CertGetNameString( pCert,
                                    CERT_NAME_ATTR_TYPE,
                                    0,
                                    szOID_COMMON_NAME,
                                    NULL,
                                    0 );

        if(Length)
        {
            pszName = LocalAlloc(LPTR, Length * sizeof(WCHAR));

            if(!pszName)
            {
                return STATUS_NO_MEMORY ;
            }

            if ( !CertGetNameStringW(pCert,
                                    CERT_NAME_ATTR_TYPE,
                                    0,
                                    szOID_COMMON_NAME,
                                    pszName,
                                    Length))
            {
                return GetLastError();
            }
        }
    }

    
    if(pszName)
    {
        *ppszName = pszName;
    }
    else
    {
        return STATUS_NOT_FOUND;
    }

    return STATUS_SUCCESS;
}


//+---------------------------------------------------------------------------
//
//  Function:   SslTryUpn
//
//  Synopsis:   Tries to find the user by UPN encoded in Cert
//
//  Arguments:  [User]        --
//              [AuthData]    --
//              [AuthDataLen] --
//
//  History:    5-11-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
SslTryUpn(
    PCCERT_CONTEXT User,
    PUCHAR * AuthData,
    PULONG AuthDataLen,
    PWSTR * ReferencedDomain
    )
{
    NTSTATUS Status ;
    UNICODE_STRING Upn = {0, 0, NULL};
    UNICODE_STRING Cracked = {0};
    UNICODE_STRING DnsDomain = {0};
    UNICODE_STRING FlatName = { 0 };
    ULONG SubStatus ;
    BOOL fMachineCert;
    PWSTR pszName = NULL;


    *ReferencedDomain = NULL ;


    //
    // Get the client name from the cert
    //

    Status = SslGetNameFromCertificate(User, &pszName, &fMachineCert);

    if(!NT_SUCCESS(Status))
    {
        return Status;
    }


    //
    // now, try and find this guy:
    //

    if(fMachineCert)
    {
        Status = STATUS_NOT_FOUND;
    }
    else
    {
        // Search for "username@foo.com".
        Upn.Buffer = pszName;
        Upn.Length = wcslen(Upn.Buffer) * sizeof(WCHAR);
        Upn.MaximumLength = Upn.Length + sizeof(WCHAR);

        DebugLog(( DEB_TRACE_MAPPER, "Looking for UPN name %ws\n", Upn.Buffer ));

        Status = LsaTable->GetAuthDataForUser( &Upn,
                                               SecNameFlat,
                                               NULL,
                                               AuthData,
                                               AuthDataLen,
                                               &FlatName );

        if ( FlatName.Length )
        {
            LsaTable->AuditAccountLogon(
                        SE_AUDITID_ACCOUNT_MAPPED,
                        (BOOLEAN) NT_SUCCESS( Status ),
                        &SslPackageName,
                        &Upn,
                        &FlatName,
                        Status );

            LsaTable->FreeLsaHeap( FlatName.Buffer );
        }
    }


    if ( Status == STATUS_NOT_FOUND )
    {
        //
        // Do the hacky check of seeing if this is our own domain, and
        // if so, try opening the user as a flat, SAM name.
        //

        if(fMachineCert)
        {
            PWSTR pPeriod;
            WCHAR ch;
            
            pPeriod = wcschr( pszName, L'.' );

            if(pPeriod)
            {
                if ( DnsNameCompare_W( (pPeriod+1), SslDnsDomainName ) )
                {
                    ch = *(pPeriod + 1);

                    *pPeriod       = L'$';
                    *(pPeriod + 1) = L'\0';

                    Upn.Buffer = pszName;
                    Upn.Length = wcslen( Upn.Buffer ) * sizeof( WCHAR );
                    Upn.MaximumLength = Upn.Length + sizeof(WCHAR);

                    DebugLog(( DEB_TRACE_MAPPER, "Looking for machine name %ws\n", Upn.Buffer ));

                    // Search for "computer$".
                    Status = LsaTable->GetAuthDataForUser( &Upn,
                                                           SecNameSamCompatible,
                                                           NULL,
                                                           AuthData,
                                                           AuthDataLen,
                                                           NULL );

                    *pPeriod = L'.';
                    *(pPeriod + 1) = ch;
                }
            }
        }
        else
        {
            PWSTR AtSign;
            
            AtSign = wcschr( pszName, L'@' );

            if ( AtSign )
            {
                if ( DnsNameCompare_W( (AtSign+1), SslDnsDomainName ) )
                {
                    *AtSign = L'\0';

                    Upn.Buffer = pszName;
                    Upn.Length = wcslen( Upn.Buffer ) * sizeof( WCHAR );
                    Upn.MaximumLength = Upn.Length + sizeof(WCHAR);

                    DebugLog(( DEB_TRACE_MAPPER, "Looking for user name %ws\n", Upn.Buffer ));

                    // Search for "username".
                    Status = LsaTable->GetAuthDataForUser( &Upn,
                                                           SecNameSamCompatible,
                                                           NULL,
                                                           AuthData,
                                                           AuthDataLen,
                                                           NULL );

                    *AtSign = L'@';
                }
            }
        }

        if (Status == STATUS_NOT_FOUND )
        {
            Upn.Buffer = pszName;
            Upn.Length = wcslen(Upn.Buffer) * sizeof(WCHAR);
            Upn.MaximumLength = Upn.Length + sizeof(WCHAR);

            DebugLog(( DEB_TRACE_MAPPER, "Cracking name %ws at GC\n", Upn.Buffer ));

            Status = LsaTable->CrackSingleName(
                                DS_USER_PRINCIPAL_NAME,
                                TRUE,
                                &Upn,
                                NULL,
                                DS_NT4_ACCOUNT_NAME,
                                &Cracked,
                                &DnsDomain,
                                &SubStatus );

            if ( NT_SUCCESS( Status ) )
            {
                if ( SubStatus == 0 )
                {
                    *ReferencedDomain = DnsDomain.Buffer ;
                    DnsDomain.Buffer = NULL;
                }

                if(Cracked.Buffer != NULL)
                {
                    LsaTable->FreeLsaHeap( Cracked.Buffer );
                }
                if(DnsDomain.Buffer != NULL)
                {
                    LsaTable->FreeLsaHeap( DnsDomain.Buffer );
                }

                Status = STATUS_NOT_FOUND ;
            }

        }

    }

    if(pszName)
    {
        LocalFree(pszName);
    }

    return Status ;
}



void
ConvertNameString(UNICODE_STRING *Name)
{
    PWSTR Comma1, Comma2;

    //
    // Scan through the name, converting "\r\n" to ",".  This should be 
    // done by the CertNameToStr APIs, but that won't happen for a while.
    //

    Comma1 = Comma2 = Name->Buffer ;
    while ( *Comma2 )
    {
        *Comma1 = *Comma2 ;

        if ( *Comma2 == L'\r' )
        {
            if ( *(Comma2 + 1) == L'\n' )
            {
                *Comma1 = L',';
                Comma2++ ;
            }
        }

        Comma1++;
        Comma2++;
    }

    *Comma1 = L'\0';

    Name->Length = wcslen( Name->Buffer ) * sizeof( WCHAR );
}

//+---------------------------------------------------------------------------
//
//  Function:   SslTryCompoundName
//
//  Synopsis:   Tries to find the user by concatenating the issuer and subject
//              names, and looking for an AlternateSecurityId.
//
//  Arguments:  [User]        --
//              [AuthData]    --
//              [AuthDataLen] --
//
//  History:    5-11-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
SslTryCompoundName(
    PCCERT_CONTEXT User,
    PUCHAR * AuthData,
    PULONG AuthDataLen,
    PWSTR * ReferencedDomain 
    )
{
    UNICODE_STRING CompoundName ;
    ULONG Length ;
    ULONG IssuerLength ;
    NTSTATUS Status ;
    PWSTR Current ;
    PWSTR Comma1, Comma2 ;
    UNICODE_STRING Cracked = {0};
    UNICODE_STRING DnsDomain = {0};
    UNICODE_STRING FlatName = { 0 };
    ULONG SubStatus ;
    const DWORD dwNameToStrFlags = CERT_X500_NAME_STR | 
                                   CERT_NAME_STR_NO_PLUS_FLAG | 
                                   CERT_NAME_STR_CRLF_FLAG;

    *ReferencedDomain = NULL ;

    IssuerLength = CertNameToStr( User->dwCertEncodingType,
                                   &User->pCertInfo->Issuer,
                                   dwNameToStrFlags,
                                   NULL,
                                   0 );

    Length = CertNameToStr( User->dwCertEncodingType,
                            &User->pCertInfo->Subject,
                            dwNameToStrFlags,
                            NULL,
                            0 );

    if ( ( IssuerLength == 0 ) ||
         ( Length == 0 ) )
    {
        return STATUS_NO_MEMORY ;
    }

    CompoundName.MaximumLength = (USHORT) (Length + IssuerLength +
                                 CCH_ISSUER_HEADER + CCH_SUBJECT_HEADER) *
                                 sizeof( WCHAR ) ;

    CompoundName.Buffer = LocalAlloc( LMEM_FIXED, CompoundName.MaximumLength );

    if ( CompoundName.Buffer )
    {
        wcscpy( CompoundName.Buffer, ISSUER_HEADER );
        Current = CompoundName.Buffer + CCH_ISSUER_HEADER ;

        IssuerLength = CertNameToStrW( User->dwCertEncodingType,
                                   &User->pCertInfo->Issuer,
                                   dwNameToStrFlags,
                                   Current,
                                   IssuerLength );

        Current += IssuerLength - 1 ;
        wcscpy( Current, SUBJECT_HEADER );
        Current += CCH_SUBJECT_HEADER ;

        Length = CertNameToStrW( User->dwCertEncodingType,
                            &User->pCertInfo->Subject,
                            dwNameToStrFlags,
                            Current,
                            Length );

        ConvertNameString(&CompoundName);

        Status = LsaTable->GetAuthDataForUser( &CompoundName,
                                               SecNameAlternateId,
                                               &SslNamePrefix,
                                               AuthData,
                                               AuthDataLen,
                                               &FlatName );

        if ( FlatName.Length )
        {
            LsaTable->AuditAccountLogon(
                        SE_AUDITID_ACCOUNT_MAPPED,
                        (BOOLEAN) NT_SUCCESS( Status ),
                        &SslPackageName,
                        &CompoundName,
                        &FlatName,
                        Status );

            LsaTable->FreeLsaHeap( FlatName.Buffer );
        }

        if ( Status == STATUS_NOT_FOUND )
        {
            Status = LsaTable->CrackSingleName(
                                    DS_ALT_SECURITY_IDENTITIES_NAME,
                                    TRUE,
                                    &CompoundName,
                                    &SslNamePrefix,
                                    DS_NT4_ACCOUNT_NAME,
                                    &Cracked,
                                    &DnsDomain,
                                    &SubStatus );

            if ( NT_SUCCESS( Status ) )
            {
                if ( SubStatus == 0 )
                {
                    *ReferencedDomain = DnsDomain.Buffer ;
                    DnsDomain.Buffer = NULL;
                }

                if(Cracked.Buffer != NULL)
                {
                    LsaTable->FreeLsaHeap( Cracked.Buffer );
                }
                if(DnsDomain.Buffer != NULL)
                {
                    LsaTable->FreeLsaHeap( DnsDomain.Buffer );
                }

                Status = STATUS_NOT_FOUND ;
            }

        }

        LocalFree( CompoundName.Buffer );
    }
    else
    {
        Status = STATUS_NO_MEMORY ;
    }

    return Status ;


}

//+---------------------------------------------------------------------------
//
//  Function:   SslTryIssuer
//
//  Synopsis:   Tries to find a user that has an issuer mapped to it.
//
//  Arguments:  [User]        --
//              [AuthData]    --
//              [AuthDataLen] --
//
//  History:    5-11-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
SslTryIssuer(
    PBYTE pIssuer,
    DWORD cbIssuer,
    PUCHAR * AuthData,
    PULONG AuthDataLen,
    PWSTR * ReferencedDomain
    )
{
    UNICODE_STRING IssuerName ;
    ULONG IssuerLength ;
    NTSTATUS Status ;
    UNICODE_STRING Cracked = { 0 };
    UNICODE_STRING DnsDomain = { 0 };
    UNICODE_STRING FlatName = { 0 };
    ULONG SubStatus ;
    const DWORD dwNameToStrFlags = CERT_X500_NAME_STR | 
                                   CERT_NAME_STR_NO_PLUS_FLAG | 
                                   CERT_NAME_STR_CRLF_FLAG;
    CERT_NAME_BLOB Issuer;

    *ReferencedDomain = NULL ;

    Issuer.pbData = pIssuer;
    Issuer.cbData = cbIssuer;

    IssuerLength = CertNameToStr( CRYPT_ASN_ENCODING,
                                  &Issuer,
                                  dwNameToStrFlags,
                                  NULL,
                                  0 );

    if ( IssuerLength == 0 )
    {
        return STATUS_NO_MEMORY ;
    }

    IssuerName.MaximumLength = (USHORT)(CCH_ISSUER_HEADER + IssuerLength) * sizeof( WCHAR ) ;

    IssuerName.Buffer = LocalAlloc( LMEM_FIXED, IssuerName.MaximumLength );

    if ( IssuerName.Buffer )
    {
        wcscpy( IssuerName.Buffer, ISSUER_HEADER );

        IssuerLength = CertNameToStrW(CRYPT_ASN_ENCODING,
                                     &Issuer,
                                     dwNameToStrFlags,
                                     IssuerName.Buffer + CCH_ISSUER_HEADER,
                                     IssuerLength );

        ConvertNameString(&IssuerName);



        Status = LsaTable->GetAuthDataForUser( &IssuerName,
                                               SecNameAlternateId,
                                               &SslNamePrefix,
                                               AuthData,
                                               AuthDataLen,
                                               &FlatName  );

        if ( FlatName.Length )
        {
            LsaTable->AuditAccountLogon(
                        SE_AUDITID_ACCOUNT_MAPPED,
                        (BOOLEAN) NT_SUCCESS( Status ),
                        &SslPackageName,
                        &IssuerName,
                        &FlatName,
                        Status );

            LsaTable->FreeLsaHeap( FlatName.Buffer );
        }

        if ( Status == STATUS_NOT_FOUND )
        {
            Status = LsaTable->CrackSingleName(
                                    DS_ALT_SECURITY_IDENTITIES_NAME,
                                    TRUE,
                                    &IssuerName,
                                    &SslNamePrefix,
                                    DS_NT4_ACCOUNT_NAME,
                                    &Cracked,
                                    &DnsDomain,
                                    &SubStatus );

            if ( NT_SUCCESS( Status ) )
            {
                if ( SubStatus == 0 )
                {
                    *ReferencedDomain = DnsDomain.Buffer ;
                    DnsDomain.Buffer = NULL;
                }

                if(Cracked.Buffer != NULL)
                {
                    LsaTable->FreeLsaHeap( Cracked.Buffer );
                }
                if(DnsDomain.Buffer != NULL)
                {
                    LsaTable->FreeLsaHeap( DnsDomain.Buffer );
                }

                Status = STATUS_NOT_FOUND ;
            }

        }

        LocalFree(IssuerName.Buffer);
    }
    else
    {
        Status = STATUS_NO_MEMORY ;
    }

    return Status ;

}

//+---------------------------------------------------------------------------
//
//  Function:   SslMapCertToUserPac
//
//  Synopsis:   Maps a certificate to a user (hopefully) and the PAC,
//
//  Arguments:  [Request]       --
//              [UserPac]       --
//              [UserPacLen]    --
//
//  History:    5-11-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
SslMapCertToUserPac(
    IN PSSL_CERT_LOGON_REQ Request,
    OUT PUCHAR * UserPac,
    OUT PULONG UserPacLen, 
    OUT PWSTR * ReferencedDomain
    )
{
    PCCERT_CONTEXT User ;
    NTSTATUS Status = STATUS_LOGON_FAILURE;
    NTSTATUS SubStatus = STATUS_NOT_FOUND;
    UNICODE_STRING UserName ;
    HANDLE UserHandle ;
    ULONG i;

    *ReferencedDomain = NULL;

    DebugLog(( DEB_TRACE_MAPPER, "SslMapCertToUserPac called\n" ));

    User = CertCreateCertificateContext( X509_ASN_ENCODING,
                                         (PBYTE)Request + Request->OffsetCertificate,
                                         Request->CertLength );

    if ( !User )
    {
        Status = STATUS_NO_MEMORY ;

        goto Cleanup ;
    }


    //
    // First, try the UPN
    //


    if(Request->Flags & REQ_UPN_MAPPING)
    {
        DebugLog(( DEB_TRACE_MAPPER, "Trying UPN mapping\n" ));

        Status = SslTryUpn( User, 
                            UserPac, 
                            UserPacLen,
                            ReferencedDomain );

        if ( NT_SUCCESS( Status ) ||
             ( *ReferencedDomain ) )
        {
            goto Cleanup;
        }

        DebugLog(( DEB_TRACE_MAPPER, "Failed with error 0x%x\n", Status ));
    }


    //
    // Swing and a miss.  Try the constructed issuer+subject name
    //

    
    if(Request->Flags & REQ_SUBJECT_MAPPING)
    {
        DebugLog(( DEB_TRACE_MAPPER, "Trying Subject mapping\n" ));

        Status = SslTryCompoundName( User, 
                                     UserPac, 
                                     UserPacLen,
                                     ReferencedDomain );

        if ( NT_SUCCESS( Status ) ||
             ( *ReferencedDomain ) )
        {
            goto Cleanup;
        }

        DebugLog(( DEB_TRACE_MAPPER, "Failed with error 0x%x\n", Status ));

        // Return error code from issuer+subject name mapping
        // in preference to the error code from many-to-one mapping.
        SubStatus = Status;
    }


    //
    // Strike two.  Try the issuer for a many-to-one mapping:
    //

    if(Request->Flags & REQ_ISSUER_MAPPING)
    {
        DebugLog(( DEB_TRACE_MAPPER, "Trying issuer mapping\n" ));

        if(Request->Flags & REQ_ISSUER_CHAIN_MAPPING)
        {
            // Loop through each issuer in the certificate chain.
            for(i = 0; i < Request->CertCount; i++)
            {
                Status = SslTryIssuer( (PBYTE)Request + Request->NameInfo[i].IssuerOffset, 
                                       Request->NameInfo[i].IssuerLength,
                                       UserPac, 
                                       UserPacLen,
                                       ReferencedDomain );

                if ( NT_SUCCESS( Status ) ||
                     ( *ReferencedDomain ) )
                {
                    goto Cleanup;
                }
            }
        }
        else
        {
            // Extract the issuer name from the certificate and try
            // to map it.
            Status = SslTryIssuer( User->pCertInfo->Issuer.pbData,
                                   User->pCertInfo->Issuer.cbData, 
                                   UserPac, 
                                   UserPacLen,
                                   ReferencedDomain );

            if ( NT_SUCCESS( Status ) ||
                 ( *ReferencedDomain ) )
            {
                goto Cleanup;
            }
        }

        DebugLog(( DEB_TRACE_MAPPER, "Failed with error 0x%x\n", Status ));
    }


    //
    // Certificate mapping failed. Decide what error code to return.
    //

    if(Status == STATUS_OBJECT_NAME_COLLISION ||
       SubStatus == STATUS_OBJECT_NAME_COLLISION)
    {
        Status = SEC_E_MULTIPLE_ACCOUNTS;
    }
    else if(Status != STATUS_NO_MEMORY)
    {
        Status = STATUS_LOGON_FAILURE ;
    }


Cleanup:

    if ( User )
    {
        CertFreeCertificateContext( User );
    }

    DebugLog(( DEB_TRACE_MAPPER, "SslMapCertToUserPac returned 0x%x\n", Status ));

    return Status ;
}


DWORD
WINAPI
MapperVerifyClientChain(
    PCCERT_CONTEXT  pCertContext,
    DWORD           dwMapperFlags,
    DWORD *         pdwMethods,
    NTSTATUS *      pVerifyStatus,
    PCCERT_CHAIN_CONTEXT *ppChainContext)   // optional
{
    DWORD dwCertFlags    = 0;
    DWORD dwIgnoreErrors = 0;
    NTSTATUS Status;

    *pdwMethods    = 0;
    *pVerifyStatus = STATUS_SUCCESS;

    DebugLog(( DEB_TRACE_MAPPER, "Checking to see if cert is verified.\n" ));

    if(dwMapperFlags & SCH_FLAG_REVCHECK_END_CERT)
        dwCertFlags |= CERT_CHAIN_REVOCATION_CHECK_END_CERT;
    if(dwMapperFlags & SCH_FLAG_REVCHECK_CHAIN)
        dwCertFlags |= CERT_CHAIN_REVOCATION_CHECK_CHAIN;
    if(dwMapperFlags & SCH_FLAG_REVCHECK_CHAIN_EXCLUDE_ROOT)
        dwCertFlags |= CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT;
    if(dwMapperFlags & SCH_FLAG_IGNORE_NO_REVOCATION_CHECK)
        dwIgnoreErrors |= CRED_FLAG_IGNORE_NO_REVOCATION_CHECK;
    if(dwMapperFlags & SCH_FLAG_IGNORE_REVOCATION_OFFLINE)
        dwIgnoreErrors |= CRED_FLAG_IGNORE_REVOCATION_OFFLINE;


    // Check to see if the certificate chain is properly signed all the way
    // up and that we trust the issuer of the root certificate.
    Status = VerifyClientCertificate(pCertContext, 
                                     dwCertFlags, 
                                     dwIgnoreErrors,
                                     CERT_CHAIN_POLICY_SSL, 
                                     ppChainContext);
    if(!NT_SUCCESS(Status))
    {
        DebugLog((DEB_WARN, "Client certificate failed to verify with SSL policy (0x%x)\n", Status));
        LogBogusClientCertEvent(pCertContext, Status);
        return Status;
    }

    // Turn on Subject and Issuer mapping.
    *pdwMethods |= REQ_SUBJECT_MAPPING | REQ_ISSUER_MAPPING;


    // Check to see if the certificate chain is valid for UPN mapping.
    Status = VerifyClientCertificate(pCertContext, 
                                     dwCertFlags, 
                                     dwIgnoreErrors,
                                     CERT_CHAIN_POLICY_NT_AUTH,
                                     NULL);
    if(NT_SUCCESS(Status))
    {
        // Turn on UPN mapping.
        *pdwMethods |= REQ_UPN_MAPPING;
    }
    else
    {
        DebugLog((DEB_WARN, "Client certificate failed to verify with NT_AUTH policy (0x%x)\n", Status));
        LogFastMappingFailureEvent(pCertContext, Status);
        *pVerifyStatus = Status;
    }

    DebugLog((DEB_TRACE, "Client certificate verified with methods: 0x%x\n", *pdwMethods));

    return SEC_E_OK;
}


DWORD
WINAPI
SslLocalMapCredential(
    IN PHMAPPER Mapper,
    IN DWORD    CredentialType,
    VOID const *pCredential,
    VOID const *pAuthority,
    OUT HLOCATOR * phLocator
    )
{
    PCCERT_CONTEXT pCert = (PCERT_CONTEXT)pCredential;
    PMSV1_0_PASSTHROUGH_RESPONSE Response = NULL ;
    PSSL_CERT_LOGON_REQ pRequest = NULL;
    PSSL_CERT_LOGON_RESP CertResp ;
    DWORD cbRequest;
    PUCHAR Pac = NULL ;
    ULONG PacLength ;
    PUCHAR ExpandedPac = NULL ;
    ULONG ExpandedPacLength ;
    NTSTATUS Status ;
    NTSTATUS VerifyStatus ;
    HANDLE Token ;
    LUID LogonId ;
    DWORD dwMethods ;
    PWSTR ReferencedDomain ;
    UNICODE_STRING DomainName ;
    UNICODE_STRING AccountDomain = { 0 };
    PCCERT_CHAIN_CONTEXT pChainContext = NULL;

    DebugLog(( DEB_TRACE_MAPPER, "SslLocalMapCredential, context %x\n", Mapper ));

    if ( CredentialType != X509_ASN_CHAIN )
    {
        return( SEC_E_UNKNOWN_CREDENTIALS );
    }

    //
    // Validate client certificate, and obtain pointer to 
    // entire certificate chain.
    //

    Status = MapperVerifyClientChain(pCert,
                                     Mapper->m_dwFlags,
                                     &dwMethods,
                                     &VerifyStatus,
                                     &pChainContext);
    if(FAILED(Status))             
    {
        return Status;
    }


    //
    // Build the logon request.
    //

    Status = SslBuildCertLogonRequest(pChainContext,
                                      dwMethods,
                                      &pRequest,
                                      &cbRequest);

    CertFreeCertificateChain(pChainContext);
    pChainContext = NULL;

    if(FAILED(Status))
    {
        return Status;
    }


    Status = SslMapCertToUserPac(
                pRequest,
                &Pac,
                &PacLength,
                &ReferencedDomain );

    if ( !NT_SUCCESS( Status ) &&
         ( ReferencedDomain != NULL ) )
    {
        //
        // Didn't find it at this DC, but another domain appears to
        // have the mapping.  Forward it there:
        //

        RtlInitUnicodeString( &DomainName, ReferencedDomain );

        Status = SslMapCertAtDC(
                    &DomainName,
                    pRequest,
                    pRequest->Length,
                    &Response );

        if ( NT_SUCCESS( Status ) )
        {
            CertResp = (PSSL_CERT_LOGON_RESP) Response->ValidationData ;
            Pac = (((PUCHAR) CertResp) + CertResp->OffsetAuthData);
            PacLength = CertResp->AuthDataLength ;

            //
            // older servers (pre 2010 or so) won't return the full structure,
            // so we need to examine it carefully.

            if ( CertResp->Length - CertResp->AuthDataLength <= sizeof( SSL_CERT_LOGON_RESP ))
            {
                AccountDomain = SslDomainName ;
            }
            else 
            {
                if ( CertResp->DomainLength < 65536 )
                {
                    AccountDomain.Length = (USHORT) CertResp->DomainLength ;
                    AccountDomain.MaximumLength = AccountDomain.Length ;
                    AccountDomain.Buffer = (PWSTR) (((PUCHAR) CertResp) + CertResp->OffsetDomain );
                }
                else 
                {
                    AccountDomain = SslDomainName ;
                }
            }
        }

        LsaTable->FreeLsaHeap( ReferencedDomain );

    }
    else
    {
        AccountDomain = SslDomainName ;
    }

    if ( NT_SUCCESS( Status ) )
    {
        Status = LsaTable->ExpandAuthDataForDomain(
                                Pac,
                                PacLength,
                                NULL,
                                &ExpandedPac,
                                &ExpandedPacLength );

        if ( NT_SUCCESS( Status ) )
        {
            //
            // Since we're about to replace the PAC
            // pointer, determine if we got it indirectly
            // (in the response from a remote server)
            // or directly from this DC
            //

            if ( Response == NULL )
            {
                //
                // This is a direct one.  Free the old
                // copy
                //

                LsaTable->FreeLsaHeap( Pac );
            }

            Pac = ExpandedPac ;
            PacLength = ExpandedPacLength ;

            if ( Response == NULL )
            {
                //
                // If we don't have a response, then the pac
                // will get freed.  If it is out of the response
                // then leave it set, and it will be caught in 
                // the cleanup.
                //

                ExpandedPac = NULL  ;
            }
        }   
    }

    if ( NT_SUCCESS( Status ) )
    {


        VerifyStatus = STATUS_SUCCESS;

        Status = SslCreateTokenFromPac( Pac,
                                        PacLength,
                                        &AccountDomain,
                                        &LogonId,
                                        &Token );

        if ( NT_SUCCESS( Status ) )
        {
            *phLocator = (HLOCATOR) Token ;
        }


    }

    if(pRequest)
    {
        LocalFree(pRequest);
    }

    if ( Response )
    {
        LsaTable->FreeReturnBuffer( Response );
    }
    else 
    {
        LsaTable->FreeLsaHeap( Pac );
    }

    if ( ExpandedPac )
    {
        LsaTable->FreeLsaHeap( ExpandedPac );
    }

    if(!NT_SUCCESS(Status))
    {
        DebugLog((DEB_WARN, "Certificate mapping failed (0x%x)\n", Status));

        LogCertMappingFailureEvent(Status);

        if(!NT_SUCCESS(VerifyStatus))
        {
            // Return certificate validation error code, unless the mapper
            // error has already been mapped to a proper sspi error code.
            if(HRESULT_FACILITY(Status) != FACILITY_SECURITY)
            {
                Status = VerifyStatus;
            }
        }
    }

    return ( Status );
}


NTSTATUS
NTAPI
SslDoClientRequest(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLen,
    OUT PVOID * ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status ;
    PSSL_CERT_LOGON_REQ Request ;
    PSSL_CERT_LOGON_RESP Response, IndirectResponse ;
    PUCHAR Pac = NULL ;
    PUCHAR ExpandedPac = NULL ;
    ULONG PacLength ;
    ULONG ExpandedPacLength ;
    PWSTR ReferencedDomain = NULL;
    PWSTR FirstDot ;
    UNICODE_STRING DomainName = { 0 };
    PMSV1_0_PASSTHROUGH_RESPONSE MsvResponse = NULL ;

    DebugLog(( DEB_TRACE_MAPPER, "Handling request to do mapping\n" ));

    if ( ARGUMENT_PRESENT( ProtocolReturnBuffer ) )
    {
        *ProtocolReturnBuffer = NULL ;
    }

    // 
    // Attempt to map the certificate locally.
    //

    Request = (PSSL_CERT_LOGON_REQ) ProtocolSubmitBuffer ;

    Status = SslMapCertToUserPac(
                    Request,
                    &Pac,
                    &PacLength,
                    &ReferencedDomain );

    DebugLog(( DEB_TRACE_MAPPER, "Local lookup returns %x\n", Status ));

    if ( !NT_SUCCESS( Status ) &&
         ( ReferencedDomain != NULL ) )
    {
        //
        // Didn't find it at this DC, but another domain appears to
        // have the mapping.  Forward it there:
        //

        RtlInitUnicodeString( &DomainName, ReferencedDomain );

        DsysAssert( !DnsNameCompare_W( ReferencedDomain, SslDnsDomainName ) );
        DsysAssert( !RtlEqualUnicodeString( &DomainName, &SslDomainName, TRUE ) );

        if ( DnsNameCompare_W( ReferencedDomain, SslDnsDomainName ) ||
             RtlEqualUnicodeString( &DomainName, &SslDomainName, TRUE ) )
        {
            DebugLog(( DEB_TRACE_MAPPER, "GC is out of sync, bailing on this user\n" ));
            Status = STATUS_LOGON_FAILURE ;

        }
        else
        {
            DebugLog(( DEB_TRACE_MAPPER, "Mapping certificate at DC for domain %ws\n", 
                       ReferencedDomain ));

            Status = SslMapCertAtDC(
                        &DomainName,
                        Request,
                        Request->Length,
                        &MsvResponse );

            if ( NT_SUCCESS( Status ) )
            {
                IndirectResponse = (PSSL_CERT_LOGON_RESP) MsvResponse->ValidationData ;

                Pac = (((PUCHAR) IndirectResponse) + IndirectResponse->OffsetAuthData);

                PacLength = IndirectResponse->AuthDataLength ;

                FirstDot = wcschr( ReferencedDomain, L'.' );

                if ( FirstDot )
                {
                    *FirstDot = L'\0';
                    RtlInitUnicodeString( &DomainName, ReferencedDomain );
                }

                if ( IndirectResponse->Length - IndirectResponse->AuthDataLength <= sizeof( SSL_CERT_LOGON_RESP ))
                {
                    //
                    // use the first token from the referenced domain
                    //

                    NOTHING ;

                }
                else 
                {
                    if ( IndirectResponse->DomainLength < 65536 )
                    {
                        DomainName.Length = (USHORT) IndirectResponse->DomainLength ;
                        DomainName.MaximumLength = DomainName.Length ;
                        DomainName.Buffer = (PWSTR) (((PUCHAR) IndirectResponse) + IndirectResponse->OffsetDomain );
                    }
                    else 
                    {
                        NOTHING ;
                    }
                }
            }

        }

    }
    else 
    {
        DomainName = SslDomainName ;
    }

    if ( NT_SUCCESS( Status ) )
    {
        //
        // expand resource groups
        //

        Status = LsaTable->ExpandAuthDataForDomain(
                                Pac,
                                PacLength,
                                NULL,
                                &ExpandedPac,
                                &ExpandedPacLength );

        if ( NT_SUCCESS( Status ) )
        {
            //
            // Careful manipulation of pointers to handle
            // the free cases in the cleanup.  This is
            // better explained up one function where
            // the expand call is also made.
            //
            if ( MsvResponse == NULL )
            {
                LsaTable->FreeLsaHeap( Pac );
            }

            Pac = ExpandedPac ;
            PacLength = ExpandedPacLength ;

            if ( MsvResponse == NULL )
            {
                ExpandedPac = NULL ;
            }
        }
    }

    if ( !NT_SUCCESS( Status ) )
    {
        *ReturnBufferLength = 0;
        *ProtocolStatus = Status ;

        Status = STATUS_SUCCESS ;

        goto Cleanup ;

    }

    //
    // Construct the response blob:
    //

    Response = VirtualAlloc(
                    NULL,
                    sizeof( SSL_CERT_LOGON_RESP ) + PacLength + DomainName.Length,
                    MEM_COMMIT,
                    PAGE_READWRITE );

    if ( Response )
    {
        Response->MessageType = SSL_LOOKUP_CERT_MESSAGE;
        Response->Length = sizeof( SSL_CERT_LOGON_RESP ) + 
                            PacLength + DomainName.Length ;

        Response->OffsetAuthData = sizeof( SSL_CERT_LOGON_RESP );
        Response->AuthDataLength = PacLength ;

        RtlCopyMemory(
            ( Response + 1 ),
            Pac,
            PacLength );

        Response->OffsetDomain = sizeof( SSL_CERT_LOGON_RESP ) + PacLength ;
        Response->DomainLength = DomainName.Length ;

        RtlCopyMemory( (PUCHAR) Response + Response->OffsetDomain,
                       DomainName.Buffer,
                       DomainName.Length );

        *ProtocolReturnBuffer = Response ;
        *ReturnBufferLength = Response->Length ;
        *ProtocolStatus = STATUS_SUCCESS ;

        Status = STATUS_SUCCESS ;

    }
    else
    {
        Status = STATUS_NO_MEMORY ;
    }

Cleanup:

    if ( MsvResponse == NULL )
    {
        LsaTable->FreeLsaHeap( Pac );
    }
    else 
    {
        LsaTable->FreeReturnBuffer( MsvResponse );
    }

    if ( ExpandedPac )
    {
        LsaTable->FreeLsaHeap( ExpandedPac );
    }

    if ( ReferencedDomain )
    {
        LsaTable->FreeLsaHeap( ReferencedDomain );
    }


    return Status ;

}

//+---------------------------------------------------------------------------
//
//  Function:   SslBuildCertLogonRequest
//
//  Synopsis:   Builds a certificate logon request to send to the server.
//
//  Arguments:  [pChainContext] --
//              [dwMethods]     --
//              [ppRequest]     --
//              [pcbRequest]    --
//
//  History:    2-26-2001   Jbanes      Created
//
//  Notes:      The certificate data that this function builds
//              looks something like this:
//
//              typedef struct _SSL_CERT_LOGON_REQ {
//                  ULONG MessageType ;
//                  ULONG Length ;
//                  ULONG OffsetCertficate ;
//                  ULONG CertLength ;
//                  ULONG Flags;
//                  ULONG CertCount;
//                  SSL_CERT_NAME_INFO NameInfo[1];
//              } SSL_CERT_LOGON_REQ, * PSSL_CERT_LOGON_REQ ;
//
//              <client certificate>
//              <issuer #1 name>
//              <issuer #2 name>
//              ...
//
//----------------------------------------------------------------------------
NTSTATUS
WINAPI
SslBuildCertLogonRequest(
    PCCERT_CHAIN_CONTEXT pChainContext,
    DWORD dwMethods,
    PSSL_CERT_LOGON_REQ *ppRequest,
    PDWORD pcbRequest)
{
    PCERT_SIMPLE_CHAIN pSimpleChain;
    PCCERT_CONTEXT pCert;
    PCCERT_CONTEXT pCurrentCert;
    PSSL_CERT_LOGON_REQ pCertReq = NULL;
    DWORD Size;
    DWORD Offset;
    DWORD CertCount;
    NTSTATUS Status;
    ULONG i;


    //
    // Compute the request size.
    //

    pSimpleChain = pChainContext->rgpChain[0];

    pCert = pSimpleChain->rgpElement[0]->pCertContext;

    Size = sizeof(SSL_CERT_LOGON_REQ) + 
           pCert->cbCertEncoded;

    CertCount = 0;

    for(i = 0; i < pSimpleChain->cElement; i++)
    {
        pCurrentCert = pSimpleChain->rgpElement[i]->pCertContext;

        if(i > 0)
        {
            // Verify that this is not a root certificate.
            if(CertCompareCertificateName(pCurrentCert->dwCertEncodingType, 
                                          &pCurrentCert->pCertInfo->Issuer,
                                          &pCurrentCert->pCertInfo->Subject))
            {
                break;
            }

            Size += sizeof(SSL_CERT_NAME_INFO);
        }

        Size += pCurrentCert->pCertInfo->Issuer.cbData;
        CertCount++;
    }

    Size = ROUND_UP_COUNT( Size, ALIGN_DWORD );


    // 
    // Build the request.
    //

    pCertReq = (PSSL_CERT_LOGON_REQ)LocalAlloc(LPTR, Size);

    if ( !pCertReq )
    {
        return SEC_E_INSUFFICIENT_MEMORY ;
    }

    Offset = sizeof(SSL_CERT_LOGON_REQ) + (CertCount - 1) * sizeof(SSL_CERT_NAME_INFO);

    pCertReq->MessageType = SSL_LOOKUP_CERT_MESSAGE;
    pCertReq->Length = Size;
    pCertReq->OffsetCertificate = Offset;
    pCertReq->CertLength = pCert->cbCertEncoded;
    pCertReq->Flags = dwMethods | REQ_ISSUER_CHAIN_MAPPING;

    RtlCopyMemory((PBYTE)pCertReq + Offset,
                  pCert->pbCertEncoded,
                  pCert->cbCertEncoded);
    Offset += pCert->cbCertEncoded;

    pCertReq->CertCount = CertCount;

    for(i = 0; i < CertCount; i++)
    {
        pCurrentCert = pSimpleChain->rgpElement[i]->pCertContext;

        pCertReq->NameInfo[i].IssuerOffset = Offset;
        pCertReq->NameInfo[i].IssuerLength = pCurrentCert->pCertInfo->Issuer.cbData;

        RtlCopyMemory((PBYTE)pCertReq + Offset,
                      pCurrentCert->pCertInfo->Issuer.pbData,
                      pCurrentCert->pCertInfo->Issuer.cbData);
        Offset += pCurrentCert->pCertInfo->Issuer.cbData;
    }

    Offset = ROUND_UP_COUNT( Offset, ALIGN_DWORD );

#if DBG
    DsysAssert(Offset == Size);
#endif

    //
    // Return completed request.
    //

    *ppRequest = pCertReq;
    *pcbRequest = Size;

    return STATUS_SUCCESS;
}


//+---------------------------------------------------------------------------
//
//  Function:   SslMapCertAtDC
//
//  Synopsis:   Maps a certificate to a user (hopefully) and the PAC,
//
//  Arguments:  [DomainName]    --
//              [pCredential]   --
//              [cbCredential]  --
//              [DcResponse]    --
//
//  History:    5-11-1998   RichardW    Created
//              2-26-2001   Jbanes      Added certificate chaining support.
//
//  Notes:      The request that gets sent to the DC looks something
//              like this:
//
//              typedef struct _MSV1_0_PASSTHROUGH_REQUEST {
//                  MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
//                  UNICODE_STRING DomainName;
//                  UNICODE_STRING PackageName;
//                  ULONG DataLength;
//                  PUCHAR LogonData;
//                  ULONG Pad ;
//              } MSV1_0_PASSTHROUGH_REQUEST, *PMSV1_0_PASSTHROUGH_REQUEST;
//
//              <domain name>
//              <package name>
//              [ padding ]
//
//              <credential>
//              [ padding ]
//
//----------------------------------------------------------------------------
NTSTATUS
WINAPI
SslMapCertAtDC(
    PUNICODE_STRING DomainName,
    VOID const *pCredential,
    DWORD cbCredential,
    PMSV1_0_PASSTHROUGH_RESPONSE * DcResponse 
    )
{
    PUCHAR Pac ;
    ULONG PacLength ;
    NTSTATUS Status ;
    PMSV1_0_PASSTHROUGH_REQUEST Request ;
    PMSV1_0_PASSTHROUGH_RESPONSE Response ;
    DWORD Size ;
    DWORD RequestSize ;
    DWORD ResponseSize ;
    PUCHAR Where ;
    NTSTATUS SubStatus ;
#if DBG
    DWORD CheckSize2 ;
#endif

    DebugLog(( DEB_TRACE_MAPPER, "Remote call to DC to do the mapping\n" ));

    // Reality check size of certificate.
    if(cbCredential > 0x4000)
    {
        return SEC_E_ILLEGAL_MESSAGE;
    }

    Size = cbCredential;

    Size = ROUND_UP_COUNT( Size, ALIGN_DWORD );

    RequestSize =   DomainName->Length +
                    SslPackageName.Length ;

    RequestSize = ROUND_UP_COUNT( RequestSize, ALIGN_DWORD );

#if DBG
    CheckSize2 = RequestSize ;
#endif

    RequestSize += sizeof( MSV1_0_PASSTHROUGH_REQUEST ) +
                   Size ;


    Request = (PMSV1_0_PASSTHROUGH_REQUEST) LocalAlloc( LMEM_FIXED, RequestSize );

    if ( !Request )
    {
        return SEC_E_INSUFFICIENT_MEMORY ;
    }

    Where = (PUCHAR) (Request + 1);

    Request->MessageType = MsV1_0GenericPassthrough ;
    Request->DomainName = *DomainName ;
    Request->DomainName.Buffer = (LPWSTR) Where ;

    RtlCopyMemory( Where,
                   DomainName->Buffer,
                   DomainName->Length );

    Where += DomainName->Length ;

    Request->PackageName = SslPackageName ;
    Request->PackageName.Buffer = (LPWSTR) Where ;
    RtlCopyMemory( Where,
                   SslPackageName.Buffer,
                   SslPackageName.Length );

    Where += SslPackageName.Length ;

    Where = ROUND_UP_POINTER( Where, ALIGN_DWORD );

#if DBG
    DsysAssert( (((PUCHAR) Request) + CheckSize2 + sizeof( MSV1_0_PASSTHROUGH_REQUEST ) ) 
                                == (PUCHAR) Where );
#endif

    Request->LogonData = Where ;
    Request->DataLength = Size ;

    RtlCopyMemory(  Request->LogonData,
                    pCredential,
                    cbCredential );


    //
    // Now, call through to our DC:
    //


    Status = LsaTable->CallPackage(
                &SslMsvName,
                Request,
                RequestSize,
                &Response,
                &ResponseSize,
                &SubStatus );

    LocalFree( Request );

    if ( !NT_SUCCESS( Status ) )
    {
        DebugLog(( DEB_TRACE_MAPPER, "SslMapCertAtDC returned status 0x%x\n", Status ));
        return Status ;
    }

    if ( !NT_SUCCESS( SubStatus ) )
    {
        DebugLog(( DEB_TRACE_MAPPER, "SslMapCertAtDC returned sub-status 0x%x\n", SubStatus ));
        return SubStatus ;
    }

    *DcResponse = Response ;

    DebugLog(( DEB_TRACE_MAPPER, "SslMapCertAtDC returned 0x%x\n", STATUS_SUCCESS ));

    return STATUS_SUCCESS ;

}


NTSTATUS
NTAPI
SslMapExternalCredential(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLen,
    OUT PVOID * ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    PSSL_EXTERNAL_CERT_LOGON_REQ Request;
    PSSL_EXTERNAL_CERT_LOGON_RESP Response;
    NT_PRODUCT_TYPE ProductType;
    BOOL DC;
    HMAPPER Mapper;
    NTSTATUS Status;
    HANDLE hUserToken = NULL;

    DebugLog(( DEB_TRACE_MAPPER, "SslMapExternalCredential\n" ));

    //
    // Validate the input parameters.
    //

    if ( ARGUMENT_PRESENT( ProtocolReturnBuffer ) )
    {
        *ProtocolReturnBuffer = NULL ;
    }

    Request = (PSSL_EXTERNAL_CERT_LOGON_REQ) ProtocolSubmitBuffer ;

    if(Request->Length != sizeof(SSL_EXTERNAL_CERT_LOGON_REQ))
    {
        return STATUS_INVALID_PARAMETER;
    }


    //
    // Attempt to map the certificate.
    //

    if(RtlGetNtProductType(&ProductType))
    {
        DC = (ProductType == NtProductLanManNt);
    }
    else
    {
        return STATUS_NO_MEMORY ;
    }

    memset(&Mapper, 0, sizeof(Mapper));

    Mapper.m_dwFlags = SCH_FLAG_SYSTEM_MAPPER | Request->Flags;

    if(DC)
    {
        Status = SslLocalMapCredential( &Mapper,
                                        Request->CredentialType,
                                        Request->Credential,
                                        NULL,
                                        (PHLOCATOR)&hUserToken);
    }
    else
    {
        Status = SslRemoteMapCredential(&Mapper,
                                        Request->CredentialType,
                                        Request->Credential,
                                        NULL,
                                        (PHLOCATOR)&hUserToken);
    }

    if(!NT_SUCCESS(Status))
    {
        *ReturnBufferLength = 0;
        *ProtocolStatus = Status;
        Status = STATUS_SUCCESS;
        goto cleanup;
    }


    //
    // Build the response.
    //

    Response = VirtualAlloc(
                    NULL,
                    sizeof(SSL_EXTERNAL_CERT_LOGON_RESP),
                    MEM_COMMIT,
                    PAGE_READWRITE);

    if ( Response )
    {
        Response->MessageType = SSL_LOOKUP_EXTERNAL_CERT_MESSAGE;
        Response->Length = sizeof(SSL_EXTERNAL_CERT_LOGON_RESP);
        Response->UserToken = hUserToken;
        Response->Flags = 0;

        *ProtocolReturnBuffer = Response;
        *ReturnBufferLength = Response->Length;
        *ProtocolStatus = STATUS_SUCCESS;
        hUserToken = NULL;

        Status = STATUS_SUCCESS;
    }
    else
    {
        Status = STATUS_NO_MEMORY;
    }

cleanup:

    if(hUserToken)
    {
        CloseHandle(hUserToken);
    }

    return Status;
}


DWORD
WINAPI
SslRemoteMapCredential(
    IN PHMAPPER Mapper,
    IN DWORD    CredentialType,
    VOID const *pCredential,
    VOID const *pAuthority,
    OUT HLOCATOR * phLocator
    )
{
    PCCERT_CONTEXT pCert = (PCERT_CONTEXT)pCredential;
    PUCHAR Pac ;
    ULONG PacLength ;
    NTSTATUS Status ;
    NTSTATUS VerifyStatus ;
    HANDLE Token ;
    LUID LogonId = { 0 };
    PMSV1_0_PASSTHROUGH_RESPONSE Response ;
    PSSL_CERT_LOGON_RESP CertResp ;
    UNICODE_STRING AccountDomain ;
    DWORD dwMethods;
    PCCERT_CHAIN_CONTEXT pChainContext = NULL;
    PSSL_CERT_LOGON_REQ pRequest = NULL;
    DWORD cbRequest;

    DebugLog(( DEB_TRACE_MAPPER, "SslRemoteMapCredential, context %x\n", Mapper ));

    if ( CredentialType != X509_ASN_CHAIN )
    {
        return( SEC_E_UNKNOWN_CREDENTIALS );
    }


    //
    // Validate client certificate, and obtain pointer to 
    // entire certificate chain.
    //

    Status = MapperVerifyClientChain(pCert,
                                     Mapper->m_dwFlags,
                                     &dwMethods,
                                     &VerifyStatus,
                                     &pChainContext);
    if(FAILED(Status))
    {
        return Status;
    }

    //
    // Build the logon request.
    //

    Status = SslBuildCertLogonRequest(pChainContext,
                                      dwMethods,
                                      &pRequest,
                                      &cbRequest);

    CertFreeCertificateChain(pChainContext);
    pChainContext = NULL;

    if(FAILED(Status))
    {
        return Status;
    }


    //
    // Send the request to the DC.
    //

    Status = SslMapCertAtDC(
                &SslDomainName,
                pRequest,
                cbRequest,
                &Response );

    LocalFree(pRequest);
    pRequest = NULL;

    if ( !NT_SUCCESS( Status ) )
    {
        LsaTable->AuditLogon(
                    Status,
                    VerifyStatus,
                    &SslNullString,
                    &SslNullString,
                    NULL,
                    NULL,
                    Network,
                    &SslTokenSource,
                    &LogonId );

        LogCertMappingFailureEvent(Status);

        if(!NT_SUCCESS(VerifyStatus))
        {
            // Return certificate validation error code, unless the mapper
            // error has already been mapped to a proper sspi error code.
            if(HRESULT_FACILITY(Status) != FACILITY_SECURITY)
            {
                Status = VerifyStatus;
            }
        }

        return Status ;
    }

    //
    // Ok, we got mapping data.  Try to use it:
    //

    CertResp = (PSSL_CERT_LOGON_RESP) Response->ValidationData ;

    //
    // older servers (pre 2010 or so) won't return the full structure,
    // so we need to examine it carefully.

    if ( CertResp->Length - CertResp->AuthDataLength <= sizeof( SSL_CERT_LOGON_RESP ))
    {
        AccountDomain = SslDomainName ;
    }
    else 
    {
        if ( CertResp->DomainLength < 65536 )
        {
            AccountDomain.Length = (USHORT) CertResp->DomainLength ;
            AccountDomain.MaximumLength = AccountDomain.Length ;
            AccountDomain.Buffer = (PWSTR) (((PUCHAR) CertResp) + CertResp->OffsetDomain );
        }
        else 
        {
            AccountDomain = SslDomainName ;
        }
    }

    Status = SslCreateTokenFromPac( (((PUCHAR) CertResp) + CertResp->OffsetAuthData),
                                    CertResp->AuthDataLength,
                                    &AccountDomain,
                                    &LogonId,
                                    &Token );

    if ( NT_SUCCESS( Status ) )
    {
        *phLocator = (HLOCATOR) Token ;
    }
    else
    {
        LogCertMappingFailureEvent(Status);
    }

    LsaTable->FreeReturnBuffer( Response );


    return ( Status );

}


DWORD
WINAPI
SslLocalCloseLocator(
    IN PHMAPPER Mapper,
    IN HLOCATOR Locator
    )
{
    DebugLog(( DEB_TRACE_MAPPER, "CloseLocator, context %x\n", Mapper ));

    NtClose( (HANDLE) Locator );

    return( SEC_E_OK );
}

DWORD
WINAPI
SslLocalGetAccessToken(
    IN PHMAPPER Mapper,
    IN HLOCATOR Locator,
    OUT HANDLE *Token
    )
{
    DebugLog(( DEB_TRACE_MAPPER, "GetAccessToken, context %x\n", Mapper ));

    *Token = (HANDLE) Locator ;

    return( SEC_E_OK );
}


BOOL
SslRelocateToken(
    IN HLOCATOR Locator,
    OUT HLOCATOR * NewLocator)
{
    NTSTATUS Status ;

    Status = LsaTable->DuplicateHandle( (HANDLE) Locator,
                                        (PHANDLE) NewLocator );

    if ( NT_SUCCESS( Status ) )
    {
        return( TRUE );
    }

    return( FALSE );

}

#if 0
DWORD
TestExternalMapper(
    PCCERT_CONTEXT pCertContext)
{
    NTSTATUS Status;
    NTSTATUS AuthPackageStatus;
    SSL_EXTERNAL_CERT_LOGON_REQ Request;
    PSSL_EXTERNAL_CERT_LOGON_RESP pResponse;
    ULONG ResponseLength;
    UNICODE_STRING PackageName;

    //
    // Build request.
    //

    memset(&Request, 0, sizeof(SSL_EXTERNAL_CERT_LOGON_REQ));

    Request.MessageType = SSL_LOOKUP_EXTERNAL_CERT_MESSAGE;
    Request.Length = sizeof(SSL_EXTERNAL_CERT_LOGON_REQ);
    Request.CredentialType = X509_ASN_CHAIN;
    Request.Credential = (PVOID)pCertContext;


    //
    // Call security package (must make call as local system).
    //

    RtlInitUnicodeString(&PackageName, L"Schannel");

    Status = LsaICallPackage(
                                &PackageName,
                                &Request,
                                Request.Length,
                                (PVOID *)&pResponse,
                                &ResponseLength,
                                &AuthPackageStatus
                                );

    if(!NT_SUCCESS(Status))
    {
        return Status;
    }

    if(NT_SUCCESS(AuthPackageStatus))
    {
        //
        // Mapping was successful.
        //




    }

    LsaIFreeReturnBuffer( pResponse );

    return ERROR_SUCCESS;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\lsa\libmain.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       libmain.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8-01-95   RichardW   Created
//              8-13-95   TerenceS   Mutated to PCT
//              1-19-97   jbanes     Remove dead code
//
//----------------------------------------------------------------------------

#include "sslp.h"

HANDLE g_hInstance = NULL;


BOOL
WINAPI
DllMain(
    HINSTANCE       hInstance,
    DWORD           dwReason,
    LPVOID          lpReserved)
{

    HCRYPTPROV hProv;
    BOOL fRet;
    NTSTATUS Status;

    if(dwReason == DLL_PROCESS_ATTACH)
    {
        g_hInstance = hInstance;

        DisableThreadLibraryCalls( hInstance );

        Status = RtlInitializeCriticalSection(&g_InitCritSec);
        if(!NT_SUCCESS(Status))
        {
            return FALSE;
        }

        // We do nothing during attach, we
        // init on first call.

    }
    else if(dwReason == DLL_PROCESS_DETACH)
    {
        // We shutdown schannel if it's
        // not shut down.
        fRet = SchannelShutdown();

        RtlDeleteCriticalSection(&g_InitCritSec);

#if DBG
        UnloadDebugSupport();
#endif 

        return fRet;
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\lsa\package.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       package.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10-02-96   RichardW   Created
//
//----------------------------------------------------------------------------

#include "sslp.h"
#include <ntmsv1_0.h>
#include <wow64t.h>

#define UNISP_NAME_WO     L"Microsoft Unified Security Protocol Provider"
#define SSL2SP_NAME_WO    L"Microsoft SSL"
#define SSL3SP_NAME_WO    L"Microsoft SSL 3.0"
#define PCT1SP_NAME_WO    L"Microsoft PCT"

#define SCHANNEL_PACKAGE_NAME           L"Schannel"
#define SCHANNEL_PACKAGE_COMMENT        L"Schannel Security Package"
#define SCHANNEL_DLL_NAME               L"schannel.dll"

DWORD dwSchannelPackageCapabilities =   SECPKG_FLAG_INTEGRITY           |
                                        SECPKG_FLAG_PRIVACY             |
                                        SECPKG_FLAG_CONNECTION          |
                                        SECPKG_FLAG_MULTI_REQUIRED      |
                                        SECPKG_FLAG_EXTENDED_ERROR      |
                                        SECPKG_FLAG_IMPERSONATION       |
                                        SECPKG_FLAG_ACCEPT_WIN32_NAME   |
                                        // SECPKG_FLAG_NEGOTIABLE          |
                                        SECPKG_FLAG_MUTUAL_AUTH         |
                                        SECPKG_FLAG_STREAM;

BOOL SslGlobalStrongEncryptionPermitted = FALSE;

// List of (QueryContextAttributes) attributes that are to be
// thunked down to the LSA process.
ULONG ThunkedContextLevels[] = {
        SECPKG_ATTR_AUTHORITY,
        SECPKG_ATTR_ISSUER_LIST,
        SECPKG_ATTR_ISSUER_LIST_EX,
        SECPKG_ATTR_LOCAL_CERT_CONTEXT,
        SECPKG_ATTR_LOCAL_CRED,
        SECPKG_ATTR_EAP_KEY_BLOCK,
        SECPKG_ATTR_USE_VALIDATED,
        SECPKG_ATTR_CREDENTIAL_NAME,
        SECPKG_ATTR_TARGET_INFORMATION,
        SECPKG_ATTR_APP_DATA
};


//
// This package exports the following:  A unified ssl/tls/pct provider, 
// and the same unified provider under a different name. We have to
// keep the original one for backward compatibility, but whistler
// components can start using the new friendlier name.
//

SECPKG_FUNCTION_TABLE   SpTable[] = {
        {                                       // The Unified Provider
            NULL,
            NULL,
            SpCallPackage,
            SpLogonTerminated,
            SpCallPackageUntrusted,
            SpCallPackagePassthrough,
            NULL,
            NULL,
            SpInitialize,
            SpShutdown,
            SpUniGetInfo,
            SpAcceptCredentials,
            SpUniAcquireCredentialsHandle,
            SpQueryCredentialsAttributes,
            SpFreeCredentialsHandle,
            SpSaveCredentials,
            SpGetCredentials,
            SpDeleteCredentials,
            SpInitLsaModeContext,
            SpAcceptLsaModeContext,
            SpDeleteContext,
            SpApplyControlToken,
            SpGetUserInfo,
            SpGetExtendedInformation,
            SpLsaQueryContextAttributes,
            NULL,
            NULL,
            SpSetContextAttributes
        },
        {                                       // The Unified Provider
            NULL,
            NULL,
            SpCallPackage,
            SpLogonTerminated,
            SpCallPackageUntrusted,
            SpCallPackagePassthrough,
            NULL,
            NULL,
            SpInitialize,
            SpShutdown,
            SpSslGetInfo,
            SpAcceptCredentials,
            SpUniAcquireCredentialsHandle,
            SpQueryCredentialsAttributes,
            SpFreeCredentialsHandle,
            SpSaveCredentials,
            SpGetCredentials,
            SpDeleteCredentials,
            SpInitLsaModeContext,
            SpAcceptLsaModeContext,
            SpDeleteContext,
            SpApplyControlToken,
            SpGetUserInfo,
            SpGetExtendedInformation,
            SpLsaQueryContextAttributes,
            NULL,
            NULL,
            SpSetContextAttributes
        }
    };


ULONG_PTR SpPackageId;
PLSA_SECPKG_FUNCTION_TABLE LsaTable ;
BOOL    SpInitialized = FALSE ;
HINSTANCE hDllInstance ;
BOOL ReplaceBaseProvider = TRUE;
TOKEN_SOURCE SslTokenSource ;
SECURITY_STRING SslNamePrefix = { 8, 10, L"X509" };
SECURITY_STRING SslComputerName ;
SECURITY_STRING SslDomainName ;
SECURITY_STRING SslPackageName ;
SECURITY_STRING SslMsvName ;
extern PWSTR SslDnsDomainName ;

//+---------------------------------------------------------------------------
//
//  Function:   SpLsaModeInitialize
//
//  Synopsis:   LSA Mode Initialization Function
//
//  Arguments:  [LsaVersion]     --
//                              [PackageVersion] --
//                              [Table]                  --
//                              [TableCount]     --
//
//  History:    10-03-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
SpLsaModeInitialize(
    IN ULONG LsaVersion,
    OUT PULONG PackageVersion,
    OUT PSECPKG_FUNCTION_TABLE * Table,
    OUT PULONG TableCount)
{
    HKEY hKey;
    int err;
    DWORD type;
    DWORD size;

    *PackageVersion = SECPKG_INTERFACE_VERSION_2;
    *Table = SpTable ;
    *TableCount = sizeof( SpTable ) / sizeof( SECPKG_FUNCTION_TABLE );


    return( SEC_E_OK );
}


//+---------------------------------------------------------------------------
//
//  Function:   SpInitialize
//
//  Synopsis:   Package Initialization Function
//
//  Arguments:  [dwPackageID] --
//              [pParameters] --
//              [Table]           --
//
//  History:    10-03-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
SpInitialize(
                ULONG_PTR           dwPackageID,
                PSECPKG_PARAMETERS  pParameters,
                PLSA_SECPKG_FUNCTION_TABLE  Table)
{
    WCHAR ComputerName[ 32 ];
    DWORD Size ;
    UNICODE_STRING Temp ;

    if ( !SpInitialized )
    {
        SpPackageId = dwPackageID ;
        LsaTable = Table ;

        CopyMemory( SslTokenSource.SourceName, "SChannel", 8 );
        AllocateLocallyUniqueId( &SslTokenSource.SourceIdentifier );

        Size = sizeof( ComputerName ) / sizeof( WCHAR );

        GetComputerName( ComputerName, &Size );

        RtlInitUnicodeString( &Temp, ComputerName );

        SslDuplicateString( &SslComputerName, &Temp );

        SslDuplicateString( &SslDomainName, &pParameters->DomainName );

        RtlInitUnicodeString( &SslPackageName, UNISP_NAME_W );

        RtlCreateUnicodeStringFromAsciiz( &SslMsvName, MSV1_0_PACKAGE_NAME );

        if ( !SslDnsDomainName )
        {
            DWORD DnsDomainLength = 0 ;

            GetComputerNameEx( ComputerNameDnsDomain, NULL, &DnsDomainLength );

            SslDnsDomainName = LocalAlloc( LMEM_FIXED,
                                           (DnsDomainLength + 1) * sizeof(WCHAR) );

            if ( SslDnsDomainName )
            {
                DnsDomainLength++ ;

                GetComputerNameEx( ComputerNameDnsDomain, SslDnsDomainName, &DnsDomainLength );

            }
        }

        if ((pParameters->MachineState & SECPKG_STATE_STRONG_ENCRYPTION_PERMITTED) != 0)
        {
            SslGlobalStrongEncryptionPermitted = TRUE;
        }

        SpInitialized = TRUE;
    }

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   SpUniGetInfo
//
//  Synopsis:   Get Package Information
//
//  Arguments:  [pInfo] --
//
//  History:    10-03-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
SpUniGetInfo(
    PSecPkgInfo pInfo
    )
{
    pInfo->wVersion         = 1;
    pInfo->wRPCID           = UNISP_RPC_ID;
    pInfo->fCapabilities    = dwSchannelPackageCapabilities;
    pInfo->cbMaxToken       = 0x4000;
    pInfo->Name             = ReplaceBaseProvider ? UNISP_NAME_WO : UNISP_NAME_W ;
    pInfo->Comment          = UNISP_NAME_W ;

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   SpSslGetInfo
//
//  Synopsis:   Get Package Information
//
//  Arguments:  [pInfo] --
//
//  History:    10-03-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
SpSslGetInfo(
    PSecPkgInfo pInfo
    )
{
    pInfo->wVersion         = 1;
    pInfo->wRPCID           = UNISP_RPC_ID;
    pInfo->fCapabilities    = dwSchannelPackageCapabilities;
    pInfo->cbMaxToken       = 0x4000;
    pInfo->Name             = SCHANNEL_PACKAGE_NAME;
    pInfo->Comment          = SCHANNEL_PACKAGE_COMMENT;

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   SslDuplicateString
//
//  Synopsis:   Duplicate a unicode string
//
//  Arguments:  [Dest]   --
//              [Source] --
//
//  History:    10-18-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
SslDuplicateString(
    PUNICODE_STRING Dest,
    PUNICODE_STRING Source
    )
{
    Dest->Buffer = (PWSTR) SPExternalAlloc(  Source->Length + sizeof(WCHAR) );
    if ( Dest->Buffer )
    {
        Dest->Length = Source->Length ;
        Dest->MaximumLength = Source->Length + sizeof(WCHAR) ;
        CopyMemory( Dest->Buffer, Source->Buffer, Source->Length );
        Dest->Buffer[ Dest->Length / 2 ] = L'\0';

        return( STATUS_SUCCESS );
    }

    return( STATUS_NO_MEMORY );
}

//+---------------------------------------------------------------------------
//
//  Function:   SpGetExtendedInformation
//
//  Synopsis:   Return extended information to the LSA
//
//  Arguments:  [Class] -- Information Class
//              [pInfo] -- Returned Information Pointer
//
//  History:    3-24-97   ramas   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
SpGetExtendedInformation(
    SECPKG_EXTENDED_INFORMATION_CLASS   Class,
    PSECPKG_EXTENDED_INFORMATION *      pInfo
    )
{
    PSECPKG_EXTENDED_INFORMATION    Info ;
    PWSTR pszPath;
    SECURITY_STATUS Status ;
    ULONG Size ;

    switch ( Class )
    {
        case SecpkgContextThunks:
            Info = (PSECPKG_EXTENDED_INFORMATION) LsaTable->AllocateLsaHeap(
                            sizeof( SECPKG_EXTENDED_INFORMATION ) +
                            sizeof( ThunkedContextLevels ) );

            if ( Info )
            {
                Info->Class = Class ;
                Info->Info.ContextThunks.InfoLevelCount =
                                sizeof( ThunkedContextLevels ) / sizeof( ULONG );
                CopyMemory( Info->Info.ContextThunks.Levels,
                            ThunkedContextLevels,
                            sizeof( ThunkedContextLevels ) );

                Status = SEC_E_OK ;

            }
            else
            {
                Status = SEC_E_INSUFFICIENT_MEMORY ;
            }

            break;

#ifdef LATER
        case SecpkgGssInfo:
            Info = (PSECPKG_EXTENDED_INFORMATION) LsaTable->AllocateLsaHeap(
                            sizeof( SECPKG_EXTENDED_INFORMATION ) +
                            sizeof( Md5Oid ) );

            if ( Info )
            {
                Info->Class = Class ;

                Info->Info.GssInfo.EncodedIdLength = sizeof( Md5Oid );

                CopyMemory( Info->Info.GssInfo.EncodedId,
                            Md5Oid,
                            sizeof( Md5Oid ) );

                Status = SEC_E_OK ;

            }
            else
            {
                Status = SEC_E_INSUFFICIENT_MEMORY ;
            }
#endif

        case SecpkgWowClientDll:

            //
            // This indicates that we're smart enough to handle wow client processes
            //

            Info = (PSECPKG_EXTENDED_INFORMATION) 
                                LsaTable->AllocateLsaHeap( sizeof( SECPKG_EXTENDED_INFORMATION ) +
                                                           (MAX_PATH * sizeof(WCHAR) ) );

            if ( Info == NULL )
            {
                Status = STATUS_INSUFFICIENT_RESOURCES ;
                break;
            }
            pszPath = (PWSTR) (Info + 1);

            Size = GetSystemWow64Directory(pszPath, MAX_PATH);
            if(Size == 0)
            {
                // This call will fail on x86 platforms.
                Status = SEC_E_UNSUPPORTED_FUNCTION;
                LsaTable->FreeLsaHeap(Info);
                break;
            }

            if(Size + 1 + wcslen(SCHANNEL_DLL_NAME) >= MAX_PATH)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES ;
                LsaTable->FreeLsaHeap(Info);
                break;
            }

            wcscat(pszPath, L"\\");
            wcscat(pszPath, SCHANNEL_DLL_NAME);

            Size += 1 + wcslen(SCHANNEL_DLL_NAME);

            Info->Class = SecpkgWowClientDll ;
            Info->Info.WowClientDll.WowClientDllPath.Buffer = pszPath;
            Info->Info.WowClientDll.WowClientDllPath.Length = (USHORT) (Size * sizeof(WCHAR));
            Info->Info.WowClientDll.WowClientDllPath.MaximumLength = (USHORT) ((Size + 1) * sizeof(WCHAR) );

            Status = SEC_E_OK;
            break;

        default:
            Status = SEC_E_UNSUPPORTED_FUNCTION ;
            Info = NULL ;
            break;

    }

    *pInfo = Info ;
    return Status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\lsa\perfmon.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1999
//
// File:        perfmon.c
//
// Contents:    Schannel performance counter functions.
//
// Functions:
//
// History:     04-11-2000   jbanes    Created
//
//------------------------------------------------------------------------
#include "sslp.h"
#include "perfmon.h"

DWORD   dwOpenCount = 0;        // count of "Open" threads
BOOL    bInitOK = FALSE;        // true = DLL initialized OK

HANDLE  LsaHandle;
DWORD   PackageNumber;

PM_OPEN_PROC    OpenSslPerformanceData;
PM_COLLECT_PROC CollectSslPerformanceData;
PM_CLOSE_PROC   CloseSslPerformanceData;

#define DWORD_MULTIPLE(x) (((x+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))

SSLPERF_DATA_DEFINITION SslPerfDataDefinition =
{
    // PERF_OBJECT_TYPE
    {
        sizeof(SSLPERF_DATA_DEFINITION) + sizeof(SSLPERF_COUNTER),
        sizeof(SSLPERF_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        SSLPERF_OBJ,
        0,
        SSLPERF_OBJ,
        0,
        PERF_DETAIL_NOVICE,
        (sizeof(SSLPERF_DATA_DEFINITION) - sizeof(PERF_OBJECT_TYPE)) /
            sizeof(PERF_COUNTER_DEFINITION),
        0
        PERF_NO_INSTANCES,
        0
    },

    // PERF_COUNTER_DEFINITION
    {
        sizeof(PERF_COUNTER_DEFINITION),
        SSL_CACHE_ENTRIES,
        0,
        SSL_CACHE_ENTRIES,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        FIELD_OFFSET(SSLPERF_COUNTER, dwCacheEntries)
    },

    // PERF_COUNTER_DEFINITION
    {
        sizeof(PERF_COUNTER_DEFINITION),
        SSL_ACTIVE_ENTRIES,
        0,
        SSL_ACTIVE_ENTRIES,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        FIELD_OFFSET(SSLPERF_COUNTER, dwActiveEntries)
    },

    // PERF_COUNTER_DEFINITION
    {
        sizeof(PERF_COUNTER_DEFINITION),
        SSL_HANDSHAKE_COUNT,
        0,
        SSL_HANDSHAKE_COUNT,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        FIELD_OFFSET(SSLPERF_COUNTER, dwHandshakeCount)
    },

    // PERF_COUNTER_DEFINITION
    {
        sizeof(PERF_COUNTER_DEFINITION),
        SSL_RECONNECT_COUNT,
        0,
        SSL_RECONNECT_COUNT,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        FIELD_OFFSET(SSLPERF_COUNTER, dwReconnectCount)
    }
};


typedef struct _INSTANCE_DATA
{
    DWORD   dwProtocol;
    LPWSTR  szInstanceName;
} INSTANCE_DATA, *PINSTANCE_DATA;

static INSTANCE_DATA wdInstance[]  =
{
    {SP_PROT_CLIENTS, L"Client"},
    {SP_PROT_SERVERS, L"Server"},
    {0,               L"_Total"}
};

static const DWORD    NUM_INSTANCES =
    (sizeof(wdInstance)/sizeof(wdInstance[0]));


/*++

Routine Description:

    This routine will initialize the data structures used to pass
    data back to the registry

Arguments:

    Pointer to object ID of each device to be opened (PerfGen)

Return Value:

    None.

--*/
DWORD APIENTRY
OpenSslPerformanceData(
    LPWSTR lpDeviceNames)
{
    LONG Status;
    HKEY hKey = 0;
    DWORD size;
    DWORD type;
    DWORD dwFirstCounter;
    DWORD dwFirstHelp;
    LSA_STRING PackageName;

    //
    //  Since WINLOGON is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). the registry routines will
    //  limit access to the initialization routine to only one thread
    //  at a time so synchronization (i.e. reentrancy) should not be
    //  a problem
    //

    if (!dwOpenCount)
    {
        // get counter and help index base values from registry
        //      Open key to registry entry
        //      read First Counter and First Help values
        //      update static data strucutures by adding base to
        //          offset value in structure.

        Status = RegOpenKeyExA(
            HKEY_LOCAL_MACHINE,
            "SYSTEM\\CurrentControlSet\\Services\\Schannel\\Performance",
            0L,
            KEY_READ,
            &hKey);

        if(Status != ERROR_SUCCESS)
        {
            // this is fatal, if we can't get the base values of the
            // counter or help names, then the names won't be available
            // to the requesting application  so there's not much
            // point in continuing.
            goto cleanup;
        }

        size = sizeof (DWORD);
        Status = RegQueryValueExA(
                    hKey,
                    "First Counter",
                    0L,
                    &type,
                    (LPBYTE)&dwFirstCounter,
                    &size);

        if(Status != ERROR_SUCCESS)
        {
            // this is fatal, if we can't get the base values of the
            // counter or help names, then the names won't be available
            // to the requesting application  so there's not much
            // point in continuing.
            goto cleanup;
        }

        size = sizeof (DWORD);
        Status = RegQueryValueExA(
                    hKey,
                    "First Help",
                    0L,
                    &type,
                    (LPBYTE)&dwFirstHelp,
                    &size);

        if(Status != ERROR_SUCCESS)
        {
            // this is fatal, if we can't get the base values of the
            // counter or help names, then the names won't be available
            // to the requesting application  so there's not much
            // point in continuing.
            goto cleanup;
        }

        //
        //  NOTE: the initialization program could also retrieve
        //      LastCounter and LastHelp if they wanted to do
        //      bounds checking on the new number. e.g.
        //
        //      counter->CounterNameTitleIndex += dwFirstCounter;
        //      if (counter->CounterNameTitleIndex > dwLastCounter) {
        //          LogErrorToEventLog (INDEX_OUT_OF_BOUNDS);
        //      }


        //
        // Establish connection to schannel.
        //

        Status = LsaConnectUntrusted(&LsaHandle);

        if(!NT_SUCCESS(Status))
        {
            goto cleanup;
        }

        PackageName.Buffer          = UNISP_NAME_A;
        PackageName.Length          = (USHORT)strlen(PackageName.Buffer);
        PackageName.MaximumLength   = PackageName.Length + 1;

        Status = LsaLookupAuthenticationPackage(
                        LsaHandle,
                        &PackageName,
                        &PackageNumber);
        if(FAILED(Status))
        {
            CloseHandle(LsaHandle);
            goto cleanup;
        }


        //
        // Initialize the performance counters.
        //

        SslPerfDataDefinition.SslPerfObjectType.ObjectNameTitleIndex += dwFirstCounter;
        SslPerfDataDefinition.SslPerfObjectType.ObjectHelpTitleIndex += dwFirstHelp;

        // assign index of default counter (Sine Wave)
        SslPerfDataDefinition.SslPerfObjectType.DefaultCounter = 0;

        SslPerfDataDefinition.CacheEntriesDef.CounterNameTitleIndex += dwFirstCounter;
        SslPerfDataDefinition.CacheEntriesDef.CounterHelpTitleIndex += dwFirstHelp;

        SslPerfDataDefinition.ActiveEntriesDef.CounterNameTitleIndex += dwFirstCounter;
        SslPerfDataDefinition.ActiveEntriesDef.CounterHelpTitleIndex += dwFirstHelp;

        SslPerfDataDefinition.HandshakeCountDef.CounterNameTitleIndex += dwFirstCounter;
        SslPerfDataDefinition.HandshakeCountDef.CounterHelpTitleIndex += dwFirstHelp;

        SslPerfDataDefinition.ReconnectCountDef.CounterNameTitleIndex += dwFirstCounter;
        SslPerfDataDefinition.ReconnectCountDef.CounterHelpTitleIndex += dwFirstHelp;

        bInitOK = TRUE;
    }

    dwOpenCount++;

    Status = ERROR_SUCCESS;

cleanup:

    if(hKey)
    {
        RegCloseKey(hKey);
    }

    return Status;
}


DWORD
GetCacheInfo(
    PSSL_PERFMON_INFO_RESPONSE pPerfmonInfo)
{
    PSSL_PERFMON_INFO_REQUEST pRequest = NULL;
    PSSL_PERFMON_INFO_RESPONSE pResponse = NULL;
    DWORD cbResponse = 0;
    DWORD SubStatus;
    DWORD Status;

    pRequest = (PSSL_PERFMON_INFO_REQUEST)LocalAlloc(LPTR, sizeof(SSL_PERFMON_INFO_REQUEST));
    if(pRequest == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }

    pRequest->MessageType = SSL_PERFMON_INFO_MESSAGE;

    Status = LsaCallAuthenticationPackage(
                    LsaHandle,
                    PackageNumber,
                    pRequest,
                    sizeof(SSL_PERFMON_INFO_REQUEST),
                    &pResponse,
                    &cbResponse,
                    &SubStatus);
    if(FAILED(Status))
    {
        goto cleanup;
    }

    *pPerfmonInfo = *pResponse;

    Status = STATUS_SUCCESS;

cleanup:

    if(pRequest)
    {
        LocalFree(pRequest);
    }

    if (pResponse != NULL)
    {
        LsaFreeReturnBuffer(pResponse);
    }

    return Status;
}

/*++

Routine Description:

    This routine will return the data for the ssl performance counters.

Arguments:

   IN       LPWSTR   lpValueName
         pointer to a wide character string passed by registry.

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

Return Value:

      ERROR_MORE_DATA if buffer passed is too small to hold data.

      ERROR_SUCCESS  if success or any other error.

--*/
DWORD APIENTRY
CollectSslPerformanceData(
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes)
{
    PERF_INSTANCE_DEFINITION *pPerfInstanceDefinition;
    SSLPERF_DATA_DEFINITION *pSslPerfDataDefinition;
    PSSLPERF_COUNTER pSC;
    SSL_PERFMON_INFO_RESPONSE PerfmonInfo;

    DWORD   dwThisInstance;
    ULONG   SpaceNeeded;
    DWORD   dwQueryType;
    DWORD   Status;

    //
    // before doing anything else, see if Open went OK
    //
    if (!bInitOK)
    {
        // unable to continue because open failed.
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS; // yes, this is a successful exit
    }

    //
    // see if this is a foreign (i.e. non-NT) computer data request
    //

    dwQueryType = GetQueryType (lpValueName);

    if (dwQueryType == QUERY_FOREIGN)
    {
        // this routine does not service requests for data from
        // Non-NT computers
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS;
    }


    if (dwQueryType == QUERY_ITEMS)
    {
        if(!(IsNumberInUnicodeList(SslPerfDataDefinition.SslPerfObjectType.ObjectNameTitleIndex, lpValueName)))
        {
            // request received for data object not provided by this routine
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            return ERROR_SUCCESS;
        }
    }

    pSslPerfDataDefinition = (SSLPERF_DATA_DEFINITION *) *lppData;

    SpaceNeeded = sizeof(SSLPERF_DATA_DEFINITION) +
          (NUM_INSTANCES * (sizeof(PERF_INSTANCE_DEFINITION) +
          (24) +    // size of instance names
          sizeof (SSLPERF_COUNTER)));

    if ( *lpcbTotalBytes < SpaceNeeded )
    {
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_MORE_DATA;
    }

    //
    // Copy the (constant, initialized) Object Type and counter definitions
    //  to the caller's data buffer
    //
    memmove(pSslPerfDataDefinition,
            &SslPerfDataDefinition,
            sizeof(SSLPERF_DATA_DEFINITION));


    //
    // Get info from schannel.
    //

    Status = GetCacheInfo(&PerfmonInfo);

    if(!NT_SUCCESS(Status))
    {
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS;
    }


    //
    //  Create data for return for each instance
    //
    pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                 &pSslPerfDataDefinition[1];

    for(dwThisInstance = 0; dwThisInstance < NUM_INSTANCES; dwThisInstance++)
    {
        MonBuildInstanceDefinition(
            pPerfInstanceDefinition,
            (PVOID *)&pSC,
            0,
            0,
            (DWORD)-1, // use name
            wdInstance[dwThisInstance].szInstanceName);

        pSC->CounterBlock.ByteLength = sizeof (SSLPERF_COUNTER);

        if(wdInstance[dwThisInstance].dwProtocol & SP_PROT_CLIENTS)
        {
            // client
            pSC->dwCacheEntries     = PerfmonInfo.ClientCacheEntries;
            pSC->dwActiveEntries    = PerfmonInfo.ClientActiveEntries;
            pSC->dwHandshakeCount   = PerfmonInfo.ClientHandshakesPerSecond;
            pSC->dwReconnectCount   = PerfmonInfo.ClientReconnectsPerSecond;
        }
        else if(wdInstance[dwThisInstance].dwProtocol & SP_PROT_SERVERS)
        {
            // server
            pSC->dwCacheEntries     = PerfmonInfo.ServerCacheEntries;
            pSC->dwActiveEntries    = PerfmonInfo.ServerActiveEntries;
            pSC->dwHandshakeCount   = PerfmonInfo.ServerHandshakesPerSecond;
            pSC->dwReconnectCount   = PerfmonInfo.ServerReconnectsPerSecond;
        }
        else
        {
            // total
            pSC->dwCacheEntries     = PerfmonInfo.ClientCacheEntries +
                                      PerfmonInfo.ServerCacheEntries;
            pSC->dwActiveEntries    = PerfmonInfo.ClientActiveEntries +
                                      PerfmonInfo.ServerActiveEntries;
            pSC->dwHandshakeCount   = PerfmonInfo.ClientHandshakesPerSecond +
                                      PerfmonInfo.ServerHandshakesPerSecond;
            pSC->dwReconnectCount   = PerfmonInfo.ClientReconnectsPerSecond +
                                      PerfmonInfo.ServerReconnectsPerSecond;
        }

        // update instance pointer for next instance
        pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)&pSC[1];
    }

    //
    // update arguments for return
    //

    *lppData = (PVOID)pPerfInstanceDefinition;

    *lpNumObjectTypes = 1;

    pSslPerfDataDefinition->SslPerfObjectType.TotalByteLength =
        *lpcbTotalBytes = (DWORD)((LONG_PTR)pPerfInstanceDefinition -
                          (LONG_PTR)pSslPerfDataDefinition);

    // update instance count
    pSslPerfDataDefinition->SslPerfObjectType.NumInstances = NUM_INSTANCES;

    return ERROR_SUCCESS;
}


/*++

Routine Description:

    This routine closes the open handles to the Signal Gen counters.

Arguments:

    None.


Return Value:

    ERROR_SUCCESS

--*/
DWORD APIENTRY
CloseSslPerformanceData(void)
{
    if(--dwOpenCount == 0)
    {
        // when this is the last thread...
        if(LsaHandle)
        {
            CloseHandle(LsaHandle);
        }
    }

    return ERROR_SUCCESS;
}


/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foreign" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
DWORD
GetQueryType (
    IN LPWSTR lpValue)
{
    if(lpValue == NULL || *lpValue == 0)
    {
        return QUERY_GLOBAL;
    }

    if(lstrcmp(lpValue, L"Global") == 0)
    {
        return QUERY_GLOBAL;
    }

    if(lstrcmp(lpValue, L"Foreign") == 0)
    {
        return QUERY_FOREIGN;
    }

    if(lstrcmp(lpValue, L"Costly") == 0)
    {
        return QUERY_COSTLY;
    }

    // if not Global and not Foreign and not Costly,
    // then it must be an item list
    return QUERY_ITEMS;
}


/*++

    MonBuildInstanceDefinition  -   Build an instance of an object

        Inputs:

            pBuffer         -   pointer to buffer where instance is to
                                be constructed

            pBufferNext     -   pointer to a pointer which will contain
                                next available location, DWORD aligned

            ParentObjectTitleIndex
                            -   Title Index of parent object type; 0 if
                                no parent object

            ParentObjectInstance
                            -   Index into instances of parent object
                                type, starting at 0, for this instances
                                parent object instance

            UniqueID        -   a unique identifier which should be used
                                instead of the Name for identifying
                                this instance

            Name            -   Name of this instance
--*/
BOOL
MonBuildInstanceDefinition(
    PERF_INSTANCE_DEFINITION *pBuffer,
    PVOID *pBufferNext,
    DWORD ParentObjectTitleIndex,
    DWORD ParentObjectInstance,
    DWORD UniqueID,
    LPWSTR Name)
{
    DWORD NameLength;
    LPWSTR pName;

    //  Include trailing null in name size
    NameLength = (lstrlenW(Name) + 1) * sizeof(WCHAR);

    pBuffer->ByteLength = sizeof(PERF_INSTANCE_DEFINITION) +
                          DWORD_MULTIPLE(NameLength);

    pBuffer->ParentObjectTitleIndex = ParentObjectTitleIndex;
    pBuffer->ParentObjectInstance = ParentObjectInstance;
    pBuffer->UniqueID = UniqueID;
    pBuffer->NameOffset = sizeof(PERF_INSTANCE_DEFINITION);
    pBuffer->NameLength = NameLength;

    // copy name to name buffer
    pName = (LPWSTR)&pBuffer[1];
    RtlMoveMemory(pName,Name,NameLength);

    // update "next byte" pointer
    *pBufferNext = (PVOID) ((PCHAR) pBuffer + pBuffer->ByteLength);

    return 0;
}


/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
BOOL
IsNumberInUnicodeList(
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList)
{
    DWORD dwThisNumber;
    DWORD cDigits;

    if(lpwszUnicodeList == 0) return FALSE;

    while(TRUE)
    {
        // Skip over leading whitespace.
        while(*lpwszUnicodeList && iswspace(*lpwszUnicodeList))
        {
            lpwszUnicodeList++;
        }

        // Get number.
        cDigits = 0;
        dwThisNumber = 0;
        while(iswdigit(*lpwszUnicodeList))
        {
            dwThisNumber *= 10;
            dwThisNumber += (*lpwszUnicodeList - L'0');
            cDigits++;
            lpwszUnicodeList++;
        }
        if(cDigits == 0)
        {
            return FALSE;
        }

        // Compare number to reference.
        if(dwThisNumber == dwNumber)
        {
            return TRUE;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\lsa\mapsam.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       mapsam.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10-17-96   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __MAPSAM_H__
#define __MAPSAM_H__


BOOL
SslInitSam(
    VOID
    );


NTSTATUS
SslGetPacForUser(
    IN PUNICODE_STRING  AlternateName,
    IN BOOL AllowGuest,
    OUT PUCHAR * pPacData,
    OUT PULONG pPacDataSize
    );

NTSTATUS
SslCreateTokenFromPac(
    IN PUCHAR   MarshalledPac,
    IN ULONG    MarshalledPacSize,
    IN PUNICODE_STRING AccountDomain,
    OUT PLUID   NewLogonId,
    OUT PHANDLE Token
    );





typedef
NTSTATUS (NTAPI * SAMICONNECT) (
    IN PSAMPR_SERVER_NAME ServerName,
    OUT SAMPR_HANDLE *ServerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN TrustedClient
    );

typedef
NTSTATUS (NTAPI * SAMRCLOSEHANDLE)(
    IN SAMPR_HANDLE * Handle);

typedef
NTSTATUS (NTAPI * SAMRQUERYINFORMATIONUSER)(
    IN SAMPR_HANDLE Handle,
    IN USER_INFORMATION_CLASS Class,
    OUT PSAMPR_USER_INFO_BUFFER * Buffer);

typedef
NTSTATUS (NTAPI * SAMRGETGROUPSFORUSER)(
    IN SAMPR_HANDLE Handle,
    OUT PSAMPR_GET_GROUPS_BUFFER * Groups);


typedef
NTSTATUS
(NTAPI * SAMROPENUSER)(
    IN SAMPR_HANDLE     Handle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG Rid,
    OUT SAMPR_HANDLE * UserHandle);

typedef
NTSTATUS (NTAPI * SAMROPENDOMAIN)(
    IN SAMPR_HANDLE Handle,
    IN ACCESS_MASK DesiredAccess,
    IN PRPC_SID DomainId,
    OUT SAMPR_HANDLE * DomainHandle );

NTSTATUS
SamIOpenUserByAlternateId(
    IN SAMPR_HANDLE DomainHandle,
    IN ACCESS_MASK DesiredAccess,
    IN PUNICODE_STRING AlternateId,
    OUT SAMPR_HANDLE * UserHandle );

typedef
NTSTATUS (NTAPI * SAMIOPENUSERBYALTERNATEID)(
    IN SAMPR_HANDLE DomainHandle,
    IN ACCESS_MASK DesiredAccess,
    IN PUNICODE_STRING AlternateId,
    OUT SAMPR_HANDLE * UserHandle );

typedef
VOID (NTAPI * SAMIFREE_SAMPR_GET_GROUPS_BUFFER)(
    PSAMPR_GET_GROUPS_BUFFER Source
    );

typedef
VOID (NTAPI * SAMIFREE_SAMPR_USER_INFO_BUFFER)(
    PSAMPR_USER_INFO_BUFFER Source,
    USER_INFORMATION_CLASS Branch
    );


//
// LSA
//

typedef
NTSTATUS (NTAPI * LSAIOPENPOLICYTRUSTED)(
    OUT PLSAPR_HANDLE PolicyHandle);

typedef
NTSTATUS (NTAPI * LSARQUERYINFORMATIONPOLICY)(
    LSAPR_HANDLE Handle,
    POLICY_INFORMATION_CLASS Class,
    PLSAPR_POLICY_INFORMATION * Info);

typedef
NTSTATUS (NTAPI * LSARCLOSE)(
    LSAPR_HANDLE * Handle);

typedef
VOID (NTAPI * LSAIFREE_LSAPR_POLICY_INFORMATION)(
    POLICY_INFORMATION_CLASS Class,
    PLSAPR_POLICY_INFORMATION Info);


extern SAMICONNECT      pSamIConnect ;
extern SAMROPENDOMAIN   pSamrOpenDomain ;
extern SAMRCLOSEHANDLE  pSamrCloseHandle ;
extern SAMRQUERYINFORMATIONUSER pSamrQueryInformationUser ;
extern SAMRGETGROUPSFORUSER pSamrGetGroupsForUser ;
extern SAMROPENUSER pSamrOpenUser ;
extern SAMIOPENUSERBYALTERNATEID pSamrOpenUserByAlternateId ;
extern SAMIFREE_SAMPR_GET_GROUPS_BUFFER pSamIFree_SAMPR_GET_GROUPS_BUFFER ;
extern SAMIFREE_SAMPR_USER_INFO_BUFFER pSamIFree_SAMPR_USER_INFO_BUFFER ;

extern LSAIOPENPOLICYTRUSTED pLsaIOpenPolicyTrusted ;
extern LSARQUERYINFORMATIONPOLICY pLsarQueryInformationPolicy ;
extern LSARCLOSE pLsarClose ;
extern LSAIFREE_LSAPR_POLICY_INFORMATION pLsaIFree_LSAPR_POLICY_INFORMATION ;



#endif  // __MAPSAM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\lsa\mapsam.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       mapsam.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10-17-96   RichardW   Created
//
//----------------------------------------------------------------------------

extern "C" {

#include "sslp.h"
#include <crypt.h>
#include <lmcons.h>
#include <ntsam.h>
#include <samrpc.h>
#include <samisrv.h>
#include <lsarpc.h>
#include <lsaisrv.h>
#include <ntmsv1_0.h>
#include <certmap.h>
#include "mapsam.h"
}

#include <pac.hxx>






//+---------------------------------------------------------------------------
//
//  Function:   SslDuplicateString
//
//  Synopsis:   Duplicate a unicode string
//
//  Arguments:  [Dest]   --
//              [Source] --
//
//  History:    10-18-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
SslDuplicateString(
    PUNICODE_STRING Dest,
    PUNICODE_STRING Source
    )
{
    Dest->Buffer = (PWSTR) LocalAlloc( LMEM_FIXED, Source->Length + sizeof(WCHAR) );
    if ( Dest->Buffer )
    {
        Dest->Length = Source->Length ;
        Dest->MaximumLength = Source->Length + sizeof(WCHAR) ;
        CopyMemory( Dest->Buffer, Source->Buffer, Source->Length );
        Dest->Buffer[ Dest->Length / 2 ] = L'\0';

        return( STATUS_SUCCESS );
    }

    return( STATUS_NO_MEMORY );
}


//+-------------------------------------------------------------------------
//
//  Function:   SslMakeDomainRelativeSid
//
//  Synopsis:   Given a domain Id and a relative ID create the corresponding
//              SID allocated from the LSA heap.
//
//  Effects:
//
//  Arguments:
//
//    DomainId - The template SID to use.
//
//    RelativeId - The relative Id to append to the DomainId.
//
//  Requires:
//
//  Returns:    Sid - Returns a pointer to a buffer allocated from the LsaHeap
//                      containing the resultant Sid.
//
//  Notes:
//
//
//--------------------------------------------------------------------------
PSID
SslMakeDomainRelativeSid(
    IN PSID DomainId,
    IN ULONG RelativeId
    )

{
    UCHAR DomainIdSubAuthorityCount;
    ULONG Size;
    PSID Sid;

    //
    // Allocate a Sid which has one more sub-authority than the domain ID.
    //

    DomainIdSubAuthorityCount = *(RtlSubAuthorityCountSid( DomainId ));
    Size = RtlLengthRequiredSid(DomainIdSubAuthorityCount+1);

    if ((Sid = LocalAlloc( LMEM_FIXED,  Size )) == NULL ) {
        return NULL;
    }

    //
    // Initialize the new SID to have the same inital value as the
    // domain ID.
    //

    if ( !NT_SUCCESS( RtlCopySid( Size, Sid, DomainId ) ) ) {
        LocalFree( Sid );
        return NULL;
    }

    //
    // Adjust the sub-authority count and
    //  add the relative Id unique to the newly allocated SID
    //

    (*(RtlSubAuthorityCountSid( Sid ))) ++;
    *RtlSubAuthoritySid( Sid, DomainIdSubAuthorityCount ) = RelativeId;


    return Sid;
}

//+-------------------------------------------------------------------------
//
//  Function:   SslDuplicateSid
//
//  Synopsis:   Duplicates a SID
//
//  Effects:    allocates memory with LsaFunctions.AllocateLsaHeap
//
//  Arguments:  DestinationSid - Receives a copy of the SourceSid
//              SourceSid - SID to copy
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS - the copy succeeded
//              STATUS_INSUFFICIENT_RESOURCES - the call to allocate memory
//                  failed
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
SslDuplicateSid(
    OUT PSID * DestinationSid,
    IN PSID SourceSid
    )
{
    ULONG SidSize;

    DsysAssert(RtlValidSid(SourceSid));

    SidSize = RtlLengthSid(SourceSid);
    *DestinationSid = (PSID) LocalAlloc( LMEM_FIXED,  SidSize );
    if (*DestinationSid == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    RtlCopyMemory(
        *DestinationSid,
        SourceSid,
        SidSize
        );
    return(STATUS_SUCCESS);
}




NTSTATUS
SslpGetPacForUser(
    IN SAMPR_HANDLE UserHandle,
    OUT PPACTYPE * ppPac
    )
{
    PSAMPR_USER_ALL_INFORMATION UserAll = NULL ;
    PSAMPR_USER_INFO_BUFFER UserAllInfo = NULL ;
    NTSTATUS Status ;
    PPACTYPE pNewPac = NULL ;
    PSAMPR_GET_GROUPS_BUFFER GroupsBuffer = NULL ;

    *ppPac = NULL ;

    Status = pSamrQueryInformationUser(
                    UserHandle,
                    UserAllInformation,
                    &UserAllInfo );

    if ( !NT_SUCCESS( Status ) )
    {
        return( Status );
    }

    UserAll = &UserAllInfo->All ;

    if ( UserAll->UserAccountControl & USER_ACCOUNT_DISABLED )
    {
        Status = STATUS_ACCOUNT_DISABLED ;

        goto GetPac_Cleanup;
    }

    Status = pSamrGetGroupsForUser(
                    UserHandle,
                    &GroupsBuffer );

    if ( !NT_SUCCESS( Status ) )
    {
        goto GetPac_Cleanup ;
    }

    Status = PAC_Init( UserAll,
                       GroupsBuffer,
                       GlobalDomainSid,
                       &GlobalDomainName,
                       &GlobalMachineName,
                       NULL,
                       ppPac );




GetPac_Cleanup:

    if ( UserAllInfo )
    {
        pSamIFree_SAMPR_USER_INFO_BUFFER( UserAllInfo, UserAllInformation );
    }

    if ( GroupsBuffer )
    {
        pSamIFree_SAMPR_GET_GROUPS_BUFFER( GroupsBuffer );
    }

    return( Status );

}




NTSTATUS
SslGetPacForUser(
    IN PUNICODE_STRING  AlternateName,
    IN BOOL AllowGuest,
    OUT PUCHAR * pPacData,
    OUT PULONG pPacDataSize
    )
{

    NTSTATUS Status ;
    PVOID   UserHandle ;

    *pPacData = NULL ;
    *pPacDataSize = 0 ;

    Status = LsaTable->OpenSamUser( AlternateName,
                                    SecNameAlternateId,
                                    &SslNamePrefix,
                                    AllowGuest,
                                    0,
                                    &UserHandle );

    if ( NT_SUCCESS( Status ) )
    {
        Status = LsaTable->GetUserAuthData( UserHandle,
                                            pPacData,
                                            pPacDataSize );

        (VOID) LsaTable->CloseSamUser( UserHandle );
    }

    return Status ;

}



NTSTATUS
SslCreateTokenFromPac(
    IN PUCHAR   MarshalledPac,
    IN ULONG    MarshalledPacSize,
    OUT PLUID   NewLogonId,
    OUT PHANDLE Token
    )
{
    PLSA_TOKEN_INFORMATION_V1 TokenInformation = NULL ;
    PLSA_TOKEN_INFORMATION_NULL TokenNull = NULL ;
    PVOID LsaTokenInformation = NULL ;

    LUID LogonId ;
    UNICODE_STRING UserName ;
    UNICODE_STRING DomainName ;
    UNICODE_STRING Workstation ;

    NTSTATUS Status ;
    NTSTATUS SubStatus ;
    HANDLE TokenHandle = NULL ;


    RtlInitUnicodeString(
        &UserName,
        L"Certificate User"
        );

    RtlInitUnicodeString(
        &DomainName,
        GlobalDomainName.Buffer
        );


    //
    // Now create the token.
    //

    LsaTokenInformation = TokenInformation;


    //
    // Create a logon session.
    //

    NtAllocateLocallyUniqueId(&LogonId);

    Status = LsaTable->CreateLogonSession( &LogonId );

    if (!NT_SUCCESS(Status))
    {
        DebugOut((DEB_ERROR,"Failed to create logon session: 0x%x\n",Status));
        goto CreateToken_Cleanup;
    }

    //
    // We would normally pass in the client workstation name when creating 
    // the token, but this information is not available since the client is 
    // sitting on the other side of an SSL connection.
    //

    RtlInitUnicodeString(
        &Workstation,
        NULL
        );

    Status = LsaTable->CreateToken(
                &LogonId,
                &SslSource,
                Network,
                LsaTokenInformationV1,
                LsaTokenInformation,
                NULL,                   // no token groups
                &UserName,
                &DomainName,
                &Workstation,
                &TokenHandle,
                &SubStatus
                );


    if (!NT_SUCCESS(Status))
    {
        DebugOut((DEB_ERROR,"Failed to create token: 0x%x\n",Status));
        goto CreateToken_Cleanup;
    }

    TokenInformation = NULL;
    TokenNull = NULL;

    if (!NT_SUCCESS(SubStatus))
    {
        DebugOut((DEB_ERROR,"Failed to create token, substatus = 0x%x\n",SubStatus));
        Status = SubStatus;
        goto CreateToken_Cleanup;
    }

    //
    // If the caller wanted an identify level token, duplicate the token
    // now.
    //

#if 0
    if ((ContextFlags & ISC_RET_IDENTIFY) != 0)
    {
        if (!DuplicateTokenEx(
                    TokenHandle,
                    TOKEN_ALL_ACCESS,
                    NULL,               // no security attributes
                    SecurityIdentification,
                    TokenImpersonation,
                    &TempTokenHandle
                    ))
        {
            DebugOut((DEB_ERROR,"Failed to duplicate token\n"));
            DsysAssert(GetLastError() == ERROR_NO_SYSTEM_RESOURCES);
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto CreateToken_Cleanup;
        }
        Status = NtClose(TokenHandle);

        DsysAssert(NT_SUCCESS(Status));
        TokenHandle = TempTokenHandle;
        TempTokenHandle = NULL;

    }
#endif

    //
    // Check the delegation information to see if we need to create
    // a logon session for this.
    //

    *NewLogonId = LogonId;
    *Token = TokenHandle;

CreateToken_Cleanup:
    if (TokenInformation != NULL)
    {
        if ( TokenInformation->User.User.Sid != NULL ) {
            LocalFree( TokenInformation->User.User.Sid );
        }

        if ( TokenInformation->Groups != NULL ) {
            ULONG i;

            for ( i=0; i < TokenInformation->Groups->GroupCount; i++ ) {
                LocalFree( TokenInformation->Groups->Groups[i].Sid );
            }

            LocalFree( TokenInformation->Groups );
        }

        if ( TokenInformation->PrimaryGroup.PrimaryGroup != NULL ) {
            LocalFree( TokenInformation->PrimaryGroup.PrimaryGroup );
        }

        LocalFree( TokenInformation );

    }
    if (TokenNull != NULL)
    {
        LocalFree(TokenNull);
    }


    if (!NT_SUCCESS(Status))
    {
        //
        // Note: if we have created a token, we don't want to delete
        // the logon session here because we will end up dereferencing
        // the logon session twice.
        //

        if (TokenHandle != NULL)
        {
            NtClose(TokenHandle);
        }
        else if ((LogonId.LowPart != 0) || (LogonId.HighPart != 0))
        {
            LsaTable->DeleteLogonSession(&LogonId);
        }
    }

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\lsa\spreg.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       spreg.c
//
//  Contents:   Schannel registry management routines. 
//
//  Classes:
//
//  Functions:
//
//  History:    11-24-97   jbanes   Enabled TLS
//
//----------------------------------------------------------------------------

#include <sslp.h>
#include "spreg.h"

HKEY   g_hkBase      = NULL;
HANDLE g_hParamEvent = NULL;
HANDLE g_hWait       = NULL;

HKEY   g_hkFipsBase      = NULL;
HANDLE g_hFipsParamEvent = NULL;
HANDLE g_hFipsWait       = NULL;

BOOL g_fManualCredValidation        = MANUAL_CRED_VALIDATION_SETTING;
BOOL g_PctClientDisabledByDefault   = PCT_CLIENT_DISABLED_SETTING;
BOOL g_Ssl2ClientDisabledByDefault  = SSL2_CLIENT_DISABLED_SETTING;

DWORD g_dwEventLogging              = DEFAULT_EVENT_LOGGING_SETTING;
DWORD g_ProtEnabled                 = DEFAULT_ENABLED_PROTOCOLS_SETTING; 

BOOL g_fFipsMode = FALSE;
BOOL g_fFranceLocale = FALSE;

typedef struct enamap
{
    TCHAR *pKey;
    DWORD Mask;
} enamap;

enamap g_ProtMap[] =
{
    {SP_REG_KEY_UNIHELLO TEXT("\\") SP_REG_KEY_CLIENT, SP_PROT_UNI_CLIENT},
    {SP_REG_KEY_UNIHELLO TEXT("\\") SP_REG_KEY_SERVER, SP_PROT_UNI_SERVER},
    {SP_REG_KEY_PCT1 TEXT("\\") SP_REG_KEY_CLIENT, SP_PROT_PCT1_CLIENT},
    {SP_REG_KEY_PCT1 TEXT("\\") SP_REG_KEY_SERVER, SP_PROT_PCT1_SERVER},
    {SP_REG_KEY_SSL2 TEXT("\\") SP_REG_KEY_CLIENT, SP_PROT_SSL2_CLIENT},
    {SP_REG_KEY_SSL2 TEXT("\\") SP_REG_KEY_SERVER, SP_PROT_SSL2_SERVER},
    {SP_REG_KEY_SSL3 TEXT("\\") SP_REG_KEY_CLIENT, SP_PROT_SSL3_CLIENT},
    {SP_REG_KEY_SSL3 TEXT("\\") SP_REG_KEY_SERVER, SP_PROT_SSL3_SERVER},
    {SP_REG_KEY_TLS1 TEXT("\\") SP_REG_KEY_CLIENT, SP_PROT_TLS1_CLIENT},
    {SP_REG_KEY_TLS1 TEXT("\\") SP_REG_KEY_SERVER, SP_PROT_TLS1_SERVER}
};

VOID
SslWatchParamKey(
    PVOID    pCtxt,
    BOOLEAN  fWaitStatus);

VOID
FipsWatchParamKey(
    PVOID    pCtxt,
    BOOLEAN  fWaitStatus);

BOOL 
SslReadRegOptions(
    BOOL fFirstTime);

BOOL SPLoadRegOptions(void)
{
    g_hParamEvent = CreateEvent(NULL,
                           FALSE,
                           FALSE,
                           NULL);

    SslWatchParamKey(g_hParamEvent, FALSE);

    g_hFipsParamEvent = CreateEvent(NULL,
                           FALSE,
                           FALSE,
                           NULL);

    FipsWatchParamKey(g_hFipsParamEvent, FALSE);

    return TRUE;
}

void SPUnloadRegOptions(void)
{
    if (NULL != g_hWait) 
    {
        RtlDeregisterWait(g_hWait);
        g_hWait = NULL;
    }

    if(NULL != g_hkBase)
    {
        RegCloseKey(g_hkBase);
    }

    if(NULL != g_hParamEvent)
    {
        CloseHandle(g_hParamEvent);
    }

    if (NULL != g_hFipsWait) 
    {
        RtlDeregisterWait(g_hFipsWait);
        g_hFipsWait = NULL;
    }

    if(NULL != g_hkFipsBase)
    {
        RegCloseKey(g_hkFipsBase);
    }

    if(NULL != g_hFipsParamEvent)
    {
        CloseHandle(g_hFipsParamEvent);
    }
}

BOOL
ReadRegistrySetting(
    HKEY    hReadKey,
    HKEY    hWriteKey,
    LPCTSTR pszValueName,
    DWORD * pdwValue,
    DWORD   dwDefaultValue)
{
    DWORD dwSize;
    DWORD dwType;
    DWORD dwOriginalValue = *pdwValue;

    dwSize = sizeof(DWORD);
    if(RegQueryValueEx(hReadKey, 
                       pszValueName, 
                       NULL, 
                       &dwType, 
                       (PUCHAR)pdwValue, 
                       &dwSize) != STATUS_SUCCESS)
    {
        *pdwValue = dwDefaultValue;

        if(hWriteKey)
        {
            RegSetValueEx(hWriteKey, 
                          pszValueName, 
                          0, 
                          REG_DWORD, 
                          (PUCHAR)pdwValue, 
                          sizeof(DWORD));
        }
    }

    return (dwOriginalValue != *pdwValue);
}


////////////////////////////////////////////////////////////////////
//
//  Name:       SslWatchParamKey
//
//  Synopsis:   Sets RegNotifyChangeKeyValue() on param key, initializes
//              debug level, then utilizes thread pool to wait on
//              changes to this registry key.  Enables dynamic debug
//              level changes, as this function will also be callback
//              if registry key modified.
//
//  Arguments:  pCtxt is actually a HANDLE to an event.  This event
//              will be triggered when key is modified.
//
//  Notes:      .
//
VOID
SslWatchParamKey(
    PVOID    pCtxt,
    BOOLEAN  fWaitStatus)
{
    NTSTATUS    Status;
    LONG        lRes = ERROR_SUCCESS;
    BOOL        fFirstTime = FALSE;
    DWORD       disp;

    if(g_hkBase == NULL)
    {
        // First time we've been called.
        Status = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                SP_REG_KEY_BASE,
                                0,
                                TEXT(""),
                                REG_OPTION_NON_VOLATILE,
                                KEY_READ,
                                NULL,
                                &g_hkBase,
                                &disp);
        if(Status)
        {
            DebugLog((DEB_WARN,"Failed to open SCHANNEL key: 0x%x\n", Status));
            return;
        }

        fFirstTime = TRUE;
    }

    if(pCtxt != NULL)
    {
        if (NULL != g_hWait) 
        {
            Status = RtlDeregisterWait(g_hWait);
            if(!NT_SUCCESS(Status))
            {
                DebugLog((DEB_WARN, "Failed to Deregister wait on registry key: 0x%x\n", Status));
                goto Reregister;
            }
        }

        lRes = RegNotifyChangeKeyValue(
                    g_hkBase,
                    TRUE,
                    REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_LAST_SET,
                    (HANDLE)pCtxt,
                    TRUE);

        if (ERROR_SUCCESS != lRes) 
        {
            DebugLog((DEB_ERROR,"Debug RegNotify setup failed: 0x%x\n", lRes));
            // we're tanked now. No further notifications, so get this one
        }
    }

    SslReadRegOptions(fFirstTime);

#if DBG
    InitDebugSupport(g_hkBase);
#endif

Reregister:

    if(pCtxt != NULL)
    {
        Status = RtlRegisterWait(&g_hWait,
                                 (HANDLE)pCtxt,
                                 SslWatchParamKey,
                                 (HANDLE)pCtxt,
                                 INFINITE,
                                 WT_EXECUTEINPERSISTENTIOTHREAD|
                                 WT_EXECUTEONLYONCE);
    }
}                       


////////////////////////////////////////////////////////////////////
//
//  Name:       FipsWatchParamKey
//
//  Synopsis:   Sets RegNotifyChangeKeyValue() on param key, initializes
//              debug level, then utilizes thread pool to wait on
//              changes to this registry key.  Enables dynamic debug
//              level changes, as this function will also be callback
//              if registry key modified.
//
//  Arguments:  pCtxt is actually a HANDLE to an event.  This event
//              will be triggered when key is modified.
//
//  Notes:      .
//
VOID
FipsWatchParamKey(
    PVOID    pCtxt,
    BOOLEAN  fWaitStatus)
{
    NTSTATUS    Status;
    LONG        lRes = ERROR_SUCCESS;
    DWORD       disp;

    if(g_hkFipsBase == NULL)
    {
        // First time we've been called.
        Status = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                SP_REG_FIPS_BASE_KEY,
                                0,
                                TEXT(""),
                                REG_OPTION_NON_VOLATILE,
                                KEY_READ,
                                NULL,
                                &g_hkFipsBase,
                                &disp);
        if(Status)
        {
            DebugLog((DEB_WARN,"Failed to open FIPS key: 0x%x\n", Status));
            return;
        }
    }

    if(pCtxt != NULL)
    {
        if (NULL != g_hFipsWait) 
        {
            Status = RtlDeregisterWait(g_hFipsWait);
            if(!NT_SUCCESS(Status))
            {
                DebugLog((DEB_WARN, "Failed to Deregister wait on registry key: 0x%x\n", Status));
                goto Reregister;
            }
        }

        lRes = RegNotifyChangeKeyValue(
                    g_hkFipsBase,
                    TRUE,
                    REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_LAST_SET,
                    (HANDLE)pCtxt,
                    TRUE);

        if (ERROR_SUCCESS != lRes) 
        {
            DebugLog((DEB_ERROR,"Debug RegNotify setup failed: 0x%x\n", lRes));
            // we're tanked now. No further notifications, so get this one
        }
    }

    SslReadRegOptions(FALSE);

Reregister:

    if(pCtxt != NULL)
    {
        Status = RtlRegisterWait(&g_hFipsWait,
                                 (HANDLE)pCtxt,
                                 FipsWatchParamKey,
                                 (HANDLE)pCtxt,
                                 INFINITE,
                                 WT_EXECUTEINPERSISTENTIOTHREAD|
                                 WT_EXECUTEONLYONCE);
    }
}                       

                        
BOOL 
SslReadRegOptions(
    BOOL fFirstTime)
{
    DWORD       err;
    DWORD       dwType;
    DWORD       fVal;
    DWORD       dwSize;
    DWORD       dwValue;
    HKEY        hKey;
    HKEY        hWriteKey;
    DWORD       disp;
    HKEY        hSubKey;
    DWORD       i;
    HKEY        hkProtocols = NULL;
    HKEY        hkCiphers = NULL;
    HKEY        hkHashes = NULL;
    HKEY        hkKeyExch = NULL;
    BOOL        fFipsMode = FALSE;
    BOOL        fSettingsChanged = FALSE;
    DWORD       dwOriginalValue;

    DebugLog((DEB_TRACE,"Load configuration parameters from registry.\n"));


    // "FipsAlgorithmPolicy"
    ReadRegistrySetting(
        g_hkFipsBase,
        0,
        SP_REG_FIPS_POLICY,
        &dwValue,
        0);
    if(dwValue == 1)
    {
        fFipsMode = TRUE;
    }
    if(fFipsMode != g_fFipsMode)
    {
        g_fFipsMode = fFipsMode;
        fSettingsChanged = TRUE;
    }


    //
    // Read top-level configuration options.
    //

    // Open top-level key that has write access.
    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                    SP_REG_KEY_BASE,
                    0,
                    KEY_READ | KEY_SET_VALUE,
                    &hWriteKey) != STATUS_SUCCESS)
    {
        hWriteKey = 0;
    }

    // "EventLogging"
    if(ReadRegistrySetting(
        g_hkBase,
        hWriteKey,
        SP_REG_VAL_EVENTLOG,
        &g_dwEventLogging,
        DEFAULT_EVENT_LOGGING_SETTING))
    {
        fSettingsChanged = TRUE;
    }

    // "ManualCredValidation"
    if(ReadRegistrySetting(
        g_hkBase,
        0,
        SP_REG_VAL_MANUAL_CRED_VALIDATION,
        &g_fManualCredValidation,
        MANUAL_CRED_VALIDATION_SETTING))
    {
        fSettingsChanged = TRUE;
    }

    // "ClientCacheTime"
    if(ReadRegistrySetting(
        g_hkBase,
        0,
        SP_REG_VAL_CLIENT_CACHE_TIME,
        &SchannelCache.dwClientLifespan,
        SP_CACHE_CLIENT_LIFESPAN))
    {
        fSettingsChanged = TRUE;
    }

    // "ServerCacheTime"
    if(ReadRegistrySetting(
        g_hkBase,
        0,
        SP_REG_VAL_SERVER_CACHE_TIME,
        &SchannelCache.dwServerLifespan,
        SP_CACHE_SERVER_LIFESPAN))
    {
        fSettingsChanged = TRUE;
    }

    // "MaximumCacheSize"
    if(ReadRegistrySetting(
        g_hkBase,
        0,
        SP_REG_VAL_MAXUMUM_CACHE_SIZE,
        &SchannelCache.dwMaximumEntries,
        SP_MAXIMUM_CACHE_ELEMENTS))
    {
        fSettingsChanged = TRUE;
    }

    if(fFirstTime)
    {
        SchannelCache.dwCacheSize = SchannelCache.dwMaximumEntries;
    }

    // "MultipleProcessClientCache"
    if(ReadRegistrySetting(
        g_hkBase,
        0,
        SP_REG_VAL_MULTI_PROC_CLIENT_CACHE,
        &g_fMultipleProcessClientCache,
        FALSE))
    {
        fSettingsChanged = TRUE;
    }

    if(hWriteKey)
    {
        RegCloseKey(hWriteKey);
        hWriteKey = 0;
    }


    //
    // Enable/Disable Protocols
    //

    if(fFipsMode)
    {
        // Disable everything except TLS.
        g_ProtEnabled = SP_PROT_TLS1;
    }
    else
    {
        DWORD dwProtEnabled = DEFAULT_ENABLED_PROTOCOLS_SETTING; 

        err = RegCreateKeyEx(   g_hkBase,
                                SP_REG_KEY_PROTOCOL,
                                0,
                                TEXT(""),
                                REG_OPTION_NON_VOLATILE,
                                KEY_READ,
                                NULL,
                                &hkProtocols,
                                &disp);

        if(err == ERROR_SUCCESS)
        {
            for(i=0; i < (sizeof(g_ProtMap)/sizeof(enamap)); i++)
            {
                if(g_ProtMap[i].Mask & SP_PROT_PCT1)
                {
                    if(g_fFranceLocale)
                    {
                        // Don't allow PCT to be enabled in France.
                        continue;
                    }
                }

                err = RegCreateKeyEx(   hkProtocols,
                                        g_ProtMap[i].pKey,
                                        0,
                                        TEXT(""),
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_READ,
                                        NULL,
                                        &hKey,
                                        &disp);
                if(!err)
                {
                    dwSize = sizeof(DWORD);
                    err = RegQueryValueEx(hKey, SP_REG_VAL_ENABLED, NULL, &dwType, (PUCHAR)&fVal, &dwSize);

                    if(!err)
                    {
                        if(fVal)
                        {
                            dwProtEnabled |= g_ProtMap[i].Mask;
                        }
                        else
                        {
                            dwProtEnabled &= ~g_ProtMap[i].Mask;
                        }
                    }

                    if(g_ProtMap[i].Mask & SP_PROT_PCT1_CLIENT)
                    {
                        // "DisabledByDefault"
                        ReadRegistrySetting(
                            hKey,
                            0,
                            SP_REG_VAL_DISABLED_BY_DEFAULT,
                            &g_PctClientDisabledByDefault,
                            PCT_CLIENT_DISABLED_SETTING);
                    }
                    if(g_ProtMap[i].Mask & SP_PROT_SSL2_CLIENT)
                    {
                        // "DisabledByDefault"
                        ReadRegistrySetting(
                            hKey,
                            0,
                            SP_REG_VAL_DISABLED_BY_DEFAULT,
                            &g_Ssl2ClientDisabledByDefault,
                            SSL2_CLIENT_DISABLED_SETTING);
                    }

                    RegCloseKey(hKey);
                }
            }

            RegCloseKey(hkProtocols);
        }

        if(g_ProtEnabled != dwProtEnabled)
        {
            g_ProtEnabled = dwProtEnabled;
            fSettingsChanged = TRUE;
        }
    }


    //
    // Enable/Disable Ciphers
    //

    if(fFipsMode)
    {
        // Disable everything except 3DES.
        for(i=0; i < g_cAvailableCiphers; i++)
        {
            if(g_AvailableCiphers[i].aiCipher != CALG_3DES)
            {
                g_AvailableCiphers[i].fProtocol = 0;
            }
        }
    }
    else
    {
        err = RegCreateKeyEx(   g_hkBase,
                                SP_REG_KEY_CIPHERS,
                                0,
                                TEXT(""),
                                REG_OPTION_NON_VOLATILE,
                                KEY_READ,
                                NULL,
                                &hkCiphers,
                                &disp);

        if(err == ERROR_SUCCESS)
        {
            for(i=0; i < g_cAvailableCiphers; i++)
            {
                dwOriginalValue = g_AvailableCiphers[i].fProtocol;

                g_AvailableCiphers[i].fProtocol = g_AvailableCiphers[i].fDefault;
                fVal = g_AvailableCiphers[i].fDefault;
                err = RegCreateKeyExA(  hkCiphers,
                                        g_AvailableCiphers[i].szName,
                                        0,
                                        "",
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_READ,
                                        NULL,
                                        &hKey,
                                        &disp);
                if(!err)
                {
                    dwSize = sizeof(DWORD);
                    err = RegQueryValueEx(hKey, SP_REG_VAL_ENABLED, NULL, &dwType, (PUCHAR)&fVal, &dwSize);

                    if(err)
                    {
                        fVal = g_AvailableCiphers[i].fDefault;
                    }
                    RegCloseKey(hKey);
                }
                g_AvailableCiphers[i].fProtocol &= fVal;

                if(g_AvailableCiphers[i].fProtocol != dwOriginalValue)
                {
                    fSettingsChanged = TRUE;
                }
            }

            RegCloseKey(hkCiphers);
        }
    }


    //
    // Enable/Disable Hashes
    //

    err = RegCreateKeyEx(   g_hkBase,
                            SP_REG_KEY_HASHES,
                            0,
                            TEXT(""),
                            REG_OPTION_NON_VOLATILE,
                            KEY_READ,
                            NULL,
                            &hkHashes,
                            &disp);

    if(err == ERROR_SUCCESS)
    {
        for(i = 0; i < g_cAvailableHashes; i++)
        {
            dwOriginalValue = g_AvailableHashes[i].fProtocol;

            g_AvailableHashes[i].fProtocol = g_AvailableHashes[i].fDefault;
            fVal = g_AvailableHashes[i].fDefault;
            err = RegCreateKeyExA(  hkHashes,
                                    g_AvailableHashes[i].szName,
                                    0,
                                    "",
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_READ,
                                    NULL,
                                    &hKey,
                                    &disp);
            if(!err)
            {
                dwSize = sizeof(DWORD);
                err = RegQueryValueEx(hKey, SP_REG_VAL_ENABLED, NULL, &dwType, (PUCHAR)&fVal, &dwSize);

                if(err)
                {
                    fVal = g_AvailableHashes[i].fDefault;
                }
                RegCloseKey(hKey);
            }
            g_AvailableHashes[i].fProtocol &= fVal;

            if(dwOriginalValue != g_AvailableHashes[i].fProtocol)
            {
                fSettingsChanged = TRUE;
            }
        }

        RegCloseKey(hkHashes);
    }


    //
    // Enable/Disable Key Exchange algs.
    //

    if(fFipsMode)
    {
        // Disable everything except RSA.
        for(i=0; i < g_cAvailableExch; i++)
        {
            if(g_AvailableExch[i].aiExch != CALG_RSA_KEYX && 
               g_AvailableExch[i].aiExch != CALG_RSA_SIGN)
            {
                g_AvailableExch[i].fProtocol = 0;
            }
        }
    }
    else
    {
        err = RegCreateKeyEx(   g_hkBase,
                                SP_REG_KEY_KEYEXCH,
                                0,
                                TEXT(""),
                                REG_OPTION_NON_VOLATILE,
                                KEY_READ,
                                NULL,
                                &hkKeyExch,
                                &disp);

        if(err == ERROR_SUCCESS)
        {
            for(i = 0; i < g_cAvailableExch; i++)
            {
                dwOriginalValue = g_AvailableExch[i].fProtocol;

                g_AvailableExch[i].fProtocol = g_AvailableExch[i].fDefault;
                fVal = g_AvailableExch[i].fDefault;
                err = RegCreateKeyExA(  hkKeyExch,
                                        g_AvailableExch[i].szName,
                                        0,
                                        "",
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_READ,
                                        NULL,
                                        &hKey,
                                        &disp);
                if(!err)
                {
                    dwSize = sizeof(DWORD);
                    err = RegQueryValueEx(hKey, SP_REG_VAL_ENABLED, NULL, &dwType, (PUCHAR)&fVal, &dwSize);

                    if(err)
                    {
                        fVal = g_AvailableExch[i].fDefault;
                    }
                    g_AvailableExch[i].fProtocol &= fVal;

                    RegCloseKey(hKey);
                }

                if(dwOriginalValue != g_AvailableExch[i].fProtocol)
                {
                    fSettingsChanged = TRUE;
                }
            }

            RegCloseKey(hkKeyExch);
        }
    }

    //
    // Purge the session cache.
    //

    if(g_fCacheInitialized && fSettingsChanged)
    {
        SPCachePurgeEntries(NULL,
                            0,
                            NULL,
                            SSL_PURGE_CLIENT_ALL_ENTRIES |
                            SSL_PURGE_SERVER_ALL_ENTRIES);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\lsa\spsspi.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       protos.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8-08-95   RichardW   Created
//
//----------------------------------------------------------------------------






SECURITY_STATUS PctTranslateError(SP_STATUS spRet);




///////////////////////////////////////////////////////
//
// Prototypes for PCT SSPI
//
///////////////////////////////////////////////////////


SECURITY_STATUS SEC_ENTRY
AcquireCredentialsHandleW(
    SEC_WCHAR SEC_FAR *         pszPrincipal,       // Name of principal
    SEC_WCHAR SEC_FAR *         pszPackageName,     // Name of package
    unsigned long               fCredentialUse,     // Flags indicating use
    void SEC_FAR *              pvLogonId,          // Pointer to logon ID
    void SEC_FAR *              pAuthData,          // Package specific data
    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func
    void SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey()
    PCredHandle                 phCredential,       // (out) Cred Handle
    PTimeStamp                  ptsExpiry           // (out) Lifetime (optional)
    );

SECURITY_STATUS SEC_ENTRY
AcquireCredentialsHandleA(
    SEC_CHAR SEC_FAR *         pszPrincipal,       // Name of principal
    SEC_CHAR SEC_FAR *         pszPackageName,     // Name of package
    unsigned long               fCredentialUse,     // Flags indicating use
    void SEC_FAR *              pvLogonId,          // Pointer to logon ID
    void SEC_FAR *              pAuthData,          // Package specific data
    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func
    void SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey()
    PCredHandle                 phCredential,       // (out) Cred Handle
    PTimeStamp                  ptsExpiry           // (out) Lifetime (optional)
    );


SECURITY_STATUS SEC_ENTRY
FreeCredentialsHandle(
    PCredHandle                 phCredential        // Handle to free
    );


SECURITY_STATUS SEC_ENTRY
InitializeSecurityContextW(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    SEC_WCHAR SEC_FAR *          pszTargetName,      // Name of target
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               Reserved1,          // Reserved, MBZ
    unsigned long               TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    unsigned long               Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    );

SECURITY_STATUS SEC_ENTRY
InitializeSecurityContextA(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    SEC_CHAR SEC_FAR *          pszTargetName,      // Name of target
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               Reserved1,          // Reserved, MBZ
    unsigned long               TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    unsigned long               Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    );


SECURITY_STATUS SEC_ENTRY
AcceptSecurityContext(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    PSecBufferDesc              pInput,             // Input buffer
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               TargetDataRep,      // Target Data Rep
    PCtxtHandle                 phNewContext,       // (out) New context handle
    PSecBufferDesc              pOutput,            // (inout) Output buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attributes
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    );

SECURITY_STATUS SEC_ENTRY
CompleteAuthToken(
    PCtxtHandle phContext,              // Context to complete
    PSecBufferDesc pToken               // Token to complete
    );

SECURITY_STATUS SEC_ENTRY
DeleteSecurityContext(
    PCtxtHandle                 phContext           // Context to delete
    );



SECURITY_STATUS SEC_ENTRY
ApplyControlToken(
    PCtxtHandle                 phContext,          // Context to modify
    PSecBufferDesc              pInput              // Input token to apply
    );


SECURITY_STATUS SEC_ENTRY
EnumerateSecurityPackagesW(
    unsigned long SEC_FAR *     pcPackages,         // Receives num. packages
    PSecPkgInfoW SEC_FAR *      ppPackageInfo       // Receives array of info
    );

SECURITY_STATUS SEC_ENTRY
EnumerateSecurityPackagesA(
    unsigned long SEC_FAR *     pcPackages,         // Receives num. packages
    PSecPkgInfoA SEC_FAR *      ppPackageInfo       // Receives array of info
    );


SECURITY_STATUS SEC_ENTRY
QuerySecurityPackageInfoW(
    SEC_WCHAR SEC_FAR *         pszPackageName,     // Name of package
    PSecPkgInfoW *              ppPackageInfo       // Receives package info
    );

SECURITY_STATUS SEC_ENTRY
QuerySecurityPackageInfoA(
    SEC_CHAR SEC_FAR *         pszPackageName,     // Name of package
    PSecPkgInfoA *              ppPackageInfo       // Receives package info
    );


SECURITY_STATUS SEC_ENTRY
FreeContextBuffer(
    void SEC_FAR *      pvContextBuffer
    );


SECURITY_STATUS SEC_ENTRY
QueryCredentialsAttributesW(
    PCredHandle phCredential,
    ULONG ulAttribute,
    PVOID pBuffer
    );


SECURITY_STATUS SEC_ENTRY
ImpersonateSecurityContext(
    PCtxtHandle                 phContext           // Context to impersonate
    );


SECURITY_STATUS SEC_ENTRY
RevertSecurityContext(
    PCtxtHandle                 phContext           // Context from which to re
    );


SECURITY_STATUS SEC_ENTRY
QueryContextAttributesW(
    PCtxtHandle                 phContext,          // Context to query
    unsigned long               ulAttribute,        // Attribute to query
    void SEC_FAR *              pBuffer             // Buffer for attributes
    );

SECURITY_STATUS SEC_ENTRY
QueryContextAttributesA(
    PCtxtHandle                 phContext,          // Context to query
    unsigned long               ulAttribute,        // Attribute to query
    void SEC_FAR *              pBuffer             // Buffer for attributes
    );


SECURITY_STATUS SEC_ENTRY
MakeSignature(
    PCtxtHandle         phContext,
    DWORD               fQOP,
    PSecBufferDesc      pMessage,
    ULONG               MessageSeqNo
    );

SECURITY_STATUS SEC_ENTRY
VerifySignature(
    PCtxtHandle     phContext,
    PSecBufferDesc  pMessage,
    ULONG           MessageSeqNo,
    DWORD *         pfQOP
    );


SECURITY_STATUS SEC_ENTRY
SealMessage(
    PCtxtHandle         phContext,
    DWORD               fQOP,
    PSecBufferDesc      pMessage,
    ULONG               MessageSeqNo
    );


SECURITY_STATUS SEC_ENTRY
UnsealMessage(
    PCtxtHandle         phContext,
    PSecBufferDesc      pMessage,
    ULONG               MessageSeqNo,
    DWORD *             pfQOP
    );

PSPContext
ValidateContextHandle(PCtxtHandle phContext);

PSPCredentialGroup
ValidateCredentialHandle(
    PCredHandle     phCred);    

SECURITY_STATUS SEC_ENTRY
SetContextAttributesW(
    PCtxtHandle phContext,              // Context to Set
    unsigned long ulAttribute,          // Attribute to Set
    void SEC_FAR * pBuffer,             // Buffer for attributes
    unsigned long cbBuffer              // Size (in bytes) of Buffer
    );

SECURITY_STATUS SEC_ENTRY
SetContextAttributesA(
    PCtxtHandle phContext,              // Context to Set
    unsigned long ulAttribute,          // Attribute to Set
    void SEC_FAR * pBuffer,             // Buffer for attributes
    unsigned long cbBuffer              // Size (in bytes) of Buffer
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\lsa\perfmon.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1999
//
// File:        perfmon.h
//
// Contents:    Schannel performance counter functions.
//
// Functions:   
//
// History:     04-11-2000   jbanes    Created
//
//------------------------------------------------------------------------

#include <winperf.h>
#include <sslperf.h>

//
//  Perf Gen Resource object type counter definitions.
//
//  This is the counter structure presently returned by the generator
//

typedef struct _SSLPERF_DATA_DEFINITION 
{
    PERF_OBJECT_TYPE		SslPerfObjectType;
    PERF_COUNTER_DEFINITION	CacheEntriesDef;
    PERF_COUNTER_DEFINITION	ActiveEntriesDef;
    PERF_COUNTER_DEFINITION	HandshakeCountDef;
    PERF_COUNTER_DEFINITION	ReconnectCountDef;
} SSLPERF_DATA_DEFINITION;

//
// This is the block of data that corresponds to each instance of the 
// object. This structure will immediately follow the instance definition
// data structure
//

typedef struct _SSLPERF_COUNTER {
    PERF_COUNTER_BLOCK      CounterBlock;
    DWORD                   dwCacheEntries;
    DWORD                   dwActiveEntries;
    DWORD                   dwHandshakeCount;
    DWORD                   dwReconnectCount;
} SSLPERF_COUNTER, *PSSLPERF_COUNTER;


#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4

DWORD
GetQueryType (
    IN LPWSTR lpValue);

BOOL
MonBuildInstanceDefinition(
    PERF_INSTANCE_DEFINITION *pBuffer,
    PVOID *pBufferNext,
    DWORD ParentObjectTitleIndex,
    DWORD ParentObjectInstance,
    DWORD UniqueID,
    LPWSTR Name);

BOOL
IsNumberInUnicodeList(
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\lsa\proto.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       proto.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10-02-96   RichardW   Created
//
//----------------------------------------------------------------------------
#include <align.h>

//
// RELOCATE_ONE - Relocate a single pointer in a client buffer.
//
// Note: this macro is dependent on parameter names as indicated in the
//       description below.  On error, this macro goes to 'Cleanup' with
//       'Status' set to the NT Status code.
//
// The MaximumLength is forced to be Length.
//
// Define a macro to relocate a pointer in the buffer the client passed in
// to be relative to 'ProtocolSubmitBuffer' rather than being relative to
// 'ClientBufferBase'.  The result is checked to ensure the pointer and
// the data pointed to is within the first 'SubmitBufferSize' of the
// 'ProtocolSubmitBuffer'.
//
// The relocated field must be aligned to a WCHAR boundary.
//
//  _q - Address of UNICODE_STRING structure which points to data to be
//       relocated
//

#define RELOCATE_ONE( _q ) \
    {                                                                       \
        ULONG_PTR Offset;                                                   \
                                                                            \
        Offset = (((PUCHAR)((_q)->Buffer)) - ((PUCHAR)ClientBufferBase));   \
        if ( Offset >= SubmitBufferSize ||                                  \
             Offset + (_q)->Length > SubmitBufferSize ||                    \
             !COUNT_IS_ALIGNED( Offset, ALIGN_WCHAR) ) {                    \
                                                                            \
            Status = STATUS_INVALID_PARAMETER;                              \
            goto Cleanup;                                                   \
        }                                                                   \
                                                                            \
        (_q)->Buffer = (PWSTR)(((PUCHAR)ProtocolSubmitBuffer) + Offset);    \
        (_q)->MaximumLength = (_q)->Length ;                                \
    }

//
// NULL_RELOCATE_ONE - Relocate a single (possibly NULL) pointer in a client
//  buffer.
//
// This macro special cases a NULL pointer then calls RELOCATE_ONE.  Hence
// it has all the restrictions of RELOCATE_ONE.
//
//
//  _q - Address of UNICODE_STRING structure which points to data to be
//       relocated
//

#define NULL_RELOCATE_ONE( _q ) \
    {                                                                       \
        if ( (_q)->Buffer == NULL ) {                                       \
            if ( (_q)->Length != 0 ) {                                      \
                Status = STATUS_INVALID_PARAMETER;                          \
                goto Cleanup;                                               \
            }                                                               \
        } else if ( (_q)->Length == 0 ) {                                   \
            (_q)->Buffer = NULL;                                            \
        } else {                                                            \
            RELOCATE_ONE( _q );                                             \
        }                                                                   \
    }



SpInitializeFn                  SpInitialize;

SpGetInfoFn                     SpUniGetInfo;
SpGetInfoFn                     SpSslGetInfo;

SpAcceptCredentialsFn           SpAcceptCredentials;

SpAcquireCredentialsHandleFn    SpUniAcquireCredentialsHandle;

SpFreeCredentialsHandleFn       SpFreeCredentialsHandle;
SpQueryCredentialsAttributesFn  SpQueryCredentialsAttributes;
SpSaveCredentialsFn             SpSaveCredentials;
SpGetCredentialsFn              SpGetCredentials;
SpDeleteCredentialsFn           SpDeleteCredentials;

SpInitLsaModeContextFn          SpInitLsaModeContext;
SpDeleteContextFn               SpDeleteContext;
SpAcceptLsaModeContextFn        SpAcceptLsaModeContext;

LSA_AP_LOGON_TERMINATED         SpLogonTerminated;
SpApplyControlTokenFn           SpApplyControlToken;
LSA_AP_CALL_PACKAGE             SpCallPackage;
LSA_AP_CALL_PACKAGE             SpCallPackageUntrusted;
LSA_AP_CALL_PACKAGE_PASSTHROUGH SpCallPackagePassthrough;
SpShutdownFn                    SpShutdown;
SpGetUserInfoFn                 SpGetUserInfo;

SpInstanceInitFn                SpInstanceInit;
SpInitUserModeContextFn         SpInitUserModeContext;
SpMakeSignatureFn               SpMakeSignature;
SpVerifySignatureFn             SpVerifySignature;
SpSealMessageFn                 SpSealMessage;
SpUnsealMessageFn               SpUnsealMessage;
SpGetContextTokenFn             SpGetContextToken;
SpQueryContextAttributesFn      SpUserQueryContextAttributes;
SpQueryContextAttributesFn      SpLsaQueryContextAttributes;
SpSetContextAttributesFn        SpSetContextAttributes;
SpDeleteContextFn               SpDeleteUserModeContext;
SpCompleteAuthTokenFn           SpCompleteAuthToken;
SpFormatCredentialsFn           SpFormatCredentials;
SpMarshallSupplementalCredsFn   SpMarshallSupplementalCreds;
SpGetExtendedInformationFn      SpGetExtendedInformation;
SpExportSecurityContextFn       SpExportSecurityContext;
SpImportSecurityContextFn       SpImportSecurityContext;

SECURITY_STATUS
SEC_ENTRY
SpSslGetInfo(
    PSecPkgInfo pInfo);

SECURITY_STATUS PctTranslateError(SP_STATUS spRet);

BOOL
SslRelocateToken(
    IN HLOCATOR Locator,
    OUT HLOCATOR * NewLocator);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\lsa\sslpi.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       sslp.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10-02-96   RichardW   Created
//
//----------------------------------------------------------------------------

#define SECURITY_PACKAGE
#define _SSL_WSP_
#include <spbasei.h>
#include <security.h>
#include <secint.h>

#include "ssldebug.h"
#include "proto.h"
#include "userctxt.h"

#define CALLBACK_GET_KEYS   1
#define CALLBACK_DO_MAPPING 2


extern  HINSTANCE   hDllInstance ;
extern  PLSA_SECPKG_FUNCTION_TABLE LsaTable ;
extern  TOKEN_SOURCE SslTokenSource ;
extern  SECURITY_STRING SslNamePrefix ;
extern  SECURITY_STRING SslComputerName ;
extern  SECURITY_STRING SslDomainName ;
extern  SECURITY_STRING SslPackageName ;
extern  SECURITY_STRING SslMsvName ;

NTSTATUS
NTAPI
SslDoClientRequest(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLen,
    OUT PVOID * ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS
NTAPI
SslMapExternalCredential(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLen,
    OUT PVOID * ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS
SslDuplicateString(
    PUNICODE_STRING Dest,
    PUNICODE_STRING Source
    );


#define REQ_UPN_MAPPING          0x00000010
#define REQ_SUBJECT_MAPPING      0x00000020
#define REQ_ISSUER_MAPPING       0x00000040
#define REQ_ISSUER_CHAIN_MAPPING 0x00000080

typedef struct _SSL_CERT_NAME_INFO {
    ULONG IssuerOffset;     // ASN1 encoded
    ULONG IssuerLength;
} SSL_CERT_NAME_INFO, * PSSL_CERT_NAME_INFO;

typedef struct _SSL_CERT_LOGON_REQ {
    ULONG MessageType ;
    ULONG Length ;
    ULONG OffsetCertificate ;
    ULONG CertLength ;
    ULONG Flags;
    ULONG CertCount;
    SSL_CERT_NAME_INFO NameInfo[1];
} SSL_CERT_LOGON_REQ, * PSSL_CERT_LOGON_REQ ;

typedef struct _SSL_CERT_LOGON_RESP {
    ULONG MessageType ;
    ULONG Length ;
    ULONG OffsetAuthData ;
    ULONG AuthDataLength ;
    ULONG Flags ;
    ULONG OffsetDomain ;
    ULONG DomainLength ;
    ULONG Align ;
} SSL_CERT_LOGON_RESP, * PSSL_CERT_LOGON_RESP ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\lsa\stubs.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       stubs.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8-01-95   RichardW   Created
//
//----------------------------------------------------------------------------


#include "sslp.h"
#include "spsspi.h"
#include <cert509.h>
#include <rsa.h>


CHAR CertTag[ 13 ] = { 0x04, 0x0b, 'c', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e' };

SecurityFunctionTableW SPFunctionTable = {
    SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION,
    EnumerateSecurityPackagesW,
    NULL,
    AcquireCredentialsHandleW,
    FreeCredentialsHandle,
    NULL,
    InitializeSecurityContextW,
    AcceptSecurityContext,
    CompleteAuthToken,
    DeleteSecurityContext,
    ApplyControlToken,
    QueryContextAttributesW,
    ImpersonateSecurityContext,
    RevertSecurityContext,
    MakeSignature,
    VerifySignature,
    FreeContextBuffer,
    QuerySecurityPackageInfoW,
    SealMessage,
    UnsealMessage,
    NULL, /* GrantProxyW */
    NULL, /* RevokeProxyW */
    NULL, /* InvokeProxyW */
    NULL, /* RenewProxyW */
    QuerySecurityContextToken,
    SealMessage,
    UnsealMessage,
    SetContextAttributesW
    };

SecurityFunctionTableA SPFunctionTableA = {
    SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION,
    EnumerateSecurityPackagesA,
    NULL,
    AcquireCredentialsHandleA,
    FreeCredentialsHandle,
    NULL,
    InitializeSecurityContextA,
    AcceptSecurityContext,
    CompleteAuthToken,
    DeleteSecurityContext,
    ApplyControlToken,
    QueryContextAttributesA,
    ImpersonateSecurityContext,
    RevertSecurityContext,
    MakeSignature,
    VerifySignature,
    FreeContextBuffer,
    QuerySecurityPackageInfoA,
    SealMessage,
    UnsealMessage,
    NULL, /* GrantProxyA */
    NULL, /* RevokeProxyA */
    NULL, /* InvokeProxyA */
    NULL, /* RenewProxyA */
    QuerySecurityContextToken,
    SealMessage,
    UnsealMessage,
    SetContextAttributesA
    };


PSecurityFunctionTableW SEC_ENTRY
InitSecurityInterfaceW(
    VOID )
{
    return(&SPFunctionTable);
}

PSecurityFunctionTableA SEC_ENTRY
InitSecurityInterfaceA(
    VOID )
{
    return(&SPFunctionTableA);
}



SECURITY_STATUS SEC_ENTRY
FreeContextBuffer(
    void SEC_FAR *      pvContextBuffer
    )
{
    SPExternalFree( pvContextBuffer );
    return(SEC_E_OK);
}



SECURITY_STATUS SEC_ENTRY
SecurityPackageControl(
    SEC_WCHAR SEC_FAR *      pszPackageName,
    unsigned long           dwFunctionCode,
    unsigned long           cbInputBuffer,
    unsigned char SEC_FAR * pbInputBuffer,
    unsigned long SEC_FAR * pcbOutputBuffer,
    unsigned char SEC_FAR * pbOutputBuffer)
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}

SECURITY_STATUS PctTranslateError(SP_STATUS spRet)
{
    if(HRESULT_FACILITY(spRet) == FACILITY_SECURITY)
    {
        return (spRet);
    }

    switch(spRet) {
        case PCT_ERR_OK: return SEC_E_OK;
        case PCT_ERR_BAD_CERTIFICATE: return SEC_E_INVALID_TOKEN;
        case PCT_ERR_CLIENT_AUTH_FAILED: return SEC_E_INVALID_TOKEN;
        case PCT_ERR_ILLEGAL_MESSAGE: return SEC_E_INVALID_TOKEN;
        case PCT_ERR_INTEGRITY_CHECK_FAILED: return SEC_E_MESSAGE_ALTERED;
        case PCT_ERR_SERVER_AUTH_FAILED: return SEC_E_INVALID_TOKEN;
        case PCT_ERR_SPECS_MISMATCH: return SEC_E_ALGORITHM_MISMATCH;
        case PCT_ERR_SSL_STYLE_MSG: return SEC_E_INVALID_TOKEN;
        case SEC_I_INCOMPLETE_CREDENTIALS: return SEC_I_INCOMPLETE_CREDENTIALS;
        case PCT_ERR_RENEGOTIATE: return SEC_I_RENEGOTIATE;
        case PCT_ERR_UNKNOWN_CREDENTIAL: return SEC_E_UNKNOWN_CREDENTIALS;

        case CERT_E_UNTRUSTEDROOT:          return SEC_E_UNTRUSTED_ROOT;
        case CERT_E_EXPIRED:                return SEC_E_CERT_EXPIRED;
        case CERT_E_VALIDITYPERIODNESTING:  return SEC_E_CERT_EXPIRED;
        case CERT_E_REVOKED:                return CRYPT_E_REVOKED;
        case CERT_E_CN_NO_MATCH:            return SEC_E_WRONG_PRINCIPAL;

        case PCT_INT_BAD_CERT: return SEC_E_INVALID_TOKEN;
        case PCT_INT_CLI_AUTH: return SEC_E_INVALID_TOKEN;
        case PCT_INT_ILLEGAL_MSG: return  SEC_E_INVALID_TOKEN;
        case PCT_INT_SPECS_MISMATCH: return SEC_E_ALGORITHM_MISMATCH;
        case PCT_INT_INCOMPLETE_MSG: return SEC_E_INCOMPLETE_MESSAGE;
        case PCT_INT_MSG_ALTERED: return SEC_E_MESSAGE_ALTERED;
        case PCT_INT_INTERNAL_ERROR: return SEC_E_INTERNAL_ERROR;
        case PCT_INT_DATA_OVERFLOW: return SEC_E_INTERNAL_ERROR;
        case SEC_E_INCOMPLETE_CREDENTIALS: return SEC_E_INCOMPLETE_CREDENTIALS;
        case PCT_INT_RENEGOTIATE: return SEC_I_RENEGOTIATE;
        case PCT_INT_UNKNOWN_CREDENTIAL: return SEC_E_UNKNOWN_CREDENTIALS;

        case PCT_INT_BUFF_TOO_SMALL:                return SEC_E_BUFFER_TOO_SMALL;
        case SEC_E_BUFFER_TOO_SMALL:                return SEC_E_BUFFER_TOO_SMALL;

        default: return SEC_E_INTERNAL_ERROR;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   SslGenerateRandomBits
//
//  Synopsis:   Hook for setup to get a good random stream
//
//  Arguments:  [pRandomData] --
//              [cRandomData] --
//
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
WINAPI
SslGenerateRandomBits(
    PUCHAR      pRandomData,
    LONG        cRandomData
    )
{
    if(!SchannelInit(TRUE))
    {
        return;
    }

    GenerateRandomBits(pRandomData, (ULONG)cRandomData);
}


//+---------------------------------------------------------------------------
//
//  Function:   SslGenerateKeyPair
//
//  Synopsis:   Generates a public/private key pair, protected by password
//
//  Arguments:  [pCerts]      --
//              [pszDN]       --
//              [pszPassword] --
//              [Bits]        --
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
WINAPI
SslGenerateKeyPair(
    PSSL_CREDENTIAL_CERTIFICATE pCerts,
    PSTR pszDN,
    PSTR pszPassword,
    DWORD Bits )
{
    if(!SchannelInit(TRUE))
    {
        return FALSE;
    }

#ifdef SCHANNEL_EXPORT
    if ( Bits > 1024 )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return( FALSE );
    }
#endif
    return GenerateKeyPair(pCerts, pszDN, pszPassword, Bits);
}


//+---------------------------------------------------------------------------
//
//  Function:   SslGetMaximumKeySize
//
//  Synopsis:   Returns maximum public key size
//
//  Arguments:  [Reserved] --
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
SslGetMaximumKeySize(
    DWORD   Reserved )
{

#ifdef SCHANNEL_EXPORT
    return( 1024 );
#else
    return( 2048 );
#endif

}


//+---------------------------------------------------------------------------
//
//  Function:   SslFreeCertificate
//
//  Synopsis:   Frees a certificate created from SslCrackCertificate
//
//  Arguments:  [pCertificate] --
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
WINAPI
SslFreeCertificate(
    PX509Certificate    pCertificate)
{
    if ( pCertificate )
    {

        SPExternalFree(pCertificate->pPublicKey);
        SPExternalFree(pCertificate);
    }
}




//+---------------------------------------------------------------------------
//
//  Function:   SslCrackCertificate
//
//  Synopsis:   Cracks a X509 certificate into remotely easy format
//
//  Arguments:  [pbCertificate] --
//              [cbCertificate] --
//              [dwFlags]       --
//              [ppCertificate] --
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
WINAPI
SslCrackCertificate(
    PUCHAR              pbCertificate,
    DWORD               cbCertificate,
    DWORD               dwFlags,
    PX509Certificate *  ppCertificate)
{


    PX509Certificate    pResult = NULL;
    PCCERT_CONTEXT      pContext = NULL;
    DWORD               cbIssuer;
    DWORD               cbSubject;

    if(!SchannelInit(TRUE))
    {
        return FALSE;
    }

    if (dwFlags & CF_CERT_FROM_FILE)
    {
        if (cbCertificate < CERT_HEADER_LEN + 1 )
        {
            goto error;
        }

        //
        // Sleazy quick check.  Some CAs wrap certs in a cert wrapper.
        // Some don't.  Some do both, but we won't mention any names.
        // Quick check for the wrapper tag.  If so, scoot in by enough
        // to bypass it (17 bytes. Sheesh).
        //

        if ( memcmp( pbCertificate + 4, CertTag, sizeof( CertTag ) ) == 0 )
        {
            pbCertificate += CERT_HEADER_LEN;
            cbCertificate -= CERT_HEADER_LEN;
        }
    }



    pContext = CertCreateCertificateContext(X509_ASN_ENCODING, pbCertificate, cbCertificate);
    if(pContext == NULL)
    {
        SP_LOG_RESULT(GetLastError());
        goto error;
    }

    if(0 >= (cbSubject = CertNameToStrA(pContext->dwCertEncodingType,
                                 &pContext->pCertInfo->Subject,
                                 CERT_X500_NAME_STR | CERT_NAME_STR_NO_PLUS_FLAG,
                                 NULL, 0)))
    {
        SP_LOG_RESULT(GetLastError());
        goto error;
    }

    if(0 >= (cbIssuer = CertNameToStrA(pContext->dwCertEncodingType,
                                 &pContext->pCertInfo->Issuer,
                                 CERT_X500_NAME_STR | CERT_NAME_STR_NO_PLUS_FLAG,
                                 NULL, 0)))
    {
        SP_LOG_RESULT(GetLastError());
        goto error;
    }


    pResult = SPExternalAlloc(sizeof(X509Certificate) + cbIssuer + cbSubject + 2);
    if(pResult == NULL)
    {
        goto error;
    }
    pResult->pPublicKey = NULL;
    pResult->pszIssuer = (PUCHAR)(pResult + 1);
    pResult->pszSubject = pResult->pszIssuer + cbIssuer;

    pResult->Version = pContext->pCertInfo->dwVersion;
    memcpy(pResult->SerialNumber,
           pContext->pCertInfo->SerialNumber.pbData,
           min(sizeof(pResult->SerialNumber), pContext->pCertInfo->SerialNumber.cbData));
    pResult->ValidFrom = pContext->pCertInfo->NotBefore;
    pResult->ValidUntil = pContext->pCertInfo->NotAfter;

    if(0 >= CertNameToStrA(pContext->dwCertEncodingType,
                             &pContext->pCertInfo->Issuer,
                             CERT_X500_NAME_STR | CERT_NAME_STR_NO_PLUS_FLAG,
                             pResult->pszIssuer, cbIssuer))
    {
        SP_LOG_RESULT(GetLastError());
        goto error;
    }

    if(0 >= CertNameToStrA(pContext->dwCertEncodingType,
                                 &pContext->pCertInfo->Subject,
                                 CERT_X500_NAME_STR | CERT_NAME_STR_NO_PLUS_FLAG,
                                 pResult->pszSubject, cbSubject))
    {
        SP_LOG_RESULT(GetLastError());
        goto error;
    }

    {
        BSAFE_PUB_KEY *pk;
        PUBLICKEY  * pPubKey = NULL;
        SP_STATUS pctRet;
        DWORD cbPublicKey;

        pResult->pPublicKey = SPExternalAlloc(sizeof(PctPublicKey) + sizeof(BSAFE_PUB_KEY));
        if(pResult->pPublicKey == NULL)
        {
            goto error;
        }
        pResult->pPublicKey->Type = 0;
        pResult->pPublicKey->cbKey = sizeof(BSAFE_PUB_KEY);

        pk = (BSAFE_PUB_KEY *)pResult->pPublicKey->pKey;
        pk->magic = RSA1;

        pctRet = SPPublicKeyFromCert(pContext, &pPubKey, NULL);

        if(pctRet == PCT_ERR_OK)
        {
            if(pPubKey->pPublic->aiKeyAlg == CALG_RSA_KEYX)
            {
                RSAPUBKEY *pRsaKey = (RSAPUBKEY *)(pPubKey->pPublic + 1);
                pk->keylen = pRsaKey->bitlen/8;
                pk->bitlen = pRsaKey->bitlen;
                pk->datalen = pk->bitlen/8 - 1;
                pk->pubexp = pRsaKey->pubexp;
            }
            else
            {
                DHPUBKEY *pDHKey = (DHPUBKEY *)(pPubKey->pPublic + 1);
                pk->keylen = pDHKey->bitlen/8;
                pk->bitlen = pDHKey->bitlen/8;
                pk->datalen = pk->bitlen/8 - 1;
                pk->pubexp = 0;

            }
            SPExternalFree(pPubKey);
        }
        else
        {
            goto error;
        }

    }
    CertFreeCertificateContext(pContext);

    *ppCertificate = pResult;
    return TRUE;

error:
    if(pContext)
    {
        CertFreeCertificateContext(pContext);
    }
    if(pResult)
    {
        if(pResult->pPublicKey)
        {
            SPExternalFree(pResult->pPublicKey);
        }
        SPExternalFree(pResult);
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   SslLoadCertificate
//
//  Synopsis:   Not supported.
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
WINAPI
SslLoadCertificate(
    PUCHAR      pbCertificate,
    DWORD       cbCertificate,
    BOOL        AddToWellKnownKeys)
{
    return FALSE;
}


BOOL
SslGetClientProcess(ULONG *pProcessID)
{
    SECPKG_CALL_INFO CallInfo;
    SECURITY_STATUS Status;

    if(LsaTable == NULL)
    {
        *pProcessID = GetCurrentProcessId();
        return TRUE;
    }

    if(LsaTable->GetCallInfo(&CallInfo))
    {
        *pProcessID = CallInfo.ProcessId;
        return TRUE;
    }
    else
    {
        *pProcessID = -1;
        return FALSE;
    }
}

BOOL
SslGetClientThread(ULONG *pThreadID)
{
    SECPKG_CALL_INFO CallInfo;
    SECURITY_STATUS Status;

    if(LsaTable == NULL)
    {
        *pThreadID = GetCurrentThreadId();
        return TRUE;
    }

    if(LsaTable->GetCallInfo(&CallInfo))
    {
        *pThreadID = CallInfo.ThreadId;
        return TRUE;
    }
    else
    {
        *pThreadID = -1;
        return FALSE;
    }
}

BOOL
SslImpersonateClient(void)
{
    SECPKG_CALL_INFO CallInfo;
    SECURITY_STATUS Status;

    // Don't impersonate if we're in the client process.
    if(LsaTable == NULL)
    {
        return FALSE;
    }

    // Don't impersonate if the client is running in the lsass process.
    if(LsaTable->GetCallInfo(&CallInfo))
    {
        if(CallInfo.ProcessId == GetCurrentProcessId())
        {
//            DebugLog((DEB_WARN, "Running locally, so don't impersonate.\n"));
            return FALSE;
        }
    }

    Status = LsaTable->ImpersonateClient();
    if(!NT_SUCCESS(Status))
    {
        SP_LOG_RESULT(Status);
        return FALSE;
    }

    return TRUE;
}

NTSTATUS
SslGetClientLogonId(LUID *pLogonId)
{
    SECPKG_CLIENT_INFO ClientInfo;
    SECURITY_STATUS Status;

    memset(pLogonId, 0, sizeof(LUID));

    Status = LsaTable->GetClientInfo(&ClientInfo);
    if(NT_SUCCESS(Status))
    {
        *pLogonId = ClientInfo.LogonId;
    }

    return Status;
}

PVOID SPExternalAlloc(DWORD cbLength)
{
    if(LsaTable)
    {
        // Lsass process
        return LsaTable->AllocateLsaHeap(cbLength);
    }
    else
    {
        // Application process
        return LocalAlloc(LPTR, cbLength);
    }
}

VOID SPExternalFree(PVOID pMemory)
{
    if(LsaTable)
    {
        // Lsass process
        LsaTable->FreeLsaHeap(pMemory);
    }
    else
    {
        // Application process
        LocalFree(pMemory);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\lsa\userctxt.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       userctxt.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10-10-96   RichardW   Created
//
//----------------------------------------------------------------------------

#include "sslp.h"

#define             SCHANNEL_USERLIST_COUNT         (16)    // count of lists
#define             SCHANNEL_USERLIST_LOCK_COUNT    (2)     // count of locks

RTL_RESOURCE        SslContextLock[ SCHANNEL_USERLIST_LOCK_COUNT ];
LIST_ENTRY          SslContextList[ SCHANNEL_USERLIST_COUNT ] ;

ULONG
HandleToListIndex(
    ULONG_PTR ContextHandle
    );

ULONG
__inline
ListIndexToLockIndex(
    ULONG ListIndex
    );



//+---------------------------------------------------------------------------
//
//  Function:   SslInitContextManager
//
//  Synopsis:   Initializes the context manager controls
//
//  History:    10-10-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
SslInitContextManager(
    VOID
    )
{
    ULONG Index;
    NTSTATUS Status = STATUS_SUCCESS;

    for( Index=0 ; Index < SCHANNEL_USERLIST_LOCK_COUNT ; Index++ )
    {
        __try {
            RtlInitializeResource (&SslContextLock[Index]);
        } __except(EXCEPTION_EXECUTE_HANDLER)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }
    }

    if( !NT_SUCCESS(Status) )
    {
        DebugLog(( DEB_ERROR, "SslInitContextManager failed!\n" ));
        return FALSE;
    }

    for( Index = 0 ; Index < SCHANNEL_USERLIST_COUNT ; Index++ )
    {
        InitializeListHead( &SslContextList[Index] );
    }

    return( TRUE );
}

#if 0
VOID
SslFreeUserContextElements(PSPContext pContext)
{
    if(pContext->hReadKey)
    {
        if(!CryptDestroyKey(pContext->hReadKey))
        {
            SP_LOG_RESULT(GetLastError());
        }
    }
    pContext->hReadKey = 0;

    if(pContext->hReadMAC)
    {
        if(!CryptDestroyKey(pContext->hReadMAC))
        {
            SP_LOG_RESULT(GetLastError());
        }
    }
    pContext->hReadMAC = 0;

    if(pContext->hWriteKey)
    {
        if(!CryptDestroyKey(pContext->hWriteKey))
        {
            SP_LOG_RESULT(GetLastError());
        }
    }
    pContext->hWriteKey = 0;

    if(pContext->hWriteMAC)
    {
        if(!CryptDestroyKey(pContext->hWriteMAC))
        {
            SP_LOG_RESULT(GetLastError());
        }
    }
    pContext->hWriteMAC = 0;
}
#endif

SECURITY_STATUS
SslAddUserContext(
    IN LSA_SEC_HANDLE LsaHandle,
    IN HANDLE Token,    // optional
    IN PSecBuffer ContextData,
    IN BOOL fImportedContext)
{
    DWORD   Size;
    PSSL_USER_CONTEXT Context ;
    SP_STATUS Status ;
    ULONG ListIndex;
    ULONG LockIndex;

    DebugLog(( DEB_TRACE, "SslAddUserContext: 0x%p\n", LsaHandle ));

    if ( ContextData->cbBuffer < sizeof( SPPackedContext ) )
    {
        return( SEC_E_INVALID_TOKEN );
    }

    if(!fImportedContext)
    {
        Context = SslFindUserContext( LsaHandle );

        if ( Context )
        {
            DebugLog(( DEB_TRACE, "Replacing existing context!\n" ));

            // Destroy elements of existing context.
            LsaContextDelete(Context->pContext);
            SPExternalFree(Context->pContext);
            Context->pContext = NULL;

            Status = SPContextDeserialize( ContextData->pvBuffer,
                                           &Context->pContext);

            if(Status != PCT_ERR_OK)
            {
                return SP_LOG_RESULT(SEC_E_DECRYPT_FAILURE);
            }

            return( SEC_E_OK );
        }
    }

    Context = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                        sizeof( SSL_USER_CONTEXT ));

    if ( !Context )
    {
        return( SEC_E_INSUFFICIENT_MEMORY );
    }

    Status = SPContextDeserialize( ContextData->pvBuffer,
                                   &Context->pContext);

    if(Status != PCT_ERR_OK)
    {
        LocalFree(Context);
        return SP_LOG_RESULT(SEC_E_DECRYPT_FAILURE);
    }

    if(ARGUMENT_PRESENT(Token))
    {
        Context->pContext->RipeZombie->hLocator = (HLOCATOR)Token;
    }

    Context->LsaHandle = LsaHandle ;
    Context->Align = ContextData->cbBuffer ;

    ListIndex = HandleToListIndex( LsaHandle );
    LockIndex = ListIndexToLockIndex( ListIndex );

    RtlAcquireResourceExclusive( &SslContextLock[LockIndex], TRUE );

    InsertTailList( &SslContextList[ListIndex], &Context->List );

    RtlReleaseResource( &SslContextLock[LockIndex] );

    return( SEC_E_OK );
}

PSSL_USER_CONTEXT
SslReferenceUserContext(
    IN LSA_SEC_HANDLE LsaHandle,
    IN BOOLEAN        Delete
    )
{
    PLIST_ENTRY List ;
    PSSL_USER_CONTEXT Context = NULL ;
    ULONG ListIndex;
    ULONG LockIndex;

    ListIndex = HandleToListIndex( LsaHandle );
    LockIndex = ListIndexToLockIndex( ListIndex );

    if( !Delete )
    {
        RtlAcquireResourceShared( &SslContextLock[LockIndex], TRUE );
    } else {
        RtlAcquireResourceExclusive( &SslContextLock[LockIndex], TRUE );
    }

    List = SslContextList[ListIndex].Flink ;

    while ( List != &SslContextList[ListIndex] )
    {
        Context = CONTAINING_RECORD( List, SSL_USER_CONTEXT, List.Flink );

        if ( Context->LsaHandle == LsaHandle )
        {
            if( Delete )
            {
                RemoveEntryList( &Context->List );
            }

            break;
        }

        Context = NULL ;

        List = List->Flink ;
    }

    RtlReleaseResource( &SslContextLock[LockIndex] );

    return( Context );
}

PSSL_USER_CONTEXT
SslFindUserContext(
    IN LSA_SEC_HANDLE LsaHandle
    )
{
    return SslReferenceUserContext( LsaHandle, FALSE );
}

PSSL_USER_CONTEXT
SslFindUserContextEx(
    IN PCRED_THUMBPRINT pThumbprint
    )
{
    PLIST_ENTRY List ;
    PSSL_USER_CONTEXT Context = NULL ;
    ULONG ListIndex;
    ULONG LockIndex;

    DebugLog(( DEB_TRACE, "SslFindUserContextEx: \n"));

    for (ListIndex = 0 ; ListIndex < SCHANNEL_USERLIST_COUNT ; ListIndex++)
    {
        LockIndex = ListIndexToLockIndex( ListIndex );
        RtlAcquireResourceShared( &SslContextLock[LockIndex], TRUE );

        List = SslContextList[ListIndex].Flink ;

        while ( List != &SslContextList[ListIndex] )
        {
            Context = CONTAINING_RECORD( List, SSL_USER_CONTEXT, List.Flink );

            if(Context->pContext != NULL &&
               IsSameThumbprint(pThumbprint, &Context->pContext->ContextThumbprint))
            {
                RtlReleaseResource( &SslContextLock[LockIndex] );
                goto done;
            }

            List = List->Flink ;
        }

        RtlReleaseResource( &SslContextLock[LockIndex] );
    }

    Context = NULL ;

done:

    return( Context );
}

VOID
SslDeleteUserContext(
    IN LSA_SEC_HANDLE LsaHandle
    )
{
    PSSL_USER_CONTEXT Context ;

    Context = SslReferenceUserContext( LsaHandle, TRUE );

    if ( Context )
    {
        DebugLog(( DEB_TRACE, "Deleting user mode context %x, handle = %x\n",
                        Context, LsaHandle ));

        LsaContextDelete(Context->pContext);
        SPExternalFree(Context->pContext);
        LocalFree( Context );

    }
    else
    {
        DebugLog(( DEB_TRACE, "No context found for handle %x\n", LsaHandle ));
    }
}


ULONG
HandleToListIndex(
    ULONG_PTR ContextHandle
    )
{
    
    ULONG Number ;
    ULONG Hash;
    ULONG HashFinal;

    ASSERT( (SCHANNEL_USERLIST_COUNT != 0) );
    ASSERT( (SCHANNEL_USERLIST_COUNT & 1) == 0 );

    Number       = (ULONG)ContextHandle;

    Hash         = Number;
    Hash        += Number >> 8;
    Hash        += Number >> 16;
    Hash        += Number >> 24;

    HashFinal    = Hash;
    HashFinal   += Hash >> 4;

    //
    // insure power of two if not one.
    //

    return ( HashFinal & (SCHANNEL_USERLIST_COUNT-1) ) ;
}

ULONG
__inline
ListIndexToLockIndex(
    ULONG ListIndex
    )
{
    ASSERT( (SCHANNEL_USERLIST_LOCK_COUNT) != 0 );
    ASSERT( (SCHANNEL_USERLIST_LOCK_COUNT & 1) == 0 );

    //
    // insure power of two if not one.
    //
    
    return ( ListIndex & (SCHANNEL_USERLIST_LOCK_COUNT-1) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\lsa\ssldebug.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       debug.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10-02-96   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __SSLDEBUG_H__
#define __SSLDEBUG_H__


#include <dsysdbg.h>

#if DBG

DECLARE_DEBUG2( Ssl );

#define DebugOut( x )   SslDebugPrint x

#else

#define DebugOut( x )

#endif

#define DEB_TRACE_FUNC      0x00000008      // Trace Function entry/exit
#define DEB_TRACE_CRED      0x00000010      // Trace Cred functions
#define DEB_TRACE_CTXT      0x00000020      // Trace Context functions
#define DEB_TRACE_MAPPER    0x00000040      // Trace Mapper

#define TRACE_ENTER( Func ) DebugOut(( DEB_TRACE_FUNC, "Entering " #Func "\n" ))

#define TRACE_EXIT( Func, Status ) DebugOut(( DEB_TRACE_FUNC, "Exiting " #Func ", code %x, line %d\n", Status, __LINE__ ));

VOID UnloadDebugSupport( VOID );
#endif //__SSLDEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\lsa\common\sslp.h ===
#include "sslpi.h"
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\lsa\userctxt.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       userctxt.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10-10-96   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __USERCTXT_H__
#define __USERCTXT_H__

typedef struct _SSL_USER_CONTEXT {
    LIST_ENTRY  List ;
    LSA_SEC_HANDLE LsaHandle;
    ULONG       Align;
    PSPContext  pContext;
} SSL_USER_CONTEXT, * PSSL_USER_CONTEXT ;

BOOL
SslInitContextManager(
    VOID
    );

SECURITY_STATUS
SslAddUserContext(
    IN LSA_SEC_HANDLE LsaHandle,
    IN HANDLE Token,    // optional
    IN PSecBuffer ContextData,
    IN BOOL fImportedContext);

PSSL_USER_CONTEXT
SslFindUserContext(
    IN LSA_SEC_HANDLE LsaHandle
    );

PSSL_USER_CONTEXT
SslFindUserContextEx(
    IN PCRED_THUMBPRINT pThumbprint
    );

VOID
SslDeleteUserContext(
    IN LSA_SEC_HANDLE LsaHandle
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\lsa\usermode.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       usermode.c
//
//  Contents:   User mode functions
//
//  Classes:
//
//  Functions:
//
//  History:    10-08-96   RichardW   Created
//
//----------------------------------------------------------------------------

#include "sslp.h"
#include <ssl2msg.h>
#include <ssl3msg.h>
#include <pct1msg.h>
#include <mapper.h>

// Counter for exported handles
ULONG_PTR ExportedContext = 0;


SECURITY_STATUS
UpdateContextUsrToLsa(IN LSA_SEC_HANDLE hContextHandle);


SECPKG_USER_FUNCTION_TABLE  SslTable[ 2 ] =
    {
        {
            SpInstanceInit,
            SpInitUserModeContext,
            SpMakeSignature,
            SpVerifySignature,
            SpSealMessage,
            SpUnsealMessage,
            SpGetContextToken,
            SpUserQueryContextAttributes,
            SpCompleteAuthToken,
            SpDeleteUserModeContext,
            SpFormatCredentials,
            SpMarshallSupplementalCreds,
            SpExportSecurityContext,
            SpImportSecurityContext
        },

        {
            SpInstanceInit,
            SpInitUserModeContext,
            SpMakeSignature,
            SpVerifySignature,
            SpSealMessage,
            SpUnsealMessage,
            SpGetContextToken,
            SpUserQueryContextAttributes,
            SpCompleteAuthToken,
            SpDeleteUserModeContext,
            SpFormatCredentials,
            SpMarshallSupplementalCreds,
            SpExportSecurityContext,
            SpImportSecurityContext
        }
    };

NTSTATUS
SEC_ENTRY
SpUserModeInitialize(
    IN ULONG    LsaVersion,
    OUT PULONG  PackageVersion,
    OUT PSECPKG_USER_FUNCTION_TABLE * UserFunctionTable,
    OUT PULONG  pcTables)
{
    if (LsaVersion != SECPKG_INTERFACE_VERSION)
    {
        DebugLog((DEB_ERROR,"Invalid LSA version: %d\n", LsaVersion));
        return(STATUS_INVALID_PARAMETER);
    }

    *PackageVersion = SECPKG_INTERFACE_VERSION ;

    *UserFunctionTable = &SslTable[0] ;
    *pcTables = 2;

    SslInitContextManager();

    return( STATUS_SUCCESS );

}

NTSTATUS NTAPI
SpInstanceInit(
    IN ULONG Version,
    IN PSECPKG_DLL_FUNCTIONS DllFunctionTable,
    OUT PVOID * UserFunctionTable
    )
{
    NTSTATUS Status;
    DWORD i;

    // Register callback functions.
    for(i = 0; i < g_cSchannelCallbacks; i++)
    {
        Status = DllFunctionTable->RegisterCallback(
                                    g_SchannelCallbacks[i].dwTag,
                                    g_SchannelCallbacks[i].pFunction);
        if(Status != STATUS_SUCCESS)
        {
            return Status;
        }
    }

    return(STATUS_SUCCESS);
}



//+-------------------------------------------------------------------------
//
//  Function:   SpDeleteUserModeContext
//
//  Synopsis:   Deletes a user mode context by unlinking it and then
//              dereferencing it.
//
//  Effects:
//
//  Arguments:  ContextHandle - Lsa context handle of the context to delete
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success, STATUS_INVALID_HANDLE if the
//              context can't be located
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpDeleteUserModeContext(
    IN LSA_SEC_HANDLE ContextHandle
    )
{
    SslDeleteUserContext( ContextHandle );

    return( SEC_E_OK );

}


//+-------------------------------------------------------------------------
//
//  Function:   SpInitUserModeContext
//
//  Synopsis:   Creates a user-mode context from a packed LSA mode context
//
//  Effects:
//
//  Arguments:  ContextHandle - Lsa mode context handle for the context
//              PackedContext - A marshalled buffer containing the LSA
//                  mode context.
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpInitUserModeContext(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBuffer PackedContext
    )
{
    SECURITY_STATUS scRet ;

    if(!SchannelInit(TRUE))
    {
        return SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
    }

    scRet = SslAddUserContext( ContextHandle, NULL, PackedContext, FALSE );

    if ( NT_SUCCESS( scRet ) )
    {
        if(g_pFreeContextBuffer)
        {
            g_pFreeContextBuffer( PackedContext->pvBuffer );
        }
    }

    return( scRet );
}


//+-------------------------------------------------------------------------
//
//  Function:   SpMakeSignature
//
//  Synopsis:   Signs a message buffer by calculatinga checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  ContextHandle - Handle of the context to use to sign the
//                      message.
//              QualityOfProtection - Unused flags.
//              MessageBuffers - Contains an array of buffers to sign and
//                      to store the signature.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found.
//              STATUS_BUFFER_TOO_SMALL - the signature buffer is too small
//                      to hold the signature
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpMakeSignature(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG QualityOfProtection,
    IN PSecBufferDesc MessageBuffers,
    IN ULONG MessageSequenceNumber
    )
{
    return( SEC_E_UNSUPPORTED_FUNCTION );
}

//+-------------------------------------------------------------------------
//
//  Function:   SpVerifySignature
//
//  Synopsis:   Verifies a signed message buffer by calculating a checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  ContextHandle - Handle of the context to use to sign the
//                      message.
//              MessageBuffers - Contains an array of signed buffers  and
//                      a signature buffer.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//              QualityOfProtection - Unused flags.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found or was too small.
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------



NTSTATUS NTAPI
SpVerifySignature(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBufferDesc MessageBuffers,
    IN ULONG MessageSequenceNumber,
    OUT PULONG QualityOfProtection
    )
{
    return( SEC_E_UNSUPPORTED_FUNCTION );
}

NTSTATUS NTAPI
SpSealMessage(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG QualityOfProtection,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSequenceNumber
    )
{
    PSSL_USER_CONTEXT   Context ;
    PSPContext          pContext;
    PSecBuffer          pHdrBuffer;
    PSecBuffer          pDataBuffer;
    PSecBuffer          pTlrBuffer;
    PSecBuffer          pTokenBuffer;
    SP_STATUS           pctRet = PCT_ERR_OK;
    SPBuffer            CommOut;
    SPBuffer            AppIn;
    DWORD               cbBuffer;
    BOOL                fAlloced = FALSE;
    BOOL                fConnectionMode = FALSE;
    int i;

    SP_BEGIN("SpSealMessage");

    Context = SslFindUserContext( ContextHandle );

    if ( !Context )
    {
        SP_RETURN( SP_LOG_RESULT(SEC_E_INVALID_HANDLE) );
    }

    pContext = Context->pContext;

    if(pContext == NULL)
    {
        SP_RETURN( SP_LOG_RESULT(SEC_E_INVALID_HANDLE) );
    }

    if(!(pContext->State & SP_STATE_CONNECTED) || !pContext->Encrypt)
    {
        SP_RETURN( SP_LOG_RESULT(SEC_E_CONTEXT_EXPIRED) );
    }

    //
    // Find the buffer with the data:
    //

    pHdrBuffer = NULL;
    pDataBuffer = NULL;
    pTlrBuffer = NULL;
    pTokenBuffer = NULL;

    /* Gibraltar passes in the following,
     * a TOKEN buffer (or SECBUFFER_STREAM_HEADER)
     * a DATA buffer
     * a TOKEN buffer (or SECBUFFER_STREAM_TRAILER)
     * or we can get a connection mode as in
     * DATA buffer
     * Token buffer
     */

    if(0 == (pContext->Flags & CONTEXT_FLAG_CONNECTION_MODE))
    {
        // Stream Mode
        // The output buffer should be a concatenation of
        // the header buffer, Data buffer, and Trailer buffers.
        for (i = 0 ; i < (int)pMessage->cBuffers ; i++ )
        {
            switch(pMessage->pBuffers[i].BufferType)
            {
                case SECBUFFER_STREAM_HEADER:
                     pHdrBuffer = &pMessage->pBuffers[i];
                     break;

                case SECBUFFER_DATA :
                     pDataBuffer = &pMessage->pBuffers[i];
                     if(pHdrBuffer == NULL) pHdrBuffer = pDataBuffer;
                     break;

                case SECBUFFER_STREAM_TRAILER:
                     pTlrBuffer = &pMessage->pBuffers[i];
                     break;

                case SECBUFFER_TOKEN:
                     if(pHdrBuffer == NULL)
                     {
                         pHdrBuffer = &pMessage->pBuffers[i];
                     }
                     else if(pTlrBuffer == NULL)
                     {
                         pTlrBuffer = &pMessage->pBuffers[i];
                     }
                     break;
                default:
                    break;
            }
        }

        if (!pHdrBuffer || !pDataBuffer )
        {
            SP_RETURN( SP_LOG_RESULT(SEC_E_INVALID_TOKEN) );
        }

#if DBG
        DebugLog((DEB_TRACE, "Header (uninitialized): cbBuffer:0x%x, pvBuffer:0x%8.8x\n",
            pHdrBuffer->cbBuffer,
            pHdrBuffer->pvBuffer));

        DebugLog((DEB_TRACE, "Data (plaintext): cbBuffer:0x%x, pvBuffer:0x%8.8x\n",
            pDataBuffer->cbBuffer,
            pDataBuffer->pvBuffer));
        DBG_HEX_STRING(DEB_BUFFERS, pDataBuffer->pvBuffer, pDataBuffer->cbBuffer);

        if(pTlrBuffer)
        {
            DebugLog((DEB_TRACE, "Trailer (uninitialized): cbBuffer:0x%x, pvBuffer:0x%8.8x\n",
                pTlrBuffer->cbBuffer,
                pTlrBuffer->pvBuffer));
        }
#endif

        // Now, figure out if all of the buffers are contiguous, if not, then we
        // have to allocate a buffer
        fAlloced = FALSE;

        if((PUCHAR)pDataBuffer->pvBuffer !=
           ((PUCHAR)pHdrBuffer->pvBuffer + pHdrBuffer->cbBuffer))
        {
            fAlloced = TRUE;
        }
        if(pTlrBuffer)
        {
            if((PUCHAR)pTlrBuffer->pvBuffer !=
               ((PUCHAR)pDataBuffer->pvBuffer + pDataBuffer->cbBuffer))
            {
                fAlloced = TRUE;
            }
        }

        if(!fAlloced)
        {
            // All of our buffers are contiguous, so we do
            // not need to allocate a contiguous buffer.
            pTokenBuffer = pHdrBuffer;

            AppIn.pvBuffer = pDataBuffer->pvBuffer;
            AppIn.cbData   = pDataBuffer->cbBuffer;
            AppIn.cbBuffer = pDataBuffer->cbBuffer;

            CommOut.pvBuffer = pHdrBuffer->pvBuffer;
            CommOut.cbData   = 0;
            CommOut.cbBuffer = pHdrBuffer->cbBuffer + pDataBuffer->cbBuffer;
            if(pTlrBuffer)
            {
                CommOut.cbBuffer += pTlrBuffer->cbBuffer;
                AppIn.cbBuffer += pTlrBuffer->cbBuffer;
            }
        }
        else
        {
            // Our buffers are not contiguous, so we must allocate a contiguous
            // buffer to do our work in.

            // Calculate the size of the buffer
            CommOut.cbBuffer = pHdrBuffer->cbBuffer + pDataBuffer->cbBuffer;
            if(pTlrBuffer)
            {
                CommOut.cbBuffer += pTlrBuffer->cbBuffer;
            }
            // Allocate the buffer
            CommOut.pvBuffer = SPExternalAlloc(CommOut.cbBuffer);
            if(CommOut.pvBuffer == NULL)
            {
                SP_RETURN( SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY) );
            }

            // Copy data to encrypt to the buffer
            CommOut.cbData = 0;
            AppIn.pvBuffer = (PBYTE)CommOut.pvBuffer + pHdrBuffer->cbBuffer;
            AppIn.cbBuffer = CommOut.cbBuffer - pHdrBuffer->cbBuffer;
            AppIn.cbData   = pDataBuffer->cbBuffer;
            CopyMemory((PBYTE)AppIn.pvBuffer, (PBYTE)pDataBuffer->pvBuffer,  pDataBuffer->cbBuffer);
        }

        pctRet = pContext->Encrypt(pContext,
                                   &AppIn,
                                   &CommOut);

        if(pctRet == PCT_ERR_OK)
        {
            // Set the various buffer sizes.
            cbBuffer = CommOut.cbData;

            // The first few bytes always go in the header buffer.
            pHdrBuffer->cbBuffer = min(cbBuffer, pHdrBuffer->cbBuffer);
            cbBuffer -= pHdrBuffer->cbBuffer;

            if(pTlrBuffer)
            {
                // The output data buffer is the same size as the input data buffer.
                pDataBuffer->cbBuffer = min(cbBuffer, pDataBuffer->cbBuffer);
                cbBuffer -= pDataBuffer->cbBuffer;

                // The trailer buffer gets the data that's left over.
                pTlrBuffer->cbBuffer = min(cbBuffer, pTlrBuffer->cbBuffer);
                cbBuffer -= pTlrBuffer->cbBuffer;
            }
            else
            {
                pDataBuffer->cbBuffer = min(cbBuffer, pDataBuffer->cbBuffer);
                cbBuffer -= pDataBuffer->cbBuffer;
            }

            if(fAlloced)
            {

                // If we allocated the buffer, then we must copy

                CopyMemory(pHdrBuffer->pvBuffer,
                           CommOut.pvBuffer,
                           pHdrBuffer->cbBuffer);


                CopyMemory(pDataBuffer->pvBuffer,
                           (PUCHAR)CommOut.pvBuffer + pHdrBuffer->cbBuffer,
                           pDataBuffer->cbBuffer);

                if(pTlrBuffer)
                {
                    CopyMemory(pTlrBuffer->pvBuffer,
                               (PUCHAR)CommOut.pvBuffer + pHdrBuffer->cbBuffer + pDataBuffer->cbBuffer,
                               pTlrBuffer->cbBuffer);
                }
            }

#if DBG
            DebugLog((DEB_TRACE, "Header (ciphertext): cbBuffer:0x%x, pvBuffer:0x%8.8x\n",
                pHdrBuffer->cbBuffer,
                pHdrBuffer->pvBuffer));
            DBG_HEX_STRING(DEB_BUFFERS, pHdrBuffer->pvBuffer, pHdrBuffer->cbBuffer);

            DebugLog((DEB_TRACE, "Data (ciphertext): cbBuffer:0x%x, pvBuffer:0x%8.8x\n",
                pDataBuffer->cbBuffer,
                pDataBuffer->pvBuffer));
            DBG_HEX_STRING(DEB_BUFFERS, pDataBuffer->pvBuffer, pDataBuffer->cbBuffer);

            if(pTlrBuffer)
            {
                DebugLog((DEB_TRACE, "Trailer (ciphertext): cbBuffer:0x%x, pvBuffer:0x%8.8x\n",
                    pTlrBuffer->cbBuffer,
                    pTlrBuffer->pvBuffer));
                DBG_HEX_STRING(DEB_BUFFERS, pTlrBuffer->pvBuffer, pTlrBuffer->cbBuffer);
            }
#endif

        }
    }
    else
    {
        // We're doing connection mode, so unpack buffers as a
        // Data and then Token buffer
        fConnectionMode = TRUE;
        for (i = 0 ; i < (int)pMessage->cBuffers ; i++ )
        {
            switch(pMessage->pBuffers[i].BufferType)
            {
                case SECBUFFER_DATA :
                     pDataBuffer = &pMessage->pBuffers[i];
                     break;


                case SECBUFFER_TOKEN:
                     if(pTokenBuffer == NULL)
                     {
                         pTokenBuffer = &pMessage->pBuffers[i];
                     }
                     break;
                default:
                    break;
            }
        }
        if((pTokenBuffer == NULL) || (pDataBuffer == NULL))
        {
            SP_RETURN( SP_LOG_RESULT(SEC_E_INVALID_TOKEN) );
        }

        if((pDataBuffer->pvBuffer == NULL) || (pTokenBuffer->pvBuffer == NULL))
        {
            SP_RETURN( SP_LOG_RESULT(SEC_E_INVALID_TOKEN) );
        }

#if DBG
        DebugLog((DEB_TRACE, "Data (plaintext): cbBuffer:0x%x, pvBuffer:0x%8.8x\n",
            pDataBuffer->cbBuffer,
            pDataBuffer->pvBuffer));
        DBG_HEX_STRING(DEB_BUFFERS, pDataBuffer->pvBuffer, pDataBuffer->cbBuffer);

        DebugLog((DEB_TRACE, "Token (uninitialized): cbBuffer:0x%x, pvBuffer:0x%8.8x\n",
            pTokenBuffer->cbBuffer,
            pTokenBuffer->pvBuffer));
#endif

        // Connection Mode
        // The output should get written to a concatenation of the
        // data buffer and the token buffer.  If no token buffer is
        // given, then we should allocate one.

        if((PUCHAR)pTokenBuffer->pvBuffer ==
           ((PUCHAR)pDataBuffer->pvBuffer + pDataBuffer->cbBuffer))
        {
            // If the buffers are contiguous, we can optimize!
            CommOut.pvBuffer = pDataBuffer->pvBuffer;
            CommOut.cbData   = 0;
            CommOut.cbBuffer = pDataBuffer->cbBuffer + pTokenBuffer->cbBuffer;
        }
        else
        {
            // We have to realloc the buffer
            fAlloced = TRUE;
            CommOut.pvBuffer = SPExternalAlloc(pDataBuffer->cbBuffer + pTokenBuffer->cbBuffer);
            if(CommOut.pvBuffer == NULL)
            {
                SP_RETURN( SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY) );
            }
            CommOut.cbBuffer = pDataBuffer->cbBuffer + pTokenBuffer->cbBuffer;
            CommOut.cbData = 0;
        }

        // The data buffer always goes to AppIn
        AppIn.pvBuffer = pDataBuffer->pvBuffer;
        AppIn.cbData   = pDataBuffer->cbBuffer;
        AppIn.cbBuffer = pDataBuffer->cbBuffer;

        pctRet = pContext->Encrypt(pContext,
                                   &AppIn,
                                   &CommOut);

        if(pctRet == PCT_ERR_OK)
        {
            // Set the various buffer sizes.
            cbBuffer = CommOut.cbData;

            // The first few bytes always go into the data buffer.
            pDataBuffer->cbBuffer = min(cbBuffer, pDataBuffer->cbBuffer);
            cbBuffer -= pDataBuffer->cbBuffer;

            // The remaining bytes go into the token buffer.
            pTokenBuffer->cbBuffer = min(cbBuffer, pTokenBuffer->cbBuffer);

            if(fAlloced)
            {
                // We encrypted into our temporary buffer, so we must
                // copy.
                CopyMemory(pDataBuffer->pvBuffer,
                           CommOut.pvBuffer,
                           pDataBuffer->cbBuffer);

                CopyMemory(pTokenBuffer->pvBuffer,
                           (PUCHAR)CommOut.pvBuffer + pDataBuffer->cbBuffer,
                           pTokenBuffer->cbBuffer);
            }
        }

#if DBG
        DebugLog((DEB_TRACE, "Data (ciphertext): cbBuffer:0x%x, pvBuffer:0x%8.8x\n",
            pDataBuffer->cbBuffer,
            pDataBuffer->pvBuffer));
        DBG_HEX_STRING(DEB_BUFFERS, pDataBuffer->pvBuffer, pDataBuffer->cbBuffer);

        DebugLog((DEB_TRACE, "Token (ciphertext): cbBuffer:0x%x, pvBuffer:0x%8.8x\n",
            pTokenBuffer->cbBuffer,
            pTokenBuffer->pvBuffer));
        DBG_HEX_STRING(DEB_BUFFERS, pTokenBuffer->pvBuffer, pTokenBuffer->cbBuffer);
#endif

    }

    if(fAlloced)
    {
        SPExternalFree(CommOut.pvBuffer);
    }

    SP_RETURN( PctTranslateError(pctRet) );
}

NTSTATUS NTAPI
SpUnsealMessage(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSequenceNumber,
    OUT PULONG QualityOfProtection
    )
{
    // Output Buffer Types
    PSSL_USER_CONTEXT   Context ;
    PSecBuffer  pHdrBuffer;
    PSecBuffer  pDataBuffer;
    PSecBuffer  pTokenBuffer;
    PSecBuffer  pTlrBuffer;
    PSecBuffer  pExtraBuffer;
    SP_STATUS   pctRet = PCT_ERR_OK;
    SPBuffer    CommIn;
    SPBuffer    AppOut;
    PSPContext  pContext;
    DWORD       cbHeaderSize;
    BOOL        fAlloced = FALSE;
    SECURITY_STATUS scRet;
    int i;

    SP_BEGIN("SpUnsealMessage");

    Context = SslFindUserContext( ContextHandle );

    if ( !Context )
    {
        SP_RETURN( SP_LOG_RESULT(SEC_E_INVALID_HANDLE) );
    }

    pContext = Context->pContext;

    if(pContext == NULL)
    {
        SP_RETURN( SP_LOG_RESULT(SEC_E_INVALID_HANDLE) );
    }

    if(!(pContext->State & SP_STATE_CONNECTED))
    {
        SP_RETURN( SP_LOG_RESULT(SEC_E_CONTEXT_EXPIRED) );
    }

    //
    // Set up output buffers:
    //

    pHdrBuffer = NULL;
    pDataBuffer = NULL;
    pTokenBuffer = NULL;
    pTlrBuffer = NULL;
    pExtraBuffer = NULL;

    // On input, the buffers can either be
    // DataBuffer
    // TokenBuffer
    //
    // or
    //
    // Data Buffer
    // Empty
    // Empty
    // Empty
    //

    // on Output, the buffers are
    // DataBuffer
    // TokenBuffer
    //
    // or
    // HdrBuffer
    // DataBuffer
    // Tlrbuffer
    // Extrabuffer or Empty

    if(0 == (pContext->Flags & CONTEXT_FLAG_CONNECTION_MODE))
    {
        // Stream Mode
        // The output buffer should be a concatenation of
        // the header buffer, Data buffer, and Trailer buffers.

        for (i = 0 ; i < (int)pMessage->cBuffers ; i++ )
        {
            switch(pMessage->pBuffers[i].BufferType)
            {
                case SECBUFFER_DATA:
                    // The message data buffer on input will be the hdr buffer on
                    // output.
                    pHdrBuffer = &pMessage->pBuffers[i];
                    break;

                case SECBUFFER_EMPTY:
                    if(pDataBuffer == NULL)
                    {
                        pDataBuffer = &pMessage->pBuffers[i];
                    }
                    else if (pTlrBuffer == NULL)
                    {
                        pTlrBuffer = &pMessage->pBuffers[i];
                    }
                    else if (pExtraBuffer == NULL)
                    {
                        pExtraBuffer = &pMessage->pBuffers[i];
                    }
                    break;

                default:
                    break;
            }
        }

        if(!pHdrBuffer || !pDataBuffer || !pTlrBuffer || !pExtraBuffer)
        {
            SP_RETURN( SP_LOG_RESULT(SEC_E_INVALID_TOKEN) );
        }
        if(pHdrBuffer->pvBuffer == NULL)
        {
            SP_RETURN( SP_LOG_RESULT(SEC_E_INVALID_TOKEN) );
        }

#if DBG
        DebugLog((DEB_TRACE, "Data (ciphertext): cbBuffer:0x%x, pvBuffer:0x%8.8x\n",
            pHdrBuffer->cbBuffer,
            pHdrBuffer->pvBuffer));
        DBG_HEX_STRING(DEB_BUFFERS, pHdrBuffer->pvBuffer, pHdrBuffer->cbBuffer);
#endif

        CommIn.pvBuffer = pHdrBuffer->pvBuffer;
        CommIn.cbData   = pHdrBuffer->cbBuffer;
        CommIn.cbBuffer = pHdrBuffer->cbBuffer;

        pctRet = pContext->GetHeaderSize(pContext, &CommIn, &cbHeaderSize);

        if(pctRet == PCT_ERR_OK)
        {
            AppOut.pvBuffer = (PUCHAR)CommIn.pvBuffer + cbHeaderSize;
            AppOut.cbData   = 0;
            AppOut.cbBuffer = CommIn.cbData-cbHeaderSize;

            pctRet = pContext->DecryptHandler(pContext,
                                       &CommIn,
                                       &AppOut);
        }

        if((pctRet == PCT_ERR_OK) ||
           (pctRet == PCT_INT_RENEGOTIATE))
        {
            if(CommIn.cbData < pHdrBuffer->cbBuffer)
            {
                pExtraBuffer->BufferType = SECBUFFER_EXTRA;
                pExtraBuffer->cbBuffer = pHdrBuffer->cbBuffer-CommIn.cbData;
                pExtraBuffer->pvBuffer = (PUCHAR)pHdrBuffer->pvBuffer+CommIn.cbData;
            }
            else
            {
                pExtraBuffer = NULL;
            }
            pHdrBuffer->BufferType = SECBUFFER_STREAM_HEADER;
            pHdrBuffer->cbBuffer = cbHeaderSize;

            pDataBuffer->BufferType = SECBUFFER_DATA;
            pDataBuffer->pvBuffer = AppOut.pvBuffer;
            pDataBuffer->cbBuffer = AppOut.cbData;

            pTlrBuffer->BufferType = SECBUFFER_STREAM_TRAILER;
            pTlrBuffer->pvBuffer = (PUCHAR)pDataBuffer->pvBuffer + AppOut.cbData;
            pTlrBuffer->cbBuffer = CommIn.cbBuffer-(AppOut.cbData+cbHeaderSize);

#if DBG
            DebugLog((DEB_TRACE, "Header (plaintext): cbBuffer:0x%x, pvBuffer:0x%8.8x\n",
                pHdrBuffer->cbBuffer,
                pHdrBuffer->pvBuffer));
            DBG_HEX_STRING(DEB_BUFFERS, pHdrBuffer->pvBuffer, pHdrBuffer->cbBuffer);

            DebugLog((DEB_TRACE, "Data (plaintext): cbBuffer:0x%x, pvBuffer:0x%8.8x\n",
                pDataBuffer->cbBuffer,
                pDataBuffer->pvBuffer));
            DBG_HEX_STRING(DEB_BUFFERS, pDataBuffer->pvBuffer, pDataBuffer->cbBuffer);

            DebugLog((DEB_TRACE, "Trailer (plaintext): cbBuffer:0x%x, pvBuffer:0x%8.8x\n",
                pTlrBuffer->cbBuffer,
                pTlrBuffer->pvBuffer));
            DBG_HEX_STRING(DEB_BUFFERS, pTlrBuffer->pvBuffer, pTlrBuffer->cbBuffer);

            if(pExtraBuffer)
            {
                DebugLog((DEB_TRACE, "Extra (ciphertext): cbBuffer:0x%x, pvBuffer:0x%8.8x\n",
                    pExtraBuffer->cbBuffer,
                    pExtraBuffer->pvBuffer));
                    DBG_HEX_STRING(DEB_BUFFERS, pExtraBuffer->pvBuffer, pExtraBuffer->cbBuffer);
            }
#endif

            if(pctRet == PCT_INT_RENEGOTIATE)
            {
                // Wow.  Need to notify the lsa mode portion of the context that
                // the caller is about to call AcceptSecurityContext again, and
                // not to panic.  So, we cruft up a magic "token" that we
                // pass along in ApplyControlToken:
                scRet = UpdateContextUsrToLsa(ContextHandle);
                if(FAILED(scRet))
                {
                    SP_RETURN( SP_LOG_RESULT(scRet) );
                }
            }

        }
        else if(pctRet == PCT_INT_INCOMPLETE_MSG)
        {
            pDataBuffer->BufferType = SECBUFFER_MISSING;
            pDataBuffer->cbBuffer = CommIn.cbData - pHdrBuffer->cbBuffer;

            /* This is a hack to work with old code that was designed to work with
             * the old SSL. */

            pHdrBuffer->BufferType = SECBUFFER_MISSING;
            pHdrBuffer->cbBuffer = CommIn.cbData - pHdrBuffer->cbBuffer;
        }
    }
    else
    {
        // Connection Mode
        for (i = 0 ; i < (int)pMessage->cBuffers ; i++ )
        {
            switch(pMessage->pBuffers[i].BufferType)
            {
                case SECBUFFER_DATA :
                     pDataBuffer = &pMessage->pBuffers[i];
                     break;


                case SECBUFFER_TOKEN:
                     if(pTokenBuffer == NULL)
                     {
                         pTokenBuffer = &pMessage->pBuffers[i];
                     }
                     break;
                default:
                    break;
            }
        }
        if((pTokenBuffer == NULL) || (pDataBuffer == NULL))
        {
            SP_RETURN( SP_LOG_RESULT(SEC_E_INVALID_TOKEN) );
        }

        if((pDataBuffer->pvBuffer == NULL) || (pTokenBuffer->pvBuffer == NULL))
        {
            SP_RETURN( SP_LOG_RESULT(SEC_E_INVALID_TOKEN) );
        }

#if DBG
        DebugLog((DEB_TRACE, "Data (ciphertext): cbBuffer:0x%x, pvBuffer:0x%8.8x\n",
            pDataBuffer->cbBuffer,
            pDataBuffer->pvBuffer));
        DBG_HEX_STRING(DEB_BUFFERS, pDataBuffer->pvBuffer, pDataBuffer->cbBuffer);

        DebugLog((DEB_TRACE, "Token (ciphertext): cbBuffer:0x%x, pvBuffer:0x%8.8x\n",
            pTokenBuffer->cbBuffer,
            pTokenBuffer->pvBuffer));
        DBG_HEX_STRING(DEB_BUFFERS, pTokenBuffer->pvBuffer, pTokenBuffer->cbBuffer);
#endif

        // The Data and Token buffers are concatenated together to
        // form a single input buffer.
        if((PUCHAR)pDataBuffer->pvBuffer + pDataBuffer->cbBuffer ==
           (PUCHAR)pTokenBuffer->pvBuffer)
        {
            // Speed Opt,  If the buffers really are just one big buffer
            // then we can party on them directly.
            CommIn.pvBuffer = pDataBuffer->pvBuffer;
            CommIn.cbData   = pDataBuffer->cbBuffer + pTokenBuffer->cbBuffer;
            CommIn.cbBuffer = CommIn.cbData;
        }
        else
        {
            // We have to allocate a uniform input buffer
            CommIn.cbData   = pDataBuffer->cbBuffer + pTokenBuffer->cbBuffer;
            CommIn.pvBuffer = SPExternalAlloc(CommIn.cbData);
            if(CommIn.pvBuffer == NULL)
            {
                SP_RETURN( SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY) );
            }
            CommIn.cbBuffer = CommIn.cbData;
            CopyMemory(CommIn.pvBuffer,  pDataBuffer->pvBuffer,  pDataBuffer->cbBuffer);

            CopyMemory((PUCHAR)CommIn.pvBuffer + pDataBuffer->cbBuffer,
                       pTokenBuffer->pvBuffer,
                       pTokenBuffer->cbBuffer);
            fAlloced = TRUE;

        }

        AppOut.pvBuffer = pDataBuffer->pvBuffer;
        AppOut.cbData   = 0;
        AppOut.cbBuffer = pDataBuffer->cbBuffer;

        pctRet = pContext->DecryptHandler(pContext,
                           &CommIn,
                           &AppOut);


        if((pctRet == PCT_ERR_OK) ||
           (pctRet == PCT_INT_RENEGOTIATE))
        {
            pDataBuffer->cbBuffer  = AppOut.cbData;
            pTokenBuffer->cbBuffer = CommIn.cbData - AppOut.cbData;
        }

        if(fAlloced)
        {
            SPExternalFree(CommIn.pvBuffer);
        }

#if DBG
        DebugLog((DEB_TRACE, "Data (plaintext): cbBuffer:0x%x, pvBuffer:0x%8.8x\n",
            pDataBuffer->cbBuffer,
            pDataBuffer->pvBuffer));
        DBG_HEX_STRING(DEB_BUFFERS, pDataBuffer->pvBuffer, pDataBuffer->cbBuffer);

        DebugLog((DEB_TRACE, "Token (plaintext): cbBuffer:0x%x, pvBuffer:0x%8.8x\n",
            pTokenBuffer->cbBuffer,
            pTokenBuffer->pvBuffer));
        DBG_HEX_STRING(DEB_BUFFERS, pTokenBuffer->pvBuffer, pTokenBuffer->cbBuffer);
#endif

    }

    DebugOut(( DEB_TRACE, "Unseal returns %x \n", PctTranslateError( pctRet ) ));

    SP_RETURN( PctTranslateError(pctRet) );
}


//+-------------------------------------------------------------------------
//
//  Function:   SpGetContextToken
//
//  Synopsis:   returns a pointer to the token for a server-side context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
SpGetContextToken(
    IN LSA_SEC_HANDLE ContextHandle,
    OUT PHANDLE ImpersonationToken
    )
{
    PSSL_USER_CONTEXT   Context;
    PSPContext          pContext;
    PSessCacheItem      pZombie;
    SECURITY_STATUS     Status;

    Context = SslFindUserContext( ContextHandle );

    if ( !Context )
    {
        return( SEC_E_INVALID_HANDLE );
    }

    pContext = Context->pContext;

    if(pContext == NULL)
    {
        SP_RETURN( SP_LOG_RESULT(SEC_E_INVALID_HANDLE) );
    }

    pZombie  = pContext->RipeZombie;

    if(pZombie == NULL || 
       pZombie->hLocator == 0)
    {
        if(pZombie->LocatorStatus)
        {
            return(SP_LOG_RESULT(pZombie->LocatorStatus));
        }
        else
        {
            return(SP_LOG_RESULT(SEC_E_NO_IMPERSONATION));
        }
    }

    if(pZombie->phMapper == NULL)
    {
        *ImpersonationToken = (HANDLE)pZombie->hLocator;
    }
    else
    {
        // Call the application mapper to get a token.
        Status = pZombie->phMapper->m_vtable->GetAccessToken(
                                            pZombie->phMapper->m_Reserved1,
                                            pZombie->hLocator,
                                            ImpersonationToken);
        if(!NT_SUCCESS(Status))
        {
            return SP_LOG_RESULT(Status);
        }
    }

    return( SEC_E_OK );
}


//+-------------------------------------------------------------------------
//
//  Function:   SpCompleteAuthToken
//
//  Synopsis:   Completes a context (in Kerberos case, does nothing)
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
NTAPI
SpCompleteAuthToken(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBufferDesc InputBuffer
    )
{
    return(STATUS_SUCCESS);
}


NTSTATUS NTAPI
SpFormatCredentials(
    IN PSecBuffer Credentials,
    OUT PSecBuffer FormattedCredentials
    )
{
    return(STATUS_NOT_SUPPORTED);
}

NTSTATUS NTAPI
SpMarshallSupplementalCreds(
    IN ULONG CredentialSize,
    IN PUCHAR Credentials,
    OUT PULONG MarshalledCredSize,
    OUT PVOID * MarshalledCreds
    )
{
    return(STATUS_NOT_SUPPORTED);
}


//+---------------------------------------------------------------------------
//
//  Function:   UpdateContextUsrToLsa
//
//  Synopsis:   UnsealMessage has just received a redo request, so push the
//              read key over to the LSA process.
//
//  Arguments:  [hLsaContext]   --  Handle to LSA schannel context.
//
//  History:    10-20-97   jbanes   Added CAPI integration.
//
//  Notes:      The format of the buffer sent to ApplyControlToken is:
//
//                  DWORD   dwOperation;    // SCHANNEL_RENEGOTIATE
//                  DWORD   dwNewState;
//                  DWORD   dwReadSequence;
//                  DWORD   cbReadKey;
//                  BYTE    rgbReadKey[];
//
//----------------------------------------------------------------------------
SECURITY_STATUS
UpdateContextUsrToLsa(
    IN LSA_SEC_HANDLE hLsaContext)
{
    PSSL_USER_CONTEXT pUserContext;
    PSPContext  pContext;
    CtxtHandle  hMyContext;
    SecBuffer   RedoNotify;
    SecBufferDesc RedoDesc;
    SECURITY_STATUS scRet;

    PBYTE pbBuffer;
    DWORD cbBuffer;


    pUserContext = SslFindUserContext( hLsaContext );
    if ( !pUserContext )
    {
        return SEC_E_INVALID_HANDLE;
    }

    pContext = pUserContext->pContext;

    if(pContext == NULL)
    {
        SP_RETURN( SP_LOG_RESULT(SEC_E_INVALID_HANDLE) );
    }

    hMyContext.dwLower = (DWORD_PTR) GetCurrentThread() ;
    hMyContext.dwUpper = hLsaContext ;


    //
    // Compute size of output buffer.
    //

    cbBuffer = sizeof(DWORD) * 2;


    //
    // Allocate memory for output buffer.
    //

    pbBuffer = SPExternalAlloc( cbBuffer);
    if(pbBuffer == NULL)
    {
        return SEC_E_INSUFFICIENT_MEMORY;
    }

    RedoNotify.BufferType = SECBUFFER_TOKEN;
    RedoNotify.cbBuffer   = cbBuffer;
    RedoNotify.pvBuffer   = pbBuffer;

    RedoDesc.ulVersion    = SECBUFFER_VERSION ;
    RedoDesc.pBuffers     = &RedoNotify ;
    RedoDesc.cBuffers     = 1 ;


    //
    // Build output buffer.
    //

    *(PDWORD)pbBuffer = SCHANNEL_RENEGOTIATE;
    pbBuffer += sizeof(DWORD);

    *(PDWORD)pbBuffer = pContext->State;
    pbBuffer += sizeof(DWORD);


    //
    // Call ApplyControlToken
    //

    DebugOut(( DEB_TRACE, "Sending state change to LSA since we're renegotiating\n" ));

    scRet = ApplyControlToken( &hMyContext, &RedoDesc );

    LocalFree(RedoNotify.pvBuffer);

    return scRet;
}

BOOL
SslEmptyCacheA(LPSTR  pszTargetName,
               DWORD  dwFlags)
{
    ANSI_STRING String;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    BOOL fSuccess;

    UnicodeString.Length = 0;
    UnicodeString.MaximumLength = 0;
    UnicodeString.Buffer = NULL;

    // Convert target name to unicode.
    if(pszTargetName)
    {
        RtlInitAnsiString(&String, pszTargetName);

        Status =  RtlAnsiStringToUnicodeString(&UnicodeString,
                                               &String,
                                               TRUE);
        if(!NT_SUCCESS(Status))
        {
            SetLastError(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
            return FALSE;
        }
    }

    // Call unicode version of function.
    fSuccess = SslEmptyCacheW(UnicodeString.Buffer, dwFlags);

    if(UnicodeString.Buffer)
    {
        RtlFreeUnicodeString(&UnicodeString);
    }
    
    return fSuccess;
}

BOOL
SslEmptyCacheW(LPWSTR pszTargetName,
               DWORD  dwFlags)
{
    HANDLE LsaHandle = 0;
    DWORD PackageNumber;
    LSA_STRING PackageName;
    PSSL_PURGE_SESSION_CACHE_REQUEST pRequest = NULL;
    DWORD cbTargetName;
    DWORD cbRequest;
    NTSTATUS Status;
    NTSTATUS SubStatus;

    Status = LsaConnectUntrusted(&LsaHandle);

    if(FAILED(Status))
    {
        SP_LOG_RESULT(Status);
        goto cleanup;
    }

    RtlInitAnsiString(&PackageName, SCHANNEL_NAME_A);

    Status = LsaLookupAuthenticationPackage(
                    LsaHandle,
                    &PackageName,
                    &PackageNumber);
    if(FAILED(Status))
    {
        SP_LOG_RESULT(Status);
        goto cleanup;
    }

    cbRequest = sizeof(SSL_PURGE_SESSION_CACHE_REQUEST);

    if(pszTargetName == NULL)
    {
        pRequest = SPExternalAlloc(cbRequest);
        if(pRequest == NULL)
        {
            Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            goto cleanup;
        }
    }
    else
    {
        cbTargetName  = (wcslen(pszTargetName) + 1) * sizeof(WCHAR);
        cbRequest += cbTargetName;

        pRequest = SPExternalAlloc(cbRequest);
        if(pRequest == NULL)
        {
            Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            goto cleanup;
        }

        memcpy(pRequest + 1, pszTargetName, cbTargetName);

        pRequest->ServerName.Buffer        = (LPWSTR)(pRequest + 1);
        pRequest->ServerName.Length        = (WORD)(wcslen(pszTargetName) * sizeof(WCHAR));
        pRequest->ServerName.MaximumLength = (WORD)cbTargetName;
    }

    pRequest->MessageType = SSL_PURGE_CACHE_MESSAGE;

    pRequest->Flags = SSL_PURGE_CLIENT_ENTRIES | SSL_PURGE_SERVER_ENTRIES;


    Status = LsaCallAuthenticationPackage(
                    LsaHandle,
                    PackageNumber,
                    pRequest,
                    cbRequest,
                    NULL,
                    NULL,
                    &SubStatus);
    if(FAILED(Status))
    {
        SP_LOG_RESULT(Status);
        goto cleanup;
    }

    if(FAILED(SubStatus))
    {
        Status = SP_LOG_RESULT(SubStatus);
    }

cleanup:

    if(LsaHandle)
    {
        CloseHandle(LsaHandle);
    }

    if(pRequest)
    {
        SPExternalFree(pRequest);
    }

    if(FAILED(Status))
    {
        SetLastError(Status);
        return FALSE;
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Function:   SpExportSecurityContext
//
//  Synopsis:   Exports a security context to another process
//
//  Effects:    Allocates memory for output
//
//  Arguments:  ContextHandle - handle to context to export
//              Flags - Flags concerning duplication. Allowable flags:
//                      SECPKG_CONTEXT_EXPORT_DELETE_OLD - causes old context
//                              to be deleted.
//              PackedContext - Receives serialized context to be freed with
//                      FreeContextBuffer
//              TokenHandle - Optionally receives handle to context's token.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
NTAPI 
SpExportSecurityContext(
    LSA_SEC_HANDLE       ContextHandle,         // (in) context to export
    ULONG                fFlags,                // (in) option flags
    PSecBuffer           pPackedContext,        // (out) marshalled context
    PHANDLE              pToken                 // (out, optional) token handle for impersonation
    )
{
    PSSL_USER_CONTEXT Context;
    PSPContext pContext;
    NTSTATUS Status;
    SP_STATUS pctRet;

    DebugLog((DEB_TRACE, "SpExportSecurityContext\n"));

    if (ARGUMENT_PRESENT(pToken))
    {
        *pToken = NULL;
    }

    pPackedContext->pvBuffer = NULL;
    pPackedContext->cbBuffer = 0;
    pPackedContext->BufferType = 0;


    //
    // Get handle to schannel context structure.
    //

    Context = SslFindUserContext( ContextHandle );

    if ( !Context )
    {
        Status = SP_LOG_RESULT(SEC_E_INVALID_HANDLE);
        goto cleanup;
    }

    pContext = Context->pContext;

    if(pContext == NULL)
    {
        Status = SP_LOG_RESULT(SEC_E_INVALID_HANDLE);
        goto cleanup;
    }

    if(!(pContext->State & SP_STATE_CONNECTED))
    {
        Status = SP_LOG_RESULT(SEC_E_CONTEXT_EXPIRED);
        goto cleanup;
    }

    
    //
    // Build packed context structure.
    //

    pctRet = SPContextSerialize(pContext, 
                                NULL, 
                                (PBYTE *)&pPackedContext->pvBuffer,
                                &pPackedContext->cbBuffer,
                                FALSE);

    if(pctRet != PCT_ERR_OK)
    {
        Status = SP_LOG_RESULT(SEC_E_ENCRYPT_FAILURE);
        goto cleanup;
    }


    //
    // Now either duplicate the token or copy it.
    //

    if (ARGUMENT_PRESENT(pToken) && (pContext->RipeZombie->hLocator))
    {
        if ((fFlags & SECPKG_CONTEXT_EXPORT_DELETE_OLD) != 0)
        {
            *pToken = (HANDLE)pContext->RipeZombie->hLocator;
            pContext->RipeZombie->hLocator = 0;
        }
        else 
        {
            Status = NtDuplicateObject(
                        NtCurrentProcess(),
                        (HANDLE)pContext->RipeZombie->hLocator,
                        NULL,
                        pToken,
                        0,              // no new access
                        0,              // no handle attributes
                        DUPLICATE_SAME_ACCESS
                        );
            if (!NT_SUCCESS(Status))
            {
                goto cleanup;
            }
        }
    }

    Status = STATUS_SUCCESS;

cleanup:

    DebugLog((DEB_TRACE, "SpExportSecurityContext returned 0x%x\n", Status));

    return(Status);
}


NTSTATUS
NTAPI 
SpImportSecurityContext(
    PSecBuffer           pPackedContext,        // (in) marshalled context
    HANDLE               Token,                 // (in, optional) handle to token for context
    PLSA_SEC_HANDLE      ContextHandle          // (out) new context handle
    )
{
    PSSL_USER_CONTEXT Context = NULL;
    LSA_SEC_HANDLE LsaHandle;
    NTSTATUS Status;

    // Dummy up an lsa handle by incrementing a global variable. This
    // will ensure that each imported context has a unique handle.
    // Skip over values that could be interpreted as an aligned pointer,
    // so that they won't get mixed up with real lsa handles.
    LsaHandle = InterlockedIncrement((PLONG)&ExportedContext);
    while(LsaHandle % MAX_NATURAL_ALIGNMENT == 0)
    {
        LsaHandle = InterlockedIncrement((PLONG)&ExportedContext);
    }

    
    Status = SslAddUserContext(LsaHandle, Token, pPackedContext, TRUE);

    if(!NT_SUCCESS(Status))
    {
        return Status;
    }

    *ContextHandle = LsaHandle;

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\perfmon\sslperf.h ===
//
//  sslperf.h
//
//  Offset definition file for exensible counter objects and counters
//
//  These "relative" offsets must start at 0 and be multiples of 2 (i.e.
//  even numbers). In the Open Procedure, they will be added to the 
//  "First Counter" and "First Help" values fo the device they belong to, 
//  in order to determine the  absolute location of the counter and 
//  object names and corresponding help text in the registry.
//
//  this file is used by the extensible counter DLL code as well as the 
//  counter name and help text definition file (.INI) file that is used
//  by LODCTR to load the names into the registry.
//
#define SSLPERF_OBJ             0
#define SSL_CACHE_ENTRIES       2
#define SSL_ACTIVE_ENTRIES      4
#define SSL_HANDSHAKE_COUNT     6
#define SSL_RECONNECT_COUNT     8
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\spbase\asn1enc.c ===
/* Copyright (C) Microsoft Corporation, 1996-1999. All rights reserved. */
/* ASN.1 definitions for SCHANNEL FORTEZZA and Private Key encoding */

#include "spbase.h"
#include "asn1enc.h"

ASN1module_t ASN1ENC_Module = NULL;

static int ASN1CALL ASN1Enc_FORTPublicKey(ASN1encoding_t enc, ASN1uint32_t tag, FORTPublicKey *val);
static int ASN1CALL ASN1Enc_PrivateKeyInfo_attributes(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyInfo_attributes *val);
static int ASN1CALL ASN1Enc_AlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, AlgorithmIdentifier *val);
static int ASN1CALL ASN1Enc_RSAPrivateKey(ASN1encoding_t enc, ASN1uint32_t tag, RSAPrivateKey *val);
static int ASN1CALL ASN1Enc_PrivateKeyInfo(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyInfo *val);
static int ASN1CALL ASN1Enc_PrivateKeyData(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyData *val);
static int ASN1CALL ASN1Enc_PrivateKeyFile(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyFile *val);
static int ASN1CALL ASN1Enc_EnhancedKeyUsage(ASN1encoding_t enc, ASN1uint32_t tag, EnhancedKeyUsage *val);
static int ASN1CALL ASN1Dec_FORTPublicKey(ASN1decoding_t dec, ASN1uint32_t tag, FORTPublicKey *val);
static int ASN1CALL ASN1Dec_PrivateKeyInfo_attributes(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyInfo_attributes *val);
static int ASN1CALL ASN1Dec_AlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, AlgorithmIdentifier *val);
static int ASN1CALL ASN1Dec_RSAPrivateKey(ASN1decoding_t dec, ASN1uint32_t tag, RSAPrivateKey *val);
static int ASN1CALL ASN1Dec_PrivateKeyInfo(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyInfo *val);
static int ASN1CALL ASN1Dec_PrivateKeyData(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyData *val);
static int ASN1CALL ASN1Dec_PrivateKeyFile(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyFile *val);
static int ASN1CALL ASN1Dec_EnhancedKeyUsage(ASN1decoding_t dec, ASN1uint32_t tag, EnhancedKeyUsage *val);
static void ASN1CALL ASN1Free_FORTPublicKey(FORTPublicKey *val);
static void ASN1CALL ASN1Free_PrivateKeyInfo_attributes(PrivateKeyInfo_attributes *val);
static void ASN1CALL ASN1Free_AlgorithmIdentifier(AlgorithmIdentifier *val);
static void ASN1CALL ASN1Free_RSAPrivateKey(RSAPrivateKey *val);
static void ASN1CALL ASN1Free_PrivateKeyInfo(PrivateKeyInfo *val);
static void ASN1CALL ASN1Free_PrivateKeyData(PrivateKeyData *val);
static void ASN1CALL ASN1Free_PrivateKeyFile(PrivateKeyFile *val);
static void ASN1CALL ASN1Free_EnhancedKeyUsage(EnhancedKeyUsage *val);

typedef ASN1BerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[5] = {
    (ASN1EncFun_t) ASN1Enc_FORTPublicKey,
    (ASN1EncFun_t) ASN1Enc_RSAPrivateKey,
    (ASN1EncFun_t) ASN1Enc_PrivateKeyInfo,
    (ASN1EncFun_t) ASN1Enc_PrivateKeyFile,
    (ASN1EncFun_t) ASN1Enc_EnhancedKeyUsage,
};
typedef ASN1BerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[5] = {
    (ASN1DecFun_t) ASN1Dec_FORTPublicKey,
    (ASN1DecFun_t) ASN1Dec_RSAPrivateKey,
    (ASN1DecFun_t) ASN1Dec_PrivateKeyInfo,
    (ASN1DecFun_t) ASN1Dec_PrivateKeyFile,
    (ASN1DecFun_t) ASN1Dec_EnhancedKeyUsage,
};
static const ASN1FreeFun_t freefntab[5] = {
    (ASN1FreeFun_t) ASN1Free_FORTPublicKey,
    (ASN1FreeFun_t) ASN1Free_RSAPrivateKey,
    (ASN1FreeFun_t) ASN1Free_PrivateKeyInfo,
    (ASN1FreeFun_t) ASN1Free_PrivateKeyFile,
    (ASN1FreeFun_t) ASN1Free_EnhancedKeyUsage,
};
static const ULONG sizetab[5] = {
    SIZE_ASN1ENC_Module_PDU_0,
    SIZE_ASN1ENC_Module_PDU_1,
    SIZE_ASN1ENC_Module_PDU_2,
    SIZE_ASN1ENC_Module_PDU_3,
    SIZE_ASN1ENC_Module_PDU_4,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */

void ASN1CALL ASN1ENC_Module_Startup(void)
{
    ASN1ENC_Module = ASN1_CreateModule(0x10000, ASN1_BER_RULE_DER, ASN1FLAGS_NOASSERT, 5, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x61686373);
}

void ASN1CALL ASN1ENC_Module_Cleanup(void)
{
    ASN1_CloseModule(ASN1ENC_Module);
    ASN1ENC_Module = NULL;
}

static int ASN1CALL ASN1Enc_FORTPublicKey(ASN1encoding_t enc, ASN1uint32_t tag, FORTPublicKey *val)
{
    if (!ASN1DEREncBitString(enc, tag ? tag : 0x3, (val)->length, (val)->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_FORTPublicKey(ASN1decoding_t dec, ASN1uint32_t tag, FORTPublicKey *val)
{
    if (!ASN1BERDecBitString2(dec, tag ? tag : 0x3, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_FORTPublicKey(FORTPublicKey *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_PrivateKeyInfo_attributes(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyInfo_attributes *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000000, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PrivateKeyInfo_attributes(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyInfo_attributes *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000000, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (PrivateKeyInfo_attributes_Set *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecOpenType(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PrivateKeyInfo_attributes(PrivateKeyInfo_attributes *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1open_free(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1open_free(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_AlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, AlgorithmIdentifier *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->algorithm))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncOpenType(enc, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, AlgorithmIdentifier *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->algorithm))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOpenType(dd, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AlgorithmIdentifier(AlgorithmIdentifier *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1open_free(&(val)->parameters);
	}
    }
}

static int ASN1CALL ASN1Enc_RSAPrivateKey(ASN1encoding_t enc, ASN1uint32_t tag, RSAPrivateKey *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->modulus))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->publicExponent))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->privateExponent))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->prime1))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->prime2))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->exponent1))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->exponent2))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->coefficient))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RSAPrivateKey(ASN1decoding_t dec, ASN1uint32_t tag, RSAPrivateKey *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->modulus))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->publicExponent))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->privateExponent))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->prime1))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->prime2))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->exponent1))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->exponent2))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->coefficient))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RSAPrivateKey(RSAPrivateKey *val)
{
    if (val) {
	ASN1intx_free(&(val)->modulus);
	ASN1intx_free(&(val)->privateExponent);
	ASN1intx_free(&(val)->prime1);
	ASN1intx_free(&(val)->prime2);
	ASN1intx_free(&(val)->exponent1);
	ASN1intx_free(&(val)->exponent2);
	ASN1intx_free(&(val)->coefficient);
    }
}

static int ASN1CALL ASN1Enc_PrivateKeyInfo(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1Enc_AlgorithmIdentifier(enc, 0, &(val)->privateKeyAlgorithm))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->privateKey).length, ((val)->privateKey).value))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_PrivateKeyInfo_attributes(enc, 0, &(val)->attributes))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PrivateKeyInfo(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1Dec_AlgorithmIdentifier(dd, 0, &(val)->privateKeyAlgorithm))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->privateKey))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_PrivateKeyInfo_attributes(dd, 0, &(val)->attributes))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PrivateKeyInfo(PrivateKeyInfo *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(&(val)->privateKeyAlgorithm);
	ASN1octetstring_free(&(val)->privateKey);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_PrivateKeyInfo_attributes(&(val)->attributes);
	}
    }
}

static int ASN1CALL ASN1Enc_PrivateKeyData(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyData *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_AlgorithmIdentifier(enc, 0, &(val)->privateKeyAlgorithm))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->privateKey).length, ((val)->privateKey).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PrivateKeyData(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyData *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_AlgorithmIdentifier(dd, 0, &(val)->privateKeyAlgorithm))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->privateKey))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PrivateKeyData(PrivateKeyData *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(&(val)->privateKeyAlgorithm);
	ASN1octetstring_free(&(val)->privateKey);
    }
}

static int ASN1CALL ASN1Enc_PrivateKeyFile(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyFile *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->name).length, ((val)->name).value))
	return 0;
    if (!ASN1Enc_PrivateKeyData(enc, 0, &(val)->privateKey))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PrivateKeyFile(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyFile *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->name))
	return 0;
    if (!ASN1Dec_PrivateKeyData(dd, 0, &(val)->privateKey))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PrivateKeyFile(PrivateKeyFile *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->name);
	ASN1Free_PrivateKeyData(&(val)->privateKey);
    }
}

static int ASN1CALL ASN1Enc_EnhancedKeyUsage(ASN1encoding_t enc, ASN1uint32_t tag, EnhancedKeyUsage *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EnhancedKeyUsage(ASN1decoding_t dec, ASN1uint32_t tag, EnhancedKeyUsage *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (UsageIdentifier *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EnhancedKeyUsage(EnhancedKeyUsage *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 1; i < (val)->count; i++) {
	}
	ASN1Free((val)->value);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\pkiutil\pkialloc.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1998
//
//  File:       pkialloc.cpp
//
//  Contents:   PKI Allocation Functions
//
//  Functions:  PkiAlloc
//
//  History:    19-Jan-98    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

//+-------------------------------------------------------------------------
//  The following functions use the 'C' runtime's allocation functions
//  when DBG is defined.  Otherwise, use LocalAlloc, LocalReAlloc or
//  LocalFree Win32 APIs.
//--------------------------------------------------------------------------

// Calls malloc when DBG is defined. Otherwise, does a
// ZEROINIT LocalAlloc.
LPVOID
WINAPI
PkiAlloc(
    IN size_t cbBytes
    )
{
    LPVOID pv;
    if (NULL == (pv = (LPVOID) LocalAlloc(LPTR, cbBytes)))
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}

// Calls malloc and does a memory clear when DBG is defined.
// Otherwise, does a ZEROINIT LocalAlloc.
LPVOID
WINAPI
PkiZeroAlloc(
    IN size_t cbBytes
    )
{
    LPVOID pv;
    // LPTR (OR includes ZEROINIT)
    pv = (LPVOID) LocalAlloc(LPTR, cbBytes);
    if (pv == NULL)
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}

// Calls malloc when DBG is defined. Otherwise, does a
// LocalAlloc without ZEOINIT.
LPVOID
WINAPI
PkiNonzeroAlloc(
    IN size_t cbBytes
    )
{
    LPVOID pv;
    pv = (LPVOID) LocalAlloc(NONZEROLPTR, cbBytes);
    if (pv == NULL)
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}

LPVOID
WINAPI
PkiRealloc(
    IN LPVOID pvOrg,
    IN size_t cbBytes
    )
{
    LPVOID pv;
    if (NULL == (pv = pvOrg ?
            (LPVOID) LocalReAlloc((HLOCAL)pvOrg, cbBytes, LMEM_MOVEABLE) :
            (LPVOID) LocalAlloc(NONZEROLPTR, cbBytes)))
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}

VOID
WINAPI
PkiFree(
    IN LPVOID pv
    )
{
    if (pv)
        LocalFree((HLOCAL)pv);
}

//+-------------------------------------------------------------------------
//  The following functions always use LocalAlloc and LocalFree Win32 APIs.
//--------------------------------------------------------------------------
LPVOID
WINAPI
PkiDefaultCryptAlloc(
    IN size_t cbSize
    )
{
    LPVOID pv;
    if (NULL == (pv = (LPVOID) LocalAlloc(NONZEROLPTR, cbSize)))
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}

VOID
WINAPI
PkiDefaultCryptFree(
    IN LPVOID pv
    )
{
    if (pv)
        LocalFree((HLOCAL) pv);
}

//+-------------------------------------------------------------------------
//  The following data structure's pfnAlloc and pfnFree are set to
//  PkiNonzeroAlloc and PkiFree.
//--------------------------------------------------------------------------
CRYPT_ENCODE_PARA PkiEncodePara = {
    offsetof(CRYPT_ENCODE_PARA, pfnFree) + sizeof(PkiEncodePara.pfnFree),
    PkiNonzeroAlloc,
    PkiFree
};


//+-------------------------------------------------------------------------
//  If pfnAlloc isn't defined, returns PkiDefaultCryptAlloc
//--------------------------------------------------------------------------
PFN_CRYPT_ALLOC
WINAPI
PkiGetEncodeAllocFunction(
    IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara
    )
{
    if (pEncodePara &&
            pEncodePara->cbSize >= offsetof(CRYPT_ENCODE_PARA, pfnAlloc) +
                sizeof(pEncodePara->pfnAlloc) &&
            pEncodePara->pfnAlloc)
        return pEncodePara->pfnAlloc;
    else
        return PkiDefaultCryptAlloc;
}

//+-------------------------------------------------------------------------
//  If pfnFree isn't defined, returns PkiDefaultCryptFree
//--------------------------------------------------------------------------
PFN_CRYPT_FREE
WINAPI
PkiGetEncodeFreeFunction(
    IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara
    )
{
    if (pEncodePara &&
            pEncodePara->cbSize >= offsetof(CRYPT_ENCODE_PARA, pfnFree) +
                sizeof(pEncodePara->pfnFree) &&
            pEncodePara->pfnFree)
        return pEncodePara->pfnFree;
    else
        return PkiDefaultCryptFree;
}

//+-------------------------------------------------------------------------
//  The following data structure's pfnAlloc and pfnFree are set to
//  PkiNonzeroAlloc and PkiFree.
//--------------------------------------------------------------------------
CRYPT_DECODE_PARA PkiDecodePara = {
    offsetof(CRYPT_DECODE_PARA, pfnFree) + sizeof(PkiDecodePara.pfnFree),
    PkiNonzeroAlloc,
    PkiFree
};

//+-------------------------------------------------------------------------
//  If pfnAlloc isn't defined, returns PkiDefaultCryptAlloc
//--------------------------------------------------------------------------
PFN_CRYPT_ALLOC
WINAPI
PkiGetDecodeAllocFunction(
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara
    )
{
    if (pDecodePara &&
            pDecodePara->cbSize >= offsetof(CRYPT_DECODE_PARA, pfnAlloc) +
                sizeof(pDecodePara->pfnAlloc) &&
            pDecodePara->pfnAlloc)
        return pDecodePara->pfnAlloc;
    else
        return PkiDefaultCryptAlloc;
}

//+-------------------------------------------------------------------------
//  If pfnFree isn't defined, returns PkiDefaultCryptFree
//--------------------------------------------------------------------------
PFN_CRYPT_FREE
WINAPI
PkiGetDecodeFreeFunction(
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara
    )
{
    if (pDecodePara &&
            pDecodePara->cbSize >= offsetof(CRYPT_DECODE_PARA, pfnFree) +
                sizeof(pDecodePara->pfnFree) &&
            pDecodePara->pfnFree)
        return pDecodePara->pfnFree;
    else
        return PkiDefaultCryptFree;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\spbase\asn1enc.h ===
/* Copyright (C) Microsoft Corporation, 1996-1999. All rights reserved. */
/* ASN.1 definitions for SCHANNEL FORTEZZA and Private Key encoding */

#ifndef _ASN1ENC_Module_H_
#define _ASN1ENC_Module_H_

#include "msber.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef ASN1open_t PrivateKeyInfo_attributes_Set;

typedef ASN1intx_t HUGEINTEGER;

typedef ASN1bitstring_t BITSTRING;

typedef ASN1octetstring_t OCTETSTRING;

typedef ASN1open_t NOCOPYANY;

typedef ASN1charstring_t NUMERICSTRING;

typedef ASN1charstring_t PRINTABLESTRING;

typedef ASN1charstring_t TELETEXSTRING;

typedef ASN1charstring_t T61STRING;

typedef ASN1charstring_t VIDEOTEXSTRING;

typedef ASN1charstring_t IA5STRING;

typedef ASN1charstring_t GRAPHICSTRING;

typedef ASN1charstring_t VISIBLESTRING;

typedef ASN1charstring_t ISO646STRING;

typedef ASN1charstring_t GENERALSTRING;

typedef ASN1char32string_t UNIVERSALSTRING;

typedef ASN1char16string_t BMPSTRING;

typedef ASN1objectidentifier2_t ObjectID;

typedef BITSTRING FORTPublicKey;
#define FORTPublicKey_PDU 0
#define SIZE_ASN1ENC_Module_PDU_0 sizeof(FORTPublicKey)

typedef ASN1octetstring_t EncryptedData;

typedef ObjectID UsageIdentifier;

typedef struct PrivateKeyInfo_attributes {
    ASN1uint32_t count;
    PrivateKeyInfo_attributes_Set *value;
} PrivateKeyInfo_attributes;

typedef struct AlgorithmIdentifier {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ObjectID algorithm;
#   define parameters_present 0x80
    ASN1open_t parameters;
} AlgorithmIdentifier;

typedef struct RSAPrivateKey {
    ASN1int32_t version;
    HUGEINTEGER modulus;
    ASN1int32_t publicExponent;
    HUGEINTEGER privateExponent;
    HUGEINTEGER prime1;
    HUGEINTEGER prime2;
    HUGEINTEGER exponent1;
    HUGEINTEGER exponent2;
    HUGEINTEGER coefficient;
} RSAPrivateKey;
#define RSAPrivateKey_PDU 1
#define SIZE_ASN1ENC_Module_PDU_1 sizeof(RSAPrivateKey)

typedef struct PrivateKeyInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    AlgorithmIdentifier privateKeyAlgorithm;
    ASN1octetstring_t privateKey;
#   define attributes_present 0x80
    PrivateKeyInfo_attributes attributes;
} PrivateKeyInfo;
#define PrivateKeyInfo_PDU 2
#define SIZE_ASN1ENC_Module_PDU_2 sizeof(PrivateKeyInfo)

typedef struct PrivateKeyData {
    AlgorithmIdentifier privateKeyAlgorithm;
    EncryptedData privateKey;
} PrivateKeyData;

typedef struct PrivateKeyFile {
    ASN1octetstring_t name;
    PrivateKeyData privateKey;
} PrivateKeyFile;
#define PrivateKeyFile_PDU 3
#define SIZE_ASN1ENC_Module_PDU_3 sizeof(PrivateKeyFile)

typedef struct EnhancedKeyUsage {
    ASN1uint32_t count;
    UsageIdentifier *value;
} EnhancedKeyUsage;
#define EnhancedKeyUsage_PDU 4
#define SIZE_ASN1ENC_Module_PDU_4 sizeof(EnhancedKeyUsage)


extern ASN1module_t ASN1ENC_Module;
extern void ASN1CALL ASN1ENC_Module_Startup(void);
extern void ASN1CALL ASN1ENC_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _ASN1ENC_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\pkiutil\pkiasn1.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1998
//
//  File:       pkiasn1.cpp
//
//  Contents:   PKI ASN.1 support functions.
//
//  Functions:  PkiAsn1Encode
//              PkiAsn1Decode
//              PkiAsn1SetEncodingRule
//              PkiAsn1GetEncodingRule
//
//              PkiAsn1ReverseBytes
//              PkiAsn1EncodeInfoEx
//              PkiAsn1EncodeInfo
//              PkiAsn1DecodeAndAllocInfo
//              PkiAsn1AllocStructInfoEx
//              PkiAsn1DecodeAndAllocInfoEx
//
//              PkiAsn1ToObjectIdentifier
//              PkiAsn1FromObjectIdentifier
//
//
//  History:    23-Oct-98    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

// All the *pvInfo extra stuff needs to be aligned
#define INFO_LEN_ALIGN(Len)  ((Len + 7) & ~7)


inline BOOL my_isdigit( char ch)
{
    return (ch >= '0') && (ch <= '9');
}

//+-------------------------------------------------------------------------
//  Asn1 Encode function. The encoded output is allocated and must be freed
//  by calling PkiAsn1FreeEncoded().
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Encode(
    IN ASN1encoding_t pEnc,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    )
{
    ASN1error_e Asn1Err;

    Asn1Err = ASN1_Encode(
        pEnc,
        pvAsn1Info,
        id,
        ASN1ENCODE_ALLOCATEBUFFER,
        NULL,                       // pbBuf
        0                           // cbBufSize
        );

    if (ASN1_SUCCEEDED(Asn1Err)) {
        Asn1Err = ASN1_SUCCESS;
        *ppbEncoded = pEnc->buf;
        *pcbEncoded = pEnc->len;
    } else {
        *ppbEncoded = NULL;
        *pcbEncoded = 0;
    }
    return Asn1Err;
}

//+-------------------------------------------------------------------------
//  Asn1 Encode function. The encoded output isn't allocated.
//
//  If pbEncoded is NULL, does a length only calculation.
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Encode2(
    IN ASN1encoding_t pEnc,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id,
    OUT OPTIONAL BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    ASN1error_e Asn1Err;
    DWORD cbEncoded;

    if (NULL == pbEncoded)
        cbEncoded = 0;
    else
        cbEncoded = *pcbEncoded;

    if (0 == cbEncoded) {
        // Length only calculation

        Asn1Err = ASN1_Encode(
            pEnc,
            pvAsn1Info,
            id,
            ASN1ENCODE_ALLOCATEBUFFER,
            NULL,                       // pbBuf
            0                           // cbBufSize
            );

        if (ASN1_SUCCEEDED(Asn1Err)) {
            if (pbEncoded)
                Asn1Err = ASN1_ERR_OVERFLOW;
            else
                Asn1Err = ASN1_SUCCESS;
            cbEncoded = pEnc->len;
            PkiAsn1FreeEncoded(pEnc, pEnc->buf);
        }
    } else {
        Asn1Err = ASN1_Encode(
            pEnc,
            pvAsn1Info,
            id,
            ASN1ENCODE_SETBUFFER,
            pbEncoded,
            cbEncoded
            );

        if (ASN1_SUCCEEDED(Asn1Err)) {
            Asn1Err = ASN1_SUCCESS;
            cbEncoded = pEnc->len;
        } else if (ASN1_ERR_OVERFLOW == Asn1Err) {
            // Re-do as length only calculation
            Asn1Err = PkiAsn1Encode2(
                pEnc,
                pvAsn1Info,
                id,
                NULL,   // pbEncoded
                &cbEncoded
                );
            if (ASN1_SUCCESS == Asn1Err)
                Asn1Err = ASN1_ERR_OVERFLOW;
        } else
            cbEncoded = 0;
    }

    *pcbEncoded = cbEncoded;
    return Asn1Err;
}

//+-------------------------------------------------------------------------
//  Asn1 Decode function. The allocated, decoded structure, **pvAsn1Info, must
//  be freed by calling PkiAsn1FreeDecoded().
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Decode(
    IN ASN1decoding_t pDec,
    OUT void **ppvAsn1Info,
    IN ASN1uint32_t id,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded
    )
{
    ASN1error_e Asn1Err;

    *ppvAsn1Info = NULL;
    Asn1Err = ASN1_Decode(
        pDec,
        ppvAsn1Info,
        id,
        ASN1DECODE_SETBUFFER,
        (BYTE *) pbEncoded,
        cbEncoded
        );
    if (ASN1_SUCCEEDED(Asn1Err))
        Asn1Err = ASN1_SUCCESS;
    else {
        if (ASN1_ERR_BADARGS == Asn1Err)
            Asn1Err = ASN1_ERR_EOD;
        *ppvAsn1Info = NULL;
    }
    return Asn1Err;
}

//+-------------------------------------------------------------------------
//  Asn1 Decode function. The allocated, decoded structure, **pvAsn1Info, must
//  be freed by calling PkiAsn1FreeDecoded().
//
//  For a successful decode, *ppbEncoded is advanced
//  past the decoded bytes and *pcbDecoded is decremented by the number
//  of decoded bytes.
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Decode2(
    IN ASN1decoding_t pDec,
    OUT void **ppvAsn1Info,
    IN ASN1uint32_t id,
    IN OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    ASN1error_e Asn1Err;

    *ppvAsn1Info = NULL;
    Asn1Err = ASN1_Decode(
        pDec,
        ppvAsn1Info,
        id,
        ASN1DECODE_SETBUFFER,
        *ppbEncoded,
        *pcbEncoded
        );
    if (ASN1_SUCCEEDED(Asn1Err)) {
        Asn1Err = ASN1_SUCCESS;
        *ppbEncoded += pDec->len;
        *pcbEncoded -= pDec->len;
    } else {
        if (ASN1_ERR_BADARGS == Asn1Err)
            Asn1Err = ASN1_ERR_EOD;
        *ppvAsn1Info = NULL;
    }
    return Asn1Err;
}


//+-------------------------------------------------------------------------
//  Asn1 Set/Get encoding rules functions
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1SetEncodingRule(
    IN ASN1encoding_t pEnc,
    IN ASN1encodingrule_e eRule
    )
{
    ASN1optionparam_s OptParam;

    OptParam.eOption = ASN1OPT_CHANGE_RULE;
    OptParam.eRule = eRule;

    return ASN1_SetEncoderOption(pEnc, &OptParam);
}

ASN1encodingrule_e
WINAPI
PkiAsn1GetEncodingRule(
    IN ASN1encoding_t pEnc
    )
{
    ASN1error_e Asn1Err;
    ASN1encodingrule_e eRule;
    ASN1optionparam_s OptParam;
    OptParam.eOption = ASN1OPT_GET_RULE;

    Asn1Err = ASN1_GetEncoderOption(pEnc, &OptParam);
    if (ASN1_SUCCEEDED(Asn1Err))
        eRule = OptParam.eRule;
    else
        eRule = ASN1_BER_RULE_DER;

    return eRule;
}


//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes in place
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1ReverseBytes(
			IN OUT PBYTE pbIn,
			IN DWORD cbIn
            )
{
    // reverse in place
    PBYTE	pbLo;
    PBYTE	pbHi;
    BYTE	bTmp;

    for (pbLo = pbIn, pbHi = pbIn + cbIn - 1; pbLo < pbHi; pbHi--, pbLo++) {
        bTmp = *pbHi;
        *pbHi = *pbLo;
        *pbLo = bTmp;
    }
}

//+-------------------------------------------------------------------------
//  Encode an ASN1 formatted info structure.
//
//  If CRYPT_ENCODE_ALLOC_FLAG is set, allocate memory for pbEncoded and
//  return *((BYTE **) pvEncoded) = pbAllocEncoded. Otherwise,
//  pvEncoded points to byte array to be updated.
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1EncodeInfoEx(
        IN ASN1encoding_t pEnc,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    ASN1error_e Asn1Err;
    DWORD cbEncoded;

    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG) {
        BYTE *pbEncoded;
        BYTE *pbAllocEncoded;
        PFN_CRYPT_ALLOC pfnAlloc;

        PkiAsn1SetEncodingRule(pEnc, ASN1_BER_RULE_DER);
        Asn1Err = PkiAsn1Encode(
            pEnc,
            pvAsn1Info,
            id,
            &pbEncoded,
            &cbEncoded
            );

        if (ASN1_SUCCESS != Asn1Err) {
            *((void **) pvEncoded) = NULL;
            goto Asn1EncodeError;
        }

        pfnAlloc = PkiGetEncodeAllocFunction(pEncodePara);
        if (NULL == (pbAllocEncoded = (BYTE *) pfnAlloc(cbEncoded))) {
            PkiAsn1FreeEncoded(pEnc, pbEncoded);
            *((void **) pvEncoded) = NULL;
            goto OutOfMemory;
        }
        memcpy(pbAllocEncoded, pbEncoded, cbEncoded);
        *((BYTE **) pvEncoded) = pbAllocEncoded;
        PkiAsn1FreeEncoded(pEnc, pbEncoded);
    } else {
        cbEncoded = *pcbEncoded;
        PkiAsn1SetEncodingRule(pEnc, ASN1_BER_RULE_DER);
        Asn1Err = PkiAsn1Encode2(
            pEnc,
            pvAsn1Info,
            id,
            (BYTE *) pvEncoded,
            &cbEncoded
            );

        if (ASN1_SUCCESS != Asn1Err) {
            if (ASN1_ERR_OVERFLOW == Asn1Err)
                goto LengthError;
            else
                goto Asn1EncodeError;
        }
    }

    fResult = TRUE;
CommonReturn:
    *pcbEncoded = cbEncoded;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

OutOfMemory:
    goto ErrorReturn;

LengthError:
    SetLastError(ERROR_MORE_DATA);
    goto ErrorReturn;

Asn1EncodeError:
    SetLastError(PkiAsn1ErrToHr(Asn1Err));
    goto ErrorReturn;
}

//+-------------------------------------------------------------------------
//  Encode an ASN1 formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1EncodeInfo(
        IN ASN1encoding_t pEnc,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info,
        OUT OPTIONAL BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return PkiAsn1EncodeInfoEx(
        pEnc,
        id,
        pvAsn1Info,
        0,                  // dwFlags
        NULL,               // pEncodePara
        pbEncoded,
        pcbEncoded
        );
}


//+-------------------------------------------------------------------------
//  Decode into an allocated, ASN1 formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1DecodeAndAllocInfo(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT void **ppvAsn1Info
        )
{
    BOOL fResult;
    ASN1error_e Asn1Err;

    *ppvAsn1Info = NULL;
    if (ASN1_SUCCESS != (Asn1Err = PkiAsn1Decode(
            pDec,
            ppvAsn1Info,
            id,
            pbEncoded,
            cbEncoded
            )))
        goto Asn1DecodeError;
    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    *ppvAsn1Info = NULL;
    fResult = FALSE;
    goto CommonReturn;

Asn1DecodeError:
    SetLastError(PkiAsn1ErrToHr(Asn1Err));
    goto ErrorReturn;
}


//+-------------------------------------------------------------------------
//  Call the callback to convert the ASN1 structure into the 'C' structure.
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1AllocStructInfoEx(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    BOOL fResult;
    LONG lRemainExtra;
    DWORD cbStructInfo;

    if (NULL == pvStructInfo || (dwFlags & CRYPT_DECODE_ALLOC_FLAG)) {
        cbStructInfo = 0;
        lRemainExtra = 0;
    } else {
        cbStructInfo = *pcbStructInfo;
        lRemainExtra = (LONG) cbStructInfo;
    }

    if (!pfnDecodeExCallback(
            pvAsn1Info,
            dwFlags & ~CRYPT_DECODE_ALLOC_FLAG,
            pDecodePara,
            pvStructInfo,
            &lRemainExtra
            )) goto DecodeCallbackError;

    if (dwFlags & CRYPT_DECODE_ALLOC_FLAG) {
        void *pv;
        PFN_CRYPT_ALLOC pfnAlloc = PkiGetDecodeAllocFunction(pDecodePara);

        assert(0 > lRemainExtra);
        lRemainExtra = -lRemainExtra;
        cbStructInfo = (DWORD) lRemainExtra;

        if (NULL == (pv = pfnAlloc(cbStructInfo)))
            goto OutOfMemory;
        if (!pfnDecodeExCallback(
                pvAsn1Info,
                dwFlags & ~CRYPT_DECODE_ALLOC_FLAG,
                pDecodePara,
                pv,
                &lRemainExtra
                )) {
            PFN_CRYPT_FREE pfnFree = PkiGetDecodeFreeFunction(pDecodePara);
            pfnFree(pv);
            goto DecodeCallbackError;
        }
        *((void **) pvStructInfo) = pv;
        assert(0 <= lRemainExtra);
    }

    if (0 <= lRemainExtra) {
        cbStructInfo = cbStructInfo - (DWORD) lRemainExtra;
    } else {
        cbStructInfo = cbStructInfo + (DWORD) -lRemainExtra;
        if (pvStructInfo) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fResult = FALSE;
            goto CommonReturn;
        }
    }

    fResult = TRUE;
CommonReturn:
    *pcbStructInfo = cbStructInfo;
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_DECODE_ALLOC_FLAG)
        *((void **) pvStructInfo) = NULL;
    cbStructInfo = 0;
    fResult = FALSE;
    goto CommonReturn;

DecodeCallbackError:
    goto ErrorReturn;

OutOfMemory:
    goto ErrorReturn;
}

//+-------------------------------------------------------------------------
//  Decode the ASN1 formatted info structure and call the callback
//  function to convert the ASN1 structure to the 'C' structure.
//
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1DecodeAndAllocInfoEx(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    BOOL fResult;
    void *pvAsn1Info = NULL;

    if (!PkiAsn1DecodeAndAllocInfo(
            pDec,
            id,
            pbEncoded,
            cbEncoded,
            &pvAsn1Info
            )) goto Asn1DecodeError;

    fResult = PkiAsn1AllocStructInfoEx(
        pvAsn1Info,
        dwFlags,
        pDecodePara,
        pfnDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
CommonReturn:
    PkiAsn1FreeInfo(pDec, id, pvAsn1Info);
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_DECODE_ALLOC_FLAG)
        *((void **) pvStructInfo) = NULL;
    *pcbStructInfo = 0;
    fResult = FALSE;
    goto CommonReturn;

Asn1DecodeError:
    goto ErrorReturn;
}

//+-------------------------------------------------------------------------
//  Convert the ascii string ("1.2.9999") to ASN1's Object Identifier
//  represented as an array of unsigned longs.
//
//  Returns TRUE for a successful conversion. 
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1ToObjectIdentifier(
    IN LPCSTR pszObjId,
    IN OUT ASN1uint16_t *pCount,
    OUT ASN1uint32_t rgulValue[]
    )
{
    BOOL fResult = TRUE;
    unsigned short c = 0;
    LPSTR psz = (LPSTR) pszObjId;
    char    ch;

    if (psz) {
        ASN1uint16_t cMax = *pCount;
        ASN1uint32_t *pul = rgulValue;
        while ((ch = *psz) != '\0' && c++ < cMax) {
            *pul++ = (ASN1uint32_t)atol(psz);
            while (my_isdigit(ch = *psz++))
                ;
            if (ch != '.')
                break;
        }
        if (ch != '\0')
            fResult = FALSE;
    }
    *pCount = c;
    return fResult;
}

//+-------------------------------------------------------------------------
//  Convert from ASN1's Object Identifier represented as an array of
//  unsigned longs to an ascii string ("1.2.9999").
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1FromObjectIdentifier(
    IN ASN1uint16_t Count,
    IN ASN1uint32_t rgulValue[],
    OUT LPSTR pszObjId,
    IN OUT DWORD *pcbObjId
    )
{
    BOOL fResult = TRUE;
    LONG lRemain;

    if (pszObjId == NULL)
        *pcbObjId = 0;

    lRemain = (LONG) *pcbObjId;
    if (Count == 0) {
        if (--lRemain > 0)
            pszObjId++;
    } else {
        char rgch[36];
        LONG lData;
        ASN1uint32_t *pul = rgulValue;
        for (; Count > 0; Count--, pul++) {
            _ltoa(*pul, rgch, 10);
            lData = strlen(rgch);
            lRemain -= lData + 1;
            if (lRemain >= 0) {
                if (lData > 0) {
                    memcpy(pszObjId, rgch, lData);
                    pszObjId += lData;
                }
                *pszObjId++ = '.';
            }
        }
    }

    if (lRemain >= 0) {
        *(pszObjId -1) = '\0';
        *pcbObjId = *pcbObjId - (DWORD) lRemain;
    } else {
        *pcbObjId = *pcbObjId + (DWORD) -lRemain;
        if (pszObjId) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fResult = FALSE;
        }
    }

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\spbase\capi.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       capi.c
//
//  Contents:   Traffic cop routines that allow schannel to switch between
//              calling an actual CSP and calling a statically linked 
//              (domestic) CSP.
//
//  Functions:
//
//  History:    11-04-97   jbanes   Created.
//              03-31-99   jbanes   Removed support for static CSP.
//
//----------------------------------------------------------------------------

#include <spbase.h>

BOOL
WINAPI
SchCryptAcquireContextA(
    HCRYPTPROV *phProv,
    LPCSTR pszContainer,
    LPCSTR pszProvider,
    DWORD dwProvType,
    DWORD dwFlags,
    DWORD dwSchFlags)
{
    return CryptAcquireContextA(phProv, pszContainer, pszProvider, dwProvType, dwFlags);
}

BOOL
WINAPI
SchCryptAcquireContextW(
    HCRYPTPROV *phProv,
    LPCWSTR pszContainer,
    LPCWSTR pszProvider,
    DWORD dwProvType,
    DWORD dwFlags,
    DWORD dwSchFlags)
{
    return CryptAcquireContextW(phProv, pszContainer, pszProvider, dwProvType, dwFlags);
}

BOOL
WINAPI
SchCryptCreateHash(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    HCRYPTKEY hKey,
    DWORD dwFlags,
    HCRYPTHASH *phHash,
    DWORD dwSchFlags)
{
    return CryptCreateHash(hProv, Algid, hKey, dwFlags, phHash);
}

BOOL
WINAPI
SchCryptDecrypt(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwSchFlags)
{
    return CryptDecrypt(hKey, hHash, Final, dwFlags, pbData, pdwDataLen);
}

BOOL
WINAPI
SchCryptDeriveKey(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    HCRYPTHASH hBaseData,
    DWORD dwFlags,
    HCRYPTKEY *phKey,
    DWORD dwSchFlags)
{
    return CryptDeriveKey(hProv, Algid, hBaseData, dwFlags, phKey);
}

BOOL
WINAPI
SchCryptDestroyHash(
    HCRYPTHASH hHash,
    DWORD dwSchFlags)
{
    return CryptDestroyHash(hHash);
}

BOOL
WINAPI
SchCryptDestroyKey(
    HCRYPTKEY hKey,
    DWORD dwSchFlags)
{
    return CryptDestroyKey(hKey);
}

BOOL
WINAPI 
SchCryptDuplicateHash(
    HCRYPTHASH hHash,
    DWORD *pdwReserved,
    DWORD dwFlags,
    HCRYPTHASH * phHash,
    DWORD dwSchFlags)
{
    return CryptDuplicateHash(hHash, pdwReserved, dwFlags, phHash);
}

BOOL
WINAPI 
SchCryptDuplicateKey(
    HCRYPTKEY hKey,
    DWORD *pdwReserved,
    DWORD dwFlags,
    HCRYPTKEY * phKey,
    DWORD dwSchFlags)
{
    return CryptDuplicateKey(hKey, pdwReserved, dwFlags, phKey);
}

BOOL
WINAPI
SchCryptEncrypt(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwBufLen,
    DWORD dwSchFlags)
{
    return CryptEncrypt(hKey, hHash, Final, dwFlags, pbData, pdwDataLen, dwBufLen);
}

BOOL
WINAPI
SchCryptExportKey(
    HCRYPTKEY hKey,
    HCRYPTKEY hExpKey,
    DWORD dwBlobType,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwSchFlags)
{
    return CryptExportKey(hKey, hExpKey, dwBlobType, dwFlags, pbData, pdwDataLen);
}

BOOL
WINAPI
SchCryptGenKey(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    DWORD dwFlags,
    HCRYPTKEY *phKey,
    DWORD dwSchFlags)
{
    return CryptGenKey(hProv, Algid, dwFlags, phKey);
}

BOOL
WINAPI
SchCryptGenRandom(
    HCRYPTPROV hProv,
    DWORD dwLen,
    BYTE *pbBuffer,
    DWORD dwSchFlags)
{
    return CryptGenRandom(hProv, dwLen, pbBuffer);
}

BOOL
WINAPI
SchCryptGetHashParam(
    HCRYPTHASH hHash,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags,
    DWORD dwSchFlags)
{
    return CryptGetHashParam(hHash, dwParam, pbData, pdwDataLen, dwFlags);
}

BOOL
WINAPI
SchCryptGetKeyParam(
    HCRYPTKEY hKey,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags,
    DWORD dwSchFlags)
{
    return CryptGetKeyParam(hKey, dwParam, pbData, pdwDataLen, dwFlags);
}

BOOL
WINAPI
SchCryptGetProvParam(
    HCRYPTPROV hProv,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags,
    DWORD dwSchFlags)
{
    return CryptGetProvParam(hProv, dwParam, pbData, pdwDataLen, dwFlags);
}

BOOL
WINAPI
SchCryptGetUserKey(
    HCRYPTPROV hProv,
    DWORD dwKeySpec,
    HCRYPTKEY *phUserKey,
    DWORD dwSchFlags)
{
    return CryptGetUserKey(hProv, dwKeySpec, phUserKey);
}

BOOL
WINAPI
SchCryptHashData(
    HCRYPTHASH hHash,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    DWORD dwFlags,
    DWORD dwSchFlags)
{
    return CryptHashData(hHash, pbData, dwDataLen, dwFlags);
}

BOOL
WINAPI
SchCryptHashSessionKey(
    HCRYPTHASH hHash,
    HCRYPTKEY hKey,
    DWORD dwFlags,
    DWORD dwSchFlags)
{
    return CryptHashSessionKey(hHash, hKey, dwFlags);
}

BOOL
WINAPI
SchCryptImportKey(
    HCRYPTPROV hProv,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    HCRYPTKEY hPubKey,
    DWORD dwFlags,
    HCRYPTKEY *phKey,
    DWORD dwSchFlags)
{
    return CryptImportKey(hProv, pbData, dwDataLen, hPubKey, dwFlags, phKey);
}

BOOL
WINAPI
SchCryptReleaseContext(
    HCRYPTPROV hProv,
    DWORD dwFlags,
    DWORD dwSchFlags)
{
    return CryptReleaseContext(hProv, dwFlags);
}

BOOL
WINAPI
SchCryptSetHashParam(
    HCRYPTHASH hHash,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags,
    DWORD dwSchFlags)
{
    return CryptSetHashParam(hHash, dwParam, pbData, dwFlags);
}

BOOL
WINAPI
SchCryptSetKeyParam(
    HCRYPTKEY hKey,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags,
    DWORD dwSchFlags)
{
    return CryptSetKeyParam(hKey, dwParam, pbData, dwFlags);
}

BOOL
WINAPI
SchCryptSetProvParam(
    HCRYPTPROV hProv,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags,
    DWORD dwSchFlags)
{
    return CryptSetProvParam(hProv, dwParam, pbData, dwFlags);
}

BOOL
WINAPI
SchCryptSignHash(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCSTR sDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen,
    DWORD dwSchFlags)
{
    return CryptSignHash(hHash, dwKeySpec, sDescription, dwFlags, pbSignature, pdwSigLen);
}

BOOL
WINAPI
SchCryptVerifySignature(
    HCRYPTHASH hHash,
    CONST BYTE *pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCSTR sDescription,
    DWORD dwFlags,
    DWORD dwSchFlags)
{
    return CryptVerifySignature(hHash, pbSignature, dwSigLen, hPubKey, sDescription, dwFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\spbase\cache.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cache.c
//
//  Contents:   
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes    LSA integration stuff.
//              07-31-98   jbanes    Made thread-safe. 
//
//----------------------------------------------------------------------------

#include "spbase.h"
#include <limits.h>
#include <mapper.h>
#include <sslcache.h>

SCHANNEL_CACHE SchannelCache = 
{
    NULL,                           // SessionCache 

    SP_CACHE_CLIENT_LIFESPAN,       // dwClientLifespan
    SP_CACHE_SERVER_LIFESPAN,       // dwServerLifespan
    SP_CACHE_CLEANUP_INTERVAL,      // dwCleanupInterval
    SP_MAXIMUM_CACHE_ELEMENTS,      // dwCacheSize
    SP_MAXIMUM_CACHE_ELEMENTS,      // dwMaximumEntries
    0                               // dwUsedEntries
};

RTL_CRITICAL_SECTION g_CacheCleanupLock;
BOOL             g_CacheCleanupCritSectInitialized = FALSE;
LIST_ENTRY       g_CacheCleanupList;
DWORD            g_CacheCleanupCount = 0;
HANDLE           g_CacheCleanupEvent = NULL;
HANDLE           g_CacheCleanupWaitObject = NULL;
BOOL             g_fMultipleProcessClientCache = FALSE;
BOOL             g_fCacheInitialized = FALSE;

// Perf counter values.
DWORD g_cClientHandshakes = 0;
DWORD g_cServerHandshakes = 0;
DWORD g_cClientReconnects = 0;
DWORD g_cServerReconnects = 0;


BOOL
SPCacheDelete(
    PSessCacheItem pItem);

BOOL
CacheExpireElements(
    BOOL fCleanupOnly,
    BOOL fBackground);

VOID 
CacheCleanupHandler(
    PVOID pVoid, 
    BOOLEAN fTimeout);


SP_STATUS
SPInitSessionCache(VOID)
{
    DWORD i;
    NTSTATUS Status = STATUS_SUCCESS;

    SP_BEGIN("SPInitSessionCache");

    // 
    // Allocate memory for cache, and initialize synchronization resource.
    //

    InitializeListHead(&SchannelCache.EntryList);
    RtlInitializeResource(&SchannelCache.Lock);
    SchannelCache.LockInitialized = TRUE;

    SchannelCache.SessionCache = (PLIST_ENTRY)SPExternalAlloc(SchannelCache.dwCacheSize * sizeof(LIST_ENTRY));
    if(SchannelCache.SessionCache == NULL)
    {
        Status = SP_LOG_RESULT(STATUS_NO_MEMORY);
        goto cleanup;
    }

    for(i = 0; i < SchannelCache.dwCacheSize; i++)
    {
        InitializeListHead(&SchannelCache.SessionCache[i]);
    }

    DebugLog((DEB_TRACE, "Space reserved at 0x%x for %d cache entries.\n", 
        SchannelCache.SessionCache,
        SchannelCache.dwCacheSize));

    //
    // Initialize cache cleanup objects.
    //

    InitializeListHead(&g_CacheCleanupList);
    Status = RtlInitializeCriticalSection(&g_CacheCleanupLock);
    if(!NT_SUCCESS(Status))
    {
        goto cleanup;
    }
    g_CacheCleanupCritSectInitialized = TRUE;

    
    g_CacheCleanupEvent = CreateEvent(NULL,
                                      FALSE,
                                      FALSE,
                                      NULL);

    if(NULL == g_CacheCleanupEvent)
    {
        Status = GetLastError();
        goto cleanup;
    }

    if(!RegisterWaitForSingleObject(&g_CacheCleanupWaitObject,
                                    g_CacheCleanupEvent,
                                    CacheCleanupHandler,
                                    NULL,
                                    SchannelCache.dwCleanupInterval,
                                    WT_EXECUTEDEFAULT))
    {
        Status = GetLastError();
        goto cleanup;
    }

    g_fCacheInitialized = TRUE;

    Status = STATUS_SUCCESS;

cleanup:

    if(!NT_SUCCESS(Status))
    {
        SPShutdownSessionCache();
    }

    SP_RETURN(Status);
}


SP_STATUS
SPShutdownSessionCache(VOID)
{
    PSessCacheItem pItem;
    PLIST_ENTRY pList;
    DWORD i;

    SP_BEGIN("SPShutdownSessionCache");

    if(SchannelCache.LockInitialized)
    {
        RtlAcquireResourceExclusive(&SchannelCache.Lock, TRUE);
    }

    g_fCacheInitialized = FALSE;

    if(SchannelCache.SessionCache != NULL)
    {
        // Blindly kill all cache items.
        // No contexts should be running at
        // this time.
        pList = SchannelCache.EntryList.Flink;

        while(pList != &SchannelCache.EntryList)
        {
            pItem  = CONTAINING_RECORD(pList, SessCacheItem, EntryList.Flink);
            pList  = pList->Flink;

            SPCacheDelete(pItem);
        }

        SPExternalFree(SchannelCache.SessionCache);
    }

    if(g_CacheCleanupCritSectInitialized)
    {
        RtlDeleteCriticalSection(&g_CacheCleanupLock);
        g_CacheCleanupCritSectInitialized = FALSE;
    }

    if(g_CacheCleanupWaitObject)
    {
        UnregisterWaitEx(g_CacheCleanupWaitObject, INVALID_HANDLE_VALUE);
        g_CacheCleanupWaitObject = NULL;
    }

    if(g_CacheCleanupEvent)
    {
        CloseHandle(g_CacheCleanupEvent);
        g_CacheCleanupEvent = NULL;
    }

    if(SchannelCache.LockInitialized)
    {
        RtlDeleteResource(&SchannelCache.Lock);
        SchannelCache.LockInitialized = FALSE;
    }

    SP_RETURN(PCT_ERR_OK);
}


LONG
SPCacheReference(
    PSessCacheItem pItem)
{
    LONG cRet;

    if(pItem == NULL)
    {
        return -1;
    }

    ASSERT(pItem->Magic == SP_CACHE_MAGIC);

    cRet = InterlockedIncrement(&pItem->cRef);

    return cRet;
}


LONG
SPCacheDereference(PSessCacheItem pItem)
{
    long cRet;

    if(pItem == NULL)
    {
        return -1;
    }

    ASSERT(pItem->Magic == SP_CACHE_MAGIC);

    cRet = InterlockedDecrement(&pItem->cRef);

    ASSERT(cRet > 0);

    return cRet;
}


BOOL
SPCacheDelete(
    PSessCacheItem pItem)
{
    long cRet;

    DebugLog((DEB_TRACE, "Delete cache item:0x%x\n", pItem));

    if(pItem == NULL)
    {
        return FALSE;
    }

    ASSERT(pItem->Magic == SP_CACHE_MAGIC);

    pItem->pActiveServerCred = NULL;
    pItem->pServerCred       = NULL;

    if(pItem->hMasterKey)
    {
        if(!CryptDestroyKey(pItem->hMasterKey))
        {
            SP_LOG_RESULT(GetLastError());
        }
        pItem->hMasterKey = 0;
    }

    if(pItem->pRemoteCert)
    {
        CertFreeCertificateContext(pItem->pRemoteCert);
        pItem->pRemoteCert = NULL;
    }

    if(pItem->pRemotePublic)
    {
        SPExternalFree(pItem->pRemotePublic);
        pItem->pRemotePublic = NULL;
    }

    if(pItem->phMapper)
    {
        if(pItem->hLocator)
        {
            SslCloseLocator(pItem->phMapper, pItem->hLocator);
            pItem->hLocator = 0;
        }
        SslDereferenceMapper(pItem->phMapper);
    }
    pItem->phMapper = NULL;

    if(pItem->pbServerCertificate)
    {
        SPExternalFree(pItem->pbServerCertificate);
        pItem->pbServerCertificate = NULL;
        pItem->cbServerCertificate = 0;
    }

    if(pItem->szCacheID)
    {
        SPExternalFree(pItem->szCacheID);
        pItem->szCacheID = NULL;
    }

    if(pItem->pClientCred)
    {
        SPDeleteCred(pItem->pClientCred);
        pItem->pClientCred = NULL;
    }

    if(pItem->pClientCert)
    {
        CertFreeCertificateContext(pItem->pClientCert);
        pItem->pClientCert = NULL;
    }

    if(pItem->pClonedItem)
    {
        SPCacheDereference(pItem->pClonedItem);
        pItem->pClonedItem = NULL;
    }

    if(pItem->pbAppData)
    {
        SPExternalFree(pItem->pbAppData);
        pItem->pbAppData = NULL;
    }

    SPExternalFree(pItem);

    return TRUE;
}


void
SPCachePurgeCredential(
    PSPCredentialGroup pCred)
{
    PSessCacheItem pItem;
    PLIST_ENTRY pList;
    DWORD i;
   

    //
    // Only server credentials are bound to the cache, so return if this is
    // a client credential.
    //

    if(pCred->grbitProtocol & SP_PROT_CLIENTS)
    {
        return;
    }


    //
    // Search through the cache entries looking for entries that are
    // bound to the specified server credential.
    //

    RtlAcquireResourceShared(&SchannelCache.Lock, TRUE);

    pList = SchannelCache.EntryList.Flink;

    while(pList != &SchannelCache.EntryList)
    {
        pItem = CONTAINING_RECORD(pList, SessCacheItem, EntryList.Flink);
        pList = pList->Flink;

        ASSERT(pItem->Magic == SP_CACHE_MAGIC);

        // Is this a server cache entry?
        if((pItem->fProtocol & SP_PROT_SERVERS) == 0)
        {
            continue;
        }

        // Does this item match the current credentials?
        if(!IsSameThumbprint(&pCred->CredThumbprint, &pItem->CredThumbprint))
        {
            continue;
        }

        // Mark this entry as non-resumable. This will cause the entry to 
        // be deleted automatically by the cleanup routines.
        pItem->ZombieJuju = FALSE;
        pItem->DeferredJuju = FALSE;
    }

    RtlReleaseResource(&SchannelCache.Lock);


    //
    // Delete all unused non-resumable cache entries.
    //

    CacheExpireElements(FALSE, FALSE);
}


void 
SPCachePurgeProcessId(
    ULONG ProcessId)
{
    PSessCacheItem pItem;
    PLIST_ENTRY pList;
    DWORD i;
   

    //
    // Search through the cache entries looking for entries that are
    // bound to the specified process.
    //

    RtlAcquireResourceShared(&SchannelCache.Lock, TRUE);

    pList = SchannelCache.EntryList.Flink;

    while(pList != &SchannelCache.EntryList)
    {
        pItem = CONTAINING_RECORD(pList, SessCacheItem, EntryList.Flink);
        pList = pList->Flink;

        ASSERT(pItem->Magic == SP_CACHE_MAGIC);

        // Does this item match the specified process?
        if(pItem->ProcessID != ProcessId)
        {
            continue;
        }

        // Mark the entry as ownerless.
        pItem->ProcessID = 0;

        // Mark this entry as non-resumable. This will cause the entry to 
        // be deleted automatically by the cleanup routines.
        pItem->ZombieJuju = FALSE;
        pItem->DeferredJuju = FALSE;
    }

    RtlReleaseResource(&SchannelCache.Lock);


    //
    // Delete all unused non-resumable cache entries.
    //

    CacheExpireElements(FALSE, FALSE);
}


BOOL 
IsSameTargetName(
    LPWSTR Name1,
    LPWSTR Name2)
{
    if(Name1 == Name2)
    {
        return TRUE;
    }

    if(Name1 == NULL || Name2 == NULL || wcscmp(Name1, Name2) != 0)
    {
        return FALSE;
    }

    return TRUE;
}

BOOL
DoesAppAllowCipher(
    PSPCredentialGroup  pCredGroup,
    PSessCacheItem      pItem)
{
    PKeyExchangeInfo pExchInfo;

    if(pCredGroup == NULL)
    {
        return FALSE;
    }

    //
    // Is protocol supported?
    //

    if((pItem->fProtocol & pCredGroup->grbitEnabledProtocols) == 0)
    {
        return FALSE;
    }

    //
    // Is cipher supported?
    //

    if(pItem->dwStrength < pCredGroup->dwMinStrength)
    {
        return FALSE;
    }

    if(pItem->dwStrength > pCredGroup->dwMaxStrength)
    {
        return FALSE;
    }

    if(!IsAlgAllowed(pCredGroup, pItem->aiCipher))
    {
        return FALSE;
    }


    //
    // Is hash supported?
    //

    if(!IsAlgAllowed(pCredGroup, pItem->aiHash))
    {
        return FALSE;
    }


    //
    // Is exchange alg supported?
    //

    if(pItem->SessExchSpec != SP_EXCH_UNKNOWN)
    {
        pExchInfo = GetKeyExchangeInfo(pItem->SessExchSpec);
        if(pExchInfo == NULL)
        {
            return FALSE;
        }

        if((pExchInfo->fProtocol & pItem->fProtocol) == 0)
        {
            return FALSE;
        }

        if(!IsAlgAllowed(pCredGroup, pExchInfo->aiExch))
        {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL SPCacheRetrieveBySession(
    struct _SPContext * pContext, 
    PBYTE pbSessionID,
    DWORD cbSessionID,
    PSessCacheItem *ppRetItem)
{
    DWORD index;
    DWORD timeNow;
    ULONG ProcessID;
    PSessCacheItem pItem;
    PLIST_ENTRY pList;
    BOOL fFound = FALSE;

    DebugLog((DEB_TRACE, "SPCacheRetrieveBySession (%x) called\n", pContext));

    if(ppRetItem == NULL)
    {
        return FALSE;
    }


    // 
    // Compute the cache index.
    //

    if(cbSessionID < sizeof(DWORD))
    {
        DebugLog((DEB_TRACE, "    FAILED\n"));
        return FALSE;
    }
    CopyMemory((PBYTE)&index, pbSessionID, sizeof(DWORD));

    if(index >= SchannelCache.dwCacheSize)
    {
        DebugLog((DEB_TRACE, "    FAILED\n"));
        return FALSE;
    }


    //
    // Retrieve the current time and application process id.
    // 

    timeNow = GetTickCount();

    SslGetClientProcess(&ProcessID);


    //
    // Lock the cache for read.
    //

    RtlAcquireResourceShared(&SchannelCache.Lock, TRUE);


    // 
    // Search through the cache entries at the computed index.
    // 

    pList = SchannelCache.SessionCache[index].Flink;

    while(pList != &SchannelCache.SessionCache[index])
    {
        pItem = CONTAINING_RECORD(pList, SessCacheItem, IndexEntryList.Flink);
        pList = pList->Flink ;

        ASSERT(pItem->Magic == SP_CACHE_MAGIC);

        // Is this entry resumable?
        if(!pItem->ZombieJuju)
        {
            continue;
        }

        // Has this item expired?
        if(HasTimeElapsed(pItem->CreationTime, timeNow, pItem->Lifespan))
        {
            continue;
        }

        // Does the session id match?
        if(cbSessionID != pItem->cbSessionID)
        {
            continue;
        }
        if(memcmp(pbSessionID, pItem->SessionID, cbSessionID) != 0)
        {
            continue;
        }

        // Is this item for the protocol we're using.
        if(0 == (pContext->dwProtocol & pItem->fProtocol))
        {
            continue;
        }

        // Does this item belong to our client process?
        if(pItem->ProcessID != ProcessID)
        {
            continue;
        }

        // Does this item match the current server credentials? 
        //
        // We don't allow different server credentials to share cache
        // entries, because if the credential that was used during
        // the original full handshake is deleted, then the cache
        // entry is unusable. Some server applications (I won't name names)
        // create a new credential for each connection, and we have to
        // guard against this.
        //
        // Note that this restriction may result in an extra full
        // handshake when IE accesses an IIS site enabled for certificate
        // mapping, mostly because IE's behavior is broken.
        if(!IsSameThumbprint(&pContext->pCredGroup->CredThumbprint, 
                             &pItem->CredThumbprint))
        {
            continue;
        }


        // Make sure that the application supports the cipher suite
        // used by this cache entry. This becomes important now that 
        // we're allowing different server credentials to share 
        // cache entries.
        if(!DoesAppAllowCipher(pContext->pCredGroup, pItem))
        {
            continue;
        }


        //
        // Found item in cache!!
        //

        fFound = TRUE;
        SPCacheReference(pItem);

        // Are we replacing something?
        // Then dereference the thing we are replacing.
        if(*ppRetItem)
        {
            SPCacheDereference(*ppRetItem);
        }

        // Return item referenced.
        *ppRetItem = pItem;
        break;
    }


    RtlReleaseResource(&SchannelCache.Lock);

    if(fFound)
    {
        DebugLog((DEB_TRACE, "    FOUND IT(%u)\n", index));
        InterlockedIncrement(&g_cServerReconnects);
    }
    else
    {
        DebugLog((DEB_TRACE, "    FAILED\n"));
    }

    return fFound;
}


DWORD
ComputeClientCacheIndex(
    LPWSTR pszTargetName)
{
    DWORD index;
    MD5_CTX Md5Hash;
    DWORD cbTargetName;

    if(pszTargetName == NULL)
    {
        index = 0;
    }
    else
    {
        cbTargetName = wcslen(pszTargetName) * sizeof(WCHAR);

        MD5Init(&Md5Hash);
        MD5Update(&Md5Hash, 
                  (PBYTE)pszTargetName, 
                  cbTargetName);
        MD5Final(&Md5Hash);
        CopyMemory((PBYTE)&index, 
                   Md5Hash.digest, 
                   sizeof(DWORD));

        index %= SchannelCache.dwCacheSize;
    }

    return index;
}


BOOL 
SPCacheRetrieveByName(
    LPWSTR pszTargetName,
    PSPCredentialGroup pCredGroup,
    PSessCacheItem *ppRetItem)
{
    DWORD index;
    PSessCacheItem pItem;
    PSessCacheItem pFoundEntry = NULL;
    DWORD timeNow;
    LUID LogonId;
    PLIST_ENTRY pList;
    PSPCredential pCurrentCred = NULL;

    DebugLog((DEB_TRACE, "SPCacheRetrieveByName (%ls) called\n", pszTargetName));

    if(ppRetItem == NULL)
    {
        return FALSE;
    }


    //
    // Retrieve the current time and user logon id.
    // 

    timeNow = GetTickCount();

    SslGetClientLogonId(&LogonId);


    // 
    // Compute the cache index.
    //

    index = ComputeClientCacheIndex(pszTargetName);


    //
    // Lock the cache for read.
    //

    RtlAcquireResourceShared(&SchannelCache.Lock, TRUE);


    // 
    // Search through the cache entries at the computed index.
    // 

    pList = SchannelCache.SessionCache[index].Flink;

    while(pList != &SchannelCache.SessionCache[index])
    {
        pItem = CONTAINING_RECORD(pList, SessCacheItem, IndexEntryList.Flink);
        pList = pList->Flink ;

        ASSERT(pItem->Magic == SP_CACHE_MAGIC);

        // Is this entry resumable?
        if(!pItem->ZombieJuju)
        {
            continue;
        }

        // Is this item for the protocol we're using?
        if(0 == (pCredGroup->grbitEnabledProtocols & pItem->fProtocol))
        {
            continue;
        }

        // Has this item expired?
        if(HasTimeElapsed(pItem->CreationTime, timeNow, pItem->Lifespan))
        {
            continue;
        }

        // Don't allow reconnects when Skipjack is used.
        if(pItem->aiCipher == CALG_SKIPJACK)
        {
            continue;
        }

        // Does this item belong to our client?
        if(!RtlEqualLuid(&pItem->LogonId, &LogonId))
        {
            continue;
        }

        // Does this item match our current credentials? 
        if(g_fMultipleProcessClientCache)
        {
            // If this cache entry has a client certificate associated with it 
            // and the passed in client credentials contain one or more certificates, 
            // then we need to make sure that they overlap.
            if(IsValidThumbprint(&pItem->CertThumbprint) && pCredGroup->pCredList != NULL)
            {
                if(!DoesCredThumbprintMatch(pCredGroup, &pItem->CertThumbprint))
                {
                    continue;
                }
            }
        }
        else
        {
            // Make sure the thumbprint of the credential group matches the
            // thumbprint of the cache entry.
            if(!IsSameThumbprint(&pCredGroup->CredThumbprint, 
                                 &pItem->CredThumbprint))
            {
                continue;
            }
        }


        if(!IsSameTargetName(pItem->szCacheID, pszTargetName))
        {
            continue;
        }

        // Make sure that the application supports the cipher suite
        // used by this cache entry. This becomes important in the 
        // multi-process client cache scenario, since different client
        // applications may be running with different settings.
        if(!DoesAppAllowCipher(pCredGroup, pItem))
        {
            continue;
        }

        
        //
        // Found item in cache!!
        //

        if(pFoundEntry == NULL)
        {
            // This is the first matching entry found.
            SPCacheReference(pItem);

            // Remember the current entry.
            pFoundEntry = pItem;
        }
        else
        {
            if(pItem->CreationTime > pFoundEntry->CreationTime)
            {
                // We found a newer entry.
                SPCacheReference(pItem);

                // Disable searching on the previous item.
                pFoundEntry->ZombieJuju = FALSE;

                // Release the previous item.
                SPCacheDereference(pFoundEntry);

                // Remember the current entry.
                pFoundEntry = pItem;
            }
            else
            {
                // This item is older than the previously found entry.

                // Disable searching on the current entry.
                pItem->ZombieJuju = FALSE;
            }
        }
    }

    RtlReleaseResource(&SchannelCache.Lock);

    if(pFoundEntry)
    {
        // Found item in cache!!

        // Are we replacing something?
        // Then dereference the thing we are replacing.
        if(*ppRetItem)
        {
            SPCacheDereference(*ppRetItem);
        }

        // Return item referenced.
        *ppRetItem = pFoundEntry;

        DebugLog((DEB_TRACE, "    FOUND IT(%u)\n", index));
        InterlockedIncrement(&g_cClientReconnects);
    }
    else
    {
        DebugLog((DEB_TRACE, "    FAILED\n"));
    }

    return (pFoundEntry != NULL);
}


BOOL
IsApplicationCertificateMapper(
    PHMAPPER phMapper)
{
    if(phMapper == NULL)
    {
        return FALSE;
    }

    if(phMapper->m_dwFlags & SCH_FLAG_SYSTEM_MAPPER)
    {
        return FALSE;
    }

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:   CacheExpireElements
//
//  Synopsis:   Traverse the session cache and remove all expired entries. 
//              If the cache is oversized, then expire some entries
//              early.
//
//  Arguments:  [fCleanupOnly]  --  If this is set, then attempt to delete
//                                  cache entries previously expired. Don't
//                                  traverse the cache.
//
//  History:    01-02-2000  jbanes  Created.
//
//  Notes:      This routine should be called only once every five or ten
//              minutes. 
//
//              The tricky bit is how to handle the case where the cache
//              entry belongs to IIS, and has an IIS certificate mapper
//              "locator" attached to it. In this case, we cannot destroy
//              the cache element unless the client process is IIS, because
//              we need to callback to IIS in order to destroy the locator.
//              In this case, we remove the element from the cache, and 
//              leave it laying around in a global "cache cleanup" list.
//              If this list gets too large, then this routine should be 
//              called frequently, with the "fCleanupOnly" parameter set
//              to TRUE.
//
//----------------------------------------------------------------------------
BOOL
CacheExpireElements(
    BOOL fCleanupOnly,
    BOOL fBackground)
{
    static ULONG    RefCount = 0;
    ULONG           LocalRefCount;
    DWORD           timeNow;
    ULONG           ProcessID;
    PSessCacheItem  pItem;
    PLIST_ENTRY     pList;
    DWORD           CleanupCount;
    ULONG           Count;

    // 
    // If another thread is currently expiring elements, then try again 
    // later. 
    //

    LocalRefCount = InterlockedIncrement(&RefCount);

    if(fBackground && LocalRefCount > 1)
    {
        InterlockedDecrement(&RefCount);
        return FALSE;
    }

    RtlEnterCriticalSection(&g_CacheCleanupLock);


    //
    // Retrieve the current time and application process id.
    // 

    timeNow = GetTickCount();

    SslGetClientProcess(&ProcessID);


    //
    // Search through the cache entries looking for expired entries.
    //

    if(!fCleanupOnly)
    {
        RtlAcquireResourceExclusive(&SchannelCache.Lock, TRUE);

        pList = SchannelCache.EntryList.Flink;

        while(pList != &SchannelCache.EntryList)
        {
            pItem = CONTAINING_RECORD(pList, SessCacheItem, EntryList.Flink);
            pList = pList->Flink;

            ASSERT(pItem->Magic == SP_CACHE_MAGIC);

            // Is the cache entry currently being used?
            if(pItem->cRef > 1)
            {
                continue;
            }

            // Mark all expired cache entries as non-resumable.
            if(HasTimeElapsed(pItem->CreationTime, timeNow, pItem->Lifespan))
            {
                pItem->ZombieJuju = FALSE;
                pItem->DeferredJuju = FALSE;
            }

            // If the cache has gotten too large, then expire elements early. The 
            // cache elements are sorted by creation time, so the oldest
            // entries will be expired first.
            if(SchannelCache.dwUsedEntries > SchannelCache.dwMaximumEntries)
            {
                pItem->ZombieJuju = FALSE;
                pItem->DeferredJuju = FALSE;
            }
                
            // Don't remove entries that are still valid.
            if(pItem->ZombieJuju == TRUE || pItem->DeferredJuju)
            {
                continue;
            }


            //
            // Remove this entry from the cache, and add it to the list of
            // entries to be destroyed.
            //

            RemoveEntryList(&pItem->IndexEntryList);
            RemoveEntryList(&pItem->EntryList);
            SchannelCache.dwUsedEntries--;

            InsertTailList(&g_CacheCleanupList, &pItem->EntryList);
        }

        RtlReleaseResource(&SchannelCache.Lock);
    }


    // 
    // Kill the expired zombies.
    //

    CleanupCount = 0;
    pList = g_CacheCleanupList.Flink;

    while(pList != &g_CacheCleanupList)
    {
        pItem = CONTAINING_RECORD(pList, SessCacheItem, EntryList.Flink);
        pList = pList->Flink;

        ASSERT(pItem->Magic == SP_CACHE_MAGIC);

        // Make sure that we only destroy server entries that belong to the
        // current application process. This is necessary because of the 
        // IIS certificate mapper.
        if(pItem->ProcessID != 0 && 
           pItem->ProcessID != ProcessID)
        {
            if(IsApplicationCertificateMapper(pItem->phMapper))
            {
                CleanupCount++;
                continue;
            }
        }

        // Remove entry from cleanup list.
        RemoveEntryList(&pItem->EntryList);

        // Destroy cache entry.
        SPCacheDelete(pItem);
    }

    g_CacheCleanupCount = CleanupCount;

    RtlLeaveCriticalSection(&g_CacheCleanupLock);

    InterlockedDecrement(&RefCount);

    return TRUE;
}


VOID 
CacheCleanupHandler(
    PVOID pVoid, 
    BOOLEAN fTimeout)
{
    if(SchannelCache.dwUsedEntries > 0)
    {
        if(fTimeout)
        {
            DebugLog((DEB_WARN, "Initiate periodic cache cleanup.\n"));
        }

        CacheExpireElements(FALSE, TRUE);

        ResetEvent(g_CacheCleanupEvent);
    }
}


/* allocate a new cache item to be used
 * by a context.  Initialize it with the
 * pszTarget if the target exists.
 * Auto-Generate a SessionID
 */
BOOL
SPCacheRetrieveNew(
    BOOL                fServer,
    LPWSTR              pszTargetName,
    PSessCacheItem *    ppRetItem)
{
    DWORD           index;
    DWORD           timeNow;
    ULONG           ProcessID;
    LUID            LogonId;
    PSessCacheItem pItem;
    BYTE            rgbSessionId[SP_MAX_SESSION_ID];

    DebugLog((DEB_TRACE, "SPCacheRetrieveNew called\n"));


    //
    // Trigger cache cleanup if too many cache entries already exist.
    //

    if(SchannelCache.dwUsedEntries > (SchannelCache.dwMaximumEntries * 21) / 20)
    {
        DebugLog((DEB_WARN, "Cache size (%d) exceeded threshold (%d), trigger cache cleanup.\n",
            SchannelCache.dwUsedEntries,
            SchannelCache.dwMaximumEntries));
        SetEvent(g_CacheCleanupEvent);
    }


    //
    // Perform cache garbage collection when the list of entries to be 
    // deleted grows too large.
    //

    if(fServer && g_CacheCleanupCount > 50)
    {
        DebugLog((DEB_WARN, "Attempt background cleanup of deleted zombies.\n"));

        CacheExpireElements(TRUE, TRUE);
    }


    //
    // Retrieve the current time and user logon id.
    // 

    timeNow = GetTickCount();

    SslGetClientProcess(&ProcessID);
    SslGetClientLogonId(&LogonId);


    // 
    // Compute the session id and the cache index.
    //

    if(fServer)
    {
        GenerateRandomBits(rgbSessionId, sizeof(rgbSessionId));
        index = *(DWORD *)rgbSessionId % SchannelCache.dwCacheSize;
        *(DWORD *)rgbSessionId = index;
    }
    else
    {
        ZeroMemory(rgbSessionId, sizeof(rgbSessionId));
        index = ComputeClientCacheIndex(pszTargetName);
    }

    //
    // Allocate a new cache entry.
    //

    pItem = SPExternalAlloc(sizeof(SessCacheItem));
    if(pItem == NULL)
    {
        SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        return FALSE;
    }

    
    //
    // Fill in the cache internal fields.
    //

    pItem->Magic           = SP_CACHE_MAGIC;
    pItem->cRef            = 1;

    pItem->CreationTime    = timeNow;
    if(fServer)
    {
        pItem->Lifespan    = SchannelCache.dwServerLifespan;
    }
    else
    {
        pItem->Lifespan    = SchannelCache.dwClientLifespan;
    }

    pItem->ProcessID       = ProcessID;
    pItem->LogonId         = LogonId;

#ifdef LOCK_MASTER_KEYS
    pItem->csMasterKey     = g_rgcsMasterKey + (index % SP_MASTER_KEY_CS_COUNT);
#endif

    if(pszTargetName)
    {
        pItem->szCacheID = SPExternalAlloc((wcslen(pszTargetName) + 1) * sizeof(WCHAR));
        if(pItem->szCacheID == NULL)
        {
            SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            SPExternalFree(pItem);
            return FALSE;
        }
        wcscpy(pItem->szCacheID, pszTargetName);
    }
    else
    {
        pItem->szCacheID = NULL;
    }

    memcpy(pItem->SessionID, rgbSessionId, sizeof(rgbSessionId));


    //
    // Give the caller a reference.
    //

    SPCacheReference(pItem);
    *ppRetItem = pItem;


    // 
    // Add the new entry to the cache.
    //

    RtlAcquireResourceExclusive(&SchannelCache.Lock, TRUE);

    InsertTailList(&SchannelCache.SessionCache[index], &pItem->IndexEntryList);
    InsertTailList(&SchannelCache.EntryList, &pItem->EntryList);
    SchannelCache.dwUsedEntries++;

    RtlReleaseResource(&SchannelCache.Lock);
    
    return TRUE;
}

 
BOOL 
SPCacheAdd(
    PSPContext pContext)
{
    PSessCacheItem     pItem;
    PSPCredentialGroup  pCred;
    DWORD               dwLifespan;
    DWORD               timeNow;

    timeNow =  GetTickCount();

    pItem = pContext->RipeZombie;
    if(!pItem) return FALSE;

    ASSERT(pItem->Magic == SP_CACHE_MAGIC);

    pCred = pContext->pCredGroup;
    if(!pCred) return FALSE;

    if(pItem->fProtocol & SP_PROT_CLIENTS)
    {
        dwLifespan = min(pCred->dwSessionLifespan, SchannelCache.dwClientLifespan);
    }
    else
    {
        dwLifespan = min(pCred->dwSessionLifespan, SchannelCache.dwServerLifespan);
    }   


    // Remember which client certificate we used.
    if(pItem->fProtocol & SP_PROT_CLIENTS)
    {
        pItem->CredThumbprint = pContext->pCredGroup->CredThumbprint;

        if(pContext->pActiveClientCred)
        {
            pItem->CertThumbprint = pContext->pActiveClientCred->CertThumbprint;
            pItem->pClientCert = CertDuplicateCertificateContext(pContext->pActiveClientCred->pCert);
            if(pItem->pClientCert == NULL)
            {
                SP_LOG_RESULT(GetLastError());
            }
        }
    }

    // Are we supposed to defer reconnects for this connection?
    if(pItem->pServerCred != NULL)
    {
        if(pItem->pServerCred->dwFlags & CRED_FLAG_DISABLE_RECONNECTS)
        {
            pItem->DeferredJuju = TRUE;
        }
    }

    // Allow cache ownership of this item
    pItem->dwFlags |= SP_CACHE_FLAG_READONLY;
    if(!pItem->DeferredJuju)
    {
        pItem->ZombieJuju = TRUE;
    }

    // if we are a cloned item, abort the old
    // item, and then dereference it.
    if(pItem->pClonedItem)
    {
        pItem->pClonedItem->ZombieJuju = FALSE;
        SPCacheDereference(pItem->pClonedItem);
        pItem->pClonedItem = NULL;
    }

    pItem->Lifespan = dwLifespan;

    return TRUE;
}

/* Allocate a new cache item, and copy 
 * over relevant information from old item,
 * and dereference old item.  This is a helper
 * for REDO
 */
BOOL
SPCacheClone(PSessCacheItem *ppItem)
{
    PSessCacheItem pNewItem;
    PSessCacheItem pOldItem;

    if(ppItem == NULL || *ppItem == NULL)
    {
        return FALSE;
    }
    pOldItem = *ppItem;

    ASSERT(pOldItem->Magic == SP_CACHE_MAGIC);
    ASSERT(!(pOldItem->fProtocol & SP_PROT_CLIENTS) || !(pOldItem->fProtocol & SP_PROT_SERVERS));

    // Get a fresh cache item.
    pNewItem = NULL;
    if(!SPCacheRetrieveNew((pOldItem->fProtocol & SP_PROT_CLIENTS) == 0,
                           pOldItem->szCacheID, 
                           &pNewItem))
    {
        return FALSE;
    }
    
    // Copy the master CSP prov handle.
    pNewItem->hMasterProv = pOldItem->hMasterProv;

    // Copy over old relevant data
    pNewItem->fProtocol         = pOldItem->fProtocol;
    pNewItem->dwCF              = pOldItem->dwCF;
    pNewItem->phMapper          = pOldItem->phMapper;
    pNewItem->pServerCred       = pOldItem->pServerCred;
    pNewItem->pActiveServerCred = pOldItem->pActiveServerCred;

    if(pOldItem->dwFlags & SP_CACHE_FLAG_MASTER_EPHEM)
    {
        pNewItem->dwFlags |= SP_CACHE_FLAG_MASTER_EPHEM;
    }

    pNewItem->CredThumbprint = pOldItem->CredThumbprint,

    // This item will be dereferenced, and 
    // Aborted when the new item is completed.
    pNewItem->pClonedItem = pOldItem;

    *ppItem = pNewItem;

    return TRUE;
}


NTSTATUS
SetCacheAppData(
    PSessCacheItem pItem,
    PBYTE pbAppData,
    DWORD cbAppData)
{
    RtlAcquireResourceExclusive(&SchannelCache.Lock, TRUE);

    if(pItem->pbAppData)
    {
        SPExternalFree(pItem->pbAppData);
    }

    pItem->pbAppData = pbAppData;
    pItem->cbAppData = cbAppData;

    RtlReleaseResource(&SchannelCache.Lock);

    return STATUS_SUCCESS;
}


NTSTATUS
GetCacheAppData(
    PSessCacheItem pItem,
    PBYTE *ppbAppData,
    DWORD *pcbAppData)
{
    if(pItem->pbAppData == NULL)
    {
        *ppbAppData = NULL;
        *pcbAppData = 0;
        return STATUS_SUCCESS;
    }

    RtlAcquireResourceShared(&SchannelCache.Lock, TRUE);

    *pcbAppData = pItem->cbAppData;
    *ppbAppData = SPExternalAlloc(pItem->cbAppData);
    if(*ppbAppData == NULL)
    {
        RtlReleaseResource(&SchannelCache.Lock);
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }

    memcpy(*ppbAppData, pItem->pbAppData, pItem->cbAppData);

    RtlReleaseResource(&SchannelCache.Lock);

    return STATUS_SUCCESS;
}


BOOL
IsEntryToBeProcessed(
    PSessCacheItem pItem,
    PLUID   LogonID,
    ULONG   ProcessID,
    LPWSTR  pszTargetName,
    DWORD   dwFlags)
{
    //
    // Validate client entries.
    //

    if(pItem->fProtocol & SP_PROT_CLIENTS)
    {
        if((dwFlags & SSL_PURGE_CLIENT_ENTRIES) == 0 &&
           (dwFlags & SSL_PURGE_CLIENT_ALL_ENTRIES) == 0)
        {
            return FALSE;
        }

        if((dwFlags & SSL_PURGE_CLIENT_ALL_ENTRIES) == 0)
        {
            if(!RtlEqualLuid(&pItem->LogonId, LogonID))
            {
                return FALSE;
            }
        }

        if(pszTargetName != NULL)
        {
            if(pItem->szCacheID == NULL || 
               wcscmp(pItem->szCacheID, pszTargetName) != 0)
            {
                return FALSE;
            }
        }

        return TRUE;
    }


    //
    // Validate server entries.
    //

    if(pItem->fProtocol & SP_PROT_SERVERS)
    {
        if((dwFlags & SSL_PURGE_SERVER_ENTRIES) == 0 &&
           (dwFlags & SSL_PURGE_SERVER_ALL_ENTRIES) == 0)
        {
            return FALSE;
        }

        if(ProcessID != pItem->ProcessID)
        {
            if((dwFlags & SSL_PURGE_SERVER_ALL_ENTRIES) == 0)
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}



NTSTATUS
SPCachePurgeEntries(
    LUID *LogonID,
    ULONG ProcessID,
    LPWSTR pszTargetName,
    DWORD dwFlags)
{
    PSessCacheItem pItem;
    PLIST_ENTRY pList;
    LIST_ENTRY DeleteList;

    DebugLog((DEB_TRACE, "Purge cache entries\n"));

    //
    // Initialize the list of deleted entries.
    //

    InitializeListHead(&DeleteList);


    //
    // Enumerate through the cache entries.
    //

    RtlAcquireResourceExclusive(&SchannelCache.Lock, TRUE);

    pList = SchannelCache.EntryList.Flink;

    while(pList != &SchannelCache.EntryList)
    {
        pItem = CONTAINING_RECORD(pList, SessCacheItem, EntryList.Flink);
        pList = pList->Flink;

        ASSERT(pItem->Magic == SP_CACHE_MAGIC);

        if(!IsEntryToBeProcessed(pItem,
                                 LogonID,
                                 ProcessID,
                                 pszTargetName,
                                 dwFlags))
        {
            continue;
        }

        if(pItem->cRef > 1)
        {
            // This entry is currently being used, so don't delete.
            // Mark it as non-resumable, though.
            pItem->ZombieJuju = FALSE;
            pItem->DeferredJuju = FALSE;
            continue;
        }

        if(pItem->ProcessID != 0 && 
           pItem->ProcessID != ProcessID)
        {
            if(IsApplicationCertificateMapper(pItem->phMapper))
            {
                // This entry has a mapper structure that doesn't belong
                // to the calling process, so don't delete. Mark it as
                // non-resumable, though.
                pItem->ZombieJuju = FALSE;
                pItem->DeferredJuju = FALSE;
                continue;
            }
        }


        //
        // Remove this entry from the cache, and add it to the list of
        // entries to be destroyed.
        //

        RemoveEntryList(&pItem->IndexEntryList);
        RemoveEntryList(&pItem->EntryList);
        SchannelCache.dwUsedEntries--;

        InsertTailList(&DeleteList, &pItem->EntryList);
    }

    RtlReleaseResource(&SchannelCache.Lock);


    // 
    // Kill the purged zombies.
    //

    pList = DeleteList.Flink;

    while(pList != &DeleteList)
    {
        pItem = CONTAINING_RECORD(pList, SessCacheItem, EntryList.Flink);
        pList = pList->Flink;

        ASSERT(pItem->Magic == SP_CACHE_MAGIC);

        SPCacheDelete(pItem);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
SPCacheGetInfo(
    LUID *  LogonID,
    LPWSTR  pszTargetName,
    DWORD   dwFlags,
    PSSL_SESSION_CACHE_INFO_RESPONSE pCacheInfo)
{
    PSessCacheItem pItem;
    PLIST_ENTRY pList;
    DWORD timeNow;
    ULONG ProcessID;

    pCacheInfo->CacheSize       = SchannelCache.dwMaximumEntries;
    pCacheInfo->Entries         = 0;
    pCacheInfo->ActiveEntries   = 0;
    pCacheInfo->Zombies         = 0;
    pCacheInfo->ExpiredZombies  = 0;
    pCacheInfo->AbortedZombies  = 0;
    pCacheInfo->DeletedZombies  = g_CacheCleanupCount;

    timeNow = GetTickCount();

    SslGetClientProcess(&ProcessID);


    RtlAcquireResourceExclusive(&SchannelCache.Lock, TRUE);

    pList = SchannelCache.EntryList.Flink;

    while(pList != &SchannelCache.EntryList)
    {
        pItem = CONTAINING_RECORD(pList, SessCacheItem, EntryList.Flink);
        pList = pList->Flink;

        ASSERT(pItem->Magic == SP_CACHE_MAGIC);

        if(pItem->fProtocol & SP_PROT_CLIENTS)
        {
            if((dwFlags & SSL_RETRIEVE_CLIENT_ENTRIES) == 0)
            {
                continue;
            }
        }
        else
        {
            if((dwFlags & SSL_RETRIEVE_SERVER_ENTRIES) == 0)
            {
                continue;
            }
        }

        pCacheInfo->Entries++;

        if(pItem->cRef == 1)
        {
            pCacheInfo->Zombies++;

            if(HasTimeElapsed(pItem->CreationTime, 
                              timeNow, 
                              pItem->Lifespan))
            {
                pCacheInfo->ExpiredZombies++;
            }
            if(pItem->ZombieJuju == FALSE)
            {
                pCacheInfo->AbortedZombies++;
            }
        }
        else
        {
            pCacheInfo->ActiveEntries++;
        }
    }

    RtlReleaseResource(&SchannelCache.Lock);

    return STATUS_SUCCESS;
}


NTSTATUS
SPCacheGetPerfmonInfo(
    DWORD   dwFlags,
    PSSL_PERFMON_INFO_RESPONSE pPerfmonInfo)
{
    PSessCacheItem pItem;
    PLIST_ENTRY pList;

    // 
    // Compute performance numbers.
    //

    pPerfmonInfo->ClientHandshakesPerSecond = g_cClientHandshakes;
    pPerfmonInfo->ServerHandshakesPerSecond = g_cServerHandshakes;
    pPerfmonInfo->ClientReconnectsPerSecond = g_cClientReconnects;
    pPerfmonInfo->ServerReconnectsPerSecond = g_cServerReconnects;


    //
    // Compute cache info.
    //

    pPerfmonInfo->ClientCacheEntries  = 0;
    pPerfmonInfo->ServerCacheEntries  = 0;
    pPerfmonInfo->ClientActiveEntries = 0;
    pPerfmonInfo->ServerActiveEntries = 0;

    RtlAcquireResourceShared(&SchannelCache.Lock, TRUE);

    pList = SchannelCache.EntryList.Flink;

    while(pList != &SchannelCache.EntryList)
    {
        pItem = CONTAINING_RECORD(pList, SessCacheItem, EntryList.Flink);
        pList = pList->Flink;

        ASSERT(pItem->Magic == SP_CACHE_MAGIC);


        if(pItem->fProtocol & SP_PROT_CLIENTS)
        {
            pPerfmonInfo->ClientCacheEntries++;

            if(pItem->cRef > 1)
            {
                pPerfmonInfo->ClientActiveEntries++;
            }
        }
        else
        {
            pPerfmonInfo->ServerCacheEntries++;

            if(pItem->cRef > 1)
            {
                pPerfmonInfo->ServerActiveEntries++;
            }
        }
    }

    RtlReleaseResource(&SchannelCache.Lock);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\spbase\certmap.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       certmap.c
//
//  Contents:   Routines to call appropriate mapper, be it the system
//              default one (in the LSA process) or an application one (in
//              the application process).
//
//  Classes:
//
//  Functions:
//
//  History:    12-23-96   jbanes   Created.
//
//----------------------------------------------------------------------------

#include <spbase.h>

DWORD
WINAPI
SslReferenceMapper(HMAPPER *phMapper)
{
    DWORD dwResult;
    SecBuffer Input;
    SecBuffer Output;
    SECURITY_STATUS scRet;

    if(phMapper == NULL)
    {
        return SP_LOG_RESULT(-1);
    }

    if(phMapper->m_dwFlags & SCH_FLAG_SYSTEM_MAPPER)
    {
        // System mapper.
        return phMapper->m_vtable->ReferenceMapper(phMapper);
    }
    else
    {
        // Application mapper.

        Input.BufferType = SECBUFFER_DATA;
        Input.cbBuffer   = 0;
        Input.pvBuffer   = NULL;

        scRet = PerformApplicationCallback( SCH_REFERENCE_MAPPER_CALLBACK,
                                            (ULONG_PTR)phMapper->m_Reserved1,
                                            TRUE,
                                            &Input,
                                            &Output,
                                            TRUE);
        if(!NT_SUCCESS(scRet))
        {
            DebugLog((DEB_ERROR, "Error 0x%x referencing mapper\n", scRet));
            return SP_LOG_RESULT(scRet);
        }

        SP_ASSERT(Output.cbBuffer == sizeof(DWORD));

        dwResult = *(PDWORD)(Output.pvBuffer);

        SPExternalFree(Output.pvBuffer);

        return dwResult;
    }
}

DWORD
WINAPI
SslDereferenceMapper(HMAPPER *phMapper)
{
    DWORD dwResult;
    SecBuffer Input;
    SecBuffer Output;
    SECURITY_STATUS scRet;

    if(phMapper == NULL)
    {
        return SP_LOG_RESULT(0);
    }

    if(phMapper->m_dwFlags & SCH_FLAG_SYSTEM_MAPPER)
    {
        // System mapper.
        return phMapper->m_vtable->DeReferenceMapper(phMapper);
    }
    else
    {
        // Application mapper.

        Input.BufferType = SECBUFFER_DATA;
        Input.cbBuffer   = 0;
        Input.pvBuffer   = NULL;

        scRet = PerformApplicationCallback( SCH_REFERENCE_MAPPER_CALLBACK,
                                            (ULONG_PTR)phMapper->m_Reserved1,
                                            FALSE,
                                            &Input,
                                            &Output,
                                            TRUE);
        if(!NT_SUCCESS(scRet))
        {
            DebugLog((DEB_ERROR, "Error 0x%x dereferencing mapper\n", scRet));
            return SP_LOG_RESULT(scRet);
        }

        SP_ASSERT(Output.cbBuffer == sizeof(DWORD));

        dwResult = *(PDWORD)(Output.pvBuffer);

        SPExternalFree(Output.pvBuffer);

        return dwResult;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ReferenceMapperCallback
//
//  Synopsis:   Reference (or dereference) the application mapper.
//
//  Arguments:  [fReference]    --  Whether to reference or dereference.
//              [dwArg2]        --  Not used.
//              [pInput]        --  HMAPPER structure.
//              [pOutput]       --  DWORD reference count.
//
//  History:    10-17-97   jbanes   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
ReferenceMapperCallback(
    ULONG_PTR Mapper,
    ULONG_PTR fReference,
    SecBuffer *pInput,
    SecBuffer *pOutput)
{
    DWORD dwResult;
    HMAPPER *phMapper;

    if(!SchannelInit(TRUE))
    {
        return SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
    }

    DebugLog((DEB_TRACE, "ReferenceMapperCallback\n"));

    phMapper = (HMAPPER *)Mapper;

    // Perform reference counting.
    try
    {
        if(fReference)
        {
            dwResult = phMapper->m_vtable->ReferenceMapper(phMapper);
        }
        else
        {
            dwResult = phMapper->m_vtable->DeReferenceMapper(phMapper);
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        return SP_LOG_RESULT(SEC_E_INVALID_HANDLE);
    }

    // Build output buffer
    pOutput->BufferType = SECBUFFER_DATA;
    pOutput->cbBuffer   = sizeof(DWORD);
    pOutput->pvBuffer   = PvExtVirtualAlloc(pOutput->cbBuffer);
    if(pOutput->pvBuffer == NULL)
    {
        return SEC_E_INSUFFICIENT_MEMORY;
    }

    *(DWORD *)(pOutput->pvBuffer) = dwResult;

    return SEC_E_OK;
}


SECURITY_STATUS
WINAPI
SslGetMapperIssuerList(
    HMAPPER *   phMapper,           // in
    BYTE **     ppIssuerList,       // out
    DWORD *     pcbIssuerList)      // out
{
    SecBuffer Input;
    SecBuffer Output;
    SECURITY_STATUS Status;

    if(phMapper == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
    }

    if(phMapper->m_dwFlags & SCH_FLAG_SYSTEM_MAPPER)
    {
        // System mapper.

        Status = phMapper->m_vtable->GetIssuerList(phMapper,
                                              0,
                                              NULL,
                                              pcbIssuerList);

        if(!NT_SUCCESS(Status))
        {
            return SP_LOG_RESULT(Status);
        }

        *ppIssuerList = SPExternalAlloc(*pcbIssuerList);
        if(*ppIssuerList == NULL)
        {
            return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        }

        Status = phMapper->m_vtable->GetIssuerList(phMapper,
                                              0,
                                              *ppIssuerList,
                                              pcbIssuerList);
        if(!NT_SUCCESS(Status))
        {
            SPExternalFree(*ppIssuerList);
            return SP_LOG_RESULT(Status);
        }

        return Status;
    }
    else
    {
        // Application mapper.

        Input.BufferType = SECBUFFER_DATA;
        Input.cbBuffer   = 0;
        Input.pvBuffer   = NULL;

        Status = PerformApplicationCallback( SCH_GET_MAPPER_ISSUER_LIST_CALLBACK,
                                            (ULONG_PTR)phMapper->m_Reserved1,
                                            0,
                                            &Input,
                                            &Output,
                                            TRUE);
        if(!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "Error 0x%x getting mapper issuer list\n", Status));

            *ppIssuerList  = NULL;
            *pcbIssuerList = 0;

            return Status;
        }

        *ppIssuerList  = Output.pvBuffer;
        *pcbIssuerList = Output.cbBuffer;

        return Status;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   GetMapperIssuerListCallback
//
//  Synopsis:   Query the application mapper for the list of trusted CAs.
//
//  Arguments:  [pIssuerList]   --  Pointer to LSA buffer.
//              [cbIssuerList]  --  Size of LSA buffer.
//              [pInput]        --  HMAPPER structure.
//              [pOutput]       --  Issuer list.
//
//  History:    10-17-97   jbanes   Created
//
//  Notes:      The format of the output buffer is as follows:
//
//              BYTE        rgbIssuerList;
//
//----------------------------------------------------------------------------
SECURITY_STATUS
GetMapperIssuerListCallback(
    ULONG_PTR Mapper,
    ULONG_PTR dwArg2,
    SecBuffer *pInput,
    SecBuffer *pOutput)
{
    HMAPPER *   phMapper;
    DWORD       cbIssuerList;
    DWORD       Status;

    if(!SchannelInit(TRUE))
    {
        return SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
    }

    DebugLog((DEB_TRACE, "GetMapperIssuerListCallback\n"));

    phMapper = (HMAPPER *)Mapper;

    pOutput->BufferType = SECBUFFER_DATA;
    pOutput->cbBuffer   = 0;
    pOutput->pvBuffer   = NULL;

    try
    {
        Status = phMapper->m_vtable->GetIssuerList(phMapper,
                                              NULL,
                                              NULL,
                                              &cbIssuerList);
        if(!NT_SUCCESS(Status))
        {
            SP_LOG_RESULT(Status);
            goto error;
        }

        pOutput->cbBuffer = cbIssuerList;
        pOutput->pvBuffer = PvExtVirtualAlloc(pOutput->cbBuffer);
        if(pOutput->pvBuffer == NULL)
        {
            Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            goto error;
        }

        Status = phMapper->m_vtable->GetIssuerList(phMapper,
                                              NULL,
                                              pOutput->pvBuffer,
                                              &cbIssuerList);
        if(!NT_SUCCESS(Status))
        {
            SP_LOG_RESULT(Status);
            goto error;
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
    	Status = SP_LOG_RESULT(SEC_E_INVALID_HANDLE);
        goto error;
    }

    return SEC_E_OK;

error:

    if(pOutput->pvBuffer)
    {
        FreeExtVirtualAlloc(pOutput->pvBuffer, pOutput->cbBuffer);
        pOutput->pvBuffer = NULL;
    }

    return Status;
}


SECURITY_STATUS
WINAPI
SslGetMapperChallenge(
    HMAPPER *   phMapper,           // in
    BYTE *      pAuthenticatorId,   // in
    DWORD       cbAuthenticatorId,  // in
    BYTE *      pChallenge,         // out
    DWORD *     pcbChallenge)       // out
{
    return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
}


SECURITY_STATUS
WINAPI
SslMapCredential(
    HMAPPER *   phMapper,           // in
    DWORD       dwCredentialType,   // in
    PCCERT_CONTEXT pCredential,     // in
    PCCERT_CONTEXT pAuthority,      // in
    HLOCATOR *  phLocator)          // out
{
    SecBuffer       Input;
    SecBuffer       Output;
    PBYTE           pbBuffer;
    DWORD           cbCredential;
    DWORD           cbAuthority;
    SECURITY_STATUS scRet;

    if(phMapper == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
    }

    if(phMapper->m_dwFlags & SCH_FLAG_SYSTEM_MAPPER)
    {
        // System mapper.
        scRet = phMapper->m_vtable->MapCredential(phMapper,
                                                 dwCredentialType,
                                                 pCredential,
                                                 pAuthority,
                                                 phLocator);
        return MapWinTrustError(scRet, SEC_E_NO_IMPERSONATION, 0);
    }
    else
    {
        // Application mapper.

        // Determine the size of the serialized cert contexts.
        scRet = SerializeCertContext(pCredential,
                                     NULL,
                                     &cbCredential);
        if(FAILED(scRet))
        {
            return SP_LOG_RESULT(scRet);
        }
        if(pAuthority)
        {
            if(!CertSerializeCertificateStoreElement(
                            pAuthority,
                            0, NULL,
                            &cbAuthority))
            {
                return SP_LOG_RESULT(GetLastError());
            }
        }
        else
        {
            cbAuthority = 0;
        }

        // Allocate memory for the input buffer.
        Input.BufferType = SECBUFFER_DATA;
        Input.cbBuffer   = sizeof(DWORD) + cbCredential +
                           sizeof(DWORD) + cbAuthority;
        Input.pvBuffer   = LocalAlloc(LMEM_FIXED, Input.cbBuffer);
        if(Input.pvBuffer == NULL)
        {
            return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        }

        // Build the input buffer.
        pbBuffer = Input.pvBuffer;

        *(PDWORD)pbBuffer = cbCredential;
        pbBuffer += sizeof(DWORD);

        *(PDWORD)pbBuffer = cbAuthority;
        pbBuffer += sizeof(DWORD);

        scRet = SerializeCertContext(pCredential,
                                     pbBuffer,
                                     &cbCredential);
        if(FAILED(scRet))
        {
            LocalFree(Input.pvBuffer);
            return SP_LOG_RESULT(scRet);
        }
        pbBuffer += cbCredential;

        if(pAuthority)
        {
            if(!CertSerializeCertificateStoreElement(
                            pAuthority,
                            0,
                            pbBuffer,
                            &cbAuthority))
            {
                scRet = SP_LOG_RESULT(GetLastError());
                LocalFree(Input.pvBuffer);
                return scRet;
            }
            pbBuffer += cbAuthority;
        }

        SP_ASSERT(pbBuffer - (PBYTE)Input.pvBuffer == (INT)Input.cbBuffer);


        scRet = PerformApplicationCallback( SCH_MAP_CREDENTIAL_CALLBACK,
                                            (ULONG_PTR)phMapper->m_Reserved1,
                                            dwCredentialType,
                                            &Input,
                                            &Output,
                                            TRUE);
        LocalFree(Input.pvBuffer);
        if(!NT_SUCCESS(scRet))
        {
            DebugLog((DEB_ERROR, "Error 0x%x mapping credential\n", scRet));
            return scRet;
        }

        SP_ASSERT(Output.cbBuffer == sizeof(HLOCATOR));
        CopyMemory(phLocator, Output.pvBuffer, sizeof(HLOCATOR));

        SPExternalFree(Output.pvBuffer);

        return SEC_E_OK;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   MapCredentialCallback
//
//  Synopsis:   Maps the specified certificate to an NT user account, via
//              an application-installed certificate mapper.
//
//  Arguments:  [dwCredentialType]  --  Credential type.
//              [dwArg2]            --  Not used.
//              [pInput]            --  See notes.
//              [pOutput]           --  Returned locator.
//
//  History:    12-29-97   jbanes   Created
//
//  Notes:      The format of the input buffer is:
//
//              DWORD           cbCredential;
//              DWORD           cbAuthority;
//              BYTE            rgbCredential[cbCredential];
//              BYTE            rgbAuthority[cbAuthority];
//
//              The credential and authority fields consist of serialized
//              CERT_CONTEXT structures.
//
//----------------------------------------------------------------------------
SECURITY_STATUS
MapCredentialCallback(
    ULONG_PTR Mapper,
    ULONG_PTR dwCredentialType,
    SecBuffer *pInput,
    SecBuffer *pOutput)
{
    HMAPPER *       phMapper;
    PCCERT_CONTEXT  pCredential = NULL;
    PCCERT_CONTEXT  pAuthority  = NULL;
    SECURITY_STATUS scRet;
    DWORD           cbCredential;
    DWORD           cbAuthority;
    PBYTE           pbBuffer;
    HLOCATOR        hLocator;


    if(!SchannelInit(TRUE))
    {
        return SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
    }

    DebugLog((DEB_TRACE, "MapCredentialCallback\n"));

    phMapper = (HMAPPER *)Mapper;


    // Initialize output buffer.
    pOutput->BufferType = SECBUFFER_DATA;
    pOutput->cbBuffer   = 0;
    pOutput->pvBuffer   = NULL;


    //
    // Parse input buffer
    //

    pbBuffer = pInput->pvBuffer;

    if(pInput->cbBuffer < sizeof(DWORD) * 2)
    {
        scRet = SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
        goto done;
    }

    cbCredential = *(PDWORD)pbBuffer;
    pbBuffer += sizeof(DWORD);

    cbAuthority = *(PDWORD)pbBuffer;
    pbBuffer += sizeof(DWORD);

    if(pInput->cbBuffer < sizeof(DWORD) * 2 + cbCredential + cbAuthority)
    {
        scRet = SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
        goto done;
    }

    // Deserialize "credential" certificate context.
    scRet = DeserializeCertContext(&pCredential,
                                   pbBuffer,
                                   cbCredential);
    if(FAILED(scRet))
    {
        scRet = SP_LOG_RESULT(scRet);
        goto done;
    }
    pbBuffer += cbCredential;

    // Deserialize "authority" certificate context.
    if(cbAuthority && pCredential->hCertStore)
    {
        if(!CertAddSerializedElementToStore(pCredential->hCertStore,
                                            pbBuffer + sizeof(DWORD),
                                            *(DWORD *)pbBuffer,
                                            CERT_STORE_ADD_USE_EXISTING,
                                            0,
                                            CERT_STORE_CERTIFICATE_CONTEXT_FLAG,
                                            NULL,
                                            &pAuthority))
        {
            scRet = SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
            goto done;
        }
    }


    //
    // Call application mapper.
    //

    try
    {
        scRet = phMapper->m_vtable->MapCredential(phMapper,
                                              (DWORD)dwCredentialType,
                                              pCredential,
                                              pAuthority,
                                              &hLocator);
        if(!NT_SUCCESS(scRet))
        {
            // Mapping was unsuccessful.
            scRet = MapWinTrustError(scRet, SEC_E_NO_IMPERSONATION, 0);
            goto done;
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        return SP_LOG_RESULT(SEC_E_INVALID_HANDLE);
    }


    //
    // Build output buffer
    //

    pOutput->BufferType = SECBUFFER_DATA;
    pOutput->cbBuffer   = sizeof(HLOCATOR);
    pOutput->pvBuffer   = PvExtVirtualAlloc(pOutput->cbBuffer);
    if(pOutput->pvBuffer == NULL)
    {
        scRet = SEC_E_INSUFFICIENT_MEMORY;
        goto done;
    }

    *(HLOCATOR *)(pOutput->pvBuffer) = hLocator;

    scRet = SEC_E_OK;


done:

    if(pCredential)
    {
        CertFreeCertificateContext(pCredential);
    }
    if(pAuthority)
    {
        CertFreeCertificateContext(pAuthority);
    }

    return scRet;
}


SECURITY_STATUS
WINAPI
SslCloseLocator(
    HMAPPER *   phMapper,           // in
    HLOCATOR    hLocator)           // in
{
    SecBuffer Input;
    SecBuffer Output;
    SECURITY_STATUS scRet;

    if(phMapper == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
    }

    if(phMapper->m_dwFlags & SCH_FLAG_SYSTEM_MAPPER)
    {
        // System mapper.
        return phMapper->m_vtable->CloseLocator(phMapper,
                                                hLocator);
    }
    else
    {
        // Application mapper.

        Input.BufferType = SECBUFFER_DATA;
        Input.cbBuffer   = 0;
        Input.pvBuffer   = NULL;

        scRet = PerformApplicationCallback( SCH_CLOSE_LOCATOR_CALLBACK,
                                            (ULONG_PTR)phMapper->m_Reserved1,
                                            (ULONG_PTR)hLocator,
                                            &Input,
                                            &Output,
                                            FALSE);
        if(!NT_SUCCESS(scRet))
        {
            DebugLog((DEB_ERROR, "Error 0x%x closing locator\n", scRet));
            return scRet;
        }

        SP_ASSERT(Output.cbBuffer == 0);

        return scRet;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CloseLocatorCallback
//
//  Synopsis:   Reference (or dereference) the application mapper.
//
//  Arguments:  [hLocator]  --  Handle to locator.
//              [dwArg2]    --  Not used.
//              [pInput]    --  HMAPPER structure.
//              [pOutput]   --  Not used.
//
//  History:    12-28-97   jbanes   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
CloseLocatorCallback(
    ULONG_PTR Mapper,
    ULONG_PTR hLocator,
    SecBuffer *pInput,
    SecBuffer *pOutput)
{
    HMAPPER *phMapper;
    SECURITY_STATUS Status;

    if(!SchannelInit(TRUE))
    {
        return SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
    }

    DebugLog((DEB_TRACE, "CloseLocatorCallback\n"));

    phMapper = (HMAPPER *)Mapper;

    // Close the locator.
    try
    {
        Status = phMapper->m_vtable->CloseLocator(phMapper, hLocator);
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        return SP_LOG_RESULT(SEC_E_INVALID_HANDLE);
    }

    // Build output buffer
    pOutput->BufferType = SECBUFFER_DATA;
    pOutput->cbBuffer   = 0;
    pOutput->pvBuffer   = NULL;

    return Status;
}

SECURITY_STATUS
WINAPI
SslQueryMappedCredentialAttributes(
    HMAPPER *   phMapper,           // in
    HLOCATOR    hLocator,           // in
    DWORD       dwAttribute,        // in
    PVOID *     ppBuffer)           // out
{
    SecBuffer Input;
    SecBuffer Output;
    SECURITY_STATUS scRet;

    if(phMapper == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INVALID_HANDLE);
    }

    if(phMapper->m_dwFlags & SCH_FLAG_SYSTEM_MAPPER)
    {
        // System mapper.
        return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
    }
    else
    {
        // Application mapper.

        Input.BufferType = SECBUFFER_DATA;
        Input.cbBuffer   = sizeof(DWORD);
        Input.pvBuffer   = &dwAttribute;

        scRet = PerformApplicationCallback( SCH_GET_MAPPER_ATTRIBUTES_CALLBACK,
                                            (ULONG_PTR)phMapper->m_Reserved1,
                                            hLocator,
                                            &Input,
                                            &Output,
                                            TRUE);
        if(!NT_SUCCESS(scRet))
        {
            DebugLog((DEB_ERROR, "Error 0x%x querying mapped attribute.\n", scRet));
            return scRet;
        }

        if(Output.cbBuffer != sizeof(PVOID))
        {
            SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
        }

        *ppBuffer = *(PVOID *)Output.pvBuffer;

        SPExternalFree(Output.pvBuffer); //this is allocated by SPExternalAlloc()

        return SEC_E_OK;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   QueryMappedCredAttributesCallback
//
//  Synopsis:   Queries the application mapper for the specified property.
//
//  Arguments:  [hLocator]      --  Handle to locator.
//              [dwAttribute]   --  Attribute to query.
//              [pInput]        --  HMAPPER structure.
//              [pOutput]       --  Pointer to attribute data (in the
//                                  application's address space).
//
//  History:    03-16-98   jbanes   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
QueryMappedCredAttributesCallback(
    ULONG_PTR Mapper,
    ULONG_PTR hLocator,
    SecBuffer *pInput,
    SecBuffer *pOutput)
{
    HMAPPER *   phMapper;
    DWORD       dwAttribute;
    PVOID       pvBuffer;
    DWORD       cbBuffer;
    DWORD       Status;

    if(!SchannelInit(TRUE))
    {
        return SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
    }

    DebugLog((DEB_TRACE, "QueryMappedCredAttributesCallback\n"));

    phMapper = (HMAPPER *)Mapper;

    // Parse input buffer
    SP_ASSERT(pInput->cbBuffer == sizeof(DWORD));
    dwAttribute = *(DWORD *)pInput->pvBuffer;

    // Query propery.
    try
    {
        // Determine buffer size.
        Status = phMapper->m_vtable->QueryMappedCredentialAttributes(
                                    phMapper,
                                    hLocator,
                                    dwAttribute,
                                    NULL,
                                    &cbBuffer);
        if(FAILED(Status))
        {
            return SP_LOG_RESULT(Status);
        }

        // Allocate memory. This gets freed by the APPLICATION with FreeSecurityBuffer() call
        // SPExternalAlloc() for the above reason!!!!

        pvBuffer = SPExternalAlloc(cbBuffer);
        if(pvBuffer == NULL)
        {
            return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        }

        // Read propery.
        Status = phMapper->m_vtable->QueryMappedCredentialAttributes(
                                    phMapper,
                                    hLocator,
                                    dwAttribute,
                                    pvBuffer,
                                    &cbBuffer);
        if(FAILED(Status))
        {
            SPExternalFree(pvBuffer);
            return SP_LOG_RESULT(Status);
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        return SP_LOG_RESULT(SEC_E_INVALID_HANDLE);
    }

    // Build output buffer
    pOutput->BufferType = SECBUFFER_DATA;
    pOutput->cbBuffer   = sizeof(PVOID);
    pOutput->pvBuffer   = PvExtVirtualAlloc(pOutput->cbBuffer);
    if(pOutput->pvBuffer == NULL)
    {
        SPExternalFree(pvBuffer);
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }

    *(PVOID *)(pOutput->pvBuffer) = pvBuffer;

    return SEC_E_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\spbase\cred.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cred.c
//
//  Contents:   Schannel credential management routines.
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   LSA integration stuff.
//              03-15-99   jbanes   Remove dead code, fix legacy SGC.
//
//----------------------------------------------------------------------------

#include <spbase.h>
#include <wincrypt.h>
#include <oidenc.h>
#include <mapper.h>
#include <userenv.h>


RTL_CRITICAL_SECTION g_SslCredLock;
LIST_ENTRY          g_SslCredList;
HANDLE              g_GPEvent;

SP_STATUS
GetPrivateFromCert(
    PSPCredential pCred, 
    DWORD dwProtocol,
    PLSA_SCHANNEL_SUB_CRED pSubCred);


BOOL
SslInitCredentialManager(VOID)
{
    BOOL fImpersonating = FALSE;
    NTSTATUS Status;

    Status = RtlInitializeCriticalSection( &g_SslCredLock );
    if (!NT_SUCCESS(Status))
    {
        return FALSE;
    }

    InitializeListHead( &g_SslCredList );

    fImpersonating = SslImpersonateClient();

    g_GPEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if(g_GPEvent)
    {
        if(!RegisterGPNotification(g_GPEvent, FALSE))
        {
            DebugLog((DEB_ERROR, "Error 0x%x registering for user GP notification\n", GetLastError()));
        }
        if(!RegisterGPNotification(g_GPEvent, TRUE))
        {
            DebugLog((DEB_ERROR, "Error 0x%x registering for machine GP notification\n", GetLastError()));
        }
    }

    if(fImpersonating)
    {
        RevertToSelf();
    }

    return( TRUE );
}


BOOL
SslFreeCredentialManager(VOID)
{
    BOOL fImpersonating = FALSE;

    fImpersonating = SslImpersonateClient();

    if(g_GPEvent)
    {
        if(!UnregisterGPNotification(g_GPEvent))
        {
            DebugLog((DEB_ERROR, "Error 0x%x unregistering for user GP notification\n", GetLastError()));
        }
        if(!UnregisterGPNotification(g_GPEvent))
        {
            DebugLog((DEB_ERROR, "Error 0x%x unregistering for machine GP notification\n", GetLastError()));
        }

        CloseHandle(g_GPEvent);
        g_GPEvent = NULL;
    }

    if(fImpersonating)
    {
        RevertToSelf();
    }

    RtlDeleteCriticalSection( &g_SslCredLock );

    return TRUE;
}


BOOL
SslCheckForGPEvent(void)
{
    PLIST_ENTRY pList;
    PSPCredentialGroup pCredGroup;
    DWORD Status;

    if(g_GPEvent)
    {
        Status = WaitForSingleObjectEx(g_GPEvent, 0, FALSE);
        if(Status == WAIT_OBJECT_0)
        {
            DebugLog((DEB_WARN, "GP event detected, so download new trusted issuer list\n"));

            RtlEnterCriticalSection( &g_SslCredLock );

            pList = g_SslCredList.Flink ;

            while ( pList != &g_SslCredList )
            {
                pCredGroup = CONTAINING_RECORD( pList, SPCredentialGroup, ListEntry.Flink );

                pCredGroup->dwFlags |= CRED_FLAG_UPDATE_ISSUER_LIST;

                pList = pList->Flink ;
            }

            RtlLeaveCriticalSection( &g_SslCredLock );

            return TRUE;
        }
    }

    return FALSE;
}


SP_STATUS
IsCredentialInGroup(
    PSPCredentialGroup  pCredGroup, 
    PCCERT_CONTEXT      pCertContext,
    PBOOL               pfInGroup)
{
    PSPCredential   pCred;
    BYTE            rgbThumbprint[20];
    DWORD           cbThumbprint;
    BYTE            rgbHash[20];
    DWORD           cbHash;
    DWORD           i;

    *pfInGroup = FALSE;

    // Get thumbprint of certificate.
    cbThumbprint = sizeof(rgbThumbprint);
    if(!CertGetCertificateContextProperty(pCertContext,
                                          CERT_MD5_HASH_PROP_ID,
                                          rgbThumbprint,
                                          &cbThumbprint))
    {
        SP_LOG_RESULT(GetLastError());
        return PCT_INT_UNKNOWN_CREDENTIAL;
    }

    for(i = 0; i < pCredGroup->cCredList; i++)
    {
        pCred = pCredGroup->pCredList + i;

        // Get thumbprint of certificate.
        cbHash = sizeof(rgbHash);
        if(!CertGetCertificateContextProperty(pCred->pCert,
                                              CERT_MD5_HASH_PROP_ID,
                                              rgbHash,
                                              &cbHash))
        {
            SP_LOG_RESULT(GetLastError());
            return PCT_INT_UNKNOWN_CREDENTIAL;
        }

        if(memcmp(rgbThumbprint, rgbHash, cbThumbprint) == 0)
        {
            *pfInGroup = TRUE;
            break;
        }
    }

    return PCT_ERR_OK;
}

BOOL
IsValidThumbprint(
    PCRED_THUMBPRINT Thumbprint)
{
    if(Thumbprint->LowPart == 0 && Thumbprint->HighPart == 0)
    {
        return FALSE;
    }

    return TRUE;
}

BOOL
IsSameThumbprint(
    PCRED_THUMBPRINT Thumbprint1,
    PCRED_THUMBPRINT Thumbprint2)
{
    if(Thumbprint1->LowPart  == Thumbprint2->LowPart && 
       Thumbprint1->HighPart == Thumbprint2->HighPart)
    {
        return TRUE;
    }

    return FALSE;
}

void
GenerateCertThumbprint(
    PCCERT_CONTEXT pCertContext,
    PCRED_THUMBPRINT Thumbprint)
{
    MD5_CTX Md5Hash;

    MD5Init(&Md5Hash);
    MD5Update(&Md5Hash, 
              pCertContext->pbCertEncoded, 
              pCertContext->cbCertEncoded);
    MD5Final(&Md5Hash);
    CopyMemory((PBYTE)Thumbprint, 
               Md5Hash.digest, 
               sizeof(CRED_THUMBPRINT));
}

void
GenerateRandomThumbprint(
    PCRED_THUMBPRINT Thumbprint)
{
    GenerateRandomBits((PBYTE)Thumbprint, sizeof(CRED_THUMBPRINT));
}

BOOL
DoesCredThumbprintMatch(
    PSPCredentialGroup pCredGroup,
    PCRED_THUMBPRINT pThumbprint)
{
    PSPCredential pCurrentCred;
    BOOL fFound = FALSE;
    DWORD i;

    for(i = 0; i < pCredGroup->cCredList; i++)
    {
        pCurrentCred = pCredGroup->pCredList + i;

        if(IsSameThumbprint(pThumbprint, &pCurrentCred->CertThumbprint))
        { 
            fFound = TRUE;
            break;
        }
    }

    return fFound;
}

SP_STATUS
SPCreateCred(
    DWORD           dwProtocol,
    PLSA_SCHANNEL_SUB_CRED pSubCred,
    PSPCredential   pCurrentCred,
    BOOL *          pfEventLogged)
{
    SP_STATUS pctRet;

    pCurrentCred->pCert = CertDuplicateCertificateContext(pSubCred->pCert);
    if(pCurrentCred->pCert == NULL)
    {
        pctRet = SP_LOG_RESULT(SEC_E_CERT_UNKNOWN);
        goto error;
    }

    pctRet = SPPublicKeyFromCert(pCurrentCred->pCert,
                                 &pCurrentCred->pPublicKey,
                                 &pCurrentCred->dwExchSpec);
    if(pctRet != PCT_ERR_OK)
    {
        goto error;
    }

    pctRet = GetPrivateFromCert(pCurrentCred, dwProtocol, pSubCred);
    if(pctRet != PCT_ERR_OK)
    {
        *pfEventLogged = TRUE;
        goto error;
    }

    pCurrentCred->dwCF = CF_EXPORT;

    if(SslGlobalStrongEncryptionPermitted)
    {
        pCurrentCred->dwCF |= CF_DOMESTIC;
    }


    // Generate the credential thumbprint. This is computed by
    // taking the hash of the certificate.
    GenerateCertThumbprint(pCurrentCred->pCert, 
                           &pCurrentCred->CertThumbprint);

    DebugLog((DEB_TRACE, "Credential thumbprint: %x %x\n", 
        pCurrentCred->CertThumbprint.LowPart,
        pCurrentCred->CertThumbprint.HighPart));


    // Read list of supported algorithms.
    if((dwProtocol & SP_PROT_SERVERS) && pCurrentCred->hProv)
    {
        GetSupportedCapiAlgs(pCurrentCred->hProv,
                             pCurrentCred->dwCapiFlags,
                             &pCurrentCred->pCapiAlgs,
                             &pCurrentCred->cCapiAlgs);
    }


    // Build SSL3 serialized certificate chain. This is an optimization
    // so that we won't have to build it for each connection.
    pctRet = SPSerializeCertificate(
                            SP_PROT_SSL3,
                            TRUE,
                            &pCurrentCred->pbSsl3SerializedChain,
                            &pCurrentCred->cbSsl3SerializedChain,
                            pCurrentCred->pCert,
                            CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL);
    if(pctRet != PCT_ERR_OK)
    {
        goto error;
    }

error:

    return pctRet;
}


SP_STATUS
SPCreateCredential(
   PSPCredentialGroup *ppCred,
   DWORD grbitProtocol,
   PLSA_SCHANNEL_CRED pSchannelCred)
{
    PSPCredentialGroup pCred = NULL;
    PSPCredential pCurrentCred = NULL;
    SECPKG_CALL_INFO CallInfo;

    SP_STATUS   pctRet = PCT_ERR_OK;
    DWORD       i;
    DWORD       dwKeySpec;
    HMAPPER *   pMapper;
    BOOL        fSelectiveCrypto;
    NTSTATUS    Status;
    BOOL        fImpersonating = FALSE;
    BOOL        fEventLogged = FALSE;

    SP_BEGIN("SPCreateCredential");

    DebugLog((DEB_TRACE, "  dwVersion:              %d\n",   pSchannelCred->dwVersion));
    DebugLog((DEB_TRACE, "  cCreds:                 %d\n",   pSchannelCred->cSubCreds));
    DebugLog((DEB_TRACE, "  paCred:                 0x%p\n", pSchannelCred->paSubCred));
    DebugLog((DEB_TRACE, "  hRootStore:             0x%p\n", pSchannelCred->hRootStore));
    DebugLog((DEB_TRACE, "  cMappers:               %d\n",   pSchannelCred->cMappers));
    DebugLog((DEB_TRACE, "  aphMappers:             0x%p\n", pSchannelCred->aphMappers));
    DebugLog((DEB_TRACE, "  cSupportedAlgs:         %d\n",   pSchannelCred->cSupportedAlgs));
    DebugLog((DEB_TRACE, "  palgSupportedAlgs:      0x%p\n", pSchannelCred->palgSupportedAlgs));
    DebugLog((DEB_TRACE, "  grbitEnabledProtocols:  0x%x\n", pSchannelCred->grbitEnabledProtocols));
    DebugLog((DEB_TRACE, "  dwMinimumCipherStrength:%d\n",   pSchannelCred->dwMinimumCipherStrength));
    DebugLog((DEB_TRACE, "  dwMaximumCipherStrength:%d\n",   pSchannelCred->dwMaximumCipherStrength));
    DebugLog((DEB_TRACE, "  dwSessionLifespan:      %d\n",   pSchannelCred->dwSessionLifespan));
    DebugLog((DEB_TRACE, "  dwFlags:                0x%x\n", pSchannelCred->dwFlags));
    DebugLog((DEB_TRACE, "  reserved:               0x%x\n", pSchannelCred->reserved));

    LogCreateCredEvent(grbitProtocol, pSchannelCred);


    //
    // Allocate the internal credential structure and perform
    // basic initialization.
    //

    pCred = SPExternalAlloc(sizeof(SPCredentialGroup));
    if(pCred == NULL)
    {
        SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
    }

    DebugLog((DEB_TRACE, "New cred:%p, Protocol:%x\n", pCred, grbitProtocol));


    pCred->Magic = PCT_CRED_MAGIC;
    pCred->grbitProtocol = grbitProtocol;

    Status = RtlInitializeCriticalSection(&pCred->csLock);
    if (!NT_SUCCESS(Status))
    {
        pctRet = SEC_E_NO_CREDENTIALS;
        goto error;
    }

    pCred->RefCount = 0;
    pCred->cMappers = 0;
    pCred->pahMappers = NULL;
    pCred->dwFlags = 0;
    pCred->pCredList = NULL;

    GenerateRandomThumbprint(&pCred->CredThumbprint);

    if((grbitProtocol & SP_PROT_SERVERS) && (pSchannelCred->cSubCreds == 0))
    {
        pctRet = SP_LOG_RESULT(SEC_E_NO_CREDENTIALS);
        goto error;
    }

    if(LsaTable->GetCallInfo(&CallInfo))
    {
        pCred->ProcessId = CallInfo.ProcessId;
    }


    //
    // Walk through and initialize all certs and keys.
    //

    if(pSchannelCred->cSubCreds)
    {
        pCred->pCredList = SPExternalAlloc(pSchannelCred->cSubCreds * sizeof(SPCredential));
        if(pCred->pCredList == NULL)
        {
            pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            goto error;
        }
        pCred->cCredList = pSchannelCred->cSubCreds;

        for(i = 0; i < pSchannelCred->cSubCreds; i++)
        {
            pCurrentCred = pCred->pCredList + i;

            pctRet = SPCreateCred(grbitProtocol,
                                  pSchannelCred->paSubCred + i,
                                  pCurrentCred,
                                  &fEventLogged);
            if(pctRet != PCT_ERR_OK)
            {
                goto error;
            }
        }
    }


    //
    // Determine which protocols are to be supported.
    //

    if(pSchannelCred->grbitEnabledProtocols == 0)
    {
        pCred->grbitEnabledProtocols = g_ProtEnabled;

        if(g_PctClientDisabledByDefault)
        {
            pCred->grbitEnabledProtocols &= ~SP_PROT_PCT1_CLIENT; 
        }
        if(g_Ssl2ClientDisabledByDefault)
        {
            pCred->grbitEnabledProtocols &= ~SP_PROT_SSL2_CLIENT; 
        }
    }
    else
    {
        pCred->grbitEnabledProtocols = pSchannelCred->grbitEnabledProtocols & g_ProtEnabled;
    }

    // Force credential to client-only or server only.
    if(grbitProtocol & SP_PROT_SERVERS)
    {
        pCred->grbitEnabledProtocols &= SP_PROT_SERVERS;
    }
    else
    {
        pCred->grbitEnabledProtocols &= SP_PROT_CLIENTS;
    }


    //
    // Propagate flags from SCHANNEL_CRED structure.
    //

    if(pSchannelCred->dwFlags & SCH_CRED_NO_SYSTEM_MAPPER)
    {
        pCred->dwFlags |= CRED_FLAG_NO_SYSTEM_MAPPER;
    }
    if(pSchannelCred->dwFlags & SCH_CRED_NO_SERVERNAME_CHECK)
    {
        pCred->dwFlags |= CRED_FLAG_NO_SERVERNAME_CHECK;
    }
    if(pSchannelCred->dwFlags & SCH_CRED_MANUAL_CRED_VALIDATION)
    {
        pCred->dwFlags |= CRED_FLAG_MANUAL_CRED_VALIDATION;
    }
    if(pSchannelCred->dwFlags & SCH_CRED_NO_DEFAULT_CREDS)
    {
        pCred->dwFlags |= CRED_FLAG_NO_DEFAULT_CREDS;
    }
    if(pSchannelCred->dwFlags & SCH_CRED_AUTO_CRED_VALIDATION)
    {
        // Automatically validate server credentials.
        pCred->dwFlags &= ~CRED_FLAG_MANUAL_CRED_VALIDATION;
    }
    if(pSchannelCred->dwFlags & SCH_CRED_USE_DEFAULT_CREDS)
    {
        // Use default client credentials.
        pCred->dwFlags &= ~CRED_FLAG_NO_DEFAULT_CREDS;
    }
    if(pSchannelCred->dwFlags & SCH_CRED_DISABLE_RECONNECTS)
    {
        // Disable reconnects.
        pCred->dwFlags |= CRED_FLAG_DISABLE_RECONNECTS;
    }

    // set revocation flags
    if(pSchannelCred->dwFlags & SCH_CRED_REVOCATION_CHECK_END_CERT)
        pCred->dwFlags |= CRED_FLAG_REVCHECK_END_CERT;
    if(pSchannelCred->dwFlags & SCH_CRED_REVOCATION_CHECK_CHAIN)
        pCred->dwFlags |= CRED_FLAG_REVCHECK_CHAIN;
    if(pSchannelCred->dwFlags & SCH_CRED_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT)
        pCred->dwFlags |= CRED_FLAG_REVCHECK_CHAIN_EXCLUDE_ROOT;
    if(pSchannelCred->dwFlags & SCH_CRED_IGNORE_NO_REVOCATION_CHECK)
        pCred->dwFlags |= CRED_FLAG_IGNORE_NO_REVOCATION_CHECK;
    if(pSchannelCred->dwFlags & SCH_CRED_IGNORE_REVOCATION_OFFLINE)
        pCred->dwFlags |= CRED_FLAG_IGNORE_REVOCATION_OFFLINE;


    // set up the min and max strength
    GetBaseCipherSizes(&pCred->dwMinStrength, &pCred->dwMaxStrength);

    if(pSchannelCred->dwMinimumCipherStrength == 0)
    {
        pCred->dwMinStrength = max(40, pCred->dwMinStrength);
    }
    else if(pSchannelCred->dwMinimumCipherStrength == (DWORD)(-1))
    {
        // Turn on NULL cipher.
        pCred->dwMinStrength = 0;
    }
    else
    {
        pCred->dwMinStrength = pSchannelCred->dwMinimumCipherStrength;
    }

    if(pSchannelCred->dwMaximumCipherStrength == (DWORD)(-1))
    {
        // NULL cipher only.
        pCred->dwMaxStrength = 0;
    }
    else if(pSchannelCred->dwMaximumCipherStrength != 0)
    {
        pCred->dwMaxStrength = pSchannelCred->dwMaximumCipherStrength;
    }

    // set up the allowed ciphers
    BuildAlgList(pCred, pSchannelCred->palgSupportedAlgs, pSchannelCred->cSupportedAlgs);


    //
    // Set up all of the applications mappers and add in the default mapper.
    //

    pCred->cMappers = pSchannelCred->cMappers + 1;
    pCred->pahMappers = SPExternalAlloc(pCred->cMappers * sizeof(HMAPPER *));
    if(pCred->pahMappers == NULL)
    {
        pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto error;
    }

    // Make system certificate mapper the first mapper in the list.
    pCred->pahMappers[0] = SslGetMapper(TRUE);

    if(pCred->dwFlags & CRED_FLAG_REVCHECK_END_CERT) 
        pCred->pahMappers[0]->m_dwFlags |= SCH_FLAG_REVCHECK_END_CERT;
    if(pCred->dwFlags & CRED_FLAG_REVCHECK_CHAIN)
        pCred->pahMappers[0]->m_dwFlags |= SCH_FLAG_REVCHECK_CHAIN;
    if(pCred->dwFlags & CRED_FLAG_REVCHECK_CHAIN_EXCLUDE_ROOT)
        pCred->pahMappers[0]->m_dwFlags |= SCH_FLAG_REVCHECK_CHAIN_EXCLUDE_ROOT;
    if(pCred->dwFlags & CRED_FLAG_IGNORE_NO_REVOCATION_CHECK)
        pCred->pahMappers[0]->m_dwFlags |= SCH_FLAG_IGNORE_NO_REVOCATION_CHECK;
    if(pCred->dwFlags & CRED_FLAG_IGNORE_REVOCATION_OFFLINE)
        pCred->pahMappers[0]->m_dwFlags |= SCH_FLAG_IGNORE_REVOCATION_OFFLINE;

    SslReferenceMapper(pCred->pahMappers[0]);

    for(i = 0; i < pSchannelCred->cMappers; i++)
    {
        pCred->pahMappers[i + 1] = pSchannelCred->aphMappers[i];
        pSchannelCred->aphMappers[i] = NULL;

        SslReferenceMapper(pCred->pahMappers[i + 1]);
    }
    

    // set up timeouts.
    if(pSchannelCred->dwSessionLifespan == 0)
    {
        if(grbitProtocol & SP_PROT_CLIENTS) 
        {
            pCred->dwSessionLifespan = SchannelCache.dwClientLifespan;
        }
        else
        {
            pCred->dwSessionLifespan = SchannelCache.dwServerLifespan;
        }
    }
    else if(pSchannelCred->dwSessionLifespan == (DWORD)(-1))
    {
        pCred->dwSessionLifespan = 0;
    }
    else
    {
        pCred->dwSessionLifespan = pSchannelCred->dwSessionLifespan;
    }


    //
    // Add credential to global list of credentials.
    //

    RtlEnterCriticalSection( &g_SslCredLock );
    InsertTailList( &g_SslCredList, &pCred->ListEntry );
    RtlLeaveCriticalSection( &g_SslCredLock );


    //
    // Get list of trusted issuers.
    //

    if(grbitProtocol & SP_PROT_SERVERS)
    {
        if(pSchannelCred->hRootStore)
        {
            pCred->hApplicationRoots = CertDuplicateStore(pSchannelCred->hRootStore);
            if(!pCred->hApplicationRoots)
            {
                DebugLog((DEB_ERROR, "Error 0x%x duplicating app root store\n", GetLastError()));
            }
        }

        fImpersonating = SslImpersonateClient();

        pCred->hUserRoots = CertOpenSystemStore(0, "ROOT");
        if(!pCred->hUserRoots)
        {
            DebugLog((DEB_ERROR, "Error 0x%x opening user root store\n", GetLastError()));
        }
        else
        {
            if(!CertControlStore(pCred->hUserRoots,
                0,
                CERT_STORE_CTRL_NOTIFY_CHANGE,
                &g_GPEvent))
            {
                DebugLog((DEB_ERROR, "Error 0x%x registering user root change notification\n", GetLastError()));
            }
        }

        if(fImpersonating)
        {
            RevertToSelf();
            fImpersonating = FALSE;
        }
    }


    SPReferenceCredential(pCred);

    *ppCred = pCred;

    SP_RETURN(PCT_ERR_OK);


error:

    if(fEventLogged == FALSE)
    {
        LogCreateCredFailedEvent(grbitProtocol);
    }

    // Error case, free the credential
    if(pCred)
    {
        SPDeleteCredential(pCred);
    }

    SP_RETURN(pctRet);
}


BOOL
SPDeleteCredential(
    PSPCredentialGroup  pCred)
{
    DWORD i;

    SP_BEGIN("SPDeleteCredential");

    if(pCred == NULL)
    {
        SP_RETURN(TRUE);
    }

    if(pCred->Magic != PCT_CRED_MAGIC)
    {
        DebugLog((SP_LOG_ERROR, "Attempting to delete invalid credential!\n"));
        SP_RETURN (FALSE);
    }

    LockCredential(pCred);

    if(pCred->pCredList)
    {
        for(i = 0; i < pCred->cCredList; i++)
        {
            SPDeleteCred(pCred->pCredList + i);
        }
        SPExternalFree(pCred->pCredList);
        pCred->pCredList = NULL;
        pCred->cCredList = 0;
    }

    if(pCred->cMappers && pCred->pahMappers)
    {
        for(i=0; i < (DWORD)pCred->cMappers; i++)
        {
            SslDereferenceMapper(pCred->pahMappers[i]);
        }
        SPExternalFree(pCred->pahMappers);
    }


    if(pCred->palgSupportedAlgs)
    {
        SPExternalFree(pCred->palgSupportedAlgs);
    }
    pCred->Magic = PCT_INVALID_MAGIC;

    if(pCred->ListEntry.Flink)
    {
        RtlEnterCriticalSection( &g_SslCredLock );
        RemoveEntryList( &pCred->ListEntry );
        RtlLeaveCriticalSection( &g_SslCredLock );
    }

    if(pCred->pbTrustedIssuers)
    {
        // LocalFree is used for the issuer list because realloc 
        // is used when building the list and the LSA doesn't 
        // provide a realloc helper function.
        LocalFree(pCred->pbTrustedIssuers);
    }

    if(pCred->hApplicationRoots)
    {
        CertCloseStore(pCred->hApplicationRoots, 0);
    }

    if(pCred->hUserRoots)
    {
        BOOL fImpersonating = SslImpersonateClient();
        CertCloseStore(pCred->hUserRoots, 0);
        if(fImpersonating) RevertToSelf();
    }

    UnlockCredential(pCred);

    RtlDeleteCriticalSection(&pCred->csLock);

    ZeroMemory(pCred, sizeof(SPCredentialGroup));
    SPExternalFree(pCred);

    SP_RETURN(TRUE);
}

void
SPDeleteCred(PSPCredential pCred)
{
    BOOL fImpersonating = FALSE;

    if(pCred == NULL)
    {
        return;
    }

    if(pCred->pPublicKey)
    {
        SPExternalFree(pCred->pPublicKey);
        pCred->pPublicKey = NULL;
    }
    if(pCred->pCert)
    {
        CertFreeCertificateContext(pCred->pCert);
        pCred->pCert = NULL;
    }

    if(pCred->hTek)
    {
        if(!CryptDestroyKey(pCred->hTek))
        {
            SP_LOG_RESULT(GetLastError());
        }
        pCred->hTek = 0;
    }

    if(pCred->hProv)
    {
        fImpersonating = SslImpersonateClient();

        if(!SchCryptReleaseContext(
                            pCred->hProv,
                            0,
                            pCred->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
        }
        pCred->hProv = 0;

        if(fImpersonating)
        {
            RevertToSelf();
            fImpersonating = FALSE;
        }
    }
    if(pCred->pCapiAlgs)
    {
        SPExternalFree(pCred->pCapiAlgs);
        pCred->pCapiAlgs = NULL;
    }
    if(pCred->hRemoteProv && !pCred->fAppRemoteProv)
    {
        if(!RemoteCryptReleaseContext(
                            pCred->hRemoteProv,
                            0,
                            pCred->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
        }
        pCred->hRemoteProv = 0;
    }
    if(pCred->hEphem512Prov)
    {
        if(!SchCryptReleaseContext(pCred->hEphem512Prov, 
                                   0,
                                   pCred->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
        }
        pCred->hEphem512Prov = 0;
    }

    if(pCred->pbSsl3SerializedChain)
    {
        SPExternalFree(pCred->pbSsl3SerializedChain);
    }
}

// Reference a credential.
// Note: This should only be called by someone who already
// has a reference to the credential, or by the CreateCredential
// call.

BOOL
SPReferenceCredential(
    PSPCredentialGroup  pCred)
{
    BOOL fRet = FALSE;

    fRet =  (InterlockedIncrement(&pCred->RefCount) > 0);

    DebugLog((SP_LOG_TRACE, "Reference Cred %lx: %d\n", pCred, pCred->RefCount));

    return fRet;
}


BOOL
SPDereferenceCredential(
    PSPCredentialGroup  pCred)
{
    LONG    Ref;
    BOOL fRet = FALSE;

    if(pCred == NULL)
    {
        return FALSE;
    }
    if(pCred->Magic != PCT_CRED_MAGIC)
    {
        DebugLog((SP_LOG_ERROR, "Attempting to dereference invalid credential!\n"));
        return FALSE;
    }

    fRet = TRUE;

    DebugLog((SP_LOG_TRACE, "Dereference Cred %lx: %d\n", pCred, pCred->RefCount-1));

    if(0 ==  InterlockedDecrement(&pCred->RefCount))
    {
        fRet = SPDeleteCredential(pCred);
    } 

    return fRet;
}


SECURITY_STATUS
UpdateCredentialFormat(
    PSCH_CRED           pSchCred,       // in
    PLSA_SCHANNEL_CRED  pSchannelCred)  // out
{
    DWORD       dwVersion;
    DWORD       dwType;
    SP_STATUS   pctRet;
    DWORD       i;
    PBYTE       pbChain;
    DWORD       cbChain;
    PSCH_CRED_PUBLIC_CERTCHAIN pCertChain;
    CRYPT_DATA_BLOB DataBlob;

    SP_BEGIN("UpdateCredentialFormat");

    //
    // Initialize the output structure to null credential.
    //

    if(pSchannelCred == NULL)
    {
        SP_RETURN(SP_LOG_RESULT(SEC_E_INTERNAL_ERROR));
    }

    memset(pSchannelCred, 0, sizeof(LSA_SCHANNEL_CRED));
    pSchannelCred->dwVersion = SCHANNEL_CRED_VERSION;


    //
    // If input buffer is empty then we're done.
    //

    if(pSchCred == NULL)
    {
        SP_RETURN(SEC_E_OK);
    }


    //
    // Copy over the mapper fields.
    //

    pSchannelCred->cMappers     = pSchCred->cMappers;
    pSchannelCred->aphMappers   = pSchCred->aphMappers;


    //
    // Convert the certificates and private keys.
    //

    if(pSchCred->cCreds == 0)
    {
        SP_RETURN(SEC_E_OK);
    }


    pSchannelCred->cSubCreds = pSchCred->cCreds;

    pSchannelCred->paSubCred = SPExternalAlloc(sizeof(LSA_SCHANNEL_SUB_CRED) * pSchannelCred->cSubCreds);
    if(pSchannelCred->paSubCred == NULL)
    {
        pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto error;
    }

    // Loop through each of the creds, and convert them into something we know
    for(i = 0; i < pSchannelCred->cSubCreds; i++)
    {
        PLSA_SCHANNEL_SUB_CRED pSubCred = pSchannelCred->paSubCred + i;

        //
        // Decode the certificate.
        //

        dwType = *(PDWORD)pSchCred->paPublic[i];

        if(dwType != SCH_CRED_X509_CERTCHAIN)
        {
            pctRet = SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
            goto error;
        }

        pCertChain = (PSCH_CRED_PUBLIC_CERTCHAIN)pSchCred->paPublic[i];

        pbChain = pCertChain->pCertChain;
        cbChain = pCertChain->cbCertChain;

        // Decode the credential
        pctRet = SPLoadCertificate(0,
                                   X509_ASN_ENCODING,
                                   pbChain,
                                   cbChain,
                                   &pSubCred->pCert);
        if(pctRet != PCT_ERR_OK)
        {
            pctRet = SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
            goto error;
        }


        //
        // Now deal with the private key.
        //

        dwType = *(DWORD *)pSchCred->paSecret[i];

        if(dwType == SCHANNEL_SECRET_PRIVKEY)
        {
            PUCHAR pPrivateKeySave;
            PSCH_CRED_SECRET_PRIVKEY pPrivKey;
            DWORD Size;

            pPrivKey = (PSCH_CRED_SECRET_PRIVKEY)pSchCred->paSecret[i];

            pSubCred->pPrivateKey  = SPExternalAlloc(pPrivKey->cbPrivateKey);
            if(pSubCred->pPrivateKey == NULL)
            {
                pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
                goto error;
            }
            memcpy(pSubCred->pPrivateKey, pPrivKey->pPrivateKey, pPrivKey->cbPrivateKey);
            pSubCred->cbPrivateKey = pPrivKey->cbPrivateKey;

            Size = strlen(pPrivKey->pszPassword) + sizeof(CHAR);
            pSubCred->pszPassword = SPExternalAlloc(Size);
            if(pSubCred->pszPassword == NULL)
            {
                pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
                goto error;
            }
            memcpy(pSubCred->pszPassword, pPrivKey->pszPassword, Size);

            break;
        }

        else if(dwType == SCHANNEL_SECRET_TYPE_CAPI)
        {
            PSCH_CRED_SECRET_CAPI pCapiKey;

            pCapiKey = (PSCH_CRED_SECRET_CAPI)pSchCred->paSecret[i];

            pSubCred->hRemoteProv = pCapiKey->hProv;
            break;
        }

        else
        {
            pctRet = SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
            goto error;
        }
    }

    SP_RETURN(SEC_E_OK);

error:

    if(pSchannelCred->paSubCred)
    {
        SPExternalFree((PVOID)pSchannelCred->paSubCred);
        pSchannelCred->paSubCred = NULL;
    }

    SP_RETURN(pctRet);
}


SP_STATUS
GetIisPrivateFromCert(
    PSPCredential pCred,
    PLSA_SCHANNEL_SUB_CRED pSubCred)
{
    PBYTE pbPrivate = NULL;
    DWORD cbPrivate;
    PBYTE pbPassword = NULL;
    DWORD cbPassword;

    PPRIVATE_KEY_FILE_ENCODE pPrivateFile = NULL;
    DWORD                    cbPrivateFile;

    BLOBHEADER *pPrivateBlob = NULL;
    DWORD       cbPrivateBlob;
    HCRYPTKEY   hPrivateKey;
    PKeyExchangeInfo pExchInfo;
    HCRYPTPROV  hProv = 0;
    SP_STATUS   pctRet;

    MD5_CTX md5Ctx;
    struct RC4_KEYSTRUCT rc4Key;
    DWORD i;

    if(pSubCred->cbPrivateKey == 0 || 
       pSubCred->pPrivateKey == NULL ||
       pSubCred->pszPassword == NULL)
    {
        return SP_LOG_RESULT(SEC_E_NO_CREDENTIALS);
    }
       
    pbPrivate = pSubCred->pPrivateKey;
    cbPrivate = pSubCred->cbPrivateKey;

    pbPassword = pSubCred->pszPassword;
    cbPassword = strlen(pbPassword);


    // We have to do a little fixup here.  Old versions of
    // schannel wrote the wrong header data into the ASN
    // for private key files, so we must fix the size data.
    pbPrivate[2] = MSBOF(cbPrivate - 4);
    pbPrivate[3] = LSBOF(cbPrivate - 4);


    // ASN.1 decode the private key.
    if(!CryptDecodeObject(X509_ASN_ENCODING,
                          szPrivateKeyFileEncode,
                          pbPrivate,
                          cbPrivate,
                          0,
                          NULL,
                          &cbPrivateFile))
    {
        DebugLog((SP_LOG_ERROR, "Error 0x%x decoding the private key\n",
            GetLastError()));
        pctRet = SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
        goto error;
    }

    pPrivateFile = SPExternalAlloc(cbPrivateFile);
    if(pPrivateFile == NULL)
    {
        pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto error;
    }

    if(!CryptDecodeObject(X509_ASN_ENCODING,
                          szPrivateKeyFileEncode,
                          pbPrivate,
                          cbPrivate,
                          0,
                          pPrivateFile,
                          &cbPrivateFile))
    {
        DebugLog((SP_LOG_ERROR, "Error 0x%x decoding the private key\n",
            GetLastError()));
        pctRet = SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
        goto error;
    }


    // Decrypt the decoded private key using the password.
    MD5Init(&md5Ctx);
    MD5Update(&md5Ctx, pbPassword, cbPassword);
    MD5Final(&md5Ctx);

    rc4_key(&rc4Key, 16, md5Ctx.digest);

    rc4(&rc4Key,
        pPrivateFile->EncryptedBlob.cbData,
        pPrivateFile->EncryptedBlob.pbData);

    // Build a PRIVATEKEYBLOB from the decrypted private key.
    if(!CryptDecodeObject(X509_ASN_ENCODING,
                  szPrivateKeyInfoEncode,
                  pPrivateFile->EncryptedBlob.pbData,
                  pPrivateFile->EncryptedBlob.cbData,
                  0,
                  NULL,
                  &cbPrivateBlob))
    {
        // Maybe this was a SGC style key.
        // Re-encrypt it, and build the SGC decrypting
        // key, and re-decrypt it.
        BYTE md5Digest[MD5DIGESTLEN];

        rc4_key(&rc4Key, 16, md5Ctx.digest);
        rc4(&rc4Key,
            pPrivateFile->EncryptedBlob.cbData,
            pPrivateFile->EncryptedBlob.pbData);
        CopyMemory(md5Digest, md5Ctx.digest, MD5DIGESTLEN);

        MD5Init(&md5Ctx);
        MD5Update(&md5Ctx, md5Digest, MD5DIGESTLEN);
        MD5Update(&md5Ctx, SGC_KEY_SALT, lstrlen(SGC_KEY_SALT));
        MD5Final(&md5Ctx);
        rc4_key(&rc4Key, 16, md5Ctx.digest);
        rc4(&rc4Key,
            pPrivateFile->EncryptedBlob.cbData,
            pPrivateFile->EncryptedBlob.pbData);

        // Try again...
        if(!CryptDecodeObject(X509_ASN_ENCODING,
                      szPrivateKeyInfoEncode,
                      pPrivateFile->EncryptedBlob.pbData,
                      pPrivateFile->EncryptedBlob.cbData,
                      0,
                      NULL,
                      &cbPrivateBlob))
        {
            DebugLog((SP_LOG_ERROR, "Error 0x%x building PRIVATEKEYBLOB\n",
                GetLastError()));
            ZeroMemory(&md5Ctx, sizeof(md5Ctx));
            pctRet =  SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
            goto error;
        }
    }
    ZeroMemory(&md5Ctx, sizeof(md5Ctx));


    pPrivateBlob = SPExternalAlloc(cbPrivateBlob);
    if(pPrivateBlob == NULL)
    {
        pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto error;
    }

    if(!CryptDecodeObject(X509_ASN_ENCODING,
                      szPrivateKeyInfoEncode,
                      pPrivateFile->EncryptedBlob.pbData,
                      pPrivateFile->EncryptedBlob.cbData,
                      0,
                      pPrivateBlob,
                      &cbPrivateBlob))
    {
        DebugLog((SP_LOG_ERROR, "Error 0x%x building PRIVATEKEYBLOB\n",
            GetLastError()));
        pctRet = SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
        goto error;
    }

    // HACKHACK - Make sure that the key contained within the private
    // key blob is marked for "key exchange".
    pPrivateBlob->aiKeyAlg = CALG_RSA_KEYX;

    // Create an in-memory key container.
    if(!CryptAcquireContext(&hProv,
                            NULL,
                            NULL,
                            PROV_RSA_SCHANNEL,
                            CRYPT_VERIFYCONTEXT))
    {
        DebugLog((SP_LOG_ERROR, "Couldn't Acquire RSA Provider %lx\n", GetLastError()));
        pctRet = SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
        goto error;
    }

    // Import the private key blob into the key container.
    if(!CryptImportKey(hProv,
                       (PBYTE)pPrivateBlob,
                       cbPrivateBlob,
                       0, 0,
                       &hPrivateKey))
    {
        DebugLog((SP_LOG_ERROR, "Error 0x%x importing PRIVATEKEYBLOB\n",
            GetLastError()));
        pctRet = SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
        goto error;
    }
    CryptDestroyKey(hPrivateKey);

    // Obtain a matching CSP handle in the application process.
    pctRet = RemoteCryptAcquireContextW(
                                    &pCred->hRemoteProv,
                                    NULL,
                                    NULL,
                                    PROV_RSA_SCHANNEL,
                                    CRYPT_VERIFYCONTEXT,
                                    SCH_CAPI_USE_CSP);
    if(!NT_SUCCESS(pctRet))
    {
        pCred->hRemoteProv = 0;
        SP_LOG_RESULT(pctRet);
        goto error;
    }

    pCred->hProv       = hProv;
    pCred->dwKeySpec   = AT_KEYEXCHANGE;
    pCred->dwCapiFlags = SCH_CAPI_USE_CSP;

    pctRet = PCT_ERR_OK;


error:
    if(pPrivateFile)    SPExternalFree(pPrivateFile);
    if(pPrivateBlob)    SPExternalFree(pPrivateBlob);

    return pctRet;
}

SP_STATUS
LocalCryptAcquireContext(
    HCRYPTPROV *         phProv,
    PCRYPT_KEY_PROV_INFO pProvInfo,
    DWORD                dwProtocol,
    BOOL *               pfEventLogged)
{
    BOOL fImpersonating = FALSE;
    BOOL fSuccess;
    SP_STATUS Status;
    HCRYPTPROV hProv;

    // If the private key belongs to one of the Microsoft PROV_RSA_FULL
    // CSPs, then manually divert it to the Microsoft PROV_RSA_SCHANNEL
    // CSP. This works because both CSP types use the same private key
    // storage scheme.
    if(pProvInfo->dwProvType == PROV_RSA_FULL)
    {
        if(lstrcmpW(pProvInfo->pwszProvName, MS_DEF_PROV_W) == 0 ||
           lstrcmpW(pProvInfo->pwszProvName, MS_STRONG_PROV_W) == 0 ||
           lstrcmpW(pProvInfo->pwszProvName, MS_ENHANCED_PROV_W) == 0)
        {
            DebugLog((DEB_WARN, "Force CSP type to PROV_RSA_SCHANNEL.\n"));
            pProvInfo->pwszProvName = MS_DEF_RSA_SCHANNEL_PROV_W;
            pProvInfo->dwProvType   = PROV_RSA_SCHANNEL;
        }
    }

    if(pProvInfo->dwProvType != PROV_RSA_SCHANNEL && 
       pProvInfo->dwProvType != PROV_DH_SCHANNEL)
    {
        DebugLog((SP_LOG_ERROR, "Bad server CSP type:%d\n", pProvInfo->dwProvType));
        return SP_LOG_RESULT(PCT_ERR_UNKNOWN_CREDENTIAL);
    }

    fImpersonating = SslImpersonateClient();

    fSuccess = CryptAcquireContextW(&hProv,
                                    pProvInfo->pwszContainerName,
                                    pProvInfo->pwszProvName,
                                    pProvInfo->dwProvType,
                                    pProvInfo->dwFlags | CRYPT_SILENT);
    if(fImpersonating)
    {
        RevertToSelf();
        fImpersonating = FALSE;
    }

    if(!fSuccess)
    {
        Status = GetLastError();
        DebugLog((SP_LOG_ERROR, "Error 0x%x calling CryptAcquireContextW\n", Status));
        LogCredAcquireContextFailedEvent(dwProtocol, Status);
        *pfEventLogged = TRUE;

        return SP_LOG_RESULT(PCT_ERR_UNKNOWN_CREDENTIAL);
    }


    DebugLog((SP_LOG_TRACE, "Local CSP handle acquired (0x%p)\n", hProv));

    *phProv = hProv;

    return PCT_ERR_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:   GetPrivateFromCert
//
//  Synopsis:   Given a certificate context, somehow obtain a handle to the
//              corresponding key container. Determine the key spec of the
//              private key.
//
//  Arguments:  [pCred]         --  Pointer to the credential.
//
//  History:    09-24-96   jbanes   Hacked for LSA integration.
//
//  Notes:      The private key often lives in a CSP. In this case, a handle
//              to the CSP context is obtained by either reading the
//              CERT_KEY_REMOTE_PROV_HANDLE_PROP_ID property, or by reading
//              the CERT_KEY_PROV_INFO_PROP_ID property and then calling
//              CryptAcquireContext.
//
//              If this fails, then check and see if the private key is
//              stored by IIS. If this is the case, then the encrypted
//              private key is obtained by reading the
//
//----------------------------------------------------------------------------
SP_STATUS
GetPrivateFromCert(
    PSPCredential pCred, 
    DWORD dwProtocol,
    PLSA_SCHANNEL_SUB_CRED pSubCred)
{
    PCRYPT_KEY_PROV_INFO pProvInfo = NULL;
    HCRYPTPROV  hProv;
    DWORD       cbSize;
    BOOL        fRemoteProvider = FALSE;
    NTSTATUS    Status;
    BOOL        fEventLogged = FALSE;


    //
    // Set the output fields to default values.
    //

    pCred->hProv        = 0;
    pCred->hRemoteProv  = 0;
    pCred->dwCapiFlags  = SCH_CAPI_USE_CSP;
    pCred->dwKeySpec    = AT_KEYEXCHANGE;


    if(dwProtocol & SP_PROT_CLIENTS)
    {
        // Access the CSP from the application process.
        fRemoteProvider = TRUE;
    }


    //
    // Check to see if the application called CryptAcquireContext. If so then
    // we don't have to. This will typically not be the case.
    //

    if(fRemoteProvider && pSubCred->hRemoteProv)
    { 
        DebugLog((SP_LOG_TRACE, "Application provided CSP handle (0x%p)\n", pSubCred->hRemoteProv));
        pCred->hRemoteProv    = pSubCred->hRemoteProv;
        pCred->fAppRemoteProv = TRUE;
    }


    //
    // Read the certificate context's "key info" property.
    //

    if(CertGetCertificateContextProperty(pCred->pCert,
                                         CERT_KEY_PROV_INFO_PROP_ID,
                                         NULL,
                                         &cbSize))
    {
        pProvInfo = SPExternalAlloc(cbSize);
        if(pProvInfo == NULL)
        {
            Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            goto cleanup;
        }

        if(!CertGetCertificateContextProperty(pCred->pCert,
                                              CERT_KEY_PROV_INFO_PROP_ID,
                                              pProvInfo,
                                              &cbSize))
        {
            DebugLog((SP_LOG_ERROR, "Error 0x%x reading CERT_KEY_PROV_INFO_PROP_ID\n",GetLastError()));
            SPExternalFree(pProvInfo);
            pProvInfo = NULL;
        }
        else
        {
            // Success.
            pCred->dwKeySpec = pProvInfo->dwKeySpec;

            DebugLog((SP_LOG_TRACE, "Container:%ls\n",     pProvInfo->pwszContainerName));
            DebugLog((SP_LOG_TRACE, "Provider: %ls\n",     pProvInfo->pwszProvName));
            DebugLog((SP_LOG_TRACE, "Type:     0x%8.8x\n", pProvInfo->dwProvType));
            DebugLog((SP_LOG_TRACE, "Flags:    0x%8.8x\n", pProvInfo->dwFlags));
            DebugLog((SP_LOG_TRACE, "Key spec: %d\n",      pProvInfo->dwKeySpec));

            LogCredPropertiesEvent(dwProtocol, pProvInfo, pCred->pCert);
        }
    }


    if(pCred->hRemoteProv)
    {
        // The application supplied an hProv for us to use.

        Status = PCT_ERR_OK;
        goto cleanup;
    }


    if(pProvInfo)
    {
        //
        // We read the "key info" property successfully, so call
        // CryptAcquireContext in order to get a handle to the appropriate
        // key container.
        //

        if(!fRemoteProvider)
        {
            // Call CryptAcquireContext from the LSA process.
            Status = LocalCryptAcquireContext(&hProv, pProvInfo, dwProtocol, &fEventLogged);
            if(Status != PCT_ERR_OK)
            {
                goto cleanup;
            }

            pCred->hProv = hProv;
        }

        // Obtain a matching CSP handle in the application process.
        Status = RemoteCryptAcquireContextW(
                                        &pCred->hRemoteProv,
                                        pProvInfo->pwszContainerName,
                                        pProvInfo->pwszProvName,
                                        pProvInfo->dwProvType,
                                        pProvInfo->dwFlags,
                                        pCred->dwCapiFlags);
        if(!NT_SUCCESS(Status))
        {
            LogCredAcquireContextFailedEvent(dwProtocol, Status);
            fEventLogged = TRUE;

            Status = SP_LOG_RESULT(PCT_ERR_UNKNOWN_CREDENTIAL);
            goto cleanup;
        }
    }
    else
    {
        //
        // We weren't able to read the "key info" property, so attempt to
        // read the "iis private key" property, and build the private key
        // up from that.
        //

        DebugLog((SP_LOG_TRACE, "Attempt IIS 4.0 compatibility hack.\n"));

        Status = GetIisPrivateFromCert(pCred, pSubCred);

        if(Status != PCT_ERR_OK)
        {
            SP_LOG_RESULT(Status);
            goto cleanup;
        }
    }

    Status = PCT_ERR_OK;

cleanup:

    if(Status != PCT_ERR_OK && fEventLogged == FALSE)
    {
        if(pProvInfo == NULL)
        {
            LogNoPrivateKeyEvent(dwProtocol);
        }
        else
        {
            LogCreateCredFailedEvent(dwProtocol);
        }
    }

    if(pProvInfo)
    {
        SPExternalFree(pProvInfo);
    }

    return Status;
}


DWORD
GetCredentialKeySize(
    PSPCredential pCred)
{
    BLOBHEADER *pPublic;
    RSAPUBKEY * pRsaPublic;

    if(pCred->pPublicKey == NULL)
    {
        return 0;
    }

    pPublic = pCred->pPublicKey->pPublic;

    if(pPublic == NULL || pPublic->bType != PUBLICKEYBLOB)
    {
        return 0;
    }

    pRsaPublic = (RSAPUBKEY *)(pPublic + 1);

    return pRsaPublic->bitlen;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\spbase\cert.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cert.c
//
//  Contents:   
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   LSA integration stuff.
//              01-05-98   jbanes   Use WinVerifyTrust to validate certs.
//              03-26-99   jbanes   Fix CTL support, bug #303246 
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <spbase.h>
#include <ssl2msg.h>
#include <ssl3msg.h>
#include <wincrypt.h>
#include <oidenc.h>
#include <softpub.h>

#define CERT_HEADER_CONST "certificate"
#define CERT_HEADER_OFFSET 6

SP_STATUS
SchGetTrustedRoots(
    HCERTSTORE *phClientRootStore);

BOOL
WINAPI
SchCreateWorldStore (
     IN HCERTSTORE hRoot,
     IN DWORD cAdditionalStore,
     IN HCERTSTORE* rghAdditionalStore,
     OUT HCERTSTORE* phWorld);

BOOL
IsCertSelfSigned(PCCERT_CONTEXT pCertContext);


// typedef struct _OIDPROVMAP
// {
//     LPSTR   szOid;
//     DWORD   dwExchSpec;
//     DWORD   dwCertType;         // used for SSL 3.0 client auth
// }  OIDPROVMAP, *POIDPROVMAP;

OIDPROVMAP g_CertTypes[] = 
{
    { szOID_RSA_RSA,                  SP_EXCH_RSA_PKCS1,     SSL3_CERTTYPE_RSA_SIGN},
    { szOID_RSA_MD2RSA,               SP_EXCH_RSA_PKCS1,     SSL3_CERTTYPE_RSA_SIGN},
    { szOID_RSA_MD4RSA,               SP_EXCH_RSA_PKCS1,     SSL3_CERTTYPE_RSA_SIGN},
    { szOID_RSA_MD5RSA,               SP_EXCH_RSA_PKCS1,     SSL3_CERTTYPE_RSA_SIGN},
    { szOID_RSA_SHA1RSA,              SP_EXCH_RSA_PKCS1,     SSL3_CERTTYPE_RSA_SIGN},
    { szOID_OIWSEC_dsa,               SP_EXCH_DH_PKCS3,      SSL3_CERTTYPE_DSS_SIGN},
    { szOID_X957_DSA,                 SP_EXCH_DH_PKCS3,      SSL3_CERTTYPE_DSS_SIGN},
};

DWORD g_cCertTypes = sizeof(g_CertTypes)/sizeof(OIDPROVMAP);


DWORD 
MapOidToKeyExch(LPSTR szOid)
{
    DWORD i;

    for(i = 0; i < g_cCertTypes; i++)
    {
        if(strcmp(szOid, g_CertTypes[i].szOid) == 0)
        {
            return g_CertTypes[i].dwExchSpec;
        }
    }
    return 0;
}

DWORD 
MapOidToCertType(LPSTR szOid)
{
    DWORD i;

    for(i = 0; i < g_cCertTypes; i++)
    {
        if(strcmp(szOid, g_CertTypes[i].szOid) == 0)
        {
            return g_CertTypes[i].dwCertType;
        }
    }
    return 0;
}


// SPLoadCertificate takes a string of encoded cert bytes
// and decodes them into the local certificate cache.  It
// then returns the first certificate of the group.

SP_STATUS
SPLoadCertificate(
    DWORD      fProtocol,
    DWORD      dwCertEncodingType,
    PUCHAR     pCertificate,
    DWORD      cbCertificate,
    PCCERT_CONTEXT *ppCertContext)
{
    HCERTSTORE      hCertStore   = NULL;
    PCCERT_CONTEXT  pCertContext = NULL;

    PBYTE           pbCurrentRaw;
    DWORD           cbCurrentRaw;
    BOOL            fLeafCert;
    SP_STATUS       pctRet;


    //
    // Dereference the cert that we are replacing.
    //

    if(ppCertContext == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    if(*ppCertContext != NULL)
    {
        CertFreeCertificateContext(*ppCertContext);
    }
    *ppCertContext = NULL;


    //
    // Create an in-memory certificate store.
    //

    hCertStore = CertOpenStore(CERT_STORE_PROV_MEMORY, 
                               0, 0, 
                               CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG, 
                               0);
    if(hCertStore == NULL)
    {
        SP_LOG_RESULT(GetLastError());
        return SEC_E_INSUFFICIENT_MEMORY;
    }

    fLeafCert    = TRUE;
    pbCurrentRaw = pCertificate;
    cbCurrentRaw = cbCertificate;

    do 
    {

        //
        // Skip to beginning of certificate.
        //

        if((fProtocol & SP_PROT_SSL3TLS1) && cbCurrentRaw > 3)
        {
            // SSL3 style cert chain, where the length
            // of each cert is prepended.
            pbCurrentRaw += 3;
            cbCurrentRaw -= 3;
        }

        // Skip past the "certificate" header
        if((cbCurrentRaw > (CERT_HEADER_OFFSET + strlen(CERT_HEADER_CONST))) && 
            (memcmp(pbCurrentRaw + CERT_HEADER_OFFSET, CERT_HEADER_CONST, strlen(CERT_HEADER_CONST)) == 0))
        {
            pbCurrentRaw += CERT_HEADER_OFFSET + strlen(CERT_HEADER_CONST);
            cbCurrentRaw -= CERT_HEADER_OFFSET + strlen(CERT_HEADER_CONST);
        }


        //
        // Decode this certificate context.
        //

        if(!CertAddEncodedCertificateToStore(hCertStore, 
                                             dwCertEncodingType,
                                             pbCurrentRaw,
                                             cbCurrentRaw,
                                             CERT_STORE_ADD_USE_EXISTING,
                                             &pCertContext))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_ERR_BAD_CERTIFICATE;
            goto cleanup;
        }

        pbCurrentRaw += pCertContext->cbCertEncoded;
        if(cbCurrentRaw < pCertContext->cbCertEncoded)
        {
            pctRet =  SP_LOG_RESULT(PCT_ERR_BAD_CERTIFICATE);
            goto cleanup;
        }
        cbCurrentRaw -= pCertContext->cbCertEncoded;

        if(fLeafCert)
        {
            fLeafCert = FALSE;
            *ppCertContext = pCertContext;
        }
        else
        {
            CertFreeCertificateContext(pCertContext);
        }
        pCertContext = NULL;

    } while(cbCurrentRaw);

    pctRet = PCT_ERR_OK;


cleanup:

    CertCloseStore(hCertStore, 0);

    if(pctRet != PCT_ERR_OK)
    {
        if(pCertContext)
        {
            CertFreeCertificateContext(pCertContext);
        }
        if(*ppCertContext)
        {
            CertFreeCertificateContext(*ppCertContext);
            *ppCertContext = NULL;
        }
    }

    return pctRet;
}


SP_STATUS  
SPPublicKeyFromCert(
    PCCERT_CONTEXT  pCert, 
    PUBLICKEY **    ppKey,
    ExchSpec *      pdwExchSpec)
{
    PCERT_PUBLIC_KEY_INFO pPubKeyInfo;
    PUBLICKEY * pPublicKey;
    DWORD       dwExchSpec;
    DWORD       cbBlob;
    SP_STATUS   pctRet;

    //
    // Log the subject and issuer names.
    //

    LogDistinguishedName(DEB_TRACE, 
                         "Subject: %s\n", 
                         pCert->pCertInfo->Subject.pbData, 
                         pCert->pCertInfo->Subject.cbData);

    LogDistinguishedName(DEB_TRACE, 
                         "Issuer: %s\n", 
                         pCert->pCertInfo->Issuer.pbData, 
                         pCert->pCertInfo->Issuer.cbData);

    //
    // Determine type of public key embedded in the certificate.
    //

    pPubKeyInfo = &pCert->pCertInfo->SubjectPublicKeyInfo;
    if(pPubKeyInfo == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    dwExchSpec = MapOidToKeyExch(pPubKeyInfo->Algorithm.pszObjId);

    if(dwExchSpec == 0)
    {
        return PCT_INT_UNKNOWN_CREDENTIAL;
    }

    //
    // Build public key blob from encoded public key.
    //

    switch(dwExchSpec)
    {
    case SP_EXCH_RSA_PKCS1:
        pctRet = RsaPublicKeyFromCert(pPubKeyInfo,
                                      NULL,
                                      &cbBlob);
        if(pctRet != PCT_ERR_OK)
        {
            return pctRet;
        }

        pPublicKey = SPExternalAlloc(sizeof(PUBLICKEY) + cbBlob);
        if(pPublicKey == NULL)
        {
            return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        }

        pPublicKey->pPublic  = (BLOBHEADER *)(pPublicKey + 1);
        pPublicKey->cbPublic = cbBlob;

        pctRet = RsaPublicKeyFromCert(pPubKeyInfo,
                                      pPublicKey->pPublic,
                                      &pPublicKey->cbPublic);
        if(pctRet != PCT_ERR_OK)
        {
            SPExternalFree(pPublicKey);
            return pctRet;
        }
        break;

    case SP_EXCH_DH_PKCS3:
        pctRet = DssPublicKeyFromCert(pPubKeyInfo,
                                      NULL,
                                      &cbBlob);
        if(pctRet != PCT_ERR_OK)
        {
            return pctRet;
        }

        pPublicKey = SPExternalAlloc(sizeof(PUBLICKEY) + cbBlob);
        if(pPublicKey == NULL)
        {
            return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        }

        pPublicKey->pPublic  = (BLOBHEADER *)(pPublicKey + 1);
        pPublicKey->cbPublic = cbBlob;

        pctRet = DssPublicKeyFromCert(pPubKeyInfo,
                                      pPublicKey->pPublic,
                                      &pPublicKey->cbPublic);
        if(pctRet != PCT_ERR_OK)
        {
            SPExternalFree(pPublicKey);
            return pctRet;
        }
        break;

    default:
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }


    //
    // Set function outputs.
    //

    *ppKey = pPublicKey;

    if(pdwExchSpec)
    {
        *pdwExchSpec = dwExchSpec;
    }

    return PCT_ERR_OK;
}


SP_STATUS
SPSerializeCertificate(
    DWORD           dwProtocol,         // in
    BOOL            fBuildChain,        // in
    PBYTE *         ppCertChain,        // out
    DWORD *         pcbCertChain,       // out
    PCCERT_CONTEXT  pCertContext,       // in
    DWORD           dwChainingFlags)    // in
{
    PCCERT_CHAIN_CONTEXT pChainContext = NULL;
    CERT_CHAIN_PARA      ChainPara;
    PCERT_SIMPLE_CHAIN   pSimpleChain;
    PCCERT_CONTEXT       pCurrentCert;

    BOOL        fSuccess = FALSE;
    PBYTE       pbCertChain;
    DWORD       cbCertChain;
    DWORD       i;
    SP_STATUS   pctRet;
    BOOL        fImpersonating = FALSE;

    SP_BEGIN("SPSerializeCertificate");

    if(pcbCertChain == NULL)
    {
        SP_RETURN( SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    if(fBuildChain)
    {
        ZeroMemory(&ChainPara, sizeof(ChainPara));
        ChainPara.cbSize = sizeof(ChainPara);

        fImpersonating = SslImpersonateClient();

        if(!(fSuccess = CertGetCertificateChain(
                                NULL,
                                pCertContext,
                                NULL,
                                NULL,
                                &ChainPara,
                                dwChainingFlags,
                                NULL,
                                &pChainContext)))
        {
            DebugLog((DEB_WARN, "Error 0x%x returned by CertGetCertificateChain!\n", GetLastError()));
            pChainContext = NULL;
        }

        if(fImpersonating) 
        {
            RevertToSelf();
            fImpersonating = FALSE;
        }
    }

    if(!fSuccess)
    {
        //
        // Send the leaf certificate only.
        //

        // Compute size of chain.
        cbCertChain = pCertContext->cbCertEncoded;
        if(dwProtocol & SP_PROT_SSL3TLS1)
        {
            cbCertChain += CB_SSL3_CERT_VECTOR;
        }

        // Allocate memory for chain.
        if(ppCertChain == NULL)
        {
            *pcbCertChain = cbCertChain;
            pctRet = PCT_ERR_OK;
            goto cleanup;
        }
        else if(*ppCertChain == NULL)
        {
            *ppCertChain = SPExternalAlloc(cbCertChain);
            if(*ppCertChain == NULL)
            {
                pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
                goto cleanup;
            }
        }
        else if(*pcbCertChain < cbCertChain)
        {
            pctRet = SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
            goto cleanup;
        }
        *pcbCertChain = cbCertChain;

        // Place chain in output buffer.
        pbCertChain = *ppCertChain;

        if(dwProtocol & SP_PROT_SSL3TLS1)
        {
            pbCertChain[0] = MS24BOF(pCertContext->cbCertEncoded);
            pbCertChain[1] = MSBOF(pCertContext->cbCertEncoded);
            pbCertChain[2] = LSBOF(pCertContext->cbCertEncoded);
            pbCertChain += CB_SSL3_CERT_VECTOR;
        }
        CopyMemory(pbCertChain, pCertContext->pbCertEncoded, pCertContext->cbCertEncoded);

        pctRet = PCT_ERR_OK;
        goto cleanup;
    }


    //
    // Compute size of chain.
    //

    pSimpleChain = pChainContext->rgpChain[0];
    cbCertChain  = 0;

    for(i = 0; i < pSimpleChain->cElement; i++)
    {
        pCurrentCert = pSimpleChain->rgpElement[i]->pCertContext;
        
        if(i > 0)
        {
            // Verify that this is not a root certificate.
            if(CertCompareCertificateName(pCurrentCert->dwCertEncodingType, 
                                          &pCurrentCert->pCertInfo->Issuer,
                                          &pCurrentCert->pCertInfo->Subject))
            {
                break;
            }
        }

        cbCertChain += pCurrentCert->cbCertEncoded;
        if(dwProtocol & SP_PROT_SSL3TLS1)
        {
            cbCertChain += CB_SSL3_CERT_VECTOR;
        }
    }


    //
    // Allocate memory for chain.
    //

    if(ppCertChain == NULL)
    {
        *pcbCertChain = cbCertChain;
        pctRet = PCT_ERR_OK;
        goto cleanup;
    }
    else if(*ppCertChain == NULL)
    {
        *ppCertChain = SPExternalAlloc(cbCertChain);
        if(*ppCertChain == NULL)
        {
            pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            goto cleanup;
        }
    }
    else if(*pcbCertChain < cbCertChain)
    {
        pctRet = SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
        goto cleanup;
    }
    *pcbCertChain = cbCertChain;


    //
    // Place chain in output buffer.
    //

    pbCertChain = *ppCertChain;

    for(i = 0; i < pSimpleChain->cElement; i++)
    {
        pCurrentCert = pSimpleChain->rgpElement[i]->pCertContext;
        
        if(i > 0)
        {
            // Verify that this is not a root certificate.
            if(CertCompareCertificateName(pCurrentCert->dwCertEncodingType, 
                                          &pCurrentCert->pCertInfo->Issuer,
                                          &pCurrentCert->pCertInfo->Subject))
            {
                break;
            }
        }

        if(dwProtocol & SP_PROT_SSL3TLS1)
        {
            pbCertChain[0] = MS24BOF(pCurrentCert->cbCertEncoded);
            pbCertChain[1] = MSBOF(pCurrentCert->cbCertEncoded);
            pbCertChain[2] = LSBOF(pCurrentCert->cbCertEncoded);
            pbCertChain += CB_SSL3_CERT_VECTOR;
        }
        CopyMemory(pbCertChain, pCurrentCert->pbCertEncoded, pCurrentCert->cbCertEncoded);
        pbCertChain += pCurrentCert->cbCertEncoded;
    }

    SP_ASSERT(*ppCertChain + cbCertChain == pbCertChain);

    pctRet = PCT_ERR_OK;

cleanup:

    if(pChainContext)
    {
        CertFreeCertificateChain(pChainContext);
    }

    SP_RETURN(pctRet);
}


/*****************************************************************************/
SP_STATUS 
ExtractIssuerNamesFromStore(
    HCERTSTORE  hStore,         // in
    PBYTE       pbIssuers,      // out
    DWORD       *pcbIssuers)    // in, out
{
    DWORD cbCurIssuerLen = 0;
    DWORD cbIssuerLen = *pcbIssuers;
    PBYTE pbCurIssuer = pbIssuers;
    PCCERT_CONTEXT pCurrent = NULL;
    SECURITY_STATUS scRet;
    BOOL fIsAllowed;

    // Initialize output to zero.
    *pcbIssuers = 0;

    while(TRUE)
    {
        pCurrent = CertEnumCertificatesInStore(hStore, pCurrent);
        if(pCurrent == NULL) break;

        // Is this a client-auth certificate?
        scRet = SPCheckKeyUsage(pCurrent,
                                szOID_PKIX_KP_CLIENT_AUTH,
                                FALSE,
                                &fIsAllowed);
        if(scRet != SEC_E_OK)
        {
            continue;
        }
        if(!fIsAllowed)
        {
            continue;
        }

        cbCurIssuerLen += 2 + pCurrent->pCertInfo->Subject.cbData;

        // Are we writing?
        if(pbIssuers)
        {
            if(cbCurIssuerLen > cbIssuerLen)
            {
                // Memory overrun
                CertFreeCertificateContext(pCurrent);
                return SP_LOG_RESULT(PCT_INT_DATA_OVERFLOW);
            }

            pbCurIssuer[0] = MSBOF(pCurrent->pCertInfo->Subject.cbData);
            pbCurIssuer[1] = LSBOF(pCurrent->pCertInfo->Subject.cbData);
            pbCurIssuer += 2;

            CopyMemory(pbCurIssuer, pCurrent->pCertInfo->Subject.pbData,
            pCurrent->pCertInfo->Subject.cbData);
            pbCurIssuer += pCurrent->pCertInfo->Subject.cbData;
        }
    }

    *pcbIssuers = cbCurIssuerLen;

    return PCT_ERR_OK;
}


/*****************************************************************************/
SP_STATUS 
GetDefaultIssuers(
    PBYTE   pbIssuers,      // out
    DWORD   *pcbIssuers)    // in, out
{
    HCERTSTORE  hStore;
    SP_STATUS   pctRet;

    pctRet = SchGetTrustedRoots(&hStore);
    if(pctRet != PCT_ERR_OK)
    {
        return pctRet;
    }

    pctRet = ExtractIssuerNamesFromStore(hStore, pbIssuers, pcbIssuers);
    if(pctRet != PCT_ERR_OK)
    {
        CertCloseStore(hStore, 0);
        return pctRet;
    }

    CertCloseStore(hStore, 0);
    return PCT_ERR_OK;
}


SP_STATUS
SchGetTrustedRoots(
    HCERTSTORE *phClientRootStore)
{
    HTTPSPolicyCallbackData  polHttps;
    CERT_CHAIN_POLICY_PARA   PolicyPara;
    CERT_CHAIN_POLICY_STATUS PolicyStatus;
    CERT_CHAIN_PARA          ChainPara;
    PCCERT_CHAIN_CONTEXT     pChainContext = NULL;
    LPSTR                    pszUsage;

    PCCERT_CONTEXT  pCertContext;
    HCERTSTORE      hClientRootStore = 0;
    HCERTSTORE      hRootStore       = 0;
    HCERTSTORE      hWorldStore      = 0;
    DWORD           Status           = SEC_E_OK;
    BOOL            fImpersonating   = FALSE;



    // Open output store.
    hClientRootStore = CertOpenStore(CERT_STORE_PROV_MEMORY, 
                                     0, 0, 
                                     CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG, 
                                     0);
    if(hClientRootStore == NULL)
    {
        //SP_LOG_RESULT(GetLastError());
        Status = SEC_E_INSUFFICIENT_MEMORY;
        goto cleanup;
    }

    fImpersonating = SslImpersonateClient();

    // Open root store.
    hRootStore = CertOpenSystemStore(0, "ROOT");
    if(hRootStore == NULL)
    {
        DebugLog((DEB_WARN, "Error 0x%x opening root store\n", GetLastError()));
    }

    // Create world store.
    if(!SchCreateWorldStore(hRootStore,
                            0, NULL, 
                            &hWorldStore))
    {
        DebugLog((DEB_ERROR, "Error 0x%x creating world store\n", GetLastError()));
        goto cleanup;
    }

    // Enumerate the certificates in the world store, looking 
    // for trusted roots. This approach will automatically take
    // advantage of any CTLs that are installed on the system.
    pCertContext = NULL;
    while(TRUE)
    {
        pCertContext = CertEnumCertificatesInStore(hWorldStore, pCertContext);
        if(pCertContext == NULL) break;

        if(!IsCertSelfSigned(pCertContext))
        {
            continue;
        }

        pszUsage = szOID_PKIX_KP_CLIENT_AUTH;

        ZeroMemory(&ChainPara, sizeof(ChainPara));
        ChainPara.cbSize = sizeof(ChainPara);
        ChainPara.RequestedUsage.dwType = USAGE_MATCH_TYPE_OR;
        ChainPara.RequestedUsage.Usage.cUsageIdentifier     = 1;
        ChainPara.RequestedUsage.Usage.rgpszUsageIdentifier = &pszUsage;

        if(!CertGetCertificateChain(
                                NULL,
                                pCertContext,
                                NULL,
                                0,
                                &ChainPara,
                                0,
                                NULL,
                                &pChainContext))
        {
            SP_LOG_RESULT(GetLastError());
            continue;
        }

        // Set up validate chain structures.
        ZeroMemory(&polHttps, sizeof(HTTPSPolicyCallbackData));
        polHttps.cbStruct           = sizeof(HTTPSPolicyCallbackData);
        polHttps.dwAuthType         = AUTHTYPE_CLIENT;
        polHttps.fdwChecks          = 0;
        polHttps.pwszServerName     = NULL;

        ZeroMemory(&PolicyStatus, sizeof(PolicyStatus));
        PolicyStatus.cbSize         = sizeof(PolicyStatus);

        ZeroMemory(&PolicyPara, sizeof(PolicyPara));
        PolicyPara.cbSize           = sizeof(PolicyPara);
        PolicyPara.pvExtraPolicyPara= &polHttps;
        PolicyPara.dwFlags = CERT_CHAIN_POLICY_IGNORE_ALL_NOT_TIME_VALID_FLAGS;

        // Validate chain
        if(!CertVerifyCertificateChainPolicy(
                                CERT_CHAIN_POLICY_SSL,
                                pChainContext,
                                &PolicyPara,
                                &PolicyStatus))
        {
            SP_LOG_RESULT(GetLastError());
            CertFreeCertificateChain(pChainContext);
            continue;
        }

        if(PolicyStatus.dwError)
        {
            // Certificate did not validate, move on to the next one.
            CertFreeCertificateChain(pChainContext);
            continue;
        }

        CertFreeCertificateChain(pChainContext);

        // Add the root certificate to the list of trusted ones.
        if(!CertAddCertificateContextToStore(hClientRootStore,
                                             pCertContext,
                                             CERT_STORE_ADD_USE_EXISTING,
                                             NULL))
        {
            SP_LOG_RESULT(GetLastError());
        }
    }

cleanup:

    if(hRootStore)
    {
        CertCloseStore(hRootStore, 0);
    }

    if(hWorldStore)
    {
        CertCloseStore(hWorldStore, 0);
    }

    if(fImpersonating)
    {
        RevertToSelf();
    }

    if(Status == SEC_E_OK)
    {
        *phClientRootStore = hClientRootStore;
    }

    return Status;
}


//+---------------------------------------------------------------------------
//
//  Function:   ChainCreateCollectionIncludingCtlCertificates
//
//  Synopsis:   create a collection which includes the source store hStore and
//              any CTL certificates from it
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainCreateCollectionIncludingCtlCertificates (
     IN HCERTSTORE hStore,
     OUT HCERTSTORE* phCollection
     )
{
    BOOL          fResult = FALSE;
    HCERTSTORE    hCollection;
    PCCTL_CONTEXT pCtlContext = NULL;
    HCERTSTORE    hCtlStore;

    hCollection = CertOpenStore(
                      CERT_STORE_PROV_COLLECTION,
                      X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                      0,
                      CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
                      NULL
                      );

    if ( hCollection == NULL )
    {
        return( FALSE );
    }

    fResult = CertAddStoreToCollection( hCollection, hStore, 0, 0 );

    while ( ( fResult == TRUE ) &&
            ( ( pCtlContext = CertEnumCTLsInStore(
                                  hStore,
                                  pCtlContext
                                  ) ) != NULL ) )
    {
        hCtlStore = CertOpenStore(
                        CERT_STORE_PROV_MSG,
                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                        0,
                        0,
                        pCtlContext->hCryptMsg
                        );

        if ( hCtlStore != NULL )
        {
            fResult = CertAddStoreToCollection(
                          hCollection,
                          hCtlStore,
                          0,
                          0
                          );

            CertCloseStore( hCtlStore, 0 );
        }
    }

    if ( fResult == TRUE )
    {
        *phCollection = hCollection;
    }
    else
    {
        CertCloseStore( hCollection, 0 );
    }

    return( fResult );
}


BOOL
WINAPI
SchCreateWorldStore (
     IN HCERTSTORE hRoot,
     IN DWORD cAdditionalStore,
     IN HCERTSTORE* rghAdditionalStore,
     OUT HCERTSTORE* phWorld)
{
    BOOL       fResult;
    HCERTSTORE hWorld;
    HCERTSTORE hStore, hCtl;
    DWORD      cCount;

    hWorld = CertOpenStore(
                 CERT_STORE_PROV_COLLECTION,
                 X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                 0,
                 CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
                 NULL
                 );

    if ( hWorld == NULL )
    {
        return( FALSE );
    }

    fResult = CertAddStoreToCollection( hWorld, hRoot, 0, 0 );

    for ( cCount = 0;
          ( cCount < cAdditionalStore ) && ( fResult == TRUE );
          cCount++ )
    {
        fResult = CertAddStoreToCollection(
                      hWorld,
                      rghAdditionalStore[ cCount ],
                      0,
                      0
                      );
    }

    if ( fResult == TRUE )
    {
        hStore = CertOpenSystemStore(0, "trust");
        if( hStore != NULL )
        {
            if(ChainCreateCollectionIncludingCtlCertificates(hStore, &hCtl))
            {
                if(!CertAddStoreToCollection( hWorld, hCtl, 0, 0 ))
                {
                    DebugLog((DEB_WARN, "Error 0x%x adding CTL collection\n", GetLastError()));
                }
                CertCloseStore( hCtl, 0 );
            }
            else
            {
                DebugLog((DEB_WARN, "Error 0x%x creating CTL collection\n", GetLastError()));
            }
            CertCloseStore( hStore, 0 );
        }
    }

    if ( fResult == TRUE )
    {
        hStore = CertOpenSystemStore(0, "ca");
        if ( hStore != NULL )
        {
            fResult = CertAddStoreToCollection( hWorld, hStore, 0, 0 );
            CertCloseStore( hStore, 0 );
        }
        else
        {
            fResult = FALSE;
        }
    }

    if ( fResult == TRUE )
    {
        hStore = CertOpenSystemStore(0, "my");
        if ( hStore != NULL )
        {
            fResult = CertAddStoreToCollection( hWorld, hStore, 0, 0 );
            CertCloseStore( hStore, 0 );
        }
        else
        {
            fResult = FALSE;
        }
    }

    if ( fResult == TRUE )
    {
        *phWorld = hWorld;
    }
    else
    {
        CertCloseStore( hWorld, 0 );
    }

    return( fResult );
}


BOOL
IsCertSelfSigned(PCCERT_CONTEXT pCertContext)
{
    // Compare subject and issuer names.
    if(pCertContext->pCertInfo->Subject.cbData == pCertContext->pCertInfo->Issuer.cbData)
    {
        if(memcmp(pCertContext->pCertInfo->Subject.pbData,
                  pCertContext->pCertInfo->Issuer.pbData,  
                  pCertContext->pCertInfo->Issuer.cbData) == 0)
        {
            return TRUE;
        }
    }

    return FALSE;
}


SP_STATUS
MapWinTrustError(DWORD Status, DWORD DefaultError, DWORD dwIgnoreErrors)
{
    if((Status == CRYPT_E_NO_REVOCATION_CHECK) &&
       (dwIgnoreErrors & CRED_FLAG_IGNORE_NO_REVOCATION_CHECK))
    {
        DebugLog((DEB_WARN, "MapWinTrustError: Ignoring CRYPT_E_NO_REVOCATION_CHECK\n"));
        Status = STATUS_SUCCESS;
    }
    if((Status == CRYPT_E_REVOCATION_OFFLINE) &&
       (dwIgnoreErrors & CRED_FLAG_IGNORE_REVOCATION_OFFLINE))
    {
        DebugLog((DEB_WARN, "MapWinTrustError: Ignoring CRYPT_E_REVOCATION_OFFLINE\n"));
        Status = STATUS_SUCCESS;
    }

    if(HRESULT_FACILITY(Status) == FACILITY_SECURITY)
    {
        return (Status);
    }

    switch(Status)
    {
        case ERROR_SUCCESS:
            return SEC_E_OK;

        // Expired certificate.
        case CERT_E_EXPIRED:
        case CERT_E_VALIDITYPERIODNESTING:
            return SEC_E_CERT_EXPIRED;

        // Unknown CA
        case CERT_E_UNTRUSTEDROOT:
        case CERT_E_UNTRUSTEDCA:
            return SEC_E_UNTRUSTED_ROOT;

        // Certificate revoked.
        case CERT_E_REVOKED:
            return CRYPT_E_REVOKED;

        // Target name doesn't match name in certificate.
        case CERT_E_CN_NO_MATCH:
            return SEC_E_WRONG_PRINCIPAL;

        // Some other error.
        default:
            if(DefaultError)
            {
                return DefaultError;
            }
            else
            {
                return SEC_E_CERT_UNKNOWN;
            }
    }
}

NTSTATUS
VerifyClientCertificate(
    PCCERT_CONTEXT  pCertContext,
    DWORD           dwCertFlags,
    DWORD           dwIgnoreErrors,
    LPCSTR          pszPolicyOID,
    PCCERT_CHAIN_CONTEXT *ppChainContext)   // optional
{
    HTTPSPolicyCallbackData  polHttps;
    CERT_CHAIN_POLICY_PARA   PolicyPara;
    CERT_CHAIN_POLICY_STATUS PolicyStatus;
    CERT_CHAIN_PARA          ChainPara;
    PCCERT_CHAIN_CONTEXT     pChainContext = NULL;
    DWORD                    Status;
    LPSTR                    pszUsage;
    BOOL                     fImpersonating = FALSE;

    //
    // Build certificate chain.
    //

    fImpersonating = SslImpersonateClient();

    pszUsage = szOID_PKIX_KP_CLIENT_AUTH;

    ZeroMemory(&ChainPara, sizeof(ChainPara));
    ChainPara.cbSize = sizeof(ChainPara);
    ChainPara.RequestedUsage.dwType = USAGE_MATCH_TYPE_OR;
    ChainPara.RequestedUsage.Usage.cUsageIdentifier     = 1;
    ChainPara.RequestedUsage.Usage.rgpszUsageIdentifier = &pszUsage;

    if(!CertGetCertificateChain(
                            NULL,                       // hChainEngine
                            pCertContext,               // pCertContext
                            NULL,                       // pTime
                            pCertContext->hCertStore,   // hAdditionalStore
                            &ChainPara,                 // pChainPara
                            dwCertFlags,                // dwFlags
                            NULL,                       // pvReserved
                            &pChainContext))            // ppChainContext
    {
        Status = SP_LOG_RESULT(GetLastError());
        goto cleanup;
    }


    //
    // Validate certificate chain.
    // 

    if(pszPolicyOID == CERT_CHAIN_POLICY_NT_AUTH)
    {
        ZeroMemory(&PolicyPara, sizeof(PolicyPara));
        PolicyPara.cbSize   = sizeof(PolicyPara);
        PolicyPara.dwFlags  = BASIC_CONSTRAINTS_CERT_CHAIN_POLICY_END_ENTITY_FLAG;
    }
    else
    {
        ZeroMemory(&polHttps, sizeof(HTTPSPolicyCallbackData));
        polHttps.cbStruct   = sizeof(HTTPSPolicyCallbackData);
        polHttps.dwAuthType = AUTHTYPE_CLIENT;
        polHttps.fdwChecks  = 0;

        ZeroMemory(&PolicyPara, sizeof(PolicyPara));
        PolicyPara.cbSize            = sizeof(PolicyPara);
        PolicyPara.pvExtraPolicyPara = &polHttps;
    }

    ZeroMemory(&PolicyStatus, sizeof(PolicyStatus));
    PolicyStatus.cbSize = sizeof(PolicyStatus);

    if(!CertVerifyCertificateChainPolicy(
                            pszPolicyOID,
                            pChainContext,
                            &PolicyPara,
                            &PolicyStatus))
    {
        Status = SP_LOG_RESULT(GetLastError());
        goto cleanup;
    }

#if DBG
    if(PolicyStatus.dwError)
    {
        DebugLog((DEB_WARN, "CertVerifyCertificateChainPolicy returned 0x%x\n", PolicyStatus.dwError));
    }
#endif

    Status = MapWinTrustError(PolicyStatus.dwError, 0, dwIgnoreErrors);

    if(Status)
    {
        DebugLog((DEB_ERROR, "MapWinTrustError returned 0x%x\n", Status));
        goto cleanup;
    }

    Status = STATUS_SUCCESS;

    if(ppChainContext != NULL)
    {
        *ppChainContext = pChainContext;
        pChainContext = NULL;
    }

cleanup:

    if(pChainContext)
    {
        CertFreeCertificateChain(pChainContext);
    }

    if(fImpersonating) RevertToSelf();

    return Status;
}


NTSTATUS
AutoVerifyServerCertificate(PSPContext pContext)
{
    PSPCredentialGroup pCredGroup;
    DWORD dwCertFlags = 0;
    DWORD dwIgnoreErrors = 0;

    if(pContext->Flags & CONTEXT_FLAG_MANUAL_CRED_VALIDATION)
    {
        return STATUS_SUCCESS;
    }

    pCredGroup = pContext->pCredGroup;
    if(pCredGroup == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
    }

    if(pCredGroup->dwFlags & CRED_FLAG_REVCHECK_END_CERT)
        dwCertFlags |= CERT_CHAIN_REVOCATION_CHECK_END_CERT;
    if(pCredGroup->dwFlags & CRED_FLAG_REVCHECK_CHAIN)
        dwCertFlags |= CERT_CHAIN_REVOCATION_CHECK_CHAIN;
    if(pCredGroup->dwFlags & CRED_FLAG_REVCHECK_CHAIN_EXCLUDE_ROOT)
        dwCertFlags |= CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT;
    if(pCredGroup->dwFlags & CRED_FLAG_IGNORE_NO_REVOCATION_CHECK)
        dwIgnoreErrors |= CRED_FLAG_IGNORE_NO_REVOCATION_CHECK;
    if(pCredGroup->dwFlags & CRED_FLAG_IGNORE_REVOCATION_OFFLINE)
        dwIgnoreErrors |= CRED_FLAG_IGNORE_REVOCATION_OFFLINE;

    return VerifyServerCertificate(pContext, dwCertFlags, dwIgnoreErrors);
}


NTSTATUS
VerifyServerCertificate(
    PSPContext  pContext,
    DWORD       dwCertFlags,
    DWORD       dwIgnoreErrors)
{
    HTTPSPolicyCallbackData  polHttps;
    CERT_CHAIN_POLICY_PARA   PolicyPara;
    CERT_CHAIN_POLICY_STATUS PolicyStatus;
    CERT_CHAIN_PARA          ChainPara;
    PCCERT_CHAIN_CONTEXT     pChainContext = NULL;

    #define SERVER_USAGE_COUNT 3
    LPSTR               rgszUsages[SERVER_USAGE_COUNT] = {
                            szOID_PKIX_KP_SERVER_AUTH,
                            szOID_SERVER_GATED_CRYPTO,
                            szOID_SGC_NETSCAPE };
 
    DWORD               Status;
    PWSTR               pwszServerName = NULL;
    PSPCredentialGroup  pCred;
    PCCERT_CONTEXT      pCertContext;
    BOOL                fImpersonating = FALSE;

    pCred = pContext->pCredGroup;
    if(pCred == NULL)
    {
        return SEC_E_INTERNAL_ERROR;
    }

    pCertContext = pContext->RipeZombie->pRemoteCert;
    if(pCertContext == NULL)
    {
        return SEC_E_INTERNAL_ERROR;
    }


    //
    // Build certificate chain.
    //

    fImpersonating = SslImpersonateClient();

    ZeroMemory(&ChainPara, sizeof(ChainPara));
    ChainPara.cbSize = sizeof(ChainPara);
    ChainPara.RequestedUsage.dwType = USAGE_MATCH_TYPE_OR;
    ChainPara.RequestedUsage.Usage.cUsageIdentifier     = SERVER_USAGE_COUNT;
    ChainPara.RequestedUsage.Usage.rgpszUsageIdentifier = rgszUsages;

    if(!CertGetCertificateChain(
                            NULL,                       // hChainEngine
                            pCertContext,               // pCertContext
                            NULL,                       // pTime
                            pCertContext->hCertStore,   // hAdditionalStore
                            &ChainPara,                 // pChainPara
                            dwCertFlags,                // dwFlags
                            NULL,                       // pvReserved
                            &pChainContext))            // ppChainContext
    {
        Status = SP_LOG_RESULT(GetLastError());
        goto cleanup;
    }


    //
    // Validate certificate chain.
    // 

    if(!(pCred->dwFlags & CRED_FLAG_NO_SERVERNAME_CHECK))
    {
        pwszServerName = pContext->RipeZombie->szCacheID;

        if(pwszServerName == NULL || lstrlenW(pwszServerName) == 0)
        {
            Status = SP_LOG_RESULT(SEC_E_WRONG_PRINCIPAL);
            goto cleanup;
        }
    }

    ZeroMemory(&polHttps, sizeof(HTTPSPolicyCallbackData));
    polHttps.cbStruct           = sizeof(HTTPSPolicyCallbackData);
    polHttps.dwAuthType         = AUTHTYPE_SERVER;
    polHttps.fdwChecks          = 0;
    polHttps.pwszServerName     = pwszServerName;

    ZeroMemory(&PolicyPara, sizeof(PolicyPara));
    PolicyPara.cbSize            = sizeof(PolicyPara);
    PolicyPara.pvExtraPolicyPara = &polHttps;

    ZeroMemory(&PolicyStatus, sizeof(PolicyStatus));
    PolicyStatus.cbSize = sizeof(PolicyStatus);

    if(!CertVerifyCertificateChainPolicy(
                            CERT_CHAIN_POLICY_SSL,
                            pChainContext,
                            &PolicyPara,
                            &PolicyStatus))
    {
        Status = SP_LOG_RESULT(GetLastError());
        goto cleanup;
    }

#if DBG
    if(PolicyStatus.dwError)
    {
        DebugLog((DEB_WARN, "CertVerifyCertificateChainPolicy returned 0x%x\n", PolicyStatus.dwError));
    }
#endif

    Status = MapWinTrustError(PolicyStatus.dwError, 0, dwIgnoreErrors);

    if(Status)
    {
        DebugLog((DEB_ERROR, "MapWinTrustError returned 0x%x\n", Status));
        LogBogusServerCertEvent(pCertContext, pwszServerName, Status);
        goto cleanup;
    }

    Status = STATUS_SUCCESS;


cleanup:

    if(pChainContext)
    {
        CertFreeCertificateChain(pChainContext);
    }

    if(fImpersonating) RevertToSelf();

    return Status;
}


SECURITY_STATUS
SPCheckKeyUsage(
    PCCERT_CONTEXT  pCertContext, 
    PSTR            pszUsage,
    BOOL            fOnCertOnly,
    PBOOL           pfIsAllowed)
{
    PCERT_ENHKEY_USAGE pKeyUsage;
    DWORD cbKeyUsage;
    DWORD j;
    BOOL  fFound;
    DWORD dwFlags = 0;

    if(fOnCertOnly)
    {
        dwFlags = CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG;
    }

    // Determine size of usage information.
    if(!CertGetEnhancedKeyUsage(pCertContext,
                                dwFlags, 
                                NULL,
                                &cbKeyUsage))
    {
        // No usage information exists.
        *pfIsAllowed = TRUE;
        return SEC_E_OK;
    }

    pKeyUsage = SPExternalAlloc(cbKeyUsage);
    if(pKeyUsage == NULL)
    {
        *pfIsAllowed = FALSE;
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }

    // Read key usage information.
    if(!CertGetEnhancedKeyUsage(pCertContext,
                                dwFlags, 
                                pKeyUsage,
                                &cbKeyUsage))
    {
        // No usage information exists.
        SPExternalFree(pKeyUsage);
        *pfIsAllowed = TRUE;
        return SEC_E_OK;
    }

    if(pKeyUsage->cUsageIdentifier == 0 && GetLastError() == CRYPT_E_NOT_FOUND)
    {
        // No usage information exists.
        SPExternalFree(pKeyUsage);
        *pfIsAllowed = TRUE;
        return SEC_E_OK;
    }

    // See if requested usage is in list of supported usages.
    fFound = FALSE;
    for(j = 0; j < pKeyUsage->cUsageIdentifier; j++)
    {
        if(strcmp(pszUsage, pKeyUsage->rgpszUsageIdentifier[j]) == 0)
        {
            fFound = TRUE;
            break;
        }
    }

    SPExternalFree(pKeyUsage);

    if(!fFound)
    {
        // Usage extensions found, but doesn't list ours.
        *pfIsAllowed = FALSE;
    }
    else
    {
        *pfIsAllowed = TRUE;
    }

    return SEC_E_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\spbase\cliprot.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cliprot.c
//
//  Contents:   
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   LSA integration stuff.
//
//----------------------------------------------------------------------------

#include <spbase.h>
#include <pct1msg.h>
#include <pct1prot.h>
#include <ssl2msg.h>
#include <ssl3msg.h>
#include <ssl2prot.h>

UNICipherMap UniAvailableCiphers[] = {
    // NULL cipher suite
    {
        // 0
        SSL3_NULL_WITH_NULL_NULL
    },

    // PCT ciphers
    { 
        // 1
        UNI_CK_PCT, 
            SP_PROT_PCT1,
            0,
            0, 0,
            SP_EXCH_UNKNOWN
    },
    { 
        // 2
        SSL_MKFAST(PCT_SSL_CERT_TYPE, MSBOF(PCT1_CERT_X509_CHAIN), LSBOF(PCT1_CERT_X509_CHAIN)), 
            SP_PROT_PCT1,
            0,
            0, 0,
            SP_EXCH_UNKNOWN
    },
    { 
        // 3
        SSL_MKFAST(PCT_SSL_CERT_TYPE, MSBOF(PCT1_CERT_X509), LSBOF(PCT1_CERT_X509)), 
            SP_PROT_PCT1,
            0,
            0, 0,
            SP_EXCH_UNKNOWN
    },
    { 
        // 4
        SSL_MKFAST(PCT_SSL_HASH_TYPE, MSBOF(PCT1_HASH_MD5), LSBOF(PCT1_HASH_MD5)), 
            SP_PROT_PCT1,
            CALG_MD5,
            0, 0,
            SP_EXCH_UNKNOWN
    },
    { 
        // 5
        SSL_MKFAST(PCT_SSL_HASH_TYPE, MSBOF(PCT1_HASH_SHA), LSBOF(PCT1_HASH_SHA)), 
            SP_PROT_PCT1,
            CALG_SHA,
            0, 0,
            SP_EXCH_UNKNOWN
    },
    { 
        // 6
        SSL_MKFAST(PCT_SSL_EXCH_TYPE, MSBOF(SP_EXCH_RSA_PKCS1),  LSBOF(SP_EXCH_RSA_PKCS1)), 
            SP_PROT_PCT1,
            0,
            0, 0,
            SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX
    },

    // SSL3 Domestic ciphers
    { 
        // 7
        SSL3_RSA_WITH_RC4_128_MD5, 
            SP_PROT_SSL3 | SP_PROT_TLS1,
            CALG_MD5 , 
            CALG_RC4 ,128 , 
            SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX,
            DOMESTIC_CIPHER_SUITE
    },
    { 
        // 8
        SSL3_RSA_WITH_RC4_128_SHA, 
            SP_PROT_SSL3 | SP_PROT_TLS1,
            CALG_SHA , 
            CALG_RC4 ,128 , 
            SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX, 
            DOMESTIC_CIPHER_SUITE
    },
    {
        // 9
        SSL3_RSA_WITH_3DES_EDE_CBC_SHA,
            SP_PROT_SSL3 | SP_PROT_TLS1,
            CALG_SHA,
            CALG_3DES ,168 ,
            SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX, 
            DOMESTIC_CIPHER_SUITE
    },
    {
        // 10
        SSL3_DHE_DSS_WITH_3DES_EDE_CBC_SHA,
            SP_PROT_SSL3 | SP_PROT_TLS1,
            CALG_SHA,
            CALG_3DES ,168 ,
            SP_EXCH_DH_PKCS3, CALG_DH_EPHEM,
            DOMESTIC_CIPHER_SUITE
    },

    // PCT Domestic ciphers
    { 
        // 12
        SSL_MKFAST(PCT_SSL_CIPHER_TYPE_1ST_HALF, MSBOF(PCT1_CIPHER_RC4>>16), LSBOF(PCT1_CIPHER_RC4>>16)),
            SP_PROT_PCT1,
            0,
            CALG_RC4 ,128 ,
            SP_EXCH_UNKNOWN, CALG_RSA_KEYX, 
            DOMESTIC_CIPHER_SUITE
    },
    { 
        // 13
        SSL_MKFAST(PCT_SSL_CIPHER_TYPE_2ND_HALF, MSBOF(PCT1_ENC_BITS_128), LSBOF(PCT1_MAC_BITS_128)), 
            SP_PROT_PCT1,
            0,
            CALG_RC4 ,128 ,
            SP_EXCH_UNKNOWN, CALG_RSA_KEYX, 
            DOMESTIC_CIPHER_SUITE
    }, 
    
    // SSL2 Domestic ciphers
    { 
        // 14
        SSL_CK_RC4_128_WITH_MD5, 
            SP_PROT_SSL2 , 
            CALG_MD5 , 
            CALG_RC4 ,128 , 
            SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX, 
            DOMESTIC_CIPHER_SUITE
    },
    { 
        // 15
        SSL_CK_DES_192_EDE3_CBC_WITH_MD5, 
            SP_PROT_SSL2 , 
            CALG_MD5 , 
            CALG_3DES ,168 , 
            SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX, 
            DOMESTIC_CIPHER_SUITE
    },
    { 
        // 16
        SSL_CK_RC2_128_CBC_WITH_MD5, 
            SP_PROT_SSL2 , 
            CALG_MD5 , 
            CALG_RC2 ,128 , 
            SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX, 
            DOMESTIC_CIPHER_SUITE
    },

    // SSL3 domestic DES ciphers
    { 
        // 22
        SSL3_RSA_WITH_DES_CBC_SHA, 
            SP_PROT_SSL3 | SP_PROT_TLS1,
            CALG_SHA , 
            CALG_DES , 56, 
            SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX, 
            DOMESTIC_CIPHER_SUITE
    },
    { 
        // 23
        SSL3_DHE_DSS_WITH_DES_CBC_SHA, 
            SP_PROT_SSL3 | SP_PROT_TLS1,
            CALG_SHA , 
            CALG_DES , 56 ,
            SP_EXCH_DH_PKCS3, CALG_DH_EPHEM, 
            DOMESTIC_CIPHER_SUITE
    },

    // SSL2 domestic DES ciphers
    { 
        // 24
        SSL_CK_DES_64_CBC_WITH_MD5, 
            SP_PROT_SSL2,
            CALG_MD5 , 
            CALG_DES , 56 , 
            SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX, 
            DOMESTIC_CIPHER_SUITE
    },

    // SSL3 56-bit export ciphers
    { 
        // 25
        TLS_RSA_EXPORT1024_WITH_RC4_56_SHA, 
            SP_PROT_SSL3 | SP_PROT_TLS1,
            CALG_SHA , 
            CALG_RC4 ,56 , 
            SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX, 
            EXPORT56_CIPHER_SUITE
    },
    { 
        // 26
        TLS_RSA_EXPORT1024_WITH_DES_CBC_SHA, 
            SP_PROT_SSL3 | SP_PROT_TLS1,
            CALG_SHA , 
            CALG_DES , 56, 
            SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX, 
            EXPORT56_CIPHER_SUITE
    },
    { 
        // 27
        TLS_DHE_DSS_EXPORT1024_WITH_DES_CBC_SHA, 
            SP_PROT_SSL3 | SP_PROT_TLS1,
            CALG_SHA , 
            CALG_DES , 56 ,
            SP_EXCH_DH_PKCS3, CALG_DH_EPHEM, 
            EXPORT56_CIPHER_SUITE
    },

    // SSL3 Export ciphers
    { 
        // 28
        SSL3_RSA_EXPORT_WITH_RC4_40_MD5, 
            SP_PROT_SSL3 | SP_PROT_TLS1,
            CALG_MD5 , 
            CALG_RC4 ,40 , 
            SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX, 
            EXPORT40_CIPHER_SUITE
    },
    { 
        // 29
        SSL3_RSA_EXPORT_WITH_RC2_CBC_40_MD5, 
            SP_PROT_SSL3 | SP_PROT_TLS1,
            CALG_MD5 , 
            CALG_RC2 ,40 , 
            SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX, 
            EXPORT40_CIPHER_SUITE
    },

    // PCT Export ciphers
    { 
        // 30
        SSL_MKFAST(PCT_SSL_CIPHER_TYPE_1ST_HALF, MSBOF(PCT1_CIPHER_RC4>>16), LSBOF(PCT1_CIPHER_RC4>>16)),  
            SP_PROT_PCT1,
            0,
            CALG_RC4 ,40 ,
            SP_EXCH_UNKNOWN, CALG_RSA_KEYX, 
            EXPORT40_CIPHER_SUITE
    },
    { 
        // 31
        SSL_MKFAST(PCT_SSL_CIPHER_TYPE_2ND_HALF, MSBOF(PCT1_ENC_BITS_40), LSBOF(PCT1_MAC_BITS_128)),  
            SP_PROT_PCT1,
            0,
            CALG_RC4 ,40 ,
            SP_EXCH_UNKNOWN, CALG_RSA_KEYX, 
            EXPORT40_CIPHER_SUITE
    },

    // SSL2 Export ciphers
    { 
        // 32
        SSL_CK_RC4_128_EXPORT40_WITH_MD5, 
            SP_PROT_SSL2 ,
            CALG_MD5 , 
            CALG_RC4 ,40 , 
            SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX, 
            EXPORT40_CIPHER_SUITE
    }, 
    { 
        // 33
        SSL_CK_RC2_128_CBC_EXPORT40_WITH_MD5, 
            SP_PROT_SSL2 ,
            CALG_MD5 , 
            CALG_RC2 ,40 , 
            SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX, 
            EXPORT40_CIPHER_SUITE
    }, 

    // SSL3 Zero privacy ciphers
    { 
        // 34
        SSL3_RSA_WITH_NULL_MD5, 
            SP_PROT_SSL3 | SP_PROT_TLS1,
            CALG_MD5 , 
            CALG_NULLCIPHER, 0, 
            SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX, 
            DOMESTIC_CIPHER_SUITE
    },
    { 
        // 35
        SSL3_RSA_WITH_NULL_SHA, 
            SP_PROT_SSL3 | SP_PROT_TLS1,
            CALG_SHA , 
            CALG_NULLCIPHER, 0, 
            SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX, 
            DOMESTIC_CIPHER_SUITE
    }
};

DWORD UniNumCiphers = sizeof(UniAvailableCiphers)/sizeof(UNICipherMap);



SP_STATUS WINAPI
GenerateSsl2StyleHello(
    PSPContext              pContext,
    PSPBuffer               pOutput,
    WORD                    fProtocol);


SP_STATUS
GetSupportedCapiAlgs(
    HCRYPTPROV          hProv,
    DWORD               dwCapiFlags,
    PROV_ENUMALGS_EX ** ppAlgInfo,
    DWORD *             pcAlgInfo)
{
    PROV_ENUMALGS_EX AlgInfo;
    DWORD   dwFlags;
    DWORD   cbData;
    DWORD   cAlgs;
    DWORD   i;

    *ppAlgInfo = NULL;
    *pcAlgInfo = 0;

    // Count the algorithms.
    dwFlags = CRYPT_FIRST;
    for(cAlgs = 0; ; cAlgs++)
    {
        cbData = sizeof(PROV_ENUMALGS_EX);
        if(!SchCryptGetProvParam(hProv, 
                                 PP_ENUMALGS_EX,
                                 (PBYTE)&AlgInfo,
                                 &cbData,
                                 dwFlags,
                                 dwCapiFlags))
        {
            if(GetLastError() != ERROR_NO_MORE_ITEMS)
            {
                SP_LOG_RESULT(GetLastError());
            }
            break;
        }
        dwFlags = 0;
    }
    if(cAlgs == 0)
    {
        return SP_LOG_RESULT(SEC_E_ALGORITHM_MISMATCH);
    }

    // Allocate memory.
    *ppAlgInfo = SPExternalAlloc(sizeof(PROV_ENUMALGS_EX) * cAlgs);
    if(*ppAlgInfo == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }

    // Read the algorithms.
    dwFlags = CRYPT_FIRST;
    for(i = 0; i < cAlgs; i++)
    {
        cbData = sizeof(PROV_ENUMALGS_EX);
        if(!SchCryptGetProvParam(hProv, 
                                 PP_ENUMALGS_EX,
                                 (PBYTE)(*ppAlgInfo + i),
                                 &cbData,
                                 dwFlags,
                                 dwCapiFlags))
        {
            if(GetLastError() != ERROR_NO_MORE_ITEMS)
            {
                SP_LOG_RESULT(GetLastError());
            }
            break;
        }
        dwFlags = 0;
    }
    if(i == 0)
    {
        SPExternalFree(*ppAlgInfo);
        *ppAlgInfo = NULL;

        LogNoCiphersSupportedEvent();
        return SP_LOG_RESULT(SEC_E_ALGORITHM_MISMATCH);
    }

    *pcAlgInfo = i;

    return PCT_ERR_OK;
}


SP_STATUS WINAPI
GenerateHello(
    PSPContext              pContext,
    PSPBuffer               pOutput,
    BOOL                    fCache)
{
    PSessCacheItem      pZombie;
    PSPCredentialGroup  pCred;
    BOOL                fFound;
    DWORD               fProt;

    if (!pOutput)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    if(fCache)
    {
        // Look this id up in the cache
        fFound = SPCacheRetrieveByName(pContext->pszTarget, 
                                       pContext->pCredGroup,
                                       &pContext->RipeZombie);
    }
    else
    {
        fFound = FALSE;
    }

    if(!fFound)
    {
        // We're doing a full handshake, so allocate a cache entry.
        if(!SPCacheRetrieveNew(FALSE,
                               pContext->pszTarget, 
                               &pContext->RipeZombie))
        {
            return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        }
        pContext->RipeZombie->dwCF = pContext->dwRequestedCF;
    }

    if(pContext->RipeZombie == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }
    pZombie = pContext->RipeZombie;

    pCred = pContext->pCredGroup;
    if(!pCred)   
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    // Use protocol from cache unless it's a new cache element, 
    // in which case use the protocol from credential.
    if(fFound)
    {
        fProt = pZombie->fProtocol;
    }
    else
    {
        fProt = pCred->grbitEnabledProtocols;
    }
    pContext->dwProtocol = fProt;
    pContext->dwClientEnabledProtocols = fProt;
    
    if(SP_PROT_UNI_CLIENT & fProt)
    {
        pContext->State             = UNI_STATE_CLIENT_HELLO;
        pContext->ProtocolHandler   = ClientProtocolHandler;

        return GenerateUniHello(pContext, pOutput, pCred->grbitEnabledProtocols);
    }

    else 
    if(SP_PROT_TLS1_CLIENT & fProt)
    {
        DWORD dwProtocol = SP_PROT_TLS1_CLIENT;

        pContext->State             = SSL3_STATE_CLIENT_HELLO;
        pContext->ProtocolHandler   = Ssl3ProtocolHandler;
        if(!fFound)
        {
            pZombie->fProtocol = SP_PROT_TLS1_CLIENT;
        }

        if(SP_PROT_SSL3_CLIENT & fProt)
        {
            // Both TLS and SSL3 are enabled.
            dwProtocol |= SP_PROT_SSL3_CLIENT;
        }

        return GenerateTls1ClientHello(pContext,  pOutput, dwProtocol);
    }

    else 
    if(SP_PROT_SSL3_CLIENT & fProt)
    {
        pContext->State             = SSL3_STATE_CLIENT_HELLO;
        pContext->ProtocolHandler   = Ssl3ProtocolHandler;
        if(!fFound)
        {
            pZombie->fProtocol = SP_PROT_SSL3_CLIENT;
        }

        return GenerateSsl3ClientHello(pContext,  pOutput);
    }

    else 
    if(SP_PROT_PCT1_CLIENT & fProt)
    {
        pContext->State             = PCT1_STATE_CLIENT_HELLO;
        pContext->ProtocolHandler   = Pct1ClientProtocolHandler;

        return GeneratePct1StyleHello(pContext, pOutput);
    }

    else 
    if(SP_PROT_SSL2_CLIENT & fProt)
    {
        pContext->State             = SSL2_STATE_CLIENT_HELLO;
        pContext->ProtocolHandler   = Ssl2ClientProtocolHandler;

        return GenerateUniHello(pContext, pOutput, SP_PROT_SSL2_CLIENT);
    } 
    else
    {
        return SP_LOG_RESULT(SEC_E_ALGORITHM_MISMATCH);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ClientVetAlg
//
//  Synopsis:   Examine the cipher suite input, and decide if it is currently
//              enabled. Take into account the enabled protocols and ciphers
//              enabled in the schannel registry as well as the protocols and
//              ciphers enabled by the application in the V3 credential. 
//              Return TRUE if the cipher suite is enabled.
//
//  Arguments:  [pContext]      --  Schannel context.
//
//              [dwProtocol]    --  Client protocols to be included in the
//                                  ClientHello message.
//
//              [pCipherMap]    --  Cipher suite to be examined.
//
//  History:    10-29-97   jbanes   Created
//
//  Notes:      This routine is called by the client-side only.
//
//----------------------------------------------------------------------------
BOOL
ClientVetAlg(
    PSPContext      pContext, 
    DWORD           dwProtocol, 
    UNICipherMap *  pCipherMap)
{
    PCipherInfo         pCipherInfo = NULL;
    PHashInfo           pHashInfo   = NULL;
    PKeyExchangeInfo    pExchInfo   = NULL;

    if((pCipherMap->fProt & dwProtocol) == 0)
    {
        return FALSE;
    }


    // Is cipher supported?
    if(pCipherMap->aiCipher != 0)
    {
        pCipherInfo = GetCipherInfo(pCipherMap->aiCipher, 
                                    pCipherMap->dwStrength);

        if(!IsCipherSuiteAllowed(pContext, 
                                 pCipherInfo, 
                                 dwProtocol,
                                 pContext->RipeZombie->dwCF,
                                 pCipherMap->dwFlags))
        {
            return FALSE;
        }
    }

    // Is hash supported?
    if(pCipherMap->aiHash != 0)
    {
        pHashInfo = GetHashInfo(pCipherMap->aiHash);

        if(!IsHashAllowed(pContext, pHashInfo, dwProtocol))
        {
            return FALSE;
        }
    }

    // Is exchange alg supported?
    if(pCipherMap->KeyExch != SP_EXCH_UNKNOWN)
    {
        pExchInfo = GetKeyExchangeInfo(pCipherMap->KeyExch);

        if(!IsExchAllowed(pContext, pExchInfo, dwProtocol))
        {
            return FALSE;
        }
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   ClientBuildAlgList
//
//  Synopsis:   Build a list of ciphers to be included in the ClientHello
//              message. This routine is used by all protocols.
//
//  Arguments:  [pContext]      --  Schannel context.
//
//              [fProtocol]     --  Protocol(s) to be included in the
//                                  ClientHello message.
//
//              [pCipherSpecs]  --  (out) Array where cipher specs are
//                                  placed.
//
//              [pcCipherSpecs] --  (out) Size of cipher specs array.
//
//  History:    10-29-97   jbanes   Created
//
//  Notes:      This routine is called by the client-side only.
//
//----------------------------------------------------------------------------
SP_STATUS
ClientBuildAlgList(
    PSPContext          pContext,
    DWORD               dwProtocol,
    Ssl2_Cipher_Kind *  pCipherSpecs,
    PDWORD              pcCipherSpecs)
{
    DWORD i;
    DWORD cCipherSpecs = 0;

    // Consider only the client protocols.
    dwProtocol &= SP_PROT_CLIENTS;


    //
    // Handle the RSA case.
    //

    if(g_hRsaSchannel && g_pRsaSchannelAlgs)
    {
        for(i = 0; i < UniNumCiphers; i++)
        {
            if(UniAvailableCiphers[i].KeyExch != SP_EXCH_RSA_PKCS1 &&
               UniAvailableCiphers[i].KeyExch != SP_EXCH_UNKNOWN) 
            {
                continue;
            }

            if(!ClientVetAlg(pContext, dwProtocol, UniAvailableCiphers + i))
            {
                continue;
            }

            if(!IsAlgSupportedCapi(dwProtocol, 
                                   UniAvailableCiphers + i,
                                   g_pRsaSchannelAlgs,
                                   g_cRsaSchannelAlgs))
            {
                continue;
            }

            // this cipher is good to request
            pCipherSpecs[cCipherSpecs++] = UniAvailableCiphers[i].CipherKind;
        }
    }


    //
    // Handle the DH case. 
    //

    if(g_hDhSchannelProv)
    {
        for(i = 0; i < UniNumCiphers; i++)
        {
            if(UniAvailableCiphers[i].KeyExch != SP_EXCH_DH_PKCS3) 
            {
                continue;
            }

            if(!ClientVetAlg(pContext, dwProtocol, UniAvailableCiphers + i))
            {
                continue;
            }

            if(!IsAlgSupportedCapi(dwProtocol, 
                                   UniAvailableCiphers + i,
                                   g_pDhSchannelAlgs,
                                   g_cDhSchannelAlgs))
            {
                continue;
            }

            // this cipher is good to request
            pCipherSpecs[cCipherSpecs++] = UniAvailableCiphers[i].CipherKind;
        }
    }


    if(cCipherSpecs == 0)
    {
        return SP_LOG_RESULT(PCT_INT_SPECS_MISMATCH);
    }

    *pcCipherSpecs = cCipherSpecs;

    return PCT_ERR_OK;
}



SP_STATUS WINAPI
GenerateUniHelloMessage(
    PSPContext              pContext,
    Ssl2_Client_Hello *     pHelloMessage,
    DWORD                   fProtocol
    )
{
    SP_STATUS   pctRet;
    UCHAR       bOffset = 2;

    SP_BEGIN("GenerateUniHelloMessage");


    if(!pHelloMessage)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }


    pContext->Flags |= CONTEXT_FLAG_CLIENT;


    // Generate the cipher list
    pHelloMessage->cCipherSpecs = MAX_UNI_CIPHERS;
    pctRet =  ClientBuildAlgList(pContext,
                                 fProtocol,
                                 pHelloMessage->CipherSpecs,
                                 &pHelloMessage->cCipherSpecs);
    if(pctRet != PCT_ERR_OK)
    {
        SP_RETURN(SP_LOG_RESULT(pctRet));
    }


    // We're minimally version 2
    pHelloMessage->dwVer = SSL2_CLIENT_VERSION;


    if(fProtocol & SP_PROT_TLS1_CLIENT)
    {
        pHelloMessage->dwVer = TLS1_CLIENT_VERSION;
    } 
    else if(fProtocol & SP_PROT_SSL3_CLIENT)
    {
        pHelloMessage->dwVer = SSL3_CLIENT_VERSION;
    } 

   /* Build the hello message. */
    pHelloMessage->cbSessionID = 0;

    if (pContext->RipeZombie && pContext->RipeZombie->cbSessionID)
    {
        KeyExchangeSystem *pKeyExchSys = NULL;

        // Get pointer to key exchange system.
        pKeyExchSys = KeyExchangeFromSpec(pContext->RipeZombie->SessExchSpec, 
                                          pContext->RipeZombie->fProtocol);
        if(pKeyExchSys)
        {
            // Request a reconnect.
            CopyMemory(pHelloMessage->SessionID, 
                       pContext->RipeZombie->SessionID,  
                       pContext->RipeZombie->cbSessionID);

            pHelloMessage->cbSessionID =  pContext->RipeZombie->cbSessionID;
        }
        else
        {
            DebugLog((DEB_WARN, "Abstaining from requesting reconnect\n"));
        }
    }

    CopyMemory(  pHelloMessage->Challenge,
                pContext->pChallenge,
                pContext->cbChallenge);
    pHelloMessage->cbChallenge = pContext->cbChallenge;

    SP_RETURN(PCT_ERR_OK);
}


SP_STATUS WINAPI
GenerateUniHello(
    PSPContext             pContext,
    PSPBuffer               pOutput,
    DWORD                   fProtocol
    )

{
    SP_STATUS pctRet;
    Ssl2_Client_Hello    HelloMessage;

    SP_BEGIN("GenerateUniHello");

    GenerateRandomBits( pContext->pChallenge, SSL2_CHALLENGE_SIZE );
    pContext->cbChallenge = SSL2_CHALLENGE_SIZE;

    pctRet = GenerateUniHelloMessage(pContext, &HelloMessage, fProtocol);
    
    pContext->ReadCounter = 0;

    if(PCT_ERR_OK != pctRet)
    {
        SP_RETURN(pctRet);
    }
    if(PCT_ERR_OK != (pctRet = Ssl2PackClientHello(&HelloMessage,  pOutput))) 
    {
        SP_RETURN(pctRet);
    }

    // Save the ClientHello message so we can hash it later, once
    // we know what algorithm and CSP we're using.
    if(pContext->pClientHello)
    {
        SPExternalFree(pContext->pClientHello);
    }
    pContext->pClientHello = SPExternalAlloc(pOutput->cbData);
    if(pContext->pClientHello == NULL)
    {
        SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
    }
    CopyMemory(pContext->pClientHello, pOutput->pvBuffer, pOutput->cbData);
    pContext->cbClientHello = pOutput->cbData;
    pContext->dwClientHelloProtocol = SP_PROT_SSL2_CLIENT;

    /* We set this here to tell the protocol engine that we just send a client
     * hello, and we're expecting a pct server hello */
    pContext->WriteCounter = 1;
    pContext->ReadCounter = 0;

    SP_RETURN(PCT_ERR_OK);
}

SP_STATUS WINAPI
ClientProtocolHandler(
    PSPContext pContext,
    PSPBuffer pCommInput,
    PSPBuffer pCommOutput)
{
    SP_STATUS pctRet = 0;
    PUCHAR pb;
    DWORD dwVersion;
    PSPCredentialGroup  pCred;

    pCred = pContext->pCredGroup;
    if(!pCred)   
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    /* PCTv1.0 Server Hello starts with
     * RECORD_LENGTH_MSB  (ignore)
     * RECORD_LENGTH_LSB  (ignore)
     * PCT1_SERVER_HELLO  (must be equal)
     * SH_PAD
     * PCT1_CLIENT_VERSION_MSB (must be pct1)
     * PCT1_CLIENT_VERSION_LSB (must be pct1) 
     *
     * ... PCT hello ...
     */


    /* SSLv2 Hello starts with
     * RECORD_LENGTH_MSB  (ignore)
     * RECORD_LENGTH_LSB  (ignore)
     * SSL2_SERVER_HELLO  (must be equal)
     * SESSION_ID_HIT
     * CERTIFICATE_TYPE
     * SSL2_CLIENT_VERSION_MSB (Must be ssl2)
     * SSL2_CLIENT_VERSION_LSB (Must be ssl2)
     *
     * ... SSLv2 Hello ...
     */


    /* SSLv3 Type 3 Server Hello starts with
     * 0x15 Hex (HANDSHAKE MESSAGE)
     * VERSION MSB
     * VERSION LSB
     * RECORD_LENGTH_MSB  (ignore)
     * RECORD_LENGTH_LSB  (ignore)
     * HS TYPE (SERVER_HELLO)
     * 3 bytes HS record length
     * HS Version
     * HS Version
     */

    // We need at least 12 bytes to determine what we have.
    if (pCommInput->cbData < 12)
    {
        return(PCT_INT_INCOMPLETE_MSG);
    }

    pb = pCommInput->pvBuffer;

    if(pb[0] == SSL3_CT_HANDSHAKE && pb[5] == SSL3_HS_SERVER_HELLO)
    {
        dwVersion = COMBINEBYTES(pb[9], pb[10]);

        if((dwVersion == SSL3_CLIENT_VERSION) && 
           (pCred->grbitEnabledProtocols & SP_PROT_SSL3_CLIENT))
        {
            // This appears to be an SSL3 server_hello.
            pContext->dwProtocol = SP_PROT_SSL3_CLIENT;
        }
        else if((dwVersion == TLS1_CLIENT_VERSION) && 
           (pCred->grbitEnabledProtocols & SP_PROT_TLS1_CLIENT))
        {
            // This appears to be a TLS server_hello.
            pContext->dwProtocol = SP_PROT_TLS1_CLIENT;
        }
        else
        {
            return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
        }

        pContext->ProtocolHandler = Ssl3ProtocolHandler;
        pContext->DecryptHandler  = Ssl3DecryptHandler;
        return(Ssl3ProtocolHandler(pContext, pCommInput, pCommOutput));
    }

    if(pb[2] == SSL2_MT_SERVER_HELLO)
    {
        dwVersion = COMBINEBYTES(pb[5], pb[6]);
        if(dwVersion == SSL2_CLIENT_VERSION) 
        {
            if(!(SP_PROT_SSL2_CLIENT & pCred->grbitEnabledProtocols))
            {
                return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
            }

            // This appears to be an SSL2 server_hello.
            pContext->dwProtocol      = SP_PROT_SSL2_CLIENT;
            pContext->ProtocolHandler = Ssl2ClientProtocolHandler;
            pContext->DecryptHandler  = Ssl2DecryptHandler;
            return(Ssl2ClientProtocolHandler(pContext, pCommInput, pCommOutput));
        }
    }
    if(pb[2] == PCT1_MSG_SERVER_HELLO)
    {
        DWORD i;
        dwVersion = COMBINEBYTES(pb[4], pb[5]);
        if(dwVersion ==PCT_VERSION_1) 
        {
            if(!(SP_PROT_PCT1_CLIENT & pCred->grbitEnabledProtocols))
            {
                return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
            }

            // Convert challenge from 16 byte to 32 byte
            for(i=0; i < pContext->cbChallenge; i++)
            {
                pContext->pChallenge[i + pContext->cbChallenge] = ~pContext->pChallenge[i];
            }
            pContext->cbChallenge = 2*pContext->cbChallenge;

            // This appears to be a PCT server_hello.
            pContext->dwProtocol      = SP_PROT_PCT1_CLIENT;
            pContext->ProtocolHandler = Pct1ClientProtocolHandler;
            pContext->DecryptHandler  = Pct1DecryptHandler;
            return(Pct1ClientProtocolHandler(pContext, pCommInput, pCommOutput));
        }
    }

    return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\spbase\context.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       context.c
//
//  Contents:   Schannel context management routines.
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   LSA integration stuff.
//
//----------------------------------------------------------------------------

#include <spbase.h>
#include <certmap.h>
#include <mapper.h>
#include <dsysdbg.h>

DWORD g_cContext = 0;

#if DBG
void DumpContexts(void);
static void AddContextToList(PSPContext pContext);
static void DeleteContextFromList(PSPContext pContext);
#endif

/************************************************************************
* SPContextCreate
*
* Create a new SPContext, and initialize it.
*
* Returns - PSPContext pointer to context object.
*
\***********************************************************************/

PSPContext SPContextCreate(LPWSTR pszTarget)
{

    PSPContext pContext;

    SP_BEGIN("SPContextCreate");

    pContext = (PSPContext)SPExternalAlloc( sizeof(SPContext));
    if(!pContext)
    {
        SP_RETURN(NULL);
    }

    DebugLog((DEB_TRACE, "Create context:0x%p\n", pContext));

    FillMemory(pContext, sizeof(SPContext), 0);

    pContext->Magic = SP_CONTEXT_MAGIC;
    pContext->Flags = 0;

    GenerateRandomThumbprint(&pContext->ContextThumbprint);

    if(pszTarget)
    {
        pContext->pszTarget = SPExternalAlloc((lstrlenW(pszTarget) + 1) * sizeof(WCHAR));
        if(pContext->pszTarget == NULL)
        {
            SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            SPExternalFree(pContext);
            SP_RETURN(NULL);
        }
        lstrcpyW(pContext->pszTarget, pszTarget);
    }


    pContext->dwRequestedCF = CF_EXPORT;

    if(SslGlobalStrongEncryptionPermitted)
    {
        pContext->dwRequestedCF |= CF_DOMESTIC;
    }

    pContext->fCertChainsAllowed = FALSE;


    g_cContext++;

    #if DBG
    //AddContextToList(pContext);
    #endif

    SP_RETURN(pContext);
}


/************************************************************************
* VOID SPContextClean(PSPContext pContext)
*
* Clean out everything used by the handshake (in case we want
* to do another).
*
\***********************************************************************/

BOOL
SPContextClean(PSPContext pContext)
{
    SP_BEGIN("SPContextClean");

    if(pContext == NULL || pContext->Magic != SP_CONTEXT_MAGIC) {
        DebugLog((DEB_WARN, "Attempt to delete invalid context\n"));
        SP_RETURN(FALSE);
    }

    if(pContext->pbEncryptedKey)
    {
        SPExternalFree(pContext->pbEncryptedKey);
        pContext->pbEncryptedKey = NULL;
    }

    if(pContext->pbServerKeyExchange)
    {
        SPExternalFree(pContext->pbServerKeyExchange);
        pContext->pbServerKeyExchange = NULL;
    }

    if(pContext->pbIssuerList)
    {
        SPExternalFree(pContext->pbIssuerList);
        pContext->pbIssuerList = NULL;
    }

    if(pContext->pClientHello)
    {
        SPExternalFree(pContext->pClientHello);
        pContext->pClientHello = NULL;
    }

    if((pContext->Flags & CONTEXT_FLAG_FULL_HANDSHAKE) &&
       (pContext->RipeZombie != NULL) &&
       (pContext->RipeZombie->pClientCred != NULL))
    {
        // We've just done a client-side full handshake in which a default
        // client certificate was selected. This client credential 
        // technically belongs to the cache (so that other contexts can
        // query the certificate etc) but we want to free up the 
        // application-process hProv now, while we're in the context
        // of the owning process.
        PSPCredential pClientCred = pContext->RipeZombie->pClientCred;

        if(pClientCred->hRemoteProv)
        {
            if(!RemoteCryptReleaseContext(
                                pClientCred->hRemoteProv,
                                0,
                                pClientCred->dwCapiFlags))
            {
                SP_LOG_RESULT(GetLastError());
            }
            pClientCred->hRemoteProv = 0;
        }
    }

    pContext->fExchKey = FALSE;

    SP_RETURN(TRUE);
}


/************************************************************************
* VOID SPDeleteContext(PSPContext pContext)
*
* Delete an existing context object.
*
\***********************************************************************/

BOOL
SPContextDelete(PSPContext pContext)
{
    SP_BEGIN("SPContextDelete");

    DebugLog((DEB_TRACE, "Delete context:0x%p\n", pContext));

    if(pContext == NULL || pContext->Magic != SP_CONTEXT_MAGIC)
    {
        DebugLog((DEB_WARN, "Attempt to delete invalid context\n"));
        SP_RETURN(FALSE);
    }

//    DsysAssert((pContext->pCredGroup->dwFlags & CRED_FLAG_DELETED) == 0);

    if(pContext->State != SP_STATE_CONNECTED &&
       pContext->State != SP_STATE_SHUTDOWN)
    {
        DebugLog((DEB_WARN, "Attempting to delete an incompleted context\n"));

        // The context is being deleted in the middle of a handshake, 
        // which is curious. This may be caused by the user aborting
        // an operation, or it may be caused by a reconfiguration of 
        // the remote computer that caused the reconnect attempt to
        // fail. If it's the latter cause, then the only way to recover
        // is to request a full handshake next time. We have no way 
        // of knowing which it is, so it's probably best that we kill 
        // the current cache  entry.
        if(pContext->RipeZombie)
        {
            pContext->RipeZombie->ZombieJuju = FALSE;
        }
    }

    SPContextClean(pContext);

    if(pContext->pszTarget)
    {
        SPExternalFree(pContext->pszTarget);
        pContext->pszTarget = NULL;
    }

    if(pContext->pszCredentialName)
    {
        SPExternalFree(pContext->pszCredentialName);
        pContext->pszCredentialName = NULL;
    }

    //
    // Delete session keys.
    //

    if(pContext->hReadKey)
    {
        if(pContext->pReadCipherInfo->aiCipher != CALG_SKIPJACK) 
        {
            SchCryptDestroyKey(pContext->hReadKey, 0);
            pContext->hReadKey = 0;
        }
    }
    if(pContext->hPendingReadKey)
    {
        if(pContext->pPendingCipherInfo->aiCipher != CALG_SKIPJACK)
        {
            SchCryptDestroyKey(pContext->hPendingReadKey, 0);
            pContext->hPendingReadKey = 0;
        }
    }
    if(pContext->hWriteKey)
    {
        if(pContext->pWriteCipherInfo->aiCipher != CALG_SKIPJACK)
        {
            SchCryptDestroyKey(pContext->hWriteKey, 0);
            pContext->hWriteKey = 0;
        }
    }
    if(pContext->hPendingWriteKey)
    {
        if(pContext->pPendingCipherInfo->aiCipher != CALG_SKIPJACK)
        {
            SchCryptDestroyKey(pContext->hPendingWriteKey, 0);
            pContext->hPendingWriteKey = 0;
        }
    }

    if(pContext->hReadMAC)
    {
        if(pContext->pReadCipherInfo->aiCipher != CALG_SKIPJACK) 
        {
            SchCryptDestroyKey(pContext->hReadMAC, 0);
            pContext->hReadMAC = 0;
        }
    }
    if(pContext->hPendingReadMAC)
    {
        if(pContext->pPendingCipherInfo->aiCipher != CALG_SKIPJACK)
        {
            SchCryptDestroyKey(pContext->hPendingReadMAC, 0);
            pContext->hPendingReadMAC = 0;
        }
    }
    if(pContext->hWriteMAC)
    {
        if(pContext->pWriteCipherInfo->aiCipher != CALG_SKIPJACK)
        {
            SchCryptDestroyKey(pContext->hWriteMAC, 0);
            pContext->hWriteMAC = 0;
        }
    }
    if(pContext->hPendingWriteMAC)
    {
        if(pContext->pPendingCipherInfo->aiCipher != CALG_SKIPJACK)
        {
            SchCryptDestroyKey(pContext->hPendingWriteMAC, 0);
            pContext->hPendingWriteMAC = 0;
        }
    }


    //
    // Delete the handshake hashes
    //

    if(pContext->hMd5Handshake)
    {
        SchCryptDestroyHash(pContext->hMd5Handshake, pContext->RipeZombie->dwCapiFlags);
        pContext->hMd5Handshake = 0;
    }
    if(pContext->hShaHandshake)
    {
        SchCryptDestroyHash(pContext->hShaHandshake, pContext->RipeZombie->dwCapiFlags);
        pContext->hShaHandshake = 0;
    }

    SPDereferenceCredential(pContext->pCredGroup);

    SPCacheDereference(pContext->RipeZombie);

    #if DBG
    //DeleteContextFromList(pContext);
    #endif

    FillMemory( pContext, sizeof( SPContext ), 0 );
    g_cContext--;

    SPExternalFree( pContext );
    SP_RETURN(TRUE);
}

/************************************************************************
* SPContext SPContextSetCredentials
*
* Associate a set of credentials with a context.
*
* Returns - PSPContext pointer to context object.
*
\***********************************************************************/
SP_STATUS
SPContextSetCredentials(
    PSPContext pContext,
    PSPCredentialGroup  pCred)
{
    DWORD cbThumbprint;
    BOOL fNewCredentials = FALSE;

    SP_BEGIN("SPContextSetCredentials");

    if(pContext->Magic != SP_CONTEXT_MAGIC)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

//    DsysAssert((pCred->dwFlags & CRED_FLAG_DELETED) == 0);


    //
    // Associate the credential group with the context.
    //

    if(pCred != pContext->pCredGroup)
    {
        if(pContext->pCredGroup)
        {
            SPDereferenceCredential(pContext->pCredGroup);
        }

        SPReferenceCredential(pCred);

        pContext->pCredGroup = pCred;

        fNewCredentials = TRUE;
    }


    //
    // Set the protocol.
    //

    if(pContext->State == SP_STATE_NONE)
    {
        switch(pCred->grbitProtocol)
        {
            case SP_PROT_UNI_CLIENT:
            case SP_PROT_UNI_SERVER:
            case SP_PROT_PCT1_CLIENT:
            case SP_PROT_PCT1_SERVER:
            case SP_PROT_SSL2_CLIENT:
            case SP_PROT_SSL2_SERVER:
            case SP_PROT_SSL3_CLIENT:
            case SP_PROT_SSL3_SERVER:
            case SP_PROT_TLS1_CLIENT:
            case SP_PROT_TLS1_SERVER:
                pContext->ProtocolHandler = ServerProtocolHandler;
                pContext->InitiateHello   = GenerateHello;
                break;

            default:
                SP_RETURN(SP_LOG_RESULT(PCT_INT_SPECS_MISMATCH));
        }
    }


    //
    // If the client application has supplied a new credential, then
    // attempt to choose a suitable client certificate to send to
    // the server.
    //

    if(fNewCredentials &&
       pContext->State == SSL3_STATE_GEN_SERVER_HELLORESP)
    {
        Ssl3CheckForExistingCred(pContext);
    }


    //
    // Allow the "manual cred validation" flag to be set from either
    // AcquireCredentialsHandle or InitializeSecurityContext.
    //

    if(pCred->dwFlags & CRED_FLAG_MANUAL_CRED_VALIDATION)
    {
        if((pContext->Flags & CONTEXT_FLAG_MUTUAL_AUTH) == 0)
        {
            pContext->Flags |= CONTEXT_FLAG_MANUAL_CRED_VALIDATION;
        }
    }

    SP_RETURN(PCT_ERR_OK);
}

SP_STATUS
ContextInitCiphersFromCache(SPContext *pContext)
{
    PSessCacheItem     pZombie;
    SP_STATUS           pctRet;

    pZombie = pContext->RipeZombie;

    pContext->pPendingCipherInfo = GetCipherInfo(pZombie->aiCipher, pZombie->dwStrength);
    pContext->pPendingHashInfo = GetHashInfo(pZombie->aiHash);
    pContext->pKeyExchInfo = GetKeyExchangeInfo(pZombie->SessExchSpec);

    pContext->dwPendingCipherSuiteIndex = pZombie->dwCipherSuiteIndex;

    if(!IsCipherAllowed(pContext,
                        pContext->pPendingCipherInfo,
                        pZombie->fProtocol,
                        pZombie->dwCF))
    {
        pContext->pPendingCipherInfo = NULL;
        return (SP_LOG_RESULT(PCT_INT_SPECS_MISMATCH));
    }

    // Load the pending hash structure
    pContext->pPendingHashInfo = GetHashInfo(pZombie->aiHash);

    if(!IsHashAllowed(pContext,
                      pContext->pPendingHashInfo,
                      pZombie->fProtocol))
    {
        pContext->pPendingHashInfo = NULL;
        return (SP_LOG_RESULT(PCT_INT_SPECS_MISMATCH));
    }

    // load the exch info structure
    pContext->pKeyExchInfo = GetKeyExchangeInfo(pZombie->SessExchSpec);
    if(!IsExchAllowed(pContext,
                      pContext->pKeyExchInfo,
                      pZombie->fProtocol))
    {
        pContext->pKeyExchInfo = NULL;
        return (SP_LOG_RESULT(PCT_INT_SPECS_MISMATCH));
    }


    // Determine the CSP to use, based on the key exchange algorithm.
    pctRet = DetermineClientCSP(pContext);
    if(pctRet != PCT_ERR_OK)
    {
        return SP_LOG_RESULT(PCT_ERR_SPECS_MISMATCH);
    }

#if DBG
    switch(pZombie->fProtocol)
    {
    case SP_PROT_PCT1_CLIENT:
        DebugLog((DEB_TRACE, "Protocol:PCT Client\n"));
        break;

    case SP_PROT_PCT1_SERVER:
        DebugLog((DEB_TRACE, "Protocol:PCT Server\n"));
        break;

    case SP_PROT_SSL2_CLIENT:
        DebugLog((DEB_TRACE, "Protocol:SSL2 Client\n"));
        break;

    case SP_PROT_SSL2_SERVER:
        DebugLog((DEB_TRACE, "Protocol:SSL2 Server\n"));
        break;

    case SP_PROT_SSL3_CLIENT:
        DebugLog((DEB_TRACE, "Protocol:SSL3 Client\n"));
        break;

    case SP_PROT_SSL3_SERVER:
        DebugLog((DEB_TRACE, "Protocol:SSL3 Server\n"));
        break;

    case SP_PROT_TLS1_CLIENT:
        DebugLog((DEB_TRACE, "Protocol:TLS Client\n"));
        break;

    case SP_PROT_TLS1_SERVER:
        DebugLog((DEB_TRACE, "Protocol:TLS Server\n"));
        break;

    default:
        DebugLog((DEB_TRACE, "Protocol:0x%x\n", pZombie->fProtocol));
    }

    DebugLog((DEB_TRACE, "Cipher:  %s\n", pContext->pPendingCipherInfo->szName));
    DebugLog((DEB_TRACE, "Strength:%d\n", pContext->pPendingCipherInfo->dwStrength));
    DebugLog((DEB_TRACE, "Hash:    %s\n", pContext->pPendingHashInfo->szName));
    DebugLog((DEB_TRACE, "Exchange:%s\n", pContext->pKeyExchInfo->szName));
#endif

    return PCT_ERR_OK;
}


SP_STATUS
DetermineClientCSP(PSPContext pContext)
{
    PSPCredential pCred = NULL;

    if(!(pContext->RipeZombie->fProtocol & SP_PROT_CLIENTS))
    {
        return PCT_ERR_OK;
    }

    if(pContext->RipeZombie->hMasterProv != 0)
    {
        return PCT_ERR_OK;
    }

    switch(pContext->pKeyExchInfo->Spec)
    {
        case SP_EXCH_RSA_PKCS1:
            pContext->RipeZombie->hMasterProv = g_hRsaSchannel;
            break;

        case SP_EXCH_DH_PKCS3:
            pContext->RipeZombie->hMasterProv = g_hDhSchannelProv;
            break;

        default:
            DebugLog((DEB_ERROR, "Appropriate Schannel CSP not available!\n"));
            pContext->RipeZombie->hMasterProv = 0;
            return SP_LOG_RESULT(PCT_ERR_SPECS_MISMATCH);
    }

    return PCT_ERR_OK;
}


SP_STATUS
ContextInitCiphers(
    SPContext *pContext,
    BOOL fRead,
    BOOL fWrite)
{
    SP_BEGIN("ContextInitCiphers");

    if((pContext == NULL) ||
        (pContext->RipeZombie == NULL))
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }


    pContext->pCipherInfo = pContext->pPendingCipherInfo;
    if ((NULL == pContext->pCipherInfo) || ((pContext->RipeZombie->fProtocol & pContext->pCipherInfo->fProtocol) == 0))
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_SPECS_MISMATCH));
    }

    pContext->pHashInfo = pContext->pPendingHashInfo;
    if ((NULL == pContext->pHashInfo)|| ((pContext->RipeZombie->fProtocol & pContext->pHashInfo->fProtocol) == 0))
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_SPECS_MISMATCH));
    }

    if (NULL == pContext->pKeyExchInfo)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_SPECS_MISMATCH));
    }

    if(fRead)
    {
        pContext->pReadCipherInfo = pContext->pPendingCipherInfo;
        pContext->pReadHashInfo   = pContext->pPendingHashInfo;
    }
    if(fWrite)
    {
        pContext->pWriteCipherInfo = pContext->pPendingCipherInfo;
        pContext->pWriteHashInfo   = pContext->pPendingHashInfo;
    }


    SP_RETURN(PCT_ERR_OK);
}


SP_STATUS
SPContextDoMapping(
    PSPContext pContext)
{
    PSessCacheItem     pZombie;
    PSPCredentialGroup  pCred;
    SP_STATUS           pctRet;
    LONG                iState;
    BOOL                fSuccess;
    LONG                iMapper;

    const SCH_MAPPER_DEFAULT_STATE   = 0;
    const SCH_MAPPER_NORMAL_STATE    = 1;

    SP_BEGIN("SPContextDoMapping");

    pZombie = pContext->RipeZombie;
    pCred   = pContext->RipeZombie->pServerCred;

    if(pCred->cMappers)
    {
        // Clear "called" flags.
        for(iMapper = 0; iMapper < pCred->cMappers; iMapper++)
        {
            pCred->pahMappers[iMapper]->m_dwFlags &= ~SCH_FLAG_MAPPER_CALLED;
        }
        pZombie->phMapper = NULL;


        for(iState = 0; iState < 2; iState++)
        {
            for(iMapper = 0; iMapper < pCred->cMappers; iMapper++)
            {
                if(pCred->pahMappers[iMapper]->m_dwFlags & SCH_FLAG_MAPPER_CALLED)
                {
                    // This mapper has already had its chance.
                    continue;
                }

                if(iState == SCH_MAPPER_DEFAULT_STATE)
                {
                    if(!(pCred->pahMappers[iMapper]->m_dwFlags & SCH_FLAG_DEFAULT_MAPPER))
                    {
                        continue;
                    }
                }

                if((pCred->dwFlags & CRED_FLAG_NO_SYSTEM_MAPPER) &&
                   (pCred->pahMappers[iMapper]->m_dwFlags & SCH_FLAG_SYSTEM_MAPPER))
                {
                    // Skip the system mapper.
                    DebugLog((DEB_TRACE, "Skip the system mapper\n"));
                    continue;
                }

#if DBG
                if(pCred->pahMappers[iMapper]->m_dwFlags & SCH_FLAG_SYSTEM_MAPPER)
                {
                    DebugLog((DEB_TRACE, "Invoke the system mapper\n"));
                }
                else
                {
                    DebugLog((DEB_TRACE, "Invoke the application mapper\n"));
                }
#endif

                // Invoke mapper.
                pctRet = SslMapCredential(
                                    pCred->pahMappers[iMapper],
                                    X509_ASN_CHAIN,
                                    pZombie->pRemoteCert,
                                    NULL,
                                    &pZombie->hLocator);

                pCred->pahMappers[iMapper]->m_dwFlags |= SCH_FLAG_MAPPER_CALLED;

                if(NT_SUCCESS(pctRet))
                {
                    // Mapping was successful.
                    DebugLog((DEB_TRACE, "Mapping was successful (0x%p)\n", pZombie->hLocator));

                    SslReferenceMapper(pCred->pahMappers[iMapper]);
                    if(pZombie->phMapper)
                    {
                        SslDereferenceMapper(pZombie->phMapper);
                    }
                    pZombie->phMapper = pCred->pahMappers[iMapper];
                    pZombie->LocatorStatus = SEC_E_OK;
                    break;
                }
                else
                {
                    // Mapping failed.
                    DebugLog((DEB_TRACE, "Mapping failed (0x%x)\n", pctRet));

                    pZombie->LocatorStatus = pctRet;
                }
            }

            if(pZombie->phMapper)
            {
                break;
            }
        }
    }

    SP_RETURN(PCT_ERR_OK);
}

SP_STATUS
RemoveDuplicateIssuers(
    PBYTE  pbIssuers,
    PDWORD pcbIssuers)
{
    DWORD cbIssuers = *pcbIssuers;
    DWORD cBlob;
    PCRYPT_DATA_BLOB rgBlob;
    DWORD cbIssuer;
    PBYTE pbIssuer;
    PBYTE pbSource, pbDest;
    DWORD i, j;


    if(pbIssuers == NULL || cbIssuers < 2)
    {
        return PCT_ERR_OK;
    }

    // Count number of issuers.
    cBlob = 0;
    pbIssuer = pbIssuers;
    while(pbIssuer + 1 < pbIssuers + cbIssuers)
    {
        cbIssuer = MAKEWORD(pbIssuer[1], pbIssuer[0]);

        pbIssuer += 2 + cbIssuer;
        cBlob++;
    }

    // Allocate memory for blob list.
    rgBlob = SPExternalAlloc(cBlob * sizeof(CRYPT_DATA_BLOB));
    if(rgBlob == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }

    // Build blob list.
    cBlob = 0;
    pbIssuer = pbIssuers;
    while(pbIssuer + 1 < pbIssuers + cbIssuers)
    {
        cbIssuer = MAKEWORD(pbIssuer[1], pbIssuer[0]);
        rgBlob[cBlob].cbData = 2 + cbIssuer;
        rgBlob[cBlob].pbData = pbIssuer;

        pbIssuer += 2 + cbIssuer;
        cBlob++;
    }

    // Mark duplicates.
    for(i = 0; i < cBlob; i++)
    {
        if(rgBlob[i].pbData == NULL) continue;

        for(j = i + 1; j < cBlob; j++)
        {
            if(rgBlob[j].pbData == NULL) continue;

            if(rgBlob[i].cbData == rgBlob[j].cbData &&
               memcmp(rgBlob[i].pbData, rgBlob[j].pbData, rgBlob[j].cbData) == 0)
            {
                // duplicate found
                rgBlob[j].pbData = NULL;
            }
        }
    }

    // Compact list.
    pbSource = pbIssuers;
    pbDest   = pbIssuers;
    for(i = 0; i < cBlob; i++)
    {
        if(rgBlob[i].pbData)
        {
            if(pbDest != pbSource)
            {
                MoveMemory(pbDest, pbSource, rgBlob[i].cbData);
            }
            pbDest += rgBlob[i].cbData;
        }
        pbSource += rgBlob[i].cbData;
    }
    *pcbIssuers = (DWORD)(pbDest - pbIssuers);

    // Free blob list.
    SPExternalFree(rgBlob);

    return PCT_ERR_OK;
}


SP_STATUS
SPContextGetIssuers(
    PSPCredentialGroup pCredGroup)
{
    LONG    i;
    PBYTE   pbIssuerList;
    DWORD   cbIssuerList;
    PBYTE   pbIssuer;
    DWORD   cbIssuer;
    PBYTE   pbNew;
    DWORD   Status;

    LockCredential(pCredGroup);

    if((pCredGroup->pbTrustedIssuers != NULL) && 
       !(pCredGroup->dwFlags & CRED_FLAG_UPDATE_ISSUER_LIST))
    {
        // Issuer list has already been built.
        Status = PCT_ERR_OK;
        goto cleanup;
    }


    // Free existing issuer list.
    if(pCredGroup->pbTrustedIssuers)
    {
        LocalFree(pCredGroup->pbTrustedIssuers);
        pCredGroup->pbTrustedIssuers = NULL;
        pCredGroup->cbTrustedIssuers = 0;
    }
    pCredGroup->dwFlags &= ~CRED_FLAG_UPDATE_ISSUER_LIST;


    //
    // Get issuers from application-specified ROOT store.
    //

    pbIssuerList  = NULL;
    cbIssuerList = 0;

    while(pCredGroup->hApplicationRoots)
    {
        Status = ExtractIssuerNamesFromStore(pCredGroup->hApplicationRoots,
                                             NULL, 
                                             &cbIssuerList);
        if(Status != PCT_ERR_OK)                                             
        {
            break;
        }

        pbIssuerList = LocalAlloc(LPTR, cbIssuerList);
        if(pbIssuerList == NULL)
        {
            break;
        }

        Status = ExtractIssuerNamesFromStore(pCredGroup->hApplicationRoots,
                                             pbIssuerList, 
                                             &cbIssuerList);
        if(Status != PCT_ERR_OK)                                             
        {
            LocalFree(pbIssuerList);
            pbIssuerList  = NULL;
            cbIssuerList = 0;
        }

        break;
    }


    //
    // Call each of the mappers in turn, building a large
    // list of all trusted issuers.
    //

    for(i = 0; i < pCredGroup->cMappers; i++)
    {
#if 0
        if((pCredGroup->dwFlags & CRED_FLAG_NO_SYSTEM_MAPPER) &&
           (pCredGroup->pahMappers[i]->m_dwFlags & SCH_FLAG_SYSTEM_MAPPER))
        {
            // Skip the system mapper.
            continue;
        }
#endif

        Status = SslGetMapperIssuerList(pCredGroup->pahMappers[i],
                                        &pbIssuer,
                                        &cbIssuer);
        if(!NT_SUCCESS(Status))
        {
            continue;
        }

        if(pbIssuerList == NULL)
        {
            pbIssuerList = LocalAlloc(LPTR, cbIssuer);
            if(pbIssuerList == NULL)
            {
                SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
                break;
            }
        }
        else
        {
            pbNew = LocalReAlloc(pbIssuerList, 
                                 cbIssuerList + cbIssuer,
                                 LMEM_MOVEABLE);
            if(pbNew == NULL)
            {
                SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
                break;
            }
            pbIssuerList = pbNew;
        }

        CopyMemory(pbIssuerList + cbIssuerList,
                   pbIssuer,
                   cbIssuer);

        cbIssuerList += cbIssuer;

        SPExternalFree(pbIssuer);
    }


    //
    // Remove duplicates from list.
    //

    if(pbIssuerList)
    {
        Status = RemoveDuplicateIssuers(pbIssuerList, &cbIssuerList);
        if(!NT_SUCCESS(Status))
        {
            LocalFree(pbIssuerList);
            goto cleanup;
        }
    }

    pCredGroup->cbTrustedIssuers = cbIssuerList;  // do not reverse these lines
    pCredGroup->pbTrustedIssuers = pbIssuerList;

    Status = PCT_ERR_OK;

cleanup:

    UnlockCredential(pCredGroup);

    return Status;
}


SP_STATUS
SPPickClientCertificate(
    PSPContext  pContext,
    DWORD       dwExchSpec)
{
    PSPCredentialGroup pCred;
    PSPCredential      pCurrentCred;
    SP_STATUS          pctRet;
    DWORD              i;

    pCred = pContext->pCredGroup;
    if((pCred == NULL) || (pCred->pCredList == NULL))
    {
        return SP_LOG_RESULT(PCT_ERR_SPECS_MISMATCH);
    }

    pContext->pActiveClientCred = NULL;

    pctRet = PCT_ERR_SPECS_MISMATCH;

    for(i = 0; i < pCred->cCredList; i++)
    {
        pCurrentCred = pCred->pCredList + i;

        if(pCurrentCred->pCert == NULL)
        {
            continue;
        }

        if(pCurrentCred->pPublicKey == NULL)
        {
            continue;
        }

        // Does this cert contain the proper key type.
        if(dwExchSpec != pCurrentCred->dwExchSpec)
        {
            continue;    // try the next cert.
        }

        // Does this cert have the proper encoding type?
        if(pCurrentCred->pCert->dwCertEncodingType != X509_ASN_ENCODING)
        {
            continue;
        }

        // WE FOUND ONE
        pContext->pActiveClientCred = pCurrentCred;

        pctRet = PCT_ERR_OK;
        break;
    }

    return pctRet;
}

SP_STATUS
SPPickServerCertificate(
    PSPContext  pContext,
    DWORD       dwExchSpec)
{
    PSPCredentialGroup pCred;
    PSPCredential      pCurrentCred;
    SP_STATUS          pctRet;
    DWORD              i;

    pCred = pContext->RipeZombie->pServerCred;
    if((pCred == NULL) || (pCred->pCredList == NULL))
    {
        return SP_LOG_RESULT(PCT_ERR_SPECS_MISMATCH);
    }

    DsysAssert((pContext->RipeZombie->dwFlags & SP_CACHE_FLAG_READONLY) == 0);

#if 0
    if(pContext->RipeZombie->dwFlags & SP_CACHE_FLAG_READONLY)
    {
        // What in the world causes this case to occur? Anything?

        // Don't mess with the current credentials.
        if(pContext->RipeZombie->pActiveServerCred == NULL)
        {
            return SP_LOG_RESULT(PCT_ERR_SPECS_MISMATCH);
        }
        else
        {
            return PCT_ERR_OK;
        }
    }
#endif

    pContext->RipeZombie->pActiveServerCred = NULL;

    pctRet = PCT_ERR_SPECS_MISMATCH;

    for(i = 0; i < pCred->cCredList; i++)
    {
        pCurrentCred = pCred->pCredList + i;

        if(pCurrentCred->pCert == NULL)
        {
            continue;
        }

        if(pCurrentCred->pPublicKey == NULL)
        {
            continue;
        }

        // Does this cert contain the proper key type.
        if(dwExchSpec != pCurrentCred->dwExchSpec)
        {
            continue;    // try the next cert.
        }

        // Does this cert have the proper encoding type?
        if(pCurrentCred->pCert->dwCertEncodingType != X509_ASN_ENCODING)
        {
            continue;
        }

        // WE FOUND ONE
        pContext->RipeZombie->pActiveServerCred = pCurrentCred;
        pContext->RipeZombie->CredThumbprint    = pCred->CredThumbprint;
        pContext->RipeZombie->CertThumbprint    = pCurrentCred->CertThumbprint;

        // Set "master" provider handle to current credential's. Note that
        // SSL3 will sometimes overide this selection in favor of its
        // ephemeral key pair.
        pContext->RipeZombie->hMasterProv = pCurrentCred->hProv;

        pctRet = PCT_ERR_OK;
        break;
    }

    return pctRet;
}


// This routine is called by the user process. It frees a context
// structure that was originally allocated by the LSA process,
// and passed over via the SPContextDeserialize routine.
BOOL
LsaContextDelete(PSPContext pContext)
{
    if(pContext)
    {
        if(pContext->hReadKey)
        {
            SchCryptDestroyKey(pContext->hReadKey, 0);
            pContext->hReadKey = 0;
        }
        if(pContext->hReadMAC)
        {
            SchCryptDestroyKey(pContext->hReadMAC, 0);
            pContext->hReadMAC = 0;
        }
        if(pContext->hWriteKey)
        {
            SchCryptDestroyKey(pContext->hWriteKey, 0);
            pContext->hWriteKey = 0;
        }
        if(pContext->hWriteMAC)
        {
            SchCryptDestroyKey(pContext->hWriteMAC, 0);
            pContext->hWriteMAC = 0;
        }

        // Close locator if this handle belongs to the system
        // default certificate mapper.
        if(pContext->RipeZombie)
        {
            if(pContext->RipeZombie->hLocator && pContext->RipeZombie->phMapper)
            {
                if(pContext->RipeZombie->phMapper->m_dwFlags & SCH_FLAG_SYSTEM_MAPPER)
                {
                    NtClose((HANDLE)pContext->RipeZombie->hLocator);
                    pContext->RipeZombie->hLocator = 0;
                }
            }

            if(pContext->RipeZombie->pbServerCertificate)
            {
                SPExternalFree(pContext->RipeZombie->pbServerCertificate);
                pContext->RipeZombie->pbServerCertificate = NULL;
            }
        }
    }
    return TRUE;
}


/*
 *
 * Misc Utility functions.
 *
 */



#if DBG
typedef struct _DbgMapCrypto {
    DWORD   C;
    PSTR    psz;
} DbgMapCrypto;

DbgMapCrypto    DbgCryptoNames[] = { {CALG_RC4, "RC4 "},
};

CHAR    DbgNameSpace[100];
PSTR    DbgAlgNames[] = { "Basic RSA", "RSA with MD2", "RSA with MD5", "RC4 stream"};
#define AlgName(x) ((x < sizeof(DbgAlgNames) / sizeof(PSTR)) ? DbgAlgNames[x] : "Unknown")

PSTR
DbgGetNameOfCrypto(DWORD x)
{
    int i;
    for (i = 0; i < sizeof(DbgCryptoNames) / sizeof(DbgMapCrypto) ; i++ )
    {
        if (x  == DbgCryptoNames[i].C)
        {
            wsprintf(DbgNameSpace, "%s",
                    (DbgCryptoNames[i].psz));
            return DbgNameSpace;
        }
    }

    return("Unknown");
}
#endif


#if 0
PSTR
CopyString(
           PSTR        pszString)
{
    PSTR    pszNewString;
    DWORD   cchString;

    cchString = lstrlen(pszString) + 1;

    pszNewString = (PSTR)SPExternalAlloc(cchString);

    if (pszNewString)
    {
        CopyMemory(pszNewString, pszString, cchString);
    }

    return(pszNewString);
}
#endif



#ifdef LTS

int __cdecl memcmp (
        const void * buf1,
        const void * buf2,
        size_t count
        )
{
        if (!count)
                return(0);

        while ( --count && *(char *)buf1 == *(char *)buf2 ) {
                buf1 = (char *)buf1 + 1;
                buf2 = (char *)buf2 + 1;
        }

        return( *((unsigned char *)buf1) - *((unsigned char *)buf2) );
}

#endif

#if DBG
typedef struct _CONTEXTLIST {
    struct _CONTEXTLIST *pNext;
    PSPContext           pContext;
} CONTEXTLIST, *PCONTEXTLIST;

PCONTEXTLIST g_ContextList = NULL;

static void AddContextToList(PSPContext pContext)
{
    PCONTEXTLIST pNew = LocalAlloc(LMEM_FIXED, sizeof(CONTEXTLIST));
    pNew->pNext = g_ContextList;
    pNew->pContext = pContext;
    g_ContextList = pNew;
}

static void DeleteContextFromList(PSPContext pContext)
{
    PCONTEXTLIST pItem, pPrevItem;
    BOOL fFound = FALSE;

    if(g_ContextList == NULL)
    {
        DebugLog((DEB_ERROR, "List is empty!\n"));
    }
    else if(g_ContextList->pContext == pContext)
    {
        // Delete first item in list
        g_ContextList = g_ContextList->pNext;
        fFound = TRUE;
    }
    else
    {
        pPrevItem = g_ContextList;

        for(pItem = g_ContextList->pNext; pItem; pItem = pItem->pNext)
        {
            if(pItem->pContext == pContext)
            {
                pPrevItem->pNext = pItem->pNext;
                LocalFree(pItem);
                fFound = TRUE;
                break;
            }
            pPrevItem = pItem;
        }
    }

    if(!fFound)
    {
        DebugLog((DEB_ERROR, "Unknown context 0x%p\n", pContext));
    }
}

void DumpContexts(void)
{
    PCONTEXTLIST pItem;
    DWORD dwCount = 0;

    SP_BEGIN("DumpContexts");

    for(pItem = g_ContextList; pItem; pItem = pItem->pNext)
    {
        dwCount++;

        DebugLog((DEB_TRACE, "Context:%8x, Cache:%8x\n",
            pItem->pContext,
            pItem->pContext->RipeZombie));
    }

    if(dwCount != g_cContext)
    {
        DebugLog((DEB_ERROR, "Context count discrepancy %d vs. %d\n",
            dwCount,
            g_cContext));
    }

    SP_END();
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\spbase\debug.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       debug.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:
//
//----------------------------------------------------------------------------

#include <spbase.h>
#include <alloca.h>

HANDLE g_hfLogFile = NULL;

#if DBG         /* NOTE:  This file not compiled for retail builds */

#include <stdio.h>
#include <stdarg.h>

#define WINDEBUG

#ifndef min
#define min(x,y) ((x)<(y)?(x):(y))
#endif

DWORD   g_dwInfoLevel  = 0;
DWORD   g_dwDebugBreak = 0;
DWORD   PctTraceIndent = 0;


#define MAX_DEBUG_BUFFER 2048

void
BuildDebugHeader(
    DWORD   Mask,
    PSTR    pszHeader,
    PDWORD  pcbHeader);

void
SPDebugOutput(char *szOutString)
{
    DWORD dwWritten;

    if (NULL != g_hfLogFile)
    {
        WriteFile(
            g_hfLogFile,
            szOutString,
            lstrlen(szOutString),
            &dwWritten,
            NULL);
    }
    OutputDebugStringA(szOutString);
}


void
DbgDumpHexString(const unsigned char *String, DWORD cbString)
{
    DWORD i,count;
    CHAR digits[]="0123456789abcdef";
    CHAR pbLine[MAX_PATH];
    DWORD cbLine, cbHeader;
    DWORD_PTR address;

    BuildDebugHeader(DEB_BUFFERS, pbLine, &cbHeader);

    if(String == NULL && cbString != 0)
    {
        strcat(pbLine, "<null> buffer!!!\n"); 
        SPDebugOutput(pbLine);
        return;
    }

    for(; cbString ; cbString -= count, String += count)
    {
        count = (cbString > 16) ? 16:cbString;

        cbLine = cbHeader;

        address = (DWORD_PTR)String;

#if defined(_WIN64)

        pbLine[cbLine++] = digits[(address >> 0x3c) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x38) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x34) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x30) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x2c) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x28) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x24) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x20) & 0x0f];

#endif

        pbLine[cbLine++] = digits[(address >> 0x1c) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x18) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x14) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x10) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x0c) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x08) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x04) & 0x0f];
        pbLine[cbLine++] = digits[(address        ) & 0x0f];
        pbLine[cbLine++] = ' ';
        pbLine[cbLine++] = ' ';

        for(i = 0; i < count; i++)
        {
            pbLine[cbLine++] = digits[String[i]>>4];
            pbLine[cbLine++] = digits[String[i]&0x0f];
            if(i == 7)
            {
                pbLine[cbLine++] = ':';
            }
            else
            {
                pbLine[cbLine++] = ' ';
            }
        }

        #if 1
        for(; i < 16; i++)
        {
            pbLine[cbLine++] = ' ';
            pbLine[cbLine++] = ' ';
            pbLine[cbLine++] = ' ';
        }

        pbLine[cbLine++] = ' ';

        for(i = 0; i < count; i++)
        {
            if(String[i] < 32 || String[i] > 126)
            {
                pbLine[cbLine++] = '.';
            }
            else
            {
                pbLine[cbLine++] = String[i];
            }
        }
        #endif

        pbLine[cbLine++] = '\n';
        pbLine[cbLine++] = 0;

        SPDebugOutput(pbLine);
    }
}


char *aszSPDebugLevel[] = {
    "Error  ",
    "Warning",
    "Trace  ",
    "Mem    ",
    "Result "
};

void
BuildDebugHeader(
    DWORD   Mask,
    PSTR    pszHeader,
    PDWORD  pcbHeader)
{
    SYSTEMTIME  stTime;
    DWORD       Level = 0;
    ULONG       ClientProcess;
    ULONG       ClientThread;

    GetLocalTime(&stTime);

    Level = 0;
    while (!(Mask & 1))
    {
        Level++;
        Mask >>= 1;
    }
    if (Level >= sizeof(aszSPDebugLevel) / sizeof(char *))
    {
        Level = sizeof(aszSPDebugLevel) / sizeof(char *) - 1;
    }

    SslGetClientProcess(&ClientProcess);
    SslGetClientThread(&ClientThread);

    *pcbHeader = 0;

    if(g_dwInfoLevel & SP_LOG_TIMESTAMP)
    {
        *pcbHeader = wsprintf(
                        pszHeader,
                        "[%2d/%2d %02d:%02d:%02d.%03d] %d.%d> %s: ",
                        stTime.wMonth, stTime.wDay,
                        stTime.wHour, stTime.wMinute, stTime.wSecond, 
                        stTime.wMilliseconds,
                        ClientProcess, ClientThread,
                        aszSPDebugLevel[Level]);
    }
    else
    {
        *pcbHeader = wsprintf(
                        pszHeader,
                        "%d.%d> %s: ",
                        ClientProcess, ClientThread,
                        aszSPDebugLevel[Level]);
    }
}

void
SPDebugLog(long Mask, const char *Format, ...)
{
    va_list ArgList;
    int     PrefixSize = 0;
    int     iOut;
    char    szOutString[MAX_DEBUG_BUFFER];
    long    OriginalMask = Mask;

    if (Mask & g_dwInfoLevel)
    {
        BuildDebugHeader(Mask, szOutString, &iOut);

        PrefixSize = min(60, PctTraceIndent * 3);
        FillMemory(szOutString+iOut, PrefixSize, ' ');
        PrefixSize += iOut;
        szOutString[PrefixSize] = '\0';

        va_start(ArgList, Format);

        if (wvsprintf(&szOutString[PrefixSize], Format, ArgList) < 0)
        {
            static char szOverFlow[] = "\n<256 byte OVERFLOW!>\n";

            // Less than zero indicates that the string would not fit into the
            // buffer.  Output a special message indicating overflow.

            lstrcpy(
            &szOutString[sizeof(szOutString) - sizeof(szOverFlow)],
            szOverFlow);
        }
        va_end(ArgList);
        SPDebugOutput(szOutString);
    }
}

void
SPLogDistinguishedName(
    DWORD LogLevel,
    LPSTR pszLabel,
    PBYTE pbName,
    DWORD cbName)
{
    CERT_NAME_BLOB Name;
    LPSTR pszName;
    DWORD cchName;

    Name.pbData = pbName;
    Name.cbData = cbName;
    
    cchName = CertNameToStr(CRYPT_ASN_ENCODING,
                            &Name,
                            CERT_X500_NAME_STR | CERT_NAME_STR_NO_PLUS_FLAG,
                            NULL,
                            0);
    if(cchName == 0)
    {
        return;
    }

    SafeAllocaAllocate(pszName, cchName);

    if(pszName == NULL)
    {
        return;
    }

    cchName = CertNameToStr(CRYPT_ASN_ENCODING,
                            &Name,
                            CERT_X500_NAME_STR | CERT_NAME_STR_NO_PLUS_FLAG,
                            pszName,
                            cchName);

    if(cchName == 0)
    {
        SafeAllocaFree(pszName);
        return;
    }

    DebugLog((LogLevel, pszLabel, pszName));

    SafeAllocaFree(pszName);
}

long
SPLogErrorCode(
    long err,
    const char *szFile,
    long lLine)
{
    char *szName = "Unknown";

    switch(err)
    {
    case PCT_ERR_OK:                     szName = "PCT_ERR_OK";                     break;
    case PCT_ERR_BAD_CERTIFICATE:        szName = "PCT_ERR_BAD_CERTIFICATE";        break;
    case PCT_ERR_CLIENT_AUTH_FAILED:     szName = "PCT_ERR_CLIENT_AUTH_FAILED";     break;
    case PCT_ERR_ILLEGAL_MESSAGE:        szName = "PCT_ERR_ILLEGAL_MESSAGE";        break;
    case PCT_ERR_INTEGRITY_CHECK_FAILED: szName = "PCT_ERR_INTEGRITY_CHECK_FAILED"; break;
    case PCT_ERR_SERVER_AUTH_FAILED:     szName = "PCT_ERR_SERVER_AUTH_FAILED";     break;
    case PCT_ERR_SPECS_MISMATCH:         szName = "PCT_ERR_SPECS_MISMATCH";         break;
    case PCT_ERR_SSL_STYLE_MSG:          szName = "PCT_ERR_SSL_STYLE_MSG";          break;
    case PCT_ERR_RENEGOTIATE:            szName = "PCT_ERR_RENEGOTIATE";            break;
    case PCT_ERR_UNKNOWN_CREDENTIAL:     szName = "PCT_ERR_UNKNOWN_CREDENTIAL";     break;

    case PCT_INT_BUFF_TOO_SMALL:         szName = "PCT_INT_BUFF_TOO_SMALL";         break;
    case PCT_INT_INCOMPLETE_MSG:         szName = "PCT_INT_INCOMPLETE_MSG";         break;
    case PCT_INT_DROP_CONNECTION:        szName = "PCT_INT_DROP_CONNECTION";        break;
    case PCT_INT_BAD_CERT:               szName = "PCT_INT_BAD_CERT";               break;
    case PCT_INT_CLI_AUTH:               szName = "PCT_INT_CLI_AUTH";               break;
    case PCT_INT_ILLEGAL_MSG:            szName = "PCT_INT_ILLEGAL_MSG";            break;
    case PCT_INT_MSG_ALTERED:            szName = "PCT_INT_MSG_ALTERED";            break;
    case PCT_INT_INTERNAL_ERROR:         szName = "PCT_INT_INTERNAL_ERROR";         break;
    case PCT_INT_DATA_OVERFLOW:          szName = "PCT_INT_DATA_OVERFLOW";          break;
    case PCT_INT_SPECS_MISMATCH:         szName = "PCT_INT_SPECS_MISMATCH";         break;
    case PCT_INT_RENEGOTIATE:            szName = "PCT_INT_RENEGOTIATE";            break;
    case PCT_INT_UNKNOWN_CREDENTIAL:     szName = "PCT_INT_UNKNOWN_CREDENTIAL";     break;

    case SEC_E_INSUFFICIENT_MEMORY:         szName = "SEC_E_INSUFFICIENT_MEMORY";       break;
    case SEC_E_INVALID_HANDLE:              szName = "SEC_E_INVALID_HANDLE";            break;
    case SEC_E_UNSUPPORTED_FUNCTION:        szName = "SEC_E_UNSUPPORTED_FUNCTION";      break;
    case SEC_E_TARGET_UNKNOWN:              szName = "SEC_E_TARGET_UNKNOWN";            break;
    case SEC_E_INTERNAL_ERROR:              szName = "SEC_E_INTERNAL_ERROR";            break;
    case SEC_E_SECPKG_NOT_FOUND:            szName = "SEC_E_SECPKG_NOT_FOUND";          break;
    case SEC_E_NOT_OWNER:                   szName = "SEC_E_NOT_OWNER";                 break;
    case SEC_E_CANNOT_INSTALL:              szName = "SEC_E_CANNOT_INSTALL";            break;
    case SEC_E_INVALID_TOKEN:               szName = "SEC_E_INVALID_TOKEN";             break;
    case SEC_E_CANNOT_PACK:                 szName = "SEC_E_CANNOT_PACK";               break;
    case SEC_E_QOP_NOT_SUPPORTED:           szName = "SEC_E_QOP_NOT_SUPPORTED";         break;
    case SEC_E_NO_IMPERSONATION:            szName = "SEC_E_NO_IMPERSONATION";          break;
    case SEC_E_LOGON_DENIED:                szName = "SEC_E_LOGON_DENIED";              break;
    case SEC_E_UNKNOWN_CREDENTIALS:         szName = "SEC_E_UNKNOWN_CREDENTIALS";       break;
    case SEC_E_NO_CREDENTIALS:              szName = "SEC_E_NO_CREDENTIALS";            break;
    case SEC_E_MESSAGE_ALTERED:             szName = "SEC_E_MESSAGE_ALTERED";           break;
    case SEC_E_OUT_OF_SEQUENCE:             szName = "SEC_E_OUT_OF_SEQUENCE";           break;
    case SEC_E_NO_AUTHENTICATING_AUTHORITY: szName = "SEC_E_NO_AUTHENTICATING_AUTHORITY";  break;
    case SEC_I_CONTINUE_NEEDED:             szName = "SEC_I_CONTINUE_NEEDED";           break;
    case SEC_I_COMPLETE_NEEDED:             szName = "SEC_I_COMPLETE_NEEDED";           break;
    case SEC_I_COMPLETE_AND_CONTINUE:       szName = "SEC_I_COMPLETE_AND_CONTINUE";     break;
    case SEC_I_LOCAL_LOGON:                 szName = "SEC_I_LOCAL_LOGON";               break;
    case SEC_E_BAD_PKGID:                   szName = "SEC_E_BAD_PKGID";                 break;
    case SEC_E_CONTEXT_EXPIRED:             szName = "SEC_E_CONTEXT_EXPIRED";           break;
    case SEC_E_INCOMPLETE_MESSAGE:          szName = "SEC_E_INCOMPLETE_MESSAGE";        break;
    case SEC_E_INCOMPLETE_CREDENTIALS:      szName = "SEC_E_INCOMPLETE_CREDENTIALS";    break;
    case SEC_E_BUFFER_TOO_SMALL:            szName = "SEC_E_BUFFER_TOO_SMALL";          break;
    case SEC_I_INCOMPLETE_CREDENTIALS:      szName = "SEC_I_INCOMPLETE_CREDENTIALS";    break;
    case SEC_I_RENEGOTIATE:                 szName = "SEC_I_RENEGOTIATE";               break;
    case SEC_E_WRONG_PRINCIPAL:             szName = "SEC_E_WRONG_PRINCIPAL";           break;
    case SEC_I_NO_LSA_CONTEXT:              szName = "SEC_I_NO_LSA_CONTEXT";            break;

    case CERT_E_EXPIRED:                    szName = "CERT_E_EXPIRED";                  break;
    case CERT_E_UNTRUSTEDROOT:              szName = "CERT_E_UNTRUSTEDROOT";            break;
    case CRYPT_E_REVOKED:                   szName = "CRYPT_E_REVOKED";                 break;
    case CRYPT_E_NO_REVOCATION_CHECK:       szName = "CRYPT_E_NO_REVOCATION_CHECK";     break;
    case CRYPT_E_REVOCATION_OFFLINE:        szName = "CRYPT_E_REVOCATION_OFFLINE";      break;

    }

    SPDebugLog(SP_LOG_RES, "Result: %s (0x%lx) - %s, Line %d\n", szName, err, szFile, lLine);

    return err;
}

#pragma warning(disable:4206)   /* Disable the empty translation unit */
                /* warning/error */

void
SPAssert(
    void * FailedAssertion,
    void * FileName,
    unsigned long LineNumber,
    char * Message)
{

    SPDebugLog(SP_LOG_ERROR,
               "Assertion FAILED, %s, %s : %d\n",
               FailedAssertion,
               FileName,
               LineNumber);
    DebugBreak();
}


VOID *
DBGAllocMem(DWORD cb, LPSTR szFile, DWORD iLine)
{
    VOID *pv;
    DWORD cbTotal = cb;

    pv = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, cbTotal);
    if(pv == NULL)
    {
        SPDebugLog(SP_LOG_ERROR,
                    "Local Alloc Failed: %s, %d\n",
                    szFile,
                    iLine);
                    DebugBreak();
    }

    return(pv);
}


VOID
DBGFreeMem(VOID *pv, LPSTR szFile, DWORD iLine)
{
    PVOID pvLocal = pv;

    LocalFree(pvLocal);

}



#endif /* DBG */ /* NOTE:  This file not compiled for retail builds */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\spbase\defcreds.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Widows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       defcreds.c
//
//  Contents:   Routines for acquiring default credentials.
//
//  Classes:
//
//  Functions:
//
//  History:    12-05-97   jbanes   Created.
//
//----------------------------------------------------------------------------

#include <spbase.h>
#include <softpub.h>

void
GetImplementationType(
    PCCERT_CONTEXT pCertContext,
    PDWORD pdwImpType);


NTSTATUS
AssignNewClientCredential(
    PSPContext      pContext,
    PCCERT_CONTEXT  pCertContext,
    BOOL            fPromptNow)
{
    PSPCredential   pCred = NULL;
    NTSTATUS        Status;
    BOOL            fEventLogged;
    LSA_SCHANNEL_SUB_CRED SubCred;

    //
    // Does this certificate have an acceptable public key type?
    //

    {
        BOOL    fFound;
        DWORD   dwKeyType;
        DWORD   i;

        fFound    = FALSE;
        dwKeyType = MapOidToCertType(pCertContext->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId);

        for(i = 0; i < pContext->cSsl3ClientCertTypes; i++)
        {
            if(pContext->Ssl3ClientCertTypes[i] == dwKeyType)
            {
                fFound = TRUE;
                break;
            }
        }
        if(!fFound)
        {
            // Don't use this certificate.
            Status = SP_LOG_RESULT(PCT_INT_UNKNOWN_CREDENTIAL);
            goto cleanup;
        }
    }


    //
    // Build a credential structure for the certificate.
    //

    pCred = SPExternalAlloc(sizeof(SPCredential));
    if(pCred == NULL)
    {
        Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto cleanup;
    }

    memset(&SubCred, 0, sizeof(SubCred));

    SubCred.pCert  = pCertContext;

    Status = SPCreateCred(pContext->dwProtocol,
                          &SubCred,
                          pCred,
                          &fEventLogged);
    if(Status != PCT_ERR_OK)
    {
        goto cleanup;
    }


    //
    // Release the existing credential, if one exists.
    //

    if(pContext->RipeZombie->pClientCred)
    {
        SPDeleteCred(pContext->RipeZombie->pClientCred);
        pContext->RipeZombie->pClientCred = NULL;
    }


    //
    // Assign the credential to the cache element.
    //

    pContext->RipeZombie->pClientCred = pCred;
    pContext->pActiveClientCred       = pCred;

    if(fPromptNow == FALSE)
    {
        pContext->RipeZombie->dwFlags |= SP_CACHE_FLAG_USE_VALIDATED;
    }

    Status = PCT_ERR_OK;


cleanup:

    if(pCred && Status != PCT_ERR_OK)
    {
        SPDeleteCred(pCred);
    }

    return Status;
}

NTSTATUS
QueryCredentialManagerForCert(
    PSPContext          pContext,
    LPWSTR              pszTarget)
{
    PCCERT_CONTEXT      pCertContext = NULL;
    LUID                LogonId;
    PENCRYPTED_CREDENTIALW pCredential = NULL;
    BOOL                fImpersonating = FALSE;
    CRYPT_HASH_BLOB     HashBlob;
    NTSTATUS            Status;
    HCERTSTORE          hStore = 0;
    PCERT_CREDENTIAL_INFO pCertInfo = NULL;
    CRED_MARSHAL_TYPE   CredType;

    //
    // Obtain client logon id.
    //

    Status = SslGetClientLogonId(&LogonId);

    if(!NT_SUCCESS(Status))
    {
        SP_LOG_RESULT(Status);
        goto cleanup;
    }

    fImpersonating = SslImpersonateClient();


    //
    // Query the credential manager for a certificate.
    //

    Status = LsaTable->CrediRead(&LogonId,
                                 CREDP_FLAGS_IN_PROCESS,
                                 pszTarget,
                                 CRED_TYPE_DOMAIN_CERTIFICATE,
                                 0,
                                 &pCredential);
    if(!NT_SUCCESS(Status))
    {
        if(Status == STATUS_NOT_FOUND)
        {
            DebugLog((DEB_WARN, "No certificate found in credential manager.\n"));
        }
        else
        {
            SP_LOG_RESULT(Status);
        }
        goto cleanup;
    }


    //
    // Extract the certificate thumbprint and (optional) PIN.
    //

    if(!CredIsMarshaledCredentialW(pCredential->Cred.UserName))
    {
        Status = SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
        goto cleanup;
    }

    if(!CredUnmarshalCredentialW(pCredential->Cred.UserName,
                                 &CredType,
                                 &pCertInfo))
    {
        Status = SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
        goto cleanup;
    }
    if(CredType != CertCredential)
    {
        Status = SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
        goto cleanup;
    }


    //
    // Look up the certificate in the MY certificate store.
    //

    hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
                           X509_ASN_ENCODING, 0,
                           CERT_SYSTEM_STORE_CURRENT_USER |
                           CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
                           L"MY");
    if(!hStore)
    {
        SP_LOG_RESULT(GetLastError());
        Status = SEC_E_NO_CREDENTIALS;
        goto cleanup;
    }


    HashBlob.cbData = sizeof(pCertInfo->rgbHashOfCert);
    HashBlob.pbData = pCertInfo->rgbHashOfCert;

    pCertContext = CertFindCertificateInStore(hStore,
                                              X509_ASN_ENCODING,
                                              0,
                                              CERT_FIND_HASH,
                                              &HashBlob,
                                              NULL);
    if(pCertContext == NULL)
    {
        DebugLog((DEB_ERROR, "Certificate designated by credential manager was not found in certificate store (0x%x).\n", GetLastError()));
        Status = SEC_E_NO_CREDENTIALS;
        goto cleanup;
    }


    //
    // Attempt to add this certificate context to the current credential.
    //

    Status = AssignNewClientCredential(pContext,
                                       pCertContext,
                                       pCredential->Cred.Flags & CRED_FLAGS_PROMPT_NOW);
    if(!NT_SUCCESS(Status))
    {
        SP_LOG_RESULT(Status);
        goto cleanup;
    }


    Status = STATUS_SUCCESS;

cleanup:

    if(pCertContext)
    {
        CertFreeCertificateContext(pCertContext);
    }

    if(hStore)
    {
        CertCloseStore(hStore, 0);
    }

    if(pCredential)
    {
        LsaTable->FreeLsaHeap(pCredential);
    }

    if(pCertInfo)
    {
        CredFree(pCertInfo);
    }

    if(fImpersonating)
    {
        RevertToSelf();
    }

    return Status;
}


DWORD
IsThreadLocalSystem(
    BOOL *pfIsLocalSystem)
{
    DWORD Status;
    HANDLE hToken = 0;
    UCHAR InfoBuffer[1024];
    DWORD dwInfoBufferSize = sizeof(InfoBuffer);
    PTOKEN_USER SlowBuffer = NULL;
    PTOKEN_USER pTokenUser = (PTOKEN_USER)InfoBuffer;
    PSID psidLocalSystem = NULL;
    PSID psidNetworkService = NULL;
    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;

    *pfIsLocalSystem = FALSE;

    //
    // Get SID of calling thread.
    //

    if(!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken))
    {
        Status = GetLastError();
        goto cleanup;
    }

    if(!GetTokenInformation(hToken, TokenUser, pTokenUser,
                            dwInfoBufferSize, &dwInfoBufferSize))
    {
        //
        // if fast buffer wasn't big enough, allocate enough storage
        // and try again.
        //

        Status = GetLastError();
        if(Status != ERROR_INSUFFICIENT_BUFFER)
        {
            goto cleanup;
        }

        SlowBuffer = (PTOKEN_USER)LocalAlloc(LPTR, dwInfoBufferSize);
        if(NULL == SlowBuffer)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        pTokenUser = SlowBuffer;
        if(!GetTokenInformation(hToken, TokenUser, pTokenUser,
                                dwInfoBufferSize, &dwInfoBufferSize))
        {
            Status = GetLastError();
            goto cleanup;
        }
    }


    //
    // Check for local system.
    //

    if(!AllocateAndInitializeSid(&siaNtAuthority,
                                 1,
                                 SECURITY_LOCAL_SYSTEM_RID,
                                 0, 0, 0, 0, 0, 0, 0,
                                 &psidLocalSystem))
    {
        Status = GetLastError();
        goto cleanup;
    }

    if (EqualSid(psidLocalSystem, pTokenUser->User.Sid))
    {
        DebugLog((DEB_TRACE, "Client is using the LOCAL SYSTEM account.\n"));
        *pfIsLocalSystem = TRUE;
        Status = ERROR_SUCCESS;
        goto cleanup;
    }


    //
    // Check for network service.
    //

    if(!AllocateAndInitializeSid(&siaNtAuthority,
                                 1,
                                 SECURITY_NETWORK_SERVICE_RID,
                                 0, 0, 0, 0, 0, 0, 0,
                                 &psidNetworkService))
    {
        Status = GetLastError();
        goto cleanup;
    }

    if (EqualSid(psidNetworkService, pTokenUser->User.Sid))
    {
        DebugLog((DEB_TRACE, "Client is using the NETWORK SERVICE account.\n"));
        *pfIsLocalSystem = TRUE;
        Status = ERROR_SUCCESS;
        goto cleanup;
    }

    Status = ERROR_SUCCESS;

cleanup:

    if(NULL != SlowBuffer)
    {
        LocalFree(SlowBuffer);
    }

    if(NULL != psidLocalSystem)
    {
        FreeSid(psidLocalSystem);
    }
    if(NULL != psidNetworkService)
    {
        FreeSid(psidNetworkService);
    }

    if(NULL != hToken)
    {
        CloseHandle(hToken);
    }

    return Status;
}


NTSTATUS
FindClientCertificate(
    PSPContext pContext,
    HCERTSTORE hMyStore,
    CERT_CHAIN_FIND_BY_ISSUER_PARA *pFindByIssuerPara,
    BOOL fSkipExpiredCerts,
    BOOL fSoftwareCspOnly)
{
    PCCERT_CHAIN_CONTEXT        pChainContext = NULL;
    HTTPSPolicyCallbackData     polHttps;
    CERT_CHAIN_POLICY_PARA      PolicyPara;
    CERT_CHAIN_POLICY_STATUS    PolicyStatus;
    PCCERT_CONTEXT              pCertContext;
    NTSTATUS Status;
    ULONG j;

    pChainContext = NULL;

    while(TRUE)
    {
        // Find a certificate chain.
        pChainContext = CertFindChainInStore(hMyStore,
                                             X509_ASN_ENCODING,
                                             0,
                                             CERT_CHAIN_FIND_BY_ISSUER,
                                             pFindByIssuerPara,
                                             pChainContext);
        if(pChainContext == NULL)
        {
            break;
        }

        // Make sure that every certificate in the chain either has the
        // client auth EKU or it has no EKUs at all.
        {
            PCERT_SIMPLE_CHAIN  pSimpleChain;
            PCCERT_CONTEXT      pCurrentCert;
            BOOL                fIsAllowed = FALSE;

            pSimpleChain = pChainContext->rgpChain[0];

            for(j = 0; j < pSimpleChain->cElement; j++)
            {
                pCurrentCert = pSimpleChain->rgpElement[j]->pCertContext;

                Status = SPCheckKeyUsage(pCurrentCert,
                                        szOID_PKIX_KP_CLIENT_AUTH,
                                        TRUE,
                                        &fIsAllowed);
                if(Status != SEC_E_OK || !fIsAllowed)
                {
                    fIsAllowed = FALSE;
                    break;
                }
            }
            if(!fIsAllowed)
            {
                // skip this certificate chain.
                continue;
            }
        }


        // Set up validate chain structures.
        ZeroMemory(&polHttps, sizeof(HTTPSPolicyCallbackData));
        polHttps.cbStruct           = sizeof(HTTPSPolicyCallbackData);
        polHttps.dwAuthType         = AUTHTYPE_CLIENT;
        polHttps.fdwChecks          = 0;
        polHttps.pwszServerName     = NULL;

        ZeroMemory(&PolicyStatus, sizeof(PolicyStatus));
        PolicyStatus.cbSize         = sizeof(PolicyStatus);

        ZeroMemory(&PolicyPara, sizeof(PolicyPara));
        PolicyPara.cbSize           = sizeof(PolicyPara);
        PolicyPara.pvExtraPolicyPara= &polHttps;

        PolicyPara.dwFlags          = CERT_CHAIN_POLICY_IGNORE_WRONG_USAGE_FLAG |
                                      CERT_CHAIN_POLICY_ALLOW_UNKNOWN_CA_FLAG;
        if(!fSkipExpiredCerts)
        {
            PolicyPara.dwFlags |= CERT_CHAIN_POLICY_IGNORE_ALL_NOT_TIME_VALID_FLAGS;
        }

        // Validate chain
        if(!CertVerifyCertificateChainPolicy(
                                CERT_CHAIN_POLICY_SSL,
                                pChainContext,
                                &PolicyPara,
                                &PolicyStatus))
        {
            DebugLog((DEB_WARN,"Error 0x%x returned by CertVerifyCertificateChainPolicy!\n", GetLastError()));
            continue;
        }
        Status = MapWinTrustError(PolicyStatus.dwError, 0, 0);
        if(Status)
        {
            // Certificate did not validate, move on to the next one.
            DebugLog((DEB_WARN, "Client certificate failed validation with 0x%x\n", Status));
            continue;
        }

        // Get pointer to leaf certificate context.
        if(pChainContext->cChain == 0 || pChainContext->rgpChain[0] == NULL)
        {
            Status = SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
            goto cleanup;
        }
        if(pChainContext->rgpChain[0]->cElement == 0 ||
           pChainContext->rgpChain[0]->rgpElement == NULL)
        {
            Status = SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
            goto cleanup;
        }
        pCertContext = pChainContext->rgpChain[0]->rgpElement[0]->pCertContext;


        //
        // Is the private key stored in a software CSP?
        //

        if(fSoftwareCspOnly)
        {
            DWORD dwImpType;

            GetImplementationType(pCertContext, &dwImpType);

            if(dwImpType != CRYPT_IMPL_SOFTWARE)
            {
                // Skip this certificate
                continue;
            }
        }


        //
        // Assign the certificate to the current context.
        //

        Status = AssignNewClientCredential(pContext,
                                           pCertContext,
                                           FALSE);
        if(NT_SUCCESS(Status))
        {
            // Success! Our work here is done.
            goto cleanup;
        }
    }

    // No suitable client credential was found.
    Status = SP_LOG_RESULT(SEC_E_INCOMPLETE_CREDENTIALS);

cleanup:

    if(pChainContext)
    {
        CertFreeCertificateChain(pChainContext);
    }

    return Status;
}


NTSTATUS
AcquireDefaultClientCredential(
    PSPContext  pContext,
    BOOL        fCredManagerOnly)
{
    CERT_CHAIN_FIND_BY_ISSUER_PARA  FindByIssuerPara;
    CERT_NAME_BLOB *    prgIssuers = NULL;
    DWORD               cIssuers = 0;
    HCERTSTORE          hStore = 0;
    NTSTATUS            Status;
    BOOL                fImpersonating = FALSE;
    BOOL                fLocalSystem = FALSE;
    ULONG               i;

    DebugLog((DEB_TRACE,"AcquireDefaultClientCredential\n"));

    //
    // Is the application running under local system?
    //

    fImpersonating = SslImpersonateClient();

    if(fImpersonating)
    {
        Status = IsThreadLocalSystem(&fLocalSystem);
        if(Status)
        {
            DebugLog((DEB_WARN, "IsThreadLocalSystem returned error 0x%x.\n", Status));
        }

        RevertToSelf();
        fImpersonating = FALSE;
    }


    //
    // Ask the credential manager to select a certificate for us.
    //

    Status = QueryCredentialManagerForCert(
                                pContext,
                                pContext->pszTarget);

    if(NT_SUCCESS(Status))
    {
        DebugLog((DEB_TRACE, "Credential manager found a certificate for us.\n"));
        goto cleanup;
    }

    if(fCredManagerOnly)
    {
        // No suitable client credential was found.
        Status = SP_LOG_RESULT(SEC_I_INCOMPLETE_CREDENTIALS);
        goto cleanup;
    }


    //
    // Get list of trusted issuers as a list of CERT_NAME_BLOBs.
    //

    if(pContext->pbIssuerList && pContext->cbIssuerList > 2)
    {
        PBYTE pbIssuerList = pContext->pbIssuerList + 2;
        DWORD cbIssuerList = pContext->cbIssuerList - 2;
        PBYTE pbIssuer;

        // Count issuers.
        cIssuers = 0;
        pbIssuer = pbIssuerList;
        while(pbIssuer + 1 < pbIssuerList + cbIssuerList)
        {
            pbIssuer += 2 + COMBINEBYTES(pbIssuer[0], pbIssuer[1]);
            cIssuers++;
        }

        // Allocate memory for list of blobs.
        prgIssuers = SPExternalAlloc(cIssuers * sizeof(CERT_NAME_BLOB));
        if(prgIssuers == NULL)
        {
            Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            goto cleanup;
        }

        // Build the issuer blob list.
        pbIssuer = pbIssuerList;
        for(i = 0; i < cIssuers; i++)
        {
            prgIssuers[i].pbData = pbIssuer + 2;
            prgIssuers[i].cbData = COMBINEBYTES(pbIssuer[0], pbIssuer[1]);

            pbIssuer += 2 + prgIssuers[i].cbData;
        }
    }


    //
    // Enumerate the certificates in the MY store, looking for a suitable
    // client certificate. 
    //

    fImpersonating = SslImpersonateClient();

    if(fLocalSystem)
    {
        hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
                               X509_ASN_ENCODING, 0,
                               CERT_SYSTEM_STORE_LOCAL_MACHINE  |
                               CERT_STORE_READONLY_FLAG         |
                               CERT_STORE_OPEN_EXISTING_FLAG,
                               L"MY");
    }
    else
    {
        hStore = CertOpenSystemStore(0, "MY");
    }

    if(!hStore)
    {
        SP_LOG_RESULT(GetLastError());
        Status = SEC_E_INTERNAL_ERROR;
        goto cleanup;
    }


    ZeroMemory(&FindByIssuerPara, sizeof(FindByIssuerPara));
    FindByIssuerPara.cbSize             = sizeof(FindByIssuerPara);
    FindByIssuerPara.pszUsageIdentifier = szOID_PKIX_KP_CLIENT_AUTH;
    FindByIssuerPara.dwKeySpec          = 0;
    FindByIssuerPara.cIssuer            = cIssuers;
    FindByIssuerPara.rgIssuer           = prgIssuers;


    //
    // Attempt to find a suitable certificate.
    //

    Status = FindClientCertificate(pContext,
                                   hStore,
                                   &FindByIssuerPara,
                                   TRUE,    // skip expired certs
                                   TRUE);   // software CSPs only

    if(NT_SUCCESS(Status))
    {
        // Success! Our work here is done.
        goto cleanup;
    }

    Status = FindClientCertificate(pContext,
                                   hStore,
                                   &FindByIssuerPara,
                                   TRUE,    // skip expired certs
                                   FALSE);  // software CSPs only

    if(NT_SUCCESS(Status))
    {
        // Success! Our work here is done.
        goto cleanup;
    }

    Status = FindClientCertificate(pContext,
                                   hStore,
                                   &FindByIssuerPara,
                                   FALSE,   // skip expired certs
                                   TRUE);   // software CSPs only

    if(NT_SUCCESS(Status))
    {
        // Success! Our work here is done.
        goto cleanup;
    }

    Status = FindClientCertificate(pContext,
                                   hStore,
                                   &FindByIssuerPara,
                                   FALSE,   // skip expired certs
                                   FALSE);  // software CSPs only

    if(NT_SUCCESS(Status))
    {
        // Success! Our work here is done.
        goto cleanup;
    }


    // No suitable client credential was found.
    Status = SP_LOG_RESULT(SEC_I_INCOMPLETE_CREDENTIALS);


cleanup:


    if(hStore)
    {
        CertCloseStore(hStore, 0);
    }

    if(fImpersonating)
    {
        RevertToSelf();
    }

    if(prgIssuers)
    {
        SPExternalFree(prgIssuers);
    }

    DebugLog((DEB_TRACE,"AcquireDefaultClientCredential returned 0x%x\n", Status));

    return Status;
}


NTSTATUS
FindDefaultMachineCred(
    PSPCredentialGroup *ppCred,
    DWORD dwProtocol)
{
    HTTPSPolicyCallbackData  polHttps;
    CERT_CHAIN_POLICY_PARA   PolicyPara;
    CERT_CHAIN_POLICY_STATUS PolicyStatus;
    CERT_CHAIN_PARA          ChainPara;
    PCCERT_CHAIN_CONTEXT     pChainContext = NULL;
    PCCERT_CONTEXT           pCertContext  = NULL;
    LSA_SCHANNEL_CRED        SchannelCred;
    LSA_SCHANNEL_SUB_CRED    SubCred;
    HCERTSTORE               hStore = 0;

    #define SERVER_USAGE_COUNT 3
    LPSTR               rgszUsages[SERVER_USAGE_COUNT] = {
                            szOID_PKIX_KP_SERVER_AUTH,
                            szOID_SERVER_GATED_CRYPTO,
                            szOID_SGC_NETSCAPE };

    LPWSTR  pwszMachineName = NULL;
    DWORD   cchMachineName;
    DWORD   Status;
    DWORD   i;

    // Get the machine name
    cchMachineName = 0;
    if(!GetComputerNameExW(ComputerNameDnsFullyQualified, NULL, &cchMachineName))
    {
        if(GetLastError() != ERROR_MORE_DATA)
        {
            DebugLog((DEB_ERROR,"Failed to get computer name size: 0x%x\n",GetLastError()));
            Status = SP_LOG_RESULT(SEC_E_WRONG_PRINCIPAL);
            goto cleanup;
        }
    }
    pwszMachineName = SPExternalAlloc(cchMachineName * sizeof(WCHAR));
    if(pwszMachineName == NULL)
    {
        Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto cleanup;
    }
    if(!GetComputerNameExW(ComputerNameDnsFullyQualified, pwszMachineName, &cchMachineName))
    {
        DebugLog((DEB_ERROR,"Failed to get computer name: 0x%x\n",GetLastError()));
        Status = SP_LOG_RESULT(SEC_E_WRONG_PRINCIPAL);
        goto cleanup;
    }

    // Remove the trailing "." if any. This can happen in the stand-alone
    // server case.
    cchMachineName = lstrlenW(pwszMachineName);
    if(cchMachineName > 0 && pwszMachineName[cchMachineName - 1] == L'.')
    {
        pwszMachineName[cchMachineName - 1] = L'\0';
    }


    DebugLog((DEB_TRACE,"Computer name: %ls\n",pwszMachineName));


    // Open the system MY store.
    hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
                           X509_ASN_ENCODING, 0,
                           CERT_SYSTEM_STORE_LOCAL_MACHINE  |
                           CERT_STORE_READONLY_FLAG         |
                           CERT_STORE_OPEN_EXISTING_FLAG,
                           L"MY");
    if(hStore == NULL)
    {
        SP_LOG_RESULT(GetLastError());
        Status = SEC_E_NO_CREDENTIALS;
        goto cleanup;
    }


    //
    // Enumerate the certificates in the MY store, looking for a suitable
    // server certificate. Do this twice, the first time looking for the
    // perfect certificate, and if this fails then look again, this time
    // being a little less picky.
    //

    for(i = 0; i < 2; i++)
    {
        pCertContext = NULL;

        while(TRUE)
        {
            // Get leaf certificate in the MY store.
            pCertContext = CertEnumCertificatesInStore(hStore, pCertContext);
            if(pCertContext == NULL)
            {
                // No more certificates.
                break;
            }

            //
            // Build a certificate chain from the leaf certificate.
            //

            ZeroMemory(&ChainPara, sizeof(ChainPara));
            ChainPara.cbSize = sizeof(ChainPara);
            ChainPara.RequestedUsage.dwType = USAGE_MATCH_TYPE_OR;
            ChainPara.RequestedUsage.Usage.cUsageIdentifier     = SERVER_USAGE_COUNT;
            ChainPara.RequestedUsage.Usage.rgpszUsageIdentifier = rgszUsages;

            if(!CertGetCertificateChain(
                                    NULL,
                                    pCertContext,
                                    NULL,
                                    0,
                                    &ChainPara,
                                    CERT_CHAIN_REVOCATION_CHECK_END_CERT,
                                    NULL,
                                    &pChainContext))
            {
                DebugLog((DEB_WARN, "Error 0x%x returned by CertGetCertificateChain!\n", GetLastError()));
                continue;
            }

            // Set up validate chain structures.
            ZeroMemory(&polHttps, sizeof(HTTPSPolicyCallbackData));
            polHttps.cbStruct           = sizeof(HTTPSPolicyCallbackData);
            polHttps.dwAuthType         = AUTHTYPE_SERVER;
            polHttps.fdwChecks          = 0;
            polHttps.pwszServerName     = pwszMachineName;

            ZeroMemory(&PolicyStatus, sizeof(PolicyStatus));
            PolicyStatus.cbSize         = sizeof(PolicyStatus);

            ZeroMemory(&PolicyPara, sizeof(PolicyPara));
            PolicyPara.cbSize           = sizeof(PolicyPara);
            PolicyPara.pvExtraPolicyPara= &polHttps;
            if(i == 0)
            {
                // Look for the perfect certificate.
                PolicyPara.dwFlags = 0;
            }
            else
            {
                // Ignore expiration.
                PolicyPara.dwFlags = CERT_CHAIN_POLICY_IGNORE_ALL_NOT_TIME_VALID_FLAGS;
            }

            // Validate chain
            if(!CertVerifyCertificateChainPolicy(
                                    CERT_CHAIN_POLICY_SSL,
                                    pChainContext,
                                    &PolicyPara,
                                    &PolicyStatus))
            {
                SP_LOG_RESULT(GetLastError());
                CertFreeCertificateChain(pChainContext);
                continue;
            }
            Status = MapWinTrustError(PolicyStatus.dwError,
                                      0,
                                      CRED_FLAG_IGNORE_NO_REVOCATION_CHECK | CRED_FLAG_IGNORE_REVOCATION_OFFLINE);
            if(Status)
            {
                // Certificate did not validate, move on to the next one.
                DebugLog((DEB_WARN, "Machine certificate failed validation with 0x%x\n", Status));
                CertFreeCertificateChain(pChainContext);
                continue;
            }

            CertFreeCertificateChain(pChainContext);


            // Build an schannel credential.
            ZeroMemory(&SchannelCred, sizeof(SchannelCred));

            SchannelCred.dwVersion = SCHANNEL_CRED_VERSION;
            SchannelCred.cSubCreds = 1;
            SchannelCred.paSubCred = &SubCred;

            ZeroMemory(&SubCred, sizeof(SubCred));

            SubCred.pCert = pCertContext;

            Status = SPCreateCredential(ppCred,
                                        dwProtocol,
                                        &SchannelCred);
            if(Status != PCT_ERR_OK)
            {
                // Don't use this certificate.
                continue;
            }

            // We have a winner!
            DebugLog((DEB_TRACE, "Machine certificate automatically acquired\n"));
            Status = PCT_ERR_OK;
            goto cleanup;
        }
    }

    // No suitable machine credential was found.
    Status = SP_LOG_RESULT(SEC_E_NO_CREDENTIALS);

cleanup:

    if(Status != PCT_ERR_OK)
    {
        LogNoDefaultServerCredEvent();
    }

    if(pwszMachineName)
    {
        SPExternalFree(pwszMachineName);
    }

    if(pCertContext)
    {
        CertFreeCertificateContext(pCertContext);
    }

    if(hStore)
    {
        CertCloseStore(hStore, 0);
    }

    return Status;
}


void
GetImplementationType(
    PCCERT_CONTEXT pCertContext,
    PDWORD pdwImpType)
{
    PCRYPT_KEY_PROV_INFO pProvInfo = NULL;
    HCRYPTPROV  hProv = 0;
    DWORD       cbSize;
    DWORD       dwImpType;

    *pdwImpType = CRYPT_IMPL_UNKNOWN;

    if(!CertGetCertificateContextProperty(pCertContext,
                                          CERT_KEY_PROV_INFO_PROP_ID,
                                          NULL,
                                          &cbSize))
    {
        goto cleanup;
    }

    pProvInfo = SPExternalAlloc(cbSize);
    if(pProvInfo == NULL)
    {
        goto cleanup;
    }

    if(!CertGetCertificateContextProperty(pCertContext,
                                          CERT_KEY_PROV_INFO_PROP_ID,
                                          pProvInfo,
                                          &cbSize))
    {
        goto cleanup;
    }

    // HACKHACK - clear the smart-card specific flag.
    pProvInfo->dwFlags &= ~CERT_SET_KEY_CONTEXT_PROP_ID;

    if(!CryptAcquireContextW(&hProv,
                             pProvInfo->pwszContainerName,
                             pProvInfo->pwszProvName,
                             pProvInfo->dwProvType,
                             pProvInfo->dwFlags | CRYPT_SILENT))
    {
        goto cleanup;
    }

    cbSize = sizeof(dwImpType);
    if(!CryptGetProvParam(hProv, 
                          PP_IMPTYPE,
                          (PBYTE)&dwImpType,
                          &cbSize,
                          0))
    {
        goto cleanup;
    }

    *pdwImpType = dwImpType;

cleanup:

    if(pProvInfo)
    {
        SPExternalFree(pProvInfo);
    }

    if(hProv)
    {
        CryptReleaseContext(hProv, 0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\spbase\keyxmsdh.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       keyxmsdh.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10-21-97   jbanes   CAPI integration stuff.
//
//----------------------------------------------------------------------------

#include <spbase.h>
#include <align.h>


// PROV_DH_SCHANNEL handle used for client and server operations. This is
// where the schannel ephemeral DH key lives.
HCRYPTPROV          g_hDhSchannelProv = 0;
PROV_ENUMALGS_EX *  g_pDhSchannelAlgs = NULL;
DWORD               g_cDhSchannelAlgs = 0;


SP_STATUS
WINAPI
DHGenerateServerExchangeValue(
    SPContext     * pContext,               // in
    PUCHAR          pServerExchangeValue,   // out
    DWORD *         pcbServerExchangeValue  // in/out
);

SP_STATUS
WINAPI
DHGenerateClientExchangeValue(
    SPContext     * pContext,               // in
    PUCHAR          pServerExchangeValue,   // in
    DWORD           cbServerExchangeValue,  // in
    PUCHAR          pClientClearValue,      // out
    DWORD *         pcbClientClearValue,    // in/out
    PUCHAR          pClientExchangeValue,   // out
    DWORD *         pcbClientExchangeValue  // in/out
);

SP_STATUS
WINAPI
DHGenerateServerMasterKey(
    SPContext     * pContext,               // in
    PUCHAR          pClientClearValue,      // in
    DWORD           cbClientClearValue,     // in
    PUCHAR          pClientExchangeValue,   // in
    DWORD           cbClientExchangeValue   // in
);


KeyExchangeSystem keyexchDH = {
    SP_EXCH_DH_PKCS3,
    "Diffie Hellman",
    DHGenerateServerExchangeValue,
    DHGenerateClientExchangeValue,
    DHGenerateServerMasterKey,
};


SP_STATUS
SPSignDssParams(
    PSPContext      pContext,
    PSPCredential   pCred,
    PBYTE           pbParams,
    DWORD           cbParams,
    PBYTE           pbEncodedSignature,
    PDWORD          pcbEncodedSignature)
{
    HCRYPTHASH  hHash;
    BYTE        rgbSignature[DSA_SIGNATURE_SIZE];
    DWORD       cbSignature;

    if(pCred == NULL)
    {
        return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

    if(!SchCryptCreateHash(pCred->hProv,
                           CALG_SHA,
                           0,
                           0,
                           &hHash,
                           pCred->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        return PCT_ERR_ILLEGAL_MESSAGE;
    }

    if(!SchCryptHashData(hHash, pContext->rgbS3CRandom, 32, 0, pCred->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        return PCT_ERR_ILLEGAL_MESSAGE;
    }

    if(!SchCryptHashData(hHash, pContext->rgbS3SRandom, 32, 0, pCred->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        return PCT_ERR_ILLEGAL_MESSAGE;
    }

    if(!SchCryptHashData(hHash, pbParams, cbParams, 0, pCred->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        return PCT_ERR_ILLEGAL_MESSAGE;
    }

    cbSignature = sizeof(rgbSignature);
    if(!SchCryptSignHash(hHash,
                         pCred->dwKeySpec,
                         NULL,
                         0,
                         rgbSignature,
                         &cbSignature,
                         pCred->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        return PCT_ERR_ILLEGAL_MESSAGE;
    }

    CryptDestroyHash(hHash);

    if(!CryptEncodeObject(X509_ASN_ENCODING,
                          X509_DSS_SIGNATURE,
                          rgbSignature,
                          pbEncodedSignature,
                          pcbEncodedSignature))
    {
        SP_LOG_RESULT(GetLastError());
        return PCT_ERR_ILLEGAL_MESSAGE;
    }

    // Return success.
    return PCT_ERR_OK;
}

SP_STATUS
SPVerifyDssParams(
    PSPContext  pContext,
    HCRYPTPROV  hProv,
    HCRYPTKEY   hPublicKey,
    DWORD       dwCapiFlags,
    PBYTE       pbParams,
    DWORD       cbParams,
    PBYTE       pbEncodedSignature,
    DWORD       cbEncodedSignature)
{
    HCRYPTHASH  hHash;
    BYTE        rgbSignature[DSA_SIGNATURE_SIZE];
    DWORD       cbSignature;

    // Decode the signature.
    cbSignature = sizeof(rgbSignature);
    if(!CryptDecodeObject(X509_ASN_ENCODING,
                          X509_DSS_SIGNATURE,
                          pbEncodedSignature,
                          cbEncodedSignature,
                          0,
                          rgbSignature,
                          &cbSignature))
    {
        SP_LOG_RESULT(GetLastError());
        return PCT_ERR_ILLEGAL_MESSAGE;
    }

    if(!SchCryptCreateHash(hProv,
                           CALG_SHA,
                           0,
                           0,
                           &hHash,
                           dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        return PCT_ERR_ILLEGAL_MESSAGE;
    }

    if(!SchCryptHashData(hHash, pContext->rgbS3CRandom, 32, 0, dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        return PCT_ERR_ILLEGAL_MESSAGE;
    }

    if(!SchCryptHashData(hHash, pContext->rgbS3SRandom, 32, 0, dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        return PCT_ERR_ILLEGAL_MESSAGE;
    }

    if(!SchCryptHashData(hHash, pbParams, cbParams, 0, dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        return PCT_ERR_ILLEGAL_MESSAGE;
    }

    if(!SchCryptVerifySignature(hHash,
                                rgbSignature,
                                cbSignature,
                                hPublicKey,
                                NULL,
                                0,
                                dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        return PCT_INT_MSG_ALTERED;
    }

    CryptDestroyHash(hHash);

    return PCT_ERR_OK;
}

SP_STATUS
GetDHEphemKey(
    PSPContext      pContext,
    HCRYPTPROV *    phProv,
    HCRYPTKEY *     phTek)
{
    PSPCredentialGroup pCredGroup;
    PSPCredential pCred;
    DWORD dwKeySize;
    DWORD cbData;
    DWORD Status;

    pCredGroup = pContext->RipeZombie->pServerCred;
    if(pCredGroup == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    pCred = pContext->RipeZombie->pActiveServerCred;
    if(pCredGroup == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    LockCredential(pCredGroup);

    if(phProv)
    {
        *phProv = pCred->hProv;
    }

    dwKeySize = 1024;

    // Determine if we've already created an ephemeral key.
    if(pCred->hTek)
    {
        *phTek = pCred->hTek;
        Status = PCT_ERR_OK;
        goto cleanup;
    }

    // Generate the ephemeral key.
    if(!CryptGenKey(pCred->hProv,
                    CALG_DH_EPHEM,
                    dwKeySize << 16,
                    phTek))
    {
        SP_LOG_RESULT(GetLastError());
        Status = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }

    pCred->hTek = *phTek;

    Status = PCT_ERR_OK;

cleanup:

    if(Status == PCT_ERR_OK)
    {
        // Determine size of key exchange key.
        cbData = sizeof(DWORD);
        if(!SchCryptGetKeyParam(*phTek,
                                KP_BLOCKLEN,
                                (PBYTE)&pContext->RipeZombie->dwExchStrength,
                                &cbData,
                                0,
                                pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
            pContext->RipeZombie->dwExchStrength = 0;
        }
    }

    UnlockCredential(pCredGroup);

    return Status;
}


//+---------------------------------------------------------------------------
//
//  Function:   DHGenerateServerExchangeValue
//
//  Synopsis:   Create a ServerKeyExchange message, containing an ephemeral
//              DH key.
//
//  Arguments:  [pContext]                  --  Schannel context.
//              [pServerExchangeValue]      --
//              [pcbServerExchangeValue]    --
//
//  History:    03-24-98   jbanes   Added CAPI integration.
//
//  Notes:      The following data is placed in the output buffer by
//              this routine:
//
//              struct {
//                 opaque dh_p<1..2^16-1>;
//                 opaque dh_g<1..2^16-1>;
//                 opaque dh_Ys<1..2^16-1>;
//              } ServerDHParams;
//
//              struct {
//                 ServerDHParams params;
//                 Signature signed_params;
//              } ServerKeyExchange;
//
//----------------------------------------------------------------------------
SP_STATUS
WINAPI
DHGenerateServerExchangeValue(
    PSPContext  pContext,               // in
    PBYTE       pServerExchangeValue,   // out
    DWORD *     pcbServerExchangeValue) // in/out
{
    PSPCredential   pCred;
    HCRYPTPROV      hProv = 0;
    HCRYPTKEY       hServerDhKey = 0;

    PBYTE           pbMessage;
    DWORD           cbMessage;
    DWORD           cbBytesLeft;
    DWORD           cbData;
    DWORD           cbP;
    DWORD           cbG;
    DWORD           cbY;
    DWORD           cbSignature;
    SP_STATUS       pctRet;
    BOOL            fImpersonating = FALSE;

    pCred = pContext->RipeZombie->pActiveServerCred;
    if(pCred == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    if(pContext->RipeZombie->fProtocol != SP_PROT_SSL3_SERVER &&
       pContext->RipeZombie->fProtocol != SP_PROT_TLS1_SERVER)
    {
        // SSL2 and PCT do not support DH.
        return SP_LOG_RESULT(PCT_INT_SPECS_MISMATCH);
    }

    // Always send a ServerKeyExchange message.
    pContext->fExchKey = TRUE;

    fImpersonating = SslImpersonateClient();


    //
    // Generate ephemeral DH key.
    //

    pctRet = GetDHEphemKey(pContext, 
                           &hProv,
                           &hServerDhKey);
    if(pctRet != PCT_ERR_OK)
    {
        SP_LOG_RESULT(pctRet);
        goto cleanup;
    }


    //
    // Estimate sizes of P, G, and Y.
    //

    if(!CryptGetKeyParam(hServerDhKey, KP_P, NULL, &cbP, 0))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }

    if(!CryptGetKeyParam(hServerDhKey, KP_G, NULL, &cbG, 0))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }

    if(!CryptExportKey(hServerDhKey,
                          0,
                          PUBLICKEYBLOB,
                          0,
                          NULL,
                          &cbY))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }


    //
    // Compute approximate size of ServerKeyExchange message.
    //

    cbMessage = 2 + cbP +
                2 + cbG +
                2 + cbY + sizeof(DWORD) +
                2 + MAX_DSA_ENCODED_SIGNATURE_SIZE;

    if(pServerExchangeValue == NULL)
    {
        *pcbServerExchangeValue = cbMessage;
        pctRet = PCT_ERR_OK;
        goto cleanup;
    }
    if(*pcbServerExchangeValue < cbMessage)
    {
        *pcbServerExchangeValue = cbMessage;
        pctRet = SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
        goto cleanup;
    }


    //
    // Build the ServerDHParams structure.
    //

    pbMessage   = pServerExchangeValue;
    cbBytesLeft = cbMessage;

    // Get P.
    if(!CryptGetKeyParam(hServerDhKey, KP_P, pbMessage + 2, &cbP, 0))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    ReverseInPlace(pbMessage + 2, cbP);

    pbMessage[0] = MSBOF(cbP);
    pbMessage[1] = LSBOF(cbP);
    pbMessage   += 2 + cbP;
    cbBytesLeft -= 2 + cbP;

    // Get G.
    if(!CryptGetKeyParam(hServerDhKey, KP_G, pbMessage + 2, &cbG, 0))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    ReverseInPlace(pbMessage + 2, cbG);

    pbMessage[0] = MSBOF(cbG);
    pbMessage[1] = LSBOF(cbG);
    pbMessage   += 2 + cbG;
    cbBytesLeft -= 2 + cbG;

    // Get Ys.
    {
        BLOBHEADER *pBlobHeader;
        DHPUBKEY *  pDHPubKey;
        PBYTE       pbKey;
        DWORD       cbKey;

        pBlobHeader = (BLOBHEADER *)ROUND_UP_POINTER(pbMessage, ALIGN_DWORD);
        cbData = cbBytesLeft - sizeof(DWORD);

        if(!CryptExportKey(hServerDhKey,
                              0,
                              PUBLICKEYBLOB,
                              0,
                              (PBYTE)pBlobHeader,
                              &cbData))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_INT_INTERNAL_ERROR;
            goto cleanup;
        }
        pDHPubKey   = (DHPUBKEY *)(pBlobHeader + 1);
        pbKey       = (BYTE *)(pDHPubKey + 1);

        cbKey = pDHPubKey->bitlen / 8;
        if(pDHPubKey->bitlen % 8) cbKey++;

        MoveMemory(pbMessage + 2, pbKey, cbKey);
        ReverseInPlace(pbMessage + 2, cbKey);

        pbMessage[0] = MSBOF(cbKey);
        pbMessage[1] = LSBOF(cbKey);
        pbMessage   += 2 + cbKey;
        cbBytesLeft -= 2 + cbKey;
    }


    //
    // Sign the ServerDHParams structure.
    //

    cbSignature = cbBytesLeft - 2;
    pctRet = SPSignDssParams(pContext,
                             pCred, 
                             pServerExchangeValue,
                             (DWORD)(pbMessage - pServerExchangeValue),
                             pbMessage + 2,
                             &cbSignature);
    if(pctRet != PCT_ERR_OK)
    {
        SP_LOG_RESULT(pctRet);
        goto cleanup;
    }
    pbMessage[0] = MSBOF(cbSignature);
    pbMessage[1] = LSBOF(cbSignature);
    pbMessage += 2 + cbSignature;
    cbBytesLeft -= 2 + cbSignature;


    //
    // Update function outputs.
    //

    SP_ASSERT(cbBytesLeft < cbMessage);

    *pcbServerExchangeValue = (DWORD)(pbMessage - pServerExchangeValue);

    // Use ephemeral key for the new connection.
    pContext->RipeZombie->hMasterProv = hProv;
    pContext->RipeZombie->dwCapiFlags = SCH_CAPI_USE_CSP;

    pctRet = PCT_ERR_OK;

cleanup:

    if(fImpersonating)
    {
        RevertToSelf();
    }

    return pctRet;
}


SP_STATUS
ParseServerKeyExchange(
    PSPContext  pContext,       // in
    PBYTE       pbMessage,      // in
    DWORD       cbMessage,      // in
    PBYTE *     ppbServerP,     // out
    PDWORD      pcbServerP,     // out
    PBYTE *     ppbServerG,     // out
    PDWORD      pcbServerG,     // out
    PBYTE *     ppbServerY,     // out
    PDWORD      pcbServerY,     // out
    BOOL        fValidateSig)   // in
{
    PBYTE       pbData;
    BLOBHEADER *pPublicBlob;
    DWORD       cbPublicBlob;
    HCRYPTKEY   hServerPublic = 0;
    PBYTE       pbSignature;
    DWORD       cbSignature;
    DWORD       cbSignedData;
    SP_STATUS   pctRet;

    //
    // Parse out ServerKeyExchange message fields
    //

    pbData = pbMessage;

    *pcbServerP = MAKEWORD(pbData[1], pbData[0]);
    *ppbServerP = pbData + 2;

    pbData += 2 + *pcbServerP;
    if(pbData >= pbMessage + cbMessage)
    {
        return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
    }

    *pcbServerG = MAKEWORD(pbData[1], pbData[0]);
    *ppbServerG = pbData + 2;

    pbData += 2 + *pcbServerG;
    if(pbData >= pbMessage + cbMessage)
    {
        return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
    }

    *pcbServerY = MAKEWORD(pbData[1], pbData[0]);
    *ppbServerY = pbData + 2;

    pbData += 2 + *pcbServerY;
    if(pbData >= pbMessage + cbMessage)
    {
        return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
    }

    cbSignedData = (DWORD)(pbData - pbMessage);

    cbSignature = MAKEWORD(pbData[1], pbData[0]);
    pbSignature = pbData + 2;

    pbData += 2 + cbSignature;
    if(pbData != pbMessage + cbMessage)
    {
        return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
    }

    if(fValidateSig == FALSE)
    {
        return PCT_ERR_OK;
    }


    //
    // Validate signature.
    //

    pPublicBlob  = pContext->RipeZombie->pRemotePublic->pPublic;
    cbPublicBlob = pContext->RipeZombie->pRemotePublic->cbPublic;

    if(!SchCryptImportKey(pContext->RipeZombie->hMasterProv,
                          (PBYTE)pPublicBlob,
                          cbPublicBlob,
                          0,
                          0,
                          &hServerPublic,
                          pContext->RipeZombie->dwCapiFlags))
    {
        return SP_LOG_RESULT(GetLastError());
    }

    pctRet = SPVerifyDssParams(
                        pContext,
                        pContext->RipeZombie->hMasterProv,
                        hServerPublic,
                        pContext->RipeZombie->dwCapiFlags,
                        pbMessage,
                        cbSignedData,
                        pbSignature,
                        cbSignature);
    if(pctRet != PCT_ERR_OK)
    {
        SchCryptDestroyKey(hServerPublic, pContext->RipeZombie->dwCapiFlags);
        return SP_LOG_RESULT(pctRet);
    }

    SchCryptDestroyKey(hServerPublic, pContext->RipeZombie->dwCapiFlags);

    return PCT_ERR_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:   DHGenerateClientExchangeValue
//
//  Synopsis:   Create a ClientKeyExchange message, containing an ephemeral
//              DH key.
//
//  Arguments:
//
//  History:    03-24-98   jbanes   Added CAPI integration.
//
//  Notes:      The following data is placed in the output buffer by
//              this routine:
//
//              struct {
//                 opaque dh_Yc<1..2^16-1>;
//              } ClientDiffieHellmanPublic;
//
//----------------------------------------------------------------------------
SP_STATUS
WINAPI
DHGenerateClientExchangeValue(
    SPContext     * pContext,               // in
    PUCHAR          pServerExchangeValue,   // in
    DWORD           cbServerExchangeValue,  // in
    PUCHAR          pClientClearValue,      // out
    DWORD *         pcbClientClearValue,    // in/out
    PUCHAR          pClientExchangeValue,   // out
    DWORD *         pcbClientExchangeValue) // in/out
{
    HCRYPTKEY       hClientDHKey = 0;
    PSessCacheItem  pZombie;
    CRYPT_DATA_BLOB Data;
    ALG_ID          Algid;
    DWORD           cbHeader;
    SP_STATUS       pctRet;

    PBYTE pbServerP = NULL;
    DWORD cbServerP;
    PBYTE pbServerG = NULL;
    DWORD cbServerG;
    PBYTE pbServerY = NULL;
    DWORD cbServerY;
    PBYTE pbClientY = NULL;
    DWORD cbClientY;

    PBYTE pbBlob = NULL;
    DWORD cbBlob;
    DWORD cbData;
    DWORD dwKeySize;


    pZombie = pContext->RipeZombie;
    if(pZombie == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    if(pZombie->hMasterProv == 0)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    // We're doing a full handshake.
    pContext->Flags |= CONTEXT_FLAG_FULL_HANDSHAKE;

    if(pZombie->fProtocol == SP_PROT_SSL3_CLIENT)
    {
        Algid = CALG_SSL3_MASTER;
    }
    else if(pZombie->fProtocol == SP_PROT_TLS1_CLIENT)
    {
        Algid = CALG_TLS1_MASTER;
    }
    else
    {
        return SP_LOG_RESULT(PCT_INT_SPECS_MISMATCH);
    }

    if(pServerExchangeValue == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
    }


    //
    // Is the output buffer large enough?
    //

    pctRet = ParseServerKeyExchange(pContext,
                                    pServerExchangeValue,
                                    cbServerExchangeValue,
                                    &pbServerP,
                                    &cbServerP,
                                    &pbServerG,
                                    &cbServerG,
                                    &pbServerY,
                                    &cbServerY,
                                    FALSE);
    if(pctRet != PCT_ERR_OK)
    {
        return pctRet;
    }

    cbBlob = sizeof(BLOBHEADER) + sizeof(DHPUBKEY) + cbServerY + 20;

    if(pClientExchangeValue == NULL)
    {
        *pcbClientExchangeValue = cbBlob;
        return PCT_ERR_OK;
    }

    if(*pcbClientExchangeValue < cbBlob)
    {
        *pcbClientExchangeValue = cbBlob;
        return SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
    }


    //
    // Parse the ServerKeyExchange message.
    //

    pctRet = ParseServerKeyExchange(pContext,
                                    pServerExchangeValue,
                                    cbServerExchangeValue,
                                    &pbServerP,
                                    &cbServerP,
                                    &pbServerG,
                                    &cbServerG,
                                    &pbServerY,
                                    &cbServerY,
                                    TRUE);
    if(pctRet != PCT_ERR_OK)
    {
        return pctRet;
    }


    //
    // Create buffer to use for endian-izing data.
    //

    cbBlob = sizeof(BLOBHEADER) + sizeof(DHPUBKEY) + cbServerY;
    cbBlob = max(cbBlob, cbServerP);
    cbBlob = max(cbBlob, cbServerG);

    pbBlob = SPExternalAlloc(cbBlob);
    if(pbBlob == NULL)
    {
        pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto cleanup;
    }


    //
    // Generate and set the parameters on the client DH key.
    //

    dwKeySize = cbServerP * 8;

    if(!SchCryptGenKey(pZombie->hMasterProv,
                       CALG_DH_EPHEM,
                       (dwKeySize << 16) | CRYPT_PREGEN,
                       &hClientDHKey,
                       pZombie->dwCapiFlags))
    {
        pctRet = SP_LOG_RESULT(GetLastError());
        goto cleanup;
    }

    ReverseMemCopy(pbBlob, pbServerP, cbServerP);
    Data.pbData = pbBlob;
    Data.cbData = cbServerP;
    if(!SchCryptSetKeyParam(hClientDHKey,
                            KP_P,
                            (PBYTE)&Data,
                            0,
                            pZombie->dwCapiFlags))
    {
        pctRet = SP_LOG_RESULT(GetLastError());
        goto cleanup;
    }

    ReverseMemCopy(pbBlob, pbServerG, cbServerG);
    Data.pbData = pbBlob;
    Data.cbData = cbServerG;
    if(cbServerG < cbServerP)
    {
        // Expand G so that it's the same size as P.
        ZeroMemory(pbBlob + cbServerG, cbServerP - cbServerG);
        Data.cbData = cbServerP;
    }
    if(!SchCryptSetKeyParam(hClientDHKey,
                            KP_G,
                            (PBYTE)&Data,
                            0,
                            pZombie->dwCapiFlags))
    {
        pctRet = SP_LOG_RESULT(GetLastError());
        goto cleanup;
    }

    // actually create the client private DH key
    if(!SchCryptSetKeyParam(hClientDHKey,
                            KP_X,
                            NULL,
                            0,
                            pZombie->dwCapiFlags))
    {
        pctRet = SP_LOG_RESULT(GetLastError());
        goto cleanup;
    }


    //
    // Import the server's public key and generate the master secret.
    //

    {
        BLOBHEADER *   pBlobHeader;
        DHPUBKEY *     pDHPubKey;
        PBYTE          pbKey;

        // Build PUBLICKEYBLOB around the server's public key.
        pBlobHeader = (BLOBHEADER *)pbBlob;
        pDHPubKey   = (DHPUBKEY *)(pBlobHeader + 1);
        pbKey       = (PBYTE)(pDHPubKey + 1);

        pBlobHeader->bType    = PUBLICKEYBLOB;
        pBlobHeader->bVersion = CUR_BLOB_VERSION;
        pBlobHeader->reserved = 0;
        pBlobHeader->aiKeyAlg = CALG_DH_EPHEM;

        pDHPubKey->magic      = MAGIC_DH1;
        pDHPubKey->bitlen     = cbServerY * 8;

        ReverseMemCopy(pbKey, pbServerY, cbServerY);

        if(!SchCryptImportKey(pZombie->hMasterProv,
                              pbBlob,
                              cbBlob,
                              hClientDHKey,
                              0,
                              &pZombie->hMasterKey,
                              pZombie->dwCapiFlags))
        {
            pctRet = GetLastError();
            goto cleanup;
        }
    }

    // Determine size of key exchange key.
    cbData = sizeof(DWORD);
    if(!SchCryptGetKeyParam(hClientDHKey,
                            KP_BLOCKLEN,
                            (PBYTE)&pZombie->dwExchStrength,
                            &cbData,
                            0,
                            pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pContext->RipeZombie->dwExchStrength = 0;
    }


    //
    // Convert the agreed key to the appropriate master key type.
    //

    if(!SchCryptSetKeyParam(pZombie->hMasterKey,
                            KP_ALGID,
                            (PBYTE)&Algid,
                            0,
                            pZombie->dwCapiFlags))
    {
        pctRet = SP_LOG_RESULT(GetLastError());
        goto cleanup;
    }


    //
    // Export the client public key, strip off the blob header
    // goo and attach a two byte length field. This will make up our
    // ClientKeyExchange message.
    //

    if(!SchCryptExportKey(hClientDHKey,
                          0,
                          PUBLICKEYBLOB,
                          0,
                          pClientExchangeValue,
                          pcbClientExchangeValue,
                          pZombie->dwCapiFlags))
    {
        pctRet = SP_LOG_RESULT(GetLastError());
        goto cleanup;
    }

    cbHeader  = sizeof(BLOBHEADER) + sizeof(DHPUBKEY);

    cbClientY = *pcbClientExchangeValue - cbHeader;
    pbClientY = pClientExchangeValue + cbHeader;

    pClientExchangeValue[0] = MSBOF(cbClientY);
    pClientExchangeValue[1] = LSBOF(cbClientY);

    ReverseInPlace(pbClientY, cbClientY);
    MoveMemory(pClientExchangeValue + 2, pbClientY, cbClientY);

    *pcbClientExchangeValue = 2 + cbClientY;


    //
    // Build the session keys.
    //

    pctRet = MakeSessionKeys(pContext,
                             pZombie->hMasterProv,
                             pZombie->hMasterKey);
    if(pctRet != PCT_ERR_OK)
    {
        goto cleanup;
    }

    // Update perf counter.
    InterlockedIncrement(&g_cClientHandshakes);

    pctRet = PCT_ERR_OK;


cleanup:

    if(pbBlob)
    {
        SPExternalFree(pbBlob);
    }

    if(hClientDHKey)
    {
        SchCryptDestroyKey(hClientDHKey, pZombie->dwCapiFlags);
    }

    return pctRet;
}


//+---------------------------------------------------------------------------
//
//  Function:   PkcsGenerateServerMasterKey
//
//  Synopsis:   Decrypt the master secret (from the ClientKeyExchange message)
//              and derive the session keys from it.
//
//  Arguments:  [pContext]              --  Schannel context.
//              [pClientClearValue]     --  Not used.
//              [cbClientClearValue]    --  Not used.
//              [pClientExchangeValue]  --
//              [cbClientExchangeValue] --
//
//  History:    03-25-98   jbanes   Created.
//
//  Notes:      The following data is supposed to be in the input buffer:
//
//              struct {
//                 opaque dh_Yc<1..2^16-1>;
//              } ClientDiffieHellmanPublic;
//
//----------------------------------------------------------------------------
SP_STATUS
WINAPI
DHGenerateServerMasterKey(
    SPContext     * pContext,               // in
    PUCHAR          pClientClearValue,      // in
    DWORD           cbClientClearValue,     // in
    PUCHAR          pClientExchangeValue,   // in
    DWORD           cbClientExchangeValue)  // in
{
    PSessCacheItem  pZombie;
    ALG_ID          Algid;
    SP_STATUS       pctRet;
    PBYTE           pbClientY;
    DWORD           cbClientY;
    HCRYPTKEY       hTek;
    BOOL            fImpersonating = FALSE;


    pZombie = pContext->RipeZombie;
    if(pZombie == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    if(pZombie->hMasterProv == 0)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    // We're doing a full handshake.
    pContext->Flags |= CONTEXT_FLAG_FULL_HANDSHAKE;

    fImpersonating = SslImpersonateClient();

    pctRet = GetDHEphemKey(pContext, 
                           NULL,
                           &hTek);
    if(pctRet != PCT_ERR_OK)
    {
        SP_LOG_RESULT(pctRet);
        goto cleanup;
    }

    if(pZombie->fProtocol == SP_PROT_SSL3_SERVER)
    {
        Algid = CALG_SSL3_MASTER;
    }
    else if(pZombie->fProtocol == SP_PROT_TLS1_SERVER)
    {
        Algid = CALG_TLS1_MASTER;
    }
    else
    {
        pctRet = SP_LOG_RESULT(PCT_INT_SPECS_MISMATCH);
        goto cleanup;
    }

    //
    // Parse ClientKeyExchange message.
    //

    if(pClientExchangeValue == NULL || cbClientExchangeValue <= 2)
    {
        pctRet = SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
        goto cleanup;
    }

    cbClientY = MAKEWORD(pClientExchangeValue[1], pClientExchangeValue[0]);
    pbClientY = pClientExchangeValue + 2;

    if(2 + cbClientY != cbClientExchangeValue)
    {
        pctRet = SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
        goto cleanup;
    }


    //
    // Import the client's public key and generate the master secret.
    //

    {
        BLOBHEADER *   pBlobHeader;
        DHPUBKEY *     pDHPubKey;
        PBYTE          pbKey;
        PBYTE          pbBlob;
        DWORD          cbBlob;

        // Build PUBLICKEYBLOB around the server's public key.
        cbBlob = sizeof(BLOBHEADER) + sizeof(DHPUBKEY) + cbClientY;
        pbBlob = SPExternalAlloc(cbBlob);
        if(pbBlob == NULL)
        {
            pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            goto cleanup;
        }

        pBlobHeader = (BLOBHEADER *)pbBlob;
        pDHPubKey   = (DHPUBKEY *)(pBlobHeader + 1);
        pbKey       = (PBYTE)(pDHPubKey + 1);

        pBlobHeader->bType    = PUBLICKEYBLOB;
        pBlobHeader->bVersion = CUR_BLOB_VERSION;
        pBlobHeader->reserved = 0;
        pBlobHeader->aiKeyAlg = CALG_DH_EPHEM;

        pDHPubKey->magic  = MAGIC_DH1;
        pDHPubKey->bitlen = cbClientY * 8;

        ReverseMemCopy(pbKey, pbClientY, cbClientY);

        if(!SchCryptImportKey(pZombie->hMasterProv,
                              pbBlob,
                              cbBlob,
                              hTek,
                              0,
                              &pZombie->hMasterKey,
                              pZombie->dwCapiFlags))
        {
            pctRet = GetLastError();
            SPExternalFree(pbBlob);
            goto cleanup;
        }

        SPExternalFree(pbBlob);
    }


    //
    // Convert the agreed key to the appropriate master key type.
    //

    if(!SchCryptSetKeyParam(pZombie->hMasterKey,
                            KP_ALGID, (PBYTE)&Algid,
                            0,
                            pZombie->dwCapiFlags))
    {
        pctRet = SP_LOG_RESULT(GetLastError());
        goto cleanup;
    }


    //
    // Build the session keys.
    //

    pctRet = MakeSessionKeys(pContext,
                             pZombie->hMasterProv,
                             pZombie->hMasterKey);
    if(pctRet != PCT_ERR_OK)
    {
        goto cleanup;
    }

    // Update perf counter.
    InterlockedIncrement(&g_cServerHandshakes);

    pctRet = PCT_ERR_OK;


cleanup:

    if(fImpersonating)
    {
        RevertToSelf();
    }

    return pctRet;
}


void
ReverseInPlace(PUCHAR pByte, DWORD cbByte)
{
    DWORD i;
    BYTE bSave;

    for(i=0; i< cbByte/2; i++)
    {
        bSave = pByte[i];
        pByte[i] = pByte[cbByte-i-1];
        pByte[cbByte-i-1] = bSave;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\spbase\oidenc.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:	    oidenc.c
//
//  Contents:   SCHANNEL encode/decode functions
//
//              ASN.1 implementation uses the Asn1 compiler.
//
//  Functions:  InitSchannelAsn1
//              ShutdownSchannelAsn1
//
//  History:	03-Dec-98	philh   changed to use msasn1
//
//--------------------------------------------------------------------------


#include <spbase.h>
#include <pkiasn1.h>
#include <crypttls.h>
#include <oidenc.h>
#include "asn1enc.h"


VOID
ReverseMemCopy(
    PUCHAR      Dest,
    PUCHAR      Source,
    ULONG       Size) ;

#define PRIVATE_KEY_TAG "private-key"


// All the *pvInfo extra stuff needs to be aligned
#define INFO_LEN_ALIGN(Len)  ((Len + 7) & ~7)

static HCRYPTASN1MODULE hAsn1Module;

//+-------------------------------------------------------------------------
//  Function:  GetEncoder/GetDecoder
//
//  Synopsis:  Initialize thread local storage for the asn libs
//
//  Returns:   pointer to an initialized Asn1 encoder/decoder data
//             structures
//--------------------------------------------------------------------------
static ASN1encoding_t GetEncoder(void)
{
    return I_CryptGetAsn1Encoder(hAsn1Module);
}
static ASN1decoding_t GetDecoder(void)
{
    return I_CryptGetAsn1Decoder(hAsn1Module);
}

//+-------------------------------------------------------------------------
//  Asn1 SCHANNEL Private Encode/Decode functions
//--------------------------------------------------------------------------

BOOL
WINAPI
Asn1RSAPublicEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PUBLICKEYSTRUC *pbKeyStruc,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );

BOOL
WINAPI
Asn1PrivateKeyFileEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PPRIVATE_KEY_FILE_ENCODE pKey,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );

BOOL
WINAPI
Asn1PrivateKeyFileDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PPRIVATE_KEY_FILE_ENCODE pKey,
        IN OUT DWORD *pcbKey
        );


BOOL
WINAPI
Asn1PrivateKeyInfoEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN BLOBHEADER * pKey,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );

BOOL
WINAPI
Asn1PrivateKeyInfoDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT BLOBHEADER * pKey,
        IN OUT DWORD *pcbKey
        );

static BOOL WINAPI Asn1X509CtlUsageDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCTL_USAGE pInfo,
        IN OUT DWORD *pcbInfo
        );


static const CRYPT_OID_FUNC_ENTRY SchannelEncodeFuncTable[] = {
    szPrivateKeyFileEncode, Asn1PrivateKeyFileEncode,
    szPrivateKeyInfoEncode, Asn1PrivateKeyInfoEncode,
    szOID_RSA_RSA_Public,    Asn1RSAPublicEncode
};

#define SCHANNEL_ENCODE_FUNC_COUNT (sizeof(SchannelEncodeFuncTable) / \
                                    sizeof(SchannelEncodeFuncTable[0]))


static const CRYPT_OID_FUNC_ENTRY SchannelDecodeFuncTable[] = {
    szPrivateKeyFileEncode,                 Asn1PrivateKeyFileDecode,
    szPrivateKeyInfoEncode,                 Asn1PrivateKeyInfoDecode,
    X509_ENHANCED_KEY_USAGE,                Asn1X509CtlUsageDecode
};

#define SCHANNEL_DECODE_FUNC_COUNT (sizeof(SchannelDecodeFuncTable) / \
                                    sizeof(SchannelDecodeFuncTable[0]))


//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL
WINAPI
InitSchannelAsn1(
        HMODULE hModule)
{
    ASN1ENC_Module_Startup();
    if (0 == (hAsn1Module = I_CryptInstallAsn1Module(ASN1ENC_Module, 0, NULL)))
    {
        return FALSE;
    }

    if (!CryptInstallOIDFunctionAddress(
            hModule,
            X509_ASN_ENCODING,
            CRYPT_OID_DECODE_OBJECT_FUNC,
            SCHANNEL_DECODE_FUNC_COUNT,
            SchannelDecodeFuncTable,
            0))
    {
        return FALSE;
    }

    if (!CryptInstallOIDFunctionAddress(
            hModule,
            X509_ASN_ENCODING,
            CRYPT_OID_ENCODE_OBJECT_FUNC,
            SCHANNEL_ENCODE_FUNC_COUNT,
            SchannelEncodeFuncTable,
            0))
    {
        return FALSE;
    }
    return TRUE;
}

BOOL
WINAPI
ShutdownSchannelAsn1()
{
    if (hAsn1Module)
    {
        I_CryptUninstallAsn1Module(hAsn1Module);
        ASN1ENC_Module_Cleanup();
        hAsn1Module = 0;
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//  Encode an Asn1 formatted info structure
//
//  Called by the Asn1X509*Encode() functions.
//--------------------------------------------------------------------------
static BOOL Asn1InfoEncode(
        IN int pdunum,
        IN void *pAsn1Info,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    ASN1encoding_t Encoder;
    
    if((Encoder = GetEncoder()) == NULL) 
    {
        return FALSE;
    }

    return PkiAsn1EncodeInfo(
        Encoder,
        pdunum,
        pAsn1Info,
        pbEncoded,
        pcbEncoded);
}

//+-------------------------------------------------------------------------
//  Encode an Asn1 formatted info structure
//
//  Called by the Asn1X509*Encode() functions.
//--------------------------------------------------------------------------
static BOOL Asn1InfoEncodeAndAlloc(
        IN int pdunum,
        IN void *pAsn1Info,
        OUT BYTE **ppEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    ASN1encoding_t Encoder;
    
    if((Encoder = GetEncoder()) == NULL) 
    {
        return FALSE;
    }

    if(!PkiAsn1EncodeInfo(
        Encoder,
        pdunum,
        pAsn1Info,
        NULL,
        pcbEncoded))
    {
        return FALSE;
    }
    *ppEncoded = SPExternalAlloc(*pcbEncoded);
    if(*ppEncoded == NULL)
    {
        return FALSE;
    }
    if(!PkiAsn1EncodeInfo(
        Encoder,
        pdunum,
        pAsn1Info,
        *ppEncoded,
        pcbEncoded))
    {
        SPExternalFree(*ppEncoded);
        return FALSE;
    }
    return TRUE;

}

//+-------------------------------------------------------------------------
//  Decode into an allocated, Asn1 formatted info structure
//
//  Called by the Asn1X509*Decode() functions.
//--------------------------------------------------------------------------
static BOOL Asn1InfoDecodeAndAlloc(
        IN int pdunum,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT void **ppAsn1Info
        )
{
    ASN1decoding_t Decoder;
    
    if((Decoder = GetDecoder()) == NULL) 
    {
        return FALSE;
    }

    return PkiAsn1DecodeAndAllocInfo(
        Decoder,
        pdunum,
        pbEncoded,
        cbEncoded,
        ppAsn1Info);
}

//+-------------------------------------------------------------------------
//  Free an allocated, Asn1 formatted info structure
//
//  Called by the Asn1X509*Decode() functions.
//--------------------------------------------------------------------------
static void Asn1InfoFree(
        IN int pdunum,
        IN void *pAsn1Info
        )
{
    ASN1decoding_t Decoder;
    
    if((Decoder = GetDecoder()) == NULL) 
    {
        return;
    }

    if (pAsn1Info) 
    {
        DWORD dwErr = GetLastError();

        // TlsGetValue globbers LastError
        PkiAsn1FreeInfo(Decoder, pdunum, pAsn1Info);

        SetLastError(dwErr);
    }
}

SP_STATUS
RsaPublicKeyFromCert(
    PCERT_PUBLIC_KEY_INFO pPublicKeyInfo,
    BLOBHEADER *pBlob,
    PDWORD      pcbBlob)
{
    SP_STATUS pctRet;

    if(!CryptDecodeObject(X509_ASN_ENCODING,
                          RSA_CSP_PUBLICKEYBLOB,
                          pPublicKeyInfo->PublicKey.pbData,
                          pPublicKeyInfo->PublicKey.cbData,
                          0,
                          pBlob,
                          pcbBlob))
    {
        pctRet = GetLastError();
        return SP_LOG_RESULT(pctRet);
    }

    return PCT_ERR_OK;
}


/*****************************************************************************/
SP_STATUS
DssPublicKeyFromCert(
    PCERT_PUBLIC_KEY_INFO pPublicKeyInfo,
    BLOBHEADER *pBlob,
    PDWORD      pcbBlob)
{
    CRYPT_UINT_BLOB *pPublic = NULL;
    DWORD cbPublic;
    CERT_DSS_PARAMETERS *pParams = NULL;
    DWORD cbParams;
    DSSPUBKEY *pDssPubKey = NULL;
    DSSSEED *pSeed = NULL;
    PBYTE pbData = NULL;
    DWORD cbBlob;
    SP_STATUS pctRet;

    //
    // Estimate size of DSS public key blob.
    //

    if(!CryptDecodeObject(X509_ASN_ENCODING,
                          X509_DSS_PUBLICKEY,
                          pPublicKeyInfo->PublicKey.pbData,
                          pPublicKeyInfo->PublicKey.cbData,
                          0,
                          NULL,
                          &cbPublic))
    {
        pctRet = GetLastError();
        return SP_LOG_RESULT(pctRet);
    }

    if(!CryptDecodeObject(X509_ASN_ENCODING,
                          X509_DSS_PARAMETERS,
                          pPublicKeyInfo->Algorithm.Parameters.pbData,
                          pPublicKeyInfo->Algorithm.Parameters.cbData,
                          0,
                          NULL,
                          &cbParams))
    {
        pctRet = GetLastError();
        return SP_LOG_RESULT(pctRet);
    }

    cbBlob = sizeof(BLOBHEADER) + sizeof(DSSPUBKEY) + cbPublic + cbParams;

    if(pBlob == NULL)
    {
        *pcbBlob = cbBlob;
        return PCT_ERR_OK;
    }
    if(*pcbBlob < cbBlob)
    {
        *pcbBlob = cbBlob;
        return SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
    }


    // 
    // Decode public key info.
    //

    pPublic = SPExternalAlloc(cbPublic + cbParams);
    if(pPublic == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }
    pParams = (CERT_DSS_PARAMETERS *)((PBYTE)pPublic + cbPublic);


    if(!CryptDecodeObject(X509_ASN_ENCODING,
                          X509_DSS_PUBLICKEY,
                          pPublicKeyInfo->PublicKey.pbData,
                          pPublicKeyInfo->PublicKey.cbData,
                          0,
                          pPublic,
                          &cbPublic))
    {
        pctRet = SP_LOG_RESULT(GetLastError());
        goto cleanup;
    }

    if(!CryptDecodeObject(X509_ASN_ENCODING,
                          X509_DSS_PARAMETERS,
                          pPublicKeyInfo->Algorithm.Parameters.pbData,
                          pPublicKeyInfo->Algorithm.Parameters.cbData,
                          0,
                          pParams,
                          &cbParams))
    {
        pctRet = SP_LOG_RESULT(GetLastError());
        goto cleanup;
    }


    // 
    // Build PUBLICKEYBLOB
    //

    pBlob->bType    = PUBLICKEYBLOB;
    pBlob->bVersion = CUR_BLOB_VERSION;
    pBlob->reserved = 0;
    pBlob->aiKeyAlg = CALG_DSS_SIGN;

    pDssPubKey = (DSSPUBKEY *)(pBlob + 1);
    pDssPubKey->magic  = MAGIC_DSS1;
    pDssPubKey->bitlen = pPublic->cbData * 8;

    pbData = (PBYTE)(pDssPubKey + 1);

    CopyMemory(pbData, pParams->p.pbData, pParams->p.cbData);
    pbData += pParams->p.cbData;

    CopyMemory(pbData, pParams->q.pbData, pParams->q.cbData);
    pbData += pParams->q.cbData;

    CopyMemory(pbData, pParams->g.pbData, pParams->g.cbData);
    pbData += pParams->g.cbData;

    CopyMemory(pbData, pPublic->pbData, pPublic->cbData);
    pbData += pPublic->cbData;

    pSeed = (DSSSEED *)pbData;
    pSeed->counter = 0xffffffff;
    ZeroMemory(pSeed->seed, sizeof(pSeed->seed));
    pbData += sizeof(DSSSEED);


    *pcbBlob = (DWORD)((PBYTE)pbData - (PBYTE)pBlob);


    pctRet = PCT_ERR_OK;

cleanup:

    if(pPublic) SPExternalFree(pPublic);

    return pctRet;
}


#define  my_isdigit(ch) ((ch >= '0') && (ch <= '9'))

//+-------------------------------------------------------------------------
//  Convert the ascii string ("1.2.9999") to Asn1's Object Identifier
//  represented as an array of unsigned longs.
//
//  Returns TRUE for a successful conversion.
//--------------------------------------------------------------------------
BOOL
WINAPI
OIDFromString(
    IN LPCSTR pszObjId,
    IN OUT unsigned short *pCount,
    OUT unsigned long rgulValue[]
    )
{
    BOOL fResult = TRUE;
    unsigned short c = 0;
    LPSTR psz = (LPSTR) pszObjId;
    if (psz) {
        unsigned short cMax = *pCount;
        unsigned long *pul = rgulValue;
        while (*psz != '\0' && c++ < cMax) {
            *pul = 0;
            while (my_isdigit(*psz))
            {
                *pul = ((*pul) * 10) + (*psz++) - '0';
            }
            pul++;
            if (*psz != '.')
                break;
            psz++;
        }
        if (*psz != '\0')
            fResult = FALSE;
    }
    *pCount = c;
    return fResult;
}

BOOL
WINAPI
Asn1PrivateKeyInfoEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN BLOBHEADER * pKey,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{

    PrivateKeyInfo KeyInfo;
    BOOL fRet;

    // First encode the private key data, depending on
    // the algorithm.
    switch(pKey->aiKeyAlg)
    {
    case CALG_RSA_SIGN:
    case CALG_RSA_KEYX:
        {
            RSAPUBKEY *pRsaPub = (RSAPUBKEY *)(pKey+1);
            RSAPrivateKey RsaPrivate;
            PBYTE   pbRsaBlob, pbRsaBlobSav;
            PBYTE   pbDataBlob = NULL, pbDataBlobSav;
            DWORD   dwDataBlob = 0;

            // Covert the RSA key into the RSAPrivateKey structure
            RsaPrivate.version = 0;
            dwDataBlob = (9 * (pRsaPub->bitlen/16)) + 7 ;
            pbDataBlobSav = pbDataBlob = SPExternalAlloc(dwDataBlob);
            if(pbDataBlob == NULL)
            {
                return FALSE;
            }

            //Copy Modulus
            *pbDataBlob = 0;
            pbRsaBlobSav = pbRsaBlob = (PBYTE)(pRsaPub+1);
            CopyMemory(pbDataBlob+1, pbRsaBlob, pRsaPub->bitlen/8);
            PkiAsn1ReverseBytes(pbDataBlob + 1, pRsaPub->bitlen/8);

            RsaPrivate.modulus.value = pbDataBlob;
            RsaPrivate.modulus.length = (pRsaPub->bitlen/8) + 1;
            pbDataBlob += (pRsaPub->bitlen/8) + 1;
            pbRsaBlob += (pRsaPub->bitlen/8);

            RsaPrivate.publicExponent = pRsaPub->pubexp;

            //Copy Prime1
            *pbDataBlob = 0;
            CopyMemory(pbDataBlob+1, pbRsaBlob, pRsaPub->bitlen/16);
            PkiAsn1ReverseBytes(pbDataBlob + 1, pRsaPub->bitlen/16);

            RsaPrivate.prime1.value = pbDataBlob;
            RsaPrivate.prime1.length = (pRsaPub->bitlen/16) + 1;
            pbDataBlob += (pRsaPub->bitlen/16) + 1;
            pbRsaBlob += (pRsaPub->bitlen/16);

            //Copy Prime2
            *pbDataBlob = 0;
            CopyMemory(pbDataBlob+1, pbRsaBlob, pRsaPub->bitlen/16);
            PkiAsn1ReverseBytes(pbDataBlob + 1, pRsaPub->bitlen/16);

            RsaPrivate.prime2.value = pbDataBlob;
            RsaPrivate.prime2.length = (pRsaPub->bitlen/16) + 1;
            pbDataBlob += (pRsaPub->bitlen/16) + 1;
            pbRsaBlob += (pRsaPub->bitlen/16);


            //Copy exponent1
            *pbDataBlob = 0;
            CopyMemory(pbDataBlob+1, pbRsaBlob, pRsaPub->bitlen/16);
            PkiAsn1ReverseBytes(pbDataBlob + 1, pRsaPub->bitlen/16);

            RsaPrivate.exponent1.value = pbDataBlob;
            RsaPrivate.exponent1.length = (pRsaPub->bitlen/16) + 1;
            pbDataBlob += (pRsaPub->bitlen/16) + 1;
            pbRsaBlob += (pRsaPub->bitlen/16);

            //Copy exponent2
            *pbDataBlob = 0;
            CopyMemory(pbDataBlob+1, pbRsaBlob, pRsaPub->bitlen/16);
            PkiAsn1ReverseBytes(pbDataBlob + 1, pRsaPub->bitlen/16);

            RsaPrivate.exponent2.value = pbDataBlob;
            RsaPrivate.exponent2.length = (pRsaPub->bitlen/16) + 1;
            pbDataBlob += (pRsaPub->bitlen/16) + 1;
            pbRsaBlob += (pRsaPub->bitlen/16);

            //Copy coefficient
            *pbDataBlob = 0;
            CopyMemory(pbDataBlob+1, pbRsaBlob, pRsaPub->bitlen/16);
            PkiAsn1ReverseBytes(pbDataBlob + 1, pRsaPub->bitlen/16);

            RsaPrivate.coefficient.value = pbDataBlob;
            RsaPrivate.coefficient.length = (pRsaPub->bitlen/16) + 1;
            pbDataBlob += (pRsaPub->bitlen/16) + 1;
            pbRsaBlob += (pRsaPub->bitlen/16);

            //Copy privateExponent
            *pbDataBlob = 0;
            CopyMemory(pbDataBlob+1, pbRsaBlob, pRsaPub->bitlen/8);
            PkiAsn1ReverseBytes(pbDataBlob + 1, pRsaPub->bitlen/8);

            RsaPrivate.privateExponent.value = pbDataBlob;
            RsaPrivate.privateExponent.length = (pRsaPub->bitlen/8) + 1;
            pbDataBlob += (pRsaPub->bitlen/8) + 1;
            pbRsaBlob += (pRsaPub->bitlen/8);


            fRet = Asn1InfoEncodeAndAlloc(RSAPrivateKey_PDU,
                                 &RsaPrivate,
                                 &KeyInfo.privateKey.value,
                                 &KeyInfo.privateKey.length);
            SPExternalFree(pbDataBlobSav);
            if(!fRet)
            {
                return FALSE;
            }
            KeyInfo.privateKeyAlgorithm.bit_mask = 0;
            KeyInfo.privateKeyAlgorithm.algorithm.count =sizeof(KeyInfo.privateKeyAlgorithm.algorithm.value)/sizeof(KeyInfo.privateKeyAlgorithm.algorithm.value[0]);


            fRet = OIDFromString(  szOID_RSA_RSA,
                                        &KeyInfo.privateKeyAlgorithm.algorithm.count,
                                        KeyInfo.privateKeyAlgorithm.algorithm.value);
            if(!fRet)
            {
                SPExternalFree(KeyInfo.privateKey.value);
                return FALSE;
            }

            break;
      }

    default:
        return FALSE;
    }

    // Set up the KeyInfo struct
    KeyInfo.bit_mask = 0;
    KeyInfo.version = 0;

    fRet =  Asn1InfoEncode(
        PrivateKeyInfo_PDU,
        &KeyInfo,
        pbEncoded,
        pcbEncoded
        );

    SPExternalFree(KeyInfo.privateKey.value);
    return fRet;
}

BOOL
WINAPI
Asn1PrivateKeyFileEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PPRIVATE_KEY_FILE_ENCODE pKey,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{

    PrivateKeyFile File;
    BOOL fRet;

    File.privateKey.privateKey.value = pKey->EncryptedBlob.pbData;
    File.privateKey.privateKey.length = pKey->EncryptedBlob.cbData;

    File.privateKey.privateKeyAlgorithm.bit_mask = 0;
    File.privateKey.privateKeyAlgorithm.algorithm.count = sizeof(File.privateKey.privateKeyAlgorithm.algorithm.value)/sizeof(File.privateKey.privateKeyAlgorithm.algorithm.value[0]);

    OIDFromString(  pKey->Alg.pszObjId,
                    &File.privateKey.privateKeyAlgorithm.algorithm.count,
                    File.privateKey.privateKeyAlgorithm.algorithm.value);

    File.name.value = PRIVATE_KEY_TAG;
    File.name.length = strlen(PRIVATE_KEY_TAG);

    fRet =  Asn1InfoEncode(
        PrivateKeyFile_PDU,
        &File,
        pbEncoded,
        pcbEncoded
        );

    return fRet;

}


BOOL
WINAPI
Asn1PrivateKeyInfoDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT BLOBHEADER *pKey,
        IN OUT DWORD *pcbKey
        )

{
    PrivateKeyInfo *pKeyInfo = NULL;
    DWORD cbKey;
    DWORD cbMod;

    BOOL fResult = FALSE;

    // Now crack the key info
    fResult = Asn1InfoDecodeAndAlloc(PrivateKeyInfo_PDU,
                                        pbEncoded,
                                        cbEncoded,
                                        (void **)&pKeyInfo);
    if(!fResult)
    {
        return FALSE;
    }



    fResult = FALSE;
    do
    {
        USHORT cbOID;
        DWORD psOID[16];

        cbOID = sizeof(psOID)/sizeof(psOID[0]);

        OIDFromString(  szOID_RSA_RSA,
                        &cbOID,
                        psOID);

        if((cbOID == pKeyInfo->privateKeyAlgorithm.algorithm.count) &&
            (memcmp(pKeyInfo->privateKeyAlgorithm.algorithm.value, psOID, cbOID*sizeof(psOID[0]))==0))
        {
            RSAPUBKEY *     pRsaPub;
            RSAPrivateKey * pRsaPrivate = NULL;
            PBYTE *         pbDataBlob;
            PBYTE           pbCurrent;
            RSAPrivateKey   RsaPrivate;

            fResult = Asn1InfoDecodeAndAlloc(RSAPrivateKey_PDU,
                                            pKeyInfo->privateKey.value,
                                            pKeyInfo->privateKey.length,
                                            (void **)&pRsaPrivate);
            if(!fResult)
            {
                break;
            }

            RsaPrivate = *pRsaPrivate;

            // We successfully decrypted an RSA Private Key,
            // so now turn it into a pRsaPub;

            // Make some adjustmenst to the lengths of things if we have leading zeros
            if(RsaPrivate.modulus.length && (0 == *(PBYTE)RsaPrivate.modulus.value))
            {
                RsaPrivate.modulus.value++;
                RsaPrivate.modulus.length--;
            }
            if(RsaPrivate.prime1.length && (0 == *(PBYTE)RsaPrivate.prime1.value))
            {
                RsaPrivate.prime1.value++;
                RsaPrivate.prime1.length--;
            }
            if(RsaPrivate.prime2.length && (0 == *(PBYTE)RsaPrivate.prime2.value))
            {
                RsaPrivate.prime2.value++;
                RsaPrivate.prime2.length--;
            }

            if(RsaPrivate.exponent1.length && (0 == *(PBYTE)RsaPrivate.exponent1.value))
            {
                RsaPrivate.exponent1.value++;
                RsaPrivate.exponent1.length--;
            }
            if(RsaPrivate.exponent2.length && (0 == *(PBYTE)RsaPrivate.exponent2.value))
            {
                RsaPrivate.exponent2.value++;
                RsaPrivate.exponent2.length--;
            }

            if(RsaPrivate.coefficient.length && (0 == *(PBYTE)RsaPrivate.coefficient.value))
            {
                RsaPrivate.coefficient.value++;
                RsaPrivate.coefficient.length--;
            }
            if(RsaPrivate.privateExponent.length && (0 == *(PBYTE)RsaPrivate.privateExponent.value))
            {
                RsaPrivate.privateExponent.value++;
                RsaPrivate.privateExponent.length--;
            }

            cbMod = (RsaPrivate.modulus.length + sizeof(DWORD) - 1) & ~(sizeof(DWORD)-1);
            cbKey = sizeof(BLOBHEADER) + sizeof(RSAPUBKEY) + (cbMod*9)/2;
            if(pKey == NULL)
            {
                *pcbKey = cbKey;
                fResult = TRUE;
                Asn1InfoFree(RSAPrivateKey_PDU, pRsaPrivate);
                break;
            }

            // we're actually unpacking this key.
            if(*pcbKey < cbKey)
            {
                fResult = FALSE;
                Asn1InfoFree(RSAPrivateKey_PDU, pRsaPrivate);
                break;
            }

            pKey->bType = PRIVATEKEYBLOB;
            pKey->bVersion = 2;
            pKey->reserved = 0;
            pKey->aiKeyAlg = CALG_RSA_KEYX;

            pRsaPub = (RSAPUBKEY *)(pKey+1);
            pRsaPub->magic = ((DWORD)'R'+((DWORD)'S'<<8)+((DWORD)'A'<<16)+((DWORD)'2'<<24));
            pRsaPub->bitlen = cbMod*8;
            pRsaPub->pubexp = RsaPrivate.publicExponent;
            pbCurrent = (PBYTE)(pRsaPub + 1);
            ReverseMemCopy(pbCurrent, RsaPrivate.modulus.value, RsaPrivate.modulus.length);
            pbCurrent += cbMod;

            ReverseMemCopy(pbCurrent, RsaPrivate.prime1.value, RsaPrivate.prime1.length);
            pbCurrent += cbMod/2;

            ReverseMemCopy(pbCurrent, RsaPrivate.prime2.value, RsaPrivate.prime2.length);
            pbCurrent += cbMod/2;

            ReverseMemCopy(pbCurrent, RsaPrivate.exponent1.value, RsaPrivate.exponent1.length);
            pbCurrent += cbMod/2;

            ReverseMemCopy(pbCurrent, RsaPrivate.exponent2.value, RsaPrivate.exponent2.length);
            pbCurrent += cbMod/2;

            ReverseMemCopy(pbCurrent, RsaPrivate.coefficient.value, RsaPrivate.coefficient.length);
            pbCurrent += cbMod/2;

            ReverseMemCopy(pbCurrent, RsaPrivate.privateExponent.value, RsaPrivate.privateExponent.length);
            pbCurrent += cbMod;
            *pcbKey = cbKey;
            Asn1InfoFree(RSAPrivateKey_PDU, pRsaPrivate);

        }

    }while(FALSE);

    Asn1InfoFree(PrivateKeyInfo_PDU, pKeyInfo);
    return fResult;
}

BOOL
WINAPI
Asn1PrivateKeyFileDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PPRIVATE_KEY_FILE_ENCODE pKey,
        IN OUT DWORD *pcbKey
        )

{
    PrivateKeyFile *pFile = NULL;
    DWORD           cbPrivateKeyStruct;

    BOOL fResult = FALSE;

    // Decode the file

    if(!Asn1InfoDecodeAndAlloc(PrivateKeyFile_PDU,
                                        pbEncoded,
                                        cbEncoded,
                                        (void **)&pFile))
    {
        DWORD dwFoo = GetLastError();
        return FALSE;
    }

    cbPrivateKeyStruct = pFile->privateKey.privateKey.length + sizeof(PRIVATE_KEY_FILE_ENCODE);
    if(pKey == NULL)
    {
        *pcbKey = cbPrivateKeyStruct;
        fResult = TRUE;
    }
    else
    {
        if(*pcbKey < cbPrivateKeyStruct)
        {
            fResult = FALSE;
        }
        else
        {
            pKey->EncryptedBlob.cbData = pFile->privateKey.privateKey.length;
            pKey->EncryptedBlob.pbData = (PBYTE)(pKey + 1);
            pKey->EncryptedBlob.cUnusedBits = 0;
            CopyMemory(pKey->EncryptedBlob.pbData, pFile->privateKey.privateKey.value, pKey->EncryptedBlob.cbData);
            fResult = TRUE;
        }
    }

    Asn1InfoFree(PrivateKeyFile_PDU, pFile);
    return fResult;

}


BOOL
WINAPI
Asn1RSAPublicEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PUBLICKEYSTRUC *pbKeyStruc,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return CryptEncodeObject(dwCertEncodingType,
                      RSA_CSP_PUBLICKEYBLOB,
                      pbKeyStruc,
                      pbEncoded,
                      pcbEncoded);
}


static void Asn1X509GetObjId(
        IN ObjectID *pAsn1,
        IN DWORD dwFlags,
        OUT LPSTR *ppszObjId,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    DWORD cbObjId;

    cbObjId = lRemainExtra > 0 ? lRemainExtra : 0;
    PkiAsn1FromObjectIdentifier(
        pAsn1->count,
        pAsn1->value,
        (LPSTR) pbExtra,
        &cbObjId
        );

    lAlignExtra = INFO_LEN_ALIGN(cbObjId);
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if(cbObjId) {
            *ppszObjId = (LPSTR) pbExtra;
        } else
            *ppszObjId = NULL;
        pbExtra += lAlignExtra;
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

static void Asn1X509GetCtlUsage(
        IN EnhancedKeyUsage *pAsn1,
        IN DWORD dwFlags,
        OUT PCTL_USAGE pUsage,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;

    DWORD cId;
    UsageIdentifier *pAsn1Id;
    LPSTR *ppszId;

    cId = pAsn1->count;
    lAlignExtra = INFO_LEN_ALIGN(cId * sizeof(LPSTR));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        pUsage->cUsageIdentifier = cId;
        ppszId = (LPSTR *) pbExtra;
        pUsage->rgpszUsageIdentifier = ppszId;
        pbExtra += lAlignExtra;
    } else
        ppszId = NULL;

    pAsn1Id = pAsn1->value;
    for ( ; cId > 0; cId--, pAsn1Id++, ppszId++)
        Asn1X509GetObjId(pAsn1Id, dwFlags, ppszId, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}


//+-------------------------------------------------------------------------
//  CTL Usage (Enhanced Key Usage) Decode (Asn1 X509)
//--------------------------------------------------------------------------
static BOOL WINAPI Asn1X509CtlUsageDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCTL_USAGE pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    BOOL fResult;
    EnhancedKeyUsage *pAsn1Info = NULL;
    BYTE *pbExtra;
    LONG lRemainExtra;

    if (pInfo == NULL)
        *pcbInfo = 0;

    if (!Asn1InfoDecodeAndAlloc(
            EnhancedKeyUsage_PDU,
            pbEncoded,
            cbEncoded,
            (void **) &pAsn1Info))
        goto ErrorReturn;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lRemainExtra = (LONG) *pcbInfo - sizeof(CTL_USAGE);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CTL_USAGE);

    Asn1X509GetCtlUsage(pAsn1Info, dwFlags, pInfo, &pbExtra, &lRemainExtra);

    if (lRemainExtra >= 0)
        *pcbInfo = *pcbInfo - (DWORD) lRemainExtra;
    else {
        *pcbInfo = *pcbInfo + (DWORD) -lRemainExtra;
        if (pInfo) goto LengthError;
    }

    fResult = TRUE;
    goto CommonReturn;

LengthError:
    SetLastError((DWORD) ERROR_MORE_DATA);
    fResult = FALSE;
    goto CommonReturn;
ErrorReturn:
    *pcbInfo = 0;
    fResult = FALSE;
CommonReturn:
    Asn1InfoFree(EnhancedKeyUsage_PDU, pAsn1Info);
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\spbase\keyxmspk.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       keyxmspk.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   LSA integration stuff.
//
//----------------------------------------------------------------------------

#include <spbase.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifdef __cplusplus
}
#endif


// PROV_RSA_SCHANNEL handle used when building ClientHello messages.
HCRYPTPROV          g_hRsaSchannel      = 0;
PROV_ENUMALGS_EX *  g_pRsaSchannelAlgs  = NULL;
DWORD               g_cRsaSchannelAlgs  = 0;

SP_STATUS
Ssl3ParseServerKeyExchange(
    PSPContext  pContext,
    PBYTE       pbMessage,
    DWORD       cbMessage,
    HCRYPTKEY   hServerPublic,
    HCRYPTKEY  *phNewServerPublic);

SP_STATUS
PkcsFinishMasterKey(
    PSPContext  pContext,
    HCRYPTKEY   hMasterKey);

SP_STATUS
WINAPI
PkcsGenerateServerExchangeValue(
    SPContext     * pContext,               // in
    PUCHAR          pServerExchangeValue,   // out
    DWORD *         pcbServerExchangeValue  // in/out
);


SP_STATUS
WINAPI
PkcsGenerateClientExchangeValue(
    SPContext     * pContext,               // in
    PUCHAR          pServerExchangeValue,   // in
    DWORD           cbServerExchangeValue,  // in
    PUCHAR          pClientClearValue,      // out
    DWORD *         pcbClientClearValue,    // in/out
    PUCHAR          pClientExchangeValue,   // out
    DWORD *         pcbClientExchangeValue  // in/out
);

SP_STATUS
WINAPI
PkcsGenerateServerMasterKey(
    SPContext     * pContext,               // in
    PUCHAR          pClientClearValue,      // in
    DWORD           cbClientClearValue,     // in
    PUCHAR          pClientExchangeValue,   // in
    DWORD           cbClientExchangeValue   // in
);


KeyExchangeSystem keyexchPKCS = {
    SP_EXCH_RSA_PKCS1,
    "RSA",
//    PkcsPrivateFromBlob,
    PkcsGenerateServerExchangeValue,
    PkcsGenerateClientExchangeValue,
    PkcsGenerateServerMasterKey,
};



VOID
ReverseMemCopy(
    PUCHAR      Dest,
    PUCHAR      Source,
    ULONG       Size)
{
    PUCHAR  p;

    p = Dest + Size - 1;
    do
    {
        *p-- = *Source++;
    } while (p >= Dest);
}

SP_STATUS
GenerateSsl3KeyPair(
    PSPContext  pContext,           // in
    DWORD       dwKeySize,          // in
    HCRYPTPROV *phEphemeralProv,    // out
    HCRYPTKEY * phEphemeralKey)     // out
{
    HCRYPTPROV *         phEphemProv;
    PCRYPT_KEY_PROV_INFO pProvInfo = NULL;
    PSPCredentialGroup   pCredGroup;
    PSPCredential        pCred;
    DWORD                cbSize;
    SP_STATUS            pctRet;

    pCredGroup = pContext->RipeZombie->pServerCred;
    if(pCredGroup == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    LockCredential(pCredGroup);

    pCred = pContext->RipeZombie->pActiveServerCred;
    if(pCred == NULL)
    {
        pctRet = SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
        goto cleanup;
    }

    if(dwKeySize == 512)
    {
        phEphemProv = &pCred->hEphem512Prov;
    } 
    else if(dwKeySize == 1024)
    {
        phEphemProv = &pCred->hEphem1024Prov;
    }
    else
    {
        pctRet = SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
        goto cleanup;
    }


    //
    // Obtain CSP context.
    //

    if(*phEphemProv == 0)
    {
        // Read the certificate context's "key info" property.
        if(CertGetCertificateContextProperty(pCred->pCert,
                                             CERT_KEY_PROV_INFO_PROP_ID,
                                             NULL,
                                             &cbSize))
        {
            pProvInfo = SPExternalAlloc(cbSize);
            if(pProvInfo == NULL)
            {
                pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
                goto cleanup;
            }

            if(!CertGetCertificateContextProperty(pCred->pCert,
                                                  CERT_KEY_PROV_INFO_PROP_ID,
                                                  pProvInfo,
                                                  &cbSize))
            {
                DebugLog((SP_LOG_ERROR, "Error 0x%x reading CERT_KEY_PROV_INFO_PROP_ID\n",GetLastError()));
                SPExternalFree(pProvInfo);
                pProvInfo = NULL;
            }
        }

        // Obtain a "verify only" csp context.
        if(pProvInfo)
        {
            // If the private key belongs to one of the Microsoft PROV_RSA_FULL
            // CSPs, then manually divert it to the Microsoft PROV_RSA_SCHANNEL
            // CSP. This works because both CSP types use the same private key
            // storage scheme.
            if(pProvInfo->dwProvType == PROV_RSA_FULL)
            {
                if(lstrcmpW(pProvInfo->pwszProvName, MS_DEF_PROV_W) == 0 ||
                   lstrcmpW(pProvInfo->pwszProvName, MS_STRONG_PROV_W) == 0 ||
                   lstrcmpW(pProvInfo->pwszProvName, MS_ENHANCED_PROV_W) == 0)
                {
                    DebugLog((DEB_WARN, "Force CSP type to PROV_RSA_SCHANNEL.\n"));
                    pProvInfo->pwszProvName = MS_DEF_RSA_SCHANNEL_PROV_W;
                    pProvInfo->dwProvType   = PROV_RSA_SCHANNEL;
                }
            }

            if(!SchCryptAcquireContextW(phEphemProv,
                                        NULL,
                                        pProvInfo->pwszProvName,
                                        pProvInfo->dwProvType,
                                        CRYPT_VERIFYCONTEXT,
                                        pCred->dwCapiFlags))
            {
                SP_LOG_RESULT(GetLastError());
                pctRet = SEC_E_NO_CREDENTIALS;
                goto cleanup;
            }

            SPExternalFree(pProvInfo);
            pProvInfo = NULL;
        }
        else
        {
            if(!SchCryptAcquireContextW(phEphemProv,
                                        NULL,
                                        NULL,
                                        PROV_RSA_SCHANNEL,
                                        CRYPT_VERIFYCONTEXT,
                                        pCred->dwCapiFlags))
            {
                SP_LOG_RESULT(GetLastError());
                pctRet = SEC_E_NO_CREDENTIALS;
                goto cleanup;
            }
        }
    }

    
    // 
    // Obtain handle to private key.
    //

    if(!SchCryptGetUserKey(*phEphemProv,
                           AT_KEYEXCHANGE,
                           phEphemeralKey,
                           pCred->dwCapiFlags))
    {
        // Key does not exist, so attempt to create one.
        DebugLog((DEB_TRACE, "Creating %d-bit ephemeral key.\n", dwKeySize));
        if(!SchCryptGenKey(*phEphemProv,
                           AT_KEYEXCHANGE,
                           (dwKeySize << 16),
                           phEphemeralKey,
                           pCred->dwCapiFlags))
        {
            DebugLog((DEB_ERROR, "Error 0x%x generating ephemeral key\n", GetLastError()));
            pctRet = SEC_E_NO_CREDENTIALS;
            goto cleanup;
        }
        DebugLog((DEB_TRACE, "Ephemeral key created okay.\n"));
    }


    *phEphemeralProv = *phEphemProv;

    pctRet = PCT_ERR_OK;

cleanup:

    if(pProvInfo)
    {
        SPExternalFree(pProvInfo);
    }

    UnlockCredential(pCredGroup);

    return pctRet;
}


//+---------------------------------------------------------------------------
//
//  Function:   PkcsGenerateServerExchangeValue
//
//  Synopsis:   Create a ServerKeyExchange message, containing an ephemeral
//              RSA key.
//
//  Arguments:  [pContext]                  --  Schannel context.
//              [pServerExchangeValue]      --
//              [pcbServerExchangeValue]    --
//
//  History:    10-09-97   jbanes   Added CAPI integration.
//
//  Notes:      This routine is called by the server-side only.
//
//              In the case of SSL3 or TLS, the ServerKeyExchange message
//              consists of the following structure, signed with the
//              server's private key.
//
//                  struct {
//                      opaque rsa_modulus<1..2^16-1>;
//                      opaque rsa_exponent<1..2^16-1>;
//                  } Server RSA Params;
//
//              This message is only sent when the server's private key
//              is greater then 512 bits and an export cipher suite is
//              being negotiated.
//
//----------------------------------------------------------------------------
SP_STATUS
WINAPI
PkcsGenerateServerExchangeValue(
    PSPContext  pContext,                   // in
    PBYTE       pServerExchangeValue,       // out
    DWORD *     pcbServerExchangeValue)     // in/out
{
    PSPCredential   pCred;
    HCRYPTKEY       hServerKey;
    HCRYPTPROV      hEphemeralProv;
    HCRYPTKEY       hEphemeralKey;
    DWORD           cbData;
    DWORD           cbServerModulus;
    PBYTE           pbBlob = NULL;
    DWORD           cbBlob;
    BLOBHEADER *    pBlobHeader = NULL;
    RSAPUBKEY *     pRsaPubKey = NULL;
    PBYTE           pbModulus = NULL;
    DWORD           cbModulus;
    DWORD           cbExp;
    PBYTE           pbMessage = NULL;
    DWORD           cbSignature;
    HCRYPTHASH      hHash;
    BYTE            rgbHashValue[CB_MD5_DIGEST_LEN + CB_SHA_DIGEST_LEN];
    UINT            i;
    SP_STATUS       pctRet;
    BOOL            fImpersonating = FALSE;
    UNICipherMap *  pCipherSuite;
    DWORD           cbAllowedKeySize;

    pCred = pContext->RipeZombie->pActiveServerCred;
    if(pCred == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    pContext->fExchKey = FALSE;

    if(pContext->RipeZombie->fProtocol == SP_PROT_SSL2_SERVER ||
       pContext->RipeZombie->fProtocol == SP_PROT_PCT1_SERVER)
    {
        // There is no ServerExchangeValue for SSL2 or PCT1
        *pcbServerExchangeValue = 0;
        return PCT_ERR_OK;
    }

    if(pContext->RipeZombie->fProtocol != SP_PROT_SSL3_SERVER &&
       pContext->RipeZombie->fProtocol != SP_PROT_TLS1_SERVER)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }


    //
    // Determine if ServerKeyExchange message is necessary.
    //

    pCipherSuite = &UniAvailableCiphers[pContext->dwPendingCipherSuiteIndex];

    if(pCipherSuite->dwFlags & DOMESTIC_CIPHER_SUITE)
    {
        // Message not necessary.
        *pcbServerExchangeValue = 0;
        return PCT_ERR_OK;
    }

    if(pCred->hProv == 0)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }


    fImpersonating = SslImpersonateClient();

    if(!SchCryptGetUserKey(pCred->hProv,
                           pCred->dwKeySpec,
                           &hServerKey,
                           pContext->RipeZombie->dwCapiFlags))
    {
        DebugLog((DEB_ERROR, "Error 0x%x obtaining handle to server public key\n",
            GetLastError()));
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }

    cbData = sizeof(DWORD);
    if(!SchCryptGetKeyParam(hServerKey,
                            KP_BLOCKLEN,
                            (PBYTE)&cbServerModulus,
                            &cbData,
                            0,
                            pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        SchCryptDestroyKey(hServerKey, pContext->RipeZombie->dwCapiFlags);
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    SchCryptDestroyKey(hServerKey, pContext->RipeZombie->dwCapiFlags);

    if(pCipherSuite->dwFlags & EXPORT56_CIPHER_SUITE)
    {
        cbAllowedKeySize = 1024;
    } 
    else
    {
        cbAllowedKeySize = 512;
    }

    if(cbServerModulus <= cbAllowedKeySize)
    {
        // Message not necessary.
        *pcbServerExchangeValue = 0;
        pctRet = PCT_ERR_OK;
        goto cleanup;
    }

    // Convert size from bits to bytes.
    cbServerModulus /= 8;

    pContext->fExchKey = TRUE;

    if(fImpersonating)
    {
        RevertToSelf();
        fImpersonating = FALSE;
    }

    //
    // Compute approximate size of ServerKeyExchange message.
    //

    if(pServerExchangeValue == NULL)
    {
        *pcbServerExchangeValue = 
                    2 + cbAllowedKeySize / 8 +      // modulus
                    2 + sizeof(DWORD) +             // exponent
                    2 + cbServerModulus;            // signature

        pctRet = PCT_ERR_OK;
        goto cleanup;
    }


    //
    // Get handle to 512-bit ephemeral RSA key. Generate it if
    // we haven't already.
    //

    pctRet = GenerateSsl3KeyPair(pContext,
                                 cbAllowedKeySize,
                                 &hEphemeralProv,
                                 &hEphemeralKey);
    if(pctRet != PCT_ERR_OK)
    {
        SP_LOG_RESULT(pctRet);
        goto cleanup;
    }


    //
    // Export ephemeral key.
    //

    if(!SchCryptExportKey(hEphemeralKey,
                          0,
                          PUBLICKEYBLOB,
                          0,
                          NULL,
                          &cbBlob,
                          pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    pbBlob = SPExternalAlloc(cbBlob);
    if(pbBlob == NULL)
    {
        pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto cleanup;
    }
    if(!SchCryptExportKey(hEphemeralKey,
                          0,
                          PUBLICKEYBLOB,
                          0,
                          pbBlob,
                          &cbBlob,
                          pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        SPExternalFree(pbBlob);
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }

    // 
    // Destroy handle to ephemeral key. Don't release the ephemeral hProv
    // though--that's owned by the credential.
    SchCryptDestroyKey(hEphemeralKey, pContext->RipeZombie->dwCapiFlags);


    //
    // Build message from key blob.
    //

    pBlobHeader = (BLOBHEADER *)pbBlob;
    pRsaPubKey  = (RSAPUBKEY *)(pBlobHeader + 1);
    pbModulus   = (BYTE *)(pRsaPubKey + 1);
    cbModulus   = pRsaPubKey->bitlen / 8;

    pbMessage   = pServerExchangeValue;

    pbMessage[0] = MSBOF(cbModulus);
    pbMessage[1] = LSBOF(cbModulus);
    pbMessage += 2;
    ReverseMemCopy(pbMessage, pbModulus, cbModulus);
    pbMessage += cbModulus;

    // Don't laugh, this works  - pete
    cbExp = ((pRsaPubKey->pubexp & 0xff000000) ? 4 :
            ((pRsaPubKey->pubexp & 0x00ff0000) ? 3 :
            ((pRsaPubKey->pubexp & 0x0000ff00) ? 2 : 1)));
    pbMessage[0] = MSBOF(cbExp);
    pbMessage[1] = LSBOF(cbExp);
    pbMessage += 2;
    ReverseMemCopy(pbMessage, (PBYTE)&pRsaPubKey->pubexp, cbExp);
    pbMessage += cbExp;

    SPExternalFree(pbBlob);
    pbBlob = NULL;

    fImpersonating = SslImpersonateClient();

    // Generate hash values
    ComputeServerExchangeHashes(
                pContext,
                pServerExchangeValue,
                (int)(pbMessage - pServerExchangeValue),
                rgbHashValue,
                rgbHashValue + CB_MD5_DIGEST_LEN);

    // Sign hash value.
    if(!SchCryptCreateHash(pCred->hProv,
                           CALG_SSL3_SHAMD5,
                           0,
                           0,
                           &hHash,
                           pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    if(!SchCryptSetHashParam(hHash,
                             HP_HASHVAL,
                             rgbHashValue,
                             0,
                             pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }

    DebugLog((DEB_TRACE, "Signing server_key_exchange message.\n"));
    cbSignature = cbServerModulus;
    if(!SchCryptSignHash(hHash,
                         pCred->dwKeySpec,
                         NULL,
                         0,
                         pbMessage + 2,
                         &cbSignature,
                         pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    DebugLog((DEB_TRACE, "Server_key_exchange message signed successfully.\n"));
    SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags);

    pbMessage[0] = MSBOF(cbSignature);
    pbMessage[1] = LSBOF(cbSignature);
    pbMessage += 2;

    // Reverse signature.
    for(i = 0; i < cbSignature / 2; i++)
    {
        BYTE n = pbMessage[i];
        pbMessage[i] = pbMessage[cbSignature - i -1];
        pbMessage[cbSignature - i -1] = n;
    }
    pbMessage += cbSignature;

    *pcbServerExchangeValue = (DWORD)(pbMessage - pServerExchangeValue);

    // Use ephemeral key for the new connection.
    pContext->RipeZombie->hMasterProv = hEphemeralProv;
    pContext->RipeZombie->dwFlags |= SP_CACHE_FLAG_MASTER_EPHEM;

    pctRet = PCT_ERR_OK;

cleanup:

    if(fImpersonating)
    {
        RevertToSelf();
    }

    return pctRet;
}


SP_STATUS
WINAPI
PkcsGenerateClientExchangeValue(
    SPContext     * pContext,               // in
    PUCHAR          pServerExchangeValue,   // in
    DWORD           cbServerExchangeValue,  // in
    PUCHAR          pClientClearValue,      // out
    DWORD *         pcbClientClearValue,    // in/out
    PUCHAR          pClientExchangeValue,   // out
    DWORD *         pcbClientExchangeValue) // in/out
{
    PSPCredentialGroup pCred;
    DWORD cbSecret;
    DWORD cbMasterKey;
    HCRYPTKEY hServerPublic = 0;
    DWORD dwGenFlags = 0;
    DWORD dwExportFlags = 0;
    SP_STATUS pctRet = PCT_ERR_OK;
    BLOBHEADER *pPublicBlob;
    DWORD cbPublicBlob;
    DWORD cbHeader;
    ALG_ID Algid = 0;
    DWORD cbData;
    DWORD cbEncryptedKey;
    DWORD dwEnabledProtocols;
    DWORD dwHighestProtocol;

    if(pContext->RipeZombie->hMasterProv == 0)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    pCred = pContext->pCredGroup;
    if(pCred == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    // We're doing a full handshake.
    pContext->Flags |= CONTEXT_FLAG_FULL_HANDSHAKE;

    //
    // Determine highest supported protocol.
    //

    dwEnabledProtocols = pContext->dwClientEnabledProtocols;

    if(dwEnabledProtocols & SP_PROT_TLS1_CLIENT)
    {
        dwHighestProtocol = TLS1_CLIENT_VERSION;
    }
    else if(dwEnabledProtocols & SP_PROT_SSL3_CLIENT)
    {
        dwHighestProtocol = SSL3_CLIENT_VERSION;
    }
    else 
    {
        dwHighestProtocol = SSL2_CLIENT_VERSION;
    }

    // Get key length.
    cbSecret = pContext->pPendingCipherInfo->cbSecret;


    //
    // Import server's public key.
    //

    pPublicBlob  = pContext->RipeZombie->pRemotePublic->pPublic;
    cbPublicBlob = pContext->RipeZombie->pRemotePublic->cbPublic;

    cbEncryptedKey = sizeof(BLOBHEADER) + sizeof(ALG_ID) + cbPublicBlob;

    if(pClientExchangeValue == NULL)
    {
        *pcbClientExchangeValue = cbEncryptedKey;
        pctRet = PCT_ERR_OK;
        goto done;
    }

    if(*pcbClientExchangeValue < cbEncryptedKey)
    {
        *pcbClientExchangeValue = cbEncryptedKey;
        pctRet = SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
        goto done;
    }

    if(!SchCryptImportKey(pContext->RipeZombie->hMasterProv,
                          (PBYTE)pPublicBlob,
                          cbPublicBlob,
                          0,
                          0,
                          &hServerPublic,
                          pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto done;
    }


    //
    // Do protocol specific stuff.
    //

    switch(pContext->RipeZombie->fProtocol)
    {
        case SP_PROT_PCT1_CLIENT:
            Algid       = CALG_PCT1_MASTER;
            dwGenFlags  = CRYPT_EXPORTABLE;

            // Generate the clear key value.
            if(cbSecret < PCT1_MASTER_KEY_SIZE)
            {
                pContext->RipeZombie->cbClearKey = PCT1_MASTER_KEY_SIZE - cbSecret;
                GenerateRandomBits( pContext->RipeZombie->pClearKey,
                                    pContext->RipeZombie->cbClearKey);

                *pcbClientClearValue = pContext->RipeZombie->cbClearKey;
                CopyMemory( pClientClearValue,
                            pContext->RipeZombie->pClearKey,
                            pContext->RipeZombie->cbClearKey);
            }
            else
            {
                *pcbClientClearValue = pContext->RipeZombie->cbClearKey = 0;
            }

            break;

        case SP_PROT_SSL2_CLIENT:
            Algid       = CALG_SSL2_MASTER;
            dwGenFlags  = CRYPT_EXPORTABLE;

            cbMasterKey = pContext->pPendingCipherInfo->cbKey;

            dwGenFlags |= ((cbSecret << 3) << 16);

            // Generate the clear key value.
            pContext->RipeZombie->cbClearKey = cbMasterKey - cbSecret;

            if(pContext->RipeZombie->cbClearKey > 0)
            {
                GenerateRandomBits(pContext->RipeZombie->pClearKey,
                                   pContext->RipeZombie->cbClearKey);

                CopyMemory(pClientClearValue,
                           pContext->RipeZombie->pClearKey,
                           pContext->RipeZombie->cbClearKey);
            }
            *pcbClientClearValue = pContext->RipeZombie->cbClearKey;

            if(dwEnabledProtocols & (SP_PROT_SSL3 | SP_PROT_TLS1))
            {
                // If we're a client doing SSL2, and
                // SSL3 is enabled, then for some reason
                // the server requested SSL2.  Maybe
                // A man in the middle changed the server
                // version in the server hello to roll
                // back.  Pad with 8 0x03's so the server
                // can detect this.
                dwExportFlags = CRYPT_SSL2_FALLBACK;
            }

            break;

        case SP_PROT_TLS1_CLIENT:
            Algid = CALG_TLS1_MASTER;

            // drop through to SSL3

        case SP_PROT_SSL3_CLIENT:

            dwGenFlags  = CRYPT_EXPORTABLE;
            if(0 == Algid)
            {
                Algid = CALG_SSL3_MASTER;
            }

            // Generate the clear key value (always empty).
            pContext->RipeZombie->cbClearKey = 0;
            if(pcbClientClearValue) *pcbClientClearValue = 0;

            if(cbServerExchangeValue && pServerExchangeValue)
            {
                // In ssl3, we look at the server exchange value.
                // It may be a 512-bit public key, signed
                // by the server public key. In this case, we need to
                // use that as our master_secret encryption key.
                HCRYPTKEY hNewServerPublic;

                pctRet = Ssl3ParseServerKeyExchange(pContext,
                                                    pServerExchangeValue,
                                                    cbServerExchangeValue,
                                                    hServerPublic,
                                                    &hNewServerPublic);
                if(pctRet != PCT_ERR_OK)
                {
                    goto done;
                }

                // Destroy public key from certificate.
                SchCryptDestroyKey(hServerPublic, pContext->RipeZombie->dwCapiFlags);

                // Use public key from ServerKeyExchange instead.
                hServerPublic = hNewServerPublic;
            }

            break;

        default:
            return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    // Generate the master_secret.
    if(!SchCryptGenKey(pContext->RipeZombie->hMasterProv,
                       Algid,
                       dwGenFlags,
                       &pContext->RipeZombie->hMasterKey,
                       pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto done;
    }

#if 1 
    // This is currently commented out because when connecting to a server running
    // an old version of schannel (NT4 SP3 or so), then we will connect using SSL3,
    // but the highest supported protocol is 0x0301. This confuses the server and
    // it drops the connection. 
    
    // Set highest supported protocol. The CSP will place this version number
    // in the pre_master_secret.
    if(!SchCryptSetKeyParam(pContext->RipeZombie->hMasterKey, 
                            KP_HIGHEST_VERSION, 
                            (PBYTE)&dwHighestProtocol, 
                            0, 
                            pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
    }
#endif


    // Encrypt the master_secret.
    DebugLog((DEB_TRACE, "Encrypt the master secret.\n"));
    if(!SchCryptExportKey(pContext->RipeZombie->hMasterKey,
                          hServerPublic,
                          SIMPLEBLOB,
                          dwExportFlags,
                          pClientExchangeValue,
                          &cbEncryptedKey,
                          pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto done;
    }
    DebugLog((DEB_TRACE, "Master secret encrypted successfully.\n"));

    // Determine size of key exchange key.
    cbData = sizeof(DWORD);
    if(!SchCryptGetKeyParam(hServerPublic,
                            KP_BLOCKLEN,
                            (PBYTE)&pContext->RipeZombie->dwExchStrength,
                            &cbData,
                            0,
                            pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pContext->RipeZombie->dwExchStrength = 0;
    }


    // Strip off the blob header and copy the encrypted master_secret
    // to the output buffer. Note that it is also converted to big endian.
    cbHeader = sizeof(BLOBHEADER) + sizeof(ALG_ID);
    cbEncryptedKey -= cbHeader;
    if(pContext->RipeZombie->fProtocol == SP_PROT_TLS1_CLIENT)
    {
        MoveMemory(pClientExchangeValue + 2, pClientExchangeValue + cbHeader, cbEncryptedKey);
        ReverseInPlace(pClientExchangeValue + 2, cbEncryptedKey);

        pClientExchangeValue[0] = MSBOF(cbEncryptedKey);
        pClientExchangeValue[1] = LSBOF(cbEncryptedKey);

        *pcbClientExchangeValue = 2 + cbEncryptedKey;
    }
    else
    {
        MoveMemory(pClientExchangeValue, pClientExchangeValue + cbHeader, cbEncryptedKey);
        ReverseInPlace(pClientExchangeValue, cbEncryptedKey);

        *pcbClientExchangeValue = cbEncryptedKey;
    }

    // Build the session keys.
    pctRet = MakeSessionKeys(pContext,
                             pContext->RipeZombie->hMasterProv,
                             pContext->RipeZombie->hMasterKey);
    if(pctRet != PCT_ERR_OK)
    {
        goto done;
    }

    // Update perf counter.
    InterlockedIncrement(&g_cClientHandshakes);

    pctRet = PCT_ERR_OK;

done:
    if(hServerPublic) SchCryptDestroyKey(hServerPublic, pContext->RipeZombie->dwCapiFlags);

    return pctRet;
}


SP_STATUS
GenerateRandomMasterKey(
    PSPContext      pContext,
    HCRYPTKEY *     phMasterKey)
{
    DWORD dwGenFlags = 0;
    ALG_ID Algid = 0;
    DWORD cbSecret;

    cbSecret = pContext->pPendingCipherInfo->cbSecret;

    switch(pContext->RipeZombie->fProtocol)
    {
        case SP_PROT_PCT1_SERVER:
            Algid       = CALG_PCT1_MASTER;
            dwGenFlags  = CRYPT_EXPORTABLE;
            break;

        case SP_PROT_SSL2_SERVER:
            Algid       = CALG_SSL2_MASTER;
            dwGenFlags  = CRYPT_EXPORTABLE;
            dwGenFlags |= ((cbSecret << 3) << 16);
            break;

        case SP_PROT_TLS1_SERVER:
            Algid = CALG_TLS1_MASTER;
            dwGenFlags  = CRYPT_EXPORTABLE;
            break;

        case SP_PROT_SSL3_SERVER:
            Algid = CALG_SSL3_MASTER;
            dwGenFlags  = CRYPT_EXPORTABLE;
            break;

        default:
            return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    // Generate the master_secret.
    if(!SchCryptGenKey(pContext->RipeZombie->hMasterProv,
                       Algid,
                       dwGenFlags,
                       phMasterKey,
                       pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        return PCT_INT_INTERNAL_ERROR;
    }

    return PCT_ERR_OK;
}



//+---------------------------------------------------------------------------
//
//  Function:   PkcsGenerateServerMasterKey
//
//  Synopsis:   Decrypt the master secret (from the ClientKeyExchange message)
//              and derive the session keys from it.
//
//  Arguments:  [pContext]              --  Schannel context.
//              [pClientClearValue]     --  Not used.
//              [cbClientClearValue]    --  Not used.
//              [pClientExchangeValue]  --  Pointer PKCS #2 block.
//              [cbClientExchangeValue] --  Length of block.
//
//  History:    10-02-97   jbanes   Created.
//
//  Notes:      This routine is called by the server-side only.
//
//----------------------------------------------------------------------------
SP_STATUS
WINAPI
PkcsGenerateServerMasterKey(
    PSPContext  pContext,               // in, out
    PUCHAR      pClientClearValue,      // in
    DWORD       cbClientClearValue,     // in
    PUCHAR      pClientExchangeValue,   // in
    DWORD       cbClientExchangeValue)  // in
{
    PSPCredentialGroup pCred;
    PBYTE       pbBlob = NULL;
    DWORD       cbBlob;
    ALG_ID      Algid;
    HCRYPTKEY   hMasterKey;
    HCRYPTKEY   hExchKey = 0;
    DWORD       dwFlags = 0;
    SP_STATUS   pctRet;
    DWORD       cbData;
    DWORD       dwEnabledProtocols;
    DWORD       dwHighestProtocol;
    BOOL        fImpersonating = FALSE;

    pCred = pContext->RipeZombie->pServerCred;
    if(pCred == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    dwEnabledProtocols = (g_ProtEnabled & pCred->grbitEnabledProtocols);

    if(dwEnabledProtocols & SP_PROT_TLS1_SERVER)
    {
        dwHighestProtocol = TLS1_CLIENT_VERSION;
    }
    else if(dwEnabledProtocols & SP_PROT_SSL3_SERVER)
    {
        dwHighestProtocol = SSL3_CLIENT_VERSION;
    }
    else 
    {
        dwHighestProtocol = SSL2_CLIENT_VERSION;
    }

    // We're doing a full handshake.
    pContext->Flags |= CONTEXT_FLAG_FULL_HANDSHAKE;

    // Determine encryption algid
    switch(pContext->RipeZombie->fProtocol)
    {
        case SP_PROT_PCT1_SERVER:
            Algid = CALG_PCT1_MASTER;

            CopyMemory(pContext->RipeZombie->pClearKey,
                   pClientClearValue,
                   cbClientClearValue);
            pContext->RipeZombie->cbClearKey = cbClientClearValue;

            break;

        case SP_PROT_SSL2_SERVER:
            Algid = CALG_SSL2_MASTER;

            if(dwEnabledProtocols & (SP_PROT_SSL3 | SP_PROT_TLS1))
            {
                // We're a server doing SSL2, and we also support SSL3.
                // If the encryption block contains the 8 0x03 padding
                // bytes, then abort the connection.
                dwFlags = CRYPT_SSL2_FALLBACK;
            }

            CopyMemory(pContext->RipeZombie->pClearKey,
                   pClientClearValue,
                   cbClientClearValue);
            pContext->RipeZombie->cbClearKey = cbClientClearValue;

            break;

        case SP_PROT_SSL3_SERVER:
            Algid = CALG_SSL3_MASTER;
            break;

        case SP_PROT_TLS1_SERVER:
            Algid = CALG_TLS1_MASTER;
            break;

        default:
            return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    // Remove (pseudo-optional) vector in front of the encrypted master key.
    if(pContext->RipeZombie->fProtocol == SP_PROT_SSL3_SERVER ||
       pContext->RipeZombie->fProtocol == SP_PROT_TLS1_SERVER)
    {
        DWORD cbMsg = MAKEWORD(pClientExchangeValue[1], pClientExchangeValue[0]);

        if(cbMsg + 2 == cbClientExchangeValue)
        {
            pClientExchangeValue += 2;
            cbClientExchangeValue -= 2;
        }
    }

    // Allocate memory for blob.
    cbBlob = sizeof(BLOBHEADER) + sizeof(ALG_ID) + cbClientExchangeValue;
    pbBlob = SPExternalAlloc(cbBlob);
    if(pbBlob == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }


    // Build SIMPLEBLOB.
    {
        BLOBHEADER *pBlobHeader = (BLOBHEADER *)pbBlob;
        ALG_ID     *pAlgid      = (ALG_ID *)(pBlobHeader + 1);
        BYTE       *pData       = (BYTE *)(pAlgid + 1);

        pBlobHeader->bType      = SIMPLEBLOB;
        pBlobHeader->bVersion   = CUR_BLOB_VERSION;
        pBlobHeader->reserved   = 0;
        pBlobHeader->aiKeyAlg   = Algid;

        *pAlgid = CALG_RSA_KEYX;
        ReverseMemCopy(pData, pClientExchangeValue, cbClientExchangeValue);
    }

    DebugLog((DEB_TRACE, "Decrypt the master secret.\n"));

    if(!(pContext->RipeZombie->dwFlags & SP_CACHE_FLAG_MASTER_EPHEM))
    {
        fImpersonating = SslImpersonateClient();
    }

    // Decrypt the master_secret.
    if(!SchCryptGetUserKey(pContext->RipeZombie->hMasterProv,
                           AT_KEYEXCHANGE,
                           &hExchKey,
                           pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }

    if(!SchCryptImportKey(pContext->RipeZombie->hMasterProv,
                          pbBlob,
                          cbBlob,
                          hExchKey,
                          dwFlags,
                          &hMasterKey,
                          pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        DebugLog((DEB_TRACE, "Master secret did not decrypt correctly.\n"));

        // Guard against the PKCS#1 attack by generating a 
        // random master key.
        pctRet = GenerateRandomMasterKey(pContext, &hMasterKey);
        if(pctRet != PCT_ERR_OK)
        {
            pctRet = PCT_INT_INTERNAL_ERROR;
            goto cleanup;
        }
    }
    else
    {
        DebugLog((DEB_TRACE, "Master secret decrypted successfully.\n"));

        // Set highest supported protocol. The CSP will use this to check for
        // version fallback attacks.
        if(!SchCryptSetKeyParam(hMasterKey, 
                                KP_HIGHEST_VERSION, 
                                (PBYTE)&dwHighestProtocol, 
                                CRYPT_SERVER, 
                                pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());

            if(GetLastError() == NTE_BAD_VER)
            {
                pctRet = SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
                SchCryptDestroyKey(hMasterKey, pContext->RipeZombie->dwCapiFlags);
                goto cleanup;
            }
        }
    }

    pContext->RipeZombie->hMasterKey = hMasterKey;

    // Determine size of key exchange key.
    cbData = sizeof(DWORD);
    if(!SchCryptGetKeyParam(hExchKey,
                            KP_BLOCKLEN,
                            (PBYTE)&pContext->RipeZombie->dwExchStrength,
                            &cbData,
                            0,
                            pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pContext->RipeZombie->dwExchStrength = 0;
    }

    SchCryptDestroyKey(hExchKey, pContext->RipeZombie->dwCapiFlags);
    hExchKey = 0;

    // Build the session keys.
    pctRet = MakeSessionKeys(pContext,
                             pContext->RipeZombie->hMasterProv,
                             hMasterKey);
    if(pctRet != PCT_ERR_OK)
    {
        SP_LOG_RESULT(pctRet);
        goto cleanup;
    }

    // Update perf counter.
    InterlockedIncrement(&g_cServerHandshakes);

    pctRet = PCT_ERR_OK;

cleanup:

    if(fImpersonating)
    {
        RevertToSelf();
    }

    if(pbBlob != NULL)
    {
        SPExternalFree(pbBlob);
    }

    if(hExchKey)
    {
        SchCryptDestroyKey(hExchKey, pContext->RipeZombie->dwCapiFlags);
    }

    return pctRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   PkcsFinishMasterKey
//
//  Synopsis:   Complete the derivation of the master key by programming the
//              CSP with the (protocol dependent) auxilary plaintext
//              information.
//
//  Arguments:  [pContext]              --  Schannel context.
//              [hMasterKey]            --  Handle to master key.
//
//  History:    10-03-97   jbanes   Created.
//
//  Notes:      This routine is called by the server-side only.
//
//----------------------------------------------------------------------------
SP_STATUS
PkcsFinishMasterKey(
    PSPContext  pContext,       // in, out
    HCRYPTKEY   hMasterKey)     // in
{
    PCipherInfo  pCipherInfo = NULL;
    PHashInfo    pHashInfo   = NULL;
    SCHANNEL_ALG Algorithm;
    BOOL         fExportable = TRUE;
    DWORD        dwCipherFlags;

    if(pContext->RipeZombie->hMasterProv == 0)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    // Get pointer to pending cipher system.
    pCipherInfo = pContext->pPendingCipherInfo;

    // Get pointer to pending hash system.
    pHashInfo = pContext->pPendingHashInfo;

    // Determine whether this is an "exportable" cipher.
    if(pContext->dwPendingCipherSuiteIndex)
    {
        // Use cipher suite flags (SSL3 & TLS).
        dwCipherFlags = UniAvailableCiphers[pContext->dwPendingCipherSuiteIndex].dwFlags;

        if(dwCipherFlags & DOMESTIC_CIPHER_SUITE)
        {
            fExportable = FALSE;
        }
    }
    else
    {
        // Use key length (PCT & SSL2).
        if(pCipherInfo->dwStrength > 40)
        {
            fExportable = FALSE;
        }
    }


    // Specify encryption algorithm.
    if(pCipherInfo->aiCipher != CALG_NULLCIPHER)
    {
        ZeroMemory(&Algorithm, sizeof(Algorithm));
        Algorithm.dwUse = SCHANNEL_ENC_KEY;
        Algorithm.Algid = pCipherInfo->aiCipher;
        Algorithm.cBits = pCipherInfo->cbSecret * 8;
        if(fExportable)
        {
            Algorithm.dwFlags = INTERNATIONAL_USAGE;
        }
        if(!SchCryptSetKeyParam(hMasterKey,
                                KP_SCHANNEL_ALG,
                                (PBYTE)&Algorithm,
                                0,
                                pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
            return PCT_INT_INTERNAL_ERROR;
        }
    }

    // Specify hash algorithm.
    Algorithm.dwUse = SCHANNEL_MAC_KEY;
    Algorithm.Algid = pHashInfo->aiHash;
    Algorithm.cBits = pHashInfo->cbCheckSum * 8;
    if(!SchCryptSetKeyParam(hMasterKey,
                            KP_SCHANNEL_ALG,
                            (PBYTE)&Algorithm,
                            0,
                            pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        return PCT_INT_INTERNAL_ERROR;
    }

    // Finish creating the master_secret.
    switch(pContext->RipeZombie->fProtocol)
    {
        case SP_PROT_PCT1_CLIENT:
        case SP_PROT_PCT1_SERVER:
        {
            CRYPT_DATA_BLOB Data;

            // Specify clear key value.
            if(pContext->RipeZombie->cbClearKey)
            {
                Data.pbData = pContext->RipeZombie->pClearKey;
                Data.cbData = pContext->RipeZombie->cbClearKey;
                if(!SchCryptSetKeyParam(hMasterKey,
                                        KP_CLEAR_KEY,
                                        (BYTE*)&Data,
                                        0,
                                        pContext->RipeZombie->dwCapiFlags))
                {
                    SP_LOG_RESULT(GetLastError());
                    return PCT_INT_INTERNAL_ERROR;
                }
            }

            // Specify the CH_CHALLENGE_DATA.
            Data.pbData = pContext->pChallenge;
            Data.cbData = pContext->cbChallenge;
            if(!SchCryptSetKeyParam(hMasterKey,
                                    KP_CLIENT_RANDOM,
                                    (BYTE*)&Data,
                                    0,
                                    pContext->RipeZombie->dwCapiFlags))
            {
                SP_LOG_RESULT(GetLastError());
                return PCT_INT_INTERNAL_ERROR;
            }

            // Specify the SH_CONNECTION_ID_DATA.
            Data.pbData = pContext->pConnectionID;
            Data.cbData = pContext->cbConnectionID;
            if(!SchCryptSetKeyParam(hMasterKey,
                                    KP_SERVER_RANDOM,
                                    (BYTE*)&Data,
                                    0,
                                    pContext->RipeZombie->dwCapiFlags))
            {
                SP_LOG_RESULT(GetLastError());
                return PCT_INT_INTERNAL_ERROR;
            }

            // Specify the SH_CERTIFICATE_DATA.
            Data.pbData = pContext->RipeZombie->pbServerCertificate;
            Data.cbData = pContext->RipeZombie->cbServerCertificate;
            if(!SchCryptSetKeyParam(hMasterKey,
                                    KP_CERTIFICATE,
                                    (BYTE*)&Data,
                                    0,
                                    pContext->RipeZombie->dwCapiFlags))
            {
                SP_LOG_RESULT(GetLastError());
                return PCT_INT_INTERNAL_ERROR;
            }

            break;
        }

        case SP_PROT_SSL2_CLIENT:
        case SP_PROT_SSL2_SERVER:
        {
            CRYPT_DATA_BLOB Data;

            // Specify clear key value.
            if(pContext->RipeZombie->cbClearKey)
            {
                Data.pbData = pContext->RipeZombie->pClearKey;
                Data.cbData = pContext->RipeZombie->cbClearKey;
                if(!SchCryptSetKeyParam(hMasterKey,
                                        KP_CLEAR_KEY,
                                        (BYTE*)&Data,
                                        0,
                                        pContext->RipeZombie->dwCapiFlags))
                {
                    SP_LOG_RESULT(GetLastError());
                    return PCT_INT_INTERNAL_ERROR;
                }
            }

            // Specify the CH_CHALLENGE_DATA.
            Data.pbData = pContext->pChallenge;
            Data.cbData = pContext->cbChallenge;
            if(!SchCryptSetKeyParam(hMasterKey,
                                    KP_CLIENT_RANDOM,
                                    (BYTE*)&Data,
                                    0,
                                    pContext->RipeZombie->dwCapiFlags))
            {
                SP_LOG_RESULT(GetLastError());
                return PCT_INT_INTERNAL_ERROR;
            }

            // Specify the SH_CONNECTION_ID_DATA.
            Data.pbData = pContext->pConnectionID;
            Data.cbData = pContext->cbConnectionID;
            if(!SchCryptSetKeyParam(hMasterKey,
                                    KP_SERVER_RANDOM,
                                    (BYTE*)&Data,
                                    0,
                                    pContext->RipeZombie->dwCapiFlags))
            {
                SP_LOG_RESULT(GetLastError());
                return PCT_INT_INTERNAL_ERROR;
            }

            break;
        }

        case SP_PROT_SSL3_CLIENT:
        case SP_PROT_SSL3_SERVER:
        case SP_PROT_TLS1_CLIENT:
        case SP_PROT_TLS1_SERVER:
        {
            CRYPT_DATA_BLOB Data;

            // Specify client_random.
            Data.pbData = pContext->rgbS3CRandom;
            Data.cbData = CB_SSL3_RANDOM;
            if(!SchCryptSetKeyParam(hMasterKey,
                                    KP_CLIENT_RANDOM,
                                    (BYTE*)&Data,
                                    0,
                                    pContext->RipeZombie->dwCapiFlags))
            {
                SP_LOG_RESULT(GetLastError());
                return PCT_INT_INTERNAL_ERROR;
            }

            // Specify server_random.
            Data.pbData = pContext->rgbS3SRandom;
            Data.cbData = CB_SSL3_RANDOM;
            if(!SchCryptSetKeyParam(hMasterKey,
                                    KP_SERVER_RANDOM,
                                    (BYTE*)&Data,
                                    0,
                                    pContext->RipeZombie->dwCapiFlags))
            {
                SP_LOG_RESULT(GetLastError());
                return PCT_INT_INTERNAL_ERROR;
            }

            break;
        }

        default:
            return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    return PCT_ERR_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   MakeSessionKeys
//
//  Synopsis:   Derive the session keys from the completed master key.
//
//  Arguments:  [pContext]              --  Schannel context.
//              [hProv]                 --
//              [hMasterKey]            --  Handle to master key.
//
//  History:    10-03-97   jbanes   Created.
//
//  Notes:      This routine is called by the server-side only.
//
//----------------------------------------------------------------------------
SP_STATUS
MakeSessionKeys(
    PSPContext  pContext,     // in
    HCRYPTPROV  hProv,        // in
    HCRYPTKEY   hMasterKey)   // in
{
    HCRYPTHASH hMasterHash = 0;
    HCRYPTKEY  hLocalMasterKey = 0;
    BOOL       fClient;
    SP_STATUS  pctRet;

    //
    // Duplicate the master key if we're doing a reconnect handshake. This 
    // will allow us to set the client_random and server_random properties 
    // on the key without having to worry about different threads 
    // interferring with each other.
    //

    if((pContext->Flags & CONTEXT_FLAG_FULL_HANDSHAKE) == 0)
    {
        if(!CryptDuplicateKey(hMasterKey, NULL, 0, &hLocalMasterKey))
        {
            pctRet = SP_LOG_RESULT(GetLastError());
            goto cleanup;
        }

        hMasterKey = hLocalMasterKey;
    }


    // Finish the master_secret.
    pctRet = PkcsFinishMasterKey(pContext, hMasterKey);
    if(pctRet != PCT_ERR_OK)
    {
        SP_LOG_RESULT(pctRet);
        goto cleanup;
    }

    fClient = !(pContext->RipeZombie->fProtocol & SP_PROT_SERVERS);

    // Create the master hash object from the master_secret key.
    if(!SchCryptCreateHash(hProv,
                           CALG_SCHANNEL_MASTER_HASH,
                           hMasterKey,
                           0,
                           &hMasterHash,
                           0))
    {
        pctRet = SP_LOG_RESULT(GetLastError());
        goto cleanup;
    }


    // Derive read key from the master hash object.
    if(pContext->hPendingReadKey)
    {
        SchCryptDestroyKey(pContext->hPendingReadKey, 0);
        pContext->hPendingReadKey = 0;
    }
    if(pContext->pPendingCipherInfo->aiCipher != CALG_NULLCIPHER)
    {
        if(!SchCryptDeriveKey(hProv,
                              CALG_SCHANNEL_ENC_KEY,
                              hMasterHash,
                              CRYPT_EXPORTABLE | (fClient ? CRYPT_SERVER : 0),
                              &pContext->hPendingReadKey,
                              0))
        {
            pctRet = SP_LOG_RESULT(GetLastError());
            goto cleanup;
        }
    }

    // Derive write key from the master hash object.
    if(pContext->hPendingWriteKey)
    {
        SchCryptDestroyKey(pContext->hPendingWriteKey, 0);
        pContext->hPendingWriteKey = 0;
    }
    if(pContext->pPendingCipherInfo->aiCipher != CALG_NULLCIPHER)
    {
        if(!SchCryptDeriveKey(hProv,
                              CALG_SCHANNEL_ENC_KEY,
                              hMasterHash,
                              CRYPT_EXPORTABLE | (fClient ? 0 : CRYPT_SERVER),
                              &pContext->hPendingWriteKey,
                              0))
        {
            pctRet = SP_LOG_RESULT(GetLastError());
            goto cleanup;
        }
    }

    if((pContext->RipeZombie->fProtocol & SP_PROT_SSL2) ||
       (pContext->RipeZombie->fProtocol & SP_PROT_PCT1))
    {
        // Set the IV on the client and server encryption keys
        if(!SchCryptSetKeyParam(pContext->hPendingReadKey,
                                KP_IV,
                                pContext->RipeZombie->pKeyArgs,
                                0,
                                0))
        {
            pctRet = SP_LOG_RESULT(GetLastError());
            goto cleanup;
        }

        if(!SchCryptSetKeyParam(pContext->hPendingWriteKey,
                                KP_IV,
                                pContext->RipeZombie->pKeyArgs,
                                0,
                                0))
        {
            pctRet = SP_LOG_RESULT(GetLastError());
            goto cleanup;
        }
    }

    if(pContext->RipeZombie->fProtocol & SP_PROT_SSL2)
    {
        // SSL 2.0 uses same set of keys for both encryption and MAC.
        pContext->hPendingReadMAC  = 0;
        pContext->hPendingWriteMAC = 0;
    }
    else
    {
        // Derive read MAC from the master hash object.
        if(pContext->hPendingReadMAC)
        {
            SchCryptDestroyKey(pContext->hPendingReadMAC, 0);
        }
        if(!SchCryptDeriveKey(hProv,
                              CALG_SCHANNEL_MAC_KEY,
                              hMasterHash,
                              CRYPT_EXPORTABLE | (fClient ? CRYPT_SERVER : 0),
                              &pContext->hPendingReadMAC,
                              0))
        {
            pctRet = SP_LOG_RESULT(GetLastError());
            goto cleanup;
        }

        // Derive write MAC from the master hash object.
        if(pContext->hPendingWriteMAC)
        {
            SchCryptDestroyKey(pContext->hPendingWriteMAC, 0);
        }
        if(!SchCryptDeriveKey(hProv,
                              CALG_SCHANNEL_MAC_KEY,
                              hMasterHash,
                              CRYPT_EXPORTABLE | (fClient ? 0 : CRYPT_SERVER),
                              &pContext->hPendingWriteMAC,
                              0))
        {
            pctRet = SP_LOG_RESULT(GetLastError());
            goto cleanup;
        }
    }

    pctRet = PCT_ERR_OK;

cleanup:

    if(hMasterHash)
    {
        SchCryptDestroyHash(hMasterHash, 0);
    }

    if(hLocalMasterKey)
    {
        CryptDestroyKey(hLocalMasterKey);
    }

    return pctRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   Ssl3ParseServerKeyExchange
//
//  Synopsis:   Parse the ServerKeyExchange message and import modulus and
//              exponent into a CryptoAPI public key.
//
//  Arguments:  [pContext]          --  Schannel context.
//
//              [pbMessage]         --  Pointer to message.
//
//              [cbMessage]         --  Message length.
//
//              [hServerPublic]     --  Handle to public key from server's
//                                      certificate. This is used to verify
//                                      the message's signature.
//
//              [phNewServerPublic] --  (output) Handle to new public key.
//
//
//  History:    10-23-97   jbanes   Created.
//
//  Notes:      This routine is called by the client-side only.
//
//              The format of the ServerKeyExchange message is:
//
//                  struct {
//                    select (KeyExchangeAlgorithm) {
//                        case diffie_hellman:
//                              ServerDHParams params;
//                              Signature signed_params;
//                        case rsa:
//                              ServerRSAParams params;
//                              Signature signed_params;
//                        case fortezza_dms:
//                              ServerFortezzaParams params;
//                    };
//                  } ServerKeyExchange;
//
//                  struct {
//                    opaque rsa_modulus<1..2^16-1>;
//                    opaque rsa_exponent<1..2^16-1>;
//                  } ServerRSAParams;
//
//----------------------------------------------------------------------------
SP_STATUS
Ssl3ParseServerKeyExchange(
    PSPContext  pContext,           // in
    PBYTE       pbMessage,          // in
    DWORD       cbMessage,          // in
    HCRYPTKEY   hServerPublic,      // in
    HCRYPTKEY  *phNewServerPublic)  // out
{
    PBYTE pbModulus = NULL;
    DWORD cbModulus;
    PBYTE pbExponent = NULL;
    DWORD cbExponent;
    PBYTE pbServerParams = NULL;
    DWORD cbServerParams;
    DWORD dwExponent;
    SP_STATUS pctRet;
    DWORD i;

    if(pbMessage == NULL || cbMessage == 0)
    {
        *phNewServerPublic = 0;
        return PCT_ERR_OK;
    }

    // Mark start of ServerRSAParams structure.
    // This is used to build hash values.
    pbServerParams = pbMessage;

    // Modulus length
    cbModulus = MAKEWORD(pbMessage[1], pbMessage[0]);
    pbMessage += 2;

    // Since the modulus is encoded as an INTEGER, it is padded with a leading
    // zero if its most significant bit is one. Remove this padding, if
    // present.
    if(pbMessage[0] == 0)
    {
        cbModulus -= 1;
        pbMessage += 1;
    }

    if(cbModulus < 512/8 || cbModulus > 1024/8)
    {
        return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
    }

    // Modulus
    pbModulus = pbMessage;
    pbMessage += cbModulus;

    // Exponent length
    cbExponent = MAKEWORD(pbMessage[1], pbMessage[0]);
    if(cbExponent < 1 || cbExponent > 4)
    {
        return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
    }
    pbMessage += 2;

    // Exponent
    pbExponent = pbMessage;
    pbMessage += cbExponent;

    // form a (little endian) DWORD from exponent data
    dwExponent =  0;
    for(i = 0; i < cbExponent; i++)
    {
        dwExponent <<= 8;
        dwExponent |=  pbExponent[i];
    }

    // Compute length of ServerRSAParams structure.
    cbServerParams = (DWORD)(pbMessage - pbServerParams);

    //
    // digitally-signed struct {
    //   select(SignatureAlgorithm) {
    //        case anonymous: struct { };
    //        case rsa:
    //             opaque md5_hash[16];
    //             opaque sha_hash[20];
    //        case dsa:
    //             opaque sha_hash[20];
    //   };
    // } Signature;
    //

    {
        BYTE rgbHashValue[CB_MD5_DIGEST_LEN + CB_SHA_DIGEST_LEN];
        PBYTE pbSignature;
        DWORD cbSignature;
        HCRYPTHASH hHash;
        PBYTE pbLocalBuffer;
        DWORD cbLocalBuffer;

        // Signature block length
        cbSignature = ((INT)pbMessage[0] << 8) + pbMessage[1];
        pbMessage += 2;
        pbSignature = pbMessage;

        // Allocate buffer for RSA operation.
        cbLocalBuffer = cbSignature;
        pbLocalBuffer = SPExternalAlloc(cbLocalBuffer);
        if(pbLocalBuffer == NULL)
        {
            return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        }

        // Reverse the signature.
        ReverseMemCopy(pbLocalBuffer, pbSignature, cbSignature);

        // Compute MD5 and SHA hash values.
        ComputeServerExchangeHashes(pContext,
                                    pbServerParams,
                                    cbServerParams,
                                    rgbHashValue,
                                    rgbHashValue + CB_MD5_DIGEST_LEN);


        if(!SchCryptCreateHash(pContext->RipeZombie->hMasterProv,
                               CALG_SSL3_SHAMD5,
                               0,
                               0,
                               &hHash,
                               pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
            SPExternalFree(pbLocalBuffer);
            return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
        }

        // set hash value
        if(!SchCryptSetHashParam(hHash,
                                 HP_HASHVAL,
                                 rgbHashValue,
                                 0,
                                 pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
            SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags);
            SPExternalFree(pbLocalBuffer);
            return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
        }

        DebugLog((DEB_TRACE, "Verify server_key_exchange message signature.\n"));
        if(!SchCryptVerifySignature(hHash,
                                    pbLocalBuffer,
                                    cbSignature,
                                    hServerPublic,
                                    NULL,
                                    0,
                                    pContext->RipeZombie->dwCapiFlags))
        {
            DebugLog((DEB_WARN, "Signature Verify Failed: %x\n", GetLastError()));
            SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags);
            SPExternalFree(pbLocalBuffer);
            return SP_LOG_RESULT(PCT_ERR_INTEGRITY_CHECK_FAILED);
        }
        DebugLog((DEB_TRACE, "Server_key_exchange message signature verified okay.\n"));

        SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags);
        SPExternalFree(pbLocalBuffer);
    }

    //
    // Import ephemeral public key into CSP.
    //

    {
        BLOBHEADER *pBlobHeader;
        RSAPUBKEY *pRsaPubKey;
        PBYTE pbBlob;
        DWORD cbBlob;

        // Allocate memory for PUBLICKEYBLOB.
        cbBlob = sizeof(BLOBHEADER) + sizeof(RSAPUBKEY) + cbModulus;
        pbBlob = SPExternalAlloc(cbBlob);
        if(pbBlob == NULL)
        {
            return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        }

        // Build PUBLICKEYBLOB from modulus and exponent.
        pBlobHeader = (BLOBHEADER *)pbBlob;
        pRsaPubKey  = (RSAPUBKEY *)(pBlobHeader + 1);

        pBlobHeader->bType    = PUBLICKEYBLOB;
        pBlobHeader->bVersion = CUR_BLOB_VERSION;
        pBlobHeader->reserved = 0;
        pBlobHeader->aiKeyAlg = CALG_RSA_KEYX;
        pRsaPubKey->magic     = 0x31415352; // RSA1
        pRsaPubKey->bitlen    = cbModulus * 8;
        pRsaPubKey->pubexp    = dwExponent;
        ReverseMemCopy((PBYTE)(pRsaPubKey + 1), pbModulus, cbModulus);

        if(!SchCryptImportKey(pContext->RipeZombie->hMasterProv,
                              pbBlob,
                              cbBlob,
                              0,
                              0,
                              phNewServerPublic,
                              pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
            SPExternalFree(pbBlob);
            return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
        }

        SPExternalFree(pbBlob);
    }

    return PCT_ERR_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\spbase\pct1srv.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       pct1srv.c
//
//  Contents:   
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   LSA integration stuff.
//
//----------------------------------------------------------------------------

#include <spbase.h>

#include <pct1msg.h>
#include <pct1prot.h>
#include <ssl2msg.h>

SP_STATUS
Pct1SrvHandleUniHello(
    PSPContext          pContext,
    PSPBuffer           pCommInput,
    PSsl2_Client_Hello  pHello,
    PSPBuffer           pCommOutput);



SP_STATUS WINAPI
Pct1ServerProtocolHandler(PSPContext pContext,
                    PSPBuffer  pCommInput,
                    PSPBuffer  pCommOutput)
{
    SP_STATUS      pctRet= 0;
    DWORD          dwStateTransition;

    SP_BEGIN("Pct1ServerProtocolHandler");

    if(pCommOutput) pCommOutput->cbData = 0;


    /* Protocol handling steps should be listed in most common
     * to least common in order to improve performance
     */

    /* We are not connected, so we're doing
     * protocol negotiation of some sort.  All protocol
     * negotiation messages are sent in the clear */
    /* There are no branches in the connecting protocol
     * state transition diagram, besides connection and error,
     * which means that a simple case statement will do */

    /* Do we have enough data to determine what kind of message we have */
    /* Do we have enough data to determine what kind of message we have, or how much data we need*/

    dwStateTransition = (pContext->State & 0xffff);

    if(((pContext->State & 0xffff) != SP_STATE_CONNECTED) &&
       ((pContext->State & 0xffff) != PCT1_STATE_RENEGOTIATE) &&
       ((pContext->State & 0xffff) != SP_STATE_SHUTDOWN) &&
       ((pContext->State & 0xffff) != SP_STATE_SHUTDOWN_PENDING))
    {
        if(pCommInput->cbData < 3)
        {
            pctRet = PCT_INT_INCOMPLETE_MSG;
        }
    }
    if(pCommInput->cbData >= 3)
    {
        dwStateTransition |= (((PUCHAR)pCommInput->pvBuffer)[2]<<16);
    }


    if(pctRet == PCT_ERR_OK)
    {
        switch(dwStateTransition)
        {
            case SP_STATE_SHUTDOWN_PENDING:
                // There's no CloseNotify in PCT, so just transition to
                // the shutdown state and leave the output buffer empty.
                pContext->State = SP_STATE_SHUTDOWN;
                break;    

            case SP_STATE_SHUTDOWN:
                return PCT_INT_EXPIRED;


            case SP_STATE_CONNECTED:
            {
                //We're connected, and we got called, so we must be doing a REDO
                SPBuffer    In;
                DWORD       cbMessage;

                // Transfer the write key over from the application process.
                if(pContext->hWriteKey == 0)
                {
                    pctRet = SPGetUserKeys(pContext, SCH_FLAG_WRITE_KEY);
                    if(pctRet != PCT_ERR_OK)
                    {
                        SP_RETURN(SP_LOG_RESULT(pctRet));
                    }
                }

                // Calculate size of buffer

                pCommOutput->cbData = 0;

                cbMessage    =  pContext->pHashInfo->cbCheckSum +
                                pContext->pCipherInfo->dwBlockSize +
                                sizeof(PCT1_MESSAGE_HEADER_EX);


                /* are we allocating our own memory? */
                if(pCommOutput->pvBuffer == NULL)
                {
                    pCommOutput->pvBuffer = SPExternalAlloc(cbMessage);
                    if (NULL == pCommOutput->pvBuffer)
                    {
                        SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
                    }
                    pCommOutput->cbBuffer = cbMessage;
                }


                if(cbMessage > pCommOutput->cbBuffer)
                {
                    pCommOutput->cbData = cbMessage;
                    SP_RETURN(PCT_INT_BUFF_TOO_SMALL);
                }

                In.pvBuffer = ((char *)pCommOutput->pvBuffer)+3;
                In.cbBuffer = pCommOutput->cbBuffer-3;
                In.cbData = 1;

                ((char *)In.pvBuffer)[0] = PCT1_ET_REDO_CONN;

                // Build a Redo Request
                pctRet = Pct1EncryptRaw(pContext, &In, pCommOutput, PCT1_ENCRYPT_ESCAPE);
                break;
            }

            /* Server receives client hello */
            case (SSL2_MT_CLIENT_HELLO << 16) | UNI_STATE_RECVD_UNIHELLO:
            {
                PSsl2_Client_Hello pSsl2Hello;

                // Attempt to recognize and handle various versions of client
                // hello, start by trying to unpickle the most recent version, and
                // then next most recent, until one unpickles.  Then run the handle
                // code.  We can also put unpickling and handling code in here for
                // SSL messages.

                pctRet = Ssl2UnpackClientHello(pCommInput, &pSsl2Hello);
                if(PCT_ERR_OK == pctRet)
                {
                    // We know we're doing a full handshake, so allocate a cache entry.

                    if(!SPCacheRetrieveNew(TRUE,
                                           pContext->pszTarget, 
                                           &pContext->RipeZombie))
                    {
                        pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
                    }
                    else
                    {
                        pContext->RipeZombie->fProtocol      = pContext->dwProtocol;
                        pContext->RipeZombie->dwCF           = pContext->dwRequestedCF;
                        pContext->RipeZombie->pServerCred    = pContext->pCredGroup;

                        pctRet = Pct1SrvHandleUniHello(
                                     pContext,
                                     pCommInput,
                                     pSsl2Hello,
                                     pCommOutput);
                        if (PCT_ERR_OK == pctRet)
                        {
                            pContext->State = PCT1_STATE_SERVER_HELLO;
                        }
                    }

                    SPExternalFree(pSsl2Hello);
                }

                if (SP_FATAL(pctRet))
                {
                    pContext->State = PCT1_STATE_ERROR;
                }
                break;
            }
            /* Server receives client hello */

            case (PCT1_MSG_CLIENT_HELLO << 16) | PCT1_STATE_RENEGOTIATE:
            {
                PPct1_Client_Hello pPct1Hello;
                UCHAR fRealSessId = 0;
                int i;

                // This is a renegotiate hello, so we do not restart

                pctRet = Pct1UnpackClientHello(
                                pCommInput,
                                &pPct1Hello);

                if(PCT_ERR_OK == pctRet)
                {
                    // Mark context as "unmapped" so that the new keys will get
                    // passed to the application process once the handshake is
                    // completed.
                    pContext->Flags &= ~CONTEXT_FLAG_MAPPED;

                    // We need to do a full handshake, so lose the cache entry.
                    SPCacheDereference(pContext->RipeZombie);
                    pContext->RipeZombie = NULL;

                    // Get a new cache item, as restarts are not allowed in
                    // REDO
                    if(!SPCacheRetrieveNew(TRUE,
                                           pContext->pszTarget, 
                                           &pContext->RipeZombie))
                    {
                        pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
                    }
                    else
                    {
                        pContext->RipeZombie->fProtocol     = SP_PROT_PCT1_SERVER;
                        pContext->RipeZombie->dwCF          = pContext->dwRequestedCF;
                        pContext->RipeZombie->pServerCred   = pContext->pCredGroup;

                        pctRet = Pct1SrvHandleClientHello(pContext,
                                                     pCommInput,
                                                     pPct1Hello,
                                                     pCommOutput);
                        if(PCT_ERR_OK == pctRet)
                        {
                            pContext->State = PCT1_STATE_SERVER_HELLO;
                        }
                    }
                    SPExternalFree(pPct1Hello);

                }
                else if(pctRet != PCT_INT_INCOMPLETE_MSG)
                {
                    pctRet |= PCT_INT_DROP_CONNECTION;
                }

                if(SP_FATAL(pctRet)) 
                {
                    pContext->State = PCT1_STATE_ERROR;
                }
                break;
            }

            case (PCT1_MSG_CLIENT_HELLO << 16) | SP_STATE_NONE:
            {
                PPct1_Client_Hello pPct1Hello;
                UCHAR fRealSessId = 0;
                int i;

                /* Attempt to recognize and handle various versions
                 * of client hello, start by trying to unpickle the
                 * most recent version, and then next most recent, until
                 * one unpickles.  Then run the handle code.  We can also put
                 * unpickling and handling code in here for SSL messages */
                pctRet = Pct1UnpackClientHello(
                                pCommInput,
                                &pPct1Hello);

                if(PCT_ERR_OK == pctRet)
                {


                    for(i=0;i<(int)pPct1Hello->cbSessionID;i++)
                    {
                        fRealSessId |= pPct1Hello->SessionID[i];
                    }

                    if (((pContext->Flags & CONTEXT_FLAG_NOCACHE) == 0) &&
                        (fRealSessId) &&
                        (SPCacheRetrieveBySession(pContext,
                                                  pPct1Hello->SessionID,
                                                  pPct1Hello->cbSessionID,
                                                  &pContext->RipeZombie)))
                    {
                        // We have a good zombie
                        DebugLog((DEB_TRACE, "Accept client's reconnect request.\n"));

                        pctRet = Pct1SrvRestart(pContext,
                                                pPct1Hello,
                                                pCommOutput);

                        if(PCT_ERR_OK == pctRet)
                        {
                            pContext->State = SP_STATE_CONNECTED;
                            pContext->DecryptHandler = Pct1DecryptHandler;
                            pContext->Encrypt = Pct1EncryptMessage;
                            pContext->Decrypt = Pct1DecryptMessage;
                            pContext->GetHeaderSize = Pct1GetHeaderSize;
                        }
                    }
                    else
                    {
                        // We're doing a full handshake, so allocate a cache entry.

                        if(!SPCacheRetrieveNew(TRUE,
                                               pContext->pszTarget, 
                                               &pContext->RipeZombie))
                        {
                            pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
                        }
                        else
                        {
                            pContext->RipeZombie->fProtocol      = pContext->dwProtocol;
                            pContext->RipeZombie->dwCF           = pContext->dwRequestedCF;
                            pContext->RipeZombie->pServerCred    = pContext->pCredGroup;

                            pctRet = Pct1SrvHandleClientHello(pContext,
                                                         pCommInput,
                                                         pPct1Hello,
                                                         pCommOutput);
                            if (PCT_ERR_OK == pctRet)
                            {
                                pContext->State = PCT1_STATE_SERVER_HELLO;
                            }
                        }
                    }
                    SPExternalFree(pPct1Hello);

                }
                else if(pctRet != PCT_INT_INCOMPLETE_MSG)
                {
                    pctRet |= PCT_INT_DROP_CONNECTION;
                }

                if(SP_FATAL(pctRet)) {
                    pContext->State = PCT1_STATE_ERROR;
                }
                break;
            }
            case (PCT1_MSG_CLIENT_MASTER_KEY << 16) | PCT1_STATE_SERVER_HELLO:
                pctRet = Pct1SrvHandleCMKey(pContext,
                                            pCommInput,
                                            pCommOutput);
                if(SP_FATAL(pctRet)) {
                    pContext->State = PCT1_STATE_ERROR;
                } else {
                    if(PCT_ERR_OK == pctRet) {
                        pContext->State = SP_STATE_CONNECTED;
                        pContext->DecryptHandler = Pct1DecryptHandler;
                        pContext->Encrypt = Pct1EncryptMessage;
                        pContext->Decrypt = Pct1DecryptMessage;
                        pContext->GetHeaderSize = Pct1GetHeaderSize;

                    }
                    /* We received a non-fatal error, so the state doesn't
                     * change, giving the app time to deal with this */
                }
                break;


            default:
                pContext->State = PCT1_STATE_ERROR;
                {
                    pctRet = PCT_INT_ILLEGAL_MSG;
                    if(((PUCHAR)pCommInput->pvBuffer)[2] == PCT1_MSG_ERROR)
                    {
                        /* we received an error message, process it */
                        pctRet = Pct1HandleError(pContext,
                                                 pCommInput,
                                                 pCommOutput);

                    } else {
                        /* we received an unknown error, generate a
                         * PCT_ERR_ILLEGAL_MESSAGE */
                        pctRet = Pct1GenerateError(pContext,
                                                    pCommOutput,
                                                    PCT_ERR_ILLEGAL_MESSAGE,
                                                    NULL);
                    }
                }

        }
    }

    if(pctRet & PCT_INT_DROP_CONNECTION) 
    {
        pContext->State &= ~SP_STATE_CONNECTED;
    }

    SP_RETURN(pctRet);
}

SP_STATUS
Pct1SrvHandleUniHello(
    PSPContext         pContext,
    PSPBuffer           pCommInput,
    PSsl2_Client_Hello  pHello,
    PSPBuffer           pCommOutput)
{
    SP_STATUS pctRet = PCT_ERR_ILLEGAL_MESSAGE;

    Pct1_Client_Hello  ClientHello;
    DWORD              iCipher;
    DWORD              dwSpec;
    DWORD              i;

    CipherSpec      aCipherSpecs[PCT1_MAX_CIPH_SPECS];
    HashSpec        aHashSpecs[PCT1_MAX_HASH_SPECS];
    CertSpec        aCertSpecs[PCT1_MAX_CERT_SPECS];
    ExchSpec        aExchSpecs[PCT1_MAX_EXCH_SPECS];


    SP_BEGIN("Pct1SrvHandlUniHello");
    if(NULL == pContext)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    ClientHello.pCipherSpecs =aCipherSpecs;
    ClientHello.pHashSpecs =aHashSpecs;
    ClientHello.pCertSpecs =aCertSpecs;
    ClientHello.pExchSpecs =aExchSpecs;

    ClientHello.cCipherSpecs =0;
    ClientHello.cHashSpecs =0;
    ClientHello.cCertSpecs =0;
    ClientHello.cExchSpecs =0;


    /* validate the buffer configuration */



    for (iCipher = 0;
         (iCipher < pHello->cCipherSpecs) && (iCipher < PCT1_MAX_CIPH_SPECS) ;
         iCipher++ )
    {
        dwSpec = pHello->CipherSpecs[iCipher] & 0xffff;

        switch(pHello->CipherSpecs[iCipher] >> 16)
        {
            case PCT_SSL_HASH_TYPE:
                ClientHello.pHashSpecs[ClientHello.cHashSpecs++] = dwSpec;
                break;

            case PCT_SSL_EXCH_TYPE:
                ClientHello.pExchSpecs[ClientHello.cExchSpecs++] = dwSpec;
                break;
            case PCT_SSL_CERT_TYPE:
                ClientHello.pCertSpecs[ClientHello.cCertSpecs++] = dwSpec;
                break;

            case PCT_SSL_CIPHER_TYPE_1ST_HALF:
                // Do we have enough room for a 2nd half.
                if(iCipher+1 >= pHello->cCipherSpecs)
                {
                    break;
                }
                if((pHello->CipherSpecs[iCipher+1] >> 16) != PCT_SSL_CIPHER_TYPE_2ND_HALF)
                {
                    break;
                }

                dwSpec = (pHello->CipherSpecs[iCipher+1] & 0xffff) |
                             (dwSpec<< 16);

                ClientHello.pCipherSpecs[ClientHello.cCipherSpecs++] = dwSpec;
                break;
        }
    }

    // Restarts are not allowed with Uni Hello's, so we don't need
    // The session ID.
    ClientHello.cbSessionID = 0;


    /* Make the SSL2 challenge into a PCT1 challenge as per the
     * compatability doc. */

    CopyMemory( ClientHello.Challenge,
                pHello->Challenge,
                pHello->cbChallenge);


    for(i=0; i < pHello->cbChallenge; i++)
    {
        ClientHello.Challenge[i + pHello->cbChallenge] = ~ClientHello.Challenge[i];
    }
    ClientHello.cbChallenge = 2*pHello->cbChallenge;

    ClientHello.cbKeyArgSize = 0;

    pctRet = Pct1SrvHandleClientHello(pContext, pCommInput, &ClientHello, pCommOutput);


    SP_RETURN(pctRet);
}



/* Otherwise known as Handle Client Hello */
SP_STATUS
Pct1SrvHandleClientHello(
    PSPContext          pContext,
    PSPBuffer           pCommInput,
    PPct1_Client_Hello  pHello,
    PSPBuffer           pCommOutput
    )
{
    SP_STATUS           pctRet = PCT_ERR_ILLEGAL_MESSAGE;
    PSPCredentialGroup  pCred;
    Pct1_Server_Hello   Reply;
    DWORD               i, j, k , fMismatch;
    BYTE                MisData[PCT_NUM_MISMATCHES];
    SPBuffer            ErrData;
    PSessCacheItem      pZombie;

    BOOL                fCert = FALSE;
    DWORD               aCertSpecs[PCT1_MAX_CERT_SPECS];
    DWORD               aSigSpecs[PCT1_MAX_SIG_SPECS];
    DWORD               cCertSpecs;
    DWORD               cSigSpecs;
    BOOL fAllocatedOutput = FALSE;

    CertTypeMap LocalCertEncodingPref[5] ;
    DWORD cLocalCertEncodingPref = 0;

    BOOL                fFound;

#if DBG
    DWORD               di;
#endif

    SP_BEGIN("Pct1SrvHandleClientHello");

    pCommOutput->cbData = 0;

    /* validate the buffer configuration */
    ErrData.cbData = 0;
    ErrData.pvBuffer = NULL;
    ErrData.cbBuffer = 0;

    pZombie = pContext->RipeZombie;


    pCred = pZombie->pServerCred;
    if (!pCred)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }


    do {

#if DBG
        DebugLog((DEB_TRACE, "Client Hello at %x\n", pHello));
        DebugLog((DEB_TRACE, "  CipherSpecs  %d\n", pHello->cCipherSpecs));
        for (di = 0 ; di < pHello->cCipherSpecs ; di++ )
        {
            DebugLog((DEB_TRACE, "    Cipher[%d] = %06x (%s)\n", di,
                      pHello->pCipherSpecs[di],
                      DbgGetNameOfCrypto(pHello->pCipherSpecs[di]) ));
        }
#endif


        /* store the challenge in the auth block */
        CopyMemory( pContext->pChallenge,
                    pHello->Challenge,
                    pHello->cbChallenge );
        pContext->cbChallenge = pHello->cbChallenge;


        // The session id was computed when the cache entry
        // was created. We do need to fill in the length, though.
        pZombie->cbSessionID = PCT1_SESSION_ID_SIZE;


        /* Begin to build the server hello */
        FillMemory( &Reply, sizeof( Reply ), 0 );

        /* no matter what, we need to make a new connection id */

        GenerateRandomBits(  Reply.ConnectionID,
                             PCT1_SESSION_ID_SIZE );
        Reply.cbConnectionID = PCT1_SESSION_ID_SIZE;

        CopyMemory( pContext->pConnectionID,
                    Reply.ConnectionID,
                    PCT1_SESSION_ID_SIZE );

        pContext->cbConnectionID = PCT_SESSION_ID_SIZE;

        /* no restart case */
        /* fill in from properties here... */

        Reply.RestartOk = FALSE;
        Reply.ClientAuthReq = ((pContext->Flags & CONTEXT_FLAG_MUTUAL_AUTH) != 0);

        fMismatch = 0;
        pContext->pPendingCipherInfo = NULL;



        /* Build a list of cert specs */
        /* Hash order of preference:
         * Server Preference
         *    Client Preference
         */
        for(i=0; i < cPct1CertEncodingPref; i++)
        {
  
            for(j=0; j< pHello->cCertSpecs; j++)
            {
                // Does the client want this cipher type
                if(aPct1CertEncodingPref[i].Spec == pHello->pCertSpecs[j])
                {
                    LocalCertEncodingPref[cLocalCertEncodingPref].Spec = aPct1CertEncodingPref[i].Spec;
                    LocalCertEncodingPref[cLocalCertEncodingPref++].dwCertEncodingType = aPct1CertEncodingPref[i].dwCertEncodingType;
                    break;
                }
            }
        }


        /* Determine Key Exchange to use */
        /* Key Exchange order of preference:
         * Server Preference
         *    Client Preference
         */

        // NOTE:  Yes, the following line does do away with any error
        // information if we had a previous mismatch.  However, the
        // setting of pctRet to mismatch in previous lines is for
        // logging purposes only.  The actual error report occurs later.
        pctRet = PCT_ERR_OK;
        for(i=0; i < cPct1LocalExchKeyPref; i++)
        {
            // Do we enable this cipher
            if(NULL == KeyExchangeFromSpec(aPct1LocalExchKeyPref[i].Spec, SP_PROT_PCT1_SERVER))
            {
                continue;
            }

            for(j=0; j< pHello->cExchSpecs; j++)
            {
                // Does the client want this cipher type
                if(aPct1LocalExchKeyPref[i].Spec != pHello->pExchSpecs[j])
                {
                    continue;
                }
                // See if we have a cert for this type of
                // key exchange.

                pctRet = SPPickServerCertificate(pContext, 
                                                 aPct1LocalExchKeyPref[i].Spec);
                if(pctRet != PCT_ERR_OK)
                {
                    continue;
                }

                // Store the exch id in the cache.
                pZombie->SessExchSpec = aPct1LocalExchKeyPref[i].Spec;
                pContext->pKeyExchInfo = GetKeyExchangeInfo(pZombie->SessExchSpec);

                // load the exch info structure
                if(!IsExchAllowed(pContext, 
                                  pContext->pKeyExchInfo,
                                  pZombie->fProtocol))
                {
                    pContext->pKeyExchInfo = NULL;
                    continue;
                }
                Reply.SrvExchSpec = aPct1LocalExchKeyPref[i].Spec;
                break;
            }
            if(pContext->pKeyExchInfo)
            {
                break;
            }
        }

        if(PCT_ERR_OK != pctRet)
        {
            fMismatch |= PCT_IMIS_CERT;
        }

        if (NULL == pContext->pKeyExchInfo)
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_SPECS_MISMATCH);
            fMismatch |= PCT_IMIS_EXCH;
        }

        if (fMismatch) 
        {
            pctRet = PCT_ERR_SPECS_MISMATCH;
            break;
        }


        /* Determine Cipher to use */
        /* Cipher order of preference:
         * Server Preference
         *    Client Preference
         */

        fFound = FALSE;

        for(i=0; i < Pct1NumCipher; i++)
        {

            for(j=0; j< pHello->cCipherSpecs; j++)
            {
                // Does the client want this cipher type
                if(Pct1CipherRank[i].Spec == pHello->pCipherSpecs[j])
                {
                    // Store this cipher identifier in the cache
                    pZombie->aiCipher = Pct1CipherRank[i].aiCipher;
                    pZombie->dwStrength = Pct1CipherRank[i].dwStrength;

                    // Load the pending cipher structure.
                    pContext->pPendingCipherInfo = GetCipherInfo(pZombie->aiCipher, 
                                                                 pZombie->dwStrength);

                    if(!IsCipherAllowed(pContext, 
                                        pContext->pPendingCipherInfo, 
                                        pZombie->fProtocol,
                                        pZombie->dwCF))
                    {
                        pContext->pPendingCipherInfo = NULL;
                        continue;
                    }

                    // Is cipher supported by CSP?
                    for(k = 0; k < pZombie->pActiveServerCred->cCapiAlgs; k++)
                    {
                        PROV_ENUMALGS_EX *pAlgInfo = &pZombie->pActiveServerCred->pCapiAlgs[k];

                        if(pAlgInfo->aiAlgid != Pct1CipherRank[i].aiCipher)
                        {
                            continue;
                        }

                        if(Pct1CipherRank[i].dwStrength > pAlgInfo->dwMaxLen ||
                           Pct1CipherRank[i].dwStrength < pAlgInfo->dwMinLen)
                        {
                            continue;
                        }

                        if(!(pAlgInfo->dwProtocols & CRYPT_FLAG_PCT1))
                        {
                            continue;
                        }

                        fFound = TRUE;
                        break;
                    }
                    if(fFound)
                    {
                        break;
                    }
                }
            }
            if(fFound)
            {
                break;
            }
        }

        if(fFound)
        {
            Reply.SrvCipherSpec = Pct1CipherRank[i].Spec;
        }
        else
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_SPECS_MISMATCH);
            fMismatch |= PCT_IMIS_CIPHER;
        }


        /* Determine Hash to use */
        /* Hash order of preference:
         * Server Preference
         *    Client Preference
         */
        for(i=0; i < Pct1NumHash; i++)
        {

            for(j=0; j< pHello->cHashSpecs; j++)
            {
                // Does the client want this cipher type
                if(Pct1HashRank[i].Spec == pHello->pHashSpecs[j])
                {
                    // Store this hash id in the cache
                    pZombie->aiHash = Pct1HashRank[i].aiHash;
                    pContext->pPendingHashInfo = GetHashInfo(pZombie->aiHash);

                    if(!IsHashAllowed(pContext, 
                                      pContext->pPendingHashInfo,
                                      pZombie->fProtocol))
                    {
                        pContext->pPendingHashInfo = NULL;
                        continue;
                    }

                    Reply.SrvHashSpec = Pct1HashRank[i].Spec;
                    break;


                }
            }
            if(pContext->pPendingHashInfo)
            {
                break;
            }
        }

        if (pContext->pPendingHashInfo==NULL)
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_SPECS_MISMATCH);
            fMismatch |= PCT_IMIS_HASH;
        }


        if (fMismatch) 
        {
            LogCipherMismatchEvent();
            pctRet = PCT_ERR_SPECS_MISMATCH;
            break;
        }


        // Pick a certificate to use based on
        // the key exchange mechanism selected.

        for(i=0; i < cLocalCertEncodingPref; i++)
        {
            if(LocalCertEncodingPref[i].dwCertEncodingType == pZombie->pActiveServerCred->pCert->dwCertEncodingType)
            {
                Reply.SrvCertSpec =    LocalCertEncodingPref[i].Spec;
                break;
            }

        }

        if(Reply.SrvCertSpec == PCT1_CERT_X509_CHAIN)
        {
            pContext->fCertChainsAllowed = TRUE;
        }

        Reply.pCertificate = NULL;
        Reply.CertificateLen = 0;
        // NOTE: SPSerializeCertificate will allocate memory
        // for the certificate, which we save in pZombie->pbServerCertificate.
        // This must be freed when the zombie dies (can the undead die?)
        pctRet = SPSerializeCertificate(SP_PROT_PCT1,
                                        pContext->fCertChainsAllowed,
                                        &pZombie->pbServerCertificate,
                                        &pZombie->cbServerCertificate,
                                        pZombie->pActiveServerCred->pCert,
                                        CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL);

        if(pctRet == PCT_ERR_OK)
        {
            Reply.pCertificate = pZombie->pbServerCertificate;
            Reply.CertificateLen = pZombie->cbServerCertificate;
        }

        else
        {
            break;
        }


        pctRet = ContextInitCiphers(pContext, TRUE, TRUE);

        if(PCT_ERR_OK != pctRet)
        {
            break;
        }

        /* sig and cert specs are pre-zeroed when Reply is initialized */

        if(Reply.ClientAuthReq)
        {
            PCertSysInfo pCertInfo;
            PSigInfo pSigInfo;

            cCertSpecs=0;
            cSigSpecs = 0;

            for(i=0; i < cPct1LocalSigKeyPref; i++)
            {
                pSigInfo = GetSigInfo(aPct1LocalSigKeyPref[i].Spec);
                if(pSigInfo != NULL)
                {
                    if(pSigInfo->fProtocol & SP_PROT_PCT1_SERVER)
                    {
                        aSigSpecs[cSigSpecs++] = aPct1LocalSigKeyPref[i].Spec;
                    }
                }
            }

            Reply.pClientSigSpecs = aSigSpecs;
            Reply.cSigSpecs = cSigSpecs;

            for(i=0; i < cPct1CertEncodingPref; i++)
            {
                pCertInfo = GetCertSysInfo(aPct1CertEncodingPref[i].dwCertEncodingType);
                if(pCertInfo == NULL)
                {
                    continue;
                }
                if(0 == (pCertInfo->fProtocol & SP_PROT_PCT1_SERVER))
                {
                    continue;
                }
                aCertSpecs[cCertSpecs++] = aPct1CertEncodingPref[i].Spec;
            }
            Reply.pClientCertSpecs = aCertSpecs;
            Reply.cCertSpecs = cCertSpecs;
        }



#if DBG
        DebugLog((DEB_TRACE, "Server picks cipher %06x (%s)\n",
                  Reply.SrvCipherSpec,
                  DbgGetNameOfCrypto(Reply.SrvCipherSpec) ));
#endif


        Reply.ResponseLen = 0;
        if(pCommOutput->pvBuffer == NULL)
        {
            fAllocatedOutput=TRUE;
        }

        pctRet = Pct1PackServerHello(&Reply, pCommOutput);
        if(PCT_ERR_OK != pctRet)
        {
            break;
        }

        /* Regenerate the internal pVerifyPrelude, so we */
        /* can match it against the client when we get the */
        /* client master key */

        pctRet = Pct1BeginVerifyPrelude(pContext,
                               pCommInput->pvBuffer,
                               pCommInput->cbData,
                               pCommOutput->pvBuffer,
                               pCommOutput->cbData);



        if(PCT_ERR_OK != pctRet)
        {
            if(fAllocatedOutput)
            {
                SPExternalFree(pCommOutput->pvBuffer);
            }

            break;
        }

        SP_RETURN(PCT_ERR_OK);
    } while (TRUE); /* end Polish Loop */



    if(pctRet == PCT_ERR_SPECS_MISMATCH) {
            for(i=0;i<PCT_NUM_MISMATCHES;i++)
            {
                MisData[i] = (BYTE)(fMismatch & 1);
                fMismatch = fMismatch >> 1;
            }

            ErrData.cbData = ErrData.cbBuffer = PCT_NUM_MISMATCHES;
            ErrData.pvBuffer = MisData;
    }

    pctRet = Pct1GenerateError(pContext,
                              pCommOutput,
                              pctRet,
                              &ErrData);


    SP_RETURN(pctRet | PCT_INT_DROP_CONNECTION);

}



//+---------------------------------------------------------------------------
//
//  Function:   Pct1SrvHandleCMKey
//
//  Synopsis:   Process the ClientKeyExchange message group.
//
//  Arguments:  [pContext]      --  Schannel context.
//              [pCommInput]    -- 
//              [pCommOutput]   --
//
//  History:    10-10-97   jbanes   Added CAPI integration.
//
//  Notes:      This routine is called by the server-side only.
//
//----------------------------------------------------------------------------
SP_STATUS
Pct1SrvHandleCMKey(
    PSPContext     pContext,
    PSPBuffer       pCommInput,
    PSPBuffer       pCommOutput)
{
    SP_STATUS          pctRet = PCT_ERR_ILLEGAL_MESSAGE;
    PPct1_Client_Master_Key  pMasterKey = NULL;
    DWORD               dwKeyLen;
    DWORD               EncryptedLen;
    Pct1_Server_Verify       Verify;
    UCHAR               VerifyPrelude[RESPONSE_SIZE];
    DWORD               cbVerifyPrelude;
    SPBuffer           ErrData;
    DWORD k;
    PSessCacheItem     pZombie;
    PSigInfo pSigInfo;

    SP_BEGIN("Pct1SrvHandleCMKey");

    pCommOutput->cbData = 0;

    ErrData.cbData = 0;
    ErrData.pvBuffer = NULL;
    ErrData.cbBuffer = 0;
    pZombie = pContext->RipeZombie;

    do {


        pctRet = Pct1UnpackClientMasterKey(pCommInput, &pMasterKey);
        if (PCT_ERR_OK != pctRet)
        {
            // If it's an incomplete message or something, just return;
            if(pctRet == PCT_INT_INCOMPLETE_MSG)
            {
                SP_RETURN(pctRet);
            }
            break;
        }




        /* Validate that the client properly authed */

        /* The server requested client auth */
        /* NOTE: this deviates from the first pct 1.0 spec,
         * Now, we continue with the protocol if client
         * auth fails.  By the first spec, we should
         * drop the connection */

        if (pContext->Flags & CONTEXT_FLAG_MUTUAL_AUTH)
        {



            /* Client auth polish loop */
            pctRet = PCT_ERR_OK;
            do
            {


                /* check to see if the client sent no cert */
                if(pMasterKey->ClientCertLen == 0)
                {
                    /* No client auth */
                    break;
                }

                pctRet = SPLoadCertificate(SP_PROT_PCT1_SERVER,
                                           X509_ASN_ENCODING,
                                           pMasterKey->pClientCert,
                                           pMasterKey->ClientCertLen,
                                           &pZombie->pRemoteCert);

                if(PCT_ERR_OK != pctRet)
                {
                    break;
                }
                if(pContext->RipeZombie->pRemotePublic != NULL)
                {
                    SPExternalFree(pContext->RipeZombie->pRemotePublic);
                    pContext->RipeZombie->pRemotePublic = NULL;
                }

                pctRet = SPPublicKeyFromCert(pZombie->pRemoteCert,
                                             &pZombie->pRemotePublic,
                                             NULL);

                if(PCT_ERR_OK != pctRet)
                {
                    break;
                }
                if(pZombie->pRemoteCert == NULL)
                {
                    break;
                }



                /* verify that we got a sig type that meets PCT spec */
                for(k=0; k < cPct1LocalSigKeyPref; k++)
                {
                    if(aPct1LocalSigKeyPref[k].Spec == pMasterKey->ClientSigSpec)
                    {
                        break;
                    }
                }

                if(k == cPct1LocalSigKeyPref)
                {
                    break;
                }


                // Get pointer to signature algorithm info and make sure 
                // we support it.
                pSigInfo = GetSigInfo(pMasterKey->ClientSigSpec);
                if(pSigInfo == NULL)
                {
                    pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
                    break;
                }
                if(!(pSigInfo->fProtocol & SP_PROT_PCT1_SERVER))
                {
                    pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
                    break;
                }

                // Verify client authentication signature.
                DebugLog((DEB_TRACE, "Verify client response signature.\n"));
                pctRet = SPVerifySignature(pZombie->hMasterProv,
                                           pZombie->dwCapiFlags,
                                           pZombie->pRemotePublic,
                                           pSigInfo->aiHash,
                                           pMasterKey->VerifyPrelude,
                                           pMasterKey->VerifyPreludeLen,
                                           pMasterKey->pbResponse,
                                           pMasterKey->ResponseLen,
                                           TRUE);
                if(pctRet != PCT_ERR_OK)
                {
                    // client auth signature failed to verify, so client auth
                    // does not happen.
                    SP_LOG_RESULT(pctRet); 
                    break;
                }
                DebugLog((DEB_TRACE, "Client response verified successfully.\n"));

                pctRet = SPContextDoMapping(pContext);


            } while(FALSE); /* end polish loop */

            if(PCT_ERR_OK != pctRet)
            {
                break;
            }

        }

        /* Client auth was successful */
        pctRet = PCT_ERR_ILLEGAL_MESSAGE;

        /* Copy over the key args */
        CopyMemory( pZombie->pKeyArgs,
                    pMasterKey->KeyArg,
                    pMasterKey->KeyArgLen );
        pZombie->cbKeyArgs = pMasterKey->KeyArgLen;


        // Decrypt the encrypted portion of the master key. Because
        // we're CAPI integrated, the keys get derived as well.
        pctRet = pContext->pKeyExchInfo->System->GenerateServerMasterKey(
                    pContext,
                    pMasterKey->ClearKey,
                    pMasterKey->ClearKeyLen,
                    pMasterKey->pbEncryptedKey,
                    pMasterKey->EncryptedKeyLen);
        if(PCT_ERR_OK != pctRet)
        {
            break;
        }

        // Activate session keys.
        Pct1ActivateSessionKeys(pContext);


        if (pMasterKey->VerifyPreludeLen != pContext->pHashInfo->cbCheckSum)
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_INTEGRITY_CHECK_FAILED);
            break;
        }

        /* Check the verify prelude hashes */
        /* Hash(CLIENT_MAC_KEY, Hash( "cvp", CLIENT_HELLO, SERVER_HELLO)) */
        /* The internal hash should already be in the verify prelude buffer */
        /* from the handle client master key. */

        cbVerifyPrelude = sizeof(VerifyPrelude);
        pctRet = Pct1EndVerifyPrelude(pContext, VerifyPrelude, &cbVerifyPrelude);
        if(PCT_ERR_OK != pctRet)
        {
            break;
        }


        /* Did the verify prelude hash successfully? */
        if(memcmp(VerifyPrelude, pMasterKey->VerifyPrelude, pContext->pHashInfo->cbCheckSum))
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_INTEGRITY_CHECK_FAILED);
            break;
        }

        /* don't need master key info anymore */
        SPExternalFree(pMasterKey);
        pMasterKey = NULL;


        pContext->WriteCounter = 2;
        pContext->ReadCounter = 2;

        pZombie->cbSessionID = PCT1_SESSION_ID_SIZE;

        CopyMemory( Verify.SessionIdData,
                    pZombie->SessionID,
                    pZombie->cbSessionID);

        /* compute the response */
        Verify.ResponseLen = sizeof(Verify.Response);
        pctRet = Pct1ComputeResponse(pContext, 
                                     pContext->pChallenge,
                                     pContext->cbChallenge,
                                     pContext->pConnectionID,
                                     pContext->cbConnectionID,
                                     pZombie->SessionID,
                                     pZombie->cbSessionID,
                                     Verify.Response,
                                     &Verify.ResponseLen);
        if(pctRet != PCT_ERR_OK)
        {
            SP_RETURN(SP_LOG_RESULT(pctRet));
        }

        pctRet = Pct1PackServerVerify(&Verify, pCommOutput);

        if(PCT_ERR_OK != pctRet)
        {
            break;
        }

        /* set up the session in cache */
        SPCacheAdd(pContext);

        SP_RETURN(PCT_ERR_OK);
    } while(TRUE); /* End of polish loop */

    if(pMasterKey) SPExternalFree(pMasterKey);

    pctRet = Pct1GenerateError(pContext,
                              pCommOutput,
                              pctRet,
                              NULL);

    SP_RETURN(pctRet | PCT_INT_DROP_CONNECTION);

}


SP_STATUS
Pct1SrvRestart(
    PSPContext          pContext,
    PPct1_Client_Hello  pHello,
    PSPBuffer           pCommOutput)
{
    Pct1_Server_Hello   Reply;
    SPBuffer            ErrData;
    SP_STATUS           pctRet = PCT_INT_ILLEGAL_MSG;
    PSessCacheItem      pZombie;
    DWORD               i;

    SP_BEGIN("Pct1SrvRestart");

    pCommOutput->cbData = 0;

    /* validate the buffer configuration */
    ErrData.cbData = 0;
    ErrData.pvBuffer = NULL;
    ErrData.cbBuffer = 0;

    pZombie = pContext->RipeZombie;



     do {

        /* store the challenge in the auth block */
        CopyMemory( pContext->pChallenge,
                    pHello->Challenge,
                    pHello->cbChallenge );
        pContext->cbChallenge = pHello->cbChallenge;


        /* Begin to build the server hello */
        FillMemory( &Reply, sizeof( Reply ), 0 );


        /* Generate new connection id */
        GenerateRandomBits(  Reply.ConnectionID,
                             PCT1_SESSION_ID_SIZE );
        Reply.cbConnectionID = PCT1_SESSION_ID_SIZE;

        CopyMemory( pContext->pConnectionID,
                    Reply.ConnectionID,
                    Reply.cbConnectionID );
        pContext->cbConnectionID = Reply.cbConnectionID;

        Reply.RestartOk = TRUE;


        /* We don't pass a server cert back during a restart */
        Reply.pCertificate = NULL;
        Reply.CertificateLen = 0;
        /* setup the context */


        for(i=0; i < Pct1NumCipher; i++)
        {
            if((Pct1CipherRank[i].aiCipher == pZombie->aiCipher) &&
               (Pct1CipherRank[i].dwStrength == pZombie->dwStrength))
            {
                Reply.SrvCipherSpec = Pct1CipherRank[i].Spec;
            }
        }

        for(i=0; i < Pct1NumHash; i++)
        {
            if(Pct1HashRank[i].aiHash == pZombie->aiHash)
            {
                Reply.SrvHashSpec = Pct1HashRank[i].Spec;
            }
        }

        Reply.SrvCertSpec =   pZombie->pActiveServerCred->pCert->dwCertEncodingType;
        Reply.SrvExchSpec =   pZombie->SessExchSpec;

        // We know what our ciphers are, so init the cipher system
        pctRet = ContextInitCiphersFromCache(pContext);

        if(PCT_ERR_OK != pctRet)
        {
            break;
        }

        // We know what our ciphers are, so init the cipher system
        pctRet = ContextInitCiphers(pContext, TRUE, TRUE);

        if(PCT_ERR_OK != pctRet)
        {
            break;
        }

        // Make a new set of session keys.
        pctRet = MakeSessionKeys(pContext,
                                 pContext->RipeZombie->hMasterProv,
                                 pContext->RipeZombie->hMasterKey);
        if(PCT_ERR_OK != pctRet)
        {
            break;
        }


        // Activate session keys.
        Pct1ActivateSessionKeys(pContext);


        /* compute the response */
        Reply.ResponseLen = sizeof(Reply.Response);
        pctRet = Pct1ComputeResponse(pContext, 
                                     pContext->pChallenge,
                                     pContext->cbChallenge,
                                     pContext->pConnectionID,
                                     pContext->cbConnectionID,
                                     pZombie->SessionID,
                                     pZombie->cbSessionID,
                                     Reply.Response,
                                     &Reply.ResponseLen);
        if(pctRet != PCT_ERR_OK)
        {
            break;
        }

        pctRet = Pct1PackServerHello(&Reply, pCommOutput);

        if(PCT_ERR_OK != pctRet)
        {
            break;
        }

        pContext->ReadCounter = 1;
        pContext->WriteCounter = 1;

        SP_RETURN(PCT_ERR_OK);
    } while (TRUE);
    pctRet = Pct1GenerateError(pContext,
                              pCommOutput,
                              pctRet,
                              &ErrData);


    SP_RETURN(pctRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\spbase\pct1pckl.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       pct1pckl.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:
//
//----------------------------------------------------------------------------

#include <spbase.h>
#include <pct1msg.h>
#include <pct1prot.h>

#define PCT_OFFSET_OF(t, v) ((DWORD)(ULONG_PTR)&(((t)NULL)->v))

#define SIZEOF(pMessage)    (Pct1RecordSize((PPCT1_MESSAGE_HEADER) pMessage ) )

DWORD MapCipherToExternal(CipherSpec Internal, ExtCipherSpec UNALIGNED *External)
{
    *External = htonl(Internal);
    return TRUE;
}

DWORD MapHashToExternal(HashSpec Internal, ExtHashSpec UNALIGNED *External)
{
    *External = htons((ExtHashSpec)Internal);
    return TRUE;
}

DWORD MapCertToExternal(CertSpec Internal, ExtCertSpec UNALIGNED *External)
{
    *External = htons((ExtCertSpec)Internal);
    return TRUE;
}

DWORD MapExchToExternal(ExchSpec Internal, ExtExchSpec UNALIGNED *External)
{
    *External = htons((ExtExchSpec)Internal);
    return TRUE;
}

DWORD MapSigToExternal(SigSpec Internal, ExtSigSpec UNALIGNED *External)
{
    *External = htons((ExtSigSpec)Internal);
    return TRUE;
}

CipherSpec MapCipherFromExternal(ExtCipherSpec External)
{
    return (CipherSpec)ntohl(External);
}

HashSpec MapHashFromExternal(ExtHashSpec External)
{
    return (HashSpec)ntohs(External);
}

CertSpec MapCertFromExternal(ExtCertSpec External)
{
    return (CertSpec)ntohs(External);
}

ExchSpec MapExchFromExternal(ExtExchSpec External)
{
    return (ExchSpec)ntohs(External);
}

SigSpec MapSigFromExternal(ExtSigSpec External)
{
    return (SigSpec)ntohs(External);
}


DWORD
Pct1RecordSize(
    PPCT1_MESSAGE_HEADER  pHeader)
{
    DWORD   Size;

    if (pHeader->Byte0 & 0x80)
    {
        Size = COMBINEBYTES(pHeader->Byte0, pHeader->Byte1) & 0x7FFF;
    }
    else
    {
        Size = COMBINEBYTES(pHeader->Byte0, pHeader->Byte1) & 0x3FFF;
    }
    return(Size);
}


SP_STATUS
Pct1PackClientHello(
    PPct1_Client_Hello       pCanonical,
    PSPBuffer          pCommOutput)
{
    DWORD               cbMessage;
    PPCT1_CLIENT_HELLO   pMessage;
    DWORD               Size;
    PUCHAR              pBuffer;
    DWORD               i, iBuff;

    SP_BEGIN("Pct1PackClientHello");

    if(pCanonical == NULL || pCommOutput == NULL)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    pCommOutput->cbData = 0;

    if(pCanonical->cbSessionID != PCT_SESSION_ID_SIZE ||
       pCanonical->cbChallenge != PCT_CHALLENGE_SIZE)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }


    pCommOutput->cbData = PCT_OFFSET_OF(PPCT1_CLIENT_HELLO, VariantData) +
                    pCanonical->cCipherSpecs * sizeof(ExtCipherSpec) +
                    pCanonical->cHashSpecs * sizeof(ExtHashSpec) +
                    pCanonical->cCertSpecs * sizeof(ExtCertSpec) +
                    pCanonical->cExchSpecs * sizeof(ExtExchSpec) +
                    pCanonical->cbKeyArgSize;


    cbMessage = pCommOutput->cbData - sizeof(PCT1_MESSAGE_HEADER);
    if (cbMessage > PCT_MAX_SHAKE_LEN)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_DATA_OVERFLOW));
    }
    /* are we allocating our own memory? */
    if(pCommOutput->pvBuffer == NULL)
    {
        pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
        if (NULL == pCommOutput->pvBuffer)
        {
            SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
        }

        pCommOutput->cbBuffer = pCommOutput->cbData;
    }

    if(pCommOutput->cbData > pCommOutput->cbBuffer)
    {
        // Required size returned in pCommOutput->cbData.
        SP_RETURN(PCT_INT_BUFF_TOO_SMALL);
    }

    pMessage = pCommOutput->pvBuffer;

    pMessage->MessageId = PCT1_MSG_CLIENT_HELLO;

    pMessage->VersionMsb = MSBOF(PCT_VERSION_1);
    pMessage->VersionLsb = LSBOF(PCT_VERSION_1);

    pMessage->OffsetMsb = MSBOF(PCT_CH_OFFSET_V1);
    pMessage->OffsetLsb = LSBOF(PCT_CH_OFFSET_V1);

    pMessage->KeyArgLenMsb = MSBOF(pCanonical->cbKeyArgSize);
    pMessage->KeyArgLenLsb = LSBOF(pCanonical->cbKeyArgSize);

    CopyMemory( pMessage->SessionIdData,
                pCanonical->SessionID,
                pCanonical->cbSessionID);

    CopyMemory( pMessage->ChallengeData,
                pCanonical->Challenge,
                pCanonical->cbChallenge);

    pBuffer = pMessage->VariantData;

    iBuff = 0;
    for (i = 0; i < pCanonical->cCipherSpecs ; i++ )
    {
        if (MapCipherToExternal(pCanonical->pCipherSpecs[i],
                                &((ExtCipherSpec UNALIGNED *) pBuffer)[iBuff]) )
        {
            iBuff++;
        }
    }
    Size = iBuff*sizeof(ExtCipherSpec);

    pMessage->CipherSpecsLenMsb = MSBOF(Size);
    pMessage->CipherSpecsLenLsb = LSBOF(Size);
    pBuffer += Size;

    cbMessage -= (pCanonical->cCipherSpecs - iBuff)*sizeof(ExtCipherSpec);


    iBuff = 0;
    for (i = 0; i < pCanonical->cHashSpecs ; i++ )
    {
        if (MapHashToExternal(pCanonical->pHashSpecs[i],
                              &((ExtHashSpec UNALIGNED *) pBuffer)[iBuff]) )
        {
            iBuff++;
        }
    }
    Size = iBuff*sizeof(ExtHashSpec);
    pBuffer += Size;

    pMessage->HashSpecsLenMsb = MSBOF(Size);
    pMessage->HashSpecsLenLsb = LSBOF(Size);
    cbMessage -= (pCanonical->cHashSpecs - iBuff)*sizeof(ExtHashSpec);


    iBuff = 0;
    for (i = 0; i < pCanonical->cCertSpecs ; i++ )
    {
        if (MapCertToExternal(pCanonical->pCertSpecs[i],
                                &((ExtCertSpec UNALIGNED *) pBuffer)[iBuff]))
        {
            iBuff ++;
        }
    }
    Size = iBuff*sizeof(ExtCertSpec);
    pBuffer += Size;

    pMessage->CertSpecsLenMsb = MSBOF(Size);
    pMessage->CertSpecsLenLsb = LSBOF(Size);
    cbMessage -= (pCanonical->cCertSpecs - iBuff)*sizeof(ExtCertSpec);


    iBuff = 0;
    for (i = 0; i < pCanonical->cExchSpecs ; i++ )
    {
        if (MapExchToExternal(pCanonical->pExchSpecs[i],
                                &((ExtExchSpec UNALIGNED *) pBuffer)[iBuff]) )
        {
            iBuff++;
        }
    }
    Size = iBuff*sizeof(ExtExchSpec);
    pBuffer += Size;


    pMessage->ExchSpecsLenMsb = MSBOF(Size);
    pMessage->ExchSpecsLenLsb = LSBOF(Size);
    cbMessage -= (pCanonical->cExchSpecs - iBuff)*sizeof(ExtExchSpec);

    if(pCanonical->pKeyArg)
    {
        CopyMemory(pBuffer, pCanonical->pKeyArg, pCanonical->cbKeyArgSize);
        pBuffer += pCanonical->cbKeyArgSize;
    }

    pCommOutput->cbData = cbMessage + 2;

    pMessage->Header.Byte0 = MSBOF(cbMessage) | 0x80;
    pMessage->Header.Byte1 = LSBOF(cbMessage);

    SP_RETURN(PCT_ERR_OK);
}

SP_STATUS
Pct1UnpackClientHello(
    PSPBuffer          pInput,
    PPct1_Client_Hello *     ppClient)
{

    PPCT1_CLIENT_HELLO   pMessage;

    DWORD               ReportedSize;
    DWORD               CipherSpecsSize, HashSpecsSize, CertSpecsSize;
    DWORD               ExchSpecsSize;
    DWORD               cCipherSpecs, cHashSpecs, cCertSpecs, cExchSpecs;
    DWORD               cOffsetBytes, KeyArgSize;
    PPct1_Client_Hello       pCanonical;
    PUCHAR              pBuffer;
    DWORD               i;

    SP_BEGIN("Pct1UnpackClientHello");

    if(pInput   == NULL ||
       ppClient == NULL ||
       pInput->pvBuffer == NULL)
    {
        SP_RETURN(PCT_INT_INTERNAL_ERROR);
    }

    pMessage = pInput->pvBuffer;

    if(pInput->cbData < 2)
    {
        pInput->cbData = 2;
        SP_RETURN(PCT_INT_INCOMPLETE_MSG);
    }

    ReportedSize = SIZEOF(pMessage);

    if ((ReportedSize+2) > pInput->cbData)
    {
        pInput->cbData = ReportedSize+2;
        SP_RETURN(PCT_INT_INCOMPLETE_MSG);
    }

    if(ReportedSize < PCT_OFFSET_OF(PPCT1_CLIENT_HELLO, VariantData))
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    if(ReportedSize > PCT_MAX_SHAKE_LEN)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    if ((pMessage->VersionMsb & 0x80) == 0)
    {
        SP_RETURN (PCT_ERR_SSL_STYLE_MSG);
    }

    /* We don't recognize hello messages of less version than ourselves,
     * those will be handled by a previous version of the code */
    if ((pMessage->MessageId != PCT1_MSG_CLIENT_HELLO) ||
        ((pMessage->VersionMsb << 8 | pMessage->VersionLsb)  < PCT_VERSION_1))
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    cOffsetBytes = COMBINEBYTES( pMessage->OffsetMsb,
                                  pMessage->OffsetLsb );

    if(cOffsetBytes < PCT_CH_OFFSET_V1)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    *ppClient = NULL;

    CipherSpecsSize = COMBINEBYTES( pMessage->CipherSpecsLenMsb,
                                    pMessage->CipherSpecsLenLsb );

    HashSpecsSize = COMBINEBYTES( pMessage->HashSpecsLenMsb,
                                  pMessage->HashSpecsLenLsb );

    CertSpecsSize = COMBINEBYTES( pMessage->CertSpecsLenMsb,
                                  pMessage->CertSpecsLenLsb );

    ExchSpecsSize = COMBINEBYTES( pMessage->ExchSpecsLenMsb,
                                  pMessage->ExchSpecsLenLsb );

    KeyArgSize = COMBINEBYTES( pMessage->KeyArgLenMsb,
                                          pMessage->KeyArgLenLsb );

    /* check that this all fits into the message */
    if (PCT_OFFSET_OF(PPCT1_CLIENT_HELLO, VariantData)
          - sizeof(PCT1_MESSAGE_HEADER)       /* don't count the header */
         + cOffsetBytes - PCT_CH_OFFSET_V1
         + CipherSpecsSize
         + HashSpecsSize
         + CertSpecsSize
         + ExchSpecsSize
         + KeyArgSize != ReportedSize)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    cCipherSpecs = CipherSpecsSize / sizeof(ExtCipherSpec);
    cHashSpecs = HashSpecsSize / sizeof(ExtHashSpec);
    cExchSpecs = ExchSpecsSize / sizeof(ExtExchSpec);
    cCertSpecs = CertSpecsSize / sizeof(ExtCertSpec);

    if(KeyArgSize > SP_MAX_KEY_ARGS)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }


    /* Allocate a buffer for the canonical client hello */
    pCanonical = (PPct1_Client_Hello)SPExternalAlloc(
                            sizeof(Pct1_Client_Hello) +
                            cCipherSpecs * sizeof(CipherSpec) +
                            cHashSpecs * sizeof(HashSpec) +
                            cCertSpecs * sizeof(CertSpec) +
                            cExchSpecs * sizeof(ExchSpec) +
                            KeyArgSize);

    if (!pCanonical)
    {
        SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
    }

    pCanonical->cbKeyArgSize = KeyArgSize;

    pCanonical->pCipherSpecs = (PCipherSpec) (pCanonical + 1);
    pCanonical->pHashSpecs = (PHashSpec) (pCanonical->pCipherSpecs +
                                          cCipherSpecs);
    pCanonical->pCertSpecs = (PCertSpec) (pCanonical->pHashSpecs +
                                          cHashSpecs);
    pCanonical->pExchSpecs = (PExchSpec) (pCanonical->pCertSpecs +
                                          cCertSpecs);

    pCanonical->pKeyArg = (PUCHAR)(pCanonical->pExchSpecs + cExchSpecs);

    CopyMemory( pCanonical->SessionID,
                pMessage->SessionIdData,
                PCT_SESSION_ID_SIZE);
    pCanonical->cbSessionID = PCT_SESSION_ID_SIZE;

    CopyMemory( pCanonical->Challenge,
                pMessage->ChallengeData,
                PCT_CHALLENGE_SIZE );
    pCanonical->cbChallenge = PCT_CHALLENGE_SIZE;


    pBuffer = &pMessage->OffsetLsb + 1 + cOffsetBytes;

    pCanonical->cCipherSpecs = cCipherSpecs;

    for (i = 0 ; i < cCipherSpecs ; i++ )
    {
        pCanonical->pCipherSpecs[i] = MapCipherFromExternal(*(ExtCipherSpec UNALIGNED *)
                                                    pBuffer);

        pBuffer += sizeof(ExtCipherSpec);
    }

    pCanonical->cHashSpecs = cHashSpecs;

    for (i = 0 ; i < cHashSpecs ; i++ )
    {
        pCanonical->pHashSpecs[i] = MapHashFromExternal(*(ExtHashSpec UNALIGNED *)
                                                    pBuffer);

        pBuffer += sizeof(ExtHashSpec);
    }

    pCanonical->cCertSpecs = cCertSpecs;

    for (i = 0 ; i < cCertSpecs ; i++ )
    {
        pCanonical->pCertSpecs[i] = MapCertFromExternal(*(ExtCertSpec UNALIGNED *)
                                                    pBuffer);

        pBuffer += sizeof(ExtCertSpec);
    }

    pCanonical->cExchSpecs = cExchSpecs;

    for (i = 0 ; i < cExchSpecs ; i++ )
    {
        pCanonical->pExchSpecs[i] = MapExchFromExternal(*(ExtExchSpec UNALIGNED *)
                                                    pBuffer);

        pBuffer += sizeof(ExtExchSpec);
    }


    CopyMemory(pCanonical->pKeyArg, pBuffer, KeyArgSize);

    *ppClient = pCanonical;
    pInput->cbData = ReportedSize + sizeof(PCT1_MESSAGE_HEADER);

    SP_RETURN(PCT_ERR_OK);
}

SP_STATUS
Pct1PackServerHello(
    PPct1_Server_Hello       pCanonical,
    PSPBuffer          pCommOutput)
{
    DWORD               cbMessage;
    PPCT1_SERVER_HELLO   pMessage;
    DWORD               Size;
    PUCHAR              pBuffer;
    DWORD               i, iBuff;


    SP_BEGIN("Pct1PackServerHello");

    if(pCanonical == NULL || pCommOutput == NULL)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    pCommOutput->cbData = 0;
    if(pCanonical->cbConnectionID != PCT_SESSION_ID_SIZE)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    cbMessage = pCanonical->CertificateLen +
                    pCanonical->cCertSpecs * sizeof(ExtCertSpec) +
                    pCanonical->cSigSpecs * sizeof(ExtSigSpec) +
                    pCanonical->ResponseLen +
                    PCT_OFFSET_OF(PPCT1_SERVER_HELLO, VariantData) -
                    sizeof(PCT1_MESSAGE_HEADER);

    if (cbMessage > PCT_MAX_SHAKE_LEN)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_DATA_OVERFLOW));
    }

    pCommOutput->cbData = cbMessage + 2;

    /* are we allocating our own memory? */
    if(pCommOutput->pvBuffer == NULL)
    {
        pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
        if (NULL == pCommOutput->pvBuffer)
        {
            SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
        }

        pCommOutput->cbBuffer = pCommOutput->cbData;
    }

    if(pCommOutput->cbData > pCommOutput->cbBuffer)
    {
        // Required size returned in pCommOutput->cbData.
        SP_RETURN(PCT_INT_BUFF_TOO_SMALL);
    }

    pMessage = pCommOutput->pvBuffer;


    pMessage->MessageId = PCT1_MSG_SERVER_HELLO;
    pMessage->ServerVersionMsb = MSBOF(PCT_VERSION_1);
    pMessage->ServerVersionLsb = LSBOF(PCT_VERSION_1);
    pMessage->RestartSessionOK = (UCHAR) pCanonical->RestartOk;
    pMessage->ClientAuthReq = (UCHAR)pCanonical->ClientAuthReq;

    MapCipherToExternal(pCanonical->SrvCipherSpec, &pMessage->CipherSpecData);
    MapHashToExternal(pCanonical->SrvHashSpec, &pMessage->HashSpecData);
    MapCertToExternal(pCanonical->SrvCertSpec, &pMessage->CertSpecData);
    MapExchToExternal(pCanonical->SrvExchSpec, &pMessage->ExchSpecData);

    CopyMemory(pMessage->ConnectionIdData, pCanonical->ConnectionID,
               pCanonical->cbConnectionID);

    pBuffer = pMessage->VariantData;


    /* Pack certificate if present */


    pMessage->CertificateLenMsb = MSBOF(pCanonical->CertificateLen);
    pMessage->CertificateLenLsb = LSBOF(pCanonical->CertificateLen);

    if (pCanonical->CertificateLen)
    {
        CopyMemory( pBuffer,
                    pCanonical->pCertificate,
                    pCanonical->CertificateLen);

        pBuffer += pCanonical->CertificateLen ;
    }

    iBuff = 0;
    for (i = 0; i < pCanonical->cCertSpecs ; i++ )
    {
        if (MapCertToExternal(pCanonical->pClientCertSpecs[i],
                                &((ExtCertSpec UNALIGNED *) pBuffer)[iBuff]))
        {
            iBuff ++;
        }
    }
    Size = iBuff*sizeof(ExtCertSpec);
    pBuffer += Size;

    pMessage->CertSpecsLenMsb = MSBOF(Size);
    pMessage->CertSpecsLenLsb = LSBOF(Size);
    cbMessage -= (pCanonical->cCertSpecs - iBuff)*sizeof(ExtCertSpec);

    iBuff = 0;
    for (i = 0; i < pCanonical->cSigSpecs ; i++ )
    {
        if (MapSigToExternal(pCanonical->pClientSigSpecs[i],
                              &((ExtSigSpec UNALIGNED *) pBuffer)[iBuff]) )
        {
            iBuff++;
        }
    }
    Size = iBuff*sizeof(ExtSigSpec);
    pBuffer += Size;

    pMessage->ClientSigSpecsLenMsb = MSBOF(Size);
    pMessage->ClientSigSpecsLenLsb = LSBOF(Size);
    cbMessage -= (pCanonical->cSigSpecs - iBuff)*sizeof(ExtSigSpec);

    pMessage->ResponseLenMsb = MSBOF(pCanonical->ResponseLen);
    pMessage->ResponseLenLsb = LSBOF(pCanonical->ResponseLen);

    CopyMemory( pBuffer,
                pCanonical->Response,
                pCanonical->ResponseLen);

    pBuffer += pCanonical->ResponseLen;

    pCommOutput->cbData = cbMessage + 2;

    pMessage->Header.Byte0 = MSBOF(cbMessage) | 0x80;
    pMessage->Header.Byte1 = LSBOF(cbMessage);


    SP_RETURN(PCT_ERR_OK);

}

SP_STATUS
Pct1UnpackServerHello(
    PSPBuffer          pInput,
    PPct1_Server_Hello *     ppServer)
{
    PPct1_Server_Hello       pCanonical;
    PPCT1_SERVER_HELLO   pMessage;
    PUCHAR              pBuffer;
    DWORD               cbCertificate, cbResponse;
    DWORD               cCertSpecs, cSigSpecs;
    DWORD               i;
    DWORD               ReportedSize;

    SP_BEGIN("Pct1UnpackServerHello");

    if(pInput   == NULL ||
       ppServer == NULL ||
       pInput->pvBuffer == NULL)
    {
        SP_RETURN(PCT_INT_INTERNAL_ERROR);
    }

    pMessage = pInput->pvBuffer;

    if(pInput->cbData < 2)
    {
        pInput->cbData = 2;
        SP_RETURN(PCT_INT_INCOMPLETE_MSG);
    }

    ReportedSize = SIZEOF(pMessage);
    if(ReportedSize > PCT_MAX_SHAKE_LEN)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    if ((ReportedSize+2) > pInput->cbData)
    {
        pInput->cbData = ReportedSize+2;
        SP_RETURN(PCT_INT_INCOMPLETE_MSG);
    }

    if(ReportedSize <  PCT_OFFSET_OF(PPCT1_SERVER_HELLO, VariantData) )
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    /* Verify Header: */

    /* we don't handle server hello messages of latter version than ourselves,
     * those will be handled by latter verisions of the protocol */
    if ((pMessage->MessageId != PCT1_MSG_SERVER_HELLO) ||
        ((pMessage->ServerVersionMsb << 8 | pMessage->ServerVersionLsb) != PCT_VERSION_1))
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    *ppServer = NULL;

    cbCertificate = COMBINEBYTES(pMessage->CertificateLenMsb,
                                 pMessage->CertificateLenLsb);

    cCertSpecs = COMBINEBYTES(pMessage->CertSpecsLenMsb,
                              pMessage->CertSpecsLenLsb);

    cCertSpecs /= sizeof(ExtCertSpec);


    cSigSpecs = COMBINEBYTES(pMessage->ClientSigSpecsLenMsb,
                             pMessage->ClientSigSpecsLenLsb);

    cSigSpecs /= sizeof(ExtSigSpec);

    cbResponse = COMBINEBYTES(pMessage->ResponseLenMsb,
                              pMessage->ResponseLenLsb);

    if(cbResponse > PCT1_RESPONSE_SIZE)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    /* check that this all fits into the message */
    if (PCT_OFFSET_OF(PPCT1_SERVER_HELLO, VariantData)
          - sizeof(PCT1_MESSAGE_HEADER)       /* don't count the header */
         + cbCertificate
         + cCertSpecs*sizeof(ExtCertSpec)
         + cSigSpecs*sizeof(ExtSigSpec)
         + cbResponse != ReportedSize)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    pCanonical = (PPct1_Server_Hello)SPExternalAlloc(
                            sizeof(Pct1_Server_Hello) +
                            cCertSpecs * sizeof(CertSpec) +
                            cSigSpecs * sizeof(SigSpec) +
                            cbCertificate);

    if (!pCanonical)
    {
        SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
    }


    /* Set up pointers to be in this memory allocation. */


    pCanonical->pClientCertSpecs = (PCertSpec) (pCanonical + 1);
    pCanonical->pClientSigSpecs = (PSigSpec)(pCanonical->pClientCertSpecs +
                                    cCertSpecs);

    pCanonical->pCertificate = (PUCHAR) (pCanonical->pClientSigSpecs +
                                    cSigSpecs);

    /* Expand out: */

    pCanonical->RestartOk = (DWORD) pMessage->RestartSessionOK;
    pCanonical->ClientAuthReq = (DWORD)pMessage->ClientAuthReq;
    pCanonical->SrvCertSpec = MapCertFromExternal(pMessage->CertSpecData);
    pCanonical->SrvCipherSpec =MapCipherFromExternal(pMessage->CipherSpecData);
    pCanonical->SrvHashSpec = MapHashFromExternal(pMessage->HashSpecData);
    pCanonical->SrvExchSpec = MapExchFromExternal(pMessage->ExchSpecData);
    pCanonical->CertificateLen = cbCertificate;
    pCanonical->ResponseLen = cbResponse;
    pCanonical->cCertSpecs = cCertSpecs;
    pCanonical->cSigSpecs = cSigSpecs;

    CopyMemory(pCanonical->ConnectionID,
               pMessage->ConnectionIdData,
               PCT_SESSION_ID_SIZE);

    pCanonical->cbConnectionID= PCT_SESSION_ID_SIZE;

    pBuffer = pMessage->VariantData;

    CopyMemory(pCanonical->pCertificate, pBuffer, cbCertificate);
    pBuffer += cbCertificate;

    for (i = 0 ; i < cCertSpecs ; i++ )
    {
        pCanonical->pClientCertSpecs[i] = MapCertFromExternal(
                                            *(ExtCertSpec UNALIGNED *)pBuffer);
        pBuffer += sizeof(ExtCertSpec);
    }

    for (i = 0 ; i < cSigSpecs ; i++ )
    {
        pCanonical->pClientSigSpecs[i] = MapSigFromExternal(
                                            *(ExtSigSpec UNALIGNED *)pBuffer);
        pBuffer += sizeof(ExtSigSpec);
    }

    CopyMemory(pCanonical->Response, pBuffer, cbResponse);


    *ppServer = pCanonical;
    pInput->cbData = ReportedSize + sizeof(PCT1_MESSAGE_HEADER);

    SP_RETURN(PCT_ERR_OK);

}

SP_STATUS
Pct1PackClientMasterKey(
    PPct1_Client_Master_Key      pCanonical,
    PSPBuffer                    pCommOutput)
{
    DWORD                   cbMessage;
    PPCT1_CLIENT_MASTER_KEY  pMessage;
    PUCHAR                  pBuffer;

    SP_BEGIN("Pct1PackClientMasterKey");

    if(pCanonical == NULL || pCommOutput == NULL)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    pCommOutput->cbData = 0;

    cbMessage = pCanonical->ClearKeyLen +
                    pCanonical->EncryptedKeyLen +
                    pCanonical->KeyArgLen +
                    pCanonical->VerifyPreludeLen +
                    pCanonical->ClientCertLen +
                    pCanonical->ResponseLen +
                    PCT_OFFSET_OF(PPCT1_CLIENT_MASTER_KEY, VariantData) -
                    sizeof(PCT1_MESSAGE_HEADER);

    if (cbMessage > PCT_MAX_SHAKE_LEN)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_DATA_OVERFLOW));
    }

    pCommOutput->cbData = cbMessage + 2;

        /* are we allocating our own memory? */
    if(pCommOutput->pvBuffer == NULL)
    {
        pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
        if (NULL == pCommOutput->pvBuffer)
        {
            SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
        }

        pCommOutput->cbBuffer = pCommOutput->cbData;
    }


    if(pCommOutput->cbData > pCommOutput->cbBuffer)
    {
        // Required size returned in pCommOutput->cbData.
        SP_RETURN(PCT_INT_BUFF_TOO_SMALL);
    }

    pMessage = pCommOutput->pvBuffer;




    pBuffer = pMessage->VariantData;

    pMessage->Header.Byte0 = MSBOF(cbMessage) | 0x80;
    pMessage->Header.Byte1 = LSBOF(cbMessage);

    pMessage->MessageId = PCT1_MSG_CLIENT_MASTER_KEY;

    pMessage->ClearKeyLenMsb = MSBOF(pCanonical->ClearKeyLen);
    pMessage->ClearKeyLenLsb = LSBOF(pCanonical->ClearKeyLen);

    MapSigToExternal(pCanonical->ClientSigSpec, &pMessage->ClientSigSpecData);
    MapCertToExternal(pCanonical->ClientCertSpec, &pMessage->ClientCertSpecData);

    CopyMemory(pBuffer, pCanonical->ClearKey, pCanonical->ClearKeyLen);

    pBuffer += pCanonical->ClearKeyLen;

    pMessage->EncryptedKeyLenMsb = MSBOF(pCanonical->EncryptedKeyLen);
    pMessage->EncryptedKeyLenLsb = LSBOF(pCanonical->EncryptedKeyLen);

    CopyMemory(pBuffer, pCanonical->pbEncryptedKey, pCanonical->EncryptedKeyLen);
    pBuffer += pCanonical->EncryptedKeyLen;

    pMessage->KeyArgLenMsb = MSBOF(pCanonical->KeyArgLen);
    pMessage->KeyArgLenLsb = LSBOF(pCanonical->KeyArgLen);

    CopyMemory(pBuffer, pCanonical->KeyArg, pCanonical->KeyArgLen);
    pBuffer += pCanonical->KeyArgLen;

    pMessage->VerifyPreludeLenMsb = MSBOF(pCanonical->VerifyPreludeLen);
    pMessage->VerifyPreludeLenLsb = LSBOF(pCanonical->VerifyPreludeLen);

    CopyMemory(pBuffer, pCanonical->VerifyPrelude,
               pCanonical->VerifyPreludeLen);
    pBuffer += pCanonical->VerifyPreludeLen;

    pMessage->ClientCertLenMsb = MSBOF(pCanonical->ClientCertLen);
    pMessage->ClientCertLenLsb = LSBOF(pCanonical->ClientCertLen);

    CopyMemory(pBuffer, pCanonical->pClientCert, pCanonical->ClientCertLen);
    pBuffer += pCanonical->ClientCertLen;

    pMessage->ResponseLenMsb = MSBOF(pCanonical->ResponseLen);
    pMessage->ResponseLenLsb = LSBOF(pCanonical->ResponseLen);

    CopyMemory(pBuffer, pCanonical->pbResponse, pCanonical->ResponseLen);


    SP_RETURN(PCT_ERR_OK);

}

SP_STATUS
Pct1UnpackClientMasterKey(
    PSPBuffer              pInput,
    PPct1_Client_Master_Key *    ppClient)
{
    PPct1_Client_Master_Key  pCanonical;

    PUCHAR              pBuffer;
    DWORD               ReportedSize;
    PPCT1_CLIENT_MASTER_KEY  pMessage;
    DWORD cbClearKey, cbEncryptedKey, cbKeyArg, cbVerifyPrelude, cbClientCert, cbResponse;

    SP_BEGIN("Pct1UnpackClientMasterKey");

    if(pInput   == NULL ||
       ppClient == NULL ||
       pInput->pvBuffer == NULL)
    {
        SP_RETURN(PCT_INT_INTERNAL_ERROR);
    }

    pMessage = pInput->pvBuffer;

    if(pInput->cbData < 2)
    {
        pInput->cbData = 2;
        SP_RETURN(PCT_INT_INCOMPLETE_MSG);
    }

    ReportedSize = SIZEOF(pMessage);
    if(ReportedSize > PCT_MAX_SHAKE_LEN)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    if ((ReportedSize+2) > pInput->cbData)
    {
        pInput->cbData = ReportedSize+2;
        SP_RETURN(PCT_INT_INCOMPLETE_MSG);
    }

    if(ReportedSize < PCT_OFFSET_OF(PPCT1_CLIENT_MASTER_KEY, VariantData))
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    /* Verify Header: */


    if (pMessage->MessageId != PCT1_MSG_CLIENT_MASTER_KEY )
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }
    cbClearKey = COMBINEBYTES( pMessage->ClearKeyLenMsb,
                                            pMessage->ClearKeyLenLsb );

    cbEncryptedKey = COMBINEBYTES( pMessage->EncryptedKeyLenMsb,
                                                pMessage->EncryptedKeyLenLsb );

    cbKeyArg = COMBINEBYTES( pMessage->KeyArgLenMsb,
                                          pMessage->KeyArgLenLsb );

    cbVerifyPrelude = COMBINEBYTES( pMessage->VerifyPreludeLenMsb,
                                            pMessage->VerifyPreludeLenLsb );

    cbClientCert = COMBINEBYTES( pMessage->ClientCertLenMsb,
                                              pMessage->ClientCertLenLsb );

    cbResponse = COMBINEBYTES( pMessage->ResponseLenMsb,
                                            pMessage->ResponseLenLsb );

    /* defensive checks..... */

    if ((cbClearKey > SP_MAX_MASTER_KEY) ||
        (cbKeyArg > PCT1_MAX_KEY_ARGS) ||
        (cbVerifyPrelude > RESPONSE_SIZE))
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }


    if ((PCT_OFFSET_OF(PPCT1_CLIENT_MASTER_KEY, VariantData) -
         sizeof(PCT1_MESSAGE_HEADER) +
         cbClearKey +
         cbEncryptedKey +
         cbKeyArg +
         cbVerifyPrelude +
         cbClientCert +
         cbResponse) !=
         ReportedSize)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }


    *ppClient = NULL;


    pCanonical = (PPct1_Client_Master_Key)SPExternalAlloc(
                            sizeof(Pct1_Client_Master_Key) + 
                            cbClientCert +
                            cbEncryptedKey +
                            cbResponse);

    if (!pCanonical)
    {
        SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));

    }

    pCanonical->ClearKeyLen = cbClearKey;

    pCanonical->EncryptedKeyLen = cbEncryptedKey;

    pCanonical->KeyArgLen = cbKeyArg;

    pCanonical->VerifyPreludeLen = cbVerifyPrelude;
    pCanonical->ClientCertLen = cbClientCert;

    pCanonical->ResponseLen = cbResponse;
    /* defensive checks..... */


    pCanonical->ClientCertSpec = MapCertFromExternal(pMessage->ClientCertSpecData);

    pCanonical->pClientCert = (PUCHAR)(pCanonical+1);

    pCanonical->ClientSigSpec = MapSigFromExternal(pMessage->ClientSigSpecData);
    /* ok, we're pretty sure we aren't going to fault. */

    pBuffer = pMessage->VariantData;

    CopyMemory(pCanonical->ClearKey, pBuffer, pCanonical->ClearKeyLen );

    pBuffer += pCanonical->ClearKeyLen;

    pCanonical->pbEncryptedKey = pCanonical->pClientCert + cbClientCert;
    CopyMemory(pCanonical->pbEncryptedKey, pBuffer, pCanonical->EncryptedKeyLen);

    pBuffer += pCanonical->EncryptedKeyLen;

    CopyMemory( pCanonical->KeyArg, pBuffer, pCanonical->KeyArgLen );

    pBuffer += pCanonical->KeyArgLen;

    CopyMemory( pCanonical->VerifyPrelude, pBuffer,
                pCanonical->VerifyPreludeLen );

    pBuffer += pCanonical->VerifyPreludeLen;

    CopyMemory( pCanonical->pClientCert, pBuffer, pCanonical->ClientCertLen );

    pBuffer += pCanonical->ClientCertLen;

    pCanonical->pbResponse = pCanonical->pbEncryptedKey + cbEncryptedKey;
    CopyMemory( pCanonical->pbResponse, pBuffer, pCanonical->ResponseLen );

    *ppClient = pCanonical;
    pInput->cbData = ReportedSize + sizeof(PCT1_MESSAGE_HEADER);
    SP_RETURN( PCT_ERR_OK );
}


SP_STATUS
Pct1PackServerVerify(
    PPct1_Server_Verify          pCanonical,
    PSPBuffer              pCommOutput)
{
    DWORD               cbMessage;
    PPCT1_SERVER_VERIFY  pMessage;
    PUCHAR              pBuffer;


    SP_BEGIN("Pct1PackServerVerify");

    if(pCanonical == NULL || pCommOutput == NULL)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    pCommOutput->cbData = 0;

    cbMessage    = pCanonical->ResponseLen +
                    PCT_OFFSET_OF(PPCT1_SERVER_VERIFY, VariantData) -
                    sizeof(PCT1_MESSAGE_HEADER);

    if (cbMessage > PCT_MAX_SHAKE_LEN)
    {
        SP_RETURN(PCT_INT_DATA_OVERFLOW);
    }

    pCommOutput->cbData = cbMessage + 2;

    /* are we allocating our own memory? */
    if(pCommOutput->pvBuffer == NULL)
    {
        pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
        if (NULL == pCommOutput->pvBuffer)
        {
            SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
        }
        pCommOutput->cbBuffer = pCommOutput->cbData;
    }


    if(pCommOutput->cbData > pCommOutput->cbBuffer)
    {
        // Required size returned in pCommOutput->cbData.
        SP_RETURN(PCT_INT_BUFF_TOO_SMALL);
    }

    pMessage = pCommOutput->pvBuffer;

    pMessage->MessageId = PCT1_MSG_SERVER_VERIFY;

    pMessage->Header.Byte0 = MSBOF(cbMessage) | 0x80;
    pMessage->Header.Byte1 = LSBOF(cbMessage);

    CopyMemory(pMessage->SessionIdData, pCanonical->SessionIdData,
               PCT_SESSION_ID_SIZE);

    pBuffer = pMessage->VariantData;


    /* Pack certificate if present */


    pMessage->ResponseLenMsb = MSBOF(pCanonical->ResponseLen);
    pMessage->ResponseLenLsb = LSBOF(pCanonical->ResponseLen);

    if (pCanonical->ResponseLen)
    {
        CopyMemory( pBuffer,
                    pCanonical->Response,
                    pCanonical->ResponseLen);
    }

    SP_RETURN( PCT_ERR_OK );

}

SP_STATUS
Pct1UnpackServerVerify(
    PSPBuffer              pInput,
    PPct1_Server_Verify *        ppServer)
{
    PPct1_Server_Verify      pCanonical;
    PPCT1_SERVER_VERIFY  pMessage;
    PUCHAR              pBuffer;
    DWORD               cbResponse;
    DWORD               ReportedSize;

    SP_BEGIN("Pct1UnpackServerVerify");

    if(pInput   == NULL ||
       ppServer == NULL ||
       pInput->pvBuffer == NULL)
    {
        SP_RETURN(PCT_INT_INTERNAL_ERROR);
    }

    pMessage = pInput->pvBuffer;

    if(pInput->cbData < 2)
    {
        pInput->cbData = 2;
        SP_RETURN(PCT_INT_INCOMPLETE_MSG);
    }

    ReportedSize = SIZEOF(pMessage);
    if(ReportedSize > PCT_MAX_SHAKE_LEN)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    if ((ReportedSize+2) > pInput->cbData)
    {
        pInput->cbData = ReportedSize+2;
        SP_RETURN(PCT_INT_INCOMPLETE_MSG);
    }

    if(ReportedSize < PCT_OFFSET_OF(PPCT1_SERVER_VERIFY, VariantData))
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    /* Verify Header: */


    if (pMessage->MessageId != PCT1_MSG_SERVER_VERIFY )
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }


    *ppServer = NULL;

    /* Verify Header: */


    cbResponse = COMBINEBYTES(pMessage->ResponseLenMsb,
                              pMessage->ResponseLenLsb);

    if (cbResponse > PCT_SESSION_ID_SIZE)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    if ((PCT_OFFSET_OF(PPCT1_SERVER_VERIFY, VariantData) -
         sizeof(PCT1_MESSAGE_HEADER) +
         cbResponse ) !=
         ReportedSize)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    pCanonical = (PPct1_Server_Verify)SPExternalAlloc( sizeof(Pct1_Server_Verify));

    if (!pCanonical)
    {
        SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
    }


    /* Expand out: */


    pCanonical->ResponseLen = cbResponse;

    CopyMemory((PUCHAR)pCanonical->SessionIdData, pMessage->SessionIdData,
               PCT_SESSION_ID_SIZE);

    pBuffer = pMessage->VariantData;

    CopyMemory(pCanonical->Response, pBuffer, cbResponse);

    *ppServer = pCanonical;
    pInput->cbData = ReportedSize + sizeof(PCT1_MESSAGE_HEADER);
    SP_RETURN(PCT_ERR_OK);
}


SP_STATUS
Pct1PackError(
    PPct1_Error            pCanonical,
    PSPBuffer              pCommOutput)
{
    DWORD               cbMessage;
    PPCT1_ERROR          pMessage;


    SP_BEGIN("Pct1PackError");

    if(pCanonical == NULL || pCommOutput == NULL)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }
    pCommOutput->cbData = 0;

    cbMessage = pCanonical->ErrInfoLen +
                    PCT_OFFSET_OF(PPCT1_ERROR, VariantData) -
                    sizeof(PCT1_MESSAGE_HEADER);

    if (cbMessage > PCT_MAX_SHAKE_LEN)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_DATA_OVERFLOW));
    }

    pCommOutput->cbData = cbMessage+2;

    /* are we allocating our own memory? */
    if(pCommOutput->pvBuffer == NULL)
    {
        pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
        if (NULL == pCommOutput->pvBuffer)
        {
            SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
        }
        pCommOutput->cbBuffer = pCommOutput->cbData;
    }


    if(pCommOutput->cbData > pCommOutput->cbBuffer)
    {
        // Required size returned in pCommOutput->cbData.
        SP_RETURN(PCT_INT_BUFF_TOO_SMALL);
    }

    pMessage = pCommOutput->pvBuffer;

    pMessage->Header.Byte0 = MSBOF(cbMessage) | 0x80;
    pMessage->Header.Byte1 = LSBOF(cbMessage);

    pMessage->MessageId = PCT1_MSG_ERROR;

    pMessage->ErrorMsb = MSBOF(pCanonical->Error);
    pMessage->ErrorLsb = LSBOF(pCanonical->Error);

    pMessage->ErrorInfoMsb = MSBOF(pCanonical->ErrInfoLen);
    pMessage->ErrorInfoLsb = LSBOF(pCanonical->ErrInfoLen);

    if(pCanonical->ErrInfoLen) {
        CopyMemory(pMessage->VariantData, pCanonical->ErrInfo, pCanonical->ErrInfoLen);
    }

    SP_RETURN( PCT_ERR_OK );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\spbase\pct1cli.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       pct1cli.c
//
//  Contents:   
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   LSA integration stuff.
//
//----------------------------------------------------------------------------

#include <spbase.h>
#include <pct1msg.h>
#include <pct1prot.h>


VOID
Pct1ActivateSessionKeys(PSPContext pContext)
{
    if(pContext->hReadKey)
    {
        if(!SchCryptDestroyKey(pContext->hReadKey, 
                               pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
        }
    }
    pContext->hReadKey = pContext->hPendingReadKey;

    if(pContext->hReadMAC)
    {
        if(!SchCryptDestroyKey(pContext->hReadMAC, 
                               pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
        }
    }
    pContext->hReadMAC = pContext->hPendingReadMAC;

    if(pContext->hWriteKey)
    {
        if(!SchCryptDestroyKey(pContext->hWriteKey, 
                               pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
        }
    }
    pContext->hWriteKey = pContext->hPendingWriteKey;

    if(pContext->hWriteMAC)
    {
        if(!SchCryptDestroyKey(pContext->hWriteMAC, 
                               pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
        }
    }
    pContext->hWriteMAC = pContext->hPendingWriteMAC;

    pContext->hPendingReadKey   = 0;
    pContext->hPendingReadMAC   = 0;
    pContext->hPendingWriteKey  = 0;
    pContext->hPendingWriteMAC  = 0;
}

SP_STATUS WINAPI 
Pct1ClientProtocolHandler(PSPContext pContext,
    PSPBuffer  pCommInput,
    PSPBuffer  pCommOutput)
{
    SP_STATUS      pctRet= PCT_ERR_OK;
    DWORD           dwStateTransition;

    SP_BEGIN("Pct1ClientProtocolHandler");

    if(pCommOutput) pCommOutput->cbData = 0;

    /* Protocol handling steps should be listed in most common
     * to least common in order to improve performance 
     */

    /* We are not connected, so we're doing
     * protocol negotiation of some sort.  All protocol
     * negotiation messages are sent in the clear */
    /* There are no branches in the connecting protocol
     * state transition diagram, besides connection and error,
     * which means that a simple case statement will do */

    /* Do we have enough data to determine what kind of message we have */
    /* Do we have enough data to determine what kind of message we have, or how much data we need*/

    dwStateTransition = (pContext->State & 0xffff);

    if(pCommInput->cbData < 3) 
    {
        if(!(dwStateTransition == PCT1_STATE_RENEGOTIATE ||
             dwStateTransition == SP_STATE_SHUTDOWN      ||
             dwStateTransition == SP_STATE_SHUTDOWN_PENDING))
        {
            pctRet = PCT_INT_INCOMPLETE_MSG;
        }
    }
    else
    {

        dwStateTransition = (((PUCHAR)pCommInput->pvBuffer)[2]<<16) |
                          (pContext->State & 0xffff);
    }

    if(pctRet == PCT_ERR_OK)
    {
        switch(dwStateTransition)
        {
            case SP_STATE_SHUTDOWN_PENDING:
                // There's no CloseNotify in PCT, so just transition to
                // the shutdown state and leave the output buffer empty.
                pContext->State = SP_STATE_SHUTDOWN;
                break;    

            case SP_STATE_SHUTDOWN:
                return PCT_INT_EXPIRED;
    
            case PCT1_STATE_RENEGOTIATE:
            {
                SPBuffer    In;
                SPBuffer    Out;
                DWORD       cbMessage;
                BOOL        fAllocated = FALSE;

                cbMessage    =  pContext->pHashInfo->cbCheckSum +
                                pContext->pCipherInfo->dwBlockSize +
                                sizeof(PCT1_MESSAGE_HEADER_EX) +
                                PCT1_MAX_CLIENT_HELLO;

 
                /* are we allocating our own memory? */
                if(pCommOutput->pvBuffer == NULL) 
                {
                    pCommOutput->pvBuffer = SPExternalAlloc(cbMessage);
                    if (NULL == pCommOutput->pvBuffer)
                    {
                        SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
                    }
                    fAllocated = TRUE;
                    pCommOutput->cbBuffer = cbMessage;
                }


                if(cbMessage > pCommOutput->cbBuffer)
                {
                    if(fAllocated)
                    {
                        SPExternalFree(pCommOutput->pvBuffer);
                        pCommOutput->pvBuffer = NULL;
                        SP_RETURN(PCT_INT_INTERNAL_ERROR);
                    }
                    pCommOutput->cbData = cbMessage;
                    SP_RETURN(PCT_INT_BUFF_TOO_SMALL);
                }

                In.pvBuffer = ((char *)pCommOutput->pvBuffer)+3;
                In.cbBuffer = pCommOutput->cbBuffer-3;
                In.cbData = 1;
                
                ((char *)In.pvBuffer)[0] = PCT1_ET_REDO_CONN;

                // Build a Redo Request
                pctRet = Pct1EncryptRaw(pContext, &In, pCommOutput, PCT1_ENCRYPT_ESCAPE);
                if(pctRet != PCT_ERR_OK)
                {
                    if(fAllocated)
                    {
                        SPExternalFree(pCommOutput->pvBuffer);
                        pCommOutput->pvBuffer = NULL;
                    }
                    break;
                }
                Out.pvBuffer = (char *)pCommOutput->pvBuffer + pCommOutput->cbData;
                Out.cbBuffer = pCommOutput->cbBuffer - pCommOutput->cbData;

                // Mark context as "unmapped" so that the new keys will get
                // passed to the application process once the handshake is
                // completed.
                pContext->Flags &= ~CONTEXT_FLAG_MAPPED;

                if(!SPCacheClone(&pContext->RipeZombie))
                {
                    if(fAllocated)
                    {
                        SPExternalFree(pCommOutput->pvBuffer);
                        pCommOutput->pvBuffer = NULL;
                    }
                    SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
                }

                pctRet = GeneratePct1StyleHello(pContext, &Out);
                pCommOutput->cbData += Out.cbData;
                break;
            }

            /* Client receives Server hello */
            case (PCT1_MSG_SERVER_HELLO << 16) | UNI_STATE_CLIENT_HELLO:
            case (PCT1_MSG_SERVER_HELLO << 16) | PCT1_STATE_CLIENT_HELLO:
            {
                PPct1_Server_Hello pHello;
                /* Attempt to recognize and handle various versions
                 * of Server hello, start by trying to unpickle the
                 * oldest, and the next version, until
                 * one unpickles.  Then run the handle code.  We can also put
                 * unpickling and handling code in here for SSL messages */
                if(PCT_ERR_OK == (pctRet = Pct1UnpackServerHello(
                                                    pCommInput,
                                                    &pHello))) 
                {
                    /* let's resurrect the zombie session */
                    if (pHello->RestartOk) 
                    {
                        pctRet = Pct1CliRestart(pContext, pHello, pCommOutput);
                        if(PCT_ERR_OK == pctRet) 
                        {
                            pContext->State = SP_STATE_CONNECTED;
                            pContext->DecryptHandler = Pct1DecryptHandler;
                            pContext->Encrypt = Pct1EncryptMessage;
                            pContext->Decrypt = Pct1DecryptMessage;
                            pContext->GetHeaderSize = Pct1GetHeaderSize;

                        } 
                    } 
                    else 
                    {   
                        pContext->RipeZombie->fProtocol = SP_PROT_PCT1_CLIENT;

                        if(pContext->RipeZombie->hMasterKey != 0)
                        {
                            // We've attempted to do a reconnect and the server has
                            // blown us off. In this case we must use a new and different
                            // cache entry.
                            pContext->RipeZombie->ZombieJuju = FALSE;
                            if(!SPCacheClone(&pContext->RipeZombie))
                            {
                                pctRet = SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
                            }
                        }

                        if(pctRet == PCT_ERR_OK)
                        {
                            pctRet = Pct1CliHandleServerHello(pContext,
                                                            pCommInput,
                                                            pHello,
                                                            pCommOutput);
                        }
                        if(PCT_ERR_OK == pctRet) 
                        {
                            pContext->State = PCT1_STATE_CLIENT_MASTER_KEY;
                            pContext->DecryptHandler = Pct1DecryptHandler;
                            pContext->Encrypt = Pct1EncryptMessage;     /* ?DCB? */
                            pContext->Decrypt = Pct1DecryptMessage;     /* ?DCB? */
                            pContext->GetHeaderSize = Pct1GetHeaderSize;

                        } 

                    }
                    SPExternalFree(pHello);

                }
                else if(pctRet != PCT_INT_INCOMPLETE_MSG)
                {
                    pctRet |= PCT_INT_DROP_CONNECTION;
                }

                if(SP_FATAL(pctRet)) 
                {
                    pContext->State = PCT1_STATE_ERROR;
                }

                break;
            }

            case (PCT1_MSG_SERVER_VERIFY << 16) | PCT1_STATE_CLIENT_MASTER_KEY:
                pctRet = Pct1CliHandleServerVerify(pContext,
                                                    pCommInput,
                                                    pCommOutput);
                if(SP_FATAL(pctRet)) 
                {
                    pContext->State = PCT1_STATE_ERROR;
                } 
                else 
                {
                    if(PCT_ERR_OK == pctRet) 
                    {
                        pContext->State = SP_STATE_CONNECTED;
                        pContext->DecryptHandler = Pct1DecryptHandler;
                        pContext->Encrypt = Pct1EncryptMessage;
                        pContext->Decrypt = Pct1DecryptMessage;
                        pContext->GetHeaderSize = Pct1GetHeaderSize;

                    } 
                    /* We received a non-fatal error, so the state doesn't
                     * change, giving the app time to deal with this */
                }
                break;

            default:
                pContext->State = PCT1_STATE_ERROR;
                {
                    pctRet = PCT_INT_ILLEGAL_MSG;
                    if(((PUCHAR)pCommInput->pvBuffer)[2] == PCT1_MSG_ERROR) 
                    {
                        /* we received an error message, process it */
                        pctRet = Pct1HandleError(pContext,
                                                 pCommInput,
                                                 pCommOutput);

                    } 
                    else 
                    {
                        /* we received an unknown error, generate a 
                         * PCT_ERR_ILLEGAL_MESSAGE */
                        pctRet = Pct1GenerateError(pContext, 
                                                    pCommOutput, 
                                                    PCT_ERR_ILLEGAL_MESSAGE, 
                                                    NULL);
                    }
                }

        }
    }
    if(pctRet & PCT_INT_DROP_CONNECTION) 
    {
        pContext->State &= ~SP_STATE_CONNECTED;
    }
    SP_RETURN(pctRet);
}



//+---------------------------------------------------------------------------
//
//  Function:   Pct1CheckForExistingCred
//
//  Synopsis:   Choose client certificate. Use one of the certificates
//              attached to the credential handle if possible. If the 
//              credential handle is anonymous, then attempt to create
//              a default credential.
//
//  Notes:      This routine is called by the client-side only.
//              
//  Returns:    PCT_ERR_OK      
//                  The function completed successfully. The
//                  pContext->pActiveClientCred field has been updated to
//                  point at a suitable client credential.
//
//              SEC_E_INCOMPLETE_CREDENTIALS
//                  No suitable certificate has been found. Notify the
//                  application.
//
//              SEC_I_INCOMPLETE_CREDENTIALS
//                  No suitable certificate has been found. Attempt an
//                  anonymous connection. 
//
//              <other>
//                  Fatal error.
//
//----------------------------------------------------------------------------
SP_STATUS
Pct1CheckForExistingCred(
    PSPContext pContext)
{
    SP_STATUS pctRet;

    //
    // Examine the certificates attached to the credential group and see
    // if any of them are suitable.
    //

    if(pContext->pCredGroup->pCredList)
    {
        pctRet = SPPickClientCertificate(pContext, SP_EXCH_RSA_PKCS1);

        if(pctRet == PCT_ERR_OK)
        {
            // We found one.
            DebugLog((DEB_TRACE, "Application provided suitable client certificate.\n"));

            return PCT_ERR_OK;
        }

        // The credential group contained one or more certificates,
        // but none were suitable. Don't even try to find a default
        // certificate in this situation.
        goto error;
    }


    //
    // Attempt to acquire a default credential.
    //

    if(pContext->pCredGroup->dwFlags & CRED_FLAG_NO_DEFAULT_CREDS)
    {
        // Look in credential manager only.
        pctRet = AcquireDefaultClientCredential(pContext, TRUE);
    }
    else
    {
        // Look in both credential manager and MY certificate store.
        pctRet = AcquireDefaultClientCredential(pContext, FALSE);
    }

    if(pctRet == PCT_ERR_OK)
    {
        DebugLog((DEB_TRACE, "Default client certificate acquired.\n"));

        return PCT_ERR_OK;
    }


error:

    if(pContext->Flags & CONTEXT_FLAG_NO_INCOMPLETE_CRED_MSG)
    {
        return SP_LOG_RESULT(SEC_I_INCOMPLETE_CREDENTIALS);
    }
    else
    {
        return SP_LOG_RESULT(SEC_E_INCOMPLETE_CREDENTIALS);
    }
}


SP_STATUS Pct1CliHandleServerHello(PSPContext pContext,
                                   PSPBuffer  pCommInput,
                                   PPct1_Server_Hello pHello,
                                   PSPBuffer  pCommOutput)
{
    /* error to return to peer */
    SP_STATUS          pctRet=PCT_ERR_ILLEGAL_MESSAGE;

    PSessCacheItem     pZombie;
    PPct1_Client_Master_Key   pCMKey = NULL;
    SPBuffer           ErrData;

    DWORD               i, j;
    DWORD               fMismatch = 0;
    DWORD               cbClientCert = 0;   
    PBYTE               pbClientCert = NULL;
    BYTE                MisData[PCT_NUM_MISMATCHES];
    CertTypeMap LocalCertEncodingPref[5] ;
    DWORD cLocalCertEncodingPref = 0;

    BOOL                fClientAuth;
    PSigInfo            pSigInfo = NULL;

    DWORD               ClientCertSpec = 0;

    SP_BEGIN("Pct1CliHandleServerHello");

    pCommOutput->cbData = 0;

    /* validate the buffer configuration */
    ErrData.cbData = 0;
    ErrData.pvBuffer = NULL;
    ErrData.cbBuffer = 0;

    pZombie = pContext->RipeZombie;

#if DBG
    DebugLog((DEB_TRACE, "Hello = %x\n", pHello));
    DebugLog((DEB_TRACE, "   Restart\t%s\n", pHello->RestartOk ? "Yes":"No"));
    DebugLog((DEB_TRACE, "   ClientAuth\t%s\n",
              pHello->ClientAuthReq ? "Yes":"No"));
    DebugLog((DEB_TRACE, "   Certificate Type\t%x\n", pHello->SrvCertSpec));
    DebugLog((DEB_TRACE, "   Hash Type\t%x\n", pHello->SrvHashSpec));
    DebugLog((DEB_TRACE, "   Cipher Type\t%x (%s)\n", pHello->SrvCipherSpec,
    DbgGetNameOfCrypto(pHello->SrvCipherSpec)));
    DebugLog((DEB_TRACE, "   Certificate Len\t%ld\n", pHello->CertificateLen));
#endif


    CopyMemory(pContext->pConnectionID,
               pHello->ConnectionID,
               pHello->cbConnectionID);

    pContext->cbConnectionID = pHello->cbConnectionID;

    fClientAuth = pHello->ClientAuthReq;


    if(fClientAuth)
    {
        // If we're doing client auth, check to see if we have
        // proper credentials.

        /* Build a list of cert specs */
        for(i=0; i < cPct1CertEncodingPref; i++)
        {
            for(j=0; j< pHello->cCertSpecs; j++)
            {
                // Does the client want this cipher type
                if(aPct1CertEncodingPref[i].Spec == pHello->pClientCertSpecs[j])
                {
                    LocalCertEncodingPref[cLocalCertEncodingPref].Spec = aPct1CertEncodingPref[i].Spec;
                    LocalCertEncodingPref[cLocalCertEncodingPref++].dwCertEncodingType = aPct1CertEncodingPref[i].dwCertEncodingType;
                    break;
                }
            }
        }

        // Decide on a signature algorithm.
        for(i = 0; i < cPct1LocalSigKeyPref; i++)
        {
            for(j = 0; j < pHello->cSigSpecs; j++)
            {
                if(pHello->pClientSigSpecs[j] != aPct1LocalSigKeyPref[i].Spec)
                {
                    continue;
                }

                pSigInfo = GetSigInfo(pHello->pClientSigSpecs[j]);
                if(pSigInfo == NULL) continue;
                if((pSigInfo->fProtocol & SP_PROT_PCT1_CLIENT) == 0)
                {
                    continue;
                }
                break;
            }
            if(pSigInfo)
            {
                break;
            }
        }

        // Our PCT implementation only supports RSA client authentication.
        pContext->Ssl3ClientCertTypes[0] = SSL3_CERTTYPE_RSA_SIGN;
        pContext->cSsl3ClientCertTypes = 1;


        pctRet = Pct1CheckForExistingCred(pContext);

        if(pctRet == SEC_E_INCOMPLETE_CREDENTIALS)
        {
            // It's okay to return here as we haven't done anything 
            // yet.  We just need to return this error as a warning.
            SP_RETURN(SEC_I_INCOMPLETE_CREDENTIALS);
        }
        else if(pctRet != PCT_ERR_OK)
        {
            // Attempt to carry on without a certificate, and hope 
            // the server doesn't shut us down.
            fClientAuth = FALSE;
            pSigInfo = NULL;
            LogNoClientCertFoundEvent();
        }
        else
        {
            // We are doing client auth with a certificate. 
            // Check to see if we're doing CHAIN based certificates
            // by finding the first shared encoding type that matches
            // our certificate type. 

            for(i=0; i < cLocalCertEncodingPref; i++)
            {
           
                if(LocalCertEncodingPref[i].dwCertEncodingType == pContext->pActiveClientCred->pCert->dwCertEncodingType)
                {
                    ClientCertSpec = LocalCertEncodingPref[i].Spec;
                    if(LocalCertEncodingPref[i].Spec == PCT1_CERT_X509_CHAIN)
                    {
                        pContext->fCertChainsAllowed = TRUE;
                    }
                    break;
                }
            }

            // Get the client certificate chain.
            pctRet = SPSerializeCertificate(SP_PROT_PCT1, 
                                            pContext->fCertChainsAllowed,
                                            &pbClientCert, 
                                            &cbClientCert, 
                                            pContext->pActiveClientCred->pCert,
                                            CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL);
            if(pctRet != PCT_ERR_OK)
            {
                SP_RETURN(pctRet);
            }
        }
    }


    for(i=0; i < Pct1NumCipher; i++)
    {
        if(Pct1CipherRank[i].Spec == pHello->SrvCipherSpec)
        {
            // Store this cipher identifier in the cache
            pZombie->aiCipher   = Pct1CipherRank[i].aiCipher;
            pZombie->dwStrength = Pct1CipherRank[i].dwStrength;

            // Load the pending cipher structure.
            pContext->pPendingCipherInfo = GetCipherInfo(pZombie->aiCipher,
                                                         pZombie->dwStrength);

            if(!IsCipherAllowed(pContext, 
                                pContext->pPendingCipherInfo, 
                                pZombie->fProtocol,
                                pZombie->dwCF))
            {
                pContext->pPendingCipherInfo = NULL;
                continue;
            }
            break;

        }
    }

    for(i=0; i < Pct1NumHash; i++)
    {
        if(Pct1HashRank[i].Spec == pHello->SrvHashSpec)
        {
            // Store this hash id in the cache
            pZombie->aiHash = Pct1HashRank[i].aiHash;

            // Load the pending hash sturcture
            pContext->pPendingHashInfo = GetHashInfo(pZombie->aiHash);
            if(!IsHashAllowed(pContext, 
                              pContext->pPendingHashInfo,
                              pZombie->fProtocol))
            {
                pContext->pPendingHashInfo = NULL;
                continue;
            }
            break;

        }
    }
 
    for(i=0; i < cPct1LocalExchKeyPref; i++)
    {
        if(aPct1LocalExchKeyPref[i].Spec == pHello->SrvExchSpec)
        {
            // Store the exch id in the cache.
            pZombie->SessExchSpec = aPct1LocalExchKeyPref[i].Spec;

            // load the exch info structure
            pContext->pKeyExchInfo = GetKeyExchangeInfo(pZombie->SessExchSpec);

            if(!IsExchAllowed(pContext, 
                              pContext->pKeyExchInfo,
                              pZombie->fProtocol))
            {
                pContext->pKeyExchInfo = NULL;
                continue;
            }
            break;

        }
    }


    if (pContext->pPendingCipherInfo == NULL)
    {
        fMismatch |= PCT_IMIS_CIPHER;
        pctRet = SP_LOG_RESULT(PCT_ERR_SPECS_MISMATCH);
        goto cleanup;
    }

    if (pContext->pPendingHashInfo == NULL)
    {
        fMismatch |= PCT_IMIS_HASH;
        pctRet = SP_LOG_RESULT(PCT_ERR_SPECS_MISMATCH);
        goto cleanup;
    }

    if (pContext->pKeyExchInfo == NULL)
    {
        fMismatch |= PCT_IMIS_EXCH;
        pctRet = SP_LOG_RESULT(PCT_ERR_SPECS_MISMATCH);
        goto cleanup;
    }
       

    // Determine the CSP to use, based on the key exchange algorithm.
    if(pContext->pKeyExchInfo->Spec != SP_EXCH_RSA_PKCS1)
    {
        pctRet = SP_LOG_RESULT(PCT_ERR_SPECS_MISMATCH);
        goto cleanup;
    }
    pContext->RipeZombie->hMasterProv = g_hRsaSchannel;

        
    // Go ahead and move the pending ciphers to active, and init them.
    pctRet = ContextInitCiphers(pContext, TRUE, TRUE);

    if(PCT_ERR_OK != pctRet)
    {
        goto cleanup;
    }


    /* we aren't restarting, so let's continue with the protocol. */

    /* Crack the server certificate */
    pctRet = SPLoadCertificate(pZombie->fProtocol, 
                             X509_ASN_ENCODING, 
                             pHello->pCertificate, 
                             pHello->CertificateLen,
                             &pZombie->pRemoteCert);
    if(pctRet != PCT_ERR_OK)
    {
        goto cleanup;
    }

    if(pContext->RipeZombie->pRemotePublic != NULL)
    {
        SPExternalFree(pContext->RipeZombie->pRemotePublic);
        pContext->RipeZombie->pRemotePublic = NULL;
    }

    pctRet = SPPublicKeyFromCert(pZombie->pRemoteCert,
                                 &pZombie->pRemotePublic,
                                 NULL);

    if(pctRet != PCT_ERR_OK)
    {
        goto cleanup;
    }


    // Automatically validate server certificate if appropriate 
    // context flag is set.
    pctRet = AutoVerifyServerCertificate(pContext);
    if(pctRet != PCT_ERR_OK)
    {
        SP_LOG_RESULT(pctRet);
        goto cleanup;
    }


    pZombie->pbServerCertificate = SPExternalAlloc(pHello->CertificateLen);
    pZombie->cbServerCertificate = pHello->CertificateLen;
    if(pZombie->pbServerCertificate == NULL)
    {
        pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto cleanup;
    }
    CopyMemory(pZombie->pbServerCertificate, pHello->pCertificate, pHello->CertificateLen);


    /* Create the verify prelude hashes */
    /* Which should look like  */
    /* Hash(CLIENT_MAC_KEY, Hash( "cvp", CLIENT_HELLO, SERVER_HELLO)) */
    /* Here we just do the inner hash */


    if(pContext->pClientHello == NULL) 
    {
        pctRet = SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
        goto cleanup;
    }

    pCMKey = (PPct1_Client_Master_Key)SPExternalAlloc(sizeof(Pct1_Client_Master_Key) + cbClientCert);

    if (NULL == pCMKey)
    {
        pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto cleanup;
    }


    // Generate Key Args
    if(pContext->pCipherInfo->dwBlockSize > 1)
    {
        GenerateRandomBits(pZombie->pKeyArgs, pContext->pCipherInfo->dwBlockSize);
        pZombie->cbKeyArgs = pCMKey->KeyArgLen = pContext->pCipherInfo->dwBlockSize;

        /* Copy over the key args */
        CopyMemory(pCMKey->KeyArg,
                    pZombie->pKeyArgs,
                    pZombie->cbKeyArgs );
    }
    else
    {    
        pCMKey->KeyArgLen = 0;
    }


    pctRet = pContext->pKeyExchInfo->System->GenerateClientExchangeValue(
                        pContext,
                        pHello->Response,
                        pHello->ResponseLen,
                        pCMKey->ClearKey,
                        &pCMKey->ClearKeyLen,
                        NULL,
                        &pCMKey->EncryptedKeyLen);
    if(PCT_ERR_OK != pctRet)
    {
        goto cleanup;
    }

    pCMKey->pbEncryptedKey = SPExternalAlloc(pCMKey->EncryptedKeyLen);
    if(pCMKey->pbEncryptedKey == NULL)
    {
        pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto cleanup;
    }

    pctRet = pContext->pKeyExchInfo->System->GenerateClientExchangeValue(
                        pContext,
                        pHello->Response,
                        pHello->ResponseLen,
                        pCMKey->ClearKey,
                        &pCMKey->ClearKeyLen,
                        pCMKey->pbEncryptedKey,
                        &pCMKey->EncryptedKeyLen);
    if(PCT_ERR_OK != pctRet)
    {
        goto cleanup;
    }

    pctRet = Pct1BeginVerifyPrelude(pContext, 
                           pContext->pClientHello,
                           pContext->cbClientHello,
                           pCommInput->pvBuffer,
                           pCommInput->cbData);
    if(PCT_ERR_OK != pctRet)
    {
        goto cleanup;
    }

    // Activate session keys.
    Pct1ActivateSessionKeys(pContext);

        
    pCMKey->VerifyPreludeLen = sizeof(pCMKey->VerifyPrelude);
    pctRet = Pct1EndVerifyPrelude(pContext, 
                                  pCMKey->VerifyPrelude, 
                                  &pCMKey->VerifyPreludeLen);

    if(PCT_ERR_OK != pctRet)
    {
        goto cleanup;
    }



    /* Choose a client cert */
    /* For each Cert the server understands, check to see if we */
    /* have that type of cert */

    pCMKey->ClientCertLen = 0;
    pCMKey->ClientCertSpec = 0;
    pCMKey->ClientSigSpec = 0;
    pCMKey->ResponseLen = 0;


    if(fClientAuth && pSigInfo != NULL)
    {

        // The client cert spec was already chosen
        // Also, pContext->fCertChainsAllowed will be
        // previously set if we're doing chains.
        pCMKey->ClientCertSpec = ClientCertSpec;
        pCMKey->ClientSigSpec = pSigInfo->Spec;

        pCMKey->pClientCert = (PUCHAR)(pCMKey+1);
        pCMKey->ClientCertLen = cbClientCert;
        memcpy(pCMKey->pClientCert, pbClientCert, cbClientCert);

        // Allocate memory for signature.
        pCMKey->ResponseLen = pContext->pActiveClientCred->pPublicKey->cbPublic;
        pCMKey->pbResponse  = SPExternalAlloc(pCMKey->ResponseLen);
        if(pCMKey->pbResponse == NULL)
        {
            pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            goto cleanup;
        }

        DebugLog((DEB_TRACE, "Sign client response.\n"));

        // Sign hash via a call to the application process.
        pctRet = SignHashUsingCallback(pContext->pActiveClientCred->hRemoteProv,
                                       pContext->pActiveClientCred->dwKeySpec,
                                       pSigInfo->aiHash,
                                       pCMKey->VerifyPrelude,
                                       pCMKey->VerifyPreludeLen,
                                       pCMKey->pbResponse,
                                       &pCMKey->ResponseLen,
                                       TRUE);
        if(pctRet != PCT_ERR_OK)
        {
            goto cleanup;
        }

        DebugLog((DEB_TRACE, "Client response signed successfully.\n"));

        // Convert signature to big endian.
        ReverseInPlace(pCMKey->pbResponse, pCMKey->ResponseLen);
    }

    pctRet = PCT_ERR_ILLEGAL_MESSAGE;
    if(PCT_ERR_OK != (pctRet = Pct1PackClientMasterKey(pCMKey,
                                                       pCommOutput)))
    {
        pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
        goto cleanup;
    }

    pContext->WriteCounter++;


    pctRet = PCT_ERR_OK;

cleanup:

    if(pCMKey)
    {
        if(pCMKey->pbEncryptedKey)
        {
            SPExternalFree(pCMKey->pbEncryptedKey);
        }
        if(pCMKey->pbResponse)
        {
            SPExternalFree(pCMKey->pbResponse);
        }
        SPExternalFree(pCMKey);
    }

    if(pbClientCert)
    {
        SPExternalFree(pbClientCert);
    }

    if(pctRet != PCT_ERR_OK)
    {
        if(pctRet == PCT_ERR_SPECS_MISMATCH)
        {
            for(i=0;i<PCT_NUM_MISMATCHES;i++)
            {
                MisData[i] = (BYTE)(fMismatch & 1);
                fMismatch = fMismatch >> 1;
            }

            ErrData.cbData = ErrData.cbBuffer = PCT_NUM_MISMATCHES;
            ErrData.pvBuffer = MisData;
        }

        pctRet = Pct1GenerateError(pContext,
                                   pCommOutput,
                                   pctRet,
                                   &ErrData);

        pctRet |= PCT_INT_DROP_CONNECTION;
    }

    SP_RETURN(pctRet);
}



SP_STATUS
Pct1CliRestart(PSPContext  pContext,
              PPct1_Server_Hello pHello,
              PSPBuffer pCommOutput)
{
    SP_STATUS           pctRet = PCT_ERR_ILLEGAL_MESSAGE;
    UCHAR               Response[RESPONSE_SIZE];
    DWORD               cbResponse;
    PPct1_Server_Hello  pLocalHello = pHello;
    PSessCacheItem      pZombie;

    SP_BEGIN("Pct1CliRestart");
    pZombie = pContext->RipeZombie;

    do {
        /* if there's no zombie, the message is wrong.  We can't restart. */
        
        if(pZombie == NULL)
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
            break;
        }

        if(!pZombie->hMasterKey)
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
            break;
        }

        if(!pZombie->ZombieJuju)
        {
            DebugLog((DEB_WARN, "Session expired on client machine, but not on server.\n"));
        }
        

        CopyMemory(pContext->pConnectionID,
                   pHello->ConnectionID,
                   pHello->cbConnectionID);

        pContext->cbConnectionID = pHello->cbConnectionID;

        //Init pending ciphers
        pctRet = ContextInitCiphersFromCache(pContext);

        if(PCT_ERR_OK != pctRet)
        {
            break;
        }

        // We know what our ciphers are, so init the cipher system
        pctRet = ContextInitCiphers(pContext, TRUE, TRUE);

        if(PCT_ERR_OK != pctRet)
        {
            break;
        }

        // Make a new set of session keys.
        pctRet = MakeSessionKeys(pContext,
                                 pContext->RipeZombie->hMasterProv,
                                 pContext->RipeZombie->hMasterKey);
        if(PCT_ERR_OK != pctRet)
        {
            break;
        }

        // Activate session keys.
        Pct1ActivateSessionKeys(pContext);

        pctRet = PCT_ERR_ILLEGAL_MESSAGE;

        DebugLog((DEB_TRACE, "Session Keys Made\n"));
        /* let's check the response in the message */

        /* check the length */
        if (pLocalHello->ResponseLen != pContext->pHashInfo->cbCheckSum) 
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
            break;
        }

        /* calculate the correct response */
        cbResponse = sizeof(Response);
        pctRet = Pct1ComputeResponse(pContext, 
                                     pContext->pChallenge,
                                     pContext->cbChallenge,
                                     pContext->pConnectionID,
                                     pContext->cbConnectionID,
                                     pZombie->SessionID,
                                     pZombie->cbSessionID,
                                     Response,
                                     &cbResponse);
        if(pctRet != PCT_ERR_OK)
        {
            break;
        }

        /* check it against the response in the message */
        if (memcmp(Response, pLocalHello->Response, pLocalHello->ResponseLen)) 
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_SERVER_AUTH_FAILED);
            break;
        }

        /* ok, we're done, so let's jettison the auth data */
        pContext->ReadCounter = 1;
        pContext->WriteCounter = 1;

        /* fini. */
        SP_RETURN(PCT_ERR_OK);
    } while (TRUE);

    pctRet = Pct1GenerateError(pContext,
                              pCommOutput,
                              pctRet,
                              NULL);

    SP_RETURN(pctRet | PCT_INT_DROP_CONNECTION);
}




SP_STATUS 
Pct1CliHandleServerVerify(
    PSPContext pContext,
    PSPBuffer  pCommInput,
    PSPBuffer  pCommOutput)
{
    SP_STATUS           pctRet;
    PPct1_Server_Verify pVerify = NULL;
    SPBuffer            ErrData;
    PSessCacheItem      pZombie;
    UCHAR               Response[RESPONSE_SIZE];
    DWORD               cbResponse;


    SP_BEGIN("Pct1CliHandleServerVerify");

    pZombie = pContext->RipeZombie;
    pContext->ReadCounter = 2;
    pContext->WriteCounter = 2;

    pCommOutput->cbData = 0;

    ErrData.cbData = 0;
    ErrData.pvBuffer = NULL;
    ErrData.cbBuffer = 0;

    do
    {

        /* unpack the message */
        pctRet = Pct1UnpackServerVerify(pCommInput, &pVerify);
        if (PCT_ERR_OK != pctRet)
        {
            // If it's an incomplete message or something, just return;
            if(!SP_FATAL(pctRet))
            {
                SP_RETURN(pctRet);
            }
            break;
        }

        // compute the correct response
        cbResponse = sizeof(Response);
        pctRet = Pct1ComputeResponse(pContext,
                                     pContext->pChallenge,
                                     pContext->cbChallenge,
                                     pContext->pConnectionID,
                                     pContext->cbConnectionID,
                                     pVerify->SessionIdData,
                                     PCT_SESSION_ID_SIZE,
                                     Response,
                                     &cbResponse);
        if(pctRet != PCT_ERR_OK)
        {
            SP_LOG_RESULT(pctRet);
            break;
        }

        if(pVerify->ResponseLen != cbResponse ||
           memcmp(pVerify->Response, Response, pVerify->ResponseLen))
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
            break;
        }

        CopyMemory(pZombie->SessionID, 
                   pVerify->SessionIdData,
                   PCT_SESSION_ID_SIZE);

        pZombie->cbSessionID = PCT_SESSION_ID_SIZE;

        /* done with the verify data */
        SPExternalFree(pVerify);
        pVerify = NULL;

        /* set up the session in cache */
        SPCacheAdd(pContext);

        SP_RETURN( PCT_ERR_OK );
    } while(TRUE); /* End of polish loop */

    if(pVerify) SPExternalFree(pVerify);

    pctRet = Pct1GenerateError(pContext,
                              pCommOutput,
                              pctRet,
                              NULL);

    SP_RETURN(pctRet | PCT_INT_DROP_CONNECTION);
}

SP_STATUS 
WINAPI
GeneratePct1StyleHello(
    PSPContext             pContext,
    PSPBuffer              pOutput)
{
    Pct1_Client_Hello   HelloMessage;
    PSessCacheItem      pZombie;
    CipherSpec          aCipherSpecs[10];
    HashSpec            aHashSpecs[10];
    CertSpec            aCertSpecs[10];
    ExchSpec            aExchSpecs[10];
    DWORD i;

    SP_STATUS pctRet = PCT_INT_INTERNAL_ERROR;

    SP_BEGIN("Pct1CliInstigateHello");

    HelloMessage.pCipherSpecs = aCipherSpecs;
    HelloMessage.pHashSpecs = aHashSpecs;
    HelloMessage.pCertSpecs = aCertSpecs;
    HelloMessage.pExchSpecs = aExchSpecs;

    if(pContext == NULL) 
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    if (!pOutput)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    pZombie = pContext->RipeZombie;


    pContext->Flags |= CONTEXT_FLAG_CLIENT;

    GenerateRandomBits( pContext->pChallenge, PCT1_CHALLENGE_SIZE );
    pContext->cbChallenge = PCT1_CHALLENGE_SIZE;
    /* Build the hello message. */

    HelloMessage.cbChallenge = PCT1_CHALLENGE_SIZE;
    HelloMessage.pKeyArg = NULL;
    HelloMessage.cbKeyArgSize = 0;


    HelloMessage.cCipherSpecs = 0;
    for(i=0; i < Pct1NumCipher; i++)
    {
        PCipherInfo pCipherInfo;
        pCipherInfo = GetCipherInfo(Pct1CipherRank[i].aiCipher, Pct1CipherRank[i].dwStrength);
        if(IsCipherAllowed(pContext, 
                           pCipherInfo, 
                           pContext->dwProtocol,
                           pContext->dwRequestedCF))
        {
            HelloMessage.pCipherSpecs[HelloMessage.cCipherSpecs++] = Pct1CipherRank[i].Spec;
        }
    }

    HelloMessage.cHashSpecs = 0;
    for(i=0; i < Pct1NumHash; i++)
    {
        PHashInfo pHashInfo;
        pHashInfo = GetHashInfo(Pct1HashRank[i].aiHash);
        if(IsHashAllowed(pContext, 
                         pHashInfo,
                         pContext->dwProtocol))
        {
            HelloMessage.pHashSpecs[HelloMessage.cHashSpecs++] = Pct1HashRank[i].Spec;
        }

    }

    HelloMessage.cCertSpecs = 0;
    for(i=0; i < cPct1CertEncodingPref; i++)
    { 
        PCertSysInfo pCertInfo = GetCertSysInfo(aPct1CertEncodingPref[i].dwCertEncodingType);

        if(pCertInfo == NULL)
        {
            continue;
        }
        // Is this cert type enabled?
        if(0 == (pCertInfo->fProtocol & SP_PROT_PCT1_CLIENT))
        {
            continue;
        }

        HelloMessage.pCertSpecs[HelloMessage.cCertSpecs++] = aPct1CertEncodingPref[i].Spec;

    }

    HelloMessage.cExchSpecs = 0;
    for(i=0; i < cPct1LocalExchKeyPref; i++)
    {
        PKeyExchangeInfo pExchInfo;
        pExchInfo = GetKeyExchangeInfo(aPct1LocalExchKeyPref[i].Spec);
        if(IsExchAllowed(pContext, 
                         pExchInfo,
                         pContext->dwProtocol))
        {
            HelloMessage.pExchSpecs[HelloMessage.cExchSpecs++] = aPct1LocalExchKeyPref[i].Spec;
        }
    }


    if (pZombie->cbSessionID)
    {
        CopyMemory(HelloMessage.SessionID, pZombie->SessionID, pZombie->cbSessionID);
        HelloMessage.cbSessionID = pZombie->cbSessionID;
    }
    else
    {
        FillMemory(HelloMessage.SessionID, PCT_SESSION_ID_SIZE, 0);
        HelloMessage.cbSessionID = PCT_SESSION_ID_SIZE;
    }

    CopyMemory(  HelloMessage.Challenge,
                pContext->pChallenge,
                HelloMessage.cbChallenge );
    HelloMessage.cbChallenge = pContext->cbChallenge;

    pctRet = Pct1PackClientHello(&HelloMessage,  pOutput);

    if(PCT_ERR_OK != pctRet)
    {
        SP_RETURN(pctRet);
    }


    // Save the ClientHello message so we can hash it later, once
    // we know what algorithm and CSP we're using.
    if(pContext->pClientHello)
    {
        SPExternalFree(pContext->pClientHello);
    }
    pContext->pClientHello = SPExternalAlloc(pOutput->cbData);
    if(pContext->pClientHello == NULL)
    {
        SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
    }
    CopyMemory(pContext->pClientHello, pOutput->pvBuffer, pOutput->cbData);
    pContext->cbClientHello = pOutput->cbData;
    pContext->dwClientHelloProtocol = SP_PROT_PCT1_CLIENT;


    /* We set this here to tell the protocol engine that we just send a client
     * hello, and we're expecting a pct server hello */
    pContext->State = PCT1_STATE_CLIENT_HELLO;
    SP_RETURN(PCT_ERR_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\spbase\rng.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       rng.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11-05-97   jbanes   Modified to use static rsaenh.dll.
//
//----------------------------------------------------------------------------

#include <spbase.h>

VOID GenerateRandomBits(PUCHAR pbBuffer,
                        ULONG  dwLength)
{
    CryptGenRandom(g_hRsaSchannel, dwLength, pbBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\spbase\pct1msg.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       pct1msg.c
//
//  Contents:   
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   LSA integration stuff.
//
//----------------------------------------------------------------------------

#include <spbase.h>
#include <pct1msg.h>
#include <pct1prot.h>


static SP_STATUS
Pct1ComputeMac(
    PSPContext pContext,  
    BOOL       fWriteMAC,  
    PSPBuffer  pData,     
    DWORD      dwSequence,
    PBYTE      pbMac,     
    PDWORD     pcbMac);


Pct1CipherMap Pct1CipherRank[] = {
    {CALG_RC4,  128, PCT1_CIPHER_RC4  | PCT1_ENC_BITS_128 | PCT1_MAC_BITS_128},
    {CALG_RC4,   64, PCT1_CIPHER_RC4  | PCT1_ENC_BITS_64  | PCT1_MAC_BITS_128},
    {CALG_RC4,   40, PCT1_CIPHER_RC4  | PCT1_ENC_BITS_40  | PCT1_MAC_BITS_128},
};

DWORD Pct1NumCipher = sizeof(Pct1CipherRank)/sizeof(Pct1CipherMap);

/* available hashes, in order of preference */
Pct1HashMap Pct1HashRank[] = {
    {CALG_MD5, PCT1_HASH_MD5},
    {CALG_SHA, PCT1_HASH_SHA}
};
DWORD Pct1NumHash = sizeof(Pct1HashRank)/sizeof(Pct1HashMap);


CertTypeMap aPct1CertEncodingPref[] =
{
    { X509_ASN_ENCODING , PCT1_CERT_X509_CHAIN },
    { X509_ASN_ENCODING , PCT1_CERT_X509 }
};
DWORD cPct1CertEncodingPref = sizeof(aPct1CertEncodingPref)/sizeof(CertTypeMap);


KeyTypeMap aPct1LocalExchKeyPref[] =   // CAPI Key type, SCHANNEL ALGID
{
    { CALG_RSA_KEYX, SP_EXCH_RSA_PKCS1 }
};

DWORD cPct1LocalExchKeyPref = sizeof(aPct1LocalExchKeyPref)/sizeof(KeyTypeMap);


KeyTypeMap aPct1LocalSigKeyPref[] =   // CAPI Key type, SCHANNEL ALGID
{
    { CALG_RSA_KEYX,      SP_SIG_RSA_MD5 },
    { CALG_RSA_KEYX,      SP_SIG_RSA_SHA }
};

DWORD cPct1LocalSigKeyPref = sizeof(aPct1LocalSigKeyPref)/sizeof(KeyTypeMap);

SP_STATUS WINAPI
Pct1EncryptRaw( PSPContext          pContext,
                    PSPBuffer       pAppInput,
                    PSPBuffer       pCommOutput,
                    DWORD           dwFlags)
{
    SP_STATUS   pctRet;
    DWORD       cPadding;
    SPBuffer    Clean;
    SPBuffer    Encrypted;

    BOOL        fEscape;
    DWORD       cbHeader;
    DWORD       cbBlockSize;

    BYTE        rgbMac[SP_MAX_DIGEST_LEN];
    DWORD       cbMac;

    fEscape = (0 != (dwFlags & PCT1_ENCRYPT_ESCAPE));

    cbBlockSize = pContext->pCipherInfo->dwBlockSize;

    cPadding = pAppInput->cbData & (cbBlockSize - 1);
    if(cPadding)
    {
        cPadding = cbBlockSize - cPadding;
    }

    if(fEscape || (cbBlockSize > 1)) 
    {
        cbHeader = sizeof(PCT1_MESSAGE_HEADER_EX);
    }
    else
    {
        cbHeader = sizeof(PCT1_MESSAGE_HEADER);
    }

    if(pCommOutput->cbBuffer < (cbHeader + cPadding + pAppInput->cbData))
    {
        return PCT_INT_BUFF_TOO_SMALL;
    }

    Encrypted.pvBuffer = (PUCHAR)pCommOutput->pvBuffer + cbHeader;
    Encrypted.cbBuffer = pCommOutput->cbBuffer - cbHeader;
    Encrypted.cbData   = pAppInput->cbData;

    // Copy input data to output buffer (we're encrypting in place).
    if(pAppInput->pvBuffer != Encrypted.pvBuffer)
    {
        DebugLog((DEB_WARN, "Pct1EncryptRaw: Unnecessary Move, performance hog\n"));
        MoveMemory(Encrypted.pvBuffer,
                   pAppInput->pvBuffer,
                   pAppInput->cbData);
    }

    /* Generate Padding */
    GenerateRandomBits((PUCHAR)Encrypted.pvBuffer + Encrypted.cbData, cPadding);
    Encrypted.cbData += cPadding;

    DebugLog((DEB_TRACE, "Sealing message %x\n", pContext->WriteCounter));

     // Transfer the write key over from the application process.
    if(pContext->hWriteKey == 0)
    {
        DebugLog((DEB_TRACE, "Transfer write key from user process.\n"));
        pctRet = SPGetUserKeys(pContext, SCH_FLAG_WRITE_KEY);
        if(pctRet != PCT_ERR_OK)
        {
            return SP_LOG_RESULT(pctRet);
        }
    }

    // Compute the MAC.
    cbMac = sizeof(rgbMac);
    pctRet = Pct1ComputeMac(pContext,
                            TRUE,
                            &Encrypted,
                            pContext->WriteCounter,
                            rgbMac,
                            &cbMac);
    if(pctRet != PCT_ERR_OK)
    {
        return SP_LOG_RESULT(pctRet);
    }

    pContext->WriteCounter ++ ;

   // Encrypt data.
    if(!SchCryptEncrypt(pContext->hWriteKey,
                        0, FALSE, 0,
                        Encrypted.pvBuffer,
                        &Encrypted.cbData,
                        Encrypted.cbBuffer,
                        pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        return PCT_INT_INTERNAL_ERROR;
    }

    // Add MAC to encrypted buffer.
    if(Encrypted.cbData + cbMac > Encrypted.cbBuffer)
    {
        return PCT_INT_BUFF_TOO_SMALL;
    }
    CopyMemory((PUCHAR)Encrypted.pvBuffer + Encrypted.cbData,
               rgbMac,
               cbMac);
    Encrypted.cbData += cbMac;

    /* set sizes */
    if(fEscape || (cbBlockSize > 1)) 
    {
        if(Encrypted.cbData > 0x3fff)
        {
            return PCT_INT_DATA_OVERFLOW;
        }

        ((PUCHAR)pCommOutput->pvBuffer)[0]= (UCHAR)(0x3f & (Encrypted.cbData>>8));
        if(fEscape)
        {
            ((PUCHAR)pCommOutput->pvBuffer)[0] |= 0x40;
        }

        ((PUCHAR)pCommOutput->pvBuffer)[1]= (UCHAR)(0xff & Encrypted.cbData);
        ((PUCHAR)pCommOutput->pvBuffer)[2]= (UCHAR)cPadding;

    } 
    else 
    {
        if(Encrypted.cbData > 0x7fff)
        {
            return PCT_INT_DATA_OVERFLOW;
        }
        ((PUCHAR)pCommOutput->pvBuffer)[0]= (UCHAR)(0x7f & (Encrypted.cbData>>8)) | 0x80;
        ((PUCHAR)pCommOutput->pvBuffer)[1]= (UCHAR)(0xff & Encrypted.cbData);
    }

    pCommOutput->cbData = Encrypted.cbData + cbHeader;

#if DBG
    {
        DWORD di;
        CHAR  KeyDispBuf[SP_MAX_DIGEST_LEN*2+1];

        for(di=0;di<cbMac;di++)
            wsprintf(KeyDispBuf+(di*2), "%2.2x", rgbMac[di]);
        DebugLog((DEB_TRACE, "  Computed MAC\t%s\n", KeyDispBuf));
    }
#endif
    
    return PCT_ERR_OK;
}

SP_STATUS WINAPI
Pct1EncryptMessage( PSPContext      pContext,
                    PSPBuffer       pAppInput,
                    PSPBuffer       pCommOutput)
{
    return Pct1EncryptRaw(pContext, pAppInput, pCommOutput,0);
}

SP_STATUS WINAPI
Pct1GetHeaderSize(
    PSPContext pContext,
    PSPBuffer pCommInput,
    DWORD * pcbHeaderSize)
{
    if(pcbHeaderSize == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }
    if(pCommInput->cbData < 1)
    {
        return (PCT_INT_INCOMPLETE_MSG);
    }
    if(  ((PUCHAR)pCommInput->pvBuffer)[0]&0x80 )
    {
        *pcbHeaderSize = 2;
    }
    else
    {
        *pcbHeaderSize = 3;
    }
    return PCT_ERR_OK;
}


SP_STATUS WINAPI
Pct1DecryptMessage(PSPContext pContext,
                   PSPBuffer  pMessage,
                   PSPBuffer  pAppOutput)
{
    SP_STATUS   pctRet;
    DWORD       cbHeader;
    DWORD       cbPadding;
    DWORD       cbPayload;
    DWORD       cbActualData;

    SPBuffer    Encrypted;

    PUCHAR      pbMAC;
    BYTE        rgbMac[SP_MAX_DIGEST_LEN];
    DWORD       cbMac;

    cbActualData = pMessage->cbData;

    // Do we have a complete header?
    pMessage->cbData = 2;
    if(cbActualData < 2)
    {
        return PCT_INT_INCOMPLETE_MSG;
    }

    if(((PUCHAR)pMessage->pvBuffer)[0] & 0x80)
    {
        cbHeader = 2;
        cbPadding = 0;
        cbPayload = MAKEWORD(((PUCHAR)pMessage->pvBuffer)[1],
                             ((PUCHAR)pMessage->pvBuffer)[0] & 0x7f);
    }
    else
    {
        // Do we still have a complete header?
        cbHeader = 3;
        pMessage->cbData++;
        if(cbActualData < cbHeader)
        {
            return PCT_INT_INCOMPLETE_MSG;
        }
        cbPadding = ((PUCHAR)pMessage->pvBuffer)[2];
        cbPayload = MAKEWORD(((PUCHAR)pMessage->pvBuffer)[1],
                            ((PUCHAR)pMessage->pvBuffer)[0] & 0x3f);
    }

    // Do we have the complete message?
    pMessage->cbData += cbPayload;
    if(cbActualData < cbHeader + cbPayload)
    {
        return PCT_INT_INCOMPLETE_MSG;
    }

    /* do we have enough data for our checksum */
    if(cbPayload < pContext->pHashInfo->cbCheckSum)
    {
        return SP_LOG_RESULT(PCT_INT_MSG_ALTERED);
    }

    Encrypted.pvBuffer = (PUCHAR)pMessage->pvBuffer + cbHeader;
    Encrypted.cbBuffer = cbPayload - pContext->pHashInfo->cbCheckSum;
    Encrypted.cbData   = Encrypted.cbBuffer;

    pbMAC = (PUCHAR)Encrypted.pvBuffer + Encrypted.cbData;

    /* check to see if we have a block size violation */
    if(Encrypted.cbData % pContext->pCipherInfo->dwBlockSize)
    {
        return SP_LOG_RESULT(PCT_INT_MSG_ALTERED);
    }

    Encrypted.cbBuffer = Encrypted.cbData;
    
    // Decrypt message.
    if(Encrypted.cbData > pAppOutput->cbBuffer)
    {
        return SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
    }
    if(Encrypted.pvBuffer != pAppOutput->pvBuffer)
    {
        DebugLog((DEB_WARN, "Pct1DecryptMessage: Unnecessary MoveMemory, performance hog\n"));

        MoveMemory(pAppOutput->pvBuffer, 
                   Encrypted.pvBuffer,
                   Encrypted.cbData);
    }
    pAppOutput->cbData = Encrypted.cbData;

    // Transfer the read key over from the application process.
    if(pContext->hReadKey == 0)
    {
        DebugLog((DEB_TRACE, "Transfer read key from user process.\n"));
        pctRet = SPGetUserKeys(pContext, SCH_FLAG_READ_KEY);
        if(pctRet != PCT_ERR_OK)
        {
            return SP_LOG_RESULT(pctRet);
        }
    }

    if(!SchCryptDecrypt(pContext->hReadKey,
                        0, FALSE, 0,
                        pAppOutput->pvBuffer,
                        &pAppOutput->cbData,
                        pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        return PCT_INT_INTERNAL_ERROR;
    }
    
    // Compute MAC
    cbMac = sizeof(rgbMac);
    pctRet = Pct1ComputeMac(pContext,
                            FALSE,
                            pAppOutput,
                            pContext->ReadCounter,
                            rgbMac,
                            &cbMac);
    if(pctRet != PCT_ERR_OK)
    {
        return SP_LOG_RESULT(pctRet);
    }

    pContext->ReadCounter++;

#if DBG
    {
        DWORD di;
        CHAR  KeyDispBuf[SP_MAX_DIGEST_LEN*2+1];

        for(di=0;di<pContext->pHashInfo->cbCheckSum;di++)
            wsprintf(KeyDispBuf+(di*2), "%2.2x", pbMAC[di]);
        DebugLog((DEB_TRACE, "  Incoming MAC\t%s\n", KeyDispBuf));

        for(di=0;di<cbMac;di++)
            wsprintf(KeyDispBuf+(di*2), "%2.2x", rgbMac[di]);
        DebugLog((DEB_TRACE, "  Computed MAC\t%s\n", KeyDispBuf));
    }
#endif

    // Validate MAC
    if (memcmp( rgbMac, pbMAC, cbMac ) )
    {
        return SP_LOG_RESULT(PCT_INT_MSG_ALTERED);
    }

    // Strip off the block cipher padding.
    if(cbPadding > pAppOutput->cbData)
    {
        return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
    }
    pAppOutput->cbData -= cbPadding;

    return( PCT_ERR_OK );
}

#if 0
SP_STATUS
PctComputeKey(PSPContext    pContext,
              PBYTE         pKey,
              DWORD         cbKey,
              PUCHAR        pConst,
              DWORD         dwCLen,
              DWORD         fFlags)
{
    DWORD               pctRet;
    HashBuf             HBHash;
    PCheckSumBuffer     pHash;
    PSessCacheItem      pZombie=NULL;
    PSPCredentialGroup  pCred=NULL;

    BYTE                i,j;

    DWORD                iMax;

    BYTE                Buffer[MAX_CHECKSUM];


    pZombie = pContext->RipeZombie;
    pCred = pZombie ->pCred;

    SP_BEGIN("PctComputeKey");
    pHash = (PCheckSumBuffer)HBHash;



    iMax = (cbKey + pContext->pHashInfo->cbCheckSum - 1)/pContext->pHashInfo->cbCheckSum;
    
    if(iMax > 4)
    {
        SP_RETURN(PCT_INT_INTERNAL_ERROR);
    }

    for(i=1; i <= iMax; i++)
    {
        InitHashBuf(HBHash, pContext);
        pContext->pHashInfo->System->Sum( pHash, 1, &i );


        if (!(fFlags & PCT_MAKE_MAC))
        {
            // constant^i
            pContext->pHashInfo->System->Sum( pHash, dwCLen*i, pConst);
        }

        // MASTER KEY
        pContext->pHashInfo->System->Sum( pHash, pContext->RipeZombie->cbMasterKey, pContext->RipeZombie->pMasterKey);

        // constant^i
        pContext->pHashInfo->System->Sum( pHash, dwCLen*i, pConst);

        // ConnectionID
        pContext->pHashInfo->System->Sum( pHash, pContext->cbConnectionID, pContext->pConnectionID);

        // constant^i
        pContext->pHashInfo->System->Sum( pHash, dwCLen*i, pConst);




        if (fFlags & PCT_USE_CERT)
        {

            /* add in the certificate */

            pContext->pHashInfo->System->Sum( pHash, pZombie->cbServerCertificate, pZombie->pbServerCertificate );

            // constant^i
            pContext->pHashInfo->System->Sum( pHash, dwCLen*i, pConst);
        }
        // ConnectionID
        pContext->pHashInfo->System->Sum( pHash, pContext->cbChallenge, pContext->pChallenge);

        // constant^i
        pContext->pHashInfo->System->Sum( pHash, dwCLen*i, pConst);
        if(pContext->pHashInfo->cbCheckSum*i <= cbKey)
        {
            pContext->pHashInfo->System->Finalize( pHash, pKey + pContext->pHashInfo->cbCheckSum*(i-1) );
        }
        else
        {
            pContext->pHashInfo->System->Finalize( pHash, Buffer );
            CopyMemory(pKey + pContext->pHashInfo->cbCheckSum*(i-1), 
                       Buffer,
                       cbKey - pContext->pHashInfo->cbCheckSum*(i-1));
        }

    }

    SP_RETURN(PCT_ERR_OK);
}
#endif

#if 0
SP_STATUS
PctComputeExportKey(PSPContext    pContext,
                    PBYTE         pKey,
                    DWORD         cbWriteKey,
                    DWORD         cbCipherKey)
{
    DWORD               pctRet;
    HashBuf             HBHash;
    PCheckSumBuffer     pHash;
    PSessCacheItem      pZombie=NULL;
    PSPCredentialGroup  pCred=NULL;

    BYTE                i,j;

    DWORD               d;
    DWORD               cbClearChunk;
    BYTE                pWriteKey[SP_MAX_MASTER_KEY];

    BYTE                Buffer[MAX_CHECKSUM];


    pZombie = pContext->RipeZombie;
    pCred = pZombie ->pCred;

    SP_BEGIN("PctComputeKey");
    pHash = (PCheckSumBuffer)HBHash;


    CopyMemory(pWriteKey, pKey, cbWriteKey);

    d = (cbCipherKey + pContext->pHashInfo->cbCheckSum - 1)/pContext->pHashInfo->cbCheckSum;
    
    if(d > 4)
    {
        SP_RETURN(PCT_INT_INTERNAL_ERROR);
    }

    cbClearChunk = pContext->RipeZombie->cbClearKey/d;

    for(i=1; i <= d; i++)
    {
        InitHashBuf(HBHash, pContext);
        pContext->pHashInfo->System->Sum( pHash, 1, &i );


        // constant^i
        pContext->pHashInfo->System->Sum( pHash, PCT_CONST_SLK_LEN*i, PCT_CONST_SLK);

        // WRITE_KEY
        pContext->pHashInfo->System->Sum( pHash, cbWriteKey, pWriteKey);

        // constant^i
        pContext->pHashInfo->System->Sum( pHash, PCT_CONST_SLK_LEN*i, PCT_CONST_SLK);

        // Clear Key
        pContext->pHashInfo->System->Sum( pHash, 
                               cbClearChunk, 
                               (PBYTE)pContext->RipeZombie->pClearKey + (i-1)*cbClearChunk);

        if(pContext->pHashInfo->cbCheckSum*i <= cbCipherKey)
        {
            pContext->pHashInfo->System->Finalize( pHash, pKey + pContext->pHashInfo->cbCheckSum*(i-1) );
        }
        else
        {
            pContext->pHashInfo->System->Finalize( pHash, Buffer );
            CopyMemory(pKey + pContext->pHashInfo->cbCheckSum*(i-1), 
                       Buffer,
                       cbCipherKey - pContext->pHashInfo->cbCheckSum*(i-1));
        }

    }

    SP_RETURN(PCT_ERR_OK);
}
#endif

#if 0
SP_STATUS
Pct1MakeSessionKeys(
    PSPContext  pContext)
{
    SP_STATUS           pctRet;
    BOOL                fClient;
    UCHAR               pWriteKey[SP_MAX_MASTER_KEY], pReadKey[SP_MAX_MASTER_KEY];
#if DBG
    DWORD       i;
    CHAR        KeyDispBuf[SP_MAX_MASTER_KEY*2+1];
#endif
    PSessCacheItem      pZombie=NULL;
    PSPCredentialGroup  pCred=NULL;


    SP_BEGIN("PctMakeSessionKeys");
    pZombie = pContext->RipeZombie;
    pCred = pZombie ->pCred;

    if (!pContext->InitMACState) 
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }
    
    

#if DBG
    DebugLog((DEB_TRACE, "Making session keys\n", KeyDispBuf));

    for(i=0;i<PCT_SESSION_ID_SIZE;i++)
        wsprintf(KeyDispBuf+(i*2), "%2.2x",
                pContext->pConnectionID[i]);
    DebugLog((DEB_TRACE, "  ConnId\t%s\n", KeyDispBuf));


    for(i=0;i<PCT_CHALLENGE_SIZE;i++)
        wsprintf(KeyDispBuf+(i*2), "%2.2x", (UCHAR)pContext->pChallenge[i]);
    DebugLog((DEB_TRACE, "  Challenge \t%s\n", KeyDispBuf));

    for(i=0;i<pContext->RipeZombie->cbClearKey;i++)
        wsprintf(KeyDispBuf+(i*2), "%2.2x", (UCHAR)pContext->RipeZombie->pClearKey[i]);
    DebugLog((DEB_TRACE, "  ClearKey \t%s\n", KeyDispBuf));

#endif



    fClient = ((pContext->Flags & CONTEXT_FLAG_CLIENT) != 0);

    pctRet = PctComputeKey( pContext, fClient?pWriteKey:pReadKey, pContext->pCipherInfo->cbSecret, PCT_CONST_CWK,
                            PCT_CONST_CWK_LEN, PCT_USE_CERT);

    if(PCT_ERR_OK != pctRet)
    {
        goto quit;
    }

    pctRet = PctComputeKey( pContext, fClient?pReadKey:pWriteKey, pContext->pCipherInfo->cbSecret, PCT_CONST_SWK,
                   PCT_CONST_SWK_LEN, 0);
    if(PCT_ERR_OK != pctRet)
    {
        goto quit;
    }
    


    /* compute the ClientMacKey */

    pctRet = PctComputeKey(pContext, 
                           (fClient?pContext->WriteMACKey:pContext->ReadMACKey), 
                           pContext->pHashInfo->cbCheckSum, 
                           PCT_CONST_CMK,
                           PCT_CONST_CMK_LEN, 
                           PCT_USE_CERT | PCT_MAKE_MAC);

    if(PCT_ERR_OK != pctRet)
    {
        goto quit;
    }

    /* compute the ServerMacKey */

    pctRet = PctComputeKey(pContext, 
                           (fClient?pContext->ReadMACKey:pContext->WriteMACKey), 
                            pContext->pHashInfo->cbCheckSum, 
                            PCT_CONST_SMK,
                            PCT_CONST_SMK_LEN, 
                            PCT_MAKE_MAC);

    if(PCT_ERR_OK != pctRet)
    {
        goto quit;
    }

    // Initialize the hash states

    InitHashBuf(pContext->RdMACBuf, pContext);
    InitHashBuf(pContext->WrMACBuf, pContext);

    // Note, we truncuate the MACing keys down to the negotiated key size
    pContext->ReadMACState = (PCheckSumBuffer)pContext->RdMACBuf;

    pContext->pHashInfo->System->Sum( pContext->ReadMACState, 
                           pContext->pHashInfo->cbCheckSum,
                           pContext->ReadMACKey);
    
    pContext->WriteMACState = (PCheckSumBuffer)pContext->WrMACBuf;

    pContext->pHashInfo->System->Sum( pContext->WriteMACState, 
                           pContext->pHashInfo->cbCheckSum,
                           pContext->WriteMACKey);

    if (pContext->pCipherInfo->cbSecret < pContext->pCipherInfo->cbKey)
    {
        pctRet = PctComputeExportKey(pContext,
                            pWriteKey,
                            pContext->pCipherInfo->cbSecret,
                            pContext->pCipherInfo->cbKey);

        if(PCT_ERR_OK != pctRet)
        {
            goto quit;
        }

        pctRet = PctComputeExportKey(pContext,
                            pReadKey,
                            pContext->pCipherInfo->cbSecret,
                            pContext->pCipherInfo->cbKey);

        if(PCT_ERR_OK != pctRet)
        {
            goto quit;
        }
       /* chop the encryption keys down to selected length */


    }



#if DBG

    for(i=0;i<pContext->RipeZombie->cbMasterKey;i++)
        wsprintf(KeyDispBuf+(i*2), "%2.2x", pContext->RipeZombie->pMasterKey[i]);
    DebugLog((DEB_TRACE, "  MasterKey \t%s\n", KeyDispBuf));

    for(i=0;i<pContext->pCipherInfo->cbKey;i++)
        wsprintf(KeyDispBuf+(i*2), "%2.2x", pReadKey[i]);
    DebugLog((DEB_TRACE, "    ReadKey\t%s\n", KeyDispBuf));

    for(i=0;i<pContext->pHashInfo->cbCheckSum;i++)
        wsprintf(KeyDispBuf+(i*2), "%2.2x", pContext->ReadMACKey[i]);
    DebugLog((DEB_TRACE, "     MACKey\t%s\n", KeyDispBuf));

    for(i=0;i<pContext->pCipherInfo->cbKey;i++)
        wsprintf(KeyDispBuf+(i*2), "%2.2x", pWriteKey[i]);
    DebugLog((DEB_TRACE, "    WriteKey\t%s\n", KeyDispBuf));

    for(i=0;i<pContext->pHashInfo->cbCheckSum;i++)
        wsprintf(KeyDispBuf+(i*2), "%2.2x", pContext->WriteMACKey[i]);
    DebugLog((DEB_TRACE, "     MACKey\t%s\n", KeyDispBuf));

#endif

    if (pContext->pCipherInfo->System->Initialize(  pReadKey,
                                        pContext->pCipherInfo->cbKey,
                                        pZombie->pKeyArgs,       // IV
                                        pZombie->cbKeyArgs,      // IV length
                                        &pContext->pReadState ) )
    {
        if (pContext->pCipherInfo->System->Initialize(  pWriteKey,
                                            pContext->pCipherInfo->cbKey,
                                            pZombie->pKeyArgs,       // IV
                                            pZombie->cbKeyArgs,      // IV length
                                            &pContext->pWriteState) )
        {
            pctRet = PCT_ERR_OK;
            goto quit;
        }
        pctRet = SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
        pContext->pCipherInfo->System->Discard( &pContext->pReadState );
    }

    pctRet = SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);

quit:
    SP_RETURN(pctRet);
}
#endif

SP_STATUS WINAPI Pct1DecryptHandler(PSPContext  pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pAppOutput)
{
    SP_STATUS      pctRet= 0;
    BOOL           fEscape;
    PPCT1_CLIENT_HELLO pHello;
    if(pCommInput->cbData > 0) {        
        /* first, we'll handle incoming data packets */
        if((pContext->State == SP_STATE_CONNECTED) && (pContext->Decrypt)) 
        {
            fEscape = (((*(PUCHAR)pCommInput->pvBuffer) & 0xc0) == 0x40);
            /* BUGFIX:  IE 3.0 and 3.0a incorrectly respond to a REDO request
             * by just sending a PCT1 client hello, instead of another REDO.
             * We therefore look at the incomming message and see if it
             * looks like a PCT1 client hello.
             */
            pHello = (PPCT1_CLIENT_HELLO)pCommInput->pvBuffer;

            if((pCommInput->cbData >= 5) &&
               (pHello->MessageId == PCT1_MSG_CLIENT_HELLO) &&
               (pHello->VersionMsb == MSBOF(PCT_VERSION_1)) &&
               (pHello->VersionLsb == LSBOF(PCT_VERSION_1)) &&
               (pHello->OffsetMsb  == MSBOF(PCT_CH_OFFSET_V1)) &&
               (pHello->OffsetLsb  == LSBOF(PCT_CH_OFFSET_V1)))
            {
                // This looks a lot like a client hello
                 /* InitiateRedo */
                pAppOutput->cbData = 0;
                pCommInput->cbData = 0;

                pContext->State = PCT1_STATE_RENEGOTIATE;
;
                return SP_LOG_RESULT(PCT_INT_RENEGOTIATE);
           }

            if(PCT_ERR_OK == 
               (pctRet = pContext->Decrypt(pContext, 
                                           pCommInput,   /* message */ 
                                           pAppOutput /* Unpacked Message */
                                ))) 
            {  
                /* look for escapes */
                if(fEscape) 
                {
                    if(pAppOutput->cbData < 1)
                    {
                        return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
                    }
                    /* The first byte of the decrypt buffer is the escape code */
                    switch(*(PUCHAR)pAppOutput->pvBuffer) 
                    {
                        case PCT1_ET_REDO_CONN:
                        {
                            /* InitiateRedo */
                            if(pAppOutput->cbData != 1)
                            {
                                return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
                            }
                            pContext->State = PCT1_STATE_RENEGOTIATE;
                            pAppOutput->cbData = 0;
                            return SP_LOG_RESULT(PCT_INT_RENEGOTIATE);
                        }
                        case PCT1_ET_OOB_DATA:
                            /* HandleOOB */
                        default:
                            /* Unknown escape, generate error */
                            pctRet = SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
                            /* Disconnect */
                            break;
                    }

                }
            }
            return (pctRet);

        } 
        else 
        {
            return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
        }
    }
    return PCT_INT_INCOMPLETE_MSG;
}

SP_STATUS Pct1GenerateError(PSPContext  pContext,
                              PSPBuffer  pCommOutput,
                              SP_STATUS  pError,
                              PSPBuffer  pErrData)
{
    Pct1Error            XmitError;
    
    /* Only pack up an error if we are allowed to return errors */
    if(!(pContext->Flags & CONTEXT_FLAG_EXT_ERR)) return pError;

    XmitError.Error = pError;
    XmitError.ErrInfoLen = 0;
    XmitError.ErrInfo = NULL;

    if(pErrData) {
        XmitError.ErrInfoLen = pErrData->cbData;
        XmitError.ErrInfo = pErrData->pvBuffer;
    }
    Pct1PackError(&XmitError,
                 pCommOutput);
    return pError;
}

/* session key computation */


SP_STATUS Pct1HandleError(PSPContext  pContext,
                          PSPBuffer  pCommInput,
                          PSPBuffer  pCommOutput)
{
    pCommOutput->cbData = 0;
    return(((PPCT1_ERROR)pCommInput->pvBuffer)->ErrorMsb << 8 )|  ((PPCT1_ERROR)pCommInput->pvBuffer)->ErrorLsb;
}

//+---------------------------------------------------------------------------
//
//  Function:   Pct1BeginVerifyPrelude
//
//  Synopsis:   Initiate the "verify prelude" computation.
//
//  Arguments:  [pContext]      --  Schannel context.
//              [pClientHello]  -- 
//              [cbClientHello] --
//              [pServerHello]  -- 
//              [cServerHello]  --
//
//  History:    10-10-97   jbanes   Added CAPI integration.
//
//  Notes:      Hash(CLIENT_MAC_KEY, Hash("cvp", CLIENT_HELLO, SERVER_HELLO));
//
//----------------------------------------------------------------------------
SP_STATUS Pct1BeginVerifyPrelude(PSPContext pContext,
                                 PUCHAR     pClientHello,
                                 DWORD      cbClientHello,
                                 PUCHAR     pServerHello,
                                 DWORD      cbServerHello)
{
    HCRYPTHASH hHash;

    if(!SchCryptCreateHash(pContext->RipeZombie->hMasterProv,
                           pContext->pHashInfo->aiHash,
                           0,
                           0,
                           &hHash,
                           pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        return PCT_INT_INTERNAL_ERROR;
    }
    if(!SchCryptHashData(hHash, 
                         PCT_CONST_VP, 
                         PCT_CONST_VP_LEN, 
                         0,
                         pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags);
        return PCT_INT_INTERNAL_ERROR;
    }
    if(!SchCryptHashData(hHash, 
                         pClientHello, 
                         cbClientHello, 
                         0,
                         pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags);
        return PCT_INT_INTERNAL_ERROR;
    }
    if(!SchCryptHashData(hHash, 
                         pServerHello, 
                         cbServerHello, 
                         0,
                         pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags);
        return PCT_INT_INTERNAL_ERROR;
    }

    pContext->hMd5Handshake = hHash;

    return PCT_ERR_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   Pct1EndVerifyPrelude
//
//  Synopsis:   Finish the "verify prelude" computation.
//
//  Arguments:  [pContext]          --  Schannel context.
//              [VerifyPrelude]     -- 
//              [pcbVerifyPrelude]  --
//
//  History:    10-10-97   jbanes   Added CAPI integration.
//
//  Notes:      
//
//----------------------------------------------------------------------------
SP_STATUS Pct1EndVerifyPrelude(PSPContext pContext,
                               PUCHAR     VerifyPrelude,
                               DWORD *    pcbVerifyPrelude)
{
    BOOL fClient;
    HCRYPTHASH hHash;

    fClient = !(pContext->RipeZombie->fProtocol & SP_PROT_SERVERS);

    if(!SchCryptGetHashParam(pContext->hMd5Handshake,
                             HP_HASHVAL,
                             VerifyPrelude,
                             pcbVerifyPrelude,
                             0,
                             pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        SchCryptDestroyHash(pContext->hMd5Handshake, pContext->RipeZombie->dwCapiFlags);
        pContext->hMd5Handshake = 0;
        return PCT_INT_INTERNAL_ERROR;
    }
    SchCryptDestroyHash(pContext->hMd5Handshake, pContext->RipeZombie->dwCapiFlags);
    pContext->hMd5Handshake = 0;

    if(!SchCryptCreateHash(pContext->RipeZombie->hMasterProv,
                           pContext->pHashInfo->aiHash,
                           0,
                           0,
                           &hHash, 
                           pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        return PCT_INT_INTERNAL_ERROR;
    }

    if(!SchCryptHashSessionKey(hHash,
                               fClient ? pContext->hWriteMAC : pContext->hReadMAC,
                               CRYPT_LITTLE_ENDIAN,
                               pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags);
        return PCT_INT_INTERNAL_ERROR;
    }

    if(!SchCryptHashData(hHash, 
                         VerifyPrelude, 
                         *pcbVerifyPrelude, 
                         0,
                         pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags);
        return PCT_INT_INTERNAL_ERROR;
    }

    if(!SchCryptGetHashParam(hHash,
                             HP_HASHVAL,
                             VerifyPrelude,
                             pcbVerifyPrelude,
                             0,
                             pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags);
        return PCT_INT_INTERNAL_ERROR;
    }
    SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags);

    return PCT_ERR_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   Pct1ComputeMac
//
//  Synopsis:   Compute the 
//
//  Arguments:  [pContext]          --  Schannel context.
//
//  History:    10-10-97   jbanes   Created.
//
//  Notes:      MAC_DATA := Hash(MAC_KEY, Hash(RECORD_HEADER_DATA, 
//                          ACTUAL_DATA, PADDING_DATA, SEQUENCE_NUMBER))
//
//----------------------------------------------------------------------------
static SP_STATUS
Pct1ComputeMac(
    PSPContext pContext,    // in
    BOOL       fWriteMAC,   // in
    PSPBuffer  pData,       // in
    DWORD      dwSequence,  // in
    PBYTE      pbMac,       // out
    PDWORD     pcbMac)      // in, out
{
    HCRYPTHASH hHash;
    DWORD dwReverseSequence;

    dwReverseSequence = htonl(dwSequence);

    // Compute inner hash
    if(!SchCryptCreateHash(pContext->RipeZombie->hMasterProv,
                           pContext->pHashInfo->aiHash,
                           0,
                           0,
                           &hHash,
                           pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        return PCT_INT_INTERNAL_ERROR;
    }
    if(!SchCryptHashData(hHash, 
                         pData->pvBuffer, 
                         pData->cbData, 
                         0, 
                         pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        return PCT_INT_INTERNAL_ERROR;
    }
    if(!SchCryptHashData(hHash, 
                         (PUCHAR)&dwReverseSequence, 
                         sizeof(DWORD), 
                         0,
                         pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags);
        return PCT_INT_INTERNAL_ERROR;
    }
    if(!SchCryptGetHashParam(hHash, 
                             HP_HASHVAL, 
                             pbMac, 
                             pcbMac, 
                             0,
                             pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags);
        return PCT_INT_INTERNAL_ERROR;
    }
    SP_ASSERT(*pcbMac == pContext->pHashInfo->cbCheckSum);
    SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags);

    // Compute outer hash.
    if(!SchCryptCreateHash(pContext->RipeZombie->hMasterProv,
                           pContext->pHashInfo->aiHash,
                           0,
                           0,
                           &hHash,
                           pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        return PCT_INT_INTERNAL_ERROR;
    }
    if(!SchCryptHashSessionKey(hHash,
                               fWriteMAC ? pContext->hWriteMAC : pContext->hReadMAC,
                               CRYPT_LITTLE_ENDIAN,
                               pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags);
        return PCT_INT_INTERNAL_ERROR;
    }
    if(!SchCryptHashData(hHash, pbMac, *pcbMac, 0, pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags);
        return PCT_INT_INTERNAL_ERROR;
    }
    if(!SchCryptGetHashParam(hHash, 
                             HP_HASHVAL, 
                             pbMac, 
                             pcbMac, 
                             0,
                             pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags);
        return PCT_INT_INTERNAL_ERROR;
    }
    SP_ASSERT(*pcbMac == pContext->pHashInfo->cbCheckSum);
    SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags);

    return PCT_ERR_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   Pct1ComputeResponse
//
//  Synopsis:   Compute the "response" field of the ServerVerify message.
//
//  Arguments:  [pContext]          --  Schannel context.
//              [pbChallenge]       -- 
//              [cbChallenge]       --
//              [pbConnectionID]    -- 
//              [cbConnectionID]    --
//              [pbSessionID]       -- 
//              [cbSessionID]       -- 
//              [pbResponse]        --
//              [pcbResponse]       -- 
//
//  History:    10-10-97   jbanes   Created.
//
//  Notes:      Hash(SERVER_MAC_KEY, Hash ("sr", CH_CHALLENGE_DATA, 
//              SH_CONNECTION_ID_DATA, SV_SESSION_ID_DATA))
//
//----------------------------------------------------------------------------
SP_STATUS
Pct1ComputeResponse(
    PSPContext pContext,        // in
    PBYTE      pbChallenge,     // in
    DWORD      cbChallenge,     // in
    PBYTE      pbConnectionID,  // in
    DWORD      cbConnectionID,  // in
    PBYTE      pbSessionID,     // in
    DWORD      cbSessionID,     // in
    PBYTE      pbResponse,      // out
    PDWORD     pcbResponse)     // in, out
{
    BOOL fClient;
    HCRYPTHASH hHash = 0;
    SP_STATUS pctRet;

    fClient = !(pContext->RipeZombie->fProtocol & SP_PROT_SERVERS);

    //
    // Hash ("sr", CH_CHALLENGE_DATA, SH_CONNECTION_ID_DATA,
    // SV_SESSION_ID_DATA). Place the result in pbResponse.
    //

    if(!SchCryptCreateHash(pContext->RipeZombie->hMasterProv,
                           pContext->pHashInfo->aiHash,
                           0,
                           0,
                           &hHash,
                           pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    if(!SchCryptHashData(hHash, 
                         PCT_CONST_RESP, 
                         PCT_CONST_RESP_LEN, 
                         0,
                         pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    if(!SchCryptHashData(hHash,
                         pbChallenge,
                         cbChallenge,
                         0,
                         pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    if(!SchCryptHashData(hHash,
                         pbConnectionID,
                         cbConnectionID,
                         0,
                         pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    if(!SchCryptHashData(hHash,
                         pbSessionID,
                         cbSessionID,
                         0,
                         pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    if(!SchCryptGetHashParam(hHash,
                             HP_HASHVAL,
                             pbResponse,
                             pcbResponse,
                             0,
                             pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags);
    hHash = 0;

    //
    // Hash (SERVER_MAC_KEY, pbResponse). Place the result back in pbResponse.
    //

    if(!SchCryptCreateHash(pContext->RipeZombie->hMasterProv,
                           pContext->pHashInfo->aiHash,
                           0,
                           0,
                           &hHash,
                           pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    if(!SchCryptHashSessionKey(hHash,
                               fClient ? pContext->hReadMAC : pContext->hWriteMAC,
                               CRYPT_LITTLE_ENDIAN,
                               pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    if(!SchCryptHashData(hHash, 
                         pbResponse, 
                         *pcbResponse, 
                         0, 
                         pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    if(!SchCryptGetHashParam(hHash,
                             HP_HASHVAL,
                             pbResponse,
                             pcbResponse,
                             0,
                             pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags);
    hHash = 0;

    pctRet = PCT_ERR_OK;

cleanup:

    if(hHash)
    {
        SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags);
    }

    return pctRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\spbase\protutil.c ===
#include <stdlib.h>
#include <spbase.h>
#include <wincrypt.h>



SP_STATUS SPAllocOutMem(DWORD cbMessage, PSPBuffer  pCommOutput)
{
    SP_BEGIN("SPAllocOutMem");
    
    pCommOutput->cbData = cbMessage;

    DebugLog((DEB_TRACE, "Output buffer size %x\n", cbMessage));

    /* are we allocating our own memory? */
    if(pCommOutput->pvBuffer == NULL) 
    {
        pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
        if (NULL == pCommOutput->pvBuffer)
        {
            SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
        }
        pCommOutput->cbBuffer = pCommOutput->cbData;
    }
    if(pCommOutput->cbData > pCommOutput->cbBuffer)
    {
        // Required buffer size returned in pCommOutput->cbData.
        SP_RETURN(PCT_INT_BUFF_TOO_SMALL);
    }
    SP_RETURN(PCT_ERR_OK);
}

//Make sure that we have cbMessage in the buffer, if not allocate, 
//if more leave it alone

SP_STATUS SPAllocOutMemChk(DWORD cbMessage, PSPBuffer  pOut)
{
    SP_STATUS pctRet = PCT_ERR_OK;


    if(pOut->cbBuffer < cbMessage)
    {
        SPBuffer spbufT;

        spbufT.cbData = spbufT.cbBuffer = 0;
        spbufT.pvBuffer = NULL;
        pctRet = SPAllocOutMem(cbMessage, &spbufT);
        if(PCT_ERR_OK == pctRet)
        {
            CopyMemory((PBYTE)spbufT.pvBuffer, (PBYTE)pOut->pvBuffer, pOut->cbData);
            SPExternalFree(pOut->pvBuffer);  
            pOut->pvBuffer = spbufT.pvBuffer;
            pOut->cbBuffer = cbMessage;
        }
    }
    return(pctRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\spbase\sigsys.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       sigsys.c
//
//  Contents:   
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   LSA integration stuff.
//
//----------------------------------------------------------------------------

#include <spbase.h>
#include <wincrypt.h>
#include <ssl2msg.h>
#include <ssl3msg.h>


SP_STATUS 
SPVerifySignature(
    HCRYPTPROV  hProv,
    DWORD       dwCapiFlags,
    PPUBLICKEY  pPublic,
    ALG_ID      aiHash,
    PBYTE       pbData, 
    DWORD       cbData, 
    PBYTE       pbSig, 
    DWORD       cbSig,
    BOOL        fHashData)
{
    HCRYPTKEY  hPublicKey = 0;
    HCRYPTHASH hHash = 0;
    PBYTE      pbSigBuff = NULL;
    SP_STATUS  pctRet;

    if(hProv == 0 || pPublic == NULL)
    {
        pctRet = SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
        goto cleanup;
    }
    
    pbSigBuff = SPExternalAlloc(cbSig);
    if(pbSigBuff == NULL)
    {
        pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto cleanup;
    }


    // 
    // Create public key.
    //

    if(!SchCryptImportKey(hProv,
                          (PBYTE)pPublic->pPublic,
                          pPublic->cbPublic,
                          0, 0,
                          &hPublicKey,
                          dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_ERR_ILLEGAL_MESSAGE;
        goto cleanup;
    }

    // 
    // Hash data.
    //

    if(!SchCryptCreateHash(hProv, aiHash, 0, 0, &hHash, dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_ERR_ILLEGAL_MESSAGE;
        goto cleanup;
    }

    if(!fHashData)
    {
        // set hash value
        if(!SchCryptSetHashParam(hHash, HP_HASHVAL, pbData, 0, dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_ERR_ILLEGAL_MESSAGE;
            goto cleanup;
        }
    }
    else
    {
        if(!SchCryptHashData(hHash, pbData, cbData, 0, dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_ERR_ILLEGAL_MESSAGE;
            goto cleanup;
        }
    }

    if(pPublic->pPublic->aiKeyAlg == CALG_DSS_SIGN)
    {
        BYTE  rgbTempSig[DSA_SIGNATURE_SIZE];
        DWORD cbTempSig;

        // Remove DSS ASN1 goo around signature and convert it to 
        // little endian.
        cbTempSig = sizeof(rgbTempSig);
        if(!CryptDecodeObject(X509_ASN_ENCODING,
                              X509_DSS_SIGNATURE,
                              pbSig,
                              cbSig,
                              0,
                              rgbTempSig,
                              &cbTempSig))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_ERR_ILLEGAL_MESSAGE;
            goto cleanup;
        }

        memcpy(pbSigBuff, rgbTempSig, cbTempSig);
        cbSig = cbTempSig;
    }
    else
    {
        // Convert signature to little endian.
        ReverseMemCopy(pbSigBuff, pbSig, cbSig);
    }

    if(!SchCryptVerifySignature(hHash,  
                                pbSigBuff,
                                cbSig, 
                                hPublicKey, 
                                NULL, 0,
                                dwCapiFlags))
    {
        DebugLog((DEB_WARN, "Signature Verify Failed: %x\n", GetLastError()));
        pctRet = SP_LOG_RESULT(PCT_INT_MSG_ALTERED);
        goto cleanup;
    }

    pctRet = PCT_ERR_OK;


cleanup:

    if(hPublicKey) 
    {
        SchCryptDestroyKey(hPublicKey, dwCapiFlags);
    }

    if(hHash) 
    {
        SchCryptDestroyHash(hHash, dwCapiFlags);
    }

    if(pbSigBuff != NULL)
    {
        SPExternalFree(pbSigBuff);
    }

    return pctRet;
}


SP_STATUS
SignHashUsingCred(
    PSPCredential pCred,
    ALG_ID        aiHash,
    PBYTE         pbHash,
    DWORD         cbHash,
    PBYTE         pbSignature,
    PDWORD        pcbSignature)
{
    HCRYPTHASH  hHash;
    DWORD       cbSignatureBuffer;
    SP_STATUS   pctRet;

    if(pCred == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    cbSignatureBuffer = *pcbSignature;

    if(pCred->hProv)
    {
        // Sign hash using local CSP handle.
        if(!CryptCreateHash(pCred->hProv, aiHash, 0, 0, &hHash))
        {
            SP_LOG_RESULT(GetLastError());
            return PCT_ERR_ILLEGAL_MESSAGE;
        }
        if(!CryptSetHashParam(hHash, HP_HASHVAL, pbHash, 0))
        {
            SP_LOG_RESULT(GetLastError());
            CryptDestroyHash(hHash);
            return PCT_ERR_ILLEGAL_MESSAGE;
        }
        if(!CryptSignHash(hHash, pCred->dwKeySpec, NULL, 0, pbSignature, pcbSignature))
        {
            SP_LOG_RESULT(GetLastError());
            CryptDestroyHash(hHash);
            return PCT_ERR_ILLEGAL_MESSAGE;
        }
        CryptDestroyHash(hHash);
    }
    else if(pCred->hRemoteProv)
    {
        // Sign hash via a call to the application process.
        pctRet = SignHashUsingCallback(pCred->hRemoteProv,
                                       pCred->dwKeySpec,
                                       aiHash,
                                       pbHash,
                                       cbHash,
                                       pbSignature,
                                       pcbSignature,
                                       FALSE);
        if(pctRet != PCT_ERR_OK)
        {
            return SP_LOG_RESULT(pctRet);
        }
    }
    else
    {
        DebugLog((DEB_ERROR, "We have no key with which to sign!\n"));
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    if(pCred->dwExchSpec == SP_EXCH_DH_PKCS3)
    {
        BYTE rgbTempSig[DSA_SIGNATURE_SIZE];

        // Add DSS ASN1 goo around signature.
        if(*pcbSignature != DSA_SIGNATURE_SIZE)
        {
            return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
        }

        memcpy(rgbTempSig, pbSignature, DSA_SIGNATURE_SIZE);
        *pcbSignature = cbSignatureBuffer;

        if(!CryptEncodeObject(X509_ASN_ENCODING,
                              X509_DSS_SIGNATURE,
                              rgbTempSig,
                              pbSignature,
                              pcbSignature))
        {
            SP_LOG_RESULT(GetLastError());
            return PCT_ERR_ILLEGAL_MESSAGE;
        }
    }
    else
    {
        // Convert signature to big endian.
        ReverseInPlace(pbSignature, *pcbSignature);
    }

    return PCT_ERR_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\spbase\serial.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       serial.c
//
//  Contents:   Schannel context serialization routines.
//
//  Functions:  SPContextSerialize
//              SPContextDeserialize
//
//  History:    02-15-00   jbanes   Created.
//
//----------------------------------------------------------------------------

#include <spbase.h>
#include <certmap.h>
#include <mapper.h>
#include <align.h>

typedef enum _SERIALIZED_ITEM_TYPE
{
    SslEndOfBuffer = 0,
    SslContext,
    SslReadKey,
    SslReadMac,
    SslWriteKey,
    SslWriteMac,
    SslMapper,
    SslRemoteCertificate
} SERIALIZED_ITEM_TYPE;

typedef struct _SERIALIZED_ITEM_TAG
{
    DWORD Type;
    DWORD Length;
    DWORD DataLength;
    DWORD reserved;
} SERIALIZED_ITEM_TAG;

#define TAG_LENGTH sizeof(SERIALIZED_ITEM_TAG)


DWORD
GetSerializedKeyLength(
    HCRYPTKEY hKey)
{
    DWORD cbKey;

    if(!CryptExportKey(hKey, 0, OPAQUEKEYBLOB, 0, NULL, &cbKey))
    {
        SP_LOG_RESULT(GetLastError());
        return 0;
    }

    return ROUND_UP_COUNT(TAG_LENGTH + cbKey, ALIGN_LPVOID);
}


SP_STATUS
SerializeKey(
    HCRYPTKEY               hKey,
    SERIALIZED_ITEM_TYPE    Type,
    PBYTE                   pbBuffer,
    PDWORD                  pcbBuffer)
{
    SERIALIZED_ITEM_TAG *pTag;
    PBYTE pbKey;
    DWORD cbKey;

    if(*pcbBuffer <= TAG_LENGTH)
    {
        return SP_LOG_RESULT(PCT_INT_DATA_OVERFLOW);
    }

    pTag = (SERIALIZED_ITEM_TAG *)pbBuffer;

    pbKey = pbBuffer   + TAG_LENGTH;
    cbKey = *pcbBuffer - TAG_LENGTH;

    if(!CryptExportKey(hKey, 0, OPAQUEKEYBLOB, 0, pbKey, &cbKey))
    {
        SP_LOG_RESULT(GetLastError());
        return PCT_INT_INTERNAL_ERROR;
    }

    pTag->Type   = Type;
    pTag->Length = ROUND_UP_COUNT(cbKey, ALIGN_LPVOID);
    pTag->DataLength = cbKey;

    if(*pcbBuffer <= TAG_LENGTH + pTag->Length)
    {
        return SP_LOG_RESULT(PCT_INT_DATA_OVERFLOW);
    }

    *pcbBuffer = TAG_LENGTH + pTag->Length;

    return PCT_ERR_OK;
}


SP_STATUS
SerializeContext(
    PSPContext pContext,
    SERIALIZE_LOCATOR_FN LocatorMove,
    PBYTE pbBuffer,
    PDWORD pcbBuffer,
    BOOL fDestroyKeys)
{
    DWORD cbData;
    DWORD cbBuffer;
    DWORD cbBytesNeeded;
    SERIALIZED_ITEM_TAG *pTag;
    PSessCacheItem pZombie;
    SP_STATUS pctRet;

    //
    // Initialize buffer pointers.
    //

    if(pbBuffer == NULL)
    {
        cbBuffer = 0;
    }
    else
    {
        cbBuffer = *pcbBuffer;
    }

    pZombie = pContext->RipeZombie;


    //
    // Context structure.
    //

    cbBytesNeeded = ROUND_UP_COUNT(TAG_LENGTH + sizeof(SPPackedContext),
                                   ALIGN_LPVOID);

    if(pbBuffer == NULL)
    {
        cbBuffer += cbBytesNeeded;
    }
    else
    {
        PSPPackedContext pSerialContext;
        HLOCATOR hLocator;

        if(cbBuffer < cbBytesNeeded)
        {
            return SP_LOG_RESULT(PCT_INT_DATA_OVERFLOW);
        }

        pContext->Flags |= CONTEXT_FLAG_SERIALIZED;

        pTag = (SERIALIZED_ITEM_TAG *)pbBuffer;
        pSerialContext = (PSPPackedContext)(pbBuffer + TAG_LENGTH);

        pTag->Type   = SslContext;
        pTag->Length = cbBytesNeeded - TAG_LENGTH;

        pSerialContext->Magic           = pContext->Magic;
        pSerialContext->State           = pContext->State;
        pSerialContext->Flags           = pContext->Flags;
        pSerialContext->dwProtocol      = pContext->dwProtocol;

        pSerialContext->ContextThumbprint = pContext->ContextThumbprint;

        pSerialContext->dwCipherInfo    = (DWORD)(pContext->pCipherInfo  - g_AvailableCiphers);
        pSerialContext->dwHashInfo      = (DWORD)(pContext->pHashInfo    - g_AvailableHashes);
        pSerialContext->dwKeyExchInfo   = (DWORD)(pContext->pKeyExchInfo - g_AvailableExch);

        pSerialContext->dwExchStrength  = pContext->RipeZombie->dwExchStrength;

        pSerialContext->ReadCounter     = pContext->ReadCounter;
        pSerialContext->WriteCounter    = pContext->WriteCounter;

        if(pZombie->fProtocol & SP_PROT_SERVERS)
        {
            if(pZombie->pActiveServerCred)
            {
                #ifdef _WIN64
                    pSerialContext->hMasterProv.QuadPart = (ULONGLONG)pZombie->pActiveServerCred->hRemoteProv;
                #else
                    pSerialContext->hMasterProv.LowPart  = (DWORD)pZombie->pActiveServerCred->hRemoteProv;
                #endif
            }

            // Copy the locator.
            if(pZombie->phMapper && pZombie->hLocator && LocatorMove)
            {
                if(pZombie->phMapper->m_dwFlags & SCH_FLAG_SYSTEM_MAPPER)
                {
                    // The locator belongs to the system mapper and consists
                    // of a user token, so use the DuplicateHandle function
                    // to make a copy.
                    LocatorMove(pZombie->hLocator, &hLocator);
                }
                else
                {
                    hLocator = pZombie->hLocator;
                }

                #ifdef _WIN64
                    pSerialContext->hLocator.QuadPart = (ULONGLONG)hLocator;
                #else
                    pSerialContext->hLocator.LowPart  = (DWORD)hLocator;
                #endif
            }

            pSerialContext->LocatorStatus = pZombie->LocatorStatus;
        }

        pSerialContext->cbSessionID = pZombie->cbSessionID;
        memcpy(pSerialContext->SessionID, pZombie->SessionID, pZombie->cbSessionID);

        pbBuffer += cbBytesNeeded;
        cbBuffer -= cbBytesNeeded;
    }


    //
    // Certificate mapper structure.
    //

    if(pContext->RipeZombie->phMapper)
    {
        cbBytesNeeded = ROUND_UP_COUNT(TAG_LENGTH + sizeof(PVOID),
                                       ALIGN_LPVOID);

        if(pbBuffer == NULL)
        {
            cbBuffer += cbBytesNeeded;
        }
        else
        {
            if(cbBuffer < cbBytesNeeded)
            {
                return SP_LOG_RESULT(PCT_INT_DATA_OVERFLOW);
            }

            pTag = (SERIALIZED_ITEM_TAG *)pbBuffer;

            pTag->Type   = SslMapper;
            pTag->Length = cbBytesNeeded - TAG_LENGTH;

            CopyMemory(pbBuffer + TAG_LENGTH,
                       &pZombie->phMapper->m_Reserved1,
                       sizeof(PVOID));

            pbBuffer += cbBytesNeeded;
            cbBuffer -= cbBytesNeeded;
        }
    }


    //
    // Data encryption and MAC keys.
    //

    if(pContext->pCipherInfo->aiCipher != CALG_NULLCIPHER)
    {
        // Read key.
        if(pbBuffer == NULL)
        {
            cbBuffer += GetSerializedKeyLength(pContext->hReadKey);
        }
        else
        {
            cbData = cbBuffer;
            pctRet = SerializeKey(pContext->hReadKey,
                                  SslReadKey,
                                  pbBuffer,
                                  &cbData);
            if(pctRet != PCT_ERR_OK)
            {
                return pctRet;
            }
            if(fDestroyKeys)
            {
                if(!CryptDestroyKey(pContext->hReadKey))
                {
                    SP_LOG_RESULT(GetLastError());
                }
                pContext->hReadKey = 0;
            }

            pbBuffer += cbData;
            cbBuffer -= cbData;
        }

        // Write key.
        if(pbBuffer == NULL)
        {
            cbBuffer += GetSerializedKeyLength(pContext->hWriteKey);
        }
        else
        {
            cbData = cbBuffer;
            pctRet = SerializeKey(pContext->hWriteKey,
                                  SslWriteKey,
                                  pbBuffer,
                                  &cbData);
            if(pctRet != PCT_ERR_OK)
            {
                return pctRet;
            }
            if(fDestroyKeys)
            {
                if(!CryptDestroyKey(pContext->hWriteKey))
                {
                    SP_LOG_RESULT(GetLastError());
                }
                pContext->hWriteKey = 0;
            }

            pbBuffer += cbData;
            cbBuffer -= cbData;
        }
    }

    // Read MAC.
    if(pContext->hReadMAC)
    {
        if(pbBuffer == NULL)
        {
            cbBuffer += GetSerializedKeyLength(pContext->hReadMAC);
        }
        else
        {
            cbData = cbBuffer;
            pctRet = SerializeKey(pContext->hReadMAC,
                                  SslReadMac,
                                  pbBuffer,
                                  &cbData);
            if(pctRet != PCT_ERR_OK)
            {
                return pctRet;
            }

            pbBuffer += cbData;
            cbBuffer -= cbData;
        }
    }

    // Write MAC.
    if(pContext->hWriteMAC)
    {
        if(pbBuffer == NULL)
        {
            cbBuffer += GetSerializedKeyLength(pContext->hWriteMAC);
        }
        else
        {
            cbData = cbBuffer;
            pctRet = SerializeKey(pContext->hWriteMAC,
                                  SslWriteMac,
                                  pbBuffer,
                                  &cbData);
            if(pctRet != PCT_ERR_OK)
            {
                return pctRet;
            }

            pbBuffer += cbData;
            cbBuffer -= cbData;
        }
    }


    //
    // Remote certificate.
    //

    if(pContext->RipeZombie->pRemoteCert)
    {
        if(pbBuffer == NULL)
        {
            pctRet = SerializeCertContext(pContext->RipeZombie->pRemoteCert,
                                          NULL,
                                          &cbData);
            if(pctRet != PCT_ERR_OK)
            {
                return SP_LOG_RESULT(pctRet);
            }

            cbBytesNeeded = ROUND_UP_COUNT(TAG_LENGTH + cbData, ALIGN_LPVOID);

            cbBuffer += cbBytesNeeded;
        }
        else
        {
            if(cbBuffer < TAG_LENGTH)
            {
                return SP_LOG_RESULT(PCT_INT_DATA_OVERFLOW);
            }
            cbData = cbBuffer - TAG_LENGTH;

            pctRet = SerializeCertContext(pContext->RipeZombie->pRemoteCert,
                                          pbBuffer + TAG_LENGTH,
                                          &cbData);
            if(pctRet != PCT_ERR_OK)
            {
                return SP_LOG_RESULT(pctRet);
            }

            cbBytesNeeded = ROUND_UP_COUNT(TAG_LENGTH + cbData, ALIGN_LPVOID);

            pTag = (SERIALIZED_ITEM_TAG *)pbBuffer;

            pTag->Type   = SslRemoteCertificate;
            pTag->Length = cbBytesNeeded - TAG_LENGTH;

            pbBuffer += cbBytesNeeded;
            cbBuffer -= cbBytesNeeded;
        }
    }


    //
    // End of buffer marker.
    //

    if(pbBuffer == NULL)
    {
        cbBuffer += TAG_LENGTH;
    }
    else
    {
        if(cbBuffer < TAG_LENGTH)
        {
            return SP_LOG_RESULT(PCT_INT_DATA_OVERFLOW);
        }

        pTag = (SERIALIZED_ITEM_TAG *)pbBuffer;

        pTag->Type   = SslEndOfBuffer;
        pTag->Length = 0;

        pbBuffer += TAG_LENGTH;
        cbBuffer -= TAG_LENGTH;
    }

    if(pbBuffer == NULL)
    {
        *pcbBuffer = cbBuffer;
    }
    else
    {
        #if DBG
        if(cbBuffer)
        {
            DebugLog((DEB_WARN, "%d bytes left over when serializing context.\n", cbBuffer));
        }
        #endif
    }

    return PCT_ERR_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:   SPContextSerialize
//
//  Synopsis:   Extract out everything necessary for bulk data encryption
//              from an Schannel context, and place it in a linear buffer.
//
//  Arguments:  [pCred]         --  Context to be serialized.
//              [ppBuffer]      --  Destination buffer.
//              [pcbBuffer]     --  Destination buffer length.
//
//  History:    09-25-96   jbanes   Hacked for LSA integration.
//
//  Notes:      This routine is called by the LSA process when transitioning
//              from the handshaking phase to the bulk encryption phase.
//
//              This function is also called by the application process as
//              part of ExportSecurityContext.
//
//----------------------------------------------------------------------------
SP_STATUS
SPContextSerialize(
    PSPContext  pContext,
    SERIALIZE_LOCATOR_FN LocatorMove,
    PBYTE *     ppBuffer,
    PDWORD      pcbBuffer,
    BOOL        fDestroyKeys)
{
    PBYTE       pbBuffer;
    DWORD       cbBuffer;
    SP_STATUS   pctRet;

    // Determine size of serialized buffer.
    pctRet = SerializeContext(pContext, LocatorMove, NULL, &cbBuffer, fDestroyKeys);
    if(pctRet != PCT_ERR_OK)
    {
        return SP_LOG_RESULT(pctRet);
    }

    // Allocate memory for serialized buffer.
    pbBuffer = SPExternalAlloc(cbBuffer);
    if(pbBuffer == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }

    // Generate serialized context.
    pctRet = SerializeContext(pContext, LocatorMove, pbBuffer, &cbBuffer, fDestroyKeys);
    if(pctRet != PCT_ERR_OK)
    {
        SPExternalFree(pbBuffer);
        return SP_LOG_RESULT(pctRet);
    }

    // Set outputs
    *ppBuffer  = pbBuffer;
    *pcbBuffer = cbBuffer;

    return PCT_ERR_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:   SPContextDeserialize
//
//  Synopsis:   Build an Schannel context structure from a linear buffer,
//              which was created via SPContextSerialize by the other
//              process.
//
//  Arguments:  [pBuffer]       --  Buffer containing serialized context.
//                                  The new context structure is built over
//                                  the top of this buffer.
//
//  History:    09-25-96   jbanes   Hacked for LSA integration.
//
//  Notes:      This routine is called by the application process when
//              transitioning from the handshaking phase to the bulk
//              encryption phase.
//
//----------------------------------------------------------------------------
SP_STATUS
SPContextDeserialize(
    PBYTE pbBuffer,
    PSPContext *ppContext)
{
    PSPContext  pContext = NULL;
    DWORD       cbReadState;
    DWORD       cbWriteState;
    HANDLE      hToken;
    DWORD       cbData;
    DWORD       Status = PCT_INT_INTERNAL_ERROR;
    HMAPPER *   pSerialMapper;
    BOOL        fDone;
    PSPPackedContext pSerialContext;
    PSessCacheItem pZombie;
    SERIALIZED_ITEM_TAG *pTag;
    DWORD       cbContext;

    DebugLog((DEB_TRACE, "Deserialize context\n"));

    //
    // Extract serialized context.
    //

    pTag = (SERIALIZED_ITEM_TAG *)pbBuffer;

    if(pTag->Type != SslContext)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }
    if(pTag->Length < sizeof(PSPPackedContext))
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    pSerialContext = (PSPPackedContext)(pbBuffer + TAG_LENGTH);

    cbContext = ROUND_UP_COUNT(sizeof(SPContext), ALIGN_LPVOID);

    pContext = SPExternalAlloc(cbContext + sizeof(SessCacheItem));
    if(pContext == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }

    pContext->RipeZombie = (PSessCacheItem)((PBYTE)pContext + cbContext);
    pZombie = pContext->RipeZombie;

    pContext->Magic             = pSerialContext->Magic;
    pContext->State             = pSerialContext->State;
    pContext->Flags             = pSerialContext->Flags;
    pContext->dwProtocol        = pSerialContext->dwProtocol;

    pContext->ContextThumbprint = pSerialContext->ContextThumbprint;

    pContext->pCipherInfo       = g_AvailableCiphers + pSerialContext->dwCipherInfo;
    pContext->pHashInfo         = g_AvailableHashes  + pSerialContext->dwHashInfo;
    pContext->pKeyExchInfo      = g_AvailableExch    + pSerialContext->dwKeyExchInfo;

    pContext->pReadCipherInfo   = pContext->pCipherInfo;
    pContext->pWriteCipherInfo  = pContext->pCipherInfo;
    pContext->pReadHashInfo     = pContext->pHashInfo;
    pContext->pWriteHashInfo    = pContext->pHashInfo;

    pContext->ReadCounter       = pSerialContext->ReadCounter;
    pContext->WriteCounter      = pSerialContext->WriteCounter;

    pContext->fAppProcess       = TRUE;

    pContext->InitiateHello     = GenerateHello;

    switch(pContext->dwProtocol)
    {
        case SP_PROT_PCT1_CLIENT:
            pContext->Decrypt           = Pct1DecryptMessage;
            pContext->Encrypt           = Pct1EncryptMessage;
            pContext->ProtocolHandler   = Pct1ClientProtocolHandler;
            pContext->DecryptHandler    = Pct1DecryptHandler;
            pContext->GetHeaderSize     = Pct1GetHeaderSize;
            break;

        case SP_PROT_PCT1_SERVER:
            pContext->Decrypt           = Pct1DecryptMessage;
            pContext->Encrypt           = Pct1EncryptMessage;
            pContext->ProtocolHandler   = Pct1ServerProtocolHandler;
            pContext->DecryptHandler    = Pct1DecryptHandler;
            pContext->GetHeaderSize     = Pct1GetHeaderSize;
            break;

        case SP_PROT_SSL2_CLIENT:
            pContext->Decrypt           = Ssl2DecryptMessage;
            pContext->Encrypt           = Ssl2EncryptMessage;
            pContext->ProtocolHandler   = Ssl2ClientProtocolHandler;
            pContext->DecryptHandler    = Ssl2DecryptHandler;
            pContext->GetHeaderSize     = Ssl2GetHeaderSize;
            break;

        case SP_PROT_SSL2_SERVER:
            pContext->Decrypt           = Ssl2DecryptMessage;
            pContext->Encrypt           = Ssl2EncryptMessage;
            pContext->ProtocolHandler   = Ssl2ServerProtocolHandler;
            pContext->DecryptHandler    = Ssl2DecryptHandler;
            pContext->GetHeaderSize     = Ssl2GetHeaderSize;
            break;

        case SP_PROT_SSL3_CLIENT:
        case SP_PROT_SSL3_SERVER:
        case SP_PROT_TLS1_CLIENT:
        case SP_PROT_TLS1_SERVER:
            pContext->Decrypt           = Ssl3DecryptMessage;
            pContext->Encrypt           = Ssl3EncryptMessage;
            pContext->ProtocolHandler   = Ssl3ProtocolHandler;
            pContext->DecryptHandler    = Ssl3DecryptHandler;
            pContext->GetHeaderSize     = Ssl3GetHeaderSize;
            break;

        default:
            pContext->Decrypt           = NULL;
            pContext->Encrypt           = NULL;
            pContext->ProtocolHandler   = NULL;
            pContext->DecryptHandler    = NULL;
            pContext->GetHeaderSize     = NULL;
    }


    //
    // Extract serialized cache entry.
    //

    pZombie->fProtocol      = pSerialContext->dwProtocol;
    pZombie->dwExchStrength = pSerialContext->dwExchStrength;

    #ifdef _WIN64
        pZombie->hLocator       = (HLOCATOR)pSerialContext->hLocator.QuadPart;
        pZombie->hMasterProv    = (HCRYPTPROV)pSerialContext->hMasterProv.QuadPart;
    #else
        pZombie->hLocator       = (HLOCATOR)pSerialContext->hLocator.LowPart;
        pZombie->hMasterProv    = (HCRYPTPROV)pSerialContext->hMasterProv.LowPart;
    #endif
    pZombie->LocatorStatus  = pSerialContext->LocatorStatus;

    pZombie->cbSessionID = pSerialContext->cbSessionID;
    memcpy(pZombie->SessionID, pSerialContext->SessionID, pSerialContext->cbSessionID);

    switch(pContext->pKeyExchInfo->Spec)
    {
        case SP_EXCH_RSA_PKCS1:
            if((pZombie->fProtocol & SP_PROT_CLIENTS) || !pZombie->hMasterProv)
            {
                pZombie->hMasterProv = g_hRsaSchannel;
            }
            break;

        case SP_EXCH_DH_PKCS3:
            if((pZombie->fProtocol & SP_PROT_CLIENTS) || !pZombie->hMasterProv)
            {
                pZombie->hMasterProv = g_hDhSchannelProv;
            }
            break;

        default:
            Status = SP_LOG_RESULT(PCT_ERR_SPECS_MISMATCH);
            goto cleanup;
    }
    pContext->hReadProv  = pZombie->hMasterProv;
    pContext->hWriteProv = pZombie->hMasterProv;

    pbBuffer += TAG_LENGTH + pTag->Length;


    //
    // Extract optional serialized data.
    //

    fDone = FALSE;

    while(!fDone)
    {
        DWORD Type   = ((SERIALIZED_ITEM_TAG UNALIGNED *)pbBuffer)->Type;
        DWORD Length = ((SERIALIZED_ITEM_TAG UNALIGNED *)pbBuffer)->Length;
        DWORD DataLength = ((SERIALIZED_ITEM_TAG UNALIGNED *)pbBuffer)->DataLength;

        pbBuffer += TAG_LENGTH;

        switch(Type)
        {
        case SslEndOfBuffer:
            DebugLog((DEB_TRACE, "SslEndOfBuffer\n"));
            fDone = TRUE;
            break;

        case SslReadKey:
            DebugLog((DEB_TRACE, "SslReadKey\n"));
            if(!CryptImportKey(pZombie->hMasterProv,
                               pbBuffer,
                               DataLength,
                               0, 0,
                               &pContext->hReadKey))
            {
                SP_LOG_RESULT(GetLastError());
                Status = PCT_INT_INTERNAL_ERROR;
                goto cleanup;
            }
            DebugLog((DEB_TRACE, "Key:0x%p\n", pContext->hReadKey));
            break;

        case SslReadMac:
            DebugLog((DEB_TRACE, "SslReadMac\n"));
            if(!CryptImportKey(pZombie->hMasterProv,
                               pbBuffer,
                               DataLength,
                               0, 0,
                               &pContext->hReadMAC))
            {
                SP_LOG_RESULT(GetLastError());
                Status = PCT_INT_INTERNAL_ERROR;
                goto cleanup;
            }
            break;

        case SslWriteKey:
            DebugLog((DEB_TRACE, "SslWriteKey\n"));
            if(!CryptImportKey(pZombie->hMasterProv,
                               pbBuffer,
                               DataLength,
                               0, 0,
                               &pContext->hWriteKey))
            {
                SP_LOG_RESULT(GetLastError());
                Status = PCT_INT_INTERNAL_ERROR;
                goto cleanup;
            }
            DebugLog((DEB_TRACE, "Key:0x%p\n", pContext->hWriteKey));
            break;

        case SslWriteMac:
            DebugLog((DEB_TRACE, "SslWriteMac\n"));
            if(!CryptImportKey(pZombie->hMasterProv,
                               pbBuffer,
                               DataLength,
                               0, 0,
                               &pContext->hWriteMAC))
            {
                SP_LOG_RESULT(GetLastError());
                Status = PCT_INT_INTERNAL_ERROR;
                goto cleanup;
            }
            break;

        case SslMapper:
            DebugLog((DEB_TRACE, "SslMapper\n"));
            pZombie->phMapper = *(HMAPPER **)pbBuffer;
            break;

        case SslRemoteCertificate:
            DebugLog((DEB_TRACE, "SslRemoteCertificate\n"));
            // Save a pointer to the serialized certificate context
            // of the remote certificate. This will be deserialized
            // by the QueryContextAttribute function when the
            // application asks for it.
            pZombie->pbServerCertificate = SPExternalAlloc(Length);
            if(pZombie->pbServerCertificate)
            {
                memcpy(pZombie->pbServerCertificate, pbBuffer, Length);
                pZombie->cbServerCertificate = Length;
            }
            break;

        default:
            DebugLog((DEB_WARN, "Invalid tag %d found when deserializing context buffer\n"));
            Status = PCT_INT_INTERNAL_ERROR;
            goto cleanup;
        }

        pbBuffer += Length;
    }

    *ppContext = pContext;
    pContext = NULL;

    Status = PCT_ERR_OK;

cleanup:

    if(pContext != NULL)
    {
        LsaContextDelete(pContext);
        SPExternalFree(pContext);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\spbase\specmap.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       specmap.c
//
//  Contents:   
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   LSA integration stuff.
//
//----------------------------------------------------------------------------
 
#include <spbase.h>
#include <des.h>
#include <des3.h>
#include <rc2.h>


/* supported cipher type arrays */

CipherInfo g_AvailableCiphers[] = {
    { 
        // 128 bit RC4
        SP_PROT_ALL,
        SP_PROT_ALL,
        TEXT("RC4 128/128"),
        CALG_RC4,
        1,
        128,
        16,
        16,
        CF_DOMESTIC | CF_SGC,
    },
    { 
        // 168 bit Triple DES
        SP_PROT_ALL,
        SP_PROT_ALL,
        TEXT("Triple DES 168/168"),
        CALG_3DES,
        DES_BLOCKLEN,
        168,
        DES3_KEYSIZE,
        DES3_KEYSIZE,
        CF_DOMESTIC | CF_SGC,
    },
    { 
        // 128 bit RC2
        SP_PROT_ALL,
        SP_PROT_ALL, 
        TEXT("RC2 128/128"),
        CALG_RC2,
        RC2_BLOCKLEN,
        128,
        16,
        16,
        CF_DOMESTIC | CF_SGC,
    },
    { 
        // 56 bit RC4
        SP_PROT_SSL3 | SP_PROT_TLS1, 
        SP_PROT_SSL3 | SP_PROT_TLS1, 
        TEXT("RC4 56/128"),
        CALG_RC4,
        1,
        56,
        16,
        7,
        CF_EXPORT,
    },

    { 
        // 56 bit RC2
        SP_PROT_SSL3 | SP_PROT_TLS1, 
        SP_PROT_SSL3 | SP_PROT_TLS1, 
        TEXT("RC2 56/128"),
        CALG_RC2,
        RC2_BLOCKLEN,
        56,
        16,
        7,
        CF_EXPORT,
    },

    { 
        // 56 bit DES
        SP_PROT_ALL,
        SP_PROT_ALL,
        TEXT("DES 56/56"),
        CALG_DES,
        DES_BLOCKLEN,
        56,
        DES_KEYSIZE,
        DES_KEYSIZE,
        CF_EXPORT,
    },

    { 
        // 40 bit RC4
        SP_PROT_ALL, 
        SP_PROT_ALL, 
        TEXT("RC4 40/128"),
        CALG_RC4,
        1,
        40,
        16,
        5,
        CF_EXPORT,
    },

    { 
        // 40 bit RC2
        SP_PROT_ALL, 
        SP_PROT_ALL, 
        TEXT("RC2 40/128"),
        CALG_RC2,
        RC2_BLOCKLEN,
        40,
        16,
        5,
        CF_EXPORT,
    },

    { 
        // No encryption.
        SP_PROT_SSL3TLS1, 
        SP_PROT_SSL3TLS1, 
        TEXT("NULL"),
        CALG_NULLCIPHER,
        1,
        0,
        0,
        1,
        CF_EXPORT,
    },
};

DWORD g_cAvailableCiphers = sizeof(g_AvailableCiphers)/sizeof(CipherInfo);

HashInfo g_AvailableHashes[] = 
{
    { 
        SP_PROT_ALL, 
        SP_PROT_ALL, 
        TEXT("MD5"),
        CALG_MD5,
        CB_MD5_DIGEST_LEN,
    },
    { 
        SP_PROT_ALL, 
        SP_PROT_ALL,
        TEXT("SHA"),
        CALG_SHA,
        CB_SHA_DIGEST_LEN,
    }
};

DWORD g_cAvailableHashes = sizeof(g_AvailableHashes)/sizeof(HashInfo);


CertSysInfo g_AvailableCerts[] = 
{
    {
        SP_PROT_ALL, 
        SP_PROT_ALL, 
        X509_ASN_ENCODING, 
        TEXT("X.509")
    }
};

DWORD g_cAvailableCerts = sizeof(g_AvailableCerts)/sizeof(CertSysInfo);

SigInfo g_AvailableSigs[] = 
{
    { 
        SP_PROT_ALL, 
        SP_PROT_ALL, 
        SP_SIG_RSA_MD2, 
        TEXT("RSA Signed MD2"),
        CALG_MD2,
        CALG_RSA_SIGN,
    },
    { 
        SP_PROT_ALL,
        SP_PROT_ALL,
        SP_SIG_RSA_MD5, 
        TEXT("RSA Signed MD5"),
        CALG_MD5,
        CALG_RSA_SIGN,
    },
    { 
        SP_PROT_SSL3TLS1,
        SP_PROT_SSL3TLS1,
        SP_SIG_RSA_SHAMD5,
        TEXT("RSA Signed MD5/SHA combination"),
        (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_SSL3SHAMD5),  // CALG_SSL3_SHAMD5
        CALG_RSA_SIGN,
    }
};

DWORD g_cAvailableSigs = sizeof(g_AvailableSigs)/sizeof(SigInfo);


KeyExchangeInfo g_AvailableExch[] = 
{
    { 
        CALG_RSA_SIGN,
        SP_PROT_ALL,
        SP_PROT_ALL,
        SP_EXCH_RSA_PKCS1,
        TEXT("PKCS"),
        &keyexchPKCS 
    },
    { 
        CALG_RSA_KEYX,
        SP_PROT_ALL,
        SP_PROT_ALL,
        SP_EXCH_RSA_PKCS1,
        TEXT("PKCS"),
        &keyexchPKCS 
    },
    { 
        CALG_DH_EPHEM,
        SP_PROT_SSL3 | SP_PROT_TLS1,
        SP_PROT_SSL3 | SP_PROT_TLS1,
        SP_EXCH_DH_PKCS3,
        TEXT("Diffie-Hellman"),
        &keyexchDH 
    },
};

DWORD g_cAvailableExch = sizeof(g_AvailableExch)/sizeof(KeyExchangeInfo);



PCipherInfo GetCipherInfo(ALG_ID aiCipher, DWORD dwStrength)
{
    DWORD i;
    for (i = 0; i < g_cAvailableCiphers; i++ )
    {
        if(g_AvailableCiphers[i].aiCipher == aiCipher &&
           g_AvailableCiphers[i].dwStrength == dwStrength) 
        { 
            return &g_AvailableCiphers[i]; 
        }       
    }
    return NULL;
}

PHashInfo GetHashInfo(ALG_ID aiHash)
{
    DWORD i;
    for (i = 0; i < g_cAvailableHashes; i++ )
    {
        if(g_AvailableHashes[i].aiHash == aiHash) 
        { 
            return &g_AvailableHashes[i]; 
        }       
    }
    return NULL;
}

PKeyExchangeInfo GetKeyExchangeInfo(ExchSpec Spec)
{
    DWORD i;
    for (i = 0; i < g_cAvailableExch; i++ )
    {
        if(g_AvailableExch[i].Spec == Spec) 
        { 
            return &g_AvailableExch[i]; 
        }       
    }
    return NULL;
}

PKeyExchangeInfo GetKeyExchangeInfoByAlg(ALG_ID aiExch)
{
    DWORD i;
    for (i = 0; i < g_cAvailableExch; i++ )
    {
        if(g_AvailableExch[i].aiExch == aiExch) 
        { 
            return &g_AvailableExch[i]; 
        }       
    }
    return NULL;
}

PCertSysInfo GetCertSysInfo(CertSpec Spec)
{
    DWORD i;
    for (i = 0; i < g_cAvailableCerts; i++ )
    {
        if(g_AvailableCerts[i].Spec == Spec) 
        { 
            return &g_AvailableCerts[i]; 
        }       
    }
    return NULL;
}


PSigInfo GetSigInfo(SigSpec Spec)
{
    DWORD i;
    for (i = 0; i < g_cAvailableSigs; i++ )
    {
        if(g_AvailableSigs[i].Spec == Spec) 
        { 
            return &g_AvailableSigs[i]; 
        }       
    }
    return NULL;
}


KeyExchangeSystem * 
KeyExchangeFromSpec(ExchSpec Spec, DWORD fProtocol)
{
    PKeyExchangeInfo pInfo;
    pInfo = GetKeyExchangeInfo(Spec);
    if(pInfo == NULL)
    {
        return NULL;
    }
    if(pInfo->fProtocol & fProtocol)
    {
        return pInfo->System;
    }
    return NULL;
}

BOOL GetBaseCipherSizes(DWORD *dwMin, DWORD *dwMax)
{
    DWORD i;
    DWORD dwFlags = CF_EXPORT | CF_FASTSGC | CF_SGC;
    *dwMin = 1000;
    *dwMax = 0;

    if(SslGlobalStrongEncryptionPermitted)
    {
        dwFlags |= CF_DOMESTIC;
    }

    for (i = 0; i < g_cAvailableCiphers; i++ )
    {
        if(g_AvailableCiphers[i].fProtocol)
        {
            if(g_AvailableCiphers[i].dwFlags & dwFlags)
            {
                *dwMin = min(g_AvailableCiphers[i].dwStrength, *dwMin);
                *dwMax = max(g_AvailableCiphers[i].dwStrength, *dwMax);
            }
        }

    }
    return TRUE;
}

void 
GetDisplayCipherSizes(
    PSPCredentialGroup pCredGroup,
    DWORD *dwMin, 
    DWORD *dwMax)
{
    DWORD i;
    DWORD dwFlags = CF_EXPORT;

    *dwMin = 1000;
    *dwMax = 0;

    if(SslGlobalStrongEncryptionPermitted)
    {
        dwFlags |= CF_DOMESTIC;
    }

    for (i = 0; i < g_cAvailableCiphers; i++ )
    {
        if(g_AvailableCiphers[i].fProtocol)
        {
            if((g_AvailableCiphers[i].dwFlags & dwFlags) && 
               (g_AvailableCiphers[i].dwStrength > 0))
            {
                *dwMin = min(g_AvailableCiphers[i].dwStrength, *dwMin);
                *dwMax = max(g_AvailableCiphers[i].dwStrength, *dwMax);
            }
        }
    }

    if(pCredGroup)
    {
        *dwMin = max(pCredGroup->dwMinStrength, *dwMin);
        *dwMax = min(pCredGroup->dwMaxStrength, *dwMax);
    }
}

BOOL IsCipherAllowed(
    PSPContext  pContext, 
    PCipherInfo pCipher, 
    DWORD       dwProtocol,
    DWORD       dwFlags)
{
    PSPCredentialGroup pCred;

    pCred = pContext->pCredGroup;
    if(!pCred) return FALSE;

    if(!pCipher) return FALSE;

    if(pCipher->dwStrength < pCred->dwMinStrength)
    {
        return FALSE;
    }

    if(pCipher->dwStrength > pCred->dwMaxStrength)
    {
        return FALSE;
    }
    if((pCipher->fProtocol & dwProtocol) == 0)
    {
        return FALSE;
    }
    if((pCipher->dwFlags & dwFlags) == 0)
    {
        return FALSE;
    }

    return IsAlgAllowed(pCred, pCipher->aiCipher);

}

BOOL 
IsCipherSuiteAllowed(
    PSPContext  pContext, 
    PCipherInfo pCipher, 
    DWORD       dwProtocol,
    DWORD       dwFlags,
    DWORD       dwSuiteFlags)
{
    if(!IsCipherAllowed(pContext, pCipher, dwProtocol, dwFlags))
    {
        return FALSE;
    }

    // Don't allow cipher suites using as domestic DES unless we're a 
    // domestic schannel or we're using SGC.
    if(!SslGlobalStrongEncryptionPermitted)
    {
        if((dwSuiteFlags & DOMESTIC_CIPHER_SUITE) &&
           (pCipher->dwStrength > 0) &&
           (dwFlags & (CF_SGC | CF_FASTSGC)) == 0)
        {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL IsHashAllowed(
    PSPContext  pContext, 
    PHashInfo   pHash,
    DWORD       dwProtocol)
{
    PSPCredentialGroup pCred;

    pCred = pContext->pCredGroup;
    if(!pCred) return FALSE;

    if(!pHash) return FALSE;

    if((pHash->fProtocol & dwProtocol) == 0)
    {
        return FALSE;
    }

    return IsAlgAllowed(pCred, pHash->aiHash);
}

BOOL IsExchAllowed(
    PSPContext       pContext, 
    PKeyExchangeInfo pExch,
    DWORD            dwProtocol)
{
    PSPCredentialGroup  pCred;

    pCred = pContext->pCredGroup;
    if(!pCred) return FALSE;

    if(!pExch) return FALSE;

    if((pExch->fProtocol & dwProtocol) == 0)
    {
        return FALSE;
    }

    return IsAlgAllowed(pCred, pExch->aiExch);
}


BOOL IsAlgAllowed(
    PSPCredentialGroup pCred, 
    ALG_ID aiAlg)
{
    DWORD i;

    if(!pCred) return FALSE;

    if(pCred->palgSupportedAlgs == NULL)
    {
        return FALSE;
    }

    for(i = 0; i < pCred->cSupportedAlgs; i++)
    {   
        if(pCred->palgSupportedAlgs[i] == CALG_RSA_KEYX || 
           pCred->palgSupportedAlgs[i] == CALG_RSA_SIGN)
        {
            // accept either algid
            if(CALG_RSA_KEYX == aiAlg || CALG_RSA_SIGN == aiAlg)
            {
                return TRUE;
            }
        }
        else
        {
            if(pCred->palgSupportedAlgs[i] == aiAlg)
            {
                return TRUE;
            }
        }
    }

    return FALSE;
}

BOOL BuildAlgList(
    PSPCredentialGroup  pCred, 
    ALG_ID *            aalgRequestedAlgs, 
    DWORD               cRequestedAlgs)
{
    DWORD i,j;
    DWORD dwAlgClass;

    BOOL                fCipher=FALSE;
    BOOL                fHash=FALSE;
    BOOL                fExch=FALSE;


    if(!pCred) return FALSE;

    dwAlgClass = 0;

    // Get a buffer to hold the algs.
    pCred->palgSupportedAlgs = (ALG_ID *)SPExternalAlloc(sizeof(ALG_ID) * 
                                                          (g_cAvailableCiphers + 
                                                           g_cAvailableHashes + 
                                                           g_cAvailableExch));
    pCred->cSupportedAlgs = 0;

    if(pCred->palgSupportedAlgs == NULL)
    {
        return FALSE;
    }

    // Get a list of Alg Classes not specified
    if(aalgRequestedAlgs != NULL)
    {
        for(i=0; i < cRequestedAlgs; i++)
        {
            BOOL fAddAlg = FALSE;
            if(GET_ALG_CLASS(aalgRequestedAlgs[i]) == ALG_CLASS_DATA_ENCRYPT) 
            {
                fCipher=TRUE;
                for (j = 0; j < g_cAvailableCiphers; j++ )
                {

                    if((g_AvailableCiphers[j].aiCipher == aalgRequestedAlgs[i]) &&
                       (g_AvailableCiphers[j].dwStrength >= pCred->dwMinStrength) &&
                       (g_AvailableCiphers[j].dwStrength <= pCred->dwMaxStrength) &&
                       (g_AvailableCiphers[j].fProtocol & pCred->grbitEnabledProtocols))
                    {
                        fAddAlg = TRUE;
                        break;
                    }       
                }             
            } 
            else if(GET_ALG_CLASS(aalgRequestedAlgs[i]) == ALG_CLASS_HASH)
            {
                PHashInfo pHash;
                fHash = TRUE;
                pHash = GetHashInfo(aalgRequestedAlgs[i]);
                if((NULL != pHash) && (pHash->fProtocol & pCred->grbitEnabledProtocols))
                {
                    fAddAlg = TRUE;
                }

            }
            else if(GET_ALG_CLASS(aalgRequestedAlgs[i]) == ALG_CLASS_KEY_EXCHANGE)
            {
                PKeyExchangeInfo pExch;
                fExch = TRUE;
                pExch = GetKeyExchangeInfoByAlg(aalgRequestedAlgs[i]);
                if((NULL != pExch) && (pExch->fProtocol & pCred->grbitEnabledProtocols))
                {
                    fAddAlg = TRUE;
                }                
            }

            if(fAddAlg & !IsAlgAllowed(pCred, aalgRequestedAlgs[i]))
            {
                pCred->palgSupportedAlgs[pCred->cSupportedAlgs++] = aalgRequestedAlgs[i];
            }
        }
    }

    if(!fCipher)
    {
        // No ciphers were included in our list, so supply the default ones

        for (j = 0; j < g_cAvailableCiphers; j++ )
        {

            if((g_AvailableCiphers[j].dwStrength >= pCred->dwMinStrength) &&
               (g_AvailableCiphers[j].dwStrength <= pCred->dwMaxStrength) &&
               (g_AvailableCiphers[j].fProtocol & pCred->grbitEnabledProtocols))
            { 
                if(!IsAlgAllowed(pCred, g_AvailableCiphers[j].aiCipher))
                {
                    pCred->palgSupportedAlgs[pCred->cSupportedAlgs++] = g_AvailableCiphers[j].aiCipher;
                }
            }       
        }
    }
    if(!fHash)
    {
        // No hashes were included in our list, so supply the default ones

        for (j = 0; j < g_cAvailableHashes; j++ )
        {

            if(g_AvailableHashes[j].fProtocol & pCred->grbitEnabledProtocols)
            { 
                if(!IsAlgAllowed(pCred, g_AvailableHashes[j].aiHash))
                {
                    pCred->palgSupportedAlgs[pCred->cSupportedAlgs++] = g_AvailableHashes[j].aiHash;
                }
            }       
        }
    }
    if(!fExch)
    {
        // No key exchange algs were included in our list, so supply the default ones

        for(j = 0; j < g_cAvailableExch; j++ )
        {

            if(g_AvailableExch[j].fProtocol & pCred->grbitEnabledProtocols)
            { 
                if(!IsAlgAllowed(pCred, g_AvailableExch[j].aiExch))
                {
                    pCred->palgSupportedAlgs[pCred->cSupportedAlgs++] = g_AvailableExch[j].aiExch;
                }
            }       
        }
    }

    return TRUE;
}


static DWORD
ConvertCapiProtocol(DWORD dwCapiProtocol)
{
    DWORD dwProtocol = 0;

    if(dwCapiProtocol & CRYPT_FLAG_PCT1)
    {
        dwProtocol |= SP_PROT_PCT1;
    }
    if(dwCapiProtocol & CRYPT_FLAG_SSL2)
    {
        dwProtocol |= SP_PROT_SSL2;
    }
    if(dwCapiProtocol & CRYPT_FLAG_SSL3)
    {
        dwProtocol |= SP_PROT_SSL3;
    }
    if(dwCapiProtocol & CRYPT_FLAG_TLS1)
    {
        dwProtocol |= SP_PROT_TLS1;
    }

    return dwProtocol;
}


//+---------------------------------------------------------------------------
//
//  Function:   IsAlgSupportedCapi
//
//  Synopsis:   Examine the cipher suite input, and determine if this is
//              supported by the schannel CSP. Return TRUE if the 
//              cipher suite is supported.
//
//  Arguments:  [dwProtocol]    --  Protocols to be included in the
//                                  ClientHello message.
//
//              [pCipherMap]    --  Cipher suite to be examined.
//
//              [pCapiAlgs]     --  Array of algorithms supported by the
//                                  schannel CSP.
//
//              [cCapiAlgs]     --  Number of elements in the pCapiAlgs
//                                  array.
//
//  History:    10-29-97   jbanes   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------
BOOL
IsAlgSupportedCapi(
    DWORD               dwProtocol, 
    UNICipherMap *      pCipherMap,
    PROV_ENUMALGS_EX *  pCapiAlgs,
    DWORD               cCapiAlgs)
{
    BOOL    fFound;
    DWORD   dwCapiProtocol;
    DWORD   i;

    // Is cipher supported?
    if(pCipherMap->aiCipher != 0 && pCipherMap->aiCipher != CALG_NULLCIPHER)
    {
        for(fFound = FALSE, i = 0; i < cCapiAlgs; i++)
        {
            if(pCipherMap->aiCipher != pCapiAlgs[i].aiAlgid)
            {
                continue;
            }

            if(pCipherMap->dwStrength > pCapiAlgs[i].dwMaxLen ||
               pCipherMap->dwStrength < pCapiAlgs[i].dwMinLen)
            {
                continue;
            }

            dwCapiProtocol = ConvertCapiProtocol(pCapiAlgs[i].dwProtocols);
            if((dwCapiProtocol & dwProtocol) == 0)
            {
                continue;
            }

            fFound = TRUE;
            break;
        }
        if(!fFound)
        {
            return FALSE;
        }
    }


    // Is hash supported?
    if(pCipherMap->aiHash != 0)
    {
        for(fFound = FALSE, i = 0; i < cCapiAlgs; i++)
        {
            if(pCipherMap->aiHash != pCapiAlgs[i].aiAlgid)
            {
                continue;
            }

            dwCapiProtocol = ConvertCapiProtocol(pCapiAlgs[i].dwProtocols);
            if((dwCapiProtocol & dwProtocol) == 0)
            {
                continue;
            }

            fFound = TRUE;
            break;
        }
        if(!fFound)
        {
            return FALSE;
        }
    }

    // Is exchange alg supported?
    if(pCipherMap->KeyExch != SP_EXCH_UNKNOWN)
    {
        for(fFound = FALSE, i = 0; i < cCapiAlgs; i++)
        {

            // RSA
            if(pCipherMap->KeyExch == SP_EXCH_RSA_PKCS1)
            {
                if(pCapiAlgs[i].aiAlgid != CALG_RSA_KEYX)
                {
                    continue;
                }
            }

            // DH
            else if(pCipherMap->KeyExch == SP_EXCH_DH_PKCS3)
            {
                if(pCapiAlgs[i].aiAlgid != CALG_DH_EPHEM)
                {
                    continue;
                }
            }

            // Any other key exchange algorithm
            else
            {
                // Not supported.
                continue;
            }


            dwCapiProtocol = ConvertCapiProtocol(pCapiAlgs[i].dwProtocols);
            if((dwCapiProtocol & dwProtocol) == 0)
            {
                continue;
            }

            fFound = TRUE;
            break;
        }
        if(!fFound)
        {
            return FALSE;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\spbase\srvprot.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       srvprot.c
//
//  Contents:   
//
//  Classes:
//
//  Functions:
//
//  History:    09-26-97   jbanes   LSA integration stuff.
//
//----------------------------------------------------------------------------

#include <spbase.h>
#include <pct1msg.h>
#include <pct1prot.h>
#include <ssl2msg.h>
#include <ssl3msg.h>
#include <ssl2prot.h>


/* The main purpose of this handler is to determine what kind of protocol
 * the client hello is
 */

SP_STATUS WINAPI
ServerProtocolHandler(
    PSPContext pContext,
    PSPBuffer pCommInput,
    PSPBuffer pCommOutput)
{
    SP_STATUS pctRet = PCT_INT_ILLEGAL_MSG;
    PBYTE pb;
    PBYTE pbClientHello;
    DWORD dwVersion;
    DWORD dwEnabledProtocols;


    /* PCTv1.0 Hello starts with
     * RECORD_LENGTH_MSB  (ignore)
     * RECORD_LENGTH_LSB  (ignore)
     * PCT1_CLIENT_HELLO  (must be equal)
     * PCT1_CLIENT_VERSION_MSB (if version greater than PCTv1)
     * PCT1_CLIENT_VERSION_LSB (if version greater than PCTv1) 
     *
     * ... PCT hello ...
     */

    /* Microsft Unihello starts with
     * RECORD_LENGTH_MSB  (ignore)
     * RECORD_LENGTH_LSB  (ignore)
     * SSL2_CLIENT_HELLO  (must be equal)
     * SSL2_CLIENT_VERSION_MSB (if version greater than SSLv2) ( or v3)
     * SSL2_CLIENT_VERSION_LSB (if version greater than SSLv2) ( or v3)
     *
     * ... SSLv2 Compatable Hello ...
     */

    /* SSLv2 Hello starts with
     * RECORD_LENGTH_MSB  (ignore)
     * RECORD_LENGTH_LSB  (ignore)
     * SSL2_CLIENT_HELLO  (must be equal)
     * SSL2_CLIENT_VERSION_MSB (if version greater than SSLv2) ( or v3)
     * SSL2_CLIENT_VERSION_LSB (if version greater than SSLv2) ( or v3)
     *
     * ... SSLv2 Hello ...
     */

    /* SSLv3 Type 2 Hello starts with
     * RECORD_LENGTH_MSB  (ignore)
     * RECORD_LENGTH_LSB  (ignore)
     * SSL2_CLIENT_HELLO  (must be equal)
     * SSL2_CLIENT_VERSION_MSB (if version greater than SSLv3)
     * SSL2_CLIENT_VERSION_LSB (if version greater than SSLv3)
     *
     * ... SSLv2 Compatable Hello ...
     */

    /* SSLv3 Type 3 Hello starts with
     * 0x15 Hex (HANDSHAKE MESSAGE)
     * VERSION MSB
     * VERSION LSB
     * RECORD_LENGTH_MSB  (ignore)
     * RECORD_LENGTH_LSB  (ignore)
     * HS TYPE (CLIENT_HELLO)
     * 3 bytes HS record length
     * HS Version
     * HS Version
     */

    dwEnabledProtocols = pContext->pCredGroup->grbitEnabledProtocols;

    // We need at least 5 bytes to determine what we have.
    if (pCommInput->cbData < 5)
    {
        return(PCT_INT_INCOMPLETE_MSG);
    }

    pb = pCommInput->pvBuffer;

    // If the first byte is 0x15, then check if we have a
    // SSLv3 Type3 client hello
    if(pb[0] == SSL3_CT_HANDSHAKE)
    {
        //
        // This is an SSL3 ClientHello.
        //

        // We need at least foo bytes to determine what we have.
        if (pCommInput->cbData < sizeof(SWRAP) + sizeof(SHSH) + 2)
        {
            return(PCT_INT_INCOMPLETE_MSG);
        }
        pbClientHello = pb + sizeof(SWRAP) + sizeof(SHSH);

        dwVersion = COMBINEBYTES(pbClientHello[0], pbClientHello[1]);
        if(dwVersion > 0x300 && (0 != (SP_PROT_TLS1_SERVER & dwEnabledProtocols)))
        {
            DebugLog((DEB_TRACE, "SSL3 ClientHello received, selected TLS\n"));
            pContext->dwProtocol = SP_PROT_TLS1_SERVER;
        }
        else if(0 != (SP_PROT_SSL3_SERVER & dwEnabledProtocols))
        {
            DebugLog((DEB_TRACE, "SSL3 ClientHello received, selected SSL3\n"));
            pContext->dwProtocol = SP_PROT_SSL3_SERVER;
        }
        else
        {
            return SP_LOG_RESULT(PCT_INT_SPECS_MISMATCH);
        }
        
        pContext->ProtocolHandler = Ssl3ProtocolHandler;
        pContext->DecryptHandler  = Ssl3DecryptHandler;
        pctRet = Ssl3ProtocolHandler(pContext, pCommInput, pCommOutput);
        return(pctRet);
    }
    else
    {
        // 
        // Assuming SSL2 (or compatible) ClientHello
        //

        dwVersion = COMBINEBYTES(pb[3], pb[4]);
    }

    if(dwVersion >= PCT_VERSION_1)
    {
        //
        // This is a PCT ClientHello.
        //

        if(!(SP_PROT_PCT1_SERVER & dwEnabledProtocols))
        {
            return SP_LOG_RESULT(PCT_ERR_SPECS_MISMATCH);
        }

        // We're running PCT, so set up the PCT handlers
        DebugLog((DEB_TRACE, "PCT ClientHello received, selected PCT\n"));
        pContext->dwProtocol        = SP_PROT_PCT1_SERVER;
        pContext->ProtocolHandler   = Pct1ServerProtocolHandler;
        pContext->DecryptHandler    = Pct1DecryptHandler;
        return(Pct1ServerProtocolHandler(pContext, pCommInput, pCommOutput));
    }

    if(dwVersion >= SSL2_CLIENT_VERSION)
    {
        // we're either receiving ssl2, ssl3, or pct1 compat

        PSSL2_CLIENT_HELLO pRawHello = pCommInput->pvBuffer;

        // Do we have one client hello message with at least one
        // cipher spec.
        if (pCommInput->cbData < (sizeof(SSL2_CLIENT_HELLO)+2))
        {
            return(PCT_INT_INCOMPLETE_MSG);
        }

        // We must have at least one cipher spec
        if(COMBINEBYTES(pRawHello->CipherSpecsLenMsb, pRawHello->CipherSpecsLenLsb) < 1)
        {
            return(SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG));
        }

        // Does client support TLS?
        if((dwVersion >= TLS1_CLIENT_VERSION) &&
            (0 != (SP_PROT_TLS1_SERVER & dwEnabledProtocols)))
        {
            DebugLog((DEB_TRACE, "SSL2 ClientHello received, selected TLS\n"));
            pContext->State             = UNI_STATE_RECVD_UNIHELLO;
            pContext->dwProtocol        = SP_PROT_TLS1_SERVER;
            pContext->ProtocolHandler   = Ssl3ProtocolHandler;
            pContext->DecryptHandler    = Ssl3DecryptHandler;
            return(Ssl3ProtocolHandler(pContext, pCommInput, pCommOutput));
        }  
        
        // Does client support SSL3?
        if((dwVersion >= SSL3_CLIENT_VERSION) &&
           (0 != (SP_PROT_SSL3TLS1_SERVERS & dwEnabledProtocols)))
        {
            DebugLog((DEB_TRACE, "SSL2 ClientHello received, selected SSL3\n"));
            pContext->State             = UNI_STATE_RECVD_UNIHELLO;
            pContext->dwProtocol        = SP_PROT_SSL3_SERVER;
            pContext->ProtocolHandler   = Ssl3ProtocolHandler;
            pContext->DecryptHandler    = Ssl3DecryptHandler;
            return(Ssl3ProtocolHandler(pContext, pCommInput, pCommOutput));
        }

        // Is the PCT compatability flag set?
        if(pRawHello->VariantData[0] == PCT_SSL_COMPAT)
        {
            // Get the pct version.
            dwVersion = COMBINEBYTES(pRawHello->VariantData[1], pRawHello->VariantData[2]);
        }

        // Does client support PCT?
        if((dwVersion >= PCT_VERSION_1) &&
           (0 != (SP_PROT_PCT1_SERVER & dwEnabledProtocols)))
        {
            DebugLog((DEB_TRACE, "SSL2 ClientHello received, selected PCT\n"));
            pContext->State             = UNI_STATE_RECVD_UNIHELLO;
            pContext->dwProtocol        = SP_PROT_PCT1_SERVER;
            pContext->ProtocolHandler   = Pct1ServerProtocolHandler;
            pContext->DecryptHandler    = Pct1DecryptHandler;
            return(Pct1ServerProtocolHandler(pContext, pCommInput, pCommOutput));
        }

        // Does client support SSL2?
        if((dwVersion >= SSL2_CLIENT_VERSION) &&
           (0 != (SP_PROT_SSL2_SERVER & dwEnabledProtocols)))
        {
            DebugLog((DEB_TRACE, "SSL2 ClientHello received, selected SSL2\n"));
            pContext->dwProtocol        = SP_PROT_SSL2_SERVER;
            pContext->ProtocolHandler   = Ssl2ServerProtocolHandler;
            pContext->DecryptHandler    = Ssl2DecryptHandler;
            return(Ssl2ServerProtocolHandler(pContext, pCommInput, pCommOutput));
        }

        return(SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG));
    }

    return (pctRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\spbase\ssl2pkl.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       pickle.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8-02-95   RichardW   Created
//
//----------------------------------------------------------------------------

#include <spbase.h>
#include <ssl2msg.h>

#define SSL_OFFSET_OF(t, v) ((DWORD)(ULONG_PTR)&(((t)NULL)->v))



#define SIZEOF(pMessage)    (SslRecordSize((PSSL2_MESSAGE_HEADER) pMessage ) )

DWORD
SslRecordSize(
    PSSL2_MESSAGE_HEADER  pHeader)
{
    DWORD   Size;

    if (pHeader->Byte0 & 0x80)
    {
        Size = COMBINEBYTES(pHeader->Byte0, pHeader->Byte1) & 0x7FFF;
    }
    else
    {
        Size = COMBINEBYTES(pHeader->Byte0, pHeader->Byte1) & 0x3FFF;
    }
    return(Size);
}



BOOL
Ssl2MapCipherToExternal(
    Ssl2_Cipher_Kind     FastForm,
    PSsl2_Cipher_Tuple   pTuple)
{
    pTuple->C1 = (UCHAR)((FastForm >> 16) & 0xff);
    pTuple->C2 = (UCHAR)((FastForm >> 8) & 0xff);
    pTuple->C3 = (UCHAR)(FastForm & 0xff);


    return(TRUE);
}

Ssl2_Cipher_Kind
Ssl2MapCipherFromExternal(
    PSsl2_Cipher_Tuple   pTuple)
{

    return SSL_MKFAST(pTuple->C1, pTuple->C2, pTuple->C3);
}



SP_STATUS
Ssl2PackClientHello(
    PSsl2_Client_Hello       pCanonical,
    PSPBuffer                pCommOutput)
{
    DWORD               cbMessage;
    PSSL2_CLIENT_HELLO  pMessage;
    DWORD               Size;
    PUCHAR              pBuffer;
    DWORD               i;

    if(pCanonical == NULL || pCommOutput == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    pCommOutput->cbData = 0;

    pCommOutput->cbData = pCanonical->cbSessionID +
                            pCanonical->cbChallenge +
                            pCanonical->cCipherSpecs * sizeof(Ssl2_Cipher_Tuple) +
                            SSL_OFFSET_OF(PSSL2_CLIENT_HELLO, VariantData);

    cbMessage = pCommOutput->cbData - sizeof(SSL2_MESSAGE_HEADER);

    /* are we allocating our own memory? */
    if(pCommOutput->pvBuffer == NULL)
    {
        pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
        if (NULL == pCommOutput->pvBuffer)
        {
            return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        }
        pCommOutput->cbBuffer = pCommOutput->cbData;
    }
    if(pCommOutput->cbData > pCommOutput->cbBuffer)
    {
        // Required buffer size returned in pCommOutput->cbData.
        return SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
    }

    pMessage = pCommOutput->pvBuffer;

    pMessage->MessageId = SSL2_MT_CLIENT_HELLO;

    pMessage->VersionMsb = MSBOF(pCanonical->dwVer);
    pMessage->VersionLsb = LSBOF(pCanonical->dwVer);

    pBuffer = pMessage->VariantData;

    cbMessage -= pCanonical->cCipherSpecs * sizeof(Ssl2_Cipher_Tuple);
    pCommOutput->cbData -= pCanonical->cCipherSpecs * sizeof(Ssl2_Cipher_Tuple);

    Size = 0;

    for (i = 0; i < pCanonical->cCipherSpecs ; i++ )
    {
        if (!Ssl2MapCipherToExternal(pCanonical->CipherSpecs[i],
                                (PSsl2_Cipher_Tuple) pBuffer) )
        {
            continue;
        }

        pBuffer += sizeof(Ssl2_Cipher_Tuple);
        Size += sizeof(Ssl2_Cipher_Tuple);
    }

    cbMessage += Size;
    pCommOutput->cbData += Size;

    pCommOutput->cbData = cbMessage + 2;

    pMessage->Header.Byte0 = MSBOF(cbMessage) | 0x80;
    pMessage->Header.Byte1 = LSBOF(cbMessage);

    pMessage->CipherSpecsLenMsb = MSBOF(Size);
    pMessage->CipherSpecsLenLsb = LSBOF(Size);

    pMessage->SessionIdLenMsb = MSBOF(pCanonical->cbSessionID);
    pMessage->SessionIdLenLsb = LSBOF(pCanonical->cbSessionID);
    if (pCanonical->cbSessionID)
    {
        CopyMemory( pBuffer,
                    pCanonical->SessionID,
                    pCanonical->cbSessionID);

        pBuffer += pCanonical->cbSessionID;
    }

    pMessage->ChallengeLenMsb = MSBOF(pCanonical->cbChallenge);
    pMessage->ChallengeLenLsb = LSBOF(pCanonical->cbChallenge);
    if (pCanonical->cbChallenge)
    {
        CopyMemory( pBuffer,
                    pCanonical->Challenge,
                    pCanonical->cbChallenge);
    }

    return(PCT_ERR_OK);
}


SP_STATUS
Ssl2UnpackClientHello(
    PSPBuffer              pInput,
    PSsl2_Client_Hello *   ppClient)
{

    PSSL2_CLIENT_HELLO   pMessage;
    DWORD               ReportedSize;
    DWORD               CipherSpecsSize;
    DWORD               cCipherSpecs;
    PSsl2_Client_Hello       pCanonical;
    PUCHAR              pBuffer;
    DWORD               Size;
    DWORD               i, dwVer;

    pMessage = pInput->pvBuffer;

    if(pInput->cbData < 2)
    {
        pInput->cbData = 2;
        return PCT_INT_INCOMPLETE_MSG;
    }

    ReportedSize = SIZEOF(pMessage);
    if ((ReportedSize+2) > pInput->cbData)
    {
        pInput->cbData = ReportedSize+2;
        return PCT_INT_INCOMPLETE_MSG;
    }
    if(ReportedSize < SSL_OFFSET_OF(PSSL2_CLIENT_HELLO, VariantData))
    {
        return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

    if (pMessage->MessageId != SSL2_MT_CLIENT_HELLO) {
        return  SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

    dwVer = COMBINEBYTES(pMessage->VersionMsb, pMessage->VersionLsb);

    if (dwVer  < 2) //VERSION 2 WILL COMPUTE TO 2 (00:02)
    {
        return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

    CipherSpecsSize = COMBINEBYTES( pMessage->CipherSpecsLenMsb,
                                    pMessage->CipherSpecsLenLsb );


    *ppClient = NULL;
    /* check that this all fits into the message */
    if (SSL_OFFSET_OF(PSSL2_CLIENT_HELLO, VariantData)
        - sizeof(SSL2_MESSAGE_HEADER)       /* don't count the header */
        + CipherSpecsSize
        > ReportedSize)
    {
        return  SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

        cCipherSpecs = CipherSpecsSize / sizeof(Ssl2_Cipher_Tuple);


    /* Allocate a buffer for the canonical client hello */
    pCanonical = (PSsl2_Client_Hello)SPExternalAlloc(
                                    sizeof(Ssl2_Client_Hello) +
                                    cCipherSpecs * sizeof(UNICipherMap));

    if (!pCanonical)
    {
        return(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    pCanonical->dwVer = COMBINEBYTES(    pMessage->VersionMsb,
                            pMessage->VersionLsb );

    pBuffer = pMessage->VariantData;


    pCanonical->cCipherSpecs = cCipherSpecs;

    for (i = 0 ; i < cCipherSpecs ; i++ )
    {
        pCanonical->CipherSpecs[i] = Ssl2MapCipherFromExternal((PSsl2_Cipher_Tuple)
                                                    pBuffer);

        pBuffer += sizeof(Ssl2_Cipher_Tuple);
    }

    Size = COMBINEBYTES(    pMessage->SessionIdLenMsb,
                            pMessage->SessionIdLenLsb );

    if (Size <= SSL2_SESSION_ID_LEN)
    {
        CopyMemory( pCanonical->SessionID, pBuffer, Size);
        pBuffer += Size;

    }
    else
    {
        SPExternalFree( pCanonical );
        return PCT_ERR_ILLEGAL_MESSAGE;
    }

    pCanonical->cbSessionID = Size;

    Size = COMBINEBYTES(    pMessage->ChallengeLenMsb,
                            pMessage->ChallengeLenLsb );

    if ((Size > 0) && (Size <= SSL2_MAX_CHALLENGE_LEN))
    {
        CopyMemory( pCanonical->Challenge, pBuffer, Size );

        pBuffer += Size;
    }
    else
    {
        SPExternalFree( pCanonical );
        return  SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

    pCanonical->cbChallenge = Size;

    *ppClient = pCanonical;
    pInput->cbData = ReportedSize + sizeof(SSL2_MESSAGE_HEADER);
    return( PCT_ERR_OK );

}

SP_STATUS
Ssl2PackServerHello(
    PSsl2_Server_Hello       pCanonical,
    PSPBuffer          pCommOutput)
{
    DWORD               cbMessage;
    PSSL2_SERVER_HELLO  pMessage;
    DWORD               Size;
    PUCHAR              pBuffer;
    DWORD               i;

    if(pCanonical == NULL || pCommOutput == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }
    pCommOutput->cbData = 0;

    cbMessage = pCanonical->cbConnectionID +
                    pCanonical->cbCertificate +
                    pCanonical->cCipherSpecs * sizeof(Ssl2_Cipher_Tuple) +
                    SSL_OFFSET_OF(PSSL2_SERVER_HELLO, VariantData) -
                    sizeof(SSL2_MESSAGE_HEADER);

    pCommOutput->cbData = cbMessage + 2;


    /* are we allocating our own memory? */
    if(pCommOutput->pvBuffer == NULL)
    {
        pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
        if (NULL == pCommOutput->pvBuffer)
        {
            return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        }
        pCommOutput->cbBuffer = pCommOutput->cbData;
    }
    if(pCommOutput->cbData > pCommOutput->cbBuffer)
    {
        // Required buffer size returned in pCommOutput->cbData.
        return SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
    }

    pMessage = pCommOutput->pvBuffer;


    pMessage->MessageId = SSL2_MT_SERVER_HELLO;
    pMessage->ServerVersionMsb = SSL2_SERVER_VERSION_MSB;
    pMessage->ServerVersionLsb = SSL2_SERVER_VERSION_LSB;
    pMessage->SessionIdHit = (UCHAR) pCanonical->SessionIdHit;
    pMessage->CertificateType = (UCHAR) pCanonical->CertificateType;

    pBuffer = pMessage->VariantData;

    //
    // Pack certificate if present
    //

    pMessage->CertificateLenMsb = MSBOF(pCanonical->cbCertificate);
    pMessage->CertificateLenLsb = LSBOF(pCanonical->cbCertificate);

    if (pCanonical->cbCertificate)
    {
        CopyMemory( pBuffer,
                    pCanonical->pCertificate,
                    pCanonical->cbCertificate);

        pBuffer += pCanonical->cbCertificate ;
    }

    Size = pCanonical->cCipherSpecs * sizeof(Ssl2_Cipher_Tuple);

    for (i = 0; i < pCanonical->cCipherSpecs ; i++ )
    {
        if (Ssl2MapCipherToExternal(pCanonical->pCipherSpecs[i],
                                (PSsl2_Cipher_Tuple) pBuffer) )
        {
            pBuffer += sizeof(Ssl2_Cipher_Tuple);
        }
        else
        {
            Size -= sizeof(Ssl2_Cipher_Tuple);
            cbMessage -= sizeof(Ssl2_Cipher_Tuple);
        }
    }

    pCommOutput->cbData = cbMessage + 2;

    pMessage->Header.Byte0 = MSBOF(cbMessage) | 0x80;
    pMessage->Header.Byte1 = LSBOF(cbMessage);

    pMessage->CipherSpecsLenMsb = MSBOF(Size);
    pMessage->CipherSpecsLenLsb = LSBOF(Size);

    pMessage->ConnectionIdLenMsb = MSBOF(pCanonical->cbConnectionID);
    pMessage->ConnectionIdLenLsb = LSBOF(pCanonical->cbConnectionID);
    if (pCanonical->cbConnectionID)
    {
        CopyMemory( pBuffer,
                    pCanonical->ConnectionID,
                    pCanonical->cbConnectionID);

        pBuffer += pCanonical->cbConnectionID;
    }


    return( PCT_ERR_OK );

}


SP_STATUS
Ssl2UnpackServerHello(
    PSPBuffer          pInput,
    PSsl2_Server_Hello *     ppServer)
{
    PSsl2_Server_Hello       pCanonical;
    PSSL2_SERVER_HELLO   pMessage;
    PUCHAR              pBuffer;
    DWORD               cbCertificate;
    DWORD               cCipherSpecs;
    DWORD               cbConnId;
    DWORD               i;
    DWORD               ReportedSize;

    pMessage = pInput->pvBuffer;
    if(pInput->cbData < 2)
    {
        pInput->cbData = 2;
        return PCT_INT_INCOMPLETE_MSG;
    }

    ReportedSize = SIZEOF(pMessage);
    if ((ReportedSize+2) > pInput->cbData)
    {
        pInput->cbData = ReportedSize+2;
        return PCT_INT_INCOMPLETE_MSG;
    }


    if(ReportedSize <  SSL_OFFSET_OF(PSSL2_SERVER_HELLO, VariantData) )
    {
        return  SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }
    *ppServer = NULL;

    //
    // Verify Header:
    //

    if ((pMessage->MessageId != SSL2_MT_SERVER_HELLO) ||
        (pMessage->ServerVersionMsb != SSL2_SERVER_VERSION_MSB) ||
        (pMessage->ServerVersionLsb != SSL2_SERVER_VERSION_LSB) )
    {
        return  SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

    cbCertificate = COMBINEBYTES(   pMessage->CertificateLenMsb,
                                    pMessage->CertificateLenLsb);

    cCipherSpecs = COMBINEBYTES(pMessage->CipherSpecsLenMsb,
                                pMessage->CipherSpecsLenLsb);

    cCipherSpecs /= sizeof(Ssl2_Cipher_Tuple);

    cbConnId = COMBINEBYTES(pMessage->ConnectionIdLenMsb,
                            pMessage->ConnectionIdLenLsb);

    pCanonical = (PSsl2_Server_Hello)SPExternalAlloc(
                        sizeof(Ssl2_Server_Hello) +
                        cCipherSpecs * sizeof(Ssl2_Cipher_Kind)  +
                        cbCertificate );


    if (!pCanonical)
    {
        return(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
    }

    pCanonical->pCertificate = (PUCHAR) (pCanonical + 1);
    pCanonical->pCipherSpecs = (PCipherSpec) (pCanonical + 1);
    pCanonical->pCertificate = (PUCHAR) (pCanonical->pCipherSpecs + cCipherSpecs);



    //
    // Expand out:
    //

    pCanonical->SessionIdHit = (DWORD) pMessage->SessionIdHit;
    pCanonical->CertificateType = (DWORD) pMessage->CertificateType;
    pCanonical->cbCertificate = cbCertificate;
    pCanonical->cCipherSpecs = cCipherSpecs;
    pCanonical->cbConnectionID = cbConnId;

    pBuffer = pMessage->VariantData;

    CopyMemory(pCanonical->pCertificate, pBuffer, cbCertificate);
    pBuffer += cbCertificate;

    for (i = 0 ; i < cCipherSpecs ; i++ )
    {
        pCanonical->pCipherSpecs[i] = Ssl2MapCipherFromExternal((PSsl2_Cipher_Tuple)
                                                                pBuffer);

        pBuffer += sizeof(Ssl2_Cipher_Tuple);
    }

    if ((cbConnId) && (cbConnId <= SSL2_MAX_CONNECTION_ID_LEN))
    {
        CopyMemory(pCanonical->ConnectionID, pBuffer, cbConnId);
    }
    else
    {
        SPExternalFree(pCanonical);
        return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

    *ppServer = pCanonical;
    pInput->cbData = ReportedSize + sizeof(SSL2_MESSAGE_HEADER);
    return( PCT_ERR_OK);

}

SP_STATUS
Ssl2PackClientMasterKey(
    PSsl2_Client_Master_Key      pCanonical,
    PSPBuffer              pCommOutput)
{
    DWORD                   cbMessage;
    PSSL2_CLIENT_MASTER_KEY pMessage;
    PUCHAR                  pBuffer;

    cbMessage = pCanonical->ClearKeyLen +
                    pCanonical->EncryptedKeyLen +
                    pCanonical->KeyArgLen +
                    SSL_OFFSET_OF(PSSL2_CLIENT_MASTER_KEY, VariantData) -
                    sizeof(SSL2_MESSAGE_HEADER);

    pCommOutput->cbData = cbMessage + 2;

        /* are we allocating our own memory? */
    if(pCommOutput->pvBuffer == NULL)
    {
        pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
        if (NULL == pCommOutput->pvBuffer)
        {
            return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        }
        pCommOutput->cbBuffer = pCommOutput->cbData;
    }
    if(pCommOutput->cbData > pCommOutput->cbBuffer)
    {
        // Required buffer size returned in pCommOutput->cbData.
        return SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
    }
    pMessage = pCommOutput->pvBuffer;

    pBuffer = pMessage->VariantData;

    pMessage->Header.Byte0 = MSBOF(cbMessage) | 0x80;
    pMessage->Header.Byte1 = LSBOF(cbMessage);

    pMessage->MessageId = SSL2_MT_CLIENT_MASTER_KEY;
    Ssl2MapCipherToExternal(pCanonical->CipherKind, &pMessage->CipherKind);

    pMessage->ClearKeyLenMsb = MSBOF(pCanonical->ClearKeyLen);
    pMessage->ClearKeyLenLsb = LSBOF(pCanonical->ClearKeyLen);

    CopyMemory(pBuffer, pCanonical->ClearKey, pCanonical->ClearKeyLen);
    pBuffer += pCanonical->ClearKeyLen;

    pMessage->EncryptedKeyLenMsb = MSBOF(pCanonical->EncryptedKeyLen);
    pMessage->EncryptedKeyLenLsb = LSBOF(pCanonical->EncryptedKeyLen);

    CopyMemory(pBuffer, pCanonical->pbEncryptedKey, pCanonical->EncryptedKeyLen);
    pBuffer += pCanonical->EncryptedKeyLen;

    pMessage->KeyArgLenMsb = MSBOF(pCanonical->KeyArgLen);
    pMessage->KeyArgLenLsb = LSBOF(pCanonical->KeyArgLen);

    CopyMemory(pBuffer, pCanonical->KeyArg, pCanonical->KeyArgLen);

    return(PCT_ERR_OK);

}


SP_STATUS
Ssl2UnpackClientMasterKey(
    PSPBuffer              pInput,
    PSsl2_Client_Master_Key *    ppClient)
{
    PSsl2_Client_Master_Key  pCanonical;
    PSSL2_CLIENT_MASTER_KEY  pMessage;
    PUCHAR              pBuffer;
    DWORD               ReportedSize;
    DWORD               EncryptedKeyLen;

    pMessage = pInput->pvBuffer;

    if(pInput->cbData < 2)
    {
        pInput->cbData = 2;
        return PCT_INT_INCOMPLETE_MSG;
    }
    ReportedSize = SIZEOF(pMessage);

    if ((ReportedSize+2) > pInput->cbData)
    {
        pInput->cbData = ReportedSize+2;
        return PCT_INT_INCOMPLETE_MSG;
    }

    if(ReportedSize < SSL_OFFSET_OF(PSSL2_CLIENT_MASTER_KEY, VariantData))
    {
        return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

    *ppClient = NULL;

    if ((pMessage->MessageId != SSL2_MT_CLIENT_MASTER_KEY))
    {
        return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

    EncryptedKeyLen = COMBINEBYTES( pMessage->EncryptedKeyLenMsb,
                                    pMessage->EncryptedKeyLenLsb );

    pCanonical = (PSsl2_Client_Master_Key)SPExternalAlloc(
                            sizeof(Ssl2_Client_Master_Key) +
                            EncryptedKeyLen);

    if (!pCanonical)
    {
        return SP_LOG_RESULT( PCT_INT_INTERNAL_ERROR );
    }

    pCanonical->CipherKind = Ssl2MapCipherFromExternal( &pMessage->CipherKind );
    pCanonical->ClearKeyLen = COMBINEBYTES( pMessage->ClearKeyLenMsb,
                                            pMessage->ClearKeyLenLsb );

    pCanonical->EncryptedKeyLen = EncryptedKeyLen;

    pCanonical->KeyArgLen = COMBINEBYTES(   pMessage->KeyArgLenMsb,
                                            pMessage->KeyArgLenLsb );


    //
    // Validate
    //
    if ((pCanonical->ClearKeyLen > SSL2_MASTER_KEY_SIZE) ||
        (pCanonical->KeyArgLen > SSL2_MAX_KEY_ARGS))
    {
        SPExternalFree(pCanonical);
        return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }


    if ((SSL_OFFSET_OF(PSSL2_CLIENT_MASTER_KEY, VariantData) -
         sizeof(SSL2_MESSAGE_HEADER) +
         pCanonical->ClearKeyLen +
         pCanonical->EncryptedKeyLen +
         pCanonical->KeyArgLen ) !=
         ReportedSize)
    {
        SPExternalFree(pCanonical);
        return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

    pBuffer = pMessage->VariantData;

    CopyMemory(pCanonical->ClearKey, pBuffer, pCanonical->ClearKeyLen );

    pBuffer += pCanonical->ClearKeyLen;

    pCanonical->pbEncryptedKey = (PBYTE)(pCanonical + 1);
    CopyMemory(pCanonical->pbEncryptedKey, pBuffer, pCanonical->EncryptedKeyLen );

    pBuffer += pCanonical->EncryptedKeyLen;

    CopyMemory( pCanonical->KeyArg, pBuffer, pCanonical->KeyArgLen );

    *ppClient = pCanonical;

    return( PCT_ERR_OK );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\spbase\ssl2cli.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ssl2cli.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8-08-95   RichardW   Created
//
//----------------------------------------------------------------------------

#include <spbase.h>
#include <ssl2msg.h>
#include <ssl3msg.h>
#include <ssl2prot.h>



SP_STATUS WINAPI
Ssl2ClientProtocolHandler(
    PSPContext pContext,
    PSPBuffer pCommInput,
    PSPBuffer pCommOutput)
{
    SP_STATUS pctRet = 0;
    DWORD cMessageType;

    DWORD dwStateTransition;
    BOOL fRaw = TRUE;
    SPBuffer MsgInput;
    DWORD cbMsg;
    PUCHAR pb;
    UCHAR bCT;

    if (NULL != pCommOutput)
    {
        pCommOutput->cbData = 0;
    }

    MsgInput.pvBuffer = pCommInput->pvBuffer;
    MsgInput.cbBuffer = pCommInput->cbBuffer;
    MsgInput.cbData   = pCommInput->cbData;

    // In the following states, we should decrypt the message:
    switch(pContext->State)
    {
        case SSL2_STATE_CLIENT_MASTER_KEY:
        case SSL2_STATE_CLIENT_FINISH:
        case SSL2_STATE_CLIENT_RESTART:
            {
                DWORD cbHeader;
                DWORD cbPadding;

                if (MsgInput.cbData < 3)
                {
                    return PCT_INT_INCOMPLETE_MSG;
                }

                if(((PCHAR)pCommInput->pvBuffer)[0] & 0x80)
                {
                    cbHeader = 2 + pContext->pHashInfo->cbCheckSum;
                    cbPadding = 0;
                }
                else
                {
                    cbHeader = 3 + pContext->pHashInfo->cbCheckSum;

                    cbPadding = ((PCHAR)pCommInput->pvBuffer)[2];
                }

                (PUCHAR)MsgInput.pvBuffer += cbHeader;
                MsgInput.cbBuffer -= cbHeader;
                MsgInput.cbData -= (cbHeader+cbPadding);

                pctRet = Ssl2DecryptMessage(pContext, pCommInput, &MsgInput);

                if (pctRet != PCT_ERR_OK)
                {
                    // to handle incomplete message errors
                    return(pctRet);
                }

                cMessageType = ((PUCHAR) MsgInput.pvBuffer)[0];
                fRaw = FALSE;
                break;
            }

        case SP_STATE_SHUTDOWN:
        case SP_STATE_SHUTDOWN_PENDING:
            cMessageType = 0;
            break;

        default:
            if(pCommInput->cbData < 3) 
            {
                return PCT_INT_INCOMPLETE_MSG;
            }
            cMessageType = ((PUCHAR) MsgInput.pvBuffer)[2];
            break;
            
    }

    dwStateTransition = pContext->State | (cMessageType<<16);


    switch(dwStateTransition)
    {
        case SP_STATE_SHUTDOWN_PENDING:
            // There's no CloseNotify in SSL2, so just transition to
            // the shutdown state and leave the output buffer empty.
            pContext->State = SP_STATE_SHUTDOWN;
            break;    

        case SP_STATE_SHUTDOWN:
            return PCT_INT_EXPIRED;

        case (SSL2_MT_SERVER_HELLO << 16) | UNI_STATE_CLIENT_HELLO:
        case (SSL2_MT_SERVER_HELLO << 16) | SSL2_STATE_CLIENT_HELLO:
        {
            PSsl2_Server_Hello pHello;

            // Attempt to recognize and handle various versions of Server
            // hello, start by trying to unpickle the oldest, and the next
            // version, until one unpickles.  Then run the handle code.
            // We can also put unpickling and handling code in here for SSL
            // messages.

            pctRet = Ssl2UnpackServerHello(pCommInput, &pHello);
            if (PCT_ERR_OK == pctRet)
            {
                if (pHello->SessionIdHit)
                {
                    pctRet = Ssl2CliHandleServerRestart(
                                    pContext,
                                    pCommInput,
                                    pHello,
                                    pCommOutput);
                    if (PCT_ERR_OK == pctRet)
                    {
                        pContext->State = SSL2_STATE_CLIENT_RESTART;
                    }
                }
                else
                {
                    if(pContext->RipeZombie->hMasterKey != 0)
                    {
                        // We've attempted to do a reconnect and the server has
                        // blown us off. In this case we must use a new and different
                        // cache entry.
                        pContext->RipeZombie->ZombieJuju = FALSE;

                        if(!SPCacheClone(&pContext->RipeZombie))
                        {
                            pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
                        }
                    }
                
                    if (pctRet == PCT_ERR_OK)
                    {
                        pctRet = Ssl2CliHandleServerHello(
                                        pContext,
                                        pCommInput,
                                        pHello,
                                        pCommOutput);
                    }
                    if (PCT_ERR_OK == pctRet)
                    {
                        pContext->State = SSL2_STATE_CLIENT_MASTER_KEY;
                    }
                }
                SPExternalFree(pHello);
            }
            else if(pctRet != PCT_INT_INCOMPLETE_MSG)
            {
                pctRet |= PCT_INT_DROP_CONNECTION;
            }

            if (SP_FATAL(pctRet))
            {
                pContext->State = PCT1_STATE_ERROR;
            }
            break;
        }

        case (SSL2_MT_SERVER_VERIFY << 16) | SSL2_STATE_CLIENT_MASTER_KEY:
            pctRet = Ssl2CliHandleServerVerify(
                    pContext,
                    &MsgInput,
                    pCommOutput);
            if (PCT_ERR_OK == pctRet)
            {
                pContext->State =SSL2_STATE_CLIENT_FINISH;
            }
            if (SP_FATAL(pctRet))
            {
                pContext->State = PCT1_STATE_ERROR;
            }
            break;

        case (SSL2_MT_SERVER_VERIFY << 16) | SSL2_STATE_CLIENT_RESTART:
            pctRet = Ssl2CliFinishRestart(pContext, &MsgInput, pCommOutput);
            if (PCT_ERR_OK == pctRet)
            {
                pContext->State =SSL2_STATE_CLIENT_FINISH;
            }
            if (SP_FATAL(pctRet))
            {
                pContext->State = PCT1_STATE_ERROR;
            }

            // Note, we will transmit no data, but we expect a server finished message.
            // If the SSPI EXTRA DATA message is not processed by wininet
            // then we may be in trouble.

            break;

        case (SSL2_MT_SERVER_FINISHED_V2 << 16) | SSL2_STATE_CLIENT_FINISH:
            pctRet = Ssl2CliHandleServerFinish(
                                                pContext,
                                                &MsgInput,
                                                pCommOutput);
            if (SP_FATAL(pctRet))
            {
                pContext->State = PCT1_STATE_ERROR;
            }
            else
            {
                if (PCT_ERR_OK == pctRet)
                {
                    pContext->State = SP_STATE_CONNECTED;
                    pContext->DecryptHandler = Ssl2DecryptHandler;
                    pContext->Encrypt = Ssl2EncryptMessage;
                    pContext->Decrypt = Ssl2DecryptMessage;
                    pContext->GetHeaderSize = Ssl2GetHeaderSize;
                }
                // We received a non-fatal error, so the state doesn't
                // change, giving the app time to deal with this.
            }
            break;

        default:
            DebugLog((DEB_WARN, "Error in protocol, dwStateTransition is %lx\n", dwStateTransition));
            pContext->State = PCT1_STATE_ERROR;
            pctRet = SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
            break;
    }
    if (pctRet & PCT_INT_DROP_CONNECTION)
    {
        pContext->State &= ~SP_STATE_CONNECTED;
    }
    // To handle incomplete message errors:
    return(pctRet);
}




SP_STATUS
Ssl2CliHandleServerHello(
    PSPContext pContext,
    PSPBuffer  pCommInput,
    PSsl2_Server_Hello pHello,
    PSPBuffer  pCommOutput)
{
    /* error to return to peer */
    SP_STATUS          pctRet=PCT_ERR_ILLEGAL_MESSAGE;

    Ssl2_Client_Master_Key   Key;
    DWORD               i,j;
    PUCHAR              pPortionToEncrypt;
    PSessCacheItem      pZombie;

    pCommOutput->cbData = 0;


    SP_BEGIN("Ssl2CliHandleServerHello");


    pZombie = pContext->RipeZombie;

    do {


        pContext->ReadCounter++;

        #if DBG
        DebugLog((DEB_TRACE, "Hello = %x\n", pHello));
        DebugLog((DEB_TRACE, "   Session ID hit \t%s\n", pHello->SessionIdHit ? "Yes" : "No"));
        DebugLog((DEB_TRACE, "   Certificate Type\t%d\n", pHello->CertificateType));
        DebugLog((DEB_TRACE, "   Certificate Len\t%d\n", pHello->cbCertificate));
        DebugLog((DEB_TRACE, "   cCipherSpecs   \t%d\n", pHello->cCipherSpecs));
        DebugLog((DEB_TRACE, "   ConnectionId   \t%d\n", pHello->cbConnectionID));
        for (i = 0 ; i < pHello->cCipherSpecs ; i++ )
        {
            DebugLog((DEB_TRACE, "    Cipher[%i] = %06x (%s)\n", i, pHello->pCipherSpecs[i],
                                    DbgGetNameOfCrypto(pHello->pCipherSpecs[i]) ));
        }
        #endif

        /* Cycle throug the array of cipher tuples to spec mappings
         * to find one that we support */

        pContext->pCipherInfo  = NULL;
        pContext->pHashInfo    = NULL;
        pContext->pKeyExchInfo = NULL;

        for(j=0;j<pHello->cCipherSpecs;j++) 
        {
            for(i = 0; i < UniNumCiphers; i++)
            {
                if(UniAvailableCiphers[i].CipherKind == pHello->pCipherSpecs[j])
                {
                    break;
                }
            }
            if(i >= UniNumCiphers)
            {
                continue;
            }
            if(UniAvailableCiphers[i].CipherKind != pHello->pCipherSpecs[j])
            {
                continue;
            }

            // Some servers send SSL3 cipher suites in the ServerHello 
            // message. Skip over these.
            if((UniAvailableCiphers[i].fProt & SP_PROT_SSL2_CLIENT) == 0)
            {
                continue;
            }

            // Copy all of the spec's to the cache
            pZombie->fProtocol    = SP_PROT_SSL2_CLIENT;
            pZombie->aiCipher     = UniAvailableCiphers[i].aiCipher;
            pZombie->dwStrength   = UniAvailableCiphers[i].dwStrength;
            pZombie->aiHash       = UniAvailableCiphers[i].aiHash;
            pZombie->SessExchSpec = UniAvailableCiphers[i].KeyExch;

            pctRet = ContextInitCiphersFromCache(pContext);

            if(pctRet != PCT_ERR_OK)
            {
                continue;
            }
            
            Key.CipherKind = pHello->pCipherSpecs[j];
            break;
        }

        // Go ahead and initialize the ciphers
        pctRet = ContextInitCiphers(pContext, TRUE, TRUE);
        if(pctRet != PCT_ERR_OK)
        {
            break;
        }


        pctRet = SPLoadCertificate(pZombie->fProtocol, 
                                   pHello->CertificateType, 
                                   pHello->pCertificate, 
                                   pHello->cbCertificate,
                                   &pZombie->pRemoteCert);

                                 
                                 

        if(pctRet != PCT_ERR_OK)
        {
            break;
        }
        if(pContext->RipeZombie->pRemotePublic != NULL)
        {
            SPExternalFree(pContext->RipeZombie->pRemotePublic);
            pContext->RipeZombie->pRemotePublic = NULL;
        }

        pctRet = SPPublicKeyFromCert(pZombie->pRemoteCert,
                                     &pZombie->pRemotePublic,
                                     NULL);

        if(PCT_ERR_OK != pctRet)
        {
            break;
        }

        // Automatically validate server certificate if appropriate 
        // context flag is set.
        pctRet = AutoVerifyServerCertificate(pContext);
        if(pctRet != PCT_ERR_OK)
        {
            SP_LOG_RESULT(pctRet);
            break;
        }

        // Generate Key Args
        if(pContext->pCipherInfo->dwBlockSize > 1)
        {
            GenerateRandomBits(pZombie->pKeyArgs, pContext->pCipherInfo->dwBlockSize);
            pZombie->cbKeyArgs = Key.KeyArgLen = pContext->pCipherInfo->dwBlockSize;

            /* Copy over the key args */
            CopyMemory(Key.KeyArg,
                        pZombie->pKeyArgs,
                        pZombie->cbKeyArgs );
        }
        else
        {    
            Key.KeyArgLen = 0;
        }

        CopyMemory(pContext->pConnectionID, pHello->ConnectionID, pHello->cbConnectionID);
        pContext->cbConnectionID = pHello->cbConnectionID;


        pctRet = pContext->pKeyExchInfo->System->GenerateClientExchangeValue(
                            pContext,
                            NULL,
                            0, 
                            Key.ClearKey,
                            &Key.ClearKeyLen,
                            NULL,
                            &Key.EncryptedKeyLen);
        if(PCT_ERR_OK != pctRet)
        {
            break;
        }

        Key.pbEncryptedKey = SPExternalAlloc(Key.EncryptedKeyLen);
        if(Key.pbEncryptedKey == NULL)
        {
            pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            break;
        }

        pctRet = pContext->pKeyExchInfo->System->GenerateClientExchangeValue(
                            pContext,
                            NULL,
                            0, 
                            Key.ClearKey,
                            &Key.ClearKeyLen,
                            Key.pbEncryptedKey,
                            &Key.EncryptedKeyLen);
        if(PCT_ERR_OK != pctRet)
        {
            SPExternalFree(Key.pbEncryptedKey);
            break;
        }

        // Activate session keys.
        pContext->hReadKey          = pContext->hPendingReadKey;
        pContext->hWriteKey         = pContext->hPendingWriteKey;
        pContext->hPendingReadKey   = 0;
        pContext->hPendingWriteKey  = 0;


        pctRet = Ssl2PackClientMasterKey(&Key, pCommOutput);

        SPExternalFree(Key.pbEncryptedKey);

        if(PCT_ERR_OK != pctRet)
        {
            break;
        }

        pContext->WriteCounter++;
        SP_RETURN(PCT_ERR_OK);
    } while(TRUE);

    if((pContext->Flags & CONTEXT_FLAG_EXT_ERR) &&
        (pctRet == PCT_ERR_SPECS_MISMATCH))
    {
        // Our SSL2 implementation does not do client auth,
        // so there is only one error message, cipher error.
        pCommOutput->cbData = 3; // MSG-ERROR + ERROR-CODE-MSB + ERROR-CODE-LSB

        if(pCommOutput->pvBuffer == NULL) 
        {
            pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
            if (NULL == pCommOutput->pvBuffer)
            {
                SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
            }
            pCommOutput->cbBuffer = pCommOutput->cbData;
        }
        if(pCommOutput->cbData > pCommOutput->cbBuffer)
        {
            // Required buffer size returned in pCommOutput->cbData.
            SP_RETURN(SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL));
        }
        ((PUCHAR)pCommOutput->pvBuffer)[0] = SSL2_MT_ERROR;
        ((PUCHAR)pCommOutput->pvBuffer)[1] = MSBOF(SSL_PE_NO_CIPHER);
        ((PUCHAR)pCommOutput->pvBuffer)[2] = LSBOF(SSL_PE_NO_CIPHER);
    }
    SP_RETURN(pctRet | PCT_INT_DROP_CONNECTION);

}

SP_STATUS
Ssl2CliHandleServerRestart(
    PSPContext         pContext,
    PSPBuffer           pCommInput,
    PSsl2_Server_Hello  pHello,
    PSPBuffer           pCommOutput)
{
    /* error to return to peer */
    SP_STATUS          pctRet=PCT_ERR_ILLEGAL_MESSAGE;
    PSessCacheItem     pZombie;

    pCommOutput->cbData = 0;


    SP_BEGIN("Ssl2CliHandleServerRestart");

    pZombie = pContext->RipeZombie;

    do {
        pContext->ReadCounter++;


        /* if there's no zombie, the message is wrong.  We can't restart. */
        
        if(pZombie == NULL)
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
            break;
        }

        if(!pZombie->hMasterKey)
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
            break;
        }

        if(!pZombie->ZombieJuju)
        {
            DebugLog((DEB_WARN, "Session expired on client machine, but not on server.\n"));
        }
        
        CopyMemory(pContext->pConnectionID,
                   pHello->ConnectionID,
                   pHello->cbConnectionID);

        pContext->cbConnectionID = pHello->cbConnectionID;


        /* Cert length, Cipher Specs, and Cert Type should be zero */

        // We know what our ciphers are, so init the cipher system
        pctRet = ContextInitCiphersFromCache(pContext);

        if(PCT_ERR_OK != pctRet)
        {
            break;
        }

        pctRet = ContextInitCiphers(pContext, TRUE, TRUE);

        if(PCT_ERR_OK != pctRet)
        {
            break;
        }

        // Make a new set of session keys.
        pctRet = MakeSessionKeys(pContext,
                                 pContext->RipeZombie->hMasterProv,
                                 pContext->RipeZombie->hMasterKey);
        if(PCT_ERR_OK != pctRet)
        {
            break;
        }

        // Activate session keys.
        pContext->hReadKey          = pContext->hPendingReadKey;
        pContext->hWriteKey         = pContext->hPendingWriteKey;
        pContext->hPendingReadKey   = 0;
        pContext->hPendingWriteKey  = 0;

        /* okay, now send the client finish */
        pctRet = Ssl2GenCliFinished(pContext, pCommOutput);

        SP_RETURN(pctRet);
    } while(TRUE);

    SP_RETURN(pctRet | PCT_INT_DROP_CONNECTION);
}


SP_STATUS
Ssl2GenCliFinished(
    PSPContext pContext,
    PSPBuffer  pCommOutput)
{
    SP_STATUS     pctRet = PCT_ERR_ILLEGAL_MESSAGE;

    PSSL2_SERVER_VERIFY     pVerify = NULL;
    PSSL2_CLIENT_FINISHED   pFinish;
    DWORD                   HeaderSize;
    SPBuffer                MsgOutput;
    DWORD                   cPadding;
    BOOL                    fAlloced=FALSE;

    SP_BEGIN("Ssl2GenCliFinished");



    pCommOutput->cbData = 0;

    MsgOutput.cbData = sizeof(UCHAR) + pContext->cbConnectionID;
    cPadding = ((MsgOutput.cbData+pContext->pHashInfo->cbCheckSum) % pContext->pCipherInfo->dwBlockSize);
    if(cPadding)
    {
        cPadding = pContext->pCipherInfo->dwBlockSize - cPadding;
    }

    HeaderSize = (cPadding?3:2);

    pCommOutput->cbData = MsgOutput.cbData +
                          pContext->pHashInfo->cbCheckSum +
                          cPadding +
                          HeaderSize;

    /* are we allocating our own memory? */
    if(pCommOutput->pvBuffer == NULL)
    {
        pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);

        if (NULL == pCommOutput->pvBuffer)
        {
            SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
        }
        fAlloced = TRUE;
        pCommOutput->cbBuffer = pCommOutput->cbData;
    }

    if(pCommOutput->cbData > pCommOutput->cbBuffer)
    {
        // Required buffer size returned in pCommOutput->cbData.
        SP_RETURN(SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL));
    }
    MsgOutput.pvBuffer= (PUCHAR)pCommOutput->pvBuffer +
                        HeaderSize +
                        pContext->pHashInfo->cbCheckSum;

    MsgOutput.cbBuffer = pCommOutput->cbBuffer -
                         (pContext->pHashInfo->cbCheckSum + HeaderSize);


    pFinish = (PSSL2_CLIENT_FINISHED) MsgOutput.pvBuffer;
    pFinish->MessageId = SSL2_MT_CLIENT_FINISHED_V2;

    CopyMemory( pFinish->ConnectionID,
                pContext->pConnectionID,
                pContext->cbConnectionID );

    pctRet = Ssl2EncryptMessage( pContext, &MsgOutput, pCommOutput);
    if(PCT_ERR_OK != pctRet)
    {
        SPExternalFree(pCommOutput->pvBuffer);
        pCommOutput->pvBuffer = NULL;
        pctRet |= PCT_INT_DROP_CONNECTION;
        pCommOutput->cbBuffer = 0;
    }

    SP_RETURN(pctRet);

}


SP_STATUS
Ssl2CliHandleServerVerify(
    PSPContext pContext,
    PSPBuffer   pCommInput,
    PSPBuffer   pCommOutput)
{
    SP_STATUS     pctRet = PCT_ERR_ILLEGAL_MESSAGE;

    PSSL2_SERVER_VERIFY     pVerify = NULL;

    /* Read and Write Counters are incremented by the encrypt and decrypt */
    SP_BEGIN("Ssl2CliHandleServerVerify");



    pCommOutput->cbData = 0;

    /* Note, there is no header in this message, as it has been pre-decrypted */
    if(pCommInput->cbData != sizeof(UCHAR) + pContext->cbChallenge)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    pVerify = pCommInput->pvBuffer;

    if (pVerify->MessageId != SSL2_MT_SERVER_VERIFY)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    if (memcmp( pVerify->ChallengeData,
                pContext->pChallenge,
                pContext->cbChallenge) )
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }


    pctRet = Ssl2GenCliFinished( pContext, pCommOutput);
    SP_RETURN(pctRet);
}

SP_STATUS
Ssl2CliFinishRestart(
    PSPContext pContext,
    PSPBuffer   pCommInput,
    PSPBuffer   pCommOutput)
{
    SP_STATUS     pctRet = PCT_ERR_ILLEGAL_MESSAGE;

    PSSL2_SERVER_VERIFY     pVerify = NULL;

    /* Read and Write Counters are incremented by the encrypt and decrypt */
    SP_BEGIN("Ssl2CliFinishRestart");



    pCommOutput->cbData = 0;

    /* Note, there is no header in this message, as it has been pre-decrypted */
    if(pCommInput->cbData != sizeof(UCHAR) + pContext->cbChallenge)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    pVerify = pCommInput->pvBuffer;

    if (pVerify->MessageId != SSL2_MT_SERVER_VERIFY)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    if (memcmp( pVerify->ChallengeData,
                pContext->pChallenge,
                pContext->cbChallenge) )
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }
    SP_RETURN(PCT_ERR_OK);
}

SP_STATUS
Ssl2CliHandleServerFinish(
    PSPContext pContext,
    PSPBuffer  pCommInput,
    PSPBuffer  pCommOutput)
{
    SP_STATUS     pctRet = PCT_ERR_ILLEGAL_MESSAGE;

    PSSL2_SERVER_FINISHED     pFinished = NULL;

    SP_BEGIN("Ssl2CliHandleServerFinish");



    pCommOutput->cbData = 0;


    /* Note, there is no header in this message, as it has been pre-decrypted */
    if(pCommInput->cbData < sizeof(UCHAR))
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    pFinished = pCommInput->pvBuffer;

    if (pFinished->MessageId != SSL2_MT_SERVER_FINISHED_V2)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    if((pCommInput->cbData-1) != SSL2_SESSION_ID_LEN)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }
    CopyMemory( pContext->RipeZombie->SessionID,
                pFinished->SessionID,
                pCommInput->cbData - 1);
    pContext->RipeZombie->cbSessionID = pCommInput->cbData - 1;

    SPCacheAdd(pContext);

    SP_RETURN(PCT_ERR_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\spbase\ssl2msg.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ssl2msg.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10-21-97   jbanes   Added CAPI integration
//
//----------------------------------------------------------------------------

#include <spbase.h>

#if 0
Ssl2CipherMap Ssl2CipherRank[] = 
{
    {SSL_CK_RC4_128_WITH_MD5,              CALG_MD5, CALG_RC4,  128, SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX},
    {SSL_CK_DES_192_EDE3_CBC_WITH_MD5,     CALG_MD5, CALG_3DES, 168, SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX},
    {SSL_CK_RC2_128_CBC_WITH_MD5,          CALG_MD5, CALG_RC2,  128, SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX},
    {SSL_CK_RC4_128_FINANCE64_WITH_MD5,    CALG_MD5, CALG_RC4,   64, SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX},
    {SSL_CK_DES_64_CBC_WITH_MD5,           CALG_MD5, CALG_DES,   56, SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX},
    {SSL_CK_RC4_128_EXPORT40_WITH_MD5,     CALG_MD5, CALG_RC4,   40, SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX},
    {SSL_CK_RC2_128_CBC_EXPORT40_WITH_MD5, CALG_MD5, CALG_RC2,   40, SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX}
};
DWORD Ssl2NumCipherRanks = sizeof(Ssl2CipherRank)/sizeof(Ssl2CipherMap);
#endif


CertTypeMap aSsl2CertEncodingPref[] =
{
    { X509_ASN_ENCODING, 0}
};

DWORD cSsl2CertEncodingPref = sizeof(aSsl2CertEncodingPref)/sizeof(CertTypeMap);


SP_STATUS WINAPI
Ssl2DecryptHandler(
    PSPContext pContext,
    PSPBuffer pCommInput,
    PSPBuffer pAppOutput)
{
    SP_STATUS pctRet = PCT_ERR_OK;

    if (pCommInput->cbData > 0)
    {
        // First, we'll handle incoming data packets:

        if ((pContext->State & SP_STATE_CONNECTED) && pContext->Decrypt)
        {
            pctRet = pContext->Decrypt(
                            pContext,
                            pCommInput,  // message
                            pAppOutput);    // Unpacked Message
            if (PCT_ERR_OK == pctRet)
            {
                /* look for escapes */
            }
            return(pctRet);
        }
        else
        {
            return(SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG));
        }
    }
    return (PCT_INT_INCOMPLETE_MSG);
}

//+---------------------------------------------------------------------------
//
//  Function:   Ssl2ComputeMac
//
//  Synopsis:   Compute an SSL2 message MAC.
//
//  Arguments:  [pContext]          --  Schannel context.
//
//  History:    10-22-97   jbanes   Created.
//
//  Notes:      MAC_DATA := Hash(key + data + sequence_number)
//
//----------------------------------------------------------------------------
static SP_STATUS
Ssl2ComputeMac(
    PSPContext pContext,    // in
    BOOL       fWriteMAC,   // in
    DWORD      dwSequence,  // in
    PSPBuffer  pData,       // in
    PBYTE      pbMac,       // out
    DWORD      cbMac)       // in
{
    DWORD       dwReverseSequence;
    BYTE        rgbSalt[SP_MAX_MASTER_KEY];
    DWORD       cbSalt;
    HCRYPTHASH  hHash;
    HCRYPTKEY   hKey;

    // Make sure output buffer is big enough.
    if(cbMac < pContext->pHashInfo->cbCheckSum)
    {
        return SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
    }

    dwReverseSequence = htonl(dwSequence);

    hKey = fWriteMAC ? pContext->hWriteKey : pContext->hReadKey;

    if(!SchCryptCreateHash(pContext->RipeZombie->hMasterProv,
                           pContext->pHashInfo->aiHash,
                           0,
                           0,
                           &hHash,
                           pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        SP_RETURN(PCT_INT_INTERNAL_ERROR);
    }

    if(!SchCryptHashSessionKey(hHash, 
                               hKey, 
                               CRYPT_LITTLE_ENDIAN,
                               pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags);
        SP_RETURN(PCT_INT_INTERNAL_ERROR);
    }
    cbSalt = sizeof(rgbSalt);
    if(!SchCryptGetKeyParam(hKey, 
                            KP_SALT, 
                            rgbSalt, 
                            &cbSalt, 
                            0, 
                            pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags);
        SP_RETURN(PCT_INT_INTERNAL_ERROR);
    }
    if(!SchCryptHashData(hHash, rgbSalt, cbSalt, 0, pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags);
        SP_RETURN(PCT_INT_INTERNAL_ERROR);
    }

    if(!SchCryptHashData(hHash, 
                         pData->pvBuffer, 
                         pData->cbData, 
                         0, 
                         pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags);
        SP_RETURN(PCT_INT_INTERNAL_ERROR);
    }

    if(!SchCryptHashData(hHash, 
                         (PBYTE)&dwReverseSequence, 
                         sizeof(DWORD), 
                         0, 
                         pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags);
        SP_RETURN(PCT_INT_INTERNAL_ERROR);
    }

    if(!SchCryptGetHashParam(hHash, 
                             HP_HASHVAL, 
                             pbMac, 
                             &cbMac, 
                             0,
                             pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags);
        SP_RETURN(PCT_INT_INTERNAL_ERROR);
    }

    SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags);

    return PCT_ERR_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   Ssl2EncryptMessage
//
//  Synopsis:   Encode a block of data as an SSL2 record.
//
//  Arguments:  [pContext]      --  Schannel context.
//              [pAppInput]     --  Data to be encrypted.
//              [pCommOutput]   --  (output) Completed SSL2 record.
//
//  History:    10-22-97   jbanes   CAPI integrated.
//
//  Notes:      An SSL2 record is usually formatted as:
//
//                  BYTE header[2];
//                  BYTE mac[mac_size];
//                  BYTE data[pAppInput->cbData];
//
//              If a block cipher is used, and the data to be encrypted
//              consists of a partial number of blocks, then the following
//              format is used:
//
//                  BYTE header[3];
//                  BYTE mac[mac_size];
//                  BYTE data[pAppInput->cbData];
//                  BYTE padding[padding_size];
//
//----------------------------------------------------------------------------
SP_STATUS WINAPI
Ssl2EncryptMessage( 
    PSPContext     pContext,
    PSPBuffer      pAppInput,
    PSPBuffer      pCommOutput)
{
    SP_STATUS                  pctRet;
    DWORD                      cPadding, cPad2;
    SPBuffer                   Clean;    
    SPBuffer                   Encrypted;

    DWORD                      ReverseSequence;
    
    SP_BEGIN("Ssl2EncryptMessage");

    /* Estimate if we have padding or not */
    Encrypted.cbData = pAppInput->cbData + pContext->pHashInfo->cbCheckSum;
    cPadding = (Encrypted.cbData % pContext->pCipherInfo->dwBlockSize);
    if(cPadding)
    {
        cPadding = pContext->pCipherInfo->dwBlockSize - cPadding;
    }

    Encrypted.cbData += cPadding;

    if(cPadding) 
    {
        if(pCommOutput->cbBuffer + Encrypted.cbData + cPadding < 3)
        {
            SP_RETURN(SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL));
        }
        Encrypted.pvBuffer = (PUCHAR)pCommOutput->pvBuffer + 3;
        Encrypted.cbBuffer = pCommOutput->cbBuffer - 3;
    } 
    else 
    {
        if(pCommOutput->cbBuffer + Encrypted.cbData + cPadding < 2)
        {
            SP_RETURN(SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL));
        }
        Encrypted.pvBuffer = (PUCHAR)pCommOutput->pvBuffer + 2;
        Encrypted.cbBuffer = pCommOutput->cbBuffer - 2;
    }
    
    DebugLog((DEB_TRACE, "Sealing message %x\n", pContext->WriteCounter));


    /* Move data out of the way if necessary */
    if((PUCHAR)Encrypted.pvBuffer + pContext->pHashInfo->cbCheckSum != pAppInput->pvBuffer) 
    {
        DebugLog((DEB_WARN, "SSL2EncryptMessage: Unnecessary Move, performance hog\n"));
        /* if caller wasn't being smart, then we must copy memory here */
        MoveMemory((PUCHAR)Encrypted.pvBuffer + pContext->pHashInfo->cbCheckSum, 
                   pAppInput->pvBuffer,
                   pAppInput->cbData); 
    }

    // Initialize pad
    if(cPadding)
    {
        FillMemory((PUCHAR)Encrypted.pvBuffer + pContext->pHashInfo->cbCheckSum + pAppInput->cbData, cPadding, 0);
    }

    // Compute MAC.
    Clean.pvBuffer = (PBYTE)Encrypted.pvBuffer + pContext->pHashInfo->cbCheckSum;
    Clean.cbData   = Encrypted.cbData - pContext->pHashInfo->cbCheckSum;
    Clean.cbBuffer = Clean.cbData;

    pctRet = Ssl2ComputeMac(pContext,
                            TRUE,
                            pContext->WriteCounter,
                            &Clean,
                            Encrypted.pvBuffer,
                            pContext->pHashInfo->cbCheckSum);
    if(pctRet != PCT_ERR_OK)
    {
        SP_RETURN(pctRet);
    }

    // Encrypt buffer.
    if(!SchCryptEncrypt(pContext->hWriteKey,
                        0, FALSE, 0,
                        Encrypted.pvBuffer,
                        &Encrypted.cbData,
                        Encrypted.cbBuffer,
                        pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        SP_RETURN(PCT_INT_INTERNAL_ERROR);
    }

    /* set sizes */
    if(cPadding) 
    {
        if(Encrypted.cbData > 0x3fff)
        {
            SP_RETURN(SP_LOG_RESULT(PCT_INT_DATA_OVERFLOW));
        }

        ((PUCHAR)pCommOutput->pvBuffer)[0]= (UCHAR)(0x3f & (Encrypted.cbData>>8));
        ((PUCHAR)pCommOutput->pvBuffer)[1]= (UCHAR)(0xff & Encrypted.cbData);
        ((PUCHAR)pCommOutput->pvBuffer)[2]= (UCHAR)cPadding;

    } 
    else 
    {
        if(Encrypted.cbData > 0x7fff) 
        {
            SP_RETURN(SP_LOG_RESULT(PCT_INT_DATA_OVERFLOW));
        }
        ((PUCHAR)pCommOutput->pvBuffer)[0]= (UCHAR)(0x7f & (Encrypted.cbData>>8)) | 0x80;
        ((PUCHAR)pCommOutput->pvBuffer)[1]= (UCHAR)(0xff & Encrypted.cbData);
    }

    pCommOutput->cbData = Encrypted.cbData + (cPadding?3:2);

    pContext->WriteCounter ++ ;

    SP_RETURN( PCT_ERR_OK );
}

SP_STATUS WINAPI
Ssl2GetHeaderSize(
    PSPContext pContext,
    PSPBuffer pCommInput,
    DWORD * pcbHeaderSize)
{
    if(pcbHeaderSize == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }
    if(pCommInput->cbData < 1)
    {
        return (PCT_INT_INCOMPLETE_MSG);
    }
    if(  ((PUCHAR)pCommInput->pvBuffer)[0]&0x80 )
    {
        *pcbHeaderSize = 2 + pContext->pHashInfo->cbCheckSum;
    }
    else
    {
        *pcbHeaderSize = 3 + pContext->pHashInfo->cbCheckSum;
    }
    return PCT_ERR_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   Ssl2DecryptMessage
//
//  Synopsis:   Decode an SSL2 record.
//
//  Arguments:  [pContext]      --  Schannel context.
//              [pMessage]      --  Data from the remote party.
//              [pAppOutput]    --  (output) Decrypted data.
//
//  History:    10-22-97   jbanes   CAPI integrated.
//
//  Notes:      An SSL2 record is usually formatted as:
//
//                  BYTE header[2];
//                  BYTE mac[mac_size];
//                  BYTE data[pAppInput->cbData];
//
//              If a block cipher is used, and the data to be encrypted
//              consists of a partial number of blocks, then the following
//              format is used:
//
//                  BYTE header[3];
//                  BYTE mac[mac_size];
//                  BYTE data[pAppInput->cbData];
//                  BYTE padding[padding_size];
//
//              The number of input data bytes consumed by this function
//              is returned in pMessage->cbData.
//              
//----------------------------------------------------------------------------
SP_STATUS WINAPI
Ssl2DecryptMessage( 
    PSPContext         pContext,
    PSPBuffer          pMessage,
    PSPBuffer          pAppOutput)
{
    SP_STATUS   pctRet;
    DWORD       cPadding;
    DWORD       dwLength;
    SPBuffer    Encrypted;
    SPBuffer    Clean;
    DWORD       cbActualData;
    UCHAR       Digest[SP_MAX_DIGEST_LEN];

    SP_BEGIN("Ssl2DecryptMessage");

    /* First determine the length of data, the length of padding,
     * and the location of data, and the location of MAC */
    cbActualData = pMessage->cbData;
    pMessage->cbData = 2; /* minimum amount of data we need */
    
    if(pMessage->cbData > cbActualData) 
    {
        SP_RETURN(PCT_INT_INCOMPLETE_MSG);
    }
    DebugLog((DEB_TRACE, "  Incomming Buffer: %lx, size %ld (%lx)\n", pMessage->pvBuffer, cbActualData, cbActualData));

    if(((PUCHAR)pMessage->pvBuffer)[0] & 0x80)
    {
        /* 2 byte header */
        cPadding = 0;
        dwLength = ((((PUCHAR)pMessage->pvBuffer)[0] & 0x7f) << 8) | 
                   ((PUCHAR)pMessage->pvBuffer)[1];

        Encrypted.pvBuffer = (PUCHAR)pMessage->pvBuffer + 2;
        Encrypted.cbBuffer = pMessage->cbBuffer - 2;
    } 
    else 
    {
        pMessage->cbData++;
        if(pMessage->cbData > cbActualData) 
        {
            SP_RETURN(PCT_INT_INCOMPLETE_MSG);
        }

        /* 3 byte header */
        cPadding = ((PUCHAR)pMessage->pvBuffer)[2];
        dwLength = ((((PUCHAR)pMessage->pvBuffer)[0] & 0x3f) << 8) | 
                   ((PUCHAR)pMessage->pvBuffer)[1];

        Encrypted.pvBuffer = (PUCHAR)pMessage->pvBuffer + 3;
        Encrypted.cbBuffer = pMessage->cbBuffer - 3;
    }

    /* Now we know how mutch data we will eat, so set cbData on the Input to be that size */
    pMessage->cbData += dwLength;

    /* do we have enough bytes for the reported data */
    if(pMessage->cbData > cbActualData) 
    {
        SP_RETURN(PCT_INT_INCOMPLETE_MSG);
    }

    /* do we have enough data for our checksum */
    if(dwLength < pContext->pHashInfo->cbCheckSum) 
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_MSG_ALTERED));
    }

    Encrypted.cbData   = dwLength;    /* encrypted data size */
    Encrypted.cbBuffer = Encrypted.cbData;

    /* check to see if we have a block size violation */
    if(Encrypted.cbData % pContext->pCipherInfo->dwBlockSize) 
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_MSG_ALTERED));
    }

    /* Decrypt */
    if(!SchCryptDecrypt(pContext->hReadKey,
                        0, FALSE, 0,
                        Encrypted.pvBuffer,
                        &Encrypted.cbData,
                        pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        SP_RETURN(PCT_INT_INTERNAL_ERROR);
    }

    // Compute MAC.
    Clean.pvBuffer = (PBYTE)Encrypted.pvBuffer + pContext->pHashInfo->cbCheckSum;
    Clean.cbData   = Encrypted.cbData - pContext->pHashInfo->cbCheckSum;
    Clean.cbBuffer = Clean.cbData;

    pctRet = Ssl2ComputeMac(pContext,
                            FALSE,
                            pContext->ReadCounter,
                            &Clean,
                            Digest,
                            sizeof(Digest));
    if(pctRet != PCT_ERR_OK)
    {
        SP_RETURN(pctRet);
    }

    // the padding is computed in the hash but is not needed after this
    Clean.cbData  -= cPadding;

    DebugLog((DEB_TRACE, "Unsealing message %x\n", pContext->ReadCounter));

    pContext->ReadCounter++;

    if(memcmp(Digest, Encrypted.pvBuffer, pContext->pHashInfo->cbCheckSum ) )
    {
       SP_RETURN(SP_LOG_RESULT(PCT_INT_MSG_ALTERED));
    }

    if(pAppOutput->pvBuffer != Clean.pvBuffer) 
    {
        DebugLog((DEB_WARN, "SSL2DecryptMessage: Unnecessary Move, performance hog\n"));
        MoveMemory(pAppOutput->pvBuffer, 
                   Clean.pvBuffer, 
                   Clean.cbData); 
    }
    pAppOutput->cbData = Clean.cbData;
    DebugLog((DEB_TRACE, "  TotalData: size %ld (%lx)\n", pMessage->cbData, pMessage->cbData));

    SP_RETURN( PCT_ERR_OK );
}

#if 0
SP_STATUS
Ssl2MakeMasterKeyBlock(PSPContext pContext)
{

    MD5_CTX     Md5Hash;
    UCHAR       cSalt;
    UCHAR       ib;


    //pContext->RipeZombe->pMasterKey containst the master secret.

#if DBG
    DebugLog((DEB_TRACE, "  Master Secret\n"));
    DBG_HEX_STRING(DEB_TRACE,pContext->RipeZombie->pMasterKey, pContext->RipeZombie->cbMasterKey);

#endif

    for(ib=0 ; ib<3 ; ib++)
    {
        // MD5(master_secret + SHA-hash)
        MD5Init  (&Md5Hash);
        MD5Update(&Md5Hash, pContext->RipeZombie->pMasterKey, pContext->RipeZombie->cbMasterKey);

        // We're going to be bug-for-bug compatable with netscape, so
        // we always add the digit into the hash, instead of following
        // the spec which says don't add the digit for DES
        //if(pContext->RipeZombie->aiCipher != CALG_DES)
        {
            cSalt = ib+'0';
            MD5Update(&Md5Hash, &cSalt, 1);
        }
        MD5Update(&Md5Hash, pContext->pChallenge, pContext->cbChallenge);
        MD5Update(&Md5Hash, pContext->pConnectionID, pContext->cbConnectionID);
        MD5Final (&Md5Hash);
        CopyMemory(pContext->Ssl3MasterKeyBlock + ib * MD5DIGESTLEN, Md5Hash.digest, MD5DIGESTLEN);
    }
 #if DBG
    DebugLog((DEB_TRACE, "  Master Key Block\n"));
    DBG_HEX_STRING(DEB_TRACE,pContext->Ssl3MasterKeyBlock, MD5DIGESTLEN*3);

#endif
   return( PCT_ERR_OK );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\spbase\ssl3msg.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ssl3msg.c
//
//  Contents:   Main crypto functions for SSL3.
//
//  Classes:
//
//  Functions:
//
//  History:    04-16-96   ramas    Created.
//
//----------------------------------------------------------------------------

#include <spbase.h>

#if VERIFYHASH
BYTE  rgbF[5000];
DWORD ibF = 0;
#endif


//------------------------------------------------------------------------------------------

SP_STATUS WINAPI
Ssl3DecryptHandler(
    PSPContext pContext,
    PSPBuffer pCommInput,
    PSPBuffer pAppOutput)
{
    SP_STATUS pctRet = PCT_ERR_OK;

    if(pCommInput->cbData == 0)
    {
        return PCT_INT_INCOMPLETE_MSG;
    }

    if(!(pContext->State & SP_STATE_CONNECTED) || pContext->Decrypt == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
    }

    switch(*(PBYTE)pCommInput->pvBuffer)
    {
    case SSL3_CT_HANDSHAKE:
        if(pContext->RipeZombie->fProtocol & SP_PROT_CLIENTS)
        {
            // This should be a HelloRequest message. We should make sure, and
            // then completely consume the message.
            pctRet = pContext->Decrypt( pContext,
                                        pCommInput,  // message
                                        pAppOutput);    // Unpacked Message
            if(PCT_ERR_OK != pctRet)
            {
                return pctRet;
            }

            if(*(PBYTE)pAppOutput->pvBuffer != SSL3_HS_HELLO_REQUEST ||
               pAppOutput->cbData != sizeof(SHSH))
            {
                // This ain't no HelloRequest!
                return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
            }
        }
        else
        {
            // This is probably a ClientHello message. In any case, let the
            // caller deal with it (by passing it to the LSA process).
            pCommInput->cbData = 0;
        }

        pAppOutput->cbData = 0;

        pContext->State = SSL3_STATE_RENEGOTIATE;
        return SP_LOG_RESULT(PCT_INT_RENEGOTIATE);


    case SSL3_CT_ALERT:
        pctRet = pContext->Decrypt( pContext,
                                    pCommInput,
                                    pAppOutput);
        if(PCT_ERR_OK != pctRet)
        {
            return pctRet;
        }

        pctRet = ParseAlertMessage(pContext,
                                   (PBYTE)pAppOutput->pvBuffer,
                                   pAppOutput->cbData);

        // make sure that APP doesn't see Alert messages...
        pAppOutput->cbData = 0;
        
        return pctRet;


    case SSL3_CT_APPLICATIONDATA:
        pctRet = pContext->Decrypt( pContext,
                                    pCommInput,
                                    pAppOutput);

        return pctRet;


    default:
        return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
    }
}

SP_STATUS WINAPI
Ssl3GetHeaderSize(
    PSPContext pContext,
    PSPBuffer pCommInput,
    DWORD * pcbHeaderSize)
{
    if(pcbHeaderSize == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    *pcbHeaderSize = sizeof(SWRAP);
    return PCT_ERR_OK;
}



#if   DBG
BYTE rgb3Mac[2048];
DWORD ibMac = 0;
#endif

//+---------------------------------------------------------------------------
//
//  Function:   Ssl3ComputeMac
//
//  Synopsis:
//
//  Arguments:  [pContext]      --
//              [fReadMac]      --
//              [pClean]        --
//              [cContentType]  --
//              [pbMac]         --
//              [cbMac]
//
//  History:    10-03-97   jbanes   Created.
//
//  Notes:
//
//----------------------------------------------------------------------------
SP_STATUS
Ssl3ComputeMac(
    PSPContext  pContext,
    BOOL        fReadMac,
    PSPBuffer   pClean,
    CHAR        cContentType,
    PBYTE       pbMac,
    DWORD       cbMac)
{
    HCRYPTHASH  hHash = 0;
    DWORD       dwReverseSequence;
    WORD        wReverseData;
    UCHAR       rgbDigest[SP_MAX_DIGEST_LEN];
    DWORD       cbDigest;
    BYTE        rgbPad[CB_SSL3_MAX_MAC_PAD];
    WORD        cbPad;
    HCRYPTPROV  hProv;
    HCRYPTKEY   hSecret;
    DWORD       dwSequence;
    DWORD       dwCapiFlags;
    PHashInfo   pHashInfo;
    SP_STATUS   pctRet;

    if(fReadMac)
    {
        hProv      = pContext->hReadProv;
        hSecret    = pContext->hReadMAC;
        dwSequence = pContext->ReadCounter;
        pHashInfo  = pContext->pReadHashInfo;
    }
    else
    {
        hProv      = pContext->hWriteProv;
        hSecret    = pContext->hWriteMAC;
        dwSequence = pContext->WriteCounter;
        pHashInfo  = pContext->pWriteHashInfo;
    }
    dwCapiFlags = pContext->RipeZombie->dwCapiFlags;

    if(!hProv)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    // Determine size of pad_1 and pad_2.
    if(pHashInfo->aiHash == CALG_MD5)
    {
        cbPad = CB_SSL3_MD5_MAC_PAD;
    }
    else
    {
        cbPad = CB_SSL3_SHA_MAC_PAD;
    }

    //
    // hash(MAC_write_secret + pad_2 +
    //      hash(MAC_write_secret + pad_1 + seq_num +
    //           SSLCompressed.type + SSLCompressed.length +
    //           SSLCompressed.fragment));
    //

    // Create hash
    if(!SchCryptCreateHash(hProv,
                           pHashInfo->aiHash,
                           0,
                           0,
                           &hHash,
                           dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }

    // Hash secret
    if(!SchCryptHashSessionKey(hHash,
                               hSecret,
                               CRYPT_LITTLE_ENDIAN,
                               dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }

    // hash pad 1
    FillMemory(rgbPad, cbPad, PAD1_CONSTANT);
    if(!SchCryptHashData(hHash, rgbPad, cbPad, 0, dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }

    /* add count */
    dwReverseSequence = 0;
    if(!SchCryptHashData(hHash,
                         (PUCHAR)&dwReverseSequence,
                         sizeof(DWORD),
                         0,
                         dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    dwReverseSequence = htonl(dwSequence);
    if(!SchCryptHashData(hHash,
                         (PUCHAR)&dwReverseSequence,
                         sizeof(DWORD),
                         0,
                         dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }

    // Add content type.
    if(cContentType != 0)
    {
        if(!SchCryptHashData(hHash, &cContentType, 1, 0, dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_INT_INTERNAL_ERROR;
            goto cleanup;
        }
    }

    /* add length */
    wReverseData = (WORD)pClean->cbData >> 8 | (WORD)pClean->cbData << 8;
    if(!SchCryptHashData(hHash,
                         (PBYTE)&wReverseData,
                         sizeof(WORD),
                         0,
                         dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }

    /* add data */
    if(!SchCryptHashData(hHash,
                         pClean->pvBuffer,
                         pClean->cbData,
                         0,
                         dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }

    #if VERIFYHASH
        if(ibMac > 1800) ibMac = 0;
        CopyMemory(&rgb3Mac[ibMac], (BYTE *)&dw32High, sizeof(DWORD));
        ibMac += sizeof(DWORD);
        CopyMemory(&rgb3Mac[ibMac], (BYTE *)&dwReverseSeq, sizeof(DWORD));
        ibMac += sizeof(DWORD);
        CopyMemory(&rgb3Mac[ibMac], (BYTE *)&wDataReverse, sizeof(WORD));
        ibMac += sizeof(WORD);
        if(wData < 50)
        {
            CopyMemory(&rgb3Mac[ibMac], (PUCHAR)pClean->pvBuffer, wData);
            ibMac += wData;
        }
    #endif

    // Get inner hash value.
    cbDigest = sizeof(rgbDigest);
    if(!SchCryptGetHashParam(hHash,
                             HP_HASHVAL,
                             rgbDigest,
                             &cbDigest,
                             0,
                             dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    SP_ASSERT(pHashInfo->cbCheckSum == cbDigest);

    SchCryptDestroyHash(hHash, dwCapiFlags);
    hHash = 0;

    #if VERIFYHASH
        CopyMemory(&rgb3Mac[ibMac], rgbDigest, pHashInfo->cbCheckSum);
        ibMac += pHashInfo->cbCheckSum;
    #endif



    // Create hash
    if(!SchCryptCreateHash(hProv,
                           pHashInfo->aiHash,
                           0,
                           0,
                           &hHash,
                           dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }

    // Hash secret
    if(!SchCryptHashSessionKey(hHash,
                               hSecret,
                               CRYPT_LITTLE_ENDIAN,
                               dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }

    // hash pad 2
    FillMemory(rgbPad, cbPad, PAD2_CONSTANT);
    if(!SchCryptHashData(hHash, rgbPad, cbPad, 0, dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }

    if(!SchCryptHashData(hHash, rgbDigest, cbDigest, 0, dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }

    // Get outer hash value.
    cbDigest = sizeof(rgbDigest);
    if(!SchCryptGetHashParam(hHash,
                             HP_HASHVAL,
                             rgbDigest,
                             &cbDigest,
                             0,
                             dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    SP_ASSERT(pHashInfo->cbCheckSum == cbDigest);

    SchCryptDestroyHash(hHash, dwCapiFlags);
    hHash = 0;

    #if VERIFYHASH
        CopyMemory(&rgb3Mac[ibMac], rgbDigest, pHashInfo->cbCheckSum);
        ibMac += pHashInfo->cbCheckSum;
    #endif

    CopyMemory(pbMac, rgbDigest, cbDigest);

    pctRet = PCT_ERR_OK;

cleanup:

    if(hHash)
    {
        SchCryptDestroyHash(hHash, dwCapiFlags);
    }

    return pctRet;
}


//+---------------------------------------------------------------------------
//
//  Function:   Ssl3BuildFinishMessage
//
//  Synopsis:
//
//  Arguments:  [pContext]      --
//              [pbMd5Digest]   --
//              [pbSHADigest]   --
//              [fClient]       --
//
//  History:    10-03-97   jbanes   Added server-side CAPI integration.
//
//  Notes:
//
//----------------------------------------------------------------------------
SP_STATUS
Ssl3BuildFinishMessage(
    PSPContext pContext,
    BYTE *pbMd5Digest,
    BYTE *pbSHADigest,
    BOOL fClient)
{
    BYTE rgbPad1[CB_SSL3_MAX_MAC_PAD];
    BYTE rgbPad2[CB_SSL3_MAX_MAC_PAD];
    BYTE szClnt[] = "CLNT";
    BYTE szSrvr[] = "SRVR";
    DWORD cbMessage;
    HCRYPTHASH hHash = 0;
    DWORD cbDigest;
    SP_STATUS pctRet;

    //
    // Compute the two hash values as follows:
    //
    // enum { client(0x434c4e54), server(0x53525652) } Sender;
    // enum { client("CLNT"), server("SRVR") } Sender;
    //
    // struct {
    //     opaque md5_hash[16];
    //     opaque sha_hash[20];
    // } Finished;
    //
    // md5_hash  -  MD5(master_secret + pad2 + MD5(handshake_messages +
    //      Sender + master_secret + pad1))
    //
    // sha_hash  -  SHA(master_secret + pad2 + SHA(handshake_messages +
    //      Sender + master_secret + pad1))
    //
    // pad_1 - The character 0x36 repeated 48 times for MD5 or
    //         40 times for SHA.
    //
    // pad_2 - The character 0x5c repeated the same number of times.
    //

    FillMemory(rgbPad1, sizeof(rgbPad1), PAD1_CONSTANT);
    FillMemory(rgbPad2, sizeof(rgbPad2), PAD2_CONSTANT);


    // Make local copy of the handshake_messages MD5 hash object
    if(!SchCryptDuplicateHash(pContext->hMd5Handshake,
                              NULL,
                              0,
                              &hHash,
                              pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }

    // Add rest of stuff to local MD5 hash object.
    if(!SchCryptHashData(hHash,
                         fClient ? szClnt : szSrvr,
                         4,
                         0,
                         pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }

    if(!SchCryptHashSessionKey(hHash,
                               pContext->RipeZombie->hMasterKey,
                               CRYPT_LITTLE_ENDIAN,
                               pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    if(!SchCryptHashData(hHash,
                         rgbPad1,
                         CB_SSL3_MD5_MAC_PAD,
                         0,
                         pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    cbDigest = CB_MD5_DIGEST_LEN;
    if(!SchCryptGetHashParam(hHash,
                             HP_HASHVAL,
                             pbMd5Digest,
                             &cbDigest,
                             0,
                             pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags);
    hHash = 0;

    // Compute "parent" MD5 hash
    if(!SchCryptCreateHash(pContext->RipeZombie->hMasterProv,
                           CALG_MD5,
                           0,
                           0,
                           &hHash,
                           pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    if(!SchCryptHashSessionKey(hHash,
                               pContext->RipeZombie->hMasterKey,
                               CRYPT_LITTLE_ENDIAN,
                               pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    if(!SchCryptHashData(hHash,
                         rgbPad2,
                         CB_SSL3_MD5_MAC_PAD,
                         0,
                         pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    if(!SchCryptHashData(hHash,
                         pbMd5Digest,
                         CB_MD5_DIGEST_LEN,
                         0,
                         pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    cbDigest = CB_MD5_DIGEST_LEN;
    if(!SchCryptGetHashParam(hHash,
                             HP_HASHVAL,
                             pbMd5Digest,
                             &cbDigest,
                             0,
                             pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags);
    hHash = 0;

    // Build SHA Hash

    // Make local copy of the handshake_messages SHA hash object
    if(!SchCryptDuplicateHash(pContext->hShaHandshake,
                              NULL,
                              0,
                              &hHash,
                              pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }

    // SHA(handshake_messages + Sender + master_secret + pad1)
    if(!SchCryptHashData(hHash,
                         fClient ? szClnt : szSrvr,
                         4,
                         0,
                         pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    if(!SchCryptHashSessionKey(hHash,
                               pContext->RipeZombie->hMasterKey,
                               CRYPT_LITTLE_ENDIAN,
                               pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    if(!SchCryptHashData(hHash,
                         rgbPad1,
                         CB_SSL3_SHA_MAC_PAD,
                         0,
                         pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    cbDigest = A_SHA_DIGEST_LEN;
    if(!SchCryptGetHashParam(hHash,
                             HP_HASHVAL,
                             pbSHADigest,
                             &cbDigest,
                             0,
                             pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags);
    hHash = 0;

    // SHA(master_secret + pad2 + SHA-hash);
    if(!SchCryptCreateHash(pContext->RipeZombie->hMasterProv,
                           CALG_SHA,
                           0,
                           0,
                           &hHash,
                           pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    if(!SchCryptHashSessionKey(hHash,
                               pContext->RipeZombie->hMasterKey,
                               CRYPT_LITTLE_ENDIAN,
                               pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    if(!SchCryptHashData(hHash,
                         rgbPad2,
                         CB_SSL3_SHA_MAC_PAD,
                         0,
                         pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    if(!SchCryptHashData(hHash,
                         pbSHADigest,
                         A_SHA_DIGEST_LEN,
                         0,
                         pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    cbDigest = A_SHA_DIGEST_LEN;
    if(!SchCryptGetHashParam(hHash,
                             HP_HASHVAL,
                             pbSHADigest,
                             &cbDigest,
                             0,
                             pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags);
        hHash = 0;

    pctRet = PCT_ERR_OK;

cleanup:

    if(hHash)
    {
        SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags);
    }

    return pctRet;
}


/*****************************************************************************/
DWORD Ssl3CiphertextLen(
    PSPContext pContext,
    DWORD cbMessage,
    BOOL fClientIsSender)
{
    DWORD cbBlock;

    // Abort early if we're not encrypting.
    if(pContext->pWriteCipherInfo == NULL)
    {
        // Add record header length.
        cbMessage += sizeof(SWRAP);

        return cbMessage;
    }

    // Add MAC length.
    cbMessage += pContext->pWriteHashInfo->cbCheckSum;

    // Add padding if we're using a block cipher.
    cbBlock = pContext->pWriteCipherInfo->dwBlockSize;
    if(cbBlock > 1)
    {
        cbMessage += cbBlock - cbMessage % cbBlock;
    }

    // Add record header length.
    cbMessage += sizeof(SWRAP);

    return cbMessage;
}

//+---------------------------------------------------------------------------
//
//  Function:   Ssl3EncryptRaw
//
//  Synopsis:   Perform the MAC and encryption steps on an SSL3 record.
//
//  Arguments:  [pContext]      --  Schannel context.
//              [pAppInput]     --  Data to be encrypted.
//              [pCommOutput]   --  (output) Encrypted SSL3 record.
//              [bContentType]  --  SSL3 context type.
//
//  History:    10-22-97   jbanes   CAPI integrated.
//
//  Notes:      This function doesn't touch the header portion of the SSL3
//              record. This is handle by the calling function.
//
//----------------------------------------------------------------------------
SP_STATUS WINAPI
Ssl3EncryptRaw(
    PSPContext pContext,
    PSPBuffer  pAppInput,
    PSPBuffer  pCommOutput,
    BYTE       bContentType)
{
    SP_STATUS pctRet;
    SPBuffer Clean;
    SPBuffer Encrypted;
    DWORD cbBlock;
    DWORD cbPadding;
    PUCHAR pbMAC = NULL;
    BOOL   fIsClient = FALSE;
    DWORD  cbBuffExpected;

    if((pContext == NULL) ||
        (pContext->RipeZombie == NULL) ||
        (pContext->pWriteHashInfo == NULL) ||
        (pContext->pWriteCipherInfo == NULL) ||
        (pAppInput == NULL) ||
        (pCommOutput == NULL) ||
        (pAppInput->pvBuffer == NULL) ||
        (pCommOutput->pvBuffer == NULL))
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    if(pAppInput->cbData > pAppInput->cbBuffer)
    {
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }
    fIsClient = ( 0 != (pContext->RipeZombie->fProtocol & SP_PROT_SSL3TLS1_CLIENTS));

    cbBuffExpected = Ssl3CiphertextLen(pContext, pAppInput->cbData, fIsClient);
    if(cbBuffExpected == 0)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    if(pCommOutput->cbBuffer < cbBuffExpected)
    {
        return SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
    }

    Clean.cbData   = pAppInput->cbData;
    Clean.pvBuffer = (PUCHAR)pCommOutput->pvBuffer + sizeof(SWRAP);
    Clean.cbBuffer = pCommOutput->cbBuffer - sizeof(SWRAP);

    /* Move data out of the way if necessary */
    if(Clean.pvBuffer != pAppInput->pvBuffer)
    {
        DebugLog((DEB_WARN, "SSL3EncryptRaw: Unnecessary Move, performance hog\n"));
        MoveMemory(Clean.pvBuffer,
                   pAppInput->pvBuffer,
                   pAppInput->cbData);
    }

    // Transfer the write key over from the application process.
    if(pContext->hWriteKey == 0 &&
       pContext->pWriteCipherInfo->aiCipher != CALG_NULLCIPHER)
    {
        DebugLog((DEB_TRACE, "Transfer write key from user process.\n"));
        pctRet = SPGetUserKeys(pContext, SCH_FLAG_WRITE_KEY);
        if(pctRet != PCT_ERR_OK)
        {
            return SP_LOG_RESULT(pctRet);
        }
    }

    // Compute MAC and add it to end of message.
    pbMAC = (PUCHAR)Clean.pvBuffer + Clean.cbData;
    if(pContext->RipeZombie->fProtocol & SP_PROT_SSL3)
    {
        pctRet = Ssl3ComputeMac(pContext,
                                FALSE,
                                &Clean,
                                bContentType,
                                pbMAC,
                                pContext->pWriteHashInfo->cbCheckSum);
        if(pctRet != PCT_ERR_OK)
        {
            return pctRet;
        }
    }
    else
    {
        pctRet = Tls1ComputeMac(pContext,
                                FALSE,
                                &Clean,
                                bContentType,
                                pbMAC,
                                pContext->pWriteHashInfo->cbCheckSum);
        if(pctRet != PCT_ERR_OK)
        {
            return pctRet;
        }
    }
    Clean.cbData += pContext->pWriteHashInfo->cbCheckSum;

    pContext->WriteCounter++;

    // Add block cipher padding to end of message.
    cbBlock = pContext->pWriteCipherInfo->dwBlockSize;
    if(cbBlock > 1)
    {
        // This is a block cipher.
        cbPadding = cbBlock - Clean.cbData % cbBlock;

        FillMemory((PUCHAR)Clean.pvBuffer + Clean.cbData,
                   cbPadding,
                   (UCHAR)(cbPadding - 1));
        Clean.cbData += cbPadding;
    }

    SP_ASSERT(Clean.cbData <= Clean.cbBuffer);

    Encrypted.cbData   = Clean.cbData;
    Encrypted.pvBuffer = Clean.pvBuffer;
    Encrypted.cbBuffer = Clean.cbBuffer;

    // Encrypt message.
    if(pContext->pWriteCipherInfo->aiCipher != CALG_NULLCIPHER)
    {
        if(!SchCryptEncrypt(pContext->hWriteKey,
                            0, FALSE, 0,
                            Encrypted.pvBuffer,
                            &Encrypted.cbData,
                            Encrypted.cbBuffer,
                            pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
            return PCT_INT_INTERNAL_ERROR;
        }
    }

    pCommOutput->cbData = Encrypted.cbData + sizeof(SWRAP);

    return PCT_ERR_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   Ssl3EncryptMessage
//
//  Synopsis:   Encode a block of data as an SSL3 record.
//
//  Arguments:  [pContext]      --  Schannel context.
//              [pAppInput]     --  Data to be encrypted.
//              [pCommOutput]   --  (output) Completed SSL3 record.
//
//  History:    10-22-97   jbanes   CAPI integrated.
//
//  Notes:      An SSL3 record is formatted as:
//
//                  BYTE header[5];
//                  BYTE data[pAppInput->cbData];
//                  BYTE mac[mac_size];
//                  BYTE padding[padding_size];
//
//----------------------------------------------------------------------------
SP_STATUS WINAPI
Ssl3EncryptMessage( PSPContext pContext,
                    PSPBuffer   pAppInput,
                    PSPBuffer   pCommOutput)
{
    DWORD cbMessage;
    SP_STATUS pctRet;

    SP_BEGIN("Ssl3EncryptMessage");

    if((pContext == NULL) ||
        (pContext->RipeZombie == NULL) ||
        (pAppInput == NULL) ||
        (pCommOutput == NULL) ||
        (pCommOutput->pvBuffer == NULL))
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    DebugLog((DEB_TRACE, "Input: cbData:0x%x, cbBuffer:0x%x, pvBuffer:0x%8.8x\n",
        pAppInput->cbData,
        pAppInput->cbBuffer,
        pAppInput->pvBuffer));

    DebugLog((DEB_TRACE, "Output: cbData:0x%x, cbBuffer:0x%x, pvBuffer:0x%8.8x\n",
        pCommOutput->cbData,
        pCommOutput->cbBuffer,
        pCommOutput->pvBuffer));

    // Compute encrypted message size.
    cbMessage = Ssl3CiphertextLen(pContext, pAppInput->cbData, TRUE);

    pctRet = Ssl3EncryptRaw(pContext, pAppInput, pCommOutput, SSL3_CT_APPLICATIONDATA);
    if(pctRet != PCT_ERR_OK)
    {
        SP_RETURN(SP_LOG_RESULT(pctRet));
    }

    SetWrapNoEncrypt(pCommOutput->pvBuffer,
                     SSL3_CT_APPLICATIONDATA,
                     cbMessage - sizeof(SWRAP));
    if(pContext->RipeZombie->fProtocol & SP_PROT_TLS1)
    {
        ((PUCHAR)pCommOutput->pvBuffer)[02] = TLS1_CLIENT_VERSION_LSB;
    }

    DebugLog((DEB_TRACE, "Output: cbData:0x%x, cbBuffer:0x%x, pvBuffer:0x%8.8x\n",
        pCommOutput->cbData,
        pCommOutput->cbBuffer,
        pCommOutput->pvBuffer));

    SP_RETURN(PCT_ERR_OK);
}


//+---------------------------------------------------------------------------
//
//  Function:   Ssl3DecryptMessage
//
//  Synopsis:   Decode an SSL3 record.
//
//  Arguments:  [pContext]      --  Schannel context.
//              [pMessage]      --  Data from the remote party.
//              [pAppOutput]    --  (output) Decrypted data.
//
//  History:    10-22-97   jbanes   CAPI integrated.
//
//  Notes:      The number of input data bytes consumed by this function
//              is returned in pMessage->cbData.
//
//----------------------------------------------------------------------------
SP_STATUS WINAPI
Ssl3DecryptMessage( PSPContext         pContext,
                    PSPBuffer          pMessage,
                    PSPBuffer          pAppOutput)
{
    SP_STATUS pctRet;
    SPBuffer  Clean;
    SPBuffer  Encrypted;
    UCHAR     rgbDigest[SP_MAX_DIGEST_LEN];
    PUCHAR    pbMAC;
    DWORD     dwLength, cbActualData;
    SWRAP     *pswrap = pMessage->pvBuffer;
    DWORD     dwVersion;

    DWORD cbBlock;
    DWORD cbPadding;

    SP_BEGIN("Ssl3DecryptMessage");

    if((pContext == NULL) ||
        (pContext->pReadCipherInfo == NULL) ||
        (pContext->RipeZombie == NULL) ||
        (pAppOutput == NULL) ||
        (pMessage == NULL) ||
        (pMessage->pvBuffer == NULL))
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    /* First determine the length of data, the length of padding,
     * and the location of data, and the location of MAC */
    cbActualData = pMessage->cbData;
    pMessage->cbData = sizeof(SWRAP); /* minimum amount of data we need */

    if(cbActualData < sizeof(SWRAP))
    {
        SP_RETURN(PCT_INT_INCOMPLETE_MSG);
    }

    dwVersion = COMBINEBYTES(pswrap->bMajor, pswrap->bMinor);
    if(dwVersion != SSL3_CLIENT_VERSION && dwVersion != TLS1_CLIENT_VERSION)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG));
    }

    dwLength = COMBINEBYTES(pswrap->bcbMSBSize, pswrap->bcbLSBSize);

    Encrypted.pvBuffer = (PUCHAR)pMessage->pvBuffer + sizeof(SWRAP);
    Encrypted.cbBuffer = pMessage->cbBuffer - sizeof(SWRAP);

    pMessage->cbData += dwLength ;

    if(pMessage->cbData > cbActualData)
    {
        SP_RETURN(PCT_INT_INCOMPLETE_MSG);
    }

    Encrypted.cbData = dwLength; /* encrypted data size */

    SP_ASSERT(Encrypted.cbData != 0);

    /* check to see if we have a block size violation */
    if(Encrypted.cbData % pContext->pReadCipherInfo->dwBlockSize)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_MSG_ALTERED));
    }

    // Transfer the read key over from the application process.
    if(pContext->hReadKey == 0 && 
       pContext->pReadCipherInfo->aiCipher != CALG_NULLCIPHER)
    {
        DebugLog((DEB_TRACE, "Transfer read key from user process.\n"));
        pctRet = SPGetUserKeys(pContext, SCH_FLAG_READ_KEY);
        if(pctRet != PCT_ERR_OK)
        {
            return SP_LOG_RESULT(pctRet);
        }
    }

    // Decrypt message.
    if(pContext->pReadCipherInfo->aiCipher != CALG_NULLCIPHER)
    {
        if(!SchCryptDecrypt(pContext->hReadKey,
                            0, FALSE, 0,
                            Encrypted.pvBuffer,
                            &Encrypted.cbData,
                            pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
            SP_RETURN(PCT_INT_INTERNAL_ERROR);
        }
    }

    // Remove block cipher padding.
    cbBlock = pContext->pReadCipherInfo->dwBlockSize;
    if(cbBlock > 1)
    {
        // This is a block cipher.
        cbPadding = *((PUCHAR)Encrypted.pvBuffer + Encrypted.cbData - 1) + 1;

        if(pContext->RipeZombie->fProtocol & SP_PROT_SSL3)
        {
            if(cbPadding > cbBlock || cbPadding >= Encrypted.cbData)
            {
                // Invalid pad size.
                DebugLog((DEB_WARN, "FINISHED Message: Padding Invalid\n"));
                SP_RETURN(SP_LOG_RESULT(PCT_INT_MSG_ALTERED));
            }
        }
        else
        {
            if(cbPadding > 256 || cbPadding >= Encrypted.cbData)
            {
                // Invalid pad size.
                DebugLog((DEB_WARN, "FINISHED Message: Padding Invalid\n"));
                SP_RETURN(SP_LOG_RESULT(PCT_INT_MSG_ALTERED));
            }
        }
        Encrypted.cbData -= cbPadding;
    }


    if(Encrypted.cbData < pContext->pReadHashInfo->cbCheckSum)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_MSG_ALTERED));
    }

    // Validate MAC.
    Clean.pvBuffer = Encrypted.pvBuffer;
    Clean.cbData   = Encrypted.cbData - pContext->pReadHashInfo->cbCheckSum;
    Clean.cbBuffer = Clean.cbData;

    if(pContext->RipeZombie->fProtocol & SP_PROT_SSL3)
    {
        pctRet = Ssl3ComputeMac(pContext,
                                TRUE,
                                &Clean,
                                pswrap->bCType,
                                rgbDigest,
                                sizeof(rgbDigest));
        if(pctRet != PCT_ERR_OK)
        {
            return pctRet;
        }
    }
    else
    {
        pctRet = Tls1ComputeMac(pContext,
                                TRUE,
                                &Clean,
                                pswrap->bCType,
                                rgbDigest,
                                sizeof(rgbDigest));
        if(pctRet != PCT_ERR_OK)
        {
            return pctRet;
        }
    }

    pContext->ReadCounter++;

    pbMAC = (PUCHAR)Clean.pvBuffer + Clean.cbData;

    if(memcmp(rgbDigest, pbMAC, pContext->pReadHashInfo->cbCheckSum))
    {
        DebugLog((DEB_WARN, "FINISHED Message: Checksum Invalid\n"));
        if(pContext->RipeZombie->fProtocol & SP_PROT_TLS1)
        {
            SetTls1Alert(pContext, TLS1_ALERT_FATAL, TLS1_ALERT_BAD_RECORD_MAC);
        }
        SP_RETURN(SP_LOG_RESULT(SEC_E_MESSAGE_ALTERED));
    }

    if(pAppOutput->pvBuffer != Clean.pvBuffer)
    {
        CopyMemory(pAppOutput->pvBuffer, Clean.pvBuffer, Clean.cbData);
    }

    pAppOutput->cbData = Clean.cbData;

    SP_RETURN(PCT_ERR_OK);
}


/*****************************************************************************/
// Create an encrypted Finish message, adding it to the end of the
// specified buffer object.
//
SP_STATUS SPBuildS3FinalFinish(PSPContext pContext, PSPBuffer pBuffer, BOOL fClient)
{
    PBYTE pbMessage = (PBYTE)pBuffer->pvBuffer + pBuffer->cbData;
    DWORD cbFinished;
    SP_STATUS pctRet;
    DWORD cbDataOut;

    BYTE rgbMd5Digest[CB_MD5_DIGEST_LEN];
    BYTE rgbSHADigest[CB_SHA_DIGEST_LEN];

    // Build Finished message body.
    pctRet = Ssl3BuildFinishMessage(pContext, rgbMd5Digest, rgbSHADigest, fClient);
    if(pctRet != PCT_ERR_OK)
    {
        return pctRet;
    }

    CopyMemory(pbMessage + sizeof(SWRAP) + sizeof(SHSH),
               rgbMd5Digest,
               CB_MD5_DIGEST_LEN);
    CopyMemory(pbMessage + sizeof(SWRAP) + sizeof(SHSH) + CB_MD5_DIGEST_LEN,
               rgbSHADigest,
               CB_SHA_DIGEST_LEN);

    // Build Finished handshake header.
    SetHandshake(pbMessage + sizeof(SWRAP),
                 SSL3_HS_FINISHED,
                 NULL,
                 CB_MD5_DIGEST_LEN + CB_SHA_DIGEST_LEN);
    cbFinished = sizeof(SHSH) + CB_MD5_DIGEST_LEN + CB_SHA_DIGEST_LEN;

    // Update handshake hash objects.
    pctRet = UpdateHandshakeHash(pContext,
                                 pbMessage + sizeof(SWRAP),
                                 cbFinished,
                                 FALSE);
    if(pctRet != PCT_ERR_OK)
    {
        return(pctRet);
    }

    // Add record header and encrypt message.
    pctRet = SPSetWrap(pContext,
            pbMessage,
            SSL3_CT_HANDSHAKE,
            cbFinished,
            fClient,
            &cbDataOut);

    if(pctRet != PCT_ERR_OK)
    {
        return pctRet;
    }

    // Update buffer length.
    pBuffer->cbData += cbDataOut;

    SP_ASSERT(pBuffer->cbData <= pBuffer->cbBuffer);

    return PCT_ERR_OK;
}

SP_STATUS
SPSetWrap(
    PSPContext pContext,
    PUCHAR pbMessage,
    UCHAR bContentType,
    DWORD cbPayload,
    BOOL fClient,
    DWORD *pcbDataOut)
{
    SWRAP *pswrap = (SWRAP *)pbMessage;
    DWORD cbMessage;
    SP_STATUS pctRet = PCT_ERR_OK;

    // Compute size of encrypted message.
    cbMessage = Ssl3CiphertextLen(pContext, cbPayload, fClient);

    if(pContext->pWriteHashInfo)
    {
        SPBuffer Clean;
        SPBuffer Encrypted;

        Clean.pvBuffer = pbMessage + sizeof(SWRAP);
        Clean.cbBuffer = cbMessage;
        Clean.cbData   = cbPayload;

        Encrypted.pvBuffer  = pbMessage;
        Encrypted.cbBuffer  = cbMessage;
        Encrypted.cbData    = cbPayload + sizeof(SWRAP);

        pctRet = Ssl3EncryptRaw(pContext, &Clean, &Encrypted, bContentType);
        cbMessage = Encrypted.cbData;
    }

    ZeroMemory(pswrap, sizeof(SWRAP));
    pswrap->bCType      = bContentType;
    pswrap->bMajor      = SSL3_CLIENT_VERSION_MSB;
    if(pContext->RipeZombie->fProtocol & SP_PROT_SSL3)
    {
        pswrap->bMinor = (UCHAR)SSL3_CLIENT_VERSION_LSB;
    }
    else
    {
        pswrap->bMinor = (UCHAR)TLS1_CLIENT_VERSION_LSB;
    }
    pswrap->bcbMSBSize  = MSBOF(cbMessage - sizeof(SWRAP));
    pswrap->bcbLSBSize  = LSBOF(cbMessage - sizeof(SWRAP));

    if(pcbDataOut != NULL)
    {
        *pcbDataOut = cbMessage;
    }

    return(pctRet);
}

void
SetWrapNoEncrypt(
    PUCHAR pbMessage,
    UCHAR bContentType,
    DWORD cbPayload)
{
    SWRAP *pswrap = (SWRAP *)pbMessage;

    ZeroMemory(pswrap, sizeof(SWRAP));
    pswrap->bCType      = bContentType;
    pswrap->bMajor      = SSL3_CLIENT_VERSION_MSB;
    pswrap->bMinor      = SSL3_CLIENT_VERSION_LSB;
    pswrap->bcbMSBSize  = MSBOF(cbPayload);
    pswrap->bcbLSBSize  = LSBOF(cbPayload);
}


void SetHandshake(PUCHAR pb, BYTE bHandshake, PUCHAR pbData, DWORD dwSize)
{
    SHSH *pshsh = (SHSH *) pb;

    FillMemory(pshsh, sizeof(SHSH), 0);
    pshsh->typHS = bHandshake;
    pshsh->bcbMSB = MSBOF(dwSize) ;
    pshsh->bcbLSB = LSBOF(dwSize) ;
    if(NULL != pbData)
    {
        CopyMemory( pb + sizeof(SHSH) , pbData, dwSize);
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   UpdateHandshakeHash
//
//  Synopsis:
//
//  Arguments:  [pContext]      --
//              [pb]            --
//              [dwcb]          --
//              [fInit]         --
//
//  History:    10-03-97   jbanes   Added server-side CAPI integration.
//
//  Notes:
//
//----------------------------------------------------------------------------
SP_STATUS
UpdateHandshakeHash(
    PSPContext  pContext,
    PUCHAR      pb,
    DWORD       dwcb,
    BOOL        fInit)
{
    if(pContext->RipeZombie->hMasterProv == 0)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    if(fInit)
    {
        DebugLog((DEB_TRACE, "UpdateHandshakeHash: initializing\n"));

        if(pContext->hMd5Handshake)
        {
            SchCryptDestroyHash(pContext->hMd5Handshake,
                                pContext->RipeZombie->dwCapiFlags);
            pContext->hMd5Handshake = 0;
        }
        if(!SchCryptCreateHash(pContext->RipeZombie->hMasterProv,
                               CALG_MD5, 0, 0,
                               &pContext->hMd5Handshake,
                               pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
            return PCT_INT_INTERNAL_ERROR;
        }

        if(pContext->hShaHandshake)
        {
            SchCryptDestroyHash(pContext->hShaHandshake,
                                pContext->RipeZombie->dwCapiFlags);
            pContext->hShaHandshake = 0;
        }
        if(!SchCryptCreateHash(pContext->RipeZombie->hMasterProv,
                               CALG_SHA, 0, 0,
                               &pContext->hShaHandshake,
                               pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
            return PCT_INT_INTERNAL_ERROR;
        }
    }

    if(pContext->hMd5Handshake == 0 || pContext->hShaHandshake == 0)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    if(dwcb && NULL != pb)
    {
        DebugLog((DEB_TRACE, "UpdateHandshakeHash: %d bytes\n", dwcb));

        if(!SchCryptHashData(pContext->hMd5Handshake,
                             pb, dwcb, 0,
                             pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
            return PCT_INT_INTERNAL_ERROR;
        }
        if(!SchCryptHashData(pContext->hShaHandshake,
                             pb, dwcb, 0,
                             pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
            return PCT_INT_INTERNAL_ERROR;
        }
    }

    #if VERIFYHASH
        CopyMemory(&rgbF[ibF], pb, dwcb);
        ibF += dwcb;
    #endif

    return PCT_ERR_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:   Tls1ComputeCertVerifyHashes
//
//  Synopsis:   Compute the hashes contained by a TLS
//              CertificateVerify message.
//
//  Arguments:  [pContext]  --  Schannel context.
//              [pbHash]    --
//              [cbHash]    --
//
//  History:    10-14-97   jbanes   Created.
//
//  Notes:      The data generated by this routine is always 36 bytes in
//              length, and consists of an MD5 hash followed by an SHA
//              hash.
//
//              The hash values are computed as:
//
//                  md5_hash = MD5(handshake_messages);
//
//                  sha_hash = SHA(handshake_messages);
//
//----------------------------------------------------------------------------
SP_STATUS
Tls1ComputeCertVerifyHashes(
    PSPContext  pContext,   // in
    PBYTE       pbMD5,      // out
    PBYTE       pbSHA)      // out
{
    HCRYPTHASH hHash = 0;
    DWORD cbData;

    if((pContext == NULL) ||
       (pContext->RipeZombie == NULL))
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    if(pbMD5 != NULL)
    {
        // md5_hash = MD5(handshake_messages);
        if(!SchCryptDuplicateHash(pContext->hMd5Handshake,
                                  NULL,
                                  0,
                                  &hHash,
                                  pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
            return PCT_INT_INTERNAL_ERROR;
        }
        cbData = CB_MD5_DIGEST_LEN;
        if(!SchCryptGetHashParam(hHash,
                                 HP_HASHVAL,
                                 pbMD5,
                                 &cbData,
                                 0,
                                 pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
            SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags);
            return PCT_INT_INTERNAL_ERROR;
        }
        SP_ASSERT(cbData == CB_MD5_DIGEST_LEN);
        if(!SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
        }
    }

    if(pbSHA != NULL)
    {
        // sha_hash = SHA(handshake_messages);
        if(!SchCryptDuplicateHash(pContext->hShaHandshake,
                                  NULL,
                                  0,
                                  &hHash,
                                  pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
            return PCT_INT_INTERNAL_ERROR;
        }
        cbData = CB_SHA_DIGEST_LEN;
        if(!SchCryptGetHashParam(hHash,
                                 HP_HASHVAL, pbSHA,
                                 &cbData,
                                 0,
                                 pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
            SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags);
            return PCT_INT_INTERNAL_ERROR;
        }
        SP_ASSERT(cbData == CB_SHA_DIGEST_LEN);
        if(!SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
        }
    }

    return PCT_ERR_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   Ssl3ComputeCertVerifyHashes
//
//  Synopsis:   Compute the hashes contained by an SSL3
//              CertificateVerify message.
//
//  Arguments:  [pContext]  --  Schannel context.
//              [pbHash]    --
//              [cbHash]    --
//
//  History:    10-14-97   jbanes   Added CAPI integration.
//
//  Notes:      The data generated by this routine is always 36 bytes in
//              length, and consists of an MD5 hash followed by an SHA
//              hash.
//
//              The hash values are computed as follows:
//
//                  md5_hash = MD5(master_secret + pad2 +
//                                 MD5(handshake_messages + master_secret +
//                                     pad1));
//
//                  sha_hash = SHA(master_secret + pad2 +
//                                 SHA(handshake_messages + master_secret +
//                                     pad1));
//
//----------------------------------------------------------------------------
SP_STATUS
Ssl3ComputeCertVerifyHashes(
    PSPContext  pContext,   // in
    PBYTE       pbMD5,      // out
    PBYTE       pbSHA)      // out
{
    BYTE rgbPad1[CB_SSL3_MAX_MAC_PAD];
    BYTE rgbPad2[CB_SSL3_MAX_MAC_PAD];
    HCRYPTHASH hHash = 0;
    DWORD cbData;
    SP_STATUS pctRet;

    FillMemory(rgbPad1, sizeof(rgbPad1), PAD1_CONSTANT);
    FillMemory(rgbPad2, sizeof(rgbPad2), PAD2_CONSTANT);

    if(pbMD5 != NULL)
    {
        //
        // CertificateVerify.signature.md5_hash = MD5(master_secret + pad2 +
        //    MD5(handshake_messages + master_secret + pad1));
        //

        // Compute inner hash.
        if(!SchCryptDuplicateHash(pContext->hMd5Handshake,
                                  NULL,
                                  0,
                                  &hHash,
                                  pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_INT_INTERNAL_ERROR;
            goto cleanup;
        }
        if(!SchCryptHashSessionKey(hHash,
                                   pContext->RipeZombie->hMasterKey,
                                   CRYPT_LITTLE_ENDIAN,
                                   pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_INT_INTERNAL_ERROR;
            goto cleanup;
        }
        if(!SchCryptHashData(hHash,
                             rgbPad1,
                             CB_SSL3_MD5_MAC_PAD,
                             0,
                             pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_INT_INTERNAL_ERROR;
            goto cleanup;
        }
        cbData = CB_MD5_DIGEST_LEN;
        if(!SchCryptGetHashParam(hHash,
                                 HP_HASHVAL,
                                 pbMD5,
                                 &cbData,
                                 0,
                                 pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_INT_INTERNAL_ERROR;
            goto cleanup;
        }
        SP_ASSERT(cbData == CB_MD5_DIGEST_LEN);
        if(!SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
        }
        hHash = 0;

        // Compute outer hash.
        if(!SchCryptCreateHash(pContext->RipeZombie->hMasterProv,
                               CALG_MD5,
                               0,
                               0,
                               &hHash,
                               pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_INT_INTERNAL_ERROR;
            goto cleanup;
        }
        if(!SchCryptHashSessionKey(hHash,
                                   pContext->RipeZombie->hMasterKey,
                                   CRYPT_LITTLE_ENDIAN,
                                   pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_INT_INTERNAL_ERROR;
            goto cleanup;
        }
        if(!SchCryptHashData(hHash,
                             rgbPad2,
                             CB_SSL3_MD5_MAC_PAD,
                             0,
                             pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_INT_INTERNAL_ERROR;
            goto cleanup;
        }
        if(!SchCryptHashData(hHash,
                             pbMD5,
                             CB_MD5_DIGEST_LEN,
                             0,
                             pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_INT_INTERNAL_ERROR;
            goto cleanup;
        }
        cbData = CB_MD5_DIGEST_LEN;
        if(!SchCryptGetHashParam(hHash,
                                 HP_HASHVAL,
                                 pbMD5,
                                 &cbData,
                                 0,
                                 pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_INT_INTERNAL_ERROR;
            goto cleanup;
        }
        SP_ASSERT(cbData == CB_MD5_DIGEST_LEN);
        if(!SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
        }
        hHash = 0;
    }

    if(pbSHA != NULL)
    {
        //
        // CertificateVerify.signature.sha_hash = SHA(master_secret + pad2 +
        //    SHA(handshake_messages + master_secret + pad1));
        //

        // Compute inner hash.
        if(!SchCryptDuplicateHash(pContext->hShaHandshake,
                                  NULL,
                                  0,
                                  &hHash,
                                  pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_INT_INTERNAL_ERROR;
            goto cleanup;
        }
        if(!SchCryptHashSessionKey(hHash,
                                   pContext->RipeZombie->hMasterKey,
                                   CRYPT_LITTLE_ENDIAN,
                                   pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_INT_INTERNAL_ERROR;
            goto cleanup;
        }
        if(!SchCryptHashData(hHash,
                             rgbPad1,
                             CB_SSL3_SHA_MAC_PAD,
                             0,
                             pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_INT_INTERNAL_ERROR;
            goto cleanup;
        }
        cbData = CB_SHA_DIGEST_LEN;
        if(!SchCryptGetHashParam(hHash,
                                 HP_HASHVAL, 
                                 pbSHA,
                                 &cbData,
                                 0,
                                 pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_INT_INTERNAL_ERROR;
            goto cleanup;
        }
        SP_ASSERT(cbData == CB_SHA_DIGEST_LEN);
        if(!SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
        }
        hHash = 0;

        // Compute outer hash.
        if(!SchCryptCreateHash(pContext->RipeZombie->hMasterProv,
                               CALG_SHA,
                               0,
                               0,
                               &hHash,
                               pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_INT_INTERNAL_ERROR;
            goto cleanup;
        }
        if(!SchCryptHashSessionKey(hHash,
                                   pContext->RipeZombie->hMasterKey,
                                   CRYPT_LITTLE_ENDIAN,
                                   pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_INT_INTERNAL_ERROR;
            goto cleanup;
        }
        if(!SchCryptHashData(hHash,
                             rgbPad2,
                             CB_SSL3_SHA_MAC_PAD,
                             0,
                             pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_INT_INTERNAL_ERROR;
            goto cleanup;
        }
        if(!SchCryptHashData(hHash,
                             pbSHA,
                             CB_SHA_DIGEST_LEN,
                             0,
                             pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_INT_INTERNAL_ERROR;
            goto cleanup;
        }
        cbData = CB_SHA_DIGEST_LEN;
        if(!SchCryptGetHashParam(hHash,
                                 HP_HASHVAL,
                                 pbSHA,
                                 &cbData,
                                 0,
                                 pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_INT_INTERNAL_ERROR;
            goto cleanup;
        }
        SP_ASSERT(cbData == CB_SHA_DIGEST_LEN);
        if(!SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
        }
        hHash = 0;
    }

    pctRet = PCT_ERR_OK;

cleanup:

    if(hHash)
    {
        SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags);
    }

    return pctRet;
}


SP_STATUS Ssl3HandleCCS(PSPContext pContext,
                   PUCHAR pb,
                   DWORD cbMessage)
{

    SP_STATUS pctRet = PCT_ERR_OK;
    BOOL fSender =
        (0 == (pContext->RipeZombie->fProtocol & SP_PROT_SSL3TLS1_CLIENTS)) ;


    SP_BEGIN("Ssl3HandleCCS");

    if(cbMessage != 1 || pb[0] != 0x1)
    {
        pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
        SP_RETURN(pctRet);
    }

    // We always zero out the read counter on receipt
    // of a change cipher spec message.
    pContext->ReadCounter = 0;


    // Move pending ciphers to real ciphers
    pctRet = ContextInitCiphers(pContext, TRUE, FALSE);

    if(pctRet != PCT_ERR_OK)
    {
        SP_RETURN(pctRet);
    }

    if(pContext->RipeZombie->fProtocol & SP_PROT_SSL3)
    {
        pctRet = Ssl3MakeReadSessionKeys(pContext);
    }
    else
    {
        pctRet = Tls1MakeReadSessionKeys(pContext);
    }
    if(pctRet != PCT_ERR_OK)
    {
        SP_RETURN(pctRet);
    }

    if(fSender)
    {
        pContext->wS3CipherSuiteClient = (WORD)UniAvailableCiphers[pContext->dwPendingCipherSuiteIndex].CipherKind;
        pContext->State = SSL3_STATE_CHANGE_CIPHER_SPEC_SERVER;
    }
    else
    {
        pContext->wS3CipherSuiteServer = (WORD)UniAvailableCiphers[pContext->dwPendingCipherSuiteIndex].CipherKind;
        pContext->State = SSL3_STATE_CHANGE_CIPHER_SPEC_CLIENT;
    }
    SP_RETURN(PCT_ERR_OK);
}


/*****************************************************************************/
// Create a (possibly encrypted) ChangeCipherSpec and an encrypted
// Finish message, adding them to the end of the specified buffer object.
//
SP_STATUS
BuildCCSAndFinishMessage(
    PSPContext pContext,
    PSPBuffer pBuffer,
    BOOL fClient)
{
    SP_STATUS pctRet;
    PBYTE pbMessage = (PBYTE)pBuffer->pvBuffer + pBuffer->cbData;
    DWORD cbDataOut;

    // Build ChangeCipherSpec message body.
    *(pbMessage + sizeof(SWRAP)) = 0x1;

    // Add record header and encrypt message.
    pctRet = SPSetWrap(pContext,
            pbMessage,
            SSL3_CT_CHANGE_CIPHER_SPEC,
            1,
            fClient,
            &cbDataOut);

    if(pctRet != PCT_ERR_OK)
        return(pctRet);

    // Update buffer length.
    pBuffer->cbData += cbDataOut;

    SP_ASSERT(pBuffer->cbData <= pBuffer->cbBuffer);

    // Update cipher suites.
    pContext->WriteCounter = 0;

    pctRet = ContextInitCiphers(pContext, FALSE, TRUE);
    if(pctRet != PCT_ERR_OK)
    {
        return(pctRet);
    }

    if(pContext->RipeZombie->fProtocol & SP_PROT_SSL3)
    {
        pctRet = Ssl3MakeWriteSessionKeys(pContext);
    }
    else
    {
        pctRet = Tls1MakeWriteSessionKeys(pContext);
    }
    if(pctRet != PCT_ERR_OK)
    {
        return(pctRet);
    }

    if(fClient)
    {
        pContext->wS3CipherSuiteClient = (WORD)UniAvailableCiphers[pContext->dwPendingCipherSuiteIndex].CipherKind;
    }
    else
    {
        pContext->wS3CipherSuiteServer = (WORD)UniAvailableCiphers[pContext->dwPendingCipherSuiteIndex].CipherKind;
    }

    // Build Finish message.
    if(pContext->RipeZombie->fProtocol & SP_PROT_SSL3)
    {
        pctRet = SPBuildS3FinalFinish(pContext, pBuffer, fClient);
    }
    else
    {
        pctRet = SPBuildTls1FinalFinish(pContext, pBuffer, fClient);
    }

    return pctRet;
}



SP_STATUS
Ssl3SelectCipher
(
    PSPContext pContext,
    WORD       wCipher
)
{
    SP_STATUS          pctRet=PCT_ERR_ILLEGAL_MESSAGE;
    DWORD               i;
    PCipherInfo         pCipherInfo = NULL;
    PHashInfo           pHashInfo = NULL;
    PKeyExchangeInfo    pExchInfo = NULL;

    pContext->dwPendingCipherSuiteIndex = 0;

    for(i = 0; i < UniNumCiphers; i++)
    {
        // Is this an SSL3 cipher suite?
        if(!(UniAvailableCiphers[i].fProt & pContext->RipeZombie->fProtocol))
        {
            continue;
        }

        // Is this the right cipher suite?
        if(UniAvailableCiphers[i].CipherKind != wCipher)
        {
            continue;
        }

        pCipherInfo = GetCipherInfo(UniAvailableCiphers[i].aiCipher, UniAvailableCiphers[i].dwStrength);
        pHashInfo = GetHashInfo(UniAvailableCiphers[i].aiHash);
        pExchInfo = GetKeyExchangeInfo(UniAvailableCiphers[i].KeyExch);

        if(!IsCipherAllowed(pContext,
                            pCipherInfo,
                            pContext->RipeZombie->fProtocol,
                            pContext->RipeZombie->dwCF))
        {
            continue;
        }
        if(!IsHashAllowed(pContext, pHashInfo, pContext->RipeZombie->fProtocol))
        {
            continue;
        }
        if(!IsExchAllowed(pContext, pExchInfo, pContext->RipeZombie->fProtocol))
        {
            continue;
        }


        if(pContext->RipeZombie->fProtocol & SP_PROT_SSL3TLS1_SERVERS)
        {
            // Determine the credentials (and CSP) to use, based on the
            // key exchange algorithm.
            pctRet = SPPickClientCertificate(pContext,
                                             UniAvailableCiphers[i].KeyExch);

            if(pctRet != PCT_ERR_OK)
            {
                continue;
            }
        }

        pContext->RipeZombie->dwCipherSuiteIndex = i;
        pContext->RipeZombie->aiCipher  = UniAvailableCiphers[i].aiCipher;
        pContext->RipeZombie->dwStrength  = UniAvailableCiphers[i].dwStrength;
        pContext->RipeZombie->aiHash  = UniAvailableCiphers[i].aiHash;
        pContext->RipeZombie->SessExchSpec  = UniAvailableCiphers[i].KeyExch;

        return ContextInitCiphersFromCache(pContext);
    }

    return(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
}

// Server side cipher selection

SP_STATUS
Ssl3SelectCipherEx(
    PSPContext pContext,
    DWORD *pCipherSpecs,
    DWORD cCipherSpecs)
{
    DWORD i, j;
    SP_STATUS pctRet;
    PCipherInfo         pCipherInfo = NULL;
    PHashInfo           pHashInfo = NULL;
    PKeyExchangeInfo    pExchInfo = NULL;
    PSPCredential       pCred = NULL;
    BOOL                fFound;

    pContext->dwPendingCipherSuiteIndex = 0;

    // Loop through the supported SSL3 cipher suites.
    for(i = 0; i < UniNumCiphers; i++)
    {
        // Is this an SSL3 cipher suite?
        if(!(UniAvailableCiphers[i].fProt & pContext->RipeZombie->fProtocol))
        {
            continue;
        }

        pCipherInfo = GetCipherInfo(UniAvailableCiphers[i].aiCipher,
                                    UniAvailableCiphers[i].dwStrength);
        pHashInfo = GetHashInfo(UniAvailableCiphers[i].aiHash);
        pExchInfo = GetKeyExchangeInfo(UniAvailableCiphers[i].KeyExch);

        // Do we currently support this hash and key exchange algorithm?
        if(!IsHashAllowed(pContext, pHashInfo, pContext->RipeZombie->fProtocol))
        {
            DebugLog((DEB_TRACE, "Cipher %d - hash not supported\n", i));
            continue;
        }
        if(!IsExchAllowed(pContext, pExchInfo, pContext->RipeZombie->fProtocol))
        {
            DebugLog((DEB_TRACE, "Cipher %d - exch not supported\n", i));
            continue;
        }

        // Do we have an appropriate certificate?
        if(pContext->RipeZombie->fProtocol & SP_PROT_SSL3TLS1_SERVERS)
        {
            pctRet = SPPickServerCertificate(pContext,
                                             UniAvailableCiphers[i].KeyExch);

            if(pctRet != PCT_ERR_OK)
            {
                DebugLog((DEB_TRACE, "Cipher %d - certificate %d not found\n",
                    i, UniAvailableCiphers[i].KeyExch));
                continue;
            }
        }
        pCred = pContext->RipeZombie->pActiveServerCred;


        // Do we support this encryption algorithm/key length?
        if(!IsCipherSuiteAllowed(pContext,
                            pCipherInfo,
                            pContext->RipeZombie->fProtocol,
                            pCred->dwCF,
                            UniAvailableCiphers[i].dwFlags))
        {
            DebugLog((DEB_TRACE, "Cipher %d - cipher not supported\n", i));
            continue;
        }

        // Is this cipher suite supported by the client?
        for(fFound = FALSE, j = 0; j < cCipherSpecs; j++)
        {
            if(UniAvailableCiphers[i].CipherKind == pCipherSpecs[j])
            {
                fFound = TRUE;
                break;
            }
        }
        if(!fFound)
        {
            DebugLog((DEB_TRACE, "Cipher %d - not supported by client\n", i));
            continue;
        }


        if(UniAvailableCiphers[i].KeyExch == SP_EXCH_RSA_PKCS1)
        {
            // This is an RSA cipher suite, so make sure that the
            // CSP supports it.
            if(!IsAlgSupportedCapi(pContext->RipeZombie->fProtocol,
                                   UniAvailableCiphers + i,
                                   pCred->pCapiAlgs,
                                   pCred->cCapiAlgs))
            {
                DebugLog((DEB_TRACE, "Cipher %d - not supported by csp\n", i));
                continue;
            }
        }


        if(UniAvailableCiphers[i].KeyExch == SP_EXCH_DH_PKCS3)
        {
            // This is a DH cipher suite, so make sure that the
            // CSP supports it.
            if(!IsAlgSupportedCapi(pContext->RipeZombie->fProtocol,
                                   UniAvailableCiphers + i,
                                   pCred->pCapiAlgs,
                                   pCred->cCapiAlgs))
            {
                DebugLog((DEB_TRACE, "Cipher %d - not supported by csp\n", i));
                continue;
            }
        }


        // Use this cipher.
        pContext->RipeZombie->dwCipherSuiteIndex = i;
        pContext->RipeZombie->aiCipher      = UniAvailableCiphers[i].aiCipher;
        pContext->RipeZombie->dwStrength    = UniAvailableCiphers[i].dwStrength;
        pContext->RipeZombie->aiHash        = UniAvailableCiphers[i].aiHash;
        pContext->RipeZombie->SessExchSpec  = UniAvailableCiphers[i].KeyExch;
        pContext->RipeZombie->dwCF          = pCred->dwCF;

        return ContextInitCiphersFromCache(pContext);
    }

    LogCipherMismatchEvent();

    return SP_LOG_RESULT(PCT_ERR_SPECS_MISMATCH);
}


/*****************************************************************************/
VOID ComputeServerExchangeHashes(
    PSPContext pContext,
    PBYTE pbServerParams,      // in
    INT   iServerParamsLen,    // in
    PBYTE pbMd5HashVal,        // out
    PBYTE pbShaHashVal)        // out
{
    MD5_CTX Md5Hash;
    A_SHA_CTX ShaHash;

    //
    // md5_hash = MD5(ClientHello.random + ServerHello.random + ServerParams);
    //
    // sha_hash = SHA(ClientHello.random + ServerHello.random + ServerParams);
    //

    MD5Init(&Md5Hash);
    MD5Update(&Md5Hash, pContext->rgbS3CRandom, 32);
    MD5Update(&Md5Hash, pContext->rgbS3SRandom, 32);
    MD5Update(&Md5Hash, pbServerParams, iServerParamsLen);
    MD5Final(&Md5Hash);
    CopyMemory(pbMd5HashVal, Md5Hash.digest, 16);

    A_SHAInit(&ShaHash);
    A_SHAUpdate(&ShaHash, pContext->rgbS3CRandom, 32);
    A_SHAUpdate(&ShaHash, pContext->rgbS3SRandom, 32);
    A_SHAUpdate(&ShaHash, pbServerParams, iServerParamsLen);
    A_SHAFinal(&ShaHash, pbShaHashVal);
}

SP_STATUS
UnwrapSsl3Message(
    PSPContext pContext,
    PSPBuffer pMsgInput)
{
    SPBuffer   Encrypted;
    SPBuffer   Clean;
    SP_STATUS pctRet;
    SWRAP *pswrap = (SWRAP *)pMsgInput->pvBuffer;
    PBYTE pbMsg = (PBYTE)pMsgInput->pvBuffer;

    //
    // Validate 5 byte header.
    //

    // ProtocolVersion version;
    if(COMBINEBYTES(pbMsg[1], pbMsg[2])  < SSL3_CLIENT_VERSION)
    {
        pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

    if(COMBINEBYTES(pswrap->bcbMSBSize, pswrap->bcbLSBSize) <
                        pContext->pReadHashInfo->cbCheckSum)
    {
        return(PCT_ERR_ILLEGAL_MESSAGE);
    }

    Encrypted.pvBuffer = pMsgInput->pvBuffer;
    Encrypted.cbBuffer = pMsgInput->cbBuffer;
    Encrypted.cbData = pMsgInput->cbData;
    Clean.pvBuffer = (PUCHAR)pMsgInput->pvBuffer + sizeof(SWRAP);
    pctRet = Ssl3DecryptMessage(pContext, &Encrypted, &Clean);
    if(pctRet == PCT_ERR_OK)
    {
        pswrap->bcbMSBSize = MSBOF(Clean.cbData);
        pswrap->bcbLSBSize = LSBOF(Clean.cbData);
    }
    return(pctRet);
}



SP_STATUS
ParseAlertMessage(
    PSPContext pContext,
    PUCHAR pbAlertMsg,
    DWORD cbMessage
    )
{
    SP_STATUS   pctRet=PCT_ERR_OK;
    if(cbMessage != 2)
    {
        return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

    if(pbAlertMsg[0] != SSL3_ALERT_WARNING  &&  pbAlertMsg[0] != SSL3_ALERT_FATAL)
    {
        return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

    DebugLog((DEB_WARN, "AlertMessage, Alert Level -  %lx\n", (DWORD)pbAlertMsg[0]));
    DebugLog((DEB_WARN, "AlertMessage, Alert Description -  %lx\n", (DWORD)pbAlertMsg[1]));

    if(pbAlertMsg[0] == SSL3_ALERT_WARNING)
    {
        switch(pbAlertMsg[1])
        {
        case SSL3_ALERT_NO_CERTIFICATE:
            DebugLog((DEB_TRACE, "no_certificate alert\n"));
            pContext->State = SSL3_STATE_NO_CERT_ALERT;
            pctRet = PCT_ERR_OK;
            break;

        case SSL3_ALERT_CLOSE_NOTIFY:
            DebugLog((DEB_TRACE, "close_notify alert\n"));
            pctRet = SEC_I_CONTEXT_EXPIRED;
            break;

        default:
            DebugLog((DEB_TRACE, "Ignoring warning alert\n"));
            pctRet = PCT_ERR_OK;
            break;
        }
    }
    else
    {
        switch(pbAlertMsg[1])
        {
        case SSL3_ALERT_UNEXPECTED_MESSAGE:
            DebugLog((DEB_TRACE, "unexpected_message alert\n"));
            pctRet = SP_LOG_RESULT(SEC_E_ILLEGAL_MESSAGE);
            break;

        case TLS1_ALERT_BAD_RECORD_MAC:
            DebugLog((DEB_TRACE, "bad_record_mac alert\n"));
            pctRet = SP_LOG_RESULT(SEC_E_MESSAGE_ALTERED);
            break;

        case TLS1_ALERT_DECRYPTION_FAILED:
            DebugLog((DEB_TRACE, "decryption_failed alert\n"));
            pctRet = SP_LOG_RESULT(SEC_E_DECRYPT_FAILURE);
            break;

        case TLS1_ALERT_RECORD_OVERFLOW:
            DebugLog((DEB_TRACE, "record_overflow alert\n"));
            pctRet = SP_LOG_RESULT(SEC_E_ILLEGAL_MESSAGE);
            break;

        case SSL3_ALERT_DECOMPRESSION_FAIL:
            DebugLog((DEB_TRACE, "decompression_fail alert\n"));
            pctRet = SP_LOG_RESULT(SEC_E_MESSAGE_ALTERED);
            break;

        case SSL3_ALERT_HANDSHAKE_FAILURE:
            DebugLog((DEB_TRACE, "handshake_failure alert\n"));
            pctRet = SP_LOG_RESULT(SEC_E_ILLEGAL_MESSAGE);
            break;

        case TLS1_ALERT_BAD_CERTIFICATE:
            DebugLog((DEB_TRACE, "bad_certificate alert\n"));
            pctRet = SP_LOG_RESULT(SEC_E_CERT_UNKNOWN);
            break;

        case TLS1_ALERT_UNSUPPORTED_CERT:
            DebugLog((DEB_TRACE, "unsupported_cert alert\n"));
            pctRet = SP_LOG_RESULT(SEC_E_CERT_UNKNOWN);
            break;

        case TLS1_ALERT_CERTIFICATE_REVOKED:
            DebugLog((DEB_TRACE, "certificate_revoked alert\n"));
            pctRet = SP_LOG_RESULT(CRYPT_E_REVOKED);
            break;

        case TLS1_ALERT_CERTIFICATE_EXPIRED:
            DebugLog((DEB_TRACE, "certificate_expired alert\n"));
            pctRet = SP_LOG_RESULT(SEC_E_CERT_EXPIRED);
            break;

        case TLS1_ALERT_CERTIFICATE_UNKNOWN:
            DebugLog((DEB_TRACE, "certificate_unknown alert\n"));
            pctRet = SP_LOG_RESULT(SEC_E_CERT_UNKNOWN);
            break;

        case SSL3_ALERT_ILLEGAL_PARAMETER:
            DebugLog((DEB_TRACE, "illegal_parameter alert\n"));
            pctRet = SP_LOG_RESULT(SEC_E_ILLEGAL_MESSAGE);
            break;

        case TLS1_ALERT_UNKNOWN_CA:
            DebugLog((DEB_TRACE, "unknown_ca alert\n"));
            pctRet = SP_LOG_RESULT(SEC_E_UNTRUSTED_ROOT);
            break;

        case TLS1_ALERT_ACCESS_DENIED:
            DebugLog((DEB_TRACE, "access_denied alert\n"));
            pctRet = SP_LOG_RESULT(SEC_E_LOGON_DENIED);
            break;

        case TLS1_ALERT_DECODE_ERROR:
            DebugLog((DEB_TRACE, "decode_error alert\n"));
            pctRet = SP_LOG_RESULT(SEC_E_ILLEGAL_MESSAGE);
            break;

        case TLS1_ALERT_DECRYPT_ERROR:
            DebugLog((DEB_TRACE, "decrypt_error alert\n"));
            pctRet = SP_LOG_RESULT(SEC_E_DECRYPT_FAILURE);
            break;

        case TLS1_ALERT_EXPORT_RESTRICTION:
            DebugLog((DEB_TRACE, "export_restriction alert\n"));
            pctRet = SP_LOG_RESULT(SEC_E_ILLEGAL_MESSAGE);
            break;

        case TLS1_ALERT_PROTOCOL_VERSION:
            DebugLog((DEB_TRACE, "protocol_version alert\n"));
            pctRet = SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
            break;

        case TLS1_ALERT_INSUFFIENT_SECURITY:
            DebugLog((DEB_TRACE, "insuffient_security alert\n"));
            pctRet = SP_LOG_RESULT(SEC_E_ALGORITHM_MISMATCH);
            break;

        case TLS1_ALERT_INTERNAL_ERROR:
            DebugLog((DEB_TRACE, "internal_error alert\n"));
            pctRet = SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
            break;

        default:
            DebugLog((DEB_TRACE, "Unknown fatal alert\n"));
            pctRet = SP_LOG_RESULT(SEC_E_ILLEGAL_MESSAGE);
            break;
        }
    }

    return pctRet;
}


void BuildAlertMessage(PBYTE pbAlertMsg, UCHAR bAlertLevel, UCHAR bAlertDesc)
{
    ALRT *palrt = (ALRT *) pbAlertMsg;

    FillMemory(palrt, sizeof(ALRT), 0);

    palrt->bCType = SSL3_CT_ALERT;
    palrt->bMajor = SSL3_CLIENT_VERSION_MSB;
//  palrt->bMinor = SSL3_CLIENT_VERSION_LSB; DONE by FillMemory
//  palrt->bcbMSBSize = 0; Done by FillMemory
    palrt->bcbLSBSize = 2;
    palrt->bAlertLevel = bAlertLevel;
    palrt->bAlertDesc  = bAlertDesc ;
}


SP_STATUS SPPacketSplit(BYTE bContentType, PSPBuffer pPlain)
    //Now let's us see whether we have the FULL-handshake
    {
        SP_STATUS pctRet = PCT_ERR_OK;
        PBYTE pb;
        DWORD cb;

        pb = pPlain->pvBuffer;

        switch(bContentType)
        {
        case SSL3_CT_HANDSHAKE:
            if(pPlain->cbData >= sizeof(SHSH))
            {
                cb = ((INT)pb[1] << 16) + ((INT)pb[2] << 8) + (INT)pb[3];
                cb += sizeof(SHSH);
                if( cb > pPlain->cbData)
                {
                    return(PCT_INT_INCOMPLETE_MSG);
                }

            }
            else
                return(PCT_INT_INCOMPLETE_MSG);
            break;
        case SSL3_CT_ALERT:
            if(pPlain->cbData != 2)
                return(PCT_INT_INCOMPLETE_MSG);
            break;
        case SSL3_CT_CHANGE_CIPHER_SPEC:
            if(pPlain->cbData != 1)
                return(PCT_INT_INTERNAL_ERROR);
        default:
            break;
        }

        return(pctRet);
    }



/*****************************************************************************/
// Create an encrypted Finish message, adding it to the end of the
// specified buffer object.
//
SP_STATUS SPBuildTls1FinalFinish(PSPContext pContext, PSPBuffer pBuffer, BOOL fClient)
{
    PBYTE pbMessage = (PBYTE)pBuffer->pvBuffer + pBuffer->cbData;
    DWORD cbFinished;
    SP_STATUS pctRet;
    DWORD cbDataOut;

    BYTE  rgbDigest[CB_TLS1_VERIFYDATA];

    // Build Finished message body.
    pctRet = Tls1BuildFinishMessage(pContext, rgbDigest, sizeof(rgbDigest), fClient);
    if(pctRet != PCT_ERR_OK)
    {
        return pctRet;
    }

    CopyMemory(pbMessage + sizeof(SWRAP) + sizeof(SHSH),
               rgbDigest,
               CB_TLS1_VERIFYDATA);

    // Build Finished handshake header.
    SetHandshake(pbMessage + sizeof(SWRAP),
                 SSL3_HS_FINISHED,
                 NULL,
                 CB_TLS1_VERIFYDATA);
    cbFinished = sizeof(SHSH) + CB_TLS1_VERIFYDATA;

    // Update handshake hash objects.
    pctRet = UpdateHandshakeHash(pContext,
                                 pbMessage + sizeof(SWRAP),
                                 cbFinished,
                                 FALSE);
    if(pctRet != PCT_ERR_OK)
    {
        return(pctRet);
    }

    // Add record header and encrypt message.
    pctRet = SPSetWrap(pContext,
            pbMessage,
            SSL3_CT_HANDSHAKE,
            cbFinished,
            fClient,
            &cbDataOut);

    if(pctRet != PCT_ERR_OK)
    {
        return(pctRet);
    }

    // Update buffer length .
    pBuffer->cbData += cbDataOut;

    SP_ASSERT(pBuffer->cbData <= pBuffer->cbBuffer);

    return pctRet;
}


//+---------------------------------------------------------------------------
//
//  Function:   Tls1BuildFinishMessage
//
//  Synopsis:   Compute a TLS MAC for the specified message.
//
//  Arguments:  [pContext]      --  Schannel context.
//              [pbVerifyData]  --  Verify data buffer.
//              [cbVerifyData]  --  Length of verify data buffer.
//              [fClient]       --  Client-generated Finished?
//
//  History:    10-13-97   jbanes   Created.
//
//  Notes:      The Finished message is computed using the following formula:
//
//              verify_data = PRF(master_secret, finished_label,
//                                MD5(handshake_messages) +
//                                SHA-1(handshake_messages)) [0..11];
//
//----------------------------------------------------------------------------
SP_STATUS
Tls1BuildFinishMessage(
    PSPContext  pContext,       // in
    PBYTE       pbVerifyData,   // out
    DWORD       cbVerifyData,   // in
    BOOL        fClient)        // in
{
    PBYTE pbLabel;
    DWORD cbLabel;
    UCHAR rgbData[CB_MD5_DIGEST_LEN + CB_SHA_DIGEST_LEN];
    DWORD cbData;
    HCRYPTHASH hHash = 0;
    CRYPT_DATA_BLOB Data;
    SP_STATUS pctRet;

    if(cbVerifyData < CB_TLS1_VERIFYDATA)
    {
        return SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
    }

    if(fClient)
    {
        pbLabel = TLS1_LABEL_CLIENTFINISHED;
    }
    else
    {
        pbLabel = TLS1_LABEL_SERVERFINISHED;
    }
    cbLabel = CB_TLS1_LABEL_FINISHED;


    // Get the MD5 hash of the handshake messages so far.
    if(!SchCryptDuplicateHash(pContext->hMd5Handshake,
                              NULL,
                              0,
                              &hHash,
                              pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto error;
    }

    cbData = CB_MD5_DIGEST_LEN;
    if(!SchCryptGetHashParam(hHash,
                             HP_HASHVAL,
                             rgbData,
                             &cbData,
                             0,
                             pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto error;
    }

    if(!SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
    }
    hHash = 0;

    // Get the SHA hash of the handshake messages so far.
    if(!SchCryptDuplicateHash(pContext->hShaHandshake,
                              NULL,
                              0,
                              &hHash,
                              pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto error;
    }

    cbData = A_SHA_DIGEST_LEN;
    if(!SchCryptGetHashParam(hHash,
                             HP_HASHVAL,
                             rgbData + CB_MD5_DIGEST_LEN,
                             &cbData,
                             0,
                             pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto error;
    }

    cbData = CB_MD5_DIGEST_LEN + CB_SHA_DIGEST_LEN;

    if(!SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
    }
    hHash = 0;

    // Compute the PRF
    if(!SchCryptCreateHash(pContext->RipeZombie->hMasterProv,
                           CALG_TLS1PRF,
                           pContext->RipeZombie->hMasterKey,
                           0,
                           &hHash,
                           pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto error;
    }

    Data.pbData = pbLabel;
    Data.cbData = cbLabel;
    if(!SchCryptSetHashParam(hHash,
                             HP_TLS1PRF_LABEL,
                             (PBYTE)&Data,
                             0,
                             pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto error;
    }

    Data.pbData = rgbData;
    Data.cbData = cbData;
    if(!SchCryptSetHashParam(hHash,
                             HP_TLS1PRF_SEED,
                             (PBYTE)&Data,
                             0,
                             pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto error;
    }

    if(!SchCryptGetHashParam(hHash,
                             HP_HASHVAL,
                             pbVerifyData,
                             &cbVerifyData,
                             0,
                             pContext->RipeZombie->dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto error;
    }

    pctRet = PCT_ERR_OK;


error:

    if(hHash)
    {
        if(!SchCryptDestroyHash(hHash, pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
        }
    }

    return pctRet;
}

SP_STATUS
SPBuildTlsAlertMessage(
    PSPContext  pContext,       // in
    PSPBuffer pCommOutput)
{
    PBYTE pbMessage = NULL;
    DWORD cbMessage;
    BOOL  fAllocated = FALSE;
    SP_STATUS pctRet;
    DWORD cbDataOut;

    SP_BEGIN("SPBuildTlsAlertMessage");

    cbMessage =  sizeof(SWRAP) +
                         CB_SSL3_ALERT_ONLY +
                         SP_MAX_DIGEST_LEN +
                         SP_MAX_BLOCKCIPHER_SIZE;

    if(pContext->State != TLS1_STATE_ERROR)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    if(pCommOutput->pvBuffer)
    {
        // Application has allocated memory.
        if(pCommOutput->cbBuffer < cbMessage)
        {
            pCommOutput->cbData = cbMessage;
            return SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
        }
        fAllocated = TRUE;
    }
    else
    {
        // Schannel is to allocate memory.
        pCommOutput->cbBuffer = cbMessage;
        pCommOutput->pvBuffer = SPExternalAlloc(cbMessage);
        if(pCommOutput->pvBuffer == NULL)
        {
            SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
        }
    }
    pCommOutput->cbData = 0;


    pbMessage = (PBYTE)pCommOutput->pvBuffer;


     // Build alert message.
    BuildAlertMessage(pbMessage,
                      pContext->bAlertLevel,
                      pContext->bAlertNumber);

#if DBG
    DBG_HEX_STRING(DEB_TRACE, pbMessage, sizeof(ALRT));
#endif

    // Build record header and encrypt message.
    pctRet = SPSetWrap(pContext,
                pbMessage,
                SSL3_CT_ALERT,
                CB_SSL3_ALERT_ONLY,
                pContext->dwProtocol & SP_PROT_SSL3TLS1_CLIENTS,
                &cbDataOut);

    if(pctRet !=  PCT_ERR_OK)
    {
        if(!fAllocated)
        {
            SPExternalFree(pCommOutput->pvBuffer);
            pCommOutput->pvBuffer = NULL;
        }
        SP_RETURN(SP_LOG_RESULT(pctRet));
    }

    // Update buffer length.
    pCommOutput->cbData = cbDataOut;

    SP_AS