******************************************************************
*
* class DuVisual
*
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* DuVisual::GetSize
*
* GetSize() provides fast access to return the logical (non XForm'd) size 
* of this DuVisual.
*
\***************************************************************************/

void        
DuVisual::GetSize(SIZE * psizeLogicalPxl) const
{
    AssertWritePtr(psizeLogicalPxl);

    psizeLogicalPxl->cx = m_rcLogicalPxl.right - m_rcLogicalPxl.left;
    psizeLogicalPxl->cy = m_rcLogicalPxl.bottom - m_rcLogicalPxl.top;
}


/***************************************************************************\
*
* DuVisual::GetLogRect
*
* GetLogRect() returns the logical rectangle for this DuVisual.
*
\***************************************************************************/

void        
DuVisual::GetLogRect(RECT * prcPxl, UINT nFlags) const
{
    AssertWritePtr(prcPxl);
    Assert((nFlags & SGR_RECTMASK) == nFlags);
    AssertMsg(!TestFlag(nFlags, SGR_ACTUAL), "Only supports logical");

    //
    // Get the information
    //

    switch (nFlags & SGR_RECTMASK)
    {
    default:
    case SGR_OFFSET:
    case SGR_PARENT:
        if (m_fRelative || IsRoot()) {
            //
            // Asking for parent (relative) and already relative, so just return out.
            //
            // NOTE: Unlike other coordinate types, if we don't have a parent, we can
            // still return relative coordinates!
            //

            InlineCopyRect(prcPxl, &m_rcLogicalPxl);
        } else {
            //
            // Asking for parent (relative), but not relative, so get parent and offset
            //

            AssertMsg(GetParent() != NULL, "Must have a parent for this path");
            AssertMsg(!GetParent()->m_fRelative, "Parent can not be relative if we are not");
            
            const RECT & rcParentPxl = GetParent()->m_rcLogicalPxl;

            prcPxl->left    = m_rcLogicalPxl.left - rcParentPxl.left;
            prcPxl->top     = m_rcLogicalPxl.top - rcParentPxl.top ;
            prcPxl->right   = prcPxl->left + (m_rcLogicalPxl.right - m_rcLogicalPxl.left);
            prcPxl->bottom  = prcPxl->top + (m_rcLogicalPxl.bottom - m_rcLogicalPxl.top);
        }
        break;

    case SGR_CONTAINER:
        if (m_fRelative && (GetParent() != NULL)) {
            //
            // Asking for container rect and relative, so get container rect of
            // parent and offset us.
            //

            RECT rcParentPxl;
            GetParent()->GetLogRect(&rcParentPxl, SGR_CONTAINER);
            InlineCopyRect(prcPxl, &m_rcLogicalPxl);
            InlineOffsetRect(prcPxl, rcParentPxl.left, rcParentPxl.top);
        } else {
            //
            // Asking for container and not relative, so just return out
            //

            InlineCopyRect(prcPxl, &m_rcLogicalPxl);
        }
        break;

    case SGR_DESKTOP:
        if (m_fRelative && (GetParent() != NULL)) {
            RECT rcParentPxl;
            GetParent()->GetLogRect(&rcParentPxl, SGR_DESKTOP);
            InlineCopyRect(prcPxl, &m_rcLogicalPxl);
            InlineOffsetRect(prcPxl, rcParentPxl.left, rcParentPxl.top);
        } else {
            RECT rcContainerPxl;
            GetContainer()->OnGetRect(&rcContainerPxl);
            InlineCopyRect(prcPxl, &m_rcLogicalPxl);
            InlineOffsetRect(prcPxl, rcContainerPxl.left, rcContainerPxl.top);
        }
        break;

    case SGR_CLIENT:
        InlineCopyZeroRect(prcPxl, &m_rcLogicalPxl);
        break;
    }
}


/***************************************************************************\
*
* DuVisual::xdSetLogRect
*
* xdSetRect() changes the logical rectangle for this DuVisual.
*
\***************************************************************************/

HRESULT
DuVisual::xdSetLogRect(int x, int y, int w, int h, UINT nFlags)
{
    AssertMsg(!TestFlag(nFlags, SGR_ACTUAL), "Only supports logical");

    UINT nRectType      = nFlags & SGR_RECTMASK;
    BOOL fInvalidate    = !TestFlag(nFlags, SGR_NOINVALIDATE);

    BOOL fRoot = IsRoot();
    AssertMsg((!fRoot) || (!TestFlag(nFlags, SGR_MOVE)),
            "Can not move a root");

#if DBG
    if (TestFlag(nFlags, SGR_SIZE)) {
        AssertMsg((w >= 0) && (h >= 0), "Ensure non-negative size when resizing");
    }
#endif // DBG

    //
    // Change the information
    //

    RECT rcOldParentPxl, rcNewActualPxl;
    GetLogRect(&rcOldParentPxl, SGR_PARENT);
    InlineCopyRect(&rcNewActualPxl, &m_rcLogicalPxl);
    
    UINT nChangeFlags = 0;


    //
    // Change the position
    //

    if (TestFlag(nFlags, SGR_MOVE)) {
        switch (nRectType)
        {
        case SGR_PARENT:
            if (m_fRelative || IsRoot()) {
                rcNewActualPxl.left = x;
                rcNewActualPxl.top  = y;
            } else {
                RECT rcParentConPxl;
                GetParent()->GetLogRect(&rcParentConPxl, SGR_CONTAINER);
                rcNewActualPxl.left = x + rcParentConPxl.left;
                rcNewActualPxl.top  = y + rcParentConPxl.top;
            }
            break;

        case SGR_CONTAINER:
            if (m_fRelative && (GetParent() != NULL)) {
                RECT rcParentConPxl;
                GetParent()->GetLogRect(&rcParentConPxl, SGR_CONTAINER);
                rcNewActualPxl.left = x - rcParentConPxl.left;
                rcNewActualPxl.top  = y - rcParentConPxl.top;
            } else {
                rcNewActualPxl.left   = x;
                rcNewActualPxl.top    = y;
            }
            break;

        case SGR_DESKTOP:
            AssertMsg(0, "Not implemented");
            return E_NOTIMPL;

        case SGR_OFFSET:
            rcNewActualPxl.left += x;
            rcNewActualPxl.top  += y;
            break;

        case SGR_CLIENT:
            // Can't set using the client rect
            return E_INVALIDARG;

        default:
            return E_NOTIMPL;
        }

        if ((rcNewActualPxl.left != m_rcLogicalPxl.left) ||
            (rcNewActualPxl.top != m_rcLogicalPxl.top)) {

            //
            // Actually moved the Gadget
            //

            SetFlag(nChangeFlags, SGR_MOVE);
        }
    }


    //
    // Change the size
    //

    SIZE sizeOld;
    sizeOld.cx = m_rcLogicalPxl.right - m_rcLogicalPxl.left;
    sizeOld.cy = m_rcLogicalPxl.bottom - m_rcLogicalPxl.top;

    if (TestFlag(nFlags, SGR_SIZE) && ((w != sizeOld.cx) || (h != sizeOld.cy))) {
        SetFlag(nChangeFlags, SGR_SIZE);

        rcNewActualPxl.right  = rcNewActualPxl.left + w;
        rcNewActualPxl.bottom = rcNewActualPxl.top + h;
    } else {
        //
        // Not actually resizing the DuVisual, so just update the right and 
        // bottom from the original size.
        //

        rcNewActualPxl.right  = rcNewActualPxl.left + sizeOld.cx;
        rcNewActualPxl.bottom = rcNewActualPxl.top + sizeOld.cy;
    }


    if (nChangeFlags) {
        AssertMsg(!InlineEqualRect(&m_rcLogicalPxl, &rcNewActualPxl), 
                "Ensure recorded change actually occured");


        //
        // Check against wrap-around.  
        //
        // NOTE: This must be done after recomputing everything, since there are
        // many combinations of location / size changes that may cause a 
        // wrap-around.
        //

        if ((rcNewActualPxl.right < rcNewActualPxl.left) || (rcNewActualPxl.bottom < rcNewActualPxl.top)) {
            PromptInvalid("New location exceeds coordinate limits");
            return E_INVALIDARG;
        }
                

        //
        // Remember how much we moved
        //

        SIZE sizeDelta;
        sizeDelta.cx    = rcNewActualPxl.left - m_rcLogicalPxl.left;
        sizeDelta.cy    = rcNewActualPxl.top - m_rcLogicalPxl.top;


        //
        // Now that the new rectangle has been determined, need to commit it 
        // back.  
        //

        m_rcLogicalPxl = rcNewActualPxl;


        //
        // Need to go through all of children moving them if they are not relative 
        // and we are not relative.
        //
        if (TestFlag(nChangeFlags, SGR_MOVE) && (!m_fRelative)) {
            AssertMsg((sizeDelta.cx != 0) || (sizeDelta.cy != 0), 
                    "Must actually move if SGR_MOVE was set on nChangeFlags");

            DuVisual * pgadCur = GetTopChild();
            while (pgadCur != NULL) {
                if (!pgadCur->m_fRelative) {
                    pgadCur->SLROffsetLogRect(&sizeDelta);
                }
                pgadCur = pgadCur->GetNext();
            }
        }


        //
        // Finally, if the rect was changed, notify the Gadget and 
        // invalidate / update the affected areas.
        //

        RECT rcNewParentPxl;
        GetLogRect(&rcNewParentPxl, SGR_PARENT);
        m_cb.xdFireChangeRect(this, &rcNewParentPxl, nChangeFlags | SGR_PARENT);

        if (fInvalidate && IsVisible()) {
            SLRUpdateBits(&rcOldParentPxl, &rcNewParentPxl, nChangeFlags);
        }

        xdUpdatePosition();
        xdUpdateAdaptors(GSYNC_RECT);
    } else {
        AssertMsg(InlineEqualRect(&m_rcLogicalPxl, &rcNewActualPxl), 
                "Rect change was not properly recorded");
    }

    return S_OK;
}


/***************************************************************************\
*
* DuVisual::SLRUpdateBits
*
* SLRUpdateBits() optimizes how invalidation and update of a Gadget after
* it has been repositioned or resized by xdSetLogRect().  There are a bunch
* of checks that can short-circuit what needs to be done to minimize the
* amount of repainting and flickering.
*
\***************************************************************************/

void
DuVisual::SLRUpdateBits(
    IN  RECT * prcOldParentPxl,         // Old location in parent pixels
    IN  RECT * prcNewParentPxl,         // New location in container pixels
    IN  UINT nChangeFlags)              // Change flags
{
    AssertMsg(IsVisible(), "Only should be called on visible Gadgets");

    //
    // If the parent has already been completely invalidated, we don't need 
    // to invalidate any children.
    //

    if (IsParentInvalid()) {
        return;
    }


    //
    // The rectangle is visible, so we need to invalidate both the old
    // and new positions.  These need to be computed in the current 
    // CLIENT coordinates so that any XForms can be properly taken into
    // account.
    //

    DuContainer * pcon = GetContainer();

#if DBG
    RECT rcBackupOldConPxl = *prcOldParentPxl;
    RECT rcBackupNewConPxl = *prcNewParentPxl;

    UNREFERENCED_PARAMETER(rcBackupOldConPxl);
    UNREFERENCED_PARAMETER(rcBackupNewConPxl);
#endif // DBG

#if ENABLE_OPTIMIZESLRUPDATE
    //
    // Let the optimizations begin!
    // 
    // NOTE: Remember that GDI coordinates are a little screwy.  Any time we
    // use left for right or right for left, we need to +1 or -1 appropriately.
    // (Same for top and bottom)
    //
    // At this point, this Gadget already has an updated position and size.
    // When calling DoInvalidateRect() to invalidate, the old position may 
    // be clipped inside the new position.  To fix, pass in coordinates on the
    // PARENT Gadget instead of the Gadget being moved.  This should give a
    // correct result.
    //

    if (nChangeFlags == SGR_SIZE) {
        //
        // Pure sizing optimizations:
        // Unless the XREDRAW flag is turned on specifying that the entire 
        // Gadget needs to repaint when resized, limit the invalid area to the 
        // difference between the two rectangles.
        //

        int xOffset = - prcNewParentPxl->left;
        int yOffset = - prcNewParentPxl->top;

        RECT * prcOldClientPxl = prcOldParentPxl;
        RECT * prcNewClientPxl = prcNewParentPxl;

        InlineOffsetRect(prcOldClientPxl, xOffset, yOffset);
        InlineOffsetRect(prcNewClientPxl, xOffset, yOffset);


        AssertMsg((prcOldClientPxl->left == prcNewClientPxl->left) &&
                (prcOldClientPxl->top == prcNewClientPxl->top), "Ensure position has not moved");

        if ((!m_fHRedraw) || (!m_fVRedraw)) {
            BOOL fChangeHorz    = (prcOldClientPxl->right != prcNewClientPxl->right);
            BOOL fChangeVert    = (prcOldClientPxl->bottom != prcNewClientPxl->bottom);

            RECT rgrcInvalidClientPxl[2];
            int idxCurRect = 0;

            BOOL fPadding = FALSE;
            RECT rcPadding = { 0, 0, 0, 0 };

            ReadOnlyLock rol;
            fPadding = m_cb.xrFireQueryPadding(this, &rcPadding);

            if (fChangeHorz && (!m_fHRedraw)) {
                RECT * prcCur   = &rgrcInvalidClientPxl[idxCurRect++];
                prcCur->left    = min(prcOldClientPxl->right, prcNewClientPxl->right) - 1;
                prcCur->right   = max(prcOldClientPxl->right, prcNewClientPxl->right);
                prcCur->top     = prcNewClientPxl->top;
                prcCur->bottom  = max(prcOldClientPxl->bottom, prcNewClientPxl->bottom);

                if (fPadding) {
                    prcCur->right -= rcPadding.right;
                    if (prcCur->right < prcCur->left) {
                        prcCur->right = prcCur->left;
                    }
                }

                fChangeHorz     = FALSE;
            }

            if (fChangeVert && (!m_fVRedraw)) {
                RECT * prcCur   = &rgrcInvalidClientPxl[idxCurRect++];
                prcCur->left    = prcNewClientPxl->left;
                prcCur->right   = max(prcOldClientPxl->right, prcNewClientPxl->right);
                prcCur->top     = min(prcOldClientPxl->bottom, prcNewClientPxl->bottom) - 1;
                prcCur->bottom  = max(prcOldClientPxl->bottom, prcNewClientPxl->bottom);

                if (fPadding) {
                    prcCur->bottom -= rcPadding.bottom;
                    if (prcCur->bottom < prcCur->top) {
                        prcCur->bottom = prcCur->top;
                    }
                }

                fChangeVert     = FALSE;
            }

            if (fChangeHorz || fChangeVert) {
                //
                // We were unable to remove all of the changes, so we need to 
                // invalidate the maximum area.
                //

                RECT rcMax;
                rcMax.left      = 0;
                rcMax.top       = 0;
                rcMax.right     = max(prcNewClientPxl->right, prcOldClientPxl->right);
                rcMax.bottom    = max(prcNewClientPxl->bottom, prcOldClientPxl->bottom);

                SLRInvalidateRects(pcon, &rcMax, 1);
                return;
            } else if (idxCurRect > 0) {
                //
                // We were able to optimize out the invalidate with H/VRedraw,
                // so invalidate the built rectangles.
                //

                SLRInvalidateRects(pcon, rgrcInvalidClientPxl, idxCurRect);
                return;
            }
        }
    }
#endif // ENABLE_OPTIMIZESLRUPDATE


    //
    // We were not able to optimize, so need to invalidate both the old and 
    // new locations so that everything gets properly redrawn.
    //


    //
    // Invalidate the old location.  We can NOT just call SLRInvalidateRects()
    // because this works off our current location.
    //
    // To invalidate the old location:
    // - Offset from parent to client
    // - Apply XForms to scale to the correct bounding area
    // - Offset back from client to parent
    // - Invalidate
    //

    DuVisual * pgadParent = GetParent();
    if (pgadParent != NULL) {
        RECT rcOldClientPxl, rcOldParentClientPxl;
        SIZE sizeDeltaPxl;

        InlineCopyZeroRect(&rcOldClientPxl, prcOldParentPxl);
        DoXFormClientToParent(&rcOldParentClientPxl, &rcOldClientPxl, 1, HINTBOUNDS_Invalidate);

        sizeDeltaPxl.cx = prcNewParentPxl->left - prcOldParentPxl->left;
        sizeDeltaPxl.cy = prcNewParentPxl->top - prcOldParentPxl->top;
        InlineOffsetRect(&rcOldParentClientPxl, -sizeDeltaPxl.cx, -sizeDeltaPxl.cy);

        pgadParent->DoInvalidateRect(pcon, &rcOldParentClientPxl, 1);
    }


    //
    // Invalidate the new location
    //

    RECT rcNewClientPxl;
    InlineCopyZeroRect(&rcNewClientPxl, prcNewParentPxl);
    SLRInvalidateRects(pcon, &rcNewClientPxl, 1);


    //
    // Mark this Gadget as completely invalid
    //

    m_fInvalidFull  = TRUE;
#if ENABLE_OPTIMIZEDIRTY
    m_fInvalidDirty = TRUE;
#endif
    
    if (pgadParent != NULL) {
        pgadParent->MarkInvalidChildren();
    }
}


/***************************************************************************\
*
* DuVisual::SLRInvalidateRects
*
* SLRInvalidateRects() invalidates a collection of client-relative rects
* that are now need to be updated as a result of xdSetLogRect().
* 
* NOTE: This is NOT a general purpose invalidation function and has been
* designed specifically for use in SLRUpdateBits();
*
\***************************************************************************/

void        
DuVisual::SLRInvalidateRects(
    IN  DuContainer * pcon,             // Container (explicit for perf reasons)
    IN  const RECT * rgrcClientPxl,     // Invalid area in client pixels.
    IN  int cRects)                     // Number of rects to convert
{
    DuVisual * pgadParent = GetParent();
    if (pgadParent) {
        //
        // We have a parent, so pass the coordinates to invalid in as 
        // parent coordinates so that old positions don't get clipped 
        // by the new position.
        //

        RECT * rgrcParentPxl = (RECT *) _alloca(cRects * sizeof(RECT));
        DoXFormClientToParent(rgrcParentPxl, rgrcClientPxl, cRects, HINTBOUNDS_Invalidate);
        pgadParent->DoInvalidateRect(pcon, rgrcParentPxl, cRects);

    } else {
        DoInvalidateRect(pcon, rgrcClientPxl, cRects);
    }
}


/***************************************************************************\
*
* DuVisual::SLROffsetLogRect
*
* SLROffsetLogRect() deep walks through all non-relative child of a subtree,
* offsetting their position relative to their parent.  This function is 
* designed to be called from xdSetLogRect() when moving a non-relative Gadget.
*
* NOTE: Only the "top" Gadget will be notified that it has been moved.  Its
* children are not notified.  This is consistent with Win32 HWND's.  Also,
* SimpleGadget's will not be re-invalidated since their parent has already
* been invalidated.
*
\***************************************************************************/

void        
DuVisual::SLROffsetLogRect(const SIZE * psizeDeltaPxl)
{
    AssertMsg(GetParent() != NULL, "Should only call on children");
    AssertMsg((psizeDeltaPxl->cx != 0) || (psizeDeltaPxl->cy != 0), 
            "Ensure actually moving child Gadget");

    m_rcLogicalPxl.left     += psizeDeltaPxl->cx;
    m_rcLogicalPxl.top      += psizeDeltaPxl->cy;
    m_rcLogicalPxl.right    += psizeDeltaPxl->cx;
    m_rcLogicalPxl.bottom   += psizeDeltaPxl->cy;

    DuVisual * pgadCur = GetTopChild();
    while (pgadCur != NULL) {
        if (!pgadCur->m_fRelative) {
            pgadCur->SLROffsetLogRect(psizeDeltaPxl);
        }
        pgadCur = pgadCur->GetNext();
    }
}


/***************************************************************************\
*
* DuVisual::FindStepImpl
*
* FindStepImpl() processes a single step inside FindFromPoint()   A given 
* point will be properly transformed from its current parent coordinates 
* into coordinates for the specified DuVisual and compared against the logical 
* rectangle.
*
* This function should not be called directly and is designed to be called
* only from FindFromPoint() and is designed to have high-speed execution.
*
\***************************************************************************/

BOOL
DuVisual::FindStepImpl(
    IN  const DuVisual * pgadCur, // Current DuVisual
    IN  int xOffset,                // DuVisual X offset from parent
    IN  int yOffset,                // DuVisual Y offset from parent
    IN OUT POINT * pptFindPxl       // Point to apply modify for Find step
    ) const
{
    //
    // It is very important to apply these transformations in the correct
    // order, of the point that is computed will not match was was actually
    // drawn.
    //

    //
    // First, offset the origin on the DuVisual.  We need to do this before
    // applying the XForm matrix.  If we were using Matrix.Translate() to do
    // this, we would do this after applying any Scale() and Rotate().
    //

    pptFindPxl->x -= xOffset;
    pptFindPxl->y -= yOffset;


    //
    // Apply XForms to search point
    //

    if (m_fXForm) {
        XFormInfo * pxfi = GetXFormInfo();

        Matrix3 matTemp;
        pxfi->ApplyAnti(&matTemp);
        matTemp.Execute(pptFindPxl, 1);
    }


    //
    // We have a point, so determine use the bounding rectangle to determine
    // if this point is inside this DuVisual
    //

    RECT rcChildPxl;
    InlineCopyZeroRect(&rcChildPxl, &pgadCur->m_rcLogicalPxl);
    return InlinePtInRect(&rcChildPxl, *pptFindPxl);
}


/***************************************************************************\
*
* DuVisual::FindFromPoint
*
* FindFromPoint() walks a DuVisual-tree looking for a DuVisual that hit-tests
* with a given point in coordinate pixels.  
* 
* NOTE: This function has been written to directly take information 
* including relative coordinates and XForms into account to give better 
* performance.  This function is called very often (for every mouse move) 
* and needs to be very high-performance.
*
* The design of this algorithm is slightly different than how Win32k/User 
* searches.  In NT-User, all WND's are stored using absolute 
* desktop-relative positioning.  The search begins at the top of the tree 
* and flows down, performing flat PtInRect comparisons against each WND's
* rectangle.  The search point (ptContainerPxl) is NOT modified during the
* search.
*
* In DirectUser/Core, each DuVisual may be either relative or absolutely 
* positioned to its parent.  They may also have transformation information.
* To acheive high-performance, the point is modified into client coordinates
* for each DuVisual.  If the point is inside this DuVisual, ptContainerPxl is
* updated and the scan continues from that DuVisual.  If the point is not
* inside, it is restored to the previous point and searching continues along
* the siblings.  By modifying the point as it is traversed down the tree,
* only DuVisuals with actual transformations need to apply Matrix operations
* to transform the point.
*
\***************************************************************************/

DuVisual *      
DuVisual::FindFromPoint(
    IN  POINT ptThisClientPxl,      // Container point to start searching from
    IN  UINT nStyle,                // Required style
    OUT POINT * pptFoundClientPxl   // Optional resulting point in client pixels
    ) const
{
    if (pptFoundClientPxl != NULL) {
        pptFoundClientPxl->x = ptThisClientPxl.x;
        pptFoundClientPxl->y = ptThisClientPxl.y;
    }
    
    //
    // Check conditions
    //

    if (!TestAllFlags(m_nStyle, nStyle)) {
        return NULL;
    }
    
    
    //
    // Setup the point to search from.  If not at the top of the tree, 
    // need to build a XForm matrix to modify the point.
    //
    // Determine if the point is in the DuVisual that we are starting in.  If 
    // not, have a short-way out.  This has to be done after the point has 
    // already been setup.
    //

    POINT ptParentPxl, ptTest;
    if (!FindStepImpl(this, 0, 0, &ptThisClientPxl)) {
        return NULL;  // Point not inside root DuVisual
    }

    const DuVisual * pgadCur = this;

    
    //
    // Start continuously updated parent coordinates in upper left corner.  As
    // we find each successive containing DuVisual, these will be updated to the
    // new parent coordinates.
    //

    ptParentPxl.x   = 0;
    ptParentPxl.y   = 0;


    //
    // Scan down the tree, looking for intersections with this point and a
    // child's location.
    //

ScanChild:
    const DuVisual * pgadChild = pgadCur->GetTopChild();
    while (pgadChild != NULL) {
        //
        // Check if Gadget matches the specified flags.
        //


        if (!TestAllFlags(pgadChild->m_nStyle, nStyle)) {
            goto ScanNextSibling;
        }


        //
        // Check if point is "inside" the Gadget.
        //

        {
            int xOffset = pgadChild->m_rcLogicalPxl.left;
            int yOffset = pgadChild->m_rcLogicalPxl.top;

            if (!pgadChild->m_fRelative) {
                xOffset -= ptParentPxl.x;
                yOffset -= ptParentPxl.y;
            }

            ptTest = ptThisClientPxl;
            if (pgadChild->FindStepImpl(pgadChild, xOffset, yOffset, &ptTest)) {
                //
                // If the Gadget has an irregular shape, we need to callback 
                // and ask if the point is actually inside or not.
                //

                if (pgadChild->m_fCustomHitTest) {
                    //
                    // The application is not allowed to modify the tree while 
                    // we are calling back on each node to hit-test.
                    //

                    ReadOnlyLock rol;

                    POINT ptClientPxl;
                    ptClientPxl.x   = ptThisClientPxl.x - xOffset;
                    ptClientPxl.y   = ptThisClientPxl.y - yOffset;

                    UINT nResult;
                    pgadChild->m_cb.xrFireQueryHitTest(pgadChild, ptClientPxl, &nResult);
                    switch (nResult)
                    {
                    case GQHT_NOWHERE:
                        // Not inside this Gadget, so continue checking its sibling
                        goto ScanNextSibling;

                    default:
                    case GQHT_INSIDE:
                        // Inside this Gadget, so continue processing normally
                        break;

                    case GQHT_CHILD:
                        // We were directly given an HGADGET back, so validate it
                        // and continue processing from it.

                        // TODO: Implement this code.
                        break;
                    }
                }


                //
                // We now know that the point is inside the Gadget, so setup for
                // another loop to check our children.
                //

                if (pgadChild->m_fRelative) {
                    //
                    // Relative child intersects.  Update the "parent" 
                    // coordinates and scan this child.
                    //

                    ptParentPxl.x   = ptParentPxl.x + xOffset;
                    ptParentPxl.y   = ptParentPxl.y + yOffset;
                } else {
                    //
                    // Non-relative child intersects.  Update the "parent" 
                    // coordinates and scan this child.
                    //

                    ptParentPxl.x   = pgadChild->m_rcLogicalPxl.left;
                    ptParentPxl.y   = pgadChild->m_rcLogicalPxl.top;
                }

                pgadCur         = pgadChild;
                ptThisClientPxl = ptTest;
                goto ScanChild;
            }
        }

ScanNextSibling:
        pgadChild = pgadChild->GetNext();
    }

    
    //
    // Got all of the way without any child being hit.  This must be the 
    // correct DuVisual.
    //

    if (pptFoundClientPxl != NULL) {
        pptFoundClientPxl->x = ptThisClientPxl.x;
        pptFoundClientPxl->y = ptThisClientPxl.y;
    }

    return const_cast<DuVisual *> (pgadCur);
}


/***************************************************************************\
*
* DuVisual::MapPoint
*
* MapPoint() converts a given point from container-relative pixels into 
* client-relative pixels.  The DuVisual tree is walked down from the root with
* each node applying any transformation operation on the given pixel.  When
* the tree has been fully walked down to the starting node, the given point
* will be in client-relative pixels.
*
* This function is designed to work with other functions including 
* FindFromPoint() to convert from actual pixels given by the container into
* logical pixels that an individual DuVisual understands.  MapPoint() should 
* be called the point is being translated for a specific DuVisual (for example
* when the mouse is captured).  FindFromPoint() should be called to find a 
* DuVisual at a specific point.
*
\***************************************************************************/

void
DuVisual::MapPoint(
    IN OUT POINT * pptPxl            // IN: ContainerPxl, OUT: ClientPxl
    ) const
{
    //
    // Need to walk up the tree so that we apply any XForm's from the root.
    //

    DuVisual * pgadParent = GetParent();
    if (pgadParent != NULL) {
        pgadParent->MapPoint(pptPxl);
    }

    //
    // Apply this node's XForm.  
    //
    // It is VERY IMPORTANT that these XForms are applied in the same order 
    // that they are applied in DuVisual::Draw() or the result will NOT 
    // correspond to what GDI is drawing.
    //

    RECT rcPxl;
    GetLogRect(&rcPxl, SGR_PARENT);

    if ((rcPxl.left != 0) || (rcPxl.top != 0)) {
        pptPxl->x -= rcPxl.left;
        pptPxl->y -= rcPxl.top;
    }

    if (m_fXForm) {
        XFormInfo * pxfi = GetXFormInfo();
        Matrix3 mat;
        pxfi->ApplyAnti(&mat);
        mat.Execute(pptPxl, 1);
    }
}


//------------------------------------------------------------------------------
void
DuVisual::MapPoint(
    IN  POINT ptContainerPxl,       // Point to convert
    OUT POINT * pptClientPxl        // Converted point
    ) const
{
    *pptClientPxl = ptContainerPxl;
    MapPoint(pptClientPxl);
}


//------------------------------------------------------------------------------
void
DuVisual::MapPoints(
    IN  const DuVisual * pgadFrom, 
    IN  const DuVisual * pgadTo, 
    IN OUT POINT * rgptClientPxl, 
    IN  int cPts)
{
    AssertMsg(pgadFrom->GetRoot() == pgadTo->GetRoot(),
            "Must be in the same tree");

    //
    // Walk up the tree, converting at each stage from client pixels into the 
    // parent's client pixels
    //

    const DuVisual * pgadCur = pgadFrom;
    while (pgadCur != NULL) {
        if (pgadCur == pgadTo) {
            return;
        }

        pgadCur->DoXFormClientToParent(rgptClientPxl, cPts);
        pgadCur = pgadCur->GetParent();
    }


    //
    // Now, just map the point into the destination
    //

    Matrix3 mat;
    pgadTo->BuildAntiXForm(&mat);
    mat.Execute(rgptClientPxl, cPts);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\init.h ===
#if !defined(CORE__Init_h__INCLUDED)
#define CORE__Init_h__INCLUDED
#pragma once

HRESULT InitCore();

#endif // CORE__Init_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\gxform.cpp ===
/***************************************************************************\
*
* File: GXForm.cpp
*
* Description:
* GXForm.cpp interfaces GDI World Transforms into the DuVisual-Tree.  
* This file focuses on exposting transform information outside.  Actual 
* understanding of transforms are (necessarily) weaved throughout 
* DuVisual.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Core.h"
#include "TreeGadget.h"
#include "TreeGadgetP.h"


/***************************************************************************\
*****************************************************************************
*
* class DuVisual
*
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* DuVisual::GetScale
*
* GetScale() returns the current scaling factor assigned to this specific
* DuVisual.  Scaling factors of parents, siblings, and children are not 
* included.
*
\***************************************************************************/

void        
DuVisual::GetScale(
    OUT float * pflScaleX,              // X scaling factor
    OUT float * pflScaleY               // Y scaling factor
    ) const
{
    AssertWritePtr(pflScaleX);
    AssertWritePtr(pflScaleY);

    if (m_fXForm) {
        XFormInfo * pxfi = GetXFormInfo();
        *pflScaleX = pxfi->flScaleX;
        *pflScaleY = pxfi->flScaleY;
    } else {
        *pflScaleX = 1.0f;
        *pflScaleY = 1.0f;
    }
}


/***************************************************************************\
*
* DuVisual::xdSetScale
*
* xdSetScale() changes the current scaling factor assigned to this specific
* DuVisual.  Scaling factors of parents, siblings, and children are not 
* changed.
*
\***************************************************************************/

HRESULT        
DuVisual::xdSetScale(
    IN  float flScaleX,                 // New X scaling factor
    IN  float flScaleY)                 // New Y scaling factor
{
    HRESULT hr;

    //
    // Check parameters
    //

    if ((flScaleX <= 0.0f) || (flScaleY <= 0.0f)) {
        return E_INVALIDARG;
    }

    if (!SupportXForm()) {
        return E_INVALIDARG;
    }

    if (!m_fXForm) {
        if (IsZero(flScaleX - 1.0f) && IsZero(flScaleY - 1.0f)) {
            return S_OK;  // Nothing to do.
        } else {
            //
            // Setting a scaling factor, so need to enable XForm's.
            //

            hr = SetEnableXForm(TRUE);
            if (FAILED(hr)) {
                return hr;
            }
        }
    } 


    //
    // Check if there is any change
    //

    XFormInfo * pxfi = GetXFormInfo();
    if (IsZero(pxfi->flScaleX - flScaleX) && IsZero(pxfi->flScaleY - flScaleY)) {
        return S_OK;
    }


    //
    // Make the change and check if we still need the XForm.
    //

    Invalidate();

    pxfi->flScaleX   = flScaleX;
    pxfi->flScaleY   = flScaleY;

    if (pxfi->IsEmpty()) {
        VerifyHR(SetEnableXForm(FALSE));
    }

    Invalidate();
    xdUpdatePosition();
    xdUpdateAdaptors(GSYNC_XFORM);

    return S_OK;
}


/***************************************************************************\
*
* DuVisual::GetRotation
*
* GetRotation() returns the current rotation angle (in radians) assigned 
* to this specific DuVisual.  Scaling factors of parents, siblings, and 
* children are not included.
*
\***************************************************************************/

float       
DuVisual::GetRotation() const
{
    if (m_fXForm) {
        AssertMsg(!IsRoot(), "Ensure not the root");

        XFormInfo * pxfi = GetXFormInfo();
        return pxfi->flRotationRad;
    } else {
        return 0.0f;
    }
}


/***************************************************************************\
*
* DuVisual::xdSetRotation
*
* xdSetRotation() changes the current rotation angle (in radians) assigned 
* to this specific DuVisual.  Scaling factors of parents, siblings, and 
* children are not changed.
*
\***************************************************************************/

HRESULT
DuVisual::xdSetRotation(
    IN  float flRotationRad)            // New rotation factor in radians
{
    HRESULT hr;

    //
    // Not allowed to change the rotation of the root.  This is to ensure 
    // that the root always fully covers the entire container.
    //

    if (IsRoot()) {
        return E_INVALIDARG;
    }

    if (!SupportXForm()) {
        return E_INVALIDARG;
    }


    if (!m_fXForm) {
        if (IsZero(flRotationRad)) {
            return S_OK;  // Nothing to do.
        } else {
            //
            // Setting a rotation, so need to enable XForm's.
            //

            hr = SetEnableXForm(TRUE);
            if (FAILED(hr)) {
                return hr;
            }
        }
    } 


    //
    // Check if there is any change
    //

    XFormInfo * pxfi    = GetXFormInfo();
    if (IsZero(pxfi->flRotationRad - flRotationRad)) {
        return S_OK;
    }

    //
    // Make the change and check if we still need the XForm.
    //

    Invalidate();

    pxfi->flRotationRad = flRotationRad;

    if (pxfi->IsEmpty()) {
        VerifyHR(SetEnableXForm(FALSE));
    }

    Invalidate();
    xdUpdatePosition();
    xdUpdateAdaptors(GSYNC_XFORM);

    return S_OK;
}


/***************************************************************************\
*
* DuVisual::GetCenterPoint
*
* GetCenterPoint() returns the current center-point that scaling and 
* rotation "pivot" for this specific DuVisual.  Center-points of parents, 
* siblings, and children are not included.
*
\***************************************************************************/

void        
DuVisual::GetCenterPoint(
    OUT float * pflCenterX,             // X center-point factor
    OUT float * pflCenterY              // Y center-point factor
    ) const
{
    AssertWritePtr(pflCenterX);
    AssertWritePtr(pflCenterY);

    if (m_fXForm) {
        XFormInfo * pxfi = GetXFormInfo();
        *pflCenterX = pxfi->flCenterX;
        *pflCenterY = pxfi->flCenterY;
    } else {
        *pflCenterX = 1.0f;
        *pflCenterY = 1.0f;
    }
}


/***************************************************************************\
*
* DuVisual::xdSetCenterPoint
*
* xdSetCenterPoint() changes the current center-point that scaling and 
* rotation "pivot" for this specific DuVisual.    Center-points of parents,
* siblings, and children are not changed.
*
\***************************************************************************/

HRESULT        
DuVisual::xdSetCenterPoint(
    IN  float flCenterX,                // New X scaling factor
    IN  float flCenterY)                // New Y scaling factor
{
    HRESULT hr;

    //
    // Check parameters
    //

    if (!SupportXForm()) {
        return E_INVALIDARG;
    }

    if (!m_fXForm) {
        if (IsZero(flCenterX) && IsZero(flCenterY)) {
            return S_OK;  // Nothing to do.
        } else {
            //
            // Setting a scaling factor, so need to enable XForm's.
            //

            hr = SetEnableXForm(TRUE);
            if (FAILED(hr)) {
                return hr;
            }
        }
    } 


    //
    // Check if there is any change
    //

    XFormInfo * pxfi = GetXFormInfo();
    if (IsZero(pxfi->flCenterX - flCenterX) && IsZero(pxfi->flCenterY - flCenterY)) {
        return S_OK;
    }


    //
    // Make the change and check if we still need the XForm.
    //

    Invalidate();

    pxfi->flCenterX = flCenterX;
    pxfi->flCenterY = flCenterY;

    if (pxfi->IsEmpty()) {
        VerifyHR(SetEnableXForm(FALSE));
    }

    Invalidate();
    xdUpdatePosition();
    xdUpdateAdaptors(GSYNC_XFORM);

    return S_OK;
}


/***************************************************************************\
*
* DuVisual::SetEnableXForm
*
* SetEnableXForm() enables / disables the extra XFormInfo dynamic property
* used to store transform information.
*
\***************************************************************************/

HRESULT
DuVisual::SetEnableXForm(
    IN  BOOL fEnable)                   // Enable optional X-Form information 
{
    HRESULT hr;

    if ((!fEnable) == (!m_fXForm)) {
        return S_OK;  // No change
    }

    if (fEnable) {
        AssertMsg(SupportXForm(), "Only can set if XForm's are supported");

        //
        // Allocate and initialize a new XFormInfo.
        //

        XFormInfo * pxfi;
        hr = m_pds.SetData(s_pridXForm, sizeof(XFormInfo), (void **) &pxfi);
        if (FAILED(hr)) {
            return hr;
        }

        pxfi->flScaleX = 1.0f;
        pxfi->flScaleY = 1.0f;
    } else {
        //
        // Remove the existing XFormInfo
        //

        m_pds.RemoveData(s_pridXForm, TRUE);
    }

    m_fXForm = (fEnable != FALSE);
    UpdateTrivial(uhNone);

    return S_OK;
}


/***************************************************************************\
*
* DuVisual::BuildXForm
*
* BuildXForm() builds a matrix that contains all transformations from this
* DuVisual up to the root.  This matrix corresponds to the cumulative matrix 
* that gets applied when drawing the DuVisuals.
*
* This is used to take logical client coordinates for a specific DuVisual
* and convert them into container coordinates.
*
\***************************************************************************/

void        
DuVisual::BuildXForm(
    IN OUT Matrix3 * pmatCur            // Optional current matrix of all XForm's.
    ) const
{
    //
    // Walk up the tree
    //

    const DuVisual * pgadParent = GetParent();
    if (pgadParent != NULL) {
        pgadParent->BuildXForm(pmatCur);
    }


    //
    // Apply this node's XForm.  
    //
    // It is VERY IMPORTANT that these XForms are applied in the same order 
    // that they are applied in DuVisual::Draw() or the result will NOT 
    // correspond to what GDI is drawing.
    //

    RECT rcPxl;
    GetLogRect(&rcPxl, SGR_PARENT);

    if ((rcPxl.left != 0) || (rcPxl.top != 0)) {
        float flOffsetX, flOffsetY;

        flOffsetX = (float) rcPxl.left;
        flOffsetY = (float) rcPxl.top;

        if (pmatCur != NULL) {
            pmatCur->Translate(flOffsetX, flOffsetY);
        }
    }

    if (m_fXForm) {
        XFormInfo * pxfi = GetXFormInfo();

        if (pmatCur != NULL) {
            pxfi->Apply(pmatCur);
        }
    }
}


/***************************************************************************\
*
* DuVisual::BuildAntiXForm
*
* BuildAntiXForm() builds the opposite transform by following the same 
* traversal path down the DuVisual tree to the specified node as 
* BuildXForm(), but it applies the opposite transformation at each step.
*
* This is used to take container coordinates and convert them into logical
* coordinates for a specific DuVisual.
*
\***************************************************************************/

void        
DuVisual::BuildAntiXForm(
    IN OUT Matrix3 * pmatCur            // Current matrix of all XForm's.
    ) const
{
    AssertMsg(pmatCur != NULL, "Must specify a matrix to modify");

    //
    // Walk up the tree
    //

    const DuVisual * pgadParent = GetParent();
    if (pgadParent != NULL) {
        pgadParent->BuildAntiXForm(pmatCur);
    }


    //
    // Apply this node's XForm.  
    //
    // It is VERY IMPORTANT that these XForms are applied in the same order 
    // that they are applied in DuVisual::Draw() or the result will NOT 
    // correspond to what GDI is drawing.
    //

    if (m_fXForm) {
        XFormInfo * pxfi = GetXFormInfo();
        pxfi->ApplyAnti(pmatCur);
    }

    RECT rcPxl;
    GetLogRect(&rcPxl, SGR_PARENT);

    if ((rcPxl.left != 0) || (rcPxl.top != 0)) {
        float flOffsetX, flOffsetY;

        flOffsetX = (float) rcPxl.left;
        flOffsetY = (float) rcPxl.top;

        pmatCur->Translate(- flOffsetX, - flOffsetY);
    }
}


/***************************************************************************\
*
* DuVisual::DoCalcClipEnumXForm
*
* DoCalcClipEnumXForm() transforms a given client rectangle into container
* coordinates while clipping the rectangle inside each of its parents 
* boundaries.  
* 
* For example, this is useful during invalidation to ensure that the 
* invalidated rectangle is completely inside of its parent.
*
\***************************************************************************/

void
DuVisual::DoCalcClipEnumXForm(
    OUT RECT * rgrcFinalClipClientPxl,  // Final clip rectangle in client pixels
    IN  const RECT * rgrcClientPxl,     // Invalid area in client pixels.
    IN  int cRects                      // Number of rects to convert
    ) const  
{
    if (GetParent() != NULL) {
        //
        // Have a parent, so walk up the tree converting the given rect into
        // (new) parent coordinates and clipping inside the new parent.
        //

        RECT * rgrcNewParentPxl     = (RECT *) _alloca(cRects * sizeof(RECT));
        RECT * rgrcClipParentPxl    = (RECT *) _alloca(cRects * sizeof(RECT));

        DoXFormClientToParent(rgrcNewParentPxl, rgrcClientPxl, cRects, HINTBOUNDS_Clip);

        RECT rcParentParentPxl;
        GetParent()->GetLogRect(&rcParentParentPxl, SGR_CLIENT);

        for (int idx = 0; idx < cRects; idx++) {
            IntersectRect(&rgrcClipParentPxl[idx], &rcParentParentPxl, &rgrcNewParentPxl[idx]);
        }

        GetParent()->DoCalcClipEnumXForm(rgrcFinalClipClientPxl, rgrcClipParentPxl, cRects);
    } else {
        //
        // No more parent, so just return directly.
        //

        CopyMemory(rgrcFinalClipClientPxl, rgrcClientPxl, cRects * sizeof(RECT));
    }
}


/***************************************************************************\
*
* DuVisual::DoXFormClientToParent
*
* DoXFormClientToParent() transforms a given client rectangle into parent
* coordinates by applying transformations and taking the BOUNDING rectangle.
* This function is called repeatedly by DoCalcClipEnumXForm() to transform
* a client rectangle into container cordinates.
* 
* NOTE: Unlike DoCalcClipEnumXForm(), this function does NOT clip the 
* resulting rectangle to the parent.
*
\***************************************************************************/

void
DuVisual::DoXFormClientToParent(
    OUT RECT * rgrcParentPxl,
    IN  const RECT * rgrcClientPxl,
    IN  int cRects,
    IN  Matrix3::EHintBounds hb
    ) const
{
    AssertMsg(cRects > 0, "Must specify a valid # of rectangles to compute");

    //
    // First, compute the translation matrix to convert from client coordinates
    // of this Gadget to client coordinates of our parent.
    //

    Matrix3 matStep;

    RECT rcThisParentPxl;
    GetLogRect(&rcThisParentPxl, SGR_PARENT);
    if ((rcThisParentPxl.left != 0) || (rcThisParentPxl.top != 0)) {
        float flOffsetX, flOffsetY;

        flOffsetX = (float) rcThisParentPxl.left;
        flOffsetY = (float) rcThisParentPxl.top;

        matStep.Translate(flOffsetX, flOffsetY);
    }

    if (m_fXForm) {
        XFormInfo * pxfi = GetXFormInfo();
        pxfi->Apply(&matStep);
    }


    //
    // Now, zip through all rectangles converting from relative to us to 
    // relative to our parent.
    //
    // NOTE: This does NOT clip the resulting rectangle to inside the parent.
    //

    int idx = cRects; 
    while (idx-- > 0) {
        matStep.ComputeBounds(rgrcParentPxl, rgrcClientPxl, hb);
        rgrcParentPxl++;
        rgrcClientPxl++;
    }
}


/***************************************************************************\
*
* DuVisual::DoXFormClientToParent
*
* DoXFormClientToParent() transforms a given point into parent coordinates
* by applying transformations.
*
\***************************************************************************/

void
DuVisual::DoXFormClientToParent(
    IN OUT POINT * rgrcClientPxl,
    IN  int cPoints
    ) const
{
    AssertMsg(cPoints > 0, "Must specify a valid # of rectangles to compute");

    //
    // First, compute the translation matrix to convert from client coordinates
    // of this Gadget to client coordinates of our parent.
    //

    Matrix3 matStep;

    RECT rcThisParentPxl;
    GetLogRect(&rcThisParentPxl, SGR_PARENT);
    if ((rcThisParentPxl.left != 0) || (rcThisParentPxl.top != 0)) {
        float flOffsetX, flOffsetY;

        flOffsetX = (float) rcThisParentPxl.left;
        flOffsetY = (float) rcThisParentPxl.top;

        matStep.Translate(flOffsetX, flOffsetY);
    }

    if (m_fXForm) {
        XFormInfo * pxfi = GetXFormInfo();
        pxfi->Apply(&matStep);
    }


    //
    // Now, zip through all points converting from relative to us to 
    // relative to our parent.
    //
    // NOTE: This does NOT clip the resulting point to inside the parent.
    //

    matStep.Execute(rgrcClientPxl, cPoints);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\messagegadget.cpp ===
/***************************************************************************\
*
* File: MessageGadget.cpp
*
* History:
*  3/25/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/

#include "stdafx.h"
#include "Core.h"
#include "MessageGadget.h"

/***************************************************************************\
*****************************************************************************
*
* class DuListener
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
DuListener::~DuListener()
{
    //
    // After notifying all event handlers that this DuVisual is being destroyed,
    // extract this DuVisual from the graph.
    //

    CleanupMessageHandlers();
}


/***************************************************************************\
*
* DuListener::Build
*
* Build() creates a new fully initialized DuListener.
*
\***************************************************************************/

HRESULT
DuListener::Build(
    IN  CREATE_INFO * pci,          // Creation information
    OUT DuListener ** ppgadNew)  // New Gadget
{
    DuListener * pgadNew = ClientNew(DuListener);
    if (pgadNew == NULL) {
        return E_OUTOFMEMORY;
    }

#if DBG
    pgadNew->m_cb.Create(pci->pfnProc, pci->pvData, pgadNew->GetHandle());
#else // DBG
    pgadNew->m_cb.Create(pci->pfnProc, pci->pvData);
#endif // DBG

    //
    // When creating as an HGADGET, we need to force initialization of the
    // MsgObject.
    //
    // TODO: Get rid of this
    //
#if ENABLE_MSGTABLE_API
    pgadNew->SetupInternal(s_mc.hclNew);
#endif

    *ppgadNew = pgadNew;
    return S_OK;
}


/***************************************************************************\
*
* DuListener::xwDeleteHandle
*
* xwDeleteHandle() is called when the application calls ::DeleteHandle() on 
* an object.
*
* NOTE: Gadgets are slightly different than other objects with callbacks in
* that their lifetime does NOT end when the application calls 
* ::DeleteHandle().  Instead, the object and its callback are completely
* valid until the GM_DESTROY message has been successfully sent.  This is 
* because a Gadget should receive any outstanding messages in both the 
* normal and delayed message queues before being destroyed.
*
\***************************************************************************/

BOOL
DuListener::xwDeleteHandle()
{
    //
    // Need to send GM_DESTROY(GDESTROY_START) as soon as the Gadget starts
    // the destruction process.
    //

    m_fStartDestroy = TRUE;
    m_cb.xwFireDestroy(this, GDESTROY_START);

    return DuEventGadget::xwDeleteHandle();
}


/***************************************************************************\
*
* DuListener::IsStartDelete
*
* IsStartDelete() is called to query an object if it has started its
* destruction process.  Most objects will just immediately be destroyed.  If
* an object has complicated destruction where it overrides xwDestroy(), it
* should also provide IsStartDelete() to let the application know the state
* of the object.
*
\***************************************************************************/

BOOL
DuListener::IsStartDelete() const
{
    return m_fStartDestroy;
}


/***************************************************************************\
*
* DuListener::xwDestroy
*
* xwDestroy() is called from xwDeleteHandle() to destroy a Gadget and free 
* its associated resources.
*
\***************************************************************************/

void
DuListener::xwDestroy()
{
    xwBeginDestroy();

    DuEventGadget::xwDestroy();
}


/***************************************************************************\
*
* DuListener::xwBeginDestroy
*
* xwBeginDestroy() starts the destruction process for a given Gadget to free 
* its associated resources.  This includes destroying all child Gadgets in
* the subtree before this Gadget is destroyed.
*
* xwBeginDestroy() is given an opportunity to clean up resources BEFORE the 
* destructors start tearing down the classes.  This is important especially
* for callbacks because the Gadgets will be partially uninitialized in the
* destructors and could have bad side-effects from other API calls during 
* the callbacks.
*
\***************************************************************************/

void        
DuListener::xwBeginDestroy()
{
    //
    // Send destroy notifications.  This needs to be done in a bottom-up 
    // order to ensure that the root DuVisual does not keep any handles 
    // to a DuVisual being destroyed.
    //

    m_cb.xwFireDestroy(this, GDESTROY_FINAL);


    //
    // At this point, the children have been cleaned up and the Gadget has
    // received its last callback.  From this point on, anything can be done,
    // but it is important to not callback.
    //

    m_cb.Destroy();
}


#if ENABLE_MSGTABLE_API

//------------------------------------------------------------------------------
HRESULT CALLBACK
DuListener::PromoteListener(DUser::ConstructProc pfnCS, HCLASS hclCur, DUser::Gadget * pgad, DUser::Gadget::ConstructInfo * pciData) 
{
    UNREFERENCED_PARAMETER(pfnCS);
    UNREFERENCED_PARAMETER(hclCur);
    UNREFERENCED_PARAMETER(pciData);

    MsgObject ** ppmsoNew = reinterpret_cast<MsgObject **> (pgad);
    AssertMsg((ppmsoNew != NULL) && (*ppmsoNew == NULL), 
            "Internal objects must be given valid storage for the MsgObject");

    DuListener * pgadNew = ClientNew(DuListener);
    if (pgadNew == NULL) {
        return E_OUTOFMEMORY;
    }

#if DBG
    pgadNew->m_cb.Create(NULL, NULL, pgadNew->GetHandle());
#else // DBG
    pgadNew->m_cb.Create(NULL, NULL);
#endif // DBG

    *ppmsoNew = pgadNew;
    return S_OK;
}

#endif // ENABLE_MSGTABLE_API
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\init.cpp ===
#include "stdafx.h"
#include "Core.h"
#include "Init.h"

#include "BaseGadget.h"
#include "MessageGadget.h"
#include "TreeGadget.h"
#include "RootGadget.h"

#if ENABLE_MSGTABLE_API

//
// Provide Implementations of classes.
//
// NOTE: We register BaseGadget by hand to ensure that messages are registered
// in a determined (and necessary) order.
//


DUser::MessageClassGuts EventGadgetImpl<DuEventGadget, MsgObject>::s_mc;
DUser::MessageInfoGuts EventGadgetImpl<DuEventGadget, MsgObject>::s_rgmi[] = {
    { DUser::Event<DuEventGadget, EventMsg>(DuEventGadget::ApiOnEvent), L"OnEvent" },
    { DUser::Method<DuEventGadget, EventGadget::GetFilterMsg>(DuEventGadget::ApiGetFilter), L"GetFilter" },
    { DUser::Method<DuEventGadget, EventGadget::SetFilterMsg>(DuEventGadget::ApiSetFilter), L"SetFilter" },
    { DUser::Method<DuEventGadget, EventGadget::AddHandlerGMsg>(DuEventGadget::ApiAddHandlerG), L"AddHandlerG" },
    { DUser::Method<DuEventGadget, EventGadget::AddHandlerDMsg>(DuEventGadget::ApiAddHandlerD), L"AddHandlerD" },
    { DUser::Method<DuEventGadget, EventGadget::RemoveHandlerGMsg>(DuEventGadget::ApiRemoveHandlerG), L"RemoveHandlerG" },
    { DUser::Method<DuEventGadget, EventGadget::RemoveHandlerDMsg>(DuEventGadget::ApiRemoveHandlerD), L"RemoveHandlerD" },
};

IMPLEMENT_GUTS_Listener(DuListener, DuEventGadget);
IMPLEMENT_GUTS_Visual(DuVisual, DuEventGadget);
IMPLEMENT_GUTS_Root(DuRootGadget, DuVisual);

#endif // ENABLE_MSGTABLE_API


HRESULT InitCore()
{
#if ENABLE_MSGTABLE_API

    if ((!DuEventGadget::InitEventGadget()) ||
        (!DuListener::InitListener()) ||
        (!DuVisual::InitVisual()) ||
        (!DuRootGadget::InitRoot())) {

        return E_OUTOFMEMORY;
    }

    DuEventGadget::MarkInternal();
    DuListener::MarkInternal();
    DuVisual::MarkInternal();
    DuRootGadget::MarkInternal();

#else
    if (FAILED(DuVisual::InitClass())) {
        return E_OUTOFMEMORY;
    }

#endif // ENABLE_MSGTABLE_API

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\messagegadget.inl ===
/***************************************************************************\
*
* File: MessageGadget.inl
*
* History:
*  3/25/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/

#if !defined(CORE__DuListener_inl__INCLUDED)
#define CORE__DuListener_inl__INCLUDED
#pragma once

/***************************************************************************\
*****************************************************************************
*
* class DuListener
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline DuListener * 
CastListener(BaseObject * pbase)
{
    if ((pbase != NULL) && (pbase->GetHandleType() == htListener)) {
        return (DuListener *) pbase;
    }
    return NULL;
}


//------------------------------------------------------------------------------
inline const DuListener * 
CastListener(const BaseObject * pbase)
{
    if ((pbase != NULL) && (pbase->GetHandleType() == htListener)) {
        return (DuListener *) pbase;
    }
    return NULL;
}


//------------------------------------------------------------------------------
inline DuListener * 
ValidateListener(HGADGET hgad)
{
    return CastListener(BaseObject::ValidateHandle(hgad));
}


//------------------------------------------------------------------------------
inline
DuListener::DuListener()
{

}


#endif // CORE__DuListener_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\messagegadget.h ===
/***************************************************************************\
*
* File: MessageGadget.h
*
* Description:
* DuListener defines a lightweight, "message-only" Gadget that can 
* send and receive GMSG's.  These can be used as Delegates.
*
*
* History:
*  3/25/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/

#if !defined(CORE__DuListener_h__INCLUDED)
#define CORE__DuListener_h__INCLUDED
#pragma once

#include "BaseGadget.h"

class DuListener : 
#if ENABLE_MSGTABLE_API
        public ListenerImpl<DuListener, DuEventGadget>
#else
        public DuEventGadget
#endif
{
// Construction
public:
    inline  DuListener();
            ~DuListener();
    static  HRESULT     Build(CREATE_INFO * pci, DuListener ** ppgadNew);
    virtual BOOL        xwDeleteHandle();
protected:
    virtual void        xwDestroy();

// Public API:
public:
#if ENABLE_MSGTABLE_API

    DECLARE_INTERNAL(Listener);
    static HRESULT CALLBACK
                        PromoteListener(DUser::ConstructProc pfnCS, HCLASS hclCur, DUser::Gadget * pgad, DUser::Gadget::ConstructInfo * pciData);

#endif // ENABLE_MSGTABLE_API

// BaseObject Interface
public:
    virtual BOOL        IsStartDelete() const;
    virtual HandleType  GetHandleType() const { return htListener; }

// Implementation
protected:
            void        xwBeginDestroy();

// Data
protected:
    //
    // NOTE: This data members are declared in order of importance to help with 
    // cache alignment.
    // 
    // DuEventGadget:      10 DWORD's      (Debug = 11 DWORD's)
    //

            BOOL        m_fStartDestroy:1;  // 1 DWORD

    //
    // Current size:    11 DWORD's      (Debug = 11 DWORD's)
    //                  40 bytes        (Debug = 44 bytes)
    //
};

#include "MessageGadget.inl"

#endif // CORE__DuListener_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\msgq.cpp ===
/***************************************************************************\
*
* File: MsgQ.h
*
* Description:
* MsgQ defines a lightweight queue of Gadget messages.
*
*
* History:
*  3/30/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Core.h"
#include "MsgQ.h"

#include "BaseGadget.h"
#include "TreeGadget.h"

#define ENABLE_CHECKLOOP    0

#if ENABLE_CHECKLOOP
#include <conio.h>
#endif

/***************************************************************************\
*****************************************************************************
*
* Global functions
*
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* xwProcessDirect
*
* xwProcessDirect() provides a MsgEntry "process" callback to process
* "Direct Event" messages on a BaseGadget.  These messages were determined
* to be "direct" at the time that they were enqueued.
*
\***************************************************************************/

HRESULT CALLBACK 
xwProcessDirect(
    IN  MsgEntry * pEntry)              // MsgEntry to process
{
    AssertMsg(TestFlag(pEntry->pmo->GetHandleMask(), hmEventGadget), 
            "Direct messages must be BaseGadget's");
    AssertMsg(pEntry->GetMsg()->nMsg >= GM_EVENT, "Must be an event");

    DuEventGadget * pdgbMsg = static_cast<DuEventGadget *>(pEntry->pmo);
    const GPCB & cb = pdgbMsg->GetCallback();
    return cb.xwInvokeDirect(pdgbMsg, (EventMsg *) pEntry->GetMsg());
}


/***************************************************************************\
*
* xwProcessFull
*
* xwProcessFull() provides a MsgEntry "process" callback to process
* "Full Event" messages on a BaseGadget.  These messages were determined
* to be "full" at the time that they were enqueued.
*
\***************************************************************************/

HRESULT CALLBACK 
xwProcessFull(
    IN  MsgEntry * pEntry)              // MsgEntry to process
{
    AssertMsg(TestFlag(pEntry->pmo->GetHandleMask(), hmVisual), 
            "Direct messages must be Visual's");
    AssertMsg(pEntry->GetMsg()->nMsg >= GM_EVENT, "Must be an event");

    DuVisual * pdgvMsg = static_cast<DuVisual *>(pEntry->pmo);
    const GPCB & cb = pdgvMsg->GetCallback();
    return cb.xwInvokeFull(pdgvMsg, (EventMsg *) pEntry->GetMsg());
}


/***************************************************************************\
*
* xwProcessMethod
*
* xwProcessMethod() provides a MsgEntry "process" callback to process
* "Method" messages on any MsgObject.
*
\***************************************************************************/

HRESULT CALLBACK 
xwProcessMethod(
    IN  MsgEntry * pEntry)              // MsgEntry to process
{
    AssertMsg(pEntry->GetMsg()->nMsg < GM_EVENT, "Must be a method");
    pEntry->pmo->InvokeMethod((MethodMsg *) pEntry->GetMsg());
    return DU_S_COMPLETE;
}


/***************************************************************************\
*
* GetProcessProc
*
* GetProcessProc() determines the "process" callback to use on a BaseGadget
* to process a specific Event message.  This function is called at the time
* the message is being enqueued when the "process" callback needs to be 
* determined.
*
\***************************************************************************/

ProcessMsgProc 
GetProcessProc(
    IN  DuEventGadget * pdgb,            // BaseGadget receiving message
    IN  UINT nFlags)                    // Send/Post GadgetEvent() flags
{
    if (TestFlag(nFlags, SGM_FULL)) {
        const DuVisual * pgadTree = CastVisual(pdgb);
        if (pgadTree != NULL) {
            return xwProcessFull;
        }
    }

    return xwProcessDirect;
}


/***************************************************************************\
*****************************************************************************
*
* class BaseMsgQ
*
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* BaseMsgQ::MsgObjectFinalUnlockProcNL
*
* MsgObjectFinalUnlockProcNL() is called by xwUnlockNL() if the specified 
* BaseObject is about to start the destruction process.  This provides the
* caller, in this case xwProcessNL, an opportunity to prepare for the 
* object's destruction, in this case by setting up a ContextLock.
*
\***************************************************************************/

void CALLBACK 
BaseMsgQ::MsgObjectFinalUnlockProcNL(
    IN  BaseObject * pobj,              // Object being destroyed
    IN  void * pvData)                  // ContextLock data
{
    ContextLock * pcl = reinterpret_cast<ContextLock *> (pvData);
    AssertMsg(pcl != NULL, "Must provide a valid ContextLock");

    DuEventGadget * pgad = CastBaseGadget(pobj);
    AssertMsg(pgad != NULL, "Must provide a valid Gadget");

    Verify(pcl->LockNL(ContextLock::edDefer, pgad->GetContext()));
}


/***************************************************************************\
*
* BaseMsgQ::xwProcessNL
*
* xwProcessNL() walks through a list and invokes each message.  Since
* we can't be inside a ContextLock during a callback, this function is an
* "NL" (No Context Lock) function.  It is also a "xw" function because we
* are making the callbacks right now, so everything needs to be properly 
* locked.
*
* NOTE: This "NL" function runs inside a Context but does not take the 
* Context lock.  Therefore, multiple threads inside this Context may also be
* active.
*
\***************************************************************************/

void        
BaseMsgQ::xwProcessNL(
    IN  MsgEntry * pEntry)              // List of entries (FIFO)
{
    //
    // Walk through the list, processing and cleaning up each message.
    //
    // Each Gadget has already been Lock()'d when it was added to the queue,
    // so it is safe to call xwInvoke().  After the message is invoked,
    // Unlock() the Gadget.
    //

#if DBG_CHECK_CALLBACKS
    DWORD cMsgs = 0;
#endif

    MsgEntry * pNext;
    while (pEntry != NULL) {
#if DBG_CHECK_CALLBACKS
        cMsgs++;
        if (!IsInitThread()) {
            AutoTrace("Current message %d = 0x%p\n", cMsgs, pEntry);
            AlwaysPromptInvalid("DirectUser has been uninitialized while processing a message");
        }
#endif
        
        pNext = static_cast<MsgEntry *> (pEntry->pNext);
        UINT nFlags = pEntry->nFlags;
        AssertMsg((nFlags & SGM_ENTIRE) == nFlags, "Ensure valid flags");
        AssertMsg(pEntry->pfnProcess, "Must specify pfnProcess when enqueuing message");
        
        MsgObject * pmo = pEntry->pmo;
        pEntry->nResult = (pEntry->pfnProcess)(pEntry);

        AssertMsg((nFlags & SGM_ENTIRE) == nFlags, "Ensure valid flags");

        HANDLE hevNotify = pEntry->hEvent;

        {
            //
            // If the Gadget gets finally unlocked and starts destruction, we 
            // may call a whole slew of non-NL functions that require the 
            // ContextLock.  To accomodate this, pass a special function that
            // will grab the ContextLock if the object is being destroyed.
            //

            ContextLock cl;
            pmo->xwUnlockNL(MsgObjectFinalUnlockProcNL, &cl);
        }

        AssertMsg((nFlags & SGM_ENTIRE) == nFlags, "Ensure valid flags");

        if (TestFlag(nFlags, SGM_RETURN)) {
            Thread * pthrReturn = pEntry->pthrSender;
            pthrReturn->ReturnMemoryNL(pEntry);
        } else if (TestFlag(nFlags, SGM_ALLOC)) {
            ProcessFree(pEntry);
        }

        if (hevNotify != NULL) {
            SetEvent(hevNotify);
        }

        pEntry = pNext;
    }
}


/***************************************************************************\
*****************************************************************************
*
* class SafeMsgQ
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
SafeMsgQ::~SafeMsgQ()
{
    AssertMsg(m_lstEntries.IsEmptyNL(), "All messages should already have been processed");

    //
    // If there are any message (for some unknown reason), we need to full
    // process them so that the Gadgets get unlocked, memory gets free'd, and
    // blocked threads get signaled.
    //

    xwProcessNL();
}


/***************************************************************************\
*
* SafeMsgQ::xwProcessNL
*
* xwProcessNL() walks through a list and invokes each message.  Since
* we can't be inside a ContextLock during a callback, this function is an
* "NL" (No Context Lock) function.  It is also a "xw" function because we
* are making the callbacks right now, so everything needs to be properly 
* locked.
*
* NOTE: This "NL" function runs inside a Context but does not take the 
* Context lock.  Therefore, multiple threads inside this Context may also be
* active.
*
\***************************************************************************/

void
SafeMsgQ::xwProcessNL()
{
    //
    // Keep processing the list until it is empty.
    // Reverse the list so that the first entry is at the head.
    //
    // NOTE: Some callers (such as DelayedMsgQ) heavily rely on this behavior.
    //

    while (!IsEmpty()) {
        MsgEntry * pEntry = m_lstEntries.ExtractNL();
        ReverseSingleList(pEntry);
        BaseMsgQ::xwProcessNL(pEntry);
    }
}


/***************************************************************************\
*
* SafeMsgQ::PostNL
*
* PostNL adds a new message to the Q.  This function does not block 
* waiting for the message to be processed.
*
* NOTE: This "NL" function runs inside a Context but does not take the 
* Context lock.  Therefore, multiple threads inside this Context may also be
* active.
*
* WARNING: This (NL) function may run on the destination Gadget's CoreSC 
* and not the current CoreSC.  It is very important to be careful.
*
\***************************************************************************/

HRESULT
SafeMsgQ::PostNL(
    IN  Thread * pthrSender,        // Sending thread
    IN  GMSG * pmsg,                // Message to send
    IN  MsgObject * pmo,            // Destination MsgObject of message
    IN  ProcessMsgProc pfnProcess,  // Message processing function
    IN  UINT nFlags)                // Message flags
{
    HRESULT hr = DU_E_GENERIC;
    AssertMsg((nFlags & SGM_ENTIRE) == nFlags, "Ensure valid flags");

    int cbAlloc = sizeof(MsgEntry) + pmsg->cbSize;
    MsgEntry * pEntry;


    //
    // Determine the heap to use to allocate the message from.  If the sending
    // thread is initialized, use its heap.  Otherwise, we need to use the 
    // receiving thread's heap.  It is preferable to use the sending threads 
    // heap since the memory can be returned to us, giving better scalability
    // especially with producer / consumer situations.
    //

    if (pthrSender != NULL) {
        AssertMsg(!TestFlag(nFlags, SGM_RECEIVECONTEXT), 
                "If using the receiving context, can't pass a sending thread");
        pEntry = (MsgEntry *) pthrSender->AllocMemoryNL(cbAlloc);
        nFlags |= SGM_RETURN;
    } else {
        pEntry = (MsgEntry *) ProcessAlloc(cbAlloc);
        nFlags |= SGM_ALLOC;
    }

    if (pEntry == NULL) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }


    //
    // Setup the message to be queued.
    //

    AssertMsg((nFlags & SGM_ENTIRE) == nFlags, "Ensure valid flags");

    CopyMemory(pEntry->GetMsg(), pmsg, pmsg->cbSize);
    pEntry->pthrSender  = pthrSender;
    pEntry->pmo         = pmo;
    pEntry->pfnProcess  = pfnProcess;
    pEntry->nFlags      = nFlags;
    pEntry->hEvent      = NULL;
    pEntry->nResult     = 0;

    AddNL(pEntry);
    hr = S_OK;

Exit:
    return hr;
}


/***************************************************************************\
*****************************************************************************
*
* class DelayedMsgQ
*
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* DelayedMsgQ::PostDelayed
*
* PostDelayed() adds a new delayed message to the Q.  The memory for 
* this message will be freed when xwProcessDelayedNL() is called.
*
\***************************************************************************/

HRESULT     
DelayedMsgQ::PostDelayed(
    IN  GMSG * pmsg,                // Message to send
    IN  DuEventGadget * pgadMsg,     // Destination Gadget of message
    IN  UINT nFlags)                // Message flags
{
    AssertMsg(m_pheap != NULL, "Heap must be initialized");
    HRESULT hr = DU_E_GENERIC;

    BOOL fEmpty = IsEmpty();

    int cbAlloc = sizeof(MsgEntry) + pmsg->cbSize;
    MsgEntry * pEntry = (MsgEntry *) m_pheap->Alloc(cbAlloc);
    if (pEntry == NULL) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }


    //
    // If this is the first time we are adding a message to the temporary heap, 
    // we need to lock it so that the memory doesn't go away from under us.
    //
    // NOTE: It is VERY important that the Lock()'s and Unlock()'s are properly
    // paired, or the memory will never be reclaimed.  Since we automatically
    // Unlock() at the end of processing, and we stay processing if any messages
    // were added (even to an empty Q) during processing, only lock the heap if
    // there are no messages and we have not started processing.
    //

    if (fEmpty && (!m_fProcessing)) {
        m_pheap->Lock();
    }

    CopyMemory(pEntry->GetMsg(), pmsg, pmsg->cbSize);
    pEntry->pthrSender  = NULL;
    pEntry->pmo         = pgadMsg;
    pEntry->pfnProcess  = GetProcessProc(pgadMsg, nFlags);
    pEntry->nFlags      = nFlags;
    pEntry->hEvent      = NULL;
    pEntry->nResult     = 0;

    Add(pEntry);
    hr = S_OK;

Exit:
    return hr;
}


//------------------------------------------------------------------------------
void
DelayedMsgQ::xwProcessDelayedNL()
{
    AssertMsg(m_pheap != NULL, "Heap must be initialized");

    //
    // Processing the delayed messages is NOT re-entrant (even on the same 
    // thread).  Once started, xwProcessNL() will continue to process all
    // messages in the queue, even if more are adding during callbacks.  The key
    // is that we CAN NOT free the memory on our temporary heap until all of the
    // messages have been processed.
    //

    if (m_fProcessing) {
        return;
    }

    if (!IsEmpty()) {
        m_fProcessing = TRUE;


        //
        // Keep processing the list until it is empty.
        // Reverse the list so that the first entry is at the head.
        //
        // NOTE: Some callers (such as DelayedMsgQ) heavily rely on this behavior.
        //

        while (!IsEmpty()) {
            MsgEntry * pEntry = m_lstEntries.Extract();
            ReverseSingleList(pEntry);
            BaseMsgQ::xwProcessNL(pEntry);
        }

        m_pheap->Unlock();

        m_fProcessing = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\msgq.inl ===
/***************************************************************************\
*
* File: MsgQ.inl
*
* History:
*  3/30/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(CORE__MsgQ_inl__INCLUDED)
#define CORE__MsgQ_inl__INCLUDED

/***************************************************************************\
*****************************************************************************
*
* struct MsgEntry
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline GMSG *
MsgEntry::GetMsg() const
{
    return (GMSG *) (((BYTE *) this) + sizeof(MsgEntry));
}


/***************************************************************************\
*****************************************************************************
*
* class BaseMsgQ
*
*****************************************************************************
\***************************************************************************/

#if DBG

//------------------------------------------------------------------------------
inline void
BaseMsgQ::DEBUG_MarkStartDestroy()
{
    m_DEBUG_fStartDestroy = TRUE;
}

#endif // DBG


/***************************************************************************\
*****************************************************************************
*
* class SafeMsgQ
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline BOOL        
SafeMsgQ::IsEmpty() const
{
    return m_lstEntries.IsEmptyNL();
}


//------------------------------------------------------------------------------
inline void        
SafeMsgQ::AddNL(MsgEntry * pEntry)
{
    AssertMsg((pEntry->nFlags & SGM_ENTIRE) == pEntry->nFlags, "Ensure valid flags");
    AssertMsg(pEntry->pfnProcess, "Must specify pfnProcess when enqueuing message");
    AssertMsg(!m_DEBUG_fStartDestroy, "Must not have started final destruction");

    pEntry->pmo->Lock();
    m_lstEntries.AddHeadNL(pEntry);
}


/***************************************************************************\
*****************************************************************************
*
* class DelayedMsgQ
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline
DelayedMsgQ::~DelayedMsgQ()
{
    //
    // Deferred messages may be (legally) queued during the destruction process,
    // locking the Gadgets until they are properly processed.  We can't just 
    // ignore them because the Gadget's can shutdown until they are properly 
    // unlocked.
    //

    xwProcessDelayedNL();
}


//------------------------------------------------------------------------------
inline void
DelayedMsgQ::Create(TempHeap * pheap)
{
    AssertReadPtr(pheap);
    m_pheap = pheap;
}


//------------------------------------------------------------------------------
inline BOOL        
DelayedMsgQ::IsEmpty() const
{
    return m_lstEntries.IsEmpty();
}


//------------------------------------------------------------------------------
inline void        
DelayedMsgQ::Add(MsgEntry * pEntry)
{
    AssertMsg(!m_DEBUG_fStartDestroy, "Must not have started final destruction");

    pEntry->pmo->Lock();
    m_lstEntries.AddHead(pEntry);
}


#endif // CORE__MsgQ_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\parkcontainer.h ===
/***************************************************************************\
*
* File: ParkContainer.h
*
* Description:
* ParkContainer defines the "Parking Container" used to hold Gadgets that
* are in the process of being constructed.
*
*
* History:
*  3/25/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/

#if !defined(CORE__ParkContainer_h__INCLUDED)
#define CORE__ParkContainer_h__INCLUDED
#pragma once

#include "Container.h"
#include "RootGadget.h"

class DuParkGadget;
class DuParkContainer;

class DuParkGadget : public DuRootGadget
{
public:
    virtual ~DuParkGadget();
    static  HRESULT     Build(DuContainer * pconOwner, DuRootGadget ** ppgadNew);
    virtual void        xwDestroy();

    friend DuParkContainer;
};

class DuParkContainer : public DuContainer
{
// Construction
public:
			DuParkContainer();
	virtual ~DuParkContainer();
            HRESULT     Create();
            void        xwPreDestroy();

// Base Interface
public:
    virtual HandleType  GetHandleType() const { return htParkContainer; }

// Container Interface
public:
    virtual void        OnGetRect(RECT * prcDesktopPxl);
    virtual void        OnInvalidate(const RECT * prcInvalidContainerPxl);
    virtual void        OnStartCapture();
    virtual void        OnEndCapture();
    virtual BOOL        OnTrackMouseLeave();
    virtual void        OnSetFocus();
    virtual void        OnRescanMouse(POINT * pptContainerPxl);

    virtual BOOL        xdHandleMessage(UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT * pr, UINT nMsgFlags);

// Operations
public:

// Data
protected:

    friend DuParkGadget;
};

//------------------------------------------------------------------------------
inline DuParkContainer * CastParkContainer(BaseObject * pBase)
{
    if ((pBase != NULL) && (pBase->GetHandleType() == htParkContainer)) {
        return (DuParkContainer *) pBase;
    }
    return NULL;
}

DuParkContainer * GetParkContainer(DuVisual * pgad);

#endif // CORE__ParkContainer_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\msgq.h ===
/***************************************************************************\
*
* File: MsgQ.h
*
* Description:
* MsgQ defines a lightweight queue of Gadget messages.
*
*
* History:
*  3/30/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(CORE__MsgQ_h__INCLUDED)
#define CORE__MsgQ_h__INCLUDED
#pragma once

class DuEventGadget;
class CoreST;
struct MsgEntry;

typedef HRESULT (CALLBACK * ProcessMsgProc)(MsgEntry * pEntry);

struct MsgEntry : public ReturnMem
{
    inline  GMSG *      GetMsg() const;

            Thread *    pthrSender; // Sending thread
            MsgObject * pmo;        // Gadget message is about
            UINT        nFlags;     // Flags modifying message
            HANDLE      hEvent;     // Event to notify when complete
            HRESULT     nResult;    // Result from GadgetProc()
            ProcessMsgProc
                        pfnProcess; // Message processing callback
};

#define SGM_ALLOC           0x80000000      // Allocated memory should be freed by receiver
#define SGM_RETURN          0x40000000      // Allocated memory should be returned to called

#define SGM_ENTIRE         (SGM_VALID | SGM_ALLOC | SGM_RETURN)

HRESULT CALLBACK   xwProcessDirect(MsgEntry * pEntry);
HRESULT CALLBACK   xwProcessFull(MsgEntry * pEntry);
HRESULT CALLBACK   xwProcessMethod(MsgEntry * pEntry);

void            xwInvokeMsgTableFunc(const MsgObject * pmo, MethodMsg * pmsg);
ProcessMsgProc  GetProcessProc(DuEventGadget * pdgb, UINT nFlags);


/***************************************************************************\
*****************************************************************************
*
* class BaseMsgQ defines a light-weight queue of messages.  This class itself 
* is NOT thread-safe and is normally wrapped with another class like SafeMsgQ 
* that provides thread-safe operations.
*
*****************************************************************************
\***************************************************************************/

class BaseMsgQ
{
// Operations
public:
#if DBG
    inline  void        DEBUG_MarkStartDestroy();
#endif // DBG

// Implementation
protected:
            void        xwProcessNL(MsgEntry * pHead);
    static  void CALLBACK MsgObjectFinalUnlockProcNL(BaseObject * pobj, void * pvData);

// Data
protected:
#if DBG
            BOOL        m_DEBUG_fStartDestroy:1;
#endif // DBG
};


/***************************************************************************\
*****************************************************************************
*
* class SafeMsgQ defines a customized queue that supports inter-thread
* messaging.
*
*****************************************************************************
\***************************************************************************/

class SafeMsgQ : public BaseMsgQ
{
// Construction
public:
            ~SafeMsgQ();

// Operations
public:
    inline  BOOL        IsEmpty() const;

    inline  void        AddNL(MsgEntry * pEntry);
            void        xwProcessNL();
            HRESULT     PostNL(Thread * pthrSender, GMSG * pmsg, MsgObject * pmo, ProcessMsgProc pfnProcess, UINT nFlags);

// Data
protected:
            GInterlockedList<MsgEntry> m_lstEntries;
};


/***************************************************************************\
*****************************************************************************
*
* class DelayedMsgQ defines a customized queue that supports additional 
* functionality for enqueing "delayed" messages.
*
*****************************************************************************
\***************************************************************************/

class DelayedMsgQ : protected BaseMsgQ
{
// Construction
public:
    inline  ~DelayedMsgQ();
    inline  void        Create(TempHeap * pheap);

// Operations
public:
    inline  BOOL        IsEmpty() const;

            void        xwProcessDelayedNL();
            HRESULT     PostDelayed(GMSG * pmsg, DuEventGadget * pgadMsg, UINT nFlags);

// Implementation
protected:
    inline  void        Add(MsgEntry * pEntry);

// Data
protected:
            GSingleList<MsgEntry> m_lstEntries;
            TempHeap *  m_pheap;
            BOOL        m_fProcessing:1;
};

#include "MsgQ.inl"

#endif // CORE__MsgQ_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\parkcontainer.cpp ===
/***************************************************************************\
*
* File: ParkContainer.cpp
*
* Description:
* DuParkContainer implements the "Parking Container" used to hold Gadgets 
* that are in the process of being constructed.
*
*
* History:
*  3/25/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/

#include "stdafx.h"
#include "Core.h"
#include "ParkContainer.h"

#include "TreeGadget.h"
#include "RootGadget.h"

/***************************************************************************\
*****************************************************************************
*
* API Implementation
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
DuParkContainer * 
GetParkContainer(DuVisual * pgad)
{
    DuContainer * pcon = pgad->GetContainer();
    AssertReadPtr(pcon);

    DuParkContainer * pconPark = CastParkContainer(pcon);
    return pconPark;
}


/***************************************************************************\
*****************************************************************************
*
* class DuParkGadget
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
DuParkGadget::~DuParkGadget()
{
    //
    // Since DuParkGadget::xwDestroy() does nothing, the destructor has to 
    // implement key pieces of DuVisual::xwDestroy().
    //

    xwBeginDestroy();
}


//------------------------------------------------------------------------------
HRESULT
DuParkGadget::Build(DuContainer * pconOwner, DuRootGadget ** ppgadNew)
{
    DuParkGadget * pgadRoot = ClientNew(DuParkGadget);
    if (pgadRoot == NULL) {
        return E_OUTOFMEMORY;
    }


    CREATE_INFO ci;
    ZeroMemory(&ci, sizeof(ci));
    pgadRoot->Create(pconOwner, FALSE, &ci);

    *ppgadNew = pgadRoot;
    return S_OK;
}


//------------------------------------------------------------------------------
void        
DuParkGadget::xwDestroy()
{
    // The parking DuVisual can not be destroyed from some outside force.
}


/***************************************************************************\
*****************************************************************************
*
* class DuParkContainer
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
DuParkContainer::DuParkContainer()
{

}


//------------------------------------------------------------------------------
DuParkContainer::~DuParkContainer()
{
    //
    // Need to destroy the DuVisual tree before this class is destructed since
    // it may need to make calls to the container during its destruction.  If 
    // we don't do this here, it may end up calling pure-virtual's on the base
    // class.
    //
    // We can't use the normal DestroyDuVisual() call since the xwDestroy() 
    // method for DuParkGadget has been no-op'd out to prevent external callers 
    // from calling DestroyHandle() on it.
    //
    
    if (m_pgadRoot != NULL) {
        DuParkGadget * pgadPark = static_cast<DuParkGadget *> (m_pgadRoot);

        if (pgadPark->HasChildren()) {
            Trace("ERROR: DUser: Parking Gadget still has children upon destruction:\n");

#if DBG
            DuVisual * pgadCur = pgadPark->GetTopChild();
            while (pgadCur != NULL) {
                DuVisual * pgadNext = pgadCur->GetNext();

                //
                // Before blowing away, dump any information.
                //

                GMSG_QUERYDESC msg;
                msg.cbSize      = sizeof(msg);
                msg.hgadMsg     = pgadCur->GetHandle();
                msg.nMsg        = GM_QUERY;
                msg.nCode       = GQUERY_DESCRIPTION;
                msg.szName[0]   = '\0';
                msg.szType[0]   = '\0';

                if (DUserSendEvent(&msg, 0) == DU_S_COMPLETE) {
                    Trace("  HGADGET = 0x%p,  Name: %S,  Type: %S\n", 
                            pgadPark->GetHandle(), msg.szName, msg.szType);
                } else {
                    Trace("  HGADGET = 0x%p", pgadPark->GetHandle());
                }


                //
                // TODO: It is now too late for this Gadget to cleanup.  Need to
                // blow it away.
                //

                pgadCur = pgadNext;
            }
#endif // DBG
        }

        ClientDelete(DuParkGadget, pgadPark);
        m_pgadRoot = NULL;
    }
}


//------------------------------------------------------------------------------
HRESULT
DuParkContainer::Create()
{
    return DuParkGadget::Build(this, &m_pgadRoot);
}


/***************************************************************************\
*
* DuParkContainer::xwPreDestroy
*
* xwPreDestroy() is called by the Core SubContext when the Context is 
* starting destruction.  This provides an opportunity for the DuParkContainer
* to cleanup before the Context destruction destroyed dependent components.
*
\***************************************************************************/

void
DuParkContainer::xwPreDestroy()
{
    if (m_pgadRoot != NULL) {
        DuParkGadget * pgadPark = static_cast<DuParkGadget *> (m_pgadRoot);

        //
        // Need to iterate through the children, removing each from the Parking 
        // Gadget using DeleteHandle().  The children may have been directly 
        // reparented into the Parking Gadget if they were not being used.  In 
        // this case, we want to give them a push to get destroyed.
        //
        // When this is finished, may need to flush the queues so that the 
        // children can be properly destroyed.
        //

        DuVisual * pgadCur = pgadPark->GetTopChild();
        while (pgadCur != NULL) {
            DuVisual * pgadNext = pgadCur->GetNext();
            pgadCur->xwDeleteHandle();
            pgadCur = pgadNext;
        }
    }
}


//------------------------------------------------------------------------------
void
DuParkContainer::OnInvalidate(const RECT * prcInvalidContainerPxl)
{
    UNREFERENCED_PARAMETER(prcInvalidContainerPxl);
}


//------------------------------------------------------------------------------
void
DuParkContainer::OnGetRect(RECT * prcDesktopPxl)
{
    prcDesktopPxl->left     = 0;
    prcDesktopPxl->top      = 0;
    prcDesktopPxl->right    = 10000;
    prcDesktopPxl->bottom   = 10000;
}


//------------------------------------------------------------------------------
void        
DuParkContainer::OnStartCapture()
{
    
}


//------------------------------------------------------------------------------
void        
DuParkContainer::OnEndCapture()
{
    
}


//------------------------------------------------------------------------------
BOOL
DuParkContainer::OnTrackMouseLeave()
{
    return TRUE;
}


//------------------------------------------------------------------------------
void        
DuParkContainer::OnSetFocus()
{
    
}


//------------------------------------------------------------------------------
void        
DuParkContainer::OnRescanMouse(POINT * pptContainerPxl)
{
    pptContainerPxl->x  = -20000;
    pptContainerPxl->y  = -20000;
}


//------------------------------------------------------------------------------
BOOL        
DuParkContainer::xdHandleMessage(UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT * pr, UINT nMsgFlags)
{
    //
    // TODO: What exactly should happen to a message that gets sent to the 
    // parking container?  The DuVisuals inside are in a semi-suspended state
    // and are not expecting interaction with the outside world.
    //
    // For now, just throw everything away.
    //

    UNREFERENCED_PARAMETER(nMsg);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(pr);
    UNREFERENCED_PARAMETER(nMsgFlags);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\proplist.cpp ===
/***************************************************************************\
*
* File: PropList.cpp
*
* Description:
* PropList.cpp implements standard dynamic properties that can be hosted on 
* any object.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Core.h"
#include "PropList.h"

/***************************************************************************\
*****************************************************************************
*
* class PropSet
*
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* PropSet::GetData
* 
* GetData() searches through window-specific user-data for a specific
* data-element and returns the corresponding data.  If the data is not found,
* NULL is returned.
*
\***************************************************************************/

HRESULT
PropSet::GetData(
    IN PRID id,                     // Short ID to find
    OUT void ** ppnValue            // Value of property
    ) const
{
    // Check parameters
    AssertWritePtr(ppnValue);

    // Search data
    int idxData = FindItem(id);
    if (idxData >= 0) {
        *ppnValue = m_arData[idxData].pData;
        return S_OK;
    }

    *ppnValue = NULL;
    return E_INVALIDARG;
}


/***************************************************************************\
*
* PropSet::SetData
*
* SetDataImpl() searches through window-specific user-data for a specific
* data-element and changes the corresponding value.  If the data is not 
* found, a new data-element is added and the value is set.
*
\***************************************************************************/

HRESULT
PropSet::SetData(
    IN  PRID id,                    // Property to change / add
    IN  void * pNewData)            // New value of property
{
    //
    // Search for existing data.

    int idxData = FindItem(id);
    if (idxData >= 0) {
        m_arData[idxData].pData = pNewData;
        return S_OK;
    }


    //
    // Data not found, so need to add.  (don't forget to allocate for leading 
    // item count.)
    //

    return AddItem(id, pNewData) ? S_OK : E_OUTOFMEMORY;
}


/***************************************************************************\
*
* PropSet::SetData
*
* SetData() allocates and adds new data to the PDS.  If data with the same 
* PRID is found, it will be returned instead of new data being allocated.  
* If the old data is a different size than the new data, this will cause a 
* problem.
*
\***************************************************************************/

HRESULT
PropSet::SetData(
    IN  PRID id,                    // Property to change / add
    IN  int cbSize,                 // Size of data
    OUT void ** ppNewData)          // Memory for property
{
    AssertWritePtr(ppNewData);
    AssertMsg(cbSize > sizeof(void *), "Call SetData() directly for small allocations");


    //
    // Search for existing data.
    //
    
    int idxData = FindItem(id);
    if (idxData >= 0) {
        *ppNewData = m_arData[idxData].pData;
        return S_OK;
    }


    //
    // Data not found, so allocate and add.  (don't forget to allocate for 
    // leading item count.)
    //

    void * pvNew = ClientAlloc(cbSize);
    if (pvNew == NULL) {
        return E_OUTOFMEMORY;
    }

    if (AddItem(id, pvNew)) {
        *ppNewData = pvNew;
        return S_OK;
    }

    //
    // Unable to allocate storage for actual data
    //

    ClientFree(pvNew);
    return E_OUTOFMEMORY;
}


/***************************************************************************\
*
* PropSet::RemoveData
*
* RemoveData() searches through and removes a window-specific 
* user-data for a specific data-element.
*
\***************************************************************************/

void 
PropSet::RemoveData(
    IN PRID id,                     // Short ID to find
    IN BOOL fFree)                  // Free memory pointed to by item
{
    int idxData = FindItem(id);
    if (idxData >= 0) {
        AssertMsg(ValidatePrivateID(id) || (!fFree), "Can only free private data");

        if (fFree) {
            void * pvMem = m_arData[idxData].pData;
            ClientFree(pvMem);
        }

        RemoveAt(idxData);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\proplist.h ===
/***************************************************************************\
*
* File: PropList.h
*
* Description:
* PropList.h defines lighweight, dynamic properties that can be hosted on 
* any object.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(CORE__PropList_h__INCLUDED)
#define CORE__PropList_h__INCLUDED
#pragma once

#include "DynaSet.h"

/***************************************************************************\
*
* PropSet maintains a set of unique properties for a given item.  This
* is a one to (potentially) many relationship.  Each property only appears 
* once in the set.
*
\***************************************************************************/

//------------------------------------------------------------------------------
class PropSet : public DynaSet
{
// Operations
public:
            HRESULT     GetData(PRID id, void ** ppData) const;
            HRESULT     SetData(PRID id, void * pNewData);
            HRESULT     SetData(PRID id, int cbSize, void ** ppNewData);
            void        RemoveData(PRID id, BOOL fFree);
};

#include "PropList.inl"

#endif // CORE__PropList_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\proplist.inl ===
/***************************************************************************\
*
* File: PropList.inl
*
* Description:
* PropList.inl implements standard dynamic properties that can be hosted on 
* any object.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(CORE__PropList_inl__INCLUDED)
#define CORE__PropList_inl__INCLUDED

/***************************************************************************\
*****************************************************************************
*
* class PropSet
*
*****************************************************************************
\***************************************************************************/

#endif // CORE__PropList_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\public.h ===
/***************************************************************************\
*
* File: Public.h
*
* Description:
* Public.h contains a list of definitions that are exposed and available
* outside this project.  Any other DirectUser project that wishes to use
* these services directly instead of going through public API's can include
* a corresponding [Project]P.h available in the \inc directory.  
* 
* Definitions that are not exposed through this file are considered project 
* specific implementation details and should not used in other projects.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(CORE__Public_h__INCLUDED)
#define CORE__Public_h__INCLUDED

#include "DynaSet.h"
#include "PropList.h"
#include "Context.h"
#include "Container.h"
#include "TreeGadget.h"
#include "MessageGadget.h"
#include "EventPool.h"
#include "RootGadget.h"
#include "ParkContainer.h"
#include "Init.h"
#include "Callback.h"

#endif // CORE__Public_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	Core.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\stdafx.h ===
#if !defined(CORE__StdAfx_h__INCLUDED)
#define CORE__StdAfx_h__INCLUDED

#pragma once

#include "CommonStdAfx.h"

#endif // CORE__StdAfx_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\thread.cpp ===
/***************************************************************************\
*
* File: Thread.cpp
*
* Description:
* This file implements the SubThread used by the DirectUser/Core project to
* maintain Thread-specific data.
*
*
* History:
*  4/20/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Core.h"
#include "Thread.h"

#include "Context.h"

IMPLEMENT_SUBTHREAD(Thread::slCore, CoreST);

/***************************************************************************\
*****************************************************************************
*
* class CoreST
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
CoreST::~CoreST()
{
#if ENABLE_MPH
    Context * pctx = m_pParent->GetContext();
    CoreSC * pSC = GetCoreSC(pctx);
    if ((pSC != NULL) && (pSC->GetMsgMode() == IGMM_STANDARD)) {
        UninitMPH();
    }
#endif
}


//------------------------------------------------------------------------------
HRESULT
CoreST::Create()
{
    //
    // Initialize the deferred message queue to use to use the thread's 
    // temporary heap.
    //

    m_msgqDefer.Create(m_pParent->GetTempHeap());

    return S_OK;
}


//------------------------------------------------------------------------------
void        
CoreST::xwLeftContextLockNL()
{
    xwProcessDeferredNL();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\rootgadget.inl ===
/***************************************************************************\
*
* File: RootGadget.inl
*
* Description:
* RootGadget.inl implements the top-most node for a Gadget-Tree that 
* interfaces to the outside world.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(CORE__DuRootGadget_inl__INCLUDED)
#define CORE__DuRootGadget_inl__INCLUDED
#pragma once

//------------------------------------------------------------------------------
inline DuContainer *  
DuVisual::GetContainer() const
{
    return GetRoot()->m_pconOwner;
}


//------------------------------------------------------------------------------
inline 
DuRootGadget::DuRootGadget()
{
    AssertMsg(m_ri.nSurface == GSURFACE_HDC, "Must default to HDC");
    m_fForeground = TRUE;
}


//------------------------------------------------------------------------------
inline BOOL
DuRootGadget::xdSetKeyboardFocus(DuVisual * pgadNew)
{
    return xdUpdateKeyboardFocus(pgadNew);
}


//------------------------------------------------------------------------------
inline void
DuRootGadget::xdHandleMouseLeaveMessage()
{
    //
    // The mouse is leaving us, so we need to update
    //

    xdUpdateMouseFocus(NULL, NULL);
}


//------------------------------------------------------------------------------
inline BOOL
DuRootGadget::HasAdaptors() const
{
    return !m_arpgadAdaptors.IsEmpty();
}


#endif // CORE__DuRootGadget_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\rootgadget.cpp ===
/***************************************************************************\
*
* File: RootGadget.cpp
*
* Description:
* RootGadget.cpp defines the top-most node for a Gadget-Tree that interfaces
* to the outside world.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#include "stdafx.h"
#include "Core.h"
#include "RootGadget.h"
#include "TreeGadgetP.h"

#include "Container.h"

#if ENABLE_FRAMERATE
#include <stdio.h>
#endif

#define DEBUG_TraceDRAW             0   // Trace painting calls

/***************************************************************************\
*****************************************************************************
*
* Public API's
*
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* GdxrDrawGadgetTree (API Implementation)
*
* GdxrDrawGadgetTree() draws the specified DuVisual sub-tree.
*
\***************************************************************************/

BOOL
GdxrDrawGadgetTree(
    IN  DuVisual * pgadDraw,    // Gadget sub-tree to draw
    IN  HDC hdcDraw,                // HDC to draw into
    IN  const RECT * prcDraw,       // Clipping area
    IN  UINT nFlags)                // Optional drawing flags
{
    RECT rcClient, rcDraw;
    AssertReadPtr(pgadDraw);

    DuRootGadget * pgadRoot = pgadDraw->GetRoot();
    if (pgadRoot == NULL) {
        return FALSE;
    }

    // TODO: Need to change this to SGR_ACTUAL
    pgadDraw->GetLogRect(&rcClient, SGR_CONTAINER);
    if (prcDraw == NULL) {
        prcDraw = &rcClient;
    }

    if (IntersectRect(&rcDraw, &rcClient, prcDraw)) {
#if ENABLE_OPTIMIZEDIRTY
        pgadRoot->xrDrawTree(pgadDraw, hdcDraw, &rcClient, nFlags, TRUE);
#else
        pgadRoot->xrDrawTree(pgadDraw, hdcDraw, &rcClient, nFlags);
#endif
    }

    return TRUE;
}


/***************************************************************************\
*****************************************************************************
*
* class DuRootGadget
*
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* DuRootGadget::Create
*
* Create() initializes a new DuRootGadget.  Since both DuRootGadget and 
* ParkGadget will create new DuRootGadget's, it is important that common 
* initialization code appears here.
*
\***************************************************************************/

HRESULT
DuRootGadget::Create(
    IN  DuContainer * pconOwner,    // Container holding DuVisual tree
    IN  BOOL fOwn,                  // Destroy container when Gadget is destroyed
    IN  CREATE_INFO * pci)          // Creation information
{
#if ENABLE_FRAMERATE
    m_dwLastTime    = GetTickCount();
    m_cFrames       = 0;
    m_flFrameRate   = 0.0f;
#endif

    AssertMsg(m_fRelative, "Root MUST be relative or we will never have any relative children");
    m_fMouseFocus = TRUE;           // Root always has mouse information
    m_fRoot = TRUE;                 // Must mark as Root

    m_fOwnContainer = fOwn;

    HRESULT hr = CommonCreate(pci);
    if (FAILED(hr)) {
        return hr;
    }

    m_pconOwner = pconOwner;
    pconOwner->AttachGadget(this);

    RECT rcDesktopPxl;
    pconOwner->OnGetRect(&rcDesktopPxl);
    VerifyHR(xdSetLogRect(0, 0, rcDesktopPxl.right - rcDesktopPxl.left, rcDesktopPxl.bottom - rcDesktopPxl.top, SGR_SIZE | SGR_CONTAINER));

    return hr;
}


//------------------------------------------------------------------------------
DuRootGadget::~DuRootGadget()
{
    AssertMsg(m_arpgadAdaptors.IsEmpty(), "All Adaptors should have been removed by now");

    if (m_fOwnContainer && (m_pconOwner != NULL)) {
        //
        // Since already in the destructor, must first destach then destroy the
        // container.
        //

        m_pconOwner->DetachGadget();
        m_pconOwner->xwUnlock();
        m_pconOwner = NULL;
    }
}


/***************************************************************************\
*
* DuRootGadget::Build
*
* Build() creates a new DuRootGadget to be hosted inside of a generic
* container.
*
\***************************************************************************/

HRESULT
DuRootGadget::Build(
    IN  DuContainer * pconOwner,    // Container holding DuVisual tree
    IN  BOOL fOwn,                  // Destroy container when Gadget is destroyed
    IN  CREATE_INFO * pci,          // Creation information
    OUT DuRootGadget ** ppgadNew)   // New Gadget
{
    if (pconOwner == NULL) {
        return E_INVALIDARG;
    }

    DuRootGadget * pgadNew = ClientNew(DuRootGadget);
    if (pgadNew == NULL) {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pgadNew->Create(pconOwner, fOwn, pci);
    if (FAILED(hr)) {
        delete pgadNew;
        return hr;
    }

    *ppgadNew = pgadNew;
    return hr;
}


/***************************************************************************\
*
* DuRootGadget::xwDestroy
*
* xwDestroy() is called from xwDeleteHandle() to destroy a Gadget and free 
* its associated resources.
*
\***************************************************************************/

void        
DuRootGadget::xwDestroy()
{
    //
    // Even though a DuRootGadget is a DuVisual, it isn't allocated in its 
    // pool, so it needs to bypass the DuVisual::xwDestroy().
    //

    xwBeginDestroy();

    DuEventGadget::xwDestroy();
}



#if DEBUG_MARKDRAWN

/***************************************************************************\
*
* DuRootGadget::ResetFlagDrawn
*
* ResetFlagDrawn() marks a DuVisual subtree as not drawn.
*
\***************************************************************************/

extern volatile BOOL g_fFlagDrawn;

void
DuRootGadget::ResetFlagDrawn(DuVisual * pgad)
{
    pgad->m_fMarkDrawn = FALSE;

    DuVisual * pgadCur = pgad->GetTopChild();
    while (pgadCur != NULL) {
        ResetFlagDrawn(pgadCur);
        pgadCur = pgadCur->GetNext();
    }
}

#endif


/***************************************************************************\
*
* DuRootGadget::xrDrawTree
*
* xrDrawTree() initializes and begins the drawing of a Gadget sub-tree.  It 
* is important to call this function to begin drawing from instead of 
* directly calling DuVisual::xrDrawStart() so that the HDC and XForm Matric 
* get properly initialized.
*
\***************************************************************************/

void
DuRootGadget::xrDrawTree(
    IN  DuVisual * pgadStart,   // Gadget to start drawing from (NULL for root)
    IN  HDC hdcDraw,                // HDC to draw into
    IN  const RECT * prcInvalid,    // Area to draw / clip into
    IN  UINT nFlags                 // Optional drawing flags
#if ENABLE_OPTIMIZEDIRTY
    IN  ,BOOL fDirty)                // Initial "dirty" state
#else
    )
#endif
{
#if DEBUG_TraceDRAW
    Trace("START xrDrawTree(): %d,%d %dx%d      @ %d\n", 
            prcInvalid->left, prcInvalid->top, 
            prcInvalid->right - prcInvalid->left, prcInvalid->bottom - prcInvalid->top,
            GetTickCount());
#endif // DEBUG_TraceDRAW

    if (IsRectEmpty(prcInvalid)) {
        return;
    }


    //
    // The application is not allowed to modify the tree while we are calling
    // back on each node to draw.
    //

    ReadOnlyLock rol;


    //
    // Prepare the DC and initialize a PaintInfo to be used when painting.
    //

    int nOldMode = 0;
    if (SupportXForm()) {
        nOldMode = SetGraphicsMode(hdcDraw, GM_ADVANCED);
    }

    XFORM xfOld;
    OS()->PushXForm(hdcDraw, &xfOld);

    //
    // When not starting at the root, need to apply all of the matricies from
    // the root to this node.  This means we need to build _inverse_ XForm to
    // transform prcInvalid and build a normal XForm to transform the HDC.
    //

    RECT rcNewInvalid;
    if (pgadStart != NULL) {
        Matrix3 matStart;
        BuildXForm(&matStart);

        if (SupportXForm()) {
            XFORM xfStart;
            matStart.Get(&xfStart);
            SetWorldTransform(hdcDraw, &xfStart);
        } else {
            OS()->TranslateDC(hdcDraw, matStart[2][0], matStart[2][1]);
        }

        Matrix3 mat;
        BuildAntiXForm(&mat);
        mat.ComputeBounds(&rcNewInvalid, prcInvalid, HINTBOUNDS_Invalidate);
        prcInvalid = &rcNewInvalid;
    } else {
        pgadStart = this;
    }


    //
    // Draw the subtree
    //

    DuSurface * psrf = NULL;
    Gdiplus::Graphics * pgpgr = NULL;
    HPALETTE hpalOld = NULL;
    RECT rcNewInvalid2;
    int nExpandInvalid = 0;

    switch (m_ri.nSurface)
    {
    case GSURFACE_GPGRAPHICS:
        if (ResourceManager::IsInitGdiPlus()) {
            pgpgr = new Gdiplus::Graphics(hdcDraw);
            if (pgpgr != NULL) {
                DuGpSurface * psrfNew = NULL;
                if (SUCCEEDED(DuGpSurface::Build(pgpgr, &psrfNew))) {
                    psrf = psrfNew;

                    if (m_ri.pgppal != NULL) {
                        // TODO: Setup GDI+ palettes
                    }


                    //
                    // When building a Gdiplus Graphics, need to propagate the
                    // invalid region to help optimize the drawing.
                    //

                    Gdiplus::RectF gprcInvalid = Convert(prcInvalid);
                    pgpgr->SetClip(gprcInvalid);
                    
                    
                    //
                    // When using GDI+ with anti-aliasing, we need to expand
                    // the invalid region to accomodate for the overflow.
                    //

                    nExpandInvalid = 1;
                } else {
                    delete pgpgr;
                    pgpgr = NULL;
                }
            }
        }
        break;

    case GSURFACE_HDC:
        {
            DuDCSurface * psrfNew;
            if (SUCCEEDED(DuDCSurface::Build(hdcDraw, &psrfNew))) {
                psrf = psrfNew;

                //
                // Setup palettes
                //

                if (m_ri.hpal != NULL) {
                    hpalOld = SelectPalette(hdcDraw, m_ri.hpal, !m_fForeground);
                    RealizePalette(hdcDraw);
                }
            }
        }
        break;

    default:
        AssertMsg(0, "Unknown surface type");
        Assert(psrf == NULL);
    }


    //
    // Check if the invalid area needs to be "expanded" out.
    //

    if (nExpandInvalid != 0) {
        rcNewInvalid2.left      = prcInvalid->left - nExpandInvalid;
        rcNewInvalid2.top       = prcInvalid->top - nExpandInvalid;
        rcNewInvalid2.right     = prcInvalid->right + nExpandInvalid;
        rcNewInvalid2.bottom    = prcInvalid->bottom + nExpandInvalid;

        prcInvalid = &rcNewInvalid2;
    }


    //
    // Setup the PaintInfo and begin the painting operation
    //

    if (psrf) {
        PaintInfo pi;
        Matrix3 matInvalid, matDC;
        pi.psrf                 = psrf;
        pi.prcCurInvalidPxl     = prcInvalid;
        pi.prcOrgInvalidPxl     = prcInvalid;
        pi.pmatCurInvalid       = &matInvalid;
        pi.pmatCurDC            = &matDC;
        pi.fBuffered            = FALSE;
#if ENABLE_OPTIMIZEDIRTY
        pi.fDirty               = fDirty;
#endif
        pi.sizeBufferOffsetPxl.cx  = 0;
        pi.sizeBufferOffsetPxl.cy  = 0;

#if DEBUG_MARKDRAWN
        if (g_fFlagDrawn) {
            ResetFlagDrawn(this);
        }
#endif

        pgadStart->xrDrawStart(&pi, nFlags);


#if ENABLE_FRAMERATE
        //
        // Display the frame rate
        //
        TCHAR szFrameRate[40];

        m_cFrames++;
        DWORD dwCurTime = GetTickCount();
        DWORD dwDelta   = dwCurTime - m_dwLastTime;
        if (dwDelta >= 1000) {
            m_flFrameRate   = ((float) m_cFrames) * 1000.0f / (float) dwDelta;
            sprintf(szFrameRate, _T("Frame Rate: %5.1f at time 0x%x\n"), m_flFrameRate, dwCurTime);
            m_cFrames = 0;
            m_dwLastTime = dwCurTime;

            OutputDebugString(szFrameRate);
        }
#endif

        //
        // Cleanup from successful drawing
        //

        switch (m_ri.nSurface)
        {
        case GSURFACE_GPGRAPHICS:
            if (pgpgr) {
                delete pgpgr;
            }
            break;

        case GSURFACE_HDC:
            if (m_ri.hpal != NULL) {
                SelectPalette(hdcDraw, hpalOld, FALSE);
            }
            break;

        default:
            AssertMsg(0, "Unknown surface type");
            Assert(psrf == NULL);
        }



        psrf->Destroy();
    }


    //
    // Remaining cleanup
    //

    OS()->PopXForm(hdcDraw, &xfOld);

    if (SupportXForm()) {
        SetGraphicsMode(hdcDraw, nOldMode);
    }

#if DEBUG_TraceDRAW
    Trace("STOP  xrDrawTree(): %d,%d %dx%d      @ %d\n", 
            prcInvalid->left, prcInvalid->top, 
            prcInvalid->right - prcInvalid->left, prcInvalid->bottom - prcInvalid->top,
            GetTickCount());
#endif // DEBUG_TraceDRAW
}


/***************************************************************************\
*
* DuRootGadget::GetInfo
*
* GetInfo() gets optional / dynamic information for the DuRootGadget, 
* including how to render, etc.
*
\***************************************************************************/

void
DuRootGadget::GetInfo(
    IN  ROOT_INFO * pri             // Information
    ) const
{
    if (TestFlag(pri->nMask, GRIM_OPTIONS)) {
        pri->nOptions = m_ri.nOptions & GRIO_VALID;
    }

    if (TestFlag(pri->nMask, GRIM_SURFACE)) {
        pri->nSurface = m_ri.nSurface;
    }

    if (TestFlag(pri->nMask, GRIM_PALETTE)) {
        pri->pvData = m_ri.pvData;
    }
}


/***************************************************************************\
*
* DuRootGadget::SetInfo
*
* SetInfo() sets optional / dynamic information for the DuRootGadget, 
* including how to render, etc.
*
\***************************************************************************/

HRESULT
DuRootGadget::SetInfo(
    IN  const ROOT_INFO * pri)      // Information
{
    //
    // Update options
    //

    if (TestFlag(pri->nMask, GRIM_OPTIONS)) {
        m_ri.nOptions = pri->nOptions & GRIO_VALID;

        GetContainer()->SetManualDraw(TestFlag(m_ri.nOptions, GRIO_MANUALDRAW));
    }


    //
    // Update the default rendering surface type
    //

    if (TestFlag(pri->nMask, GRIM_SURFACE) && (m_ri.nSurface != pri->nSurface)) {
        m_ri.nSurface = pri->nSurface;

        //
        // Reset information that is surface specific.
        //

        m_ri.pvData = NULL;
    }


    //
    // Setup new information that is surface specific after we have determined
    // the surface type being used.
    //

    if (TestFlag(pri->nMask, GRIM_PALETTE)) {
        m_typePalette = DuDCSurface::GetSurfaceType(pri->nSurface);
        m_ri.pvData = pri->pvData;
    }

    return S_OK;
}


//------------------------------------------------------------------------------
DuVisual *
DuRootGadget::GetFocus()
{
    CoreSC * pSC = GetCoreSC();
    return pSC->pgadCurKeyboardFocus;
}


/***************************************************************************\
*
* DuRootGadget::xdFireChangeState
*
* xdFireChangeState() prepares for and fires messages associated with a 
* GM_CHANGESTATE.  Since the message is deferred, it is very important not
* to pass a Gadget that has started destruction since it may not exist when
* the message is actually handled.
*
\***************************************************************************/

void
DuRootGadget::xdFireChangeState(
    IN OUT DuVisual ** ppgadLost,   // Gadget loosing state
    IN OUT DuVisual ** ppgadSet,    // Gadget gaining state
    IN  UINT nCmd)                      // State change
{
    HGADGET hgadLost, hgadSet;
    DuVisual * pgadLost = *ppgadLost;
    DuVisual * pgadSet = *ppgadSet;

    //
    // Determine the handles
    //

    if ((pgadLost != NULL) && (!pgadLost->m_fFinalDestroy)) {
        hgadLost = (HGADGET) pgadLost->GetHandle();
    } else {
        pgadLost = NULL;
        hgadLost = NULL;
    }
    if ((pgadSet != NULL) && (!pgadSet->m_fFinalDestroy)) {
        hgadSet = (HGADGET) pgadSet->GetHandle();
    } else {
        pgadSet = NULL;
        hgadSet = NULL;
    }


    //
    // Fire the messages
    //

    if (pgadLost != NULL) {
        pgadLost->m_cb.xdFireChangeState(pgadLost, nCmd, hgadLost, hgadSet, GSC_LOST);
    }
    if (pgadSet != NULL) {
        pgadSet->m_cb.xdFireChangeState(pgadSet, nCmd, hgadLost, hgadSet, GSC_SET);
    }

    *ppgadLost = pgadLost;
    *ppgadSet = pgadSet;
}


/***************************************************************************\
*
* DuRootGadget::NotifyDestroy
*
* NotifyDestroy() is called when a Gadget is destroyed.  This gives the
* DuRootGadget an opportunity to update any cached information.
*
\***************************************************************************/

void
DuRootGadget::NotifyDestroy(
    IN  const DuVisual * pgadDestroy) // Gadget being destroyed
{
    CoreSC * pSC = GetCoreSC();

#if DBG
    if (pSC->pgadDrag != NULL) {
        AssertMsg(!pSC->pgadDrag->IsDescendent(pgadDestroy), 
                "Should have already cleaned up drag");
    }

    if (pSC->pgadMouseFocus != NULL) {
        AssertMsg((pgadDestroy == this) || 
                (!pSC->pgadMouseFocus->IsDescendent(pgadDestroy)), 
                "Should have already cleaned up mouse focus");
    }
#endif // DBG

    if (pgadDestroy == pSC->pressLast.pgadClick) {
        pSC->pressLast.pgadClick = NULL;
    }        

    if (pgadDestroy == pSC->pressNextToLast.pgadClick) {
        pSC->pressNextToLast.pgadClick = NULL;
    }        

    if (pgadDestroy == pSC->pgadRootMouseFocus) {
        pSC->pgadRootMouseFocus = NULL;
    }

    if (pgadDestroy == pSC->pgadMouseFocus) {
        pSC->pgadMouseFocus = NULL;
    }

    if (pgadDestroy == pSC->pgadCurKeyboardFocus) {
        pSC->pgadCurKeyboardFocus = NULL;
    }

    if (pgadDestroy == pSC->pgadLastKeyboardFocus) {
        pSC->pgadLastKeyboardFocus = NULL;
    }
}


/***************************************************************************\
*
* DuRootGadget::xdNotifyChangeInvisible
*
* xdNotifyChangeInvisible() is called when a Gadget becomes invisible.  This 
* gives the DuRootGadget an opportunity to update any cached information.
*
\***************************************************************************/

void        
DuRootGadget::xdNotifyChangeInvisible(
    IN  const DuVisual * pgadChange)  // Gadget being changed
{
    AssertMsg(!pgadChange->m_fVisible, "Only call on invisible Gadget's");

    //
    // Check if the Gadget that we were dragging on has just disappeared.  We
    // need to cancel the drag operation.
    //

    CoreSC * pSC = GetCoreSC();
    if ((pSC->pgadDrag != NULL) && pgadChange->IsDescendent(pSC->pgadDrag)) {
        xdHandleMouseLostCapture();
    }


    //
    // When someone becomes invisible, there "position" has changed, so we
    // need to update mouse focus.
    //

    xdNotifyChangePosition(pgadChange);
}


/***************************************************************************\
*
* DuRootGadget::CheckCacheChange
*
* CheckCacheChange() checks if the changing Gadget is currently within a
* subtree represented by some cached data.  This is used to determine if we
* need to change the cached data.
*
\***************************************************************************/

BOOL
DuRootGadget::CheckCacheChange(
    IN  const DuVisual * pgadChange,  // Gadget being changed
    IN  const DuVisual * pgadCache    // Cached variable
    ) const
{
    //
    // A Gadget has moved, so we need to update the cached Gadget because
    // it may now be in a different Gadget.  This unfortunately is not cheap 
    // and needs to be called whenever any Gadget changes position.
    //
    // - Change is a descendent of the cached Gadget
    // - Change is a direct child of a some parent of the cached Gadget
    //

    if (pgadCache == NULL) {
        //
        // No one has mouse focus, so we are not even inside the Container.
        // Therefore, no one is going to have mouse focus, even after the 
        // change.
        //

        return FALSE;
    }

    if (pgadCache->IsDescendent(pgadChange)) {
        return TRUE;
    } else {
        //
        // Walk up the tree, checking if pgadChange is a direct child of one
        // of our parents.
        //

        const DuVisual * pgadCurParent    = pgadCache->GetParent();
        const DuVisual * pgadChangeParent = pgadChange->GetParent();

        while (pgadCurParent != NULL) {
            if (pgadChangeParent == pgadCurParent) {
                return TRUE;
            }
            pgadCurParent = pgadCurParent->GetParent();
        }
    }

    return FALSE;
}


/***************************************************************************\
*
* DuRootGadget::xdNotifyChangePosition
*
* xdNotifyChangePosition() is called when a Gadget's position has changed.  
* This gives the DuRootGadget an opportunity to update any cached information.
*
\***************************************************************************/

void
DuRootGadget::xdNotifyChangePosition(
    IN  const DuVisual * pgadChange)  // Gadget being changed
{
    AssertMsg(pgadChange != NULL, "Must specify valid Gadget being changed");

    //
    // If started the destruction process, stop updating the mouse focus.
    //

    if (m_fFinalDestroy) {
        return;
    }


    //
    // Checked cached data
    // - We won't loose mouse focus if a drag operation is going on.
    // - Only care about updating the DropTarget if in "precise" mode.  In
    //   "fast" mode, we are relying on OLE2 to poll so this is unnecessary.
    //

    CoreSC * pSC = GetCoreSC();
    BOOL fMouseFocus = (pSC->pgadDrag == NULL) && CheckCacheChange(pgadChange, pSC->pgadMouseFocus);
    if (fMouseFocus) {
        POINT ptContainerPxl, ptClientPxl;
        GetContainer()->OnRescanMouse(&ptContainerPxl);
        DuVisual * pgadMouse = FindFromPoint(ptContainerPxl, 
                GS_VISIBLE | GS_ENABLED | gspDeepMouseFocus, &ptClientPxl);

        xdUpdateMouseFocus(&pgadMouse, &ptClientPxl);
    }
}


/***************************************************************************\
*
* DuRootGadget::xdNotifyChangeRoot
*
* xdNotifyChangeRoot() is called when a Gadget is moved between Root's.
* This gives the old DuRootGadget an opportunity to update any cached states
* accordingly BEFORE the Gadget is actually moved.
*
\***************************************************************************/

void
DuRootGadget::xdNotifyChangeRoot(
    IN  const DuVisual * pgadChange)  // Gadget being reparented
{
    AssertMsg(pgadChange != NULL, "Must specify valid Gadget");
    AssertMsg(pgadChange->GetRoot() == this, "Must call before reparenting");
    AssertMsg(pgadChange != this, "Can not change Roots");

    CoreSC * pSC = GetCoreSC();


    //
    // If the current keyboard focus is a in the subtree being moved, need to
    // "push" keyboard focus up to the parent of the Gadget being moved.
    //

    if (pSC->pgadCurKeyboardFocus != NULL) {
        if (pgadChange->IsDescendent(pSC->pgadCurKeyboardFocus)) {
            xdUpdateKeyboardFocus(pgadChange->GetParent());
        }
    }

    if (pSC->pgadLastKeyboardFocus != NULL) {
        if (pgadChange->IsDescendent(pSC->pgadLastKeyboardFocus)) {
            pSC->pgadLastKeyboardFocus = NULL;
        }
    }


    //
    // Mouse state
    //

    if (pSC->pgadRootMouseFocus == this) {
        if ((pSC->pgadMouseFocus != NULL) && pgadChange->IsDescendent(pSC->pgadMouseFocus)) {
            DuVisual * pgadParent = pgadChange->GetParent();
            xdUpdateMouseFocus(&pgadParent, NULL);
        }

        if ((pSC->pgadDrag != NULL) && pgadChange->IsDescendent(pSC->pgadDrag)) {
            xdHandleMouseLostCapture();
        }
    }
}


/***************************************************************************\
*
* DuRootGadget::xdHandleActivate
*
* xdHandleActivate() is called by the Container to update window activation 
* inside the Gadget subtree.
*
\***************************************************************************/

BOOL
DuRootGadget::xdHandleActivate(
    IN  UINT nCmd)                  // Command to handle
{
    if (nCmd == GSC_SET) {
        CoreSC * pSC = GetCoreSC();
        xdUpdateKeyboardFocus(pSC->pgadLastKeyboardFocus);
    }

    return FALSE;  // Not completely handled
}


/***************************************************************************\
*
* DuRootGadget::RegisterAdaptor
*
* RegisterAdaptor() adds an Adaptor from the list maintained on this Root.
*
\***************************************************************************/

HRESULT
DuRootGadget::RegisterAdaptor(DuVisual * pgadAdd)
{
    AssertMsg(pgadAdd->m_fAdaptor, "Adaptor must be marked as an Adaptor");
    int idxAdd = m_arpgadAdaptors.Find(pgadAdd);
    AssertMsg(idxAdd < 0, "Calling RegisterAdaptor on an already registered Adaptor");
    if (idxAdd < 0) {
        idxAdd = m_arpgadAdaptors.Add(pgadAdd);
    }

    if (idxAdd >= 0) {
        GetCoreSC()->m_cAdaptors++;
        return S_OK;
    } else {
        return E_OUTOFMEMORY;
    }
}


/***************************************************************************\
*
* DuRootGadget::UnregisterAdaptor
*
* UnregisterAdaptor() removes an Adaptor from the list maintained on this
* Root.
*
\***************************************************************************/

void        
DuRootGadget::UnregisterAdaptor(
    IN  DuVisual * pgadRemove)        // Adaptor to remove
{
    AssertMsg(pgadRemove->m_fAdaptor, "Adaptor must still be marked as an Adaptor");
    if (m_arpgadAdaptors.Remove(pgadRemove)) {
        AssertMsg(GetCoreSC()->m_cAdaptors > 0, "Must have an adaptor to remove");
        GetCoreSC()->m_cAdaptors--;
    } else {
        AssertMsg(0, "Could not find specified adaptor to remove");
    }
}


/***************************************************************************\
*
* DuRootGadget::xdUpdateAdaptors
*
* xdUpdateAdaptors() is called, usually by DuVisual, when something occurs
* that requires the Adaptors to be notified so that they have a chance update
* their cached information.
*
* NOTE: It is somewhat expensive to find the Root to update Adaptors if none
* actually exist.  Therefore, before blindly calling this function, it is 
* best to check on the Context if any Adaptors actually exist.
*
\***************************************************************************/

void        
DuRootGadget::xdUpdateAdaptors(UINT nCode) const
{
    AssertMsg(GetCoreSC()->m_cAdaptors > 0, "Only call when have adaptors");

    if (m_fFinalDestroy) {
        return;
    }

    int cAdaptors = m_arpgadAdaptors.GetSize();
    for (int idx = 0; idx < cAdaptors; idx++) {
        DuVisual * pgad = m_arpgadAdaptors[idx];
        AssertMsg(pgad->m_fAdaptor, "Adaptor must still be marked as an Adaptor");

        
        //
        // Only notify the adaptor of the change if it has not started the
        // destruction process.  We need to actually check this since it will
        // be sent updates during destruction when it is moved into the 
        // Parking Gadget.
        //

        if (!pgad->m_fFinalDestroy) {
            pgad->m_cb.xdFireSyncAdaptor(pgad, nCode);
        }
    }
}


/***************************************************************************\
*
* DuRootGadget::xdSynchronizeAdaptors
*
* xdSynchronizeAdaptors() is called when an Adaptor may have been moved 
* between different Roots and we need to synchronize cached data.
*
\***************************************************************************/

HRESULT
DuRootGadget::xdSynchronizeAdaptors()
{
    AssertMsg(GetCoreSC()->m_cAdaptors > 0, "Only call when have adaptors");

    HRESULT hr = S_OK;

    //
    // Walk through the set of Adaptors and see if their Root's have changed.
    // If they have, remove them from us and add them to their new Root.
    //
    // NOTE: We need to walk the array BACKWARDS since we are removing 
    // adaptors that have moved from one tree to the other.
    //

    int cAdaptors = m_arpgadAdaptors.GetSize();
    for (int idx = cAdaptors - 1; idx >= 0; idx--) {
        DuVisual * pgadAdaptor = m_arpgadAdaptors[idx];
        AssertMsg(pgadAdaptor->m_fAdaptor, "Adaptor must still be marked as an Adaptor");

        DuRootGadget * pgadNewRoot = pgadAdaptor->GetRoot();
        if (pgadNewRoot != this) {
            UnregisterAdaptor(pgadAdaptor);
            if (pgadNewRoot != NULL) {
                HRESULT hrTemp = pgadNewRoot->RegisterAdaptor(pgadAdaptor);
                if (FAILED(hrTemp)) {
                    hr = hrTemp;
                }
            }
        }
    }

    return hr;
}


#if ENABLE_MSGTABLE_API

//------------------------------------------------------------------------------
HRESULT CALLBACK
DuRootGadget::PromoteRoot(DUser::ConstructProc pfnCS, HCLASS hclCur, DUser::Gadget * pgad, DUser::Gadget::ConstructInfo * pciData)
{
    UNREFERENCED_PARAMETER(pfnCS);
    UNREFERENCED_PARAMETER(hclCur);
    UNREFERENCED_PARAMETER(pgad);
    UNREFERENCED_PARAMETER(pciData);

    AssertMsg(0, "Creating a Root is not yet supported");
    
    return E_NOTIMPL;
}


//------------------------------------------------------------------------------
HRESULT
DuRootGadget::ApiGetFocus(Root::GetFocusMsg * pmsg)
{
    BEGIN_API(ContextLock::edNone, GetContext());

    pmsg->pgvFocus = Cast<Visual>(GetFocus());
    retval = S_OK;

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuRootGadget::ApiGetRootInfo(Root::GetRootInfoMsg * pmsg)
{
    BEGIN_API(ContextLock::edNone, GetContext());
    VALIDATE_WRITE_STRUCT(pmsg->pri, ROOT_INFO);
    VALIDATE_FLAGS(pmsg->pri->nMask, GRIM_VALID);

    GetInfo(pmsg->pri);
    retval = S_OK;

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuRootGadget::ApiSetRootInfo(Root::SetRootInfoMsg * pmsg)
{
    BEGIN_API(ContextLock::edDefer, GetContext());
    VALIDATE_READ_STRUCT(pmsg->pri, ROOT_INFO);
    VALIDATE_FLAGS(pmsg->pri->nMask, GRIM_VALID);
    VALIDATE_FLAGS(pmsg->pri->nOptions, GRIO_VALID);
#pragma warning(disable: 4296)
    VALIDATE_RANGE(pmsg->pri->nSurface, GSURFACE_MIN, GSURFACE_MAX);
    VALIDATE_RANGE(pmsg->pri->nDropTarget, GRIDT_MIN, GRIDT_MAX);
#pragma warning(default: 4296)

    retval = SetInfo(pmsg->pri);

    END_API();
}

#endif // ENABLE_MSGTABLE_API
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\rootgadget.h ===
/***************************************************************************\
*
* File: RootGadget.h
*
* Description:
* RootGadget.h defines the top-most node for a Gadget-Tree that interfaces
* to the outside world.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#if !defined(CORE__DuRootGadget_h__INCLUDED)
#define CORE__DuRootGadget_h__INCLUDED
#pragma once

#include "TreeGadget.h"

#define ENABLE_FRAMERATE    0       // Display current frame-rate to debug output

class DuRootGadget : 
#if ENABLE_MSGTABLE_API
        public RootImpl<DuRootGadget, DuVisual>
#else
        public DuVisual
#endif
{
// Construction
public:
    inline  DuRootGadget();
protected:
    virtual ~DuRootGadget();
            HRESULT     Create(DuContainer * pconOwner, BOOL fOwn, CREATE_INFO * pci);
public:
    static  HRESULT     Build(DuContainer * pconOwner, BOOL fOwn, CREATE_INFO * pci, DuRootGadget ** ppgadNew);
protected:
    virtual void        xwDestroy();

// Public API:
public:
#if ENABLE_MSGTABLE_API

    DECLARE_INTERNAL(Root);
    static HRESULT CALLBACK
                        PromoteRoot(DUser::ConstructProc pfnCS, HCLASS hclCur, DUser::Gadget * pgad, DUser::Gadget::ConstructInfo * pciData);

    dapi    HRESULT     ApiGetFocus(Root::GetFocusMsg * pmsg);

    dapi    HRESULT     ApiGetRootInfo(Root::GetRootInfoMsg * pmsg);
    dapi    HRESULT     ApiSetRootInfo(Root::SetRootInfoMsg * pmsg);

#endif

// Operations
public:
#if ENABLE_OPTIMIZEDIRTY
            void        xrDrawTree(DuVisual * pgadStart, HDC hdcDraw, const RECT * prcInvalid, UINT nFlags, BOOL fDirty = FALSE);
#else
            void        xrDrawTree(DuVisual * pgadStart, HDC hdcDraw, const RECT * prcInvalid, UINT nFlags);
#endif
            void        GetInfo(ROOT_INFO * pri) const;
            HRESULT     SetInfo(const ROOT_INFO * pri);

            // Input management
            void        xdHandleMouseLostCapture();
            BOOL        xdHandleMouseMessage(GMSG_MOUSE * pmsg, POINT ptContainerPxl);
    inline  void        xdHandleMouseLeaveMessage();

            BOOL        xdHandleKeyboardMessage(GMSG_KEYBOARD * pmsg, UINT nMsgFlags);
            BOOL        xdHandleKeyboardFocus(UINT nCmd);
    static  DuVisual* GetFocus();
    inline  BOOL        xdSetKeyboardFocus(DuVisual * pgadNew);

            BOOL        xdHandleActivate(UINT nCmd);

            // Cached State management
            void        NotifyDestroy(const DuVisual * pgadDestroy);
            void        xdNotifyChangeInvisible(const DuVisual * pgadChange);
            void        xdNotifyChangePosition(const DuVisual * pgadChange);
            void        xdNotifyChangeRoot(const DuVisual * pgadChange);

            // Adaptors
            HRESULT     RegisterAdaptor(DuVisual * pgadAdd);
            void        UnregisterAdaptor(DuVisual * pgadRemove);
            void        xdUpdateAdaptors(UINT nCode) const;
    inline  BOOL        HasAdaptors() const;
            HRESULT     xdSynchronizeAdaptors();


// Implementation
protected:
            // Input management
            BOOL        CheckCacheChange(const DuVisual * pgadChange, const DuVisual * pgadCache) const;

            BOOL        xdUpdateKeyboardFocus(DuVisual * pgadNew);
            void        xdUpdateMouseFocus(DuVisual ** ppgadNew, POINT * pptClientPxl);
            BOOL        xdProcessGadgetMouseMessage(GMSG_MOUSE * pmsg, DuVisual * pgadMouse, POINT ptClientPxl);

            void        xdFireChangeState(DuVisual ** ppgadLost, DuVisual ** ppgadSet, UINT nCmd);

#if DEBUG_MARKDRAWN
            void        ResetFlagDrawn(DuVisual * pgad);
#endif

// Data
protected:
            DuContainer* m_pconOwner;
            BOOL        m_fOwnContainer:1;  // Destroy container when destroy this gadget
            BOOL        m_fUpdateFocus:1;   // In middle of updating focus
            BOOL        m_fUpdateCapture:1; // In middle of updating the mouse (capture)

#if ENABLE_FRAMERATE
            // Frame rate
            DWORD       m_dwLastTime;
            DWORD       m_cFrames;
            float       m_flFrameRate;
#endif

            // Adaptors
            GArrayF<DuVisual *>
                        m_arpgadAdaptors;   // Collect of adaptors in this tree

            // Root Information
            ROOT_INFO   m_ri;               // Root Information
            DuSurface::EType
                        m_typePalette;      // Surface type for palette
            BOOL        m_fForeground;      // This DuRootGadget is in foreground

    friend DuVisual;
};

#include "RootGadget.inl"

BOOL    GdxrDrawGadgetTree(DuVisual * pgadParent, HDC hdcDraw, const RECT * prcDraw, UINT nFlags);

#endif // CORE__DuRootGadget_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\thread.h ===
/***************************************************************************\
*
* File: Thread.h
*
* Description:
* This file declares the SubThread used by the DirectUser/Core project to
* maintain Thread-specific data.
*
*
* History:
*  4/20/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(CORE__Thread_h__INCLUDED)
#define CORE__Thread_h__INCLUDED
#pragma once

#include "MsgQ.h"

/***************************************************************************\
*****************************************************************************
*
* CoreST contains Thread-specific information used by the Core project
* in DirectUser.  This class is instantiated by the ResourceManager when it
* creates a new Thread object.
*
*****************************************************************************
\***************************************************************************/

class CoreST : public SubThread
{
// Construction
public:
    virtual ~CoreST();
    virtual HRESULT     Create();

// Operations
public:
    inline  HRESULT     DeferMessage(GMSG * pmsg, DuEventGadget * pgadMsg, UINT nFlags);
    inline  void        xwProcessDeferredNL();
    virtual void        xwLeftContextLockNL();

// Implementation
protected:

// Data
protected:
            DelayedMsgQ m_msgqDefer;    // Deferred notifications
};

inline  CoreST *    GetCoreST();
inline  CoreST *    GetCoreST(Thread * pThread);

#include "Thread.inl"

#endif // CORE__Thread_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\thread.inl ===
/***************************************************************************\
*
* File: Thread.inl
*
* History:
*  4/20/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(CORE__Thread_inl__INCLUDED)
#define CORE__Thread_inl__INCLUDED
#pragma once


/***************************************************************************\
*****************************************************************************
*
* class CoreST
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline CoreST *   
GetCoreST()
{
    SubThread * psub = GetThread()->GetST(Thread::slCore);
    return static_cast<CoreST *> (psub);
}


//------------------------------------------------------------------------------
inline CoreST *    
GetCoreST(Thread * pThread)
{
    return static_cast<CoreST *> (pThread->GetST(Thread::slCore));
}


//------------------------------------------------------------------------------
inline HRESULT     
CoreST::DeferMessage(GMSG * pmsg, DuEventGadget * pgadMsg, UINT nFlags)
{
    AssertMsg(m_pParent->GetContext()->IsEnableDefer(), "Deferring must first be enabled");
    
    m_pParent->GetContext()->MarkPending();
    return m_msgqDefer.PostDelayed(pmsg, pgadMsg, nFlags);
}


//------------------------------------------------------------------------------
inline void        
CoreST::xwProcessDeferredNL()
{
    //
    // NOTE: The Context will not necessarily be marked as "EnableDefer" still
    // since this is reset while still _inside_ the ContextLock and the 
    // processing of the messages is done _outside_ the ContextLock.
    //
    
    m_msgqDefer.xwProcessDelayedNL();
}


#endif // CORE__Thread_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\treegadget.cpp ===
/***************************************************************************\
*
* File: TreeGadget.cpp
*
* Description:
* TreeGadget.cpp implements the standard DuVisual-Tree management 
* functions.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/


#include "stdafx.h"
#include "Core.h"
#include "TreeGadget.h"
#include "TreeGadgetP.h"

#include "RootGadget.h"
#include "Container.h"
#include "ParkContainer.h"

#pragma warning(disable: 4296)      // expression is always false


/***************************************************************************\
*****************************************************************************
*
* Global functions
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
Visual *
GetVisual(DuVisual * pdgv)
{
    return static_cast<Visual *> (MsgObject::CastGadget(pdgv));
}


/***************************************************************************\
*****************************************************************************
*
* class DuVisual
*
*****************************************************************************
\***************************************************************************/

CritLock    DuVisual::s_lockProp;
AtomSet     DuVisual::s_ptsProp;
PRID        DuVisual::s_pridXForm         = PRID_Unused;
PRID        DuVisual::s_pridBackFill      = PRID_Unused;
PRID        DuVisual::s_pridBufferInfo    = PRID_Unused;
PRID        DuVisual::s_pridTicket        = PRID_Unused;

#if DBG
DuVisual* DuVisual::s_DEBUG_pgadOutline = NULL;
#endif // DBG


/***************************************************************************\
*
* DuVisual::DuVisual
*
* DuVisual() cleans up resources associated with the given DuVisual,
* including all children, attached items, and associated handles.
*
* NOTE: Because of C++ destructors being called from most-derived to 
* base-class, the Gadget has already started destruction and may be in a
* semi-stable state.  Therefore, it is VERY IMPORTANT that the destructor
* is never directly called and that the xwDestroy() function is called 
* instead.
*
\***************************************************************************/

DuVisual::~DuVisual()
{
    //
    // NOTE: No callbacks are allowed on this object past this point.  We have
    // already destroyed the GPCB.
    //

    AssertMsg(m_fFinalDestroy, "Must call xwBeginDestroy() to begin the destruction process");
    AssertMsg(!m_fDestroyed, "Only can be destroyed once");
    m_fDestroyed = TRUE;

    //
    // Notify the root that this Gadget is being destroyed so that it can 
    // update cached information
    //

    DuRootGadget * pgadRoot = GetRoot();
    if (pgadRoot != NULL) {
        pgadRoot->NotifyDestroy(this);
    }

#if DBG
    if (s_DEBUG_pgadOutline == this) {
        s_DEBUG_pgadOutline = NULL;
    }
#endif // DBG


    //
    // After notifying all event handlers that this DuVisual is being 
    // destroyed, extract this DuVisual from the graph.
    //

    CleanupMessageHandlers();


    //
    // Unlink out of the tree
    //

    Unlink();


    //
    // Cleanup resources
    //

    VerifyHR(SetEnableXForm(FALSE));
    VerifyHR(SetFill((HBRUSH) NULL));
    VerifyHR(SetBuffered(FALSE));
    ClearTicket();


#if DBG_STORE_NAMES

    if (m_DEBUG_pszName != NULL) {
        free(m_DEBUG_pszName);
    }

    if (m_DEBUG_pszType != NULL) {
        free(m_DEBUG_pszType);
    }
    
#endif // DBG_STORE_NAMES
}


static const GUID GUID_XForm        = { 0x9451c768, 0x401d, 0x4bc1, { 0xa6, 0xbb, 0xaf, 0x7c, 0x52, 0x29, 0xad, 0x24 } }; // {9451C768-401D-4bc1-A6BB-AF7C5229AD24}
static const GUID GUID_Background   = { 0x4bab7597, 0x6aaf, 0x42ee, { 0xb1, 0x87, 0xcf, 0x7, 0x7e, 0xb7, 0xff, 0xb8 } };  // {4BAB7597-6AAF-42ee-B187-CF077EB7FFB8}
static const GUID GUID_BufferInfo   = { 0x2aeffe25, 0x1d8, 0x4992, { 0x8e, 0x29, 0xa6, 0xd7, 0xf9, 0x2e, 0x23, 0xd1 } };  // {2AEFFE25-01D8-4992-8E29-A6D7F92E23D1}
static const GUID GUID_Ticket       = { 0x5a8fa581, 0x2df4, 0x44c9, { 0x8e, 0x1a, 0xaa, 0xa7, 0x00, 0xbb, 0xda, 0xb7 } }; // {5A8FA581-2DF4-44C9-8E1A-AAA700BBDAB7}

/***************************************************************************\
*
* DuVisual::InitClass
*
* InitClass() is called during startup and provides an opportunity to 
* initialize common Gadget data, including properties.
*
\***************************************************************************/

HRESULT
DuVisual::InitClass()
{
    HRESULT hr;

    if (FAILED(hr = s_ptsProp.AddRefAtom(&GUID_XForm, ptPrivate, &s_pridXForm)) ||
        FAILED(hr = s_ptsProp.AddRefAtom(&GUID_Background, ptPrivate, &s_pridBackFill)) ||
        FAILED(hr = s_ptsProp.AddRefAtom(&GUID_BufferInfo, ptPrivate, &s_pridBufferInfo)) ||
        FAILED(hr = s_ptsProp.AddRefAtom(&GUID_Ticket, ptPrivate, &s_pridTicket))) {

        return hr;
    }

    return S_OK;
}


/***************************************************************************\
*
* DuVisual::Build
*
* Build() creates and fully initializes a new DuVisual.
*
\***************************************************************************/

HRESULT
DuVisual::Build(
    IN  DuVisual * pgadParent,          // Optional parent
    IN  CREATE_INFO * pci,              // Creation information
    OUT DuVisual ** ppgadNew,           // New Gadget
    IN  BOOL fDirect)                   // DuVisual is being created as a Visual
{
    //
    // Check parameters
    //

    Context * pctx;
    if (pgadParent != NULL) {
        if (pgadParent->m_fAdaptor) {
            PromptInvalid("Adaptors can not be parents");
            return E_INVALIDARG;
        }

        pctx = pgadParent->GetContext();
    } else {
        pctx = ::GetContext();
    }


    DuVisual * pgadNew = GetCoreSC(pctx)->ppoolDuVisualCache->New();
    if (pgadNew == NULL) {
        return E_OUTOFMEMORY;
    }


    pgadNew->m_fInvalidFull     = TRUE;
#if ENABLE_OPTIMIZEDIRTY
    pgadNew->m_fInvalidDirty    = TRUE;
#endif

    HRESULT hr = pgadNew->CommonCreate(pci, fDirect);
    if (FAILED(hr)) {
        pgadNew->xwDestroy();
        return hr;
    }

    //
    // Perform special optimizations if there is not actual callback.  These
    // let us do better performance when the caller is simply creating a DuVisual
    // to be a container.
    //

    if (pci->pfnProc == NULL) {
        //
        // Set directly b/c don't want callback from xdSetStyle().
        //

        pgadNew->m_fZeroOrigin  = FALSE;
        pgadNew->m_fDeepTrivial = TRUE;
    }

    
    //
    // Setup the parent
    //

    if (pgadParent != NULL) {
        //
        // If our new parent is not relative, we must automatically also not
        // be relative.
        //

        if (!pgadParent->m_fRelative) {
            pgadNew->m_fRelative = FALSE;
        }

        //
        // Add the new node to the parent.
        //
        // NOTE: If the Gadget is marked as an Adaptor, it wasn't added to the 
        // cached list of adaptors when we set the style.  Therefore, we need 
        // to add it now.
        //

        pgadNew->Link(pgadParent);
        pgadNew->MarkInvalidChildren();

        if (pgadNew->m_fAdaptor) {
            DuRootGadget * pgadRoot = pgadNew->GetRoot();
            AssertMsg(pgadRoot != NULL, "Must have a root when initially created");
            hr = pgadRoot->RegisterAdaptor(pgadNew);
            if (FAILED(hr)) {
                pgadNew->xwDestroy();
                return hr;
            }
        }
    }

    *ppgadNew = pgadNew;
    return hr;
}


/***************************************************************************\
*
* DuVisual::CommonCreate
*
* CommonCreate() provides common creation across all DuVisual's.  This 
* function should be called in the Build() function for the derived 
* DuVisual.
*
\***************************************************************************/

HRESULT
DuVisual::CommonCreate(
    IN  CREATE_INFO * pci,          // Creation information
    IN  BOOL fDirect)               // DuVisual is being created as a Visual
{
    if (!fDirect) {
#if ENABLE_MSGTABLE_API
        if (!SetupInternal(s_mc.hclNew)) {
            return E_OUTOFMEMORY;
        }
#endif
    }

#if DBG
    m_cb.Create(pci->pfnProc, pci->pvData, GetHandle());
#else // DBG
    m_cb.Create(pci->pfnProc, pci->pvData);
#endif // DBG

    return S_OK;
}



#if DBG

/***************************************************************************\
*
* DuVisual::DEBUG_IsZeroLockCountValid
*
* DuVisuals allow a zero lock count during the destruction of a Gadget.
*
\***************************************************************************/

BOOL
DuVisual::DEBUG_IsZeroLockCountValid() const
{
    return m_fFinalDestroy;
}

#endif // DBG


/***************************************************************************\
*
* DuVisual::xwDeleteHandle
*
* xwDeleteHandle() is called when the application calls ::DeleteHandle() on 
* an object.
*
* NOTE: Gadgets are slightly different than other objects with callbacks in
* that their lifetime does NOT end when the application calls 
* ::DeleteHandle().  Instead, the object and its callback are completely
* valid until the GM_DESTROY message has been successfully sent.  This is 
* because a Gadget should receive any outstanding messages in both the 
* normal and delayed message queues before being destroyed.
*
\***************************************************************************/

BOOL
DuVisual::xwDeleteHandle()
{
    //
    // Don't allow deleting a handle that has already started to be destroyed.
    // If this happens, it is an application error.
    //

    if (m_fFinalDestroy) {
        PromptInvalid("Can not call DeleteHandle() on a Gadget that has already started final destruction");
        return FALSE;
    }


    m_cb.xwFireDestroy(this, GDESTROY_START);

    //
    // When an application explicitely calls ::DeleteHandle(), immediately 
    // hide and disable the Gadget.  The Gadget may be locked if there are
    // queued messages for it, but it will no longer be visible.
    //

    if (m_fVisible) {
        //
        // TODO: Need to invalidate the parent (and not this Gadget) when we
        // hide it.
        //

        Invalidate();
        m_fVisible  = FALSE;
    }
    m_fEnabled  = FALSE;

    DuRootGadget * pgadRoot = GetRoot();
    if (pgadRoot != NULL) {
        pgadRoot->xdNotifyChangeInvisible(this);
    }

    return DuEventGadget::xwDeleteHandle();
}


/***************************************************************************\
*
* DuVisual::IsStartDelete
*
* IsStartDelete() is called to query an object if it has started its
* destruction process.  Most objects will just immediately be destroyed.  If
* an object has complicated destruction where it overrides xwDestroy(), it
* should also provide IsStartDelete() to let the application know the state
* of the object.
*
\***************************************************************************/

BOOL
DuVisual::IsStartDelete() const
{
    return m_fFinalDestroy;
}


/***************************************************************************\
*
* DuVisual::xwDestroy
*
* xwDestroy() is called from xwDeleteHandle() to destroy a Gadget and free 
* its associated resources.
*
\***************************************************************************/

void
DuVisual::xwDestroy()
{
    //
    // Don't allow deleting a handle that has already started to be destroyed.
    // If this happens, it may be legitimate if we are locking and unlocking
    // a parent who is also being destroyed.
    //

    if (m_fFinalDestroy) {
        return;
    }


    //
    // Derived classes should ensure that DuVisual::xwBeginDestroy() 
    // is called.
    //

    CoreSC * pCoreSC = GetCoreSC(m_pContext);

    xwBeginDestroy();
    xwEndDestroy();

    pCoreSC->ppoolDuVisualCache->Delete(this);
}


/***************************************************************************\
*
* DuVisual::xwBeginDestroy
*
* xwBeginDestroy() starts the destruction process for a given Gadget to free 
* its associated resources.  This includes destroying all child Gadgets in
* the subtree before this Gadget is destroyed.
*
* xwBeginDestroy() is given an opportunity to clean up resources BEFORE the 
* destructors start tearing down the classes.  This is important especially
* for callbacks because the Gadgets will be partially uninitialized in the
* destructors and could have bad side-effects from other API calls during 
* the callbacks.
*
\***************************************************************************/

void        
DuVisual::xwBeginDestroy()
{
    //
    // Make invisible while destroying
    //

    m_fFinalDestroy = TRUE;
    m_fVisible      = FALSE;
    m_fEnabled      = FALSE;

    DuRootGadget * pgadRoot = GetRoot();
    if (pgadRoot != NULL) {
        pgadRoot->xdNotifyChangeInvisible(this);
    }


    //
    // Send destroy notifications.  This needs to be done in a bottom-up 
    // order to ensure that the root DuVisual does not keep any handles 
    // to a DuVisual being destroyed.
    //
    // We also need to remove ourself from the list of Adaptors that the
    // Root is maintaining since we are going away.
    //

    xwDestroyAllChildren();
    if (m_fAdaptor) {
        AssertMsg(pgadRoot == GetRoot(), 
                "Should not be able to reparent once start destruction");

        if (pgadRoot != NULL) {
            pgadRoot->UnregisterAdaptor(this);
        }
        m_fAdaptor = FALSE;
    }

    m_cb.xwFireDestroy(this, GDESTROY_FINAL);


    //
    // At this point, the children have been cleaned up and the Gadget has
    // received its last callback.  From this point on, anything can be done,
    // but it is important to not callback.
    //

    m_cb.Destroy();
}


/***************************************************************************\
*
* DuVisual::GetGadget
*
* GetGadget() returns the specified Gadget in the specified relationship.
*
\***************************************************************************/

DuVisual *
DuVisual::GetGadget(
    IN  UINT nCmd                   // Relationship
    ) const
{
    switch (nCmd)
    {
    case GG_PARENT:
        return GetParent();
    case GG_NEXT:
        return GetNext();
    case GG_PREV:
        return GetPrev();
    case GG_TOPCHILD:
        return GetTopChild();
    case GG_BOTTOMCHILD:
        return GetBottomChild();
    case GG_ROOT:
        return GetRoot();
    default:
        return NULL;
    }
}


/***************************************************************************\
*
* DuVisual::xdSetStyle
*
* xdSetStyle() changes the style of the given Gadget.
*
\***************************************************************************/

HRESULT
DuVisual::xdSetStyle(
    IN  UINT nNewStyle,             // New style of Gadget
    IN  UINT nMask,                 // Mask of what to change
    IN  BOOL fNotify)               // Notify the Gadget of changes
{
    //
    // Determine actual new style
    //

    AssertMsg((nNewStyle & GS_VALID) == nNewStyle, "Must set valid style");
    nNewStyle = (nNewStyle & nMask);
    UINT nOldStyle  = m_nStyle & GS_VALID;

    if (nNewStyle == nOldStyle) {
        return S_OK;
    }


    //
    // If have started destruction, only allowed to set / clear certain bits.
    //

    if (m_fFinalDestroy && ((nNewStyle & GS_VISIBLE) != 0)) {
        PromptInvalid("Not allowed to change this style after starting destruction");
        return E_INVALIDARG;
    }


    //
    // FIRST: Validate that the new style is valid.  If it is not, want to fail
    // out here.  Once we start changing, it could get pretty bad if we need to
    // bail in the middle.  We can't catch everything, but we this cuts down
    // on a lot of the problem.
    //

    //
    // Check if need to change from relative to absolute coordinates / etc.
    //
    bool fRelative = TestFlag(nNewStyle, GS_RELATIVE);

    if (TestFlag(nMask, GS_RELATIVE) && ((!m_fRelative) == fRelative)) {
        //
        // Want to change if using relative coordinates.  We can only do this
        // if we don't have any children.  We also can not become non-relative
        // if our parent is relative.
        //

        if (GetTopChild() != NULL) {
            return E_INVALIDARG;
        }

        if ((GetParent() != NULL) && (GetParent()->m_fRelative) && (!fRelative)) {
            return E_INVALIDARG;
        }
    }

    if (TestFlag(nMask, GS_MOUSEFOCUS)) {
        if (IsRoot()) {
            return E_INVALIDARG;
        }
    }


    if (TestFlag(nMask, GS_ADAPTOR)) {
        if (GetParent() != NULL) {
            DuRootGadget * pgadRoot = GetRoot();
            if ((pgadRoot == NULL) || HasChildren()) {
                //
                // Already created, but not part of the tree, so in destruction.
                // We can't become an adaptor now.
                //

                return E_INVALIDARG;
            }
        }
    }


    //
    // SECOND: Everything appears valid, so start making changes.  If something
    // goes wrong, flag a failure.
    //

    HRESULT hr = S_OK;

    if (TestFlag(nMask, GS_RELATIVE) && ((!m_fRelative) == fRelative)) {
        m_fRelative = fRelative;
    }

    if (TestFlag(nMask, GS_KEYBOARDFOCUS)) {
        m_fKeyboardFocus = TestFlag(nNewStyle, GS_KEYBOARDFOCUS);
    }

    if (TestFlag(nMask, GS_MOUSEFOCUS)) {
        AssertMsg(!IsRoot(), "Must not be a DuRootGadget"); 
        m_fMouseFocus = TestFlag(nNewStyle, GS_MOUSEFOCUS);
    }

    if (TestFlag(nMask, GS_VISIBLE)) {
        bool fVisible = TestFlag(nNewStyle, GS_VISIBLE);

        if (GetParent() != NULL) {
            if ((!fVisible) != (!IsVisible())) {
                /*
                 * Invalidate() both before and after the call since if the visibility
                 * is changing, only one of these calls will actually invalidate.
                 */

                if (m_fVisible) {
                    Invalidate();
                }

                m_fVisible = TestFlag(nNewStyle, GS_VISIBLE);

                if (m_fVisible) {
                    Invalidate();
                } else {
                    DuRootGadget * pgadRoot = GetRoot();
                    if (pgadRoot != NULL) {
                        pgadRoot->xdNotifyChangeInvisible(this);
                    }
                }
            }
        } else {
            m_fVisible = TestFlag(nNewStyle, GS_VISIBLE);
        }
    }

    if (TestFlag(nMask, GS_ENABLED)) {
        m_fEnabled = TestFlag(nNewStyle, GS_ENABLED);
    }

    if (TestFlag(nMask, GS_CLIPINSIDE)) {
        m_fClipInside = TestFlag(nNewStyle, GS_CLIPINSIDE);
    }

    if (TestFlag(nMask, GS_CLIPSIBLINGS)) {
        m_fClipSiblings = TestFlag(nNewStyle, GS_CLIPSIBLINGS);
    }

    if (TestFlag(nMask, GS_ZEROORIGIN)) {
        m_fZeroOrigin = TestFlag(nNewStyle, GS_ZEROORIGIN);
    }

    if (TestFlag(nMask, GS_HREDRAW)) {
        m_fHRedraw = TestFlag(nNewStyle, GS_HREDRAW);
    }

    if (TestFlag(nMask, GS_VREDRAW)) {
        m_fVRedraw = TestFlag(nNewStyle, GS_VREDRAW);
    }

    if (TestFlag(nMask, GS_CUSTOMHITTEST)) {
        m_fCustomHitTest = TestFlag(nNewStyle, GS_CUSTOMHITTEST);
    }

    if (TestFlag(nMask, GS_ADAPTOR)) {
        if (GetParent() != NULL) {
            //
            // Actually linked into the tree, so need to update the cached list
            // of adaptors for this tree.
            //

            DuRootGadget * pgadRoot = GetRoot();
            AssertMsg(pgadRoot != NULL, "Should have validated earlier that has Root");

            BOOL fOldAdaptor = m_fAdaptor;
            BOOL fNewAdaptor = TestFlag(nNewStyle, GS_ADAPTOR);
            if ((!m_fAdaptor) != (!fNewAdaptor)) {
                if (fNewAdaptor) {
                    m_fAdaptor = fNewAdaptor;
                    HRESULT hrTemp = pgadRoot->RegisterAdaptor(this);
                    if (FAILED(hrTemp)) {
                        hr = hrTemp;
                        m_fAdaptor = fOldAdaptor;
                    }
                } else {
                    pgadRoot->UnregisterAdaptor(this);
                    m_fAdaptor = fNewAdaptor;
                }
            }
        } else {
            //
            // Not yet part of the tree, so we can only mark this Gadget as an
            // adaptor for now.  When we call xdSetParent(), we will need to
            // add it into the cached list of adaptors then.
            //
            
            m_fAdaptor = TestFlag(nNewStyle, GS_ADAPTOR);
        }
    }


    //
    // Currently, both buffering and caching need the Gadget to be opaque.  
    // Since changing styles may fail, it may be necessary to call SetStyle
    // multiple times to successfully change the style.
    //
    
    if (TestFlag(nMask, GS_OPAQUE)) {
        BOOL fNewOpaque = TestFlag(nNewStyle, GS_OPAQUE);
        if ((!fNewOpaque) && (m_fBuffered || m_fCached)) {
            hr = E_NOTIMPL;
            goto Exit;
        }

        m_fOpaque = fNewOpaque;
    }

    if (TestFlag(nMask, GS_BUFFERED)) {
        BOOL fNewBuffered = TestFlag(nNewStyle, GS_BUFFERED);
        if (fNewBuffered && (!m_fOpaque)) {
            hr = E_NOTIMPL;
            goto Exit;
        }
        HRESULT hrTemp = SetBuffered(fNewBuffered);
        if (FAILED(hrTemp)) {
            hr = hrTemp;
        }
    }

    if (TestFlag(nMask, GS_CACHED)) {
        BOOL fNewCached = TestFlag(nNewStyle, GS_CACHED);
        if (fNewCached && (!m_fOpaque)) {
            hr = E_NOTIMPL;
            goto Exit;
        }

        m_fCached = fNewCached;
    }

    if (TestFlag(nMask, GS_DEEPPAINTSTATE)) {
        m_fDeepPaintState = TestFlag(nNewStyle, GS_DEEPPAINTSTATE);
    }


    //
    // Update the deep state if any relavant flags were affected
    //

    if (TestFlag(nMask, GS_MOUSEFOCUS)) {
        UpdateWantMouseFocus(uhNone);
    }
    
    if (TestFlag(nMask, GS_CLIPSIBLINGS | GS_ZEROORIGIN | GS_BUFFERED | GS_CACHED)) {
        UpdateTrivial(uhNone);
    }
    

    //
    // Notify the Gadget that its style was changed.
    //

    if (fNotify) {
        UINT nTempStyle = m_nStyle & GS_VALID;
        if (nTempStyle != nOldStyle) {
            m_cb.xdFireChangeStyle(this, nOldStyle, nTempStyle);
        }

        xdUpdateAdaptors(GSYNC_STYLE);
    }

Exit:
    return hr;
}


/***************************************************************************\
*
* DuVisual::SetFill
*
* SetFill() sets the optional background fill of the Gadget.
*
\***************************************************************************/

HRESULT
DuVisual::SetFill(
    IN  HBRUSH hbrFill,             // Brush to use
    IN  BYTE bAlpha,                // Alpha degree
    IN  int w,                      // Tiling width
    IN  int h)                      // Tiling height
{
    if (hbrFill == NULL) {
        //
        // Remove any existing fill
        //

        if (m_fBackFill) {
            m_pds.RemoveData(s_pridBackFill, TRUE);
            m_fBackFill = FALSE;
        }
    } else {
        //
        // Add a new fill
        //

        FillInfo * pfi;
        HRESULT hr = m_pds.SetData(s_pridBackFill, sizeof(FillInfo), (void **) &pfi);
        if (FAILED(hr)) {
            return hr;
        }

        //
        // Don't call DeleteObject() on hbrFill because this form does not own it.
        // (It may be a shared resource or a system brush)
        //

        m_fBackFill         = TRUE;

        pfi->type           = DuSurface::stDC;
        pfi->hbrFill        = hbrFill;
        pfi->sizeBrush.cx   = w;
        pfi->sizeBrush.cy   = h;
        pfi->bAlpha         = bAlpha;
    }

    return S_OK;
}

/***************************************************************************\
*
* DuVisual::SetFill
*
* SetFill() sets the optional background fill of the Gadget.
*
\***************************************************************************/

HRESULT
DuVisual::SetFill(
    Gdiplus::Brush * pgpbr)         // Brush to use
{
    if (pgpbr == NULL) {
        //
        // Remove any existing fill
        //

        if (m_fBackFill) {
            m_pds.RemoveData(s_pridBackFill, TRUE);
            m_fBackFill = FALSE;
        }
    } else {
        //
        // Add a new fill
        //

        FillInfo * pfi;
        HRESULT hr = m_pds.SetData(s_pridBackFill, sizeof(FillInfo), (void **) &pfi);
        if (FAILED(hr)) {
            return hr;
        }

        //
        // Don't call DeleteObject() on hbrFill because this form does not own it.
        // (It may be a shared resource or a system brush)
        //

        m_fBackFill         = TRUE;

        pfi->type           = DuSurface::stGdiPlus;
        pfi->pgpbr          = pgpbr;
    }

    return S_OK;
}


/***************************************************************************\
*
* DuVisual::xwDestroyAllChildren
*
* xwDestroyAllChildren() is called during a Gadget's destruction to 
* recursively xwDestroy() all children. 
*
* NOTE: This is an "xw" function, so we need to be VERY careful how we 
* enumerate our children.  Since new children could potentially be added to 
* us during the callback, we need to continue enumerating as long as we have 
* children.
*
\***************************************************************************/

void
DuVisual::xwDestroyAllChildren()
{
    //
    // DuVisual can have a list of children, so go through and destroy each of
    // those children.  
    //
    // Before each child is unlocked(), it needs to be unlinked from the 
    // tree to prevent it from further accessing its siblings or its parent 
    // which may be destroyed.  This can happen if the Gadget is has 
    // outstanding locks, for example in a MsgQ.
    //
    // NOTE: We can't just unlink the node into oblivion since it MUST still 
    // have a valid Root.  Instead, move it into the Parking Gadget.  This
    // somewhat stinks if we are going to just go away, but we can't risk 
    // leaving the Gadget floating nowhere.
    //

    while (HasChildren()) {
        DuVisual * pgadChild = GetTopChild();

        {
            ObjectLock ol(pgadChild);
            pgadChild->m_cb.xwFireDestroy(pgadChild, GDESTROY_START);
            pgadChild->xdSetParent(NULL, NULL, GORDER_ANY);
            pgadChild->xwUnlock();
        }
    }
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::xwEnumGadgets(GADGETENUMPROC pfnProc, void * pvData, UINT nFlags)
{
    if (TestFlag(nFlags, GENUM_MODIFYTREE)) {
        // Currently not implemented
        return E_NOTIMPL;
    }

    //
    // Enumerate this node
    //

    if (TestFlag(nFlags, GENUM_CURRENT)) {
        if (!(pfnProc)(GetHandle(), pvData)) {
            return DU_S_STOPPEDENUMERATION;
        }
    }

    //
    // Enumerate children
    //

    HRESULT hr;
    if (TestFlag(nFlags, GENUM_SHALLOWCHILD | GENUM_DEEPCHILD)) {
        UINT nCurFlags = nFlags;
        SetFlag(nCurFlags, GENUM_CURRENT);
        ClearFlag(nCurFlags, GENUM_SHALLOWCHILD);

        DuVisual * pgadCur = GetTopChild();
        while (pgadCur != NULL) {
            DuVisual * pgadNext = pgadCur->GetNext();

            hr = pgadCur->xwEnumGadgets(pfnProc, pvData, nCurFlags);
            if (hr != S_OK) {
                return hr;
            }

            pgadCur = pgadNext;
        }
    }

    return S_OK;
}


/***************************************************************************\
*
* DuVisual::AddChild
*
* AddChild() creates a new child Gadget.
*
\***************************************************************************/

HRESULT
DuVisual::AddChild(
    IN  CREATE_INFO * pci,          // Creation information
    OUT DuVisual ** ppgadNew)     // New child
{
    if (m_fFinalDestroy) {
        PromptInvalid("Can not add a Gadget to one that has started destruction");
        return DU_E_STARTDESTROY;
    }

    return DuVisual::Build(this, pci, ppgadNew, FALSE);
}


/***************************************************************************\
*
* DuVisual::IsDescendent
*
* IsDescendent() determines if a specified node is a descendent of this node.
*
\***************************************************************************/

BOOL
DuVisual::IsDescendent(
    IN  const DuVisual * pgadChild
    ) const
{
    AssertMsg(pgadChild != NULL, "Must have valid node");

    //
    // Walk up the tree, checking each parent to see if it matches.
    //

    const DuVisual * pgadCur = pgadChild;
    do {
        if (pgadCur == this) {
            return TRUE;
        }
        pgadCur = pgadCur->GetParent();
    } while (pgadCur != NULL);

    return FALSE;
}


/***************************************************************************\
*
* DuVisual::IsSibling
*
* IsSibling() determines if two specified nodes share a common (immediate)
* parent.
*
\***************************************************************************/

BOOL
DuVisual::IsSibling(const DuVisual * pgad) const
{
    AssertMsg(pgad != NULL, "Must have valid node");

    DuVisual * pgadParentA = GetParent();
    DuVisual * pgadParentB = pgad->GetParent();

    if ((pgadParentA == NULL) || (pgadParentA != pgadParentB)) {
        return FALSE;
    }

    return TRUE;
}


/***************************************************************************\
*
* DuVisual::xdSetParent
*
* xdSetParent() changes the Gadget's parent and z-order inside the sub-tree.
*
\***************************************************************************/

HRESULT
DuVisual::xdSetParent(
    IN  DuVisual * pgadNewParent, // New parent
    IN  DuVisual * pgadOther,     // Gadget to moved relative to
    IN  UINT nCmd)                  // Relationship
{
    HRESULT hr = S_OK;
    DuVisual * pgadOldParent;
    DuVisual * pgadPark;

    pgadOldParent = GetParent();

    //
    // Check parameters- see if we even need to move
    //

    AssertMsg(!IsRoot(), "Can not change a DuRootGadget's parent");


    pgadPark = GetCoreSC()->pconPark->GetRoot();
    if ((pgadNewParent == NULL) || (pgadNewParent == pgadPark)) {
        pgadNewParent = pgadPark;

        if (pgadNewParent->m_fFinalDestroy) {
            //
            // The Parking Gadget has already started to be destroyed, so
            // we can't be reparented into it.
            //

            pgadNewParent = NULL;
        }
    }

    if ((nCmd == GORDER_ANY) && (pgadOldParent == pgadNewParent)) {
        return S_OK;
    }

    if (m_fFinalDestroy || 
            ((pgadNewParent != NULL) && pgadNewParent->m_fFinalDestroy)) {
        //
        // We have started to be destroyed, so we can't change our parent to
        // avoid destruction.  We also can be reparented to a Gadget that has
        // started destruction because we may not be properly destroyed.
        //

        PromptInvalid("Can not move a Gadget that has started destruction");
        return DU_E_STARTDESTROY;
    }

    if ((pgadNewParent != NULL) && (pgadNewParent->GetContext() != GetContext())) {
        //
        // Illegally trying to move the Gadget between Contexts.
        //

        PromptInvalid("Can not move a Gadget between Contexts");
        return E_INVALIDARG;
    }


    AssertMsg(GORDER_TOP == (int) TreeNode::ltTop, "Ensure enum's match");

    if ((pgadNewParent != NULL) && (pgadNewParent->m_fAdaptor)) {
        PromptInvalid("Adaptors can not be parents");
        return E_INVALIDARG;
    }


    //
    // When actually moving from one parent to another or changing sibling 
    // z-order, need to hide the Gadget while moving and invalidate the before
    // and after locations.  If the parent has changed, we also need to notify 
    // the DuRootGadget because the tree has changed around.
    //
    // NOTE: It may actually not be that important to notify the Root at all-
    // still need to determine the impact on dragging from changing the parent.
    //

    BOOL fVisible = m_fVisible;

    if (fVisible) {
        //
        // TODO: Need to fix how we mark the Gadget as not visible so that 
        // we properly invalidate the PARENT.
        //

        Invalidate();
        m_fVisible = FALSE;

        if (pgadNewParent != pgadOldParent) {
            GetRoot()->xdNotifyChangeInvisible(this);
        }
    }

    AssertMsg((pgadNewParent == NULL) || 
            ((!m_fRelative) == (!pgadNewParent->m_fRelative)),
            "If not a Root, relative setting for us and our parent must match");

    //
    // If reparenting across DuRootGadget's, need to notify the old 
    // DuRootGadget so that it can update its state.  Need to do this BEFORE
    // we move.
    //

    DuRootGadget * pgadOldRoot = pgadOldParent != NULL ? pgadOldParent->GetRoot() : NULL;
    DuRootGadget * pgadNewRoot = pgadNewParent != NULL ? pgadNewParent->GetRoot() : NULL;

    if (pgadOldRoot != pgadNewRoot) {
        pgadOldRoot->xdNotifyChangeRoot(this);
    }


    //
    // If moving forward or backward, determine the actual sibling and change 
    // the command into a TreeNode::ELinkType
    //

    switch (nCmd)
    {
    case GORDER_FORWARD:
        pgadOther   = GetPrev();
        if (pgadOther == NULL) {
            nCmd    = GORDER_TOP;
        } else {
            nCmd    = GORDER_BEFORE;
        }
        break;

    case GORDER_BACKWARD:
        pgadOther   = GetNext();
        if (pgadOther == NULL) {
            nCmd    = GORDER_BOTTOM;
        } else {
            nCmd    = GORDER_BEHIND;
        }
        break;
    }


    //
    // Move from the old Parent to the new Parent.
    //

    Unlink();
    if (pgadNewParent != NULL) {
        Link(pgadNewParent, pgadOther, (TreeNode::ELinkType) nCmd);
    }

    if (fVisible) {
        m_fVisible = fVisible;
        Invalidate();
    }


    if (pgadNewParent != NULL) {
        if (pgadNewParent != pgadOldParent) {
            //
            // Synchronize (newly inherited) invalidation state.
            //

#if ENABLE_OPTIMIZEDIRTY
            if (m_fInvalidFull || m_fInvalidDirty) {
#else
            if (m_fInvalidFull) {
#endif
                pgadNewParent->MarkInvalidChildren();
            }


            //
            // Update cached Adaptor information.  If we are moving an Adaptor, we
            // may need to notify the Roots.  Even if we are not moving an Adaptor,
            // if there are ANY Adaptors, they may need to recompute visrgn's, etc 
            // so they need to be notified.
            //
            // NOTE: We may end up moving an Adaptor by moving its parent, so we 
            // can't only just check the m_fAdaptor field.  We also need to check 
            // if the old DuRootGadget has any Adaptors and if so synchronize all of
            // them.  We also need to check the m_fAdaptor field because if the 
            // Gadget wasn't linked into a tree, it won't show up in the cached list
            // of adaptors.
            //

            hr = S_OK;
            if ((pgadOldParent == NULL) && m_fAdaptor) {
                //
                // The Gadget didn't have a parent, so it wasn't added to the cached
                // list of adaptors.  We need to add it now.
                //

                AssertMsg(pgadNewParent != NULL, "Must have a valid new parent");
                AssertMsg(GetRoot() == pgadNewParent->GetRoot(), "Roots should match");
                hr = GetRoot()->RegisterAdaptor(this);
            } else if (GetCoreSC()->m_cAdaptors > 0) {
                DuRootGadget * pgadOldRoot = pgadOldParent->GetRoot();
                if (pgadOldRoot->HasAdaptors()) {
                    hr = pgadOldRoot->xdSynchronizeAdaptors();
                }
            }

            if (FAILED(hr)) {
                //
                // This is really bad.  We are not able to add this adaptor to 
                // its new root.  There is not much that we can do because 
                // moving it back is just as likely to fail.  All that we can
                // do is report the failure.
                //
            }
        }

        xdUpdatePosition();
        xdUpdateAdaptors(GSYNC_PARENT);
    }

    return hr;
}


/***************************************************************************\
*
* DuVisual::SetFilter
*
* SetFilter() changes the message filter of the Gadget.
*
\***************************************************************************/

void        
DuVisual::SetFilter(
    IN  UINT nNewFilter,            // New message filter
    IN  UINT nMask)                 // Mask to change
{
    // TEMPORARY HACK TO ALLOW MOUSEMOVE's
    //
    // TODO: Need to traverse tree, rolling up and recomputing m_we.

    if (TestFlag(nMask, GMFI_INPUTMOUSEMOVE)) {
        if (TestFlag(nNewFilter, GMFI_INPUTMOUSEMOVE)) {
            m_we |= weMouseMove | weDeepMouseMove;
        } else {
            m_we &= ~(weMouseMove | weDeepMouseMove);
        }
    }

    DuEventGadget::SetFilter(nNewFilter, nMask);
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::RegisterPropertyNL(const GUID * pguid, PropType pt, PRID * pprid)
{
    s_lockProp.Enter();
    HRESULT hr = s_ptsProp.AddRefAtom(pguid, pt, pprid);
    s_lockProp.Leave();

    return hr;
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::UnregisterPropertyNL(const GUID * pguid, PropType pt)
{
    s_lockProp.Enter();
    HRESULT hr = s_ptsProp.ReleaseAtom(pguid, pt);
    s_lockProp.Leave();

    return hr;
}


/***************************************************************************\
*
* DuVisual::xdUpdatePosition
*
* xdUpdatePosition() is called when something occurs that changes the 
* position of a Gadget.  When this happens, the Root needs to be notified so 
* that it can update cached information like mouse focus.
*
\***************************************************************************/

void        
DuVisual::xdUpdatePosition() const
{
    //
    // Only need to update the position if we are completely visible.
    //

    const DuVisual * pgadCur = this;
    const DuVisual * pgadParent;
    while (1) {
        if (!pgadCur->m_fVisible) {
            return;
        }

        pgadParent = pgadCur->GetParent();
        if (pgadParent == NULL) {
            AssertMsg(pgadCur->m_fRoot, "Top must be a DuRootGadget");
            DuRootGadget * pgadRoot = (DuRootGadget *) pgadCur;
            pgadRoot->xdNotifyChangePosition(this);
            return;
        }

        pgadCur = pgadParent;
    }
}


//------------------------------------------------------------------------------
void
DuVisual::xdUpdateAdaptors(UINT nCode) const
{
    if (GetCoreSC()->m_cAdaptors == 0) {
        return;  // No adaptors to notify
    }

    DuRootGadget * pgadRoot = GetRoot();
    if (pgadRoot != NULL) {
        pgadRoot->xdUpdateAdaptors(nCode);
    }
}


/***************************************************************************\
*
* DuVisual::GetTicket
*
* The GetTicket function returns the ticket that can be used to 
* identify this gadget.
*
* <param name="pdwTicket">
*     [out] The storage for a copy of the ticket assigned to this gadget.
* </param>
*
* <return type="DWORD">
*     If the function succeeds, the return value is a 32-bit ticket that
*     can be used to identify the specified gadget.
*     If the function fails, the return value is zero.
* </return>
*
* <remarks>
*     Tickets are created to give an external identity to a gadget.  A
*     is guaranteed to be 32 bits on all platforms.  If no ticket is
*     currently associated with this gadget, one is allocated.
* </remarks>
*
* <see type="function">DuVisual::ClearTicket</>
* <see type="function">DuVisual::LookupTicket</>
*
\***************************************************************************/

HRESULT
DuVisual::GetTicket(OUT DWORD * pdwTicket)
{
    HRESULT hr = S_OK;

    if (NULL == pdwTicket) {
        return E_POINTER;
    } else {
        *pdwTicket = 0;
    }

    //
    // If we have already assigned this gadget a ticket, we should have it stored
    // in the gadget's dynamic data.
    //
    if (m_fTicket) {
        void * pTicket = NULL;

        hr = m_pds.GetData(s_pridTicket, (void**) &pTicket);
        AssertMsg(SUCCEEDED(hr), "Our state is out of sync!");

        if (SUCCEEDED(hr)) {
            *pdwTicket = PtrToUlong(pTicket);  // Yes, I am just casting the pointer!
        } else {
            //
            // Try to repair our state!
            //
            m_fTicket = FALSE;
            hr = S_OK;
        }
    }
    
    //
    // If we haven't assigned this gadget a ticket yet, get one from the global
    // ticket manager and store it in the gadget's dynamic data.
    //
    if (!m_fTicket) {
        hr = GetTicketManager()->Add(this, pdwTicket);
        if (SUCCEEDED(hr)) {
            hr = m_pds.SetData(s_pridTicket, ULongToPtr(*pdwTicket)); // Yes, I am just casting to a pointer!

            if (SUCCEEDED(hr)) {
                m_fTicket = TRUE;
            } else {
                GetTicketManager()->Remove(*pdwTicket, NULL);
                *pdwTicket = 0;
            }
        }
    }

    return hr;
}


/***************************************************************************\
*
* DuVisual::ClearTicket
*
* The ClearTicket function remmoves the association between this\
* gadget and the current ticket.
*
* <return type="void">
* </return>
*
* <see type="function">DuVisual::GetTicket</>
* <see type="function">DuVisual::LookupTicket</>
*
\***************************************************************************/

void
DuVisual::ClearTicket()
{
    if (m_fTicket) {
        HRESULT hr;
        void * pTicket= NULL;
        DWORD dwTicket;

        hr = m_pds.GetData(s_pridTicket, (void**) &pTicket);
        if (SUCCEEDED(hr)) {
            dwTicket = PtrToUlong(pTicket);  // Yes, I am just casting the pointer!
            VerifyHR(GetTicketManager()->Remove(dwTicket, NULL));
        }

        m_pds.RemoveData(s_pridTicket, FALSE);
        m_fTicket = FALSE;
    }
}


/***************************************************************************\
*
* DuVisual::LookupTicket
*
* The LookupTicket function returns the gadget that is associated with
* the specified ticket.
*
* <param name="dwTicket">
*     [in] A ticket that has been associated with a gadget via the
*     DuVisual::GetTicket function.
* </param>
*
* <return type="HGADGET">
*     If the function succeeds, the return value is a handle to the gadget
*     associated with the ticket.
*     If the function fails, the return value is NULL.
* </return>
*
* <see type="function">DuVisual::GetTicket</>
* <see type="function">DuVisual::ClearTicket</>
*
\***************************************************************************/

HGADGET
DuVisual::LookupTicket(DWORD dwTicket)
{
    BaseObject * pObject = NULL;
    HGADGET hgad = NULL;
    HRESULT hr;

    hr = GetTicketManager()->Lookup(dwTicket, &pObject);
    if (SUCCEEDED(hr) && pObject != NULL) {
        hgad = (HGADGET) pObject->GetHandle();
    }

    return hgad;
}

#if DBG

//------------------------------------------------------------------------------
void        
DuVisual::DEBUG_SetOutline(DuVisual * pgadOutline)
{
    if (s_DEBUG_pgadOutline != NULL) {
        s_DEBUG_pgadOutline->Invalidate();
    }

    s_DEBUG_pgadOutline = pgadOutline;

    if (s_DEBUG_pgadOutline != NULL) {
        s_DEBUG_pgadOutline->Invalidate();
    }
}


//------------------------------------------------------------------------------
void
AppendName(WCHAR * & pszDest, const WCHAR * pszSrc, int & cchRemain, BOOL & fFirst)
{
    if (cchRemain <= 0) {
        return;
    }

    if (!fFirst) {
        if (cchRemain <= 2) {
            CopyString(pszDest, L"", cchRemain);
            cchRemain = 0;
            return;
        }

        CopyString(pszDest, L", ", cchRemain);
        cchRemain -= 2;
        pszDest += 2;
    }

    int cchCopy = (int) wcslen(pszSrc);
    CopyString(pszDest, pszSrc, cchRemain);

    cchRemain   -= cchCopy;
    pszDest     += cchCopy;

    fFirst = FALSE;
}


//------------------------------------------------------------------------------
void        
DuVisual::DEBUG_GetStyleDesc(LPWSTR pszDesc, int cchMax) const
{
    pszDesc[0] = '\0';

    int cchRemain = cchMax;
    WCHAR * pszDest = pszDesc;
    BOOL fFirst = TRUE;

    if (m_fAllowSubclass)
        AppendName(pszDest, L"AllowSubclass", cchRemain, fFirst);
    if (m_fAdaptor)
        AppendName(pszDest, L"Adaptor", cchRemain, fFirst);
    if (m_fBackFill)
        AppendName(pszDest, L"BackFill*", cchRemain, fFirst);
    if (m_fBuffered)
        AppendName(pszDest, L"Buffered", cchRemain, fFirst);
    if (m_fCached)
        AppendName(pszDest, L"Cache", cchRemain, fFirst);
    if (m_fClipInside)
        AppendName(pszDest, L"ClipInside", cchRemain, fFirst);
    if (m_fClipSiblings)
        AppendName(pszDest, L"ClipSiblings", cchRemain, fFirst);
    if (m_fDeepPaintState)
        AppendName(pszDest, L"DeepPaintState", cchRemain, fFirst);
    if (m_fDeepMouseFocus)
        AppendName(pszDest, L"DeepMouseFocus*", cchRemain, fFirst);
    if (m_fDeepTrivial)
        AppendName(pszDest, L"DeepTrivial*", cchRemain, fFirst);
    if (m_fDestroyed)
        AppendName(pszDest, L"Destroyed*", cchRemain, fFirst);
    if (m_fEnabled)
        AppendName(pszDest, L"Enabled", cchRemain, fFirst);
    if (m_fCustomHitTest)
        AppendName(pszDest, L"HitTest", cchRemain, fFirst);
    if (m_fHRedraw)
        AppendName(pszDest, L"H-Redraw", cchRemain, fFirst);
    if (m_fKeyboardFocus)
        AppendName(pszDest, L"KeyboardFocus", cchRemain, fFirst);
    if (m_fMouseFocus)
        AppendName(pszDest, L"MouseFocus", cchRemain, fFirst);
    if (m_fZeroOrigin)
        AppendName(pszDest, L"ZeroOrigin", cchRemain, fFirst);
    if (m_fOpaque)
        AppendName(pszDest, L"Opaque", cchRemain, fFirst);
    if (m_fRelative)
        AppendName(pszDest, L"Relative", cchRemain, fFirst);
    if (m_fVisible)
        AppendName(pszDest, L"Visible", cchRemain, fFirst);
    if (m_fVRedraw)
        AppendName(pszDest, L"V-Redraw", cchRemain, fFirst);
    if (m_fXForm)
        AppendName(pszDest, L"XForm*", cchRemain, fFirst);
}

#endif // DBG


//------------------------------------------------------------------------------
HRESULT CALLBACK DummyEventProc(HGADGET hgadCur, void * pvCur, EventMsg * pMsg)
{
    UNREFERENCED_PARAMETER(hgadCur);
    UNREFERENCED_PARAMETER(pvCur);
    UNREFERENCED_PARAMETER(pMsg);

    return DU_S_NOTHANDLED;
}


#if ENABLE_MSGTABLE_API

//------------------------------------------------------------------------------
HRESULT CALLBACK
DuVisual::PromoteVisual(DUser::ConstructProc pfnCS, HCLASS hclCur, DUser::Gadget * pgad, DUser::Gadget::ConstructInfo * pciData)
{
    UNREFERENCED_PARAMETER(pfnCS);
    UNREFERENCED_PARAMETER(hclCur);

    Visual::VisualCI * pciVisual = static_cast<Visual::VisualCI *> (pciData);
    MsgObject ** ppmsoNew = reinterpret_cast<MsgObject **> (pgad);
    AssertMsg((ppmsoNew != NULL) && (*ppmsoNew == NULL), 
            "Internal objects must be given valid storage for the MsgObject");

    CREATE_INFO ci;
    ci.pfnProc  = DummyEventProc;   // Can't use NULL b'c SimpleGadgetProc turns too much off
    ci.pvData   = NULL;

    DuVisual * pgt;
    DuVisual * pgtParent = pciVisual->pgvParent != NULL ? 
            CastVisual(pciVisual->pgvParent) : GetCoreSC()->pconPark->GetRoot();
    HRESULT hr = Build(pgtParent, &ci, &pgt, TRUE);
    if (FAILED(hr)) {
        return hr;
    }

    *ppmsoNew = pgt;
    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiSetOrder(Visual::SetOrderMsg * pmsg)
{
    DuVisual * pdgvOther;

    BEGIN_API(ContextLock::edDefer, GetContext());
    VALIDATE_RANGE(pmsg->nCmd, GORDER_MIN, GORDER_MAX);
    VALIDATE_VISUAL_OR_NULL(pmsg->pgvOther, pdgvOther);
    CHECK_MODIFY();

    retval = xdSetOrder(pdgvOther, pmsg->nCmd);

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiSetParent(Visual::SetParentMsg * pmsg)
{
    DuVisual * pdgvParent;
    DuVisual * pdgvOther;
    HRESULT hr;

    BEGIN_API(ContextLock::edDefer, GetContext());
    VALIDATE_RANGE(pmsg->nCmd, GORDER_MIN, GORDER_MAX);
    VALIDATE_VISUAL_OR_NULL(pmsg->pgvParent, pdgvParent);
    VALIDATE_VISUAL_OR_NULL(pmsg->pgvOther, pdgvOther);
    CHECK_MODIFY();

    if (IsRoot()) {
        PromptInvalid("Can not change a RootGadget's parent");
        retval = E_INVALIDARG;
        goto ErrorExit;
    }

    //
    // Check that can become a child of the specified parent
    //

    if ((!IsRelative()) && pdgvParent->IsRelative()) {
        PromptInvalid("Can not set non-relative child to a relative parent");
        retval = DU_E_BADCOORDINATEMAP;
        goto ErrorExit;
    }

    //
    // DuVisual::xdSetParent() handles if pgadParent is NULL and will move to the
    // parking window.
    //

    hr = xdSetParent(pdgvParent, pdgvOther, pmsg->nCmd);

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiGetGadget(Visual::GetGadgetMsg * pmsg)
{
    BEGIN_API(ContextLock::edNone, GetContext());
    VALIDATE_RANGE(pmsg->nCmd, GG_MIN, GG_MAX);

    pmsg->pgv = GetVisual(GetGadget(pmsg->nCmd));
    retval = S_OK;

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiGetStyle(Visual::GetStyleMsg * pmsg)
{
    BEGIN_API(ContextLock::edNone, GetContext());

    pmsg->nStyle = GetStyle();
    retval = S_OK;

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiSetStyle(Visual::SetStyleMsg * pmsg)
{
    BEGIN_API(ContextLock::edDefer, GetContext());
    VALIDATE_FLAGS(pmsg->nNewStyle, GS_VALID);
    VALIDATE_FLAGS(pmsg->nMask, GS_VALID);
    CHECK_MODIFY();

    retval = xdSetStyle(pmsg->nNewStyle, pmsg->nMask);

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiSetKeyboardFocus(Visual::SetKeyboardFocusMsg * pmsg)
{
    DuRootGadget * pdgvRoot;

    BEGIN_API(ContextLock::edDefer, GetContext());
    CHECK_MODIFY();

    //
    // TODO: Do we need to only allow the app to change focus if on the same
    // thread?  USER does this.
    //

    pdgvRoot = GetRoot();
    if (pdgvRoot != NULL) {
        retval = pdgvRoot->xdSetKeyboardFocus(this) ? S_OK : DU_E_GENERIC;
    }

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiIsParentChainStyle(Visual::IsParentChainStyleMsg * pmsg)
{
    BEGIN_API(ContextLock::edNone, GetContext());
    VALIDATE_VALUE(pmsg->nFlags, 0);
    VALIDATE_FLAGS(pmsg->nStyle, GS_VALID);
    CHECK_MODIFY();

    pmsg->fResult = IsParentChainStyle(pmsg->nStyle);
    retval = S_OK;

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiGetProperty(Visual::GetPropertyMsg * pmsg)
{
    BEGIN_API(ContextLock::edNone, GetContext());
    CHECK_MODIFY();

    retval = GetProperty(pmsg->id, &pmsg->pvValue);
       
    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiSetProperty(Visual::SetPropertyMsg * pmsg)
{
    BEGIN_API(ContextLock::edDefer, GetContext());
    CHECK_MODIFY();

    retval = SetProperty(pmsg->id, pmsg->pvValue);

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiRemoveProperty(Visual::RemovePropertyMsg * pmsg)
{
    BEGIN_API(ContextLock::edDefer, GetContext());
    CHECK_MODIFY();

    RemoveProperty(pmsg->id, FALSE /* Can't free memory for Global property*/);
    retval = S_OK;
    
    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiInvalidate(Visual::InvalidateMsg * pmsg)
{
    BEGIN_API(ContextLock::edDefer, GetContext());
    CHECK_MODIFY();

    Invalidate();
    retval = S_OK;

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiInvalidateRects(Visual::InvalidateRectsMsg * pmsg)
{
    BEGIN_API(ContextLock::edDefer, GetContext());
    CHECK_MODIFY();
    VALIDATE_RANGE(pmsg->cRects, 1, 1024);
    VALIDATE_READ_PTR_(pmsg->rgrcClientPxl, sizeof(RECT) * pmsg->cRects);

    InvalidateRects(pmsg->rgrcClientPxl, pmsg->cRects);
    retval = S_OK;

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiSetFillF(Visual::SetFillFMsg * pmsg)
{
    BEGIN_API(ContextLock::edDefer, GetContext());
    CHECK_MODIFY();

    retval = SetFill(pmsg->pgpgrFill);

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiSetFillI(Visual::SetFillIMsg * pmsg)
{
    BEGIN_API(ContextLock::edDefer, GetContext());
    CHECK_MODIFY();

    retval = SetFill(pmsg->hbrFill, pmsg->bAlpha, pmsg->w, pmsg->h);

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiGetScale(Visual::GetScaleMsg * pmsg)
{
    BEGIN_API(ContextLock::edNone, GetContext());

    GetScale(&pmsg->flX, &pmsg->flY);
    retval = S_OK;

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiSetScale(Visual::SetScaleMsg * pmsg)
{
    BEGIN_API(ContextLock::edDefer, GetContext());
    CHECK_MODIFY();

    retval = xdSetScale(pmsg->flX, pmsg->flY);

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiGetRotation(Visual::GetRotationMsg * pmsg)
{
    BEGIN_API(ContextLock::edNone, GetContext());

    pmsg->flRotationRad = GetRotation();
    retval = S_OK;

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiSetRotation(Visual::SetRotationMsg * pmsg)
{
    BEGIN_API(ContextLock::edDefer, GetContext());
    CHECK_MODIFY();

    retval = xdSetRotation(pmsg->flRotationRad);

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiGetCenterPoint(Visual::GetCenterPointMsg * pmsg)
{
    BEGIN_API(ContextLock::edNone, GetContext());

    GetCenterPoint(&pmsg->flX, &pmsg->flY);
    retval = S_OK;

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiSetCenterPoint(Visual::SetCenterPointMsg * pmsg)
{
    BEGIN_API(ContextLock::edDefer, GetContext());
    CHECK_MODIFY();

    retval = xdSetCenterPoint(pmsg->flX, pmsg->flY);

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiGetBufferInfo(Visual::GetBufferInfoMsg * pmsg)
{
    BEGIN_API(ContextLock::edNone, GetContext());
    VALIDATE_WRITE_STRUCT(pmsg->pbi, BUFFER_INFO);
    VALIDATE_FLAGS(pmsg->pbi->nMask, GBIM_VALID);

    if (!IsBuffered()) {
        PromptInvalid("Gadget is not GS_BUFFERED");
        retval = DU_E_NOTBUFFERED;
        goto ErrorExit;
    }

    retval = GetBufferInfo(pmsg->pbi);

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiSetBufferInfo(Visual::SetBufferInfoMsg * pmsg)
{
    BEGIN_API(ContextLock::edDefer, GetContext());
    VALIDATE_READ_STRUCT(pmsg->pbi, BUFFER_INFO);
    VALIDATE_FLAGS(pmsg->pbi->nMask, GBIM_VALID);
    CHECK_MODIFY();

    if (!IsBuffered()) {
        PromptInvalid("Gadget is not GS_BUFFERED");
        retval = DU_E_NOTBUFFERED;
        goto ErrorExit;
    }

    retval = SetBufferInfo(pmsg->pbi);

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiGetSize(Visual::GetSizeMsg * pmsg)
{
    BEGIN_API(ContextLock::edNone, GetContext());

    GetSize(&pmsg->sizeLogicalPxl);
    retval = S_OK;

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiGetRect(Visual::GetRectMsg * pmsg)
{
    BEGIN_API(ContextLock::edNone, GetContext());
    VALIDATE_FLAGS(pmsg->nFlags, SGR_VALID_GET);
 
    if (TestFlag(pmsg->nFlags, SGR_ACTUAL)) {
        AssertMsg(0, "TODO: Not Implemented");
    } else {
        GetLogRect(&pmsg->rcPxl, pmsg->nFlags);
        retval = S_OK;
    }

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiSetRect(Visual::SetRectMsg * pmsg)
{
    BEGIN_API(ContextLock::edDefer, GetContext());
    VALIDATE_FLAGS(pmsg->nFlags, SGR_VALID_SET);
    VALIDATE_READ_PTR_(pmsg->prcPxl, sizeof(RECT));
    CHECK_MODIFY();

    if (IsRoot()) {
        if (TestFlag(pmsg->nFlags, SGR_MOVE)) {
            PromptInvalid("Can not move a RootGadget");
            retval = E_INVALIDARG;
            goto ErrorExit;
        }
    }


    //
    // Ensure that size is non-negative
    //

    int x, y, w, h;
    x = pmsg->prcPxl->left;
    y = pmsg->prcPxl->top;
    w = pmsg->prcPxl->right - pmsg->prcPxl->left;
    h = pmsg->prcPxl->bottom - pmsg->prcPxl->top;

    if (TestFlag(pmsg->nFlags, SGR_SIZE)) {
        if (w < 0) {
            w = 0;
        }
        if (h < 0) {
            h = 0;
        }
    }

    if (TestFlag(pmsg->nFlags, SGR_ACTUAL)) {
//        AssertMsg(0, "TODO: Not Implemented");
        ClearFlag(pmsg->nFlags, SGR_ACTUAL);
        retval = xdSetLogRect(x, y, w, h, pmsg->nFlags);
    } else {
        retval = xdSetLogRect(x, y, w, h, pmsg->nFlags);
    }

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiFindFromPoint(Visual::FindFromPointMsg * pmsg)
{
    BEGIN_API(ContextLock::edNone, GetContext());
    VALIDATE_FLAGS(pmsg->nStyle, GS_VALID);

    pmsg->pgvFound = GetVisual(FindFromPoint(pmsg->ptThisClientPxl, pmsg->nStyle, &pmsg->ptFoundClientPxl));
    retval = S_OK;

    END_API();
}


//------------------------------------------------------------------------------
HRESULT
DuVisual::ApiMapPoints(Visual::MapPointsMsg * pmsg)
{
    DuVisual * pdgvTo;

    BEGIN_API(ContextLock::edNone, GetContext());
    VALIDATE_VISUAL(pmsg->pgvTo, pdgvTo);
    VALIDATE_WRITE_PTR_(pmsg->rgptClientPxl, sizeof(POINT) * pmsg->cPts);

    if (GetRoot() != pdgvTo->GetRoot()) {
        PromptInvalid("Must be in the same tree");
        retval = E_INVALIDARG;
        goto ErrorExit;
    }

    DuVisual::MapPoints(this, pdgvTo, pmsg->rgptClientPxl, pmsg->cPts);
    retval = S_OK;

    END_API();
}

#endif // ENABLE_MSGTABLE_API


#if DBG

/***************************************************************************\
*
* DuVisual::DEBUG_AssertValid
*
* DEBUG_AssertValid() provides a DEBUG-only mechanism to perform rich 
* validation of an object to attempt to determine if the object is still 
* valid.  This is used during debugging to help track damaged objects
*
\***************************************************************************/

void
DuVisual::DEBUG_AssertValid() const
{
#if ENABLE_MSGTABLE_API
    VisualImpl<DuVisual, DuEventGadget>::DEBUG_AssertValid();
#else
    DuEventGadget::DEBUG_AssertValid();
#endif

    TreeNodeT<DuVisual>::DEBUG_AssertValid();

    Assert(!m_fAllowSubclass);

    Assert(m_rcLogicalPxl.right >= m_rcLogicalPxl.left);
    Assert(m_rcLogicalPxl.bottom >= m_rcLogicalPxl.top);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\treegadget.inl ===
/***************************************************************************\
*
* File: TreeGadget.inl
*
* Description:
* TreeGadget.inl implements lightweight common Gadget functions.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/

#if !defined(CORE__TreeGadget_inl__INCLUDED)
#define CORE__TreeGadget_inl__INCLUDED
#pragma once

/***************************************************************************\
*****************************************************************************
*
* class DuVisual
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline DuVisual * 
CastVisual(BaseObject * pbase)
{
    if ((pbase != NULL) && TestFlag(pbase->GetHandleMask(), hmVisual)) {
#if DBG
        ((DuVisual *) pbase)->DEBUG_AssertValid();
#endif
        return (DuVisual *) pbase;
    }
    return NULL;
}


//------------------------------------------------------------------------------
inline const DuVisual * 
CastVisual(const BaseObject * pbase)
{
    if ((pbase != NULL) && TestFlag(pbase->GetHandleMask(), hmVisual)) {
#if DBG
        ((const DuVisual *) pbase)->DEBUG_AssertValid();
#endif
        return (const DuVisual *) pbase;
    }
    return NULL;
}


//------------------------------------------------------------------------------
inline DuVisual *
CastVisual(DUser::Gadget * pg)
{
    DuVisual * pgad = (DuVisual *) MsgObject::CastMsgObject(pg);

#if DBG
    if (pgad != NULL) {
        pgad->DEBUG_AssertValid();
    }
#endif

    return pgad;
}


//------------------------------------------------------------------------------
inline DuVisual * 
ValidateVisual(HGADGET hgad)
{
    DuVisual * pgad = CastVisual(BaseObject::ValidateHandle(hgad));

#if DBG
    if (pgad != NULL) {
        pgad->DEBUG_AssertValid();
    }
#endif

    return pgad;
}


//------------------------------------------------------------------------------
inline DuVisual * 
ValidateVisual(Visual * pgv)
{
    DuVisual * pgad = (DuVisual *) MsgObject::CastMsgObject(pgv);

#if DBG
    if (pgad != NULL) {
        pgad->DEBUG_AssertValid();
    }
#endif

    return pgad;
}


//------------------------------------------------------------------------------
inline
DuVisual::DuVisual()
{
    // Make the default to be relative.  It is important to do this since only 
    // relative children can be added to a relative parent.  Also, the default 
    // behavior, whenever possible, should be to be relative unless the parent 
    // prevents us.
    //

    m_nStyle = GS_VISIBLE | GS_ENABLED | GS_RELATIVE;
    m_fDeepTrivial = TRUE;

    //
    // DuVisual's should have weDeepMouseEnter on by default so that 
    // GM_MOUSEENTER and GM_MOUSELEAVE can be processed.
    //
    // NOTE: This NEED's to be set AFTER m_nStyle has been set since m_we is
    // stored inside m_nStyle.
    //

    m_we = weDeepMouseEnter;
}


//------------------------------------------------------------------------------
inline DuRootGadget * 
DuVisual::GetRoot() const
{
    //
    // For the top level layout, need to have a DuRootGadget as its own owner.  
    // THIS IS VERY IMPORTANT, but it means that we need to be careful when 
    // using the owning layout b/c there is a circular link.  Use the parent 
    // tree when walking up to avoid this.
    //

    DuVisual * pgadCur = const_cast<DuVisual *> (this);
    while (pgadCur->GetParent() != NULL) {
        pgadCur = pgadCur->GetParent();
    }

    // Top level is always a DuRootGadget
    if (pgadCur->m_fRoot) {
        return (DuRootGadget *) pgadCur;
    } else {
        return NULL;
    }
}


//------------------------------------------------------------------------------
inline UINT
DuVisual::GetWantEvents() const
{
    return m_we;
}


//------------------------------------------------------------------------------
inline UINT        
DuVisual::GetStyle() const
{
    // Mask out bits that are not publicly exposed

    return m_nStyle & GS_VALID;
}


//------------------------------------------------------------------------------
inline BOOL        
DuVisual::GetEnableXForm() const
{
    return m_fXForm;
}


//------------------------------------------------------------------------------
inline XFormInfo *   
DuVisual::GetXFormInfo() const
{
    AssertMsg(m_fXForm, "Only can call if Trx are enabled");
    AssertMsg(SupportXForm(), "Only can set if XForm's are supported");

    XFormInfo * pti;
    VerifyHR(m_pds.GetData(s_pridXForm, (void **) &pti));
    return pti;
}


//------------------------------------------------------------------------------
inline BOOL        
DuVisual::IsRoot() const
{
    //
    // NOTE: A non-root Gadget may not yet have a parent during construction.
    // The called should be able to safely call IsRoot() during this time, but
    // is not allowed to call GetRoot() during this time.
    //

    return m_fRoot;
}


//------------------------------------------------------------------------------
inline BOOL        
DuVisual::IsRelative() const
{
    return m_fRelative;
}


//------------------------------------------------------------------------------
inline BOOL
DuVisual::IsParentChainStyle(UINT nStyle) const
{
    const DuVisual * pgadCur = this;
    while (pgadCur != NULL) {
        if ((pgadCur->m_nStyle & nStyle) != nStyle) {
            return FALSE;
        }

        pgadCur = pgadCur->GetParent();
    }

    return TRUE;
}


//------------------------------------------------------------------------------
inline BOOL        
DuVisual::IsVisible() const
{
    return IsParentChainStyle(GS_VISIBLE);
}


//------------------------------------------------------------------------------
inline BOOL        
DuVisual::IsEnabled() const
{
    return IsParentChainStyle(GS_ENABLED);
}


//------------------------------------------------------------------------------
inline BOOL        
DuVisual::HasChildren() const
{
    return m_ptnChild != NULL;
}


//------------------------------------------------------------------------------
inline BOOL        
DuVisual::IsBuffered() const
{
    return m_fBuffered;
}


//------------------------------------------------------------------------------
inline BUFFER_INFO *
DuVisual::GetBufferInfo() const
{
    AssertMsg(m_fBuffered, "Only call on buffered Gadgets");

    BUFFER_INFO * pbi;
    VerifyHR(m_pds.GetData(s_pridBufferInfo, (void **) &pbi));
    return pbi;
}


//------------------------------------------------------------------------------
inline HRESULT
DuVisual::xdSetOrder(
    IN  DuVisual * pgadOther,     
    IN  UINT nCmd)
{
    return xdSetParent(GetParent(), pgadOther, nCmd);
}


//------------------------------------------------------------------------------
inline HRESULT
DuVisual::GetProperty(PRID id, void ** ppValue) const
{
    return m_pds.GetData(id, (void **) ppValue);
}


//------------------------------------------------------------------------------
inline HRESULT
DuVisual::SetProperty(PRID id, void * pValue)
{
    return m_pds.SetData(id, pValue);
}


//------------------------------------------------------------------------------
inline void
DuVisual::RemoveProperty(PRID id, BOOL fFree)
{
    m_pds.RemoveData(id, fFree);
}


//------------------------------------------------------------------------------
inline void
DuVisual::Link(DuVisual * pgadParent, DuVisual * pgadSibling, ELinkType lt)
{
    AssertMsg(GetParent() == NULL, "Must not already be linked");

    TreeNodeT<DuVisual>::DoLink(pgadParent, pgadSibling, lt);

    if (pgadParent != NULL) {
        pgadParent->UpdateTrivial(m_fDeepTrivial ? uhTrue : uhFalse);
        pgadParent->UpdateWantMouseFocus(m_fDeepMouseFocus ? uhTrue : uhFalse);
    }
}


//------------------------------------------------------------------------------
inline void
DuVisual::Unlink()
{
    DuVisual * pgadParent = GetParent();
    TreeNodeT<DuVisual>::DoUnlink();

    if (pgadParent != NULL) {
        pgadParent->UpdateTrivial(uhTrue /* Unlink is Trivial */);
        pgadParent->UpdateWantMouseFocus(uhTrue /* Unlink is Trivial */);
    }
}


//------------------------------------------------------------------------------
inline void
DuVisual::MarkInvalidChildren()
{
    //
    // Walk up the tree marking each parent as invalid
    //

    DuVisual * pgadCur = this;
    while ((pgadCur != NULL) && (!pgadCur->m_fInvalidChildren)) {
        pgadCur->m_fInvalidChildren = TRUE;
        pgadCur = pgadCur->GetParent();
    }
}


//------------------------------------------------------------------------------
inline DuVisual * 
DuVisual::GetKeyboardFocusableAncestor(
    IN DuVisual * pgadCur)
{
    //
    // Walk up the tree until we find a keyboard focusable gadget
    //

    while (pgadCur != NULL) {
        if (pgadCur->m_fKeyboardFocus && pgadCur->IsVisible() /*&& pgadCur->IsEnabled()*/) {
            return pgadCur;
        }

        pgadCur = pgadCur->GetParent();
    }

    return NULL;
}


//------------------------------------------------------------------------------
inline void
DuVisual::UpdateTrivial(EUdsHint hint)
{
    UpdateDeepAllState(hint, CheckIsTrivial, gspDeepTrivial);
}


//------------------------------------------------------------------------------
inline void
DuVisual::UpdateWantMouseFocus(EUdsHint hint)
{
    UpdateDeepAnyState(hint, CheckIsWantMouseFocus, gspDeepMouseFocus);
}


#endif // CORE__TreeGadget_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\animation.cpp ===
#include "stdafx.h"
#include "Ctrl.h"
#include "Animation.h"

#if ENABLE_MSGTABLE_API

/***************************************************************************\
*****************************************************************************
*
* Global Functions
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
DUSER_API void WINAPI
DUserStopAnimation(Visual * pgvSubject, PRID pridAni)
{
    if (pgvSubject == NULL) {
        PromptInvalid("Invalid pgvSubject");
        return;
    }
    if (pridAni <= 0) {
        PromptInvalid("Invalid Animation pridAni");
        return;
    }

    DuExtension * pext = DuExtension::GetExtension(pgvSubject, pridAni);
    if (pext != NULL) {
        pext->GetStub()->OnRemoveExisting();
    }
}


/***************************************************************************\
*****************************************************************************
*
* class DuAnimation
*
*****************************************************************************
\***************************************************************************/

MSGID       DuAnimation::s_msgidComplete = 0;

//------------------------------------------------------------------------------
DuAnimation::~DuAnimation()
{
    Destroy(TRUE);

    SafeRelease(m_pipol);
    SafeRelease(m_pgflow);

#if DEBUG_TRACECREATION
    Trace("STOP  Animation  0x%p    @ %d  (%d frames)\n", this, GetTickCount(), m_DEBUG_cUpdates);
#endif // DEBUG_TRACECREATION


    //
    // Ensure proper destruction
    //

    AssertMsg(m_hact == NULL, "Action should already be destroyed");
}


/***************************************************************************\
*
* DuAnimation::InitClass
*
* InitClass() is called during startup and provides an opportunity to 
* initialize common data.
*
\***************************************************************************/

HRESULT
DuAnimation::InitClass()
{
    s_msgidComplete = RegisterGadgetMessage(&_uuidof(Animation::evComplete));
    if (s_msgidComplete == 0) {
        return (HRESULT) GetLastError();
    }

    return S_OK;
}

//------------------------------------------------------------------------------
HRESULT
DuAnimation::PreBuild(DUser::Gadget::ConstructInfo * pci)
{
    //
    // Validate parameters
    //

    Animation::AniCI * pDesc = reinterpret_cast<Animation::AniCI *>(pci);
    if ((pDesc->pipol == NULL) || (pDesc->pgflow == NULL)) {
        PromptInvalid("Must provide valid Interpolation and Flow objects");
        return E_INVALIDARG;
    }

    PRID pridExtension = 0;
    VerifyHR(pDesc->pgflow->GetPRID(&pridExtension));
    if (pridExtension == 0) {
        PromptInvalid("Flow must register PRID");
        return E_INVALIDARG;
    }

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
DuAnimation::PostBuild(DUser::Gadget::ConstructInfo * pci)
{
    //
    // Check parameters.  This should be validated in PreBuild().
    //

    Animation::AniCI * pDesc = reinterpret_cast<Animation::AniCI *>(pci);

    Assert(pDesc->pipol != NULL);
    Assert(pDesc->pgflow != NULL);


    //
    // Setup the Action
    //

    GMA_ACTION gma;
    ZeroMemory(&gma, sizeof(gma));
    gma.cbSize      = sizeof(gma);
    gma.flDelay     = pDesc->act.flDelay;
    gma.flDuration  = pDesc->act.flDuration;
    gma.flPeriod    = pDesc->act.flPeriod;
    gma.cRepeat     = pDesc->act.cRepeat;
    gma.dwPause     = pDesc->act.dwPause;
    gma.pfnProc     = RawActionProc;
    gma.pvData      = this;

    m_hact = CreateAction(&gma);
    if (m_hact == NULL) {
        return (HRESULT) GetLastError();
    }

    PRID pridExtension;
    VerifyHR(pDesc->pgflow->GetPRID(&pridExtension));
    HRESULT hr = DuExtension::Create(pDesc->pgvSubject, pridExtension, DuExtension::oAsyncDestroy);
    if (FAILED(hr)) {
        return hr;
    }


    //
    // Store the related objects
    //

    pDesc->pipol->AddRef();
    pDesc->pgflow->AddRef();

    m_pipol     = pDesc->pipol;
    m_pgflow    = pDesc->pgflow;


    //
    // Animations need to be AddRef()'d again (have a reference count of 2) 
    // because they need to outlive the initial call to Release() after the 
    // called has setup the animation returned from BuildAnimation().  
    //
    // This is because the Animation continues to life until it has fully 
    // executed (or has been aborted).
    //

    AddRef();

    return S_OK;
}


//------------------------------------------------------------------------------
void
DuAnimation::Destroy(BOOL fFinal)
{
    //
    // Mark that we have already started the destruction process and don't need
    // to start again.  We only want to post the destruction message once.
    //

    if (m_fStartDestroy) {
        return;
    }
    m_fStartDestroy = TRUE;


    if (m_pgvSubject != NULL) {
#if DBG
        DuAnimation * paniExist = static_cast<DuAnimation *> (GetExtension(m_pgvSubject, m_pridListen));
        if (paniExist != NULL) {
            AssertMsg(paniExist == this, "Animations must match");
        }
#endif // DBG

        CleanupChangeGadget();
    }


    //
    // Destroy the Animation
    //

    AssertMsg(!fFinal, "Object is already being destructed");
    if (fFinal) {
        GetStub()->OnAsyncDestroy();
    } else {
        PostAsyncDestroy();
    }
}


//------------------------------------------------------------------------------
HRESULT
DuAnimation::ApiOnAsyncDestroy(Animation::OnAsyncDestroyMsg *)
{
    AssertMsg(m_fStartDestroy, "Must call Destroy() to start the destruction process.");
    AssertMsg(!m_fProcessing, "Should not be processing when start destruction");

    AssertMsg(m_pgvSubject == NULL, "Animation should already have detached from Gadget");
    HACTION hact = m_hact;

    //
    // Set everything to NULL now.
    //

    m_hact = NULL;
    if (hact != NULL) {
        ::DeleteHandle(hact);
        hact = NULL;
    }

    Release();

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
DuAnimation::ApiSetTime(Animation::SetTimeMsg * pmsg)
{
    GMA_ACTIONINFO mai;

    //
    // TODO: Need to save these values from the last time so that they are 
    // valid.
    //

    mai.hact        = m_hact;
    mai.pvData      = this;
    mai.flDuration  = 0.0f;

    m_time = (Animation::ETime) pmsg->time;
    switch (pmsg->time)
    {
    case Animation::tComplete:
        // Don't do anything
        return S_OK;

    default:
    case Animation::tAbort:
    case Animation::tDestroy:
        goto Done;

    case Animation::tEnd:
        mai.flProgress  = 1.0f;
        break;

    case Animation::tReset:
        mai.flProgress  = 0.0f;
        break;
    }

    mai.cEvent      = 0;
    mai.cPeriods    = 0;
    mai.fFinished   = FALSE;

    m_fProcessing = TRUE;
    m_pgflow->OnAction(m_pgvSubject, m_pipol, mai.flProgress);
    Assert(m_fProcessing);
    m_fProcessing = FALSE;

Done:
    ::DeleteHandle(m_hact);
    
    return S_OK;    
}


//------------------------------------------------------------------------------
void
DuAnimation::CleanupChangeGadget()
{
    //
    // Give the derived Animation a chance to cleanup
    //
    // Check that we are still the Animation attached to this Gadget.  We need 
    // to remove this property immediately.  We can not wait for a posted 
    // message to be processed because we may need to set it right now if we are
    // creating a new Animation.
    //

    BOOL fStarted = FALSE;

    Animation::CompleteEvent msg;
    msg.cbSize  = sizeof(msg);
    msg.nMsg    = s_msgidComplete;
    msg.hgadMsg = GetHandle();
    msg.fNormal = IsStartDelete(m_pgvSubject->GetHandle(), &fStarted) && (!fStarted);

    DUserSendEvent(&msg, 0);


    Assert(m_pgvSubject != NULL);
    Assert(m_pridListen != 0);

    Verify(SUCCEEDED(m_pgvSubject->RemoveProperty(m_pridListen)));

    m_pgvSubject = NULL;
}

    
//------------------------------------------------------------------------------
void CALLBACK
DuAnimation::RawActionProc(
    IN  GMA_ACTIONINFO * pmai)
{
    //
    // Need to AddRef while processing the Animation to ensure that it does not
    // get destroyed from under us, for example, during one of the callbacks.
    //

    DuAnimation * pani = (DuAnimation *) pmai->pvData;
    pani->AddRef();

    Assert(!pani->m_fProcessing);

#if DEBUG_TRACECREATION
    Trace("START RawActionP 0x%p    @ %d\n", pani, GetTickCount());
#endif // DEBUG_TRACECREATION

    pani->ActionProc(pmai);

#if DEBUG_TRACECREATION
    Trace("STOP  RawActionP 0x%p    @ %d\n", pani, GetTickCount());
#endif // DEBUG_TRACECREATION

    Assert(!pani->m_fProcessing);

    pani->Release();
}


//------------------------------------------------------------------------------
void
DuAnimation::ActionProc(
    IN  GMA_ACTIONINFO * pmai)
{
#if DBG
    m_DEBUG_cUpdates++;
#endif // DBG

    if ((!m_fStartDestroy) && (m_pgvSubject != NULL)) {
        //
        // This ActionProc will be called when the Action is being destroyed, so
        // we only want to invoke the Action under certain circumstances.
        //

        switch (m_time)
        {
        case Animation::tComplete:
        case Animation::tEnd:
        case Animation::tReset:
            //
            // All of these are valid to complete.  If it isn't in this list, we
            // don't want to execute it during a shutdown.
            //

            m_fProcessing = TRUE;
            m_pgflow->OnAction(m_pgvSubject, m_pipol, pmai->flProgress);
            Assert(m_fProcessing);
            m_fProcessing = FALSE;
            break;
        }
    }

    if (pmai->fFinished) {
        m_hact = NULL;
        Destroy(FALSE);
    }
}


//------------------------------------------------------------------------------
HRESULT
DuAnimation::ApiOnRemoveExisting(Animation::OnRemoveExistingMsg *)
{
    GetStub()->SetTime(Animation::tDestroy);
    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
DuAnimation::ApiOnDestroySubject(Animation::OnDestroySubjectMsg *)
{
    AddRef();

    if (m_pgvSubject != NULL) {
        CleanupChangeGadget();

        //
        // The Gadget that we are modifying is being destroyed, so we need
        // to stop animating it.
        //

        m_time = Animation::tDestroy;
        Destroy(FALSE);
    }

    Release();

    return S_OK;
}

#else

//------------------------------------------------------------------------------
DUSER_API void WINAPI
DUserStopAnimation(Visual * pgvSubject, PRID pridAni)
{
    UNREFERENCED_PARAMETER(pgvSubject);
    UNREFERENCED_PARAMETER(pridAni);

    PromptInvalid("Not implemented without MsgTable support");
}

#endif // ENABLE_MSGTABLE_API
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\treegadget.h ===
/***************************************************************************\
*
* File: TreeGadget.h
*
* Description:
* TreeGadget.h defines the base "DuVisual" used inside a 
* DuVisual-Tree for hosting objects inside a form.  There are several 
* derived classes that are optimized for hosting different types of objects.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/

#if !defined(CORE__TreeGadget_h__INCLUDED)
#define CORE__TreeGadget_h__INCLUDED
#pragma once

#include "BaseGadget.h"
#include "PropList.h"

#define ENABLE_OPTIMIZESLRUPDATE    1   // Optimize xdSetLogRect updating bits
#define ENABLE_OPTIMIZEDIRTY        0   // Optimize dirty invalidation

// Forward declarations
class DuContainer;
class DuVisual;
class DuRootGadget;

struct XFormInfo;
struct FillInfo;
struct PaintInfo;

class DuVisual : 
#if ENABLE_MSGTABLE_API
        public VisualImpl<DuVisual, DuEventGadget>,
#else
        public DuEventGadget,
#endif
        public TreeNodeT<DuVisual>
{
// Construction
public:
    inline  DuVisual();
    virtual ~DuVisual();
    virtual BOOL        xwDeleteHandle();
    static  HRESULT     InitClass();
    static  HRESULT     Build(DuVisual * pgadParent, CREATE_INFO * pci, DuVisual ** ppgadNew, BOOL fDirect);
            HRESULT     CommonCreate(CREATE_INFO * pci, BOOL fDirect = FALSE);
protected:
    virtual void        xwDestroy();

// Public API
public:
#if ENABLE_MSGTABLE_API

    DECLARE_INTERNAL(Visual);
    static HRESULT CALLBACK
                        PromoteVisual(DUser::ConstructProc pfnCS, HCLASS hclCur, DUser::Gadget * pgad, DUser::Gadget::ConstructInfo * pciData);

    dapi    HRESULT     ApiSetOrder(Visual::SetOrderMsg * pmsg);
    dapi    HRESULT     ApiSetParent(Visual::SetParentMsg * pmsg);

    dapi    HRESULT     ApiGetGadget(Visual::GetGadgetMsg * pmsg);
    dapi    HRESULT     ApiGetStyle(Visual::GetStyleMsg * pmsg);
    dapi    HRESULT     ApiSetStyle(Visual::SetStyleMsg * pmsg);
    dapi    HRESULT     ApiSetKeyboardFocus(Visual::SetKeyboardFocusMsg * pmsg);
    dapi    HRESULT     ApiIsParentChainStyle(Visual::IsParentChainStyleMsg * pmsg);

    dapi    HRESULT     ApiGetProperty(Visual::GetPropertyMsg * pmsg);
    dapi    HRESULT     ApiSetProperty(Visual::SetPropertyMsg * pmsg);
    dapi    HRESULT     ApiRemoveProperty(Visual::RemovePropertyMsg * pmsg);

    dapi    HRESULT     ApiInvalidate(Visual::InvalidateMsg * pmsg);
    dapi    HRESULT     ApiInvalidateRects(Visual::InvalidateRectsMsg * pmsg);
    dapi    HRESULT     ApiSetFillF(Visual::SetFillFMsg * pmsg);
    dapi    HRESULT     ApiSetFillI(Visual::SetFillIMsg * pmsg);
    dapi    HRESULT     ApiGetScale(Visual::GetScaleMsg * pmsg);
    dapi    HRESULT     ApiSetScale(Visual::SetScaleMsg * pmsg);
    dapi    HRESULT     ApiGetRotation(Visual::GetRotationMsg * pmsg);
    dapi    HRESULT     ApiSetRotation(Visual::SetRotationMsg * pmsg);
    dapi    HRESULT     ApiGetCenterPoint(Visual::GetCenterPointMsg * pmsg);
    dapi    HRESULT     ApiSetCenterPoint(Visual::SetCenterPointMsg * pmsg);

    dapi    HRESULT     ApiGetBufferInfo(Visual::GetBufferInfoMsg * pmsg);
    dapi    HRESULT     ApiSetBufferInfo(Visual::SetBufferInfoMsg * pmsg);

    dapi    HRESULT     ApiGetSize(Visual::GetSizeMsg * pmsg);
    dapi    HRESULT     ApiGetRect(Visual::GetRectMsg * pmsg);
    dapi    HRESULT     ApiSetRect(Visual::SetRectMsg * pmsg);

    dapi    HRESULT     ApiFindFromPoint(Visual::FindFromPointMsg * pmsg);
    dapi    HRESULT     ApiMapPoints(Visual::MapPointsMsg * pmsg);

#endif // ENABLE_MSGTABLE_API

// BaseObject Interface
public:
    virtual BOOL        IsStartDelete() const;
    virtual HandleType  GetHandleType() const { return htVisual; }
    virtual UINT        GetHandleMask() const { return hmMsgObject | hmEventGadget | hmVisual; }

#if DBG
protected:
    virtual BOOL        DEBUG_IsZeroLockCountValid() const;
#endif // DBG


// Operations
public:
    inline  UINT        GetStyle() const;
            HRESULT     xdSetStyle(UINT nNewStyle, UINT nMask, BOOL fNotify = FALSE);

            // Tree Operations
    inline  DuRootGadget* GetRoot() const;
    inline  DuContainer * GetContainer() const;

            DuVisual* GetGadget(UINT nCmd) const;
    inline  HRESULT     xdSetOrder(DuVisual * pgadOther, UINT nCmd);
            HRESULT     xdSetParent(DuVisual * pgadNewParent, DuVisual * pgadOther, UINT nCmd);
            HRESULT     xwEnumGadgets(GADGETENUMPROC pfnProc, void * pvData, UINT nFlags);
            HRESULT     AddChild(CREATE_INFO * pci, DuVisual ** ppgadNew);

    inline  BOOL        IsRoot() const;
    inline  BOOL        IsRelative() const;
    inline  BOOL        IsParentChainStyle(UINT nStyle) const;
    inline  BOOL        IsVisible() const;
    inline  BOOL        IsEnabled() const;
    inline  BOOL        HasChildren() const;
            BOOL        IsDescendent(const DuVisual * pgadChild) const;
            BOOL        IsSibling(const DuVisual * pgad) const;

            // Size, location, XForm Operations
            void        GetSize(SIZE * psizeLogicalPxl) const;
            void        GetLogRect(RECT * prcPxl, UINT nFlags) const;
            HRESULT     xdSetLogRect(int x, int y, int w, int h, UINT nFlags);

            void        GetScale(float * pflScaleX, float * pflScaleY) const;
            HRESULT     xdSetScale(float flScaleX, float flScaleY);
            float       GetRotation() const;
            HRESULT     xdSetRotation(float flRotationRad);
            void        GetCenterPoint(float * pflCenterX, float * pflCenterY) const;
            HRESULT     xdSetCenterPoint(float flCenterX, float flCenterY);

            DuVisual *
                        FindFromPoint(POINT ptThisClientPxl, UINT nStyle, POINT * pptFoundClientPxl) const;
            void        MapPoint(POINT * pptPxl) const;
            void        MapPoint(POINT ptContainerPxl, POINT * pptClientPxl) const;
    static  void        MapPoints(const DuVisual * pgadFrom, const DuVisual * pgadTo, POINT * rgptClientPxl, int cPts);


            // Painting Operations
            void        Invalidate();
            void        InvalidateRects(const RECT * rgrcClientPxl, int cRects);
            HRESULT     SetFill(HBRUSH hbrFill, BYTE bAlpha = BLEND_OPAQUE, int w = 0, int h = 0);
            HRESULT     SetFill(Gdiplus::Brush * pgpbr);
            HRESULT     GetRgn(UINT nRgnType, HRGN hrgn, UINT nFlags) const;

    inline  BOOL        IsBuffered() const;
            HRESULT     GetBufferInfo(BUFFER_INFO * pbi) const;
            HRESULT     SetBufferInfo(const BUFFER_INFO * pbi);

#if DBG
    static  void        DEBUG_SetOutline(DuVisual * pgadOutline);
            void        DEBUG_GetStyleDesc(LPWSTR pszDesc, int cchMax) const;
#endif // DBG

            // Messaging and Event Operations
            enum EWantEvent
            {
                weMouseMove     = 0x00000001,   // (Shallow) Mouse move
                weMouseEnter    = 0x00000002,   // Mouse enter and leave
                weDeepMouseMove = 0x00000004,   // (Deep) Mouse move (either me or my children)
                weDeepMouseEnter= 0x00000008,   // (Deep) Mouse enter and leave
            };

    inline  UINT        GetWantEvents() const;
    virtual void        SetFilter(UINT nNewFilter, UINT nMask);

    static  HRESULT     RegisterPropertyNL(const GUID * pguid, PropType pt, PRID * pprid);
    static  HRESULT     UnregisterPropertyNL(const GUID * pguid, PropType pt);

    inline  HRESULT     GetProperty(PRID id, void ** ppValue) const;
    inline  HRESULT     SetProperty(PRID id, void * pValue);
    inline  void        RemoveProperty(PRID id, BOOL fFree);

            // Tickets
            HRESULT     GetTicket(DWORD * pdwTicket);
            void        ClearTicket();
    static  HGADGET     LookupTicket(DWORD dwTicket);

// Internal Implementation
            // Creation / Destruction
protected:
            void        xwBeginDestroy();
            void        xwDestroyAllChildren();

            // Tree management
private:
    inline  void        Link(DuVisual * pgadParent, DuVisual * pgadSibling = NULL, ELinkType lt = ltTop);
    inline  void        Unlink();
    inline  DuVisual *GetKeyboardFocusableAncestor(DuVisual * pgad);

            void        xdUpdatePosition() const;
            void        xdUpdateAdaptors(UINT nCode) const;

            // Painting
protected:
            void        xrDrawStart(PaintInfo * ppi, UINT nFlags);
private:
            void        xrDrawFull(PaintInfo * ppi);
            void        DrawFill(DuSurface * psrf, const RECT * prcDrawPxl);
            void        xrDrawCore(PaintInfo * ppi, const RECT * prcGadgetPxl);
            void        xrDrawTrivial(PaintInfo * ppi, const SIZE sizeOffsetPxl);
            int         DrawPrepareClip(PaintInfo * ppi, const RECT * prcGadgetPxl, void ** ppvOldClip) const;
            void        DrawCleanupClip(PaintInfo * ppi, void * pvOldClip) const;
            void        DrawSetupBufferCommand(const RECT * prcBoundsPxl, SIZE * psizeBufferOffsetPxl, UINT * pnCmd) const;

    inline  BUFFER_INFO *
                        GetBufferInfo() const;
            HRESULT     SetBuffered(BOOL fBuffered);


            enum EUdsHint
            {
                uhNone,         // No hint
                uhTrue,         // A child changed to TRUE
                uhFalse         // A child changed to FALSE
            };

    typedef BOOL        (DuVisual::*DeepCheckNodeProc)() const;
            BOOL        CheckIsTrivial() const;
            BOOL        CheckIsWantMouseFocus() const;
                
    inline  void        UpdateTrivial(EUdsHint hint);
    inline  void        UpdateWantMouseFocus(EUdsHint hint);
            void        UpdateDeepAllState(EUdsHint hint, DeepCheckNodeProc pfnCheck, UINT nStateMask);
            void        UpdateDeepAnyState(EUdsHint hint, DeepCheckNodeProc pfnCheck, UINT nStateMask);


            // Invalidation
private:
            BOOL        IsParentInvalid() const;
            void        DoInvalidateRect(DuContainer * pcon, const RECT * rgrcClientPxl, int cRects);
    inline  void        MarkInvalidChildren();
            void        ResetInvalid();
#if DBG
            void        DEBUG_CheckResetInvalid() const;
#endif // DBG


            // XForms
protected:
            void        BuildXForm(Matrix3 * pmatCur) const;
            void        BuildAntiXForm(Matrix3 * pmatCur) const;
private:
    inline  BOOL        GetEnableXForm() const;
            HRESULT     SetEnableXForm(BOOL fEnable);
            XFormInfo * GetXFormInfo() const;
            void        DoCalcClipEnumXForm(RECT * rgrcFinalClipClientPxl, const RECT * rgrcClientPxl, int cRects) const;
            void        DoXFormClientToParent(RECT * rgrcParentPxl, const RECT * rgrcClientPxl, int cRects, Matrix3::EHintBounds hb) const;
            void        DoXFormClientToParent(POINT * rgptClientPxl, int cPoints) const;
            BOOL        FindStepImpl(const DuVisual * pgadCur, int xOffset, int yOffset, POINT * pptFindPxl) const;

            // Positioning
private:
            void        SLROffsetLogRect(const SIZE * psizeDeltaPxl);
            void        SLRUpdateBits(RECT * prcOldParentPxl, RECT * prcNewParentPxl, UINT nChangeFlags);
            void        SLRInvalidateRects(DuContainer * pcon, const RECT * rgrcClientPxl, int cRects);

#if DBG
public:
    virtual void        DEBUG_AssertValid() const;
#endif // DBG

// Data
protected:
    static  CritLock    s_lockProp;         // Lock for s_ptsProp
    static  AtomSet     s_ptsProp;          // AtomSet for properties
    static  PRID        s_pridXForm;        // PRID: World Transform
    static  PRID        s_pridBackFill;     // PRID: Background Brush
    static  PRID        s_pridBufferInfo;   // PRID: Buffering information
    static  PRID        s_pridTicket;       // PRID: ticket


    //
    // NOTE: This data members are declared in order of importance to help with
    // cache alignment.
    //
    // DuEventGadget:   10 DWORD's       (Debug = 11 DWORD's)
    // TreeNode:        4 DWORD's
    //

            PropSet     m_pds;              // (1D) Dynamic property data set

    union {
            UINT        m_nStyle;           // (1D) Combined style

        struct {
            // Public flags exposed through GetStyle()
            BOOL        m_fRelative:1;      // Relative to parent positioning
            BOOL        m_fVisible:1;       // Visible
            BOOL        m_fEnabled:1;       // Enabled
            BOOL        m_fBuffered:1;      // Sub-tree drawing is buffered
            BOOL        m_fAllowSubclass:1; // Allow subclassing
            BOOL        m_fKeyboardFocus:1; // Can "accept" keyboard focus
            BOOL        m_fMouseFocus:1;    // Can "accept" mouse focus
            BOOL        m_fClipInside:1;    // Clip drawing inside this DuVisual
            BOOL        m_fClipSiblings:1;  // Clip siblings of this DuVisual
            BOOL        m_fHRedraw:1;       // Redraw entire Gadget if resized horizontally
            BOOL        m_fVRedraw:1;       // Redraw entire Gadget if resized vertically
            BOOL        m_fOpaque:1;        // HINT: Drawing is not composited
            BOOL        m_fZeroOrigin:1;    // Set origin to (0,0)
            BOOL        m_fCustomHitTest:1; // Requires custom hit-testing
            BOOL        m_fAdaptor:1;       // Requires extra notifications to host
            BOOL        m_fCached:1;        // Sub-tree drawing is cached
            BOOL        m_fDeepPaintState:1;// Sub-tree has paint state

            // Private flags used internally
            BOOL        m_fRoot:1;          // Root of a subtree (DuRootGadget)
            BOOL        m_fFinalDestroy:1;  // Started destruction of window
            BOOL        m_fDestroyed:1;     // Final stage of destruction
            BOOL        m_fXForm:1;         // Has world-transform information
            BOOL        m_fBackFill:1;      // Has background fill information
            BOOL        m_fTicket:1;        // Has ticket information
            BOOL        m_fDeepTrivial:1;   // Gadget sub-tree has "trivial" painting
            BOOL        m_fDeepMouseFocus:1; // Gadget sub-tree wants mouse focus
            BOOL        m_fInvalidFull:1;   // Gadget has been fully invalidated
            BOOL        m_fInvalidChildren:1; // Gadget has invalid children
#if ENABLE_OPTIMIZEDIRTY
            BOOL        m_fInvalidDirty:1;  // Gadget has been (at least) partially invalidated
#endif

#if DEBUG_MARKDRAWN
            BOOL        m_fMarkDrawn:1;     // DEBUG: Was drawn in last paint
#endif

            UINT        m_we:4;             // Want events
        };
    };

    enum EStyle {
        gspRoot =               0x00020000,
        gspFinalDestroy =       0x00040000,
        gspDestroyed =          0x00080000,
        gspXForm =              0x00100000,
        gspBackFill =           0x00200000,
        gspTicket =             0x00400000,
        gspDeepTrivial =        0x00800000,
        gspDeepMouseFocus =     0x01000000,
        gspInvalidFull =        0x02000000,
        gspInvalidChildren =    0x04000000,
    };

            RECT        m_rcLogicalPxl;     // (4D) Logical location (pixels)

#if DBG_STORE_NAMES
            WCHAR *     m_DEBUG_pszName;    // DEBUG: Name of Gadget
            WCHAR *     m_DEBUG_pszType;    // DEBUG: Type of Gadget
#endif // DBG_STORE_NAMES

#if DBG
    static  DuVisual* s_DEBUG_pgadOutline;// DEBUG: Outline Gadget after drawing
#endif // DBG

    //
    // Current size:    20 DWORD's      (Debug = 21 DWORD's)
    //                  80 bytes        (Debug = 84 bytes)
    //

    friend DuRootGadget;
};


#include "TreeGadget.inl"

#endif // CORE__TreeGadget_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\animation.h ===
#if !defined(CTRL__Animation_h__INCLUDED)
#define CTRL__Animation_h__INCLUDED
#pragma once

#include "Extension.h"

#if ENABLE_MSGTABLE_API

//------------------------------------------------------------------------------
class DuAnimation : 
    public AnimationImpl<DuAnimation, DuExtension>
{
// Construction
public:
    inline  DuAnimation();
            ~DuAnimation();
    static  HRESULT     InitClass();
    static  HRESULT     PreBuild(DUser::Gadget::ConstructInfo * pci);
            HRESULT     PostBuild(DUser::Gadget::ConstructInfo * pci);
            void        Destroy(BOOL fFinal);

// Public API
public:
    dapi    HRESULT     ApiOnRemoveExisting(Animation::OnRemoveExistingMsg * pmsg);
    dapi    HRESULT     ApiOnDestroySubject(Animation::OnDestroySubjectMsg * pmsg);
    dapi    HRESULT     ApiOnAsyncDestroy(Animation::OnAsyncDestroyMsg * pmsg);

    dapi    HRESULT     ApiAddRef(Animation::AddRefMsg *) { AddRef(); return S_OK; }
    dapi    HRESULT     ApiRelease(Animation::ReleaseMsg *) { Release(); return S_OK; }

    dapi    HRESULT     ApiSetTime(Animation::SetTimeMsg * pmsg);

// Implementation
protected:
    static  void CALLBACK
                        RawActionProc(GMA_ACTIONINFO * pmai);
            void        ActionProc(GMA_ACTIONINFO * pmai);

            void        CleanupChangeGadget();

    inline  void        AddRef();
    inline  void        Release(); 

// Data
protected:
    static  MSGID       s_msgidComplete;

            HACTION     m_hact;
            Animation::ETime
                        m_time;         // Time when completed
            UINT        m_cRef;

            Interpolation *
                        m_pipol;
            Flow *      m_pgflow;

            BOOL        m_fStartDestroy:1;
            BOOL        m_fProcessing:1;

#if DBG
            UINT        m_DEBUG_cUpdates;
#endif
};


#endif // ENABLE_MSGTABLE_API

#include "Animation.inl"

#endif // CTRL__Animation_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\core\treegadgetp.h ===
/***************************************************************************\
*
* File: TreeGadgetP.h
*
* Description:
* TreeGadgetP.h includes private definitions used internally to the 
* DuVisual class.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/

#if !defined(CORE__TreeGadgetP_h__INCLUDED)
#define CORE__TreeGadgetP_h__INCLUDED

//
// XFormInfo contains information about GDI World Transforms for a specific
// DuVisual.
//

inline bool IsZero(float fl)
{
    return (fl < 0.00001f) && (fl > -0.00001f);
}

struct XFormInfo
{
    float       flScaleX;           // Horizontal scaling factor
    float       flScaleY;           // Vertical scaling factor
    float       flCenterX;          // Horizontal center-point
    float       flCenterY;          // Vertical center-point
    float       flRotationRad;      // Rotation around upper left corner in radians

    inline bool IsEmpty() const
    {
        return IsZero(flScaleX - 1.0f) && 
                IsZero(flScaleY - 1.0f) && 
                IsZero(flCenterX) && 
                IsZero(flCenterY) &&
                IsZero(flRotationRad);
    }

    void Apply(Matrix3 * pmat)
    {
        pmat->Translate(flCenterX, flCenterY);
        pmat->Rotate(flRotationRad);
        pmat->Scale(flScaleX, flScaleY);
        pmat->Translate(-flCenterX, -flCenterY);
    }

    void ApplyAnti(Matrix3 * pmat)
    {
        pmat->Translate(flCenterX, flCenterY);
        pmat->Scale(1.0f / flScaleX, 1.0f / flScaleY);
        pmat->Rotate(-flRotationRad);
        pmat->Translate(-flCenterX, -flCenterY);
    }
};


//
// FillInfo holds information used for filling the background with the
// specified brush.
//

struct FillInfo
{
    DuSurface::EType type;          // Surface type for brush
    union
    {
        struct
        {
            HBRUSH      hbrFill;        // (Background) fill brush
            BYTE        bAlpha;         // Use background brush for alpha on front
            SIZE        sizeBrush;      // Size of fill brush
        };
        struct
        {
            Gdiplus::Brush *
                        pgpbr;          // (Background) fill brush
        };
    };
};


//
// PaintInfo holds information used for painting requests
//

struct PaintInfo
{
    const RECT *    prcCurInvalidPxl;   // Invalid rectangle in XForm'ed coordinates
    const RECT *    prcOrgInvalidPxl;   // Original invalid rectangle in container coordinates
    DuSurface *     psrf;               // Surface to draw into
    Matrix3 *       pmatCurInvalid;     // Current invalid transformation matrix
    Matrix3 *       pmatCurDC;          // Current DC transformation matrix
    BOOL            fBuffered;          // Subtree drawing is being buffered
#if ENABLE_OPTIMIZEDIRTY
    BOOL            fDirty;             // Dirty state
#endif
    SIZE            sizeBufferOffsetPxl; // Forced offset b/c of Buffer
};


//
// Invalidation should edge outside any boundaries to ensure that the pixels
// on the edge are included in the invalidation.
//
// Clipping should edge inside any boundaries to ensure that pixels on the edge
// are not included.
//
// This is VERY important to setup correctly because of GDI world 
// transformations and rounding errors converting from floats to ints and back.
//

const Matrix3::EHintBounds  HINTBOUNDS_Invalidate = Matrix3::hbOutside;
const Matrix3::EHintBounds  HINTBOUNDS_Clip = Matrix3::hbInside;

#endif // CORE__TreeGadgetP_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\animation.inl ===
#if !defined(CTRL__Animation_inl__INCLUDED)
#define CTRL__Animation_inl__INCLUDED
#pragma once

#if ENABLE_MSGTABLE_API

#define DEBUG_TRACECREATION         0   // Trace Creation and destruction of animations

/***************************************************************************\
*****************************************************************************
*
* class DuAnimation
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline 
DuAnimation::DuAnimation()
{
    m_cRef = 1;
    m_time = Animation::tComplete;  // By default, completes normally

#if DEBUG_TRACECREATION
    Trace("START Animation  0x%p    @ %d\n", this, GetTickCount());
#endif // DEBUG_TRACECREATION
}


//------------------------------------------------------------------------------
inline void
DuAnimation::AddRef()
{ 
    ++m_cRef; 
}


//------------------------------------------------------------------------------
inline void
DuAnimation::Release() 
{ 
    if (--m_cRef == 0) 
        Delete(); 
}


#endif // ENABLE_MSGTABLE_API

#endif // CTRL__Animation_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\ctrlstubs.cpp ===
#include "stdafx.h"
#include "Ctrl.h"

#define GADGET_ENABLE_CONTROLS

#include "OldInterpolation.h"
#include "OldAnimation.h"
#include "OldDragDrop.h"

inline void SetError(HRESULT hr)
{
    SetLastError((DWORD) hr);
}


//------------------------------------------------------------------------------
DUSER_API BOOL WINAPI
BuildInterpolation(UINT nIPolID, int nVersion, REFIID riid, void ** ppvUnk)
{
    if (nVersion != 0) {
        SetError(E_INVALIDARG);
        return FALSE;
    }

    HRESULT hr = E_INVALIDARG;

    switch (nIPolID) 
    {
    case INTERPOLATION_LINEAR:
        hr = OldInterpolationT<OldLinearInterpolation, ILinearInterpolation>::Build(riid, ppvUnk);
        break;

    case INTERPOLATION_LOG:
        hr = OldInterpolationT<OldLogInterpolation, ILogInterpolation>::Build(riid, ppvUnk);
        break;

    case INTERPOLATION_EXP:
        hr = OldInterpolationT<OldExpInterpolation, IExpInterpolation>::Build(riid, ppvUnk);
        break;

    case INTERPOLATION_S:
        hr = OldInterpolationT<OldSInterpolation, ISInterpolation>::Build(riid, ppvUnk);
        break;
    }

    if (SUCCEEDED(hr)) {
        return TRUE;
    } else {
        SetError(hr);
        return FALSE;
    }
}


//------------------------------------------------------------------------------
DUSER_API BOOL WINAPI
BuildAnimation(UINT nAniID, int nVersion, GANI_DESC * pDesc, REFIID riid, void ** ppvUnk)
{
    HRESULT hr = E_INVALIDARG;
    if (nVersion != 0) {
        goto Error;
    }
    if (ppvUnk == NULL) {
        goto Error;
    }

    switch (nAniID) 
    {
    case ANIMATION_ALPHA:
        hr = OldAnimationT<OldAlphaAnimation, IAnimation, GANI_ALPHADESC>::Build(pDesc, riid, ppvUnk);
        break;

    case ANIMATION_SCALE:
        hr = OldAnimationT<OldScaleAnimation, IAnimation, GANI_SCALEDESC>::Build(pDesc, riid, ppvUnk);
        break;

    case ANIMATION_RECT:
        hr = OldAnimationT<OldRectAnimation, IAnimation, GANI_RECTDESC>::Build(pDesc, riid, ppvUnk);
        break;

    case ANIMATION_ROTATE:
        hr = OldAnimationT<OldRotateAnimation, IAnimation, GANI_ROTATEDESC>::Build(pDesc, riid, ppvUnk);
        break;
    }

    if (SUCCEEDED(hr)) {
        return TRUE;
    } else {
Error:
        SetError(hr);
        return FALSE;
    }
}


//------------------------------------------------------------------------------
DUSER_API BOOL WINAPI
GetGadgetAnimation(HGADGET hgad, UINT nAniID, REFIID riid, void ** ppvUnk)
{
    HRESULT hr = E_INVALIDARG;
    if (hgad == NULL) {
        goto Error;
    }
    if (ppvUnk == NULL) {
        goto Error;
    }

    switch (nAniID) 
    {
    case ANIMATION_ALPHA:
        hr = OldAnimationT<OldAlphaAnimation, IAnimation, GANI_ALPHADESC>::GetInterface(hgad, riid, ppvUnk);
        break;

    case ANIMATION_SCALE:
        hr = OldAnimationT<OldScaleAnimation, IAnimation, GANI_SCALEDESC>::GetInterface(hgad, riid, ppvUnk);
        break;

    case ANIMATION_RECT:
        hr = OldAnimationT<OldRectAnimation, IAnimation, GANI_RECTDESC>::GetInterface(hgad, riid, ppvUnk);
        break;

    case ANIMATION_ROTATE:
        hr = OldAnimationT<OldRotateAnimation, IAnimation, GANI_ROTATEDESC>::GetInterface(hgad, riid, ppvUnk);
        break;
    }

    if (SUCCEEDED(hr)) {
        return TRUE;
    } else {
Error:
        SetError(hr);
        return FALSE;
    }
}


//------------------------------------------------------------------------------
DUSER_API BOOL WINAPI
BuildDropTarget(HGADGET hgadRoot, HWND hwnd)
{
    HRESULT hr = E_INVALIDARG;
    hgadRoot = GetGadget(hgadRoot, GG_ROOT);  // Ensure root

    if ((hgadRoot == NULL) || (!IsWindow(hwnd))) {
        goto Error;
    }

    OldDropTarget * pdt;
    hr = OldDropTarget::Build(hgadRoot, hwnd, &pdt);
    if (SUCCEEDED(hr)) {
        return TRUE;
    }

Error:
    SetError(hr);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\ctrl.h ===
/***************************************************************************\
*
* File: Ctrl.h
*
* Description:
* This file provides a project-wide header that is included in all source 
* files specific to this project.  It is similar to a precompiled header, 
* but is designed for more rapidly changing headers.
*
* The primary purpose of this file is to determine which DirectUser 
* projects this project has direct access to instead of going through public
* API's.  It is VERY IMPORTANT that this is as minimal as possible since
* adding a new project unnecessarily reduces the benefit of project 
* partitioning.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(CTRL___Ctrl_h__INCLUDED)
#define CTRL___Ctrl_h__INCLUDED

#define GADGET_ENABLE_DX
#define GADGET_ENABLE_COM
#define GADGET_ENABLE_OLE
#define GADGET_ENABLE_TRANSITIONS   // Actions
#include <DUser.h>
#include <DUserCtrl.h>

#include <DUserBaseP.h>
#include <DUserObjectAPIP.h>
#include <DUserServicesP.h>

#if DBG

#define PromptInvalid(comment) \
    do \
    { \
        if (IDebug_Prompt(GetDebug(), "Validation error:\r\n" comment, __FILE__, __LINE__, "DirectUser/Ctrl Notification")) \
            AutoDebugBreak(); \
    } while (0) \

#else // DBG

#define PromptInvalid(comment) ((void) 0)

#endif // DBG

#endif // CTRL___Ctrl_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\dragdrop.h ===
/***************************************************************************\
*
* File: DragDrop.h
*
* Description:
* DragDrop.h defines drag and drop operations
*
*
* History:
*  7/31/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/

#if !defined(CORE__DragDrop_h__INCLUDED)
#define CORE__DragDrop_h__INCLUDED
#pragma once

#if ENABLE_MSGTABLE_API

#include "Extension.h"

class TargetLock;

#if 1

class DuDropTarget : 
        public DropTargetImpl<DuDropTarget, DuExtension>,
        public IDropTarget
{
protected:
    inline  DuDropTarget();
            ~DuDropTarget();
public:
    static  HRESULT     InitClass();

// IDropTarget
public:
    STDMETHOD(DragEnter)(IDataObject * pdoSrc, DWORD grfKeyState, POINTL ptDesktopPxl, DWORD * pdwEffect);
    STDMETHOD(DragOver)(DWORD grfKeyState, POINTL ptDesktopPxl, DWORD * pdwEffect);
    STDMETHOD(DragLeave)();
    STDMETHOD(Drop)(IDataObject * pdoSrc, DWORD grfKeyState, POINTL ptDesktopPxl, DWORD * pdwEffect);

// Public API
public:
    dapi    HRESULT     ApiOnDestroySubject(DropTarget::OnDestroySubjectMsg * pmsg);

    static  HRESULT CALLBACK
                        PromoteDropTarget(DUser::ConstructProc pfnCS, HCLASS hclCur, DUser::Gadget * pgad, DUser::Gadget::ConstructInfo * pmicData);

    static  HCLASS CALLBACK
                        DemoteDropTarget(HCLASS hclCur, DUser::Gadget * pgad, void * pvData);

// Implementation
protected:
    inline  BOOL        HasSource() const;
    inline  BOOL        HasTarget() const;

            HRESULT     xwDragScan(POINTL ptDesktopPxl, DWORD * pdwEffect, POINT * pptClientPxl);
            HRESULT     xwUpdateTarget(POINT ptContainerPxl, DWORD * pdwEffect, POINT * pptClientPxl);
            HRESULT     xwUpdateTarget(Visual * pgvFound, DWORD * pdwEffect, POINT * pptClientPxl);
            HRESULT     xwDragEnter(POINT * pptClientPxl, DWORD * pdwEffect);
            void        xwDragLeave();

// Data
protected:
    static  const IID * s_rgpIID[];
            IDropTarget *
                        m_pdtCur;               // Current Gadget DuDropTarget
            IDataObject *
                        m_pdoSrc;               // Source's data object
            HWND        m_hwnd;                 // Containing HWND
            DWORD       m_grfLastKeyState;      // Last key state
            POINT       m_ptLastContainerPxl;   // Last container pixel
            Visual *    m_pgvDrop;              // Current DuDropTarget
    static  PRID        s_pridListen;           // PRID for DuDropTarget

    friend class TargetLock;
};


class TargetLock
{
public:
    inline  TargetLock();
    inline  ~TargetLock();
            BOOL        Lock(DuDropTarget * p, DWORD * pdwEffect, BOOL fAddRef = TRUE);

protected:
            IUnknown *      m_punk;
            BOOL            m_fAddRef;
};

#endif // ENABLE_MSGTABLE_API

#endif

#include "DragDrop.inl"

#endif // CORE__DragDrop_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\dragdrop.inl ===
#if !defined(CORE__DragDrop_inl__INCLUDED)
#define CORE__DragDrop_inl__INCLUDED
#pragma once

#if 1

#if ENABLE_MSGTABLE_API

/***************************************************************************\
*****************************************************************************
*
* class TargetLock
* 
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline
TargetLock::TargetLock()
{
    
}


//------------------------------------------------------------------------------
inline
TargetLock::~TargetLock() 
{
    if (m_fAddRef) {
        m_punk->Release();
    }
}


/***************************************************************************\
*****************************************************************************
*
* class DuDropTarget
* 
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline 
DuDropTarget::DuDropTarget()
{

}


//------------------------------------------------------------------------------
inline BOOL
DuDropTarget::HasSource() const
{
    return m_pdoSrc != NULL;
}


//------------------------------------------------------------------------------
inline BOOL
DuDropTarget::HasTarget() const
{
    return m_pdtCur != NULL;
}

#endif // ENABLE_MSGTABLE_API

#endif

#endif // CORE__DragDrop_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\dragdrop.cpp ===
/***************************************************************************\
*
* File: DragDrop.cpp
*
* Description:
* DragDrop.cpp implements drag and drop operations
*
*
* History:
*  7/31/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/

#include "stdafx.h"
#include "Ctrl.h"
#include "DragDrop.h"

#include <SmObject.h>

#if 1

#if ENABLE_MSGTABLE_API

static const GUID guidDropTarget = { 0x6a8bb3c8, 0xcbfc, 0x40d1, { 0x98, 0x1e, 0x3f, 0x8a, 0xaf, 0x99, 0x13, 0x7b } };  // {6A8BB3C8-CBFC-40d1-981E-3F8AAF99137B}

/***************************************************************************\
*****************************************************************************
*
* class TargetLock
*
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* TargetLock::Lock
*
* Lock() prepares for executing inside the Context when being called back
* from OLE's IDropTarget that was registered.
*
\***************************************************************************/

BOOL 
TargetLock::Lock(
    IN  DuDropTarget * p,           // DuDropTarget being used
    OUT DWORD * pdwEffect,          // Resulting DROPEFFECT if failure
    IN  BOOL fAddRef)               // Lock DT during use
{
    m_fAddRef   = fAddRef;
    m_punk      = static_cast<IUnknown *> (p);

    if (m_fAddRef) {
        m_punk->AddRef();
    }

    if (p->m_pgvSubject == NULL) {
        if (pdwEffect != NULL) {
            *pdwEffect = DROPEFFECT_NONE;
        }
        return FALSE;
    }

    return TRUE;
}

    
/***************************************************************************\
*****************************************************************************
*
* class DuDropTarget
* 
* NOTE: With the current design and implementation, DuDropTarget can not be 
* "removed" from an object until the object is destroyed.  If this needs to 
* change, we need to revisit this.
* 
*****************************************************************************
\***************************************************************************/

const IID * DuDropTarget::s_rgpIID[] =
{
    &__uuidof(IUnknown),
    &__uuidof(IDropTarget),
    NULL
};

PRID DuDropTarget::s_pridListen = 0;


//
// NOTE: We are calling back directly on the IDropTarget's, so we need to grab
// a read-only lock so that the tree doesn't get smashed.
//

/***************************************************************************\
*
* DuDropTarget::~DuDropTarget
*
* ~DuDropTarget() cleans up resources used by the DuDropTarget.
*
\***************************************************************************/

DuDropTarget::~DuDropTarget()
{
    TargetLock lt;
    lt.Lock(this, NULL, FALSE);
    xwDragLeave();
    SafeRelease(m_pdoSrc);
}


//------------------------------------------------------------------------------
HRESULT
DuDropTarget::InitClass()
{
    s_pridListen = RegisterGadgetProperty(&guidDropTarget);
    return s_pridListen != 0 ? S_OK : (HRESULT) GetLastError();
}


typedef SmObjectT<DuDropTarget, IDropTarget> DuDropTargetObj;

//------------------------------------------------------------------------------
HRESULT CALLBACK
DuDropTarget::PromoteDropTarget(DUser::ConstructProc pfnCS, HCLASS hclCur, DUser::Gadget * pgad, DUser::Gadget::ConstructInfo * pmicData)
{
    HRESULT hr;

    DropTarget::DropCI * pciD = (DropTarget::DropCI *) pmicData;

    //
    // Check parameters
    //

    Visual * pgvRoot;
    if (pciD->pgvRoot == NULL) {
        return E_INVALIDARG;
    }

    hr = pciD->pgvRoot->GetGadget(GG_ROOT, &pgvRoot);
    if (FAILED(hr)) {
        return hr;
    }

    if ((pgvRoot == NULL) || (!IsWindow(pciD->hwnd))) {
        return E_INVALIDARG;
    }


    //
    // Setup a new DuDropTarget on this Gadget / HWND.
    //

    if (!GetComManager()->Init(ComManager::sOLE)) {
        return E_OUTOFMEMORY;
    }

    hr = (pfnCS)(DUser::Gadget::ccSuper, s_hclSuper, pgad, pmicData);
    if (FAILED(hr)) {
        return hr;
    }

    SmObjectT<DuDropTarget, IDropTarget> * pdt = new SmObjectT<DuDropTarget, IDropTarget>;
    if (pdt == NULL) {
        return NULL;
    }

    hr = (pfnCS)(DUser::Gadget::ccSetThis, hclCur, pgad, pdt);
    if (FAILED(hr)) {
        return hr;
    }

    pdt->m_hwnd = pciD->hwnd;
    pdt->m_pgad = pgad;
    pdt->AddRef();

    hr = GetComManager()->RegisterDragDrop(pciD->hwnd, static_cast<IDropTarget *> (pdt));
    if (FAILED(hr)) {
        pdt->Release();
        return hr;
    }
    //CoLockObjectExternal(pdt, TRUE, FALSE);


    hr = pdt->Create(pgvRoot, s_pridListen, DuExtension::oUseExisting);
    if ((hr == DU_S_ALREADYEXISTS) || FAILED(hr)) {
        GetComManager()->RevokeDragDrop(pciD->hwnd);
        pdt->Release();
        return hr;
    }

    return S_OK;
}


//------------------------------------------------------------------------------
HCLASS CALLBACK
DuDropTarget::DemoteDropTarget(HCLASS hclCur, DUser::Gadget * pgad, void * pvData)
{
    UNREFERENCED_PARAMETER(hclCur);
    UNREFERENCED_PARAMETER(pgad);

    DuDropTargetObj * pc = reinterpret_cast<DuDropTargetObj *> (pvData);
    delete pc;

    return DuDropTargetObj::s_hclSuper;
}


/***************************************************************************\
*
* DuDropTarget::DragEnter
*
* DragEnter() is called by OLE when entering the DT.
*
\***************************************************************************/

STDMETHODIMP
DuDropTarget::DragEnter(
    IN  IDataObject * pdoSrc,       // Source data
    IN  DWORD grfKeyState,          // Keyboard modifiers
    IN  POINTL ptDesktopPxl,        // Cursor location on desktop
    OUT DWORD * pdwEffect)          // Resulting DROPEFFECT
{
    if (pdoSrc == NULL) {
        return E_INVALIDARG;
    }

    TargetLock tl;
    if (!tl.Lock(this, pdwEffect)) {
        return S_OK;
    }


    //
    // Cache the DataObject.
    //

    SafeRelease(m_pdoSrc);
    if (pdoSrc != NULL) {
        pdoSrc->AddRef();
        m_pdoSrc = pdoSrc;
    }

    m_grfLastKeyState = grfKeyState;

    POINT ptClientPxl;
    return xwDragScan(ptDesktopPxl, pdwEffect, &ptClientPxl);
}


/***************************************************************************\
*
* DuDropTarget::DragOver
*
* DragOver() is called by OLE during the drag operation to give feedback 
* while inside the DT.
*
\***************************************************************************/

STDMETHODIMP
DuDropTarget::DragOver(
    IN  DWORD grfKeyState,          // Keyboard modifiers
    IN  POINTL ptDesktopPxl,        // Cursor location on desktop
    OUT DWORD * pdwEffect)          // Resulting DROPEFFECT
{
    TargetLock tl;
    if (!tl.Lock(this, pdwEffect)) {
        return S_OK;
    }

    m_grfLastKeyState = grfKeyState;

    POINT ptClientPxl;
    return xwDragScan(ptDesktopPxl, pdwEffect, &ptClientPxl);
}


/***************************************************************************\
*
* DuDropTarget::DragLeave
*
* DragLeave() is called by OLE when leaving the DT.
*
\***************************************************************************/

STDMETHODIMP
DuDropTarget::DragLeave()
{
    TargetLock tl;
    if (!tl.Lock(this, NULL)) {
        return S_OK;
    }

    xwDragLeave();
    SafeRelease(m_pdoSrc);

    return S_OK;
}


/***************************************************************************\
*
* DuDropTarget::Drop
*
* Drop() is called by OLE when the user has dropped while inside DT.
*
\***************************************************************************/

STDMETHODIMP
DuDropTarget::Drop(
    IN  IDataObject * pdoSrc,       // Source data
    IN  DWORD grfKeyState,          // Keyboard modifiers
    IN  POINTL ptDesktopPxl,        // Cursor location on desktop
    OUT DWORD * pdwEffect)          // Resulting DROPEFFECT
{
    TargetLock tl;
    if (!tl.Lock(this, pdwEffect)) {
        return S_OK;
    }

    if (!HasTarget()) {
        *pdwEffect = DROPEFFECT_NONE;
        return S_OK;
    }

    m_grfLastKeyState = grfKeyState;


    //
    // Update to get the latest Gadget information.
    //

    POINT ptClientPxl;
    HRESULT hr = xwDragScan(ptDesktopPxl, pdwEffect, &ptClientPxl);
    if (FAILED(hr) || (*pdwEffect == DROPEFFECT_NONE)) {
        return hr;
    }

    AssertMsg(HasTarget(), "Must have a target if UpdateTarget() succeeds");


    //
    // Now that the state has been updated, execute the actual drop.
    //

    POINTL ptDrop = { ptClientPxl.x, ptClientPxl.y };
    m_pdtCur->Drop(pdoSrc, m_grfLastKeyState, ptDrop, pdwEffect);

    xwDragLeave();
    SafeRelease(m_pdoSrc);

    return S_OK;
}


/***************************************************************************\
*
* DuDropTarget::xwDragScan
*
* xwDragScan() is called from the various IDropTarget methods to process
* a request coming from outside.
*
\***************************************************************************/

HRESULT
DuDropTarget::xwDragScan(
    IN  POINTL ptDesktopPxl,        // Cursor location on desktop
    OUT DWORD * pdwEffect,          // Resulting DROPEFFECT
    OUT POINT * pptClientPxl)       // Cursor location in client
{
    POINT ptContainerPxl;
    RECT rcDesktopPxl;

    GetClientRect(m_hwnd, &rcDesktopPxl);
    ClientToScreen(m_hwnd, (LPPOINT) &(rcDesktopPxl.left));

    ptContainerPxl.x = ptDesktopPxl.x - rcDesktopPxl.left;
    ptContainerPxl.y = ptDesktopPxl.y - rcDesktopPxl.top;;

    return xwUpdateTarget(ptContainerPxl, pdwEffect, pptClientPxl);
}

    
/***************************************************************************\
*
* DuDropTarget::xwUpdateTarget
*
* xwUpdateTarget() provides the "worker" of DropTarget, updating 
* Enter, Leave, and Over information for the Gadgets in the tree.
*
\***************************************************************************/

HRESULT
DuDropTarget::xwUpdateTarget(
    IN  POINT ptContainerPxl,       // Cursor location in container
    OUT DWORD * pdwEffect,          // Resulting DROPEFFECT
    OUT POINT * pptClientPxl)       // Cursor location in client
{
    AssertMsg(HasSource(), "Only call when have valid data source");
    AssertWritePtr(pdwEffect);
    AssertWritePtr(pptClientPxl);

    m_ptLastContainerPxl = ptContainerPxl;

    //
    // Determine the Gadget that is currently at the drop location.  We use this
    // as a starting point.
    //

    Visual * pgvFound = NULL;
    m_pgvSubject->FindFromPoint(ptContainerPxl, GS_VISIBLE | GS_ENABLED, pptClientPxl, &pgvFound);
    if (pgvFound == NULL) {
        *pdwEffect = DROPEFFECT_NONE;
        return S_OK;
    }

    return xwUpdateTarget(pgvFound, pdwEffect, pptClientPxl);
}


/***************************************************************************\
*
* DuDropTarget::xwUpdateTarget
*
* xwUpdateTarget() provides the "worker" of DropTarget, updating 
* Enter, Leave, and Over information for the Gadgets in the tree.
*
\***************************************************************************/

HRESULT
DuDropTarget::xwUpdateTarget(
    IN  Visual * pgvFound,          // Visual Gadget getting Drop
    OUT DWORD * pdwEffect,          // Resulting DROPEFFECT
    IN  POINT * pptClientPxl)       // Cursor location in client
{
    HRESULT hr = S_OK;


    //
    // Check if the drop Gadget has changed.
    //

    if ((pgvFound != NULL) && (pgvFound != m_pgvDrop)) {
        //
        // Ask the new Gadget if he wants to participate in Drag & Drop.
        //

        GMSG_QUERYDROPTARGET msg;
        ZeroMemory(&msg, sizeof(msg));
        msg.cbSize  = sizeof(msg);
        msg.nMsg    = GM_QUERY;
        msg.nCode   = GQUERY_DROPTARGET;
        msg.hgadMsg = DUserCastHandle(pgvFound);

        static int s_cSend = 0;
        Trace("Send Query: %d to 0x%p\n", s_cSend++, pgvFound);

        Visual * pgvNewDrop;
        HRESULT hr = DUserSendEvent(&msg, SGM_FULL);
        if (SUCCEEDED(hr) && (hr != DU_S_NOTHANDLED)) {
            pgvNewDrop = Visual::Cast(msg.hgadDrop);
            if ((pgvNewDrop != NULL) && (msg.pdt != NULL)) {
                if (pgvNewDrop != pgvFound) {
                    //
                    // The message returned a different to handle the DnD request,
                    // so we need to re-adjust.  We know that this Gadget is enabled
                    // and visible since it is in our parent chain and we are already
                    // enabled and visible.
                    //

#if DBG
                    BOOL fChain = FALSE;
                    pgvNewDrop->IsParentChainStyle(GS_VISIBLE | GS_ENABLED, &fChain, 0);
                    if (!fChain) {
                        Trace("WARNING: DUser: DropTarget: Parent chain for 0x%p is not fully visible and enabled.\n", pgvNewDrop);
                    }
#endif

                    pgvFound->MapPoints(pgvNewDrop, pptClientPxl, 1);
                }
            }
        } else {
            pgvNewDrop  = NULL;
            msg.pdt     = NULL;
        }


        //
        // Notify the old Gadget that the Drag operation has left him.
        // Update to new state
        // Notify the new Gadget that the Drag operation has entered him.
        //

        if (m_pgvDrop != pgvNewDrop) {
            xwDragLeave();

            m_pgvDrop   = pgvNewDrop;
            m_pdtCur    = msg.pdt;

            hr = xwDragEnter(pptClientPxl, pdwEffect);
            if (FAILED(hr) || (*pdwEffect == DROPEFFECT_NONE)) {
                goto Exit;
            }
        } else {
            SafeRelease(msg.pdt);
            *pdwEffect = DROPEFFECT_NONE;
        }
    }


    //
    // Update the DropTarget
    //

    if (HasTarget()) {
        POINTL ptDrop = { pptClientPxl->x, pptClientPxl->y };
        hr = m_pdtCur->DragOver(m_grfLastKeyState, ptDrop, pdwEffect);
    }

Exit:
    AssertMsg(FAILED(hr) || 
            ((*pdwEffect == DROPEFFECT_NONE) && !HasTarget()) ||
            HasTarget(),
            "Check valid return state");

    return hr;
}


/***************************************************************************\
*
* DuDropTarget::xwDragEnter
*
* xwDragEnter() is called when entering a new Gadget during a DnD operation.
*
\***************************************************************************/

HRESULT
DuDropTarget::xwDragEnter(
    IN OUT POINT * pptClientPxl,    // Client location (updated)
    OUT DWORD * pdwEffect)          // Resulting DROPEFFECT
{
    AssertMsg(HasSource(), "Only call when have valid data source");

    //
    // Notify the new Gadget that the drop has entered him.
    //

    if (HasTarget()) {
        POINTL ptDrop = { pptClientPxl->x, pptClientPxl->y };
        HRESULT hr = m_pdtCur->DragEnter(m_pdoSrc, m_grfLastKeyState, ptDrop, pdwEffect);
        if (FAILED(hr)) {
            return hr;
        }
    } else {
        *pdwEffect = DROPEFFECT_NONE;
    }

    return S_OK;
}


/***************************************************************************\
*
* DuDropTarget::xwDragLeave
*
* xwDragLeave() is called when leaving a Gadget during a DnD operation.
*
\***************************************************************************/

void
DuDropTarget::xwDragLeave()
{
    if (HasTarget()) {
        m_pdtCur->DragLeave();
        m_pdtCur->Release();
        m_pdtCur = NULL;

        m_pgvDrop = NULL;
    }
}


//------------------------------------------------------------------------------
HRESULT
DuDropTarget::ApiOnDestroySubject(DropTarget::OnDestroySubjectMsg * pmsg)
{
    UNREFERENCED_PARAMETER(pmsg);
    
    if (IsWindow(m_hwnd)) {
        GetComManager()->RevokeDragDrop(m_hwnd);
    }

    //CoLockObjectExternal(pdt, FALSE, TRUE);
    DuExtension::DeleteHandle();

    return S_OK;
}

#endif

#endif // ENABLE_MSGTABLE_API
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\extension.inl ===
#if !defined(CTRL__Extension_inl__INCLUDED)
#define CTRL__Extension_inl__INCLUDED
#pragma once

#if ENABLE_MSGTABLE_API

//------------------------------------------------------------------------------
inline DuExtension::DuExtension()
{

}

#endif // ENABLE_MSGTABLE_API

#endif // CTRL__Extension_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\extension.cpp ===
#include "stdafx.h"
#include "Ctrl.h"
#include "Extension.h"

#if ENABLE_MSGTABLE_API

/***************************************************************************\
*****************************************************************************
*
* class DuExtension
*
*****************************************************************************
\***************************************************************************/

static const GUID guidAysncDestroy      = { 0xbfe02331, 0xc17d, 0x45ea, { 0x96, 0x35, 0xa0, 0x7a, 0x90, 0x37, 0xfe, 0x34 } };   // {BFE02331-C17D-45ea-9635-A07A9037FE34}
MSGID       DuExtension::s_msgidAsyncDestroy = 0;

/***************************************************************************\
*
* DuExtension::~DuExtension
*
* ~DuExtension() checks that resources were properly cleaned up before the
* DuExtension was destroyed.
*
\***************************************************************************/

DuExtension::~DuExtension()
{
    //
    // Ensure proper destruction
    //

}


//------------------------------------------------------------------------------
HRESULT
DuExtension::InitClass()
{
    s_msgidAsyncDestroy = RegisterGadgetMessage(&guidAysncDestroy);
    return s_msgidAsyncDestroy != 0 ? S_OK : (HRESULT) GetLastError();
}


/***************************************************************************\
*
* DuExtension::Create
*
* Create() initializes a new DuExtension and attaches it to the subject Gadget
* being modified.
*
\***************************************************************************/

HRESULT
DuExtension::Create(
    IN  Visual * pgvSubject,            // Gadget being "extended"
    IN  PRID pridExtension,             // Short ID for DuExtension
    IN  UINT nOptions)                  // Options
{
    AssertMsg(pridExtension > 0, "Must have valid PRID");


    //
    // Do not allow attaching a DuExtension to a Gadget that has already started 
    // the destruction process.
    //

    HGADGET hgadSubject = DUserCastHandle(pgvSubject);

    BOOL fStartDelete;
    if ((!IsStartDelete(hgadSubject, &fStartDelete)) || fStartDelete) {
        return DU_E_STARTDESTROY;
    }


    //
    // Setup options
    //

    m_fAsyncDestroy = TestFlag(nOptions, oAsyncDestroy);


    //
    // Determine if this DuExtension is already attached to the Gadget being 
    // extended.
    //

    DuExtension * pbExist;
    if (SUCCEEDED(pgvSubject->GetProperty(pridExtension, (void **) &pbExist))) {
        AssertMsg(pbExist != NULL, "Existing Extension must not be NULL");
        if (TestFlag(nOptions, oUseExisting)) {
            return DU_S_ALREADYEXISTS;
        } else {
            //
            // Already attached, but can't use the existing one.  We need to
            // remove the existing DuExtension before attaching the new one.  
            // After calling RemoveExisting(), the DuExtension should no longer 
            // be attached to the Gadget.
            //

            pbExist->GetStub()->OnRemoveExisting();
            Assert(FAILED(pgvSubject->GetProperty(pridExtension, (void **) &pbExist)));
        }
    }


    //
    // Setup a listener to be notifyed when the RootGadget is destroyed.
    //

    HRESULT hr      = S_OK;
    m_pgvSubject    = pgvSubject;
    m_pridListen    = pridExtension;

    if (FAILED(pgvSubject->SetProperty(pridExtension, this)) || 
            FAILED(pgvSubject->AddHandlerG(GM_DESTROY, GetStub()))) {

        hr = E_OUTOFMEMORY;
        goto Error;
    }


    //
    // Successfully created the DuExtension
    //

    return S_OK;

Error:
    return hr;
}


/***************************************************************************\
*
* DuExtension::Destroy
*
* Destroy() is called from the derived class to cleanup resources associated
* with the DuExtension.
*
\***************************************************************************/

void
DuExtension::Destroy()
{
    //
    // Since the DuExtension is being destroyed, need to ensure that it is no 
    // longer "attached" to the Gadget being extended
    //

    if ((m_pridListen != 0) && (m_pgvSubject != NULL)) {
        DuExtension * pb;
        if (SUCCEEDED(m_pgvSubject->GetProperty(m_pridListen, (void **) &pb))) {
            if (pb == this) {
                m_pgvSubject->RemoveProperty(m_pridListen);
            }
        }
    }

    Delete();
}


/***************************************************************************\
*
* DuExtension::DeleteHandle
*
* DeleteHandle() starts the destruction process for the DuExtension.
*
\***************************************************************************/

void
DuExtension::DeleteHandle()
{
    Delete();
}


//------------------------------------------------------------------------------
HRESULT
DuExtension::ApiOnEvent(EventMsg * pmsg)
{
    switch (GET_EVENT_DEST(pmsg))
    {
    case GMF_DIRECT:
        if (m_fAsyncDestroy && (pmsg->nMsg == s_msgidAsyncDestroy)) {
            GetStub()->OnAsyncDestroy();
            return DU_S_PARTIAL;
        }
        break;

    case GMF_EVENT:
        if (pmsg->nMsg == GM_DESTROY) {
            if (((GMSG_DESTROY *) pmsg)->nCode == GDESTROY_FINAL) {
                GetStub()->OnDestroySubject();
                return DU_S_PARTIAL;
            }
        }
        break;
    }

    return SListener::ApiOnEvent(pmsg);
}


/***************************************************************************\
*
* DuExtension::ApiOnRemoveExisting
*
* ApiOnRemoveExisting() is called when creating a new DuExtension to remove 
* an existing DuExtension already attached to the subject Gadget.
*
\***************************************************************************/

HRESULT
DuExtension::ApiOnRemoveExisting(Extension::OnRemoveExistingMsg *)
{
    return S_OK;
}


/***************************************************************************\
*
* DuExtension::ApiOnDestroySubject
*
* ApiOnDestroySubject() notifies the derived DuExtension that the subject 
* Gadget being modified has been destroyed.
*
\***************************************************************************/

HRESULT
DuExtension::ApiOnDestroySubject(Extension::OnDestroySubjectMsg *)
{
    return S_OK;
}


/***************************************************************************\
*
* DuExtension::ApiOnAsyncDestroy
*
* ApiOnAsyncDestroy() is called when the DuExtension receives an asynchronous
* destruction message that was previously posted.  This provides the derived
* DuExtension an opportunity to start the destruction process without being
* nested several levels.
*
\***************************************************************************/

HRESULT
DuExtension::ApiOnAsyncDestroy(Extension::OnAsyncDestroyMsg *)
{
    return S_OK;
}


/***************************************************************************\
*
* DuExtension::PostAsyncDestroy
*
* PostAsyncDestroy() queues an asynchronous destruction message.  This 
* provides the derived DuExtension an opportunity to start the destruction 
* process without being nested several levels.
*
\***************************************************************************/

void
DuExtension::PostAsyncDestroy()
{
    AssertMsg(m_fAsyncDestroy, 
            "Must create DuExtension with oAsyncDestroy if want to destroy asynchronously");
    Assert(s_msgidAsyncDestroy != 0);
    EventMsg msg;
    ZeroMemory(&msg, sizeof(msg));
    msg.cbSize  = sizeof(msg);
    msg.hgadMsg = GetHandle();
    msg.nMsg    = s_msgidAsyncDestroy;

    DUserPostEvent(&msg, 0);
}


/***************************************************************************\
*
* DuExtension::GetExtension
*
* GetExtension() retrieves the DuExtension of a specific type currently 
* attached to the subject Gadget.
*
\***************************************************************************/

DuExtension *
DuExtension::GetExtension(Visual * pgvSubject, PRID prid)
{
    DuExtension * pbExist;
    if (SUCCEEDED(pgvSubject->GetProperty(prid, (void **) &pbExist))) {
        AssertMsg(pbExist != NULL, "Attached DuExtension must be valid");
        return pbExist;
    }
    
    return NULL;
}

#endif // ENABLE_MSGTABLE_API
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\flow.cpp ===
#include "stdafx.h"
#include "Ctrl.h"
#include "Flow.h"

#if ENABLE_MSGTABLE_API

PRID        DuAlphaFlow::s_pridAlpha   = 0;
PRID        DuScaleFlow::s_pridScale   = 0;
PRID        DuRectFlow::s_pridRect     = 0;
PRID        DuRotateFlow::s_pridRotate = 0;

static const GUID guidAlphaFlow     = { 0x41a2e2f2, 0xf262, 0x41ae, { 0x89, 0xda, 0xb7, 0x9c, 0x8f, 0xf5, 0x94, 0xbb } };   // {41A2E2F2-F262-41ae-89DA-B79C8FF594BB}
static const GUID guidScaleFlow     = { 0xa5b1df84, 0xb9c0, 0x4305, { 0xb9, 0x3a, 0x5b, 0x80, 0x31, 0x86, 0x70, 0x69 } };   // {A5B1DF84-B9C0-4305-B93A-5B8031867069}
static const GUID guidRectFlow      = { 0x8e41c241, 0x3cdf, 0x432e, { 0xa1, 0xae, 0xf, 0x7b, 0x59, 0xdc, 0x82, 0xb } };     // {8E41C241-3CDF-432e-A1AE-0F7B59DC820B}
static const GUID guidRotateFlow    = { 0x78f16dd5, 0xa198, 0x4cd2, { 0xb1, 0x78, 0x31, 0x61, 0x3e, 0x32, 0x12, 0x54 } };   // {78F16DD5-A198-4cd2-B178-31613E321254}

/***************************************************************************\
*****************************************************************************
*
* Public API
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
PRID
DUserGetAlphaPRID()
{
    return DuAlphaFlow::s_pridAlpha;
}


//------------------------------------------------------------------------------
PRID
DUserGetRectPRID()
{
    return DuRectFlow::s_pridRect;
}


//------------------------------------------------------------------------------
PRID
DUserGetRotatePRID()
{
    return DuRotateFlow::s_pridRotate;
}


//------------------------------------------------------------------------------
PRID
DUserGetScalePRID()
{
    return DuScaleFlow::s_pridScale;
}


/***************************************************************************\
*****************************************************************************
*
* class DuFlow
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
HRESULT
DuFlow::ApiOnReset(Flow::OnResetMsg * pmsg)
{
    UNREFERENCED_PARAMETER(pmsg);

    return E_NOTIMPL;
}


//------------------------------------------------------------------------------
HRESULT
DuFlow::ApiGetKeyFrame(Flow::GetKeyFrameMsg * pmsg)
{
    UNREFERENCED_PARAMETER(pmsg);

    PromptInvalid("Derived Flow must override");

    return E_NOTIMPL;
}


//------------------------------------------------------------------------------
HRESULT
DuFlow::ApiSetKeyFrame(Flow::SetKeyFrameMsg * pmsg)
{
    UNREFERENCED_PARAMETER(pmsg);

    PromptInvalid("Derived Flow must override");

    return E_NOTIMPL;
}


//------------------------------------------------------------------------------
HRESULT
DuFlow::ApiOnAction(Flow::OnActionMsg * pmsg)
{
    UNREFERENCED_PARAMETER(pmsg);

    return E_NOTIMPL;
}


/***************************************************************************\
*****************************************************************************
*
* class DuAlphaFlow
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
HRESULT
DuAlphaFlow::InitClass()
{
    s_pridAlpha = RegisterGadgetProperty(&guidAlphaFlow);
    return s_pridAlpha != 0 ? S_OK : (HRESULT) GetLastError();
}


//------------------------------------------------------------------------------
HRESULT
DuAlphaFlow::PostBuild(
    IN  DUser::Gadget::ConstructInfo * pci)
{
    //
    // Get the information from the Gadget
    //

    Flow::FlowCI * pDesc = static_cast<Flow::FlowCI *>(pci);
    Visual * pgvSubject = pDesc->pgvSubject;
    if (pgvSubject != NULL) {
        //
        // Given a subject, so setup from current attributes
        //

        UINT nStyle = 0;
        pgvSubject->GetStyle(&nStyle);

        if (!TestFlag(nStyle, GS_OPAQUE)) {
            PromptInvalid("AlphaFlow requires GS_OPAQUE");
            return E_INVALIDARG;
        }

        float flAlpha = 1.0f;
        if (TestFlag(nStyle, GS_BUFFERED)) {
            //
            // Gadget is already buffered, so use it current alpha value.
            //

            BUFFER_INFO bi;
            ZeroMemory(&bi, sizeof(bi));
            bi.cbSize   = sizeof(bi);
            bi.nMask    = GBIM_ALPHA;
            HRESULT hr  = pgvSubject->GetBufferInfo(&bi);
            if (SUCCEEDED(hr)) {
                flAlpha = ((float) bi.bAlpha) / 255.0f;
            }
        }

        m_flStart   = flAlpha;
        m_flEnd     = flAlpha;
    } else {
        //
        // No subject, so use some reasonable defaults
        //

        m_flStart   = 1.0f;
        m_flEnd     = 1.0f;
    }

#if DEBUG_TRACECREATION
    Trace("DuAlphaFlow 0x%p on 0x%p initialized\n", pgvSubject, this);
#endif // DEBUG_TRACECREATION

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
DuAlphaFlow::ApiGetKeyFrame(Flow::GetKeyFrameMsg * pmsg)
{
    if (pmsg->pkf->cbSize != sizeof(AlphaFlow::AlphaKeyFrame)) {
        PromptInvalid("Incorrect keyframe size");
        return E_INVALIDARG;
    }
    AlphaFlow::AlphaKeyFrame * pkfA = static_cast<AlphaFlow::AlphaKeyFrame *>(pmsg->pkf);

    switch (pmsg->time)
    {
    case Flow::tBegin:
        pkfA->flAlpha = m_flStart;
        return S_OK;

    case Flow::tEnd:
        pkfA->flAlpha = m_flEnd;
        return S_OK;

    default:
        PromptInvalid("Invalid time");
        return E_INVALIDARG;
    }
}


//------------------------------------------------------------------------------
HRESULT
DuAlphaFlow::ApiSetKeyFrame(Flow::SetKeyFrameMsg * pmsg)
{
    if (pmsg->pkf->cbSize != sizeof(AlphaFlow::AlphaKeyFrame)) {
        PromptInvalid("Incorrect keyframe size");
        return E_INVALIDARG;
    }
    const AlphaFlow::AlphaKeyFrame * pkfA = static_cast<const AlphaFlow::AlphaKeyFrame *>(pmsg->pkf);

    float flAlpha = BoxAlpha(pkfA->flAlpha);

    switch (pmsg->time)
    {
    case Flow::tBegin:
        m_flStart = flAlpha;
        return S_OK;

    case Flow::tEnd:
        m_flEnd = flAlpha;
        return S_OK;

    default:
        PromptInvalid("Invalid time");
        return E_INVALIDARG;
    }
}


//------------------------------------------------------------------------------
HRESULT        
DuAlphaFlow::ApiOnAction(Flow::OnActionMsg * pmsg)
{
    float flResult = 0.0f;
    pmsg->pipol->Compute(pmsg->flProgress, m_flStart, m_flEnd, &flResult);
    SetVisualAlpha(pmsg->pgvSubject, flResult);

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
DuAlphaFlow::ApiOnReset(Flow::OnResetMsg * pmsg)
{
    SetVisualAlpha(pmsg->pgvSubject, m_flStart);

    return S_OK;
}


//------------------------------------------------------------------------------
void        
DuAlphaFlow::SetVisualAlpha(Visual * pgvSubject, float flAlpha)
{
    AssertMsg((flAlpha <= 1.0f) && (flAlpha >= 0.0f), "Ensure valid alpha");


    //
    // Setup Buffer state
    //

    BOOL fNewBuffered   = (flAlpha * 255.0f) <= 245;

    UINT nStyle = 0;
    VerifyHR(pgvSubject->GetStyle(&nStyle));
    BOOL fOldBuffered   = TestFlag(nStyle, GS_BUFFERED);

    if ((!fOldBuffered) != (!fNewBuffered)) {
        pgvSubject->SetStyle(fNewBuffered ? GS_BUFFERED : 0, GS_BUFFERED);
    }


    //
    // Set Alpha level
    //

    if (fNewBuffered) {
        BYTE bAlpha;
        if (flAlpha < 0.0f) {
            bAlpha = (BYTE) 0;
        } else if (flAlpha > 1.0f) {
            bAlpha = (BYTE) 255;
        } else {
            bAlpha = (BYTE) (flAlpha * 255.0f);
        }

        BUFFER_INFO bi;
        bi.cbSize   = sizeof(bi);
        bi.nMask    = GBIM_ALPHA;
        bi.bAlpha   = bAlpha;

        pgvSubject->SetBufferInfo(&bi);
    }
    pgvSubject->Invalidate();
}


/***************************************************************************\
*****************************************************************************
*
* class DuRectFlow
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
HRESULT
DuRectFlow::InitClass()
{
    s_pridRect = RegisterGadgetProperty(&guidRectFlow);
    return s_pridRect != 0 ? S_OK : (HRESULT) GetLastError();
}


//------------------------------------------------------------------------------
HRESULT
DuRectFlow::PostBuild(
    IN  DUser::Gadget::ConstructInfo * pci)
{
    //
    // Get the information from the Gadget
    //

    Flow::FlowCI * pDesc = static_cast<Flow::FlowCI *>(pci);
    Visual * pgvSubject = pDesc->pgvSubject;
    if (pgvSubject != NULL) {
        //
        // Given a subject, so setup from current attributes
        //

        RECT rcGadget;
        HRESULT hr = pgvSubject->GetRect(SGR_PARENT, &rcGadget);
        if (FAILED(hr)) {
            return hr;
        }

        m_ptStart.x     = rcGadget.left;
        m_ptStart.y     = rcGadget.top;
        m_sizeStart.cx  = rcGadget.right - rcGadget.left;
        m_sizeStart.cy  = rcGadget.bottom - rcGadget.top;

        m_ptEnd         = m_ptStart;
        m_sizeEnd       = m_sizeStart;
        m_nChangeFlags  = 0;
    } else {
        //
        // No subject, so use some reasonable defaults
        //

        AssertMsg((m_ptEnd.x == 0) && (m_ptEnd.y == 0) && 
                (m_sizeEnd.cx == 0) && (m_sizeEnd.cy == 0) && (m_nChangeFlags == 0),
                "Ensure zero-init");
    }

#if DEBUG_TRACECREATION
    Trace("DuRectFlow  0x%p on 0x%p initialized\n", pgvSubject, this);
#endif // DEBUG_TRACECREATION

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
DuRectFlow::ApiGetKeyFrame(Flow::GetKeyFrameMsg * pmsg)
{
    if (pmsg->pkf->cbSize != sizeof(RectFlow::RectKeyFrame)) {
        PromptInvalid("Incorrect keyframe size");
        return E_INVALIDARG;
    }
    RectFlow::RectKeyFrame * pkfR = static_cast<RectFlow::RectKeyFrame *>(pmsg->pkf);

    switch (pmsg->time)
    {
    case Flow::tBegin:
        pkfR->rcPxl.left    = m_ptStart.x;
        pkfR->rcPxl.top     = m_ptStart.y;
        pkfR->rcPxl.right   = m_ptStart.x + m_sizeStart.cx;
        pkfR->rcPxl.bottom  = m_ptStart.y + m_sizeStart.cy;
        pkfR->nChangeFlags  = m_nChangeFlags;
        return S_OK;

    case Flow::tEnd:
        pkfR->rcPxl.left    = m_ptEnd.x;
        pkfR->rcPxl.top     = m_ptEnd.y;
        pkfR->rcPxl.right   = m_ptEnd.x + m_sizeEnd.cx;
        pkfR->rcPxl.bottom  = m_ptEnd.y + m_sizeEnd.cy;
        pkfR->nChangeFlags  = 0;
        return S_OK;

    default:
        PromptInvalid("Invalid time");
        return E_INVALIDARG;
    }
}


//------------------------------------------------------------------------------
HRESULT
DuRectFlow::ApiSetKeyFrame(Flow::SetKeyFrameMsg * pmsg)
{
    if (pmsg->pkf->cbSize != sizeof(RectFlow::RectKeyFrame)) {
        PromptInvalid("Incorrect keyframe size");
        return E_INVALIDARG;
    }
    const RectFlow::RectKeyFrame * pkfR = static_cast<const RectFlow::RectKeyFrame *>(pmsg->pkf);
    if ((pkfR->nChangeFlags & SGR_VALID_SET) != pkfR->nChangeFlags) {
        PromptInvalid("Invalid change flags");
        return E_INVALIDARG;
    }

    switch (pmsg->time)
    {
    case Flow::tBegin:
        m_ptStart.x     = pkfR->rcPxl.left;
        m_ptStart.y     = pkfR->rcPxl.top;
        m_sizeStart.cx  = pkfR->rcPxl.right - pkfR->rcPxl.left;
        m_sizeStart.cy  = pkfR->rcPxl.bottom - pkfR->rcPxl.top;
        m_nChangeFlags  = pkfR->nChangeFlags;
        return S_OK;

    case Flow::tEnd:
        m_ptEnd.x       = pkfR->rcPxl.left;
        m_ptEnd.y       = pkfR->rcPxl.top;
        m_sizeEnd.cx    = pkfR->rcPxl.right - pkfR->rcPxl.left;
        m_sizeEnd.cy    = pkfR->rcPxl.bottom - pkfR->rcPxl.top;
        m_nChangeFlags  = pkfR->nChangeFlags;
        return S_OK;

    default:
        PromptInvalid("Invalid time");
        return E_INVALIDARG;
    }
}


//------------------------------------------------------------------------------
HRESULT
DuRectFlow::ApiOnReset(Flow::OnResetMsg * pmsg)
{
    if (m_nChangeFlags != 0) {
        pmsg->pgvSubject->SetRect(m_nChangeFlags, m_ptStart.x, m_ptStart.y, m_sizeStart.cx, m_sizeStart.cy);
    }

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
DuRectFlow::ApiOnAction(Flow::OnActionMsg * pmsg)
{
    if (m_nChangeFlags != 0) {
        POINT ptNew;
        SIZE sizeNew;

        ptNew.x     = Compute(pmsg->pipol, pmsg->flProgress, m_ptStart.x, m_ptEnd.x);
        ptNew.y     = Compute(pmsg->pipol, pmsg->flProgress, m_ptStart.y, m_ptEnd.y);
        sizeNew.cx  = Compute(pmsg->pipol, pmsg->flProgress, m_sizeStart.cx, m_sizeEnd.cx);
        sizeNew.cy  = Compute(pmsg->pipol, pmsg->flProgress, m_sizeStart.cy, m_sizeEnd.cy);

        pmsg->pgvSubject->SetRect(m_nChangeFlags, ptNew.x, ptNew.y, sizeNew.cx, sizeNew.cy);
    }

    return S_OK;
}


/***************************************************************************\
*****************************************************************************
*
* class DuRotateFlow
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
HRESULT
DuRotateFlow::InitClass()
{
    s_pridRotate = RegisterGadgetProperty(&guidRotateFlow);
    return s_pridRotate != 0 ? S_OK : (HRESULT) GetLastError();
}


//------------------------------------------------------------------------------
HRESULT
DuRotateFlow::PostBuild(
    IN  DUser::Gadget::ConstructInfo * pci)
{
    //
    // Get the information from the Gadget
    //

    Flow::FlowCI * pDesc = static_cast<Flow::FlowCI *>(pci);
    Visual * pgvSubject = pDesc->pgvSubject;
    if (pgvSubject != NULL) {
        //
        // Given a subject, so setup from current attributes
        //

        float flRotation;
        HRESULT hr = pgvSubject->GetRotation(&flRotation);
        if (FAILED(hr)) {
            return hr;
        }

        m_flRawStart    = flRotation;
        m_flRawEnd      = flRotation;
        m_flActualStart = flRotation;
        m_flActualEnd   = flRotation;
    } else {
        //
        // No subject, so use some reasonable defaults
        //

        AssertMsg((m_flRawStart == 0.0f) && (m_flRawEnd == 0.0f), 
                "Ensure zero-init");
    }

    m_nDir          = RotateFlow::dMin;

    MarkDirty();

#if DEBUG_TRACECREATION
    Trace("DuRotateFlow  0x%p on 0x%p initialized\n", pgvSubject, this);
#endif // DEBUG_TRACECREATION

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
DuRotateFlow::ApiGetKeyFrame(Flow::GetKeyFrameMsg * pmsg)
{
    if (pmsg->pkf->cbSize != sizeof(RotateFlow::RotateKeyFrame)) {
        PromptInvalid("Incorrect keyframe size");
        return E_INVALIDARG;
    }
    RotateFlow::RotateKeyFrame * pkfR = static_cast<RotateFlow::RotateKeyFrame *>(pmsg->pkf);

    switch (pmsg->time)
    {
    case Flow::tBegin:
        pkfR->flRotation = m_flRawStart;
        pkfR->nDir = m_nDir;
        return S_OK;

    case Flow::tEnd:
        pkfR->flRotation = m_flRawEnd;
        pkfR->nDir = m_nDir;
        return S_OK;

    default:
        PromptInvalid("Invalid time");
        return E_INVALIDARG;
    }
}


//------------------------------------------------------------------------------
HRESULT
DuRotateFlow::ApiSetKeyFrame(Flow::SetKeyFrameMsg * pmsg)
{
    if (pmsg->pkf->cbSize != sizeof(RotateFlow::RotateKeyFrame)) {
        PromptInvalid("Incorrect keyframe size");
        return E_INVALIDARG;
    }
    const RotateFlow::RotateKeyFrame * pkfR = static_cast<const RotateFlow::RotateKeyFrame *>(pmsg->pkf);

    switch (pmsg->time)
    {
    case Flow::tBegin:
        m_flRawStart = pkfR->flRotation;
        m_nDir = pkfR->nDir;
        MarkDirty();
        return S_OK;

    case Flow::tEnd:
        m_flRawEnd = pkfR->flRotation;
        m_nDir = pkfR->nDir;
        MarkDirty();
        return S_OK;

    default:
        PromptInvalid("Invalid time");
        return E_INVALIDARG;
    }
}


//------------------------------------------------------------------------------
HRESULT
DuRotateFlow::ApiOnReset(Flow::OnResetMsg * pmsg)
{
    ComputeAngles();

    pmsg->pgvSubject->SetRotation(m_flActualStart);

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
DuRotateFlow::ApiOnAction(Flow::OnActionMsg * pmsg)
{
    ComputeAngles();

    pmsg->pgvSubject->SetRotation(Compute(pmsg->pipol, pmsg->flProgress, m_flActualStart, m_flActualEnd));

    return S_OK;
}


/***************************************************************************\
*
* DuRotateFlow::ComputeAngles
*
* ComputeAngles() updates the angles to conform to the desired direction.
* This is lazily computed, allowing the application to specify the angles
* and direction in any order, then snapping the angles when actually needed.
*
\***************************************************************************/

void
DuRotateFlow::ComputeAngles()
{
    if (!m_fDirty) {
        return;
    }


    //
    // Adjust the starting and ending angles so that we "move" in the correct
    // direction.  We do this by adding or subtracting full rotations depending
    // on the "move" we are trying to accomplish.
    //

    m_flActualStart = m_flRawStart;
    m_flActualEnd = m_flRawEnd;

    switch (m_nDir)
    {
    case RotateFlow::dShort:
        if (m_flActualStart < m_flActualEnd) {
            while ((m_flActualEnd - m_flActualStart) > (float) PI) {
                m_flActualStart += (float) (2 * PI);
            }
        } else {
            while ((m_flActualStart - m_flActualEnd) > (float) PI) {
                m_flActualStart -= (float) (2 * PI);
            }
        }
        break;

    case RotateFlow::dLong:
        if (m_flActualStart < m_flActualEnd) {
            while ((m_flActualStart - m_flActualEnd) < (float) PI) {
                m_flActualEnd -= (float) (2 * PI);
            }
        } else {
            while ((m_flActualEnd - m_flActualStart) < (float) PI) {
                m_flActualEnd += (float) (2 * PI);
            }
        }
        break;

    case RotateFlow::dCW:
        while (m_flActualStart > m_flActualEnd) {
            m_flActualEnd += (float) (2 * PI);
        }
        break;

    case RotateFlow::dCCW:
        while (m_flActualStart < m_flActualEnd) {
            m_flActualStart += (float) (2 * PI);
        }
        break;
    }

    m_fDirty = FALSE;
}


/***************************************************************************\
*****************************************************************************
*
* class DuScaleFlow
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
HRESULT
DuScaleFlow::InitClass()
{
    s_pridScale = RegisterGadgetProperty(&guidScaleFlow);
    return s_pridScale != 0 ? S_OK : (HRESULT) GetLastError();
}


//------------------------------------------------------------------------------
HRESULT
DuScaleFlow::PostBuild(
    IN  DUser::Gadget::ConstructInfo * pci)
{
    //
    // Get the information from the Gadget
    //

    Flow::FlowCI * pDesc = static_cast<Flow::FlowCI *>(pci);
    Visual * pgvSubject = pDesc->pgvSubject;
    if (pgvSubject != NULL) {
        //
        // Given a subject, so setup from current attributes
        //

        float flX, flY;
        HRESULT hr = pgvSubject->GetScale(&flX, &flY);
        if (FAILED(hr)) {
            return hr;
        }

        m_flStart   = flX;
        m_flEnd     = flX;
    } else {
        //
        // No subject, so use some reasonable defaults
        //

        m_flStart   = 1.0f;
        m_flEnd     = 1.0f;
    }


#if DEBUG_TRACECREATION
    Trace("DuScaleFlow 0x%p on 0x%p initialized\n", pgvSubject, this);
#endif // DEBUG_TRACECREATION

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
DuScaleFlow::ApiGetKeyFrame(Flow::GetKeyFrameMsg * pmsg)
{
    if (pmsg->pkf->cbSize != sizeof(ScaleFlow::ScaleKeyFrame)) {
        PromptInvalid("Incorrect keyframe size");
        return E_INVALIDARG;
    }
    ScaleFlow::ScaleKeyFrame * pkfS = static_cast<ScaleFlow::ScaleKeyFrame *>(pmsg->pkf);

    switch (pmsg->time)
    {
    case Flow::tBegin:
        pkfS->flScale = m_flStart;
        return S_OK;

    case Flow::tEnd:
        pkfS->flScale = m_flEnd;
        return S_OK;

    default:
        PromptInvalid("Invalid time");
        return E_INVALIDARG;
    }
}


//------------------------------------------------------------------------------
HRESULT
DuScaleFlow::ApiSetKeyFrame(Flow::SetKeyFrameMsg * pmsg)
{
    if (pmsg->pkf->cbSize != sizeof(ScaleFlow::ScaleKeyFrame)) {
        PromptInvalid("Incorrect keyframe size");
        return E_INVALIDARG;
    }
    const ScaleFlow::ScaleKeyFrame * pkfS = static_cast<const ScaleFlow::ScaleKeyFrame *>(pmsg->pkf);

    switch (pmsg->time)
    {
    case Flow::tBegin:
        m_flStart = pkfS->flScale;
        return S_OK;

    case Flow::tEnd:
        m_flEnd = pkfS->flScale;
        return S_OK;

    default:
        PromptInvalid("Invalid time");
        return E_INVALIDARG;
    }
}


//------------------------------------------------------------------------------
HRESULT
DuScaleFlow::ApiOnReset(Flow::OnResetMsg * pmsg)
{
    pmsg->pgvSubject->SetScale(m_flStart, m_flStart);

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
DuScaleFlow::ApiOnAction(Flow::OnActionMsg * pmsg)
{
    float flx   = Compute(pmsg->pipol, pmsg->flProgress, m_flStart, m_flEnd);
    float fly   = flx;
    pmsg->pgvSubject->SetScale(flx, fly);

    return S_OK;
}


#else // ENABLE_MSGTABLE_API


/***************************************************************************\
*****************************************************************************
*
* Public API
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
PRID
DUserGetAlphaPRID()
{
    PromptInvalid("Not implemented without MsgTable support");
    return 0;
}


//------------------------------------------------------------------------------
PRID
DUserGetRectPRID()
{
    PromptInvalid("Not implemented without MsgTable support");
    return 0;
}


//------------------------------------------------------------------------------
PRID
DUserGetRotatePRID()
{
    PromptInvalid("Not implemented without MsgTable support");
    return 0;
}


//------------------------------------------------------------------------------
PRID
DUserGetScalePRID()
{
    PromptInvalid("Not implemented without MsgTable support");
    return 0;
}


#endif // ENABLE_MSGTABLE_API
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\extension.h ===
#if !defined(CTRL__Extension_h__INCLUDED)
#define CTRL__Extension_h__INCLUDED
#pragma once

#if ENABLE_MSGTABLE_API

class DuExtension :
        public ExtensionImpl<DuExtension, SListener>
{
// Construction
public:
    inline  DuExtension();
    virtual ~DuExtension();
    static  HRESULT     InitClass();

    enum EOptions
    {
        oUseExisting    = 0x00000001,   // Use existing Extension if already attached
        oAsyncDestroy   = 0x00000002,   // Use asynchronous destruction
    };

            HRESULT     Create(Visual * pgvChange, PRID pridExtension, UINT nOptions);
            void        Destroy();
            void        DeleteHandle();

// Public API
public:
    dapi    HRESULT     ApiOnEvent(EventMsg * pmsg);

    dapi    HRESULT     ApiOnRemoveExisting(Extension::OnRemoveExistingMsg * pmsg);
    dapi    HRESULT     ApiOnDestroySubject(Extension::OnDestroySubjectMsg * pmsg);
    dapi    HRESULT     ApiOnAsyncDestroy(Extension::OnAsyncDestroyMsg * pmsg);

// Operations
public:
    static  DuExtension* GetExtension(Visual * pgvSubject, PRID prid);

// Implementation 
protected:
            void        PostAsyncDestroy();

// Data
protected:
            Visual *    m_pgvSubject;   // Visual Gadget being "extended"
            PRID        m_pridListen;   // PRID for Extension
            BOOL        m_fAsyncDestroy:1;
                                        // Need to destroy asynchronously

    static  MSGID       s_msgidAsyncDestroy;
};

#endif // ENABLE_MSGTABLE_API

#include "Extension.inl"

#endif // CTRL__Extension_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\flow.h ===
#if !defined(CTRL__Flow_h__INCLUDED)
#define CTRL__Flow_h__INCLUDED
#pragma once

#if ENABLE_MSGTABLE_API

//------------------------------------------------------------------------------
class DuFlow : 
        public FlowImpl<DuFlow, DUser::SGadget>
{
// Construction
public:
    inline  DuFlow();

// Public API
public:
    dapi    HRESULT     ApiAddRef(Flow::AddRefMsg *) { AddRef(); return S_OK; }
    dapi    HRESULT     ApiRelease(Flow::ReleaseMsg *) { Release(); return S_OK; }

    dapi    HRESULT     ApiGetPRID(Flow::GetPRIDMsg * pmsg) { pmsg->prid = 0; return S_OK; }
    dapi    HRESULT     ApiGetKeyFrame(Flow::GetKeyFrameMsg * pmsg);
    dapi    HRESULT     ApiSetKeyFrame(Flow::SetKeyFrameMsg * pmsg);

    dapi    HRESULT     ApiOnReset(Flow::OnResetMsg * pmsg);
    dapi    HRESULT     ApiOnAction(Flow::OnActionMsg * pmsg);

// Implementation
protected:
    inline  void        AddRef();
    inline  void        Release(); 

// Data
protected:
            UINT        m_cRef;
};


//------------------------------------------------------------------------------
class DuAlphaFlow :
        public AlphaFlowImpl<DuAlphaFlow, DuFlow>
{
// Construction
public:
    static  HRESULT     InitClass();
            HRESULT     PostBuild(DUser::Gadget::ConstructInfo * pci);

// Operations
public:

// Public API:
public:
    dapi    HRESULT     ApiGetPRID(Flow::GetPRIDMsg * pmsg) { pmsg->prid = s_pridAlpha; return S_OK; }
    dapi    HRESULT     ApiGetKeyFrame(Flow::GetKeyFrameMsg * pmsg);
    dapi    HRESULT     ApiSetKeyFrame(Flow::SetKeyFrameMsg * pmsg);

    dapi    HRESULT     ApiOnReset(Flow::OnResetMsg * pmsg);
    dapi    HRESULT     ApiOnAction(Flow::OnActionMsg * pmsg);

// Implementaton
protected:
            void        SetVisualAlpha(Visual * pgvSubject, float flAlpha);
    inline  float       BoxAlpha(float flAlpha) const;

// Data
public:
    static  PRID        s_pridAlpha;
protected:
            float       m_flStart;
            float       m_flEnd;
};


//------------------------------------------------------------------------------
class DuRectFlow : 
        public RectFlowImpl<DuRectFlow, DuFlow>
{
// Construction
public:
    static  HRESULT     InitClass();
            HRESULT     PostBuild(DUser::Gadget::ConstructInfo * pci);

// Operations
public:

// Public API:
public:
    dapi    HRESULT     ApiGetPRID(Flow::GetPRIDMsg * pmsg) { pmsg->prid = s_pridRect; return S_OK; }
    dapi    HRESULT     ApiGetKeyFrame(Flow::GetKeyFrameMsg * pmsg);
    dapi    HRESULT     ApiSetKeyFrame(Flow::SetKeyFrameMsg * pmsg);

    dapi    HRESULT     ApiOnReset(Flow::OnResetMsg * pmsg);
    dapi    HRESULT     ApiOnAction(Flow::OnActionMsg * pmsg);

// Implementaton
protected:

// Data
public:
    static  PRID        s_pridRect;
protected:
            POINT       m_ptStart;
            POINT       m_ptEnd;
            SIZE        m_sizeStart;
            SIZE        m_sizeEnd;
            UINT        m_nChangeFlags;
};


//------------------------------------------------------------------------------
class DuRotateFlow : 
        public RotateFlowImpl<DuRotateFlow, DuFlow>
{
// Construction
public:
    static  HRESULT     InitClass();
            HRESULT     PostBuild(DUser::Gadget::ConstructInfo * pci);

// Operations
public:

// Public API:
public:
    dapi    HRESULT     ApiGetPRID(Flow::GetPRIDMsg * pmsg) { pmsg->prid = s_pridRotate; return S_OK; }
    dapi    HRESULT     ApiGetKeyFrame(Flow::GetKeyFrameMsg * pmsg);
    dapi    HRESULT     ApiSetKeyFrame(Flow::SetKeyFrameMsg * pmsg);

    dapi    HRESULT     ApiOnReset(Flow::OnResetMsg * pmsg);
    dapi    HRESULT     ApiOnAction(Flow::OnActionMsg * pmsg);

// Implementaton
protected:
            void        ComputeAngles();
    inline  void        MarkDirty();

// Data
public:
    static  PRID        s_pridRotate;
protected:
            float       m_flRawStart;   // User specified starting angle
            float       m_flRawEnd;
            float       m_flActualStart;// Actually computed starting angle
            float       m_flActualEnd;
            RotateFlow::EDirection
                        m_nDir;
            BOOL        m_fDirty;       // State has changed since last updated
};


//------------------------------------------------------------------------------
class DuScaleFlow : 
        public ScaleFlowImpl<DuScaleFlow, DuFlow>
{
// Construction
public:
    static  HRESULT     InitClass();
            HRESULT     PostBuild(DUser::Gadget::ConstructInfo * pci);

// Operations
public:

// Public API:
public:
    dapi    HRESULT     ApiGetPRID(Flow::GetPRIDMsg * pmsg) { pmsg->prid = s_pridScale; return S_OK; }
    dapi    HRESULT     ApiGetKeyFrame(Flow::GetKeyFrameMsg * pmsg);
    dapi    HRESULT     ApiSetKeyFrame(Flow::SetKeyFrameMsg * pmsg);

    dapi    HRESULT     ApiOnReset(Flow::OnResetMsg * pmsg);
    dapi    HRESULT     ApiOnAction(Flow::OnActionMsg * pmsg);

// Implementaton
protected:

// Data
public:
    static  PRID        s_pridScale;
protected:
            float       m_flStart;
            float       m_flEnd;
};


#endif // ENABLE_MSGTABLE_API

#include "Flow.inl"

#endif // CTRL__Flow_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\gdihelp.h ===
#if !defined(CTRL__GdiHelp_h__INCLUDED)
#define CTRL__GdiHelp_h__INCLUDED

HFONT       GdBuildFont(LPCWSTR pszName, int idxDeciSize, DWORD nFlags, HDC hdcDevice);
COLORREF    GdGetColor(HBITMAP hbmp, POINT * pptPxl);

#endif // CTRL__GdiHelp_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\flow.inl ===
#if !defined(CTRL__Flow_inl__INCLUDED)
#define CTRL__Flow_inl__INCLUDED
#pragma once

#if ENABLE_MSGTABLE_API


/***************************************************************************\
*****************************************************************************
*
* Global Functions
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline int
Round(float f)
{
    return (int) (f + 0.5);
}


//------------------------------------------------------------------------------
inline int     
Compute(Interpolation * pipol, float flProgress, int nStart, int nEnd)
{
    float flResult = 0.0f;
    VerifyHR(pipol->Compute(flProgress, (float) nStart, (float) nEnd, &flResult));
    return Round(flResult);
}


//------------------------------------------------------------------------------
inline float
Compute(Interpolation * pipol, float flProgress, float flStart, float flEnd)
{
    float flResult = 0.0f;
    VerifyHR(pipol->Compute(flProgress, flStart, flEnd, &flResult));
    return flResult;
}


/***************************************************************************\
*****************************************************************************
*
* class DuFlow
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline 
DuFlow::DuFlow()
{
    m_cRef = 1;
}


//------------------------------------------------------------------------------
inline void
DuFlow::AddRef()
{ 
    ++m_cRef; 
}


//------------------------------------------------------------------------------
inline void
DuFlow::Release() 
{ 
    if (--m_cRef == 0) 
        Delete(); 
}


/***************************************************************************\
*****************************************************************************
*
* class DuAlphaFlow
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline float
DuAlphaFlow::BoxAlpha(float flAlpha) const
{
    if (flAlpha < 0.0f) {
        return 0.0f;
    } else if (flAlpha > 1.0f) {
        return 1.0f;
    } else {
        return flAlpha;
    }
}


/***************************************************************************\
*****************************************************************************
*
* class DuScaleFlow
*
*****************************************************************************
\***************************************************************************/


/***************************************************************************\
*****************************************************************************
*
* class DuRectFlow
*
*****************************************************************************
\***************************************************************************/


/***************************************************************************\
*****************************************************************************
*
* class DuRotateFlow
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline void
DuRotateFlow::MarkDirty()
{
    m_fDirty = TRUE;
}


#endif // ENABLE_MSGTABLE_API

#endif // CTRL__Flow_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\init.h ===
#if !defined(CTRL__Init_h__INCLUDED)
#define CTRL__Init_h__INCLUDED
#pragma once

HRESULT InitCtrl();

#endif // CTRL__Init_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\init.cpp ===
#include "stdafx.h"
#include "Ctrl.h"
#include "Init.h"

#if ENABLE_MSGTABLE_API

#include "Extension.h"
#include "DragDrop.h"
#include "Animation.h"
#include "Flow.h"
#include "Sequence.h"
#include "Interpolation.h"

#include "SmCheckBox.h"
#include "SmHyperLink.h"
#include "SmText.h"
#include "SmButton.h"
#include "SmEditLine.h"
#include "SmImage.h"
#include "SmVector.h"

IMPLEMENT_GUTS_Extension(DuExtension, SListener);
IMPLEMENT_GUTS_DropTarget(DuDropTarget, DuExtension);

IMPLEMENT_GUTS_Animation(DuAnimation, DuExtension);
IMPLEMENT_GUTS_Flow(DuFlow, DUser::SGadget);
IMPLEMENT_GUTS_AlphaFlow(DuAlphaFlow, DuFlow);
IMPLEMENT_GUTS_RectFlow(DuRectFlow, DuFlow);
IMPLEMENT_GUTS_RotateFlow(DuRotateFlow, DuFlow);
IMPLEMENT_GUTS_ScaleFlow(DuScaleFlow, DuFlow);
IMPLEMENT_GUTS_Sequence(DuSequence, SListener);

IMPLEMENT_GUTS_Interpolation(DuInterpolation, DUser::SGadget);
IMPLEMENT_GUTS_LinearInterpolation(DuLinearInterpolation, DuInterpolation);
IMPLEMENT_GUTS_LogInterpolation(DuLogInterpolation, DuInterpolation);
IMPLEMENT_GUTS_ExpInterpolation(DuExpInterpolation, DuInterpolation);
IMPLEMENT_GUTS_SCurveInterpolation(DuSCurveInterpolation, DuInterpolation);

IMPLEMENT_GUTS_CheckBoxGadget(SmCheckBox, SVisual);
IMPLEMENT_GUTS_TextGadget(SmText, SVisual);
IMPLEMENT_GUTS_HyperLinkGadget(SmHyperLink, SmText);
IMPLEMENT_GUTS_ButtonGadget(SmButton, SVisual);
IMPLEMENT_GUTS_EditLineGadget(SmEditLine, SVisual);
IMPLEMENT_GUTS_EditLineFGadget(SmEditLineF, SVisual);
IMPLEMENT_GUTS_ImageGadget(SmImage, SVisual);
IMPLEMENT_GUTS_VectorGadget(SmVector, SVisual);

#endif // ENABLE_MSGTABLE_API

//------------------------------------------------------------------------------
HRESULT InitCtrl()
{
#if ENABLE_MSGTABLE_API

    if ((!DuExtension::InitExtension()) ||
        (!DuDropTarget::InitDropTarget()) ||
        (!DuAnimation::InitAnimation()) ||
        (!DuFlow::InitFlow()) ||
        (!DuAlphaFlow::InitAlphaFlow()) ||
        (!DuRectFlow::InitRectFlow()) ||
        (!DuRotateFlow::InitRotateFlow()) ||
        (!DuScaleFlow::InitScaleFlow()) ||
        (!DuSequence::InitSequence()) ||
        (!DuInterpolation::InitInterpolation()) ||
        (!DuLinearInterpolation::InitLinearInterpolation()) ||
        (!DuLogInterpolation::InitLogInterpolation()) ||
        (!DuExpInterpolation::InitExpInterpolation()) ||
        (!DuSCurveInterpolation::InitSCurveInterpolation()) ||
        (!SmCheckBox::InitCheckBoxGadget()) ||
        (!SmText::InitTextGadget()) ||
        (!SmHyperLink::InitHyperLinkGadget()) ||
        (!SmButton::InitButtonGadget()) ||
        (!SmEditLine::InitEditLineGadget()) ||
        (!SmEditLineF::InitEditLineFGadget()) ||
        (!SmImage::InitImageGadget()) ||
        (!SmVector::InitVectorGadget())) {

        return E_OUTOFMEMORY;
    }

#endif // ENABLE_MSGTABLE_API

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\gdihelp.cpp ===
#include "stdafx.h"
#include "Ctrl.h"
#include "GdiHelp.h"

/***************************************************************************\
*
* GdBuildFont (API)
*
* GdBuildFont() is a helper function that assists in making fonts easier to
* create.
*
* This function is DESIGNED to work with Gadgets.  When FS_COMPATIBLE is not
* set, the font size will always be the same, regardless of when large-fonts
* is enabled or not.  When FS_COMPATIBLE is set, the font size will use the
* MSDN documented mechanism to compute the font size, taking large-fonts 
* into account.  
* 
* The problem with FS_COMPATIBLE is that the font gets larger, but nothing 
* else does.  DLU's try to fix this, but they have a lot of problems.
* Gadgets solve this by using GDI's World Transforms and having complete
* scaling of all drawing.
*
\***************************************************************************/

HFONT
GdBuildFont(
    IN  LPCWSTR pszName,            // Name of font
    IN  int idxDeciSize,            // Size in decipoints
    IN  DWORD nFlags,               // Font creation flags
    IN  HDC hdcDevice)              // Optional device (Display if NULL)
{
    LOGFONTW lf;

    int nLogPixelsY;
    if (hdcDevice != NULL) {
        nLogPixelsY = GetDeviceCaps(hdcDevice, LOGPIXELSY);
    } else if (TestFlag(nFlags, FS_COMPATIBLE)) {
        HDC hdcDesktop  = GetGdiCache()->GetTempDC();
        if (hdcDesktop == NULL) {
            return NULL;
        }

        nLogPixelsY = GetDeviceCaps(hdcDesktop, LOGPIXELSY);
        GetGdiCache()->ReleaseTempDC(hdcDesktop);
    } else {
        nLogPixelsY = 96;  // Hard code for normal fonts
    }

    ZeroMemory(&lf, sizeof(LOGFONT));

    wcscpy(lf.lfFaceName, pszName);
    lf.lfHeight         = -MulDiv(idxDeciSize, nLogPixelsY, 720);
    lf.lfWeight         = nFlags & FS_BOLD ? FW_BOLD : FW_NORMAL;
    lf.lfItalic         = (nFlags & FS_ITALIC) != 0;
    lf.lfUnderline      = (nFlags & FS_UNDERLINE) != 0;
    lf.lfStrikeOut      = (nFlags & FS_STRIKEOUT) != 0;
    lf.lfCharSet        = DEFAULT_CHARSET;
    lf.lfOutPrecision   = OUT_DEFAULT_PRECIS;
    lf.lfClipPrecision  = CLIP_DEFAULT_PRECIS;
    lf.lfQuality        = ANTIALIASED_QUALITY;
    lf.lfPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;

    return OS()->CreateFontIndirect(&lf);
}


/***************************************************************************\
*
* GdGetColor
*
* GdGetColor gets the color of a pixel at the specified point in the bitmap.
* This utility function is designed to help when determining the transparent
* color of a bitmap.
*
\***************************************************************************/

COLORREF    
GdGetColor(HBITMAP hbmp, POINT * pptPxl)
{
    POINT ptTest;
    if (pptPxl != NULL) {
        ptTest = *pptPxl;
    } else {
        ptTest.x = 0;
        ptTest.y = 0;
    }


    HDC hdcBitmap   = GetGdiCache()->GetCompatibleDC();
    HBITMAP hbmpOld = (HBITMAP) SelectObject(hdcBitmap, hbmp);
    COLORREF crTr   = GetPixel(hdcBitmap, ptTest.x, ptTest.y);
    SelectObject(hdcBitmap, hbmpOld);
    GetGdiCache()->ReleaseCompatibleDC(hdcBitmap);

    return crTr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\interpolation.cpp ===
#include "stdafx.h"
#include "Ctrl.h"
#include "Interpolation.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\oldanimation.inl ===
#if !defined(CTRL__OldAnimation_inl__INCLUDED)
#define CTRL__OldAnimation_inl__INCLUDED
#pragma once

#define DEBUG_TRACECREATION         0   // Trace Creation and destruction of animations

/***************************************************************************\
*****************************************************************************
*
* Global Functions
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline int
Round(float f)
{
    return (int) (f + 0.5);
}


//------------------------------------------------------------------------------
inline int     
Compute(IInterpolation * pipol, float flProgress, int nStart, int nEnd)
{
    return Round(pipol->Compute(flProgress, (float) nStart, (float) nEnd));
}


//------------------------------------------------------------------------------
inline float
Compute(IInterpolation * pipol, float flProgress, float flStart, float flEnd)
{
    return pipol->Compute(flProgress, flStart, flEnd);
}


/***************************************************************************\
*****************************************************************************
*
* class OldAnimation
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline 
OldAnimation::OldAnimation()
{
    m_time = IAnimation::tComplete;  // By default, completes normally

#if DEBUG_TRACECREATION
    Trace("START Animation  0x%p    @ %d\n", this, GetTickCount());
#endif // DEBUG_TRACECREATION
}


/***************************************************************************\
*****************************************************************************
*
* class OldAlphaAnimation
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline 
OldAlphaAnimation::OldAlphaAnimation()
{

}


//------------------------------------------------------------------------------
inline HRESULT
OldAlphaAnimation::GetInterface(HGADGET hgad, REFIID riid, void ** ppvUnk)
{
    return OldAnimation::GetInterface(hgad, s_pridAlpha, riid, ppvUnk);
}


/***************************************************************************\
*****************************************************************************
*
* class OldScaleAnimation
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline 
OldScaleAnimation::OldScaleAnimation()
{

}


//------------------------------------------------------------------------------
inline HRESULT
OldScaleAnimation::GetInterface(HGADGET hgad, REFIID riid, void ** ppvUnk)
{
    return OldAnimation::GetInterface(hgad, s_pridScale, riid, ppvUnk);
}


/***************************************************************************\
*****************************************************************************
*
* class OldRectAnimation
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline 
OldRectAnimation::OldRectAnimation()
{

}


//------------------------------------------------------------------------------
inline HRESULT
OldRectAnimation::GetInterface(HGADGET hgad, REFIID riid, void ** ppvUnk)
{
    return OldAnimation::GetInterface(hgad, s_pridRect, riid, ppvUnk);
}


/***************************************************************************\
*****************************************************************************
*
* class OldRotateAnimation
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline 
OldRotateAnimation::OldRotateAnimation()
{

}


//------------------------------------------------------------------------------
inline HRESULT
OldRotateAnimation::GetInterface(HGADGET hgad, REFIID riid, void ** ppvUnk)
{
    return OldAnimation::GetInterface(hgad, s_pridRotate, riid, ppvUnk);
}


#endif // CTRL__OldAnimation_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\oldanimation.h ===
#if !defined(CTRL__OldAnimation_h__INCLUDED)
#define CTRL__OldAnimation_h__INCLUDED
#pragma once

#include "SmObject.h"
#include "OldExtension.h"

/***************************************************************************\
*****************************************************************************
*
* class OldAnimationT
*
* OldAnimationT defines a common implementation class for building
* Animations in DirectUser.
*
*****************************************************************************
\***************************************************************************/

template <class base, class iface, class desc>
class OldAnimationT : public SmObjectT<base, iface>
{
// Operations
public:
    static HRESULT
    Build(GANI_DESC * pDesc, REFIID riid, void ** ppv)
    {
        AssertWritePtr(ppv);

        if (pDesc->cbSize != sizeof(desc)) {
            return E_INVALIDARG;
        }

        OldAnimationT<base, iface, desc> * pObj = new OldAnimationT<base, iface, desc>;
        if (pObj != NULL) {
            pObj->m_cRef = 1;

            HRESULT hr = pObj->Create(pDesc);
            if (SUCCEEDED(hr)) {
                //
                // Animations need to be AddRef()'d again (have a reference 
                // count of 2) because they need to outlife the initial call 
                // to Release() after the called has setup the animation 
                // returned from BuildAnimation().  
                //
                // This is because the Animation continues to life until it 
                // has fully executed (or has been aborted).
                //

                hr = pObj->QueryInterface(riid, ppv);
            } else {
                pObj->Release();
            }
            return hr;
        } else {
            return E_OUTOFMEMORY;
        }
    }
};


//------------------------------------------------------------------------------
class OldAnimation : 
    public OldExtension,
    public IAnimation
{
// Construction
protected:
    inline  OldAnimation();
    virtual ~OldAnimation() PURE;
            HRESULT     Create(const GUID * pguidID, PRID * pprid, GANI_DESC * pDesc);
            void        Destroy(BOOL fFinal);

// Operations
public:
    STDMETHOD_(void,    SetFunction)(IInterpolation * pipol);
    STDMETHOD_(void,    SetTime)(IAnimation::ETime time);
    STDMETHOD_(void,    SetCallback)(IAnimationCallback * pcb);

// Implementation
protected:
    static  void CALLBACK
                        RawActionProc(GMA_ACTIONINFO * pmai);
    virtual void        Action(GMA_ACTIONINFO * pmai) PURE;

    static  HRESULT     GetInterface(HGADGET hgad, PRID prid, REFIID riid, void ** ppvUnk);

    virtual void        OnRemoveExisting();
    virtual void        OnDestroySubject();
    virtual void        OnDestroyListener();

    virtual void        OnComplete() { }
    virtual void        OnAsyncDestroy();

            void        CleanupChangeGadget();

// Data
protected:
            HACTION     m_hact;
            IInterpolation *
                        m_pipol;
            IAnimationCallback *
                        m_pcb;
            IAnimation::ETime
                        m_time;         // Time when completed
            BOOL        m_fStartDestroy:1;
            BOOL        m_fProcessing:1;

            UINT        m_DEBUG_cUpdates;
};


//------------------------------------------------------------------------------
class OldAlphaAnimation : public OldAnimation
{
// Construction
public:
    inline  OldAlphaAnimation();
    virtual ~OldAlphaAnimation();
            HRESULT     Create(GANI_DESC * pDesc);

// Operations
public:
    STDMETHOD_(UINT,    GetID)() const;

    static  HRESULT     GetInterface(HGADGET hgad, REFIID riid, void ** ppvUnk);

// Implementaton
protected:
    virtual void        Action(GMA_ACTIONINFO * pmai);
    virtual void        OnComplete();

// Data
protected:
    static  PRID        s_pridAlpha;
    static  const IID * s_rgpIID[];
            float       m_flStart;
            float       m_flEnd;
            BOOL        m_fPushToChildren;
            UINT        m_nOnComplete;
};


//------------------------------------------------------------------------------
class OldScaleAnimation : public OldAnimation
{
// Construction
public:
    inline  OldScaleAnimation();
    virtual ~OldScaleAnimation();
            HRESULT     Create(GANI_DESC * pDesc);

// Operations
public:
    STDMETHOD_(UINT,    GetID)() const;

    static  HRESULT     GetInterface(HGADGET hgad, REFIID riid, void ** ppvUnk);

// Implementaton
protected:
    virtual void        Action(GMA_ACTIONINFO * pmai);

// Data
protected:
    static  PRID        s_pridScale;
    static  const IID * s_rgpIID[];
            GANI_SCALEDESC::EAlignment  
                        m_al;
            float       m_flStart;
            float       m_flEnd;
            POINT       m_ptStart;
            SIZE        m_sizeCtrl;
};


//------------------------------------------------------------------------------
class OldRectAnimation : public OldAnimation
{
// Construction
public:
    inline  OldRectAnimation();
    virtual ~OldRectAnimation();
            HRESULT     Create(GANI_DESC * pDesc);

// Operations
public:
    STDMETHOD_(UINT,    GetID)() const;

    static  HRESULT     GetInterface(HGADGET hgad, REFIID riid, void ** ppvUnk);

// Implementaton
protected:
    virtual void        Action(GMA_ACTIONINFO * pmai);

// Data
protected:
    static  PRID        s_pridRect;
    static  const IID * s_rgpIID[];
            POINT       m_ptStart;
            POINT       m_ptEnd;
            SIZE        m_sizeStart;
            SIZE        m_sizeEnd;
            UINT        m_nChangeFlags;
};


//------------------------------------------------------------------------------
class OldRotateAnimation : public OldAnimation
{
// Construction
public:
    inline  OldRotateAnimation();
    virtual ~OldRotateAnimation();
            HRESULT     Create(GANI_DESC * pDesc);

// Operations
public:
    STDMETHOD_(UINT,    GetID)() const;

    static  HRESULT     GetInterface(HGADGET hgad, REFIID riid, void ** ppvUnk);

// Implementaton
protected:
    virtual void        Action(GMA_ACTIONINFO * pmai);

// Data
protected:
    static  PRID        s_pridRotate;
    static  const IID * s_rgpIID[];
            float       m_flStart;
            float       m_flEnd;
            UINT        m_nDir;
};


#include "OldAnimation.inl"

#endif // CTRL__OldAnimation_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\olddragdrop.inl ===
#if !defined(CORE__OldDragDrop_inl__INCLUDED)
#define CORE__OldDragDrop_inl__INCLUDED
#pragma once

/***************************************************************************\
*****************************************************************************
*
* class OldTargetLock
* 
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline
OldTargetLock::OldTargetLock()
{
    
}


//------------------------------------------------------------------------------
inline
OldTargetLock::~OldTargetLock() 
{
    if (m_fAddRef) {
        m_punk->Release();
    }
}


/***************************************************************************\
*****************************************************************************
*
* class OldDropTarget
* 
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline 
OldDropTarget::OldDropTarget()
{

}


//------------------------------------------------------------------------------
inline BOOL
OldDropTarget::HasSource() const
{
    return m_pdoSrc != NULL;
}


//------------------------------------------------------------------------------
inline BOOL
OldDropTarget::HasTarget() const
{
    return m_pdtCur != NULL;
}


#endif // CORE__OldDragDrop_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\olddragdrop.cpp ===
/***************************************************************************\
*
* File: DragDrop.cpp
*
* Description:
* DragDrop.cpp implements drag and drop operations
*
*
* History:
*  7/31/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/

#include "stdafx.h"
#include "Ctrl.h"
#include "OldDragDrop.h"

#include <SmObject.h>


static const GUID guidDropTarget = { 0x6a8bb3c8, 0xcbfc, 0x40d1, { 0x98, 0x1e, 0x3f, 0x8a, 0xaf, 0x99, 0x13, 0x7b } };  // {6A8BB3C8-CBFC-40d1-981E-3F8AAF99137B}

/***************************************************************************\
*****************************************************************************
*
* class OldTargetLock
*
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* OldTargetLock::Lock
*
* Lock() prepares for executing inside the Context when being called back
* from OLE's IDropTarget that was registered.
*
\***************************************************************************/

BOOL 
OldTargetLock::Lock(
    IN  OldDropTarget * p,           // OldDropTarget being used
    OUT DWORD * pdwEffect,          // Resulting DROPEFFECT if failure
    IN  BOOL fAddRef)               // Lock DT during use
{
    m_fAddRef   = fAddRef;
    m_punk      = static_cast<IUnknown *> (p);

    if (m_fAddRef) {
        m_punk->AddRef();
    }

    if (p->m_hgadSubject == NULL) {
        if (pdwEffect != NULL) {
            *pdwEffect = DROPEFFECT_NONE;
        }
        return FALSE;
    }

    return TRUE;
}

    
/***************************************************************************\
*****************************************************************************
*
* class OldDropTarget
* 
* NOTE: With the current design and implementation, OldDropTarget can not be 
* "removed" from an object until the object is destroyed.  If this needs to 
* change, we need to revisit this.
* 
*****************************************************************************
\***************************************************************************/

const IID * OldDropTarget::s_rgpIID[] =
{
    &__uuidof(IUnknown),
    &__uuidof(IDropTarget),
    NULL
};

PRID OldDropTarget::s_pridListen = 0;


//
// NOTE: We are calling back directly on the IDropTarget's, so we need to grab
// a read-only lock so that the tree doesn't get smashed.
//

/***************************************************************************\
*
* OldDropTarget::~OldDropTarget
*
* ~OldDropTarget() cleans up resources used by the OldDropTarget.
*
\***************************************************************************/

OldDropTarget::~OldDropTarget()
{
    OldTargetLock lt;
    lt.Lock(this, NULL, FALSE);
    xwDragLeave();
    SafeRelease(m_pdoSrc);

    OldExtension::Destroy();
}


/***************************************************************************\
*
* OldDropTarget::Build
*
* Build() builds a new OldDropTarget instance.  This should only be called for
* a RootGadget that doesn't already have a DT.
*
\***************************************************************************/

HRESULT 
OldDropTarget::Build(
    IN  HGADGET hgadRoot,           // RootGadget
    IN  HWND hwnd,                  // Containing HWND
    OUT OldDropTarget ** ppdt)       // Newly created DT
{
    AssertMsg(hgadRoot != NULL, "Must have a valid root");

    //
    // Setup a new OldDropTarget on this Gadget / HWND.
    //

    if (!GetComManager()->Init(ComManager::sOLE)) {
        return E_OUTOFMEMORY;
    }

    SmObjectT<OldDropTarget, IDropTarget> * pdt = new SmObjectT<OldDropTarget, IDropTarget>;
    if (pdt == NULL) {
        return E_OUTOFMEMORY;
    }
    pdt->AddRef();

    HRESULT hr = GetComManager()->RegisterDragDrop(hwnd, static_cast<IDropTarget *> (pdt));
    if (FAILED(hr)) {
        pdt->Release();
        return E_OUTOFMEMORY;
    }
    //CoLockObjectExternal(pdt, TRUE, FALSE);


    hr = pdt->Create(hgadRoot, &guidDropTarget, &s_pridListen, OldExtension::oUseExisting);
    if ((hr == DU_S_ALREADYEXISTS) || FAILED(hr)) {
        GetComManager()->RevokeDragDrop(hwnd);
        pdt->Release();
        return hr;
    }

    pdt->m_hwnd         = hwnd;

    *ppdt = pdt;
    return S_OK;
}


/***************************************************************************\
*
* OldDropTarget::DragEnter
*
* DragEnter() is called by OLE when entering the DT.
*
\***************************************************************************/

STDMETHODIMP
OldDropTarget::DragEnter(
    IN  IDataObject * pdoSrc,       // Source data
    IN  DWORD grfKeyState,          // Keyboard modifiers
    IN  POINTL ptDesktopPxl,        // Cursor location on desktop
    OUT DWORD * pdwEffect)          // Resulting DROPEFFECT
{
    if (pdoSrc == NULL) {
        return E_INVALIDARG;
    }

    OldTargetLock tl;
    if (!tl.Lock(this, pdwEffect)) {
        return S_OK;
    }


    //
    // Cache the DataObject.
    //

    SafeRelease(m_pdoSrc);
    if (pdoSrc != NULL) {
        pdoSrc->AddRef();
        m_pdoSrc = pdoSrc;
    }

    m_grfLastKeyState = grfKeyState;

    POINT ptClientPxl;
    return xwDragScan(ptDesktopPxl, pdwEffect, &ptClientPxl);
}


/***************************************************************************\
*
* OldDropTarget::DragOver
*
* DragOver() is called by OLE during the drag operation to give feedback 
* while inside the DT.
*
\***************************************************************************/

STDMETHODIMP
OldDropTarget::DragOver(
    IN  DWORD grfKeyState,          // Keyboard modifiers
    IN  POINTL ptDesktopPxl,        // Cursor location on desktop
    OUT DWORD * pdwEffect)          // Resulting DROPEFFECT
{
    OldTargetLock tl;
    if (!tl.Lock(this, pdwEffect)) {
        return S_OK;
    }

    m_grfLastKeyState = grfKeyState;

    POINT ptClientPxl;
    return xwDragScan(ptDesktopPxl, pdwEffect, &ptClientPxl);
}


/***************************************************************************\
*
* OldDropTarget::DragLeave
*
* DragLeave() is called by OLE when leaving the DT.
*
\***************************************************************************/

STDMETHODIMP
OldDropTarget::DragLeave()
{
    OldTargetLock tl;
    if (!tl.Lock(this, NULL)) {
        return S_OK;
    }

    xwDragLeave();
    SafeRelease(m_pdoSrc);

    return S_OK;
}


/***************************************************************************\
*
* OldDropTarget::Drop
*
* Drop() is called by OLE when the user has dropped while inside DT.
*
\***************************************************************************/

STDMETHODIMP
OldDropTarget::Drop(
    IN  IDataObject * pdoSrc,       // Source data
    IN  DWORD grfKeyState,          // Keyboard modifiers
    IN  POINTL ptDesktopPxl,        // Cursor location on desktop
    OUT DWORD * pdwEffect)          // Resulting DROPEFFECT
{
    OldTargetLock tl;
    if (!tl.Lock(this, pdwEffect)) {
        return S_OK;
    }

    if (!HasTarget()) {
        *pdwEffect = DROPEFFECT_NONE;
        return S_OK;
    }

    m_grfLastKeyState = grfKeyState;


    //
    // Update to get the latest Gadget information.
    //

    POINT ptClientPxl;
    HRESULT hr = xwDragScan(ptDesktopPxl, pdwEffect, &ptClientPxl);
    if (FAILED(hr) || (*pdwEffect == DROPEFFECT_NONE)) {
        return hr;
    }

    AssertMsg(HasTarget(), "Must have a target if UpdateTarget() succeeds");


    //
    // Now that the state has been updated, execute the actual drop.
    //

    POINTL ptDrop = { ptClientPxl.x, ptClientPxl.y };
    m_pdtCur->Drop(pdoSrc, m_grfLastKeyState, ptDrop, pdwEffect);

    xwDragLeave();
    SafeRelease(m_pdoSrc);

    return S_OK;
}


/***************************************************************************\
*
* OldDropTarget::xwDragScan
*
* xwDragScan() is called from the various IDropTarget methods to process
* a request coming from outside.
*
\***************************************************************************/

HRESULT
OldDropTarget::xwDragScan(
    IN  POINTL ptDesktopPxl,        // Cursor location on desktop
    OUT DWORD * pdwEffect,          // Resulting DROPEFFECT
    OUT POINT * pptClientPxl)       // Cursor location in client
{
    POINT ptContainerPxl;
    RECT rcDesktopPxl;

    GetClientRect(m_hwnd, &rcDesktopPxl);
    ClientToScreen(m_hwnd, (LPPOINT) &(rcDesktopPxl.left));

    ptContainerPxl.x = ptDesktopPxl.x - rcDesktopPxl.left;
    ptContainerPxl.y = ptDesktopPxl.y - rcDesktopPxl.top;;

    return xwUpdateTarget(ptContainerPxl, pdwEffect, pptClientPxl);
}

    
/***************************************************************************\
*
* OldDropTarget::xwUpdateTarget
*
* xwUpdateTarget() provides the "worker" of DropTarget, updating 
* Enter, Leave, and Over information for the Gadgets in the tree.
*
\***************************************************************************/

HRESULT
OldDropTarget::xwUpdateTarget(
    IN  POINT ptContainerPxl,       // Cursor location in container
    OUT DWORD * pdwEffect,          // Resulting DROPEFFECT
    OUT POINT * pptClientPxl)       // Cursor location in client
{
    AssertMsg(HasSource(), "Only call when have valid data source");
    AssertWritePtr(pdwEffect);
    AssertWritePtr(pptClientPxl);

    m_ptLastContainerPxl = ptContainerPxl;

    //
    // Determine the Gadget that is currently at the drop location.  We use this
    // as a starting point.
    //

    HGADGET hgadFound = FindGadgetFromPoint(m_hgadSubject, ptContainerPxl, GS_VISIBLE | GS_ENABLED, pptClientPxl);
    if (hgadFound == NULL) {
        *pdwEffect = DROPEFFECT_NONE;
        return S_OK;
    }

    return xwUpdateTarget(hgadFound, pdwEffect, pptClientPxl);
}


/***************************************************************************\
*
* OldDropTarget::xwUpdateTarget
*
* xwUpdateTarget() provides the "worker" of DropTarget, updating 
* Enter, Leave, and Over information for the Gadgets in the tree.
*
\***************************************************************************/

HRESULT
OldDropTarget::xwUpdateTarget(
    IN  HGADGET hgadFound,          // Gadget getting Drop
    OUT DWORD * pdwEffect,          // Resulting DROPEFFECT
    IN  POINT * pptClientPxl)       // Cursor location in client
{
    HRESULT hr = S_OK;


    //
    // Check if the drop Gadget has changed.
    //

    if ((hgadFound != NULL) && (hgadFound != m_hgadDrop)) {
        //
        // Ask the new Gadget if he wants to participate in Drag & Drop.
        //

        GMSG_QUERYDROPTARGET msg;
        ZeroMemory(&msg, sizeof(msg));
        msg.cbSize  = sizeof(msg);
        msg.nMsg    = GM_QUERY;
        msg.nCode   = GQUERY_DROPTARGET;
        msg.hgadMsg = hgadFound;

        static int s_cSend = 0;
        Trace("Send Query: %d to 0x%p\n", s_cSend++, hgadFound);

        HRESULT hr = DUserSendEvent(&msg, SGM_FULL);
        if (IsHandled(hr)) {
            if ((msg.hgadDrop != NULL) && (msg.pdt != NULL)) {
                if (msg.hgadDrop != hgadFound) {
                    //
                    // The message returned a different to handle the DnD request,
                    // so we need to re-adjust.  We know that this Gadget is enabled
                    // and visible since it is in our parent chain and we are already
                    // enabled and visible.
                    //

#if DBG
                    BOOL fChain = FALSE;
                    IsGadgetParentChainStyle(msg.hgadDrop, GS_VISIBLE | GS_ENABLED, &fChain, 0);
                    if (!fChain) {
                        Trace("WARNING: DUser: DropTarget: Parent chain for 0x%p is not fully visible and enabled.\n", msg.hgadDrop);
                    }
#endif

                    MapGadgetPoints(hgadFound, msg.hgadDrop, pptClientPxl, 1);
                }
            }
        } else {
            msg.hgadDrop    = NULL;
            msg.pdt         = NULL;
        }


        //
        // Notify the old Gadget that the Drag operation has left him.
        // Update to new state
        // Notify the new Gadget that the Drag operation has entered him.
        //

        if (m_hgadDrop != msg.hgadDrop) {
            xwDragLeave();

            m_hgadDrop  = msg.hgadDrop;
            m_pdtCur    = msg.pdt;

            hr = xwDragEnter(pptClientPxl, pdwEffect);
            if (FAILED(hr) || (*pdwEffect == DROPEFFECT_NONE)) {
                goto Exit;
            }
        } else {
            SafeRelease(msg.pdt);
            *pdwEffect = DROPEFFECT_NONE;
        }
    }


    //
    // Update the DropTarget
    //

    if (HasTarget()) {
        POINTL ptDrop = { pptClientPxl->x, pptClientPxl->y };
        hr = m_pdtCur->DragOver(m_grfLastKeyState, ptDrop, pdwEffect);
    }

Exit:
    AssertMsg(FAILED(hr) || 
            ((*pdwEffect == DROPEFFECT_NONE) && !HasTarget()) ||
            HasTarget(),
            "Check valid return state");

    return hr;
}


/***************************************************************************\
*
* OldDropTarget::xwDragEnter
*
* xwDragEnter() is called when entering a new Gadget during a DnD operation.
*
\***************************************************************************/

HRESULT
OldDropTarget::xwDragEnter(
    IN OUT POINT * pptClientPxl,    // Client location (updated)
    OUT DWORD * pdwEffect)          // Resulting DROPEFFECT
{
    AssertMsg(HasSource(), "Only call when have valid data source");

    //
    // Notify the new Gadget that the drop has entered him.
    //

    if (HasTarget()) {
        POINTL ptDrop = { pptClientPxl->x, pptClientPxl->y };
        HRESULT hr = m_pdtCur->DragEnter(m_pdoSrc, m_grfLastKeyState, ptDrop, pdwEffect);
        if (FAILED(hr)) {
            return hr;
        }
    } else {
        *pdwEffect = DROPEFFECT_NONE;
    }

    return S_OK;
}


/***************************************************************************\
*
* OldDropTarget::xwDragLeave
*
* xwDragLeave() is called when leaving a Gadget during a DnD operation.
*
\***************************************************************************/

void
OldDropTarget::xwDragLeave()
{
    if (HasTarget()) {
        m_pdtCur->DragLeave();
        m_pdtCur->Release();
        m_pdtCur = NULL;

        m_hgadDrop = NULL;
    }
}


//------------------------------------------------------------------------------
void
OldDropTarget::OnDestroyListener()
{
    Release();
}


//------------------------------------------------------------------------------
void
OldDropTarget::OnDestroySubject()
{
    if (IsWindow(m_hwnd)) {
        GetComManager()->RevokeDragDrop(m_hwnd);
    }

    //CoLockObjectExternal(pdt, FALSE, TRUE);
    OldExtension::DeleteHandle();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\interpolation.h ===
#if !defined(CTRL__Interpolation_h__INCLUDED)
#define CTRL__Interpolation_h__INCLUDED
#pragma once

#if ENABLE_MSGTABLE_API

/***************************************************************************\
*****************************************************************************
*
* class DuInterpolation
*
*****************************************************************************
\***************************************************************************/

class DuInterpolation :
        public InterpolationImpl<DuInterpolation, DUser::SGadget>
{
// Operations
public:
    inline DuInterpolation()
    {
        m_cRef = 1;
    }


    dapi HRESULT ApiAddRef(Interpolation::AddRefMsg *)
    {
        m_cRef++;
        return S_OK;
    }


    dapi HRESULT ApiRelease(Interpolation::ReleaseMsg *)
    {
        if (--m_cRef == 0) {
            DeleteHandle(GetHandle());
        }
        return S_OK;
    }


    dapi HRESULT ApiCompute(Interpolation::ComputeMsg * pmsg)
    {
        pmsg->flResult = 0.0f;
        return S_OK;
    }

// Data
protected:
            ULONG       m_cRef;
};


/***************************************************************************\
*****************************************************************************
*
* class DuLinearInterpolation
*
*****************************************************************************
\***************************************************************************/

class DuLinearInterpolation :
        public LinearInterpolationImpl<DuLinearInterpolation, DuInterpolation>
{
// Operations
public:
    dapi HRESULT ApiCompute(Interpolation::ComputeMsg * pmsg)
    {
        pmsg->flResult = (1.0f - pmsg->flProgress) * pmsg->flStart + pmsg->flProgress * pmsg->flEnd;
        
        return S_OK;
    }
};

        
/***************************************************************************\
*****************************************************************************
*
* class DuLogInterpolation
*
*****************************************************************************
\***************************************************************************/

class DuLogInterpolation :
        public LogInterpolationImpl<DuLogInterpolation, DuInterpolation>
{
// Operations
public:
    inline  DuLogInterpolation()
    {
        m_flScale = 1.0f;
    }

    dapi HRESULT ApiCompute(Interpolation::ComputeMsg * pmsg)
    {
        float flMax = (float) log10(m_flScale * 9.0f + 1.0f);
        float flT   = (float) log10(pmsg->flProgress * m_flScale * 9.0f + 1.0f) / flMax;
        pmsg->flResult = (1.0f - flT) * pmsg->flStart + flT * pmsg->flEnd;
        
        return S_OK;
    }

    dapi HRESULT ApiSetScale(LogInterpolation::SetScaleMsg * pmsg)
    {
        m_flScale = pmsg->flScale;
        
        return S_OK;
    }

// Data
protected:
            float       m_flScale;
};


/***************************************************************************\
*****************************************************************************
*
* class DuExpInterpolation
*
*****************************************************************************
\***************************************************************************/

class DuExpInterpolation :
        public ExpInterpolationImpl<DuExpInterpolation, DuInterpolation>
{
// Operations
public:
    inline  DuExpInterpolation()
    {
        m_flScale = 1.0f;
    }

    dapi HRESULT ApiCompute(Interpolation::ComputeMsg * pmsg)
    {
        double dflProgress  = pmsg->flProgress;
        double dflStart     = pmsg->flStart;
        double dflEnd       = pmsg->flEnd;
        double dflScale     = m_flScale;

        double dflMax = (((10.0 * dflScale) - 1.0) / 9.0);
        double dflT   = (((pow(10.0 * dflScale, dflProgress) - 1.0) / 9.0) / dflMax);
        pmsg->flResult = (float) ((1.0 - dflT) * dflStart + dflT * dflEnd);

        return S_OK;
    }

    dapi HRESULT ApiSetScale(ExpInterpolation::SetScaleMsg * pmsg)
    {
        m_flScale = pmsg->flScale;

        return S_OK;
    }

// Data
protected:
            float       m_flScale;
};

        
/***************************************************************************\
*****************************************************************************
*
* class DuSCurveInterpolation
*
*****************************************************************************
\***************************************************************************/

class DuSCurveInterpolation :
        public SCurveInterpolationImpl<DuSCurveInterpolation, DuInterpolation>
{
// Operations
public:
    inline  DuSCurveInterpolation()
    {
        m_flScale = 1.0f;
    }

    dapi HRESULT ApiCompute(Interpolation::ComputeMsg * pmsg)
    {
        //
        // Slow - fast - slow
        //

        double dflProgress  = pmsg->flProgress;
        double dflStart     = pmsg->flStart;
        double dflEnd       = pmsg->flEnd;
        double dflScale     = m_flScale;
        double dflMax;
        double dflT;

        if (dflProgress < 0.5) {
            double dflPartProgress = dflProgress * 2.0;
            dflMax = (((10.0 * dflScale) - 1.0) / 9.0) * 2.0;
            dflT   = ((pow(10.0 * dflScale, dflPartProgress) - 1.0) / 9.0) / dflMax;
        } else {
            double dflPartProgress = (1.0 - dflProgress) * 2.0;
            dflMax = (((10.0 * dflScale) - 1.0) / 9.0) * 2.0;
            dflT   = 1.0 - ((pow(10.0 * dflScale, dflPartProgress) - 1.0) / 9.0) / dflMax;
        }

        pmsg->flResult = (float) ((1.0 - dflT) * dflStart + dflT * dflEnd);

        return S_OK;
    }

    dapi HRESULT ApiSetScale(SCurveInterpolation::SetScaleMsg * pmsg)
    {
        m_flScale = pmsg->flScale;

        return S_OK;
    }

// Data
protected:
            float       m_flScale;
};

#endif // ENABLE_MSGTABLE_API

#endif // CTRL__Interpolation_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\olddragdrop.h ===
/***************************************************************************\
*
* File: DragDrop.h
*
* Description:
* DragDrop.h defines drag and drop operations
*
*
* History:
*  7/31/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/

#if !defined(CORE__OldDragDrop_h__INCLUDED)
#define CORE__OldDragDrop_h__INCLUDED
#pragma once

#include "OldExtension.h"

class OldTargetLock;

class OldDropTarget : 
        public OldExtension,
        public IDropTarget
{
protected:
    inline  OldDropTarget();
            ~OldDropTarget();
public:
    static  HRESULT Build(HGADGET hgadRoot, HWND hwnd, OldDropTarget ** ppdt);

// IDropTarget
public:
    STDMETHOD(DragEnter)(IDataObject * pdoSrc, DWORD grfKeyState, POINTL ptDesktopPxl, DWORD * pdwEffect);
    STDMETHOD(DragOver)(DWORD grfKeyState, POINTL ptDesktopPxl, DWORD * pdwEffect);
    STDMETHOD(DragLeave)();
    STDMETHOD(Drop)(IDataObject * pdoSrc, DWORD grfKeyState, POINTL ptDesktopPxl, DWORD * pdwEffect);

// Operations
public:

// Implementation
protected:
    inline  BOOL        HasSource() const;
    inline  BOOL        HasTarget() const;

            HRESULT     xwDragScan(POINTL ptDesktopPxl, DWORD * pdwEffect, POINT * pptClientPxl);
            HRESULT     xwUpdateTarget(POINT ptContainerPxl, DWORD * pdwEffect, POINT * pptClientPxl);
            HRESULT     xwUpdateTarget(HGADGET hgadFound, DWORD * pdwEffect, POINT * pptClientPxl);
            HRESULT     xwDragEnter(POINT * pptClientPxl, DWORD * pdwEffect);
            void        xwDragLeave();

    virtual void        OnDestroyListener();
    virtual void        OnDestroySubject();

// Data
protected:
    static  const IID * s_rgpIID[];
            IDropTarget *
                        m_pdtCur;               // Current Gadget OldDropTarget
            IDataObject *
                        m_pdoSrc;               // Source's data object
            HWND        m_hwnd;                 // Containing HWND
            DWORD       m_grfLastKeyState;      // Last key state
            POINT       m_ptLastContainerPxl;   // Last container pixel
            HGADGET     m_hgadDrop;             // Current OldDropTarget
    static  PRID        s_pridListen;           // PRID for OldDropTarget

    friend class OldTargetLock;
};


class OldTargetLock
{
public:
    inline  OldTargetLock();
    inline  ~OldTargetLock();
            BOOL        Lock(OldDropTarget * p, DWORD * pdwEffect, BOOL fAddRef = TRUE);

protected:
            IUnknown *      m_punk;
            BOOL            m_fAddRef;
};


#include "OldDragDrop.inl"

#endif // CORE__OldDragDrop_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\oldanimation.cpp ===
#include "stdafx.h"
#include "Ctrl.h"
#include "OldAnimation.h"

PRID        OldAlphaAnimation::s_pridAlpha   = 0;
PRID        OldScaleAnimation::s_pridScale   = 0;
PRID        OldRectAnimation::s_pridRect     = 0;
PRID        OldRotateAnimation::s_pridRotate = 0;

static const GUID guidAlphaAnimation    = { 0x41a2e2f2, 0xf262, 0x41ae, { 0x89, 0xda, 0xb7, 0x9c, 0x8f, 0xf5, 0x94, 0xbb } };   // {41A2E2F2-F262-41ae-89DA-B79C8FF594BB}
static const GUID guidScaleAnimation    = { 0xa5b1df84, 0xb9c0, 0x4305, { 0xb9, 0x3a, 0x5b, 0x80, 0x31, 0x86, 0x70, 0x69 } };   // {A5B1DF84-B9C0-4305-B93A-5B8031867069}
static const GUID guidRectAnimation     = { 0x8e41c241, 0x3cdf, 0x432e, { 0xa1, 0xae, 0xf, 0x7b, 0x59, 0xdc, 0x82, 0xb } };     // {8E41C241-3CDF-432e-A1AE-0F7B59DC820B}
static const GUID guidRotateAnimation   = { 0x78f16dd5, 0xa198, 0x4cd2, { 0xb1, 0x78, 0x31, 0x61, 0x3e, 0x32, 0x12, 0x54 } };   // {78F16DD5-A198-4cd2-B178-31613E321254}


const IID * OldAlphaAnimation::s_rgpIID[] =
{
    &__uuidof(IUnknown),
    &__uuidof(IAnimation),
    NULL
};

const IID * OldScaleAnimation::s_rgpIID[] =
{
    &__uuidof(IUnknown),
    &__uuidof(IAnimation),
    NULL
};

const IID * OldRectAnimation::s_rgpIID[] =
{
    &__uuidof(IUnknown),
    &__uuidof(IAnimation),
    NULL
};

const IID * OldRotateAnimation::s_rgpIID[] =
{
    &__uuidof(IUnknown),
    &__uuidof(IAnimation),
    NULL
};


/***************************************************************************\
*****************************************************************************
*
* class OldAnimation
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
OldAnimation::~OldAnimation()
{
#if DEBUG_TRACECREATION
    Trace("STOP  Animation  0x%p    @ %d  (%d frames)\n", this, GetTickCount(), m_DEBUG_cUpdates);
#endif // DEBUG_TRACECREATION


    //
    // Ensure proper destruction
    //

    AssertMsg(m_hact == NULL, "Action should already be destroyed");
}


//------------------------------------------------------------------------------
HRESULT
OldAnimation::Create(
    IN  const GUID * pguid, 
    IN OUT PRID * pprid, 
    IN  GANI_DESC * pDesc)              // Animation information
{
    if (pDesc->pipol != NULL) {
        pDesc->pipol->AddRef();
        m_pipol = pDesc->pipol;
    }

    if (pDesc->pcb != NULL) {
        pDesc->pcb->AddRef();
        m_pcb = pDesc->pcb;
    }

    GMA_ACTION gma;
    ZeroMemory(&gma, sizeof(gma));
    gma.cbSize      = sizeof(gma);
    gma.flDelay     = pDesc->act.flDelay;
    gma.flDuration  = pDesc->act.flDuration;
    gma.flPeriod    = pDesc->act.flPeriod;
    gma.cRepeat     = pDesc->act.cRepeat;
    gma.dwPause     = pDesc->act.dwPause;
    gma.pfnProc     = RawActionProc;
    gma.pvData      = this;

    m_hact = CreateAction(&gma);
    if (m_hact == NULL) {
        return (HRESULT) GetLastError();
    }

    HRESULT hr = OldExtension::Create(pDesc->hgadChange, pguid, pprid, OldExtension::oAsyncDestroy);
    if (FAILED(hr)) {
        return hr;
    }

    return S_OK;
}


//------------------------------------------------------------------------------
void
OldAnimation::Destroy(BOOL fFinal)
{
    //
    // Mark that we have already started the destruction process and don't need
    // to start again.  We only want to post the destruction message once.
    //

    if (m_fStartDestroy) {
        return;
    }
    m_fStartDestroy = TRUE;


    //
    // Give the derived Animation a chance to cleanup
    //
    // Check that we are still the Animation attached to this Gadget.  We need 
    // to remove this property immediately.  We can not wait for a posted 
    // message to be processed because we may need to set it right now if we are
    // creating a new Animation.
    //

    if (m_hgadSubject != NULL) {
        OnComplete();

#if DBG
        OldAnimation * paniExist = static_cast<OldAnimation *> (GetExtension(m_hgadSubject, m_pridListen));
        if (paniExist != NULL) {
            AssertMsg(paniExist == this, "Animations must match");
        }
#endif // DBG

        CleanupChangeGadget();
    }


    //
    // Destroy the Animation
    //

    AssertMsg(!fFinal, "Object is already being destructed");
    if (fFinal) {
        OnAsyncDestroy();
    } else {
        PostAsyncDestroy();
    }
}


//------------------------------------------------------------------------------
void        
OldAnimation::OnAsyncDestroy()
{
    AssertMsg(m_fStartDestroy, "Must call Destroy() to start the destruction process.");
    AssertMsg(!m_fProcessing, "Should not be processing when start destruction");

    AssertMsg(m_hgadSubject == NULL, "Animation should already have detached from Gadget");
    HACTION hact = m_hact;

    //
    // Notify any callback that the Animation is finished
    //

    if (m_pcb != NULL) {
        IAnimation * paniI = static_cast<IAnimation *> (this);

        __try 
        {
            m_pcb->OnComplete(paniI, m_time);
        }
        __except(StdExceptionFilter(GetExceptionInformation()))
        {
            ExitProcess(GetExceptionCode());
        }
    }


    //
    // Set everything to NULL now.
    //

    m_hact = NULL;
    OldExtension::DeleteHandle();


    //
    // Stop the Action
    //

    if (hact != NULL) {
        ::DeleteHandle(hact);
        hact = NULL;
    }


    //
    // Release() our cached interfaces
    //

    SafeRelease(m_pipol);
    SafeRelease(m_pcb);
}


//------------------------------------------------------------------------------
STDMETHODIMP_(void)
OldAnimation::SetFunction(IInterpolation * pipol)
{
    AssertReadPtr(pipol);

    SafeRelease(m_pipol);
    pipol->AddRef();
    m_pipol = pipol;
}


//------------------------------------------------------------------------------
STDMETHODIMP_(void)
OldAnimation::SetTime(IAnimation::ETime time)
{
    GMA_ACTIONINFO mai;

    //
    // TODO: Need to save these values from the last time so that they are 
    // valid.
    //

    mai.hact        = m_hact;
    mai.pvData      = this;
    mai.flDuration  = 0.0f;

    m_time = time;
    switch (time)
    {
    case IAnimation::tComplete:
        // Don't do anything
        return;

    default:
    case IAnimation::tAbort:
    case IAnimation::tDestroy:
        goto Done;

    case IAnimation::tEnd:
        mai.flProgress  = 1.0f;
        break;

    case IAnimation::tReset:
        mai.flProgress  = 0.0f;
        break;
    }

    mai.cEvent      = 0;
    mai.cPeriods    = 0;
    mai.fFinished   = FALSE;

    m_fProcessing = TRUE;
    Action(&mai);
    Assert(m_fProcessing);
    m_fProcessing = FALSE;

Done:
    if (m_pcb != NULL) {
        IAnimation * paniI = static_cast<IAnimation *> (this);
        m_pcb->OnSetTime(paniI, time);
    }

    ::DeleteHandle(m_hact);
}


//------------------------------------------------------------------------------
STDMETHODIMP_(void)
OldAnimation::SetCallback(IAnimationCallback * pcb)
{
    // pcb can be NULL

    SafeRelease(m_pcb);

    if (pcb != NULL) {
        pcb->AddRef();
        m_pcb = pcb;
    }
}


//------------------------------------------------------------------------------
HRESULT
OldAnimation::GetInterface(HGADGET hgad, PRID prid, REFIID riid, void ** ppvUnk)
{
    OldAnimation * paniExist = static_cast<OldAnimation *> (GetExtension(hgad, prid));
    if (paniExist != NULL) {
        if (IsEqualIID(riid, __uuidof(IAnimation))) {
            paniExist->AddRef();
            *ppvUnk = static_cast<IAnimation *> (paniExist);
            return S_OK;
        } else {
            return paniExist->QueryInterface(riid, ppvUnk);
        }
    }

    return DU_E_NOTFOUND;   // This Animation doesn't exist on this Gadget.
}


//------------------------------------------------------------------------------
void
OldAnimation::CleanupChangeGadget()
{
    Assert(m_hgadSubject != NULL);
    Assert(m_pridListen != 0);

    Verify(::RemoveGadgetProperty(m_hgadSubject, m_pridListen));

    m_hgadSubject = NULL;
}

    
//------------------------------------------------------------------------------
void CALLBACK
OldAnimation::RawActionProc(
    IN  GMA_ACTIONINFO * pmai)
{
    OldAnimation * pani = (OldAnimation *) pmai->pvData;
    pani->AddRef();
    Assert(!pani->m_fProcessing);

#if DBG
    pani->m_DEBUG_cUpdates++;
#endif // DBG

#if DEBUG_TRACECREATION
    Trace("START RawActionP 0x%p    @ %d\n", pani, GetTickCount());
#endif // DEBUG_TRACECREATION

    if ((!pani->m_fStartDestroy) && (pani->m_hgadSubject != NULL)) {
        //
        // This ActionProc will be called when the Action is being destroyed, so
        // we only want to invoke the Action under certain circumstances.
        //

        switch (pani->m_time)
        {
        case tComplete:
        case tEnd:
        case tReset:
            //
            // All of these are valid to complete.  If it isn't in this list, we
            // don't want to execute it during a shutdown.
            //

            pani->m_fProcessing = TRUE;
            pani->Action(pmai);
            Assert(pani->m_fProcessing);
            pani->m_fProcessing = FALSE;
            break;
        }
    }

    if (pmai->fFinished) {
        pani->m_hact = NULL;
        pani->Destroy(FALSE);
    }

#if DEBUG_TRACECREATION
    Trace("STOP  RawActionP 0x%p    @ %d\n", pani, GetTickCount());
#endif // DEBUG_TRACECREATION

    Assert(!pani->m_fProcessing);
    pani->Release();
}


//------------------------------------------------------------------------------
void
OldAnimation::OnRemoveExisting()
{
    SetTime(IAnimation::tDestroy);
}


//------------------------------------------------------------------------------
void
OldAnimation::OnDestroyListener()
{
    AddRef();

    if (m_hgadListen != NULL) {
        //
        // TODO: Figure out when this case can actually occur.  This means that
        // the MessageGadget was destroyed, but the caller didn't go through
        // OldAnimation::Destroy() to do it.
        //

        m_hgadListen = NULL;
        Destroy(FALSE);
    }
    VerifyMsg(Release() > 0, "Must still have lock from beginning of function");

    Release();
}


//------------------------------------------------------------------------------
void
OldAnimation::OnDestroySubject()
{
    AddRef();

    if (m_hgadSubject != NULL) {
        CleanupChangeGadget();

        //
        // The Gadget that we are modifying is being destroyed, so we need
        // to stop animating it.
        //

        m_time = IAnimation::tDestroy;
        Destroy(FALSE);
    }

    Release();
}


/***************************************************************************\
*****************************************************************************
*
* class OldAlphaAnimation
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
OldAlphaAnimation::~OldAlphaAnimation()
{
    Destroy(TRUE);

#if DEBUG_TRACECREATION
    Trace("OldAlphaAnimation 0x%p destroyed\n", this);
#endif // DEBUG_TRACECREATION
}


//------------------------------------------------------------------------------
HRESULT
OldAlphaAnimation::Create(
    IN  GANI_DESC * pDesc)
{
    HRESULT hr = OldAnimation::Create(&guidAlphaAnimation, &s_pridAlpha, pDesc);
    if (FAILED(hr)) {
        return hr;
    }


    //
    // Get the information from the Gadget
    //

    GANI_ALPHADESC * pDescA = (GANI_ALPHADESC *) pDesc;
    m_nOnComplete           = pDescA->nOnComplete;
    m_fPushToChildren       = pDescA->fPushToChildren && 
            (::GetGadget(m_hgadSubject, GG_TOPCHILD) != NULL);

    BOOL fBuffered = TestFlag(::GetGadgetStyle(m_hgadSubject), GS_BUFFERED);

    if (TestFlag(pDesc->nAniFlags, ANIF_USESTART)) {
        m_flStart   = pDescA->flStart;
    } else {
        if (fBuffered) {
            //
            // Gadget is already buffered, so use it current alpha value.
            //

            BUFFER_INFO bi;
            ZeroMemory(&bi, sizeof(bi));
            bi.cbSize   = sizeof(bi);
            bi.nMask    = GBIM_ALPHA;
            if (::GetGadgetBufferInfo(m_hgadSubject, &bi)) {
                m_flStart = ((float) bi.bAlpha) / 255.0f;
            } else {
                m_flStart = 1.0f;
            }
        } else {
            m_flStart = 1.0f;
        }
    }

    if (m_fPushToChildren) {
        //
        // If we are currently alpha blended, we need to turn this off.
        //
        
        if (fBuffered) {
            ::SetGadgetStyle(m_hgadSubject, 0, GS_BUFFERED);
            ::SetGadgetStyle(m_hgadSubject, 0, GS_OPAQUE);
        }
        
        
        //
        // Setup each direct child to be buffered for the alpha-blending
        //

        BYTE bAlpha = (BYTE) (m_flStart * 255.0f);

        HGADGET hgadChild = ::GetGadget(m_hgadSubject, GG_TOPCHILD);
        while (hgadChild != NULL) {
            if (!::SetGadgetStyle(hgadChild, GS_BUFFERED | GS_OPAQUE, GS_BUFFERED | GS_OPAQUE)) {
                return (HRESULT) GetLastError();
            }

            BUFFER_INFO bi;
            bi.cbSize   = sizeof(bi);
            bi.nMask    = GBIM_ALPHA;
            bi.bAlpha   = bAlpha;
            if (!SetGadgetBufferInfo(hgadChild, &bi)) {
                return (HRESULT) GetLastError();
            }

            hgadChild = ::GetGadget(hgadChild, GG_NEXT);
        }
    } else if (!fBuffered) {
        //
        // Need to mark the Gadget as being buffered to perform alpha effects
        //

        if (!::SetGadgetStyle(m_hgadSubject, GS_BUFFERED | GS_OPAQUE, GS_BUFFERED | GS_OPAQUE)) {
            return (HRESULT) GetLastError();
        }
    }

    m_flEnd = pDescA->flEnd;

#if DEBUG_TRACECREATION
    Trace("OldAlphaAnimation 0x%p on 0x%p initialized\n", m_hgadSubject, this);
#endif // DEBUG_TRACECREATION

    return S_OK;
}


//------------------------------------------------------------------------------
STDMETHODIMP_(UINT)
OldAlphaAnimation::GetID() const
{
    return ANIMATION_ALPHA;
}


//------------------------------------------------------------------------------
void        
OldAlphaAnimation::Action(GMA_ACTIONINFO * pmai)
{
    float flPr      = pmai->flProgress;
    float flAlpha   = m_pipol->Compute(flPr, m_flStart, m_flEnd);

    BYTE bAlpha;
    if (flAlpha < 0.0f) {
        bAlpha = (BYTE) 0;
    } else if (flAlpha > 1.0f) {
        bAlpha = (BYTE) 255;
    } else {
        bAlpha = (BYTE) (flAlpha * 255.0f);
    }

    BUFFER_INFO bi;
    bi.cbSize   = sizeof(bi);
    bi.nMask    = GBIM_ALPHA;
    bi.bAlpha   = bAlpha;

    if (m_fPushToChildren) {
        HGADGET hgadChild = ::GetGadget(m_hgadSubject, GG_TOPCHILD);
        while (hgadChild != NULL) {
            SetGadgetStyle(hgadChild, GS_BUFFERED | GS_OPAQUE, GS_BUFFERED | GS_OPAQUE);
            SetGadgetBufferInfo(hgadChild, &bi);
            InvalidateGadget(hgadChild);

            hgadChild = ::GetGadget(hgadChild, GG_NEXT);
        }
    } else {
        SetGadgetStyle(m_hgadSubject, GS_BUFFERED | GS_OPAQUE, GS_BUFFERED | GS_OPAQUE);
        SetGadgetBufferInfo(m_hgadSubject, &bi);
        InvalidateGadget(m_hgadSubject);
    }
}


//------------------------------------------------------------------------------
void        
OldAlphaAnimation::OnComplete()
{
    if (TestFlag(m_nOnComplete, GANI_ALPHACOMPLETE_OPTIMIZE)) {
        if ((m_flEnd * 255.0f) >= 245) {
            if (m_fPushToChildren) {
                HGADGET hgadChild = ::GetGadget(m_hgadSubject, GG_TOPCHILD);
                while (hgadChild != NULL) {
                    SetGadgetStyle(hgadChild, 0, GS_BUFFERED);
                    hgadChild = ::GetGadget(hgadChild, GG_NEXT);
                }
            } else {
                SetGadgetStyle(m_hgadSubject, 0, GS_BUFFERED);
            }
            InvalidateGadget(m_hgadSubject);
        }
    }
}


/***************************************************************************\
*****************************************************************************
*
* class OldScaleAnimation
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
OldScaleAnimation::~OldScaleAnimation()
{
    Destroy(TRUE);

#if DEBUG_TRACECREATION
    Trace("OldScaleAnimation 0x%p destroyed\n", this);
#endif // DEBUG_TRACECREATION
}


//------------------------------------------------------------------------------
HRESULT
OldScaleAnimation::Create(
    IN  GANI_DESC * pDesc)
{
    HRESULT hr = OldAnimation::Create(&guidScaleAnimation, &s_pridScale, pDesc);
    if (FAILED(hr)) {
        return hr;
    }


    //
    // Get the information from the Gadget
    //

    GANI_SCALEDESC * pDescS = (GANI_SCALEDESC *) pDesc;

    if (TestFlag(pDesc->nAniFlags, ANIF_USESTART)) {
        m_flStart   = pDescS->flStart;
    } else {
        float flX, flY;
        if (!::GetGadgetScale(m_hgadSubject, &flX, &flY)) {
            return (HRESULT) GetLastError();
        }

        m_flStart       = flX;
    }
    m_flEnd         = pDescS->flEnd;
    m_al            = pDescS->al;


    RECT rcParent;
    ::GetGadgetRect(m_hgadSubject, &rcParent, SGR_PARENT);
    m_ptStart.x     = rcParent.left;
    m_ptStart.y     = rcParent.top;
    m_sizeCtrl.cx   = rcParent.right - rcParent.left;
    m_sizeCtrl.cy   = rcParent.bottom - rcParent.top;

#if DEBUG_TRACECREATION
    Trace("OldScaleAnimation 0x%p on 0x%p initialized\n", m_hgadSubject, this);
#endif // DEBUG_TRACECREATION

    return S_OK;
}


//------------------------------------------------------------------------------
STDMETHODIMP_(UINT)
OldScaleAnimation::GetID() const
{
    return ANIMATION_SCALE;
}


//------------------------------------------------------------------------------
void        
OldScaleAnimation::Action(GMA_ACTIONINFO * pmai)
{
    float flPr  = pmai->flProgress;
    float flx   = m_pipol->Compute(flPr, m_flStart, m_flEnd);
    float fly   = flx;
    ::SetGadgetScale(m_hgadSubject, flx, fly);

    POINT ptNew;
    ptNew.x     = m_ptStart.x - (int) ((m_sizeCtrl.cx * flx - m_sizeCtrl.cx) / 2.0);
    ptNew.y     = m_ptStart.y - (int) ((m_sizeCtrl.cy * fly - m_sizeCtrl.cy) / 2.0);
    ::SetGadgetRect(m_hgadSubject, ptNew.x, ptNew.y, 0, 0, SGR_MOVE | SGR_PARENT);
}


/***************************************************************************\
*****************************************************************************
*
* class OldRectAnimation
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
OldRectAnimation::~OldRectAnimation()
{
    Destroy(TRUE);

#if DEBUG_TRACECREATION
    Trace("OldRectAnimation 0x%p destroyed\n", this);
#endif // DEBUG_TRACECREATION
}


//------------------------------------------------------------------------------
HRESULT
OldRectAnimation::Create(
    IN  GANI_DESC * pDesc)
{
    HRESULT hr = OldAnimation::Create(&guidRectAnimation, &s_pridRect, pDesc);
    if (FAILED(hr)) {
        return hr;
    }


    //
    // Get the information from the Gadget
    //

    GANI_RECTDESC * pDescR = (GANI_RECTDESC *) pDesc;

    UINT nGetFlags = SGR_VALID_GET & pDescR->nChangeFlags;
    if (nGetFlags == 0) {
        return E_INVALIDARG;
    }

    if (TestFlag(pDesc->nAniFlags, ANIF_USESTART)) {
        m_ptStart   = pDescR->ptStart;
        m_sizeStart = pDescR->sizeStart;
    } else {
        RECT rcGadget;
        if (!::GetGadgetRect(m_hgadSubject, &rcGadget, nGetFlags)) {
            return (HRESULT) GetLastError();
        }

        m_ptStart.x     = rcGadget.left;
        m_ptStart.y     = rcGadget.top;
        m_sizeStart.cx  = rcGadget.right - rcGadget.left;
        m_sizeStart.cy  = rcGadget.bottom - rcGadget.top;
    }

    m_ptEnd         = pDescR->ptEnd;
    m_sizeEnd       = pDescR->sizeEnd;
    m_nChangeFlags  = pDescR->nChangeFlags;

#if DEBUG_TRACECREATION
    Trace("OldRectAnimation  0x%p on 0x%p initialized\n", m_hgadSubject, this);
#endif // DEBUG_TRACECREATION

    return S_OK;
}


//------------------------------------------------------------------------------
STDMETHODIMP_(UINT)
OldRectAnimation::GetID() const
{
    return ANIMATION_RECT;
}


//------------------------------------------------------------------------------
void        
OldRectAnimation::Action(GMA_ACTIONINFO * pmai)
{
    POINT ptNew;
    SIZE sizeNew;
    float flProgress = pmai->flProgress;

    ptNew.x     = Compute(m_pipol, flProgress, m_ptStart.x, m_ptEnd.x);
    ptNew.y     = Compute(m_pipol, flProgress, m_ptStart.y, m_ptEnd.y);
    sizeNew.cx  = Compute(m_pipol, flProgress, m_sizeStart.cx, m_sizeEnd.cx);
    sizeNew.cy  = Compute(m_pipol, flProgress, m_sizeStart.cy, m_sizeEnd.cy);

    SetGadgetRect(m_hgadSubject, ptNew.x, ptNew.y, sizeNew.cx, sizeNew.cy, m_nChangeFlags);
}


/***************************************************************************\
*****************************************************************************
*
* class OldRotateAnimation
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
OldRotateAnimation::~OldRotateAnimation()
{
    Destroy(TRUE);

#if DEBUG_TRACECREATION
    Trace("OldRotateAnimation 0x%p destroyed\n", this);
#endif // DEBUG_TRACECREATION
}


//------------------------------------------------------------------------------
HRESULT
OldRotateAnimation::Create(
    IN  GANI_DESC * pDesc)
{
    HRESULT hr = OldAnimation::Create(&guidRotateAnimation, &s_pridRotate, pDesc);
    if (FAILED(hr)) {
        return hr;
    }


    //
    // Get the information from the Gadget
    //

    GANI_ROTATEDESC * pDescR = (GANI_ROTATEDESC *) pDesc;

    if (TestFlag(pDesc->nAniFlags, ANIF_USESTART)) {
        m_flStart = pDescR->flStart;
    } else {
        if (!::GetGadgetRotation(m_hgadSubject, &m_flStart)) {
            return (HRESULT) GetLastError();
        }
    }

    m_flEnd = pDescR->flEnd;
    m_nDir  = pDescR->nDir;


    //
    // Adjust the starting and ending angles so that we "move" in the correct
    // direction.  We do this by adding or subtracting full rotations depending
    // on the "move" we are trying to accomplish.
    //

    switch (m_nDir)
    {
    case GANI_ROTATEDIRECTION_SHORT:
        if (m_flStart < m_flEnd) {
            while ((m_flEnd - m_flStart) > (float) PI) {
                m_flStart += (float) (2 * PI);
            }
        } else {
            while ((m_flStart - m_flEnd) > (float) PI) {
                m_flStart -= (float) (2 * PI);
            }
        }
        break;

    case GANI_ROTATEDIRECTION_LONG:
        if (m_flStart < m_flEnd) {
            while ((m_flStart - m_flEnd) < (float) PI) {
                m_flEnd -= (float) (2 * PI);
            }
        } else {
            while ((m_flEnd - m_flStart) < (float) PI) {
                m_flEnd += (float) (2 * PI);
            }
        }
        break;

    case GANI_ROTATEDIRECTION_CW:
        while (m_flStart > m_flEnd) {
            m_flEnd += (float) (2 * PI);
        }
        break;

    case GANI_ROTATEDIRECTION_CCW:
        while (m_flStart < m_flEnd) {
            m_flStart += (float) (2 * PI);
        }
        break;
    }


#if DEBUG_TRACECREATION
    Trace("OldRotateAnimation  0x%p on 0x%p initialized\n", m_hgadSubject, this);
#endif // DEBUG_TRACECREATION

    return S_OK;
}


//------------------------------------------------------------------------------
STDMETHODIMP_(UINT)
OldRotateAnimation::GetID() const
{
    return ANIMATION_ROTATE;
}


//------------------------------------------------------------------------------
void        
OldRotateAnimation::Action(GMA_ACTIONINFO * pmai)
{
    float flProgress    = pmai->flProgress;
    float flAngleNew = Compute(m_pipol, flProgress, m_flStart, m_flEnd);

    SetGadgetRotation(m_hgadSubject, flAngleNew);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\oldextension.h ===
#if !defined(CTRL__OldExtension_h__INCLUDED)
#define CTRL__OldExtension_h__INCLUDED
#pragma once

class OldExtension
{
// Construction
public:
    inline  OldExtension();
    virtual ~OldExtension();

    enum EOptions
    {
        oUseExisting    = 0x00000001,   // Use existing Extension if already attached
        oAsyncDestroy   = 0x00000002,   // Use asynchronous destruction
    };

            HRESULT     Create(HGADGET hgadChange, const GUID * pguid, PRID * pprid, UINT nOptions);
            void        Destroy();
            void        DeleteHandle();

// Implementation
protected:
    virtual void        OnRemoveExisting();
    virtual void        OnDestroySubject();
    virtual void        OnDestroyListener();
    virtual void        OnAsyncDestroy();

            void        PostAsyncDestroy();
    static  OldExtension * GetExtension(HGADGET hgadSubject, PRID prid);

private:
    static  HRESULT CALLBACK
                        ListenProc(HGADGET hgadCur, void * pvCur, EventMsg * pmsg);

// Data
protected:
            HGADGET     m_hgadSubject;  // Gadget being "extended"
            HGADGET     m_hgadListen;   // Listener for destruction
            PRID        m_pridListen;   // PRID for Extension
            BOOL        m_fAsyncDestroy:1;
                                        // Need to destroy asynchronously

    static  MSGID       s_msgidAsyncDestroy;
};


#include "OldExtension.inl"

#endif // CTRL__OldExtension_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\oldextension.inl ===
#if !defined(CTRL__Extension_inl__INCLUDED)
#define CTRL__Extension_inl__INCLUDED
#pragma once

//------------------------------------------------------------------------------
inline OldExtension::OldExtension()
{

}


#endif // CTRL__Extension_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\oldinterpolation.cpp ===
#include "stdafx.h"
#include "Ctrl.h"
#include "OldInterpolation.h"

const IID * OldLinearInterpolation::s_rgpIID[] =
{
    &__uuidof(IUnknown),
    &__uuidof(IInterpolation),
    &__uuidof(ILinearInterpolation),
    NULL
};

const IID * OldLogInterpolation::s_rgpIID[] =
{
    &__uuidof(IUnknown),
    &__uuidof(IInterpolation),
    &__uuidof(ILogInterpolation),
    NULL
};

const IID * OldExpInterpolation::s_rgpIID[] =
{
    &__uuidof(IUnknown),
    &__uuidof(IInterpolation),
    &__uuidof(IExpInterpolation),
    NULL
};

const IID * OldSInterpolation::s_rgpIID[] =
{
    &__uuidof(IUnknown),
    &__uuidof(IInterpolation),
    &__uuidof(ISInterpolation),
    NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\public.h ===
/***************************************************************************\
*
* File: Public.h
*
* Description:
* Public.h contains a list of definitions that are exposed and available
* outside this project.  Any other DirectUser project that wishes to use
* these services directly instead of going through public API's can include
* a corresponding [Project]P.h available in the \inc directory.  
* 
* Definitions that are not exposed through this file are considered project 
* specific implementation details and should not used in other projects.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(CTRL__Public_h__INCLUDED)
#define CTRL__Public_h__INCLUDED

#include "Init.h"
#include "GdiHelp.h"

#endif // CTRL__Public_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\oldextension.cpp ===
#include "stdafx.h"
#include "Ctrl.h"
#include "OldExtension.h"

/***************************************************************************\
*****************************************************************************
*
* class OldExtension
*
*****************************************************************************
\***************************************************************************/

static const GUID guidAysncDestroy      = { 0xbfe02331, 0xc17d, 0x45ea, { 0x96, 0x35, 0xa0, 0x7a, 0x90, 0x37, 0xfe, 0x34 } };   // {BFE02331-C17D-45ea-9635-A07A9037FE34}
MSGID       OldExtension::s_msgidAsyncDestroy = 0;

/***************************************************************************\
*
* OldExtension::~OldExtension
*
* ~OldExtension() checks that resources were properly cleaned up before the
* OldExtension was destroyed.
*
\***************************************************************************/

OldExtension::~OldExtension()
{
    //
    // Ensure proper destruction
    //

    AssertMsg(m_hgadListen == NULL, "Gadget should already be destroyed");
}


/***************************************************************************\
*
* OldExtension::Create
*
* Create() initializes a new OldExtension and attaches it to the subject Gadget
* being modified.
*
\***************************************************************************/

HRESULT
OldExtension::Create(
    IN  HGADGET hgadSubject,            // Gadget being "extended"
    IN  const GUID * pguid,             // Unique ID of OldExtension
    IN OUT PRID * pprid,                // Short ID for OldExtension
    IN  UINT nOptions)                  // Options
{
    AssertWritePtr(pprid);


    //
    // Do not allow attaching a OldExtension to a Gadget that has already started 
    // the destruction process.
    //

    BOOL fStartDelete;
    if ((!IsStartDelete(hgadSubject, &fStartDelete)) || fStartDelete) {
        return DU_E_STARTDESTROY;
    }


    //
    // Setup information necessary for asynchronous destruction.
    //

    m_fAsyncDestroy = TestFlag(nOptions, oAsyncDestroy);
    if (m_fAsyncDestroy) {
        if (s_msgidAsyncDestroy == 0) {
            s_msgidAsyncDestroy = RegisterGadgetMessage(&guidAysncDestroy);
            if (s_msgidAsyncDestroy == 0) {
                return (HRESULT) GetLastError();
            }
        }
    }


    //
    // Determine if this OldExtension is already attached to the Gadget being 
    // extended.
    //

    if (*pprid == 0) {
        *pprid = RegisterGadgetProperty(pguid);
        if (*pprid == 0) {
            return GetLastError();
        }
    }
    PRID prid = *pprid;

    OldExtension * pbExist;
    if (GetGadgetProperty(hgadSubject, prid, (void **) &pbExist) != NULL) {
        if (TestFlag(nOptions, oUseExisting)) {
            return DU_S_ALREADYEXISTS;
        } else {
            //
            // Already attached, but can't use the existing one.  We need to
            // remove the existing OldExtension before attaching the new one.  After
            // calling RemoveExisting(), the OldExtension should no longer be 
            // attached to the Gadget.
            //

            pbExist->OnRemoveExisting();
            Assert(!GetGadgetProperty(hgadSubject, prid, (void **) &pbExist));
        }
    }


    //
    // Setup a listener to be notifyed when the RootGadget is destroyed.
    //

    HRESULT hr = S_OK;
    m_hgadListen = CreateGadget(NULL, GC_MESSAGE, ListenProc, this);
    if (m_hgadListen == NULL) {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    m_hgadSubject   = hgadSubject;
    m_pridListen    = prid;

    if (!SetGadgetProperty(hgadSubject, prid, this) || 
            (!AddGadgetMessageHandler(hgadSubject, GM_DESTROY, m_hgadListen))) {

        DeleteObject(m_hgadListen);
        m_hgadListen = NULL;
        hr = E_OUTOFMEMORY;
        goto Error;
    }


    //
    // Successfully created the OldExtension
    //

    return S_OK;

Error:
    Destroy();
    return hr;
}


/***************************************************************************\
*
* OldExtension::Destroy
*
* Destroy() is called from the derived class to cleanup resources associated
* with the OldExtension.
*
\***************************************************************************/

void
OldExtension::Destroy()
{
    //
    // Since the OldExtension is being destroyed, need to ensure that it is no 
    // longer "attached" to the Gadget being extended
    //

    if ((m_pridListen != 0) && (m_hgadSubject != NULL)) {
        OldExtension * pb;
        if (GetGadgetProperty(m_hgadSubject, m_pridListen, (void **) &pb)) {
            if (pb == this) {
                RemoveGadgetProperty(m_hgadSubject, m_pridListen);
            }
        }
    }

    if (m_hgadListen != NULL) {
        ::DeleteHandle(m_hgadListen);
        m_hgadListen = NULL;
    }
}


/***************************************************************************\
*
* OldExtension::DeleteHandle
*
* DeleteHandle() starts the destruction process for the OldExtension.
*
\***************************************************************************/

void
OldExtension::DeleteHandle()
{
    if (m_hgadListen != NULL) {
        HGADGET hgad = m_hgadListen;
        m_hgadListen = NULL;
        ::DeleteHandle(hgad);
    }
}


/***************************************************************************\
*
* OldExtension::ListenProc
*
* ListenProc() is called on the MessageGadget Listener attached to the
* RootGadget.
*
\***************************************************************************/

HRESULT
OldExtension::ListenProc(HGADGET hgadCur, void * pvCur, EventMsg * pmsg)
{
    UNREFERENCED_PARAMETER(hgadCur);
    OldExtension * pb = (OldExtension *) pvCur;

    switch (GET_EVENT_DEST(pmsg))
    {
    case GMF_DIRECT:
        if (pmsg->nMsg == GM_DESTROY) {
            GMSG_DESTROY * pmsgD = (GMSG_DESTROY *) pmsg;
            if (pmsgD->nCode == GDESTROY_FINAL) {
                pb->OnDestroyListener();
                return DU_S_PARTIAL;
            }
        } else if (pb->m_fAsyncDestroy && (pmsg->nMsg == s_msgidAsyncDestroy)) {
            pb->OnAsyncDestroy();
            return DU_S_PARTIAL;
        }
        break;

    case GMF_EVENT:
        if (pmsg->nMsg == GM_DESTROY) {
            if (((GMSG_DESTROY *) pmsg)->nCode == GDESTROY_FINAL) {
                pb->OnDestroySubject();
                return DU_S_PARTIAL;
            }
        }
        break;
    }

    return DU_S_NOTHANDLED;
}


/***************************************************************************\
*
* OldExtension::OnRemoveExisting
*
* OnRemoveExisting() is called when creating a new OldExtension to remove an
* existing OldExtension already attached to the subject Gadget.
*
\***************************************************************************/

void
OldExtension::OnRemoveExisting()
{

}


/***************************************************************************\
*
* OldExtension::OnDestroySubject
*
* OnDestroySubject() notifies the derived OldExtension that the subject Gadget
* being modified has been destroyed.
*
\***************************************************************************/

void
OldExtension::OnDestroySubject()
{

}


/***************************************************************************\
*
* OldExtension::OnDestroyListener
*
* OnDestroyListener() notifies the derived OldExtension that the internal
* "Listener" Gadget has been destroyed and that the OldExtension should start
* its destruction process.
*
\***************************************************************************/

void
OldExtension::OnDestroyListener()
{

}


/***************************************************************************\
*
* OldExtension::OnAsyncDestroy
*
* OnAsyncDestroy() is called when the OldExtension receives an asynchronous
* destruction message that was previously posted.  This provides the derived
* OldExtension an opportunity to start the destruction process without being
* nested several levels.
*
\***************************************************************************/

void
OldExtension::OnAsyncDestroy()
{

}


/***************************************************************************\
*
* OldExtension::PostAsyncDestroy
*
* PostAsyncDestroy() queues an asynchronous destruction message.  This 
* provides the derived OldExtension an opportunity to start the destruction 
* process without being nested several levels.
*
\***************************************************************************/

void
OldExtension::PostAsyncDestroy()
{
    AssertMsg(m_fAsyncDestroy, 
            "Must create OldExtension with oAsyncDestroy if want to destroy asynchronously");
    Assert(s_msgidAsyncDestroy != 0);
    AssertMsg(m_hgadListen, "Must still have a valid Listener");

    EventMsg msg;
    ZeroMemory(&msg, sizeof(msg));
    msg.cbSize  = sizeof(msg);
    msg.hgadMsg = m_hgadListen;
    msg.nMsg    = s_msgidAsyncDestroy;

    DUserPostEvent(&msg, 0);
}


/***************************************************************************\
*
* OldExtension::GetExtension
*
* GetExtension() retrieves the OldExtension of a specific type currently 
* attached to the subject Gadget.
*
\***************************************************************************/

OldExtension *
OldExtension::GetExtension(HGADGET hgadSubject, PRID prid)
{
    OldExtension * pbExist;
    if (GetGadgetProperty(hgadSubject, prid, (void **) &pbExist)) {
        AssertMsg(pbExist != NULL, "Attached OldExtension must be valid");
        return pbExist;
    }
    
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\oldinterpolation.h ===
#if !defined(CTRL__OldInterpolation_h__INCLUDED)
#define CTRL__OldInterpolation_h__INCLUDED
#pragma once

#include "SmObject.h"

/***************************************************************************\
*****************************************************************************
*
* class OldInterpolationT
*
* OldInterpolationT defines a common implementation class for building
* Interpolation functions that can be used with Animations in DirectUser.
*
*****************************************************************************
\***************************************************************************/

template <class base, class iface>
class OldInterpolationT : public SmObjectT<base, iface>
{
// Operations
public:
    static HRESULT
    Build(REFIID riid, void ** ppv)
    {
        OldInterpolationT<base, iface> * pObj = new OldInterpolationT<base, iface>;
        if (pObj != NULL) {
            pObj->m_cRef = 0;
            
            HRESULT hr = pObj->QueryInterface(riid, ppv);
            if (FAILED(hr)) {
                delete pObj;
            }
            return hr;
        } else {
            return E_OUTOFMEMORY;
        }
    }
};


/***************************************************************************\
*****************************************************************************
*
* class OldLinearInterpolation
*
*****************************************************************************
\***************************************************************************/

class OldLinearInterpolation : public ILinearInterpolation
{
public:
    STDMETHOD_(float, Compute)(float flProgress, float flStart, float flEnd)
    {
        return (1.0f - flProgress) * flStart + flProgress * flEnd;
    }

protected:
    static  const IID * s_rgpIID[];
};


/***************************************************************************\
*****************************************************************************
*
* class OldLogInterpolation
*
*****************************************************************************
\***************************************************************************/

class OldLogInterpolation : public ILogInterpolation
{
// Operations
public:
    inline  OldLogInterpolation()
    {
        m_flScale = 1.0f;
    }

    STDMETHOD_(float, Compute)(float flProgress, float flStart, float flEnd)
    {
        float flMax = (float) log10(m_flScale * 9.0f + 1.0f);
        float flT   = (float) log10(flProgress * m_flScale * 9.0f + 1.0f) / flMax;
        return (1.0f - flT) * flStart + flT * flEnd;
    }

    STDMETHOD_(void, SetScale)(float flScale)
    {
        m_flScale = flScale;
    }

// Data
protected:
            float       m_flScale;
    static  const IID * s_rgpIID[];
};


/***************************************************************************\
*****************************************************************************
*
* class OldExpInterpolation
*
*****************************************************************************
\***************************************************************************/

class OldExpInterpolation : public IExpInterpolation
{
// Operations
public:
    inline  OldExpInterpolation()
    {
        m_flScale = 1.0f;
    }

    STDMETHOD_(float, Compute)(float flProgress, float flStart, float flEnd)
    {
        double dflProgress = flProgress;
        double dflStart = flStart;
        double dflEnd = flEnd;
        double dflScale = m_flScale;

        double dflMax = (((10.0 * dflScale) - 1.0) / 9.0);
        double dflT   = (((pow(10.0 * dflScale, dflProgress) - 1.0) / 9.0) / dflMax);
        return (float) ((1.0 - dflT) * dflStart + dflT * dflEnd);
    }

    STDMETHOD_(void, SetScale)(float flScale)
    {
        m_flScale = flScale;
    }

// Data
protected:
            float       m_flScale;
    static  const IID * s_rgpIID[];
};


/***************************************************************************\
*****************************************************************************
*
* class OldSInterpolation
*
*****************************************************************************
\***************************************************************************/

class OldSInterpolation : public ISInterpolation
{
// Operations
public:
    inline  OldSInterpolation()
    {
        m_flScale = 1.0f;
    }

    STDMETHOD_(float, Compute)(float flProgress, float flStart, float flEnd)
    {
        //
        // Slow - fast - slow
        //

        double dflProgress = flProgress;
        double dflStart = flStart;
        double dflEnd = flEnd;
        double dflScale = m_flScale;
        double dflMax;
        double dflT;

        if (dflProgress < 0.5) {
            double dflPartProgress = dflProgress * 2.0;
            dflMax = (((10.0 * dflScale) - 1.0) / 9.0) * 2.0;
            dflT   = ((pow(10.0 * dflScale, dflPartProgress) - 1.0) / 9.0) / dflMax;
        } else {
            double dflPartProgress = (1.0 - dflProgress) * 2.0;
            dflMax = (((10.0 * dflScale) - 1.0) / 9.0) * 2.0;
            dflT   = 1.0 - ((pow(10.0 * dflScale, dflPartProgress) - 1.0) / 9.0) / dflMax;
        }

        return (float) ((1.0 - dflT) * dflStart + dflT * dflEnd);
    }

    STDMETHOD_(void, SetScale)(float flScale)
    {
        m_flScale = flScale;
    }

// Data
protected:
            float       m_flScale;
    static  const IID * s_rgpIID[];
};


#endif // CTRL__OldInterpolation_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\sequence.cpp ===
#include "stdafx.h"
#include "Ctrl.h"
#include "Sequence.h"

#if ENABLE_MSGTABLE_API

/***************************************************************************\
*****************************************************************************
*
* Global Functions
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline BOOL
IsSameTime(float flA, float flB)
{
    float flDelta = flA - flB;
    return ((flDelta < 0.005f) && (flDelta > -0.005f));
}


/***************************************************************************\
*****************************************************************************
*
* class DuSequence
*
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* DuSequence::ApiOnEvent
*
* ApiOnEvent() processes events.
*
\***************************************************************************/

HRESULT
DuSequence::ApiOnEvent(EventMsg * pmsg)
{
    if (pmsg->nMsg == GM_DESTROY) {
        GMSG_DESTROY * pmsgD = static_cast<GMSG_DESTROY *>(pmsg);
        switch (GET_EVENT_DEST(pmsgD))
        {
        case GMF_DIRECT:
            //
            // We are being destroyed.
            //

            Stop();
            return DU_S_COMPLETE;

        case GMF_EVENT:
            //
            // Our Subject is being destroyed
            //

            Stop();
            return DU_S_PARTIAL;
        }
    }

    return SListener::ApiOnEvent(pmsg);
}


/***************************************************************************\
*
* DuSequence::ApiGetLength
*
* ApiGetLength() returns the length of a sequence, not including the initial
* delay.
*
\***************************************************************************/

HRESULT
DuSequence::ApiGetLength(Sequence::GetLengthMsg * pmsg)
{
    int cItems = m_arSeqData.GetSize();
    if (cItems <= 0) {
        pmsg->flLength = 0.0f;
    } else {
        pmsg->flLength = m_arSeqData[cItems - 1].flTime;
    }

    return S_OK;
}


/***************************************************************************\
*
* DuSequence::ApiGetDelay
*
* ApiGetDelay() returns the delay to wait before starting the sequence.
*
\***************************************************************************/

HRESULT
DuSequence::ApiGetDelay(Sequence::GetDelayMsg * pmsg)
{
    pmsg->flDelay = m_flDelay;

    return S_OK;
}


/***************************************************************************\
*
* DuSequence::ApiSetDelay
*
* ApiSetDelay() changes the delay to wait before starting the sequence.
*
\***************************************************************************/

HRESULT        
DuSequence::ApiSetDelay(Sequence::SetDelayMsg * pmsg)
{
    if (pmsg->flDelay < 0.0f) {
        PromptInvalid("Can not set a delay time in the past");
        return E_INVALIDARG;
    }

    if (IsPlaying()) {
        PromptInvalid("Sequence is busy");
        return DU_E_BUSY;
    }

    m_flDelay = pmsg->flDelay;
    return S_OK;
}


/***************************************************************************\
*
* DuSequence::ApiGetFlow
*
* ApiGetFlow() returns the Flow being used through-out the sequence to 
* modify a given Subject.
*
\***************************************************************************/

HRESULT
DuSequence::ApiGetFlow(Sequence::GetFlowMsg * pmsg)
{
    SafeAddRef(m_pflow);
    pmsg->pflow = m_pflow;

    return S_OK;
}


/***************************************************************************\
*
* DuSequence::ApiSetFlow
*
* ApiSetFlow() changes the Flow being used through-out the sequence to 
* modify a given Subject.
*
\***************************************************************************/

HRESULT
DuSequence::ApiSetFlow(Sequence::SetFlowMsg * pmsg)
{
    if (IsPlaying()) {
        PromptInvalid("Sequence is busy");
        return DU_E_BUSY;
    }

    SafeRelease(m_pflow);
    SafeAddRef(pmsg->pflow);
    m_pflow = pmsg->pflow;

    return S_OK;
}


/***************************************************************************\
*
* DuSequence::ApiGetFramePause
*
* ApiGetFramePause() returns the default "dwPause" value used for 
* Animations during playback.
*
\***************************************************************************/

HRESULT
DuSequence::ApiGetFramePause(Sequence::GetFramePauseMsg * pmsg)
{
    pmsg->dwPause = m_dwFramePause;

    return S_OK;
}


/***************************************************************************\
*
* DuSequence::ApiSetFramePause
*
* ApiSetFramePause() changes the default "dwPause" value used for 
* Animations during playback.
*
\***************************************************************************/

HRESULT
DuSequence::ApiSetFramePause(Sequence::SetFramePauseMsg * pmsg)
{
    if (IsPlaying()) {
        PromptInvalid("Sequence is busy");
        return DU_E_BUSY;
    }

    m_dwFramePause = pmsg->dwPause;

    return S_OK;
}


/***************************************************************************\
*
* DuSequence::ApiGetKeyFrameCount
*
* ApiGetKeyFrameCount() return the number of KeyFrames used in the sequence.
*
\***************************************************************************/

HRESULT
DuSequence::ApiGetKeyFrameCount(Sequence::GetKeyFrameCountMsg * pmsg)
{
    pmsg->cFrames = m_arSeqData.GetSize();
    return S_OK;
}


/***************************************************************************\
*
* DuSequence::ApiAddKeyFrame
*
* ApiAddKeyFrame() adds a new KeyFrame at the specified time.  If a KeyFrame
* already exists at the given time, that KeyFrame will be returned.
*
\***************************************************************************/

HRESULT
DuSequence::ApiAddKeyFrame(Sequence::AddKeyFrameMsg * pmsg)
{
    if (pmsg->flTime < 0.0f) {
        PromptInvalid("Can not set a delay time in the past");
        return E_INVALIDARG;
    }

    if (IsPlaying()) {
        PromptInvalid("Sequence is busy");
        return DU_E_BUSY;
    }


    //
    // Search the sequence to determine what slot to insert the new data in.  We
    // want to keep all time in order.
    //

    int cItems = m_arSeqData.GetSize();
    int idxAdd = cItems;
    for (int idx = 0; idx < cItems; idx++) {
        if (IsSameTime(m_arSeqData[idx].flTime, pmsg->flTime)) {
            pmsg->idxKeyFrame = idx;
            return S_OK;
        }

        if (m_arSeqData[idx].flTime > pmsg->flTime) {
            idxAdd = idx;
        }
    }


    //
    // Add a new KeyFrame at this time
    //

    SeqData data;
    data.flTime = pmsg->flTime;
    data.pkf    = NULL;
    data.pipol  = NULL;

    if (!m_arSeqData.InsertAt(idxAdd, data)) {
        return E_OUTOFMEMORY;
    }

    pmsg->idxKeyFrame = idxAdd;
    return S_OK;
}


/***************************************************************************\
*
* DuSequence::ApiRemoveKeyFrame
*
* ApiRemoveKeyFrame() removes the specified KeyFrame.
*
\***************************************************************************/

HRESULT
DuSequence::ApiRemoveKeyFrame(Sequence::RemoveKeyFrameMsg * pmsg)
{
    if ((pmsg->idxKeyFrame < 0) || (pmsg->idxKeyFrame >= m_arSeqData.GetSize())) {
        PromptInvalid("Invalid KeyFrame");
        return E_INVALIDARG;
    }

    if (IsPlaying()) {
        PromptInvalid("Sequence is busy");
        return DU_E_BUSY;
    }


    SeqData & data = m_arSeqData[pmsg->idxKeyFrame];
    ClientFree(data.pkf);
    SafeRelease(data.pipol);

    m_arSeqData.RemoveAt(pmsg->idxKeyFrame);

    return S_OK;
}


/***************************************************************************\
*
* DuSequence::ApiRemoveAllKeyFrames
*
* ApiRemoveAllKeyFrames() removes all KeyFrames.
*
\***************************************************************************/

HRESULT
DuSequence::ApiRemoveAllKeyFrames(Sequence::RemoveAllKeyFramesMsg * pmsg)
{
    UNREFERENCED_PARAMETER(pmsg);

    if (IsPlaying()) {
        PromptInvalid("Sequence is busy");
        return DU_E_BUSY;
    }

    RemoveAllKeyFrames();

    return S_OK;
}


/***************************************************************************\
*
* DuSequence::ApiFindKeyFrame
*
* ApiFindKeyFrame() finds the KeyFrame at the given time.
*
\***************************************************************************/

HRESULT
DuSequence::ApiFindKeyFrame(Sequence::FindKeyFrameMsg * pmsg)
{
    FindAtTime(pmsg->flTime, &pmsg->idxKeyFrame);

    return S_OK;
}


/***************************************************************************\
*
* DuSequence::ApiGetTime
*
* ApiGetTime() returns the time at a given KeyFrame.
*
\***************************************************************************/

HRESULT
DuSequence::ApiGetTime(Sequence::GetTimeMsg * pmsg)
{
    if ((pmsg->idxKeyFrame < 0) || (pmsg->idxKeyFrame >= m_arSeqData.GetSize())) {
        PromptInvalid("Invalid KeyFrame");
        return E_INVALIDARG;
    }

    pmsg->flTime = m_arSeqData[pmsg->idxKeyFrame].flTime;
    return S_OK;
}


/***************************************************************************\
*
* DuSequence::ApiSetTime
*
* ApiSetTime() changes the time of a given KeyFrame.  This function will
* reorder keyframes to maintain proper time order.
*
\***************************************************************************/

HRESULT
DuSequence::ApiSetTime(Sequence::SetTimeMsg * pmsg)
{
    if ((pmsg->idxKeyFrame < 0) || (pmsg->idxKeyFrame >= m_arSeqData.GetSize())) {
        PromptInvalid("Invalid KeyFrame");
        return E_INVALIDARG;
    }

    if (pmsg->flTime < 0.0f) {
        PromptInvalid("Can not set a delay time in the past");
        return E_INVALIDARG;
    }

    if (IsPlaying()) {
        PromptInvalid("Sequence is busy");
        return DU_E_BUSY;
    }


    m_arSeqData[pmsg->idxKeyFrame].flTime = pmsg->flTime;


    //
    // We have changed the time of one of the KeyFrames, so we need to re-sort.
    //

    SortKeyFrames();

    return S_OK;
}


/***************************************************************************\
*
* DuSequence::ApiGetKeyFrame
*
* ApiGetKeyFrame() returns Flow-specific data at a given KeyFrame.
*
\***************************************************************************/

HRESULT
DuSequence::ApiGetKeyFrame(Sequence::GetKeyFrameMsg * pmsg)
{
    if ((pmsg->idxKeyFrame < 0) || (pmsg->idxKeyFrame >= m_arSeqData.GetSize())) {
        PromptInvalid("Invalid KeyFrame");
        return E_INVALIDARG;
    }

    SeqData & data = m_arSeqData[pmsg->idxKeyFrame];
    if (data.pkf == NULL) {
        PromptInvalid("KeyFrame has not been set");
        return E_INVALIDARG;
    }

    if (pmsg->pkf->cbSize < data.pkf->cbSize) {
        PromptInvalid("cbSize is not large enough to store KeyFrame");
        return E_INVALIDARG;
    }

    CopyMemory(pmsg->pkf, data.pkf, data.pkf->cbSize);
    return S_OK;
}


/***************************************************************************\
*
* DuSequence::ApiSetKeyFrame
*
* ApiSetKeyFrame() changes Flow-specific data at a given KeyFrame.
*
\***************************************************************************/

HRESULT
DuSequence::ApiSetKeyFrame(Sequence::SetKeyFrameMsg * pmsg)
{
    if ((pmsg->idxKeyFrame < 0) || (pmsg->idxKeyFrame >= m_arSeqData.GetSize())) {
        PromptInvalid("Invalid KeyFrame");
        return E_INVALIDARG;
    }

    if (pmsg->pkfSrc->cbSize <= 0) {
        PromptInvalid("cbSize must be set");
        return E_INVALIDARG;
    }

    if (IsPlaying()) {
        PromptInvalid("Sequence is busy");
        return DU_E_BUSY;
    }


    //
    // Copy and store the KeyFrame
    //
    
    int cbAlloc = pmsg->pkfSrc->cbSize;
    DUser::KeyFrame * pkfCopy = reinterpret_cast<DUser::KeyFrame *> (ClientAlloc(cbAlloc));
    if (pkfCopy == NULL) {
        return E_OUTOFMEMORY;
    }

    SeqData & data = m_arSeqData[pmsg->idxKeyFrame];
    ClientFree(data.pkf);
    CopyMemory(pkfCopy, pmsg->pkfSrc, cbAlloc);
    data.pkf = pkfCopy;

    return S_OK;
}


/***************************************************************************\
*
* DuSequence::ApiGetInterpolation
*
* ApiGetInterpolation() returns the Interpolation used to move to the next
* keyframe.
*
\***************************************************************************/

HRESULT
DuSequence::ApiGetInterpolation(Sequence::GetInterpolationMsg * pmsg)
{
    if ((pmsg->idxKeyFrame < 0) || (pmsg->idxKeyFrame >= m_arSeqData.GetSize())) {
        PromptInvalid("Invalid KeyFrame");
        return E_INVALIDARG;
    }

    SeqData & data = m_arSeqData[pmsg->idxKeyFrame];
    SafeAddRef(data.pipol);
    pmsg->pipol = data.pipol;

    return S_OK;
}


/***************************************************************************\
*
* DuSequence::ApiSetInterpolation
*
* ApiSetInterpolation() changes the Interpolation used to move to the next
* keyframe.
*
\***************************************************************************/

HRESULT     
DuSequence::ApiSetInterpolation(Sequence::SetInterpolationMsg * pmsg)
{
    if ((pmsg->idxKeyFrame < 0) || (pmsg->idxKeyFrame >= m_arSeqData.GetSize())) {
        PromptInvalid("Invalid KeyFrame");
        return E_INVALIDARG;
    }

    if (IsPlaying()) {
        PromptInvalid("Sequence is busy");
        return DU_E_BUSY;
    }


    //
    // Copy and store the KeyFrame
    //

    SeqData & data = m_arSeqData[pmsg->idxKeyFrame];
    SafeRelease(data.pipol);
    SafeAddRef(pmsg->pipol);
    data.pipol = pmsg->pipol;

    return S_OK;
}


/***************************************************************************\
*
* DuSequence::Play
*
* ApiPlay() executes the Animation sequence for the given Visual.  A
* Sequence only supports animating a single Visual at a given time.  
* Multiple sequences may be created to animate multiple Visuals 
* simultaneously.
*
\***************************************************************************/

HRESULT
DuSequence::ApiPlay(Sequence::PlayMsg * pmsg)
{
    Assert(DEBUG_IsProperTimeOrder());

    //
    // Setup for animation:
    // - Validate all information is filled in.
    // - Ensure no existing Animation.
    // - Determine parameters for Animation.
    //

    HRESULT hr = CheckComplete();
    if (FAILED(hr)) {
        return hr;
    }

    Stop();
    AssertMsg(m_arAniData.GetSize() == 0, "Must not have pending Animations");


    //
    // Setup for Animation
    // - Attach as a Listener
    // - Allocate information necessary to create the Animations.
    // - Add a reference to allow the Sequence to fully play.
    //

    hr = pmsg->pgvSubject->AddHandlerG(GM_DESTROY, GetStub());
    if (FAILED(hr)) {
        return hr;
    }
    m_pgvSubject = pmsg->pgvSubject;


    int cItems = m_arSeqData.GetSize();
    if (cItems == 0) {
        return S_OK;
    }
    if (!m_arAniData.SetSize(cItems - 1)) {
        return E_OUTOFMEMORY;
    }

    AddRef();


    //
    // Queue all animations
    //

    for (int idx = 0; idx < cItems - 1; idx++) {
        hr = QueueAnimation(idx);
        if (FAILED(hr)) {
            return hr;
        }
    }

    return S_OK;
}


/***************************************************************************\
*
* DuSequence::ApiStop
*
* ApiStop() stops any executing Animation sequence.
*
\***************************************************************************/

HRESULT
DuSequence::ApiStop(Sequence::StopMsg * pmsg)
{
    UNREFERENCED_PARAMETER(pmsg);
    
    Stop(TRUE);

    return S_OK;
}


/***************************************************************************\
*
* DuSequence::ApiStop
*
* ApiStop() stops any executing Animation sequence.
*
\***************************************************************************/

void
DuSequence::Stop(BOOL fKillAnimations)
{
    if (IsPlaying()) {
        //
        // To prevent re-entrancy, mark that we are no longer playing.  However,
        // don't remove ourself as a listener until we are done.
        //

        Visual * pgvSubject = m_pgvSubject;
        m_pgvSubject = NULL;


        //
        // Stop any queued Animations.  When doing this, set 
        // m_arAniData[idx].hact to NULL to signal to the Action to not
        // create the Animation.  We need to do this since every Action will
        // get called back.
        //

        if (fKillAnimations) {
            PRID prid = 0;
            VerifyHR(m_pflow->GetPRID(&prid));
            Animation::Stop(pgvSubject, prid);

            int cItems = m_arAniData.GetSize();
            for (int idx = 0; idx < cItems; idx++) {
                HACTION hact = m_arAniData[idx].hact;
                if (hact != NULL) {
                    DeleteHandle(hact);
                    AssertMsg(m_arAniData[idx].hact == NULL, "Ensure Action is destroyed");
                }
            }
        }

        AssertMsg(m_cQueuedAni == 0, "All queued animations should be destroyed");
        m_arAniData.RemoveAll();


        //
        // Notify any listeners that this sequence has completed.
        //

        MSGID msgid = 0;
        const GUID * rgMsg[] = { &__uuidof(Animation::evComplete) };
        if (!FindGadgetMessages(rgMsg, &msgid, 1)) {
            AssertMsg(0, "Animations have not been properly registered");
        }
        
        Animation::CompleteEvent msg;
        msg.cbSize  = sizeof(msg);
        msg.nMsg    = msgid;
        msg.hgadMsg = GetStub()->GetHandle();
        msg.fNormal = !fKillAnimations;
        DUserSendEvent(&msg, 0);


        //
        // Remove ourself as a Listener
        //

        VerifyHR(pgvSubject->RemoveHandlerG(GM_DESTROY, GetStub()));


        //
        // Release outstanding reference from when started Play().
        //

        Release();
    }
}


/***************************************************************************\
*
* DuSequence::QueueAnimation
*
* QueueAnimation() queues an Action to be fired when the specified segment
* of the overall sequence is to be animated.  Since an Animation can only
* animate a single segment, we will build multiple Animations to play the
* entire sequence.
*
\***************************************************************************/

HRESULT
DuSequence::QueueAnimation(
    IN  int idxKeyFrame)                // KeyFrame to setup
{
    AssertMsg((idxKeyFrame < m_arAniData.GetSize()) && (idxKeyFrame >= 0),
            "Must have valid, non-final keyframe");


    SeqData & data1 = m_arSeqData[idxKeyFrame];
    AniData & ad    = m_arAniData[idxKeyFrame];
    ad.pseq         = this;
    ad.idxFrame     = idxKeyFrame;

    //
    // Setup the segment.  If successful, increment m_cQueuedAni to reflect 
    // that the animation has been "enqueued".  We need to wait until all
    // are dequeued before we can "stop" the Animation and allow applications
    // to modify the Sequence.
    //

    HRESULT hr;
    if (IsSameTime(data1.flTime, 0.0f)) {
        //
        // This segment immediate occurs, so directly build the Animation.
        //

        ad.hact = NULL;     // No action
        hr = BuildAnimation(idxKeyFrame);
        if (SUCCEEDED(hr)) {
            m_cQueuedAni++;
        }
    } else {
        //
        // This segment occurs in the future, so build a new Action that will 
        // be signaled when to begin the Animation between the specified 
        // keyframes.
        //

        GMA_ACTION act;
        ZeroMemory(&act, sizeof(act));
        act.cbSize      = sizeof(act);
        act.flDelay     = data1.flTime;
        act.flDuration  = 0.0;
        act.flPeriod    = 0.0;
        act.cRepeat     = 0;
        act.dwPause     = (DWORD) -1;
        act.pfnProc     = DuSequence::ActionProc;
        act.pvData      = &(m_arAniData[idxKeyFrame]);

        if ((ad.hact = CreateAction(&act)) != NULL) {
            m_cQueuedAni++;
            hr = S_OK;
        } else {
            hr = (HRESULT) GetLastError();
        }
    }

    return hr;
}


/***************************************************************************\
*
* DuSequence::BuildAnimation
*
* BuildAnimation() builds the actual Animation for a given segment of the
* sequence.  This function is called by QueueAnimation() (for immediate 
* segments) and ActionProc() (as future segments become ready).
*
\***************************************************************************/

HRESULT
DuSequence::BuildAnimation(
    IN  int idxKeyFrame)                // KeyFrame to animate
{
    //
    // Setup the actual Animation.
    //

    SeqData & data1     = m_arSeqData[idxKeyFrame];
    SeqData & data2     = m_arSeqData[idxKeyFrame + 1];
    float flDuration    = data2.flTime - data1.flTime;

    AssertMsg(m_pflow != NULL, "Must have valid Flow");
    m_pflow->SetKeyFrame(Flow::tBegin, data1.pkf);
    m_pflow->SetKeyFrame(Flow::tEnd, data2.pkf);

    Animation::AniCI aci;
    ZeroMemory(&aci, sizeof(aci));
    aci.cbSize          = sizeof(aci);
    aci.act.flDuration  = flDuration;
    aci.act.flPeriod    = 1;
    aci.act.cRepeat     = 0;
    aci.act.dwPause     = m_dwFramePause;
    aci.pgvSubject      = m_pgvSubject;
    aci.pipol           = data1.pipol;
    aci.pgflow          = m_pflow;

    Animation * pani = Animation::Build(&aci);
    if (pani != NULL) {
        MSGID msgid = 0;
        const GUID * rgMsg[] = { &__uuidof(Animation::evComplete) };
        if (!FindGadgetMessages(rgMsg, &msgid, 1)) {
            AssertMsg(0, "Animations have not been properly registered");
        }

        VerifyHR(pani->AddHandlerD(msgid, EVENT_DELEGATE(this, OnAnimationComplete)));
        pani->Release();
        return S_OK;
    } else {
        //
        // Unable to build the Animation, so stop any future Animations.
        //

        Stop();
        return (HRESULT) GetLastError();
    }
}


/***************************************************************************\
*
* DuSequence::ActionProc
*
* ActionProc() is called when the Animation for a given segment is supposed
* to begin.
*
\***************************************************************************/

void CALLBACK
DuSequence::ActionProc(
    IN  GMA_ACTIONINFO * pmai)          // Action Information
{
    AniData * pad       = reinterpret_cast<AniData *>(pmai->pvData);
    DuSequence * pseq   = pad->pseq;
    if (pmai->fFinished) {
        if (pad->hact != NULL) {
            //
            // The Animation was never built, so we need to decrement the
            // number of outstanding Animations.
            //

            pad->hact = NULL;

            AssertMsg(pseq->m_cQueuedAni > 0, "Must have an outstanding Animation");
            if (--pseq->m_cQueuedAni == 0) {
                pseq->Stop(FALSE);
            }
        }
        return;
    }

    pad->hact = NULL;
    pseq->BuildAnimation(pad->idxFrame);
}


/***************************************************************************\
*
* DuSequence::OnAnimationComplete
*
* OnAnimationComplete() is called when an Animation has been completed and
* is no longer attached to the subject.
*
\***************************************************************************/

UINT CALLBACK
DuSequence::OnAnimationComplete(EventMsg * pmsg)
{
    //
    // If all outstanding Animations have ended, then stop the playback.
    //

    UNREFERENCED_PARAMETER(pmsg);

    AssertMsg(m_cQueuedAni > 0, "Must have an outstanding Animation");
    if (--m_cQueuedAni == 0) {
        Stop(FALSE);
    }

    return DU_S_COMPLETE;
}


/***************************************************************************\
*
* DuSequence::ApiReset
*
* ApiReset() resets the given Visual to the beginning of the sequence.
*
\***************************************************************************/

HRESULT
DuSequence::ApiReset(Sequence::ResetMsg * pmsg)
{
    if (IsPlaying()) {
        PromptInvalid("Sequence is busy");
        return DU_E_BUSY;
    }

    HRESULT hr = CheckComplete();
    if (FAILED(hr)) {
        return hr;
    }

    if (m_arSeqData.GetSize() > 0) {
        ResetSubject(pmsg->pgvSubject, 0);
    }

    return S_OK;
}


/***************************************************************************\
*
* DuSequence::ApiGotoTime
*
* ApiGotoTime() applies all keyframes to the given Visual that would applied
* at a given time.
*
\***************************************************************************/

HRESULT
DuSequence::ApiGotoTime(Sequence::GotoTimeMsg * pmsg)
{
    if (IsPlaying()) {
        PromptInvalid("Sequence is busy");
        return DU_E_BUSY;
    }

    HRESULT hr = CheckComplete();
    if (FAILED(hr)) {
        return hr;
    }


    //
    // Find the keyframe before the time
    //

    int cItems = m_arSeqData.GetSize();
    if (cItems == 0) {
        //
        // No key frames, so nothing to do.
        //

        return S_OK;
    } else if (cItems == 1) {
        //
        // Only one keyframe, so just reset the object
        //

        ResetSubject(pmsg->pgvSubject, 0);
    } else {
        //
        // Multiple keyframes- need to determine the closest keyframe.
        // - If land on a keyframe, then "exact"
        // - If before all keyframes, idxFrame = -1;
        // - If after all keyframes, idxFrame = cItems
        // - If in the middle, idxFrame = first frame
        //

        int idxFrame    = -1;
        BOOL fExact     = FALSE;
        int cItems      = m_arSeqData.GetSize();

        if (pmsg->flTime > m_arSeqData[cItems - 1].flTime) {
            idxFrame = cItems;
        } else {
            for (int idx = 0; idx < cItems; idx++) {
                SeqData & data = m_arSeqData[idx];
                if (data.pkf != NULL) {
                    if (IsSameTime(data.flTime, pmsg->flTime)) {
                        idxFrame    = idx;
                        fExact      = TRUE;
                        break;
                    } else if (data.flTime > pmsg->flTime) {
                        idxFrame    = idx - 1;
                        fExact      = FALSE;
                        break;
                    }
                }
            }
        }


        if (fExact) {
            //
            // Exactly landed on a keyframe, so set directly
            //

            ResetSubject(pmsg->pgvSubject, idxFrame);
        } else {
            //
            // Interpolate between two keyframes.  Since this wasn't an exact
            // match, we need to cap the keyframes.
            //

            if (idxFrame < 0) {
                ResetSubject(pmsg->pgvSubject, 0);
            } else if (idxFrame >= cItems) {
                ResetSubject(pmsg->pgvSubject, cItems - 1);
            } else {
                SeqData & dataA     = m_arSeqData[idxFrame];
                SeqData & dataB     = m_arSeqData[idxFrame + 1];

                float flTimeA       = dataA.flTime;
                float flTimeB       = dataB.flTime;
                float flProgress    = (pmsg->flTime - flTimeA) / (flTimeB - flTimeA);
                if (flProgress > 1.0f) {
                    flProgress = 1.0f;
                }

                m_pflow->SetKeyFrame(Flow::tBegin, dataA.pkf);
                m_pflow->SetKeyFrame(Flow::tEnd, dataB.pkf);

                m_pflow->OnAction(pmsg->pgvSubject, dataA.pipol, flProgress);
            }
        }
    }
    
    return S_OK;
}


/***************************************************************************\
*
* DuSequence::RemoveAllKeyFrames
*
* RemoveAllKeyFrames() removes all KeyFrames.
*
\***************************************************************************/

void
DuSequence::RemoveAllKeyFrames()
{
    int cItems = m_arSeqData.GetSize();
    for (int idx = 0; idx < cItems; idx++) {
        SeqData & data = m_arSeqData[idx];
        ClientFree(data.pkf);
        SafeRelease(data.pipol);
    }

    m_arSeqData.RemoveAll();
}


/***************************************************************************\
*
* DuSequence::ResetSubject
*
* ResetSubject() resets the given subject to the beginning of the Sequence.
*
\***************************************************************************/

void 
DuSequence::ResetSubject(Visual * pgvSubject, int idxFrame)
{
    m_pflow->SetKeyFrame(Flow::tBegin, m_arSeqData[idxFrame].pkf);
    m_pflow->OnReset(pgvSubject);
}


/***************************************************************************\
*
* DuSequence::CompareItems
*
* CompareItems() is called from SortKeyFrames() to sort two individual
* KeyFrames by time.
*
\***************************************************************************/

int
DuSequence::CompareItems(
    IN  const void * pva,               // First SeqData
    IN  const void * pvb)               // Second SeqData
{
    float flTimeA = ((SeqData *) pva)->flTime;
    float flTimeB = ((SeqData *) pvb)->flTime;

    if (flTimeA < flTimeB) {
        return -1;
    } else if (flTimeA > flTimeB) {
        return 1;
    } else {
        return 0;
    }
}


/***************************************************************************\
*
* DuSequence::FindAtTime
*
* FindAtTime() finds the KeyFrame at the given time.
*
\***************************************************************************/

void
DuSequence::FindAtTime(
    IN  float flTime,                   // Time of KeyFrame
    OUT int * pidxKeyFrame              // KeyFrame, if found
    ) const
{
    int cItems = m_arSeqData.GetSize();
    for (int idx = 0; idx < cItems; idx++) {
        SeqData & data = m_arSeqData[idx];
        if (data.pkf != NULL) {
            if (IsSameTime(data.flTime, flTime)) {
                *pidxKeyFrame = idx;
                return;
            }
        }
    }

    *pidxKeyFrame = -1; // Not found
}


/***************************************************************************\
*
* DuSequence::CheckComplete
*
* CheckComplete() determines if all information for the Sequence has been 
* filled in.  This is necessary when use the sequence to play animations.
*
\***************************************************************************/

HRESULT
DuSequence::CheckComplete() const
{
    if (m_pflow == NULL) {
        PromptInvalid("Flow has not been specified");
        return E_INVALIDARG;
    }

    int cItems = m_arSeqData.GetSize();
    for (int idx = 0; idx < cItems; idx++) {
        if (m_arSeqData[idx].pkf == NULL) {
            PromptInvalid("KeyFrame information has not been specified");
            return E_INVALIDARG;
        }
        if (m_arSeqData[idx].pipol == NULL) {
            PromptInvalid("Interpolation has not been specified");
            return E_INVALIDARG;
        }
    }

    return S_OK;
}


#if DBG

/***************************************************************************\
*
* DuSequence::DEBUG_IsProperTimeOrder
*
* DEBUG_IsProperTimeOrder() validates that all keyframes are in increasing
* time order.
*
\***************************************************************************/

BOOL
DuSequence::DEBUG_IsProperTimeOrder() const
{
    float flTime = 0;

    int cItems = m_arSeqData.GetSize();
    for (int idx = 0; idx < cItems; idx++) {
        if (m_arSeqData[idx].flTime < flTime) {
            return FALSE;
        }

        flTime = m_arSeqData[idx].flTime;
    }

    return TRUE;
}

#endif // DBG

#endif // ENABLE_MSGTABLE_API
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\smbutton.h ===
#if !defined(CTRL__SmButton_h__INCLUDED)
#define CTRL__SmButton_h__INCLUDED
#pragma once

#if ENABLE_MSGTABLE_API

//------------------------------------------------------------------------------
class SmButton : 
        public ButtonGadgetImpl<SmButton, SVisual>
{
// Construction
public:
            SmButton();
    inline  HRESULT     PostBuild(DUser::Gadget::ConstructInfo * pci);

// Operations
public:
    virtual void        OnDraw(HDC hdc, GMSG_PAINTRENDERI * pmsgR);

// IButtonGadget Interface
public:
    dapi    HRESULT     ApiOnEvent(EventMsg * pmsgE);
    dapi    HRESULT     ApiGetColor(ButtonGadget::GetColorMsg * pmsg);
    dapi    HRESULT     ApiSetColor(ButtonGadget::SetColorMsg * pmsg);
    dapi    HRESULT     ApiGetItem(ButtonGadget::GetItemMsg * pmsg);
    dapi    HRESULT     ApiSetItem(ButtonGadget::SetItemMsg * pmsg);
    dapi    HRESULT     ApiSetText(ButtonGadget::SetTextMsg * pmsg);

// Implementation
protected:
            void        EmptyButton();
            void        ComputeLayout();
            UINT        OnMouse(GMSG_MOUSE * pmsg);

// Data
protected:
    static  HFONT       s_hfntText;             // Standard font used for text
    static  BOOL        s_fInit;                // Initialized
    static  MSGID       s_msgidClicked;         // Clicked message

            COLORREF    m_crButton;             // Color of check
            Visual *    m_pgvItem;              // Nested item
            BOOL        m_fKeyboardFocus:1;     // Button has keyboard focus
            BOOL        m_fMouseFocus:1;        // Button has mouse focus
            BOOL        m_fText:1;              // Item is a TextGadget
            BOOL        m_fPressed:1;           // Button is pressed
};

#endif // ENABLE_MSGTABLE_API

#include "SmButton.inl"

#endif // CTRL__SmButton_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\smbutton.cpp ===
#include "stdafx.h"
#include "Ctrl.h"
#include "SmButton.h"

#if ENABLE_MSGTABLE_API

/***************************************************************************\
*****************************************************************************
*
* class SmButton
*
*****************************************************************************
\***************************************************************************/

HFONT   SmButton::s_hfntText        = NULL;
BOOL    SmButton::s_fInit           = FALSE;
MSGID   SmButton::s_msgidClicked    = 0;

//------------------------------------------------------------------------------
SmButton::SmButton()
{
    if (!s_fInit) {
        s_msgidClicked = RegisterGadgetMessage(&_uuidof(evButtonClicked));
        s_fInit = TRUE;
    }
}


//------------------------------------------------------------------------------
HRESULT
SmButton::ApiOnEvent(EventMsg * pmsg)
{
    switch (GET_EVENT_DEST(pmsg))
    {
    case GMF_DIRECT:
        switch (pmsg->nMsg)
        {
        case GM_PAINT:
            {
                GMSG_PAINT * pmsgPaint = (GMSG_PAINT *) pmsg;
                if (pmsgPaint->nCmd == GPAINT_RENDER) {
                    switch (pmsgPaint->nSurfaceType)
                    {
                    case GSURFACE_HDC:
                        {
                            GMSG_PAINTRENDERI * pmsgR = (GMSG_PAINTRENDERI *) pmsgPaint;
                            OnDraw(pmsgR->hdc, pmsgR);
                        }
                        break;
                    }

                    return DU_S_PARTIAL;
                }
            }
            break;

        case GM_QUERY:
            {
                GMSG_QUERY * pmsgQ = (GMSG_QUERY *) pmsg;
                switch (pmsgQ->nCode)
                {
                case GQUERY_DESCRIPTION:
                    {
                        GMSG_QUERYDESC * pmsgQD = (GMSG_QUERYDESC *) pmsg;
                        CopyString(pmsgQD->szType, L"SmButton", _countof(pmsgQD->szType));
                        return DU_S_COMPLETE;
                    }
                }
            }
            break;

        case GM_CHANGERECT:
            {
                GMSG_CHANGERECT * pmsgR = (GMSG_CHANGERECT *) pmsg;
                if (TestFlag(pmsgR->nFlags, SGR_SIZE)) {
                    ComputeLayout();
                }
            }
            break;
    
        case GM_INPUT:
            {
MouseDown:
                GMSG_INPUT * pmsgI = (GMSG_INPUT *) pmsg;
                if (pmsgI->nDevice == GINPUT_MOUSE) {
                    GMSG_MOUSE * pmsgM = (GMSG_MOUSE *) pmsgI;
                    return OnMouse(pmsgM);
                }
            }
            break;

        case GM_CHANGESTATE:
            {
ChangeState:
                GMSG_CHANGESTATE * pmsgS = (GMSG_CHANGESTATE *) pmsg;
                switch (pmsgS->nCode)
                {
                case GSTATE_KEYBOARDFOCUS:
                    m_fKeyboardFocus = (pmsgS->nCmd == GSC_SET);
                    GetStub()->Invalidate();
                    return DU_S_PARTIAL;

                case GSTATE_MOUSEFOCUS:
                    m_fMouseFocus = (pmsgS->nCmd == GSC_SET);
                    GetStub()->Invalidate();
                    return DU_S_PARTIAL;
                }
            }
            break;
        }
        break;

    case GMF_ROUTED:
        //
        // Routed message before handled by control.
        //

        switch (pmsg->nMsg)
        {
        case GM_CHANGESTATE:
            goto ChangeState;
        }
        break;

    case GMF_BUBBLED:
        //
        // Bubbled message not handled by control
        //

        switch (pmsg->nMsg)
        {
        case GM_INPUT:
            goto MouseDown;
        }
        break;
    }

    return SVisual::ApiOnEvent(pmsg);
}


inline bool
PtInBox(int cx, int cy, POINT & pt)
{
    return (pt.x <= cx) && (pt.y <= cy) && (pt.x >= 0) && (pt.y >= 0);
}


//------------------------------------------------------------------------------
UINT
SmButton::OnMouse(GMSG_MOUSE * pmsg)
{
    if (pmsg->bButton == GBUTTON_LEFT) {
        switch (pmsg->nCode)
        {
        case GMOUSE_DOWN:
            m_fPressed = TRUE;
            goto UpdatePressed;

        case GMOUSE_UP:
            m_fPressed = FALSE;
            goto UpdatePressed;
        }
    }

    return DU_S_NOTHANDLED;

UpdatePressed:
    if (m_pgvItem != NULL) {
        SIZE sizeOffset;
        if (m_fPressed) {
            sizeOffset.cx = sizeOffset.cy = 1;
        } else {
            sizeOffset.cx = sizeOffset.cy = -1;
        }
        m_pgvItem->SetRect(SGR_MOVE | SGR_OFFSET, sizeOffset.cx, sizeOffset.cy, 0, 0);
    }

    GetStub()->Invalidate();

    if (m_fPressed) {
        EventMsg msg;
        msg.cbSize  = sizeof(msg);
        msg.nMsg    = s_msgidClicked;
        msg.hgadMsg = GetHandle();
        DUserSendEvent(&msg, 0);
    }

    return DU_S_COMPLETE;
}


//------------------------------------------------------------------------------
void        
SmButton::OnDraw(HDC hdc, GMSG_PAINTRENDERI * pmsgR) 
{
    const RECT * prcGadget = pmsgR->prcGadgetPxl;

    HFONT hfntOld   = (HFONT) SelectObject(hdc, s_hfntText);
    COLORREF crOld  = SetTextColor(hdc, m_crButton);
    int nOldMode    = SetBkMode(hdc, TRANSPARENT);

    FillRect(hdc, prcGadget, GetSysColorBrush(COLOR_BTNFACE));

    UINT nEdge;
    if (m_fMouseFocus && m_fPressed) {
        nEdge = EDGE_SUNKEN;
    } else {
        nEdge = EDGE_RAISED;
    }

    DrawEdge(hdc, (RECT *) prcGadget, nEdge, BF_RECT);

    SetBkMode(hdc, nOldMode);
    SetTextColor(hdc, crOld);
    SelectObject(hdc, hfntOld);

    if (m_fKeyboardFocus) {
        RECT rcItem = *prcGadget;
        InflateRect(&rcItem, -3, -3);
        DrawFocusRect(hdc, &rcItem);
    }
}


//------------------------------------------------------------------------------
HRESULT
SmButton::ApiGetColor(ButtonGadget::GetColorMsg * pmsg)
{
    pmsg->crButton = m_crButton;
    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
SmButton::ApiSetColor(ButtonGadget::SetColorMsg * pmsg)
{
    m_crButton = pmsg->crButton;
    GetStub()->Invalidate();
    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
SmButton::ApiGetItem(ButtonGadget::GetItemMsg * pmsg)
{
    pmsg->pgvItem = m_pgvItem;
    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
SmButton::ApiSetItem(ButtonGadget::SetItemMsg * pmsg)
{
    AssertMsg(m_pgvItem == NULL, "TODO: Destroy existing item");

    m_pgvItem = pmsg->pgvItem;

    if (m_pgvItem != NULL) {
        ComputeLayout();
    }

    m_fText = FALSE;
    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
SmButton::ApiSetText(ButtonGadget::SetTextMsg * pmsg)
{
    TextGadget * pgvText = NULL;
    if (!m_fText) {
        AssertMsg(m_pgvItem == NULL, "TODO: Destroy existing item");

        pgvText = BuildVisual<TextGadget>((Visual *) m_pgad);
        m_pgvItem = pgvText;
        if (m_pgvItem == NULL) {
            return S_OK;
        }

        m_fText = TRUE;
    } else {
        pgvText = (TextGadget *) m_pgvItem;
    }

    AssertMsg(m_pgvItem != NULL, "Must have valid TextGadget by now");

    if (s_hfntText == NULL) {
        s_hfntText = UtilBuildFont(L"Tahoma", 85, FS_NORMAL);
    }

    pgvText->SetAutoSize(TRUE);
    pgvText->SetFont(s_hfntText);
    pgvText->SetText(pmsg->pszText);
    pgvText->SetColor(RGB(0, 0, 128));

    ComputeLayout();

    return S_OK;
}


//------------------------------------------------------------------------------
void        
SmButton::ComputeLayout()
{
    SIZE sizePxl;
    GetStub()->GetSize(&sizePxl);

    if (m_pgvItem != NULL) {
        RECT rcItem;
        m_pgvItem->GetRect(SGR_CLIENT, &rcItem);

        GMSG_QUERYRECT msg;
        msg.cbSize          = sizeof(GMSG_QUERYRECT);
        msg.nMsg            = GM_QUERY;
        msg.nCode           = GQUERY_RECT;
        msg.hgadMsg         = m_pgvItem->GetHandle();
        msg.sizeBound.cx    = sizePxl.cx - 10;
        msg.sizeBound.cy    = sizePxl.cy - 10;
        msg.sizeResult      = msg.sizeBound;
        msg.nFlags          = GQR_PRIHORZ;

        if (DUserSendEvent(&msg, 0) == DU_S_NOTHANDLED) {
            SIZE sizeItemPxl;
            m_pgvItem->GetSize(&sizeItemPxl);

            msg.sizeResult.cx   = min(sizeItemPxl.cx, msg.sizeBound.cx);
            msg.sizeResult.cy   = min(sizeItemPxl.cy, msg.sizeBound.cy);
        }

        SIZE sizeBorderPxl;
        sizeBorderPxl.cx    = 5;
        sizeBorderPxl.cy    = (sizePxl.cy - msg.sizeResult.cy) / 2;

        m_pgvItem->SetRect(SGR_MOVE | SGR_SIZE | SGR_PARENT | SGR_NOINVALIDATE,
                sizeBorderPxl.cx, sizeBorderPxl.cy, msg.sizeResult.cx, msg.sizeResult.cy);
    }

    GetStub()->Invalidate();
}

#endif // ENABLE_MSGTABLE_API
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\smbutton.inl ===
#if !defined(CORE__SmButton_inl__INCLUDED)
#define CORE__SmButton_inl__INCLUDED

#if ENABLE_MSGTABLE_API

/***************************************************************************\
*****************************************************************************
*
* class SmButton
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline HRESULT
SmButton::PostBuild(DUser::Gadget::ConstructInfo * pci)
{
    UNREFERENCED_PARAMETER(pci);        

    GetStub()->SetFilter(  GMFI_PAINT | GMFI_INPUTMOUSE | GMFI_CHANGERECT | GMFI_CHANGESTATE, GMFI_ALL);
    GetStub()->SetStyle(   GS_KEYBOARDFOCUS | GS_MOUSEFOCUS,
                    GS_KEYBOARDFOCUS | GS_MOUSEFOCUS);

    return S_OK;
}

#endif // ENABLE_MSGTABLE_API

#endif // CORE__SmButton_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\sequence.inl ===
#if !defined(CTRL__Sequence_inl__INCLUDED)
#define CTRL__Sequence_inl__INCLUDED
#pragma once

#if ENABLE_MSGTABLE_API

/***************************************************************************\
*****************************************************************************
*
* class DuSequence
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline 
DuSequence::DuSequence()
{
    m_cRef = 1;
}


//------------------------------------------------------------------------------
inline
DuSequence::~DuSequence()
{
    Stop();
    RemoveAllKeyFrames();

    SafeRelease(m_pflow);
}


//------------------------------------------------------------------------------
inline void
DuSequence::AddRef()
{ 
    ++m_cRef; 
}


//------------------------------------------------------------------------------
inline void
DuSequence::Release() 
{ 
    if (--m_cRef == 0) 
        Delete(); 
}


//------------------------------------------------------------------------------
inline void
DuSequence::SortKeyFrames()
{
    qsort(m_arSeqData.GetData(), m_arSeqData.GetSize(), sizeof(SeqData), CompareItems);
}


//------------------------------------------------------------------------------
inline BOOL
DuSequence::IsPlaying() const
{
    return m_pgvSubject != NULL;
}


#endif // ENABLE_MSGTABLE_API

#endif // CTRL__Sequence_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\sequence.h ===
#if !defined(CTRL__Sequence_h__INCLUDED)
#define CTRL__Sequence_h__INCLUDED
#pragma once

#if ENABLE_MSGTABLE_API

//------------------------------------------------------------------------------
class DuSequence :
        public SequenceImpl<DuSequence, SListener>
{
// Construction
public:
    inline  DuSequence();
    inline  ~DuSequence();

// Public API
public:
    dapi    HRESULT     ApiOnEvent(EventMsg * pmsg);

    dapi    HRESULT     ApiAddRef(Sequence::AddRefMsg *) { AddRef(); return S_OK; }
    dapi    HRESULT     ApiRelease(Sequence::ReleaseMsg *) { Release(); return S_OK; }

    dapi    HRESULT     ApiGetLength(Sequence::GetLengthMsg * pmsg);
    dapi    HRESULT     ApiGetDelay(Sequence::GetDelayMsg * pmsg);
    dapi    HRESULT     ApiSetDelay(Sequence::SetDelayMsg * pmsg);
    dapi    HRESULT     ApiGetFlow(Sequence::GetFlowMsg * pmsg);
    dapi    HRESULT     ApiSetFlow(Sequence::SetFlowMsg * pmsg);
    dapi    HRESULT     ApiGetFramePause(Sequence::GetFramePauseMsg * pmsg);
    dapi    HRESULT     ApiSetFramePause(Sequence::SetFramePauseMsg * pmsg);

    dapi    HRESULT     ApiGetKeyFrameCount(Sequence::GetKeyFrameCountMsg * pmsg);
    dapi    HRESULT     ApiAddKeyFrame(Sequence::AddKeyFrameMsg * pmsg);
    dapi    HRESULT     ApiRemoveKeyFrame(Sequence::RemoveKeyFrameMsg * pmsg);
    dapi    HRESULT     ApiRemoveAllKeyFrames(Sequence::RemoveAllKeyFramesMsg * pmsg);
    dapi    HRESULT     ApiFindKeyFrame(Sequence::FindKeyFrameMsg * pmsg);

    dapi    HRESULT     ApiGetTime(Sequence::GetTimeMsg * pmsg);
    dapi    HRESULT     ApiSetTime(Sequence::SetTimeMsg * pmsg);
    dapi    HRESULT     ApiGetKeyFrame(Sequence::GetKeyFrameMsg * pmsg);
    dapi    HRESULT     ApiSetKeyFrame(Sequence::SetKeyFrameMsg * pmsg);
    dapi    HRESULT     ApiGetInterpolation(Sequence::GetInterpolationMsg * pmsg);
    dapi    HRESULT     ApiSetInterpolation(Sequence::SetInterpolationMsg * pmsg);

    dapi    HRESULT     ApiPlay(Sequence::PlayMsg * pmsg);
    dapi    HRESULT     ApiStop(Sequence::StopMsg * pmsg);
    dapi    HRESULT     ApiReset(Sequence::ResetMsg * pmsg);
    dapi    HRESULT     ApiGotoTime(Sequence::GotoTimeMsg * pmsg);

// Implementation
protected:
    inline  void        AddRef();
    inline  void        Release(); 

            void        RemoveAllKeyFrames();

    inline  void        SortKeyFrames();
    static  int __cdecl CompareItems(const void * pva, const void * pvb);
            void        FindAtTime(float flTime, int * pidxKeyFrame) const;
            void        ResetSubject(Visual * pgvSubject, int idxFrame);

    inline  BOOL        IsPlaying() const;
            HRESULT     QueueAnimation(int idxKeyFrame);
            HRESULT     BuildAnimation(int idxKeyFrame);
            void        Stop(BOOL fKillAnimations = TRUE);
    static  void CALLBACK  
                        ActionProc(GMA_ACTIONINFO * pmai);
            UINT CALLBACK 
                        OnAnimationComplete(EventMsg * pmsg);

            HRESULT     CheckComplete() const;
#if DBG
            BOOL        DEBUG_IsProperTimeOrder() const;
#endif

// Data
protected:
    struct SeqData
    {
        float           flTime;         // Time of current keyframe
        DUser::KeyFrame *
                        pkf;            // Information for this KeyFrame
        Interpolation * pipol;          // Interpolation to next KeyFrame
    };

    struct AniData
    {
        DuSequence *    pseq;           // Owning Sequence
        int             idxFrame;       // 1st KeyFrame of specific Animation
        HACTION         hact;           // Action of outstanding Animation
    };

            UINT        m_cRef;         // Reference count
            float       m_flDelay;      // Delay before starting animation
            Flow *      m_pflow;        // Flow used between keyframes
            Visual *    m_pgvSubject;   // Visual being animated
            int         m_cQueuedAni;   // Outstanding queued animations
            DWORD       m_dwFramePause; // Generic frame pause

            GArrayF<SeqData>
                        m_arSeqData;
            GArrayF<AniData>
                        m_arAniData;
};

#endif // ENABLE_MSGTABLE_API

#include "Sequence.inl"

#endif // CTRL__Sequence_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\smcheckbox.inl ===
#if !defined(CORE__SmCheckBox_inl__INCLUDED)
#define CORE__SmCheckBox_inl__INCLUDED

#if ENABLE_MSGTABLE_API

/***************************************************************************\
*****************************************************************************
*
* class SmCheckBox
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline
SmCheckBox::SmCheckBox()
{
    m_bChecked      = CheckBoxGadget::csUnchecked;
    m_bType         = CheckBoxGadget::ctNormal;

    if (s_hfntCheck == NULL) {
        s_hfntCheck = UtilBuildFont(L"Marlett", 120, FS_NORMAL);
    }
}


//------------------------------------------------------------------------------
inline HRESULT
SmCheckBox::PostBuild(DUser::Gadget::ConstructInfo * pci)
{
    UNREFERENCED_PARAMETER(pci);

    GetStub()->SetFilter(  GMFI_PAINT | GMFI_INPUTMOUSE | GMFI_CHANGESTATE, GMFI_ALL);
    GetStub()->SetStyle(   GS_KEYBOARDFOCUS | GS_MOUSEFOCUS,
                    GS_KEYBOARDFOCUS | GS_MOUSEFOCUS);

    return S_OK;
}


//------------------------------------------------------------------------------
inline BYTE        
SmCheckBox::GetMaxCheck() const
{
    return (BYTE) (m_bType == CheckBoxGadget::ctNormal ? CheckBoxGadget::csChecked : CheckBoxGadget::csUnknown);
}


//------------------------------------------------------------------------------
inline void        
SmCheckBox::SetKeyboardFocus(BOOL fFocus)
{
    m_fKeyboardFocus = fFocus;
    GetStub()->Invalidate();
}


#if TEST_MOUSEFOCUS

//------------------------------------------------------------------------------
inline void        
SmCheckBox::SetMouseFocus(BOOL fFocus)
{
    UINT nBrush = fFocus ? SC_BurlyWood : SC_PapayaWhip;
    UtilSetBackground(m_hgad, GetStdColorBrushI(nBrush));
    CallInvalidate();
}

#endif // TEST_MOUSEFOCUS

#endif // ENABLE_MSGTABLE_API

#endif // CORE__SmCheckBox_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\smcheckbox.cpp ===
#include "stdafx.h"
#include "Ctrl.h"
#include "SmCheckBox.h"

#if ENABLE_MSGTABLE_API

/***************************************************************************\
*****************************************************************************
*
* class SmCheckBox
*
*****************************************************************************
\***************************************************************************/

const SIZE SIZE_Box = {13, 13};

HFONT   SmCheckBox::s_hfntCheck = NULL;
HFONT   SmCheckBox::s_hfntText  = NULL;

//------------------------------------------------------------------------------
HRESULT
SmCheckBox::ApiOnEvent(EventMsg * pmsg)
{
    switch (GET_EVENT_DEST(pmsg))
    {
    case GMF_DIRECT:
    case GMF_EVENT:
        switch (pmsg->nMsg)
        {
        case GM_PAINT:
            {
                GMSG_PAINT * pmsgPaint = (GMSG_PAINT *) pmsg;
                if (pmsgPaint->nCmd == GPAINT_RENDER) {
                    switch (pmsgPaint->nSurfaceType)
                    {
                    case GSURFACE_HDC:
                        {
                            GMSG_PAINTRENDERI * pmsgR = (GMSG_PAINTRENDERI *) pmsgPaint;
                            OnDraw(pmsgR->hdc, pmsgR);
                        }
                        break;

                    case GSURFACE_GPGRAPHICS:
                        {
                            GMSG_PAINTRENDERF * pmsgR = (GMSG_PAINTRENDERF *) pmsgPaint;
                            OnDraw(pmsgR->pgpgr, pmsgR);
                        }
                        break;
                    default:
                        Trace("WARNING: Unknown surface type\n");
                    }

                    return DU_S_PARTIAL;
                }
            }
            break;

        case GM_CHANGERECT:
            {
                GMSG_CHANGERECT * pmsgR = (GMSG_CHANGERECT *) pmsg;
                if (TestFlag(pmsgR->nFlags, SGR_SIZE)) {
                    ComputeLayout();
                }
            }
            break;
    
        case GM_INPUT:
            {
MouseDown:
                GMSG_INPUT * pmsgI = (GMSG_INPUT *) pmsg;
                if (pmsgI->nDevice == GINPUT_MOUSE) {
                    GMSG_MOUSE * pmsgM = (GMSG_MOUSE *) pmsgI;
                    if (pmsgM->nCode == GMOUSE_DOWN) {
                        return OnMouseDown(pmsgM);
                    }
                }
            }
            break;

        case GM_CHANGESTATE:
            {
ChangeState:
                GMSG_CHANGESTATE * pmsgS = (GMSG_CHANGESTATE *) pmsg;
                switch (pmsgS->nCode)
                {
                case GSTATE_KEYBOARDFOCUS:
                    SetKeyboardFocus(pmsgS->nCmd == GSC_SET);
                    return DU_S_PARTIAL;

#if TEST_MOUSEFOCUS
                case GSTATE_MOUSEFOCUS:
                    SetMouseFocus(pmsgS->nCmd == GSC_SET);
                    return DU_S_PARTIAL;
#endif // TEST_MOUSEFOCUS
                }
            }
            break;
        case GM_QUERY:
            {
                GMSG_QUERY * pmsgQ = (GMSG_QUERY *) pmsg;
                switch (pmsgQ->nCode)
                {
                case GQUERY_DESCRIPTION:
                    {
                        GMSG_QUERYDESC * pmsgQD = (GMSG_QUERYDESC *) pmsg;
                        CopyString(pmsgQD->szType, L"SmCheckBox", _countof(pmsgQD->szType));
                        return DU_S_COMPLETE;
                    }
                }
            }
            break;
        }
        break;

    case GMF_ROUTED:
        //
        // Routed message before handled by control.
        //

        switch (pmsg->nMsg)
        {
        case GM_CHANGESTATE:
            //
            // When focus changes for the checkbox or one of its children,
            // the checkbox wants to know.
            //
            goto ChangeState;
        }
        break;

    case GMF_BUBBLED:
        //
        // Bubbled message not handled by control
        //

        switch (pmsg->nMsg)
        {
        case GM_INPUT:
            goto MouseDown;
        }
        break;
    }

    return SVisual::ApiOnEvent(pmsg);
}


inline bool
PtInBox(int cx, int cy, POINT & pt)
{
    return (pt.x <= cx) && (pt.y <= cy) && (pt.x >= 0) && (pt.y >= 0);
}


//------------------------------------------------------------------------------
UINT
SmCheckBox::OnMouseDown(GMSG_MOUSE * pmsg)
{
    if (pmsg->bButton == GBUTTON_LEFT) {
        if (((GET_EVENT_DEST(pmsg) == GMF_DIRECT) && PtInRect(&m_rcCheckPxl, pmsg->ptClientPxl)) ||
            PtInBox(m_rcItemPxl.right, m_rcItemPxl.bottom, pmsg->ptClientPxl)) {

            m_bChecked++;
            if (m_bChecked > GetMaxCheck()) {
                m_bChecked = 0;
            }
            GetStub()->Invalidate();

            return DU_S_COMPLETE;
        }
    }

    return DU_S_NOTHANDLED;
}


//------------------------------------------------------------------------------
void        
SmCheckBox::OnDraw(HDC hdc, GMSG_PAINTRENDERI * pmsgR) 
{
    UNREFERENCED_PARAMETER(pmsgR);

    HFONT hfntOld   = (HFONT) SelectObject(hdc, s_hfntCheck);
    COLORREF crOld  = SetTextColor(hdc, m_crCheckBox);
    int nOldMode    = 0;

    RECT rcDraw = m_rcCheckPxl;
    OffsetRect(&rcDraw, pmsgR->prcGadgetPxl->left, pmsgR->prcGadgetPxl->top);

    WCHAR * pszCheck;
    switch (m_bChecked)
    {
    default:
    case CheckBoxGadget::csUnchecked:
        pszCheck = NULL;
        break;

    case CheckBoxGadget::csChecked:
        pszCheck = L"a";
        nOldMode = SetBkMode(hdc, TRANSPARENT);
        break;

    case CheckBoxGadget::csUnknown:
        pszCheck = L"a";
        nOldMode = SetBkMode(hdc, OPAQUE);
        SetBkColor(hdc, RGB(223, 223, 223));
        break;
    }

    if (pszCheck != NULL) {
        OS()->TextOut(hdc, rcDraw.left - 1, rcDraw.top, pszCheck, 1);
    }

    DrawEdge(hdc, &rcDraw, EDGE_SUNKEN, BF_RECT);

    switch (m_bChecked)
    {
    case CheckBoxGadget::csChecked:
    case CheckBoxGadget::csUnknown:
        SetBkMode(hdc, nOldMode);
        break;
    }

    SetTextColor(hdc, crOld);
    SelectObject(hdc, hfntOld);

    if (m_fKeyboardFocus) {
        RECT rcItem = m_rcItemPxl;
        OffsetRect(&rcItem, pmsgR->prcGadgetPxl->left, pmsgR->prcGadgetPxl->top);
        InflateRect(&rcItem, 2, 1);
        DrawFocusRect(hdc, &rcItem);
    }
}


//------------------------------------------------------------------------------
void        
SmCheckBox::OnDraw(Gdiplus::Graphics * pgpgr, GMSG_PAINTRENDERF * pmsgR)
{
    UNREFERENCED_PARAMETER(pmsgR);

    Gdiplus::Color cr(GetRValue(m_crCheckBox), GetGValue(m_crCheckBox), GetBValue(m_crCheckBox));
    Gdiplus::SolidBrush br(cr);
    Gdiplus::Font fnt(L"Marlett", 8.0f, Gdiplus::FontStyleRegular, Gdiplus::UnitPoint);
    Gdiplus::RectF rc(
            (float) m_rcCheckPxl.left, 
            (float) m_rcCheckPxl.top,
            (float) (m_rcCheckPxl.right - m_rcCheckPxl.left),
            (float) (m_rcCheckPxl.bottom - m_rcCheckPxl.top));
    rc.Offset((float) pmsgR->prcGadgetPxl->X, (float) pmsgR->prcGadgetPxl->Y);

    WCHAR * pszCheck;
    switch (m_bChecked)
    {
    default:
    case CheckBoxGadget::csUnchecked:
        pszCheck = NULL;
        break;

    case CheckBoxGadget::csChecked:
        pszCheck = L"\xf061";
        break;

    case CheckBoxGadget::csUnknown:
        pszCheck = L"\xf061";
        break;
    }

    if (pszCheck != NULL) {
        pgpgr->DrawString(pszCheck, 1, &fnt, rc, 0, &br);
    }

    if (m_fKeyboardFocus) {
        Gdiplus::RectF rcItem(
                (float) m_rcItemPxl.left,
                (float) m_rcItemPxl.top,
                (float) (m_rcItemPxl.right - m_rcItemPxl.left),
                (float) (m_rcItemPxl.bottom - m_rcItemPxl.top));
        rcItem.Offset(pmsgR->prcGadgetPxl->X, pmsgR->prcGadgetPxl->Y);
        rcItem.Inflate(2.0f, 1.0f);

        Gdiplus::Pen pen(cr);
        pgpgr->DrawRectangle(&pen, rcItem);
    }
}


//------------------------------------------------------------------------------
HRESULT
SmCheckBox::ApiGetColor(CheckBoxGadget::GetColorMsg * pmsg)
{
    pmsg->crCheckBox = m_crCheckBox;
    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
SmCheckBox::ApiSetColor(CheckBoxGadget::SetColorMsg * pmsg)
{
    m_crCheckBox = pmsg->crCheckBox;
    GetStub()->Invalidate();
    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
SmCheckBox::ApiGetCheck(CheckBoxGadget::GetCheckMsg * pmsg)
{
    pmsg->nCheck = m_bChecked;
    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
SmCheckBox::ApiSetCheck(CheckBoxGadget::SetCheckMsg * pmsg)
{
    if (pmsg->nCheck <= GetMaxCheck()) {
        m_bChecked = (BYTE) pmsg->nCheck;
        GetStub()->Invalidate();
        return S_OK;
    }

    return E_INVALIDARG;
}


//------------------------------------------------------------------------------
HRESULT
SmCheckBox::ApiGetType(CheckBoxGadget::GetTypeMsg * pmsg)
{
    pmsg->nType = m_bType;
    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
SmCheckBox::ApiSetType(CheckBoxGadget::SetTypeMsg * pmsg)
{
    if (pmsg->nType <= CheckBoxGadget::ctMax) {
        m_bType = (BYTE) pmsg->nType;
        return S_OK;
    }

    return E_INVALIDARG;
}


//------------------------------------------------------------------------------
HRESULT
SmCheckBox::ApiGetItem(CheckBoxGadget::GetItemMsg * pmsg)
{
    pmsg->pgvItem = m_pgvItem;
    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
SmCheckBox::ApiSetItem(CheckBoxGadget::SetItemMsg * pmsg)
{
    AssertMsg(m_pgvItem == NULL, "TODO: Destroy existing item");

    m_pgvItem = pmsg->pgvItem;

    if (m_pgvItem != NULL) {
        ComputeLayout();
    }

    m_fText = FALSE;
    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
SmCheckBox::ApiSetText(CheckBoxGadget::SetTextMsg * pmsg)
{
    TextGadget * pgvText = NULL;
    if (!m_fText) {
        AssertMsg(m_pgvItem == NULL, "TODO: Destroy existing item");

        pgvText = BuildVisual<TextGadget>((Visual *) m_pgad);
        m_pgvItem = pgvText;
        if (m_pgvItem == NULL) {
            return S_OK;
        }

        m_fText = TRUE;
    } else {
        pgvText = (TextGadget *) m_pgvItem;
    }

    AssertMsg(m_pgvItem != NULL, "Must have valid TextGadget by now");

    if (s_hfntText == NULL) {
        s_hfntText = UtilBuildFont(L"Tahoma", 85, FS_NORMAL);
    }

    pgvText->SetAutoSize(TRUE);
    pgvText->SetFont(s_hfntText);
    pgvText->SetText(pmsg->pszText);
    pgvText->SetColor(RGB(0, 0, 128));

    ComputeLayout();

    return S_OK;
}


//------------------------------------------------------------------------------
void        
SmCheckBox::ComputeLayout()
{
    SIZE sizePxl;
    GetStub()->GetSize(&sizePxl);
    int nHeight = sizePxl.cy;

    if (m_pgvItem != NULL) {
        SIZE sizeBound, sizeBorderPxl;
        sizeBound.cx        = sizePxl.cx - (SIZE_Box.cx + 4 + 4);
        sizeBound.cy        = sizePxl.cy - 2;
        sizeBorderPxl.cx    = SIZE_Box.cx + 4;
        sizeBorderPxl.cy    = (sizePxl.cy - sizeBound.cy) / 2;

        m_pgvItem->SetRect(SGR_MOVE | SGR_SIZE | SGR_PARENT | SGR_NOINVALIDATE, 
                sizeBorderPxl.cx, sizeBorderPxl.cy, sizeBound.cx, sizeBound.cy);

        m_rcItemPxl.left    = sizeBorderPxl.cx;
        m_rcItemPxl.top     = sizeBorderPxl.cy;
        m_rcItemPxl.right   = m_rcItemPxl.left + sizeBound.cx;
        m_rcItemPxl.bottom  = m_rcItemPxl.top + sizeBound.cy;
    }

    m_rcCheckPxl.left   = 0;
    m_rcCheckPxl.top    = (nHeight - SIZE_Box.cy) / 2;
    m_rcCheckPxl.right  = m_rcCheckPxl.left + SIZE_Box.cx;
    m_rcCheckPxl.bottom = m_rcCheckPxl.top + SIZE_Box.cy;
}

#endif // ENABLE_MSGTABLE_API
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\smcheckbox.h ===
#if !defined(CTRL__SmCheckBox_h__INCLUDED)
#define CTRL__SmCheckBox_h__INCLUDED
#pragma once

#if ENABLE_MSGTABLE_API

#define TEST_MOUSEFOCUS    0            // Test MouseFocus by highlighting the CheckBox

//------------------------------------------------------------------------------
class SmCheckBox : 
        public CheckBoxGadgetImpl<SmCheckBox, SVisual>
{
// Construction
public:
    inline  SmCheckBox();
    inline  HRESULT     PostBuild(DUser::Gadget::ConstructInfo * pci);

// Operations
public:
    virtual void        OnDraw(HDC hdc, GMSG_PAINTRENDERI * pmsgR);
    virtual void        OnDraw(Gdiplus::Graphics * pgpgr, GMSG_PAINTRENDERF * pmsgR);

// Public Interface
public:
    dapi    HRESULT     ApiOnEvent(EventMsg * pmsg);

    dapi    HRESULT     ApiGetColor(CheckBoxGadget::GetColorMsg * pmsg);
    dapi    HRESULT     ApiSetColor(CheckBoxGadget::SetColorMsg * pmsg);
    dapi    HRESULT     ApiGetCheck(CheckBoxGadget::GetCheckMsg * pmsg);
    dapi    HRESULT     ApiSetCheck(CheckBoxGadget::SetCheckMsg * pmsg);
    dapi    HRESULT     ApiGetType(CheckBoxGadget::GetTypeMsg * pmsg);
    dapi    HRESULT     ApiSetType(CheckBoxGadget::SetTypeMsg * pmsg);
    dapi    HRESULT     ApiGetItem(CheckBoxGadget::GetItemMsg * pmsg);
    dapi    HRESULT     ApiSetItem(CheckBoxGadget::SetItemMsg * pmsg);
    dapi    HRESULT     ApiSetText(CheckBoxGadget::SetTextMsg * pmsg);

// Implementation
protected:
    inline  BYTE        GetMaxCheck() const;
            void        EmptyCheckBox();
            void        ComputeLayout();
            UINT        OnMouseDown(GMSG_MOUSE * pmsg);
    inline  void        SetKeyboardFocus(BOOL fFocus);

#if TEST_MOUSEFOCUS
    inline  void        SetMouseFocus(BOOL fFocus);
#endif // TEST_MOUSEFOCUS

// Data
protected:
    static  HFONT       s_hfntCheck;            // Standard font used for check
    static  HFONT       s_hfntText;             // Standard font used for text

            Visual *    m_pgvItem;              // Nested item
            RECT        m_rcCheckPxl;           // Check position (client)
            RECT        m_rcItemPxl;            // Nested item position (client)
            COLORREF    m_crCheckBox;           // Color of check
            BYTE        m_bChecked:8;           // State of checkbox
            BYTE        m_bType:8;              // Type of checkbox
            BOOL        m_fKeyboardFocus:1;     // Checkbox has keyboard focus
            BOOL        m_fText:1;              // Item is a TextGadget
};

#endif // ENABLE_MSGTABLE_API

#include "SmCheckBox.inl"

#endif // CTRL__SmCheckBox_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\smeditline.h ===
#if !defined(CTRL__SmEditLine_h__INCLUDED)
#define CTRL__SmEditLine_h__INCLUDED
#pragma once

#if ENABLE_MSGTABLE_API

//------------------------------------------------------------------------------
class SmEditLine : 
        public EditLineGadgetImpl<SmEditLine, SVisual>
#if 0
        ,public IDropTarget
#endif
{
// Construction
public:
            SmEditLine();
            ~SmEditLine();
            HRESULT     PostBuild(DUser::Gadget::ConstructInfo * pci);

// Operations
public:
    virtual void        OnDraw(HDC hdc, GMSG_PAINTRENDERI * pmsgR);

#if 0
    GBEGIN_COM_MAP(SmEditLine)
        GCOM_INTERFACE_ENTRY(IDropTarget)
    GEND_COM_MAP()
#endif

// Public API
public:
    dapi    HRESULT     ApiOnEvent(EventMsg * pmsg);
    dapi    HRESULT     ApiGetFont(EditLineGadget::GetFontMsg * pmsg);
    dapi    HRESULT     ApiSetFont(EditLineGadget::SetFontMsg * pmsg);
    dapi    HRESULT     ApiGetText(EditLineGadget::GetTextMsg * pmsg);
    dapi    HRESULT     ApiSetText(EditLineGadget::SetTextMsg * pmsg);
    dapi    HRESULT     ApiGetTextColor(EditLineGadget::GetTextColorMsg * pmsg);
    dapi    HRESULT     ApiSetTextColor(EditLineGadget::SetTextColorMsg * pmsg);

// IDropTarget
public:
#if 0
    STDMETHOD(DragEnter)(IDataObject * pdoSrc, DWORD grfKeyState, POINTL pt, DWORD * pdwEffect);
    STDMETHOD(DragOver)(DWORD grfKeyState, POINTL pt, DWORD * pdwEffect);
    STDMETHOD(DragLeave)();
    STDMETHOD(Drop)(IDataObject * pdoSrc, DWORD grfKeyState, POINTL pt, DWORD * pdwEffect);
#endif

// Implementation
protected:
    static  void CALLBACK BlinkActionProc(GMA_ACTIONINFO * pmai);

            void        SetTextColor(COLORREF crText);

			void		InsertChar(WCHAR chKey);
            void        DeleteChars(int idxchStart, int cchDel);
            void        RebuildCaret();
            void        UpdateCaretPos();
            int         ComputeMouseChar(POINT ptOffsetPxl);

            void        UpdateFocus(UINT nCmd);

#if 0
            BOOL        HasText(IDataObject * pdoSrc);
#endif


// Data
protected:
    static  HFONT       s_hfntDefault;      // Default font

            Thread *    m_pThread;          // Owning thread
            HPEN        m_hpenCaret;        // Pen to draw caret with
            HFONT       m_hfnt;             // Text font
            COLORREF    m_crText;           // Color of text
            HACTION     m_hactBlink;        // Action to blink caret

            DWORD       m_dwLastDropEffect; // Last dwEffect for DnD

            enum {
                m_cchMax    = 128  // Temporary hack
            };
            WCHAR       m_szBuffer[m_cchMax];
            int         m_idxchCaret;       // Character position of caret in buffer
            int         m_cchSize;          // Number of characters in buffer
            int         m_cyLinePxl;        // Height of single line in pixels
            int         m_cyCaretPxl;       // Height of caret in pixels
            int         m_yCaretOffsetPxl;  // Offset of caret in pixels
            POINT       m_ptCaretPxl;       // Location of caret
            BOOL        m_fFocus:1;         // Control has focus
            BOOL        m_fCaretShown:1;    // Caret is shown
};



//------------------------------------------------------------------------------
class SmEditLineF : 
        public EditLineFGadgetImpl<SmEditLineF, SVisual>
{
// Construction
public:
            SmEditLineF();
            ~SmEditLineF();
            HRESULT     PostBuild(DUser::Gadget::ConstructInfo * pci);

// Operations
public:
    virtual void        OnDraw(Gdiplus::Graphics * pgpgr, GMSG_PAINTRENDERF * pmsgR);

// Public API
public:
    dapi    HRESULT     ApiOnEvent(EventMsg * pmsg);
    dapi    HRESULT     ApiGetFont(EditLineFGadget::GetFontMsg * pmsg);
    dapi    HRESULT     ApiSetFont(EditLineFGadget::SetFontMsg * pmsg);
    dapi    HRESULT     ApiGetText(EditLineFGadget::GetTextMsg * pmsg);
    dapi    HRESULT     ApiSetText(EditLineFGadget::SetTextMsg * pmsg);
    dapi    HRESULT     ApiGetTextFill(EditLineFGadget::GetTextFillMsg * pmsg);
    dapi    HRESULT     ApiSetTextFill(EditLineFGadget::SetTextFillMsg * pmsg);

// Implementation
protected:
    static  void CALLBACK BlinkActionProc(GMA_ACTIONINFO * pmai);

			void		InsertChar(WCHAR chKey);
            void        DeleteChars(int idxchStart, int cchDel);
            void        RebuildCaret();
            void        UpdateCaretPos();
            int         ComputeMouseChar(POINT ptOffsetPxl);

            void        UpdateFocus(UINT nCmd);

// Data
protected:
    static  HFONT       s_hfntDefault;      // Default font

            Thread *    m_pThread;          // Owning thread
            Gdiplus::Font * 
                        m_pgpfnt;           // Text font
            Gdiplus::Brush *
                        m_pgpbrText;        // Text brush
            HACTION     m_hactBlink;        // Action to blink caret

            DWORD       m_dwLastDropEffect; // Last dwEffect for DnD

            enum {
                m_cchMax    = 128  // Temporary hack
            };
            WCHAR       m_szBuffer[m_cchMax];
            int         m_idxchCaret;       // Character position of caret in buffer
            int         m_cchSize;          // Number of characters in buffer
            int         m_cyLinePxl;        // Height of single line in pixels
            int         m_cyCaretPxl;       // Height of caret in pixels
            int         m_yCaretOffsetPxl;  // Offset of caret in pixels
            Gdiplus::PointF
                        m_ptCaretPxl;       // Location of caret
            BOOL        m_fFocus:1;         // Control has focus
            BOOL        m_fCaretShown:1;    // Caret is shown
            BOOL        m_fOwnFont:1;       // Own text font
};


#endif // ENABLE_MSGTABLE_API

#endif // CTRL__SmEditLine_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\smhyperlink.h ===
#if !defined(CTRL__SmHyperLink_h__INCLUDED)
#define CTRL__SmHyperLink_h__INCLUDED
#pragma once

#include "SmText.h"

#if ENABLE_MSGTABLE_API

//------------------------------------------------------------------------------
class SmHyperLink : 
        public HyperLinkGadgetImpl<SmHyperLink, SmText>
{
// Construction
public:
    inline  SmHyperLink();
    inline  HRESULT     PostBuild(DUser::Gadget::ConstructInfo * pci);

// Operations
public:
    dapi    HRESULT     ApiOnEvent(EventMsg * pmsg);

    dapi    HRESULT     ApiGetActiveFont(HyperLinkGadget::GetActiveFontMsg * pmsg);
    dapi    HRESULT     ApiSetActiveFont(HyperLinkGadget::SetActiveFontMsg * pmsg);
    dapi    HRESULT     ApiGetNormalFont(HyperLinkGadget::GetNormalFontMsg * pmsg);
    dapi    HRESULT     ApiSetNormalFont(HyperLinkGadget::SetNormalFontMsg * pmsg);
    dapi    HRESULT     ApiGetActiveColor(HyperLinkGadget::GetActiveColorMsg * pmsg);
    dapi    HRESULT     ApiSetActiveColor(HyperLinkGadget::SetActiveColorMsg * pmsg);
    dapi    HRESULT     ApiGetNormalColor(HyperLinkGadget::GetNormalColorMsg * pmsg);
    dapi    HRESULT     ApiSetNormalColor(HyperLinkGadget::SetNormalColorMsg * pmsg);

// Data
protected:
    static  HCURSOR     s_hcurHand;
    static  HCURSOR     s_hcurOld;
            HFONT       m_hfntActive;
            HFONT       m_hfntNormal;
            COLORREF    m_crActive;
            COLORREF    m_crNormal;
            BOOL        m_fClicked:1;
};

#endif // ENABLE_MSGTABLE_API

#include "SmHyperLink.inl"

#endif // CTRL__SmHyperLink_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\smhyperlink.cpp ===
#include "stdafx.h"
#include "Ctrl.h"
#include "SmHyperLink.h"

#if ENABLE_MSGTABLE_API

// TODO: Need to make cross-platform
#ifndef IDC_HAND
#define IDC_HAND            MAKEINTRESOURCE(32649)
#endif

#define ENABLE_RAISEACTIVE          0   // Raise hyperlink when active

/***************************************************************************\
*****************************************************************************
*
* class SmHyperLink
*
*****************************************************************************
\***************************************************************************/

HCURSOR SmHyperLink::s_hcurHand = NULL;
HCURSOR SmHyperLink::s_hcurOld  = NULL;

static const GUID guidEventClicked = { 0x307a94bc, 0x6c9e, 0x4f21, { 0xa8, 0x74, 0x72, 0x29, 0xde, 0x82, 0x2a, 0xba } };    // {307A94BC-6C9E-4f21-A874-7229DE822ABA}

//------------------------------------------------------------------------------
HRESULT
SmHyperLink::ApiOnEvent(EventMsg * pmsg)
{
     if (GET_EVENT_DEST(pmsg) == GMF_DIRECT) {
        switch (pmsg->nMsg)
        {
        case GM_CHANGESTATE:
            {
                GMSG_CHANGESTATE * pmsgC = (GMSG_CHANGESTATE *) pmsg;
                if (pmsgC->nCode == GSTATE_MOUSEFOCUS) {
                    switch (pmsgC->nCmd) 
                    {
                    case GSC_SET:
                        m_fClicked  = TRUE;
                        m_hfnt      = m_hfntActive;
                        m_crText    = m_crActive;
                        s_hcurOld   = SetCursor(s_hcurHand);

#if ENABLE_RAISEACTIVE
                        {
                            RECT rcThis;
                            CallGetRect(SGR_PARENT, &rcThis);
                            CallSetRect(SGR_MOVE | SGR_PARENT, m_hgad, rcThis.left - 1, rcThis.top - 1, 0, 0);
                        }
#endif

                        GetStub()->Invalidate();
                        break;

                    case GSC_LOST:
                        m_fClicked  = FALSE;
                        m_hfnt      = m_hfntNormal;
                        m_crText    = m_crNormal;
                        SetCursor(s_hcurOld);

#if ENABLE_RAISEACTIVE
                        {
                            RECT rcThis;
                            GetGadgetRect(SGR_PARENT, &rcThis);
                            SetGadgetRect(SGR_MOVE | SGR_PARENT, rcThis.left + 1, rcThis.top + 1, 0, 0);
                        }
#endif

                        GetStub()->Invalidate();
                        break;
                    }
                    return DU_S_PARTIAL;
                }  // GINPUT_MOUSE
            }
            break;  // GM_INPUT

        case GM_QUERY:
            {
                GMSG_QUERY * pmsgQ = (GMSG_QUERY *) pmsg;
                switch (pmsgQ->nCode)
                {
                case GQUERY_DESCRIPTION:
                    {
                        GMSG_QUERYDESC * pmsgQD = (GMSG_QUERYDESC *) pmsg;
                        CopyString(pmsgQD->szName, m_pszText, _countof(pmsgQD->szName));
                        CopyString(pmsgQD->szType, L"SmHyperLink", _countof(pmsgQD->szType));
                        return DU_S_COMPLETE;
                    }
                }
            }
            break;
        }
    }


    return SmText::ApiOnEvent(pmsg);
}


//------------------------------------------------------------------------------
HRESULT
SmHyperLink::ApiGetActiveFont(HyperLinkGadget::GetActiveFontMsg * pmsg)
{
    pmsg->hfnt = m_hfntActive;

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
SmHyperLink::ApiSetActiveFont(HyperLinkGadget::SetActiveFontMsg * pmsg)
{
    m_hfntActive = pmsg->hfnt;
    if (m_fClicked) {
        GetStub()->SetFont(pmsg->hfnt);
    }

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
SmHyperLink::ApiGetNormalFont(HyperLinkGadget::GetNormalFontMsg * pmsg)
{
    pmsg->hfnt = m_hfntNormal;

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
SmHyperLink::ApiSetNormalFont(HyperLinkGadget::SetNormalFontMsg * pmsg)
{
    m_hfntNormal = pmsg->hfnt;
    if (!m_fClicked) {
        GetStub()->SetFont(pmsg->hfnt);
    }

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
SmHyperLink::ApiGetActiveColor(HyperLinkGadget::GetActiveColorMsg * pmsg)
{
    pmsg->crText = m_crActive;

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
SmHyperLink::ApiSetActiveColor(HyperLinkGadget::SetActiveColorMsg * pmsg)
{
    m_crActive = pmsg->crText;
    if (m_fClicked) {
        m_crText = pmsg->crText;
    }

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
SmHyperLink::ApiGetNormalColor(HyperLinkGadget::GetNormalColorMsg * pmsg)
{
    pmsg->crText = m_crNormal;

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
SmHyperLink::ApiSetNormalColor(HyperLinkGadget::SetNormalColorMsg * pmsg)
{
    m_crNormal = pmsg->crText;
    if (!m_fClicked) {
        m_crText = pmsg->crText;
    }

    return S_OK;
}

#endif // ENABLE_MSGTABLE_API
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\smeditline.cpp ===
#include "stdafx.h"
#include "Ctrl.h"
#include "SmEditLine.h"

#if ENABLE_MSGTABLE_API

/***************************************************************************\
*****************************************************************************
*
* class SmEditLine
*
*****************************************************************************
\***************************************************************************/

HFONT       SmEditLine::s_hfntDefault   = NULL;

//------------------------------------------------------------------------------
SmEditLine::SmEditLine()
{
    if (s_hfntDefault == NULL) {
        s_hfntDefault = UtilBuildFont(L"Tahoma", 85, FS_NORMAL);
    }

    m_szBuffer[0]   = '\0';
    m_idxchCaret    = 0;
    m_cchSize       = 0;
    m_hfnt          = s_hfntDefault;
    m_hpenCaret     = NULL;
    m_fFocus        = FALSE;

    m_pThread       = GetThread();

    RebuildCaret();
}


//------------------------------------------------------------------------------
SmEditLine::~SmEditLine()
{
    ::DeleteHandle(m_hactBlink);
    ::DeleteObject(m_hpenCaret);
}


//------------------------------------------------------------------------------
HRESULT
SmEditLine::PostBuild(DUser::Gadget::ConstructInfo * pci)
{
    UNREFERENCED_PARAMETER(pci);

    GetStub()->SetFilter(  GMFI_PAINT | GMFI_INPUTKEYBOARD | GMFI_INPUTMOUSE | GMFI_CHANGESTATE, GMFI_ALL);
    GetStub()->SetStyle(   GS_KEYBOARDFOCUS | GS_ZEROORIGIN | GS_MOUSEFOCUS, 
                    GS_KEYBOARDFOCUS | GS_ZEROORIGIN | GS_MOUSEFOCUS);

    SetTextColor(RGB(0, 0, 0));

    return S_OK;
}


//------------------------------------------------------------------------------
void CALLBACK
SmEditLine::BlinkActionProc(GMA_ACTIONINFO * pmai)
{
    SmEditLine * pThis = (SmEditLine *) pmai->pvData;
    if (pmai->fFinished) {
        pThis->m_hactBlink = NULL;
        return;
    }

    pThis->m_fCaretShown = !pThis->m_fCaretShown;
    pThis->GetStub()->Invalidate();
}


//------------------------------------------------------------------------------
HRESULT
SmEditLine::ApiOnEvent(EventMsg * pmsg)
{
     if (GET_EVENT_DEST(pmsg) == GMF_DIRECT) {
        switch (pmsg->nMsg)
        {
        case GM_PAINT:
            {
                GMSG_PAINT * pmsgPaint = (GMSG_PAINT *) pmsg;
                if (pmsgPaint->nCmd == GPAINT_RENDER) {
                    switch (pmsgPaint->nSurfaceType)
                    {
                    case GSURFACE_HDC:
                        {
                            GMSG_PAINTRENDERI * pmsgR = (GMSG_PAINTRENDERI *) pmsgPaint;
                            OnDraw(pmsgR->hdc, pmsgR);
                        }
                        break;

                    default:
                        Trace("WARNING: Unknown surface type\n");
                    }

                    return DU_S_PARTIAL;
                }
            }
            break;

        case GM_INPUT:
            {
                GMSG_INPUT * pmsgI = (GMSG_INPUT *) pmsg;
                switch (pmsgI->nDevice)
                {
                case GINPUT_KEYBOARD:
                    {
                        GMSG_KEYBOARD * pmsgK = (GMSG_KEYBOARD *) pmsgI;
                        switch (pmsgK->nCode)
                        {
                        case GKEY_DOWN:
                            {
                                //
                                // GKEY_DOWN is the raw key-press event that contains any key that
                                // is pressed.
                                //

                                WCHAR chKey = pmsgK->ch;
                                switch (chKey)
                                {
                                case VK_LEFT:
                                    if (m_idxchCaret > 0) {
                                        m_idxchCaret--;
                                        UpdateCaretPos();
                                    }
                                    break;

                                case VK_RIGHT:
                                    if (m_idxchCaret < m_cchSize) {
                                        m_idxchCaret++;
                                        UpdateCaretPos();
                                    }
                                    break;

                                case VK_BACK:
                                    DeleteChars(m_idxchCaret - 1, 1);
                                    UpdateCaretPos();
                                    break;

                                case VK_DELETE:
                                    DeleteChars(m_idxchCaret, 1);
                                    UpdateCaretPos();
                                    break;

                                case VK_HOME:
                                    m_idxchCaret = 0;
                                    UpdateCaretPos();
                                    break;

                                case VK_END:
                                    m_idxchCaret = m_cchSize;
                                    UpdateCaretPos();
                                    break;

				                case VK_RETURN:
					                InsertChar('\r\n');
					                break;
                                }
                            }
                            break;

                        case GKEY_CHAR:
                            {
                                //
                                // GKEY_CHAR is a "processed" key-press event that gets
				                // generated from other messages.  This will take into account
				                // the caps-lock state, etc., so it is useful to get
				                // characters.
                                //

                                WCHAR chKey = pmsgK->ch;
                                if (chKey >= ' ') {
					                InsertChar(chKey);
                                }
                            }
                            break;
                        }
                    }
                    break;  // GINPUT_KEYBOARD

                case GINPUT_MOUSE:
                    {
                        GMSG_MOUSE * pmsgM = (GMSG_MOUSE *) pmsg;
                        switch (pmsgM->nCode)
                        {
                        case GMOUSE_DOWN:
                        case GMOUSE_UP:
                            if (pmsgM->bButton == GBUTTON_LEFT) {
                                POINT ptOffsetPxl = pmsgM->ptClientPxl;
                                int idxchNew = ComputeMouseChar(ptOffsetPxl);
                                if (idxchNew != m_idxchCaret) {
                                    m_idxchCaret = idxchNew;
                                    UpdateCaretPos();
                                }

                                return DU_S_COMPLETE;
                            }
                        }
                    }
                    break;  // GINPUT_MOUSE
                }
            }
            break;  // GM_INPUT

        case GM_CHANGESTATE:
            {
                GMSG_CHANGESTATE * pmsgS = (GMSG_CHANGESTATE *) pmsg;
                if (pmsgS->nCode == GSTATE_KEYBOARDFOCUS) {
                    UpdateFocus(pmsgS->nCmd);
                }
            }
            break;

        case GM_QUERY:
            {
                GMSG_QUERY * pmsgQ = (GMSG_QUERY *) pmsg;
                switch (pmsgQ->nCode)
                {
                case GQUERY_DESCRIPTION:
                    {
                        GMSG_QUERYDESC * pmsgQD = (GMSG_QUERYDESC *) pmsg;
                        CopyString(pmsgQD->szName, m_szBuffer, _countof(pmsgQD->szName));
                        CopyString(pmsgQD->szType, L"SmEditLine", _countof(pmsgQD->szType));
                        return DU_S_COMPLETE;
                    }

#if 0
                case GQUERY_DROPTARGET:
                    {
                        GMSG_QUERYDROPTARGET * pmsgQDT = (GMSG_QUERYDROPTARGET *) pmsg;
                        pmsgQDT->hgadDrop   = GetHandle();
                        pmsgQDT->pdt        = static_cast<IDropTarget *> (this);
                        pmsgQDT->pdt->AddRef();
                        return DU_S_COMPLETE;
                    }
#endif
                }
            }
            break;
        }
    }

    return SVisual::ApiOnEvent(pmsg);
}


//------------------------------------------------------------------------------
void
SmEditLine::UpdateFocus(UINT nCmd)
{
    m_fFocus = (nCmd == GSC_SET);

    if (m_fFocus) {
        //
        // This control is getting the focus.
        //

        //
        // Create an action that can be used to blink the edit control.  Each thread
        // needs to do this since timers are per-thread and Gadget functions need
        // to execute in the correct Context.
        //

        GMA_ACTION gma;
        ZeroMemory(&gma, sizeof(gma));
        gma.cbSize      = sizeof(gma);
        gma.cRepeat     = (UINT) -1;
        gma.flDelay     = 0.0f;
        gma.flPeriod    = GetCaretBlinkTime() / 1000.0f;
        gma.flDuration  = 0.0f;
        gma.pfnProc     = BlinkActionProc;
        gma.pvData      = this;

        m_hactBlink = CreateAction(&gma);
    } else {
        //
        // Loosing focus, so change to NULL if currently point 
        // to this Edit control.
        //

        ::DeleteHandle(m_hactBlink);
        m_hactBlink = NULL;
    }

    GetStub()->Invalidate();
}


//------------------------------------------------------------------------------
void
SmEditLine::InsertChar(WCHAR chKey)
{
    if (m_cchSize < m_cchMax) {
        //
        // Move the text after current position down one character
        //

        int cchMove = m_cchSize - m_idxchCaret + 1;
        if (cchMove > 0) {
            MoveMemory(&m_szBuffer[m_idxchCaret + 1], &m_szBuffer[m_idxchCaret], cchMove * sizeof(WCHAR));
        }

        //
        // Insert the new character
        //

        m_szBuffer[m_idxchCaret] = chKey;

        //
        // Check if need to re-NULL-terminate
        //

        if (m_idxchCaret > m_cchSize) {
            m_szBuffer[m_idxchCaret] = '\0';
        }

        //
        // Update position
        //

        m_idxchCaret++;
        m_cchSize++;

        UpdateCaretPos();
    }
}


//------------------------------------------------------------------------------
void
SmEditLine::DeleteChars(int idxchStart, int cchDel)
{
    if ((idxchStart >= m_cchSize) || (idxchStart < 0)) {
        // Nothing to delete
        return;
    }

    // Make sure deleting within range
    cchDel = min(cchDel, m_cchSize - idxchStart);

    int idxchDest   = idxchStart;
    int idxchSrc    = idxchStart + cchDel;
    int chMove      = m_cchSize - idxchSrc;

    MoveMemory(&m_szBuffer[idxchDest], &m_szBuffer[idxchSrc], chMove * sizeof(WCHAR));

    m_cchSize -= cchDel;

    if (m_idxchCaret > idxchStart) {
        m_idxchCaret = idxchStart;
    }
}


//------------------------------------------------------------------------------
void
SmEditLine::OnDraw(HDC hdc, GMSG_PAINTRENDERI * pmsgR)
{
    RECT rcDraw = *pmsgR->prcGadgetPxl;

    if (m_cchSize != 0) {
        HFONT hfntOld = NULL;
        if (m_hfnt != NULL) {
            hfntOld = (HFONT) ::SelectObject(hdc, m_hfnt);
        }

        COLORREF crOld  = ::SetTextColor(hdc, m_crText);
        int nOldMode    = ::SetBkMode(hdc, TRANSPARENT);

        //
        // NOTE: We have currently disabled calling DrawText because the 
        // performance is TERRIBLE!  This should be much better using Text+.
        //

#if 1
        OS()->ExtTextOut(hdc, rcDraw.left, rcDraw.top, 
                ETO_CLIPPED, &rcDraw, m_szBuffer, m_cchSize, NULL);
#else
        OS()->DrawText(hdc, m_szBuffer, m_cchSize, &rcDraw, 
                DT_TOP | DT_LEFT | DT_WORDBREAK | DT_NOPREFIX);
#endif

        ::SetBkMode(hdc, nOldMode);
        ::SetTextColor(hdc, crOld);

        if (m_hfnt != NULL) {
            ::SelectObject(hdc, hfntOld);
        }
    }

    if (m_fFocus && m_fCaretShown) {
        HPEN hpenOld = (HPEN) SelectObject(hdc, m_hpenCaret);

        POINT rgpt[2];
        rgpt[0].x   = m_ptCaretPxl.x;
        rgpt[0].y   = m_ptCaretPxl.y + m_yCaretOffsetPxl;
        rgpt[1].x   = m_ptCaretPxl.x;
        rgpt[1].y   = m_ptCaretPxl.y + m_cyCaretPxl + m_yCaretOffsetPxl;

        Polyline(hdc, rgpt, _countof(rgpt));

        SelectObject(hdc, hpenOld);
    }
}


//------------------------------------------------------------------------------
HRESULT
SmEditLine::ApiGetFont(EditLineGadget::GetFontMsg * pmsg)
{
    pmsg->hfnt = m_hfnt;
    
    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
SmEditLine::ApiSetFont(EditLineGadget::SetFontMsg * pmsg)
{
    m_hfnt = pmsg->hfnt;
    RebuildCaret();
    UpdateCaretPos();
    
    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
SmEditLine::ApiGetText(EditLineGadget::GetTextMsg * pmsg)
{
    pmsg->pszText = m_szBuffer;
    
    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
SmEditLine::ApiSetText(EditLineGadget::SetTextMsg * pmsg)
{
    wcsncpy(m_szBuffer, pmsg->pszText, m_cchMax);
    m_szBuffer[m_cchMax] = '\0';
    m_cchSize   = lstrlenW(m_szBuffer);
    if (m_idxchCaret > m_cchSize) {
        m_idxchCaret = m_cchSize;
    }

    UpdateCaretPos();
    
    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
SmEditLine::ApiGetTextColor(EditLineGadget::GetTextColorMsg * pmsg)
{
    pmsg->crText = m_crText;
    
    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
SmEditLine::ApiSetTextColor(EditLineGadget::SetTextColorMsg * pmsg)
{
    SetTextColor(pmsg->crText);
    
    return S_OK;
}


//------------------------------------------------------------------------------
void
SmEditLine::SetTextColor(COLORREF crText)
{
    m_crText = crText;

    if (m_hpenCaret != NULL) {
        DeleteObject(m_hpenCaret);
    }

    m_hpenCaret = CreatePen(PS_SOLID, 1, m_crText);
}


//------------------------------------------------------------------------------
void
SmEditLine::RebuildCaret()
{
    HDC hdc = GetGdiCache()->GetTempDC();
    TEXTMETRIC tm;
    HFONT hfntOld   = (HFONT) SelectObject(hdc, m_hfnt);

    GetTextMetrics(hdc, &tm);
    m_cyLinePxl         = tm.tmHeight;
    m_cyCaretPxl        = tm.tmHeight;
    m_yCaretOffsetPxl   = tm.tmInternalLeading;

    SelectObject(hdc, hfntOld);
    GetGdiCache()->ReleaseTempDC(hdc);
}


//------------------------------------------------------------------------------
void
SmEditLine::UpdateCaretPos()
{
    HDC hdc         = GetGdiCache()->GetTempDC();
    HFONT hfntOld   = (HFONT) SelectObject(hdc, m_hfnt);

    //
    // TODO: This wrapping calculation is PURE EVIL and needs to be properly
    // written using Text+.
    //

    SIZE sizeTextPxl;
    if (OS()->GetTextExtentPoint32(hdc, m_szBuffer, m_idxchCaret, &sizeTextPxl)) {
        int nLine = 0;
        int idxStart = 0;

        SIZE sizeGadgetPxl;
        GetStub()->GetSize(&sizeGadgetPxl);
        while(sizeTextPxl.cx > sizeGadgetPxl.cx) {
            //
            // Need to word wrap.
            //

            int idxMax;
            if (OS()->GetTextExtentExPoint(hdc, &m_szBuffer[idxStart], m_idxchCaret, sizeGadgetPxl.cx, &idxMax, NULL, &sizeTextPxl)) {
                idxMax += idxStart;
                for (int idx = idxMax; idx >= idxStart; idx--) {
                    if (m_szBuffer[idx] == ' ') {
                        break;
                    }
                }
                if (idx == (idxStart - 1)) {
                    //
                    // There was no space in the word to break on, so just chop at the end
                    //
                    idx = idxMax;
                }

                nLine++;
                idxStart = idx + 1;
                OS()->GetTextExtentPoint32(hdc, &m_szBuffer[idxStart], m_idxchCaret - idxStart, &sizeTextPxl);
            }
        }

        m_ptCaretPxl.x  = sizeTextPxl.cx;
        m_ptCaretPxl.y  = nLine * m_cyLinePxl;

        if (m_ptCaretPxl.x > 0) {
            m_ptCaretPxl.x++;
        }
    }

    SelectObject(hdc, hfntOld);
    GetGdiCache()->ReleaseTempDC(hdc);

    GetStub()->Invalidate();
}


//------------------------------------------------------------------------------
int
SmEditLine::ComputeMouseChar(POINT ptOffsetPxl)
{
    //
    // Check boundary conditions
    //

    if (ptOffsetPxl.x < 0) {
        return 0;
    }

    SIZE sizePxl;
    GetStub()->GetSize(&sizePxl);
    if (ptOffsetPxl.x > sizePxl.cx) {
        return m_cchSize;
    }

    //
    // This implementation is very poor, but we don't care for now because this
    // is a sample control and is only for single-line.
    //

    HDC hdc         = GetGdiCache()->GetTempDC();
    HFONT hfntOld   = (HFONT) SelectObject(hdc, m_hfnt);
    int ichFound    = m_cchSize;

    SIZE sizeTextPxl;
    for (int cch = 0; cch < m_cchSize; cch++) {
        OS()->GetTextExtentPoint32(hdc, m_szBuffer, cch, &sizeTextPxl);
        if (sizeTextPxl.cx > ptOffsetPxl.x) {
            // We are greater, so return previous character

            AssertMsg(cch > 0, "Should have at least one character");
            ichFound = cch - 1;
            goto Cleanup;
        }
    }

Cleanup:
    SelectObject(hdc, hfntOld);
    GetGdiCache()->ReleaseTempDC(hdc);

    return ichFound;
}


#if 0
//------------------------------------------------------------------------------
STDMETHODIMP
SmEditLine::DragEnter(IDataObject * pdoSrc, DWORD grfKeyState, POINTL pt, DWORD * pdwEffect)
{
    UNREFERENCED_PARAMETER(grfKeyState);
    UNREFERENCED_PARAMETER(pt);

    if (pdoSrc == NULL) {
        return E_INVALIDARG;
    }

    m_dwLastDropEffect = DROPEFFECT_NONE;

    if (HasText(pdoSrc)) {
        m_dwLastDropEffect = DROPEFFECT_COPY;
    }

    *pdwEffect = m_dwLastDropEffect;

    GetStub()->Invalidate();

    return S_OK;
}


//------------------------------------------------------------------------------
STDMETHODIMP
SmEditLine::DragOver(DWORD grfKeyState, POINTL pt, DWORD * pdwEffect)
{
    UNREFERENCED_PARAMETER(grfKeyState);
    UNREFERENCED_PARAMETER(pt);

    *pdwEffect = m_dwLastDropEffect;
    return S_OK;
}


//------------------------------------------------------------------------------
STDMETHODIMP
SmEditLine::DragLeave()
{
    GetStub()->Invalidate();

    return S_OK;
}


//------------------------------------------------------------------------------
STDMETHODIMP
SmEditLine::Drop(IDataObject * pdoSrc, DWORD grfKeyState, POINTL pt, DWORD * pdwEffect)
{
    UNREFERENCED_PARAMETER(grfKeyState);
    UNREFERENCED_PARAMETER(pt);

    Assert(pdoSrc != NULL);

    FORMATETC etc;
    etc.cfFormat    = CF_TEXT;
    etc.ptd         = NULL;
    etc.dwAspect    = DVASPECT_CONTENT;
    etc.lindex      = -1;
    etc.tymed       = TYMED_HGLOBAL;

    STGMEDIUM stg;
    stg.tymed       = TYMED_HGLOBAL;
    stg.hGlobal     = NULL;

    *pdwEffect = DROPEFFECT_NONE;

    HRESULT hr = pdoSrc->GetData(&etc, &stg);
    if (hr == S_OK) {
        USES_CONVERSION;

        void * pvData = GlobalLock(stg.hGlobal);
        if (pvData != NULL) {
            SetText(A2W((LPCSTR) pvData));
            GlobalUnlock(stg.hGlobal);
            *pdwEffect = DROPEFFECT_COPY;
        }
            
        GetComManager()->ReleaseStgMedium(&stg);
    }

    return S_OK;
}


//------------------------------------------------------------------------------
BOOL
SmEditLine::HasText(IDataObject * pdoSrc)
{
    Assert(pdoSrc != NULL);

    FORMATETC etc;
    etc.cfFormat    = CF_TEXT;
    etc.ptd         = NULL;
    etc.dwAspect    = DVASPECT_CONTENT;
    etc.lindex      = -1;
    etc.tymed       = TYMED_HGLOBAL;

    HRESULT hr = pdoSrc->QueryGetData(&etc);
    return hr == S_OK;  // S_OK means the data format is supported
}

#endif



/***************************************************************************\
*****************************************************************************
*
* class SmEditLineF
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
SmEditLineF::SmEditLineF()
{
    m_szBuffer[0]   = '\0';
    m_idxchCaret    = 0;
    m_cchSize       = 0;
    m_pgpfnt        = new Gdiplus::Font(L"Tahoma", 12.0f, Gdiplus::FontStyleRegular, Gdiplus::UnitPoint);
    m_fOwnFont      = TRUE;
    m_fFocus        = FALSE;

    m_pThread       = GetThread();

    RebuildCaret();
}


//------------------------------------------------------------------------------
SmEditLineF::~SmEditLineF()
{
    ::DeleteHandle(m_hactBlink);

    if (m_fOwnFont) {
        delete m_pgpfnt;
    }
}


//------------------------------------------------------------------------------
HRESULT
SmEditLineF::PostBuild(DUser::Gadget::ConstructInfo * pci)
{
    UNREFERENCED_PARAMETER(pci);

    GetStub()->SetFilter(  GMFI_PAINT | GMFI_INPUTKEYBOARD | GMFI_INPUTMOUSE | GMFI_CHANGESTATE, GMFI_ALL);
    GetStub()->SetStyle(   GS_KEYBOARDFOCUS | GS_ZEROORIGIN | GS_MOUSEFOCUS, 
                    GS_KEYBOARDFOCUS | GS_ZEROORIGIN | GS_MOUSEFOCUS);

    m_pgpbrText = GetStdColorBrushF(SC_Black);

    return S_OK;
}


//------------------------------------------------------------------------------
void CALLBACK
SmEditLineF::BlinkActionProc(GMA_ACTIONINFO * pmai)
{
    SmEditLineF * pThis = (SmEditLineF *) pmai->pvData;
    if (pmai->fFinished) {
        pThis->m_hactBlink = NULL;
        return;
    }

    pThis->m_fCaretShown = !pThis->m_fCaretShown;
    pThis->GetStub()->Invalidate();
}


//------------------------------------------------------------------------------
HRESULT
SmEditLineF::ApiOnEvent(EventMsg * pmsg)
{
     if (GET_EVENT_DEST(pmsg) == GMF_DIRECT) {
        switch (pmsg->nMsg)
        {
        case GM_PAINT:
            {
                GMSG_PAINT * pmsgPaint = (GMSG_PAINT *) pmsg;
                if (pmsgPaint->nCmd == GPAINT_RENDER) {
                    switch (pmsgPaint->nSurfaceType)
                    {
                    case GSURFACE_GPGRAPHICS:
                        {
                            GMSG_PAINTRENDERF * pmsgR = (GMSG_PAINTRENDERF *) pmsgPaint;
                            OnDraw(pmsgR->pgpgr, pmsgR);
                        }
                        break;
                    default:
                        Trace("WARNING: Unknown surface type\n");
                    }

                    return DU_S_PARTIAL;
                }
            }
            break;

        case GM_INPUT:
            {
                GMSG_INPUT * pmsgI = (GMSG_INPUT *) pmsg;
                switch (pmsgI->nDevice)
                {
                case GINPUT_KEYBOARD:
                    {
                        GMSG_KEYBOARD * pmsgK = (GMSG_KEYBOARD *) pmsgI;
                        switch (pmsgK->nCode)
                        {
                        case GKEY_DOWN:
                            {
                                //
                                // GKEY_DOWN is the raw key-press event that contains any key that
                                // is pressed.
                                //

                                WCHAR chKey = pmsgK->ch;
                                switch (chKey)
                                {
                                case VK_LEFT:
                                    if (m_idxchCaret > 0) {
                                        m_idxchCaret--;
                                        UpdateCaretPos();
                                    }
                                    break;

                                case VK_RIGHT:
                                    if (m_idxchCaret < m_cchSize) {
                                        m_idxchCaret++;
                                        UpdateCaretPos();
                                    }
                                    break;

                                case VK_BACK:
                                    DeleteChars(m_idxchCaret - 1, 1);
                                    UpdateCaretPos();
                                    break;

                                case VK_DELETE:
                                    DeleteChars(m_idxchCaret, 1);
                                    UpdateCaretPos();
                                    break;

                                case VK_HOME:
                                    m_idxchCaret = 0;
                                    UpdateCaretPos();
                                    break;

                                case VK_END:
                                    m_idxchCaret = m_cchSize;
                                    UpdateCaretPos();
                                    break;

				                case VK_RETURN:
					                InsertChar('\r\n');
					                break;
                                }
                            }
                            break;

                        case GKEY_CHAR:
                            {
                                //
                                // GKEY_CHAR is a "processed" key-press event that gets
				                // generated from other messages.  This will take into account
				                // the caps-lock state, etc., so it is useful to get
				                // characters.
                                //

                                WCHAR chKey = pmsgK->ch;
                                if (chKey >= ' ') {
					                InsertChar(chKey);
                                }
                            }
                            break;
                        }
                    }
                    break;  // GINPUT_KEYBOARD

                case GINPUT_MOUSE:
                    {
                        GMSG_MOUSE * pmsgM = (GMSG_MOUSE *) pmsg;
                        switch (pmsgM->nCode)
                        {
                        case GMOUSE_DOWN:
                        case GMOUSE_UP:
                            if (pmsgM->bButton == GBUTTON_LEFT) {
                                POINT ptOffsetPxl = pmsgM->ptClientPxl;
                                int idxchNew = ComputeMouseChar(ptOffsetPxl);
                                if (idxchNew != m_idxchCaret) {
                                    m_idxchCaret = idxchNew;
                                    UpdateCaretPos();
                                }

                                return DU_S_COMPLETE;
                            }
                        }
                    }
                    break;  // GINPUT_MOUSE
                }
            }
            break;  // GM_INPUT

        case GM_CHANGESTATE:
            {
                GMSG_CHANGESTATE * pmsgS = (GMSG_CHANGESTATE *) pmsg;
                if (pmsgS->nCode == GSTATE_KEYBOARDFOCUS) {
                    UpdateFocus(pmsgS->nCmd);
                }
            }
            break;

        case GM_QUERY:
            {
                GMSG_QUERY * pmsgQ = (GMSG_QUERY *) pmsg;
                switch (pmsgQ->nCode)
                {
                case GQUERY_DESCRIPTION:
                    {
                        GMSG_QUERYDESC * pmsgQD = (GMSG_QUERYDESC *) pmsg;
                        CopyString(pmsgQD->szName, m_szBuffer, _countof(pmsgQD->szName));
                        CopyString(pmsgQD->szType, L"SmEditLineF", _countof(pmsgQD->szType));
                        return DU_S_COMPLETE;
                    }
                }
            }
            break;
        }
    }

    return SVisual::ApiOnEvent(pmsg);
}


//------------------------------------------------------------------------------
void
SmEditLineF::UpdateFocus(UINT nCmd)
{
    m_fFocus = (nCmd == GSC_SET);

    if (m_fFocus) {
        //
        // This control is getting the focus.
        //

        //
        // Create an action that can be used to blink the edit control.  Each thread
        // needs to do this since timers are per-thread and Gadget functions need
        // to execute in the correct Context.
        //

        GMA_ACTION gma;
        ZeroMemory(&gma, sizeof(gma));
        gma.cbSize      = sizeof(gma);
        gma.cRepeat     = (UINT) -1;
        gma.flDelay     = 0.0f;
        gma.flPeriod    = GetCaretBlinkTime() / 1000.0f;
        gma.flDuration  = 0.0f;
        gma.pfnProc     = BlinkActionProc;
        gma.pvData      = this;

        m_hactBlink = CreateAction(&gma);
    } else {
        //
        // Loosing focus, so change to NULL if currently point 
        // to this Edit control.
        //

        ::DeleteHandle(m_hactBlink);
        m_hactBlink = NULL;
    }

    GetStub()->Invalidate();
}


//------------------------------------------------------------------------------
void
SmEditLineF::InsertChar(WCHAR chKey)
{
    if (m_cchSize < m_cchMax) {
        //
        // Move the text after current position down one character
        //

        int cchMove = m_cchSize - m_idxchCaret + 1;
        if (cchMove > 0) {
            MoveMemory(&m_szBuffer[m_idxchCaret + 1], &m_szBuffer[m_idxchCaret], cchMove * sizeof(WCHAR));
        }

        //
        // Insert the new character
        //

        m_szBuffer[m_idxchCaret] = chKey;

        //
        // Check if need to re-NULL-terminate
        //

        if (m_idxchCaret > m_cchSize) {
            m_szBuffer[m_idxchCaret] = '\0';
        }

        //
        // Update position
        //

        m_idxchCaret++;
        m_cchSize++;

        UpdateCaretPos();
    }
}


//------------------------------------------------------------------------------
void
SmEditLineF::DeleteChars(int idxchStart, int cchDel)
{
    if ((idxchStart >= m_cchSize) || (idxchStart < 0)) {
        // Nothing to delete
        return;
    }

    // Make sure deleting within range
    cchDel = min(cchDel, m_cchSize - idxchStart);

    int idxchDest   = idxchStart;
    int idxchSrc    = idxchStart + cchDel;
    int chMove      = m_cchSize - idxchSrc;

    MoveMemory(&m_szBuffer[idxchDest], &m_szBuffer[idxchSrc], chMove * sizeof(WCHAR));

    m_cchSize -= cchDel;

    if (m_idxchCaret > idxchStart) {
        m_idxchCaret = idxchStart;
    }
}


//------------------------------------------------------------------------------
void
SmEditLineF::OnDraw(Gdiplus::Graphics * pgpgr, GMSG_PAINTRENDERF * pmsgR)
{
    pgpgr->DrawString(m_szBuffer, m_cchSize, m_pgpfnt, *pmsgR->prcGadgetPxl, 0, m_pgpbrText);

    if (m_fFocus && m_fCaretShown) {
        Gdiplus::PointF rgpt[2];
        rgpt[0].X   = m_ptCaretPxl.X;
        rgpt[0].Y   = m_ptCaretPxl.Y + m_yCaretOffsetPxl;
        rgpt[1].X   = m_ptCaretPxl.X;
        rgpt[1].Y   = m_ptCaretPxl.Y + m_cyCaretPxl + m_yCaretOffsetPxl;

        pgpgr->DrawLine(GetStdColorPenF(SC_MidnightBlue), rgpt[0], rgpt[1]);
    }
}


//------------------------------------------------------------------------------
HRESULT
SmEditLineF::ApiGetFont(EditLineFGadget::GetFontMsg * pmsg)
{
    pmsg->pgpfnt = m_pgpfnt;

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
SmEditLineF::ApiSetFont(EditLineFGadget::SetFontMsg * pmsg)
{
    if (m_fOwnFont) {
        delete m_pgpfnt;
    }

    m_pgpfnt = pmsg->pgpfnt;
    m_fOwnFont = pmsg->fPassOwnership;
    RebuildCaret();
    UpdateCaretPos();

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
SmEditLineF::ApiGetText(EditLineFGadget::GetTextMsg * pmsg)
{
    pmsg->pszText = m_szBuffer;

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
SmEditLineF::ApiSetText(EditLineFGadget::SetTextMsg * pmsg)
{
    wcsncpy(m_szBuffer, pmsg->pszText, m_cchMax);
    m_szBuffer[m_cchMax] = '\0';
    m_cchSize   = lstrlenW(m_szBuffer);
    if (m_idxchCaret > m_cchSize) {
        m_idxchCaret = m_cchSize;
    }

    UpdateCaretPos();
    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
SmEditLineF::ApiGetTextFill(EditLineFGadget::GetTextFillMsg * pmsg)
{
    pmsg->pgpbrFill = m_pgpbrText;

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
SmEditLineF::ApiSetTextFill(EditLineFGadget::SetTextFillMsg * pmsg)
{
    m_pgpbrText = pmsg->pgpbrFill;

    return S_OK;
}


//------------------------------------------------------------------------------
void
SmEditLineF::RebuildCaret()
{
    m_cyLinePxl         = (int) (m_pgpfnt->GetSize() * 1.5f);
    m_cyCaretPxl        = m_cyLinePxl;
    m_yCaretOffsetPxl   = 0;
}


//------------------------------------------------------------------------------
void
SmEditLineF::UpdateCaretPos()
{
    Gdiplus::Graphics gpgr(GetDesktopWindow());
    Gdiplus::RectF rcBound, rcLayout;
    RECT rcThis;
    GetStub()->GetRect(SGR_CLIENT, &rcThis);
    rcLayout.X      = 0;
    rcLayout.Y      = 0;
    rcLayout.Width  = (float) rcThis.right;
    rcLayout.Height = (float) rcThis.bottom;
    gpgr.MeasureString(m_szBuffer, m_idxchCaret, m_pgpfnt, rcLayout, &rcBound);

    m_ptCaretPxl.X  = rcBound.Width;
    m_ptCaretPxl.Y  = 0;

    GetStub()->Invalidate();
}


//------------------------------------------------------------------------------
int
SmEditLineF::ComputeMouseChar(POINT ptOffsetPxl)
{
    //
    // Check boundary conditions
    //

    if (ptOffsetPxl.x < 0) {
        return 0;
    }

    SIZE sizePxl;
    GetStub()->GetSize(&sizePxl);
    if (ptOffsetPxl.x > sizePxl.cx) {
        return m_cchSize;
    }

    //
    // This implementation is very poor, but we don't care for now because this
    // is a sample control and is only for single-line.
    //

    int ichFound = 0;
    Gdiplus::Graphics gpgr(GetDesktopWindow());
    Gdiplus::RectF rcBound, rcLayout;
    rcLayout.X      = 0;
    rcLayout.Y      = 0;
    rcLayout.Width  = (float) sizePxl.cx;
    rcLayout.Height = (float) sizePxl.cy;

    for (int cch = 0; cch < m_cchSize; cch++) {
        gpgr.MeasureString(m_szBuffer, cch, m_pgpfnt, rcLayout, &rcBound);

        if (rcBound.Width > (float) ptOffsetPxl.x) {
            // We are greater, so return previous character

            AssertMsg(cch > 0, "Should have at least one character");
            ichFound = cch - 1;
            goto Cleanup;
        }
    }

Cleanup:

    return ichFound;
}


#endif // ENABLE_MSGTABLE_API
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\smhyperlink.inl ===
#if !defined(CORE__SmHyperLink_inl__INCLUDED)
#define CORE__SmHyperLink_inl__INCLUDED

#if ENABLE_MSGTABLE_API

/***************************************************************************\
*****************************************************************************
*
* class SmHyperLink
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline
SmHyperLink::SmHyperLink()
{
    m_crActive      = RGB(255, 197, 138);
    m_crNormal      = RGB(255, 255, 255);

    if (s_hcurHand == NULL) {
        s_hcurHand = LoadCursor(NULL, IDC_HAND);
    }
}


//------------------------------------------------------------------------------
inline HRESULT
SmHyperLink::PostBuild(DUser::Gadget::ConstructInfo * pci)
{
    UNREFERENCED_PARAMETER(pci);

    GetStub()->SetFilter(  GMFI_PAINT | GMFI_INPUTMOUSE | GMFI_CHANGESTATE, GMFI_ALL);
    GetStub()->SetStyle(   GS_MOUSEFOCUS,
                    GS_MOUSEFOCUS);

    return S_OK;
}

#endif // ENABLE_MSGTABLE_API

#endif // CORE__SmHyperLink_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\smimage.inl ===
#if !defined(CTRL__SmImage_inl__INCLUDED)
#define CTRL__SmImage_inl__INCLUDED

#if ENABLE_MSGTABLE_API

/***************************************************************************\
*****************************************************************************
*
* class SmImage
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline 
SmImage::SmImage()
{
    m_nMode             = ImageGadget::imNormal;
    m_fOwnImage         = TRUE;
    m_bAlpha            = BLEND_OPAQUE;
}


//------------------------------------------------------------------------------
inline HRESULT
SmImage::PostBuild(DUser::Gadget::ConstructInfo * pci)
{
    UNREFERENCED_PARAMETER(pci);

    GetStub()->SetFilter(GMFI_PAINT, GMFI_ALL);

    return S_OK;
}

#endif // ENABLE_MSGTABLE_API

#endif // CTRL__SmImage_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\smimage.h ===
#if !defined(CTRL__SmImage_h__INCLUDED)
#define CTRL__SmImage_h__INCLUDED
#pragma once

#if ENABLE_MSGTABLE_API

//------------------------------------------------------------------------------
class SmImage : public ImageGadgetImpl<SmImage, SVisual>
{
// Construction
public:
    inline  SmImage();
            ~SmImage();
    inline  HRESULT     PostBuild(DUser::Gadget::ConstructInfo * pci);

// Public API
public:
    dapi    HRESULT     ApiOnEvent(EventMsg * pmsg);
    dapi    HRESULT     ApiGetImage(ImageGadget::GetImageMsg * pmsg);
    dapi    HRESULT     ApiSetImage(ImageGadget::SetImageMsg * pmsg);
    dapi    HRESULT     ApiGetOptions(ImageGadget::GetOptionsMsg * pmsg);
    dapi    HRESULT     ApiSetOptions(ImageGadget::SetOptionsMsg * pmsg);
    dapi    HRESULT     ApiGetTransparentColor(ImageGadget::GetTransparentColorMsg * pmsg);
    dapi    HRESULT     ApiSetTransparentColor(ImageGadget::SetTransparentColorMsg * pmsg);
    dapi    HRESULT     ApiGetCrop(ImageGadget::GetCropMsg * pmsg);
    dapi    HRESULT     ApiSetCrop(ImageGadget::SetCropMsg * pmsg);
    dapi    HRESULT     ApiGetMode(ImageGadget::GetModeMsg * pmsg);
    dapi    HRESULT     ApiSetMode(ImageGadget::SetModeMsg * pmsg);
    dapi    HRESULT     ApiGetAlphaLevel(ImageGadget::GetAlphaLevelMsg * pmsg);
    dapi    HRESULT     ApiSetAlphaLevel(ImageGadget::SetAlphaLevelMsg * pmsg);

// Implementation
protected:
            void        OnDraw(HDC hdc, GMSG_PAINTRENDERI * pmsgR);
            void        DeleteImage();
            BOOL        AlphaBlt(HDC hdcDest, int xDest, int yDest, int wDest, int hDest, 
                                HDC hdcSrc, int xSrc, int ySrc, int wSrc, int hSrc) const;
            void        SetCrop(int x, int y, int w, int h);

// Data
protected:
            HBITMAP     m_hbmp;
            COLORREF    m_crTransparent;
            SIZE        m_sizeBmpPxl;
            POINT       m_ptOffsetPxl;
            SIZE        m_sizeCropPxl;
            UINT        m_nMode:24;
            UINT        m_bAlpha:8;

    union
    {
        UINT        m_nOptions;
        struct {
            // Public Options
            BOOL    m_fTransparent:1;   // Support transparent color-key
            BOOL    m_fPixelAlpha:1;    // Support per-pixel alpha
            BOOL    m_fAutoTransparent:1;   // Automatically determine transparent color

            // Private Options
            BOOL    m_fOwnImage:1;      // SmImage owns the handle on the image
        };
    };
};

#endif // ENABLE_MSGTABLE_API

#include "SmImage.inl"

#endif // CTRL__SmImage_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\smimage.cpp ===
#include "stdafx.h"
#include "Ctrl.h"
#include "SmImage.h"

#include "GdiHelp.h"

#if ENABLE_MSGTABLE_API

/***************************************************************************\
*****************************************************************************
*
* class SmImage
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
SmImage::~SmImage()
{
    DeleteImage();
}


//------------------------------------------------------------------------------
HRESULT
SmImage::ApiOnEvent(EventMsg * pmsg)
{
    if (GET_EVENT_DEST(pmsg) == GMF_DIRECT) {
        switch (pmsg->nMsg)
        {
        case GM_PAINT:
            {
                GMSG_PAINT * pmsgPaint = (GMSG_PAINT *) pmsg;
                if (pmsgPaint->nCmd == GPAINT_RENDER) {
                    switch (pmsgPaint->nSurfaceType)
                    {
                    case GSURFACE_HDC:
                        {
                            GMSG_PAINTRENDERI * pmsgR = (GMSG_PAINTRENDERI *) pmsgPaint;
                            OnDraw(pmsgR->hdc, pmsgR);
                        }
                        break;
                    }

                    return DU_S_PARTIAL;
                }
            }
            break;

        case GM_QUERY:
            {
                GMSG_QUERY * pmsgQ = (GMSG_QUERY *) pmsg;
                switch (pmsgQ->nCode)
                {
                case GQUERY_DESCRIPTION:
                    {
                        GMSG_QUERYDESC * pmsgQD = (GMSG_QUERYDESC *) pmsg;
                        CopyString(pmsgQD->szType, L"SmImage", _countof(pmsgQD->szType));
                        return DU_S_COMPLETE;
                    }
                }
            }
            break;
        }
    }

    return SVisual::ApiOnEvent(pmsg);
}


#define AC_SRC_ALPHA                0x01

//------------------------------------------------------------------------------
BOOL
SmImage::AlphaBlt(HDC hdcDest, int xDest, int yDest, int wDest, int hDest, 
        HDC hdcSrc, int xSrc, int ySrc, int wSrc, int hSrc) const
{
    BLENDFUNCTION bf;
    bf.BlendOp              = AC_SRC_OVER;
    bf.BlendFlags           = 0;
    bf.SourceConstantAlpha  = m_bAlpha;
    bf.AlphaFormat          = (BYTE) (m_fPixelAlpha ? AC_SRC_ALPHA : 0);

    return AlphaBlend(hdcDest, xDest, yDest, wDest, hDest, hdcSrc, xSrc, ySrc, wSrc, hSrc, bf);
}


//------------------------------------------------------------------------------
void        
SmImage::OnDraw(HDC hdc, GMSG_PAINTRENDERI * pmsgR)
{
    if (m_bAlpha == BLEND_TRANSPARENT) {
        // Completely transparent, so don't draw anything.
        return;
    }

#if 1
    // TEMPORARY HACK B/C OF WIN9X GDI LEAKS in TRANSPARENTBLT
    if (!SupportXForm()) {
        m_fTransparent = FALSE;
    }
#endif

    if (m_hbmp != NULL) {
        POINT ptShift;
        ptShift.x   = pmsgR->prcGadgetPxl->left;
        ptShift.y   = pmsgR->prcGadgetPxl->top;

        POINT ptBrushOrg;
        GetBrushOrgEx(hdc, &ptBrushOrg);
        int nOldMode    = SetStretchBltMode(hdc, HALFTONE);
        SetBrushOrgEx(hdc, ptBrushOrg.x, ptBrushOrg.y, NULL);

        SIZE sizeGadget, sizeDest;
        sizeGadget.cx = pmsgR->prcGadgetPxl->right - pmsgR->prcGadgetPxl->left;
        sizeGadget.cy = pmsgR->prcGadgetPxl->bottom - pmsgR->prcGadgetPxl->top;

        HDC hdcMem = NULL;
        HBITMAP hbmpOld = NULL;

        hdcMem  = GetGdiCache()->GetCompatibleDC();
        hbmpOld = (HBITMAP) SelectObject(hdcMem, m_hbmp);

        if (m_nMode == ImageGadget::imStretchMaxAspect) {
            //
            // TODO: Implement this properly
            //

            float fAspectX  = (float) sizeGadget.cx / (float) m_sizeCropPxl.cx;
            float fAspectY  = (float) sizeGadget.cy / (float) m_sizeCropPxl.cy;

            SIZE sizeSrc;
            if (fAspectX >= fAspectY) {
                sizeSrc.cx  = m_sizeCropPxl.cx;
                sizeSrc.cy  = (int) (m_sizeCropPxl.cy / fAspectX * fAspectY);
            } else {
                sizeSrc.cx  = (int) (m_sizeCropPxl.cx / fAspectY * fAspectX);
                sizeSrc.cy  = m_sizeCropPxl.cy;
            }

            if (m_bAlpha == BLEND_OPAQUE) {
                StretchBlt(hdc, ptShift.x, ptShift.y, sizeGadget.cx, sizeGadget.cy,
                        hdcMem, m_ptOffsetPxl.x, m_ptOffsetPxl.y, sizeSrc.cx, sizeSrc.cy, SRCCOPY);
            } else {
                AlphaBlt(hdc, ptShift.x, ptShift.y, sizeGadget.cx, sizeGadget.cy,
                        hdcMem, m_ptOffsetPxl.x, m_ptOffsetPxl.y, sizeSrc.cx, sizeSrc.cy);
            }
        } else {
            SIZE sizeTile;
            sizeTile.cx     = min(sizeGadget.cx, m_sizeCropPxl.cx);
            sizeTile.cy     = min(sizeGadget.cy, m_sizeCropPxl.cy);

            if (m_nMode == ImageGadget::imTiled) {
                sizeDest.cx = sizeGadget.cx;
                sizeDest.cy = sizeGadget.cy;
            } else {
                sizeDest = sizeTile;
            }

            for (int y = ptShift.y; y < ptShift.y + sizeDest.cy; y += sizeTile.cy) {
                for (int x = ptShift.x; x < ptShift.x + sizeDest.cx; x += sizeTile.cx) {
                    if (!m_fTransparent) {
                        if (m_bAlpha == BLEND_OPAQUE) {
                            BitBlt(hdc, x, y, sizeTile.cx, sizeTile.cy, 
                                    hdcMem, m_ptOffsetPxl.x, m_ptOffsetPxl.y, SRCCOPY);
                        } else {
                            AlphaBlt(hdc, x, y, sizeTile.cx, sizeTile.cy, 
                                    hdcMem, m_ptOffsetPxl.x, m_ptOffsetPxl.y, sizeTile.cx, sizeTile.cy);
                        }
                    } else {
                        //
                        // TODO: Determine if need to check the number of colors and call 
                        // AlphaBlend() if hicolor
                        //

                        if (m_bAlpha == BLEND_OPAQUE) {
                            TransparentBlt(hdc, x, y, sizeTile.cx, sizeTile.cy, 
                                    hdcMem, m_ptOffsetPxl.x, m_ptOffsetPxl.y, sizeTile.cx, sizeTile.cy, m_crTransparent);
                        } else {
                            AlphaBlt(hdc, x, y, sizeTile.cx, sizeTile.cy, 
                                    hdcMem, m_ptOffsetPxl.x, m_ptOffsetPxl.y, sizeTile.cx, sizeTile.cy);
                        }
                    }
                }
            }
        }

        SelectObject(hdcMem, hbmpOld);
        GetGdiCache()->ReleaseCompatibleDC(hdcMem);

        SetStretchBltMode(hdc, nOldMode);
    }
}


//------------------------------------------------------------------------------
HRESULT
SmImage::ApiGetImage(ImageGadget::GetImageMsg * pmsg)
{
    pmsg->hbmp = m_hbmp;

    return S_OK;    
}


//------------------------------------------------------------------------------
HRESULT
SmImage::ApiSetImage(ImageGadget::SetImageMsg * pmsg)
{
    DeleteImage();
    m_hbmp      = pmsg->hbmp;
    m_fOwnImage = pmsg->fPassOwnership;

    //
    // First, try as a DIB, then as a BITMAP.  Since the first part of a 
    // DIBSECTION is a BITMAP, we can use m_bmpInfo when we load m_dsInfo.  How
    // convenient!
    //

    BITMAP bmpInfo;
    GetObject(m_hbmp, sizeof(bmpInfo), &bmpInfo);

    m_sizeBmpPxl.cx     = bmpInfo.bmWidth;
    m_sizeBmpPxl.cy     = bmpInfo.bmHeight;
    m_ptOffsetPxl.x     = 0;
    m_ptOffsetPxl.y     = 0;
    m_sizeCropPxl.cx    = bmpInfo.bmWidth;
    m_sizeCropPxl.cy    = bmpInfo.bmHeight;

    GetStub()->Invalidate();

    return S_OK;    
}


//------------------------------------------------------------------------------
HRESULT
SmImage::ApiGetTransparentColor(ImageGadget::GetTransparentColorMsg * pmsg)
{
    pmsg->crTransparent = m_crTransparent;

    return S_OK;    
}


//------------------------------------------------------------------------------
HRESULT
SmImage::ApiSetTransparentColor(ImageGadget::SetTransparentColorMsg * pmsg)
{
    m_fTransparent  = TRUE;
    m_crTransparent = pmsg->crTransparent;

    return S_OK;    
}


//------------------------------------------------------------------------------
HRESULT
SmImage::ApiGetCrop(ImageGadget::GetCropMsg * pmsg)
{
    pmsg->ptOffsetPxl   = m_ptOffsetPxl;
    pmsg->sizeCropPxl   = m_sizeCropPxl;

    return S_OK;    
}


//------------------------------------------------------------------------------
HRESULT
SmImage::ApiSetCrop(ImageGadget::SetCropMsg * pmsg)
{
    //
    // The offset can be set just fine.  However, the size needs to be capped
    // inside the bitmap.  If it overflows, calls to TransparentBlt() will fail.
    //

    m_ptOffsetPxl       = pmsg->ptOffsetPxl;
    m_sizeCropPxl.cx    = max(min(pmsg->sizeCropPxl.cx, m_sizeBmpPxl.cx - pmsg->ptOffsetPxl.x), 0);
    m_sizeCropPxl.cy    = max(min(pmsg->sizeCropPxl.cy, m_sizeBmpPxl.cy - pmsg->ptOffsetPxl.y), 0);

    return S_OK;    
}


//------------------------------------------------------------------------------
HRESULT
SmImage::ApiGetMode(ImageGadget::GetModeMsg * pmsg)
{
    pmsg->nMode = m_nMode;

    return S_OK;    
}


//------------------------------------------------------------------------------
HRESULT
SmImage::ApiSetMode(ImageGadget::SetModeMsg * pmsg)
{
    if (pmsg->nNewMode <= ImageGadget::imMax) {
        m_nMode = pmsg->nNewMode;
        GetStub()->Invalidate();
        return S_OK;
    }

    return E_INVALIDARG;
}


//------------------------------------------------------------------------------
HRESULT
SmImage::ApiGetOptions(ImageGadget::GetOptionsMsg * pmsg)
{
    pmsg->nOptions = m_nOptions & ImageGadget::ioValid;

    return S_OK;    
}


//------------------------------------------------------------------------------
HRESULT
SmImage::ApiSetOptions(ImageGadget::SetOptionsMsg * pmsg)
{
    ChangeFlag(m_nOptions, pmsg->nOptions & ImageGadget::ioValid, pmsg->nMask);
    if (m_fTransparent && (m_hbmp != NULL) && m_fAutoTransparent) {
        //
        // Determine an initial transparent color by getting the color of the
        // upper left pixel.
        //

        GdGetColor(m_hbmp, NULL);
    }

    GetStub()->Invalidate();

    return S_OK;    
}


//------------------------------------------------------------------------------
HRESULT
SmImage::ApiGetAlphaLevel(ImageGadget::GetAlphaLevelMsg * pmsg)
{
    pmsg->bAlpha = m_bAlpha;

    return S_OK;    
}


//------------------------------------------------------------------------------
HRESULT
SmImage::ApiSetAlphaLevel(ImageGadget::SetAlphaLevelMsg * pmsg)
{
    m_bAlpha = pmsg->bAlpha;
    GetStub()->Invalidate();

    return S_OK;    
}


//------------------------------------------------------------------------------
void 
SmImage::DeleteImage()
{
    if (m_fOwnImage && (m_hbmp != NULL)) {
        DeleteObject(m_hbmp);
    }

    m_hbmp          = NULL;
    m_fOwnImage     = TRUE;
    m_fTransparent  = FALSE;
    m_crTransparent = RGB(0, 0, 0);
}

#endif // ENABLE_MSGTABLE_API
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\smtext.inl ===
#if !defined(CTRL__SmText_inl__INCLUDED)
#define CTRL__SmText_inl__INCLUDED

#if ENABLE_MSGTABLE_API

/***************************************************************************\
*****************************************************************************
*
* class SmText
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline
SmText::SmText()
{
    m_crText    = RGB(0, 0, 128);
}


//------------------------------------------------------------------------------
inline HRESULT
SmText::PostBuild(DUser::Gadget::ConstructInfo * pci)
{
    UNREFERENCED_PARAMETER(pci);

    GetStub()->SetFilter(GMFI_PAINT, GMFI_ALL);

    return S_OK;
}

#endif // ENABLE_MSGTABLE_API

#endif // CTRL__SmText_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\smtext.cpp ===
#include "stdafx.h"
#include "Ctrl.h"
#include "SmText.h"

#if ENABLE_MSGTABLE_API

/***************************************************************************\
*****************************************************************************
*
* class SmText
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
SmText::~SmText()
{
    EmptyText();
}


//------------------------------------------------------------------------------
HRESULT
SmText::ApiOnEvent(EventMsg * pmsg)
{
    if (GET_EVENT_DEST(pmsg) == GMF_DIRECT) {
        switch (pmsg->nMsg)
        {
        case GM_PAINT:
            {
                GMSG_PAINT * pmsgPaint = (GMSG_PAINT *) pmsg;
                if (pmsgPaint->nCmd == GPAINT_RENDER) {
                    switch (pmsgPaint->nSurfaceType)
                    {
                    case GSURFACE_HDC:
                        {
                            GMSG_PAINTRENDERI * pmsgR = (GMSG_PAINTRENDERI *) pmsgPaint;
                            OnDraw(pmsgR->hdc, pmsgR);
                        }
                        break;

                    case GSURFACE_GPGRAPHICS:
                        {
                            GMSG_PAINTRENDERF * pmsgR = (GMSG_PAINTRENDERF *) pmsgPaint;
                            OnDraw(pmsgR->pgpgr, pmsgR);
                        }
                        break;
                    default:
                        Trace("WARNING: Unknown surface type\n");
                    }

                    return DU_S_PARTIAL;
                }
            }
            break;
        case GM_QUERY:
            {
                GMSG_QUERY * pmsgQ = (GMSG_QUERY *) pmsg;
                switch (pmsgQ->nCode)
                {
                case GQUERY_RECT:
                    QueryRect((GMSG_QUERYRECT *) pmsg);
                    return DU_S_COMPLETE;

                case GQUERY_DESCRIPTION:
                    {
                        GMSG_QUERYDESC * pmsgQD = (GMSG_QUERYDESC *) pmsg;
                        CopyString(pmsgQD->szName, m_pszText, _countof(pmsgQD->szName));
                        CopyString(pmsgQD->szType, L"SmText", _countof(pmsgQD->szType));
                        return DU_S_COMPLETE;
                    }
                }
            }
            break;
        }
    }

    return SVisual::ApiOnEvent(pmsg);
}


//------------------------------------------------------------------------------
void        
SmText::OnDraw(HDC hdc, GMSG_PAINTRENDERI * pmsgR)
{
    if ((m_pszText == NULL) || (m_hfnt == NULL)) {
        return;
    }

    HFONT hfntOld   = (HFONT) SelectObject(hdc, m_hfnt);
    COLORREF crOld  = SetTextColor(hdc, m_crText);
    int nOldMode    = SetBkMode(hdc, TRANSPARENT);

    OS()->TextOut(hdc, pmsgR->prcGadgetPxl->left, pmsgR->prcGadgetPxl->top, m_pszText, m_cch);

    SetBkMode(hdc, nOldMode);
    SetTextColor(hdc, crOld);
    SelectObject(hdc, hfntOld);
}


//------------------------------------------------------------------------------
void        
SmText::OnDraw(Gdiplus::Graphics * pgpgr, GMSG_PAINTRENDERF * pmsgR)
{
    if (m_pszText == NULL) {
        return;
    }

    Gdiplus::Color cr(GetRValue(m_crText), GetGValue(m_crText), GetBValue(m_crText));
    Gdiplus::SolidBrush br(cr);
    Gdiplus::Font fnt(L"Tahoma", 12.0f, Gdiplus::FontStyleRegular, Gdiplus::UnitPoint);

    pgpgr->DrawString(m_pszText, m_cch, &fnt, *pmsgR->prcGadgetPxl, 0, &br);
}


//------------------------------------------------------------------------------
HRESULT
SmText::ApiGetFont(TextGadget::GetFontMsg * pmsg)
{
    pmsg->hfnt = m_hfnt;

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
SmText::ApiSetFont(TextGadget::SetFontMsg * pmsg)
{
    m_hfnt = pmsg->hfnt;
    AutoSize();

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
SmText::ApiGetText(TextGadget::GetTextMsg * pmsg)
{
    pmsg->pszText = m_pszText;

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
SmText::ApiSetText(TextGadget::SetTextMsg * pmsg)
{
    EmptyText();

    int cch     = lstrlenW(pmsg->pszText);
    int cbAlloc = (cch + 1) * sizeof(WCHAR);
    m_pszText   = (WCHAR *) ClientAlloc(cbAlloc);
    if (m_pszText == NULL) {
        return E_OUTOFMEMORY;
    }

    CopyMemory(m_pszText, pmsg->pszText, cbAlloc);
    m_cch = cch;

    AutoSize();

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
SmText::ApiGetColor(TextGadget::GetColorMsg * pmsg)
{
    pmsg->crText = m_crText;

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
SmText::ApiSetColor(TextGadget::SetColorMsg * pmsg)
{
    m_crText = pmsg->crText;

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
SmText::ApiGetAutoSize(TextGadget::GetAutoSizeMsg * pmsg)
{
    pmsg->fAutoSize = m_fAutoSize;

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
SmText::ApiSetAutoSize(TextGadget::SetAutoSizeMsg * pmsg)
{
    m_fAutoSize = pmsg->fAutoSize;
    AutoSize();

    return S_OK;
}


//------------------------------------------------------------------------------
void
SmText::QueryRect(GMSG_QUERYRECT * pmsg)
{
    ComputeIdealSize(pmsg->sizeBound, pmsg->sizeResult);
}


//------------------------------------------------------------------------------
void        
SmText::EmptyText()
{
    if (m_pszText != NULL) {
        ClientFree(m_pszText);
        m_pszText = NULL;
    }

    m_cch = 0;
}


//------------------------------------------------------------------------------
void
SmText::ComputeIdealSize(const SIZE & sizeBoundPxl, SIZE & sizeResultPxl)
{
    if ((m_pszText != NULL) && (sizeBoundPxl.cx != 0) && (sizeBoundPxl.cy != 0)) {
        HDC hdc = GetGdiCache()->GetTempDC();

        HFONT hfntOld = NULL;
        if (m_hfnt != NULL) {
            hfntOld = (HFONT) SelectObject(hdc, m_hfnt);
        }

        OS()->GetTextExtentPoint32(hdc, m_pszText, m_cch, &sizeResultPxl);
        sizeResultPxl.cx    = min(sizeResultPxl.cx, sizeBoundPxl.cx);
        sizeResultPxl.cy    = min(sizeResultPxl.cy, sizeBoundPxl.cy);

        if (m_hfnt != NULL) {
            SelectObject(hdc, hfntOld);
        }

        GetGdiCache()->ReleaseTempDC(hdc);
    } else {
        sizeResultPxl.cx = 0;
        sizeResultPxl.cy = 0;
    }
}


//------------------------------------------------------------------------------
void
SmText::AutoSize()
{
    if (m_fAutoSize) {
        SIZE sizeBoundPxl, sizeResultPxl;

        GetStub()->GetSize(&sizeBoundPxl);
        ComputeIdealSize(sizeBoundPxl, sizeResultPxl);
        RECT rc = { 0, 0, sizeResultPxl.cx, sizeResultPxl.cy };
        GetStub()->SetRect(SGR_SIZE, &rc);
    }
}

#endif // ENABLE_MSGTABLE_API
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\smvector.cpp ===
#include "stdafx.h"
#include "Ctrl.h"
#include "SmVector.h"

#if ENABLE_MSGTABLE_API

//**************************************************************************************************
//
// class SmVector
//
//**************************************************************************************************

//------------------------------------------------------------------------------
SmVector::SmVector()
{
    m_sizeBounds.cx     = 0;
    m_sizeBounds.cy     = 0;
    m_ptOffsetPxl.x     = 0;
    m_ptOffsetPxl.y     = 0;
    m_sizeCropPxl.cx    = 0;
    m_sizeCropPxl.cy    = 0;
    m_nMode             = VectorGadget::vmNormal;
    m_fOwnImage         = TRUE;
}


//------------------------------------------------------------------------------
SmVector::~SmVector()
{
    DeleteImage();
}


//------------------------------------------------------------------------------
HRESULT
SmVector::PostBuild(DUser::Gadget::ConstructInfo * pci)
{
    UNREFERENCED_PARAMETER(pci);

    GetStub()->SetFilter(GMFI_PAINT, GMFI_ALL);

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
SmVector::ApiOnEvent(EventMsg * pmsg)
{
     if (GET_EVENT_DEST(pmsg) == GMF_DIRECT) {
        switch (pmsg->nMsg)
        {
        case GM_PAINT:
            {
                GMSG_PAINT * pmsgPaint = (GMSG_PAINT *) pmsg;
                if (pmsgPaint->nCmd == GPAINT_RENDER) {
                    switch (pmsgPaint->nSurfaceType)
                    {
                    case GSURFACE_HDC:
                        {
                            GMSG_PAINTRENDERI * pmsgR = (GMSG_PAINTRENDERI *) pmsgPaint;
                            OnDraw(pmsgR->hdc, pmsgR);
                        }
                        break;
                    }

                    return DU_S_PARTIAL;
                }
            }
            break;

        case GM_QUERY:
            {
                GMSG_QUERY * pmsgQ = (GMSG_QUERY *) pmsg;
                switch (pmsgQ->nCode)
                {
                case GQUERY_DESCRIPTION:
                    {
                        GMSG_QUERYDESC * pmsgQD = (GMSG_QUERYDESC *) pmsg;
                        CopyString(pmsgQD->szType, L"SmVector", _countof(pmsgQD->szType));
                        return DU_S_COMPLETE;
                    }
                }
            }
            break;
        }
    }

    return SVisual::ApiOnEvent(pmsg);
}


//------------------------------------------------------------------------------
void        
SmVector::OnDraw(HDC hdc, GMSG_PAINTRENDERI * pmsgR)
{
    if (m_hemf != NULL) {
        // TODO: Need to stretch to fill ppi

        POINT ptShift;
        ptShift.x       = pmsgR->prcGadgetPxl->left;
        ptShift.y       = pmsgR->prcGadgetPxl->top;

        RECT rcDraw;
        rcDraw.left     = ptShift.x;
        rcDraw.top      = ptShift.y;
        rcDraw.right    = m_sizeBounds.cx + ptShift.x;
        rcDraw.bottom   = m_sizeBounds.cy + ptShift.y;

        PlayEnhMetaFile(hdc, m_hemf, &rcDraw);
    }
}


//------------------------------------------------------------------------------
HRESULT
SmVector::ApiGetImage(VectorGadget::GetImageMsg * pmsg)
{
    pmsg->hemf = m_hemf;

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
SmVector::ApiSetImage(VectorGadget::SetImageMsg * pmsg)
{
    DeleteImage();
    m_hemf      = pmsg->hemf;
    m_fOwnImage = pmsg->fPassOwnership;

    ENHMETAHEADER hdr;
    if (GetEnhMetaFileHeader(m_hemf, sizeof(hdr), &hdr) > 0) {
        m_sizeBounds.cx = hdr.rclBounds.right - hdr.rclBounds.left;
        m_sizeBounds.cy = hdr.rclBounds.bottom - hdr.rclBounds.top;
    }

    m_ptOffsetPxl.x     = 0;
    m_ptOffsetPxl.y     = 0;
    m_sizeCropPxl.cx    = m_sizeBounds.cx;
    m_sizeCropPxl.cy    = m_sizeBounds.cy;

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
SmVector::ApiGetCrop(VectorGadget::GetCropMsg * pmsg)
{
    pmsg->ptOffsetPxl   = m_ptOffsetPxl;
    pmsg->sizeCropPxl   = m_sizeCropPxl;

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
SmVector::ApiSetCrop(VectorGadget::SetCropMsg * pmsg)
{
    //
    // The offset can be set just fine.  However, the size needs to be capped
    // inside the bitmap.  If it overflows, calls to TransparentBlt() will fail.
    //

    m_ptOffsetPxl       = pmsg->ptOffsetPxl;
    m_sizeCropPxl.cx    = max(min(pmsg->sizeCropPxl.cx, m_sizeBounds.cx - pmsg->ptOffsetPxl.x), 0);
    m_sizeCropPxl.cy    = max(min(pmsg->sizeCropPxl.cy, m_sizeBounds.cy - pmsg->ptOffsetPxl.y), 0);

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
SmVector::ApiGetMode(VectorGadget::GetModeMsg * pmsg)
{
    pmsg->nMode = m_nMode;

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
SmVector::ApiSetMode(VectorGadget::SetModeMsg * pmsg)
{
    if (pmsg->nNewMode <= VectorGadget::vmMax) {
        m_nMode = pmsg->nNewMode;
        GetStub()->Invalidate();
        return S_OK;
    }

    return E_INVALIDARG;
}


//------------------------------------------------------------------------------
void 
SmVector::DeleteImage()
{
    if (m_fOwnImage && (m_hemf != NULL)) {
        DeleteObject(m_hemf);
    }

    m_hemf          = NULL;
    m_fOwnImage     = TRUE;
}

#endif // ENABLE_MSGTABLE_API
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\smtext.h ===
#if !defined(CTRL__SmText_h__INCLUDED)
#define CTRL__SmText_h__INCLUDED
#pragma once

#if ENABLE_MSGTABLE_API

//------------------------------------------------------------------------------
class SmText : 
        public TextGadgetImpl<SmText, SVisual>
{
// Construction
public:
    inline  SmText();
            ~SmText();
    inline  HRESULT     PostBuild(DUser::Gadget::ConstructInfo * pci);


// Operations
public:
            void        OnDraw(HDC hdc, GMSG_PAINTRENDERI * pmsgR);
            void        OnDraw(Gdiplus::Graphics * pgpgr, GMSG_PAINTRENDERF * pmsgR);

// Public API
public:
    dapi    HRESULT     ApiOnEvent(EventMsg * pmsg);
    dapi    HRESULT     ApiGetFont(TextGadget::GetFontMsg * pmsg);
    dapi    HRESULT     ApiSetFont(TextGadget::SetFontMsg * pmsg);
    dapi    HRESULT     ApiGetText(TextGadget::GetTextMsg * pmsg);
    dapi    HRESULT     ApiSetText(TextGadget::SetTextMsg * pmsg);
    dapi    HRESULT     ApiGetColor(TextGadget::GetColorMsg * pmsg);
    dapi    HRESULT     ApiSetColor(TextGadget::SetColorMsg * pmsg);
    dapi    HRESULT     ApiGetAutoSize(TextGadget::GetAutoSizeMsg * pmsg);
    dapi    HRESULT     ApiSetAutoSize(TextGadget::SetAutoSizeMsg * pmsg);

// Implementation
protected:
            void        QueryRect(GMSG_QUERYRECT * pmsg);
            void        EmptyText();
            void        AutoSize();
            void        ComputeIdealSize(const SIZE & sizeBoundPxl, SIZE & sizeResultPxl);

// Data
protected:
    HFONT       m_hfnt;
    COLORREF    m_crText;
    WCHAR *     m_pszText;
    int         m_cch:31;
    BOOL        m_fAutoSize:1;
};

#endif // ENABLE_MSGTABLE_API

#include "SmText.inl"

#endif // CTRL__SmText_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	Ctrl.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\smvector.h ===
#if !defined(CTRL__SmVector_h__INCLUDED)
#define CTRL__SmVector_h__INCLUDED
#pragma once

#if ENABLE_MSGTABLE_API

//------------------------------------------------------------------------------
class SmVector : 
        public VectorGadgetImpl<SmVector, SVisual>
{
// Construction
public:
            SmVector();
            ~SmVector();
            HRESULT     PostBuild(DUser::Gadget::ConstructInfo * pci);

// Operations
public:
    virtual void        OnDraw(HDC hdc, GMSG_PAINTRENDERI * pmsgR);

// Public API
public:
    dapi    HRESULT     ApiOnEvent(EventMsg * pmsg);
    dapi    HRESULT     ApiGetImage(VectorGadget::GetImageMsg * pmsg);
    dapi    HRESULT     ApiSetImage(VectorGadget::SetImageMsg * pmsg);
    dapi    HRESULT     ApiGetCrop(VectorGadget::GetCropMsg * pmsg);
    dapi    HRESULT     ApiSetCrop(VectorGadget::SetCropMsg * pmsg);
    dapi    HRESULT     ApiGetMode(VectorGadget::GetModeMsg * pmsg);
    dapi    HRESULT     ApiSetMode(VectorGadget::SetModeMsg * pmsg);

            void        SetCrop(int x, int y, int w, int h);

// Implementation
protected:
            void        DeleteImage();

// Data
protected:
    HENHMETAFILE m_hemf;
    SIZE        m_sizeBounds;
    POINT       m_ptOffsetPxl;
    SIZE        m_sizeCropPxl;
    UINT        m_nMode;
    BOOL        m_fOwnImage:1;
};

#endif // ENABLE_MSGTABLE_API

#endif // CTRL__SmVector_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\ctrl\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(CTRL__StdAfx_h__INCLUDED)
#define CTRL__StdAfx_h__INCLUDED

#pragma once

#include "CommonStdAfx.h"

#endif // CTRL__StdAfx_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\duser\duser.cpp ===
// DUser.cpp : Defines the entry point for the DLL application.
//

#include "stdafx.h"
#include "_DUser.h"

#pragma comment(lib, "GdiPlus")

//
// Downlevel delay load support (need to link to dload.lib)
//
#include <delayimp.h>

EXTERN_C
FARPROC
WINAPI
Downlevel_DelayLoadFailureHook(
    UINT            unReason,
    PDelayLoadInfo  pDelayInfo
    );

PfnDliHook __pfnDliFailureHook = Downlevel_DelayLoadFailureHook;

extern "C" 
{
HANDLE BaseDllHandle;
}


extern "C" BOOL WINAPI DllMain(HINSTANCE hModule, DWORD  dwReason, LPVOID lpReserved);
extern "C" BOOL WINAPI RawDllMain(HINSTANCE hModule, DWORD  dwReason, LPVOID lpReserved);

extern "C" BOOL (WINAPI* _pRawDllMain)(HINSTANCE, DWORD, LPVOID) = &RawDllMain;


/***************************************************************************\
*
* DllMain
*
* DllMain() is called after the CRT has fully ininitialized.
*
\***************************************************************************/

extern "C"
BOOL WINAPI
DllMain(HINSTANCE hModule, DWORD  dwReason, LPVOID lpReserved)
{
    UNREFERENCED_PARAMETER(hModule);
    UNREFERENCED_PARAMETER(lpReserved);
    
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        BaseDllHandle = hModule;   // for delayload

        //
        // At this point, all global objects have been fully constructed.
        //

        if (FAILED(ResourceManager::Create())) {
            return FALSE;
        }

        if (FAILED(InitCore()) ||
            FAILED(InitCtrl())) {

            return FALSE;
        }

        {
            InitStub is;
        }

        break;
        
    case DLL_PROCESS_DETACH:
        //
        // At this point, no global objects have been destructed.
        //

        ResourceManager::xwDestroy();
        break;

    case DLL_THREAD_ATTACH:
        break;

    case DLL_THREAD_DETACH:
        //
        // NOTE: We can NOT call ResourceManager::xwNotifyThreadDestroyNL() to
        // post clean-up, since we are now in the "Loader Lock" and can not 
        // safely perform the cleanup because of deadlocks.
        //
        
        break;
    }

    return TRUE;
}


/***************************************************************************\
*
* RawDllMain
*
* RawDllMain() is called after the before CRT has fully ininitialized.
*
\***************************************************************************/

extern "C"
BOOL WINAPI
RawDllMain(HINSTANCE hModule, DWORD  dwReason, LPVOID lpReserved)
{
    UNREFERENCED_PARAMETER(hModule);
    UNREFERENCED_PARAMETER(lpReserved);
    
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        //
        // At this point, no global objects have been constructed.
        //

        g_hDll = (HINSTANCE) hModule;

        if (FAILED(CreateProcessHeap())) {
            return FALSE;
        }

        break;
        
    case DLL_PROCESS_DETACH:
        //
        // At this point, all global objects have been destructed.
        //

        DestroyProcessHeap();


        //
        // Dump any CRT memory leaks here.  When using a shared CRT DLL, we only
        // want to dump memory leaks when everything has had a chance to clean 
        // up.  We do this in a common place in AutoUtil.
        //
        // When using private static-linked CRT, GREEN_STATIC_CRT will be 
        // defined, allowing each individual module to dump their own memory 
        // leaks.
        //

#if DBG
        _CrtDumpMemoryLeaks();
#endif // DBG
        break;

    case DLL_THREAD_ATTACH:
        break;

    case DLL_THREAD_DETACH:
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\duser\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DUser.rc
//
#define IDD_DLG                         100
#define IDB_SPYICON                     101
#define IDD_Assert                      101
#define IDC_ebcFileName                 1000
#define IDC_ebcExpression               1001
#define IDC_ebcLineNum                  1002
#define IDC_IGNORE                      1003
#define IDC_COPY                        1004
#define IDC_lvcCallStack                1005
#define IDC_DEBUG                       1008
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\duser\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	DUser.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\duser\guids.c ===
#pragma warning(disable: 4514)      // unreferenced inline/local function has been removed
#pragma warning(push, 3)

#include <objbase.h>
#include <dxtguid.c>
#include <initguid.h>
#include <ddraw.h>

#pragma warning(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\duser\_duser.h ===
#if !defined(DUSER__DUser_h__INCLUDED)
#define DUSER__DUser_h__INCLUDED

#define GADGET_ENABLE_DX
#define GADGET_ENABLE_COM
#define GADGET_ENABLE_TRANSITIONS
#include <DUser.h>

#include <DUserBaseP.h>
#include <DUserObjectAPIP.h>
#include <DUserServicesP.h>
#include <DUserMsgP.h>
#include <DUserCoreP.h>
#include <DUserMotionP.h>
#include <DUserCtrlP.h>

#endif // DUSER__DUser_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\duser\stdafx.h ===
#if !defined(DUSER__StdAfx_h__INCLUDED)
#define DUSER__StdAfx_h__INCLUDED

#pragma once

#include "CommonStdAfx.h"

#endif // DUSER__StdAfx_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\lava\dxcontainer.cpp ===
#include "stdafx.h"
#include "Lava.h"
#include "DxContainer.h"

#include "MsgHelp.h"


/***************************************************************************\
*****************************************************************************
*
* API Implementation
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
DxContainer * 
GetDxContainer(DuVisual * pgad)
{
    DuContainer * pcon = pgad->GetContainer();
    AssertReadPtr(pcon);

    DxContainer * pconDX = CastDxContainer(pcon);
    return pconDX;
}


//------------------------------------------------------------------------------
HRESULT
GdCreateDxRootGadget(
    IN  const RECT * prcContainerPxl,
    IN  CREATE_INFO * pci,              // Creation information
    OUT DuRootGadget ** ppgadNew)
{
    HRESULT hr;

    DxContainer * pconNew;
    hr = DxContainer::Build(prcContainerPxl, &pconNew);
    if (FAILED(hr)) {
        return hr;
    }

    hr = DuRootGadget::Build(pconNew, TRUE, pci, ppgadNew);
    if (FAILED(hr)) {
        pconNew->xwUnlock();
        return hr;
    }

    //
    // Don't setup an initial brush when using DirectX
    //

    return S_OK;
}


/***************************************************************************\
*****************************************************************************
*
* class DxContainer
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
DxContainer::DxContainer()
{

}


//------------------------------------------------------------------------------
DxContainer::~DxContainer()
{
    //
    // Need to destroy the gadget tree before this class is destructed since
    // it may need to make calls to the container during its destruction.  If 
    // we don't do this here, it may end up calling pure-virtual's on the base
    // class.
    //

    xwDestroyGadget();
}


//------------------------------------------------------------------------------
HRESULT
DxContainer::Build(const RECT * prcContainerPxl, DxContainer ** ppconNew)
{
    AssertReadPtr(prcContainerPxl);
    DxContainer * pconNew = ClientNew(DxContainer);
    if (pconNew == NULL) {
        return E_OUTOFMEMORY;
    }

    pconNew->m_rcContainerPxl = *prcContainerPxl;

    pconNew->m_rcClientPxl.left     = 0;
    pconNew->m_rcClientPxl.top      = 0;
    pconNew->m_rcClientPxl.right    = pconNew->m_rcContainerPxl.right - pconNew->m_rcContainerPxl.left;
    pconNew->m_rcClientPxl.bottom   = pconNew->m_rcContainerPxl.bottom - pconNew->m_rcContainerPxl.top;

    *ppconNew = pconNew;
    return S_OK;
}


//------------------------------------------------------------------------------
void        
DxContainer::OnGetRect(RECT * prcDesktopPxl)
{
    AssertWritePtr(prcDesktopPxl);
    *prcDesktopPxl = m_rcContainerPxl;
}


//------------------------------------------------------------------------------
void        
DxContainer::OnInvalidate(const RECT * prcInvalidContainerPxl)
{
    UNREFERENCED_PARAMETER(prcInvalidContainerPxl);
}


//------------------------------------------------------------------------------
void        
DxContainer::OnStartCapture()
{

}


//------------------------------------------------------------------------------
void        
DxContainer::OnEndCapture()
{

}


//------------------------------------------------------------------------------
BOOL        
DxContainer::OnTrackMouseLeave()
{
    return FALSE;
}


//------------------------------------------------------------------------------
void  
DxContainer::OnSetFocus()
{

}


//------------------------------------------------------------------------------
void        
DxContainer::OnRescanMouse(POINT * pptContainerPxl)
{
    pptContainerPxl->x  = -20000;
    pptContainerPxl->y  = -20000;
}


//------------------------------------------------------------------------------
BOOL        
DxContainer::xdHandleMessage(UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT * pr, UINT nMsgFlags)
{
    if (m_pgadRoot == NULL) {
        return FALSE;  // If don't have a root, there is nothing to handle.
    }

    //
    // NOTE: All messages that come into the DxContainer are coming through the
    // ForwardGadgetMessage() API which has already taken a Context lock.  
    // Therefore, we don't need to take the Context lock in this function again.
    // Other Containers do NOT necessarily have this behavior.
    //

    POINT ptContainerPxl;

    *pr = 0;

    switch (nMsg)
    {
    case WM_LBUTTONDOWN:
    case WM_RBUTTONDOWN:
    case WM_MBUTTONDOWN:
    case WM_LBUTTONDBLCLK:
    case WM_RBUTTONDBLCLK:
    case WM_MBUTTONDBLCLK:
    case WM_LBUTTONUP:
    case WM_RBUTTONUP:
    case WM_MBUTTONUP:
        {
            GMSG_MOUSECLICK msg;
            GdConvertMouseClickMessage(&msg, nMsg, wParam);

            ptContainerPxl.x = GET_X_LPARAM(lParam);
            ptContainerPxl.y = GET_Y_LPARAM(lParam);

            ContextLock cl;
            if (cl.LockNL(ContextLock::edDefer)) {
                return m_pgadRoot->xdHandleMouseMessage(&msg, ptContainerPxl);
            }
            break;
        }

    case WM_MOUSEWHEEL:
        {
            ptContainerPxl.x = GET_X_LPARAM(lParam);
            ptContainerPxl.y = GET_Y_LPARAM(lParam);

            GMSG_MOUSEWHEEL msg;
            GdConvertMouseWheelMessage(&msg, wParam);

            ContextLock cl;
            if (cl.LockNL(ContextLock::edDefer)) {
                return m_pgadRoot->xdHandleMouseMessage(&msg, ptContainerPxl);
            }
            break;
        }

    case WM_MOUSEMOVE:
    case WM_MOUSEHOVER:
        {
            GMSG_MOUSE msg;
            GdConvertMouseMessage(&msg, nMsg, wParam);

            ptContainerPxl.x = GET_X_LPARAM(lParam);
            ptContainerPxl.y = GET_Y_LPARAM(lParam);

            ContextLock cl;
            if (cl.LockNL(ContextLock::edDefer)) {
                return m_pgadRoot->xdHandleMouseMessage(&msg, ptContainerPxl);
            }
            break;
        }

    case WM_MOUSELEAVE:
        {
            ContextLock cl;
            if (cl.LockNL(ContextLock::edDefer)) {
                m_pgadRoot->xdHandleMouseLeaveMessage();
                return TRUE;
            }
            break;
        }

    case WM_CHAR:
    case WM_KEYDOWN:
    case WM_KEYUP:
    case WM_SYSCHAR:
    case WM_SYSKEYDOWN:
    case WM_SYSKEYUP:
        {
            GMSG_KEYBOARD msg;
            GdConvertKeyboardMessage(&msg, nMsg, wParam, lParam);
            BOOL fResult = m_pgadRoot->xdHandleKeyboardMessage(&msg, nMsgFlags);
            return fResult;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\lava\dxcontainer.h ===
#if !defined(WINAPI__DxContainer_h__INCLUDED)
#define WINAPI__DxContainer_h__INCLUDED
#pragma once

class DxContainer : public DuContainer
{
// Construction
public:
            DxContainer();
    virtual ~DxContainer();
    static  HRESULT     Build(const RECT * prcContainerPxl, DxContainer ** ppconNew);

// Base Interface
public:
    virtual HandleType  GetHandleType() const { return htDxContainer; }

// Container Interface
public:
    virtual void        OnGetRect(RECT * prcDesktopPxl);
    virtual void        OnInvalidate(const RECT * prcInvalidContainerPxl);
    virtual void        OnStartCapture();
    virtual void        OnEndCapture();
    virtual BOOL        OnTrackMouseLeave();
    virtual void        OnSetFocus();
    virtual void        OnRescanMouse(POINT * pptContainerPxl);

    virtual BOOL        xdHandleMessage(UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT * pr, UINT nMsgFlags);

// Operations
public:

// Data
protected:
    RECT        m_rcContainerPxl;
    RECT        m_rcClientPxl;
};


//------------------------------------------------------------------------------
inline DxContainer * CastDxContainer(BaseObject * pBase)
{
    if ((pBase != NULL) && (pBase->GetHandleType() == htDxContainer)) {
        return (DxContainer *) pBase;
    }
    return NULL;
}

DxContainer * GetDxContainer(DuVisual * pgad);

#endif // WINAPI__DxDrawContainer_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\lava\hwndcontainer.h ===
#if !defined(WINAPI__HWndContainer_h__INCLUDED)
#define WINAPI__HWndContainer_h__INCLUDED
#pragma once

class HWndContainer : public DuContainer
{
// Construction
public:
			HWndContainer();
	virtual ~HWndContainer();
    static  HRESULT     Build(HWND hwnd, HWndContainer ** ppconNew);

// Base Interface
public:
    virtual HandleType  GetHandleType() const { return htHWndContainer; }

// Container Interface
public:
    virtual void        OnGetRect(RECT * prcDesktopPxl);
    virtual void        OnInvalidate(const RECT * prcInvalidContainerPxl);
    virtual void        OnStartCapture();
    virtual void        OnEndCapture();
    virtual BOOL        OnTrackMouseLeave();
    virtual void        OnSetFocus();
    virtual void        OnRescanMouse(POINT * pptContainerPxl);

    virtual BOOL        xdHandleMessage(UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT * pr, UINT nMsgFlags);

// Operations
public:

// Implementation
protected:

// Data
protected:
            HWND        m_hwndOwner;
            SIZE        m_sizePxl;
            BOOL        m_fEnableDragDrop:1;
};


//------------------------------------------------------------------------------
inline HWndContainer * CastHWndContainer(BaseObject * pBase)
{
    if ((pBase != NULL) && (pBase->GetHandleType() == htHWndContainer)) {
        return (HWndContainer *) pBase;
    }
    return NULL;
}

HWndContainer * GetHWndContainer(DuVisual * pgad);

#endif // WINAPI__HWndContainer_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\lava\hwndcontainer.cpp ===
#include "stdafx.h"
#include "Lava.h"
#include "HWndContainer.h"

#include "MsgHelp.h"
#include "Spy.h"

#define PROFILE_DRAW    0

#if PROFILE_DRAW
#include <icecap.h>
#endif

#if DBG
UINT g_uMsgEnableSpy    = RegisterWindowMessage(TEXT("GadgetSpy Enable"));
UINT g_uMsgFindGadget   = RegisterWindowMessage(TEXT("GadgetSpy FindGadget"));
#endif // DBG

/***************************************************************************\
*****************************************************************************
*
* API Implementation
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
HWndContainer * 
GetHWndContainer(DuVisual * pgad)
{
    DuContainer * pcon = pgad->GetContainer();
    AssertReadPtr(pcon);

    HWndContainer * pconHWND = CastHWndContainer(pcon);
    return pconHWND;
}


/***************************************************************************\
*****************************************************************************
*
* class HWndContainer
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
HWndContainer::HWndContainer()
{
    m_hwndOwner = NULL;
}


//------------------------------------------------------------------------------
HWndContainer::~HWndContainer()
{
    //
    // Need to destroy the gadget tree before this class is destructed since
    // it may need to make calls to the container during its destruction.  If 
    // we don't do this here, it may end up calling pure-virtual's on the base
    // class.
    //

    ContextLock cl;
    Verify(cl.LockNL(ContextLock::edDefer));
    xwDestroyGadget();
}


//------------------------------------------------------------------------------
HRESULT
HWndContainer::Build(HWND hwnd, HWndContainer ** ppconNew)
{
    // Check parameters
    if (!ValidateHWnd(hwnd)) {
        return E_INVALIDARG;
    }

    // Create a new container
    HWndContainer * pconNew = ClientNew(HWndContainer);
    if (pconNew == NULL) {
        return E_OUTOFMEMORY;
    }

    pconNew->m_hwndOwner    = hwnd;

    RECT rcClient;
    GetClientRect(hwnd, &rcClient);
    pconNew->m_sizePxl.cx   = rcClient.right;
    pconNew->m_sizePxl.cy   = rcClient.bottom;

    *ppconNew = pconNew;
    return S_OK;
}


//------------------------------------------------------------------------------
void
HWndContainer::OnInvalidate(const RECT * prcInvalidContainerPxl)
{
    if ((!InlineIsRectEmpty(prcInvalidContainerPxl)) &&
        (prcInvalidContainerPxl->left <= m_sizePxl.cx) &&
        (prcInvalidContainerPxl->top <= m_sizePxl.cy) &&
        (prcInvalidContainerPxl->right >= 0) &&
        (prcInvalidContainerPxl->bottom >= 0)) {

        // TODO: How do we handle multiple layers / background?

#if 0
        Trace("HWndContainer::OnInvalidate(): %d, %d, %d, %d\n", 
                prcInvalidContainerPxl->left, prcInvalidContainerPxl->top,
                prcInvalidContainerPxl->right, prcInvalidContainerPxl->bottom);
#endif
        InvalidateRect(m_hwndOwner, prcInvalidContainerPxl, TRUE);
    }
}


//------------------------------------------------------------------------------
void
HWndContainer::OnGetRect(RECT * prcDesktopPxl)
{
    GetClientRect(m_hwndOwner, prcDesktopPxl);
    ClientToScreen(m_hwndOwner, (LPPOINT) &(prcDesktopPxl->left));
    ClientToScreen(m_hwndOwner, (LPPOINT) &(prcDesktopPxl->right));
}


//------------------------------------------------------------------------------
void        
HWndContainer::OnStartCapture()
{
    SetCapture(m_hwndOwner);
}


//------------------------------------------------------------------------------
void        
HWndContainer::OnEndCapture()
{
    ReleaseCapture();
}


//------------------------------------------------------------------------------
BOOL
HWndContainer::OnTrackMouseLeave()
{
    TRACKMOUSEEVENT tme;
    tme.cbSize          = sizeof(tme);
    tme.dwFlags         = TME_LEAVE | TME_HOVER;
    tme.dwHoverTime     = HOVER_DEFAULT;
    tme.hwndTrack       = m_hwndOwner;

    return TrackMouseEvent(&tme);
}


//------------------------------------------------------------------------------
void        
HWndContainer::OnSetFocus()
{
    if (GetFocus() != m_hwndOwner) {
        //
        // Setting focus is a little more complicated than pure HWND's.  This is
        // because Gadgets greatly simplify several things
        //
        // 1. SetFocus
        // 2. Setup caret, if any
        //

        //Trace("HWndContainer::OnSetFocus()\n");
        SetFocus(m_hwndOwner);
    }
}


//------------------------------------------------------------------------------
void        
HWndContainer::OnRescanMouse(POINT * pptContainerPxl)
{
    POINT ptCursor;
    if (!GetCursorPos(&ptCursor)) {
        ptCursor.x  = -20000;
        ptCursor.y  = -20000;
    }

    ScreenToClient(m_hwndOwner, &ptCursor);
    *pptContainerPxl = ptCursor;
}


//------------------------------------------------------------------------------
BOOL        
HWndContainer::xdHandleMessage(UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT * pr, UINT nMsgFlags)
{
    if (m_pgadRoot == NULL) {
        return FALSE;  // If don't have a root, there is nothing to handle.
    }

    POINT ptContainerPxl;
    *pr = 0;

    switch (nMsg)
    {
    case WM_LBUTTONDOWN:
    case WM_RBUTTONDOWN:
    case WM_MBUTTONDOWN:
    case WM_LBUTTONDBLCLK:
    case WM_RBUTTONDBLCLK:
    case WM_MBUTTONDBLCLK:
    case WM_LBUTTONUP:
    case WM_RBUTTONUP:
    case WM_MBUTTONUP:
        {
            GMSG_MOUSECLICK msg;
            GdConvertMouseClickMessage(&msg, nMsg, wParam);

            ptContainerPxl.x = GET_X_LPARAM(lParam);
            ptContainerPxl.y = GET_Y_LPARAM(lParam);

            ContextLock cl;
            if (cl.LockNL(ContextLock::edDefer)) {
                return m_pgadRoot->xdHandleMouseMessage(&msg, ptContainerPxl);
            }
            break;
        }

    case WM_MOUSEWHEEL:
        {
            ptContainerPxl.x = GET_X_LPARAM(lParam);
            ptContainerPxl.y = GET_Y_LPARAM(lParam);

            // unlike every other mouse message, the x,y params for the
            // mouse wheel are in *screen* coordinates, not *client*
            // coordinates -- convert 'em here to "play along"
            ScreenToClient(m_hwndOwner, &ptContainerPxl);

            GMSG_MOUSEWHEEL msg;
            GdConvertMouseWheelMessage(&msg, wParam);

            ContextLock cl;
            if (cl.LockNL(ContextLock::edDefer)) {
                return m_pgadRoot->xdHandleMouseMessage(&msg, ptContainerPxl);
            }
            break;
        }

    case WM_MOUSEMOVE:
    case WM_MOUSEHOVER:
        {
            GMSG_MOUSE msg;
            GdConvertMouseMessage(&msg, nMsg, wParam);

            ptContainerPxl.x = GET_X_LPARAM(lParam);
            ptContainerPxl.y = GET_Y_LPARAM(lParam);

            ContextLock cl;
            if (cl.LockNL(ContextLock::edDefer)) {
                return m_pgadRoot->xdHandleMouseMessage(&msg, ptContainerPxl);
            }
            break;
        }

    case WM_MOUSELEAVE:
        {
            ContextLock cl;
            if (cl.LockNL(ContextLock::edDefer)) {
                m_pgadRoot->xdHandleMouseLeaveMessage();
                return TRUE;
            }
            break;
        }

    case WM_CAPTURECHANGED:
        if (m_hwndOwner != (HWND) lParam) {
            ContextLock cl;
            if (cl.LockNL(ContextLock::edDefer)) {
                m_pgadRoot->xdHandleMouseLostCapture();
            }
        }
        break;

    //
    // WM_SETFOCUS and WM_KILLFOCUS will restore and save (respectively) Gadget focus only
    // if we are gaining for losing focus from an HWND outside our tree.
    //

    case WM_SETFOCUS:
        {
            if ((m_hwndOwner != (HWND)wParam) && (IsChild(m_hwndOwner, (HWND)wParam) == FALSE)) {
                ContextLock cl;
                if (cl.LockNL(ContextLock::edDefer)) {
                    return m_pgadRoot->xdHandleKeyboardFocus(GSC_SET);
                }
            }
            break;
        }

    case WM_KILLFOCUS:
        {
            if ((m_hwndOwner != (HWND)wParam) && (IsChild(m_hwndOwner, (HWND)wParam) == FALSE)) {
                ContextLock cl;
                if (cl.LockNL(ContextLock::edDefer)) {
                    return m_pgadRoot->xdHandleKeyboardFocus(GSC_LOST);
                }
            }
            break;
        }

    case WM_CHAR:
    case WM_KEYDOWN:
    case WM_KEYUP:
    case WM_SYSCHAR:
    case WM_SYSKEYDOWN:
    case WM_SYSKEYUP:
        {
            GMSG_KEYBOARD msg;
            GdConvertKeyboardMessage(&msg, nMsg, wParam, lParam);

            ContextLock cl;
            if (cl.LockNL(ContextLock::edDefer)) {
                return m_pgadRoot->xdHandleKeyboardMessage(&msg, nMsgFlags);
            }
            break;
        }

    case WM_ERASEBKGND:
        return TRUE;

    case WM_PAINT:
        if ((!m_fManualDraw) && (m_pgadRoot != NULL)) {
            PAINTSTRUCT ps;
            if (BeginPaint(m_hwndOwner, &ps) != NULL) {

#if PROFILE_DRAW
                StartProfile(PROFILE_GLOBALLEVEL, PROFILE_CURRENTID);
#endif

                {
                    ContextLock cl;
                    if (cl.LockNL(ContextLock::edNone)) {
                        m_pgadRoot->xrDrawTree(NULL, ps.hdc, &ps.rcPaint, 0);
                    }
                }

#if PROFILE_DRAW
                StopProfile(PROFILE_GLOBALLEVEL, PROFILE_CURRENTID);
#endif

                EndPaint(m_hwndOwner, &ps);
            }
            return TRUE;
        }
        break;

    case WM_WINDOWPOSCHANGED:
        {
            WINDOWPOS * pwp = (WINDOWPOS *) lParam;

            UINT nFlags = 0;
            if (!TestFlag(pwp->flags, SWP_NOSIZE)) {
                RECT rcClient;
                GetClientRect(m_hwndOwner, &rcClient);

                nFlags |= SGR_SIZE;
                m_sizePxl.cx = rcClient.right;
                m_sizePxl.cy = rcClient.bottom;
            }

            //
            // Even if the window has moved, we don't need to change the 
            // root gadget since it is relative to the container and that
            // has not changed.
            //

            // TODO: Need to change this to SGR_ACTUAL

            if (nFlags != 0) {
                ContextLock cl;
                if (cl.LockNL(ContextLock::edDefer)) {
                    VerifyHR(m_pgadRoot->xdSetLogRect(0, 0, m_sizePxl.cx, m_sizePxl.cy, nFlags));
                }
            }
        }
        break;

    case WM_PARENTNOTIFY:

        // TODO: Need to notify the root gadget that an HWND has been created
        //       or destroyed so that it can create an adapter gadget to back
        //       it.

        break;

    case WM_GETROOTGADGET:
        if (m_pgadRoot != NULL) {
            *pr = (LRESULT) m_pgadRoot->GetHandle();
            return TRUE;
        }
        break;
        
#if DBG
    default:
        if (nMsg == g_uMsgEnableSpy) {
            if (m_pgadRoot != NULL) {
                HGADGET hgadSelect = (HGADGET) lParam;
                HCURSOR hcurOld = SetCursor(LoadCursor(NULL, IDC_WAIT));

                ContextLock cl;
                if (cl.LockNL(ContextLock::edNone)) {
                    Spy::BuildSpy(m_hwndOwner, m_pgadRoot->GetHandle(), hgadSelect);
                    SetCursor(hcurOld);
                }
            }
        } else if (nMsg == g_uMsgFindGadget) {
            POINT ptFindScreenPxl;
            ptFindScreenPxl.x = GET_X_LPARAM(lParam);
            ptFindScreenPxl.y = GET_Y_LPARAM(lParam);
            ScreenToClient(m_hwndOwner, &ptFindScreenPxl);

            ContextLock cl;
            if (cl.LockNL(ContextLock::edNone)) {
                POINT ptClientPxl;
                DuVisual * pgadFound = m_pgadRoot->FindFromPoint(ptFindScreenPxl, GS_VISIBLE, &ptClientPxl);
                if (wParam) {
                    DuVisual::DEBUG_SetOutline(pgadFound);
                }

                if (pgadFound != NULL) {
                    *pr = (LRESULT) pgadFound->GetHandle();
                    return TRUE;
                }
            }
        }
#endif // DBG
    }
    
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\lava\hwndhelp.h ===
#if !defined(LAVA__HWndHelp_h__INCLUDED)
#define LAVA__HWndHelp_h__INCLUDED
#pragma once

HRESULT     GdAttachWndProc(HWND hwnd, ATTACHWNDPROC pfnDelegate, void * pvDelegate, BOOL fAnsi);
HRESULT     GdDetachWndProc(HWND hwnd, ATTACHWNDPROC pfnDelegate, void * pvDelegate);

#endif // LAVA__HWndHelp_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\lava\lava.h ===
/***************************************************************************\
*
* File: Lava.h
*
* Description:
* This file provides a project-wide header that is included in all source 
* files specific to this project.  It is similar to a precompiled header, 
* but is designed for more rapidly changing headers.
*
* The primary purpose of this file is to determine which DirectUser 
* projects this project has direct access to instead of going through public
* API's.  It is VERY IMPORTANT that this is as minimal as possible since
* adding a new project unnecessarily reduces the benefit of project 
* partitioning.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(LAVA__Lava_h__INCLUDED)
#define LAVA__Lava_h__INCLUDED

#define GADGET_ENABLE_DX
#define GADGET_ENABLE_COM
#define GADGET_ENABLE_OLE
#define GADGET_ENABLE_TRANSITIONS
#include <DUser.h>

#include <DUserBaseP.h>
#include <DUserObjectAPIP.h>
#include <DUserServicesP.h>
#include <DUserMsgP.h>
#include <DUserCoreP.h>
#include <DUserMotionP.h>

#if DBG

#define PromptInvalid(comment) \
    do \
    { \
        if (IDebug_Prompt(GetDebug(), "Validation error:\r\n" comment, __FILE__, __LINE__, "DirectUser/Lava Notification")) \
            AutoDebugBreak(); \
    } while (0) \

#else // DBG

#define PromptInvalid(comment) ((void) 0)

#endif // DBG

#endif // LAVA__Lava_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\lava\hwndhelp.cpp ===
#include "stdafx.h"
#include "Lava.h"
#include "HWndHelp.h"

/***************************************************************************\
*****************************************************************************
*
* WindowProc thunks provide a mechanism of attaching a new WNDPROC to an
* existing HWND.  This does not require you to derive from any classes,
* does not use any HWND properties, and can be applied multiple times on the
* same HWND.
*
* Taken from ATLWIN.H
*
*****************************************************************************
\***************************************************************************/

/////////////////////////////////////////////////////////////////////////////
// WindowProc thunks

class CWndProcThunk
{
public:
        _AtlCreateWndData cd;
        CStdCallThunk thunk;

        void Init(WNDPROC proc, void* pThis)
        {
            thunk.Init((DWORD_PTR)proc, pThis);
        }
};

#define DUSERUNSUBCLASSMESSAGE "DUserUnSubClassMessage"

class WndBridge
{
// Construction
public:
            WndBridge();
            ~WndBridge();
    static  HRESULT     Build(HWND hwnd, ATTACHWNDPROC pfnDelegate, void * pvDelegate, BOOL fAnsi);
            HRESULT     Detach(BOOL fForceCleanup);

// Operations
public:
    static  LRESULT CALLBACK
                    RawWndProc(HWND hwnd, UINT nMsg, WPARAM wParam, LPARAM lParam);

// Data
protected:
    CWndProcThunk   m_thunkUs;
    ATTACHWNDPROC   m_pfnDelegate;
    void *          m_pvDelegate;
    HWND            m_hwnd;
    WNDPROC         m_pfnOldWndProc;
    BOOL            m_fAnsi;
    UINT            m_msgUnSubClass;

private:
    ULONG           AddRef();
    ULONG           Release();
    LONG            m_cRefs;
    BOOL            m_fAttached;
};


//------------------------------------------------------------------------------
WndBridge::WndBridge()
{
    m_thunkUs.Init(RawWndProc, this);
    m_msgUnSubClass = RegisterWindowMessage(DUSERUNSUBCLASSMESSAGE);
    m_cRefs         = 0;
    m_fAttached     = TRUE;
    m_pvDelegate = m_pfnDelegate = NULL;
}

//------------------------------------------------------------------------------
WndBridge::~WndBridge()
{
    AssertMsg(!m_fAttached, "WndBridge still attached at destruction!");
}

//------------------------------------------------------------------------------
HRESULT
WndBridge::Build(HWND hwnd, ATTACHWNDPROC pfnDelegate, void * pvDelegate, BOOL fAnsi)
{
    WndBridge * pBridge = ProcessNew(WndBridge);

    if (pBridge == NULL) {
        return E_OUTOFMEMORY;
    } else if (pBridge->m_msgUnSubClass == 0) {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    pBridge->m_pvDelegate = pvDelegate;
    pBridge->m_pfnDelegate = pfnDelegate;
    pBridge->m_hwnd = hwnd;
    pBridge->m_fAnsi = fAnsi;

    WNDPROC pProc = (WNDPROC)(pBridge->m_thunkUs.thunk.pThunk);
    WNDPROC pfnOldWndProc = NULL;

    if (fAnsi) {
        pfnOldWndProc = (WNDPROC)::SetWindowLongPtrA(hwnd, GWLP_WNDPROC, (LPARAM)pProc);
    } else {
        pfnOldWndProc = (WNDPROC)::SetWindowLongPtrW(hwnd, GWLP_WNDPROC, (LPARAM)pProc);
    }

    if (pfnOldWndProc == NULL) {
        //
        // Didn't have a previous WNDPROC, so the call to SWLP failed.
        //

        ProcessDelete(WndBridge, pBridge);
        return E_OUTOFMEMORY;
    }

    pBridge->m_pfnOldWndProc = pfnOldWndProc;

    //
    // Once successfully created, the reference count starts at 1.
    //
    pBridge->m_cRefs = 1;

    return S_OK;
}


//------------------------------------------------------------------------------
LRESULT
WndBridge::RawWndProc(HWND hwndThis, UINT nMsg, WPARAM wParam, LPARAM lParam)
{
    WndBridge * pThis = (WndBridge *) hwndThis;

    //
    // Addref the WndBridge object so that we keep it around while we are
    // processing this message.
    //
    pThis->AddRef();

    //
    // Cache these values because we may delete our WndBridge object during
    // the processing of certain messages.
    //

    HWND hwnd = pThis->m_hwnd;
    WNDPROC pfnOldWndProc = pThis->m_pfnOldWndProc;
    BOOL fAnsi = pThis->m_fAnsi;

    LRESULT lRet = 0;
    BOOL fHandled = FALSE;

    if (nMsg == pThis->m_msgUnSubClass) {
        //
        // We received our special message to detach.  Make sure it is intended
        // for us (by matching proc and additional param).
        //
        if (wParam == (WPARAM)pThis->m_pfnDelegate && lParam == (LPARAM)pThis->m_pvDelegate) {
            lRet = (S_OK == pThis->Detach(FALSE)) ? TRUE :  FALSE;
            fHandled = TRUE;
        }
    } else {
        //
        // Pass this message to our delegate function.
        //
        if (pThis->m_pfnDelegate != NULL) {
            fHandled = pThis->m_pfnDelegate(pThis->m_pvDelegate, hwnd, nMsg, wParam, lParam, &lRet);
        }

        //
        // Handle WM_NCDESTROY explicitly to forcibly clean up.
        //
        if (nMsg == WM_NCDESTROY) {
            //
            // The fact that we received this message means that we are still
            // in the call chain.  This is our last chance to clean up, and
            // no other message should be received by this window proc again.
            // It is OK to force a cleanup now.
            //
            pThis->Detach(TRUE);


            //
            // Always pass the WM_NCDESTROY message down the chain!
            //
            fHandled = FALSE;
        }
    }

    //
    // If our delegate function didn't handle this message, pass it on down the chain.
    //
    if (!fHandled) {
        if (fAnsi) {
            lRet = CallWindowProcA(pfnOldWndProc, hwnd, nMsg, wParam, lParam);
        } else {
            lRet = CallWindowProcW(pfnOldWndProc, hwnd, nMsg, wParam, lParam);
        }
    }

    //
    // Release our reference.  The WndBridge object may evaporate after this.
    //
    pThis->Release();

    return lRet;
}

//------------------------------------------------------------------------------
// S_OK -> not attached
// S_FALSE -> still attached
HRESULT
WndBridge::Detach(BOOL fForceCleanup)
{
    HRESULT hr = S_FALSE;
    BOOL fCleanup = fForceCleanup;

    //
    // If we have already detached, return immediately.
    //

    if (!m_fAttached) {
        return S_OK;
    }

    //
    // When we detach, we simply break our connection to the delegate proc.
    //

    m_pfnDelegate  = NULL;
    m_pvDelegate   = NULL;

    if (!fForceCleanup) {
        //
        // Get the pointers to our thunk proc and the current window proc.
        //

        WNDPROC pfnThunk = (WNDPROC)m_thunkUs.thunk.pThunk;
        WNDPROC pfnWndProc = NULL;
        if (m_fAnsi) {
            pfnWndProc = (WNDPROC)::GetWindowLongPtrA(m_hwnd, GWLP_WNDPROC);
        } else {
            pfnWndProc = (WNDPROC)::GetWindowLongPtrW(m_hwnd, GWLP_WNDPROC);
        }
        AssertMsg(pfnWndProc != NULL, "Must always have a window proc!");

        //
        // If the current window proc is our own thunk proc, then we can
        // clean up more completely.
        //

        fCleanup = (pfnWndProc == pfnThunk);
    }

    if (fCleanup) {
        if (m_fAnsi) {
            ::SetWindowLongPtrA(m_hwnd, GWLP_WNDPROC, (LPARAM)m_pfnOldWndProc);
        } else {
            ::SetWindowLongPtrW(m_hwnd, GWLP_WNDPROC, (LPARAM)m_pfnOldWndProc);
        }

        m_fAttached = FALSE;
        Release();
        hr = S_OK;
    }

    return hr;
}

//------------------------------------------------------------------------------
ULONG WndBridge::AddRef()
{
    return InterlockedIncrement(&m_cRefs);
}

//------------------------------------------------------------------------------
ULONG WndBridge::Release()
{
    ULONG cRefs = InterlockedDecrement(&m_cRefs);

    if (cRefs == 0) {
        ProcessDelete(WndBridge, this);
    }

    return cRefs;
}

//------------------------------------------------------------------------------
HRESULT
GdAttachWndProc(HWND hwnd, ATTACHWNDPROC pfnDelegate, void * pvDelegate, BOOL fAnsi)
{
    return WndBridge::Build(hwnd, pfnDelegate, pvDelegate, fAnsi);
}

//------------------------------------------------------------------------------
HRESULT
GdDetachWndProc(HWND hwnd, ATTACHWNDPROC pfnDelegate, void * pvDelegate)
{
    UINT msgUnSubClass = RegisterWindowMessage(DUSERUNSUBCLASSMESSAGE);

    if (msgUnSubClass == 0) {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if (SendMessage(hwnd, msgUnSubClass, (WPARAM) pfnDelegate, (LPARAM) pvDelegate)) {
        return S_OK;
    } else {
        PromptInvalid("Unable to find subclass.");
        return E_FAIL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\lava\msghelp.h ===
#if !defined(LAVA__MsgHelp_h__INCLUDED)
#define LAVA__MsgHelp_h__INCLUDED

void            GdConvertMouseMessage(GMSG_MOUSE * pmsg, UINT nMsg, WPARAM wParam);
void            GdConvertKeyboardMessage(GMSG_KEYBOARD * pmsg, UINT nMsg, WPARAM wParam, LPARAM lParam);

void            GdConvertMouseClickMessage(GMSG_MOUSECLICK * pmsg, UINT nMsg, WPARAM wParam);
void            GdConvertMouseWheelMessage(GMSG_MOUSEWHEEL * pmsg, WPARAM wParam);

#endif // LAVA__MsgHelp_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\lava\nccontainer.cpp ===
#include "stdafx.h"
#include "Lava.h"
#include "NcContainer.h"

#include "MsgHelp.h"


/***************************************************************************\
*****************************************************************************
*
* API Implementation
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
NcContainer * 
GetNcContainer(DuVisual * pgad)
{
    DuContainer * pcon = pgad->GetContainer();
    AssertReadPtr(pcon);

    NcContainer * pconHWND = CastNcContainer(pcon);
    return pconHWND;
}


/***************************************************************************\
*
* GdCreateNcRootGadget (Public)
*
* GdCreateNcRootGadget() creates a new RootGadget for an existing HWND's
* non-client area.
*
\***************************************************************************/

HRESULT
GdCreateNcRootGadget(
    IN  HWND hwndContainer,             // Window to be hosted inside
    IN  CREATE_INFO * pci,              // Creation information
    OUT DuRootGadget ** ppgadNew)         // New Root Gadget
{
    HRESULT hr;

    //
    // Build a new container and top gadget
    //

    NcContainer * pconNew;
    hr = NcContainer::Build(hwndContainer, &pconNew);
    if (FAILED(hr)) {
        return hr;
    }

    hr = DuRootGadget::Build(pconNew, FALSE, pci, ppgadNew);
    if (FAILED(hr)) {
        pconNew->xwUnlock();
        return hr;
    }

    //
    // Don't setup an initial brush when using Non-Client
    //

    return S_OK;
}


/***************************************************************************\
*****************************************************************************
*
* class NcContainer
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
NcContainer::NcContainer()
{
    m_hwndOwner = NULL;
}


//------------------------------------------------------------------------------
NcContainer::~NcContainer()
{
    //
    // Need to destroy the gadget tree before this class is destructed since
    // it may need to make calls to the container during its destruction.  If 
    // we don't do this here, it may end up calling pure-virtual's on the base
    // class.
    //

    xwDestroyGadget();
}


//------------------------------------------------------------------------------
HRESULT
NcContainer::Build(HWND hwnd, NcContainer ** ppconNew)
{
    // Check parameters
    if (!ValidateHWnd(hwnd)) {
        return E_INVALIDARG;
    }

    // Create a new container
    NcContainer * pconNew = ClientNew(NcContainer);
    if (pconNew == NULL) {
        return E_OUTOFMEMORY;
    }

    pconNew->m_hwndOwner    = hwnd;

    RECT rcWin;
    GetWindowRect(hwnd, &rcWin);
    pconNew->m_sizePxl.cx   = rcWin.right - rcWin.left;
    pconNew->m_sizePxl.cy   = rcWin.bottom - rcWin.top;

    *ppconNew = pconNew;
    return S_OK;
}


//------------------------------------------------------------------------------
void
NcContainer::OnInvalidate(const RECT * prcInvalidContainerPxl)
{
    UNREFERENCED_PARAMETER(prcInvalidContainerPxl);
}


//------------------------------------------------------------------------------
void
NcContainer::OnGetRect(RECT * prcDesktopPxl)
{
    GetWindowRect(m_hwndOwner, prcDesktopPxl);
}


//------------------------------------------------------------------------------
void        
NcContainer::OnStartCapture()
{
    
}


//------------------------------------------------------------------------------
void        
NcContainer::OnEndCapture()
{
    
}


//------------------------------------------------------------------------------
BOOL
NcContainer::OnTrackMouseLeave()
{
    return FALSE;
}


//------------------------------------------------------------------------------
void        
NcContainer::OnSetFocus()
{
    if (GetFocus() != m_hwndOwner) {
        //
        // Setting focus is a little more complicated than pure HWND's.  This is
        // because Gadgets greatly simplify several things
        //
        // 1. SetFocus
        // 2. Setup caret, if any
        //

        Trace("NcContainer::OnSetFocus()\n");
        SetFocus(m_hwndOwner);
    }
}


//------------------------------------------------------------------------------
void        
NcContainer::OnRescanMouse(POINT * pptContainerPxl)
{
//    Trace("%p OnRescanMouse\n", GetTickCount());

    POINT ptCursor;
    if (!GetCursorPos(&ptCursor)) {
        ptCursor.x  = -20000;
        ptCursor.y  = -20000;
    }

    ScreenToClient(m_hwndOwner, &ptCursor);
    *pptContainerPxl = ptCursor;
}


//------------------------------------------------------------------------------
BOOL        
NcContainer::xdHandleMessage(UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT * pr, UINT nMsgFlags)
{
    UNREFERENCED_PARAMETER(nMsgFlags);

    if (m_pgadRoot == NULL) {
        return FALSE;  // If don't have a root, there is nothing to handle.
    }

    POINT ptContainerPxl;

    *pr = 0;

    Trace("NcContainer::HandleMessage: msg: 0x%x\n", nMsg);

    switch (nMsg)
    {
    case WM_NCLBUTTONDOWN:
    case WM_NCRBUTTONDOWN:
    case WM_NCMBUTTONDOWN:
    case WM_NCLBUTTONDBLCLK:
    case WM_NCRBUTTONDBLCLK:
    case WM_NCMBUTTONDBLCLK:
    case WM_NCLBUTTONUP:
    case WM_NCRBUTTONUP:
    case WM_NCMBUTTONUP:
        ptContainerPxl.x = GET_X_LPARAM(lParam);
        ptContainerPxl.y = GET_Y_LPARAM(lParam);

        if ((GetCapture() == m_hwndOwner) && 
            (ChildWindowFromPointEx(m_hwndOwner, ptContainerPxl, CWP_SKIPINVISIBLE) != m_hwndOwner)) {
           
            ReleaseCapture();
        }

        {
            GMSG_MOUSECLICK msg;
            nMsg += WM_LBUTTONDOWN - WM_NCLBUTTONDOWN;

            GdConvertMouseClickMessage(&msg, nMsg, wParam);

            ContextLock cl;
            if (cl.LockNL(ContextLock::edDefer)) {
                return m_pgadRoot->xdHandleMouseMessage(&msg, ptContainerPxl);
            }
            break;
        }

    case WM_NCMOUSEMOVE:
        ptContainerPxl.x = GET_X_LPARAM(lParam);
        ptContainerPxl.y = GET_Y_LPARAM(lParam);

        if ((GetCapture() == m_hwndOwner) && 
            (ChildWindowFromPointEx(m_hwndOwner, ptContainerPxl, CWP_SKIPINVISIBLE) != m_hwndOwner)) {
           
            ReleaseCapture();
        }

        {
            GMSG_MOUSE msg;
            nMsg += WM_LBUTTONDOWN - WM_NCLBUTTONDOWN;

            GdConvertMouseMessage(&msg, nMsg, wParam);

            ContextLock cl;
            if (cl.LockNL(ContextLock::edDefer)) {
                return m_pgadRoot->xdHandleMouseMessage(&msg, ptContainerPxl);
            }
            break;
        }

    case WM_CAPTURECHANGED:
        if (m_hwndOwner != (HWND) lParam) {
            ContextLock cl;
            if (cl.LockNL(ContextLock::edDefer)) {
                m_pgadRoot->xdHandleMouseLostCapture();
            }
        }
        break;

    case WM_SETFOCUS:
        {
            ContextLock cl;
            if (cl.LockNL(ContextLock::edDefer)) {
                return m_pgadRoot->xdHandleKeyboardFocus(GSC_SET);
            }
            break;
        }

    case WM_KILLFOCUS:
        {
            ContextLock cl;
            if (cl.LockNL(ContextLock::edDefer)) {
                return m_pgadRoot->xdHandleKeyboardFocus(GSC_LOST);
            }
            break;
        }

    case WM_CHAR:
    case WM_KEYDOWN:
    case WM_KEYUP:
    case WM_SYSCHAR:
    case WM_SYSKEYDOWN:
    case WM_SYSKEYUP:
        {
            Trace("NcContainer::xdHandleMessage(Keyboard=0x%x)\n", nMsg);
        }
        break;

    case WM_NCACTIVATE:
        {
            ContextLock cl;
            if (cl.LockNL(ContextLock::edDefer)) {
                m_pgadRoot->xdHandleActivate(wParam ? GSC_LOST : GSC_SET);
            }
            break;
        }
        // Fall through to WM_NCPAINT

    case WM_NCPAINT:
        if ((!m_fManualDraw) && (m_pgadRoot != NULL)) {
//            HDC hdc = GetDCEx(m_hwndOwner, (HRGN) wParam, DCX_WINDOW | DCX_INTERSECTRGN);
            HDC hdc = GetWindowDC(m_hwndOwner);
            RECT rcInvalid;
            {
                ContextLock cl;
                if (cl.LockNL(ContextLock::edNone)) {
                    m_pgadRoot->GetLogRect(&rcInvalid, SGR_CLIENT);
                    m_pgadRoot->xrDrawTree(NULL, hdc, &rcInvalid, 0);
                }
            }
            ReleaseDC(m_hwndOwner, hdc);
            return TRUE;
        }
        break;

    case WM_WINDOWPOSCHANGED:
        {
            WINDOWPOS * pwp = (WINDOWPOS *) lParam;
            if (!TestFlag(pwp->flags, SWP_NOSIZE)) {
                RECT rcWin;
                GetWindowRect(m_hwndOwner, &rcWin);
                ContextLock cl;
                if (cl.LockNL(ContextLock::edDefer)) {
                    VerifyHR(m_pgadRoot->xdSetLogRect(0, 0, rcWin.right - rcWin.left, rcWin.bottom - rcWin.top, SGR_SIZE));
                }
                break;
            }
        }
        break;

    case WM_GETROOTGADGET:
        if (m_pgadRoot != NULL) {
            *pr = (LRESULT) m_pgadRoot->GetHandle();
            return TRUE;
        }
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\lava\public.h ===
/***************************************************************************\
*
* File: Public.h
*
* Description:
* Public.h contains a list of definitions that are exposed and available
* outside this project.  Any other DirectUser project that wishes to use
* these services directly instead of going through public API's can include
* a corresponding [Project]P.h available in the \inc directory.  
* 
* Definitions that are not exposed through this file are considered project 
* specific implementation details and should not used in other projects.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(LAVA__Public_h__INCLUDED)
#define LAVA__Public_h__INCLUDED

#include "DxContainer.h"
#include "HWndContainer.h"
#include "NcContainer.h"
#include "HWndHelp.h"

#endif // LAVA__Public_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\lava\msghelp.cpp ===
#include "stdafx.h"
#include "Lava.h"
#include "MsgHelp.h"

/***************************************************************************\
*
* GdConvertMouseMessage (Public)
*
* GdConvertMouseMessage converts from an HWND mouse event into a Gadget 
* mouse event.
*
\***************************************************************************/

void
SetStandardInputFields(
    IN OUT GMSG_INPUT * pmsg,
    IN     UINT cbSize)
{
    ZeroMemory(pmsg, cbSize);
    pmsg->cbSize     = cbSize;
    pmsg->lTime      = GetMessageTime();
    pmsg->nModifiers = 0;

    //
    // todo -- measure perf
    //
    BYTE bKeys[256];
    if (GetKeyboardState(bKeys)) {
        if (bKeys[VK_LBUTTON]  & 0x80)  pmsg->nModifiers |= GMODIFIER_LBUTTON;
        if (bKeys[VK_RBUTTON]  & 0x80)  pmsg->nModifiers |= GMODIFIER_RBUTTON;
        if (bKeys[VK_MBUTTON]  & 0x80)  pmsg->nModifiers |= GMODIFIER_MBUTTON;
        if (bKeys[VK_LSHIFT]   & 0x80)  pmsg->nModifiers |= GMODIFIER_LSHIFT;
        if (bKeys[VK_RSHIFT]   & 0x80)  pmsg->nModifiers |= GMODIFIER_RSHIFT;
        if (bKeys[VK_LCONTROL] & 0x80)  pmsg->nModifiers |= GMODIFIER_LCONTROL;
        if (bKeys[VK_RCONTROL] & 0x80)  pmsg->nModifiers |= GMODIFIER_RCONTROL;
        if (bKeys[VK_LMENU]    & 0x80)  pmsg->nModifiers |= GMODIFIER_LALT;
        if (bKeys[VK_RMENU]    & 0x80)  pmsg->nModifiers |= GMODIFIER_RALT;
    }
}


void 
GdConvertMouseClickMessage(
    IN OUT GMSG_MOUSECLICK * pmsg,
    IN     UINT nMsg,
    IN     WPARAM wParam)
{
    SetStandardInputFields(pmsg, sizeof(GMSG_MOUSECLICK));
    pmsg->nFlags        = LOWORD(wParam);
    pmsg->cClicks       = 0;

    switch (nMsg)
    {
    case WM_LBUTTONDBLCLK:
    case WM_LBUTTONDOWN:
        pmsg->bButton   = GBUTTON_LEFT;
        pmsg->nCode     = GMOUSE_DOWN;
        break;

    case WM_RBUTTONDBLCLK:
    case WM_RBUTTONDOWN:
        pmsg->bButton   = GBUTTON_RIGHT;
        pmsg->nCode     = GMOUSE_DOWN;
        break;

    case WM_MBUTTONDBLCLK:
    case WM_MBUTTONDOWN:
        pmsg->bButton   = GBUTTON_MIDDLE;
        pmsg->nCode     = GMOUSE_DOWN;
        break;

    case WM_LBUTTONUP:
        pmsg->bButton   = GBUTTON_LEFT;
        pmsg->nCode     = GMOUSE_UP;
        break;

    case WM_RBUTTONUP:
        pmsg->bButton   = GBUTTON_RIGHT;
        pmsg->nCode     = GMOUSE_UP;
        break;

    case WM_MBUTTONUP:
        pmsg->bButton   = GBUTTON_MIDDLE;
        pmsg->nCode     = GMOUSE_UP;
        break;

    default:
        AssertMsg(0, "Unknown message or should needs different convertor");
    }
}

void 
GdConvertMouseWheelMessage(
    IN OUT GMSG_MOUSEWHEEL * pmsg,
    IN     WPARAM wParam)
{
    SetStandardInputFields(pmsg, sizeof(GMSG_MOUSEWHEEL));
    pmsg->nCode         = GMOUSE_WHEEL;
    pmsg->bButton       = GBUTTON_NONE;
    pmsg->nFlags        = LOWORD(wParam);
    pmsg->sWheel        = GET_WHEEL_DELTA_WPARAM(wParam);
}


void 
GdConvertMouseMessage(
    IN OUT GMSG_MOUSE * pmsg,
    UINT nMsg,
    WPARAM wParam)
{
    SetStandardInputFields(pmsg, sizeof(GMSG_MOUSE));
    pmsg->nFlags        = LOWORD(wParam);
    
    switch (nMsg)
    {
    case WM_MOUSEMOVE:
        pmsg->bButton   = GBUTTON_NONE;
        pmsg->nCode     = GMOUSE_MOVE;
        break;

    case WM_MOUSEHOVER:
        pmsg->bButton   = GBUTTON_NONE;
        pmsg->nCode     = GMOUSE_HOVER;
        break;
    
    case WM_MOUSELEAVE:
        AssertMsg(0, "Must call RootGadget::xdHandleMouseLeaveMessage() directly");
        break;

    default:
        AssertMsg(0, "Unknown message or should needs different convertor");
    }
}


/***************************************************************************\
*
* GdConvertKeyboardMessage (Public)
*
* GdConvertKeyboardMessage converts from an HWND keyboard event into a 
* Gadget mouse event.
*
\***************************************************************************/

void            
GdConvertKeyboardMessage(
    IN OUT GMSG_KEYBOARD * pmsg,
    IN     UINT nMsg,
    IN     WPARAM wParam,
    IN     LPARAM lParam)
{
    SetStandardInputFields(pmsg, sizeof(GMSG_KEYBOARD));
    pmsg->ch            = (WCHAR) wParam;
    pmsg->cRep          = LOWORD(lParam);
    pmsg->wFlags        = HIWORD(lParam);
    
    switch (nMsg)
    {
    case WM_CHAR:
        pmsg->nCode     = GKEY_CHAR;
        break;

    case WM_KEYDOWN:
        pmsg->nCode     = GKEY_DOWN;
        break;

    case WM_KEYUP:
        pmsg->nCode     = GKEY_UP;
        break;

    case WM_SYSCHAR:
        pmsg->nCode     = GKEY_SYSCHAR;
        break;

    case WM_SYSKEYDOWN:
        pmsg->nCode     = GKEY_SYSDOWN;
        break;

    case WM_SYSKEYUP:
        pmsg->nCode     = GKEY_SYSUP;
        break;

    default:
        AssertMsg(0, "Unknown message or should needs different convertor");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\lava\nccontainer.h ===
#if !defined(WINAPI__NcContainer_h__INCLUDED)
#define WINAPI__NcContainer_h__INCLUDED
#pragma once

class NcContainer : public DuContainer
{
// Construction
public:
			NcContainer();
	virtual ~NcContainer();
    static  HRESULT     Build(HWND hwnd, NcContainer ** ppconNew);

// Base Interface
public:
    virtual HandleType  GetHandleType() const { return htNcContainer; }

// Container Interface
public:
    virtual void        OnGetRect(RECT * prcDesktopPxl);
    virtual void        OnInvalidate(const RECT * prcInvalidContainerPxl);
    virtual void        OnStartCapture();
    virtual void        OnEndCapture();
    virtual BOOL        OnTrackMouseLeave();
    virtual void        OnSetFocus();
    virtual void        OnRescanMouse(POINT * pptContainerPxl);

    virtual BOOL        xdHandleMessage(UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT * pr, UINT nMsgFlags);

// Operations
public:

// Implementation
protected:

// Data
protected:
    HWND        m_hwndOwner;
    SIZE        m_sizePxl;
    UINT        m_nFlags;
};


//------------------------------------------------------------------------------
inline NcContainer * CastNcContainer(BaseObject * pBase)
{
    if ((pBase != NULL) && (pBase->GetHandleType() == htNcContainer)) {
        return (NcContainer *) pBase;
    }
    return NULL;
}

NcContainer * GetNcContainer(DuVisual * pgad);

#endif // WINAPI__NcContainer_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\lava\spy.h ===
#if !defined(LAVA__Spy_h__INCLUDED)
#define LAVA__Spy_h__INCLUDED
#pragma once

#include <commctrl.h>

#if DBG
class Spy : public ListNodeT<Spy>
{
// Construction
public:
            Spy();
            ~Spy();

// Operations
public:
    static  BOOL        BuildSpy(HWND hwndParent, HGADGET hgadRoot, HGADGET hgadSelect);

// Implementation
protected:
    static  LRESULT CALLBACK
                        RawSpyWndProc(HWND hwnd, UINT nMsg, WPARAM wParam, LPARAM lParam);
            LRESULT     SpyWndProc(UINT nMsg, WPARAM wParam, LPARAM lParam);

    static  HRESULT CALLBACK
                        RawEventProc(HGADGET hgadCur, void * pvCur, EventMsg * pmsg);
            HRESULT     EventProc(EventMsg * pmsg);

        struct EnumData
        {
            Spy *       pspy;
            HTREEITEM   htiParent;
            int         nLevel;
        };

    static  BOOL CALLBACK 
                        EnumAddList(HGADGET hgad, void * pvData);
    static  BOOL CALLBACK 
                        EnumRemoveLink(HGADGET hgad, void * pvData);


        struct CheckIsChildData
        {
            HGADGET     hgadCheck;
            BOOL        fChild;
        };

    static  BOOL CALLBACK 
                        EnumCheckIsChild(HGADGET hgad, void * pvData);

        enum EImage
        {
            iGadget     = 0,
        };

            void        SelectGadget(HGADGET hgad);
    
            HGADGET     GetGadget(HTREEITEM hti);
            HTREEITEM   InsertTreeItem(HTREEITEM htiParent, HGADGET hgad);
            void        DisplayContextMenu(BOOL fViaKbd);

            void        UpdateTitle();
            void        UpdateDetails();
            void        UpdateLayout();
            void        UpdateLayoutDesc(BOOL fForceLayoutDesc);
            
            // Painting
            void        OnPaint(HDC hdc);

            void        PaintLine(HDC hdc, POINT * pptOffset, LPCTSTR pszName, LPCTSTR pszText, HFONT hfnt = NULL);
            void        PaintLine(HDC hdc, POINT * pptOffset, LPCTSTR pszName, LPCWSTR pszText, BOOL fMultiline = FALSE, HFONT hfnt = NULL);
            void        PaintLine(HDC hdc, POINT * pptOffset, LPCTSTR pszName, int nValue, HFONT hfnt = NULL);
            void        PaintLine(HDC hdc, POINT * pptOffset, LPCTSTR pszName, void * pvValue, HFONT hfnt = NULL);

            int         NumLines(int cyPxl) const;

// Data
protected:
            HWND        m_hwnd;
            HWND        m_hwndTree;
            HIMAGELIST  m_hilc;
    static  HBRUSH      s_hbrOutline;
    static  HFONT       s_hfntDesc;
    static  HFONT       s_hfntDescBold;

            HGADGET     m_hgadMsg;      // Common MessageHandler attached to each Gadget
            HGADGET     m_hgadRoot;     // Root of tree
            HGADGET     m_hgadDetails;  // Current Gadget displayed in Details
            int         m_cItems;       // Number of Gadgets in tree
            TCHAR       m_szRect[128];  // Cached position
            WCHAR       m_szName[128];  // Cached name
            WCHAR       m_szType[128];  // Cached type
            WCHAR       m_szStyle[1024];// Style description
            BOOL        m_fShowDesc:1;  // Whether to show the description area
            BOOL        m_fValid:1;     // Set TRUE when Tree is completely valid
            SIZE        m_sizeWndPxl;   // Size of frame window
    static  int         s_cyLinePxl;    // Height of each line in the description area
            int         m_cLines;       // Number of lines
            int         m_cyDescPxl;    // Height of description area in pixels

    static  DWORD       g_tlsSpy;       // TLS Slot for Spy
    static  PRID        s_pridLink;
    static  ATOM        s_atom;
    static  CritLock    s_lockList;     // Lock for list of Spies
    static  GList<Spy>  s_lstSpys;      // List of all open Spies
};

#endif // DBG

#include "Spy.inl"

#endif // LAVA__Spy_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\lava\spy.inl ===
#if !defined(LAVA__Spy_inl__INCLUDED)
#define LAVA__Spy_inl__INCLUDED
#pragma once

/***************************************************************************\
*****************************************************************************
*
* class Spy
*
*****************************************************************************
\***************************************************************************/

#if DBG

#endif // DBG

#endif // LAVA__Spy_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\lava\spy.cpp ===
#include "stdafx.h"
#include "Lava.h"
#include "Spy.h"

#include "..\DUser\resource.h"

#if DBG

const UINT  IDC_GADGETTREE  = 1;
const int   cxValue         = 80;
const int   cxBorder        = 5;
const int   cyBorder        = 5;

/***************************************************************************\
*****************************************************************************
*
* class Spy
*
*****************************************************************************
\***************************************************************************/

PRID        Spy::s_pridLink     = 0;
ATOM        Spy::s_atom         = NULL;
HFONT       Spy::s_hfntDesc     = NULL;
HFONT       Spy::s_hfntDescBold = NULL;
HBRUSH      Spy::s_hbrOutline   = NULL;
int         Spy::s_cyLinePxl    = 0;
DWORD       Spy::g_tlsSpy       = (DWORD) -1;
CritLock    Spy::s_lockList;
GList<Spy>  Spy::s_lstSpys;

static const GUID guidLink = { 0xd5818900, 0xaf18, 0x4c98, { 0x87, 0x20, 0x5a, 0x32, 0x47, 0xa3, 0x1, 0x78 } }; // {D5818900-AF18-4c98-8720-5A3247A30178}

//------------------------------------------------------------------------------
Spy::Spy()
{

}


//------------------------------------------------------------------------------
Spy::~Spy()
{
    s_lockList.Enter();
    s_lstSpys.Unlink(this);
    s_lockList.Leave();
}


//------------------------------------------------------------------------------
BOOL
Spy::BuildSpy(HWND hwndParent, HGADGET hgadRoot, HGADGET hgadSelect)
{
    BOOL fSuccess = FALSE;
    Spy * pSpy, * pSpyCur;

    s_lockList.Enter();


    //
    // Perform first-time initialization for Spy
    //

    if (g_tlsSpy == -1) {
        //
        // Allocate a TLS slot for Spy.  This is DEBUG only, so we don't worry about
        // the extra cost.  However, if this ever becomes on in RETAIL, we need to
        // create a SubTread for Lava and add a Spy slot.
        //

        g_tlsSpy = TlsAlloc();
        if (g_tlsSpy == -1) {
            goto Exit;
        }


        //
        // Initialize CommCtrl.
        //

        INITCOMMONCONTROLSEX icc;
        icc.dwSize  = sizeof(icc);
        icc.dwICC   = ICC_TREEVIEW_CLASSES;

        if (!InitCommonControlsEx(&icc)) {
            goto Exit;
        }
    }


    AssertMsg(::GetGadget(hgadRoot, GG_PARENT) == NULL, "Ensure Root Gadget");

    //
    // Each Gadget subtree can only be spied on once because there are
    // back-pointers from each Gadget to the corresponding HTREEITEM's.  Need to
    // check if this Gadget subtree is already is being spied on.
    //

    pSpyCur = s_lstSpys.GetHead();
    while (pSpyCur != NULL) {
        if (pSpyCur->m_hgadRoot == hgadRoot) {
            //
            // Already exists, so don't open another Spy.
            //

            SetForegroundWindow(pSpyCur->m_hwnd);
            goto Exit;
        }

        pSpyCur = pSpyCur->GetNext();
    }


    //
    // Register a WNDCLASS to use
    //

    if (s_atom == NULL) {
        WNDCLASSEX wcex;

        ZeroMemory(&wcex, sizeof(wcex));
        wcex.cbSize = sizeof(WNDCLASSEX);

        wcex.style			= CS_HREDRAW | CS_VREDRAW;
        wcex.lpfnWndProc	= RawSpyWndProc;
        wcex.hInstance		= g_hDll;
        wcex.hCursor		= LoadCursor(NULL, IDC_ARROW);
        wcex.hbrBackground	= (HBRUSH)(COLOR_3DFACE + 1);
        wcex.lpszClassName	= "GadgetSpy (Inside)";

        s_atom = RegisterClassEx(&wcex);
        if (s_atom == NULL) {
            goto Exit;
        }
    }


    //
    // Create GDI objects used in painting
    //

    if (s_hfntDesc == NULL) {
        s_hfntDesc = UtilBuildFont(L"Tahoma", 85, FS_NORMAL, NULL);

        HDC hdc = GetGdiCache()->GetCompatibleDC();
        HFONT hfntOld = (HFONT) SelectObject(hdc, s_hfntDesc);

        TEXTMETRIC tm;
        GetTextMetrics(hdc, &tm);
        s_cyLinePxl = tm.tmHeight;

        SelectObject(hdc, hfntOld);
        GetGdiCache()->ReleaseCompatibleDC(hdc);
    }

    if (s_hfntDescBold == NULL) {
        s_hfntDescBold = UtilBuildFont(L"Tahoma", 85, FS_BOLD, NULL);
    }

    if (s_hbrOutline == NULL) {
        s_hbrOutline = CreateSolidBrush(GetSysColor(COLOR_3DSHADOW));
    }

    if (s_pridLink == 0) {
        s_pridLink = RegisterGadgetProperty(&guidLink);
    }


    //
    // Create a new Spy instance and HWND
    //

    pSpy = ProcessNew(Spy);
    if (pSpy == NULL) {
        goto Exit;
    }

    pSpy->m_hgadMsg     = CreateGadget(NULL, GC_MESSAGE, RawEventProc, pSpy);
    pSpy->m_hgadRoot    = hgadRoot;
    Verify(TlsSetValue(g_tlsSpy, pSpy));

    {
        RECT rcParentPxl;
        GetWindowRect(hwndParent, &rcParentPxl);

        HWND hwndSpy = CreateWindowEx(WS_EX_TOOLWINDOW | WS_EX_CLIENTEDGE,
                (LPCTSTR) s_atom, NULL,
                WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN, rcParentPxl.left + 20, rcParentPxl.top + 20,
                300, 500, hwndParent, NULL, g_hDll, NULL);
        if (hwndSpy == NULL) {
            ProcessDelete(Spy, pSpy);
            goto Exit;
        }

        pSpy->UpdateTitle();

        ShowWindow(hwndSpy, SW_SHOW);
        UpdateWindow(hwndSpy);
    }


    //
    // Select the specified Gadget as a starting point.  We want to check
    // if this HGADGET is actually a valid child since it may have been
    // "grabbed" at an earlier time and no longer be valid.
    //

    if (hgadSelect) {
        CheckIsChildData cicd;
        cicd.hgadCheck  = hgadSelect;
        cicd.fChild     = FALSE;

        Verify(EnumGadgets(hgadRoot, EnumCheckIsChild, &cicd, GENUM_DEEPCHILD));

        if (cicd.fChild) {
            HTREEITEM htiSelect;
            if (GetGadgetProperty(hgadSelect, s_pridLink, (void **) &htiSelect)) {
                AssertMsg(htiSelect != NULL, "Must have valid HTREEITEM");
                if (!TreeView_SelectItem(pSpy->m_hwndTree, htiSelect)) {
                    Trace("SPY: Unable to select default Gadget\n");
                }
            }
        }
    }

    s_lstSpys.Add(pSpy);

    fSuccess = TRUE;
Exit:
    s_lockList.Leave();

    return fSuccess;
}


//------------------------------------------------------------------------------
BOOL CALLBACK
Spy::EnumCheckIsChild(HGADGET hgad, void * pvData)
{
    CheckIsChildData * pcicd = (CheckIsChildData *) pvData;

    if (hgad == pcicd->hgadCheck) {
        pcicd->fChild = TRUE;
        return FALSE;  // No longer need to enumerate
    }

    return TRUE;
}


//------------------------------------------------------------------------------
void
Spy::UpdateTitle()
{
    TCHAR szTitle[256];
    wsprintf(szTitle, "Root HGADGET = 0x%p, %d Gadgets", m_hgadRoot, m_cItems);

    SetWindowText(m_hwnd, szTitle);
}


//------------------------------------------------------------------------------
LRESULT CALLBACK
Spy::RawSpyWndProc(HWND hwnd, UINT nMsg, WPARAM wParam, LPARAM lParam)
{
    Spy * pSpy = (Spy *) GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if (pSpy == NULL) {
        //
        // Creating a new Spy HWND, so hook up to the Spy object that was
        // previously created.
        //

        pSpy = reinterpret_cast<Spy *> (TlsGetValue(g_tlsSpy));
        AssertMsg(pSpy != NULL, "Ensure already created new Spy instance");
        TlsSetValue(g_tlsSpy, NULL);
        pSpy->m_hwnd = hwnd;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR) pSpy);
    }

    AssertMsg(pSpy->m_hwnd == hwnd, "Ensure HWND's match");
    return pSpy->SpyWndProc(nMsg, wParam, lParam);
}


//------------------------------------------------------------------------------
LRESULT
Spy::SpyWndProc(UINT nMsg, WPARAM wParam, LPARAM lParam)
{
    switch (nMsg)
    {
    case WM_CREATE:
        if (DefWindowProc(m_hwnd, nMsg, wParam, lParam) == -1) {
            return -1;
        }

        //
        // Setup the window
        //

        AssertMsg(m_hgadRoot != NULL, "Must already have specified Gadget");

        RECT rcClient;
        GetClientRect(m_hwnd, &rcClient);

        m_hwndTree = CreateWindowEx(0, _T("SysTreeView32"),
                NULL, WS_CHILD | WS_VISIBLE | TVS_HASBUTTONS | TVS_HASLINES | TVS_SHOWSELALWAYS,
                0, 0, rcClient.right, rcClient.bottom, m_hwnd, (HMENU)((UINT_PTR)IDC_GADGETTREE), g_hDll, NULL);

        m_hilc = ImageList_LoadImage(g_hDll, MAKEINTRESOURCE(IDB_SPYICON),
                16, 1, RGB(128, 0, 128), IMAGE_BITMAP, LR_SHARED);
        if ((m_hwndTree == NULL) || (m_hilc == NULL)) {
            return -1;
        }

        TreeView_SetImageList(m_hwndTree, m_hilc, TVSIL_NORMAL);

        EnumData ed;
        ed.pspy         = this;
        ed.htiParent    = InsertTreeItem(TVI_ROOT, m_hgadRoot);
        ed.nLevel       = 1;
        Verify(EnumGadgets(m_hgadRoot, EnumAddList, &ed, GENUM_SHALLOWCHILD));
        m_fValid        = TRUE;

        TreeView_Expand(m_hwndTree, ed.htiParent, TVE_EXPAND);
        m_hgadDetails = m_hgadRoot;
        UpdateDetails();

        break;

    case WM_DESTROY:
        SelectGadget(NULL);
        ::DeleteHandle(m_hgadMsg);
        break;

    case WM_NCDESTROY:
        ProcessDelete(Spy, this);
        goto CallDWP;

    case WM_SIZE:
        if ((wParam == SIZE_MAXIMIZED) || (wParam == SIZE_RESTORED)) {
            UpdateLayout();
        }
        break;

    case WM_PAINT:
        {
            PAINTSTRUCT ps;
            HDC hdc = BeginPaint(m_hwnd, &ps);
            OnPaint(hdc);
            EndPaint(m_hwnd, &ps);
        }
        break;

    case WM_NOTIFY:
        if (wParam == IDC_GADGETTREE) {
            NMHDR * pnm = (NMHDR *) lParam;
            if (pnm->code == TVN_SELCHANGED) {
                NMTREEVIEW * pnmtv = (NMTREEVIEW *) lParam;
                if (m_fValid) {
                    SelectGadget(GetGadget(pnmtv->itemNew.hItem));
                }
                break;
            } else if (pnm->code == TVN_KEYDOWN) {
                NMTVKEYDOWN * pnmtvkd = (NMTVKEYDOWN *) lParam;
                if (pnmtvkd->wVKey == VK_APPS) {
                    DisplayContextMenu(TRUE);
                }
            } else if (pnm->code == NM_RCLICK) {
                DisplayContextMenu(FALSE);
            }
        }
        goto CallDWP;

    default:
CallDWP:
        return DefWindowProc(m_hwnd, nMsg, wParam, lParam);
    }

    return 0;
}


//------------------------------------------------------------------------------
HRESULT CALLBACK
Spy::RawEventProc(HGADGET hgadCur, void * pvCur, EventMsg * pmsg)
{
    UNREFERENCED_PARAMETER(hgadCur);

    Spy * pSpy = (Spy *) pvCur;
    return pSpy->EventProc(pmsg);
}


//------------------------------------------------------------------------------
BOOL
IsDescendant(
    HGADGET hgadParent,
    HGADGET hgadChild)
{
    AssertMsg(hgadParent != NULL, "Must have valid parent");

    if (hgadChild == hgadParent) {
        return TRUE;
    } if (hgadChild == NULL) {
        return FALSE;
    } else {
        return IsDescendant(hgadParent, ::GetGadget(hgadChild, GG_PARENT));
    }
}


//------------------------------------------------------------------------------
HRESULT
Spy::EventProc(EventMsg * pmsg)
{
    switch (GET_EVENT_DEST(pmsg))
    {
    case GMF_DIRECT:
        //
        // Our Listener is being destroyed.  We need to detach from everything.
        //

        if (m_hgadRoot != NULL) {
            Trace("SPY: Destroying Spy MsgGadget\n");
            Verify(EnumGadgets(m_hgadRoot, EnumRemoveLink, NULL, GENUM_DEEPCHILD));
            m_hgadRoot = NULL;
        }
        break;

    case GMF_EVENT:
        switch (pmsg->nMsg)
        {
        case GM_DESTROY:
            {
                GMSG_DESTROY * pmsgD = (GMSG_DESTROY *) pmsg;
                if (pmsgD->nCode == GDESTROY_START) {
                    //
                    // Gadget is being destroyed
                    //

                    Trace("SPY: Destroying Gadget 0x%p\n", pmsg->hgadMsg);
                    HTREEITEM hti;
                    if (GetGadgetProperty(pmsg->hgadMsg, s_pridLink, (void **) &hti)) {
                        AssertMsg(hti != NULL, "Must have valid HTREEITEM");
                        Verify(EnumGadgets(pmsg->hgadMsg, EnumRemoveLink, NULL, GENUM_DEEPCHILD));
                        TreeView_DeleteItem(m_hwndTree, hti);
                    }
                }
            }
            break;

        case GM_CHANGERECT:
            if (IsDescendant(pmsg->hgadMsg, m_hgadDetails)) {
                UpdateDetails();
            }
            break;
        }
    }

    return DU_S_NOTHANDLED;
}


//------------------------------------------------------------------------------
BOOL CALLBACK
Spy::EnumAddList(HGADGET hgad, void * pvData)
{
    EnumData * ped      = (EnumData *) pvData;
    Spy * pSpy          = ped->pspy;
    HTREEITEM htiNew    = pSpy->InsertTreeItem(ped->htiParent, hgad);

    pSpy->m_cItems++;

    if (::GetGadget(hgad, GG_TOPCHILD) != NULL) {
        EnumData ed;
        ed.pspy         = pSpy;
        ed.htiParent    = htiNew;
        ed.nLevel       = ped->nLevel + 1;
        Verify(EnumGadgets(hgad, EnumAddList, &ed, GENUM_SHALLOWCHILD));

        if (ped->nLevel <= 2) {
            TreeView_Expand(pSpy->m_hwndTree, htiNew, TVE_EXPAND);
        }
    }

    return TRUE;
}


//------------------------------------------------------------------------------
BOOL CALLBACK
Spy::EnumRemoveLink(HGADGET hgad, void * pvData)
{
    UNREFERENCED_PARAMETER(pvData);

    RemoveGadgetProperty(hgad, s_pridLink);
    return TRUE;
}


//------------------------------------------------------------------------------
void
Spy::SelectGadget(HGADGET hgad)
{
    m_hgadDetails = hgad;

    {
        //
        // We are bypassinging the normal API's to directly call a
        // DEBUG-only function.  Need to lock the Context and do FULL handle
        // validation.
        //

        ContextLock cl;
        if (!cl.LockNL(ContextLock::edDefer)) {
            return;
        }
        
        DuVisual * pgadTree = ValidateVisual(hgad);
        DuVisual::DEBUG_SetOutline(pgadTree);
    }

    UpdateDetails();
}


//------------------------------------------------------------------------------
HTREEITEM
Spy::InsertTreeItem(HTREEITEM htiParent, HGADGET hgad)
{
    TCHAR szName[1024];

    GMSG_QUERYDESC msg;
    msg.cbSize      = sizeof(msg);
    msg.hgadMsg     = hgad;
    msg.nMsg        = GM_QUERY;
    msg.nCode       = GQUERY_DESCRIPTION;
    msg.szName[0]   = '\0';
    msg.szType[0]   = '\0';

    if (DUserSendEvent(&msg, 0) == DU_S_COMPLETE) {
        if (msg.szName[0] != '\0') {
            wsprintf(szName, "0x%p %S: \"%S\"", hgad, msg.szType, msg.szName);
        } else {
            wsprintf(szName, "0x%p %S", hgad, msg.szType);
        }
    } else {
        wsprintf(szName, "0x%p", hgad);
    }

    TVINSERTSTRUCT tvis;
    tvis.hParent        = htiParent;
    tvis.hInsertAfter   = TVI_LAST;
    tvis.item.mask      = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE;
    tvis.item.pszText   = szName;
    tvis.item.iImage    = iGadget;
    tvis.item.lParam    = (LPARAM) hgad;

    HTREEITEM htiNew = TreeView_InsertItem(m_hwndTree, &tvis);
    if (htiNew != NULL) {
        if (AddGadgetMessageHandler(hgad, 0, m_hgadMsg)) {
            Verify(SetGadgetProperty(hgad, s_pridLink, htiNew));
        } else {
            Trace("WARNING: Spy unable to attach handler on 0x%p\n", hgad);
        }
    }
    return htiNew;
}


//------------------------------------------------------------------------------
HGADGET
Spy::GetGadget(HTREEITEM hti)
{
    TVITEM tvi;
    tvi.hItem   = hti;
    tvi.mask    = TVIF_PARAM | TVIF_HANDLE;

    if (TreeView_GetItem(m_hwndTree, &tvi)) {
        HGADGET hgadItem = (HGADGET) tvi.lParam;
        AssertMsg(hgadItem != NULL, "All items in the tree should have a Gadget");

        return hgadItem;
    }

    return NULL;
}


//------------------------------------------------------------------------------
void
Spy::DisplayContextMenu(BOOL fViaKbd)
{
    //
    // Locate TreeView item
    //
    
    POINT ptPopup;
    ZeroMemory(&ptPopup, sizeof(ptPopup));

    HTREEITEM hti;

    if (fViaKbd) {
        //
        // Keyboard driven
        //

        hti = TreeView_GetSelection(m_hwndTree);
        if (hti != NULL) {
            RECT rc;

            TreeView_GetItemRect(m_hwndTree, hti, &rc, TRUE);

            ptPopup.x = rc.left;
            ptPopup.y = rc.bottom;
            ClientToScreen(m_hwndTree, &ptPopup);
        }
    } else {
        //
        // Mouse driven
        //

        TVHITTESTINFO tvht;

        DWORD dwPos = GetMessagePos();

        ptPopup.x = GET_X_LPARAM(dwPos);
        ptPopup.y = GET_Y_LPARAM(dwPos);

        tvht.pt = ptPopup;
        ScreenToClient(m_hwndTree, &tvht.pt);

        hti = TreeView_HitTest(m_hwndTree, &tvht);
    }


    //
    // Now have tree item and popup position
    //

    if (hti != NULL) {
        //
        // Get Gadget associated with this item
        //
        
        HGADGET hgad = GetGadget(hti);
        
        
        //
        // Create popup menu template
        //
        
        HMENU hMenu = CreatePopupMenu();
        if (hMenu != NULL) {

            BOOL fRes;

            const int cmdDetails = 10;

            fRes = AppendMenu(hMenu, MF_STRING, cmdDetails, "Details...");
            if (fRes) {

                UINT nCmd = TrackPopupMenu(hMenu, TPM_RETURNCMD | TPM_RIGHTBUTTON, ptPopup.x, ptPopup.y, 0, m_hwndTree, NULL);

                DestroyMenu(hMenu);


                //
                // Invoke commands
                //

                switch (nCmd)
                {
                case cmdDetails:
                    {
                        GMSG_QUERYDETAILS msg;
                        msg.cbSize      = sizeof(msg);
                        msg.hgadMsg     = hgad;
                        msg.nMsg        = GM_QUERY;
                        msg.nCode       = GQUERY_DETAILS;
                        msg.nType       = GQDT_HWND;
                        msg.hOwner      = m_hwndTree;

                        DUserSendEvent(&msg, 0);
                    }
                    break;
                }
            }
        }
    }
}


//------------------------------------------------------------------------------
int
Spy::NumLines(int cyPxl) const
{
    return (cyPxl - 1) / s_cyLinePxl + 1;
}


//------------------------------------------------------------------------------
void
Spy::UpdateDetails()
{
    if (m_hgadDetails == NULL) {
        return;
    }

    RECT rcPxl;
    GetGadgetRect(m_hgadDetails, &rcPxl, SGR_CONTAINER);

    wsprintf(m_szRect, "(%d, %d)-(%d, %d) %d %d",
            rcPxl.left, rcPxl.top, rcPxl.right, rcPxl.bottom,
            rcPxl.right - rcPxl.left, rcPxl.bottom - rcPxl.top);


    GMSG_QUERYDESC msg;
    msg.cbSize      = sizeof(msg);
    msg.hgadMsg     = m_hgadDetails;
    msg.nMsg        = GM_QUERY;
    msg.nCode       = GQUERY_DESCRIPTION;
    msg.szName[0]   = '\0';
    msg.szType[0]   = '\0';

    if (DUserSendEvent(&msg, 0) == DU_S_COMPLETE) {
        CopyString(m_szName, msg.szName, _countof(m_szName));
        CopyString(m_szType, msg.szType, _countof(m_szType));
    } else {
        m_szName[0] = '\0';
        m_szType[0] = '\0';
    }


    //
    // We are bypassinging the normal API's to directly call a
    // DEBUG-only function.  Need to lock the Context and do FULL handle
    // validation.
    //

    ContextLock cl;
    if (cl.LockNL(ContextLock::edNone)) {
        DuVisual * pgadTree = ValidateVisual(m_hgadDetails);
        AssertMsg(pgadTree != NULL, "Should be a valid DuVisual for Spy");
        pgadTree->DEBUG_GetStyleDesc(m_szStyle, _countof(m_szStyle));

        UpdateLayoutDesc(FALSE);
        InvalidateRect(m_hwnd, NULL, TRUE);
    }
}


//------------------------------------------------------------------------------
void
Spy::UpdateLayout()
{
    RECT rcClient;
    GetClientRect(m_hwnd, &rcClient);
    m_sizeWndPxl.cx = rcClient.right;
    m_sizeWndPxl.cy = rcClient.bottom;

    UpdateLayoutDesc(TRUE);
}


//------------------------------------------------------------------------------
void
Spy::UpdateLayoutDesc(BOOL fForceLayoutDesc)
{
    //
    // Compute the number of needed lines
    //

    int cOldLines = m_cLines;
    m_cLines = 4;

    RECT rcStyle;
    rcStyle.left    = cxBorder + cxValue;
    rcStyle.top     = 0;
    rcStyle.right   = m_sizeWndPxl.cx - cxBorder;
    rcStyle.bottom  = 10000;

    HDC hdc = GetGdiCache()->GetTempDC();
    HFONT hfntOld = (HFONT) SelectObject(hdc, s_hfntDesc);
    int nHeight = OS()->DrawText(hdc, m_szStyle, (int) wcslen(m_szStyle), &rcStyle,
            DT_CALCRECT | DT_LEFT | DT_TOP | DT_WORDBREAK);
    SelectObject(hdc, hfntOld);
    GetGdiCache()->ReleaseTempDC(hdc);

    m_cLines += NumLines(nHeight);


    //
    // Move the Tree to provide space for the description
    //

    if ((cOldLines != m_cLines) || fForceLayoutDesc) {
        m_cyDescPxl = s_cyLinePxl * m_cLines + 10;
        m_fShowDesc = m_sizeWndPxl.cy > m_cyDescPxl;

        SIZE sizeTree;
        sizeTree.cx = m_sizeWndPxl.cx;
        sizeTree.cy = m_fShowDesc ? (m_sizeWndPxl.cy - m_cyDescPxl) : m_sizeWndPxl.cy;

        MoveWindow(m_hwndTree, 0, 0, sizeTree.cx, sizeTree.cy, TRUE);
    }
}


//------------------------------------------------------------------------------
void
Spy::OnPaint(HDC hdc)
{
    HFONT hfntOld   = (HFONT) SelectObject(hdc, s_hfntDesc);
    int nOldMode    = SetBkMode(hdc, TRANSPARENT);

    RECT rcOutline;
    rcOutline.left      = 2;
    rcOutline.top       = m_sizeWndPxl.cy - m_cyDescPxl + 2;
    rcOutline.right     = m_sizeWndPxl.cx - 1;
    rcOutline.bottom    = m_sizeWndPxl.cy - 1;
    GdDrawOutlineRect(hdc, &rcOutline, s_hbrOutline);

    POINT pt;
    pt.x = cxBorder;
    pt.y = m_sizeWndPxl.cy - m_cyDescPxl + cyBorder;

    // NOTE: m_cLines should equal the number of lines displayed here

    PaintLine(hdc, &pt, "HGADGET: ",    m_hgadDetails);
    PaintLine(hdc, &pt, "Name: ",       m_szName,       FALSE, s_hfntDescBold);
    PaintLine(hdc, &pt, "Type: ",       m_szType);
    PaintLine(hdc, &pt, "Rectangle: ",  m_szRect);
    PaintLine(hdc, &pt, "Style: ",      m_szStyle,      TRUE);

    SetBkMode(hdc, nOldMode);
    SelectObject(hdc, hfntOld);
}


class CTempSelectFont
{
public:
    CTempSelectFont(HDC hdc, HFONT hfnt)
    {
        m_hdc       = hdc;
        m_fSelect   = (hfnt != NULL);
        if (m_fSelect) {
            m_hfntOld = (HFONT) SelectObject(m_hdc, hfnt);
        }
    }

    ~CTempSelectFont()
    {
        if (m_fSelect) {
            SelectObject(m_hdc, m_hfntOld);
        }
    }

    BOOL    m_fSelect;
    HDC     m_hdc;
    HFONT   m_hfntOld;
};

//------------------------------------------------------------------------------
void
Spy::PaintLine(HDC hdc, POINT * pptOffset, LPCTSTR pszName, LPCTSTR pszText, HFONT hfnt)
{
    TextOut(hdc, pptOffset->x, pptOffset->y, pszName, (int) _tcslen(pszName));

    CTempSelectFont tsf(hdc, hfnt);
    TextOut(hdc, pptOffset->x + cxValue, pptOffset->y, pszText, (int) _tcslen(pszText));

    pptOffset->y += s_cyLinePxl;
}


//------------------------------------------------------------------------------
void
Spy::PaintLine(HDC hdc, POINT * pptOffset, LPCTSTR pszName, LPCWSTR pszText, BOOL fMultiline, HFONT hfnt)
{
    TextOut(hdc, pptOffset->x, pptOffset->y, pszName, (int) _tcslen(pszName));

    CTempSelectFont tsf(hdc, hfnt);

    if (fMultiline) {
        RECT rcStyle;
        rcStyle.left    = pptOffset->x + cxValue;
        rcStyle.top     = pptOffset->y;
        rcStyle.right   = m_sizeWndPxl.cx - cxBorder;
        rcStyle.bottom  = 10000;

        int nHeight = OS()->DrawText(hdc, pszText, (int) wcslen(pszText), &rcStyle,
                DT_LEFT | DT_TOP | DT_WORDBREAK);
        pptOffset->y += NumLines(nHeight) * s_cyLinePxl;
    } else {
        OS()->TextOut(hdc, pptOffset->x + cxValue, pptOffset->y, pszText, (int) wcslen(pszText));
        pptOffset->y += s_cyLinePxl;
    }
}


//------------------------------------------------------------------------------
void
Spy::PaintLine(HDC hdc, POINT * pptOffset, LPCTSTR pszName, int nValue, HFONT hfnt)
{
    TextOut(hdc, pptOffset->x, pptOffset->y, pszName, (int) _tcslen(pszName));

    CTempSelectFont tsf(hdc, hfnt);
    TCHAR szValue[20];
    _itot(nValue, szValue, 10);
    TextOut(hdc, pptOffset->x + cxValue, pptOffset->y, szValue, (int) _tcslen(szValue));

    pptOffset->y += s_cyLinePxl;
}


//------------------------------------------------------------------------------
void
Spy::PaintLine(HDC hdc, POINT * pptOffset, LPCTSTR pszName, void * pvValue, HFONT hfnt)
{
    TextOut(hdc, pptOffset->x, pptOffset->y, pszName, (int) _tcslen(pszName));

    CTempSelectFont tsf(hdc, hfnt);
    TCHAR szValue[20];
    wsprintf(szValue, "0x%p", pvValue);
    TextOut(hdc, pptOffset->x + cxValue, pptOffset->y, szValue, (int) _tcslen(szValue));

    pptOffset->y += s_cyLinePxl;
}


#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\lava\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	Lava.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\lava\stdafx.h ===
#if !defined(LAVA__StdAfx_h__INCLUDED)
#define LAVA__StdAfx_h__INCLUDED

#pragma once

#include "CommonStdAfx.h"

#endif // LAVA__StdAfx_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\motion\action.cpp ===
#include "stdafx.h"
#include "Motion.h"
#include "Action.h"


/***************************************************************************\
*****************************************************************************
*
* class Action
*
*****************************************************************************
\***************************************************************************/

//---------------------------------------------------------------------------
Action::Action()
{
    m_cEventsInPeriod   = 0;
    m_cPeriods          = 0;
    m_fPresent          = FALSE;
    m_fDestroy          = FALSE;
    m_flLastProgress    = 0.0f;
    m_pThread           = ::GetThread();
}


//---------------------------------------------------------------------------
Action::~Action()
{
    AssertMsg(!m_DEBUG_fInFire, "Can't destroy if should be locked for Schedule::xwFireNL()\n");

    //
    // We need to notify the application that it needs to cleanup, so we 
    // can't take the Scheduler lock.
    //
    // We also need to directly setup the "Last" members so that xwFireNL() 
    // will signal the application that the Action is being destroyed.
    //

    xwFireFinalNL();

    if (m_plstParent != NULL) {
        m_plstParent->Unlink(this);
    }
}


/***************************************************************************\
*
* Action::xwDeleteHandle
*
* xwDeleteHandle() is called when the application calls ::DeleteHandle() on 
* an object.
*
\***************************************************************************/

BOOL        
Action::xwDeleteHandle()
{
    if (m_fDestroy) {
        PromptInvalid("Can not call DeleteHandle() on an Action after the final callback");
        return FALSE;
    }


    //
    // When the user calls DeleteHandle() on an Action, we need to remove it
    // from the Scheduler's lists.  It may also already be in a callback list
    // currently be processed, but that is okay.  The important thing is to
    // Unlock() the Scheduler's reference so that we can properly be destroyed.
    //

    if (m_plstParent) {
        //
        // Still in a Scheduler list, so the Scheduler still has a valid lock.
        //

        m_plstParent->Unlink(this);
        m_plstParent = NULL;
        VerifyMsg(xwUnlock(), "Should still be valid after the Scheduler Unlock()");
    }


    //
    // If the object isn't destroyed, we need to clear out the callback 
    // right now since the object that is being called is no longer valid.
    //
    // Unlike Gadgets, we actually clear out the callback here since Actions
    // are usually "simple" objects without complicated callbacks.  They do
    // guarantee that to receive all callbacks before being destroyed.  They
    // only guarentee to receive a "destroy" message when the Action is 
    // actually destroyed.
    //

    BOOL fValid = BaseObject::xwDeleteHandle();
    if (fValid) {
        //
        // The Action may still be valid if it is in a Scheduler callback list.
        //

        xwFireFinalNL();
    }

    return fValid;
}


//---------------------------------------------------------------------------
Action * 
Action::Build(
    IN  GList<Action> * plstParent,     // List containing Action
    IN  const GMA_ACTION * pma,         // Timing information
    IN  DWORD dwCurTick,                // Current time
    IN  BOOL fPresent)                  // Action is already present
{
    AssertMsg(plstParent != NULL, "Must specify a parent");

    Action * pact = ClientNew(Action);
    if (pact == NULL) {
        return NULL;
    }

    
    //
    // Copy the Action information over and determine the amount of time between
    // timeslices.
    //
    // For the default time (0), use 10 ms.
    // For no time (-1), use 0 ms.
    //
    
    pact->m_ma = *pma;
    pact->m_dwLastProcessTick = dwCurTick;

    if (pact->m_ma.dwPause == 0) {
        pact->m_ma.dwPause = 10;
    } else if (pact->m_ma.dwPause == (DWORD) -1) {
        pact->m_ma.dwPause = 0;
    }


    //
    // When creating the new Action, it needs to be in the future or the
    // beginning part of the Action may be clipped.  However, if it is actually
    // in the present, set the starting time to right now so that it doesn't
    // get delayed.
    //

    pact->m_fSingleShot = IsPresentTime(pma->flDuration);
    pact->m_plstParent  = plstParent;

    if (fPresent) {
        pact->ResetPresent(dwCurTick);
    } else {
        pact->ResetFuture(dwCurTick, TRUE);
    }
    pact->SetPresent(fPresent);

    return pact;
}


//---------------------------------------------------------------------------
void
Action::Process(DWORD dwCurTime, BOOL * pfFinishedPeriod, BOOL * pfFire)
{
    AssertWritePtr(pfFinishedPeriod);
    AssertWritePtr(pfFire);

#if DBG
    m_DEBUG_fFireValid  = FALSE;
#endif // DBG

    *pfFire             = FALSE;
    *pfFinishedPeriod   = FALSE;

    if (IsPresent()) {
        //
        // Processing a present action, so determine our progress through the
        // action and callback.
        //

        if (m_fSingleShot) {
            //
            // Single-shot Action
            //

            m_dwLastProcessTick = dwCurTime;
            m_flLastProgress    = 1.0f;
            *pfFinishedPeriod   = TRUE;
            *pfFire             = TRUE;
        } else {
            //
            // Continuous Action
            //

            int nElapsed     = ComputePastTickDelta(dwCurTime, m_dwStartTick);
            float flProgress = (nElapsed / m_ma.flDuration) / 1000.0f;
            if (flProgress > 1.0f) {
                flProgress = 1.0f;
            }

            int nDelta = ComputeTickDelta(dwCurTime, m_dwLastProcessTick + GetPauseTimeOut());
            *pfFire = nDelta > 0;  // Full pause has elapsed
            if (*pfFire) {
                 m_dwLastProcessTick = dwCurTime;
            }

            *pfFinishedPeriod   = (flProgress >= 1.0f);
            m_flLastProgress    = flProgress;
        }

#if DBG
        m_DEBUG_fFireValid  = *pfFire;
#endif // DBG
        AssertMsg(!m_fDestroy, "Should not be marked as being destroyed yet");
    } else {
        //
        // Processing a future action, so advance counters
        //

        int nElapsed        = ComputeTickDelta(dwCurTime, m_dwStartTick);
        if (nElapsed >= 0) {
            //
            // The action is now ready to be executed.
            //

            *pfFinishedPeriod = TRUE;
        }
    }
}


//---------------------------------------------------------------------------
void
Action::xwFireNL()
{
    //
    // NOTE: xwFireNL() expects that m_flLastProgress and m_fDestroy were
    // properly filled in from the last call to Process().
    //

    AssertMsg(m_DEBUG_fFireValid, "Only valid if last call to Process() returned fFire");

    GMA_ACTIONINFO mai;
    mai.hact        = (HACTION) GetHandle();
    mai.pvData      = m_ma.pvData;
    mai.flDuration  = m_ma.flDuration;
    mai.flProgress  = m_flLastProgress;
    mai.cEvent      = m_cEventsInPeriod++;
    mai.fFinished   = m_fDestroy;

#if DBG_CHECK_CALLBACKS
    BEGIN_CALLBACK()
#endif

    __try 
    {
        (m_ma.pfnProc)(&mai);
    }
    __except(StdExceptionFilter(GetExceptionInformation()))
    {
        ExitProcess(GetExceptionCode());
    }

#if DBG_CHECK_CALLBACKS
    END_CALLBACK()
#endif


    //
    // If the Action is complete and has not been manually destroyed, destroy
    // it now.  The Action will still exist until the Scheduler actually 
    // Unlock()'s it.
    //

    if ((!m_fDestroy) && m_fDeleteInFire) {
        AssertMsg(IsComplete(), "Must be complete to destroy");
        VerifyMsg(xwDeleteHandle(), "Should still be valid.");
    }
}


/***************************************************************************\
*
* Action::xwFireFinalNL
*
* xwFireFinalNL() fires the final notification to the Action.  Any 
* notifications that the Action fires after this point will be sent to
* EmptyActionProc().  This function can be called both by the destructor as
* well as xwDeleteHandle() when the object doesn't finally go away.
*
\***************************************************************************/

void
Action::xwFireFinalNL()
{
    if (m_fDestroy) {
        return;
    }

#if DBG
    m_DEBUG_fFireValid  = TRUE;
#endif // DBG

    m_flLastProgress    = 1.0f;
    m_fDestroy          = TRUE;

    xwFireNL();

    m_ma.pfnProc = EmptyActionProc;
}


//---------------------------------------------------------------------------
void
Action::EndPeriod()
{
    if ((m_ma.cRepeat != 0) && (m_ma.cRepeat != (UINT) -1)) {
        m_ma.cRepeat--;
    }
}


//---------------------------------------------------------------------------
void
Action::EmptyActionProc(GMA_ACTIONINFO * pmai)
{
    UNREFERENCED_PARAMETER(pmai);
}


#if DBG

//---------------------------------------------------------------------------
void
Action::DEBUG_MarkInFire(BOOL fInFire)
{
    AssertMsg(!fInFire != !m_DEBUG_fInFire, "Must be switching states");

    m_DEBUG_fInFire = fInFire;
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\motion\action.h ===
#if !defined(MOTION__Action_h__INCLUDED)
#define MOTION__Action_h__INCLUDED

/***************************************************************************\
*
* class Action
*
* Action maintains a single action to be called by the Scheduler at the
* appointed time.
*
\***************************************************************************/

class Action : public BaseObject, public ListNodeT<Action>
{
// Construction
public:
            Action();
    virtual ~Action();          // Must use xwUnlock() to remove
protected:
    virtual BOOL        xwDeleteHandle();
public:
    static  Action *    Build(GList<Action> * plstParent, const GMA_ACTION * pma,
                                DWORD dwCurTick, BOOL fPresent);

// Operations
public:
    inline  BOOL        IsPresent() const;
    inline  BOOL        IsComplete() const;
    inline  DWORD       GetStartTime() const;

    inline  void        SetPresent(BOOL fPresent);
    inline  void        SetParent(GList<Action> * plstParent);

    inline  float       GetStartDelay() const;
    inline  DWORD       GetIdleTimeOut(DWORD dwCurTick) const;
    inline  DWORD       GetPauseTimeOut() const;
    inline  Thread *    GetThread() const;

    inline  void        ResetPresent(DWORD dwCurTick);
    inline  void        ResetFuture(DWORD dwCurTick, BOOL fInit);
            void        Process(DWORD dwCurTick, BOOL * pfFinishedPeriod, BOOL * pfFire);
            void        EndPeriod();

            void        xwFireNL();
            void        xwFireFinalNL();

    inline  void        MarkDelete(BOOL fDelete);

#if DBG
            void        DEBUG_MarkInFire(BOOL fInFire);
#endif // DBG

// BaseObject Interface
public:
    virtual HandleType  GetHandleType() const { return htAction; }
    virtual UINT        GetHandleMask() const { return 0; }

// Implementation
protected:
    static  void CALLBACK 
                        EmptyActionProc(GMA_ACTIONINFO * pmai);


// Data
protected:
            Thread *    m_pThread;
            GMA_ACTION  m_ma;
            GList<Action> * m_plstParent;
            UINT        m_cEventsInPeriod;
            UINT        m_cPeriods;
            DWORD       m_dwStartTick;
            DWORD       m_dwLastProcessTick;
            BOOL        m_fPresent:1;
            BOOL        m_fSingleShot:1;
            BOOL        m_fDestroy:1;       // Action is being destroyed
            BOOL        m_fDeleteInFire:1;  // Action should be deleted during
                                            // the next xwFire().


            // Cache some data from last call to Process() to be used in 
            // xwFire().
#if DBG
            BOOL        m_DEBUG_fFireValid;
            BOOL        m_DEBUG_fInFire;
#endif // DBG

            float       m_flLastProgress;

    // Need to make the collection classes friends to give access to destructor.
    // NOTE: These lists should never actually destroy the objects.
    friend GList<Action>;
};

#include "Action.inl"

#endif // MOTION__Action_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\motion\colors.inl ===
#if !defined(UTIL__Colors_inl__INCLUDED)
#define UTIL__Colors_inl__INCLUDED

extern ColorInfo g_rgciStd[];

//------------------------------------------------------------------------------
inline LPCWSTR     
ColorInfo::GetName() const
{
    return m_pszName;
}


//------------------------------------------------------------------------------
inline COLORREF    
ColorInfo::GetColorI() const
{
    return m_cr;
}


//------------------------------------------------------------------------------
inline Gdiplus::Color
ColorInfo::GetColorF() const
{
    return Gdiplus::Color(GetRValue(m_cr), GetGValue(m_cr), GetBValue(m_cr));
}


//------------------------------------------------------------------------------
inline const ColorInfo * 
GdGetColorInfo(UINT c)
{
    AssertMsg(c <= SC_MAXCOLORS, "Ensure valid index");
    return &g_rgciStd[c];
}


#endif // UTIL__Colors_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\motion\colors.cpp ===
#include "stdafx.h"
#include "Motion.h"
#include "Colors.h"

ColorInfo g_rgciStd[] = {
    { L"AliceBlue",             RGB(240,248,255)    },
    { L"AntiqueWhite",          RGB(250,235,215)    },
    { L"Aqua",                  RGB(0,255,255)      },
    { L"Aquamarine",            RGB(127,255,212)    },
    { L"Azure",                 RGB(240,255,255)    },
    { L"Beige",                 RGB(245,245,220)    },
    { L"Bisque",                RGB(255,228,196)    },
    { L"Black",                 RGB(0,0,0)          },
    { L"BlanchedAlmond",        RGB(255,235,205)    },
    { L"Blue",                  RGB(0,0,255)        },
    { L"BlueViolet",            RGB(138,43,226)     },
    { L"Brown",                 RGB(165,42,42)      },
    { L"BurlyWood",             RGB(222,184,135)    },
    { L"CadetBlue",             RGB(95,158,160)     },
    { L"Chartreuse",            RGB(127,255,0)      },
    { L"Chocolate",             RGB(210,105,30)     },
    { L"Coral",                 RGB(255,127,80)     },
    { L"CornflowerBlue",        RGB(100,149,237)    },
    { L"Cornsilk",              RGB(255,248,220)    },
    { L"Crimson",               RGB(220,20,60)      },
    { L"Cyan",                  RGB(0,255,255)      },
    { L"DarkBlue",              RGB(0,0,139)        },
    { L"DarkCyan",              RGB(0,139,139)      },
    { L"DarkGoldenrod",         RGB(184,134,11)     },
    { L"DarkGray",              RGB(169,169,169)    },
    { L"DarkGreen",             RGB(0,100,0)        },
    { L"DarkKhaki",             RGB(189,183,107)    },
    { L"DarkMagenta",           RGB(139,0,139)      },
    { L"DarkOliveGreen",        RGB(85,107,47)      },
    { L"DarkOrange",            RGB(255,140,0)      },
    { L"DarkOrchid",            RGB(153,50,204)     },
    { L"DarkRed",               RGB(139,0,0)        },
    { L"DarkSalmon",            RGB(233,150,122)    },
    { L"DarkSeaGreen",          RGB(143,188,143)    },
    { L"DarkSlateBlue",         RGB(72,61,139)      },
    { L"DarkSlateGray",         RGB(47,79,79)       },
    { L"DarkTurquoise",         RGB(0,206,209)      },
    { L"DarkViolet",            RGB(148,0,211)      },
    { L"DeepPink",              RGB(255,20,147)     },
    { L"DeepSkyBlue",           RGB(0,191,255)      },
    { L"DimGray",               RGB(105,105,105)    },
    { L"DodgerBlue",            RGB(30,144,255)     },
    { L"FireBrick",             RGB(178,34,34)      },
    { L"FloralWhite",           RGB(255,250,240)    },
    { L"ForestGreen",           RGB(34,139,34)      },
    { L"Fuchsia",               RGB(255,0,255)      },
    { L"Gainsboro",             RGB(220,220,220)    },
    { L"GhostWhite",            RGB(248,248,255)    },
    { L"Gold",                  RGB(255,215,0)      },
    { L"Goldenrod",             RGB(218,165,32)     },
    { L"Gray",                  RGB(128,128,128)    },
    { L"Green",                 RGB(0,128,0)        },
    { L"GreenYellow",           RGB(173,255,47)     },
    { L"Honeydew",              RGB(240,255,240)    },
    { L"HotPink",               RGB(255,105,180)    },
    { L"IndianRed",             RGB(205,92,92)      },
    { L"Indigo",                RGB(75,0,130)       },
    { L"Ivory",                 RGB(255,255,240)    },
    { L"Khaki",                 RGB(240,230,140)    },
    { L"Lavender",              RGB(230,230,250)    },
    { L"LavenderBlush",         RGB(255,240,245)    },
    { L"LawnGreen",             RGB(124,252,0)      },
    { L"LemonChiffon",          RGB(255,250,205)    },
    { L"LightBlue",             RGB(173,216,230)    },
    { L"LightCoral",            RGB(240,128,128)    },
    { L"LightCyan",             RGB(224,255,255)    },
    { L"LightGoldenrodYellow",  RGB(250,250,210)    },
    { L"LightGreen",            RGB(144,238,144)    },
    { L"LightGrey",             RGB(211,211,211)    },
    { L"LightPink",             RGB(255,182,193)    },
    { L"LightSalmon",           RGB(255,160,122)    },
    { L"LightSeaGreen",         RGB(32,178,170)     },
    { L"LightSkyBlue",          RGB(135,206,250)    },
    { L"LightSlateGray",        RGB(119,136,153)    },
    { L"LightSteelBlue",        RGB(176,196,222)    },
    { L"LightYellow",           RGB(255,255,224)    },
    { L"Lime",                  RGB(0,255,0)        },
    { L"LimeGreen",             RGB(50,205,50)      },
    { L"Linen",                 RGB(250,240,230)    },
    { L"Magenta",               RGB(255,0,255)      },
    { L"Maroon",                RGB(128,0,0)        },
    { L"MediumAquamarine",      RGB(102,205,170)    },
    { L"MediumBlue",            RGB(0,0,205)        },
    { L"MediumOrchid",          RGB(186,85,211)     },
    { L"MediumPurple",          RGB(147,112,219)    },
    { L"MediumSeaGreen",        RGB(60,179,113)     },
    { L"MediumSlateBlue",       RGB(123,104,238)    },
    { L"MediumSpringGreen",     RGB(0,250,154)      },
    { L"MediumTurquoise",       RGB(72,209,204)     },
    { L"MediumVioletRed",       RGB(199,21,133)     },
    { L"MidnightBlue",          RGB(25,25,112)      },
    { L"MintCream",             RGB(245,255,250)    },
    { L"MistyRose",             RGB(255,228,225)    },
    { L"Moccasin",              RGB(255,228,181)    },
    { L"NavajoWhite",           RGB(255,222,173)    },
    { L"Navy",                  RGB(0,0,128)        },
    { L"OldLace",               RGB(253,245,230)    },
    { L"Olive",                 RGB(128,128,0)      },
    { L"OliveDrab",             RGB(107,142,35)     },
    { L"Orange",                RGB(255,165,0)      },
    { L"OrangeRed",             RGB(255,69,0)       },
    { L"Orchid",                RGB(218,112,214)    },
    { L"PaleGoldenrod",         RGB(238,232,170)    },
    { L"PaleGreen",             RGB(152,251,152)    },
    { L"PaleTurquoise",         RGB(175,238,238)    },
    { L"PaleVioletRed",         RGB(219,112,147)    },
    { L"PapayaWhip",            RGB(255,239,213)    },
    { L"PeachPuff",             RGB(255,218,185)    },
    { L"Peru",                  RGB(205,133,63)     },
    { L"Pink",                  RGB(255,192,203)    },
    { L"Plum",                  RGB(221,160,221)    },
    { L"PowderBlue",            RGB(176,224,230)    },
    { L"Purple",                RGB(128,0,128)      },
    { L"Red",                   RGB(255,0,0)        },
    { L"RosyBrown",             RGB(188,143,143)    },
    { L"RoyalBlue",             RGB(65,105,225)     },
    { L"SaddleBrown",           RGB(139,69,19)      },
    { L"Salmon",                RGB(250,128,114)    },
    { L"SandyBrown",            RGB(244,164,96)     },
    { L"SeaGreen",              RGB(46,139,87)      },
    { L"Seashell",              RGB(255,245,238)    },
    { L"Sienna",                RGB(160,82,45)      },
    { L"Silver",                RGB(192,192,192)    },
    { L"SkyBlue",               RGB(135,206,235)    },
    { L"SlateBlue",             RGB(106,90,205)     },
    { L"SlateGray",             RGB(112,128,144)    },
    { L"Snow",                  RGB(255,250,250)    },
    { L"SpringGreen",           RGB(0,255,127)      },
    { L"SteelBlue",             RGB(70,130,180)     },
    { L"Tan",                   RGB(210,180,140)    },
    { L"Teal",                  RGB(0,128,128)      },
    { L"Thistle",               RGB(216,191,216)    },
    { L"Tomato",                RGB(255,99,71)      },
    { L"Turquoise",             RGB(64,224,208)     },
    { L"Violet",                RGB(238,130,238)    },
    { L"Wheat",                 RGB(245,222,179)    },
    { L"White",                 RGB(255,255,255)    },
    { L"WhiteSmoke",            RGB(245,245,245)    },
    { L"Yellow",                RGB(255,255,0)      },
    { L"YellowGreen",           RGB(154,205,50)     },
};


//------------------------------------------------------------------------------
UINT
GdFindStdColor(LPCWSTR pszName)
{
    //
    // TODO: Change this to do a more efficient search:
    // - Convert name to lower-case before starting
    // - Create a hash code
    // - Perform a binary search comparing hashes
    //

    for (int idx = 0; idx <= SC_MAXCOLORS; idx++) {
        if (_wcsicmp(g_rgciStd[idx].GetName(), pszName) == 0) {
            //
            // Found match
            //

            return idx;
        }
    }

    // Can't find anything
    return (UINT) -1;
}


//------------------------------------------------------------------------------
HPALETTE    
GdGetStdPalette()
{
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\motion\colors.h ===
#if !defined(UTIL__Colors_h_INCLUDED)
#define UTIL__Colors_h_INCLUDED
#pragma once

class ColorInfo
{
// Operations
public:
    inline  LPCWSTR     GetName() const;
    inline  COLORREF    GetColorI() const;
    inline  Gdiplus::Color
                        GetColorF() const;


// Data: These must be public so that we can preinitialize them.  However, it
//       is VERY important not to directly access them.
public:
            LPCWSTR     m_pszName;
            COLORREF    m_cr;
};

inline  const ColorInfo * 
                    GdGetColorInfo(UINT c);
        UINT        GdFindStdColor(LPCWSTR pszName);
        HPALETTE    GdGetStdPalette();

#include "Colors.inl"

#endif // UTIL__Colors_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\motion\context.cpp ===
#include "stdafx.h"
#include "Motion.h"
#include "Context.h"

#include "Action.h"


/***************************************************************************\
*****************************************************************************
*
* class MotionSC
*
*****************************************************************************
\***************************************************************************/

IMPLEMENT_SUBCONTEXT(Context::slMotion, MotionSC);


//------------------------------------------------------------------------------
MotionSC::~MotionSC()
{
    //
    // NOTE: The Context (and its SubContexts) can be destroyed on a different
    // thread during destruction.  It is advisable to allocate any dangling data
    // on the Process heap so that it can be safely destroyed at this time.
    //

    for (UINT idx = 0; idx < SC_MAXCOLORS; idx++) {
        if (m_rghbrStd[idx] != NULL) {
            DeleteObject(m_rghbrStd[idx]);
        }
        if (m_rghpenStd[idx] != NULL) {
            DeleteObject(m_rghpenStd[idx]);
        }
        if (m_rgpgpbrStd[idx] != NULL) {
            delete m_rgpgpbrStd[idx];
        }
        if (m_rgpgppenStd[idx] != NULL) {
            delete m_rgpgppenStd[idx];
        }
    }
}

    
/***************************************************************************\
*
* MotionSC::OnIdle
*
* OnIdle() gives this SubContext an opportunity to perform any idle-time
* processing.  This is time when there are no more messages to process.
*
\***************************************************************************/

DWORD
MotionSC::xwOnIdleNL()
{
    int nDelta;
    DWORD dwDelay, dwCurTick;

    dwCurTick = ::GetTickCount();
    nDelta = ComputeTickDelta(dwCurTick, m_dwLastTimeslice + m_dwPauseTimeslice);
    if (nDelta >= 0) {
        //
        // The timeslice is up again, so let the Scheduler process the Actions.
        //

        dwDelay = m_sch.xwProcessActionsNL();
        m_dwLastTimeslice = dwCurTick;
    } else {
        dwDelay = (DWORD) (-nDelta);
    }

    return dwDelay;
}


/***************************************************************************\
*
* MotionSC::xwPreDestroyNL
*
* xwPreDestroyNL() gives this SubContext an opportunity to perform any cleanup 
* while the Context is still valid.  Any operations that involve callbacks
* MUST be done at this time.
*
\***************************************************************************/

void        
MotionSC::xwPreDestroyNL()
{
    //
    // When we callback to allow the SubContext's to destroy, we need to
    // grab a ContextLock so that we can defer messages.  When we leave 
    // this scope, all of these messages will be triggered.  This needs
    // to occur BEFORE the Context continues getting blown away.
    //

    ContextLock cl;
    Verify(cl.LockNL(ContextLock::edDefer, m_pParent));

    m_sch.xwPreDestroy();
}


//------------------------------------------------------------------------------
Gdiplus::Brush *
MotionSC::GetBrushF(UINT idxBrush) const
{
    AssertMsg(idxBrush <= SC_MAXCOLORS, "Ensure valid color");

    if (m_rgpgpbrStd[idxBrush] == NULL) {
        if (!ResourceManager::IsInitGdiPlus()) {
            return NULL;
        }

        m_rgpgpbrStd[idxBrush] = new Gdiplus::SolidBrush(GdGetColorInfo(idxBrush)->GetColorF());
    }

    return m_rgpgpbrStd[idxBrush];
}


//------------------------------------------------------------------------------
Gdiplus::Pen *
MotionSC::GetPenF(UINT idxPen) const
{
    AssertMsg(idxPen <= SC_MAXCOLORS, "Ensure valid color");

    if (m_rgpgppenStd[idxPen] == NULL) {
        if (!ResourceManager::IsInitGdiPlus()) {
            return NULL;
        }

        m_rgpgppenStd[idxPen] = new Gdiplus::Pen(GdGetColorInfo(idxPen)->GetColorF());
    }

    return m_rgpgppenStd[idxPen];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\motion\action.inl ===
#if !defined(MOTION__Action_inl__INCLUDED)
#define MOTION__Action_inl__INCLUDED

/***************************************************************************\
*****************************************************************************
*
* Global Functions
*
*****************************************************************************
\***************************************************************************/

/*
 * ComputeTickDelta: PORTED FROM NT-USER
 *
 * ComputeTickDelta computes a time delta between two times.  The
 * delta is defined as a 31-bit, signed value.  It is best to think of time as
 * a clock that wraps around.  The delta is the minimum distance on this circle
 * between two different places on the circle.  If the delta goes
 * counter-clockwise, it is looking at a time in the PAST and is POSITIVE.  If
 * the delta goes clockwise, it is looking at a time in the FUTURE and is
 * negative.
 *
 * It is IMPORTANT to realize that the (dwCurTime >= dwLastTime) comparison does
 * not determine the delta's sign, but only determines the operation to compute
 * the delta without an overflow occuring.
 */

//---------------------------------------------------------------------------
inline
int ComputeTickDelta(
    IN DWORD dwCurTick,
    IN DWORD dwLastTick)
{
    return (int) (dwCurTick - dwLastTick);
}


//---------------------------------------------------------------------------
inline
int ComputePastTickDelta(
    IN DWORD dwCurTick,
    IN DWORD dwLastTick)
{
    int nDelta = ComputeTickDelta(dwCurTick, dwLastTick);
    AssertMsg(nDelta >= 0, "Ensure delta occurs in the past");
    return nDelta;
}


/***************************************************************************\
*****************************************************************************
*
* class Action
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline Action * CastAction(BaseObject * pbase)
{
    if ((pbase != NULL) && (pbase->GetHandleType() == htAction)) {
        return (Action *) pbase;
    }
    return NULL;
}


//------------------------------------------------------------------------------
inline bool IsPresentTime(float fl)
{
    return (fl < 0.01f);
}


//------------------------------------------------------------------------------
inline BOOL
Action::IsPresent() const
{
    AssertMsg((!m_fPresent) || IsPresentTime(m_ma.flDelay), "Ensure delay matches if present");
    return m_fPresent;
}


//------------------------------------------------------------------------------
inline BOOL
Action::IsComplete() const
{
    return (m_ma.cRepeat == 0);
}


//------------------------------------------------------------------------------
inline DWORD       
Action::GetStartTime() const
{
    return m_dwStartTick;
}


//------------------------------------------------------------------------------
inline float       
Action::GetStartDelay() const
{
    float flDelay = m_ma.flPeriod - m_ma.flDuration;
    if (flDelay < 0.0f) {
        flDelay = 0.0f;
    }

    return flDelay;
}


//------------------------------------------------------------------------------
inline Thread *    
Action::GetThread() const
{
    return m_pThread;
}


//------------------------------------------------------------------------------
inline void        
Action::SetPresent(BOOL fPresent)
{
    m_fPresent   = fPresent;
    if (fPresent) {
        m_ma.flDelay = 0.0f;
    }
}


//---------------------------------------------------------------------------
inline void        
Action::SetParent(GList<Action> * plstParent)
{
    m_plstParent = plstParent;
}


/***************************************************************************\
*
* Action::ResetPresent
*
* ResetPresent() resets the Action's counters to be called immediately.
*
\***************************************************************************/

inline void        
Action::ResetPresent(DWORD dwCurTick)
{
    m_dwStartTick = dwCurTick;
}


/***************************************************************************\
*
* Action::ResetFuture
*
* ResetFuture() resets the Action's counters into the future for the next
* time the Action will be called.
*
\***************************************************************************/

inline void        
Action::ResetFuture(DWORD dwCurTick, BOOL fInit)
{
    float flDelay = GetStartDelay();
    if (fInit) {
        flDelay += m_ma.flDelay;
    }
    m_dwStartTick = dwCurTick + (int) (flDelay * 1000.0f);
}


//---------------------------------------------------------------------------
inline DWORD
Action::GetIdleTimeOut(DWORD dwCurTick) const
{
    //
    // Return the amount of time needed before this Action starts to get 
    // processed.  The Future is the reverse of the normal ComputeTickDelta().
    // We also need to make sure that the time returned is never in the past.
    //

    int nFuture = -ComputeTickDelta(dwCurTick, m_dwStartTick);
    return nFuture >= 0 ? (DWORD) (nFuture) : 0;
}


//---------------------------------------------------------------------------
inline DWORD
Action::GetPauseTimeOut() const
{
    //
    // Return the amount of time that the Action requests before its next
    // timeslice.  This is used to keep long-lived Actions from taking all of
    // the CPU time, but is different than IdleTimeOut which is the amount of
    // time before the Action needs to execute again.
    //

    return m_ma.dwPause;
}


//---------------------------------------------------------------------------
inline void
Action::MarkDelete(BOOL fDelete)
{
    AssertMsg(!m_fDeleteInFire, "Only should be marked to be deleted once");
    m_fDeleteInFire = fDelete;
}


#endif // MOTION__Action_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\motion\context.h ===
#if !defined(MOTION__Context_h__INCLUDED)
#define MOTION__Context_h__INCLUDED
#pragma once

#include "Scheduler.h"

/***************************************************************************\
*****************************************************************************
*
* MotionSC contains Context-specific information used by the Motion project
* in DirectUser.  This class is instantiated by the ResourceManager when it
* creates a new Context object.
*
*****************************************************************************
\***************************************************************************/

class MotionSC : public SubContext
{
// Construction
public:
    inline  MotionSC();
    virtual ~MotionSC();
    virtual void        xwPreDestroyNL();

// Operations
public:
    inline  Scheduler * GetScheduler();
    inline  DWORD       GetTimeslice();
    inline  void        SetTimeslice(DWORD dwTimeslice);

    inline  HBRUSH      GetBrushI(UINT idxBrush) const;
            Gdiplus::Brush *
                        GetBrushF(UINT idxBrush) const;
    inline  HPEN        GetPenI(UINT idxPen) const;
            Gdiplus::Pen *
                        GetPenF(UINT idxPen) const;

    virtual DWORD       xwOnIdleNL();

// Data
protected:
            Scheduler   m_sch;
            DWORD       m_dwLastTimeslice;
            DWORD       m_dwPauseTimeslice;

    //
    // NOTE: Both GDI and GDI+ lock the brush / pen objects when they are 
    // being used.  This means that if multiple threads try to use the same 
    // brush, the function calls may fail.
    //

    mutable HBRUSH      m_rghbrStd[SC_MAXCOLORS];
    mutable HPEN        m_rghpenStd[SC_MAXCOLORS];
    mutable Gdiplus::SolidBrush * 
                        m_rgpgpbrStd[SC_MAXCOLORS];
    mutable Gdiplus::Pen * 
                        m_rgpgppenStd[SC_MAXCOLORS];

};
                    
inline  MotionSC *  GetMotionSC();
inline  MotionSC *  GetMotionSC(Context * pContext);

#include "Context.inl"

#endif // MOTION__Context_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\motion\dxform3drmtrx.h ===
#if !defined(MOTION__DXForm3DRMTrx_h__INCLUDED)
#define MOTION__DXForm3DRMTrx_h__INCLUDED

#include "DXFormTrx.h"

class DXForm3DRMTrx : public DXFormTrx
{
// Construction
public:
            DXForm3DRMTrx();
    virtual ~DXForm3DRMTrx();
protected:
            BOOL        Create(const GTX_DXTX3DRM_TRXDESC * ptxData);
public:
    static  DXForm3DRMTrx * Build(const GTX_DXTX3DRM_TRXDESC * ptxData);
};

#endif // MOTION__DXForm3DRMTrx_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\motion\context.inl ===
#if !defined(MOTION__Context_inl__INCLUDED)
#define MOTION__Context_inl__INCLUDED
#pragma once

#include "Colors.h"

//------------------------------------------------------------------------------
inline MotionSC *   
GetMotionSC()
{
    return static_cast<MotionSC *> (GetContext()->GetSC(Context::slMotion));
}


//------------------------------------------------------------------------------
inline MotionSC *    
GetMotionSC(Context * pContext)
{
    return static_cast<MotionSC *> (pContext->GetSC(Context::slMotion));
}


//------------------------------------------------------------------------------
inline
MotionSC::MotionSC()
{
    m_dwLastTimeslice = ::GetTickCount();
    m_dwPauseTimeslice = 0;
}


//------------------------------------------------------------------------------
inline Scheduler * 
MotionSC::GetScheduler()
{
    return &m_sch;
}


//------------------------------------------------------------------------------
inline DWORD
MotionSC::GetTimeslice()
{
    return m_dwPauseTimeslice;
}


//------------------------------------------------------------------------------
inline void
MotionSC::SetTimeslice(DWORD dwTimeslice)
{
    m_dwPauseTimeslice = dwTimeslice;
}


//------------------------------------------------------------------------------
inline HBRUSH
MotionSC::GetBrushI(UINT idxBrush) const
{
    AssertMsg(idxBrush <= SC_MAXCOLORS, "Ensure valid color");

    if (m_rghbrStd[idxBrush] == NULL) {
        m_rghbrStd[idxBrush] = CreateSolidBrush(GdGetColorInfo(idxBrush)->GetColorI());
    }

    return m_rghbrStd[idxBrush];
}


//------------------------------------------------------------------------------
inline HPEN
MotionSC::GetPenI(UINT idxPen) const
{
    AssertMsg(idxPen <= SC_MAXCOLORS, "Ensure valid color");

    if (m_rghpenStd[idxPen] == NULL) {
        m_rghpenStd[idxPen] = CreatePen(PS_SOLID, 1, GdGetColorInfo(idxPen)->GetColorI());
    }

    return m_rghpenStd[idxPen];
}


#endif // MOTION__Context_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\motion\public.h ===
/***************************************************************************\
*
* File: Public.h
*
* Description:
* Public.h contains a list of definitions that are exposed and available
* outside this project.  Any other DirectUser project that wishes to use
* these services directly instead of going through public API's can include
* a corresponding [Project]P.h available in the \inc directory.  
* 
* Definitions that are not exposed through this file are considered project 
* specific implementation details and should not used in other projects.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(MOTION__Public_h__INCLUDED)
#define MOTION__Public_h__INCLUDED

#include "Transitions.h"
#include "Scheduler.h"
#include "Colors.h"
#include "Context.h"

#endif // MOTION__Public_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\motion\motion.h ===
/***************************************************************************\
*
* File: Motion.h
*
* Description:
* This file provides a project-wide header that is included in all source 
* files specific to this project.  It is similar to a precompiled header, 
* but is designed for more rapidly changing headers.
*
* The primary purpose of this file is to determine which DirectUser 
* projects this project has direct access to instead of going through public
* API's.  It is VERY IMPORTANT that this is as minimal as possible since
* adding a new project unnecessarily reduces the benefit of project 
* partitioning.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(MOTION__Motion_h__INCLUDED)
#define MOTION__Motion_h__INCLUDED

#define GADGET_ENABLE_DX
#define GADGET_ENABLE_COM
#define GADGET_ENABLE_TRANSITIONS
#include <DUser.h>

#include <DUserBaseP.h>
#include <DUserObjectAPIP.h>
#include <DUserServicesP.h>

#if DBG

#define PromptInvalid(comment) \
    do \
    { \
        if (IDebug_Prompt(GetDebug(), "Validation error:\r\n" comment, __FILE__, __LINE__, "DirectUser/Motion Notification")) \
            AutoDebugBreak(); \
    } while (0) \

#else // DBG

#define PromptInvalid(comment) ((void) 0)

#endif // DBG

#endif // MOTION__Motion_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\motion\dxform3drmtrx.cpp ===
#include "stdafx.h"
#include "Motion.h"
#include "DXForm3DRMTrx.h"


//**************************************************************************************************
//
// class DXForm3DRMTrx
//
//**************************************************************************************************

//------------------------------------------------------------------------------
DXForm3DRMTrx::DXForm3DRMTrx()
{

}


//------------------------------------------------------------------------------
DXForm3DRMTrx::~DXForm3DRMTrx()
{

}


//------------------------------------------------------------------------------
BOOL        
DXForm3DRMTrx::Create(const GTX_DXTX3DRM_TRXDESC * ptxData)
{
    //
    // Need to setup DxXForm's for Retained Mode before creating the actual
    // transform.
    //

    HRESULT hr;
    hr = GetDxManager()->GetTransformFactory()->SetService(SID_SDirect3DRM, ptxData->pRM, FALSE);
    if (FAILED(hr)) {
        return FALSE;
    }

    GTX_DXTX2D_TRXDESC td;
    td.tt               = GTX_TYPE_DXFORM2D;
    td.clsidTransform   = ptxData->clsidTransform;
    td.flDuration       = ptxData->flDuration;
    td.pszCopyright     = ptxData->pszCopyright;

    if (!DXFormTrx::Create(&td)) {
        return FALSE;
    }

    return TRUE;
}


//------------------------------------------------------------------------------
DXForm3DRMTrx * 
DXForm3DRMTrx::Build(const GTX_DXTX3DRM_TRXDESC * ptxData)
{
    DXForm3DRMTrx * ptrx = ClientNew(DXForm3DRMTrx);
    if (ptrx == NULL) {
        return NULL;
    }

    if (!ptrx->Create(ptxData)) {
        ClientDelete(DXForm3DRMTrx, ptrx);
        return NULL;
    }

    return ptrx;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\motion\dxformtrx.h ===
#if !defined(MOTION__DXFormTrx_h__INCLUDED)
#define MOTION__DXFormTrx_h__INCLUDED

#include "Transitions.h"

/***************************************************************************\
*
* class DXFormTrx
*
* DXFormTrx implements a DirectTransform Transition.
*
\***************************************************************************/

class DXFormTrx : public Transition
{
// Construction
public:
            DXFormTrx();
    virtual ~DXFormTrx();
protected:
            BOOL        Create(const GTX_DXTX2D_TRXDESC * ptxData);
public:
    static  DXFormTrx * Build(const GTX_DXTX2D_TRXDESC * ptxData);

// Transition Interface
protected:
    virtual BOOL        Play(const GTX_PLAY * pgx);
    virtual BOOL        GetInterface(IUnknown ** ppUnk);

    virtual BOOL        Begin(const GTX_PLAY * pgx);
    virtual BOOL        Print(float fProgress);
    virtual BOOL        End(const GTX_PLAY * pgx);

// Implementation
protected:
            BOOL        InitTrx(const GTX_PLAY * pgx);
            BOOL        InitTrxInputItem(const GTX_ITEM * pgxi, DxSurface * psur, int & cSurfaces);
            BOOL        InitTrxOutputItem(const GTX_ITEM * pgxi);
            BOOL        UninitTrx(const GTX_PLAY * pgx);
            BOOL        UninitTrxOutputItem(const GTX_ITEM * pgxi);
            BOOL        ComputeSize(const GTX_PLAY * pgx);
            BOOL        ComputeSizeItem(const GTX_ITEM * pgxi, SIZE & sizePxl) const;
            BOOL        DrawFrame(float fProgress, DxSurface * psurOut);
            BOOL        CopyGadget(DxSurface * psurDest, HGADGET hgadSrc);

// Data
protected:
            IDXTransform * m_pdxTransform;
            IDXEffect * m_pdxEffect;
            TrxBuffer * m_pbufTrx;      // Trx Buffer when playing

            float       m_flDuration;
            BOOL        m_fCache;       // Cached surfaces when finished

            POINT       m_ptOffset;
            SIZE        m_sizePxl;
            GTX_ITEM    m_gxiOutput;
            HBITMAP     m_hbmpOutOld;   // Bitmap needed to restore SelectObject()
};

#endif // MOTION__DXFormTrx_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\motion\dxformtrx.cpp ===
#include "stdafx.h"
#include "Motion.h"
#include "DXFormTrx.h"

//**************************************************************************************************
//
// class DXFormTrx
//
//**************************************************************************************************

//------------------------------------------------------------------------------
DXFormTrx::DXFormTrx()
{
    m_pdxTransform  = NULL;
    m_pdxEffect     = NULL;
}


//------------------------------------------------------------------------------
DXFormTrx::~DXFormTrx()
{
    SafeRelease(m_pdxTransform);
    SafeRelease(m_pdxEffect);
}


/***************************************************************************\
*
* DXFormTrx::Build
*
* Build() creates an initializes a new instance of DXFormTrx.
*
\***************************************************************************/

DXFormTrx *   
DXFormTrx::Build(const GTX_DXTX2D_TRXDESC * ptxData)
{
    DXFormTrx * ptrx = ClientNew(DXFormTrx);
    if (ptrx == NULL) {
        return NULL;
    }

    if (!ptrx->Create(ptxData)) {
        ClientDelete(DXFormTrx, ptrx);
        return NULL;
    }

    return ptrx;
}


//------------------------------------------------------------------------------
BOOL 
DXFormTrx::Create(const GTX_DXTX2D_TRXDESC * ptxData)
{
    // Check parameters and state
    Assert(m_pdxTransform == NULL);
    Assert(m_pdxEffect == NULL);

    //
    // Create the DX Transform
    //

    HRESULT hr;

    m_flDuration = ptxData->flDuration;

    hr = GetDxManager()->GetTransformFactory()->CreateTransform(NULL, 0, NULL, 0, 
            NULL, NULL, ptxData->clsidTransform, IID_IDXTransform, (void **)&m_pdxTransform);
    if (FAILED(hr) || (m_pdxTransform == NULL)) {
        goto Error;
    }

    hr = m_pdxTransform->QueryInterface(IID_IDXEffect, (void **)&m_pdxEffect);
    if (FAILED(hr) || (m_pdxEffect == NULL)) {
        goto Error;
    }


    m_pdxEffect->put_Duration(m_flDuration);


    //
    // Set any copyright information.  To do this, use IDispatch to at runtime 
    // search for any "Copyright" property to set.  
    //
    // Yes, this is a lot to do b/c IDispatch::Invoke() stinks.
    //

    if (ptxData->pszCopyright != NULL) {
        if (GetComManager()->Init(ComManager::sAuto)) {
            IDispatch * pdis = NULL;
            HRESULT hr = m_pdxTransform->QueryInterface(IID_IDispatch, (void **) &pdis);
            if (SUCCEEDED(hr)) {
                DISPID dispid;
                LPWSTR szMember = L"Copyright";
                hr = pdis->GetIDsOfNames(IID_NULL, &szMember, 1, LOCALE_SYSTEM_DEFAULT, &dispid);
                if (SUCCEEDED(hr)) {
                    BSTR bstrCP = GetComManager()->SysAllocString(ptxData->pszCopyright);
                    if (bstrCP != NULL) {
                        DISPPARAMS dp;
                        VARIANTARG rgvarg[1];

                        GetComManager()->VariantInit(&rgvarg[0]);
                        rgvarg[0].vt        = VT_BSTR;
                        rgvarg[0].bstrVal   = bstrCP;

                        DISPID dispidArg        = DISPID_PROPERTYPUT;
                        dp.rgvarg               = rgvarg;
                        dp.rgdispidNamedArgs    = &dispidArg;
                        dp.cArgs                = 1;
                        dp.cNamedArgs           = 1;

                        UINT nArgErr = 0;
                        hr = pdis->Invoke(dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, 
                                DISPATCH_PROPERTYPUT, &dp, NULL, NULL, &nArgErr);
                        GetComManager()->VariantClear(&rgvarg[0]);
                    }
                }

                pdis->Release();
            }
        } else {
            // Unable to initialize OLE-automation, so fail
            goto Error;
        }
    }

    return TRUE;

Error:
    SafeRelease(m_pdxTransform);
    SafeRelease(m_pdxEffect);
    return FALSE;
}


//------------------------------------------------------------------------------
BOOL        
DXFormTrx::CopyGadget(DxSurface * psurDest, HGADGET hgadSrc)
{
    BOOL fSuccess = FALSE;

    SIZE sizePxl;
    GetGadgetSize(hgadSrc, &sizePxl);

    //
    // Render the selected gadget directly onto the DxSurface.
    //

    IDXSurface * prawSur = psurDest->GetSurface();
    IDXDCLock * pdxLock = NULL;
    HRESULT hr = prawSur->LockSurfaceDC(NULL, INFINITE, DXLOCKF_READWRITE, &pdxLock);
    if (SUCCEEDED(hr) && (pdxLock != NULL)) {
        HDC hdc = pdxLock->GetDC();

        RECT rcClient;
        rcClient.left   = 0;
        rcClient.top    = 0;
        rcClient.right  = sizePxl.cx;
        rcClient.bottom = sizePxl.cy;
        DrawGadgetTree(hgadSrc, hdc, &rcClient, GDRAW_SHOW);

        pdxLock->Release();
        fSuccess = TRUE;
    }
    
    return fSuccess;
}


//------------------------------------------------------------------------------
BOOL        
DXFormTrx::InitTrx(const GTX_PLAY * pgx)
{
    HRESULT hr;

    DxSurface * psurIn0 = m_pbufTrx->GetSurface(0);
    DxSurface * psurIn1 = m_pbufTrx->GetSurface(1);
    DxSurface * psurOut = m_pbufTrx->GetSurface(2);

    if ((psurIn0 == NULL) || (psurIn1 == NULL) || (psurOut == NULL)) {
        return FALSE;
    }

    //
    // Initialize input surfaces
    //

    int cSurIn = 0;
    if (!InitTrxInputItem(&pgx->rgIn[0], psurIn0, cSurIn)) {
        goto Error;
    }
    if (!InitTrxInputItem(&pgx->rgIn[1], psurIn1, cSurIn)) {
        goto Error;
    }

    if (cSurIn <= 0) {
        goto Error;
    }


    //
    // Initialize the output surface
    //

    if (!InitTrxOutputItem(&pgx->gxiOut)) {
        goto Error;
    }

    //
    // Setup the transform
    //

    IUnknown *  rgIn[2];
    IUnknown *  rgOut[1];
    rgIn[0]     = psurIn0->GetSurface();
    rgIn[1]     = psurIn1->GetSurface();
    rgOut[0]    = psurOut->GetSurface();

    hr = m_pdxTransform->Setup(rgIn, cSurIn, rgOut, _countof(rgOut), 0);
    if (FAILED(hr)) {
        goto Error;
    }


    return TRUE;
Error:
    return FALSE;
}


//------------------------------------------------------------------------------
BOOL
DXFormTrx::InitTrxInputItem(const GTX_ITEM * pgxi, DxSurface * psur, int & cSurfaces)
{
    switch (pgxi->it)
    {
    case GTX_ITEMTYPE_NONE:
    default:
        ;
        break;

    case GTX_ITEMTYPE_BITMAP:
        {
            HBITMAP hbmp            = (HBITMAP) pgxi->pvData;
            const RECT * prcCrop    = TestFlag(pgxi->nFlags, GTX_IF_CROP) ? &pgxi->rcCrop : NULL;

            if (!psur->CopyBitmap(hbmp, prcCrop)) {
                return FALSE;
            }
            cSurfaces++;
        }
        break;

    case GTX_ITEMTYPE_HDC:
        {
            HDC hdcSrc = (HDC) pgxi->pvData;

            RECT rcCrop;
            if (TestFlag(pgxi->nFlags, GTX_IF_CROP)) {
                rcCrop = pgxi->rcCrop;
            } else {
                rcCrop.left     = m_ptOffset.x;
                rcCrop.top      = m_ptOffset.y;
                rcCrop.right    = m_ptOffset.x + m_sizePxl.cx;
                rcCrop.bottom   = m_ptOffset.y + m_sizePxl.cy;
            }

            if (!psur->CopyDC(hdcSrc, rcCrop)) {
                return FALSE;
            }
            cSurfaces++;
        }
        break;

    case GTX_ITEMTYPE_HWND:
        AssertMsg(0, "TODO: Use PrintWindow to get bitmap");
        cSurfaces++;
        break;

    case GTX_ITEMTYPE_GADGET:
        {
            // TODO: Support GTX_IF_CROP flag

            HGADGET hgad = (HGADGET) pgxi->pvData;
            if (!CopyGadget(psur, hgad)) {
                return FALSE;
            }
            cSurfaces++;
        }
        break;

    case GTX_ITEMTYPE_DXSURFACE:
        AssertMsg(0, "TODO: Copy source from DX Surface");
        cSurfaces++;
        break;
    }

    return TRUE;
}


//------------------------------------------------------------------------------
BOOL
DXFormTrx::InitTrxOutputItem(const GTX_ITEM * pgxi)
{
    switch (pgxi->it)
    {
    case GTX_ITEMTYPE_NONE:
    default:
        return FALSE;

    case GTX_ITEMTYPE_BITMAP:
        {
            HBITMAP hbmpSrc = (HBITMAP) pgxi->pvData;
            if (hbmpSrc == NULL) {
                return FALSE;
            }
            HDC hdcBmp = GetGdiCache()->GetCompatibleDC();
            if (hdcBmp == NULL) {
                return FALSE;
            }
            m_hbmpOutOld = (HBITMAP) SelectObject(hdcBmp, hbmpSrc);

            m_gxiOutput.it      = GTX_ITEMTYPE_HDC;
            m_gxiOutput.pvData  = hdcBmp;
        }
        break;

    case GTX_ITEMTYPE_HDC:
        m_gxiOutput.it      = GTX_ITEMTYPE_HDC;
        m_gxiOutput.pvData  = pgxi->pvData;
        break;

    case GTX_ITEMTYPE_HWND:
        {
            HWND hwnd = (HWND) pgxi->pvData;
            if (hwnd == NULL) {
                return FALSE;
            }

            m_gxiOutput.it      = GTX_ITEMTYPE_HDC;
            m_gxiOutput.pvData  = GetDC(hwnd);
        }
        break;

    case GTX_ITEMTYPE_GADGET:
        AssertMsg(0, "Outputing directly to a Gadget is not yet supported");
        return FALSE;

    case GTX_ITEMTYPE_DXSURFACE:
        m_gxiOutput.it      = GTX_ITEMTYPE_DXSURFACE;
        m_gxiOutput.pvData  = NULL;
        break;
    }

    AssertMsg((m_gxiOutput.it == GTX_ITEMTYPE_HDC) || 
            (m_gxiOutput.it == GTX_ITEMTYPE_DXSURFACE), "Check output is supported");
    return TRUE;
}


//------------------------------------------------------------------------------
BOOL        
DXFormTrx::UninitTrx(const GTX_PLAY * pgx)
{
    //
    // When unitializing, it is very important call IDXTransform::Setup() and 
    // have the DXForm Release() the DXSurface buffers, or they will stick 
    // around for a long time and potentially have "memory leaks".
    //

    BOOL fSuccess = TRUE;
        
    if (!UninitTrxOutputItem(&pgx->gxiOut)) {
        fSuccess = FALSE;
    }

    HRESULT hr = m_pdxTransform->Setup(NULL, 0, NULL, 0, 0);
    if (FAILED(hr)) {
        fSuccess = FALSE;
    }

    return fSuccess;
}


//------------------------------------------------------------------------------
BOOL
DXFormTrx::UninitTrxOutputItem(const GTX_ITEM * pgxi)
{
    switch (pgxi->it)
    {
    case GTX_ITEMTYPE_NONE:
    case GTX_ITEMTYPE_HDC:
    case GTX_ITEMTYPE_DXSURFACE:
    case GTX_ITEMTYPE_GADGET:
    default:
        // Nothing to do

        return TRUE;

    case GTX_ITEMTYPE_BITMAP:
        {
            HDC hdcBmp = (HDC) m_gxiOutput.pvData;

            SelectObject(hdcBmp, m_hbmpOutOld);
            GetGdiCache()->ReleaseCompatibleDC(hdcBmp);
        }
        break;

    case GTX_ITEMTYPE_HWND:
        {
            HWND hwnd   = (HWND) pgxi->pvData; 
            HDC hdc     = (HDC) m_gxiOutput.pvData;
           
            ReleaseDC(hwnd, hdc);
        }
        break;
    }

    AssertMsg((m_gxiOutput.it == GTX_ITEMTYPE_HDC) || 
            (m_gxiOutput.it == GTX_ITEMTYPE_DXSURFACE), "Check output is supported");
    return TRUE;
}


//------------------------------------------------------------------------------
BOOL
DXFormTrx::DrawFrame(float fProgress, DxSurface * psurOut)
{
    //
    // Setup the positions used for drawing.  Always draw into the upper-left
    // corner of the DX-Surfaces, but remember to offset them properly when
    // copying to the final destination.
    //

    DXVEC Placement = { DXBT_DISCRETE, 0 };
    if (FAILED(m_pdxEffect->put_Progress(fProgress))) {
        return FALSE;
    }

    CDXDBnds bnds;
    bnds.SetXYSize(m_sizePxl.cx, m_sizePxl.cy);

    if (FAILED(m_pdxTransform->Execute(NULL, &bnds, &Placement))) {
        return FALSE;
    }

    switch (m_gxiOutput.it)
    {
    case GTX_ITEMTYPE_HDC:
        {
            HDC hdcDest = (HDC) m_gxiOutput.pvData;
            DXSrcCopy(hdcDest, m_ptOffset.x, m_ptOffset.y, m_sizePxl.cx, m_sizePxl.cy, 
                    psurOut->GetSurface(), 0, 0);
        }
        break;

    case GTX_ITEMTYPE_DXSURFACE:
        AssertMsg(0, "TODO: Implement support");

        //
        // Probably just stuff the IDirectDrawSurface7 into some pointer and
        // allow the caller to copy the bits directly.
        //

        break;

    default:
    AssertMsg(0, "Unsupported output type");
    }

    return TRUE;
}


//------------------------------------------------------------------------------
BOOL
DXFormTrx::ComputeSizeItem(const GTX_ITEM * pgxi, SIZE & sizePxl) const
{
    switch (pgxi->it)
    {
    case GTX_ITEMTYPE_NONE:
    default:
        return FALSE;

    case GTX_ITEMTYPE_BITMAP:
        {
            HBITMAP hbmp;
            BITMAP bmp;
            hbmp = (HBITMAP) pgxi->pvData;
            if (GetObject(hbmp, sizeof(bmp), &bmp) > 0) {
                sizePxl.cx = bmp.bmWidth;
                sizePxl.cy = bmp.bmHeight;
            }
        }
        break;

    case GTX_ITEMTYPE_HDC:
        break;

    case GTX_ITEMTYPE_HWND:
        {
            HWND hwnd = (HWND) pgxi->pvData;
            RECT rcClient;
            GetClientRect(hwnd, &rcClient);
            sizePxl.cx = rcClient.right;
            sizePxl.cy = rcClient.bottom;
        }
        break;

    case GTX_ITEMTYPE_GADGET:
        {
            HGADGET hgad = (HGADGET) pgxi->pvData;
            GetGadgetSize(hgad, &sizePxl);
        }
        break;

    case GTX_ITEMTYPE_DXSURFACE:
        {
            // TODO: Need to query which surface type and call GetSurface() to
            // determine the dimensions

            AssertMsg(0, "TODO");
        }
        break;
    }

    return TRUE;
}


//------------------------------------------------------------------------------
BOOL   
DXFormTrx::ComputeSize(const GTX_PLAY * pgx)
{
    SIZE sizeTempPxl;

    //
    // Start off at the full desktop size.  We really want to get smaller than 
    // this, but we need to include everything.
    //

    m_ptOffset.x    = 0;
    m_ptOffset.y    = 0;
    m_sizePxl.cx    = GetSystemMetrics(SM_CXVIRTUALSCREEN);;
    m_sizePxl.cy    = GetSystemMetrics(SM_CYVIRTUALSCREEN);;


    //
    // Check if an output crop was given.  This is the most important since it
    // can radically cut down the size.
    //

    if (TestFlag(pgx->gxiOut.nFlags, GTX_IF_CROP)) {
        const RECT & rcCrop = pgx->gxiOut.rcCrop;

        m_ptOffset.x    = rcCrop.left;
        m_ptOffset.y    = rcCrop.top;
        m_sizePxl.cx    = rcCrop.right - rcCrop.left;
        m_sizePxl.cy    = rcCrop.bottom - rcCrop.top;
    }

    //
    // Determine the minimum size from the inputs and outputs
    //

    if (pgx->gxiOut.it != GTX_ITEMTYPE_HDC) {
        //
        // Not an HDC, so can potentially compute and trim the size
        //

        sizeTempPxl = m_sizePxl;
        if (!ComputeSizeItem(&pgx->gxiOut, sizeTempPxl)) {
            return FALSE;
        }
        m_sizePxl.cx = min(m_sizePxl.cx, sizeTempPxl.cx);
        m_sizePxl.cy = min(m_sizePxl.cy, sizeTempPxl.cy);
    }

    sizeTempPxl = m_sizePxl;
    if (!ComputeSizeItem(&pgx->rgIn[0], sizeTempPxl)) {
        return FALSE;
    }
    m_sizePxl.cx = min(m_sizePxl.cx, sizeTempPxl.cx);
    m_sizePxl.cy = min(m_sizePxl.cy, sizeTempPxl.cy);

    if (pgx->rgIn[1].it != GTX_ITEMTYPE_NONE) {
        sizeTempPxl = m_sizePxl;
        if (!ComputeSizeItem(&pgx->rgIn[1], sizeTempPxl)) {
            m_sizePxl.cx = min(m_sizePxl.cx, sizeTempPxl.cx);
            m_sizePxl.cy = min(m_sizePxl.cy, sizeTempPxl.cy);
        }
    }

    return TRUE;
}


//------------------------------------------------------------------------------
BOOL    
DXFormTrx::Play(const GTX_PLAY * pgx)
{
    //
    // Check if already playing.
    //

    if (m_fPlay) {
        return FALSE;
    }


    BOOL fSuccess   = FALSE;
    m_pbufTrx       = NULL;

    if (!ComputeSize(pgx)) {
        return FALSE;
    }

    m_pbufTrx;
    HRESULT hr = GetBufferManager()->BeginTransition(m_sizePxl, 3, TRUE, &m_pbufTrx);
    if (FAILED(hr)) {
        goto Cleanup;
    }

    if (!InitTrx(pgx)) {
        goto Cleanup;
    }

    //
    // Perform the transition
    //

    {
        DxSurface * psurOut = m_pbufTrx->GetSurface(2);

        DWORD dwStartTick   = GetTickCount();
        DWORD dwCurTick     = dwStartTick;
        DWORD dwDuration    = (DWORD) (m_flDuration * 1000.0f);
        m_fBackward         = (pgx->nFlags & GTX_EXEC_DIR) == GTX_EXEC_BACKWARD;
        float   fProgress;
    
        while ((dwCurTick - dwStartTick) <= dwDuration) {
            fProgress = ((float) dwCurTick - dwStartTick) / (float) dwDuration;
            if (m_fBackward) {
                fProgress = 1.0f - fProgress;
            }

            if (!DrawFrame(fProgress, psurOut)) {
                goto Cleanup;
            }
            dwCurTick = GetTickCount();
        }

        //
        // Never properly end on the dot, so force the issue.
        //

        if (m_fBackward) {
            fProgress = 0.0f;
        } else {
            fProgress = 1.0f;
        }

        if (!DrawFrame(fProgress, psurOut)) {
            goto Cleanup;
        }
    }

    fSuccess = TRUE;

Cleanup:
    UninitTrx(pgx);
    if (m_pbufTrx != NULL) {
        GetBufferManager()->EndTransition(m_pbufTrx, TestFlag(pgx->nFlags, GTX_EXEC_CACHE));
        m_pbufTrx = NULL;
    }

    return fSuccess;
}


//------------------------------------------------------------------------------
BOOL    
DXFormTrx::GetInterface(IUnknown ** ppUnk)
{
    AssertWritePtr(ppUnk);

    if (m_pdxTransform != NULL) {
        m_pdxTransform->AddRef();
        *ppUnk = m_pdxTransform;
        return TRUE;
    } else {
        return FALSE;
    }
}


//------------------------------------------------------------------------------
BOOL    
DXFormTrx::Begin(const GTX_PLAY * pgx)
{
    //
    // Check if already playing.
    //

    if (m_fPlay) {
        return FALSE;
    }


    m_pbufTrx = NULL;

    if (!ComputeSize(pgx)) {
        return FALSE;
    }

    m_pbufTrx;
    HRESULT hr = GetBufferManager()->BeginTransition(m_sizePxl, 3, TRUE, &m_pbufTrx);
    if (FAILED(hr)) {
        return FALSE;
    }

    if (!InitTrx(pgx)) {
        GetBufferManager()->EndTransition(m_pbufTrx, FALSE);
        m_pbufTrx = NULL;
        return FALSE;
    }

    m_fBackward = (pgx->nFlags & GTX_EXEC_DIR) == GTX_EXEC_BACKWARD;
    m_fPlay     = TRUE;

    return TRUE;
}


//------------------------------------------------------------------------------
BOOL    
DXFormTrx::Print(float fProgress)
{
    //
    // Ensure already playing.
    //

    if (!m_fPlay) {
        return FALSE;
    }

    if (m_fBackward) {
        fProgress = 1.0f - fProgress;
    }

    DxSurface * psurOut = m_pbufTrx->GetSurface(2);
    return DrawFrame(fProgress, psurOut);
}


//------------------------------------------------------------------------------
BOOL    
DXFormTrx::End(const GTX_PLAY * pgx)
{
    //
    // Ensure already playing.
    //

    if (!m_fPlay) {
        return FALSE;
    }

    UninitTrx(pgx);
    if (m_pbufTrx != NULL) {
        GetBufferManager()->EndTransition(m_pbufTrx, TestFlag(pgx->nFlags, GTX_EXEC_CACHE));
        m_pbufTrx = NULL;
    }

    m_fPlay = FALSE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\motion\scheduler.inl ===
#if !defined(MOTION__Scheduler_inl__INCLUDED)
#define MOTION__Scheduler_inl__INCLUDED
#pragma once

//------------------------------------------------------------------------------
inline void        
Scheduler::Enter()
{
    m_lock.Enter();

#if DBG
    InterlockedExchange(&m_DEBUG_fLocked, TRUE);
#endif // DBG
}


//------------------------------------------------------------------------------
inline void        
Scheduler::Leave()
{
#if DBG
    InterlockedExchange(&m_DEBUG_fLocked, FALSE);
#endif // DBG

    m_lock.Leave();
}


#endif // MOTION__Scheduler_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\motion\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	Motion.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\motion\scheduler.h ===
/***************************************************************************\
*
* File: Scheduler.h
*
* Description:
* Scheduler.h maintains a collection of timers that are created and used
* by the application for notifications.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(MOTION__Scheduler_h__INCLUDED)
#define MOTION__Scheduler_h__INCLUDED
#pragma once

// Forward declarations
class Action;

/***************************************************************************\
*
* class Scheduler
*
* Scheduler maintains lists of actions that are both occuring now and will
* occur in the future.
*
\***************************************************************************/

class Scheduler
{
// Construction
public:
            Scheduler();
            ~Scheduler();
            void        xwPreDestroy();

// Operations
public:
            Action *    AddAction(const GMA_ACTION * pma);
            DWORD       xwProcessActionsNL();

// Implementation
protected:
            void        xwRemoveAllActions();

    inline  void        Enter();
    inline  void        Leave();

            void        xwFireNL(GArrayF<Action *> & aracFire, BOOL fFire) const;

// Data
protected:
            CritLock        m_lock;
            GList<Action>   m_lstacPresent;
            GList<Action>   m_lstacFuture;

#if DBG
            long        m_DEBUG_fLocked;
#endif // DBG

            BOOL        m_fShutdown:1;  // Have started shutdown
};

HACTION     GdCreateAction(const GMA_ACTION * pma);

#include "Scheduler.inl"

#endif // MOTION__Scheduler_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\motion\scheduler.cpp ===
/***************************************************************************\
*
* File: Scheduler.cpp
*
* Description:
* Scheduler.cpp maintains a collection of timers that are created and used
* by the application for notifications.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Motion.h"
#include "Scheduler.h"
#include "Action.h"

#include "Context.h"

/***************************************************************************\
*****************************************************************************
*
* class Scheduler
*
*****************************************************************************
\***************************************************************************/

//---------------------------------------------------------------------------
Scheduler::Scheduler()
{
#if DBG
    m_DEBUG_fLocked = FALSE;
#endif // DBG
}


//---------------------------------------------------------------------------
Scheduler::~Scheduler()
{
    AssertMsg(m_fShutdown, "Scheduler must be manually shutdown before destruction");
}


/***************************************************************************\
*
* Scheduler::xwPreDestroy
*
* xwPreDestroy() prepares the Scheduler for destruction while it is still
* valid to callback into the application.
*
\***************************************************************************/

void        
Scheduler::xwPreDestroy()
{
    m_fShutdown = TRUE;
    xwRemoveAllActions();
}


/***************************************************************************\
*
* Scheduler::AddAction
*
* AddAction() creates and adds a new Action, using the specified information.
*
\***************************************************************************/

Action *
Scheduler::AddAction(
    IN  const GMA_ACTION * pma)         // Action information
{
    //
    // Check if shutting down and don't allow any new Actions to be created.
    //

    if (m_fShutdown) {
        return NULL;
    }

    Action * pact;
    Enter();

    //
    // Determine which list to add the action to and add it.
    //

    GList<Action> * plstParent = NULL;
    bool fPresent = IsPresentTime(pma->flDelay);
    if (fPresent) {
        plstParent = &m_lstacPresent;
    } else {
        plstParent = &m_lstacFuture;
    }

    DWORD dwCurTick = GetTickCount();
    pact = Action::Build(plstParent, pma, dwCurTick, fPresent);
    if (pact == NULL) {
        goto Exit;
    }

    plstParent->Add(pact);


    //
    // Returning out the Action, so we need to lock the HACTION that we are 
    // giving back.
    //

    pact->Lock();

Exit:
    Leave();
    return pact;
}


/***************************************************************************\
*
* Scheduler::xwRemoveAllActions
*
* xwRemoveAllActions() removes all Actions still "owned" by the Scheduler.
*
\***************************************************************************/

void
Scheduler::xwRemoveAllActions()
{
    GArrayF<Action *>   aracFire;

    //
    // NOTE: We can not fire any notifications while inside the Scheduler lock,
    // or the Scheduler could get messed up.  Instead, we need to remember all
    // of the Actions to fire, and then fire them when we leave the lock.
    //
    
    Enter();

    int cItems = m_lstacPresent.GetSize() + m_lstacFuture.GetSize();
    aracFire.SetSize(cItems);
    
    int idxAdd = 0;
    while (!m_lstacPresent.IsEmpty()) {
        Action * pact = m_lstacPresent.UnlinkHead();
        VerifyMsg(pact->xwUnlock(), "Action should still be valid");
        
        pact->SetParent(NULL);
        aracFire[idxAdd++] = pact;
    }

    while (!m_lstacFuture.IsEmpty()) {
        Action * pact = m_lstacFuture.UnlinkHead();
        VerifyMsg(pact->xwUnlock(), "Action should still be valid");
        
        pact->SetParent(NULL);
        aracFire[idxAdd++] = pact;
    }

    AssertMsg(idxAdd == cItems, "Should have added all items");

    Leave();


    //
    // Don't fire from processing when removing the Actions.  Instead, only
    // have the destructors fire when the Action finally gets cleaned up.
    //

    xwFireNL(aracFire, FALSE);
}


/***************************************************************************\
*
* Scheduler::xwProcessActionsNL
*
* xwProcessActionsNL() processes the Actions for one iteration, moving 
* between queues and firing notifications.
*
\***************************************************************************/

DWORD
Scheduler::xwProcessActionsNL()
{
    DWORD dwCurTime = ::GetTickCount();

    //
    // NOTE: We need to leave the lock when calling back as part of the
    // Action::Fire() mechanism.  To accomplish this, we store up all of the
    // Actions to callback during processing and callback after leaving the
    // lock.
    //
    // NOTE: We can not use a GList to store the actions to fire because they
    // are already stored in a list and the ListNode's would conflict.  So,
    // we use an Array instead.
    //

    GArrayF<Action *>   aracFire;

    Enter();

    Thread * pCurThread = GetThread();
    BOOL fFinishedPeriod, fFire;

    //
    // Go through and pre-process all future actions.  If a future actions 
    // time has come up, move it to the present actions list.
    //

    Action * pactCur = m_lstacFuture.GetHead();
    while (pactCur != NULL) {
        Action * pactNext = pactCur->GetNext();
        if (pactCur->GetThread() == pCurThread) {
            AssertMsg(!pactCur->IsPresent(), "Ensure action not yet present");
            pactCur->Process(dwCurTime, &fFinishedPeriod, &fFire);
            AssertMsg(! fFire, "Should not fire future Actions");
            if (fFinishedPeriod) {
                //
                // Action has reached the present
                //

                m_lstacFuture.Unlink(pactCur);
                pactCur->SetPresent(TRUE);
                pactCur->ResetPresent(dwCurTime);

                pactCur->SetParent(&m_lstacPresent);
                m_lstacPresent.Add(pactCur);
            }
        }
        pactCur = pactNext;
    }


    //
    // Go through and process all present actions
    //

    pactCur = m_lstacPresent.GetHead();
    while (pactCur != NULL) {
        Action * pactNext = pactCur->GetNext();
        if (pactCur->GetThread() == pCurThread) {
            pactCur->Process(dwCurTime, &fFinishedPeriod, &fFire);
            if (fFire) {
                //
                // The Action should be fired, so lock it and add it to the
                // delayed set of Actions to fire.  It is important to lock
                // it if the Action is finished so that it doesn't get 
                // destroyed.
                //

                pactCur->Lock();
                if (aracFire.Add(pactCur) < 0) {
                    // TODO: Unable to add the Action.  This is pretty bad.
                    // Need to figure out how to handle this situation,
                    // especially if fFinishedPeriod or the app may leak resources.
                }
            }

            if (fFinishedPeriod) {
                pactCur->SetParent(NULL);
                m_lstacPresent.Unlink(pactCur);

                pactCur->EndPeriod();

                //
                // The action has finished this round.  If it is not periodic, it
                // will be destroyed during its callback.  If it is periodic, 
                // need to re-add it to the correct (present or future) list.
                //

                if (pactCur->IsComplete()) {
                    pactCur->MarkDelete(TRUE);
                    VerifyMsg(pactCur->xwUnlock(), "Should still have HANDLE lock");
                } else {
                    GList<Action> * plstParent = NULL;
                    float flWait = pactCur->GetStartDelay();
                    BOOL fPresent = IsPresentTime(flWait);
                    if (fPresent) {
                        pactCur->ResetPresent(dwCurTime);
                        plstParent = &m_lstacPresent;
                    } else {
                        pactCur->ResetFuture(dwCurTime, FALSE);
                        plstParent = &m_lstacFuture;
                    }

                    pactCur->SetPresent(fPresent);
                    pactCur->SetParent(plstParent);
                    plstParent->Add(pactCur);
                }
            }
        }

        pactCur = pactNext;
    }


    //
    // Now that everything has been determined, determine how long until Actions
    // need to be processed again.
    //
    // NOTE: To keep Actions from overwhelming CPU and giving other tasks some
    // time to accumulate and process, we normally limit the granularity to 
    // 10 ms.  We actually should allow Actions to specify there own granularity 
    // and provide a default, probably of 10 ms for continuous Actions.
    //
    // NOTE: Is is very important that this number is not too high, because it
    // will severly limit the framerate to 1000 / delay.  After doing 
    // significant profiling work, 10 ms was found to be ideal which gives an
    // upper bound of about 100 fps.
    //

    DWORD dwTimeOut = INFINITE;
    if (m_lstacPresent.IsEmpty()) {
        //
        // There are no present Actions, so check over the future Actions to 
        // determine when the next one executes.
        //

        Action * pactCur = m_lstacFuture.GetHead();
        while (pactCur != NULL) {
            Action * pactNext = pactCur->GetNext();
            if (pactCur->GetThread() == pCurThread) {
                AssertMsg(!pactCur->IsPresent(), "Ensure action not yet present");

                DWORD dwNewTimeOut = pactCur->GetIdleTimeOut(dwCurTime);
                AssertMsg(dwTimeOut > 0, "If Action has no TimeOut, should already be present.");
                if (dwNewTimeOut < dwTimeOut) {
                    dwTimeOut = dwNewTimeOut;
                }
            }

            pactCur = pactNext;
        }
    } else {
        //
        // There are present Actions, so query their PauseTimeOut().
        //

        Action * pactCur = m_lstacPresent.GetHead();
        while (pactCur != NULL) {
            Action * pactNext = pactCur->GetNext();

            DWORD dwNewTimeout = pactCur->GetPauseTimeOut();
            if (dwNewTimeout < dwTimeOut) {
                dwTimeOut = dwNewTimeout;
                if (dwTimeOut == 0) {
                    break;
                }
            }

            pactCur = pactNext;
        }
    }


    Leave();

    xwFireNL(aracFire, TRUE);


    //
    // After actually execution the Actions, compute how much time to wait until
    // processing the next batch.  We want to subtract the time we spent 
    // processing the Actions, since if we setup timers on 50 ms intervals and
    // the processing takes 20 ms, we should only wait 30 ms.
    //
    // NOTE we need to do this AFTER calling xwFireNL(), since this fires the
    // actual notifications and does the processing.  If we compute before this,
    // the majority of the work will not be included.
    //

    DWORD dwOldCurTime  = dwCurTime;

    dwCurTime           = ::GetTickCount();  // Update the current time
    DWORD dwProcessTime = ComputeTickDelta(dwCurTime, dwOldCurTime);
    
    if (dwProcessTime < dwTimeOut) {
        dwTimeOut -= dwProcessTime;
    } else {
        dwTimeOut = 0;
    }

    return dwTimeOut;
}


//---------------------------------------------------------------------------
#if DBG
void
DEBUG_CheckValid(const GArrayF<Action *> & aracFire, int idxStart)
{
    int cActions = aracFire.GetSize();
    for (int i = idxStart; i < cActions; i++) {
        DWORD * pdw = (DWORD *) aracFire[i];
        AssertMsg(*pdw != 0xfeeefeee, "Should still be valid");
    }
}
#endif // DBG


/***************************************************************************\
*
* Scheduler::xwFireNL
*
* xwFireNL() fires notifications for the specified Actions, updating Action
* state as it is fired.
*
\***************************************************************************/

void        
Scheduler::xwFireNL(
    IN  GArrayF<Action *> & aracFire,   // Actions to notify
    IN  BOOL fFire                      // "Fire" the notification (or just update)
    ) const
{
#if DBG
    //
    // Check that each Action is only in the list once.
    //

    {
        int cActions = aracFire.GetSize();
        for (int i = 0; i < cActions; i++) {
            aracFire[i]->DEBUG_MarkInFire(TRUE);

            for (int j = i + 1; j < cActions; j++) {
                AssertMsg(aracFire[i] != aracFire[j], "Should only be in once");
            }

        }

        DEBUG_CheckValid(aracFire, 0);
    }

#endif // DBG

    //
    // Outside of the lock, so can fire the callbacks.
    //
    // NOTE: We may actually be locked by a different thread, but that's okay.
    //

    int cActions = aracFire.GetSize();
    for (int idx = 0; idx < cActions; idx++) {
        Action * pact = aracFire[idx];

#if DBG
        DEBUG_CheckValid(aracFire, idx);
#endif // DBG

        if (fFire) {
            pact->xwFireNL();
        }

#if DBG
        aracFire[idx]->DEBUG_MarkInFire(FALSE);
#endif // DBG

        pact->xwUnlock();

#if DBG
        aracFire[idx] = NULL;
#endif // DBG
    }

    //
    // NOTE: Since we pass in a Action * array, we don't need to worry about
    // the destructors getting called and the Actions being incorrectly 
    // destroyed.
    //
}


/***************************************************************************\
*****************************************************************************
*
* Global Functions
*
*****************************************************************************
\***************************************************************************/

//---------------------------------------------------------------------------
HACTION
GdCreateAction(const GMA_ACTION * pma)
{
    return (HACTION) GetHandle(GetMotionSC()->GetScheduler()->AddAction(pma));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\motion\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__B62CD79E_4F87_4613_BB92_C6DE549293E8__INCLUDED_)
#define AFX_STDAFX_H__B62CD79E_4F87_4613_BB92_C6DE549293E8__INCLUDED_

#pragma once

#include "CommonStdAfx.h"

#endif // !defined(AFX_STDAFX_H__B62CD79E_4F87_4613_BB92_C6DE549293E8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\motion\transitions.cpp ===
#include "stdafx.h"
#include "Motion.h"
#include "Transitions.h"
#include "DXFormTrx.h"
#include "DXForm3DRMTrx.h"

//**************************************************************************************************
//
// class Transition
//
//**************************************************************************************************

//------------------------------------------------------------------------------
Transition::Transition()
{
    m_fPlay     = FALSE;
    m_fBackward = FALSE;
}


//------------------------------------------------------------------------------
Transition::~Transition()
{

}


//**************************************************************************************************
//
// Public API Functions
//
//**************************************************************************************************

//------------------------------------------------------------------------------
Transition *
GdCreateTransition(const GTX_TRXDESC * ptx)
{
    // Check parameters
    if (ptx == NULL) {
        return FALSE;
    }

    //
    // Create a new transition
    //
    switch (ptx->tt)
    {
    case GTX_TYPE_DXFORM2D: 
        return DXFormTrx::Build((const GTX_DXTX2D_TRXDESC *) ptx);

    case GTX_TYPE_DXFORM3DRM:
        return DXForm3DRMTrx::Build((const GTX_DXTX3DRM_TRXDESC *) ptx);
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\motion\transitions.inl ===
#if !defined(MOTION__Transition_inl__INCLUDED)
#define MOTION__Transition_inl__INCLUDED


//------------------------------------------------------------------------------
inline Transition * CastTransition(BaseObject * pbase)
{
    if ((pbase != NULL) && (pbase->GetHandleType() == htTransition)) {
        return (Transition *) pbase;
    }
    return NULL;
}


#endif // MOTION__Transition_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\msg\classlibrary.h ===
/***************************************************************************\
*
* File: ClassLibrary.h
*
* Description:
* ClassLibrary.h defines the library of "message classes" that have been 
* registered with DirectUser.
*
*
* History:
*  8/05/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(MSG__ClassLibrary_h__INCLUDED)
#define MSG__ClassLibrary_h__INCLUDED
#pragma once

class MsgClass;

class ClassLibrary
{
// Construction
public:
            ClassLibrary();
            ~ClassLibrary();

// Operations
public:
            HRESULT     RegisterGutsNL(DUser::MessageClassGuts * pmcInfo, MsgClass ** ppmc);
            HRESULT     RegisterStubNL(DUser::MessageClassStub * pmcInfo, MsgClass ** ppmc);
            HRESULT     RegisterSuperNL(DUser::MessageClassSuper * pmcInfo, MsgClass ** ppmc);
            void        MarkInternal(HCLASS hcl);

            const MsgClass *  
                        FindClass(ATOM atomName) const;

// Implementation
protected:
            HRESULT     BuildClass(LPCWSTR pszClassName, MsgClass ** ppmc);

// Data
protected:
            CritLock    m_lock;
            GList<MsgClass> 
                        m_lstClasses;
};

ClassLibrary *
            GetClassLibrary();

#include "ClassLibrary.inl"

#endif // MSG__ClassLibrary_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\motion\transitions.h ===
#if !defined(MOTION__Transitions_h__INCLUDED)
#define MOTION__Transitions_h__INCLUDED

class DxSurface;
class TrxBuffer;

/***************************************************************************\
*
* class Transition
*
* Transition defines a base class that is used for transitions.
*
\***************************************************************************/

class Transition : public BaseObject
{
// Construction
protected:
            Transition();
    virtual ~Transition();

// BaseObject Interface
public:
    virtual HandleType  GetHandleType() const { return htTransition; }
    virtual UINT        GetHandleMask() const { return 0; }

// Transition Interface
public:
    virtual BOOL        Play(const GTX_PLAY * pgx) PURE;
    virtual BOOL        GetInterface(IUnknown ** ppUnk) PURE;

    virtual BOOL        Begin(const GTX_PLAY * pgx) PURE;
    virtual BOOL        Print(float fProgress) PURE;
    virtual BOOL        End(const GTX_PLAY * pgx) PURE;

// Data
protected:
            BOOL        m_fPlay:1;      // Transition is playing
            BOOL        m_fBackward:1;  // Playing backward
};


Transition* GdCreateTransition(const GTX_TRXDESC * ptx);

#include "Transitions.inl"

#endif // MOTION__Transitions_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\msg\classlibrary.cpp ===
/***************************************************************************\
*
* File: ClassLibrary.cpp
*
* Description:
* ClassLibrary.h implements the library of "message classes" that have been 
* registered with DirectUser.
*
*
* History:
*  8/05/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Msg.h"
#include "ClassLibrary.h"

#include "MsgClass.h"
#include "MsgObject.h"


/***************************************************************************\
*****************************************************************************
*
* class ClassLibrary
* 
*****************************************************************************
\***************************************************************************/

ClassLibrary g_cl;

ClassLibrary *
GetClassLibrary()
{
    return &g_cl;
}


/***************************************************************************\
*
* ClassLibrary::~ClassLibrary
*
* ~ClassLibrary() cleans up resources used by a ClassLibrary.
* 
\***************************************************************************/

ClassLibrary::~ClassLibrary()
{
    //
    // Need to directly destroy the MsgClass's since they are allocated in
    // process memory.
    //

    while (!m_lstClasses.IsEmpty()) {
        MsgClass * pmc = m_lstClasses.UnlinkHead();
        ProcessDelete(MsgClass, pmc);
    }
}


/***************************************************************************\
*
* ClassLibrary::RegisterGutsNL
*
* RegisterGutsNL() registers the implementation of a MsgClass so that it can
* be instantiated.  The MsgClass may already exist if it was previously
* registered, but can not be instantiated until the implementation has also
* been registered.  The implementation can only be registered once.
* 
\***************************************************************************/

HRESULT
ClassLibrary::RegisterGutsNL(
    IN OUT DUser::MessageClassGuts * pmcInfo, // Guts information
    OUT MsgClass ** ppmc)                   // OPTIONAL Class
{
    HRESULT hr = S_OK;

    m_lock.Enter();

    MsgClass * pmc;
    hr = BuildClass(pmcInfo->pszClassName, &pmc);
    if (FAILED(hr)) {
        goto Cleanup;
    }

    hr = pmc->RegisterGuts(pmcInfo);
    if (SUCCEEDED(hr) && (ppmc != NULL)) {
        *ppmc = pmc;
    }

    hr = S_OK;

Cleanup:
    m_lock.Leave();
    return hr;
}


/***************************************************************************\
*
* ClassLibrary::RegisterStubNL
*
* RegisterStubNL() registers a Stub to use a MsgClass.  Many Stubs may
* register the same MsgClass, but they can not instantiate a new instance
* until the implementation has also been registered.
* 
\***************************************************************************/

HRESULT
ClassLibrary::RegisterStubNL(
    IN OUT DUser::MessageClassStub * pmcInfo, // Stub information
    OUT MsgClass ** ppmc)                   // OPTIONAL Class
{
    HRESULT hr = S_OK;

    m_lock.Enter();

    MsgClass * pmc;
    hr = BuildClass(pmcInfo->pszClassName, &pmc);
    if (FAILED(hr)) {
        goto Cleanup;
    }

    hr = pmc->RegisterStub(pmcInfo);
    if (SUCCEEDED(hr) && (ppmc != NULL)) {
        *ppmc = pmc;
    }

    hr = S_OK;

Cleanup:
    m_lock.Leave();
    return hr;
}


/***************************************************************************\
*
* ClassLibrary::RegisterSuperNL
*
* RegisterSuperNL() registers a Super to use a MsgClass.  Many Supers may
* register the same MsgClass, but they can not instantiate a new instance
* until the implementation has also been registered.
* 
\***************************************************************************/

HRESULT
ClassLibrary::RegisterSuperNL(
    IN OUT DUser::MessageClassSuper * pmcInfo, // Super information
    OUT MsgClass ** ppmc)                   // OPTIONAL class
{
    HRESULT hr = S_OK;

    m_lock.Enter();

    MsgClass * pmc;
    hr = BuildClass(pmcInfo->pszClassName, &pmc);
    if (FAILED(hr)) {
        goto Cleanup;
    }

    hr = pmc->RegisterSuper(pmcInfo);
    if (SUCCEEDED(hr) && (ppmc != NULL)) {
        *ppmc = pmc;
    }

    hr = S_OK;

Cleanup:
    m_lock.Leave();
    return hr;
}


/***************************************************************************\
*
* ClassLibrary::MarkInternal
*
* MarkInternal() marks a class as being internally implemented inside DUser.
* 
\***************************************************************************/

void
ClassLibrary::MarkInternal(
    IN  HCLASS hcl)                     // Class to mark internal
{
    MsgClass * pmc = ValidateMsgClass(hcl);
    AssertMsg(pmc != NULL, "Must give a valid class");
    pmc->MarkInternal();

#if DBG
    if (pmc->GetSuper() != NULL) {
        AssertMsg(pmc->GetSuper()->IsInternal(), "Super class must also be internal");
    }
#endif
}


/***************************************************************************\
*
* ClassLibrary::FindClass
*
* FindClass() finds a class by name already in the library.  If the class is
* not found, NULL is returned.
* 
\***************************************************************************/

const MsgClass *  
ClassLibrary::FindClass(
    IN  ATOM atomName                   // Name of class
    ) const
{
    if (atomName == 0) {
        return NULL;
    }


    //
    // First, see if the class already exists.
    //

    MsgClass * pmcCur = m_lstClasses.GetHead();
    while (pmcCur != NULL) {
        if (pmcCur->GetName() == atomName) {
            return pmcCur;
        }

        pmcCur = pmcCur->GetNext();
    }

    return NULL;
}


/***************************************************************************\
*
* ClassLibrary::BuildClass
*
* BuildClass() adds a MsgClass into the library.  If the MsgClass already
* is in the library, the existing implementation is returned.
* 
\***************************************************************************/

HRESULT     
ClassLibrary::BuildClass(
    IN  LPCWSTR pszClassName,           // Class information
    OUT MsgClass ** ppmc)               // MsgClass
{
    //
    // Search for the class
    //

    MsgClass * pmcNew = const_cast<MsgClass *> (FindClass(FindAtomW(pszClassName)));
    if (pmcNew != NULL) {
        *ppmc = pmcNew;
        return S_OK;
    }


    //
    // Build a new class
    //

    HRESULT hr = MsgClass::Build(pszClassName, &pmcNew);
    if (FAILED(hr)) {
        return hr;
    }

    m_lstClasses.Add(pmcNew);
    *ppmc = pmcNew;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\msg\classlibrary.inl ===
/***************************************************************************\
*
* File: ClassLibrary.inl
*
* Description:
* ClassLibrary.inl implements the library of "message classes" that have been 
* registered with DirectUser.
*
*
* History:
*  8/05/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(MSG__ClassLibrary_inl__INCLUDED)
#define MSG__ClassLibrary_inl__INCLUDED
#pragma once


/***************************************************************************\
*****************************************************************************
*
* class ClassLibrary
* 
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline
ClassLibrary::ClassLibrary()
{

}


#endif // MSG__ClassLibrary_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\msg\msg.h ===
/***************************************************************************\
*
* File: Msg.h
*
* Description:
* This file provides a project-wide header that is included in all source 
* files specific to this project.  It is similar to a precompiled header, 
* but is designed for more rapidly changing headers.
*
* The primary purpose of this file is to determine which DirectUser 
* projects this project has direct access to instead of going through public
* API's.  It is VERY IMPORTANT that this is as minimal as possible since
* adding a new project unnecessarily reduces the benefit of project 
* partitioning.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(MSG__Msg_h__INCLUDED)
#define MSG__Msg_h__INCLUDED
#pragma once

#define GADGET_ENABLE_DX
#define GADGET_ENABLE_COM
#define GADGET_ENABLE_OLE
#include <DUser.h>

#include <DUserBaseP.h>
#include <DUserServicesP.h>

#if DBG

#define PromptInvalid(comment) \
    do \
    { \
        if (IDebug_Prompt(GetDebug(), "Validation error:\r\n" comment, __FILE__, __LINE__, "DirectUser/Msg Notification")) \
            AutoDebugBreak(); \
    } while (0) \

#else // DBG

#define PromptInvalid(comment) ((void) 0)

#endif // DBG

#endif // MSG__Msg_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\msg\msgclass.cpp ===
/***************************************************************************\
*
* File: MsgClass.h
*
* Description:
* MsgClass.h implements the "Message Class" object that is created for each
* different message object type.  Each object has a corresponding MsgClass
* that provides information about that object type.
*
*
* History:
*  8/05/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Msg.h"
#include "MsgClass.h"

#include "MsgTable.h"
#include "MsgObject.h"
#include "ClassLibrary.h"


/***************************************************************************\
*****************************************************************************
*
* class MsgClass
* 
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* MsgClass::~MsgClass
* 
* ~MsgClass() cleans up resources associated with a specific message class.
*
\***************************************************************************/

MsgClass::~MsgClass()
{
    //
    // Clean up internal resources
    //

    if (m_pmt != NULL) {
        m_pmt->Destroy();
    }

    DeleteAtom(m_atomName);
}


/***************************************************************************\
*
* MsgClass::Build
* 
* Build() creates a placeholder MsgClass so that we can register Stubs to be
* setup after the implementation is registered.  
*
* NOTE: We can NOT instantiate MsgObject's until the implementation has also
* been registered.
*
\***************************************************************************/

HRESULT
MsgClass::Build(
    IN  LPCWSTR pszClassName,           // Class information
    OUT MsgClass ** ppmcNew)            // New MsgClass
{
    //
    // Allocate the new MsgClass
    //

    ATOM atomName = AddAtomW(pszClassName);
    if (atomName == 0) {
        return E_OUTOFMEMORY;
    }

    MsgClass * pmcNew = ProcessNew(MsgClass);
    if (pmcNew == NULL) {
        return E_OUTOFMEMORY;
    }
    pmcNew->m_pszName   = pszClassName;
    pmcNew->m_atomName  = atomName;

    *ppmcNew = pmcNew;
    return S_OK;
}


/***************************************************************************\
*
* MsgClass::xwDeleteHandle
* 
* xwDeleteHandle() is called when the application calls ::DeleteHandle() on 
* an object.  
*
\***************************************************************************/

BOOL
MsgClass::xwDeleteHandle()
{
    //
    // MsgClass's can not be deleted externally.  Once registered, they exist
    // for the lifetime of the process.  The reason is that we don't keep track
    // of how many already created objects may be using the MsgTable owned by
    // the MsgClass.  We also would need to ensure that no classes derive from
    // this class.
    //

    return TRUE;
}


/***************************************************************************\
*
* MsgClass::RegisterGuts
* 
* RegisterGuts() is called by the implementation class to provide the "guts"
* of a MsgClass.  This fills in the outstanding information required to be
* able to actually instantiate the MsgClass.
*
\***************************************************************************/

HRESULT
MsgClass::RegisterGuts(
    IN OUT  DUser::MessageClassGuts * pmcInfo) 
                                        // Class information
{
    AssertWritePtr(pmcInfo);

    if (IsGutsRegistered()) {
        PromptInvalid("The implementation has already been registered");
        return DU_E_CLASSALREADYREGISTERED;
    }


    //
    // Find the super
    //

    const MsgClass * pmcSuper = NULL;
    if ((pmcInfo->pszSuperName != NULL) && (pmcInfo->pszSuperName[0] != '\0')) {
        pmcSuper = GetClassLibrary()->FindClass(FindAtomW(pmcInfo->pszSuperName));
        if (pmcSuper == NULL) {
            PromptInvalid("The specified super class was not found");
            return DU_E_NOTFOUND;
        }

        // TODO: Remove this requirement that the Super's guts must be 
        // registered before this class's guts can be registered.
        if (!pmcSuper->IsGutsRegistered()) {
            PromptInvalid("The super class's implementation to be registered first");
            return DU_E_CLASSNOTIMPLEMENTED;
        }
    }


    m_pmcSuper      = pmcSuper;
    m_nVersion      = pmcInfo->nClassVersion;
    m_pfnPromote    = pmcInfo->pfnPromote;
    m_pfnDemote     = pmcInfo->pfnDemote;


    //
    // Build the MsgTable for the new MsgClass
    //

    MsgTable * pmtNew;
    HRESULT hr = MsgTable::Build(pmcInfo, this, &pmtNew);
    if (FAILED(hr)) {
        return hr;
    }

    m_pmt = pmtNew;


    //
    // Return out the new MsgClass and the Super.  These are used by the
    // caller to create instances of the object.
    //

    pmcInfo->hclNew     = GetHandle();
    pmcInfo->hclSuper   = pmcSuper != NULL ? pmcSuper->GetHandle() : NULL;


    //
    // Now that the Guts are registered, we can backfill all of the Stubs
    // and Supers.  After this, we no longer need to store them.
    //

    int idx;
    int cStubs = m_arStubs.GetSize();
    for (idx = 0; idx < cStubs; idx++) {
        FillStub(m_arStubs[idx]);
    }
    m_arStubs.RemoveAll();

    int cSupers = m_arSupers.GetSize();
    for (idx = 0; idx < cSupers; idx++) {
        FillSuper(m_arSupers[idx]);
    }
    m_arSupers.RemoveAll();

    return S_OK;
}


/***************************************************************************\
*
* MsgClass::RegisterStub
*
* RegisterStub() starts the lookup process for a Stub.  If the class is 
* already setup, we can fill in immediately.  If the class isn't already 
* setup, we need to wait until it is setup and then we call post-fill-in.
* 
\***************************************************************************/

HRESULT
MsgClass::RegisterStub(
    IN OUT DUser::MessageClassStub * pmcInfo) // Stub information to be filled in
{
    //
    // NOTE: ONLY fill in the Stub if the caller is requesting the messages to
    // be filled in.  If cMsgs == 0, they are probably just preregistering the
    // class (for a Super) and have allocated pmcInfo on the stack.  In this
    // case, it is very important not to backfill it since we will trash the
    // memory.
    //

    if (pmcInfo->cMsgs > 0) {
        if (IsGutsRegistered()) {
            return FillStub(pmcInfo);
        } else {
            return m_arStubs.Add(pmcInfo) >= 0 ? S_OK : E_OUTOFMEMORY;
        }
    }

    return S_OK;
}


/***************************************************************************\
*
* MsgClass::RegisterSuper
*
* RegisterSuper() starts the lookup process for a Super.  If the class is 
* already setup, we can fill in immediately.  If the class isn't already 
* setup, we need to wait until it is setup and then we call post-fill-in.
* 
\***************************************************************************/

HRESULT
MsgClass::RegisterSuper(
    IN OUT DUser::MessageClassSuper * pmcInfo) // Stub information to be filled in
{
    if (IsGutsRegistered()) {
        FillSuper(pmcInfo);
        return S_OK;
    } else {
        return m_arSupers.Add(pmcInfo) >= 0 ? S_OK : E_OUTOFMEMORY;
    }
}


/***************************************************************************\
*
* MsgClass::xwConstructCB
* 
* xwConstructCB() is called back by a pfnPromoteClass function to 
* initialize a super class's portion of a MsgObject.  This allows the 
* specific pfnPromoteClass to decide what implementation classes to actually
* implement and which to delegate.  
* 
* The caller passes in the super-class to actually construct.
*
\***************************************************************************/

HRESULT CALLBACK 
MsgClass::xwConstructCB(
    IN  DUser::Gadget::ConstructCommand cmd, // Construction code
    IN  HCLASS hclCur,                  // Class being initialized
    IN  DUser::Gadget * pgad,           // Object being initialized
    IN  void * pvData)                  // Construction information
{
    //
    // Validate parameters.
    // NOTE: We NEED to check if hclSuper == NULL when passed in since this is
    //       LEGAL (if we don't need a super-class generated).  
    //       ValidateMsgClass() will set pmcSuper == NULL if there is a 
    //       validation error.
    //

    if (hclCur == NULL) {
        return S_OK;
    }

    const MsgClass * pmcCur = ValidateMsgClass(hclCur);
    if (pmcCur == NULL) {
        PromptInvalid("Given invalid HCLASS during xwConstructSuperCB()");
        return E_INVALIDARG;
    }

    MsgObject * pmoNew = MsgObject::CastMsgObject(pgad);
    if (pmoNew == NULL) {
        return E_INVALIDARG;
    }


    HRESULT hr;
    switch (cmd)
    {
    case DUser::Gadget::ccSuper:
        //
        // pmcCur specifies the super-class that is being asked to build its 
        // object.
        //

        hr = pmcCur->xwBuildUpObject(pmoNew, reinterpret_cast<DUser::Gadget::ConstructInfo *>(pvData));
        break;

    case DUser::Gadget::ccSetThis:
        //
        // pmcCur specifies the class to start filling the this pointers.
        //

        {
            int idxStartDepth   = pmoNew->GetBuildDepth();
            int idxEndDepth     = pmcCur->m_pmt->GetDepth();
            pmoNew->FillThis(idxStartDepth, idxEndDepth, pvData, pmcCur->m_pmt);
            hr = S_OK;
        }
        break;

    default:
        PromptInvalid("Unknown dwCode to ConstructProc()");
        hr = E_INVALIDARG;
    }

    return hr;
}


/***************************************************************************\
*
* MsgClass::xwBuildUpObject
*
* xwBuildUpObject() builds up an newly constructed MsgObject by calling
* the most-derived Promotion function to initialize the MsgObject.  This
* Promotion function will usually callback to xwConstructCB() to 
* initialize base classes that are not provided in that implementation.
* 
* As each Promotion function is called, xwBuildUpObject() will be called
* from xwConstructCB() to construct the super-classes.  As each Super
* finishes construction, the "this array" on the MsgObject is updated.
* 
\***************************************************************************/

HRESULT
MsgClass::xwBuildUpObject(
    IN  MsgObject * pmoNew,             // Object being constructed / promoted
    IN  DUser::Gadget::ConstructInfo * pciData // Construction information
    ) const
{
    //
    // For non-internally implemented classes, we need to callback to get the
    // "this" pointer to use.  The callback is responsible for calling 
    // ConstructProc(CONSTRUCT_SETTHIS) to Promote the object and set the 
    // "this" pointers.  For internally implemented classes, we use the 
    // MsgObject to directly Promote the object.
    // 
    //

    HRESULT hr;
    if (IsInternal()) {
        hr = S_OK;
    } else {
        //
        // Callback to this Super to give a chance to construct.  This is done
        // from the most derived class and relies on callbacks to initialize 
        // super-classes.
        //

        DUser::Gadget * pgad   
                    = pmoNew->GetGadget();
        HCLASS hcl  = GetHandle();
        hr          = (m_pfnPromote)(xwConstructCB, hcl, pgad, pciData);
    }

#if DBG
    if (SUCCEEDED(hr)) {
        //
        // Check that the Promotion function properly set the this pointer.
        //

        int idxObjectDepth  = pmoNew->GetDepth();
        int idxSuperDepth   = m_pmt->GetDepth();

        if (idxObjectDepth <= idxSuperDepth) {
            PromptInvalid("The PromoteProc() function did not call ConstructProc(CONSTRUCT_SETTHIS).");
        }

        if (pmoNew->GetThis(idxSuperDepth) == ULongToPtr(0xA0E20000 + idxSuperDepth)) {
            PromptInvalid("The PromoteProc() function did not call ConstructProc(CONSTRUCT_SETTHIS).");
        }
    }
#endif // DBG

    return hr;
}


/***************************************************************************\
*
* MsgClass::xwBuildObject
*
* xwBuildObject() builds and initializes a new MsgObject.
* 
\***************************************************************************/

HRESULT
MsgClass::xwBuildObject(
    OUT MsgObject ** ppmoNew,           // New MsgObject
    IN  DUser::Gadget::ConstructInfo * pciData // Construction information
    ) const
{
    //
    // Allocate a new object:
    // 1. Walk up the inheritance chain to determine the DUser object to build
    //    that will provide MsgObject functionality.
    // 2. While walking up, Verify that the guts of all classes have been 
    //    properly registered.
    // 3. Kick off the build-up process.
    //

    HRESULT hr;
    MsgObject * pmoNew              = NULL;
    const MsgClass * pmcInternal    = this;
    while (pmcInternal != NULL) {
        if (!pmcInternal->IsGutsRegistered()) {
            PromptInvalid("The implementation of the specified class has not been provided");
            return DU_E_CLASSNOTIMPLEMENTED;
        }

        if (pmcInternal->IsInternal()) {
            AssertMsg(pmoNew == NULL, "Must be NULL for internal Promote() functions");
            hr = (pmcInternal->m_pfnPromote)(NULL, pmcInternal->GetHandle(), (DUser::Gadget *) &pmoNew, pciData);
            if (FAILED(hr)) {
                return E_OUTOFMEMORY;
            }
            AssertMsg(pmoNew != NULL, "Internal objects must fill in the MsgObject");
            AssertMsg(pmoNew->GetHandleType() != htNone, "Must have a valid handle type");
            break;
        }

        pmcInternal = pmcInternal->GetSuper();
    }

    if (pmoNew == NULL) {
        AssertMsg(pmcInternal == NULL, "Internal classes must have already allocated the MsgObject");

        pmoNew = ClientNew(MsgObject);
        if (pmoNew == NULL) {
            return E_OUTOFMEMORY;
        }
    }

    hr = pmoNew->PreAllocThis(m_pmt->GetDepth() + 1);
    if (FAILED(hr)) {
        goto Error;
    }
    if (pmcInternal != NULL) {
        int cObjectDepth = pmcInternal->m_pmt->GetDepth();
        pmoNew->FillThis(0, cObjectDepth, pmoNew, pmcInternal->m_pmt);
    }

    hr = xwBuildUpObject(pmoNew, pciData);
    if (FAILED(hr)) {
        goto Error;
    }

    *ppmoNew = pmoNew;
    return S_OK;

Error:
    if (pmoNew != NULL) {
        xwTearDownObject(pmoNew);
    }
    return hr;
}


/***************************************************************************\
*
* MsgClass::xwTearDownObject
*
* xwTearDownObject() tears down a MsgObject as part of the destruction 
* process.  This gives each of the implentation classes an opportunity to
* cleanup resources, similar to having a destructor in C++.
* 
\***************************************************************************/

void
MsgClass::xwTearDownObject(
    IN  MsgObject * pmoNew              // Object being destroyed.
    ) const
{
    DUser::Gadget * pgad 
                = pmoNew->GetGadget();
    int idxThis = m_pmt->GetDepth();

    const MsgClass * pmcCur = this;
    const MsgClass * pmcNext, * pmcTest;
    while (pmcCur != NULL) {
        HCLASS hcl = pmcCur->GetHandle();
        void * pvThis = pmoNew->GetThis(idxThis);
        hcl = (pmcCur->m_pfnDemote)(hcl, pgad, pvThis);


        //
        // Determine how many class to remove by how far up the chain this 
        // MsgClass is.
        // - TODO: Need to check that returned class is actually in the chain.
        //

        pmcNext = ValidateMsgClass(hcl);
        if ((hcl != NULL) && (pmcNext == NULL)) {
            PromptInvalid("Incorrect HCLASS returned from Demote function.  Object will not be properly destroyed.");
        }

        pmcTest = pmcCur;
        int cDepth = 0;
        while ((pmcTest != NULL) && (pmcTest != pmcNext)) {
            cDepth++;
            pmcTest = pmcTest->m_pmcSuper;
        }

        pmoNew->Demote(cDepth);
        idxThis -= cDepth;

        pmcCur = pmcNext;
    }
}


/***************************************************************************\
*
* MsgClass::FillStub
*
* FillStub() provides the calling stub with information about a previously
* registered MsgClass.
* 
\***************************************************************************/

HRESULT
MsgClass::FillStub(
    IN OUT DUser::MessageClassStub * pmcInfo // Stub information to be filled in
    ) const
{
    HRESULT hr = S_OK;

    ATOM atomMsg;
    int idxSlot;
    int cbBeginOffset = sizeof(MsgTable);

    DUser::MessageInfoStub * rgMsgInfo = pmcInfo->rgMsgInfo;
    int cMsgs = pmcInfo->cMsgs;
    for (int idx = 0; idx < cMsgs; idx++) {
        if (((atomMsg = FindAtomW(rgMsgInfo[idx].pszMsgName)) == 0) || 
                ((idxSlot = m_pmt->FindIndex(atomMsg)) < 0)) {

            //
            // Could not find the function, so store a -1 to signal that this
            // slot with the error.
            //

            PromptInvalid("Unable to find message during lookup");
            hr = DU_E_MESSAGENOTFOUND;
            rgMsgInfo[idx].cbSlotOffset = -1;
        } else {
            //
            // Successfully found the function.  We need to store the offset
            // to the slot so that it can be directly accessed without any math
            // or special knowledge of our internals.
            //

            int cbSlotOffset = idxSlot * sizeof(MsgSlot) + cbBeginOffset;
            rgMsgInfo[idx].cbSlotOffset = cbSlotOffset;
        }
    }

    return hr;
}


/***************************************************************************\
*
* MsgClass::FillSuper
*
* FillStub() provides the calling super with information about a previously
* registered MsgClass.
* 
\***************************************************************************/

void
MsgClass::FillSuper(
    IN OUT DUser::MessageClassSuper * pmcInfo // Super information to be filled in
    ) const
{
    pmcInfo->pmt = m_pmt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\msg\msgclass.h ===
/***************************************************************************\
*
* File: MsgClass.h
*
* Description:
* MsgClass.h defines the "Message Class" object that is created for each
* different message object type.  Each object has a corresponding MsgClass
* that provides information about that object type.
*
*
* History:
*  8/05/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(MSG__MsgClass_h__INCLUDED)
#define MSG__MsgClass_h__INCLUDED
#pragma once

class MsgTable;
class MsgObject;

class MsgClass : 
    public BaseObject,
    public ListNodeT<MsgClass>
{
// Construction
public:
    inline  MsgClass();
            ~MsgClass();
    static  HRESULT     Build(LPCWSTR pszClassName, MsgClass ** ppmcNew);
    virtual BOOL        xwDeleteHandle();

// BaseObject
public:
    virtual HandleType  GetHandleType() const { return htMsgClass; }
    virtual UINT        GetHandleMask() const { return 0; }
    inline  HCLASS      GetHandle() const;

// Operations
public:
    inline  ATOM        GetName() const;
    inline  const MsgTable *  
                        GetMsgTable() const;
    inline  const MsgClass *
                        GetSuper() const;
    inline  BOOL        IsGutsRegistered() const;
    inline  BOOL        IsInternal() const;
    inline  void        MarkInternal();

            HRESULT     RegisterGuts(DUser::MessageClassGuts * pmcInfo);
            HRESULT     RegisterStub(DUser::MessageClassStub * pmcInfo);
            HRESULT     RegisterSuper(DUser::MessageClassSuper * pmcInfo);

            HRESULT     xwBuildObject(MsgObject ** ppmoNew, DUser::Gadget::ConstructInfo * pciData) const;
            void        xwTearDownObject(MsgObject * pmoNew) const;

// Implementation
protected:
    static  HRESULT CALLBACK 
                        xwConstructCB(DUser::Gadget::ConstructCommand cmd, HCLASS hclCur, DUser::Gadget * pgad, void * pvData);
            HRESULT     xwBuildUpObject(MsgObject * pmoNew, DUser::Gadget::ConstructInfo * pciData) const;
            HRESULT     FillStub(DUser::MessageClassStub * pmcInfo) const;
            void        FillSuper(DUser::MessageClassSuper * pmcInfo) const;

// Data
protected:
            ATOM        m_atomName;
            LPCWSTR     m_pszName;
            int         m_nVersion;
            const MsgClass *  
                        m_pmcSuper;
            MsgTable *  m_pmt;
            DUser::PromoteProc 
                        m_pfnPromote;
            DUser::DemoteProc  
                        m_pfnDemote;

            GArrayS<DUser::MessageClassStub *, ProcessHeap>
                        m_arStubs;
            GArrayS<DUser::MessageClassSuper *, ProcessHeap>
                        m_arSupers;

            BOOL        m_fInternal:1;
};

#include "MsgClass.inl"

#endif // MSG__MsgClass_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\msg\msgobject.inl ===
/***************************************************************************\
*
* File: MsgObject.inl
*
* Description:
* MsgObject.inl implements the "Message Object" class that is used to receive
* messages in DirectUser.  This object is created for each instance of a
* class that is instantiated.
*
*
* History:
*  8/05/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(MSG__MsgObject_inl__INCLUDED)
#define MSG__MsgObject_inl__INCLUDED
#pragma once

#include "MsgTable.h"

/***************************************************************************\
*****************************************************************************
*
* class MsgObject
* 
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline MsgObject * 
CastMsgObject(BaseObject * pbase)
{
    if ((pbase != NULL) && TestFlag(pbase->GetHandleMask(), hmMsgObject)) {
        return (MsgObject *) pbase;
    }
    return NULL;
}


//------------------------------------------------------------------------------
inline const MsgObject * 
CastMsgObject(const BaseObject * pbase)
{
    if ((pbase != NULL) && TestFlag(pbase->GetHandleMask(), hmMsgObject)) {
        return (const MsgObject *) pbase;
    }
    return NULL;
}


//------------------------------------------------------------------------------
inline MsgObject * 
ValidateMsgObject(HGADGET hgad)
{
    return CastMsgObject(BaseObject::ValidateHandle(hgad));
}




//------------------------------------------------------------------------------
inline
MsgObject::MsgObject()
{

}


//------------------------------------------------------------------------------
inline
MsgObject::~MsgObject()
{

}


//------------------------------------------------------------------------------
inline MsgObject * 
MsgObject::RawCastMsgObject(DUser::Gadget * pg)
{
    Assert(pg != NULL);
    return reinterpret_cast<MsgObject *> (((BYTE *) pg) - offsetof(MsgObject, m_emo));
}


//------------------------------------------------------------------------------
inline DUser::Gadget *    
MsgObject::RawCastGadget(MsgObject * pmo)
{
    Assert(pmo != NULL);
    return reinterpret_cast<DUser::Gadget *> (((BYTE *) pmo) + offsetof(MsgObject, m_emo));
}


//------------------------------------------------------------------------------
inline DUser::Gadget *
MsgObject::CastGadget(HGADGET hgad)
{
    return CastGadget(ValidateMsgObject(hgad));
}


//------------------------------------------------------------------------------
inline DUser::Gadget *
MsgObject::CastGadget(MsgObject * pmo)
{
    if (pmo == NULL) {
        return NULL;
    } else {
        return RawCastGadget(pmo);
    }
}


//------------------------------------------------------------------------------
inline HGADGET
MsgObject::CastHandle(DUser::Gadget * pg)
{
    if (pg == NULL) {
        return NULL;
    } else {
        return (HGADGET) RawCastMsgObject(pg)->GetHandle();
    }
}


//------------------------------------------------------------------------------
inline HGADGET
MsgObject::CastHandle(MsgObject * pmo)
{
    if (pmo == NULL) {
        return NULL;
    } else {
        return (HGADGET) pmo->GetHandle();
    }
}


//------------------------------------------------------------------------------
inline MsgObject *
MsgObject::CastMsgObject(DUser::Gadget * pg)
{
    if (pg == NULL) {
        return NULL;
    } else {
        return RawCastMsgObject(pg);
    }
}


//------------------------------------------------------------------------------
inline MsgObject *
MsgObject::CastMsgObject(HGADGET hgad)
{
    return ValidateMsgObject(hgad);
}


//------------------------------------------------------------------------------
inline DUser::Gadget *
MsgObject::GetGadget() const
{
    return RawCastGadget(const_cast<MsgObject *>(this));
}


//------------------------------------------------------------------------------
inline HRESULT
MsgObject::PreAllocThis(int cSlots)
{
#if DBG
    AssertMsg(m_emo.m_arpThis.GetSize() == 0, "Only can preallocate once");
#endif

    BOOL fSuccess = m_emo.m_arpThis.SetSize(cSlots);

#if DBG
    if (fSuccess) {
        for (int idxSlot = 0 ; idxSlot < cSlots; idxSlot++) {
            m_emo.m_arpThis[idxSlot] = ULongToPtr(0xA0E20000 + idxSlot);
        }
    }
#endif

    return fSuccess ? S_OK : E_OUTOFMEMORY;
}


//------------------------------------------------------------------------------
inline void
MsgObject::FillThis(int idxSlotStart, int idxSlotEnd, void * pvThis, const MsgTable * pmtNew)
{
    AssertMsg(idxSlotStart <= idxSlotEnd, "Must give valid indicies");
    AssertMsg(idxSlotEnd < m_emo.m_arpThis.GetSize(), "Must preallocate this array");

    for (int idxSlot = idxSlotStart; idxSlot <= idxSlotEnd; idxSlot++) {
        AssertMsg(m_emo.m_arpThis[idxSlot] == ULongToPtr(0xA0E20000 + idxSlot), 
                "Slot must not be already set");
        m_emo.m_arpThis[idxSlot] = pvThis;
    }
    m_emo.m_pmt = pmtNew;
}


//------------------------------------------------------------------------------
inline HRESULT
MsgObject::Promote(void * pvThis, const MsgTable * pmtNew)
{
    int idxAdd = m_emo.m_arpThis.Add(pvThis);
    if (idxAdd < 0) {
        return E_OUTOFMEMORY;
    }

    m_emo.m_pmt = pmtNew;
    return S_OK;
}


//------------------------------------------------------------------------------
inline void
MsgObject::Demote(int cLevels)
{
    int cThis = m_emo.m_arpThis.GetSize();
    AssertMsg(cThis >= 1, "Must have been previously promoted");
    AssertMsg(cLevels <= cThis, "Can only remove as many levels as available");

    Verify(m_emo.m_arpThis.SetSize(cThis - cLevels));
}


//------------------------------------------------------------------------------
inline void * 
MsgObject::GetThis(int idxThis) const
{
    return m_emo.m_arpThis[idxThis];
}


//------------------------------------------------------------------------------
inline int
MsgObject::GetDepth() const
{
    return m_emo.m_arpThis.GetSize();
}


//------------------------------------------------------------------------------
inline int
MsgObject::GetBuildDepth() const
{
    return m_emo.m_pmt != NULL ? m_emo.m_pmt->GetDepth() + 1 : 0;
}


//------------------------------------------------------------------------------
inline void
MsgObject::InvokeMethod(
    IN  MethodMsg * pmsg                // Method to invoke
    ) const
{
    GetGadget()->CallStubMethod(pmsg);
}


//------------------------------------------------------------------------------
inline DUser::Gadget *
MsgObject::CastClass(const MsgClass * pmcTest) const
{
    if (InstanceOf(pmcTest)) {
        return GetGadget();
    } else {
        return NULL;
    }
}


#endif // MSG__MsgObject_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\msg\msgtable.cpp ===
/***************************************************************************\
*
* File: MsgTable.cpp
*
* Description:
* MsgTable.cpp implements the "Message Table" object that provide a 
* dynamically generated v-table for messages.
*
*
* History:
*  8/05/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Msg.h"
#include "MsgTable.h"

#include "MsgClass.h"


/***************************************************************************\
*****************************************************************************
*
* class MsgTable
* 
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* MsgTable::Build
*
* Build() builds and fully initializes a new MsgTable.
* 
\***************************************************************************/

HRESULT
MsgTable::Build(
    IN  const DUser::MessageClassGuts * pmcInfo, 
                                        // Implementation information
    IN  const MsgClass * pmcPeer,       // "Owning" MsgClass
    OUT MsgTable ** ppmtNew)            // Newly built MsgTable
{
    AssertMsg(pmcPeer != NULL, "Must have a valid MsgClass peer");
    HRESULT hr = S_OK;

    //
    // Compute how much memory the MsgTable will take
    // - Find the Super
    // - Determine the number of messages.  This is the number of messages 
    //   defined in the super + the number of _new_ (not overridden) messages.
    //

    int cSuperMsgs = 0, cNewMsgs = 0;
    const MsgClass * pmcSuper = pmcPeer->GetSuper();
    const MsgTable * pmtSuper = NULL;
    if (pmcSuper != NULL) {
        pmtSuper = pmcSuper->GetMsgTable();
        cSuperMsgs = pmtSuper->GetCount();
        for (int idx = 0; idx < pmcInfo->cMsgs; idx++) {
            if ((pmcInfo->rgMsgInfo[idx].pfn != NULL) &&
                (pmtSuper->Find(FindAtomW(pmcInfo->rgMsgInfo[idx].pszMsgName)) == 0)) {

                cNewMsgs++;
            }
        }
    } else {
        cNewMsgs = pmcInfo->cMsgs;
    }


    //
    // Allocate the new MsgTable
    //

    int cTotalMsgs      = cSuperMsgs + cNewMsgs;
    int cbAlloc         = sizeof(MsgTable) + cTotalMsgs * sizeof(MsgSlot);
    if ((cbAlloc > GM_EVENT) || (cTotalMsgs > 1024)) {
        PromptInvalid("MsgTable will contain too many methods.");
        return E_INVALIDARG;
    }

    void * pvAlloc      = ProcessAlloc(cbAlloc);
    if (pvAlloc == NULL) {
        return E_OUTOFMEMORY;
    }
    MsgTable * pmtNew   = placement_new(pvAlloc, MsgTable);
    pmtNew->m_cMsgs     = cTotalMsgs;
    pmtNew->m_pmcPeer   = pmcPeer;
    pmtNew->m_pmtSuper  = pmtSuper;


    //
    // Setup message entries
    // - Copy messages from super-class
    // - Override and add messages from new class
    //
    // NOTE: We are using GArrayS<> to store the array of this pointers.  The
    // data stored in here points to the beginning of the array of data.  
    // Before this array, we store the size, but we don't need to worry about 
    // that here.
    //

    if (cTotalMsgs > 0) {
        MsgSlot * rgmsDest  = pmtNew->GetSlots();
        int cThisDepth      = pmtSuper != NULL ? pmtSuper->GetDepth() + 1 : 0;
        int cbThisOffset    = cThisDepth * sizeof(void *);
        int idxAdd = 0;

        if (pmtSuper != NULL) {
            const MsgSlot * rgmsSrc = pmtSuper->GetSlots();
            for (idxAdd = 0; idxAdd < cSuperMsgs; idxAdd++) {
                rgmsDest[idxAdd] = rgmsSrc[idxAdd];
            }
        }
        Assert(idxAdd == cSuperMsgs);

        for (int idx = 0; idx < pmcInfo->cMsgs; idx++) {
            const DUser::MessageInfoGuts * pmi = &pmcInfo->rgMsgInfo[idx];
            ATOM atomMsg    = 0;
            int idxMsg      = -1;

            if (pmi->pfn == NULL) {
                continue;  // Just skip this slot
            }

            if ((pmtSuper == NULL) ||                               // No super
                ((atomMsg = FindAtomW(pmi->pszMsgName)) == 0) ||    // Message not yet defined
                ((idxMsg = pmtSuper->FindIndex(atomMsg)) < 0)) {    // Message not in super

                //
                // Function is defined, so it should be added.
                //

                atomMsg = AddAtomW(pmi->pszMsgName);
                idxMsg  = idxAdd++;
            }

            MsgSlot & ms    = rgmsDest[idxMsg];
            ms.atomNameID   = atomMsg;
            ms.cbThisOffset = cbThisOffset;
            ms.pfn          = pmi->pfn;
        }

        AssertMsg(idxAdd == cTotalMsgs, "Should have added all messages");


        //
        // Check to see if any messages were not properly setup.
        //

        BOOL fMissing = FALSE;
        for (idx = 0; idx < cTotalMsgs; idx++) {
            if (rgmsDest[idx].pfn == NULL) {
                //
                // Function is not defined and is not in the super.  This is
                // an error because it is being declared "new" and not being
                // defined.
                //

                WCHAR szMsgName[256];
                GetAtomNameW(rgmsDest[idx].atomNameID, szMsgName, _countof(szMsgName));

                Trace("ERROR: DUser: %S::%S() was not properly setup.\n", 
                        pmcInfo->pszClassName, szMsgName);
                fMissing = TRUE;
            }
        }

        if (fMissing) {
            PromptInvalid("Class registration does not have all functions properly setup.");
            hr = DU_E_MESSAGENOTIMPLEMENTED;
            goto ErrorExit;
        }
    }


    //
    // Done building- return out
    //

    *ppmtNew = pmtNew;
    return S_OK;

ErrorExit:
    delete pmtNew;
    return hr;
}


/***************************************************************************\
*
* MsgTable::FindIndex
*
* FindIndex() finds the corresponding index for the specified 
* method / message.
* 
\***************************************************************************/

int
MsgTable::FindIndex(
    IN  ATOM atomNameID                 // Method to find
    ) const
{
    const MsgSlot * rgSlots = GetSlots();
    for (int idx = 0; idx < m_cMsgs; idx++) {
        if (rgSlots[idx].atomNameID == atomNameID) {
            return idx;
        }
    }

    return -1;
}


/***************************************************************************\
*
* MsgTable::Find
*
* Find() finds the corresponding MsgSlot for the specified method / message.
* 
\***************************************************************************/

const MsgSlot *
MsgTable::Find(
    IN  ATOM atomNameID                 // Method to find
    ) const
{
    int idx = FindIndex(atomNameID);
    if (idx >= 0) {
        return &(GetSlots()[idx]);
    } else {
        return NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\msg\msgobject.h ===
/***************************************************************************\
*
* File: MsgObject.h
*
* Description:
* MsgObject.h defines the "Message Object" class that is used to receive
* messages in DirectUser.  This object is created for each instance of a
* class that is instantiated.
*
*
* History:
*  8/05/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(MSG__MsgObject_h__INCLUDED)
#define MSG__MsgObject_h__INCLUDED
#pragma once

class MsgTable;
class MsgClass;

struct ExposedMsgObject
{
    const MsgTable *    m_pmt;
    GArrayS<void *>     m_arpThis;
};

class MsgObject : public BaseObject
{
// Construction
public:
    inline  MsgObject();
    inline  ~MsgObject();
protected:
    virtual void        xwDestroy();
            void        xwEndDestroy();

// BaseObject
public:
    virtual HandleType  GetHandleType() const { return htMsgObject; }
    virtual UINT        GetHandleMask() const { return hmMsgObject; }
    
// Operations
public:
    static  DUser::Gadget *    
                        CastGadget(HGADGET hgad);
    static  DUser::Gadget *    
                        CastGadget(MsgObject * pmo);
    static  HGADGET     CastHandle(DUser::Gadget * pg);
    static  HGADGET     CastHandle(MsgObject * pmo);
    static  MsgObject * CastMsgObject(DUser::Gadget * pg);
    static  MsgObject * CastMsgObject(HGADGET hgad);
    inline  DUser::Gadget *    
                        GetGadget() const;

            BOOL        InstanceOf(const MsgClass * pmcTest) const;
    inline  DUser::Gadget *    
                        CastClass(const MsgClass * pmcTest) const;
            void *      GetGutsData(const MsgClass * pmcData) const;

    inline  HRESULT     PreAllocThis(int cSlots);
    inline  void        FillThis(int idxSlotStart, int idxSlotEnd, void * pvThis, const MsgTable * pmtNew);

    inline  HRESULT     Promote(void * pvThis, const MsgTable * pmtNew);
    inline  void        Demote(int cLevels);
    inline  void *      GetThis(int idxThis) const;
    inline  int         GetDepth() const;
    inline  int         GetBuildDepth() const;

    inline  void        InvokeMethod(MethodMsg * pmsg) const;

#if 1
            BOOL        SetupInternal(HCLASS hcl);
#endif

// Implementation
protected:
    static  MsgObject * RawCastMsgObject(DUser::Gadget * pg);
    static  DUser::Gadget *    
                        RawCastGadget(MsgObject * pmo);

public:
    static  HRESULT CALLBACK
                        PromoteInternal(DUser::ConstructProc pfnCS, HCLASS hclCur, DUser::Gadget * pgad, DUser::Gadget::ConstructInfo * pciData);
    static  HCLASS CALLBACK
                        DemoteInternal(HCLASS hclCur, DUser::Gadget * pgad, void * pvData);


// Data
private:
            ExposedMsgObject    
                        m_emo;          // Actual data
public:
    static  HCLASS      s_hclSuper;     // DUMMY data used by IMPL classes
};


#define DECLARE_INTERNAL(name) \
    static HCLASS CALLBACK \
    Demote##name(HCLASS hclCur, DUser::Gadget * pgad, void * pvData) \
    { \
        return DemoteInternal(hclCur, pgad, pvData); \
    } \
    \
    static void MarkInternal() \
    { \
        GetClassLibrary()->MarkInternal(s_mc.hclNew); \
    } \

template <class T>
inline T * 
Cast(const MsgObject * pmo)
{
    return static_cast<T *> (const_cast<MsgObject *> (pmo)->GetGadget());
}


#include "MsgObject.inl"

#endif // MSG__MsgObject_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\msg\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	Motion.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\msg\msgclass.inl ===
/***************************************************************************\
*
* File: MsgClass.inl
*
* Description:
* MsgClass.inl implements the "Message Class" object that is created for each
* different message object type.  Each object has a corresponding MsgClass
* that provides information about that object type.
*
*
* History:
*  8/05/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(MSG__MsgClass_inl__INCLUDED)
#define MSG__MsgClass_inl__INCLUDED
#pragma once

/***************************************************************************\
*****************************************************************************
*
* class MsgClass
* 
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline MsgClass * 
CastMsgClass(BaseObject * pbase)
{
    if ((pbase != NULL) && (pbase->GetHandleType() == htMsgClass)) {
        return (MsgClass *) pbase;
    }
    return NULL;
}


//------------------------------------------------------------------------------
inline const MsgClass * 
CastMsgClass(const BaseObject * pbase)
{
    if ((pbase != NULL) && (pbase->GetHandleType() == htMsgClass)) {
        return (const MsgClass *) pbase;
    }
    return NULL;
}


//------------------------------------------------------------------------------
inline MsgClass * 
ValidateMsgClass(HCLASS hgad)
{
    return CastMsgClass(BaseObject::ValidateHandle(hgad));
}


//------------------------------------------------------------------------------
inline 
MsgClass::MsgClass()
{

}


//------------------------------------------------------------------------------
inline HCLASS
MsgClass::GetHandle() const
{
    return (HCLASS) BaseObject::GetHandle();
}


//------------------------------------------------------------------------------
inline ATOM
MsgClass::GetName() const
{
    return m_atomName;
}


//------------------------------------------------------------------------------
inline const MsgTable *
MsgClass::GetMsgTable() const
{
    return m_pmt;
}


//------------------------------------------------------------------------------
inline const MsgClass *
MsgClass::GetSuper() const
{
    return m_pmcSuper;
}


//------------------------------------------------------------------------------
inline BOOL
MsgClass::IsGutsRegistered() const
{
    return m_pmt != NULL;
}


//------------------------------------------------------------------------------
inline BOOL
MsgClass::IsInternal() const
{
    return m_fInternal;
}


//------------------------------------------------------------------------------
inline void
MsgClass::MarkInternal()
{
    m_fInternal = TRUE;
}


#endif // MSG__MsgClass_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\msg\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__B62CD79E_4F87_4613_BB92_C6DE549293E8__INCLUDED_)
#define AFX_STDAFX_H__B62CD79E_4F87_4613_BB92_C6DE549293E8__INCLUDED_

#pragma once

#include "CommonStdAfx.h"

#endif // !defined(AFX_STDAFX_H__B62CD79E_4F87_4613_BB92_C6DE549293E8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\msg\msgobject.cpp ===
/***************************************************************************\
*
* File: MsgObject.cpp
*
* Description:
* MsgObject.cpp implements the "Message Object" class that is used to receive
* messages in DirectUser.  This object is created for each instance of a
* class that is instantiated.
*
*
* History:
*  8/05/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Msg.h"
#include "MsgObject.h"

#include "MsgTable.h"
#include "MsgClass.h"


/***************************************************************************\
*****************************************************************************
*
* class MsgObject
* 
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* MsgObject::xwDestroy
*
* xwDestroy() is called when the object reaches the final xwUnlock(), giving
* the MsgObject a chance to hook into properly tear-down the external object.
*
\***************************************************************************/

void
MsgObject::xwDestroy()
{
    xwEndDestroy();

    BaseObject::xwDestroy();
}


/***************************************************************************\
*
* MsgObject::xwEndDestroy
*
* xwEndDestroy() ends the destruction process for a given MsgObject to free 
* its associated resources.  This includes destroying all child Gadgets in
* the subtree before this Gadget is destroyed.
*
* Any class that derives from MsgObject and overrides xwDestroy() without
* calling MsgObject::xwDestroy() MUST call xwEndDestroy().  This allows 
* derived classes to use special pool allocators, but still properly 
* tear down the "attached" objects.  
*
\***************************************************************************/

void
MsgObject::xwEndDestroy()
{
    if (m_emo.m_pmt != NULL) {
        //
        // Need to "demote" the object all of the way down.
        //

        m_emo.m_pmt->GetClass()->xwTearDownObject(this);
        AssertMsg(m_emo.m_arpThis.GetSize() == 0, 
                "After TearDown, should not have any remaining 'this' pointers");

#if DBG
        // DEBUG: Stuff pMT with a bogus value to help identify destroyed object
        m_emo.m_pmt = (const MsgTable *) ULongToPtr(0xA0E2A0E2);
#endif
    }
}


/***************************************************************************\
*
* MsgObject::PromoteInternal
*
* PromoteInternal() provides an empty promotion function that can be used
* to build internal objects.  This promotion function WILL NOT actually 
* allocate the object and can only be used to prevent the creation of a
* base class that can not be directly created.
*
\***************************************************************************/

HRESULT CALLBACK
MsgObject::PromoteInternal(
    IN  DUser::ConstructProc pfnCS,     // Creation callback function
    IN  HCLASS hclCur,                  // Class to promote to
    IN  DUser::Gadget * pgad,           // Object being promoted
    IN  DUser::Gadget::ConstructInfo * pciData) // Construction parameters
{
    UNREFERENCED_PARAMETER(pfnCS);
    UNREFERENCED_PARAMETER(hclCur);
    UNREFERENCED_PARAMETER(pgad);
    UNREFERENCED_PARAMETER(pciData);


    //
    // Not allowed to directly create this object.  Derived classes must provide
    // their own Promotion function.
    //

    return S_OK;
}


/***************************************************************************\
*
* MsgObject::DemoteInternal
*
* DemoteInternal() provides an empty demotion function that can be used
* to tear-down internal objects.  Since there is rarely anything to do for
* demotion of internal objects, this demotion function may be safely used
* for internal objects.
*
\***************************************************************************/

HCLASS CALLBACK
MsgObject::DemoteInternal(
    IN  HCLASS hclCur,                  // Class of Gadget being destroyed
    IN  DUser::Gadget * pgad,           // Gadget being destroyed
    IN  void * pvData)                  // Implementation data on object
{
    UNREFERENCED_PARAMETER(hclCur);
    UNREFERENCED_PARAMETER(pgad);
    UNREFERENCED_PARAMETER(pvData);

    return NULL;
}


#if 1

/***************************************************************************\
*
* MsgObject::SetupInternal
*
* SetupInternal() sets up an internal object that is being created as a 
* handle (legacy object).  This function should not be called on objects 
* that are being created as "Gadget's".
*
* TODO: Try to remove this function
*
\***************************************************************************/

BOOL
MsgObject::SetupInternal(
    IN  HCLASS hcl)                     // Internal class being setup
{
    MsgClass * pmcThis = ValidateMsgClass(hcl);
    AssertMsg((pmcThis != NULL) && pmcThis->IsInternal(), "Must be a valid internal class");

    int cLevels = 0;
    const MsgClass * pmcCur = pmcThis;
    while (pmcCur != NULL) {
        cLevels++;
        pmcCur = pmcCur->GetSuper();
    }

    VerifyMsg(m_emo.m_arpThis.GetSize() == 0, "Must not already be initialized");
    if (!m_emo.m_arpThis.SetSize(cLevels)) {
        return FALSE;
    }

    for (int idx = 0; idx < cLevels; idx++) {
        m_emo.m_arpThis[idx] = this;
    }

    m_emo.m_pmt = pmcThis->GetMsgTable();
    AssertMsg(m_emo.m_pmt != NULL, "Must now have a valid MT");
    return TRUE;
}
#endif


/***************************************************************************\
*
* MsgObject::InstanceOf
*
* InstanceOf() checks if the MsgObject is an "instance of" a specified class
* by traversing the inheritance heirarchy.
*
\***************************************************************************/

BOOL
MsgObject::InstanceOf(
    IN  const MsgClass * pmcTest        // Class checking for instance
    ) const
{
    AssertMsg(pmcTest != NULL, "Must have a valid MsgClass");

    const MsgClass * pmcCur = m_emo.m_pmt->GetClass();
    while (pmcCur != NULL) {
        if (pmcCur == pmcTest) {
            return TRUE;
        }

        pmcCur = pmcCur->GetSuper();
    }

    return FALSE;
}


/***************************************************************************\
*
* MsgObject::GetGutsData
*
* GetGutsData() retreives the implementation-specific data for the specified
* class on the given object.  
*
* NOTE: This operation has been highly optimized for speed and will not 
* validate that the object is of the specified class type.  If the caller is
* uncertain, they must call InstanceOf() or CastClass() to properly 
* determine the object's type.
*
\***************************************************************************/

void *
MsgObject::GetGutsData(
    IN  const MsgClass * pmcData        // Class of guts data
    ) const
{
#if DBG
    if (!InstanceOf(pmcData)) {
        PromptInvalid("The Gadget is not the specified class");
    }
#endif

    int cDepth = pmcData->GetMsgTable()->GetDepth();
#if DBG
    if ((cDepth < 0) || (cDepth >= m_emo.m_arpThis.GetSize())) {
        PromptInvalid("The Gadget does not have data for the specified class");
    }
#endif

    return m_emo.m_arpThis[cDepth];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\objectapi\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	Services.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\msg\public.h ===
/***************************************************************************\
*
* File: Public.h
*
* Description:
* Public.h contains a list of definitions that are exposed and available
* outside this project.  Any other DirectUser project that wishes to use
* these services directly instead of going through public API's can include
* a corresponding [Project]P.h available in the \inc directory.  
* 
* Definitions that are not exposed through this file are considered project 
* specific implementation details and should not used in other projects.
*
*
* History:
*  8/04/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(MSG__Public_h__INCLUDED)
#define MSG__Public_h__INCLUDED

#include "MsgTable.h"
#include "MsgClass.h"
#include "MsgObject.h"
#include "ClassLibrary.h"

#endif // MSG__Public_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\msg\msgtable.h ===
/***************************************************************************\
*
* File: MsgTable.h
*
* Description:
* MsgTable.h defines the "Message Table" object that provide a 
* dynamically generated v-table for messages.
*
*
* History:
*  8/05/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(MSG__MsgTable_h__INCLUDED)
#define MSG__MsgTable_h__INCLUDED
#pragma once

//
// NOTE: MsgSlot NEEDS to have data packed on 8-byte boundaries since it will
// be directly accessed on Win64.
//

struct MsgSlot
{
    void *      pfn;            // Implementation function
    int         cbThisOffset;   // "this" offset in arpThis
    ATOM        atomNameID;     // Unique ID for message
};

class MsgClass;

class MsgTable
{
// Construction
public:
    inline  MsgTable();
    inline  ~MsgTable();
    static  HRESULT     Build(const DUser::MessageClassGuts * pmc, const MsgClass * pmcPeer, MsgTable ** ppmt);
    inline  void        Destroy();

// Operations
public:
    inline  int         GetCount() const;
    inline  int         GetDepth() const;
    inline  const MsgClass *
                        GetClass() const;
    inline  const MsgSlot *
                        GetMsgSlot(int nMsg) const;
            const MsgSlot *
                        Find(ATOM atomNameID) const;
            int         FindIndex(ATOM atomNameID) const;

// Implementation
protected:
    inline  MsgSlot *   GetSlots();
    inline  const MsgSlot *
                        GetSlots() const;

// Data
protected:
            const MsgTable *  
                        m_pmtSuper;
            const MsgClass * 
                        m_pmcPeer;
            int         m_cMsgs;
};


#include "MsgTable.inl"

#endif // MSG__MsgTable_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\msg\msgtable.inl ===
/***************************************************************************\
*
* File: MsgTable.inl
*
* Description:
* MsgTable.inl implements the "Message Table" object that provide a 
* dynamically generated v-table for messages.
*
*
* History:
*  8/05/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(MSG__MsgTable_inl__INCLUDED)
#define MSG__MsgTable_inl__INCLUDED
#pragma once


/***************************************************************************\
*****************************************************************************
*
* class MsgTable
* 
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline 
MsgTable::MsgTable()
{

}


//------------------------------------------------------------------------------
inline 
MsgTable::~MsgTable()
{
    
}


//------------------------------------------------------------------------------
inline void
MsgTable::Destroy()
{
    placement_delete(this, MsgTable);
    ProcessFree(this);
}


//------------------------------------------------------------------------------
inline int
MsgTable::GetCount() const
{
    return m_cMsgs;
}


//------------------------------------------------------------------------------
inline int
MsgTable::GetDepth() const
{
    int cDepth = 0;
    const MsgTable * pmt = m_pmtSuper;
    while (pmt != NULL) {
        cDepth++;
        pmt = pmt->m_pmtSuper;
    }

    return cDepth;
}


//------------------------------------------------------------------------------
inline const MsgClass *
MsgTable::GetClass() const
{
    return m_pmcPeer;
}


//------------------------------------------------------------------------------
inline MsgSlot *
MsgTable::GetSlots()
{
    BYTE * pb = reinterpret_cast<BYTE *> (this);
    pb += sizeof(MsgTable);
    return reinterpret_cast<MsgSlot *> (pb);
}


//------------------------------------------------------------------------------
inline const MsgSlot *
MsgTable::GetSlots() const
{
    BYTE * pb = reinterpret_cast<BYTE *> (const_cast<MsgTable *> (this));
    pb += sizeof(MsgTable);
    return reinterpret_cast<const MsgSlot *> (pb);
}


//------------------------------------------------------------------------------
inline const MsgSlot *
MsgTable::GetMsgSlot(
    IN  int nMsg                        // Method to invoke
    ) const
{
    AssertMsg(nMsg < GM_EVENT, "Must be a method");
    AssertMsg(nMsg >= sizeof(MsgTable), "Must properly offset from the beginning");
    AssertMsg((nMsg - sizeof(MsgTable)) % sizeof(MsgSlot) == 0,
            "Must point to the beginning on a slot");

    BYTE * pb = reinterpret_cast<BYTE *> (const_cast<MsgTable *> (this));
    pb += nMsg;
    return reinterpret_cast<const MsgSlot *> (pb);
}


#endif // MSG__MsgTable_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\objectapi\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__EF8D234D_DC43_4715_B055_D42A2E096361__INCLUDED_)
#define AFX_STDAFX_H__EF8D234D_DC43_4715_B055_D42A2E096361__INCLUDED_

#pragma once

#include "CommonStdAfx.h"
#include <atlconv.h>            // String conversion routines

#endif // !defined(AFX_STDAFX_H__EF8D234D_DC43_4715_B055_D42A2E096361__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\objectapi\public.h ===
/***************************************************************************\
*
* File: Public.h
*
* Description:
* Public.h contains a list of definitions that are exposed and available
* outside this project.  Any other DirectUser project that wishes to use
* these files directly instead of going through public API's can include
* a corresponding [Project]P.h available in the \inc directory.  
* 
* Definitions that are not exposed through this file are considered project 
* specific implementation details and should not used in other projects.
*
*
* History:
*   9/7/2000:  JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(OBJECTAPI__Public_h__INCLUDED)
#define OBJECTAPI__Public_h__INCLUDED

#define GADGET_ENABLE_ALL
#define GADGET_ENABLE_GDIPLUS
#define GADGET_ENABLE_COM
#define GADGET_ENABLE_OLE
#define GADGET_ENABLE_DX
#define GADGET_ENABLE_TRANSITIONS

#include "DUser.h"
#include "DUserCore.h"
#include "DUserMotion.h"
#include "DUserCtrl.h"

#include "Stub.h"
#include "Super.h"
#include "Validate.h"

#endif // OBJECTAPI__Public_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\objectapi\objectapi.h ===
/***************************************************************************\
*
* File: ObjectAPI.h
*
* Description:
* This file provides a project-wide header that is included in all source 
* files specific to this project.  It is similar to a precompiled header, 
* but is designed for more rapidly changing headers.
*
* The primary purpose of this file is to determine which DirectUser 
* projects this project has direct access to instead of going through public
* API's.  It is VERY IMPORTANT that this is as minimal as possible since
* adding a new project unnecessarily reduces the benefit of project 
* partitioning.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(OBJECTAPI__ObjectApi_h__INCLUDED)
#define OBJECTAPI__ObjectApi_h__INCLUDED
#pragma once

#include "Public.h"

#include <DUserBaseP.h>

#if DBG

#define PromptInvalid(comment) \
    do \
    { \
        if (IDebug_Prompt(GetDebug(), "Validation error:\r\n" comment, __FILE__, __LINE__, "DirectUser/ObjectAPI Notification")) \
            AutoDebugBreak(); \
    } while (0) \

#else // DBG

#define PromptInvalid(comment) ((void) 0)

#endif // DBG

#endif // OBJECTAPI__ObjectApi_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\objectapi\makefile.inc ===
#
# GIDL
#

$(O)\stub.cpp: $(WINDOWS_INC_PATH)\DUser\DUser.gidl $(WINDOWS_INC_PATH)\DUser\DUser.gh
    Gidl.exe -I$(WINDOWS_INC_PATH)\DUser -I..\..\inc\public DUser.gidl DUserCtrl.gidl DUser.gh DUserCtrl.gh -dtarget=$(_BUILDARCH) -dproject=..\..\ObjectAPI.h -o$(O) -t$(NTMAKEENV)\DirectMT.gml

$(O)\super.cpp: $(WINDOWS_INC_PATH)\DUser\DUser.gidl $(WINDOWS_INC_PATH)\DUser\DUser.gh
    Gidl.exe -I$(WINDOWS_INC_PATH)\DUser -I..\..\inc\public DUser.gidl DUserCtrl.gidl DUser.gh DUserCtrl.gh -dtarget=$(_BUILDARCH) -dproject=..\..\ObjectAPI.h -o$(O) -t$(NTMAKEENV)\DirectMT.gml
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\sources.inc ===
!IF 0

Module Name:  Shared sources.inc file for RockAll projects.

Abstract:

Author:
        JStall

!ENDIF

SOURCES_USED=..\sources.inc

MSC_STDCALL=1
MSC_WARNING_LEVEL=-W4
NT_UP=0

USE_MSVCRT=1
MSC_OPTIMIZATION=/Oxt

C_DEFINES=$(C_DEFINES) -DWIN32 -D_MBCS -DNO_DEFAULT_HEAP -DROCKALL_DIRECTUSER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\objectapi\validate.h ===
#if !defined(OBJECTAPI__Validate_h__INCLUDED)
#define OBJECTAPI__Validate_h__INCLUDED
#pragma once

#if DBG

// AutoDebug functions that are only available in DEBUG builds

inline BOOL IsBadCode(const void * pv)
{
    return IsBadCodePtr((FARPROC) pv);
}

template <class T>
inline BOOL IsBadRead(const void * pv, T cb)
{
    return IsBadReadPtr(pv, (UINT_PTR) cb);
}

template <class T>
inline BOOL IsBadWrite(void * pv, T cb)
{
    return IsBadWritePtr(pv, (UINT_PTR) cb);
}

inline BOOL IsBadString(LPCTSTR pv, int cb)
{
    return IsBadStringPtr(pv, (UINT_PTR) cb);
}

inline BOOL IsBadStringA(LPCSTR pv, int cb)
{
    return IsBadStringPtrA(pv, (UINT_PTR) cb);
}

inline BOOL IsBadStringW(LPCWSTR pv, int cb)
{
    return IsBadStringPtrW(pv, (UINT_PTR) cb);
}

#else // DBG

inline BOOL IsBadCode(const void * pv)
{
    UNREFERENCED_PARAMETER(pv);
    return FALSE;
}

template <class T>
inline BOOL IsBadRead(const void * pv, T cb)
{
    UNREFERENCED_PARAMETER(pv);
    UNREFERENCED_PARAMETER(cb);
    return FALSE;
}

template <class T>
inline BOOL IsBadWrite(void * pv, T cb)
{
    UNREFERENCED_PARAMETER(pv);
    UNREFERENCED_PARAMETER(cb);
    return FALSE;
}

inline BOOL IsBadString(LPCTSTR pv, int cb)
{
    UNREFERENCED_PARAMETER(pv);
    UNREFERENCED_PARAMETER(cb);
    return FALSE;
}

inline BOOL IsBadStringA(LPCSTR pv, int cb)
{
    UNREFERENCED_PARAMETER(pv);
    UNREFERENCED_PARAMETER(cb);
    return FALSE;
}

inline BOOL IsBadStringW(LPCWSTR pv, int cb)
{
    UNREFERENCED_PARAMETER(pv);
    UNREFERENCED_PARAMETER(cb);
    return FALSE;
}

#endif // DBG



//
// API Entry / Exit setup rountines
//

#if DBG

#define BEGIN_API(defermsg, pctx)               \
    HRESULT retval = DU_E_GENERIC;              \
                                                \
    {                                           \
        Context * pctxThread = pctx;            \
        ContextLock cl;                         \
        if (!cl.LockNL(defermsg, pctxThread)) { \
            retval = E_INVALIDARG;              \
            goto ErrorExit;                     \
        }                                       \
        AssertInstance(pctxThread);            \
                                                \
        if (pctx != ::RawGetContext()) {        \
            PromptInvalid("Must use Gadget inside correct Context"); \
            retval = DU_E_INVALIDCONTEXT;       \
            goto ErrorExit;                     \
        }                                       \
        if (pmsg == NULL) {                     \
            PromptInvalid("Must specify a valid message"); \
            retval = E_INVALIDARG;              \
            goto ErrorExit;                     \
        }                                       \

#else // DBG

#define BEGIN_API(defermsg, pctx)               \
    HRESULT retval = DU_E_GENERIC;              \
                                                \
    {                                           \
        Context * pctxThread = pctx;            \
        ContextLock cl;                         \
        if (!cl.LockNL(defermsg, pctxThread)) { \
            retval = E_INVALIDARG;              \
            goto ErrorExit;                     \
        }                                       \
                                                \
        if (pmsg == NULL) {                     \
            PromptInvalid("Must specify a valid message"); \
            retval = E_INVALIDARG;              \
            goto ErrorExit;                     \
        }                                       \

#endif // DBG

#define END_API()                               \
        goto ErrorExit;                         \
ErrorExit:                                      \
        /* Unlocks the Context here */          \
        ;                                       \
    }                                           \
    return retval;


#define BEGIN_API_NOLOCK()                      \
    HRESULT retval = DU_E_GENERIC;              \
                                                \
    {                                           \


#define END_API_NOLOCK()                        \
        goto ErrorExit;                         \
ErrorExit:                                      \
        ;                                       \
    }                                           \
    return retval;



#define BEGIN_API_NOCONTEXT()                   \
    HRESULT retval = DU_E_GENERIC;              \


#define END_API_NOCONTEXT()                     \
    goto ErrorExit;                             \
ErrorExit:                                      \
    return retval;



#define CHECK_MODIFY()                          \
    if (pctxThread->IsReadOnly()) {             \
        PromptInvalid("Can not call modifying function while in read-only state / callback"); \
        retval = DU_E_READONLYCONTEXT;          \
        goto ErrorExit;                         \
    }                                           \


//
// Individual parameter validation rountines
//

#define VALIDATE_GADGETCONTEXT(v)                           \
    {                                                       \
        Context * pctxGad = (v)->GetContext();              \
        if (pctxThread != pctxGad) {                        \
            PromptInvalid("Must use Gadget inside correct Context"); \
            retval = DU_E_INVALIDCONTEXT;                   \
            goto ErrorExit;                                 \
        }                                                   \
    }

#define VALIDATE_VALUE(x, v)                                \
    if (x != v) {                                           \
        retval = E_INVALIDARG;                              \
        goto ErrorExit;                                     \
    }

#define VALIDATE_HWND(wnd)                                  \
    if ((h##wnd == NULL) || (!IsWindow(h##wnd))) {          \
        PromptInvalid("Handle is not a valid Window");     \
        retval = E_INVALIDARG;                              \
        goto ErrorExit;                                     \
    }

#define VALIDATE_REGION(rgn)                                \
    if (h##rgn == NULL) {                                   \
        PromptInvalid("Handle is not a valid region");     \
        retval = E_INVALIDARG;                              \
        goto ErrorExit;                                     \
    }

#define VALIDATE_OBJECT(r, v)                               \
    {                                                       \
        v = BaseObject::ValidateHandle(r);                  \
        if (v == NULL) {                                    \
            PromptInvalid("Handle is not a valid object"); \
            retval = E_INVALIDARG;                          \
            goto ErrorExit;                                 \
        }                                                   \
    }

#define VALIDATE_EVENTGADGET(r, v)                          \
    {                                                       \
        v = ValidateBaseGadget(r);                          \
        if (v == NULL) {                                    \
            PromptInvalid("Handle is not a valid Gadget"); \
            retval = E_INVALIDARG;                          \
            goto ErrorExit;                                 \
        }                                                   \
        VALIDATE_GADGETCONTEXT(v)                           \
    }

#define VALIDATE_EVENTGADGET_NOCONTEXT(r, v)                \
    {                                                       \
        v = ValidateBaseGadget(r);                          \
        if (v == NULL) {                                    \
            PromptInvalid("Handle is not a valid Gadget"); \
            retval = E_INVALIDARG;                          \
            goto ErrorExit;                                 \
        }                                                   \
    }

#define VALIDATE_VISUAL(r, v)                               \
    {                                                       \
        v = ValidateVisual(r);                              \
        if (v == NULL) {                                    \
            PromptInvalid("Handle is not a valid Gadget"); \
            retval = E_INVALIDARG;                          \
            goto ErrorExit;                                 \
        }                                                   \
        VALIDATE_GADGETCONTEXT(v)                           \
    }

#define VALIDATE_ROOTGADGET(r, v)                           \
    {                                                       \
        {                                                   \
            DuVisual * pgadTemp = ValidateVisual(r);        \
            if (pgadTemp == NULL) {                         \
                PromptInvalid("Handle is not a valid Gadget"); \
                retval = E_INVALIDARG;                      \
                goto ErrorExit;                             \
            }                                               \
            if (!pgadTemp->IsRoot()) {                      \
                goto ErrorExit;                             \
            }                                               \
            VALIDATE_GADGETCONTEXT(pgadTemp)                \
            v = (DuRootGadget *) pgadTemp;                  \
        }                                                   \
    }

#define VALIDATE_VISUAL_OR_NULL(r, v)                       \
    {                                                       \
        if (r == NULL) {                                    \
            v = NULL;                                       \
        } else {                                            \
            v = ValidateVisual(r);                          \
            if (v == NULL) {                                \
                PromptInvalid("Handle is not a valid Gadget"); \
                retval = E_INVALIDARG;                      \
                goto ErrorExit;                             \
            }                                               \
            VALIDATE_GADGETCONTEXT(v)                       \
        }                                                   \
    }

#define VALIDATE_TRANSITION(trx)                            \
    {                                                       \
        BaseObject * pbase##trx = BaseObject::ValidateHandle(h##trx); \
        p##trx = CastTransition(pbase##trx);                \
        if (p##trx == NULL) {                               \
            PromptInvalid("Handle is not a valid Transition"); \
            retval = E_INVALIDARG;                          \
            goto ErrorExit;                                 \
        }                                                   \
    }

#define VALIDATE_FLAGS(f, m)                                \
    if ((f & m) != f) {                                     \
        PromptInvalid("Specified flags are invalid");      \
        retval = E_INVALIDARG;                              \
        goto ErrorExit;                                     \
    }

#define VALIDATE_RANGE(i, a, b)                             \
    if (((i) < (a)) || ((i) > (b))) {                       \
        PromptInvalid("Value is outside expected range");  \
        retval = E_INVALIDARG;                              \
        goto ErrorExit;                                     \
    }                                                       \

#define VALIDATE_CODE_PTR(p)                                \
    if ((p == NULL) || IsBadCode(p)) {                      \
        PromptInvalid("Bad code pointer: " STRINGIZE(p));  \
        retval = E_INVALIDARG;                              \
        goto ErrorExit;                                     \
    }                                                       \

#define VALIDATE_CODE_PTR_OR_NULL(p)                        \
    if ((p != NULL) && IsBadCode((FARPROC) p)) {            \
        PromptInvalid("Bad code pointer: " STRINGIZE(p));  \
        retval = E_INVALIDARG;                              \
        goto ErrorExit;                                     \
    }                                                       \

#define VALIDATE_READ_PTR(p)                                \
    if ((p == NULL) || IsBadRead(p, sizeof(char *))) {      \
        PromptInvalid("Bad read pointer: " STRINGIZE(p));  \
        retval = E_INVALIDARG;                              \
        goto ErrorExit;                                     \
    }                                                       \

#define VALIDATE_READ_PTR_(p, b)                            \
    if ((p == NULL) || IsBadRead(p, b)) {                   \
        PromptInvalid("Bad read pointer: " STRINGIZE(p));  \
        retval = E_INVALIDARG;                              \
        goto ErrorExit;                                     \
    }                                                       \

#define VALIDATE_READ_PTR_OR_NULL_(p, b)                    \
    if ((p != NULL) && IsBadRead(p, b)) {                   \
        PromptInvalid("Bad read pointer: " STRINGIZE(p));  \
        retval = E_INVALIDARG;                              \
        goto ErrorExit;                                     \
    }                                                       \

#define VALIDATE_READ_STRUCT(p, s)                          \
    if ((p == NULL) || IsBadRead(p, sizeof(s))) {           \
        PromptInvalid("Bad read pointer: " STRINGIZE(p));  \
        retval = E_INVALIDARG;                              \
        goto ErrorExit;                                     \
    }                                                       \
    if (p->cbSize != sizeof(s)) {                           \
        PromptInvalid("Structure is not expected size for " STRINGIZE(s)); \
        retval = E_INVALIDARG;                              \
        goto ErrorExit;                                     \
    }
    
#define VALIDATE_WRITE_PTR(p)                               \
    if ((p == NULL) || IsBadWrite(p, sizeof(char *))) {     \
        PromptInvalid("Bad write pointer: " STRINGIZE(p)); \
        retval = E_INVALIDARG;                              \
        goto ErrorExit;                                     \
    }                                                       \

#define VALIDATE_WRITE_PTR_(p, b)                           \
    if ((p == NULL) || IsBadWrite(p, b)) {                  \
        PromptInvalid("Bad write pointer: " STRINGIZE(p)); \
        retval = E_INVALIDARG;                              \
        goto ErrorExit;                                     \
    }                                                       \

#define VALIDATE_WRITE_PTR_OR_NULL_(p, b)                   \
    if ((p != NULL) && IsBadWrite(p, b)) {                  \
        PromptInvalid("Bad write pointer: " STRINGIZE(p)); \
        retval = E_INVALIDARG;                              \
        goto ErrorExit;                                     \
    }                                                       \

#define VALIDATE_WRITE_STRUCT(p, s)                         \
    if ((p == NULL) || IsBadWrite(p, sizeof(s))) {          \
        PromptInvalid("Bad write pointer: " STRINGIZE(p)); \
        retval = E_INVALIDARG;                              \
        goto ErrorExit;                                     \
    }                                                       \
    if (p->cbSize != sizeof(s)) {                           \
        PromptInvalid("Structure is not expected size for " STRINGIZE(s)); \
        retval = E_INVALIDARG;                              \
        goto ErrorExit;                                     \
    }
    
#define VALIDATE_STRING_PTR(p, cch)                         \
    if ((p == NULL) || IsBadString(p, cch)) {               \
        PromptInvalid("Bad string pointer: " STRINGIZE(p)); \
        retval = E_INVALIDARG;                              \
        goto ErrorExit;                                     \
    }                                                       \

#define VALIDATE_STRINGA_PTR(p, cch)                        \
    if ((p == NULL) || IsBadStringA(p, cch)) {              \
        PromptInvalid("Bad string pointer: " STRINGIZE(p)); \
        retval = E_INVALIDARG;                              \
        goto ErrorExit;                                     \
    }                                                       \

#define VALIDATE_STRINGW_PTR(p, cch)                        \
    if ((p == NULL) || IsBadStringW(p, cch)) {              \
        PromptInvalid("Bad string pointer: " STRINGIZE(p)); \
        retval = E_INVALIDARG;                              \
        goto ErrorExit;                                     \
    }                                                       \





#endif // OBJECTAPI__Validate_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\heap\bucketlist.hpp ===
#ifndef _BUCKET_LIST_HPP_
#define _BUCKET_LIST_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "List.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class PAGE;

    /********************************************************************/
    /*                                                                  */
    /*   The bucket list.                                               */
    /*                                                                  */
    /*   All allocation buckets have a linked list of pages with        */
    /*   available space in ascending order of address.                 */
    /*                                                                  */
    /********************************************************************/

class BUCKET_LIST
    {
		//
		//   Private data.
		//
 		LIST						  BucketList;

   public:
        //
        //   Public inline functions.
		//
		//   All page descriptions contain three linked lists.
		//   These lists are all derived from a common base
		//   class.  However, this class is unable to support
		//   multiple instances in a single class a wrapper
		//   has been created for each list to make it work
		//   as required.
        //
        BUCKET_LIST( VOID )
			{ /* void */ };

		INLINE VOID DeleteFromBucketList( LIST *HeadOfList )
			{ BucketList.Delete( HeadOfList ); }

		INLINE BOOLEAN EndOfBucketList( VOID )
			{ return (this == NULL); }

		STATIC INLINE PAGE *FirstInBucketList( LIST *HeadOfList )
			{ return ((PAGE*) HeadOfList -> First()); }

		INLINE VOID InsertInBucketList( LIST *HeadOfList )
			{ BucketList.Insert( HeadOfList ); }

		INLINE VOID InsertAfterInBucketList( LIST *HeadOfList,PAGE *Page )
			{ BucketList.InsertAfter( HeadOfList,(LIST*) Page ); }

		INLINE VOID InsertBeforeInBucketList( LIST *HeadOfList,PAGE *Page )
			{ BucketList.InsertBefore( HeadOfList,(LIST*) Page ); }

		STATIC INLINE PAGE *LastInBucketList( LIST *HeadOfList )
			{ return ((PAGE*) HeadOfList -> Last()); }

		INLINE PAGE *NextInBucketList( VOID )
			{ return ((PAGE*) BucketList.Next()); }

		INLINE PAGE *PreviousInBucketList( VOID )
			{ return ((PAGE*) BucketList.Previous()); }

        ~BUCKET_LIST( VOID )
			{ /* void */ };

	private:
        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        BUCKET_LIST( CONST BUCKET_LIST & Copy );

        VOID operator=( CONST BUCKET_LIST & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\heap\cache.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "HeapPCH.hpp"

#include "Cache.hpp"
#include "Heap.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here control the maximum size of        */
    /*   the cache.                                                     */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 MaxCacheSize			  = ((2 << 16)-1);

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new allocation cache and prepare it for use.  A       */
    /*   is inactive until the first request is received at which       */
    /*   time it springs into life.                                     */
    /*                                                                  */
    /********************************************************************/

CACHE::CACHE
		( 
		SBIT32						  NewAllocationSize,
		SBIT32						  NewCacheSize,
		SBIT32						  NewChunkSize,
		SBIT32						  NewPageSize,
		BOOLEAN						  NewStealing,
		BOOLEAN						  NewThreadSafe
		) :
		//
		//   Call the constructors for the contained classes.
		//
		BUCKET( NewAllocationSize,NewChunkSize,NewPageSize )
    {
	//
	//   We need to be very careful with the configuration
	//   information as it has come indirectly from the
	//   user and my be bogus.
	//
	if ( (NewCacheSize >= 0) && (NewCacheSize < MaxCacheSize) )
		{
		//
		//   Setup the cache and mark it as inactive.
		//
		Active = False;
		Stealing = NewStealing;
		ThreadSafe = NewThreadSafe;
#ifdef ENABLE_HEAP_STATISTICS

		CacheFills = 0;
		CacheFlushes = 0;
		HighTide = 0;
		HighWater = 0;
		InUse = 0;
#endif

		CacheSize = ((SBIT16) NewCacheSize);
		FillSize = 1;
		NumberOfChildren = 0;

		//
		//   The stacks that may later contain allocations
		//   are set to zero just to be neat.
		//
		DeleteStack = NULL;
		NewStack = NULL;

		TopOfDeleteStack = 0;
		TopOfNewStack = 0;
		}
	else
		{ Failure( "Cache size in constructor for CACHE" ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Create the cache stacks.                                       */
    /*                                                                  */
    /*   A cache is created on demand.  We do this when we get the      */
    /*   first allocation or deallocation request.                      */
    /*                                                                  */
    /********************************************************************/

VOID CACHE::CreateCacheStacks( VOID )
	{
	//
	//   We allocate the cache stacks from the internal
	//   new page allocator if we have not done it already.
	//
	if ( DeleteStack == NULL )
		{
		REGISTER SBIT32 Size = (CacheSize * sizeof(ADDRESS_AND_PAGE));

		DeleteStack = 
			((ADDRESS_AND_PAGE*) (NewPage -> NewCacheStack( Size )));
		}

	if ( NewStack == NULL )
		{
		REGISTER SBIT32 Size = (CacheSize * sizeof(VOID*));

		NewStack = 
			((VOID**) (NewPage -> NewCacheStack( Size )));
		}

	//
	//   We can now activate the cache as long as we 
	//   were able to allocate both stacks.
	//
	if ( (NewStack != NULL ) && (DeleteStack != NULL ) )
		{
		//
		//   We have completed creating the cache so set
		//   various flags and zero various counters.
		//
		Active = True;

		//
		//   Setup the fill size.
		//
		FillSize = 1;

		//
		//   Zero the stack tops.
		//
		TopOfDeleteStack = 0;
		TopOfNewStack = 0;
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Create a new data page.                                        */
    /*                                                                  */
    /*   When we create a new page we also need to allocate some        */
    /*   memory to hold the associated data.                            */
    /*                                                                  */
    /********************************************************************/

VOID *CACHE::CreateDataPage( VOID )
	{
	REGISTER VOID *NewMemory;

	//
	//   When there is a potential for multiple threads we
	//   claim the cache lock.
	//
	ClaimCacheLock();

	//
	//   Create a data page.
	//
	NewMemory = ((BUCKET*) this) -> New( True );

	//
	//   Release any lock we may have claimed earlier.
	//
	ReleaseCacheLock();

	return NewMemory;
	}
#ifdef ENABLE_HEAP_STATISTICS

    /********************************************************************/
    /*                                                                  */
    /*   Compute high water.                                            */
    /*                                                                  */
    /*   Compute the high water mark for the current cache.             */
    /*                                                                  */
    /********************************************************************/

VOID CACHE::ComputeHighWater( SBIT32 Size )
	{
	//
	//   Update the usage statistics.
	//
	if ( (InUse += Size) > HighTide )
		{ 
		HighTide = InUse;
		
		if ( HighTide > HighWater )
			{ HighWater = HighTide; }
		}
	}
#endif

    /********************************************************************/
    /*                                                                  */
    /*   A memory deallocation cache.                                   */
    /*                                                                  */
    /*   We cache memory deallocation requests to improve performance.  */
    /*   We do this by stacking requests until we have a batch.         */
    /*                                                                  */
    /********************************************************************/

BOOLEAN CACHE::Delete( VOID *Address,PAGE *Page,SBIT32 Version )
	{
	REGISTER BOOLEAN Result;

	//
	//   When there is a potential for multiple threads we
	//   claim the cache lock.
	//
	ClaimCacheLock();

	//
	//   At various times the cache may be either disabled
	//   or inactive.  Here we ensure that we are able to use
	//   the cache.  If not we bypass it and call the bucket 
	//   directly.
	//
	if ( Active )
		{
		//
		//   If recycling is allowed and the address is
		//   on the current page or a previous page and
		//   there is space on the new stack then put the
		//   element in the new stack for immediate reuse.
		//
		if 
				(
				(Stealing)
					&&
				(Address < GetCurrentPage())
					&&
				(TopOfNewStack < CacheSize)
				)
			{
			//
			//   The address is suitable for immediate
			//   reuse.  So put it on the stack of new
			//   elements.
			//
			NewStack[ (TopOfNewStack ++) ] = Address;

			Result = True;
			}
		else
			{
			REGISTER ADDRESS_AND_PAGE *Current = 
				(& DeleteStack[ TopOfDeleteStack ++ ]);

			//
			//   The address would best be deleted before
			//   being reused.
			//
			Current -> Address = Address;
			Current -> Page = Page;
			Current -> Version = Version;

			//
			//   When the delete stack is full we flush it.
			//
			if ( TopOfDeleteStack >= CacheSize )
				{
				AUTO SBIT32 Deleted;

				//
				//   Flush the delete stack.
				//
				Result = 
					(
					((BUCKET*) this) -> MultipleDelete
						(
						DeleteStack,
						& Deleted,
						TopOfDeleteStack 
						)
					);
#ifdef ENABLE_HEAP_STATISTICS

				//
				//   Update the usage statistics.  There
				//   is a nasty case here where we cache
				//   a delete only to find out later that
				//   it was bogus.   When this occurs we
				//   have to increase the 'InUse' count 
				//   to allow for this situation.
				//
				CacheFlushes ++;
				
				InUse += (TopOfDeleteStack - Deleted);
#endif

				//
				//   Zero the top of the stack.
				//
				TopOfDeleteStack = 0;
				}
			else
				{ Result = True; }
			}
		}
	else
		{
		//
		//   Delete the element.
		//
		Result = 
			(((BUCKET*) this) -> Delete( Address,Page,Version )); 
		}
#ifdef ENABLE_HEAP_STATISTICS

	//
	//   Update the usage statistics.
	//
	if ( Result )
		{ InUse --; }
#endif

	//
	//   Release any lock we may have claimed earlier.
	//
	ReleaseCacheLock();

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete all allocations.                                        */
    /*                                                                  */
    /*   The entire heap is about to be deleted under our feet.  We     */
    /*   need to prepare for this by disabling the cache as its         */
    /*   contents will disappear as well.                               */
    /*                                                                  */
    /********************************************************************/

VOID CACHE::DeleteAll( VOID )
	{
	//
	//   Disable the cache if needed.
	//
	Active = False;
#ifdef ENABLE_HEAP_STATISTICS

	//
	//   Zero the statistics.
	//
	HighTide = 0;
	InUse = 0;
#endif

	//
	//   Setup the fill size.
	//
	FillSize = 1;

	//
	//   Zero the top of stacks.
	//
	TopOfDeleteStack = 0;
	TopOfNewStack = 0;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete a data page.                                            */
    /*                                                                  */
    /*   Delete a data page that was associated with a smaller cache    */
    /*   so its space can be reused.                                    */
    /*                                                                  */
    /********************************************************************/

BOOLEAN CACHE::DeleteDataPage( VOID *Address )
	{
	AUTO SEARCH_PAGE Details;
	REGISTER BOOLEAN Result;
	REGISTER PAGE *Page;

	//
	//   When there is a potential for multiple threads we
	//   claim the cache lock.
	//
	ClaimCacheLock();

	//
	//   Find the description of the data page we need to 
	//   delete and make sure it is valid.
	//
	Find -> ClaimFindShareLock();

	Page = FindParentPage( Address );

	if ( Page != NULL )
		{ Page = (Page -> FindPage( Address,& Details,False )); }

	Find -> ReleaseFindShareLock();

	//
	//   Delete the data page.
	//
	if ( Page != NULL )
		{ Result = (Page -> Delete( & Details )); }
	else
		{ Failure( "No data page in DeleteDataPage" ); }

	//
	//   Release any lock we may have claimed earlier.
	//
	ReleaseCacheLock();

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory allocations.                                   */
    /*                                                                  */
    /*   The allocation cache contains preallocated memory from the     */
    /*   associated allocation bucket.  The cache will supply these     */
    /*   preallocated elements with the minimum fuss to any caller.     */
    /*                                                                  */
    /********************************************************************/

BOOLEAN CACHE::MultipleNew( SBIT32 *Actual,VOID *Array[],SBIT32 Requested )
	{
	REGISTER BOOLEAN Result;

	//
	//   When there is a potential for multiple threads we
	//   claim the cache lock.
	//
	ClaimCacheLock();

	//
	//   At various times the cache may be either disabled
	//   or inactive.  Here we ensure that we are able to use
	//   the cache.  If not we bypass it and call the bucket 
	//   directly.
	//
	if ( Active )
		{
		//
		//   We have been asked to allocalte multiple
		//   new elements.  If it appears that we don't  
		//   have enough elements available but stealing 
		//   is allowed we can try raiding the deleted 
		//   stack.
		//
		if ( (Requested > TopOfNewStack) && (Stealing) )
			{
			while ( (TopOfDeleteStack > 0) && (TopOfNewStack < CacheSize) )
				{
				NewStack[ (TopOfNewStack ++) ] = 
					(DeleteStack[ (-- TopOfDeleteStack) ].Address);
				}
			}

		//
		//   We will allocate from the cache if requested 
		//   size is smaller than the number of available 
		//   elements.
		//
		if ( Requested <= TopOfNewStack )
			{
			REGISTER SBIT32 Count;

			//
			//   We need to copy the elements out of the
			//   cache into the callers array.
			//
			for ( Count=0;Count < Requested;Count ++ )
				{ Array[ Count ] = NewStack[ (-- TopOfNewStack) ]; }

			(*Actual) = Requested;

			Result = True;
			}
		else
			{
			REGISTER BUCKET *Bucket = ((BUCKET*) this);

			//
			//   We don't have enough elements in the cache 
			//   so we allocate directly from the bucket.
			//
			Result =
				(
				Bucket -> MultipleNew
					( 
					Actual,
					Array,
					Requested
					)
				);

			//
			//   We fill up the cache so we have a good 
			//   chance of dealing with any following 
			//   requests if it is less than half full.
			//
			if ( TopOfNewStack <= (CacheSize / 2) )
				{
				AUTO SBIT32 NewSize;
				REGISTER SBIT32 MaxSize = (CacheSize - TopOfNewStack);

				//
				//   We slowly increse the fill size
				//   of the cache to make sure we don't
				//   waste too much space.
				//
				if ( FillSize < CacheSize )
					{
					if ( (FillSize *= 2) > CacheSize )
						{ FillSize = CacheSize; }
					}

				//
				//   Bulk load the cache with new
				//   elements.
				//
				Bucket -> MultipleNew
					( 
					& NewSize, 
					& NewStack[ TopOfNewStack ],
					((FillSize < MaxSize) ? FillSize : MaxSize)
					);
#ifdef ENABLE_HEAP_STATISTICS

				CacheFills ++;
#endif
				TopOfNewStack += NewSize;
				}
			}
		}
	else
		{
		//
		//   We may want to enable the cache for next
		//   time so see if this needs to be done.
		//
		if ( CacheSize > 1 )
			{ CreateCacheStacks(); }

		//
		//   The cache is disabled so go directly to the
		//   bucket.
		//
		Result = ((BUCKET*) this) -> MultipleNew
			( 
			Actual,
			Array,
			Requested
			);
		}
#ifdef ENABLE_HEAP_STATISTICS

	//
	//   Update the usage statistics.
	//
	ComputeHighWater( (*Actual) );
#endif

	//
	//   Release any lock we may have claimed earlier.
	//
	ReleaseCacheLock();

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation.                                             */
    /*                                                                  */
    /*   The allocation cache contains preallocated memory from the     */
    /*   associated allocation bucket.  The cache will supply these     */
    /*   preallocated elements with the minimum fuss to any caller.     */
    /*                                                                  */
    /********************************************************************/

VOID *CACHE::New( VOID )
	{
	REGISTER VOID *NewMemory;

	//
	//   When there is a potential for multiple threads we
	//   claim the cache lock.
	//
	ClaimCacheLock();

	//
	//   At various times the cache may be either disabled
	//   or inactive.  Here we ensure that we are able to use
	//   the cache.  If not we bypass it and call the bucket 
	//   directly.
	//
	if ( Active )
		{
		//
		//   We first try the stack for new allocations
		//   to see if there are any available elements.
		//
		if ( TopOfNewStack > 0 )
			{ NewMemory = (NewStack[ (-- TopOfNewStack) ]); }
		else
			{
			//
			//   When stealing is allowed we will recycle
			//   elements from the top of the deleted stack.
			//
			if ( (TopOfDeleteStack > 0) && (Stealing) )
				{ NewMemory = (DeleteStack[ (-- TopOfDeleteStack) ].Address); }
			else
				{
				//
				//   We slowly increse the fill size
				//   of the cache to make sure we don't
				//   waste too much space.
				//
				if ( FillSize < CacheSize )
					{
					if ( (FillSize *= 2) > CacheSize )
						{ FillSize = CacheSize; }
					}

				//
				//   We need to bulk load some new  
				//   memory from the heap.
				//
				if 
						( 
						((BUCKET*) this) -> MultipleNew
							( 
							& TopOfNewStack,
							NewStack,
							FillSize
							) 
						)
					{
					//
					//   Update the statistics and return
					//   the top element on the stack.
					//
#ifdef ENABLE_HEAP_STATISTICS
					CacheFills ++;
#endif
					NewMemory = NewStack[ (-- TopOfNewStack) ]; 
					}
				else
					{
					//
					//   Update the statistics and fail
					//   the request for memeory.
					//
					NewMemory = ((VOID*) AllocationFailure);
					}
				}
			}
		}
	else
		{ 
		//
		//   We may want to enable the cache for next
		//   time so see if this needs to be done.
		//
		if ( CacheSize > 1 )
			{ CreateCacheStacks(); }

		//
		//   The cache is disabled so go directly to the
		//   bucket.
		//
		NewMemory = ((BUCKET*) this) -> New( False ); 
		}
#ifdef ENABLE_HEAP_STATISTICS

	//
	//   Update the usage statistics.
	//
	ComputeHighWater( (NewMemory != ((VOID*) AllocationFailure)) );
#endif

	//
	//   Release any lock we may have claimed earlier.
	//
	ReleaseCacheLock();

	//
	//   Prefetch the first cache line if we are running
	//   a Pentium III or better.
	//
	Prefetch.L1( ((CHAR*) NewMemory),1 );

	return NewMemory;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation for non-standard sizes.                      */
    /*                                                                  */
    /*   A non standard sized allocation simply by-passes the cache     */
    /*   but it still needs to hold the lock to prevent failure on      */
    /*   SMP systems.                                                   */
    /*                                                                  */
    /********************************************************************/

VOID *CACHE::New( BOOLEAN SubDivided,SBIT32 NewSize )
	{
	REGISTER VOID *NewMemory;

	//
	//   When there is a potential for multiple threads we
	//   claim the cache lock.
	//
	ClaimCacheLock();

	//
	//   Allocate a non-standard sized block.
	//
	NewMemory = ((BUCKET*) this) -> New( SubDivided,NewSize );
#ifdef ENABLE_HEAP_STATISTICS

	//
	//   Update the usage statistics.
	//
	ComputeHighWater( (NewMemory != ((VOID*) AllocationFailure)) );
#endif

	//
	//   Release any lock we may have claimed earlier.
	//
	ReleaseCacheLock();

	return NewMemory;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Release free space.                                            */
    /*                                                                  */
    /*   We sometimes do not release free space from a bucket as        */
    /*   returning it to the operating system and getting it again      */
    /*   later is very expensive.  Here we flush any free space we      */
    /*   have aquired over the user supplied limit.                     */
    /*                                                                  */
    /********************************************************************/

VOID CACHE::ReleaseSpace( SBIT32 MaxActivePages )
	{
	//
	//   When there is a potential for multiple threads 
	//   we claim the cache lock.
	//
	ClaimCacheLock();

	//
	//   Release the free space from the backet.
	//
	((BUCKET*) this) -> ReleaseSpace( MaxActivePages );

	//
	//   Release any lock we may have claimed earlier.
	//
	ReleaseCacheLock();
	}

    /********************************************************************/
    /*                                                                  */
    /*   Search the cacahe for an allocation.                           */
    /*                                                                  */
    /*   We sometimes need to search the cache to see if an             */
    /*   allocation is currently in the cacahe awaiting allocation      */
    /*   or release.                                                    */
    /*                                                                  */
    /********************************************************************/

BOOLEAN CACHE::SearchCache( VOID *Address )
	{
	REGISTER BOOLEAN Result = False;

	//
	//   We check to see if the cache is active.
	//
	if ( Active )
		{
		//
		//   When there is a potential for multiple 
		//   threads we claim the cache lock.
		//
		ClaimCacheLock();

		//
		//   We check to see if the cache is still 
		//   active.
		//
		if ( Active )
			{
			REGISTER SBIT32 Count;

			//
			//   Search the allocated cache.
			//
			for ( Count=(TopOfNewStack-1);Count >= 0;Count -- )
				{ 
				if ( Address == NewStack[ Count ] )
					{
					Result = True;
					break;
					}
				}

			//
			//   If it has not been found yet then try
			//   the deleted cache.
			//
			if ( ! Result )
				{
				//
				//   Search the deleted cache.
				//
				for ( Count=(TopOfDeleteStack-1);Count >= 0;Count -- )
					{ 
					if ( Address == DeleteStack[ Count ].Address )
						{
						Result = True;
						break;
						}
					}
				}
			}

		//
		//   Release any lock we may have claimed earlier.
		//
		ReleaseCacheLock();
		}

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Truncate the heap.                                             */
    /*                                                                  */
    /*   Flush the cache to release the maximum amount of space back    */
    /*   to the operating system.  This is slow but may be very         */
    /*   valuable in some situations.                                   */
    /*                                                                  */
    /********************************************************************/

BOOLEAN CACHE::Truncate( VOID )
	{
	REGISTER BOOLEAN Result = True;

	//
	//   When there is a potential for multiple threads we
	//   claim the cache lock.
	//
	ClaimCacheLock();

	//
	//   Disable the cache if needed.
	//
	Active = False;

	//
	//   Setup the fill size.
	//
	FillSize = 1;

	//
	//   Flush any elements in the delete cache.
	//   We do this now because we need to use 
	//   the delete cache below.
	//
	if ( TopOfDeleteStack > 0 )
		{
		AUTO SBIT32 Deleted;

		//
		//   Flush the delete stack.
		//
		Result = 
			(
			((BUCKET*) this) -> MultipleDelete
				(
				DeleteStack,
				& Deleted,
				TopOfDeleteStack 
				)
				&&
			(Result)
			);
#ifdef ENABLE_HEAP_STATISTICS

		//
		//   Update the usage statistics.  There
		//   is a nasty case here where we cache
		//   a delete only to find out later that
		//   it was bogus.   When this occurs we
		//   have to increase the 'InUse' count 
		//   to allow for this situation.
		//
		CacheFlushes ++;
		
		InUse += (TopOfDeleteStack - Deleted);
#endif
		
		//
		//   Zero the top of the stack.
		//
		TopOfDeleteStack = 0;
		}
	
	//
	//   Flush any elements in the new cache by
	//   copying them over to the delete cache
	//   and adding the additional information
	//   required.
	//
	if ( TopOfNewStack > 0 )
		{
		//
		//   We need to find the data page for each  
		//   allocation we have in the new cache.
		//   Claim the lock here to make things a
		//   little more efficient.
		//
		Find -> ClaimFindShareLock();

		//
		//   We copy each allocation across and 
		//   add the associated page information.
		//
		for ( TopOfNewStack --;TopOfNewStack >= 0;TopOfNewStack -- )
			{
			REGISTER VOID *Address = (NewStack[ TopOfNewStack ]);
			REGISTER PAGE *Page = (ParentCache -> FindChildPage( Address ));

			//
			//   You would think that any memory in the
			//   new cache had to be valid.   Well it
			//   does except in the case when we have
			//   'Recycle' set and somebody does a double
			//   delete on a valid heap address.
			//
			if ( Page != NULL )
				{
				REGISTER ADDRESS_AND_PAGE *Current = 
					(& DeleteStack[ TopOfDeleteStack ++ ]);

				//
				//   We need to find the allocation page
				//   where the memory was allocated from
				//   so we can delete it.
				//
				Current -> Address = Address;
				Current -> Page = Page;
				Current -> Version = Page -> GetVersion();
				}
			else
				{ 
#ifdef ENABLE_HEAP_STATISTICS
				//
				//   Update the usage statistics.  There
				//   is a nasty case here where we cache
				//   a delete only to find out later that
				//   it was bogus.   When this occurs we
				//   have to increase the 'InUse' count 
				//   to allow for this situation.
				//
				InUse ++;

#endif
				Result = False; 
				}
			}

		//
		//   Release the lock.
		//
		Find -> ReleaseFindShareLock();
		}

	//
	//   Flush the delete cache again to delete
	//   any new elements that we added to it
	//   above.
	//
	if ( TopOfDeleteStack > 0 )
		{
		AUTO SBIT32 Deleted;

		//
		//   Flush the delete stack.
		//
		Result = 
			(
			((BUCKET*) this) -> MultipleDelete
				(
				DeleteStack,
				& Deleted,
				TopOfDeleteStack 
				)
				&&
			(Result)
			);
#ifdef ENABLE_HEAP_STATISTICS

		//
		//   Update the usage statistics.  There
		//   is a nasty case here where we cache
		//   a delete only to find out later that
		//   it was bogus.   When this occurs we
		//   have to increase the 'InUse' count 
		//   to allow for this situation.
		//
		CacheFlushes ++;
		
		InUse += (TopOfDeleteStack - Deleted);
#endif
		
		//
		//   Zero the top of the stack.
		//
		TopOfDeleteStack = 0;
		}

	//
	//   Release any lock we may have claimed earlier.
	//
	ReleaseCacheLock();

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Update the bucket information.                                 */
    /*                                                                  */
    /*   When we create the bucket there is some information that       */
    /*   is not available.  Here we update the bucket to make sure      */
    /*   it has all the data it needs.                                  */
    /*                                                                  */
    /********************************************************************/

VOID CACHE::UpdateCache
		( 
		FIND						  *NewFind,
		HEAP						  *NewHeap,
		NEW_PAGE					  *NewPages,
		CACHE						  *NewParentCache
		)
	{
	//
	//   Notify the parent cache that it has a new
	//   child.
	//
	if ( NewParentCache != ((CACHE*) GlobalRoot) )
		{ NewParentCache -> NumberOfChildren ++; }

	//
	//   Update the allocation bucket.
	//
	UpdateBucket
		( 
		NewFind,
		NewHeap,
		NewPages,
		NewParentCache 
		);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the cache and ensure it is disabled.                   */
    /*                                                                  */
    /********************************************************************/

CACHE::~CACHE( VOID )
	{
	if ( Active )
		{ Failure( "Cache active in destructor for CACHE" ); }
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\heap\cache.hpp ===
#ifndef _CACHE_HPP_
#define _CACHE_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Bucket.hpp"
#include "Find.hpp"
#include "NewPage.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   The allocation cache.                                          */
    /*                                                                  */
    /*   The memory allocation cache consists of two stacks.  The       */
    /*   first stack contains preallocated elements which are           */
    /*   available for use.  The second stack contains elements         */
    /*   which have been deallocated and are about to be recycled.      */
    /*                                                                  */
    /********************************************************************/

class CACHE : public BUCKET
    {
		//
		//   Private data.
		//
		//   A cache sits on top of a bucket and shields 
		//   it from being swamped by calls.  The 'Active'
		//   flag is set when the cache is active.  The
		//   'Stealing' flag indicates that deallocated
		//   memory can be stolen and reallocated.  The
		//   'ThreadSafe' flag indicates that locking is
		//   required.
		//
		BOOLEAN						  Active;
		BOOLEAN						  Stealing;
		BOOLEAN						  ThreadSafe;
#ifdef ENABLE_HEAP_STATISTICS

		//
		//   When we are collecting statistics we enable 
		//   the following variables.  The 'CacheFills' 
		//   count keeps track of the number of times
		//   the cache was filled from the bucket.  The
		//   'CacheFlushes' count keeps track of the 
		//   number of times the cache flushed deleted
		//   elements to the bucket.  The 'HighTide' count  
		//   keeps track the the highest number of outstanding
		//   allocations since the last "DeleteAll()'.  The 
		//   'HighWater' count keeps track of the maximum 
		//   number of allocations at any point.  The
		//   'InUse' counts the the current number of outstanding 
		//   allocations.
		//
		SBIT32						  CacheFills;
		SBIT32						  CacheFlushes;
		SBIT32						  HighTide;
		SBIT32						  HighWater;
		SBIT32						  InUse;
#endif

		//
		//   A cache can be controlled by the user.  The
		//   'CacheSize' controls the number of allocations
		//   that can be preallocated or queued for 
		//   deletion.  The 'NumberOfChildren' is a count
		//   of the number of caches that allocate space
		//   from this cache.
		//
		SBIT16						  CacheSize;
		SBIT16						  FillSize;
		SBIT16						  NumberOfChildren;

		//
		//   The cache consists of two stacks.  The
		//   'DeleteStack' contains elements that are 
		//   waiting to be deleted.  The 'NewStack' 
		//   contains elements waiting to be allocated.
		//
		ADDRESS_AND_PAGE			  *DeleteStack;
		VOID						  **NewStack;

		//
		//   The top of the deleted stack is kept in
		//   'TopOfDeleteStack' and the top of the new
		//   stack is kept in 'TopOfNewStack'.
		//
		SBIT32						  TopOfDeleteStack;
		SBIT32						  TopOfNewStack;

		//
		//   The 'Spinlock' is a fast lock employed to
		//   make the cache multi-threaded if 'ThreadSafe'
		//   is true.
		//   
		SPINLOCK					  Spinlock;

   public:
		//
		//   Public functions.
		//
		//   The cacahe is a subset of the full haep interface
		//   a certain calls simply bypass it.  However, there
		//   are a few additional functions for cases where the
		//   cache needs to be notified of significant heap
		//   events.
		//
        CACHE
			( 
			SBIT32					  NewAllocationSize,
			SBIT32					  NewCacheSize,
			SBIT32					  NewChunkSize,
			SBIT32					  NewPageSize,
			BOOLEAN					  NewStealing,
			BOOLEAN					  NewThreadSafe
			);

		VOID *CreateDataPage( VOID );

		BOOLEAN Delete( VOID *Address,PAGE *Page,SBIT32 Version );

		VOID DeleteAll( VOID );

		BOOLEAN DeleteDataPage( VOID *Address );

		BOOLEAN MultipleNew
			( 
			SBIT32					  *Actual,
			VOID					  *Array[],
			SBIT32					  Requested 
			);

		VOID *New( VOID );

		VOID *New( BOOLEAN SubDivided,SBIT32 NewSize = NoSize );

		VOID ReleaseSpace( SBIT32 MaxActivePages );

		BOOLEAN SearchCache( VOID *Address );

		BOOLEAN Truncate( VOID );

		VOID UpdateCache
			( 
			FIND					  *NewFind,
			HEAP					  *NewHeap,
			NEW_PAGE				  *NewPages,
			CACHE					  *NewParentCache
			);

        ~CACHE( VOID );

		//
		//   Public inline functions.
		//
		//   A cache just like its parent bucket is closely
		//   coupled to various other classes and provides
		//   then is vital information.
		//
		INLINE VOID ClaimCacheLock( VOID )
			{
			if ( (ThreadSafe) && (Find -> GetLockCount() == 0) )
				{ Spinlock.ClaimLock(); } 
			}

		INLINE PAGE *FindChildPage( VOID *Address )
			{
			return Find -> FindPage
				( 
				((VOID*) (((BIT32) Address) & ~(GetAllocationSize()-1))),
				(CACHE*) this
				); 
			}

		INLINE PAGE *FindParentPage( VOID *Address )
			{
			return Find -> FindPage
				( 
				((VOID*) (((BIT32) Address) & ~(GetPageSize()-1))),
				ParentCache
				); 
			}

		INLINE SBIT16 GetCacheSize( VOID )
			{ return CacheSize; }

		INLINE SBIT32 GetNumberOfChildren( VOID )
			{ return NumberOfChildren; }

		INLINE VOID ReleaseCacheLock( VOID )
			{
			if ( (ThreadSafe) && (Find -> GetLockCount() == 0) )
				{ Spinlock.ReleaseLock(); } 
			}

		INLINE BOOLEAN Walk( SEARCH_PAGE *Details )
			{ return NewPage -> Walk( Details ); }
#ifdef ENABLE_HEAP_STATISTICS

		//
		//   Cache statistics.
		//
		//   A cache has a collection statistics which it
		//   uses to measure how it is doing.  It is possible
		//   to get access to this data for the purpose of
		//   outputing various reports.
		//
		INLINE SBIT32 GetCacheFills( VOID )
			{ return CacheFills; }

		INLINE SBIT32 GetCacheFlushes( VOID )
			{ return CacheFlushes; }

		INLINE SBIT32 GetHighWater( VOID )
			{ return HighWater; }
#endif

	private:
		//
		//   Private functions.
		//
		//   A cache is initially inactive.  If at least one
		//   allocation request is made it will spring into
		//   life, allocate any space needed and prepare itself
		//   for use.
		//
		VOID CreateCacheStacks( VOID );
#ifdef ENABLE_HEAP_STATISTICS

		VOID ComputeHighWater( SBIT32 Size );
#endif

        //
        //   Disabled operations.
 		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        CACHE( CONST CACHE & Copy );

        VOID operator=( CONST CACHE & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\heap\bucket.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "HeapPCH.hpp"

#include "Bucket.hpp"
#include "Cache.hpp"
#include "Heap.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here relate the compuation of the       */
    /*   current active page address range.                             */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 HighestAddress			  = -1;

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new allocation bucket and prepare it for use.         */
    /*   We need to be sure to carefully check everything we have       */
    /*   been supplied as it has come indirectly from the user.         */
    /*                                                                  */
    /********************************************************************/

BUCKET::BUCKET
		( 
		SBIT32						  NewAllocationSize,
		SBIT32						  NewChunkSize,
		SBIT32						  NewPageSize 
		)
    {
	//
	//   We want to make sure that the bucket configuration
	//   appears to make basic sense.  If not we have no 
	//   alternative than to throw an expection.
	//
	if
			(
			(NewAllocationSize > 0)
				&&
			(NewChunkSize >= NewAllocationSize)
				&&
			(NewChunkSize <= NewPageSize)
				&&
			PowerOfTwo( NewPageSize )
			)
		{
		//
		//   Create the bucket and prepare it for use.
		//   Pre-compute any information we can here to
		//   save work later.
		//
		AllocationSize = NewAllocationSize;
		ChunkSize = NewChunkSize;
		PageSize = NewPageSize;

		ActivePages = 0;
		AllocationShift = 0;

		//
		//   Compute the optimization level from the
		//   available bucket information.  The highest
		//   level means everything is a power of two
		//   (just shifts - yipee !!).  The next means
		//   means no chunks (just multiplies and one 
		//   divide).  The final alternative is not even
		//   pleasant to think about.
		//   
		if ( ConvertDivideToShift( AllocationSize,& AllocationShift ) )
			{
			//
			//   If we are not using chunking we can skip the
			//   extra compuation that is needed.  We can tell
			//   this is the case if the chunk size and the page
			//   size match or if the chunk size is a multiple
			//   of the allocation size.
			//
			if 
					( 
					(ChunkSize == PageSize)
						||
					((ChunkSize % AllocationSize) == 0)
					)
				{
				ComputeAddressFunction = ComputeAddressWithShift;
				ComputeOffsetFunction = ComputeOffsetWithShift;
				}
			else
				{ 
				ComputeAddressFunction = ComputeAddressWithDivide;
				ComputeOffsetFunction = ComputeOffsetWithDivide;
				}
			}
		else
			{
			//
			//   If we are not using chunking we can ship the
			//   extra compuation that is needed.  We can tell
			//   this is the case if the chunk size and the page
			//   size match or if the chunk size is a multiple
			//   of the allocation size.
			//
			if 
					( 
					(ChunkSize == PageSize)
						||
					((ChunkSize % AllocationSize) == 0)
					)
				{ 
				ComputeAddressFunction = ComputeAddressWithMultiply;
				ComputeOffsetFunction = ComputeOffsetWithMultiply;
				}
			else
				{ 
				ComputeAddressFunction = ComputeAddressWithDivide;
				ComputeOffsetFunction = ComputeOffsetWithDivide;
				}
			}

		//
		//   Compute all the information that will be
		//   needed later to describe the allocation
		//   pages.
		//
		NumberOfElements = 
			((SBIT16) ((PageSize / ChunkSize) * (ChunkSize / AllocationSize)));
		SizeOfChunks = (SBIT16)
			((SBIT16) (ChunkSize / AllocationSize));
		SizeOfElements = (SBIT16)
			((SBIT16) (((NumberOfElements-1) / OverheadBitsPerWord) + 1));
		SizeKey = NoSizeKey;
		}
	else
		{ Failure( "Configuration in constructor for BUCKET" ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Compute the allocation address.                                */
    /*                                                                  */
    /*   Compute the allocation address given the page address and      */
    /*   the vector offset in the page.                                 */
    /*                                                                  */
    /********************************************************************/

VOID *BUCKET::ComputeAddressWithShift( CHAR *Address,SBIT32 Offset )
	{ return ((VOID*) (Address + (Offset << AllocationShift))); }

    /********************************************************************/
    /*                                                                  */
    /*   Compute the allocation address.                                */
    /*                                                                  */
    /*   Compute the allocation address given the page address and      */
    /*   the vector offset in the page.                                 */
    /*                                                                  */
    /********************************************************************/

VOID *BUCKET::ComputeAddressWithMultiply( CHAR *Address,SBIT32 Offset )
	{ return ((VOID*) (Address + (Offset * AllocationSize))); }

    /********************************************************************/
    /*                                                                  */
    /*   Compute the allocation address.                                */
    /*                                                                  */
    /*   Compute the allocation address given the page address and      */
    /*   the vector offset in the page.                                 */
    /*                                                                  */
    /********************************************************************/

VOID *BUCKET::ComputeAddressWithDivide( CHAR *Address,SBIT32 Offset )
	{
	REGISTER SBIT32 ChunkNumber = (Offset / SizeOfChunks);
	REGISTER SBIT32 ChunkOffset = (ChunkNumber * SizeOfChunks);
	REGISTER SBIT32 AllocationNumber = (Offset - ChunkOffset);

	return
		((VOID*)
			(
			Address 
				+
			(ChunkNumber * ChunkSize)
				+
			(AllocationNumber * AllocationSize)
			)
		);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Compute the bit vector offset.                                 */
    /*                                                                  */
    /*   Compute the bit vector offset given the address of the         */
    /*   memory allocation in the page.                                 */
    /*                                                                  */
    /********************************************************************/

SBIT32 BUCKET::ComputeOffsetWithShift( SBIT32 Displacement,BOOLEAN *Found )
	{
	REGISTER SBIT32 ArrayOffset;

	ArrayOffset = (Displacement >> AllocationShift);

	(*Found) = (Displacement == (ArrayOffset << AllocationShift));
#ifdef DEBUGGING

	if ( ArrayOffset >= NumberOfElements )
		{ Failure( "Array offset in ComputeOffsetWithShift" ); }
#endif

	return ArrayOffset;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Compute the bit vector offset.                                 */
    /*                                                                  */
    /*   Compute the bit vector offset given the address of the         */
    /*   memory allocation in the page.                                 */
    /*                                                                  */
    /********************************************************************/

SBIT32 BUCKET::ComputeOffsetWithMultiply( SBIT32 Displacement,BOOLEAN *Found )
	{
	REGISTER SBIT32 ArrayOffset;

	ArrayOffset = (Displacement / AllocationSize);

	(*Found) = (Displacement == (ArrayOffset * AllocationSize));
#ifdef DEBUGGING

	if ( ArrayOffset >= NumberOfElements )
		{ Failure( "Array offset in ComputeOffsetWithMultiply" ); }
#endif

	return ArrayOffset;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Compute the bit vector offset.                                 */
    /*                                                                  */
    /*   Compute the bit vector offset given the address of the         */
    /*   memory allocation in the page.                                 */
    /*                                                                  */
    /********************************************************************/

SBIT32 BUCKET::ComputeOffsetWithDivide( SBIT32 Displacement,BOOLEAN *Found )
	{
	REGISTER SBIT32 ArrayOffset;
	REGISTER SBIT32 ChunkNumber = (Displacement / ChunkSize);
	REGISTER SBIT32 ChunkAddress = (ChunkNumber * ChunkSize);
	REGISTER SBIT32 ChunkOffset = (Displacement - ChunkAddress);
	REGISTER SBIT32 AllocationNumber = (ChunkOffset / AllocationSize);

	ArrayOffset = ((ChunkNumber * SizeOfChunks) + AllocationNumber);

	(*Found) = 
		(
		(Displacement) 
			== 
		(ChunkAddress + (AllocationNumber * AllocationSize))
		);
#ifdef DEBUGGING

	if ( ArrayOffset >= NumberOfElements )
		{ Failure( "Array offset in ComputeOffsetWithDivide" ); }
#endif

	return ArrayOffset;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete a memory allocation.                                    */
    /*                                                                  */
    /*   We need to delete a single memory allocation from a bucket.    */
    /*   We do this by passing the request on to the page.              */
    /*                                                                  */
    /********************************************************************/

BOOLEAN BUCKET::Delete( VOID *Address,PAGE *Page,SBIT32 Version )
	{
	AUTO SEARCH_PAGE Details;

	//
	//   When we delete an allocation we need to ensure 
	//   the page has not radically changed since we found
	//   it.  Hence, we compare the current page version  
	//   number with the one we found earlier.  If all is 
	//   well we get the details relating to the allocation
	//   and then delete it.
	//
	return
		(
		((Page -> GetVersion()) == Version)
			&&
		(Page -> FindPage( Address,& Details,False ) != NULL)
			&&
		(Page -> Delete( & Details ))
		);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete a page from the bucket list.                            */
    /*                                                                  */
    /*   When a page becomes full it is removed from the bucket list    */
    /*   so it will be no longer inspected when looking for free space. */
    /*                                                                  */
    /********************************************************************/

VOID BUCKET::DeleteFromBucketList( PAGE *Page )
	{
	//
	//   We keep track of the number of active pages on the 
	//   bucket list.  This helps us when we need to scan the
	//   bucket list for some reason later.
	//
	if ( (-- ActivePages) >= 0 )
		{
		//
		//   Delete the page from the bucket list as it is 
		//   no longer needed.  There are two cases when this 
		//   happens.  When the page is full and when the page 
		//   is about to be deleted.
		//
		Page -> DeleteFromBucketList( & BucketList );

		//
		//   Compute the highest address on the first page.  We 
		//   use this information to figure out whether to 
		//   recycle an allocation or pass it along for deletion
		//   in the cache.
		//
		Page = (PAGE::FirstInBucketList( & BucketList ));
		
		if ( ! Page -> EndOfBucketList() )
			{
			CurrentPage =
				(
				((VOID*) (((LONG) Page -> GetAddress()) + (PageSize - 1)))
				);
			}
		else
			{ CurrentPage = ((VOID*) HighestAddress); }
		}
	else
		{ Failure( "Active page count in DeleteFromBucketList" ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Insert a page into the bucket list.                            */
    /*                                                                  */
    /*   When a page is created or when it changes from being full      */
    /*   to having at least one free slot it is added to the bucket     */
    /*   list so that it can be used to allocate space.                 */
    /*                                                                  */
    /********************************************************************/

VOID BUCKET::InsertInBucketList( PAGE *Page )
	{
	//
	//   We keep track of the number of active pages on the 
	//   bucket list.  This helps us when we need to scan the
	//   bucket list for some reason later.
	//
	ActivePages ++;

	//
	//   We insert pages into the list in ascending address
	//   order.  This ensures that we always allocate the 
	//   lowest addresses first.  This is done to try to keep 
	//   the working set small and compact.
	//
	if ( ! BucketList.EndOfList() )
		{
		REGISTER VOID *Address = (Page -> GetAddress());
		REGISTER PAGE *Last = (Page -> LastInBucketList( & BucketList ));

		//
		//   We are about to walk the entire page list
		//   trying to find where to insert this page.
		//   Lets see if the page needs to be inserted
		//   at the end of the list.  If so have saved
		//   ourseleves a lot of work and we can exit 
		//   early.
		//   
		if ( Address < (Last -> GetAddress()) )
			{
			REGISTER PAGE *Current;

			//
			//   Well it looks like we need to walk along 
			//   the entire page list to find the correct 
			//   place to insert this element.
			//
			for 
					( 
					Current = (Page -> FirstInBucketList( & BucketList ));
					! Current -> EndOfBucketList();
					Current = Current -> NextInBucketList() 
					)
				{
				//
				//   While the current address is lower 
				//   than ours we need to keep on walking.
				//
				if ( Address < (Current -> GetAddress()) )
					{
					//
					//   We have found the spot so insert 
					//   the bucket just before the current 
					//   bucket.
					//
					Current -> InsertBeforeInBucketList( & BucketList,Page );

					break;
					}
				}
			}
		else
			{
			//
			//   The page has the highest address so insert
			//   it at the end of the list.
			//
			Last -> InsertAfterInBucketList( & BucketList,Page );
			}
		}
	else
		{ Page -> InsertInBucketList( & BucketList ); }

	//
	//   Compute the highest address on the first page.  We can
	//   use this information to figure out whether to recycle an
	//   allocation or pass it along for deletion in the cache.
	//
	Page = (PAGE::FirstInBucketList( & BucketList ));
	
	CurrentPage =
		(
		((VOID*) (((LONG) Page -> GetAddress()) + (PageSize - 1)))
		);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory deallocations.                                 */
    /*                                                                  */
    /*   When the delete cache becomes full we complete any pending     */
    /*   delete requests.  We also flush the delete cache when if       */
    /*   we need to allocate additional memory unless recycling is      */
    /*   enabled in which case we just steal it directly from the       */
    /*   delete cache.                                                  */
    /*                                                                  */
    /********************************************************************/

BOOLEAN BUCKET::MultipleDelete
		( 
		ADDRESS_AND_PAGE			  *Array,
		SBIT32						  *Deleted,
		SBIT32						  Size 
		)
	{
	AUTO SEARCH_PAGE Details;
	REGISTER SBIT32 Count;

	//
	//   Zero the count of deleted items.
	//
	(*Deleted) = 0;

	//
	//   Delete each element one at a time.  We would love to
	//   delete them all at once but we haven't got a clue where
	//   they have come from so we have to do it one at a time. 
	//   
	for ( Count=0;Count < Size;Count ++ )
		{
		REGISTER ADDRESS_AND_PAGE *Current = & Array[ Count ];
		REGISTER PAGE *Page = Current -> Page;

		//
		//   It may see like a waste of time to batch up all
		//   the deletions.  Why not do them as they arrive.
		//   There are a number of reasons.  The deletes can
		//   be recycled, batchs of deletes is faster than
		//   single deletes (due to cache effects) and so on.
		//
		if
				(
				(Current -> Version == Page -> GetVersion())
					&&
				(Page -> FindPage( Current -> Address,& Details,False ) != NULL)
					&&
				(Page -> Delete( & Details ))
				)
			{ (*Deleted) ++; }
		}

	return ((*Deleted) == Size);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory allocations.                                   */
    /*                                                                  */
    /*   We need to make a multiple memory allocation from this			*/
    /*   bucket so walk the bucket list allocating any available        */
    /*   space and return it to the caller.                             */
    /*                                                                  */
    /********************************************************************/

BOOLEAN BUCKET::MultipleNew
		( 
		SBIT32						  *Actual,
		VOID						  *Array[],
		SBIT32						  Requested 
		)
    {
	//
	//   Zero the count of allocated elements.
	//
	(*Actual) = 0;

	//
	//   We walk the sorted list of pages with available
	//   allocations searching for elements to allocate.
	//
	do
		{
		REGISTER PAGE *Page;
		REGISTER PAGE *NextPage;

		//
		//   Walk the bucket list looking for any available
		//   free space.
		//
		for 
				( 
				Page = (PAGE::FirstInBucketList( & BucketList ));
				! Page -> EndOfBucketList();
				Page = NextPage
				)
			{
			REGISTER SBIT32 ActualSize = (Page -> GetPageSize());

			//
			//   Lets find the next page now as the current 
			//   bucket may be removed from the bucket list
			//   by the following allocation call.
			//
			NextPage = Page -> NextInBucketList();

			//
			//   We allow the page size to be dynamically
			//   modified to support a variety of wierd
			//   data layouts for BBT.   If the current page
			//   is not the standard size then skip it.
			//
			if ( (ActualSize == NoSize) || (ActualSize == PageSize) )
				{
				//
				//   We try allocate all the space we need 
				//   from each page in the bucket list.  If 
				//   the page has enough space we can exit 
				//   early if not we go round the loop and
				//   try the next page.
				//
				if ( Page -> MultipleNew( Actual,Array,Requested ) )
					{ return True; }
				}
			}
		}
	while 
		( 
		NewPage -> CreatePage( (CACHE*) this )
			!= 
		((PAGE*) AllocationFailure) 
		);

	//
	//   We see if we managed to allocate all the elements
	//   we wanted.  If so we are happy and we can get out 
	//   of here.
	//
	if ( (*Actual) < Requested )
		{
		//
		//   We see if we managed to allocate any elements 
		//   at all.  If not we fail the request.
		//
		if ( (*Actual) > 0 )
			{
			REGISTER SBIT32 Count;
			REGISTER SBIT32 Delta = ((Requested) - (*Actual));

			//
			//   We are very naughty when we allocate multiple
			//   elements in that we put them in the array in
			//   reverse order.  The logic is that this is just
			//   what we want when we allocate out of the cache.
			//   However, if we are unable to allocate all the
			//   elements we needed then we have to move the 
			//   pointers down to the base of the array.
			//
			for ( Count=0;Count < (*Actual);Count ++ )
				{ Array[ Count ] = Array[ (Count + Delta) ]; }
			}
		else
			{ return False; }
		}

	return True;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation.                                             */
    /*                                                                  */
    /*   We need to make a new memory allocation from this bucket       */
    /*   so search the page list of available space and return a        */
    /*   free element.                                                  */
    /*                                                                  */
    /********************************************************************/

VOID *BUCKET::New( BOOLEAN SubDivided,SBIT32 NewSize )
    {
	do
		{
		REGISTER PAGE *Page;

		//
		//   Walk the bucket list looking for any available
		//   free space.
		//
		for 
				( 
				Page = (PAGE::FirstInBucketList( & BucketList ));
				! Page -> EndOfBucketList();
				Page = Page -> NextInBucketList()
				)
			{
			REGISTER SBIT32 ActualSize = (Page -> GetPageSize());

			//
			//   We allow the page size to be dynamically
			//   modified to support a variety of wierd
			//   data layouts for BBT.   If the current page
			//   is not the correct size then skip it.
			//
			if 
					( 
					(ActualSize == NoSize) 
						|| 
					(ActualSize == ((NewSize == NoSize) ? PageSize : NewSize))
					)
				{
				//
				//   We know that any page that appears in 
				//   the bucket list will have at least one 
				//   free element available.  So if we find
				//   that the bucket list a suitable page 
				//   then we know that we can allocate something.
				//
				return (Page -> New( SubDivided ));
				}
			}
		}
	while 
		( 
		NewPage -> CreatePage( ((CACHE*) this),NewSize ) 
			!= 
		((PAGE*) AllocationFailure) 
		);

	//
	//   We were unable to find anything we could allocate
	//   so fail the request.
	//
	return ((VOID*) AllocationFailure);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Release free space.                                            */
    /*                                                                  */
    /*   We sometimes do not release free space from a bucket as        */
    /*   returning it to the operating system and getting it again      */
    /*   later is very expensive.  Here we flush any free space we      */
    /*   have aquired over the user supplied limit.                     */
    /*                                                                  */
    /********************************************************************/

VOID BUCKET::ReleaseSpace( SBIT32 MaxActivePages )
    {
	REGISTER SBIT32 Current = ActivePages;

	//
	//   We only bother to try to trim the number of
	//   active pages if we are over the limit.
	//
	if ( Current > MaxActivePages )
		{
		REGISTER PAGE *NextPage;
		REGISTER PAGE *Page;

		//
		//   Walk the backwards along the bucket list 
		//   and delete the highest addressed free pages
		//   if we are over the limit.
		//
		for 
				( 
				Page = (PAGE::LastInBucketList( & BucketList ));
				(Current > MaxActivePages) 
					&& 
				(! Page -> EndOfBucketList());
				Page = NextPage
				)
			{
			//
			//   We are walking backwards down the bucket
			//   list looking for empty pages to delete.
			//   However, if we find a page we can remove
			//   it will be automatically removed from the
			//   list so we need to get the next pointer
			//   before this happens.
			//
			NextPage = Page -> PreviousInBucketList();

			//
			//   We can only release a page if it is empty
			//   if not we must skip it.
			//
			if ( Page -> Empty() )
				{
				Current --;

				DeletePage( Page ); 
				}
			}
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Update the bucket information.                                 */
    /*                                                                  */
    /*   When we create the bucket there is some information that       */
    /*   is not available.  Here we update the bucket to make sure      */
    /*   it has all the data we need.                                   */
    /*                                                                  */
    /********************************************************************/

VOID BUCKET::UpdateBucket
		( 
		FIND						  *NewFind,
		HEAP						  *NewHeap,
		NEW_PAGE					  *NewPages,
		CACHE						  *NewParentCache
		)
	{
	REGISTER SBIT16 NewSizeKey = (NewPages -> FindSizeKey( NumberOfElements ));

	//
	//   We compute and verify the size key to make sure
	//   it is suitable for all the pages that we will
	//   create after the heap constructor is completed.
	//
	if ( NewSizeKey != NoSizeKey )
		{
		//
		//   Update the size key and the connections.
		//
		SizeKey = NewSizeKey;

		UpdateConnections
			( 
			NewFind,
			NewHeap,
			NewPages,
			NewParentCache 
			);
		}
	else
		{ Failure( "Bucket can't get a size key in UpdateBucket" ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the allocation bucket.                                 */
    /*                                                                  */
    /********************************************************************/

BUCKET::~BUCKET( VOID )
	{ /* void */ }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\heap\bucket.hpp ===
#ifndef _BUCKET_HPP_
#define _BUCKET_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Connections.hpp"
#include "Page.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class CACHE;
class HEAP;

    /********************************************************************/
    /*                                                                  */
    /*   A collection of pages.                                         */
    /*                                                                  */
    /*   A bucket is a collection of pages capable of allocating        */
    /*   fixed sized memory elements.  The pages are allocated from     */
    /*   from larger buckets and are stored in a linked list in         */
    /*   order of ascending of page addresses.                          */
    /*                                                                  */
    /********************************************************************/

class BUCKET : public CONNECTIONS
    {
		//
		//   Private type definitions.
		//
		//   All allocations are registered in bit vectors.
		//   Here we have some prototypes for seriously  
		//   optimized functions to do address to bit 
		//   vector computations.
		//
		typedef VOID *(BUCKET::*COMPUTE_ADDRESS)
			( 
			CHAR					  *Address,
			SBIT32					  Offset 
			);

		typedef SBIT32 (BUCKET::*COMPUTE_OFFSET)
			( 
			SBIT32					  Displacement,
			BOOLEAN					  *Found 
			);

		//
		//   Private data.
		//
		//   A bucket owns all the memory of a given size
		//   and manages it.  Above it is a cache to 
		//   protect it from huge number of calls and
		//   below it are the connections to various 
		//   other classes.  The 'AllocationSize' is the
		//   buckets allocation size.  The 'ChunkSize' is
		//   chunking size which is typically half way
		//   between the 'AllocationSize' and the 'PageSize'.
		//   The 'PageSize' is the size of the bucket
		//   where this bucket gets its space.
		//   
		//
		SBIT32                        AllocationSize;
		SBIT32						  ChunkSize;
		SBIT32						  PageSize;

		//
		//   It is the job of the bucket to keep track of
		//   all the information relating to allocations
		//   of a given 'AllocationSize'.  The 'ActivePages'
		//   keeps track of the number of available pages
		//   in the 'BucketList'.  The 'BucketList' is a
		//   linked list of pages that have available space.
		//   The 'CurrentPage' contains the highest address
		//   of the first page in the 'BucketList'.
		//
		SBIT32						  ActivePages;
		LIST						  BucketList;
		VOID						  *CurrentPage;

		//
		//   A bucket needs to be able to quickly convert
		//   bit vector offsets to addresses (and vice versa).
		//   The 'AllocationShift' is set when the 
		//   'AllocationSize' is a power of two to avoid 
		//   any divides.  The 'ComputeAddressFunction'
		//   and 'ComputeOffsetFunction' point to optimized
		//   functions to do conversions that are selected
		//   by the constructor.
		//
		SBIT32						  AllocationShift;
		COMPUTE_ADDRESS				  ComputeAddressFunction;
		COMPUTE_OFFSET				  ComputeOffsetFunction;

		//
		//   A bucket typically contains a collection of
		//   pages.  As all pages are the same data that
		//   should really be stored in page descriptions
		//   is instead stored in the bucket to save space.
		//   The 'NumberOfElements' contains the number of
		//   elements in each pages bit vector.  The 
		//   'SizeOfChunks' contains the pre-computed chunk
		//   size.  The 'SizeOfElements' contains the number
		//   of words in the pages bit vector.  The 'SizeKey'
		//   contains an index which selects the size of the
		//   bit vector when a new page is created.
		//
		SBIT16						  NumberOfElements;
		SBIT16						  SizeOfChunks;
		SBIT16						  SizeOfElements;
		SBIT16						  SizeKey;

   public:
		//
		//   Public functions.
		//
		//   The functionality provided by this class pretty
		//   much matches the external API.  Nonetheless, these
		//   APIs are protected from excessive calls by a fast
		//   cache that is derived from this class.
		//
        BUCKET
			( 
			SBIT32					  NewAllocationSize,
			SBIT32					  NewChunkSize,
			SBIT32					  NewPageSize 
			);

		BOOLEAN Delete( VOID *Address,PAGE *Page,SBIT32 Version );

		VOID DeleteFromBucketList( PAGE *Page );

		VOID InsertInBucketList( PAGE *Page );

		BOOLEAN MultipleDelete
			( 
			ADDRESS_AND_PAGE		  *Array,
			SBIT32					  *Deleted,
			SBIT32					  Size 
			);

		BOOLEAN MultipleNew
			( 
			SBIT32					  *Actual,
			VOID					  *Array[],
			SBIT32					  Requested 
			);

		VOID *New( BOOLEAN SubDivided,SBIT32 NewSize = NoSize );

		VOID ReleaseSpace( SBIT32 MaxActivePages );

		VOID UpdateBucket
			( 
			FIND					  *NewFind,
			HEAP					  *NewHeap,
			NEW_PAGE				  *NewPages,
			CACHE					  *NewParentCache
			);

        ~BUCKET( VOID );

		//
		//   Public inline functions.
		//
		//   It saves a significant amount of space by putting
		//   common information in the bucket instead of a 
		//   separate copy in each page description.  Nonetheless,
		//   it means that both classes are very much dependent
		//   upon each other.
		//
		INLINE VOID *ComputeAddress( CHAR *Address,SBIT32 Offset )
			{ return (this ->* ComputeAddressFunction)( Address,Offset ); }

		INLINE SBIT32 ComputeOffset( SBIT32 Displacement,BOOLEAN *Found )
			{ return (this ->* ComputeOffsetFunction)( Displacement,Found ); }

		INLINE SBIT32 GetAllocationSize( VOID )
			{ return AllocationSize; }

		INLINE SBIT32 GetChunkSize( VOID )
			{ return ChunkSize; }

		VOID *GetCurrentPage( VOID )
			{ return CurrentPage; }

		INLINE SBIT16 GetNumberOfElements( VOID )
			{ return NumberOfElements; }

		INLINE SBIT32 GetPageSize( VOID )
			{ return PageSize; }

		INLINE SBIT16 GetSizeOfChunks( VOID )
			{ return SizeOfChunks; }

		INLINE SBIT16 GetSizeOfElements( VOID )
			{ return SizeOfElements; }

		INLINE SBIT16 GetSizeKey( VOID )
			{ return SizeKey; }

	private:
		//
		//   Private functions.
		//
		//   When we need to convert an address to a bit 
		//   offset (or vice versa) we use one of the following 
		//   functions.
		//
		VOID *ComputeAddressWithShift( CHAR *Address,SBIT32 Offset );
		VOID *ComputeAddressWithMultiply( CHAR *Address,SBIT32 Offset );
		VOID *ComputeAddressWithDivide( CHAR *Address,SBIT32 Offset );

		SBIT32 ComputeOffsetWithShift( SBIT32 Displacement,BOOLEAN *Found );
		SBIT32 ComputeOffsetWithMultiply( SBIT32 Displacement,BOOLEAN *Found );
		SBIT32 ComputeOffsetWithDivide( SBIT32 Displacement,BOOLEAN *Found );

        //
        //   Disabled operations.
 		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
		//
        BUCKET( CONST BUCKET & Copy );

        VOID operator=( CONST BUCKET & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\heap\connections.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "HeapPCH.hpp"

#include "Connections.hpp"
#include "Cache.hpp"
#include "Find.hpp"
#include "Heap.hpp"
#include "NewPage.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   There are a variety of connections that need to be made        */
    /*   after all the classes are ready for use.  However, we          */
    /*   initially zero all these connection pointers until we are      */
    /*   ready to link everything.                                      */
    /*                                                                  */
    /********************************************************************/

CONNECTIONS::CONNECTIONS( VOID )
    {
	Active = False;

	Find = NULL;
	Heap = NULL;
	NewPage = NULL;
	ParentCache = NULL;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Update the connections.                                        */
    /*                                                                  */
    /*   When we create an allocator there is some information that     */
    /*   is not available.  Here we update the connection information   */
    /*   so we can locate the correct instances of various other        */
    /*   classes.                                                       */
    /*                                                                  */
    /********************************************************************/

VOID CONNECTIONS::UpdateConnections
		( 
		FIND						  *NewFind,
		HEAP						  *NewHeap,
		NEW_PAGE					  *NewPages,
		CACHE						  *NewParentCache
		)
	{
	//
	//   We typically only need to update the connections once
	//   but in some situations multiple updates can occur.  If
	//   this is the case we carefully check the update is 
	//   consistent with the previous update.
	//
	if ( ! Active )
		{
		//
		//   We now have the information we need to update the 
		//   connections.
		//
		Active = True;
		Find = NewFind;
		Heap = NewHeap;
		NewPage = NewPages;
		ParentCache = NewParentCache;
		}
	else
		{
		//
		//   Nasty, we have already updated the connections once.  
		//   Since we have been called again we know this node 
		//   must be shared between two heaps.  We can deal with  
		//   this as long as selected pointers are the same.
		//
		if 
				(
				(Find != NewFind)
					||
				(NewPage != NewPages)
					||
				(ParentCache != NewParentCache)
				)
			{ Failure( "Sharing violation in UpdateConnections" ); }
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the connections.                                       */
    /*                                                                  */
    /********************************************************************/

CONNECTIONS::~CONNECTIONS( VOID )
    {
	Active = False;

	Find = NULL;
	Heap = NULL;
	NewPage = NULL;
	ParentCache = NULL;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\heap\find.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "HeapPCH.hpp"

#include "Cache.hpp"
#include "Find.hpp"
#include "Heap.hpp"
#include "New.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here control the size of the hash       */
    /*   table and other related features.                              */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 MinHash				  = 1024;
CONST SBIT32 MinHashSpace			  = (100/25);
CONST SBIT32 MinLookAside			  = 128;

CONST BIT32 NoAddressMask			  = ((BIT32) -1);
CONST SBIT32 NoCacheEntry			  = -1;

#ifndef ENABLE_RECURSIVE_LOCKS
    /********************************************************************/
    /*                                                                  */
    /*   Static member initialization.                                  */
    /*                                                                  */
    /*   Static member initialization sets the initial value for all    */
    /*   static members.                                                */
    /*                                                                  */
    /********************************************************************/

THREAD_LOCAL_STORE FIND::LockCount;
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create the hash table and initialize it ready for use. The     */
    /*   configuration information supplied from the parameters needs   */
    /*   to be carefully checked as it has come indirectly from the     */
    /*   user and may be bogus.                                         */
    /*                                                                  */
    /********************************************************************/

FIND::FIND
		( 
		SBIT32						  NewMaxHash,
		SBIT32						  NewMaxLookAside,
		SBIT32						  NewFindThreshold,
		ROCKALL						  *NewRockall,
		BOOLEAN						  NewResize, 
		BOOLEAN						  NewThreadSafe 
		)
    {
	REGISTER SBIT32 AlignMask = (NewRockall -> NaturalSize()-1);

	//
	//   We need to make sure that the size of the hash table
	//   makes sense.  The hash table size needs to be a reasonable
	//   size (say 1k or larger) and a power of 2 (so we don't need
	//   to do any divides).
	//   
	if 
			(
			PowerOfTwo( (AlignMask+1) )
				&&
			(NewFindThreshold >= 0 )
				&&
			(NewMaxHash >= MinHash) 
				&&
			(ConvertDivideToShift( NewMaxHash,& HashMask ))
				&& 
			(NewMaxLookAside >= MinLookAside) 
				&& 
			(ConvertDivideToShift( NewMaxLookAside,& LookAsideMask ))
			)
		{
		REGISTER SBIT32 HashSize = (NewMaxHash * sizeof(LIST));
		REGISTER SBIT32 LookAsideSize = (NewMaxLookAside * sizeof(LOOK_ASIDE));
		REGISTER SBIT32 TotalSize = (HashSize + LookAsideSize);

		//
		//   Set up the hash table.
		//
		MaxHash = NewMaxHash;

		HashShift = (32-HashMask);
		HashMask = ((1 << HashMask)-1);
		Resize = NewResize;

		//
		//   Set up the lookaside table.
		//
		MaxLookAside = NewMaxLookAside;

		MaxAddressMask = NoAddressMask;
		MinAddressMask = NoAddressMask;

		LookAsideActions = 0;
		LookAsideShift = (32-LookAsideMask);
		LookAsideMask = ((1 << LookAsideMask)-1);
		LookAsideThreshold = NewFindThreshold;

		ThreadSafe = NewThreadSafe;

		//
		//   Create some space for the find table and the 
		//   look aside table.
		//
		Hash = ((LIST*) NewRockall -> NewArea( AlignMask,TotalSize,False ));
		LookAside = ((LOOK_ASIDE*) & Hash[ MaxHash ]);
		Rockall = NewRockall;

		//
		//   If the memory allocation request for the hash
		//   table fails we are doomed.  If it works we need
		//   to call the constructor for each linked list
		//   head node.
		//
		if ( Hash != ((LIST*) AllocationFailure) )
			{
			REGISTER SBIT32 Count;

			//
			//   Call the constructor for each hash table
			//   linked list header.
			//
			for ( Count=0;Count < NewMaxHash;Count ++ )
				{ PLACEMENT_NEW( & Hash[ Count ],LIST ); }

			//
			//   Zero the look aside structures.  We need
			//   to do this to ensure they do not match a
			//   valid allocation address later.
			//
			for ( Count=0;Count < MaxLookAside;Count ++ )
				{
				REGISTER LOOK_ASIDE *Current = & LookAside[ Count ];

				Current -> Address = ((VOID*) NoCacheEntry);
				Current -> Page = ((PAGE*) NoCacheEntry);
#ifdef DEBUGGING
				Current -> Version = ((SBIT32) NoCacheEntry);
#endif
				}
#ifdef ENABLE_HEAP_STATISTICS

			//
			//   Zero the statistics information.
			//
			Fills = 0;
			Hits = 0;
			MaxPages = 0;
			MaxTests = 0;
			Misses = 0;
			Scans = 0;
			Tests = 0;
#endif
			Used = 0;
			}
		else
			{ Failure( "Create hash fails in constructor for FIND" ); }
		}
	else
		{ Failure( "Hash table size in constructor for FIND" ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Delete a memory allocation.                                    */
    /*                                                                  */
    /*   We need to delete a particular memory allocation.  All         */
    /*   we have is an address.  We use this to find the largest        */
    /*   allocation page this address is contained in and then          */
    /*   navigate through the sub-divisions of this page until we       */
    /*   find the allocation we need to delete.                         */
    /*                                                                  */
    /********************************************************************/

BOOLEAN FIND::Delete( VOID *Address,CACHE *ParentCache )
    {
	REGISTER PAGE *Page;
	REGISTER BOOLEAN Update;
	
	//
	//   If we need to be thread safe then claim a sharable lock
	//   on the hash table to stop it being changed under our feet.
	//
	ClaimFindShareLock();

	//
	//   Lets try the lookaside table.  There is a pretty
	//   good chance that we will have the details we need 
	//   already in the cache.  If not we need to find it
	//   the hard way.  During the process we add the mapping
	//   into the lookaside for next time.
	//
	if
			( 
			Update = 
				(
				! FindLookAside
					( 
					((VOID*) (((LONG) Address) & ~MinAddressMask)),
					& Page 
					)
				)
			)
		{
		//
		//   Find the allocation page and get the details of entry.
		//   We do this by finding the parent of the top cache.
		//   We  know that this is the global root and will find
		//   the correct page even if it is on another heap (as
		//   long as the find table is globally shared).
		//
		Page = (ParentCache -> FindParentPage( Address ));

		if ( Page != ((PAGE*) NULL) )
			{ Page = (Page -> FindPage( Address,NULL,True )); }
		}

	//
	//   We may have failed to find the address.  If so
	//   we simply fail the call.  If not we put the deleted 
	//   element back in the associated cache.
	//
	if ( Page != ((PAGE*) NULL) )
 		{
		REGISTER CACHE *Cache = (Page -> GetCache());
		REGISTER SBIT32 Original = (Page -> GetVersion());

		//
		//   Prefetch the class data if we are running a
		//   Pentium III or better with locks.  We do this
		//   because prefetching hot SMP data structures
		//   really helps.  However, if the structures are
		//   not shared (i.e. no locks) then it is worthless
		//   overhead.
		//
		if ( ThreadSafe )
			{ Prefetch.Nta( ((CHAR*) Cache),sizeof(CACHE) ); }

		//
		//   Release the lock if we claimed it earlier and
		//   update the lookaside if needed.
		//
		if ( Update )
			{ ReleaseFindShareLockAndUpdate( Address,Page,Original ); }
		else
			{ ReleaseFindShareLock(); }

		//
		//   We have found the associated page description
		//   so pass the delete request along to the cache
		//   and get out of here.
		//
		return (Cache -> Delete( Address,Page,Original ));
		}
	else
		{ 
		//
		//   Release the lock if we claimed it earlier.
		//
		ReleaseFindShareLock();

		return False; 
		}
  }

    /********************************************************************/
    /*                                                                  */
    /*   Delete an item from the find table.                            */
    /*                                                                  */
    /*   We need to delete page from the find list.  We expect          */
    /*   this to take quite a while as multiple threads can be          */
    /*   using this class at the same time.                             */
    /*                                                                  */
    /********************************************************************/

VOID FIND::DeleteFromFindList( PAGE *Page )
	{
	REGISTER VOID *Address = (Page -> GetAddress());

	//
	//   Claim an exclusive lock so we can update the 
	//   hash and lookaside as needed.
	//
	ClaimFindExclusiveLock();

	//
	//   Delete the page from the hash table.
	//
	Page -> DeleteFromFindList( FindHashHead( Address ) );

	//
	//   When we create very small heaps (i.e. a heap
	//   where only 20-30 allocations are requested)
	//   the various caches become a problem as they
	//   tend to front load work.  So we allow a limit
	//   to be set before which we run with caches 
	//   disabled.
	//   
	if ( LookAsideActions >= LookAsideThreshold )
		{
		REGISTER SBIT32 Count;
		REGISTER CACHE *Cache = (Page -> GetCache());
		REGISTER SBIT32 Stride = (Cache -> GetAllocationSize());

		//
		//   We are about look up various look aside entries
		//   and delete any that are stale.  We need to do
		//   this for every lookaside slot that relates to
		//   the page.  If the allocation size is smaller
		//   than the lookaside slot size we can save some
		//   iterations by increasing the stride size.
		//
		if ( Stride <= ((SBIT32) MinAddressMask) )
			{ Stride = ((SBIT32) (MinAddressMask+1)); }

		//
		//   Whenever we delete an entry from the hash table
		//   the lookaside is potentially corrupt.  So we 
		//   need to delete any look aside entries relating
		//   to this page.
		//
		for ( Count=0;Count < Cache -> GetPageSize();Count += Stride )
			{
			REGISTER VOID *Segment = 
				((VOID*) ((((LONG) Address) + Count) & ~MinAddressMask));
			REGISTER LOOK_ASIDE *Current = 
				(FindLookAsideHead( Segment ));

			//
			//   Delete the look aside entry if it is stale.
			//
			if ( Segment == Current -> Address )
				{
				Current -> Address = ((VOID*) NoCacheEntry);
				Current -> Page = ((PAGE*) NoCacheEntry);
#ifdef DEBUGGING
				Current -> Version = ((SBIT32) NoCacheEntry);
#endif
				}
			}
		}

	//
	//   Update the statistics.
	//
	Used --;

	//
	//   Release the lock if we claimed it earlier.
	//
	ReleaseFindExclusiveLock();
	}

    /********************************************************************/
    /*                                                                  */
    /*   Details of a memory allocation.                                */
    /*                                                                  */
    /*   We need to the details of a particular memory allocation.      */
    /*   All we have is an address.  We use this to find the largest    */
    /*   allocation page this address is contained in and then          */
    /*   navigate through the sub-divisions of this page until we       */
    /*   find the allocation.                                           */
    /*                                                                  */
    /********************************************************************/

BOOLEAN FIND::Details
		( 
		VOID						  *Address,
		SEARCH_PAGE					  *Details,
		CACHE						  *ParentCache,
		SBIT32						  *Size 
		)
    {
	REGISTER PAGE *Page;
	REGISTER BOOLEAN Result;
	REGISTER BOOLEAN Update;
	
	//
	//   If we need to be thread safe then claim a sharable lock
	//   on the hash table to stop it being changed under our feet.
	//
	ClaimFindShareLock();

	//
	//   Lets try the lookaside table.  There is a pretty
	//   good chance that we will have the deatils we need 
	//   already in the cache.  If not we need to find it
	//   the hard way.  During the process we add the mapping
	//   into the lookaside for next time.
	//
	if
			( 
			Update = 
				(
				! FindLookAside
					( 
					((VOID*) (((LONG) Address) & ~MinAddressMask)),
					& Page 
					)
				)
			)
		{
		//
		//   Find the allocation page and get the details of entry.
		//   We do this by finding the parent of the top cache.
		//   We  know that this is the global root and will find
		//   the correct page even if it is on another heap (as
		//   long as the find table is globally shared).
		//
		Page = (ParentCache -> FindParentPage( Address ));

		if ( Page != ((PAGE*) NULL) )
			{ Page = (Page -> FindPage( Address,Details,True )); }
		}
	else
		{
		//
		//   We may need to provide the all the details of the
		//   allocation for some reason.
		//
		if ( Details != NULL )
			{ Page = (Page -> FindPage( Address,Details,True )); }
		}

	//
	//   We may have failed to find the address.  If so
	//   we simply fail the call.  If not we extract the 
	//   information we want.
	//
	if ( Result = (Page != ((PAGE*) NULL)) )
 		{
		//
		//   Compute the size.  We would normally expect
		//   this to be the cache size.  However, there
		//   are some weird pages that sometimes have
		//   other sizes.
		//
		(*Size) = (Page -> ActualSize());
		}

	//
	//   Release the lock if we claimed it earlier and 
	//   update the lookaside if needed.
	//
	if ( (Update) && (Result) )
		{ ReleaseFindShareLockAndUpdate( Address,Page,Page -> GetVersion() ); }
	else
		{ ReleaseFindShareLock(); }

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Find in the look aside.                                        */
    /*                                                                  */
    /*   We need to find a particular page in the look aside.  So we    */
    /*   try a simple look up (no lists or chains).                     */
    /*                                                                  */
    /********************************************************************/

BOOLEAN FIND::FindLookAside( VOID *Address,PAGE **Page )
    {
	//
	//   When we create very small heaps (i.e. a heap
	//   where only 20-30 allocations are requested)
	//   the various caches become a problem as they
	//   tend to front load work.  So we allow a limit
	//   to be set before which we run with caches 
	//   disabled.
	//   
	if ( LookAsideActions >= LookAsideThreshold )
		{
		REGISTER LOOK_ASIDE *Current = FindLookAsideHead( Address );

		//
		//   We have hashed to a lookaside slot.  Maybe
		//   it contains what we want or maybe not.
		//
		if ( Address == Current -> Address )
			{
#ifdef DEBUGGING
			if ( Current -> Version == (Current -> Page -> GetVersion()) )
				{
#endif
				//
				//   We hit the lookaside and the 
				//   contents are valid.
				//
				(*Page) = (Current -> Page);
#ifdef ENABLE_HEAP_STATISTICS

				//
				//   Update the statistics.
				//
				Hits ++;
#endif

				return True;
#ifdef DEBUGGING
				}
			else
				{ Failure( "Deleted page in FindLookAside" ); }
#endif
			}
		}
	else
		{
		//
		//   We update number of times we tried to
		//   use the lookaside and it was disabled.  
		//   After a while this will lead to the 
		//   lookaside being enabled.
		//
		LookAsideActions ++; 
		}
#ifdef ENABLE_HEAP_STATISTICS

	//
	//   We missed the lookaside so update the 
	//   statistics to reflect our misfortune.
	//
	Misses ++;
#endif

	return False; 
    }

    /********************************************************************/
    /*                                                                  */
    /*   Find a page.                                                   */
    /*                                                                  */
    /*   We need to find a particular page in the hash table.  So we    */
    /*   scan along the associated linked list looking for a match.     */
    /*                                                                  */
    /********************************************************************/

PAGE *FIND::FindPage( VOID *Address,CACHE *ParentCache )
    {
#ifdef ENABLE_HEAP_STATISTICS
	REGISTER SBIT32 Cycles = 0;
	REGISTER PAGE *Result = NULL;
#endif
	REGISTER PAGE *Page;

	//
	//   Find the associated hash bucket and then walk
	//   along the linked list for this looking for
	//   the correct page description.
	//
	for 
			( 
			Page = PAGE::FirstInFindList( FindHashHead( Address ) );
			! Page -> EndOfFindList();
			Page = Page -> NextInFindList()
			)
		{
#ifdef ENABLE_HEAP_STATISTICS
		//
		//   Count the number of iterations in when we
		//   are recording statistics so we can calculate
		//   the average chain length.
		//
		Cycles ++;

#endif
		//
		//   We can identify the the target page by two key
		//   characteristics.  These are the start address and
		//   the parent page.   Although we may have sub-divided
		//   a page into various chunks each chunk will have
		//   a different parent (although its start address
		//   may sometimes be the same).
		//
		if 
				( 
				(Address == (Page -> GetAddress())) 
					&& 
				(ParentCache == (Page -> GetParentPage()))
				)
			{
#ifdef ENABLE_HEAP_STATISTICS
			//
			//   We have found the target page.  So return it
			//   to the caller.
			//
			if ( Page -> ValidPage() )
				{
				Result = Page;
				break;
				}
			else
				{ Failure( "Deleted page in FindPage" ); }
#else
			return Page;
#endif
			}
		}

#ifdef ENABLE_HEAP_STATISTICS
	//
	//   When we are in statistics mode we need to update the
	//   information so we can output it at the end of the
	//   run.
	//
	if ( MaxTests < Cycles )
		{ MaxTests = Cycles; }

	Tests += Cycles;

	Scans ++;

	return Result;
#else
	return NULL;
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Insert an item into the find table.                            */
    /*                                                                  */
    /*   We need to insert a new page into the find table.  We expect   */
    /*   this to take quite a while as multiple threads can be using    */
    /*   this class at the same time.                                   */
    /*                                                                  */
    /********************************************************************/

VOID FIND::InsertInFindList( PAGE *Page )
	{
	REGISTER VOID *Address = (Page -> GetAddress());

	//
	//   Claim an exclusive lock so we can update the 
	//   find table and lookaside as needed.
	//
	ClaimFindExclusiveLock();

	//
	//   Insert a new page into the find table.
	//
	Page -> InsertInFindList( FindHashHead( Address ) );

	//
	//   When we create very small heaps (i.e. a heap
	//   where only 20-30 allocations are requested)
	//   the various caches become a problem as they
	//   tend to front load work.  So we allow a limit
	//   to be set before which we run with caches 
	//   disabled.
	//   
	if ( LookAsideActions >= LookAsideThreshold )
		{
		REGISTER SBIT32 Count;
		REGISTER CACHE *Cache = (Page -> GetCache());
		REGISTER SBIT32 Stride = (Cache -> GetAllocationSize());

		//
		//   We are about look up various lookaside entries
		//   and update any that are stale.  We need to do
		//   this for every lookaside slot that relates to
		//   the page.  If the allocation size is smaller
		//   than the lookaside slot size we can save some
		//   iterations by increasing the stride size.
		//
		if ( Stride <= ((SBIT32) MinAddressMask) )
			{ Stride = ((SBIT32) (MinAddressMask+1)); }

		//
		//   Whenever we add an entry from the find table
		//   the lookaside is potentially corrupt.  So we 
		//   need to update any lookaside entries relating
		//   to the page.
		//
		for ( Count=0;Count < Cache -> GetPageSize();Count += Stride )
			{
			REGISTER VOID *Segment = 
				((VOID*) ((((LONG) Address) + Count) & ~MinAddressMask));
			REGISTER LOOK_ASIDE *Current = 
				(FindLookAsideHead( Segment ));

			//
			//   Add the new page to the lookaside as we
			//   expect it to get hit pretty soon one way
			//   or another.
			//
			Current -> Address = Segment;
			Current -> Page = Page;
#ifdef DEBUGGING
			Current -> Version = Page -> GetVersion();
#endif
			}
		}

	//
	//   Update the statistics and resize the find
	//   table if it is over 75% full.
	//
	if ( ((++ Used) + (MaxHash / MinHashSpace)) > MaxHash )
		{ ResizeHashTable(); }
#ifdef ENABLE_HEAP_STATISTICS

	if ( Used > MaxPages )
		{ MaxPages = Used; }
#endif

	//
	//   Release the lock if we claimed it earlier.
	//
	ReleaseFindExclusiveLock();
	}

    /********************************************************************/
    /*                                                                  */
    /*   A known area.                                                  */
    /*                                                                  */
    /*   We have an address and don't have a clue which heap            */
    /*   owns the space.  Here we take a look at the address            */
    /*   and figure out if it is known to the current heap.             */
    /*                                                                  */
    /********************************************************************/

BOOLEAN FIND::KnownArea( VOID *Address,CACHE *ParentCache )
    {
	REGISTER PAGE *Page;
	
	//
	//   If we need to be thread safe then claim a sharable lock
	//   on the hash table to stop it being changed under our feet.
	//
	ClaimFindShareLock();

	//
	//   Find out if the address belongs to this heap
	//   or any other heap of which we are aware (i.e.
	//   when single image is active).
	//
	Page = (ParentCache -> FindParentPage( Address ));

	//
	//   Release the lock if we claimed it earlier.
	//
	ReleaseFindShareLock();

	return (Page != ((PAGE*) NULL));
	}

    /********************************************************************/
    /*                                                                  */
    /*   Release a shared lock and update.                              */
    /*                                                                  */
    /*   We have been asked to insert a page into the lookaside.        */
    /*   We assume the caller already has a share lock which we         */
    /*   release when we are finished.                                  */
    /*                                                                  */
    /********************************************************************/

VOID FIND::ReleaseFindShareLockAndUpdate
		( 
		VOID						  *Address,
		PAGE						  *Page,
		SBIT32						  Version
		)
    {
	//
	//   When we create very small heaps (i.e. a heap
	//   where only 20-30 allocations are requested)
	//   the various caches become a problem as they
	//   tend to front load work.  So we allow a limit
	//   to be set before which we run with caches 
	//   disabled.
	//   
	if ( LookAsideActions >= LookAsideThreshold )
		{
		//
		//   Claim an exclusive lock so we can update the 
		//   lookaside as needed.
		//
		ChangeToExclusiveLock();

#ifdef DEBUGGING
		if ( Page -> ValidPage() )
			{
#endif
			if ( Version == (Page -> GetVersion()) )
				{
				REGISTER LONG Base = (((LONG) Address) & ~MinAddressMask);
				REGISTER VOID *Segment = ((VOID*) Base);
				REGISTER LOOK_ASIDE *Current = FindLookAsideHead( Segment );

				//
				//   Overwrite any existing information.
				//
				Current -> Address = Segment;
				Current -> Page = Page;
#ifdef DEBUGGING
				Current -> Version = Page -> GetVersion();
#endif
#ifdef ENABLE_HEAP_STATISTICS

				//
				//   Update the statistics.
				//
				Fills ++;
#endif
				}
#ifdef DEBUGGING
			}
		else
			{ Failure( "Deleted page in ReleaseFindShareLockAndUpdate" ); }
#endif

		//
		//   Release the lock if we claimed it earlier.
		//
		ReleaseFindExclusiveLock();
		}
	else
		{ 
		//
		//   Release the lock if we claimed it earlier.
		//
		ReleaseFindShareLock(); 
		}
    }

    /********************************************************************/
    /*                                                                  */
    /*   Resize the find table.                                         */
    /*                                                                  */
    /*   We need to grow the hash table as it appears to be a little    */
    /*   small given the number of pages that have been created.        */
    /*                                                                  */
    /********************************************************************/

VOID FIND::ResizeHashTable( VOID )
    {
	AUTO SBIT32 NewHashMask;
	AUTO SBIT32 NewLookAsideMask;

	//
	//   When we need to resize the hash table it is a
	//   straight race.  The first thread to claim the
	//   lock gets to do the work.  Everyone else just
	//   exits.
	//
	if ( (Resize) && (Spinlock.ClaimLock(0)) )
		{
		REGISTER SBIT32 AlignMask = (Rockall -> NaturalSize()-1);
		REGISTER SBIT32 NewMaxHash = (MaxHash * ExpandStore);
		REGISTER SBIT32 NewMaxLookAside = (MaxLookAside * ExpandStore);
		REGISTER SBIT32 NewHashSize = (NewMaxHash * sizeof(LIST));
		REGISTER SBIT32 NewLookAsideSize = (NewMaxLookAside * sizeof(LOOK_ASIDE));
		REGISTER SBIT32 NewTotalSize = (NewHashSize + NewLookAsideSize);
		REGISTER SBIT32 HashSize = (MaxHash * sizeof(LIST));
		REGISTER SBIT32 LookAsideSize = (MaxLookAside * sizeof(LOOK_ASIDE));
		REGISTER SBIT32 TotalSize = (HashSize + LookAsideSize);

		//
		//   It is actually possible for a thread to get
		//   delayed for so long that it thinks the hash 
		//   table still needs to be resized long after the 
		//   work has been completed.  Additionally, we want
		//   to make sure that all the new values are sane.
		//
		if 
				(
				PowerOfTwo( (AlignMask+1) )
					&&
				(NewMaxHash > 0)
					&&
				(ConvertDivideToShift( NewMaxHash,& NewHashMask ))
					&&
				(NewMaxLookAside > 0)
					&& 
				(ConvertDivideToShift( NewMaxLookAside,& NewLookAsideMask ))
					&&
				((Used + (MaxHash / MinHashSpace)) > MaxHash)
				)
			{
			REGISTER LIST *NewHash;
			REGISTER LOOK_ASIDE *NewLookAside;

			//
			//   We have been picked as the victim who
			//   needs to resize the hash table.  We are
			//   going to call the external allocator 
			//   to get more memory.  As we know this is 
			//   likely to to nail us we drop the lock to 
			//   allow other threads to continue.
			//
			ReleaseFindExclusiveLock();

			//
			//   We know that allocating a new table and 
			//   initializing it is going to take ages.
			//   Well at least everyone else gets to carry
			//   on in the mean time.
			//
			NewHash = 
				((LIST*) Rockall -> NewArea( AlignMask,NewTotalSize,False ));

			NewLookAside = 
				((LOOK_ASIDE*) & NewHash[ NewMaxHash ]);

			//
			//   If the memory allocation request for the hash
			//   table fails we exit and try again later. 
			//
			if ( NewHash != ((LIST*) AllocationFailure) )
				{
				REGISTER SBIT32 Count;

				//
				//   Call the constructor for each hash table
				//   linked list header.
				//
				for ( Count=0;Count < NewMaxHash;Count ++ )
					{ PLACEMENT_NEW( & NewHash[ Count ],LIST ); }

				//
				//   Zero the look aside structure.
				//
				for ( Count=0;Count < NewMaxLookAside;Count ++ )
					{
					REGISTER LOOK_ASIDE *Current = & NewLookAside[ Count ];

					Current -> Address = ((VOID*) NoCacheEntry);
					Current -> Page = ((PAGE*) NoCacheEntry);
#ifdef DEBUGGING
					Current -> Version = ((SBIT32) NoCacheEntry);
#endif
					}
				}

			//
			//   Claim an exclusive lock so we can resize  
			//   the hash table.
			//
			ClaimFindExclusiveLock();

			//
			//   If we have allocated the new find table
			//   we can now rehash the existing entries.
			//   If not we are out of here.
			//
			if ( NewHash != ((LIST*) AllocationFailure) )
				{
				REGISTER SBIT32 Count;
				REGISTER SBIT32 MaxOldHash = MaxHash;
				REGISTER LIST *OldHash = Hash;

				//
				//   Update the control information 
				//   for the new hash table.
				//
				MaxHash = NewMaxHash;
				HashShift = (32-NewHashMask);
				HashMask = ((1 << NewHashMask)-1);

				MaxLookAside = NewMaxLookAside;
				LookAsideShift = (32-NewLookAsideMask);
				LookAsideMask = ((1 << NewLookAsideMask)-1);

				Hash = NewHash;
				LookAside = NewLookAside;

				//
				//   Delete all the existing records
				//   from the old hash table and insert
				//   them into the new hash table.
				//
				for ( Count=0;Count < MaxOldHash;Count ++ )
					{
					REGISTER LIST *Current = & OldHash[ Count ];

					//
					//   Walk along each hash bucket 
					//   deleting the records and inserting
					//   them into the new hash table.
					//
					while ( ! Current -> EndOfList() )
						{
						REGISTER PAGE *Page = PAGE::FirstInFindList( Current );
						REGISTER VOID *Address = (Page -> GetAddress());

						Page -> DeleteFromFindList( Current );

						Page -> InsertInFindList( FindHashHead( Address ) );
						}
					}

				//
				//   Time to do more operating system work
				//   so lets drop the lock again.
				//
				ReleaseFindExclusiveLock();

				//
				//   Delete all the list heads and return the
				//   original allocation to the operating system.
				//
				for ( Count=0;Count < MaxOldHash;Count ++ )
					{ PLACEMENT_DELETE( & OldHash[ Count ],LIST ); }

				//
				//   Deallocate the old extent.
				//
				Rockall -> DeleteArea( ((VOID*) OldHash),TotalSize,False );

				//
				//   We are finished so reclaim the lock
				//   so we can exit.
				//
				ClaimFindExclusiveLock();
				}
			else
				{ Resize = False; }
			}

		Spinlock.ReleaseLock();
		}
    }

    /********************************************************************/
    /*                                                                  */
    /*   Update the find table.                                         */
    /*                                                                  */
    /*   We need to update the find table with certain information      */
    /*   to ensure it is used correctly and consistently.               */
    /*                                                                  */
    /********************************************************************/

VOID FIND::UpdateFind( BIT32 NewMaxAddressMask,BIT32 NewMinAddressMask )
    {
	//
	//   When we have a single heap image all the 'TopCache' sizes
	//   must be the same.
	//
	if 
			( 
			(MaxAddressMask == NoAddressMask) 
				|| 
			(MaxAddressMask == NewMaxAddressMask) 
			)
		{
		//
		//   If we need to be thread safe then claim a sharable lock
		//   on the hash table to stop it being changed under our feet.
		//
		ClaimFindExclusiveLock();

		//
		//   Update the max address mask if it is not the current
		//   value but yet consistent.
		//
		MaxAddressMask = NewMaxAddressMask;

		//
		//   Update the address mask is the new heap has a smaller
		//   parent than all of the other heaps.
		//
		if ( MinAddressMask > NewMinAddressMask )
			{ MinAddressMask = NewMinAddressMask; }

		//
		//   Release the lock if we claimed it earlier.
		//
		ReleaseFindExclusiveLock();
		}
	else
		{ Failure( "Different 'TopCache' sizes with 'SingleImage'" ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Walk the heap.                                                 */
    /*                                                                  */
    /*   We have been asked to walk the heap.  It is hard to know       */
    /*   whay anybody might want to do this given the rest of the       */
    /*   functionality available.  Nonetheless, we just do what is      */
    /*   required to keep everyone happy.                               */
    /*                                                                  */
    /********************************************************************/

BOOLEAN FIND::Walk
		( 
		BOOLEAN						  *Active,
		VOID						  **Address,
		CACHE						  *ParentCache,
		SBIT32						  *Size 
		)
    {
	REGISTER VOID *Memory = (*Address);
	REGISTER BOOLEAN Result;
	REGISTER BOOLEAN Update;
	REGISTER PAGE *Page;
	
	//
	//   If we need to be thread safe then claim a sharable lock
	//   on the hash table to stop it being changed under our feet.
	//
	ClaimFindShareLock();

	//
	//   When the address is null we need to set up the heap
	//   walk.  In all other cases we just extract the next
	//   allocation in the list.
	//
	if ( Memory != NULL )
		{
		AUTO SEARCH_PAGE Details;

		//
		//   Lets try the lookaside table.  There is a pretty
		//   good chance that we will have the details we need 
		//   already in the cache.  If not we need to find it
		//   the hard way.  During the process we add the mapping
		//   into the lookaside for next time.
		//
		if
				(
				Update =
					( 
					! FindLookAside
						( 
						((VOID*) (((LONG) Memory) & ~MinAddressMask)),
						& Page 
						) 
					)
				)
			{
			//
			//   Find the allocation page and get the details of entry.
			//   We do this by finding the parent of the top cache.
			//   We  know that this is the global root and will find
			//   the correct page even if it is on another heap (as
			//   long as the find table is globally shared).
			//
			Page = (ParentCache -> FindParentPage( Memory ));
			}

		//
		//   We now compute all the details relating to the address
		//   so we can find any subsequent allocation.
		//
		if ( Page != ((PAGE*) NULL) )
			{ Page = (Page -> FindPage( Memory,& Details,True )); }

		//
		//   We may have failed to find the address  .If so
		//   we simply fail the call.  If not we find the next
		//   allocation in the heap.
		//
		if ( Result = ((Page != ((PAGE*) NULL)) && (Details.Found)) )
 			{
			//
			//   We need to walk the heap to get te details
			//   of the next allocation.
			//
			if ( Result = (Page -> Walk( & Details )) )
				{
				REGISTER BIT32 AllocationBit =
					((*Details.VectorWord) & Details.AllocationMask);

				(*Active) = (AllocationBit != 0);
				(*Address) = Details.Address;
				(*Size) = (Details.Page -> ActualSize());

				//
				//   If we are considering putting something
				//   in the lookaside lets make sure that
				//   we will get to hit the cache entry at
				//   least once.  If not lets forget putting
				//   it in the cache.
				//
				if ( Update )
					{
					Update =
						(
						(((LONG) Memory) & ~MinAddressMask)
							==
						(((LONG) Details.Address) & ~MinAddressMask)
						);
					}
				}
			}
		}
	else
		{
		AUTO SEARCH_PAGE Details;

		//
		//   We start a heap walk by setting the initial 
		//   address to the value null.
		//
		Details.Address = NULL;
		Details.Cache = ParentCache;
		Details.Page = NULL;

		Page = NULL;
		Update = False;

		//
		//   We walk the heap to get te details of the
		//   first heap allocation.
		//
		if ( Result = (Page -> Walk( & Details )) )
			{
			REGISTER BIT32 AllocationBit =
				((*Details.VectorWord) & Details.AllocationMask);

			(*Active) = (AllocationBit != 0);
			(*Address) = Details.Address;
			(*Size) = (Details.Page -> ActualSize());
			}
		}

	//
	//   Release the lock if we claimed it earlier and
	//   update the lookaside if needed.
	//
	if ( (Update) && (Result) )
		{ ReleaseFindShareLockAndUpdate( Memory,Page,Page -> GetVersion() ); }
	else
		{ ReleaseFindShareLock(); }

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Delete the hash table and release all the associated memory.   */
    /*                                                                  */
    /********************************************************************/

FIND::~FIND( VOID )
    {
	REGISTER SBIT32 Count;
	REGISTER SBIT32 HashSize = (MaxHash * sizeof(LIST));
	REGISTER SBIT32 LookAsideSize = (MaxLookAside * sizeof(LOOK_ASIDE));
	REGISTER SBIT32 TotalSize = (HashSize + LookAsideSize);

	//
	//   Call the destructor for each hash table
	//   linked list header.
	//
	for ( Count=0;Count < MaxHash;Count ++ )
		{ PLACEMENT_DELETE( & Hash[ Count ],LIST ); }

	//
	//   Deallocate the area.
	//
	Rockall -> DeleteArea( ((VOID*) Hash),TotalSize,False );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\heap\connections.hpp ===
#ifndef _CONNECTIONS_HPP_
#define _CONNECTIONS_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Environment.hpp"
#include "Common.hpp"
#include "Find.hpp"
#include "NewPage.hpp"
#include "Prefetch.hpp"
  
    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   At the top level the parent of all caches is a constant        */
    /*   called 'GlobalRoot'.                                           */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 GlobalRoot				  = -1;

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class CACHE;
class HEAP;
class PAGE;

    /********************************************************************/
    /*                                                                  */
    /*   Data structures exported from the class.                       */
    /*                                                                  */
    /*   We communicate between a page and the associated cache         */
    /*   using an address pointer, page pointer and version triple.     */
    /*                                                                  */
    /********************************************************************/

typedef struct
	{
	VOID							  *Address;
	PAGE							  *Page;
	SBIT32							  Version;
	}
ADDRESS_AND_PAGE;

    /********************************************************************/
    /*                                                                  */
    /*   Connections to other classes.                                  */
    /*                                                                  */
    /*   The connections between the various classes in the memory      */
    /*   allocator is a twisted mess.  The root cause is that at a      */
    /*   fundamental level.  Every part depends on every other part.    */
    /*   Nonetheless, a significant effort has been made to seperate    */
    /*   the parts as best as possible.  The various classes are        */
    /*   linked here so every part can find the correct instance of     */
    /*   every other part.                                              */
    /*                                                                  */
    /********************************************************************/

class CONNECTIONS : public ENVIRONMENT, public COMMON
    {
		//
		//   Private data.
		//
		BOOLEAN						  Active;

   public:
		//
		//   Public data.
		//
		//   All the classes that inherit this class get
		//   pointers to related classes they need to call
		//   from time to time. 
		//
		FIND                          *Find;
		HEAP                          *Heap;
		NEW_PAGE					  *NewPage;
		CACHE						  *ParentCache;

		//
		//   The 'Prefetch' is a class that will trigger
		//   a cache fetch if the CPU supports it.
		//   
		PREFETCH					  Prefetch;

        //
        //   Public functions.
		//
		//   The sole job of this class is to provide 
		//   pointers to related classes.  These pointers
		//   are unknown until after the heap has been
		//   created and this need to be dynamically
		//   linked during the execution of the top 
		//   level heap constructor.
        //
        CONNECTIONS( VOID );

		VOID UpdateConnections
			( 
			FIND					  *NewFind,
			HEAP					  *NewHeap,
			NEW_PAGE				  *NewPages,
			CACHE					  *NewParentCache
			);

        ~CONNECTIONS( VOID );

		//
		//   Public inline functions.
		//
		//   The complex linkages in the heap sometimes 
		//   lead to the case where a class has a pointer
		//   to it's cache but not to the class it needs
		//   to call.  Thus, to avoid replicating large
		//   numbers of pointers we export call interfaces
		//   from here to allow the required calls to be
		//   made indirectly.
		//
		INLINE VOID DeleteFromFindList( PAGE *Page )
			{ Find -> DeleteFromFindList( Page ); }

		INLINE VOID DeletePage( PAGE *Page )
			{ NewPage -> DeletePage( Page ); }

		INLINE HEAP *GetHeap( VOID )
			{ return Heap; }

		INLINE CACHE *GetParentCache( VOID )
			{ return ParentCache; }

		INLINE VOID InsertInFindList( PAGE *Page )
			{ Find -> InsertInFindList( Page ); }

		INLINE BOOLEAN TopCache( VOID )
			{ return (ParentCache == ((CACHE*) GlobalRoot)); }

	private:
        //
        //   Disabled operations.
        //
        CONNECTIONS( CONST CONNECTIONS & Copy );

        VOID operator=( CONST CONNECTIONS & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\heap\find.hpp ===
#ifndef _FIND_HPP_
#define _FIND_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Environment.hpp"
#include "Common.hpp"
#include "List.hpp"
#include "Page.hpp"
#include "Prefetch.hpp"
#include "Rockall.hpp"
#include "Sharelock.hpp"
#include "Spinlock.hpp"
#include "Tls.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class CACHE;
class HEAP;

    /********************************************************************/
    /*                                                                  */
    /*   Find a memory allocation.                                      */
    /*                                                                  */
    /*   When a memory allocation is released all we are given is .     */
    /*   the allocation address.  This is not very helpful as the       */
    /*   allocation information is not stored relative to this          */
    /*   address.  Instead we use a hash table to map the allocation    */
    /*   address to the allocation information.                         */
    /*                                                                  */
    /********************************************************************/

class FIND : public ENVIRONMENT, public COMMON
    {
		//
		//   Private type specifications.
		//
		//   We need to do a recursive search in the find 
		//   table in order to locate the associated page
		//   from an address.  As this is expensive there
		//   is also a cache that slaves common translations
		//   to improve performance.
		//
		typedef struct
			{
			VOID					  *Address;
			PAGE					  *Page;
#ifdef DEBUGGING
			SBIT32					  Version;
#endif
			}
		LOOK_ASIDE;

		//
		//   Private data.
		//
		//   All the page descriptions are stored in the 
		//   hash table so they can be quickly found.  The
		//   key is the address of the first byte on the
		//   page.  The 'MaxHash' is the number of elements
		//   in the hash table and is always a power of two.
		//   The 'HashMask' is a bit mask to remove any 
		//   unwanted part of the hash key.  The 'HashShift'
		//   is the number of bits required to shift and is
		//   as a substitute for divide.  The 'Resize' flag
		//   indicates whether the hash table is permitted 
		//   to grow.
		//
		SBIT32						  MaxHash;

		SBIT32						  HashMask;
		SBIT32						  HashShift;
		BOOLEAN						  Resize;

		//
		//   The hash table allows addresses to be mapped to
		//   page descriptions quickly.  Nonetheless, it is 
		//   not fast enough.  To enhance performance a look
		//   aside cache slaves the hottest translations.  The
		//   'MaxLookAside' is the number of elements in the
		//   cache.  The 'MaxAddressMask' is a mask that removes 
		//   low order bits of an address and represents the
		//   span of each cache entry.  The 'LookAsideActions'
		//   is a simple count of requests to the cache.  The
		//   'LookAsideMask' and 'LookAsideShift' parallel the
		//   fields above in the hash table.  The 'LookAsideThreshold'
		//   determines at what point the cache will become 
		//   active.  The 'ThreadSafe' flag indicates whether
		//   locking is required.
		//
		SBIT32						  MaxLookAside;

		BIT32						  MaxAddressMask;
		BIT32						  MinAddressMask;

		SBIT32						  LookAsideActions;
		SBIT32						  LookAsideMask;
		SBIT32						  LookAsideShift;
		SBIT32						  LookAsideThreshold;
		BOOLEAN						  ThreadSafe;

		//
		//   When a request is made to translate an address to
		//   a page description the cache is the first port of
		//   call.  If the translation is not found then the
		//   hash table is tried.  The 'Hash' points to the hash
		//   table.  The 'LookAside' points to the lookaside
		//   hash table.  The 'Rockall' points to the external API
		//   to give access to the low level external allocation
		//   functions.  
		//
		LIST						  *Hash;
		LOOK_ASIDE					  *LookAside;
		ROCKALL						  *Rockall;

		//
		//   The translation of addresses to page descriptions
		//   is very common.  So care has been taken to ensure
		//   it is not a bottleneck when locking is enabled.  The
		//   'Sharelock' is a fast reader/writer lock and is used
		//   almost all the time.  The 'Spinlock' is an exclusive
		//   lock and is only used when the 'Hash' and 'LookAside'
		//   tables are resized.
		//
		PREFETCH					  Prefetch;
		SHARELOCK					  Sharelock;
		SPINLOCK					  Spinlock;
#ifdef ENABLE_HEAP_STATISTICS

		//
		//   Statistics data.
		//
		//   There is a concern with any hash table about
		//   poor hashing keys and poor performance.  The
		//   statistics monitor various data so as to allow
		//   the performance metrics to be monitored.  The
		//   'Fills' counter keeps track of the number of
		//   cache fills.  The 'Hits' counter monitors the
		//   number of cache hits.  The 'MaxPages' counter
		//   is the high water mark of hash table entries.
		//   The 'MaxTests' is the max number of compares 
		//   done while searching an entry.  The 'Misses' 
		//   counter keeps track of the number of cache misses.
		//   The 'Scans' counter monitors the number of hash
		//   table searches.  The 'Tests' counter is the 
		//   total number of tests performed while searching
		//   for entries.
		//
		SBIT32						  Fills;
		SBIT32						  Hits;
		SBIT32						  MaxPages;
		SBIT32						  MaxTests;
		SBIT32						  Misses;
		SBIT32						  Scans;
		SBIT32						  Tests;
#endif
		SBIT32						  Used;
#ifndef ENABLE_RECURSIVE_LOCKS

		//
		//   Static private data.
		//
		//   It is not uncommon for developers to have some
		//   form of bias.  I dislike recursive locks so here
		//   I introduce a TLS value to indicate whether the
		//   current thread has a global lock.  If so all
		//   locking in the other classes is disabled.
		//
		STATIC THREAD_LOCAL_STORE	  LockCount;
#endif

   public:
		//
		//   Public functions.
		//
		//   The translation functionality supplied by this
		//   class is only applicable after an allocation
		//   has been made.  Hence, all of the APIs supported
		//   relate to the need to translate an allocation
		//   address to the host page description.
		//
        FIND
			( 
			SBIT32					  NewMaxHash,
			SBIT32					  NewMaxLookAside,
			SBIT32					  NewFindThreshold,
			ROCKALL					  *NewRockall,
			BOOLEAN					  NewResize,
			BOOLEAN					  NewThreadSafe 
			);

		BOOLEAN Delete( VOID *Address,CACHE *ParentCache );

		VOID DeleteFromFindList( PAGE *Page );

		BOOLEAN Details
			( 
			VOID					  *Address,
			SEARCH_PAGE				  *Details,
			CACHE					  *ParentCache,
			SBIT32					  *Size 
			);

		PAGE *FindPage( VOID *Address,CACHE *ParentCache );

		VOID InsertInFindList( PAGE *Page );

		BOOLEAN KnownArea( VOID *Address,CACHE *ParentCache );

		VOID ReleaseFindShareLockAndUpdate
			( 
			VOID					  *Address,
			PAGE					  *Page,
			SBIT32					  Version 
			);

		BOOLEAN Walk
			( 
			BOOLEAN					  *Active,
			VOID					  **Address,
			CACHE					  *ParentCache,
			SBIT32					  *Size 
			);

		VOID UpdateFind
			( 
			BIT32					  NewMaxAddressMask,
			BIT32					  NewMinAddressMask
			);

        ~FIND( VOID );

		//
		//   Public inline functions.
		//
		//   Although this class is perhaps the most self
		//   contained.  Nonetheless, there is still lots
		//   of situations when other classes need to 
		//   interact and get information about the current
		//   situation.
		//
		INLINE VOID ClaimFindExclusiveLock( VOID )
			{
			if ( (ThreadSafe) && (GetLockCount() == 0) )
				{ Sharelock.ClaimExclusiveLock(); } 
			}

		INLINE VOID ClaimFindShareLock( VOID )
			{
			if ( (ThreadSafe) && (GetLockCount() == 0) )
				{ Sharelock.ClaimShareLock(); } 
			}

		INLINE VOID DeleteAll( VOID )
			{ LookAsideActions = 0; }

		INLINE VOID ReleaseFindExclusiveLock( VOID )
			{
			if ( (ThreadSafe) && (GetLockCount() == 0) )
				{ Sharelock.ReleaseExclusiveLock(); } 
			}

		INLINE VOID ReleaseFindShareLock( VOID )
			{
			if ( (ThreadSafe) && (GetLockCount() == 0) )
				{ Sharelock.ReleaseShareLock(); } 
			}

		//
		//   Static public inline functions.
		//
		//   There is a strong case for removing the lock
		//   count functionality from this class.  However,
		//   as it consists of a single declaration and the
		//   following inline functions I have not been
		//   driven to fix this yet.  Maybe some day. 
		//
#ifndef ENABLE_RECURSIVE_LOCKS
		STATIC INLINE VOID DecrementLockCount( VOID )
			{ 
			LockCount.SetPointer
				( 
				((VOID*) (((SBIT32) LockCount.GetPointer()) - 1))
				);
			}

		STATIC INLINE SBIT32 GetLockCount( VOID )
			{ return ((SBIT32) LockCount.GetPointer()); }

		STATIC INLINE VOID IncrementLockCount( VOID )
			{ 
			LockCount.SetPointer
				( 
				((VOID*) (((SBIT32) LockCount.GetPointer()) + 1))
				);
			}
#else
		STATIC INLINE VOID DecrementLockCount( VOID )
			{ /* void */ }

		STATIC INLINE SBIT32 GetLockCount( VOID )
			{ return 0; }

		STATIC INLINE VOID IncrementLockCount( VOID )
			{ /* void */ }
#endif

#ifdef ENABLE_HEAP_STATISTICS

		//
		//   Public inline statistic functions.
		//
		//   The statistics are typically provided in 
		//   debug builds to provide good information  
		//   about allocation patterns.  
		//
		INLINE SBIT32 AverageHashLength( VOID )
			{ return (Tests / ((Scans > 0) ? Scans : 1)); }

		INLINE SBIT32 CacheFills( VOID )
			{ return Fills; }

		INLINE SBIT32 CacheHits( VOID )
			{ return Hits; }

		INLINE SBIT32 CacheMisses( VOID )
			{ return Misses; }

		INLINE SBIT32 MaxHashLength( VOID )
			{ return MaxTests; }

		INLINE SBIT32 MaxHashSize( VOID )
			{ return MaxHash; }

		INLINE SBIT32 MaxLookAsideSize( VOID )
			{ return MaxLookAside; }

		INLINE SBIT32 MaxUsage( VOID )
			{ return ((MaxPages * 100) / MaxHash); }

		INLINE SBIT32 TotalScans( VOID )
			{ return Scans; }
#endif

	private:
		//
		//   Private functions.
		//
		//   Although the hashed lookup functionality is 
		//   externally visable the look aside cache is 
		//   hidden from view along with the ability to
		//   resize the hash table.
		//
		BOOLEAN FindLookAside( VOID *Address,PAGE **Page );

		VOID ResizeHashTable( VOID );

		//
		//   Private inline functions.
		//
		//   Although I am not keen on code in the headers
		//   certain functions are so small or so hot that
		//   I have to submit to the desire to do it. 
		//
		INLINE VOID ChangeToExclusiveLock( VOID )
			{
			if ( (ThreadSafe) && (GetLockCount() == 0) )
				{ Sharelock.ChangeSharedLockToExclusiveLock(); } 
			}

		INLINE LIST *FindHashHead( VOID *Address )
			{
			REGISTER BIT32 Value = (((BIT32) Address) * 2964557531);

			return (& Hash[ ((Value >> HashShift) & HashMask) ]); 
			}

		INLINE LOOK_ASIDE *FindLookAsideHead( VOID *Address )
			{
			REGISTER BIT32 Value = (((BIT32) Address) * 2964557531);

			return (& LookAside[ ((Value >> LookAsideShift) & LookAsideMask) ]); 
			}

        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        FIND( CONST FIND & Copy );

        VOID operator=( CONST FIND & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\heap\findlist.hpp ===
#ifndef _FIND_LIST_HPP_
#define _FIND_LIST_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "BucketList.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   The find list.                                                 */
    /*                                                                  */
    /*   The find list links all the pages in the same hash bucket      */
    /*   together so that the correct page can be found.                */
    /*                                                                  */
    /********************************************************************/

class FIND_LIST : public BUCKET_LIST
    {
		//
		//   Private data.
		//
 		LIST						  FindList;

   public:
		//
		//   Public inline functions.
		//
		//   All page descriptions contain three linked lists.
		//   These lists are all derived from a common base
		//   class.  However, this class is unable to support
		//   multiple instances in a single class a wrapper
		//   has been created for each list to make it work
		//   as required.
		//
        FIND_LIST( VOID )
			{ /* void */ };

		INLINE VOID DeleteFromFindList( LIST *HeadOfList )
			{ FindList.Delete( HeadOfList ); }

		INLINE BOOLEAN EndOfFindList( VOID )
			{ return (this == NULL); }

		STATIC INLINE PAGE *FirstInFindList( LIST *HeadOfList )
			{ return ComputePageAddress( ((CHAR*) HeadOfList -> First()) ); }

		INLINE VOID InsertInFindList( LIST *HeadOfList )
			{ FindList.Insert( HeadOfList ); }

		INLINE PAGE *NextInFindList( VOID )
			{ return ComputePageAddress( ((CHAR*) FindList.Next()) ); }

        ~FIND_LIST( VOID )
			{ /* void */ };

	private:
		//
		//   Private functions.
		//
		//   Compute the actual start address of the page
		//   and return it to allow the linked list to
		//   be correctly walked.
		//
		STATIC INLINE PAGE *ComputePageAddress( CHAR *Address )
			{
			if ( Address != NULL )
				{ return ((PAGE*) (Address - sizeof(BUCKET_LIST))); }
			else
				{ return ((PAGE*) NULL); }
			}

        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        FIND_LIST( CONST FIND_LIST & Copy );

        VOID operator=( CONST FIND_LIST & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\heap\heap.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "HeapPCH.hpp"

#include "Cache.hpp"
#include "Find.hpp"
#include "Heap.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here control minimum size of an         */
    /*   allocation bucket.                                             */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 MinParentSize			  = 32;

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a heap and prepare it for use.  Additionally, make      */
    /*   sure that the heap configuration makes sense.  This is         */
    /*   tricky as the whole structure of the heap can be changed       */
    /*   by the external configuration information.                     */
    /*                                                                  */
    /********************************************************************/

HEAP::HEAP
		(
		CACHE						  *Caches1[],
		CACHE						  *Caches2[],
		SBIT32						  MaxFreeSpace,
		FIND						  *NewFind,
		NEW_PAGE					  *NewPages,
		ROCKALL						  *NewRockall,
		SBIT32						  Size1,
		SBIT32						  Size2,
		SBIT32						  Stride1,
		SBIT32						  Stride2,
		BOOLEAN						  NewThreadSafe
		)
    {
	//
	//   The top three buckets are special and a user can not 
	//   allocate memory from two of them.  Thus, unless we have  
	//   at least four buckets the memory allocator is not going 
	//   to be very useful. 
	//
	if ( (Size1 >= 1) && (Size2 >= 3) )
		{
		REGISTER CACHE *FirstCache = Caches1[0];
		REGISTER CACHE *MiddleCache = Caches2[0];
		REGISTER CACHE *LastCache = Caches2[ (Size2-3) ];

		//
		//   Calculate the minimum and maximum allocation sizes.
		//   All allocations outside of this range will be passed
		//   directly to the external allocator.
		//
		CachesSize = (Size1 + Size2);
		MinCacheSize = FirstCache -> GetAllocationSize();
		MidCacheSize = MiddleCache -> GetAllocationSize();
		MaxCacheSize = LastCache -> GetAllocationSize();

		//
		//   Calculate and save various useful pointers needed
		//   during the course of execution.
		//
		Caches = Caches1;
		ExternalCache = (Caches2[ (Size2-1) ]);
		Find = NewFind;
		NewPage = NewPages;
		Rockall = NewRockall;
		TopCache = (Caches2[ (Size2-2) ]);
#ifdef ENABLE_HEAP_STATISTICS

		//
		//   Zero the heap statistics.
		//
		CopyMisses = 0;
		MaxCopySize = 0;
		MaxNewSize = 0;
		NewMisses = 0;
		Reallocations = 0;
		TotalCopySize = 0;
		TotalNewSize = 0;
#endif

		//
		//   The external allocation size must be reasonable.
		//   All allocation sizes must be a multiple of the
		//   minimum allocation size.  The minimum allocation
		//   size and the middle allocation size must be a 
		//   power of two.
		//   
		if 
				( 
				(ExternalCache -> GetPageSize() == TopCache -> GetPageSize())
					&& 
				(PowerOfTwo( Rockall -> NaturalSize() ))
					&&
				(Rockall -> NaturalSize() >= PageSize())
					&&
				(TopCache -> GetPageSize() >= PageSize())
					&&
				(PowerOfTwo( TopCache -> GetPageSize() ))
					&&
				((Stride1 > 0) && (PowerOfTwo( Stride1 )))
					&&
				((Stride2 >= Stride1) && (PowerOfTwo( Stride2 )))
					&&
				(ConvertDivideToShift( Stride1,& ShiftSize1 ))
					&&
				(ConvertDivideToShift( Stride2,& ShiftSize2 ))
				)
			{
			REGISTER SBIT32 Count1;
			REGISTER SBIT32 TopCacheSize = (TopCache -> GetPageSize());
			REGISTER SBIT32 MaxSize1 = (MidCacheSize / Stride1);
			REGISTER SBIT32 MaxSize2 = (TopCacheSize / Stride2);

			//
			//   Calculate the maximum number of free pages 
			//   that can be kept.  Also set the smallest parent
			//   mask to the maximum value.
			//
			MaxFreePages = (MaxFreeSpace / (TopCache -> GetAllocationSize()));
			SmallestParentMask = ((TopCache -> GetAllocationSize())-1);
			ThreadSafe = NewThreadSafe;

			//
			//   Calculate the sizes of the arrays that map 
			//   sizes to caches.
			//
			MaxTable1 = (MaxSize1 * sizeof(CACHE*));
			MaxTable2 = (MaxSize2 * sizeof(CACHE*));

			//
			//   The heap pages must be specified in asceding
			//   order of size and be an exact multiple of the
			//   minimum allocation size.
			//
			for ( Count1=0;Count1 < Size1;Count1 ++ )
				{
				REGISTER CACHE *Current = Caches1[ Count1 ];
				REGISTER CACHE *Next = Caches1[ (Count1+1) ];
				REGISTER SBIT32 AllocationSize = Current -> GetAllocationSize();
				REGISTER SBIT32 ChunkSize = Current -> GetChunkSize();
				REGISTER SBIT32 PageSize = Current -> GetPageSize();

				//
				//   Ensure each cache specification meets the
				//   requirements of the heap.  If not fail
				//   the heap entire heap creation.
				//
				if ( (AllocationSize % Stride1) != 0 )
					{ Failure( "Cache size not multiple of stride" ); }

				if ( AllocationSize >= Next -> GetAllocationSize() )
					{ Failure( "Cache sizes not in ascending order" ); }

				if ( (AllocationSize > ChunkSize) || (ChunkSize > PageSize) )
					{ Failure( "Chunk size not suitable for cache" ); }

				if ( AllocationSize >= PageSize )
					{ Failure( "Cache size larger than parent size" ); }

				if ( PageSize > TopCacheSize )
					{ Failure( "Parent size exceeds 'TopCache' size" ); }
				}

			//
			//   The heap pages must be specified in asceding
			//   order of size and be an exact multiple of the
			//   minimum allocation size.
			//
			for ( Count1=0;Count1 < (Size2-2);Count1 ++ )
				{
				REGISTER CACHE *Current = Caches2[ Count1 ];
				REGISTER CACHE *Next = Caches2[ (Count1+1) ];
				REGISTER SBIT32 AllocationSize = Current -> GetAllocationSize();
				REGISTER SBIT32 ChunkSize = Current -> GetChunkSize();
				REGISTER SBIT32 PageSize = Current -> GetPageSize();

				//
				//   Ensure each cache specification meets the
				//   requirements of the heap.  If not fail
				//   the heap entire heap creation.
				//
				if ( (AllocationSize % Stride2) != 0 )
					{ Failure( "Cache size not multiple of stride" ); }

				if ( AllocationSize >= Next -> GetAllocationSize() )
					{ Failure( "Cache sizes not in ascending order" ); }

				if ( (AllocationSize > ChunkSize) || (ChunkSize > PageSize) )
					{ Failure( "Chunk size not suitable for cache" ); }

				if ( AllocationSize >= PageSize )
					{ Failure( "Cache size larger than parent size" ); }

				if ( PageSize > TopCacheSize )
					{ Failure( "Parent size exceeds 'TopCache' size" ); }
				}

			//
			//   The external and top caches have special rules
			//   which must be checked to ensure these caches
			//   are valid.
			//
			for ( Count1=(Size2-2);Count1 < Size2;Count1 ++ )
				{
				REGISTER CACHE *Current = Caches2[ Count1 ];
				REGISTER SBIT32 AllocationSize = Current -> GetAllocationSize();

				//
				//   Ensure each cache specification meets the
				//   requirements of the heap.  If not fail
				//   the heap entire heap creation.
				//
				if ( (AllocationSize % Stride2) != 0 )
					{ Failure( "Top cache size not multiple of minimum" ); }

				if ( AllocationSize != Current -> GetChunkSize() )
					{ Failure( "Chunk size not suitable for top cache" ); }

				if ( AllocationSize != Current -> GetPageSize() )
					{ Failure( "Page size not suitable for top cache" ); }

				if ( Current -> GetCacheSize() != 0 )
					{ Failure( "Cache size not zero for top cache" ); }
				}

			//
			//   We need to allocate two arrays to enable requested
			//   sizes to be quickly mapped to allocation caches.
			//   Here we allocate the tables and later fill in all
			//   the necessary mapping information.
			//
			SizeToCache1 = (CACHE**) 
				(
				Rockall -> NewArea
					(
					(Rockall -> NaturalSize() - 1),
					(MaxTable1 + MaxTable2),
					False
					)
				);
#ifdef ENABLE_HEAP_STATISTICS

			//
			//   When we are compiled for statistics we keep
			//   information on all the allocations we see.
			//
			Statistics = (SBIT32*)
				(
				Rockall -> NewArea
					(
					(Rockall -> NaturalSize() - 1),
					(MaxCacheSize * sizeof(SBIT32)),
					False
					)
				);
#endif

			//
			//   We make sure that the allocations we made 
			//   did not fail.  If not we have to fail the 
			//   creation of the whole heap.
			//
			if 
					( 
					(SizeToCache1 != ((CACHE**) AllocationFailure))
#ifdef ENABLE_HEAP_STATISTICS
						&&
					(Statistics != ((SBIT32*) AllocationFailure))
#endif
					) 
				{
				REGISTER SBIT32 Count2;

				//
				//   Cycle through the first segment of the 
				//   mapping table creating approriate 
				//   translations.
				//
				for ( Count1=0,Count2=0;Count1 < MaxSize1;Count1 ++ )
					{
					//
					//   We make sure that the current allocation
					//   page is large enough to hold an element
					//   of some given size.  If not we move on to
					//   the next allocation page.
					//
					if 
							( 
							((Count1 + 1) * Stride1)
								> 
							(Caches1[ Count2 ] -> GetAllocationSize()) 
							)
						{ Count2 ++; }

					//
					//   Store a pointer so that a request for
					//   this size of allocation goes directly
					//   to the correct page.
					//
					SizeToCache1[ Count1 ] = Caches1[ Count2 ];
					}

				//
				//   Compute the start address for the second
				//   segment of the table.
				//
				SizeToCache2 = 
					((CACHE**) & ((CHAR*) SizeToCache1)[ MaxTable1 ]);

				//
				//   Cycle through the second segment of the 
				//   mapping table creating approriate 
				//   translations.
				//
				for ( Count1=0,Count2=0;Count1 < MaxSize2;Count1 ++ )
					{
					//
					//   We make sure that the current allocation
					//   page is large enough to hold an element
					//   of some given size.  If not we move on to
					//   the next allocation page.
					//
					if 
							( 
							((Count1 + 1) * Stride2)
								> 
							(Caches2[ Count2 ] -> GetAllocationSize()) 
							)
						{ Count2 ++; }

					//
					//   Store a pointer so that a request for
					//   this size of allocation goes directly
					//   to the correct page.
					//
					SizeToCache2[ Count1 ] = Caches2[ Count2 ];
					}

				//
				//   Now that we have created the size to cache 
				//   mappings lets use them to link each cache to  
				//   the cache it uses to allocate additional 
				//   memory.
				//
				for ( Count1=0;Count1 < (CachesSize-1);Count1 ++ )
					{
					REGISTER CACHE *CurrentCache = Caches[ Count1 ];
					REGISTER SBIT32 PageSize = CurrentCache -> GetPageSize();
					REGISTER CACHE *ParentCache = FindCache( PageSize );
					REGISTER BOOLEAN Top = (CurrentCache == ParentCache);

					//
					//   Ensure that the parent cache is suitable
					//   and in line with what we were expecting. 
					//
					if 
							(
							(PowerOfTwo( PageSize ))
								&&
							(PageSize >= MinParentSize)
								&&
							(PageSize == (ParentCache -> GetAllocationSize()))
							)
						{
						//
						//   We keep track of the smallest
						//   cache that is a parent.  We can
						//   use this to improve the performance
						//   of the find hash table.
						//
						if ( ((BIT32) PageSize) < SmallestParentMask )
							{ SmallestParentMask = (PageSize-1); }

						//
						//   Update the current cache with  
						//   information about it's parent 
						//   cache.
						//
						CurrentCache -> UpdateCache
							(
							NewFind,
							this,
							NewPages,
							((Top) ? ((CACHE*) GlobalRoot) : ParentCache)
							); 
						} 
					else
						{ Failure( "Parent bucket is invalid" ); }
					}

				//
				//   The external cache is an exact duplicate
				//   of the top cache and is used to hold all
				//   memory allocations that are too large for
				//   any bucket.  Nonetheless, its parent is
				//   still the top cache.
				//
				ExternalCache -> UpdateCache
					(
					NewFind,
					this,
					NewPages,
					TopCache
					);

				//
				//   Update the hash table with the minimum
				//   parent size for this heap.
				//
				Find -> UpdateFind
					(
					(TopCache -> GetAllocationSize()-1),
					SmallestParentMask 
					);

				//
				//   Update the new page structure with the 
				//   details of the top cache.
				//
				NewPage -> UpdateNewPage( TopCache );

				//
				//   Activate the heap.
				//
				Active = True;
				}
			else
				{ Failure( "Mapping table in constructor for HEAP" ); }
			}
		else
			{ Failure( "The allocation sizes in constructor for HEAP" ); }
		}
	else
		{ Failure( "A heap size in constructor for HEAP" ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Memory deallocation.                                           */
    /*                                                                  */
    /*   We need to release some memory.  First we try to slave the     */
    /*   request in the free cache so we can do a batch of releases     */
    /*   later.  If not we are forced to do it at once.                 */
    /*                                                                  */
    /********************************************************************/

BOOLEAN HEAP::Delete( VOID *Address,SBIT32 Size )
	{
	//
	//   Although normally a class is never called before
	//   its constructor.  The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		//
		//   When the caller gives us the size of the 
		//   allocation we can short cut the deallocation 
		//   process by skipping directly to the correct 
		//   cache.  However, if the user supplies us
		//   with bogus data we will retry using the
		//   the full deallocation process.
		//
		if ( (Size > 0) && (Size <= MaxCacheSize) )
			{
			REGISTER CACHE *Cache = (FindCache( Size ));

			if ( Find -> Delete( Address,Cache ) )
				{ return True; }
			}

		//
		//   It looks like all we have is the address so 
		//   deallocate using the long path.
		//
		return (Find -> Delete( Address,TopCache ));
		}
	else
		{ return False; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete all allocations.                                        */
    /*                                                                  */
    /*   We delete the entire heap and free all existing allocations.   */
    /*   If 'Recycle' is requested we slave the allocated memory as     */
    /*   we expect some new allocations.  If not we return all the      */
    /*   memory to the external allocator.                              */
    /*                                                                  */
    /********************************************************************/

VOID HEAP::DeleteAll( BOOLEAN Recycle )
	{
	//
	//   Although normally a class is never called before
	//   its constructor.  The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		REGISTER SBIT32 Count;

		//
		//   We claim all of the heap locks to freeze
		//   all new allocations or deletions.
		//
		LockAll();

		//
		//   Now reset all the caches and the find
		//   hash table statistics.
		//
		Find -> DeleteAll();

		for ( Count=0;Count < CachesSize;Count ++ )
			{ Caches[ Count ] -> DeleteAll(); }

		//
		//   Delete the heap.
		//
		NewPage -> DeleteAll( Recycle );

		//
		//   Now release all the heap locks we claimed
		//   earlier and unfreeze the heap.
		//
		UnlockAll();

		//
		//   Trim the free space if needed.
		//
		if ( Recycle )
			{ TopCache -> ReleaseSpace( MaxFreePages ); }
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Details of a memory allocation.                                */
    /*                                                                  */
    /*   We need to the details of a particular memory allocation.      */
    /*   All we have is an address.  We use this to find the largest    */
    /*   allocation page this address is contained in and then          */
    /*   navigate through the sub-divisions of this page until we       */
    /*   find the allocation.                                           */
    /*                                                                  */
    /********************************************************************/

BOOLEAN HEAP::Details( VOID *Address,SBIT32 *Size )
    {
	//
	//   Although normally a class is never called before
	//   its constructor.  The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		AUTO SBIT32 Dummy;

		//
		//   We allow the caller to omit the 'Size' parameter.
		//   I can see little reason for this but it is supported
		//   anyway.
		//
		if ( Size == NULL )
			{ Size = & Dummy; }

		//
		//   Find the details relating to this allocation
		//   and return them.
		//
		return (Find -> Details( Address,NULL,TopCache,Size ));
		}
	else
		{ return False; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Find a cache.                                                  */
    /*                                                                  */
    /*   Find the allocation cache for the size supplied and return     */
    /*   a pointer to it.                                               */
    /*                                                                  */
    /********************************************************************/

CACHE *HEAP::FindCache( SBIT32 Size )
	{
	REGISTER CACHE *Cache;

	//
	//   Compute the cache address.
	//
	if ( Size < MidCacheSize )
		{ return (SizeToCache1[ ((Size-1) >> ShiftSize1) ]); }
	else
		{ return (SizeToCache2[ ((Size-1) >> ShiftSize2) ]); }

	//
	//   Prefetch the class data if we are running a
	//   Pentium III or better with locks.  We do this
	//   because prefetching hot SMP data structures
	//   really helps.  However, if the structures are
	//   not shared (i.e. no locks) then it is worthless
	//   overhead.
	//
	if ( ThreadSafe )
		{ Prefetch.Nta( ((CHAR*) Cache),sizeof(CACHE) ); }

	return Cache;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Claim a lock on the entire heap.                               */
    /*                                                                  */
    /*   We claim a lock on the heap to improve performance             */
    /*   or prevent others from performing heap operations.             */
    /*                                                                  */
    /********************************************************************/

VOID HEAP::LockAll( VOID )
	{
	//
	//   Although normally a class is never called before
	//   its constructor.  The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		//
		//   We claim the locks if we have not already
		//   claimed them earlier.
		//
		if ( Find -> GetLockCount() == 0 )
			{
			REGISTER SBIT32 Count;

			//
			//   We claim all of the heap locks to freeze
			//   all new allocations or deletions.
			//
			for ( Count=0;Count < CachesSize;Count ++ )
				{ Caches[ Count ] -> ClaimCacheLock(); }

			//
			//  Although the heap is frozen at this point
			//  we claim the last few locks just to be
			//  tidy.
			//
			Find -> ClaimFindExclusiveLock();

			NewPage -> ClaimNewPageLock();
			}

		//
		//   Increment the per thread lock count.
		//
		Find -> IncrementLockCount();
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete multiple allocations.                                   */
    /*                                                                  */
    /*   We need to release multiple memory allocations.  First we try  */
    /*   to slave the requets in the free cache so we can do a batch    */
    /*   of releases later.  If not we are forced to do it immediately. */
    /*                                                                  */
    /********************************************************************/

BOOLEAN HEAP::MultipleDelete
		( 
		SBIT32						  Actual,
		VOID						  *Array[],
		SBIT32						  Size 
		)
	{
	//
	//   Although normally a class is never called before
	//   its constructor.  The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		REGISTER SBIT32 Count;
		REGISTER BOOLEAN Result = True;
		REGISTER CACHE *ParentCache = ((CACHE*) GlobalRoot);

		//
		//   When the caller gives us the size of the allocation
		//   we can short cut the deallocation process by skipping
		//   directly to the correct cache.  However, if the user
		//   supplies us with bogus data we will retry using the
		//   the long path.
		//
		if ( (Size > 0) && (Size <= MaxCacheSize) )
			{
			REGISTER CACHE *Cache = (FindCache( Size ));

			ParentCache = (Cache -> GetParentCache());
			}

		//
		//   Delete each memory allocation one at a time.
		//   We would like to delete them all at once but
		//   we can't be sure they are all vaild or related.
		//
		for ( Count=0;Count < Actual;Count ++ )
			{
			REGISTER VOID *Address = Array[ Count ];

			//
			//   First try to optimize the delete and if that
			//   fails then try the long path.
			//
			if 
					(
					(ParentCache == ((CACHE*) GlobalRoot)) 
						|| 
					(! Find -> Delete( Address,ParentCache )) 
					)
				{
				Result =
					(
					Find -> Delete( Address,TopCache )
						&&
					Result
					);
				}
			}

		return Result;
		}
	else
		{ return False; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory allocations.                                   */
    /*                                                                  */
    /*   We have been asked to allocate muliple memory blocks.   We     */
    /*   we do this by using the cache and then claiming and addition   */
    /*   space from the heap as needed.                                 */
    /*                                                                  */
    /********************************************************************/

BOOLEAN HEAP::MultipleNew
		( 
		SBIT32						  *Actual,
		VOID						  *Array[],
		SBIT32						  Requested,
		SBIT32						  Size,
		SBIT32						  *Space,
		BOOLEAN						  Zero
		)
	{
	//
	//   Although normally a class is never called before
	//   its constructor.  The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		AUTO SBIT32 Dummy;

		//
		//   We allow the caller to omit the 'Actual' parameter.
		//   I can see little reason for this but it is supported
		//   anyway.  Regardless we zero it.
		//
		if ( Actual == NULL )
			{ Actual = & Dummy; }

		(*Actual) = 0;

		//
		//   We need to be sure that the size requested is in the 
		//   range supported by the memory allocator.  If not we
		//   do a series of single allocations from the default
		//   allocator.
		//
		if ( (Size > 0) && (Size <= MaxCacheSize) )
			{
			REGISTER CACHE *Cache = (FindCache( Size ));
			REGISTER SBIT32 NewSize = (Cache -> GetAllocationSize());

			//
			//   Allocate memory from the appropriate 
			//   allocation bucket.
			//
			(VOID) Cache -> MultipleNew( Actual,Array,Requested );

			//
			//   If needed return the actual amount  
			//   of space allocated for each element.
			//
			if ( Space != NULL )
				{ (*Space) = NewSize; }
#ifdef ENABLE_HEAP_STATISTICS

			//
			//   Update the allocation statistics.
			//
			Statistics[ (Size-1) ] += Requested;
#endif

			//
			//   If needed zero each element that is  
			//   allocated.
			//
			if ( Zero )
				{
				REGISTER SBIT32 Count;

				for ( Count=((*Actual)-1);Count >= 0;Count -- )
					{ ZeroMemory( Array[ Count ],NewSize ); }
				}

			return ((*Actual) == Requested);
			}
		else
			{
			//
			//   If the allocation size is greater than
			//   zero we create the allocations.  If not
			//   we fail the request.
			//
			if ( Size > 0 )
				{
				//
				//   We have got a request for an element size
				//   larger than the largest bucket size.  So 
				//   we call the single allocation interface 
				//   as this supports large sizes.
				//
				for 
					( 
					/* void */;
					((*Actual) < Requested)
						&&
					((Array[ (*Actual) ] = New( Size )) != AllocationFailure);
					(*Actual) ++ 
					);

				//
				//   If needed return the actual amount of space 
				//   allocated for each element.
				//
				if ( Space != NULL )
					{ (*Space) = Size; }

				return ((*Actual) == Requested);
				}
			}
		}

	return False;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation.                                             */
    /*                                                                  */
    /*   We have been asked to allocate some memory.  Hopefully,        */
    /*   we will be able to do this out of the cache.  If not we        */
    /*   will need to pass it along to the appropriate allocation       */
    /*   bucket.                                                        */
    /*                                                                  */
    /********************************************************************/

VOID *HEAP::New( SBIT32 Size,SBIT32 *Space,BOOLEAN Zero )
	{
	REGISTER VOID *NewMemory = ((VOID*) AllocationFailure);

	//
	//   Although normally a class is never called before
	//   its constructor. The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		//
		//   We ensure the allocation size is in
		//   the range supported by the heap.
		//
		if ( (Size > 0) && (Size <= MaxCacheSize) )
			{
			REGISTER CACHE *Cache = (FindCache( Size ));
#ifdef ENABLE_HEAP_STATISTICS

			//
			//   Update the allocation statistics.
			//
			Statistics[ (Size-1) ] ++;
#endif

			//
			//   Allocate memory from the appropriate
			//   cache in the heap.
			//
			NewMemory = (Cache -> New()); 
			Size = (Cache -> GetAllocationSize());
			}
		else
			{ 
			//
			//   If the allocation size is greater than
			//   zero we create the allocation.  If not
			//   we fail the request.
			//
			if ( Size > 0 )
				{
#ifdef ENABLE_HEAP_STATISTICS
				//
				//   Update the allocation statistics.
				//
				if ( Size > MaxNewSize )
					{ MaxNewSize = Size; }

				NewMisses ++;
				TotalNewSize += Size;

#endif
				//
				//   Allocate memory from a special
				//   cache bucket which gets space
				//   externally.
				//
				NewMemory = (ExternalCache -> New( False,Size ));
				}
			else
				{ NewMemory = ((VOID*) AllocationFailure); }
			}

		//
		//   We need to be sure that the allocation 
		//   request did not fail.
		//
		if ( NewMemory != ((VOID*) AllocationFailure) )
			{
			//
			//   If needed return the actual amount of space 
			//   allocated for this request.
			//
			if ( Space != NULL )
				{ (*Space) = Size; }

			//
			//   Zero the memory if the needed.
			//
			if ( Zero )
				{ ZeroMemory( NewMemory,Size ); }
			}
		}

	return NewMemory;
	}
#ifdef ENABLE_HEAP_STATISTICS

    /********************************************************************/
    /*                                                                  */
    /*   Print statistics.                                              */
    /*                                                                  */
    /*   We output the allocation statistics to the debug console.      */
    /*                                                                  */
    /********************************************************************/

VOID HEAP::PrintDebugStatistics( VOID )
	{
	REGISTER HANDLE Semaphore;
	
	//
	//   As we may have multiple heaps executing there 
	//   destructors at the same time we create a semaphore
	//   to prevent multiple threads producing output at
	//   the same time.
	//
	if ( (Semaphore = CreateSemaphore( NULL,1,MaxCpus,"Print" )) != NULL)
        {
		//
		//   Wait for the global semaphore.
		//
		if 
				( 
				WaitForSingleObject( Semaphore,INFINITE ) 
					== 
				WAIT_OBJECT_0 
				)
			{
			REGISTER SBIT32 Count;
			REGISTER SBIT32 CurrentSize = 0;
			REGISTER SBIT32 GrandTotal = 0;
			REGISTER SBIT32 HighWater = 0;
			REGISTER SBIT32 Total = 0;

			//
			//   Output the titles to the debug console.
			//
			DebugPrint
				( 
				"\n"
				"  Original    New      Bucket    High   "
				"   Cache    Cache     Partial    Grand\n" 
				"    Size    Allocs      Size     Water  "
				"   Fills   Flushes     Total     Total\n"
				);

			//
			//   Output details for every sample size.
			//
			for ( Count=0;Count < MaxCacheSize;Count ++ )
				{
				REGISTER SBIT32 Hits = Statistics[ Count ]; 

				//
				//   Skip the sample if there are no hits.
				//
				if ( Hits > 0 )
					{
					REGISTER CACHE *Cache = FindCache( (Count+1) );
					REGISTER SBIT32 CacheSize = Cache -> GetAllocationSize();

					//
					//   Zero the running totals at the end
					//   of each bucket.
					//
					if ( CurrentSize != CacheSize )
						{
						CurrentSize = CacheSize;
						Total = 0;

						DebugPrint
							( 
							"----------------------------------------"
							"--------------------------------------\n" 
							);
						}

					//
					//   Compute and output the totals.
					//
					if ( Total == 0)
						{ HighWater += (Cache -> GetHighWater() * CacheSize); }

					Total += Hits;
					GrandTotal += Hits;

					DebugPrint
						(
						"%8d  %8d  %8d  %8d  %8d  %8d  %8d  %8d\n",
						(Count + 1),
						Hits,
						CacheSize,
						Cache -> GetHighWater(),
						Cache -> GetCacheFills(),
						Cache -> GetCacheFlushes(),
						Total,
						GrandTotal
						); 
					}
				}

			//
			//   Print the hash table statistics.
			//
			DebugPrint( "\nHash Table Statistics" );
			DebugPrint( "\n---------------------\n" );

			DebugPrint
				(
				"\t*** Cache ***\n"
				"\tFills\t\t: %d\n\tHits\t\t: %d\n\tMisses\t\t: %d\n"
				"\t*** Table ***\n"
				"\tAverage\t\t: %d\n\tMax\t\t: %d\n\tScans\t\t: %d\n"
				"\tMax Hash\t: %d\n\tMax LookAside\t: %d\n\tUsage\t\t: %d%%\n",
				Find -> CacheFills(),
				Find -> CacheHits(),
				Find -> CacheMisses(),
				Find -> AverageHashLength(),
				Find -> MaxHashLength(),
				Find -> TotalScans(),
				Find -> MaxHashSize(),
				Find -> MaxLookAsideSize(),
				Find -> MaxUsage()
				);

			//
			//   Print the reallocation statistics.
			//
			DebugPrint( "\nOversize Statistics" );
			DebugPrint( "\n-------------------\n" );

			DebugPrint
				(
				"\tAverage Size\t: %d\n\tMax Size\t: %d\n\tMisses\t\t: %d\n",
				(TotalNewSize / ((NewMisses > 0) ? NewMisses : 1)),
				MaxNewSize,
				NewMisses
				);

			//
			//   Print the reallocation statistics.
			//
			DebugPrint( "\nRealloc Statistics" );
			DebugPrint( "\n------------------\n" );

			DebugPrint
				(
				"\tAverage Copy\t: %d\n\tCalls\t\t: %d\n\tMax Copy\t: %d\n"
				"\tTotal Copies\t: %d\n",
				(TotalCopySize / ((CopyMisses > 0) ? CopyMisses : 1)),
				Reallocations,
				MaxCopySize,
				CopyMisses
				);

			//
			//   Print the general statistics.
			//
			DebugPrint( "\nSummary Statistics" );
			DebugPrint( "\n------------------\n" );

			DebugPrint
				(
				"\tHigh Water\t: %d\n",
				HighWater
				);
			}
		else
			{ Failure( "Sleep failed in PrintDebugStatistics" ); }

		//
		//   Release the global semaphore.
		//
		ReleaseSemaphore( Semaphore,1,NULL );

		CloseHandle( Semaphore );
		}
	}
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Memory reallocation.                                           */
    /*                                                                  */
    /*   We have been asked to reallocate some memory.  Hopefully,      */
    /*   we will be able to do this out of the cache.  If not we        */
    /*   will need to pass it along to the appropriate allocation       */
    /*   bucket, do a copy and free the orginal allocation.             */
    /*                                                                  */
    /********************************************************************/

VOID *HEAP::Resize
		( 
		VOID						  *Address,
		SBIT32						  NewSize,
		SBIT32						  Move,
		SBIT32						  *Space,
		BOOLEAN						  NoDelete,
		BOOLEAN						  Zero
		)
	{
	//
	//   Although normally a class is never called before
	//   its constructor.  The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		AUTO SBIT32 Size;
		AUTO SBIT32 NewSpace;

		//
		//   Find the details of the existing allocation.
		//   If there is no existing allocation then exit.
		//
		if ( Details( Address,& Size ) )
			{
			REGISTER VOID *NewMemory;
			REGISTER SBIT32 Smallest = ((Size < NewSize) ? Size : NewSize);

			//
			//   Make sure the sizes appear to make sense.
			//
			if ( Smallest > 0 )
				{
#ifdef ENABLE_HEAP_STATISTICS
				//
				//   Update the statistics.
				//
				Reallocations ++;

#endif
				//
				//   When the new allocation allocation is 
				//   standard heap allocation size we check 
				//   for various optimizations.
				//
				if ( NewSize <= MaxCacheSize )
					{
					REGISTER CACHE *Cache = (FindCache( NewSize ));
					REGISTER SBIT32 CacheSize = (Cache -> GetAllocationSize());
					REGISTER SBIT32 Delta = (CacheSize - Size);
					
					//
					//   We only need to reallocate if the new
					//   size is larger than the current bucket
					//   or the new size is smaller and we have 
					//   been given permission to move the 
					//   allocation.
					//
					if ( ResizeTest( Delta,Move ) )
						{
						//
						//   We need to allocate some more
						//   memory and copy the old data.
						//   into the new area.
						//
						NewMemory = (Cache -> New());
						NewSpace = CacheSize;
#ifdef ENABLE_HEAP_STATISTICS

						//
						//   Update the statistics.
						//
						Statistics[ (NewSize-1) ] ++;
#endif
						}
					else
						{
						//
						//   If the new size is unchanged or smaller
						//   then just return the current allocation.
						//   If the new size is larger then we must
						//   fail the call.
						//
						if ( Delta <= 0 )
							{
							//
							//   The amount of memory allocated for  
							//   this request is unchanged so return  
							//   the current size.
							//
							if ( Space != NULL )
								{ (*Space) = Size; }

							return Address; 
							}
						else
							{ return ((VOID*) AllocationFailure); }
						}
					}
				else
					{
					REGISTER SBIT32 Delta = (NewSize - Size);

					//
					//   We only need to reallocate if the new
					//   size is larger than the current bucket
					//   or the new size is smaller and we have 
					//   been given permission to move the 
					//   allocation.
					//
					if ( ResizeTest( Delta,Move ) )
						{
						//
						//   One of the sizes is not within the
						//   allocation range of the heap.  So
						//   I have to punt and reallocate.
						//   
						NewMemory = 
							(
							ExternalCache -> New
								( 
								False,
								(NewSpace = NewSize)
								)
							);
#ifdef ENABLE_HEAP_STATISTICS

						//
						//   Update the allocation statistics.
						//
						if ( NewSize > MaxNewSize )
							{ MaxNewSize = NewSize; }

						NewMisses ++;
						TotalNewSize += NewSize;
#endif
						}
					else
						{
						//
						//   If the new size is unchanged or smaller
						//   then just return the current allocation.
						//   If the new size is larger then we must
						//   fail the call.
						//
						if ( Delta <= 0 )
							{
							//
							//   The amount of memory allocated for  
							//   this request is unchanged so return  
							//   the current size.
							//
							if ( Space != NULL )
								{ (*Space) = Size; }

							return Address; 
							}
						else
							{ return ((VOID*) AllocationFailure); }
						}
					}
				
				//
				//   We need to make sure we were able to allocate
				//   the new memory otherwise the copy will fail.
				//
				if ( NewMemory != ((VOID*) AllocationFailure) )
					{
					//
					//   Copy the contents of the old allocation 
					//   to the new allocation.
					//
					memcpy
						( 
						((void*) NewMemory),
						((void*) Address),
						((int) Smallest) 
						);

					//
					//   If needed return the actual amount of  
					//   space allocated for this request.
					//
					if ( Space != NULL )
						{ (*Space) = NewSpace; }

					//
					//   Delete the old allocation unless we
					//   need to keep it around.
					//
					if ( ! NoDelete )
						{
						//
						//   Delete the old allocation.
						//
						if ( ! Delete( Address,Size ) )
							{ Failure( "Deleting allocation in Resize" ); }
						}

					//
					//   Zero the memory if the needed.
					//
					if ( Zero )
						{
						REGISTER SBIT32 Difference = (NewSpace - Smallest);

						//
						//   If the new size is larger than 
						//   old size then zero the end of the
						//   new allocation.
						//
						if ( Difference > 0 )
							{ 
							REGISTER CHAR *Array = ((CHAR*) NewMemory);

							ZeroMemory( & Array[ Smallest ],Difference ); 
							} 
						}	
#ifdef ENABLE_HEAP_STATISTICS

					//
					//   Update the allocation statistics.
					//
					if ( Smallest > MaxCopySize )
						{ MaxCopySize = Smallest; }

					CopyMisses ++;
					TotalCopySize += Smallest;
#endif
					}

				return NewMemory;
				}
			}
		}

	return ((VOID*) AllocationFailure);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Truncate the heap.                                             */
    /*                                                                  */
    /*   We need to truncate the heap.  This pretty much a do nothing   */
    /*   as we do this automatically anyway.  The only thing we can     */
    /*   do is free any space the user suggested keeping earlier.       */
    /*                                                                  */
    /********************************************************************/

BOOLEAN HEAP::Truncate( SBIT32 MaxFreeSpace )
	{
	REGISTER BOOLEAN Result = True;

	//
	//   Although normally a class is never called before
	//   its constructor.  The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		REGISTER SBIT32 Count;

		//
		//   Flush all the caches and to free up
		//   as much space as possible.
		//
		for ( Count=0;Count < CachesSize;Count ++ )
			{
			Result =
				(
				(Caches[ Count ] -> Truncate())
					&&
				(Result)
				); 
			}

		//
		//   We slave all available free space in the top
		//   bucket so force it to be released.
		//
		TopCache -> ReleaseSpace
			(
			(MaxFreeSpace / (TopCache -> GetAllocationSize()))
			);
		}

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Release all the heap locks.                                    */
    /*                                                                  */
    /*   We release the locks so others can use the heap.               */
    /*                                                                  */
    /********************************************************************/

VOID HEAP::UnlockAll( BOOLEAN Partial )
	{
	//
	//   Although normally a class is never called before
	//   its constructor.  The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		//
		//   Decrement the per thread lock count.
		//
		Find -> DecrementLockCount();

		//
		//   We release the locks only if we have claimed 
		//   them earlier.
		//
		if ( (Find -> GetLockCount()) == 0 )
			{
			//
			//   Now release all the heap locks we claimed
			//   earlier and unfreeze the heap.
			//
			NewPage -> ReleaseNewPageLock();

			Find -> ReleaseFindExclusiveLock();

			//
			//   When we destroy the heap we hold on
			//   to the cache locks to prevent errors.
			//
			if ( ! Partial )
				{
				REGISTER SBIT32 Count;

				//
				//   Now release all the cache locks we claimed
				//   earlier and unfreeze the cache.
				//
				for ( Count=0;Count < CachesSize;Count ++ )
					{ Caches[ Count ] -> ReleaseCacheLock(); }
				}
			}
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Verify of a memory allocation.                                 */
    /*                                                                  */
    /*   We need to verify the details of a memory allocation.          */
    /*   All we have is an address.  We use this to find the largest    */
    /*   allocation page this address is contained in and then          */
    /*   navigate through the sub-divisions of this page until we       */
    /*   find the allocation.  Finally, we check that the element       */
    /*   is not in the cache waiting to be allocated or freed.          */
    /*                                                                  */
    /********************************************************************/

BOOLEAN HEAP::Check( VOID *Address,SBIT32 *Size )
    {
	//
	//   Although normally a class is never called before
	//   its constructor.  The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		AUTO SEARCH_PAGE Details;
		AUTO SBIT32 NewSize;

		//
		//   We extract the size of the allocation and  
		//   any associated allocation information.
		//   to see if it is present.
		//
		if ( Find -> Details( Address,& Details,TopCache,& NewSize ) )
			{
			//
			//   We need to be careful to make sure this 
			//   element is actually allocated.
			//
			if ( Details.Found )
				{
				//
				//   We know that the element appears to be 
				//   allocated but it may be in the cache
				//   somewhere so ensure this is not the case.
				//
				if ( (NewSize > 0) && (NewSize <= MaxCacheSize) )
					{
					if ( Details.Cache -> SearchCache( Address ) )
						{ return False; }
					}

				//
				//   We have shown that the element is active
				//   so return the size if requested.
				//
				if ( Size != NULL )
					{ (*Size) = NewSize; }

				return True;
				}
			}
		}

	return False;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Walk the heap.                                                 */
    /*                                                                  */
    /*   We have been asked to walk the heap.  It is hard to know       */
    /*   whay anybody might want to do this given the rest of the       */
    /*   functionality available.  Nonetheless, we just do what is      */
    /*   required to keep everyone happy.                               */
    /*                                                                  */
    /********************************************************************/

BOOLEAN HEAP::Walk
		( 
		BOOLEAN						  *Active,
		VOID						  **Address,
		SBIT32						  *Size 
		)
    {
	//
	//   Although normally a class is never called before
	//   its constructor.  The heap is subject to some strange
	//   behaviour so we check to make sure this is not the
	//   case.
	//
	if ( Active )
		{
		//
		//   We walk the heap and find the next allocation
		//   along with some basic information.
		//
		if ( Find -> Walk( Active,Address,TopCache,Size ) )
			{
			//
			//   We know that the element appears to be 
			//   allocated but it may be in the cache
			//   somewhere so ensure this is not the case.
			//
			if ( ((*Size) > 0) && ((*Size) <= MaxCacheSize) )
				{
				if ( FindCache( (*Size) ) -> SearchCache( (*Address) ) )
					{ (*Active) = False; }
				}

			return True;
			}
		}

	return False;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   We would like to destroy the heap at the end of the run        */
    /*   just to be tidy.  However, to do this we need to know that     */
    /*   all of the other destructors have been called and that the     */
    /*   application will not request more memory or use any existing   */
    /*   allocations.  We can't know this without help from the         */
    /*   compiler and OS.                                               */
    /*                                                                  */
    /********************************************************************/

HEAP::~HEAP( VOID )
	{
	REGISTER SBIT32 Count;

	//
	//   We mark the heap as inactive.
	//
	Active = False;

	//
	//   We claim all of the heap locks to freeze
	//   all new allocations or deletions.
	//
	LockAll();

	//
	//   Now reset all the caches.
	//
	for ( Count=0;Count < CachesSize;Count ++ )
		{ Caches[ Count ] -> DeleteAll(); }

	//
	//   Delete the heap.
	//
	NewPage -> DeleteAll( False );

	//
	//   We release any of the shared locks we 
	//   cliamed earlier.
	//
	UnlockAll( True );
#ifdef ENABLE_HEAP_STATISTICS

	//
	//   Deal with heap statistics.
	//
	if ( Statistics != NULL ) 
		{
		//
		//   Print all the statistics.
		//
		PrintDebugStatistics();

		//
		//   Deallocate the area.
		//
		Rockall -> DeleteArea
			( 
			((VOID*) Statistics),
			(MaxCacheSize * sizeof(SBIT32)),
			False
			); 
		}
#endif

	//
	//   Delete the heap mapping tables.
	//
	if ( SizeToCache1 != NULL ) 
		{ 	
		//
		//   Deallocate the area.
		//
		Rockall -> DeleteArea
			( 
			((VOID*) SizeToCache1),
			(MaxTable1 + MaxTable2),
			False
			); 
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\heap\heappch.hpp ===
#ifndef _HEAP_PCH_HPP_
#define _HEAP_PCH_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#ifndef DISABLE_PRECOMPILED_HEADERS
#include "Bucket.hpp"
#include "BucketList.hpp"
#include "Cache.hpp"
#include "Connections.hpp"
#include "Find.hpp"
#include "FindList.hpp"
#include "Heap.hpp"
#include "NewPage.hpp"
#include "NewPageList.hpp"
#include "Page.hpp"
#include "Rockall.hpp"

#include "LibraryPCH.hpp"
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\heap\heap.hpp ===
#ifndef _HEAP_HPP_
#define _HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Environment.hpp"
#include "Common.hpp"
#include "Find.hpp"
#include "NewPage.hpp"
#include "Prefetch.hpp"
#include "Rockall.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class BUCKET;
class CACHE;

    /********************************************************************/
    /*                                                                  */
    /*   The heap interface.                                            */
    /*                                                                  */
    /*   The traditional memory allocation interface only supports      */
    /*   a single allocation heap.  This memory allocator supports      */
    /*   multiple allocation heaps.  However, the interface nicely      */
    /*   hides this so at this point we are back to the traditional     */
    /*   single heap interface.                                         */
    /*                                                                  */
    /********************************************************************/

class HEAP : public ENVIRONMENT, public COMMON
    {
		//
		//   Private data.
		//
		//   The heap is the top level container of all the
		//   functionality in the other classes.  The 'Active'
		//   flag indicates if the heap has been initialized.
		//   The 'MaxFreePages' controls the amount of free
		//   space the heap will slave before it starts to
		//   return it the the external allocator.  The
		//   'SmallestParentMask' is mask that shows which 
		//   parts of an address can be safely masked off
		//   and still ensure a hit in the find lookaside
		//   cache.  The 'ThreadSafe' flag indicates whether
		//   locking being used.
		//
		BOOLEAN						  Active;
		SBIT32						  MaxFreePages;
		BIT32						  SmallestParentMask;
		BOOLEAN						  ThreadSafe;

		//
		//   A heap is merely a collection of fixed sized
		//   allocation buckets (each with an optional cache).
		//   The 'CachesSize' is the total number of buckets.
		//   The 'MinCacheSize' is the allocation size of the
		//   smallest bucket.  The 'MidCacheSize' is the size
		//   of the bucket where the stride changes.  The
		//   'MaxCacheSize' is the allocation size of the 
		//   largest bucket externally visable.
		//
		SBIT32						  CachesSize;
		SBIT32						  MinCacheSize;
		SBIT32						  MidCacheSize;
		SBIT32						  MaxCacheSize;

		//
		//   A key function of the heap is to convert the
		//   requested allocation size into a pointer to
		//   the appropriate bucket (and cache).  This has
		//   to be very fast and is achieved using a direct
		//   lookup (i.e. an array).  The lookup array 
		//   consists of two sections (i.e. for small sizes
		//   and large sizes) to minimize space.  The 
		//   'MaxTable1' and 'MaxTable2' variables contain 
		//   the size of each section of the array.  The 
		//   'ShiftSize1' and 'ShiftSize2' variables contain
		//   the shift that should be applied to the size to
		//   obtain the appropriate index.  The 'SizeToCache1'
		//   and 'SizeToCache2' pointers refer to the direct
		//   lookup tables.
		//   
		SBIT32						  MaxTable1;
		SBIT32						  MaxTable2;
		SBIT32						  ShiftSize1;
		SBIT32						  ShiftSize2;
		CACHE                         **SizeToCache1;
		CACHE                         **SizeToCache2;

		//
		//   The heap needs to have access to most of the 
		//   other classes.  The 'Caches' class sits on
		//   top of an allocation bucket which owns all
		//   the allocated memory for a given size.  The
		//   'ExternalCache' is a special bucket that 
		//   contains weird sized pages.  The 'Find' class
		//   translates allocation addresses to page 
		//   descriptions.  The 'Rockall' class is needed
		//   to gain access to the external allocation APIs.
		//   The 'NewPage' class owns all page descriptions
		//   and plays a significant role in whole heap
		//   operations.  The 'TopCache' is the largest 
		//   bucket size and owns almost all the externally
		//   allocated memory.
		//
		CACHE						  **Caches;
		CACHE						  *ExternalCache;
		FIND						  *Find;
		NEW_PAGE					  *NewPage;
		PREFETCH					  Prefetch;
		ROCKALL						  *Rockall;
		CACHE						  *TopCache;
#ifdef ENABLE_HEAP_STATISTICS

		//
		//   Statistics data.
		//
		//   A key feature of this heap is its ability to be
		//   significantly reconfigured at run time.  A great
		//   deal of complexity could have been removed if 
		//   certain static choices had been made.  Although
		//   this flexibility is nice the support of statistics
		//   here allows precise information to be collected so
		//   to enable the value of this to be maximized.
		//   
		//
		SBIT32						  CopyMisses;
		SBIT32						  MaxCopySize;
		SBIT32						  MaxNewSize;
		SBIT32						  NewMisses;
		SBIT32						  Reallocations;
		SBIT32						  *Statistics;
		SBIT32						  TotalCopySize;
		SBIT32						  TotalNewSize;
#endif

   public:
		//
		//   Public functions.
		//
		//   The heap exports the high level interface
		//   out to the world.  Any request a developer
		//   can make must come through one of these
		//   functions.
		//
        HEAP
			(
			CACHE					  *Caches1[],
			CACHE					  *Caches2[],
			SBIT32					  MaxFreeSpace,
			FIND					  *NewFind,
			NEW_PAGE				  *NewPages,
			ROCKALL					  *NewRockall,
			SBIT32					  Size1,
			SBIT32					  Size2,
			SBIT32					  Stride1,
			SBIT32					  Stride2,
			BOOLEAN					  NewThredSafe
			);

		BOOLEAN Delete( VOID *Address,SBIT32 Size = NoSize );

		VOID DeleteAll( BOOLEAN Recycle = True );

		BOOLEAN Details( VOID *Address,SBIT32 *Size = NULL );

		VOID LockAll( VOID );

		BOOLEAN MultipleDelete
			( 
			SBIT32					  Actual,
			VOID					  *Array[],
			SBIT32					  Size = NoSize
			);

		BOOLEAN MultipleNew
			( 
			SBIT32					  *Actual,
			VOID					  *Array[],
			SBIT32					  Requested,
			SBIT32					  Size,
			SBIT32					  *Space = NULL,
			BOOLEAN					  Zero = False
			);

		VOID *New
			( 
			SBIT32					  Size,
			SBIT32					  *Space = NULL,
			BOOLEAN					  Zero = False
			);

		VOID *Resize
			( 
			VOID					  *Address,
			SBIT32					  NewSize,
			SBIT32					  Move = 1,
			SBIT32					  *Space = NULL,
			BOOLEAN					  NoDelete = False,
			BOOLEAN					  Zero = False
			);

		BOOLEAN Truncate( SBIT32 MaxFreeSpace = 0 );

		VOID UnlockAll( BOOLEAN Partial = False );

		BOOLEAN Check( VOID *Address,SBIT32 *Size = NULL );

		BOOLEAN Walk
			( 
			BOOLEAN					  *Active,
			VOID					  **Address,
			SBIT32					  *Size 
			);

        ~HEAP( VOID );

		//
		//   Public inline functions.
		//
		//   Although these functions are public they mostly
		//   intended for internal consumption and are not
		//   to be called externally.
		//
		INLINE SBIT32 GetMaxFreePages( VOID )
			{ return MaxFreePages; }

		INLINE BOOLEAN KnownArea( VOID *Address )
			{ return (Find -> KnownArea( Address,TopCache )); }

		INLINE VOID *SpecialNew( SBIT32 Size )
			{ return NewPage -> NewCacheStack( Size ); }

	private:
		//
		//   Private functions.
		//
		//   All of the statistical information is 
		//   generated and output when the heaps
		//   destructor executes.
		//
		CACHE *FindCache( SBIT32 Size );
#ifdef ENABLE_HEAP_STATISTICS

		VOID PrintDebugStatistics( VOID );
#endif
		//
		//   Private inline functions.
		//
		//   The notion that resizing an allocation is 
		//   cheap has worked its way into the minds of 
		//   a large number of developers.  As a result
		//   parameter has been added to the function to
		//   allow the actual behavior to be controlled.
		//
		INLINE BOOLEAN ResizeTest( SBIT32 Delta,SBIT32 Move )
			{
			return
				(
				((Move > 0) && ((((Delta >= 0) ? Delta : -Delta) >= Move)))
					||
				((Move < 0) && ((Delta > 0) || (Delta <= Move)))
				);
			}

        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        HEAP( CONST HEAP & Copy );

        VOID operator=( CONST HEAP & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\heap\heappch.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "HeapPCH.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\heap\newpage.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "HeapPCH.hpp"

#include "Cache.hpp"
#include "New.hpp"
#include "NewPage.hpp"
#include "Rockall.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants set overall limits on the number and size of     */
    /*   page descriptions for pages within the memory allocator.       */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 MinNewPages			  = 1;
CONST SBIT32 VectorRange			  = ((2 << 15) - 1);

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   A 'PAGE' structure has various fixed fields and a variable     */
    /*   sized allocation bit vector.  When this class is initialized   */
    /*   the user is required to supply us with an array that details   */
    /*   the sizes of allocation bit vectors supported.                 */
    /*                                                                  */
    /********************************************************************/

NEW_PAGE::NEW_PAGE
		(
		FIND						  *NewFind,
		SBIT32						  NewPageSizes[],
		ROCKALL						  *NewRockall,
		SBIT32						  Size,
		BOOLEAN						  NewThreadSafe 
		)
    {
	REGISTER SBIT32 DefaultRootSize = (NewRockall -> NaturalSize());
	REGISTER SBIT32 ReservedBytes = (Size * sizeof(NEW_PAGES));
	REGISTER SBIT32 SpareBytes = (DefaultRootSize - ReservedBytes);
	REGISTER SBIT32 StackSize = (SpareBytes / sizeof(VOID*));

	//
	//   We need to make sure that we appear to have a valid
	//   array of 'NewPageSizes' and that the bit vector sizes
	//   do not exceed the memory addressing range.
	//
	if 
			(
			PowerOfTwo( DefaultRootSize )
				&&
			(DefaultRootSize >= PageSize())
				&&
			(Size >= MinNewPages) 
				&&
			((NewPageSizes[ (Size-1) ] * OverheadBitsPerWord) <= VectorRange)
			)
		{
		REGISTER VOID *NewMemory = 
			(
			NewRockall -> NewArea
				( 
				(DefaultRootSize-1),
				DefaultRootSize,
				False
				)
			);

		//
		//   We are in big trouble if we can not allocate space
		//   to store this initial control information.  If the
		//   allocation fails we are forced to exit and the whole  
		//   memory allocator becomes unavailable.
		//
		if ( NewMemory != AllocationFailure )
			{
			REGISTER SBIT32 Count;
			REGISTER SBIT32 LastSize = 0;

			//
			//   We are now ready to setup the configuration
			//   information.
			//
			MaxCacheStack = 0;
			MaxNewPages = Size;
			MaxStack = StackSize;

			NaturalSize = DefaultRootSize;
			RootCoreSize = DefaultRootSize;
			RootStackSize = 0;
			ThreadSafe = NewThreadSafe;
			TopOfStack = 0;
			Version = 0;

			CacheStack = NULL;
			NewPages = ((NEW_PAGES*) NewMemory);
			Stack = ((VOID**) & NewPages[ Size ]);

			Find = NewFind;
			Rockall = NewRockall;
			TopCache = NULL;

			//
			//   Create a lists for the various page 
			//   sizes and prepare them for use.
			//
			for ( Count=0;Count < Size;Count ++ )
				{
				REGISTER SBIT32 CurrentSize = NewPageSizes[ Count ];

				if ( CurrentSize > LastSize )
					{
					REGISTER NEW_PAGES *NewPage = & NewPages[ Count ];

					//
					//   Create a list for the current
					//   size and fill in all the related
					//   details.
					//
					NewPage -> Elements = (CurrentSize * OverheadBitsPerWord);
					PLACEMENT_NEW( & NewPage -> ExternalList,LIST );
					PLACEMENT_NEW( & NewPage -> FullList,LIST );
					PLACEMENT_NEW( & NewPage -> FreeList,LIST );
					NewPage -> Size = (CurrentSize * sizeof(BIT32));

					LastSize = CurrentSize;
					}
				else
					{ Failure( "Sizes in constructor for NEW_PAGES" ); }
				}
			}
		else
			{ Failure( "No memory in constructor for NEW_PAGES" ); }
		}
	else
		{ Failure( "Setup of pages in constructor for NEW_PAGES" ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Create a new page.                                             */
    /*                                                                  */
    /*   Create a new 'PAGE' structure and prepare it for use.  If      */
    /*   we don't already have any pages of the required size then      */
    /*   allocate memory, create new 'PAGE' structures and link them    */
    /*   into the appropriate free chain.                               */
    /*                                                                  */
    /********************************************************************/

PAGE *NEW_PAGE::CreatePage( CACHE *Cache,SBIT32 NewSize )
    {
	REGISTER PAGE *NewPage = ((PAGE*) AllocationFailure);
	REGISTER SBIT16 SizeKey = (Cache -> GetSizeKey());

	//
	//   All allocations are made from fixed sized
	//   pages.  These pages have a bit vector to
	//   keep track of which elements are allocated
	//   and available.  The 'SizeKey' is an index
	//   into 'NewPages[]' that will supply a page
	//   that has a big enough the bit vector.
	//
#ifdef DEBUGGING
	if ( (SizeKey >= 0) && (SizeKey < MaxNewPages) )
		{
#endif
		REGISTER NEW_PAGES *Current;

		//
		//   When there is a potential for multiple threads 
		//   we claim the lock.
		//
		ClaimNewPageLock();

		//
		//   We allocate 'PAGE' structures as we need them
		//   and link them together in the free list.
		//   If we don't have any structures available we 
		//   allocate some more and add tem to the list.
		//
		if ( (Current = & NewPages[ SizeKey ]) -> FreeList.EndOfList() )
			{
			REGISTER SBIT32 ArrayElements = (Current -> Size - MinVectorSize);
			REGISTER SBIT32 ArraySize = (ArrayElements * sizeof(BIT32));
			REGISTER SBIT32 TotalSize = (sizeof(PAGE) + ArraySize);
			REGISTER SBIT32 FinalSize = CacheAlignSize( TotalSize );
			REGISTER SBIT32 TotalPages = (NaturalSize / FinalSize);

			//
			//   Nasty, we have run out of stack space.  If
			//   we can not grow this table then the heap
			//   will not be able to expand any further.
			//
			if ( TopOfStack >= MaxStack )
				{
				//
				//   Try to grow the stack size.
				//
				ResizeStack();

				//
				//   Update the pointer as the table may
				//   have moved.
				//
				Current = & NewPages[ SizeKey ];
				}

			//
			//   We may find ourseleves in a situation where
			//   the size of the new 'PAGE' structure is larger
			//   than the natural allocation size or the stack
			//   is full so we can't create new pages.  If so we
			//   refuse to create any new pages so any allocation
			//   requests for this size will fail.
			//
			if ( (TotalPages > 0) && (TopOfStack < MaxStack) )
				{
				REGISTER CHAR *NewMemory = 
					((CHAR*) VerifyNewArea( (NaturalSize-1),NaturalSize ));

				//
				//   We may also find ourselves unable to 
				//   anymore memory.  If so we will fail the
				//   request to create a page.
				//
				if ( NewMemory != AllocationFailure )
					{
					REGISTER SBIT32 Count;

					//
					//   Add the new allocation to stack of
					//   outstanding external allocations.
					//
					Stack[ (TopOfStack ++) ] = ((VOID*) NewMemory);

					//
					//   Add the new elements to the free list
					//   for the current allocation size.
					//
					for 
							( 
							Count=0;
							Count < TotalPages;
							Count ++, (NewMemory += FinalSize)
							)
						{
						REGISTER PAGE *Page = ((PAGE*) NewMemory);

						//
						//   The page has been allocated but not 
						//   initialized so call the constructor
						//   and the destructor to get it into
						//   a sane state.
						//
						PLACEMENT_NEW( NewPage,PAGE ) 
							(
							NULL,
							NULL,
							0,
							NULL,
							0
							);

						PLACEMENT_DELETE( Page,PAGE );

						//
						//   Finally add the page to the free list
						//   so it can be used.
						//
						Page -> InsertInNewPageList( & Current -> FreeList ); 
						}
					}
				}
			}

		//
		//   We are now ready to create a new allocation
		//   page.  We start by requesting a page from
		//   the parent bucket.  If this works we know that 
		//   we have almost everthing we need to create the 
		//   new page.
		//
		if ( ! Current -> FreeList.EndOfList() )
			{
			REGISTER VOID *NewMemory;
			REGISTER CACHE *ParentPage = (Cache -> GetParentCache());

			NewPage = (PAGE::FirstInNewPageList( & Current -> FreeList ));

			//
			//   We have found a suitable page structure
			//   so remove it from the free list.
			//
			NewPage -> DeleteFromNewPageList( & Current -> FreeList );

			//
			//   Release any lock we might have as another
			//   thread may be waiting to delete a page and
			//   be holding the lock we need in order to
			//   create a page.
			//
			ReleaseNewPageLock();

			//
			//   We need to allocate memory to store the users 
			//   data.  After all we are the memory allocator
			//   and that is our job in life.  Typically, we do
			//   this by making a recursive internal request
			//   from a larger bucket.  Nonetheless, at some point
			//   we will reach the 'TopCache' and will be forced
			//   to request memory from an external source.
			//
			if ( (Cache -> TopCache()) || (NewSize != NoSize) )
				{
				REGISTER AlignMask = (TopCache -> GetPageSize()-1);

				//
				//   We allocate memory externally in large blocks 
				//   and sub-divide these allocations into smaller
				//   blocks.  The only exception is if the caller 
				//   caller is requesting some weird size in which
				//   case we request memory directly from the
				//   external allocator (usually the OS).
				//
				if ( NewSize == NoSize )
					{ NewSize = (Cache -> GetPageSize()); }

				//
				//   All externally allocated memory belongs
				//   to the global root.  Thus, it will be 
				//   found in the first lookup in the find
				//   table.
				//
				ParentPage = ((CACHE*) GlobalRoot);

				//
				//   Allocate from the external allocator.
				//
				NewMemory = (VerifyNewArea( AlignMask,NewSize ));
				}
			else
				{
				//
				//   Allocate memory from a larger cache and then
				//   sub-divide it as needed.
				//
				NewMemory = 
					(Cache -> GetParentCache() -> CreateDataPage()); 
				}

			//
			//   Reclaim any lock we have had earlier so 
			//   we can update the the new page structure.
			//
			ClaimNewPageLock();

			//
			//   Lets make sure we sucessfully allocated the
			//   memory for the data page.
			//
			if ( NewMemory != AllocationFailure )
				{
				//
				//   We now have everything we need so lets
				//   create a new page.
				//
				PLACEMENT_NEW( NewPage,PAGE ) 
					(
					NewMemory,
					Cache,
					NewSize,
					ParentPage,
					(Version += 2)
					);

				//
				//   Finally lets add the new page to the various
				//   lists so we can quickly find it again later.
				//
				Cache -> InsertInBucketList( NewPage );

				Cache -> InsertInFindList( NewPage );

				NewPage -> InsertInNewPageList
					(
					(Cache -> TopCache())
						? & Current -> ExternalList 
						: & Current -> FullList 
					); 
				}
			else
				{
				//
				//   We were unable to allocate any data space
				//   for this new page so lets free the page 
				//   description and exit.
				//
				NewPage -> InsertInNewPageList( & Current -> FreeList );

				NewPage = ((PAGE*) AllocationFailure);
				}
			}

		//
		//   We have finished so release the lock now. 
		//
		ReleaseNewPageLock();
#ifdef DEBUGGING
		}
	else
		{ Failure( "The page size key is out of range" ); }
#endif

	return NewPage;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete all allocations.                                        */
    /*                                                                  */
    /*   Delete an entire heap and return all the memory to the         */
    /*   top level pool or the external allocator (usually the OS).     */
    /*                                                                  */
    /********************************************************************/

VOID NEW_PAGE::DeleteAll( BOOLEAN Recycle )
    {
	REGISTER SBIT32 Count;

	//
	//   Claim the global lock so that the various  
	//   lists can be updated.
	//
	ClaimNewPageLock();

	//
	//   We assume at this point that we have blocked
	//   all memory allocation and dealloction requests.
	//   We are now going to walk through the various lists
	//   and just blow away things.  We are going to
	//   do this in a tidy way just in case the caller
	//   wants to use the heap again later.
	//
	for ( Count=0;Count < MaxNewPages;Count ++ )
		{
		REGISTER NEW_PAGES *Current = & NewPages[ Count ];
		REGISTER PAGE *Page;
		REGISTER PAGE *NextPage;

		//
		//   All allocations that appear in the full list
		//   have been sub-allocated from larger pages in
		//   almost all cases.
		//
		for
				(
				Page = (PAGE::FirstInNewPageList( & Current -> FullList ));
				! Page -> EndOfNewPageList();
				Page = NextPage
				)
			{
			REGISTER VOID *Address = (Page -> GetAddress());
			REGISTER CACHE *Cache = (Page -> GetCache());
			REGISTER SBIT32 PageSize = (Page -> GetPageSize());

			//
			//   We decide here how we will deal with the page.
			//   If it is empty, non-standard or we are not
			//   recycling we will blow it away.  If not we
			//   simply reset it for later use.
			//
			if ( (Page -> Empty()) || (PageSize != NoSize) || (! Recycle) )
				{
				//
				//   We need to release any associated data page.
				//   If this is the top level then release the
				//   memory back to the external allocator.  If 
				//   not we release it back to the parent bucket.
				//
				if ( PageSize == NoSize )
					{
					//
					//   If we are just recycling then we cleanly
					//   delete the page.  If not then we know it
					//   will be blown away later so why bother.
					//
					if ( Recycle )
						{
						REGISTER CACHE *ParentCache = 
							(Cache -> GetParentCache());

						if ( ! (ParentCache -> DeleteDataPage( Address )) )
							{ Failure( "Reset data page in DeleteAll" ); }
						}
					}
				else
					{ Rockall -> DeleteArea( Address,PageSize,True ); }

				//
				//   We may have been blowing away pages  
				//   randomly and now we are about to destroy 
				//   the current page.  So lets figure out 
				//   what page comes next before we continue.
				//
				NextPage = (Page -> NextInNewPageList());

				//
				//   If the page is not full it will in a 
				//   bucket list somewhere.  We need to remove
				//   it as we are about to delete the page.
				//
				if ( ! Page -> Full() )
					{ Cache -> DeleteFromBucketList( Page ); }

				//
				//   Delete the page from the find list and the
				//   new page list.
				//
				Cache -> DeleteFromFindList( Page );

				Page -> DeleteFromNewPageList( & Current -> FullList );

				//
				//   Delete the page structure.
				//
				PLACEMENT_DELETE( Page,PAGE );

				//
				//   Finally add the page to the free list
				//   so it can be recycled.
				//
				Page -> InsertInNewPageList( & Current -> FreeList );
				}
			else
				{
				//
				//   We know that the current page has at 
				//   least one allocation on it so instead
				//   of deleting it we will mark it as free
				//   (except for any sub-allocations) and
				//   leave it around for next time.  If it
				//   is never used the next top level 
				//   'DeleteAll' will delete it.
				//
				Page -> DeleteAll();

				//
				//   We have now reset the current page so  
				//   lets figure out what page comes next.
				//
				NextPage = (Page -> NextInNewPageList());
				}
			}

		//
		//   We have a choice to make.  If we intend to
		//   use this heap again we keep all top level
		//   allocated memory in a list ready for reuse.
		//   If not we return it to the external allocator
		//   (usually the OS).
		//   
		if ( ! Recycle )
			{
			//
			//   The external allocations list contains an
			//   entry for every externally allocated page
			//   except those allocated for special internal 
			//   use within this class or for weird sized
			//   pages that appeared above in the 'FullList'.
			//
			for
					(
					Page = (PAGE::FirstInNewPageList( & Current -> ExternalList ));
					! Page -> EndOfNewPageList();
					Page = (PAGE::FirstInNewPageList( & Current -> ExternalList ))
					)
				{
				REGISTER VOID *Address = (Page -> GetAddress());
				REGISTER CACHE *Cache = (Page -> GetCache());
				REGISTER SBIT32 PageSize = (Page -> GetPageSize());

				//
				//   We no longer need this top level allocation
				//   so return it to the external allocator.
				//
				Rockall -> DeleteArea( Address,PageSize,True );

				//
				//   If the page is not full it will in a 
				//   bucket list somewhere.  We need to remove
				//   it as we are about to delete the page.
				//
				if ( ! Page -> Full() )
					{ Cache -> DeleteFromBucketList( Page ); }

				//
				//   Delete the page from the find list and the
				//   new page list.
				//
				Cache -> DeleteFromFindList( Page );

				Page -> DeleteFromNewPageList( & Current -> ExternalList );

				//
				//   Delete the page structure.
				//
				PLACEMENT_DELETE( Page,PAGE );

				//
				//   Finally add the page to the free list
				//   so it can be recycled.
				//
				Page -> InsertInNewPageList( & Current -> FreeList );
				}
			}
		}

	//
	//   We have finished so release the lock now. 
	//
	ReleaseNewPageLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Delete a page.                                                 */
    /*                                                                  */
    /*   Delete a page structure, free the associated memory and        */
    /*   unlink it from the various allocation lists.                   */
    /*                                                                  */
    /********************************************************************/

VOID NEW_PAGE::DeletePage( PAGE *Page )
    {
	REGISTER CACHE *Cache = Page -> GetCache();
	REGISTER SBIT16 SizeKey = Cache -> GetSizeKey();

	//
	//   All allocations are made from fixed sized
	//   pages.  These pages have a bit vector to
	//   keep track of which elements are allocated
	//   and available.  The 'SizeKey' is an index
	//   into 'NewPages[]' that will supply a page
	//   that has a big enough the bit vector.
	//
#ifdef DEBUGGING
	if ( (SizeKey >= 0) && (SizeKey < MaxNewPages) )
		{
#endif
		REGISTER VOID *Address = (Page -> GetAddress());
		REGISTER NEW_PAGES *Current = & NewPages[ SizeKey ];
		REGISTER SBIT32 Size = (Page -> GetPageSize());

		//
		//   We need to release any associated data page.
		//   If this is the top level then release the
		//   memory back to the external allocator.  If 
		//   not we release it back to the parent bucket.
		//
		if ( Size == NoSize )
			{ 
			REGISTER CACHE *ParentCache = (Cache -> GetParentCache());

			if ( ! (ParentCache -> DeleteDataPage( Address )) )
				{ Failure( "Deleting data page in DeletePage" ); }
			}
		else
			{ Rockall -> DeleteArea( Address,Size,True ); }

		//
		//   Claim the global lock so that the various  
		//   lists can be updated.
		//
		ClaimNewPageLock();

		//
		//   Remove the page from the lists and delete it.
		//
		Cache -> DeleteFromBucketList( Page );

		Cache -> DeleteFromFindList( Page );

		Page -> DeleteFromNewPageList
			(
			(Cache -> TopCache())
				? & Current -> ExternalList 
				: & Current -> FullList 
			); 

		PLACEMENT_DELETE( Page,PAGE );

		//
		//   Finally add the page to the free list
		//   so it can be recycled.
		//
		Page -> InsertInNewPageList( & Current -> FreeList );

		//
		//   We have finsihed so release the lock.
		//
		ReleaseNewPageLock();
#ifdef DEBUGGING
		}
	else
		{ Failure( "The page size key out of range in DeletePage" ); }
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Find the correct index in new page.                            */
    /*                                                                  */
    /*   When we come to create a new page we need to make sure the     */
    /*   bit vector is large enough for the page.  We calculate this    */
	/*   here just once to save time later.                             */
    /*                                                                  */
    /********************************************************************/

SBIT16 NEW_PAGE::FindSizeKey( SBIT16 NumberOfElements )
    {
	REGISTER SBIT32 Count;

	//
	//   Search the table of page structures looking for 
	//   elements of a suitable size.  As the table is
	//   known to be in order of increasing size we can
	//   terminate the search as soon as we find something 
	//   large enough.
	//
	for ( Count=0;Count < MaxNewPages;Count ++ )
		{
		REGISTER NEW_PAGES *Current = & NewPages[ Count ];

		if ( NumberOfElements <= Current -> Elements )
			{ return ((SBIT16) Count); }
		}

	//
	//   Nasty, we don't seem to have anything large enough
	//   to store the bit vector.
	//
	return NoSizeKey;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Create a new cache stack.                                      */
    /*                                                                  */
    /*   A cache stack is an array that contains memory allocations     */
    /*   that are waiting to be allocated or released.                  */
    /*                                                                  */
    /********************************************************************/

VOID *NEW_PAGE::NewCacheStack( SBIT32 Size )
    {
	REGISTER VOID *NewStack;

	//
	//   Claim the global lock so that the various  
	//   lists can be updated.
	//
	ClaimNewPageLock();

	//
	//   We ensure that there is enough space to make the
	//   allocation.  If not we request additional space
	//   and prepare it for use.
	//
	if ( (CacheStack == NULL) || ((MaxCacheStack + Size) > NaturalSize) )
		{
		//
		//   Nasty, we have run out of stack space.  If
		//   we can not grow this table then the heap
		//   will not be able to expand any further.
		//
		if ( TopOfStack >= MaxStack )
			{
			//
			//   Try to grow the stack size.
			//
			ResizeStack();
			}

		//
		//   We may find ourseleves in a situation where
		//   the size of the new stack structure is larger
		//   than the natural allocation size or the stack
		//   is full so we can't create new pages.  If so we
		//   refuse to create any new stacks.
		//
		if ( (Size < NaturalSize) && (TopOfStack < MaxStack) )
			{
			REGISTER CHAR *NewMemory = 
				((CHAR*) VerifyNewArea( (NaturalSize-1),NaturalSize ));

			//
			//   We may also find ourselves unable to 
			//   anymore memory.  If so we will fail the
			//   request to create a new cache stack.
			//
			if ( NewMemory != AllocationFailure )
				{
				//
				//   Add the new allocation to stack of
				//   outstanding external allocations.
				//
				Stack[ (TopOfStack ++) ] = ((VOID*) NewMemory);

				//
				//   Prepare the new memory block for use.
				//   
				CacheStack = NewMemory;
				MaxCacheStack = 0;
				}
			else
				{ return NULL; }
			}
		else
			{ return NULL; }
		}

	//
	//   We allocate some space for the new cache 
	//   stack and update and align the high water
	//   mark of the space used.
	//
	NewStack = ((VOID*) & CacheStack[ MaxCacheStack ]);

	MaxCacheStack += (Size + CacheLineMask);
	MaxCacheStack &= ~CacheLineMask;

	//
	//   We have finished so release the lock now. 
	//
	ReleaseNewPageLock();

	return NewStack;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Resize the new page stack.                                     */
    /*                                                                  */
    /*   The new page stack holds pointers to all the pages owned       */
    /*   by the heap.  If this stack become full we must expand it      */
	/*   otherwise we can no longer grow the heap.                      */
    /*                                                                  */
    /********************************************************************/

VOID NEW_PAGE::ResizeStack( VOID )
    {
	REGISTER SBIT32 NewSize = 
		(((RootStackSize <= 0) ? NaturalSize : RootStackSize) * 2);

	//
	//   Lets just check that we have really run out
	//   of stack space as expanding it really hurts.
	//
	if ( TopOfStack >= MaxStack )
		{
		REGISTER VOID *NewMemory = 
			(
			Rockall -> NewArea
				( 
				(NaturalSize-1),
				NewSize,
				False
				)
			);

		//
		//   We need to verify that we were able to allocate
		//   fresh memory for the stack.
		//
		if ( NewMemory != NULL )
			{
			REGISTER BOOLEAN DeleteStack = (RootStackSize > 0);
			REGISTER VOID *OriginalMemory = ((VOID*) Stack);
			REGISTER SBIT32 OriginalSize = (MaxStack * sizeof(VOID*));

			//
			//   All is well as we were able to allocate 
			//   additional space for the stack.  All we 
			//   need to do now is to update the control 
			//   information.
			//
			MaxStack = (NewSize / sizeof(VOID*));

			RootStackSize = NewSize;

			Stack = ((VOID**) NewMemory);

			//
			//   Now lets copy across the existing data. 
			//
			memcpy( NewMemory,OriginalMemory,OriginalSize );

			//
			//   When the heap is created we put the
			//   stack on the root core page.  Later
			//   we may move it if we expand it.  If
			//   this is the case we have to delete  
			//   the previous expansion here.
			//
			if ( DeleteStack )
				{
				//
				//   Deallocate the existing stack if it
				//   is not on the root core page.
				//
				Rockall -> DeleteArea( OriginalMemory,OriginalSize,False );
				}
			}
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Verify an external allocation.                                 */
    /*                                                                  */
    /*   All memory requests are allocated from the external allocator  */
	/*   at the highest level.  Here we have a wrapper for this         */
    /*   function so we can test the result and make sure it is sane.   */
    /*                                                                  */
    /********************************************************************/

VOID *NEW_PAGE::VerifyNewArea( SBIT32 AlignMask,SBIT32 Size )
	{
#ifdef DEBUGGING
	//
	//   We need to ensure that the alignment of the new
	//   external allocation is a power of two.
	//
	if ( PowerOfTwo( (AlignMask + 1) ) )
		{
#endif
		REGISTER VOID *NewMemory = 
			(Rockall -> NewArea( AlignMask,Size,True ));

		//
		//   We need to ensure that the external allocation
		//   request is sucessful.  If not it makes no sense
		//   to try and check it.
		//
		if ( NewMemory != ((VOID*) AllocationFailure) )
			{
			//
			//   We require the external memory allocator to always
			//   allocate memory on the requested boundary.  If not 
			//   we are forced to reject the supplied memory.
			//
			if ( (((SBIT32) NewMemory) & AlignMask) == 0 )
				{ return NewMemory; }
			else
				{ 
				Rockall -> DeleteArea( NewMemory,Size,True );
				
				Failure( "Alignment of allocation in VerifyNewArea" );
				}
			}
#ifdef DEBUGGING
		}
	else
		{ Failure( "Alignment is not a power of two in VerifyNewArea" ); }
#endif

	return ((VOID*) AllocationFailure);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Walk the heap.                                                 */
    /*                                                                  */
    /*   We have been asked to walk the heap.  It is hard to know       */
    /*   why anybody might want to do this given the rest of the        */
    /*   functionality available.  Nonetheless, we just do what is      */
    /*   required to keep everyone happy.                               */
    /*                                                                  */
    /********************************************************************/

BOOLEAN NEW_PAGE::Walk( SEARCH_PAGE *Details )
    {
	//
	//   Claim the global lock so that the various  
	//   lists can be updated.
	//
	ClaimNewPageLock();

	//
	//   We examine the current address to see if it
	//   is null.  If so then this is the start of a
	//   heap walk so we need to set it up.
	//
	if ( Details -> Address == NULL )
		{
		REGISTER SBIT32 Count;

		//
		//   Walk through the list of different sized
		//   page descriptions.
		//
		for ( Count=0;Count < MaxNewPages;Count ++ )
			{
			REGISTER NEW_PAGES *Current = & NewPages[ Count ];

			//
			//   Compute a pointer to the first element
			//   of the current size.
			//
			Details -> Page = 
				(PAGE::FirstInNewPageList( & Current -> FullList ));

			//
			//   Examine the current list of full (or 
			//   partially full) pages.  If there is at  
			//   least one page then this is the starting 
			//   point for the heap walk.
			//
			if ( ! Details -> Page -> EndOfNewPageList() )
				{
				//
				//   Compute the starting address of the 
				//   heap walk.
				//
				Details -> Address = 
					(Details -> Page -> GetAddress());

				break;
				}
			}
		}
	else
		{
		REGISTER PAGE *LastPage = Details -> Page;

		//
		//   We have exhusted the current page so walk
		//   the list and find the next page.
		//
		Details -> Page = 
			(Details -> Page -> NextInNewPageList());

		//
		//   We need to ensure that we have not reached
		//   the end of the current list.
		//
		if ( Details -> Page -> EndOfNewPageList() )
			{
			REGISTER SBIT32 Count;
			REGISTER BOOLEAN Found = False;

			//
			//   We need to find a new page description
			//   list to walk so reset the current 
			//   address just in case we don't find 
			//   anything.
			//
			Details -> Address = NULL;

			//
			//   We have reached the end of the current
			//   list and we need to continue with the
			//   start of the next list.  However, we
			//   don't know which list we were using
			//   previously.  So first we identify the
			//   previous list and then select the next
			//   avaibale list.
			//
			for ( Count=0;Count < MaxNewPages;Count ++ )
				{
				REGISTER NEW_PAGES *Current = & NewPages[ Count ];

				//
				//   We search for the original list
				//   we were walking.
				//
				if ( ! Found )
					{
					//
					//   When we find the original list
					//   then we set a flag showing that
					//   the next available list is the
					//   target.
					//
					if 
							( 
							LastPage 
								== 
							(PAGE::LastInNewPageList( & Current -> FullList )) 
							)
						{ Found = True; }
					}
				else
					{
					//
					//   We have found the previous list
					//   so the first element of the next
					//   list seems a good place to continue.
					//
					Details -> Page = 
						(PAGE::FirstInNewPageList( & Current -> FullList ));

					//
					//   We check to make sure that the list
					//   has at least one active page.  If not
					//   it is worthless and we continue looking
					//   for a suitable list.
					//
					if ( ! Details -> Page -> EndOfNewPageList() )
						{
						//
						//   Compute the starting address for 
						//   the next page in the heap walk.
						//
						Details -> Address = 
							(Details -> Page -> GetAddress());

						break;
						}
					}
				}
			}
		else
			{ 
			//
			//   Compute the starting address for 
			//   the next page in the heap walk.
			//
			Details -> Address = 
				(Details -> Page -> GetAddress());
			}
		}

	//
	//   If we find a new heap page to walk we update
	//   the details.  We mark some entry's as exhusted
    //   so as to provoke other code to set them up.
	//
	if ( Details -> Address != NULL )
		{
		//
		//   Compute the new allocation details.
		//
		Details -> Page -> FindPage
			( 
			Details -> Address,
			Details,
			False 
			);
		}

	//
	//   We have finished so release the lock now. 
	//
	ReleaseNewPageLock();

	return (Details -> Address != NULL);
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory all the page structures and release any allocated      */
    /*   memory.                                                        */
    /*                                                                  */
    /********************************************************************/

NEW_PAGE::~NEW_PAGE( VOID )
    {
	REGISTER SBIT32 Count;

	//
	//   Delete all active allocations.
	//
	DeleteAll( False );

	//
	//   We are about to delete all of the memory 
	//   allocated by this class so destroy any
	//   internal pointers.
	//
	MaxCacheStack = 0;
	CacheStack = NULL;

	//
	//   We have now deleted all the memory allocated by
	//   this heap except for the memory  allocated directly 
	//   by this class.  Here we finish off the job by 
	//   deleting these allocations and reseting the internal 
	//   data structures.
	//
	for ( Count=0;Count < TopOfStack;Count ++ )
		{
		REGISTER VOID *Current = Stack[ Count ];

		Rockall -> DeleteArea( Current,NaturalSize,False );
		}

	TopOfStack = 0;

	//
	//   If we were forced to expand the root stack then
	//   release this additional memory now.
	//
	if ( RootStackSize > 0 )
		{
		//
		//   Deallocate root stack which previously 
		//   contained pointers to all the memory
		//   allocated by this class.
		//
		Rockall -> DeleteArea( ((VOID*) Stack),RootStackSize,False );
		}

	//
	//   Delete all the new page list headings just
	//   to be neat
	//
	for ( Count=0;Count < MaxNewPages;Count ++ )
		{
		REGISTER NEW_PAGES *Current = & NewPages[ Count ];

		PLACEMENT_DELETE( & Current -> ExternalList,LIST );
		PLACEMENT_DELETE( & Current -> FullList,LIST );
		PLACEMENT_DELETE( & Current -> FreeList,LIST );
		}

	//
	//   Deallocate root core page which previously 
	//   contained all the new page lists.
	//
	Rockall -> DeleteArea( ((VOID*) NewPages),RootCoreSize,False );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\heap\newpagelist.hpp ===
#ifndef _NEW_PAGE_LIST_HPP_
#define _NEW_PAGE_LIST_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "FindList.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   The new page list.                                             */
    /*                                                                  */
    /*   The new page list links all the memory allocated by the low    */
    /*   level external allocator, or sub-divided pages or free pages   */
    /*   so they can be quickly found.                                  */
    /*                                                                  */
    /********************************************************************/

class NEW_PAGE_LIST : public FIND_LIST
    {
		//
		//   Private data.
		//
 		LIST						  NewPageList;

   public:
		//
		//   Public inline functions.
		//
		//   All page descriptions contain three linked lists.
		//   These lists are all derived from a common base
		//   class.  However, this class is unable to support
		//   multiple instances in a single class a wrapper
		//   has been created for each list to make it work
		//   as required.
		//
        NEW_PAGE_LIST( VOID )
			{ /* void */ };

		INLINE VOID DeleteFromNewPageList( LIST *HeadOfList )
			{ NewPageList.Delete( HeadOfList ); }

		INLINE BOOLEAN EndOfNewPageList( VOID )
			{ return (this == NULL); }

		STATIC INLINE PAGE *FirstInNewPageList( LIST *HeadOfList )
			{ return ComputePageAddress( ((CHAR*) HeadOfList -> First()) ); }

		INLINE VOID InsertInNewPageList( LIST *HeadOfList )
			{ NewPageList.Insert( HeadOfList ); }

		STATIC INLINE PAGE *LastInNewPageList( LIST *HeadOfList )
			{ return ComputePageAddress( ((CHAR*) HeadOfList -> Last()) ); }

		INLINE PAGE *NextInNewPageList( VOID )
			{ return ComputePageAddress( ((CHAR*) NewPageList.Next()) ); }

        ~NEW_PAGE_LIST( VOID )
			{ /* void */ };

	private:
		//
		//   Private functions.
		//
		//   Compute the actual start address of the page
		//   and return it to allow the linked list to
		//   be correctly walked.
		//
		STATIC INLINE PAGE *ComputePageAddress( CHAR *Address )
			{
			if ( Address != NULL )
				{ return ((PAGE*) (Address - sizeof(FIND_LIST))); }
			else
				{ return ((PAGE*) NULL); }
			}

        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        NEW_PAGE_LIST( CONST NEW_PAGE_LIST & Copy );

        VOID operator=( CONST NEW_PAGE_LIST & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\heap\newpage.hpp ===
#ifndef _NEW_PAGE_HPP_
#define _NEW_PAGE_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Environment.hpp"
#include "Common.hpp"
#include "Find.hpp"
#include "Page.hpp"
#include "Rockall.hpp"
#include "Spinlock.hpp"
 
    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The constants supplied here relate to various failure          */
    /*   conditions or situations where information is unknown.         */
    /*                                                                  */
    /********************************************************************/

CONST SBIT16 NoSizeKey				  = -1;

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class CACHE;

    /********************************************************************/
    /*                                                                  */
    /*   Create and delete pages.                                       */
    /*                                                                  */
    /*   We would normally expect a class to manage its own memory.     */
    /*   However, this is quite difficult for the 'PAGE' class as it    */
    /*   is also responsible for managing the memory for the memory     */
    /*   allocator.  So here we remove a potentially nasty chore        */
    /*   and isolate it in a class of its own.                          */
    /*                                                                  */
    /********************************************************************/

class NEW_PAGE : public ENVIRONMENT, public COMMON
    {
		//
		//   Private structures.
		//
		//   All the pages descriptions created by this
		//   class and managed by the memory allocator
		//   are linked in three list.  One of these lists
		//   is managed by this class and is called the
		//   'NewPageList'.  All pages are linked into 
		//   of three sub-lists.  The 'ExternalList' is
		//   a list of pages externally allocated pages.
		//   The 'FullList' is a list of sub-allocated
		//   space from the 'ExternalList' which is 
		//   partially or completely filled with alocations.
		//   Finally, the 'FreeList' is a collection of
		//   empty page descriptions all of the same size.
		//   
		//
		typedef struct
			{
			SBIT32                    Elements;
			LIST					  ExternalList;
			LIST					  FreeList;
			LIST					  FullList;
			SBIT32                    Size;
			}
		NEW_PAGES;
		
		//
		//   Private data.
		//
		//   We manage a collection of data structures in
		//   this class.  The fundamental data structure
		//   is a stack of externally allocated pages that
		//   typically contain page descriptions that are
		//   linked together into linked lists.  The maximum
		//   size of this stack is given by 'MaxStack'. 
		//   A few additional pages are consumed to allocate
		//   stacks for caches in other classes.
		//
		SBIT32						  MaxCacheStack;
		SBIT32						  MaxNewPages;
		SBIT32						  MaxStack;

		//
		//   We keep track of various values to save having
		//   to recompute them.  The 'NaturalSize' is the 
		//   natural allocation size of our host (i.e. the OS).
		//   The 'RootSize' is some multiple of the 
		//   'NaturalSize' that this class uses to consume 
		//   memory.  The 'ThreadSafe' flag indicates whether
		//   we need to use locks.  The "TopOfStack' is the
		//   stack which contains pointers to the externally
		//   allocated space.  The 'Version' is the global
		//   version number that is used to stamp each page
		//   whenever it is allocated or deallocated.  The
		//   version number allows the code to ensure that
		//   a page description has not been changed while
		//   it was not holding the associated lock.
		//   
		SBIT32						  NaturalSize;
		SBIT32						  RootCoreSize;
		SBIT32						  RootStackSize;
		BOOLEAN						  ThreadSafe;
		SBIT32						  TopOfStack;
		SBIT32						  Version;

		//
		//   We keep pointers to all the interesting data
		//   structures we may need to update.  The
		//   'CacheStack' points to block of memory that
		//   is being sliced into small stacks for caches
		//   in other classes.  The 'NewPages' points to
		//   an array of linked lists of page descriptions.
		//   Each collection of page descriptions is 
		//   identical except for the size of the assocated
		//   bit vector.
		//
		CHAR						  *CacheStack;
 		NEW_PAGES					  *NewPages;
		VOID                          **Stack;

		//
		//   We sometimes need to interact with some of
		//   the other class.  The 'Find" class is a hash
		//   table of all the currently allocated pages.
		//   The 'Rockall' class contains the external
		//   API which includes the external memory memory
		//   allocation functions.  The 'TopCache' is the
		//   largest cache we support and contains details
		//   about top level allocations sizes.
		//
		FIND						  *Find;
		ROCKALL						  *Rockall;
		CACHE						  *TopCache;

		SPINLOCK                      Spinlock;

   public:
		//
		//   Public functions.
		//
		//   The public functions provide support for creating
		//   new page descriptions and caches for other 
		//   classes.  Although a lot of the fuinctionality
		//   of the heap is masked from this class various
		//   features such as deleting the entire heap
		//   (i.e. 'DeleteAll') are still visable.
		//
        NEW_PAGE
			(
			FIND					  *NewFind,
			SBIT32					  NewPageSizes[],
			ROCKALL					  *NewRockall,
			SBIT32					  Size,
			BOOLEAN					  NewThreadSafe 
			);

		PAGE *CreatePage( CACHE *Cache,SBIT32 NewSize = NoSize );

		VOID DeleteAll( BOOLEAN Recycle );

		VOID DeletePage( PAGE *Page );

		SBIT16 FindSizeKey( SBIT16 NumberOfElements );

		VOID *NewCacheStack( SBIT32 Size  );

		VOID ResizeStack( VOID );

		BOOLEAN Walk( SEARCH_PAGE *Details );

        ~NEW_PAGE( VOID );

		//
		//   Public inline functions.
		//
		//   The public inline functions are typically either
		//   small or highly performance sensitive.  The
		//   functions here mainly relate to locking and
		//   updating various data structures.
		//
		INLINE VOID ClaimNewPageLock( VOID )
			{
			if ( (ThreadSafe) && (Find -> GetLockCount() == 0) )
				{ Spinlock.ClaimLock(); } 
			}

		INLINE VOID ReleaseNewPageLock( VOID )
			{
			if ( (ThreadSafe) && (Find -> GetLockCount() == 0) )
				{ Spinlock.ReleaseLock(); } 
			}

		INLINE VOID UpdateNewPage( CACHE *NewTopCache )
			{ TopCache = NewTopCache; }

	private:
		//
		//   Private functions.
		//
		//   We support the overloading of the external
		//   memory allocation routines.  This is somewhat
		//   unusual and means that we need to Verify
		//   that these functions do not supply us with
		//   total rubbish.
		//
		VOID *VerifyNewArea( SBIT32 AlignMask,SBIT32 Size );

        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        NEW_PAGE( CONST NEW_PAGE & Copy );

        VOID operator=( CONST NEW_PAGE & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\heap\page.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "HeapPCH.hpp"

#include "Cache.hpp"
#include "Heap.hpp"
#include "NewPage.hpp"
#include "Page.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here allow the allocation bit vector    */
    /*   to be rapidly searched for free storage.                       */
    /*                                                                  */
    /********************************************************************/

CONST BIT32 AllocatedMask			  = 0x2;
CONST BIT32 FullSearchMask			  = 0xaaaaaaaa;
CONST BIT32 FullWordShift			  = (MaxBitsPerWord - OverheadBits);
CONST BIT32 SubDividedMask			  = 0x1;
CONST BIT32 WordSearchMask			  = (AllocatedMask << FullWordShift);

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*                                                                  */
    /*   All page descriptions are actually created and deleted by      */
    /*   a separate class called 'NEW_PAGE'.  Nonetheless, as a         */
    /*   step the appropriate constructors and destructors are          */
    /*   invoked to support the standard C++ programming methodology.   */
    /*                                                                  */
    /********************************************************************/

PAGE::PAGE
		( 
		VOID						  *NewAddress,
		CACHE						  *NewCache,
		SBIT32						  NewPageSize, 
		CACHE						  *NewParentPage,
		SBIT32						  NewVersion 
		)
	{
	REGISTER SBIT32 Count;
	REGISTER SBIT16 NumberOfElements = (NewCache -> GetNumberOfElements());
	REGISTER SBIT16 SizeOfElements = (NewCache -> GetSizeOfElements());

	//
	//   Create a page description.
	//
	Address = (CHAR*) NewAddress;
	PageSize = NewPageSize;
	Version = NewVersion;

	Allocated = 0;
	Available = NumberOfElements;
	FirstFree = 0;

	//
	//   Set up the pointers to related classes.
	//
	Cache = NewCache;
	ParentPage = NewParentPage;

	//
	//   Zero the bit vector.
	//
	for ( Count=0;Count < SizeOfElements;Count ++ )
		{ Vector[ Count ] = 0; }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Compute the actual size.                                       */
    /*                                                                  */
    /*   Almost all allocation sizes are derived from the associated    */
    /*   caches.  However, there are a few special pages that contain   */
    /*   a single allocation of some weird size.                        */
    /*                                                                  */
    /********************************************************************/

SBIT32 PAGE::ActualSize( VOID )
	{
	return
		(
		(ParentPage == ((CACHE*) GlobalRoot))
			? PageSize
			: (Cache -> GetAllocationSize())
		);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete an allocation.                                          */
    /*                                                                  */
    /*   We need to delete the memory allocation described by the       */
    /*   parameters.  However, as we are of an untrusting nature        */
    /*   we carefully check the request to ensure it is valid.          */
    /*                                                                  */
    /********************************************************************/

BOOLEAN PAGE::Delete( SEARCH_PAGE *Details )
    {
	//
	//   We know that no one would deallocate memory
	//   they had not previously allocated (yea - right).
	//   So here we check for this case.
	//
	if ( (*Details -> VectorWord) & Details -> AllocationMask )
		{
		//
		//   Nasty: it is possible for the user to give us an
		//   address that points to the middle of the element
		//   to be freed instead of the beginning.  This is no
		//   problem for us but we have to ponder whether the
		//   caller knew what they were doing.  If this is the 
		//   case we fail the request.
		//
		if ( Details -> Found )
			{
			//
			//   We have found that the element is allocated
			//   (as one might expect) so lets deallocate it 
			//   and update the various counters.
			//
			(*Details -> VectorWord) &= 
				~(Details -> AllocationMask | Details ->SubDivisionMask);

			//
			//   We may need to push back the pointer to the 
			//   first free element.  This will ensure that
			//   we can quickly locate the freed element for  
			//   later so we can reuse it.
			//
			if ( FirstFree > Details -> VectorOffset )
				{ FirstFree = ((SBIT16) Details -> VectorOffset); }

			//
			//   If the page was full and now has an empty
			//   slot then add it to the bucket list so that
			//   the free space can be found.
			//
			if ( Full() )
				{ Cache -> InsertInBucketList( this ); }

			//
			//   Update the allocation information.
			//
			Allocated --;
			Available ++;

			//
			//   If the page is now empty then delete 
			//   the page to conserve space.
			//
			if ( Empty() ) 
				{
				//
				//   We immediately delete empty pages
				//   except at the top level where it is
				//   under user control.
				//
				if ( ! Cache -> TopCache() )
					{ Cache -> DeletePage( this ); }
				else
					{
					REGISTER SBIT32 MaxFreePages = 
						(Cache -> GetHeap() -> GetMaxFreePages());

					((BUCKET*) Cache) -> ReleaseSpace( MaxFreePages );
					}
				}

			return True;
			}
		}

	return False;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Delete all simple allocations.                                 */
    /*                                                                  */
    /*   Although this routine may seem insignificant its effects are   */
    /*   dramatic.  When called this function deletes all the none      */
    /*   sub-allocated elements and updates the control values.         */
    /*                                                                  */
    /********************************************************************/

VOID PAGE::DeleteAll( VOID )
    {
	REGISTER BOOLEAN PageFull = Full();

	//
	//   Simply reset the allocation counts.
	//
	Allocated = 0;
	Available = (Cache -> GetNumberOfElements());
	FirstFree = 0;

	//
	//   We know that if this cache does not have any
	//   child allocations that it is safe to simply
	//   zero the bit vector.  If not we have to do it
	//   the long way.
	//
	if ( Cache -> GetNumberOfChildren() > 0 )
		{
		REGISTER SBIT32 Count;
		REGISTER SBIT16 SizeOfElements = (Cache -> GetSizeOfElements());

		//
		//   We examine each word of the bit vector 
		//   and delete all the elements that are
		//   not sub-divided into smaller sizes.
		//
		for ( Count=0;Count < SizeOfElements;Count ++ )
			{
			REGISTER BIT32 *Word = & Vector[ Count ];
			REGISTER BIT32 AllAllocations = ((*Word) & FullSearchMask);
			REGISTER BIT32 AllSubDivided = ((*Word) & (AllAllocations >> 1));
			REGISTER BIT32 FinalMask = (AllSubDivided | (AllSubDivided << 1));

			//
			//   Delete all normal allocations.
			//
			(*Word) &= FinalMask;

			//
			//   If the final mask is not zero then
			//   we still have some allocations active.
			//   We need to count these and update the
			//   control information.
			//
			if ( FinalMask != 0 )
				{
				REGISTER SBIT32 Total = 0;

				//
				//   Count the allocations.
				//
				for ( /* void */;FinalMask != 0;FinalMask >>= OverheadBits )
					{ Total += (FinalMask & 1); }

				//
				//   Update the control information.
				//
				Allocated = ((SBIT16) (Allocated + Total));
				Available = ((SBIT16) (Available - Total));
				}
			}
		}
	else
		{
		REGISTER SBIT32 Count;
		REGISTER SBIT16 SizeOfElements = (Cache -> GetSizeOfElements());

		//
		//   Zero the bit vector.
		//
		for ( Count=0;Count < SizeOfElements;Count ++ )
			{ Vector[ Count ] = 0; }
		}

	//
	//   If the page was full and now has empty
	//   slots then add it to the bucket list so 
	//   that the free space can be found.
	//
	if ( (PageFull) && (! Full()) )
		{ Cache -> InsertInBucketList( this ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Find an allocation page.                                       */
    /*                                                                  */
    /*   When we receive a request to delete an allocation we don't     */
    /*   have a clue about where to find it.  All we have is a hash     */
    /*   table (see 'FIND') of allocated pages.  So we mask off the     */
    /*   low order bits of the address and try to find the top level    */
    /*   external allocation.  If this works we see if the area we      */
    /*   are looking at has been sub-divided and if so we try the       */
    /*   same trick again until we get the the origibal allocation      */
    /*   page.                                                          */
    /*                                                                  */
    /********************************************************************/

PAGE *PAGE::FindPage( VOID *Memory,SEARCH_PAGE *Details,BOOLEAN Recursive )
    {
	//
	//   We navigate through the pages trying to find
	//   the allocation page associated with the address.
	//   If we find a page that has no children then 
	//   we can assume we have arrived and exit early 
	//   unless the caller has requested all the realated 
	//   details.
	//
	if ( (Cache -> GetNumberOfChildren() > 0) || (Details != NULL) )
		{
		AUTO BOOLEAN Found;
		REGISTER SBIT32 Displacement = 
			((SBIT32) (((CHAR*) Memory) - Address));
		REGISTER SBIT32 ArrayOffset = 
			(Cache -> ComputeOffset( Displacement,& Found ));
		REGISTER SBIT32 VectorOffset = 
			(ArrayOffset / OverheadBitsPerWord);
		REGISTER SBIT32 WordOffset = 
			(ArrayOffset - (VectorOffset * OverheadBitsPerWord));
		REGISTER SBIT32 WordShift = 
			(((OverheadBitsPerWord-1) - WordOffset) * OverheadBits);
		REGISTER BIT32 AllocationMask = 
			(AllocatedMask << WordShift);
		REGISTER BIT32 SubDivisionMask = 
			(SubDividedMask << WordShift);
		REGISTER BIT32 *VectorWord = 
			& Vector[ VectorOffset ];

		//
		//  We will recursively search and find the target 
		//  address if requested otherwise we will just 
		//  return the details of the next level in the tree.
		//
		if 
				(
				(Recursive)
					&&
				((*VectorWord) & AllocationMask)
					&&
				((*VectorWord) & SubDivisionMask)
				)
			{
			REGISTER PAGE *Page = (Cache -> FindChildPage( Memory ));

			//
			//   We have found the element and checked it. 
			//   So lets pass this request on to the
			//   child page.  However, there is a slight
			//   chance of a race condition here.  It
			//   might be that the original page was
			//   deleted and a new page is currently
			//   being created.  If this is the case
			//   then we will not find the page in the 
			//   hash table so we just exit and fail the 
			//   call.
			//
			if ( Page != ((PAGE*) NULL) )
				{ return (Page -> FindPage( Memory,Details,Recursive )); }
			else
				{ return NULL; }
			}

		//
		//   We see if the caller is interested in the
		//   details relating to this address at the
		//   current level in the tree.
		//
		if ( Details != NULL )
			{
			//
			//   We have computed the details relating
			//   to this address at the current level
			//   in the tree so load them into the
			//   caller supplied structure.
			//
			Details -> Address = Memory;
			Details -> Cache = Cache;
			Details -> Found = Found;
			Details -> Page = this;

			Details -> AllocationMask = AllocationMask;
			Details -> SubDivisionMask = SubDivisionMask;
			Details -> VectorWord = VectorWord;

			Details -> ArrayOffset = ArrayOffset;
			Details -> VectorOffset = VectorOffset;
			Details -> WordShift = WordShift;
			}
		}

	return this;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory allocations.                                   */
    /*                                                                  */
    /*   Allocate available memeory elements from a page.  This is      */
    /*   done by scanning the bit vector looking for unallocated        */
    /*   slots.                                                         */
    /*                                                                  */
    /********************************************************************/

BOOLEAN PAGE::MultipleNew( SBIT32 *Actual,VOID *Array[],SBIT32 Requested )
    {
	//
	//   We begin by making sure that there is at least
	//   one element to allocate and that we need to
	//   allocated at least one element.
	//
	if ( (! Full()) && ((*Actual) < Requested) )
		{
		REGISTER SBIT16 SizeOfElements = (Cache -> GetSizeOfElements());

		//
		//   Search the bit vector from low addresses to 
		//   high addresses looking for a free slots.
		//   We keep a pointer to the first word with
		//   a free element in 'FirstFree'.  Sometimes
		//   the current word may be fully allocated so 
		//   we might need to scan.  However, there can
		//   never be any free memory before this point 
		//   in the bit vector.
		//
		for ( /* void */;FirstFree < SizeOfElements;FirstFree ++ )
			{
			REGISTER SBIT32 ArrayOffset = (FirstFree * OverheadBitsPerWord);
			REGISTER BIT32 AvailableMask = WordSearchMask;
			REGISTER BIT32 *VectorWord = & Vector[ FirstFree ];
			REGISTER SBIT32 WordOffset = 0;

			//
			//   We scan the bit vector word at a time 
			//   looking for any free allocation slots.
			//
			while ( ((*VectorWord) & FullSearchMask) != FullSearchMask )
				{
				REGISTER BIT32 Value = (*VectorWord);

				//
				//   We know there is an at least one empty  
				//   slot availabale in the current word but  
				//   don't know which one We search for the
				//   slot with the lowest address and stop
				//   when we find it.
				//
				for 
					(
					/* void */;
					(AvailableMask & Value) != 0; 
					AvailableMask >>= OverheadBits, WordOffset ++   
					);

				//
				//   We should never fail to find a free 
				//   allocation slot so if we do then the 
				//   heap must be corrupt.
				//
				if ( WordOffset < OverheadBitsPerWord )
					{
					REGISTER SBIT32 VectorOffset = (ArrayOffset + WordOffset);

					//
					//   We need to ensure that the element 
					//   we have chosen if not outside the 
					//   valid range for this page.
					//
					if ( VectorOffset < (Cache -> GetNumberOfElements()) )
						{
						//
						//   Update the allocation information.
						//
						Allocated ++;
						Available --;

						//
						//   Turn on the bits indicating that this
						//   element is in use.
						//
						(*VectorWord) |= AvailableMask;

						//
						//   If the page is full we remove it
						//   from the bucket list so we will no
						//   longer look at it when we are 
						//   trying to find free space.
						//
						if ( Full() )
							{ Cache -> DeleteFromBucketList( this ); }

						//
						//   Add the element to the allocation array
						//   so it can be returned to the caller.
						//
						Array[ (Requested - ((*Actual) ++) - 1) ] =
							(
							Cache -> ComputeAddress
								( 
								Address,
								VectorOffset
								)
							);

						//
						//   When we have got what we need we exit.
						//
						if ( ((*Actual) >= Requested) )
							{ return True; }
						}
					else
						{ break; }
					}
				else
					{ Failure( "Bit vector is corrupt in MultipleNew" ); }
				}
			}
		}

	return ((*Actual) >= Requested);
    }

    /********************************************************************/
    /*                                                                  */
    /*   A single memory allocation.                                    */
    /*                                                                  */
    /*   Allocate an available memeory element from the page.  This     */
    /*   is done by scanning the bit vector looking for unallocated     */
    /*   slots.                                                         */
    /*                                                                  */
    /********************************************************************/

VOID *PAGE::New( BOOLEAN SubDivided )
    {
	//
	//   We begin by making sure that there is at least
	//   one element to allocate.
	//
	if ( ! Full() )
		{
		REGISTER SBIT16 SizeOfElements = (Cache -> GetSizeOfElements());

		//
		//   Search the bit vector from low addresses to 
		//   high addresses looking for a free slot.
		//   We keep a pointer to the first word with
		//   a free element in 'FirstFree'.  Sometimes
		//   the current word may be fully allocated so 
		//   we might need to scan.  However, there can
		//   never be any free memory before this point 
		//   in the bit vector.
		//
		for ( /* void */;FirstFree < SizeOfElements;FirstFree ++ )
			{
			REGISTER BIT32 *VectorWord = & Vector[ FirstFree ];

			//
			//   We scan the bit vector word at a time 
			//   looking for any free allocation slots.
			//
			if ( ((*VectorWord) & FullSearchMask) != FullSearchMask )
				{
				REGISTER BIT32 AvailableMask = WordSearchMask;
				REGISTER BIT32 Value = (*VectorWord);
				REGISTER SBIT32 WordOffset = 0;

				//
				//   We know there is an at least one empty  
				//   slot availabale in the current word but  
				//   don't know which one We search for the
				//   slot with the lowest address and stop
				//   when we find it.
				//
				for 
					(
					/* void */;
					(AvailableMask & Value) != 0; 
					AvailableMask >>= OverheadBits, WordOffset ++   
					);

				//
				//   We should never fail to find a free 
				//   allocation slot so if we do then the 
				//   heap must be corrupt.
				//
				if ( WordOffset < OverheadBitsPerWord )
					{
					REGISTER SBIT32 VectorOffset = 
						((FirstFree * OverheadBitsPerWord) + WordOffset);

					//
					//   We need to ensure that the element 
					//   we have chosen if not outside the 
					//   valid range for this page.
					//
					if ( VectorOffset < (Cache -> GetNumberOfElements()) )
						{
						//
						//   Update the allocation information.
						//
						Allocated ++;
						Available --;

						//
						//   Turn on the bit indicating that this
						//   element is in use.  If the allocation 
						//   is to be sub-divided then trun on this
						//   bit as well.
						//
						(*VectorWord) |=
							(
							AvailableMask
								|
							(SubDivided ? (AvailableMask >> 1) : 0)
							);

						//
						//   If the page is full we remove it
						//   from the bucket list so we will no
						//   longer look at it when we are 
						//   trying to find free space.
						//
						if ( Full() )
							{ Cache -> DeleteFromBucketList( this ); }

						//
						//   Return the address of the allocated 
						//   memory to the caller.
						//
						return
							(
							Cache -> ComputeAddress
								( 
								Address,
								VectorOffset
								)
							);
						}
					}
				else
					{ Failure( "Bit vector is corrupt in New" ); }
				}
			}
#ifdef DEBUGGING

		if ( ! Full() )
			{ Failure( "Available count corrupt in New" ); }
#endif
		}

	return ((VOID*) AllocationFailure);
    }

    /********************************************************************/
    /*                                                                  */
    /*   Walk the heap.                                                 */
    /*                                                                  */
    /*   We have been asked to walk the heap.  It is hard to know       */
    /*   why anybody might want to do this given the rest of the        */
    /*   functionality available.  Nonetheless, we just do what is      */
    /*   required to keep everyone happy.                               */
    /*                                                                  */
    /********************************************************************/

BOOLEAN PAGE::Walk( SEARCH_PAGE *Details )
    {
	REGISTER BOOLEAN FreshPage = False;

	//
	//   We have been handed the details of an allocation.
	//   We need to walk along this allocation and find
	//   the next non-subdivided allocation.
	do
		{
		//
		//   We need to setup the heap walk if the address
		//   is null so we skip the heap walk code.
		//
		if ( Details -> Address != NULL )
			{
			REGISTER SBIT32 Count;
			REGISTER SBIT32 End = Details -> Cache -> GetNumberOfElements();
			REGISTER SBIT32 Start = Details -> ArrayOffset;
			REGISTER PAGE *Page = Details -> Page;

			//
			//   Walk the current page looking for a suitable
			//   memory allocation to report to the user.  When
			//   we reach the end of the page we need to get
			//   another page to walk.
			//
			for 
					(
					Count = ((FreshPage) ? 0 : 1);
					(Start + Count) < End;
					Count ++
					)
				{
				//
				//   Compute the new address.
				//
				Details -> Address = 
					(
					Page -> Cache -> ComputeAddress
						( 
						Page -> Address,
						(Start + Count)
						)
					);

				//
				//   Compute the new allocation details.
				//
				Page -> FindPage
					( 
					Details -> Address,
					Details,
					False 
					);

				//
				//   We skip all sub-divided allocations as they 
				//   will get reported elsewhere.
				//
				if (! ((*Details -> VectorWord) & Details -> SubDivisionMask) )
					{ return True; }
				}
			}

		//
		//   Update the flag to show that we have
		//   had to go and get a new page.
		//
		FreshPage = True;
		}
	while ( Details -> Cache -> Walk( Details ) );

	return False;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the current page structure.                            */
    /*                                                                  */
    /********************************************************************/

PAGE::~PAGE( VOID )
	{
#ifdef DEBUGGING
	//
	//   Destroy the page structure.
	//
	Address = NULL;
	PageSize = 0;
	ParentPage = NULL;

	Allocated = 0;
	Available = 0;
	FirstFree = 0;

#endif
	//
	//   We update the version number whenever a page is created
	//   or destroyed.  We use the version number to ensure that
	//   a page has not been deleteed and/or recreated between
	//   releasing one lock and claiming a another other lock.
	//
	Version ++;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\interface\interfacepch.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "InterfacePCH.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\interface\debugheap.hpp ===
#ifndef _DEBUG_HEAP_HPP_
#define _DEBUG_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Rockall.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   The debug memory allocator.                                    */
    /*                                                                  */
    /*   The debug memory allocator checks all the memory allocation    */
    /*   calls to make sure they are reasonable.  If not then it        */
    /*   raises an execption at the point it detects a problem.         */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_DLL_LINKAGE DEBUG_HEAP : public ROCKALL
    {
		//
		//   Private type definitions.
		//
		//   A debug heap places a collection of guard words
		//   before and after each allocation.  It checks
		//   these guard words everytime the allocation is
		//   examined or modified.
		//
		typedef struct
			{
			int						  Size;
			int						  StartGuard;
			}
		DEBUG_HEADER;

		typedef struct
			{
			char					  MidGuard[ sizeof(int) ];
			int						  EndGuard[1];
			}
		DEBUG_TRAILER;

		typedef struct
			{
			DEBUG_HEADER			  DebugHeader;
			DEBUG_TRAILER			  DebugTrailer;
			}
		DEBUG_GUARD;

    public:
        //
        //   Public functions.
		//
		//   A heaps public interface consists of a number
		//   of groups of related APIs.
        //
        DEBUG_HEAP
			( 
			int						  MaxFreeSpace = 0,
			bool					  Recycle = false,
			bool					  SingleImage = false,
			bool					  ThreadSafe = true 
			);

		//
		//   Manipulate allocations.
		//
		//   The first group of functions manipulate 
		//   single or small arrays of allocations. 
		//
		virtual bool Delete
			( 
			void					  *Address,
			int						  Size = NoSize 
			);

		virtual bool Details
			( 
			void					  *Address,
			int						  *Space = NULL 
			);

		virtual bool MultipleDelete
			( 
			int						  Actual,
			void					  *Array[],
			int						  Size = NoSize
			);

		virtual bool MultipleNew
			( 
			int						  *Actual,
			void					  *Array[],
			int						  Requested,
			int						  Size,
			int						  *Space = NULL,
			bool					  Zero = false
			);

		virtual void *New
			( 
			int						  Size,
			int						  *Space = NULL,
			bool					  Zero = false
			);

		virtual void *Resize
			( 
			void					  *Address,
			int						  NewSize,
			int						  Move = 1,
			int						  *Space = NULL,
			bool					  NoDelete = false,
			bool					  Zero = false
			);

		virtual bool Check
			( 
			void					  *Address = NULL,
			int						  *Space = NULL 
			);

		//
		//   Manipulate the heap.
		//
		//   The second group of functions act upon a heap
		//   as a whole.
		//
		virtual void DeleteAll( bool Recycle = true );

		virtual void HeapLeaks( void );

		virtual bool Truncate( int MaxFreeSpace = 0 );

		virtual bool Walk
			(
			bool					  *Active,
			void					  **Address,
			int						  *Space
			);

		//
		//   Low level heap interface.
		//
		//   The third group of functions are called by the
		//   heap to aquire or release large blocks of memory.
		//   These functions can be overloaded to enable the
		//   heap work in constrained environments.
		//
		virtual void *NewArea( int AlignMask,int Size,bool User );

        virtual ~DEBUG_HEAP( void );

	private:
		//
		//   Private functions.
		//
		//   A debug heap verifies each allocation using a 
		//   collection of private functions.
		//
		DEBUG_HEADER *ComputeHeaderAddress( void *Address )
			{
			register int HeaderSize = sizeof(DEBUG_HEADER);

			return ((DEBUG_HEADER*) (((char*) Address) - HeaderSize)); 
			}

		void *ComputeDataAddress( DEBUG_HEADER *Header )
			{ return ((void*) & Header[1]); }

		void ResetGuardWords( DEBUG_HEADER *Header,int TotalSize );

		void SetGuardWords( DEBUG_HEADER *Header,int Size,int TotalSize );

		void TestGuardWords( DEBUG_HEADER *Header,int TotalSize );

		void UnmodifiedGuardWords( DEBUG_HEADER *Header,int TotalSize );

		void UpdateGuardWords( DEBUG_HEADER *Header,int Size,int TotalSize );

        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        DEBUG_HEAP( const DEBUG_HEAP & Copy );

        void operator=( const DEBUG_HEAP & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\interface\debugheap.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "InterfacePCH.hpp"

#include "DebugHeap.hpp"
#include "Heap.hpp"

void Failure( char* a);

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here try to make the layout of the      */
    /*   the caches easier to understand and update.  Additionally,     */
    /*   there are also various guard related constants.                */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 FindCacheSize			  = 512;
CONST SBIT32 FindCacheThreshold		  = 0;
CONST SBIT32 FindSize				  = 4096;
CONST SBIT32 Stride1				  = 4;
CONST SBIT32 Stride2				  = 1024;

CONST int GuardMask					  = (sizeof(int)-1);
CONST int GuardSize					  = sizeof(int);

    /********************************************************************/
    /*                                                                  */
    /*   The description of the heap.                                   */
    /*                                                                  */
    /*   A heap is a collection of fixed sized allocation caches.       */
    /*   An allocation cache consists of an allocation size, the        */
    /*   number of pre-built allocations to cache, a chunk size and     */
    /*   a parent page size which is sub-divided to create elements     */
    /*   for this cache.  A heap consists of two arrays of caches.      */
    /*   Each of these arrays has a stride (i.e. 'Stride1' and          */
    /*   'Stride2') which is typically the smallest common factor of    */
    /*   all the allocation sizes in the array.                         */
    /*                                                                  */
    /********************************************************************/

STATIC ROCKALL::CACHE_DETAILS Caches1[] =
	{
	    //
	    //   Bucket   Size Of   Bucket   Parent
	    //    Size     Cache    Chunks  Page Size
		//
		{        4,        0,       32,       32 },
		{        8,        0,       32,       32 },
		{       12,        0,       64,       64 },
		{       16,        0,       64,       64 },
		{       20,        0,       64,       64 },
		{       24,        0,      128,      128 },

		{       32,        0,       64,       64 },
		{       40,        0,      128,      128 },
		{       48,        0,      256,      256 },

		{       64,        0,      128,      128 },
		{       80,        0,      512,      512 },
		{       96,        0,      512,      512 },

		{      128,        0,      256,      256 },
		{      160,        0,      512,      512 },
		{      192,        0,     1024,     1024 },
		{      224,        0,      512,      512 },

		{      256,        0,      512,      512 },
		{      320,        0,     1024,     1024 },
		{      384,        0,     2048,     2048 },
		{      448,        0,     4096,     4096 },
		{      512,        0,     1024,     1024 },
		{      576,        0,     4096,     4096 },
		{      640,        0,     8192,     8192 },
		{      704,        0,     4096,     4096 },
		{      768,        0,     4096,     4096 },
		{      832,        0,     8192,     8192 },
		{      896,        0,     8192,     8192 },
		{      960,        0,     4096,     4096 },
		{ 0,0,0,0 }
	};

STATIC ROCKALL::CACHE_DETAILS Caches2[] =
	{
	    //
	    //   Bucket   Size Of   Bucket   Parent
	    //    Size     Cache    Chunks  Page Size
		//
		{     1024,        0,     2048,     2048 },
		{     2048,        0,     4096,     4096 },
		{     3072,        0,    65536,    65536 },
		{     4096,        0,     8192,     8192 },
		{     5120,        0,    65536,    65536 },
		{     6144,        0,    65536,    65536 },
		{     7168,        0,    65536,    65536 },
		{     8192,        0,    65536,    65536 },
		{     9216,        0,    65536,    65536 },
		{    10240,        0,    65536,    65536 },
		{    12288,        0,    65536,    65536 },
		{    16384,        0,    65536,    65536 },
		{    21504,        0,    65536,    65536 },
		{    32768,        0,    65536,    65536 },

		{    65536,        0,    65536,    65536 },
		{    65536,        0,    65536,    65536 },
		{ 0,0,0,0 }
	};

    /********************************************************************/
    /*                                                                  */
    /*   The description bit vectors.                                   */
    /*                                                                  */
    /*   All heaps keep track of allocations using bit vectors.  An     */
    /*   allocation requires 2 bits to keep track of its state.  The    */
    /*   following array supplies the size of the available bit         */
    /*   vectors measured in 32 bit words.                              */
    /*                                                                  */
    /********************************************************************/

STATIC int NewPageSizes[] = { 1,4,0 };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   The overall structure and layout of the heap is controlled     */
    /*   by the various constants and calls made in this function.      */
    /*   There is a significant amount of flexibility available to      */
    /*   a heap which can lead to them having dramatically different    */
    /*   properties.                                                    */
    /*                                                                  */
    /********************************************************************/

DEBUG_HEAP::DEBUG_HEAP
		( 
		int							  MaxFreeSpace,
		bool						  Recycle,
		bool						  SingleImage,
		bool						  ThreadSafe 
		) :
		//
		//   Call the constructors for the contained classes.
		//
		ROCKALL
			(
			Caches1,
			Caches2,
			FindCacheSize,
			FindCacheThreshold,
			FindSize,
			MaxFreeSpace,
			NewPageSizes,
			Recycle,
			SingleImage,
			Stride1,
			Stride2,
			ThreadSafe
			)
	{
	//
	//   We make much use of the guard value in the
	//   debug heap so here we try to claim the 
	//   address but not commit it so we will cause
	//   an access violation if the program ever
	//   tries to access it.
	//
	VirtualAlloc
		( 
		((void*) GuardValue),
		GuardSize,
		MEM_RESERVE,
		PAGE_NOACCESS 
		);

	//
	//   We verify various values and ensure the heap
	//   is not corrupt.
	//
	if 
			( 
			(MaxFreeSpace < 0) 
				|| 
			(ROCKALL::Corrupt()) 
			)
		{ Failure( "Heap initialization failed to complete" ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory deallocation.                                           */
    /*                                                                  */
    /*   We make sure the memory is allocated and that the guard        */
    /*   words have not been damanged.  If so we reset the contents     */
    /*   of the allocation and delete the allocation.                   */
    /*                                                                  */
    /********************************************************************/

bool DEBUG_HEAP::Delete( void *Address,int Size )
    {
	AUTO DEBUG_HEADER *Header =
		(
		(Address == ((void*) AllocationFailure))
			? ((DEBUG_HEADER*) Address)
			: ComputeHeaderAddress( Address )
		);

	//
	//   A well known practice is to try to delete
	//   a null pointer.  This is really a very poor  
	//   style but we support it in any case.
	//   
	if ( Header != ((void*) AllocationFailure) )
		{
		AUTO int TotalSize;

		//
		//   Ask for the details of the allocation.  This 
		//   will fail if the memory is not allocated.
		//
		if ( ROCKALL::Check( ((void*) Header),& TotalSize ) )
			{
			REGISTER int NewSize = (Size + sizeof(DEBUG_GUARD));

			//
			//   Test the guard words to make sure they have
			//   not been damaged.
			//
			TestGuardWords( Header,TotalSize );

			//
			//   Delete the user information by writing 
			//   guard words over the allocation.  This
			//   should cause the application to crash
			//   if the area is read and also allows us 
			//   to check to see if it is written later.
			//
			ResetGuardWords( Header,TotalSize );

			//
			//   Delete the allocation.  This really ought 
			//   to work given we have already checked that 
			//   the allocation is valid unless there is a  
			//   race condition.
			//
			if ( ! ROCKALL::Delete( ((void*) Header),NewSize ) )
				{ Failure( "Delete requested failed due to race" ); }

			//
			//   We ensure that the heap has not become corrupt
			//   during the deletion process.
			//
			if ( ROCKALL::Corrupt() ) 
				{ Failure( "Delete failed to complete" ); }
			}
		else
			{ Failure( "Delete requested on unallocated memory" ); }
		}

	return true;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete all allocations.                                        */
    /*                                                                  */
    /*   We check to make sure the heap is not corrupt and force        */
    /*   the return of all heap space back to the operating system.     */
    /*                                                                  */
    /********************************************************************/

void DEBUG_HEAP::DeleteAll( bool Recycle )
    {
	AUTO bool Active;
	AUTO void *Address = NULL;
	AUTO int Space;

	//
	//   Walk the heap and check all the allocations
	//   to make sure the guard words have not been
	//   overwritten.
	//
	while ( ROCKALL::Walk( & Active,& Address,& Space ) )
		{
		//
		//   We inspect the guard words to make sure
		//   they have not been overwritten.
		//
		if ( Active )
			{ TestGuardWords( ((DEBUG_HEADER*) Address),Space ); }
		else
			{ UnmodifiedGuardWords( ((DEBUG_HEADER*) Address),Space ); }
		}

	//
	//   Delete the heap and force all the allocated
	//   memory to be returned to the operating system
	//   regardless of what the user requested.  Any
	//   attempt to access the deallocated memory will 
	//   be trapped by the operating system.
	//
	ROCKALL::DeleteAll( (Recycle && false) );

	//
	//   We ensure that the heap has not become corrupt
	//   during the deletion process.
	//
	if ( ROCKALL::Corrupt() ) 
		{ Failure( "DeleteAll failed to complete" ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation details.                                     */
    /*                                                                  */
    /*   Extract information about a memory allocation and just for     */
    /*   good measure check the guard words at the same time.           */
    /*                                                                  */
    /********************************************************************/

bool DEBUG_HEAP::Details( void *Address,int *Space )
	{ return Check( Address,Space ); }

    /********************************************************************/
    /*                                                                  */
    /*   Print a list of heap leaks.                                    */
    /*                                                                  */
    /*   We walk the heap and output a list of active heap              */
    /*   allocations to the debug window,                               */
    /*                                                                  */
    /********************************************************************/

void DEBUG_HEAP::HeapLeaks( void )
    {
	AUTO bool Active;
	AUTO void *Address = NULL;
	AUTO int Space;

	//
	//   Walk the heap and find all the active and
	//   available spece.  We would normally expect
	//   this to be proportional to the size of the
	//   heap.
	//
	while ( ROCKALL::Walk( & Active,& Address,& Space ) )
		{
		CONST INT DebugBufferSize = 8192;
#ifndef OUTPUT_FREE_SPACE

		//
		//   We report all active heap allocations
		//   just so the user knows there are leaks.
		//
		if ( Active )
			{
#endif
			AUTO CHAR Buffer[ DebugBufferSize ];

			//
			//   Format the string to be printed.
			//
			(void) sprintf
				(
				Buffer,
				"Memory leak \t%d \t0x%x \t%d\n",
				Active,
				(((SBIT32) Address) + sizeof(DEBUG_HEADER)),
				Space
				);

			//
			//   Force null termination.
			//
			Buffer[ (DebugBufferSize-1) ] = '\0';

			//
			//   Write the string to the debug window.
			//
			OutputDebugString( Buffer );
#ifndef OUTPUT_FREE_SPACE
			}
#endif
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory deallocations.                                 */
    /*                                                                  */
    /*   We make sure all the memory is allocated and that the guard    */
    /*   words have not been damaged.  If so we reset the contents      */
    /*   of the allocations and then delete all the allocations.        */
    /*                                                                  */
    /********************************************************************/

bool DEBUG_HEAP::MultipleDelete
		( 
		int							  Actual,
		void						  *Array[],
		int							  Size
		)
    {
	REGISTER int Count;
	REGISTER int NewSize = (Size + sizeof(DEBUG_GUARD));

	//
	//   Examine each memory allocation and delete it
	//   after carefully checking it.
	//
	for ( Count=0;Count < Actual;Count ++ )
		{
		AUTO int TotalSize;
		AUTO VOID *Address = Array[ Count ];
		AUTO DEBUG_HEADER *Header =
			(
			(Address == ((void*) AllocationFailure))
				? ((DEBUG_HEADER*) Address)
				: ComputeHeaderAddress( Address )
			);

		//
		//   Ask for the details of the allocation.  This 
		//   will fail if the memory is not allocated.
		//
		if ( ROCKALL::Check( ((void*) Header),& TotalSize ) )
			{
			//
			//   Test the guard words to make sure they have
			//   not been damaged.
			//
			TestGuardWords( Header,TotalSize );

			//
			//   Delete the user information by writing 
			//   guard words over the allocation.  This
			//   should cause the application to crash
			//   if the area is read and also allows us 
			//   to check to see if it is written later.
			//
			ResetGuardWords( Header,TotalSize );

			//
			//   Update the address in the array to the
			//   address originally allocated.
			//
			Array[ Count ] = ((VOID*) Header);
			}
		else
			{ Failure( "Delete requested on unallocated memory" ); }
		}

	//
	//   Delete the allocation.  This really ought 
	//   to work given we have already checked that 
	//   the allocations are valid unless there is a  
	//   race condition.
	//
	if ( ! ROCKALL::MultipleDelete( Actual,Array,NewSize ) )
		{ Failure( "Delete requested failed due to race" ); }

	//
	//   We ensure that the heap has not become corrupt
	//   during the deletion process.
	//
	if ( ROCKALL::Corrupt() ) 
		{ Failure( "MultipleDelete failed to complete" ); }

	return true;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory allocations.                                   */
    /*                                                                  */
    /*   Allocate a collection of memory elements and setup the         */
    /*   guard information so we can check they have not been           */
    /*   damaged later.                                                 */
    /*                                                                  */
    /********************************************************************/

bool DEBUG_HEAP::MultipleNew
		( 
		int							  *Actual,
		void						  *Array[],
		int							  Requested,
		int							  Size,
		int							  *Space,
		bool						  Zero
		)
    {
	REGISTER bool Result = false;

	//
	//   The requested number of elements and the size  
	//   must be greater than zero.  We require the 
	//   caller to allocate a positive amount of memory.
	//
	if ( (Requested > 0) && (Size >= 0) )
		{
		AUTO int TotalSize;
		REGISTER int NewSize = 
			(((Size + sizeof(DEBUG_GUARD)) + GuardMask) & ~GuardMask);

		//
		//   Allocate the memory plus some additional 
		//   memory for the guard words.
		//
		Result = 
			(
			ROCKALL::MultipleNew
				( 
				Actual,
				Array,
				Requested,
				NewSize,
				& TotalSize 
				)
			);

		//
		//   If we were able to allocate some memory then
		//   set the guard words so we can detect any
		//   corruption later.
		//
		if ( (*Actual) > 0 )
			{
			REGISTER int Count;

			//
			//   If the real size is requested then return 
			//   it to the caller.
			//
			if ( Space != NULL )
				{ (*Space) = (TotalSize - sizeof(DEBUG_GUARD)); }

			//
			//   Set the guard words so we can see if 
			//   someone damages any allocation.  If the 
			//   caller requested the size information 
			//   then we must assume that it could be  
			//   used so we need to adjust the number 
			//   of guard words.
			//
			for ( Count=0;Count < (*Actual);Count ++ )
				{ 
				REGISTER void **Current = & Array[ Count ];

				//
				//   Set up the guard words and ensure
				//   the allocation has not been written
				//   since being freed.
				//
				SetGuardWords
					( 
					((DEBUG_HEADER*) (*Current)),
					((Space == NULL) ? Size : (*Space)), 
					TotalSize
					);

				//
				//   Compute the external address and place
				//   it back in the array.
				//
				(*Current) = ComputeDataAddress( ((DEBUG_HEADER*) (*Current)) );

				//
				//   Zero the memory if the needed.
				//
				if ( Zero )
					{ 
					ZeroMemory
						( 
						(*Current),
						((Space == NULL) ? Size : (*Space)) 
						); 
					}
				}
			}

		//
		//   We ensure that the heap has not become corrupt
		//   during the allocation process.
		//
		if ( ROCKALL::Corrupt() ) 
			{ Failure( "Multiple new failed to complete" ); }
		}
	else
		{ Failure( "Allocation size must greater than zero" ); }

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation.                                             */
    /*                                                                  */
    /*   We add some space on to the original allocation size for       */
    /*   various information and then call the allocator.  We then      */
    /*   set the guard words so we can check for overruns.              */
    /*                                                                  */
    /********************************************************************/

void *DEBUG_HEAP::New( int Size,int *Space,bool Zero )
    {
	REGISTER void *Address = ((void*) AllocationFailure);

	//
	//   The size must be greater than or equal to zero.  
	//   We do not know how to allocate a negative amount
	//   of memory.
	//
	if ( Size >= 0 )
		{
		AUTO int TotalSize;
		REGISTER int NewSize = 
			(((Size + sizeof(DEBUG_GUARD)) + GuardMask) & ~GuardMask);

		//
		//   Allocate the memory plus some additional 
		//   memory for the guard words.
		//
		Address = ROCKALL::New( NewSize,& TotalSize,false );

		//
		//   If we were able to allocate some memory then
		//   set the guard words so we can detect any
		//   corruption later.
		//
		if ( Address != ((void*) AllocationFailure) ) 
			{
			//
			//   If the real size is requested then return it
			//   to the caller.
			//
			if ( Space != NULL )
				{ (*Space) = (TotalSize - sizeof(DEBUG_GUARD)); }

			//
			//   Set the guard words so we can see if 
			//   someone damages any allocation.  If the 
			//   caller requested the size information 
			//   then we must assume that it could be  
			//   used so we need to adjust the number 
			//   of guard words.
			//
			SetGuardWords
				( 
				((DEBUG_HEADER*) Address),
				((Space == NULL) ? Size : (*Space)), 
				TotalSize
				); 

			//
			//   Compute the external address and place
			//   it back in the variable.
			//
			Address = ComputeDataAddress( ((DEBUG_HEADER*) Address) );

			//
			//   Zero the allocation if needed.
			//
			if ( Zero )
				{ 
				ZeroMemory
					( 
					Address,
					((Space == NULL) ? Size : (*Space)) 
					); 
				} 
			}

		//
		//   We ensure that the heap has not become corrupt
		//   during the allocation process.
		//
		if ( ROCKALL::Corrupt() ) 
			{ Failure( "New failed to complete" ); }
		}
	else
		{ Failure( "Allocation size can not be negative" ); }

	return Address;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory area allocation.                                        */
    /*                                                                  */
    /*   We need to allocate some new memory from the operating         */
    /*   system and prepare it for use in the debugging heap.           */
    /*                                                                  */
    /********************************************************************/

void *DEBUG_HEAP::NewArea( int AlignMask,int Size,bool User )
    {
	REGISTER void *Memory = ROCKALL::NewArea( AlignMask,Size,User );

	//
	//   If we managed to get a new page then write
	//   the guard value over it to allow us to
	//   verify it has not been overwritten later.
	//
	if ( Memory != ((void*) AllocationFailure) )
		{
		REGISTER int Count;

		//
		//   Write the guard value into all of the new
		//   heap page to allow it to be checked for
		//   corruption.
		//
		for ( Count=0;Count < Size;Count += GuardSize )
			{ (((int*) Memory)[ (Count / GuardSize) ]) = GuardValue; }
		}
	
	return Memory;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory reallocation.                                           */
    /*                                                                  */
    /*   We need to resize an allocation.  We ensure the original       */
    /*   allocation was undamaged and then expand it.  We also          */
    /*   update the guard words to reflect the changes.                 */
    /*                                                                  */
    /********************************************************************/

void *DEBUG_HEAP::Resize
		( 
		void						  *Address,
		int							  NewSize,
		int							  Move,
		int							  *Space,
		bool						  NoDelete,
		bool						  Zero
		)
    {
	AUTO DEBUG_HEADER *Header =
		(
		(Address == ((void*) AllocationFailure))
			? ((DEBUG_HEADER*) Address)
			: ComputeHeaderAddress( Address )
		);

	//
	//   A well known practice is to try to resize a null
	//   pointer.  This is really a very poor style but we 
	//   support it in any case.
	//   
	if ( Header != ((void*) AllocationFailure) )
		{
		AUTO int TotalSize;

		//
		//   The new size must be greater than or equal to  
		//   zero.  We do not know how to allocate a negative 
		//   amount of memory.
		//
		if ( NewSize >= 0 )
			{
			REGISTER int Size = 
				(((NewSize + sizeof(DEBUG_GUARD)) + GuardMask) & ~GuardMask);

			//
			//   Ask for the details of the allocation.  This 
			//   will fail if the memory is not allocated.
			//
			if ( ROCKALL::Check( ((void*) Header),& TotalSize ) )
				{
				REGISTER void *OriginalAddress = ((void*) Header);
				REGISTER int OriginalSize = TotalSize;

				//
				//   Test the guard words to make sure they have
				//   not been damaged.
				//
				TestGuardWords( Header,TotalSize );

				//
				//   Reallocate the memory plus some additional 
				//   memory for the guard words.
				//
				Address =
					(
					ROCKALL::Resize
						( 
						OriginalAddress,
						Size,
						Move,
						& TotalSize,
						true,
						false
						)
					);

				//
				//   If we were able to allocate some memory 
				//   then set the guard words so we can detect 
				//   any corruption later.
				//
				if ( Address != ((void*) AllocationFailure) )
					{
					REGISTER SBIT32 SpaceUsed = Header -> Size;

					//
					//   Delete the user information by writing 
					//   guard words over the allocation.  This
					//   should cause the application to crash
					//   if the area is read and allows us to
					//   check to see if it is written later.
					//
					if ( (! NoDelete) && (Address != OriginalAddress) )
						{
						ResetGuardWords( Header,OriginalSize );

						if ( ! ROCKALL::Delete( OriginalAddress ) )
							{ Failure( "Delete failed due to race" ); }
						}

					//
					//   If the real size is requested then 
					//   return it to the caller.
					//
					if ( Space != NULL )
						{ (*Space) = (TotalSize - sizeof(DEBUG_GUARD)); }

					//
					//   Update the guard words so we can see 
					//   if someone damages the allocation.  If
					//   the caller requested the size information 
					//   then we must assume that it could be 
					//   used so we need to adjust the guard words.
					//
					UpdateGuardWords
						( 
						((DEBUG_HEADER*) Address),
						((Space == NULL) ? NewSize : (*Space)), 
						TotalSize
						); 

					//
					//   Compute the external address and place
					//   it back in the variable.
					//
					Address = ComputeDataAddress( ((DEBUG_HEADER*) Address) );

					//
					//   Zero the memory if the needed.
					//
					if ( Zero )
						{
						REGISTER SBIT32 ActualSize = 
							((Space == NULL) ? Size : (*Space));
						REGISTER SBIT32 Difference = 
							(ActualSize - SpaceUsed);

						//
						//   If the new size is larger than 
						//   old size then zero the end of the
						//   new allocation.
						//
						if ( Difference > 0 )
							{ 
							REGISTER CHAR *Array = ((CHAR*) Address);

							ZeroMemory( & Array[ SpaceUsed ],Difference ); 
							} 
						}	
					}
				}
			else
				{ Failure( "Resize requested on unallocated memory" ); }
			}
		else
			{ Failure( "Allocation size must be positive" ); }
		}
	else
		{ Address = New( NewSize,Space,Zero ); }

	//
	//   We ensure that the heap has not become corrupt
	//   during the reallocation process.
	//
	if ( ROCKALL::Corrupt() ) 
		{ Failure( "Resize failed to complete" ); }

	return Address;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Reset the guard words.                                         */
    /*                                                                  */
    /*   We need to reset the guard words just before we delete a       */
    /*   memory allocation.                                             */
    /*                                                                  */
    /********************************************************************/

void DEBUG_HEAP::ResetGuardWords( DEBUG_HEADER *Header,int TotalSize )
	{
	REGISTER int Count;

	//
	//   Write guard words over the allocated space as
	//   the allocation is about to be freed.
	//
	for ( Count=0;Count < TotalSize;Count += GuardSize )
		{ (((int*) Header)[ (Count / GuardSize) ]) = GuardValue; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Set the guard words.                                           */
    /*                                                                  */
    /*   We need to set the guard words just after an allocation so     */
    /*   we can check them later.                                       */
    /*                                                                  */
    /********************************************************************/

void DEBUG_HEAP::SetGuardWords( DEBUG_HEADER *Header,int Size,int TotalSize )
	{
	//
	//   We check that the information supplied seems
	//   to make sense before setting up the guard words.
	//
	if 
			(
			((((int) Header) & GuardMask) == 0)
				&&
			((TotalSize & GuardMask) == 0)
				&&
			((Size + ((int) sizeof(DEBUG_GUARD))) <= TotalSize) 
				&& 
			(Size >= 0) 
			)
		{
		REGISTER int Count;

		//
		//   We know that the entire allocation should be
		//   set to the guard value so check that it has
		//   not been overwritten.
		//
		for ( Count=0;Count < TotalSize;Count += GuardSize )
			{ 
			if ( (((int*) Header)[ (Count / GuardSize) ]) != GuardValue )
				{ Failure( "Guard words have been damaged" ); }
			}

		//
		//   Write the header information.
		//
		Header -> Size = Size;
		}
	else
		{ Failure( "Guard word area is too small or unaligned" ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Test the guard words.                                          */
    /*                                                                  */
    /*   We need to test the guard words a various times to ensure      */
    /*   are still valid.                                               */
    /*                                                                  */
    /********************************************************************/

void DEBUG_HEAP::TestGuardWords( DEBUG_HEADER *Header,int TotalSize )
	{
	//
	//   We check that the information supplied seems
	//   to make sense before testing the guard words.
	//
	if 
			(
			((((int) Header) & GuardMask) == 0)
				&&
			((TotalSize & GuardMask) == 0)
				&&
			((Header -> Size + ((int) sizeof(DEBUG_GUARD))) <= TotalSize)
				&&
			(Header -> Size >= 0) 
			)
		{
		REGISTER int Count;
		REGISTER char *DataArea = ((char*) ComputeDataAddress( Header ));
		REGISTER int EndIndex = ((Header -> Size + GuardMask) & ~GuardMask);
		REGISTER int EndSize = (TotalSize - sizeof(DEBUG_HEADER) - GuardSize);
		REGISTER char *MidGuard = & DataArea[ (EndIndex - GuardSize) ];
		REGISTER DEBUG_TRAILER *Trailer = ((DEBUG_TRAILER*) MidGuard);

		//
		//   Test the guard word just before the allocation
		//   to see if it has been overwritten.
		//
		if ( Header -> StartGuard != GuardValue )
			{ Failure( "Leading guard word has been damaged" ); }

		//
		//   Test the guard bytes just after the allocation
		//   to see if they have been overwritten.
		//
		for ( Count=Header -> Size;(Count & GuardMask) != 0;Count ++ )
			{
			REGISTER int ByteIndex = (Count & GuardMask);

			//
			//   Test each byte up to the next word boundary.
			//
			if 
					( 
					Trailer -> MidGuard[ ByteIndex ] 
						!= 
					((char*) & GuardValue)[ ByteIndex ]
					)
				{ Failure( "Trailing guard byte has been damaged" ); }
			}

		//
		//   Test the guard words following the allocation
		//   to see if they have been overwritten.
		//
		for ( Count=(EndSize - Count);Count >= 0;Count -= GuardSize )
			{ 
			if ( Trailer -> EndGuard[ (Count / GuardSize) ] != GuardValue )
				{ Failure( "Trailing guard word has been damaged" ); }
			}
		}
	else
		{ Failure( "Guard information has been damaged" ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory Trunction.                                              */
    /*                                                                  */
    /*   We truncate the heap and make sure that this does not          */
    /*   corrupt the heap in some way.                                  */
    /*                                                                  */
    /********************************************************************/

bool DEBUG_HEAP::Truncate( int MaxFreeSpace )
	{
	REGISTER bool Result;

	//
	//   We truncate the heap and release all available
	//   memory regardless of what the caller requested.
	//
	Result = ROCKALL::Truncate( 0 );

	//
	//   We verify various values and ensure the heap
	//   is not corrupt.
	//
	if 
			( 
			(MaxFreeSpace < 0) 
				|| 
			(ROCKALL::Corrupt()) 
			)
		{ Failure( "Heap truncation failed to complete" ); }

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Unmodified guard words.                                        */
    /*                                                                  */
    /*   We need to inspect the guard words to ensure they have not     */
    /*   changed after being freed.                                     */
    /*                                                                  */
    /********************************************************************/

void DEBUG_HEAP::UnmodifiedGuardWords( DEBUG_HEADER *Header,int TotalSize )
	{
	REGISTER int Count;

	//
	//   We know that the entire allocation should be
	//   set to the guard value so check that it has
	//   not been overwritten.
	//
	for ( Count=0;Count < TotalSize;Count += GuardSize )
		{ 
		if ( (((int*) Header)[ (Count / GuardSize) ]) != GuardValue )
			{ Failure( "Guard words on unallocated memory have been damaged" ); }
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Update the guard words.                                        */
    /*                                                                  */
    /*   We need to update the guard words after a resize so we can     */
    /*   check them later.                                              */
    /*                                                                  */
    /********************************************************************/

void DEBUG_HEAP::UpdateGuardWords( DEBUG_HEADER *Header,int Size,int TotalSize )
	{
	//
	//   We check that the information supplied seems
	//   to make sense before setting up the guard words.
	//
	if 
			(
			((((int) Header) & GuardMask) == 0)
				&&
			((TotalSize & GuardMask) == 0)
				&&
			((Size + ((int) sizeof(DEBUG_GUARD))) <= TotalSize)
				&&
			(Size >= 0) 
			)
		{
		//
		//   We only copy the smaller of the new size 
		//   and the old size.  So check just the
		//   correct number of guard words.
		//
		if ( Header -> Size > Size )
			{
			REGISTER int Count;
			REGISTER char *DataArea = ((char*) ComputeDataAddress( Header ));
			REGISTER int EndIndex = ((Size + GuardMask) & ~GuardMask);
			REGISTER int EndSize = (TotalSize - sizeof(DEBUG_HEADER) - GuardSize);
			REGISTER char *MidGuard = & DataArea[ (EndIndex - GuardSize) ];
			REGISTER DEBUG_TRAILER *Trailer = ((DEBUG_TRAILER*) MidGuard);

			//
			//   Update the guard bytes just after the 
			//   allocation.
			//
			for ( Count=Size;(Count & GuardMask) != 0;Count ++ )
				{
				REGISTER int ByteIndex = (Count & GuardMask);

				Trailer -> MidGuard[ ByteIndex ] =
					((char*) & GuardValue)[ ByteIndex ];
				}

			//
			//   Write guard words over part of the space 
			//   as the allocation is being shrunk.
			//
			for ( Count=(EndSize - Count);Count >= 0;Count -= GuardSize )
				{ Trailer -> EndGuard[ (Count / GuardSize) ] = GuardValue; }

			//
			//   Update the header information.
			//
			Header -> Size = Size; 

			//
			//   We know that the entire allocation should 
			//   be set to the guard value so check that it 
			//   has not been overwritten.
			//
			TestGuardWords( Header,TotalSize );
			}
		else
			{
			//
			//   We know that the entire allocation should be
			//   set to the guard value so check that it has
			//   not been overwritten.
			//
			TestGuardWords( Header,TotalSize );

			//
			//   Update the header information.
			//
			Header -> Size = Size; 
			}
		}
	else
		{ Failure( "Guard word information area is damaged" ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Verify memory allocation details.                              */
    /*                                                                  */
    /*   Extract information about a memory allocation and just for     */
    /*   good measure check the guard words at the same time.           */
    /*                                                                  */
    /********************************************************************/

bool DEBUG_HEAP::Check( void *Address,int *Space )
    {
	AUTO bool Result;
	AUTO int TotalSize;
	AUTO DEBUG_HEADER *Header =
		(
		(Address == ((void*) AllocationFailure))
			? ((DEBUG_HEADER*) Address)
			: ComputeHeaderAddress( Address )
		);

	//
	//   Extract information about the memory allocation.
	//
	Result = 
		(
		ROCKALL::Check
			( 
			((void*) Header),
			& TotalSize 
			)
		);

	//
	//   If we managed to extract the information then
	//   check the guard words for good measure.
	//
	if ( Result )
		{
		//
		//   If we are about to return the actual 
		//   amount of spce available then we must 
		//   update the size of the guard area.
		//
		if ( Space == NULL )
			{
			//
			//   Test the guard words to make sure they have
			//   not been damaged.
			//
			TestGuardWords( Header,TotalSize );
			}
		else
			{ 
			//
			//   Compute the amount of available space.
			//   
			(*Space) = (TotalSize - sizeof(DEBUG_GUARD));

			//
			//   Test the guard words to make sure they have
			//   not been damaged.
			//
			UpdateGuardWords( Header,(*Space),TotalSize );
			}
		}

	//
	//   We ensure that the heap has not become corrupt
	//   during the verification process.
	//
	if ( ROCKALL::Corrupt() ) 
		{ Failure( "Heap check failed to complete" ); }

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Walk the heap.                                                 */
    /*                                                                  */
    /*   We have been asked to walk the heap.  It is hard to know       */
    /*   why anybody might want to do this given the rest of the        */
    /*   functionality available.  Nonetheless, we just do what is      */
    /*   required to keep everyone happy.                               */
    /*                                                                  */
    /********************************************************************/

bool DEBUG_HEAP::Walk( bool *Active,void **Address,int *Space )
    {
	AUTO DEBUG_HEADER *Header =
		(
		((*Address) == ((void*) AllocationFailure))
			? ((DEBUG_HEADER*) (*Address))
			: ComputeHeaderAddress( (*Address) )
		);

	//
	//   Walk the heap.
	//
	if ( ROCKALL::Walk( Active,((VOID**) & Header),Space ) )
		{
		//
		//   We inspect the guard words to make sure
		//   they have not been overwritten.
		//
		if ( (*Active) )
			{ TestGuardWords( Header,(*Space) ); }
		else
			{ UnmodifiedGuardWords( Header,(*Space) ); }

		//
		//   Compute the new heap address.
		//
		(*Address) = ComputeDataAddress( Header );

		//
		//   Compute the amount of available space.
		//   
		(*Space) -= sizeof(DEBUG_GUARD);

		return true;
		}
	else
		{ return false; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the current instance of the class.                     */
    /*                                                                  */
    /********************************************************************/

DEBUG_HEAP::~DEBUG_HEAP( void )
	{
	AUTO bool Active;
	AUTO void *Address = NULL;
	AUTO int Space;

	//
	//   Walk the heap and check all the allocations
	//   to make sure the guard words have not been
	//   overwritten.
	//
	while ( ROCKALL::Walk( & Active,& Address,& Space ) )
		{
		//
		//   We inspect the guard words to make sure
		//   they have not been overwritten.
		//
		if ( Active )
			{ TestGuardWords( ((DEBUG_HEADER*) Address),Space ); }
		else
			{ UnmodifiedGuardWords( ((DEBUG_HEADER*) Address),Space ); }
		}

	//
	//   We ensure that the heap has not become corrupt
	//   during the its lifetime.
	//
	if ( ROCKALL::Corrupt() ) 
		{ Failure( "Destructor failed to complete" ); }
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\heap\page.hpp ===
#ifndef _PAGE_HPP_
#define _PAGE_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "NewPageList.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The constants supplied here control the number of bits in      */
    /*   a page descriptions bit vector and its minimum size.           */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 MaxBitsPerWord			  = (sizeof(BIT32) * 8);
CONST SBIT32 MinVectorSize			  = 1;
CONST SBIT32 OverheadBits			  = 2;
CONST SBIT32 OverheadBitsPerWord	  = (MaxBitsPerWord / OverheadBits);

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class CACHE;

    /********************************************************************/
    /*                                                                  */
    /*   Data structures exported from the class.                       */
    /*                                                                  */
    /*   The page descriptions supported by this class are at the       */
    /*   heart of the memory allocator.  These pages are linked in      */
    /*   various ways so they can be quickly found.  The following      */
    /*   structure contains the results of a search for a specific      */
    /*   memory address and its related page information.               */
    /*                                                                  */
    /********************************************************************/

typedef struct
	{
	VOID							  *Address;
	CACHE							  *Cache;
	BOOLEAN							  Found;
	PAGE							  *Page;

	BIT32							  AllocationMask;
	BIT32							  SubDivisionMask;
	BIT32							  *VectorWord;

	SBIT32							  ArrayOffset;
	SBIT32							  VectorOffset;
	SBIT32							  WordShift;
	}
SEARCH_PAGE;

    /********************************************************************/
    /*                                                                  */
    /*   The page allocation mechanism.                                 */
    /*                                                                  */
    /*   The memory manager allocates storage in large chunks from      */
    /*   the external memory allocator.  It then sub-divides these      */
    /*   chunks into various sized pages and keeps track of these       */
    /*   allocations using a bit vector in each page description.       */
    /*                                                                  */
    /********************************************************************/

class PAGE : public NEW_PAGE_LIST
    {
		//
		//   Private data.
		//
		//   The page description contains various details
		//   about the page.  The 'Address' is the starting 
		//   address of the allocation page.  The 'PageSize'
		//   is typically empty but contains a value is the 
		//   page size is weird and not realted to the
		//   assocated bucket.  The 'Version' is a unique
		//   version number and is changed everytime a new
		//   page description is created or deleted.  This
		//   version number allows a thread to see if anyone
		//   has been significantly playing with a page  
		//   description since it last held the associated lock.
		//
		CHAR                          *Address;
		SBIT32						  PageSize;
		SBIT32						  Version;

		//
		//   We keep track of the number of elements that
		//   are currently 'Allocated' and 'Available' on
		//   the page.  Additionally, 'FirstFree' is the
		//   index of the first word in the bit vector that
		//   has at least one available slot.
		//
		SBIT16                        Allocated;
		SBIT16                        Available;
		SBIT16						  FirstFree;

		//
		//   We sometimes need to interact with other classes.
		//   The 'Cache' class typically owns a number of pages
		//   and keeps all the information about this size of
		//   allocation.  The 'ParentPage' is a pointer to 
		//   another cache from where this page was sub-allocated
		//   and where the space will need to be returned when
		//   it becomes free.
		//
		CACHE						  *Cache;
		CACHE						  *ParentPage;

		//
		//   The 'Vector' is the variable sized bit vector that
		//   contains allocation information.  Each allocation
		//   is recorded using 2 bits.  The first bit indicates
		//   whether the allocation is in use and the second bit
		//   indicates whether an active allocation has been 
		//   sub-divided into smaller chunks.  Any unused bits
		//   at the end of the final word are set to zero, assumed
		//   to be zero and should never be non-zero.
		//
		BIT32                         Vector[MinVectorSize];

   public:
		//
		//   Public functions.
		//
		//   The page description contains all the information
		//   relating to an allocation.  There is no information
		//   stored with the allocation itself.  A significant
		//   portion of the external API can find its way to
		//   this class if the many layers of caches fail to
		//   deal with the request first.
		//
        PAGE
			( 
			VOID					  *NewAddress,
			CACHE					  *NewCache,
			SBIT32					  NewPageSize,
			CACHE					  *NewParentPage,
			SBIT32					  NewVersion 
			);

		SBIT32 ActualSize( VOID );

		BOOLEAN Delete( SEARCH_PAGE *Details );

		VOID DeleteAll( VOID );

		PAGE *FindPage
			( 
			VOID					  *Address,
			SEARCH_PAGE				  *Details,
			BOOLEAN					  Recursive 
			);

		BOOLEAN MultipleNew
			( 
			SBIT32					  *Available, 
			VOID					  *Array[],
			SBIT32					  Requested
			);

		VOID *New( BOOLEAN SubDivided );

		BOOLEAN Walk( SEARCH_PAGE *Details );

        ~PAGE( VOID );

		//
		//   Public inline functions.
		//
		//   The page class is so central to the entire memory
		//   allocator that a number of other classes need to
		//   get at certain data from time to time.  Thus, it 
		//   is necessary for both brevity and performance to
		//   provide inline function for certain critical 
		//   information relating to a page.
		//
		INLINE BOOLEAN Empty( VOID )
			{ return (Allocated <= 0); }

		INLINE BOOLEAN Full( VOID )
			{ return (Available <= 0); }

		INLINE VOID *GetAddress( VOID )
			{ return ((VOID*) Address); }

		INLINE CACHE *GetCache( VOID )
			{ return Cache; }

		INLINE SBIT32 GetPageSize( VOID )
			{ return PageSize; }

		INLINE CACHE *GetParentPage( VOID )
			{ return ParentPage; }

		INLINE SBIT32 GetVersion( VOID )
			{ return Version; }

		INLINE BOOLEAN ValidPage( VOID )
			{ return ((BOOLEAN) ~(Version & 0x1)); }

	private:
        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        PAGE( CONST PAGE & Copy );

        VOID operator=( CONST PAGE & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\interface\rockall.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "InterfacePCH.hpp"

#include "Cache.hpp"
#include "Common.hpp"
#include "Find.hpp"
#include "Heap.hpp"
#include "New.hpp"
#include "NewPage.hpp"
#include "Rockall.hpp"
#include "Spinlock.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here try to make the layout of the      */
    /*   the caches easier to understand and update.                    */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 EnableLookAside		  = 0;
CONST SBIT32 GlobalMask				  = (sizeof(SBIT64) - 1);
CONST SBIT32 GlobalPaddedSize		  = (sizeof(FIND) + GlobalMask);
CONST SBIT32 GlobalByteSize			  = (GlobalPaddedSize & ~GlobalMask);
CONST SBIT32 GlobalWordSize			  = (GlobalByteSize / sizeof(SBIT64));

    /********************************************************************/
    /*                                                                  */
    /*   Static member initialization.                                  */
    /*                                                                  */
    /*   Static member initialization sets the initial value for all    */
    /*   static members.                                                */
    /*                                                                  */
    /********************************************************************/

STATIC SBIT64 GlobalFind[ GlobalWordSize ];
STATIC SBIT32 ReferenceCount = 0;
STATIC SPINLOCK Spinlock;

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   The interface default constructor creates a null heap for      */
    /*   internal use by selected classes.                              */
    /*                                                                  */
    /********************************************************************/

ROCKALL::ROCKALL( void )
	{
	//
	//   A heap constructed by this constructor should
	//   never be used.  Hence, we zero key pointers to
	//   ensure grave disorder will result if anyone tries.
	//
	Array = NULL;
	Caches = NULL;
	Find = NULL;
	Heap = NULL;
	NewPage = NULL;

	GlobalDelete = True;
	GuardWord = GuardValue;
	NumberOfCaches = 0;
	TotalSize = 0;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   The overall structure and layout of the heap is controlled     */
    /*   by the various constants and calls made in this function.      */
    /*   There is a significant amount of flexibility within heaps      */
    /*   leading to potentially dramatically different properties.      */
    /*                                                                  */
    /********************************************************************/

ROCKALL::ROCKALL
		(
		CACHE_DETAILS				  *Caches1,
		CACHE_DETAILS				  *Caches2,
		int							  FindCacheSize,
		int							  FindCacheThreshold,
		int							  FindSize,
		int							  MaxFreeSpace,
		int							  *NewPageSizes,
		bool						  Recycle,
		bool						  SingleImage,
		int							  Stride1,
		int							  Stride2,
		bool						  ThreadSafe 
		)
	{
	TRY
		{
		REGISTER int AlignMask = ((int) (NaturalSize()-1));
		REGISTER int Stride = (sizeof(CACHE_DETAILS));
		REGISTER int Size1 = (ComputeSize( ((char*) Caches1),Stride ));
		REGISTER int Size2 = (ComputeSize( ((char*) Caches2),Stride ));
		REGISTER int Size3 = (ComputeSize( ((char*) NewPageSizes),sizeof(int) ));

		//
		//   The interface pointer members are zeroed to
		//   ensure they do not end up containing random 
		//   rubbish whatever happens.
		//
		Array = NULL;
		Caches = NULL;
		Find = NULL;
		Heap = NULL;
		NewPage = NULL;

		//
		//   Set key flags and compute information about
		//   the number of caches and the total amount of
		//   space required for the low level heap structures.
		//
		GlobalDelete = SingleImage;
		GuardWord = GuardValue;
		NumberOfCaches = (Size1 + Size2);

		TotalSize = 
			( 
			(NumberOfCaches * sizeof(CACHE*)) 
				+ 
			(NumberOfCaches * sizeof(CACHE))
				+
			((GlobalDelete) ? 0 : sizeof(FIND))
				+ 
			(sizeof(NEW_PAGE))
				+
			(sizeof(HEAP))
			);

		//
		//   Ensure the alignment mask is valid and we have
		//   at least four caches.  If not the heap will be
		//   worthless.
		//
		if 
				( 
				(COMMON::PowerOfTwo( ((SBIT32) (AlignMask+1)) )) 
					&& 
				((Size1 >= 1) && (Size2 >= 3))
					&&
				((Stride1 > 0) && (COMMON::PowerOfTwo( Stride1 )))
					&&
				((Stride2 >= Stride1) && (COMMON::PowerOfTwo( Stride2 )))
				)
			{
			REGISTER CHAR *NewMemory = 
				((CHAR*) NewArea( ((SBIT32) AlignMask),TotalSize,False ));

			//
			//   We check to make sure that we can allocate space
			//   to store the low level heap control information.
			//   If not we exit.
			//
			if ( NewMemory != NULL )
				{
				REGISTER SBIT32 Count;

				//
				//   Build the caches.
				//
				//   The first step in creating a heap is to
				//   create all the caches and related buckets 
				//   requested by the user.  
				//
				Caches = ((CACHE*) NewMemory);
				NewMemory += (NumberOfCaches * sizeof(CACHE));

				for ( Count=0;Count < Size1;Count ++ )
					{
					REGISTER CACHE_DETAILS *Current = & Caches1[ Count ];

					PLACEMENT_NEW( & Caches[ Count ],CACHE )
						(  
						((SBIT32) Current -> AllocationSize),    
						((SBIT32) Current -> CacheSize), 
						((SBIT32) Current -> ChunkSize),    
						((SBIT32) Current -> PageSize),
						((BOOLEAN) Recycle),
						((BOOLEAN) ThreadSafe)
						);
					}

				for ( Count=0;Count < Size2;Count ++ )
					{
					REGISTER CACHE_DETAILS *Current = & Caches2[ Count ];

					PLACEMENT_NEW( & Caches[ (Count + Size1) ],CACHE )
						(  
						((SBIT32) Current -> AllocationSize),    
						((SBIT32) Current -> CacheSize),    
						((SBIT32) Current -> ChunkSize),    
						((SBIT32) Current -> PageSize),    
						((BOOLEAN) Recycle),  
						((BOOLEAN) ThreadSafe)
						);
					}

				//
				//   Build the cache array.
				//
				//   After we have constructed all of the caches 
				//   we take the address of each cache and load 
				//   it into an array.  This indirection allows 
				//   caches to be shared between heaps.
				//
				Array = (CACHE**) NewMemory;
				NewMemory += (NumberOfCaches * sizeof(CACHE*));

				for ( Count=0;Count < NumberOfCaches;Count ++ )
					{ Array[ Count ] = & Caches[ Count ]; }

				//
				//   Configuration of the find hash table.
				//
				//   The find hash table maps addresses to page 
				//   descriptions and is a key part of the memory  
				//   deallocation mechanism.  Here we specify 
				//   the size of the hash table.  It is important 
				//   to size it based on the expected number of 
				//   memory allocations.  Nonetheless, it will
				//   automatically grow if the correct option is 
				//   set and it is clearly too small.
				//
				if ( GlobalDelete )
					{
					//
					//   We claim a lock just in case there
					//   are multiple threads.
					//
					Spinlock.ClaimLock();

					//
					//   We create the global find hash table
					//   if we are the first thread to create
					//   a heap.
					//
					if ( (ReferenceCount ++) == 0 )
						{
						STATIC ROCKALL Rockall;

						//
						//   Select the global find table 
						//   and call the constructor.
						//
						Find = ((FIND*) GlobalFind);

						PLACEMENT_NEW( Find,FIND ) 
							( 
							((SBIT32) FindSize),
							((SBIT32) FindCacheSize),
							((SBIT32) EnableLookAside),
							((ROCKALL*) & Rockall),
							((BOOLEAN) True),
							((BOOLEAN) (GlobalDelete || ThreadSafe))
							);
						}
					else
						{
						//
						//   A global find has table already
						//   exists so just use it.
						//
						Find = ((FIND*) GlobalFind); 
						}

					//
					//   Release the lock now.
					//
					Spinlock.ReleaseLock();
					}
				else
					{
					Find = (FIND*) NewMemory;
					NewMemory += sizeof(FIND);

					//
					//   We create a local find hash table
					//   if we are do not need to provide
					//   a single heap image.
					//
					PLACEMENT_NEW( Find,FIND ) 
						( 
						((SBIT32) FindSize),
						((SBIT32) FindCacheSize),
						((SBIT32) FindCacheThreshold),
						((ROCKALL*) this),
						((BOOLEAN) True),
						((BOOLEAN) ThreadSafe)
						);
					}

				//
				//   Configuration of the allocation overhead.
				//
				//   The allocation overhead is controlled by 
				//   the size of the bit vectors used to keep 
				//   track of the allocations.  There is a built 
				//   in limit of ((2^15)-1) elements in a single 
				//   bit vector.
				//
				NewPage = (NEW_PAGE*) NewMemory;
				NewMemory += sizeof(NEW_PAGE);

				PLACEMENT_NEW( NewPage,NEW_PAGE ) 
					(
					((FIND*) Find),
					((SBIT32*) NewPageSizes),
					((ROCKALL*) this),
					((SBIT32) Size3),
					((BOOLEAN) ThreadSafe)
					);

				//
				//   Create the heap.
				//
				//   We can now create the heap.  We do this
				//   by passing pointers to all the parts of  
				//   the heap that we have just created.
				//   
				//
				Heap = (HEAP*) NewMemory;

				PLACEMENT_NEW( Heap,HEAP )
					( 
					((CACHE**) & Array[0]),
					((CACHE**) & Array[ Size1 ]),
					((SBIT32) MaxFreeSpace),
					((FIND*) Find),
					((NEW_PAGE*) NewPage),
					((ROCKALL*) this),
					((SBIT32) Size1),
					((SBIT32) Size2),
					((SBIT32) Stride1),
					((SBIT32) Stride2),
					ThreadSafe
					);
				}
			else
				{ Failure( "Heap constructor failed in ROCKALL" ); }
			}
		else
			{ Failure( "Cache size in constructor for ROCKALL" ); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( TEXT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Compute the size of the caches.                                */
    /*                                                                  */
    /*   Compute the size of various data structures for internal       */
    /*   sizing purposes.                                               */
    /*                                                                  */
    /********************************************************************/

int ROCKALL::ComputeSize( char *Array,int Stride )
	{
	register int Count;

	for 
		( 
		Count=0;
		((*((int*) & Array[ Count ])) != 0);
		Count += Stride 
		);

	return (Count / Stride);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory deallocation.                                           */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail and exit.                        */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL::Delete( void *Address,int Size )
    {
	TRY
		{
		//
		//   We verify that the parameters look
		//   reasonable and the heap is not corrupt
		//   and then try to delete the supplied 
		//   allocation.
		//
		if ( Available() )
			{ return (Heap -> Delete( ((VOID*) Address),((SBIT32) Size) )); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( TEXT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete all allocations.                                        */
    /*                                                                  */
    /*   At certain places in am application we sometimes need to       */
    /*   delete a significant number of allocations.  If all of         */
    /*   these allocations are placed into a single heap we can         */
    /*   delete them all using this call.                               */
    /*                                                                  */
    /********************************************************************/

void ROCKALL::DeleteAll( bool Recycle )
    {
	TRY
		{
		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{ Heap -> DeleteAll( (BOOLEAN) Recycle ); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( TEXT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete allocation area.                                        */
    /*                                                                  */
    /*   All memory requests are eventually sent back to the external   */
    /*   deallocator.  This function can be overloaded so that memory   */
    /*   can be provided from any source.  The default is to send       */
    /*   the area back to the operating system.                         */
    /*                                                                  */
    /********************************************************************/

void ROCKALL::DeleteArea( void *Memory,int Size,bool User )
	{
	REGISTER DWORD NewSize = ((Size == 0) ? Size : 0);

#ifdef DEBUGGING
#ifdef ENABLE_ALLOCATION_STATISTICS
	//
	//  When we are debugging print out trace information.
	//  
	DebugPrint( "Delete\t 0x%08x %d bytes\n",Memory,Size );

#endif
#endif
	//
	//   The NT 'VirtualFree' call requires the 'Size'
	//   to be zero.  This may not be true of all 
	//   deallocators so we pass the value and then
	//   replace it with zero above.
	//
	if ( VirtualFree( Memory,NewSize,MEM_RELEASE ) == NULL )
		{ Failure( "Delete fails in DeleteArea" ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation details.                                     */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail the call appropriately.          */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL::Details( void *Address,int *Space )
    {
	TRY
		{
		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{ return (Heap -> Details( ((VOID*) Address),((SBIT32*) Space) )); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( TEXT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   A known area.                                                  */
    /*                                                                  */
    /*   We have an address and don't have a clue which heap            */
    /*   owns the space.  Here we take a look at the address            */
    /*   and figure out it it belongs to the current heap.              */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL::KnownArea( void *Address )
    {
	TRY
		{
		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{
			return ( Heap -> KnownArea( ((VOID*) Address) ) );
			}
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( TEXT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Claim all the heap locks.                                      */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail and exit.                        */
    /*                                                                  */
    /********************************************************************/

void ROCKALL::LockAll( VOID )
	{
	TRY
		{
		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{ Heap -> LockAll(); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( TEXT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory deallocations.                                 */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail and exit.                        */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL::MultipleDelete
		( 
		int							  Actual,
		void						  *Array[],
		int							  Size
		)
    {
	TRY
		{
		//
		//   We verify that the parameters look
		//   reasonable and the heap is not corrupt
		//   and then try to delete the supplied 
		//   allocations.
		//
		if ( (Actual > 0) && (Array != NULL) && (Available()) )
			{
			return
				(
				Heap -> MultipleDelete
					( 
					((SBIT32) Actual),
					((VOID**) Array),
					((SBIT32) Size) 
					)
				);
			}
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( TEXT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif
	
	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory allocations.                                   */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail and exit.                        */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL::MultipleNew
		( 
		int							  *Actual,
		void						  *Array[],
		int							  Requested,
		int							  Size,
		int							  *Space,
		bool						  Zero
		)
    {
	TRY
		{
		//
		//   We verify that the parameters look
		//   reasonable and the heap is not corrupt
		//   and then try to create the requested 
		//   allocation.
		//
		if 
				(
				((Array != NULL) && (Available()))
					&& 
				((Requested > 0) && (Size >= 0))
				)
			{
			return
				(
				Heap -> MultipleNew
					( 
					((SBIT32*) Actual),
					((VOID**) Array),
					((SBIT32) Requested),
					((SBIT32) ((Size > 0) ? Size : 1)),
					((SBIT32*) Space),
					((BOOLEAN) Zero)
					)
				);
			}
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( TEXT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif
	
	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   The natural allocation size.                                   */
    /*                                                                  */
    /*   We would like to know a good default size for allocations.     */
    /*   The default is to ask the operating system for the             */
    /*   allocation granularity.                                        */
    /*                                                                  */
    /********************************************************************/

int ROCKALL::NaturalSize( void )
    {
	STATIC SBIT32 AllocationSize = 0;

	//
	//   Ask the operation system for the allocation
	//   granularity.
	//
	if ( AllocationSize <= 0 )
		{
		AUTO SYSTEM_INFO SystemInformation;

		GetSystemInfo( & SystemInformation );

		AllocationSize = (SBIT32) SystemInformation.dwAllocationGranularity;
		}

	return ((int) AllocationSize);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation.                                             */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail and exit.                        */
    /*                                                                  */
    /********************************************************************/

void *ROCKALL::New( int Size,int *Space,bool Zero )
    {
	TRY
		{ 
		//
		//   We verify that the parameters look
		//   reasonable and the heap is not corrupt
		//   and then try to create the requested 
		//   allocation.
		//
		if ( (Available()) && (Size >= 0) )
			{
			return 
				(
				Heap -> New
					( 
					((SBIT32) ((Size > 0) ? Size : 1)),
					((SBIT32*) Space),
					((BOOLEAN) Zero)
					)
				);
			}
		} 
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING
	catch ( TEXT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return ((void*) AllocationFailure); 
	}

    /********************************************************************/
    /*                                                                  */
    /*   New allocation area.                                           */
    /*                                                                  */
    /*   All memory requests are eventually sent to the new external    */
    /*   allocator.  This function can be overloaded so that memory     */
    /*   can be provided from any source.  The default is to get        */
    /*   new memory from the operating system.                          */
    /*                                                                  */
    /********************************************************************/

void *ROCKALL::NewArea( int AlignMask,int Size,bool User )
    {
	//
	//   When there is an alignment requirement greater
	//   than the natural alignment provided by the
	//   operating system we have to play various tricks
	//   to allocate a suitable block.  If not then we
	//   just do a normal allocation call.
	//
	if ( AlignMask > NaturalSize() )
		{
		REGISTER SBIT32 NewSize = (AlignMask + Size);

		//
		//   We need to allocate a block with an 
		//   alignment requirement greater than 
		//   the operating system default.  So we
		//   allocate a much larger block and
		//   release the parts we don't need.
		//
		while ( True )
			{
			REGISTER VOID *Reserved =
				(
				VirtualAlloc
					( 
					NULL,
					((DWORD) NewSize),
					MEM_RESERVE,
					PAGE_READWRITE 
					)
				);

			//
			//   Lets ensure we were able to find a suitable
			//   memory block.  If not then we exit.
			//
			if ( Reserved != NULL )
				{
				//
				//   We just want to return the parts of
				//   the block we don't need but 'NT' is  
				//   not smart enough.  So we free the  
				//   entire block.
				//
				if ( VirtualFree( Reserved,0,MEM_RELEASE ) )
					{
					REGISTER LONG Address = ((LONG) Reserved);
					REGISTER VOID *NewMemory;

					//
					//   Compute the base address of the part 
					//   of the block we really want to allocate.
					//
					Address = ((Address + AlignMask) & ~AlignMask);

					//
					//   Finally, lets reallocate the part of  
					//   the block we wanted but just released   
					//   and hope that nobody else got it before
					//   us.
					//
					NewMemory =
						(
						VirtualAlloc
							( 
							((LPVOID) Address),
							((DWORD) Size),
							(MEM_RESERVE | MEM_COMMIT),
							PAGE_READWRITE 
							)
						);

					//
					//   If it all worked we can exit.
					//
					if ( NewMemory != NULL )
						{ 
#ifdef DEBUGGING
#ifdef ENABLE_ALLOCATION_STATISTICS
						//
						//  When we are debugging output 
						//  out trace information.
						//  
						DebugPrint
							( 
							"New\t\t 0x%08x %d bytes\n",
							NewMemory,
							Size 
							);

#endif
#endif
						return ((void*) NewMemory); 
						}
					}
				else
					{ return ((void*) AllocationFailure); }

				}
			else
				{ return ((void*) AllocationFailure); }
			}
		}
	else
		{
		REGISTER VOID *NewMemory;

		//
		//   We can allocate directly from the operating 
		//   system as the default alignment requirement 
		//   is enough for this case.
		//
		NewMemory =
			(
			VirtualAlloc
				( 
				NULL,
				((DWORD) Size),
				MEM_COMMIT,
				PAGE_READWRITE
				)
			);
#ifdef DEBUGGING
#ifdef ENABLE_ALLOCATION_STATISTICS

		if ( NewMemory != NULL )
			{
			//
			//  When we are debugging output out trace
			//  information.
			//  
			DebugPrint( "New\t\t 0x%08x %d bytes\n",NewMemory,Size );
			}
#endif
#endif

		return ((void*) NewMemory);
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory reallocation.                                           */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail and exit.                        */
    /*                                                                  */
    /********************************************************************/

void *ROCKALL::Resize
		( 
		void						  *Address,
		int							  NewSize,
		int							  Move,
		int							  *Space,
		bool						  NoDelete,
		bool						  Zero
		)
    {
	TRY
		{
		//
		//   A well known practice is to try to
		//   resize a null pointer.  This is really
		//   a very poor style but we support it
		//   in any case.
		//   
		if ( Address != ((void*) AllocationFailure) )
			{
			//
			//   We verify that the parameters look
			//   reasonable and the heap is not corrupt
			//   and then try to resize the supplied 
			//   allocation.
			//
			if ( (Available()) && (NewSize >= 0) )
				{
				return 
					(
					Heap -> Resize
						( 
						((VOID*) Address),
						((SBIT32) ((NewSize > 0) ? NewSize : 1)),
						((SBIT32) Move),
						((SBIT32*) Space),
						((BOOLEAN) NoDelete),
						((BOOLEAN) Zero)
						)
					);
				}
			}
		else
			{ return (New( NewSize,Space,Zero )); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING
	catch ( TEXT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return ((void*) AllocationFailure); 
	}

    /********************************************************************/
    /*                                                                  */
    /*   Special memory allocation.                                     */
    /*                                                                  */
    /*   We sometimes need to allocate some memory from the internal    */
    /*   memory allocator which lives for the lifetime of the heap.     */
    /*                                                                  */
    /********************************************************************/

void *ROCKALL::SpecialNew( int Size )
    {
	TRY
		{ 
		//
		//   We verify that the parameters look
		//   reasonable and the heap is not corrupt
		//   and then try to create the requested 
		//   allocation.
		//
		if ( (Available()) && (Size > 0) )
			{ return (Heap -> SpecialNew( ((SBIT32) Size) )); }
		} 
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING
	catch ( TEXT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return ((void*) AllocationFailure); 
	}

    /********************************************************************/
    /*                                                                  */
    /*   Truncate the heap.                                             */
    /*                                                                  */
    /*   We need to truncate the heap.  This is pretty much a null      */
    /*   call as we do this as we go along anyway.  The only thing we   */
    /*   can do is free any space the user suggested keeping earlier.   */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL::Truncate( int MaxFreeSpace )
    {
	TRY
		{
		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{ return (Heap -> Truncate( (SBIT32) MaxFreeSpace )); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( TEXT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Release all the heap locks.                                    */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail and exit.                        */
    /*                                                                  */
    /********************************************************************/

void ROCKALL::UnlockAll( VOID )
	{
	TRY
		{
		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{ Heap -> UnlockAll(); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( TEXT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Verify a memory allocation details.                            */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail the call appropriately.          */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL::Check( void *Address,int *Space )
    {
	TRY
		{
		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{
			return
				(
				(Address == ((void*) AllocationFailure)) 
					||
				(Heap -> Check( ((VOID*) Address),((SBIT32*) Space) ))
				);
			}
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( TEXT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Walk the heap.                                                 */
    /*                                                                  */
    /*   We have been asked to walk the heap.  It is hard to know       */
    /*   why anybody might want to do this given the rest of the        */
    /*   functionality available.  Nonetheless, we just do what is      */
    /*   required to keep everyone happy.                               */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL::Walk( bool *Active,void **Address,int *Space )
    {
	TRY
		{

		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{
			AUTO BOOLEAN NewActive;

			//
			//   Walk the active heap.
			//
			if
					(
					Heap -> Walk
						( 
						((BOOLEAN*) & NewActive),
						((VOID**) Address),
						((SBIT32*) Space) 
						)
					)
				{
				(*Active) = (NewActive != False);

				return true;
				}
			}
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( TEXT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the current heap.                                      */
    /*                                                                  */
    /********************************************************************/

ROCKALL::~ROCKALL( void )
	{
	TRY
		{
		//
		//   We are about to destroy a heap but before we
		//   start we make sure that the heap is not corrupt
		//   and seems to be in reasonable shape.  If not we 
		//   leave it alone to avoid possible trouble.
		//
		if ( (Available()) && (NumberOfCaches > 0) && (TotalSize > 0) )
			{
			REGISTER SBIT32 Count;

			//
			//   Execute the heap destructor.
			//
			PLACEMENT_DELETE( Heap,HEAP );

			//
			//   Execute the new page destructor.
			//
			PLACEMENT_DELETE( NewPage,NEW_PAGE );

			//
			//   Execute the find hash table destructor.
			//
			if ( GlobalDelete )
				{
				//
				//   We only delete the global find hash 
				//   table if the reference count is zero.
				//
				Spinlock.ClaimLock();

				if ( (-- ReferenceCount) == 0 )
					{ PLACEMENT_DELETE( Find,FIND ); }

				Spinlock.ReleaseLock();
				}
			else
				{ PLACEMENT_DELETE( Find,FIND ); }


			//
			//   Execute the cache destructors.
			//
			for ( Count=0;Count < NumberOfCaches;Count ++ )
				{ PLACEMENT_DELETE( & Caches[ Count ],CACHE ); }

			//
			//   Deallocate the heap structures.
			//
			DeleteArea( ((VOID*) Caches),TotalSize,False );

			//
			//   Finally, zero any remaining members.
			//   We really do not need to do this but
			//   just want to be sure that any following 
			//   calls will clearly fail.
			//
			TotalSize = 0;
			NumberOfCaches = 0;
			GuardWord = 0;
			GlobalDelete = False;

			NewPage = NULL;
			Heap = NULL;
			Find = NULL;
			Caches = NULL;
			Array = NULL;
			}
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( TEXT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\interface\interfacepch.hpp ===
#ifndef _ROCKALL_PCH_HPP_
#define _ROCKALL_PCH_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#ifndef DISABLE_PRECOMPILED_HEADERS
#include "HeapPCH.hpp"
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\library\assembly.hpp ===
#ifndef _ASSEMBLY_HPP_
#define _ASSEMBLY_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The assembly constants indicate the location of the thread     */
    /*   local store.                                                   */
    /*                                                                  */
    /********************************************************************/

#define PcTeb                         0x18
#define IDTeb                         0x24

#ifdef WINDOWS_95
CONST SBIT32 TebSlot				  = 0x88;
#else
CONST SBIT32 TebSlot				  = 0xE10;
#endif

#ifndef ASSEMBLY_PREFETCH_SUPPORT
#define prefetcht0					  __asm _emit 0x0f __asm _emit 0x18 __asm _emit 0x08
#define prefetcht1					  __asm _emit 0x0f __asm _emit 0x18 __asm _emit 0x10
#define prefetcht2					  __asm _emit 0x0f __asm _emit 0x18 __asm _emit 0x18
#define prefetchnta					  __asm _emit 0x0f __asm _emit 0x18 __asm _emit 0x00
#endif

#pragma warning( disable : 4035 )

    /********************************************************************/
    /*                                                                  */
    /*   Assembly language for ultra high performance.                  */
    /*                                                                  */
    /*   We have coded a few functions in assembly language for         */
    /*   ultra high performance.                                        */
    /*                                                                  */
    /********************************************************************/

class ASSEMBLY
    {
    public:
        //
        //   Public inline functions.
        //
		ASSEMBLY( VOID )
			{ /* void */ }

		STATIC INLINE SBIT32 AtomicAdd
				( 
				VOLATILE SBIT32		  *Address,
				SBIT32				  Value 
				)
			{
#ifdef ASSEMBLY_X86
			__asm
				{
				mov		ecx,Address					// Load the address.
				mov		eax,Value					// Load the value.
				lock	xadd dword ptr[ecx],eax		// Increment the value.
				}
#else
			return 
				(
				(SBIT32) InterlockedExchangeAdd
					( 
					((LPLONG) Address),
					((LONG) Value) 
					)
				);
#endif
			}

		STATIC INLINE SBIT32 AtomicCompareExchange
				( 
				VOLATILE SBIT32		  *Address,
				SBIT32				  NewValue,
				SBIT32				  Value 
				)
			{
#ifdef ASSEMBLY_X86
			__asm
				{
				mov		ecx,Address					// Load the address.
				mov		edx,NewValue				// Load the new value.
				mov		eax,Value					// Load the value.
				lock	cmpxchg	dword ptr[ecx],edx	// Update the value.
				}
#else
			return 
				(
				(SBIT32) InterlockedCompareExchange
					( 
					((VOID**) Address),
					((VOID*) NewValue),
					((VOID*) Value)
					)
				);
#endif
			}
#ifdef ASSEMBLY_X86

		STATIC INLINE SBIT64 AtomicCompareExchange64
				( 
				VOLATILE SBIT64		  *Address,
				SBIT64				  NewValue,
				SBIT64				  Value 
				)
			{
			__asm
				{
				mov		esi, Address				// Load the adrress.
				mov		ebx, dword ptr NewValue[0]	// Load the new value.
				mov		ecx, dword ptr NewValue[4]	// Load the new value.
				mov		eax, dword ptr Value[0]		// Load the value.
				mov		edx, dword ptr Value[4]		// Load the value.
				lock	cmpxchg8b [esi]				// Update the value.
				}
			}
#endif

		STATIC INLINE SBIT32 AtomicDecrement( VOLATILE SBIT32 *Address )
			{
#ifdef ASSEMBLY_X86
			__asm
				{
				mov		ecx,Address					// Load the Address.
				mov		eax,-1						// Load constant.
				lock	xadd dword ptr[ecx],eax		// Decrement value.
				dec		eax							// Correct result.
				}
#else
			return ((SBIT32) InterlockedDecrement( ((LONG*) Address) ));
#endif
			}

		STATIC INLINE SBIT32 AtomicExchange
				( 
				VOLATILE SBIT32		  *Address,
				SBIT32				  NewValue 
				)
			{
#ifdef ASSEMBLY_X86
			__asm
				{
				mov		ecx,Address					// Load the Address.
				mov		eax,NewValue				// Load the value.
				lock	xchg dword ptr[ecx],eax		// Exchange new value.
				}
#else
			return 
				(
				(SBIT32) InterlockedExchange
					( 
					((LONG*) Address),
					((LONG) NewValue) 
					)
				);
#endif
			}

		STATIC INLINE SBIT32 AtomicIncrement( VOLATILE SBIT32 *Address )
			{
#ifdef ASSEMBLY_X86
			__asm
				{
				mov		ecx,Address					// Load the Address.
				mov		eax,1						// Load constant.
				lock	xadd dword ptr[ecx],eax		// Increment value.
				inc		eax							// Correct result.
				}
#else
			return ((SBIT32) InterlockedIncrement( ((LONG*) Address) ));
#endif
			}

		STATIC INLINE SBIT32 GetThreadId( VOID )
			{
#ifdef ASSEMBLY_X86
#ifdef ENABLE_NON_STANDARD_ASSEMBLY
			__asm
				{
				mov		eax,fs:[PcTeb]				// Load TEB base address.
				mov		eax,dword ptr[eax+IDTeb]	// Load thread ID.
				}
#else
			return ((SBIT32) GetCurrentThreadId());
#endif
#else
			return ((SBIT32) GetCurrentThreadId());
#endif
			}

		STATIC INLINE VOID PrefetchL1( VOID *Address )
			{
#ifdef ASSEMBLY_X86
			__asm
				{
				mov			eax,Address				// Load Address.
#ifdef ASSEMBLY_PREFETCH_SUPPORT
				prefetcht0	[eax]					// Prefetch into the L1.
#else
				prefetcht0							// Prefetch into the L1.
#endif
				}
#endif
			}

		STATIC INLINE VOID PrefetchL2( VOID *Address )
			{
#ifdef ASSEMBLY_X86
			__asm
				{
				mov			eax,Address				// Load Address.
#ifdef ASSEMBLY_PREFETCH_SUPPORT
				prefetcht1	[eax]					// Prefetch into the L2.
#else
				prefetcht1							// Prefetch into the L2.
#endif
				}
#endif
			}

		STATIC INLINE VOID PrefetchL3( VOID *Address )
			{
#ifdef ASSEMBLY_X86
			__asm
				{
				mov			eax,Address				// Load Address.
#ifdef ASSEMBLY_PREFETCH_SUPPORT
				prefetcht2	[eax]					// Prefetch into the L3.
#else
				prefetcht2							// Prefetch into the L3.
#endif
				}
#endif
			}

		STATIC INLINE VOID PrefetchNta( VOID *Address )
			{
#ifdef ASSEMBLY_X86
			__asm
				{
				mov			eax,Address				// Load Address.
#ifdef ASSEMBLY_PREFETCH_SUPPORT
				prefetchnta	[eax]					// Prefetch into the L1.
#else
				prefetchnta							// Prefetch into the L1.
#endif
				}
#endif
			}

		STATIC INLINE SBIT32 GetFeatureMask( VOID )
			{
#ifdef ASSEMBLY_X86
			__asm
				{
				mov		eax,1						// Load CPUID feature ID.
				cpuid								// Get the CPU infomation.
				mov		eax,edx						// Feature mask return.
				}
#else
			return 0;
#endif
			}

#ifdef ASSEMBLY_X86
#ifdef ENABLE_NON_STANDARD_ASSEMBLY
		STATIC INLINE VOID *GetTlsAddress( SBIT32 TlsOffset )
			{
			__asm
				{
				mov		eax,TlsOffset				// Load TLS offset.
				add		eax,fs:[PcTeb]				// Add TEB base address.
				}
			}
#endif
#endif

		STATIC INLINE VOID *GetTlsValue( SBIT32 TlsIndex,SBIT32 TlsOffset )
			{
#ifdef ASSEMBLY_X86
#ifdef ENABLE_NON_STANDARD_ASSEMBLY
			__asm
				{
				mov		eax,TlsOffset				// Load TLS offset.
				add		eax,fs:[PcTeb]				// Add TEB base address.
				mov		eax,[eax]					// Load TLS value.
				}
#else
			return (TlsGetValue( ((DWORD) TlsIndex) ));
#endif
#else
			return (TlsGetValue( ((DWORD) TlsIndex) ));
#endif
			}

		STATIC INLINE VOID SetTlsValue
				( 
				SBIT32				  TlsIndex,
				SBIT32				  TlsOffset,
				VOID				  *NewPointer 
				)
			{
#ifdef ASSEMBLY_X86
#ifdef ENABLE_NON_STANDARD_ASSEMBLY
			__asm
				{
				mov		eax,TlsOffset				// Load TLS offset.
				add		eax,fs:[PcTeb]				// Add TEB base address.
				mov		edx,NewPointer				// Load new TLS value.
				mov		[eax],edx					// Store new TLS value.
				}
#else
			(VOID) TlsSetValue( ((DWORD) TlsIndex),NewPointer );
#endif
#else
			(VOID) TlsSetValue( ((DWORD) TlsIndex),NewPointer );
#endif
			}

		~ASSEMBLY( VOID )
			{ /* void */ }

	private:
        //
        //   Disabled operations.
        //
        ASSEMBLY( CONST ASSEMBLY & Copy );

        VOID operator=( CONST ASSEMBLY & Copy );
    };

#pragma warning( default : 4035 )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\library\align.hpp ===
#ifndef _ALIGN_HPP_
#define _ALIGN_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "New.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Alignment of structures to cache line boundaries.              */
    /*                                                                  */
    /*   This class aligns data structures to cache line boundaries.    */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> class ALIGN
    {
        //
        //   Private data.
        //
        TYPE                          *Aligned;
        CHAR                          *Allocated;

    public:
        //
        //   Public functions.
        //
        ALIGN( VOID );

        ~ALIGN( VOID );

		//
		//   Public inline functions.
		//
        INLINE TYPE *operator&( VOID )
			{ return Aligned; }

	private:
        //
        //   Disabled operations.
        //
        ALIGN( CONST ALIGN & Copy );

        VOID operator=( CONST ALIGN & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Ceate a memory allocation and initialize it.  This call is     */
    /*   not thread safe and should only be made in a single thread     */
    /*   environment.                                                   */        
    /*                                                                  */
    /********************************************************************/

template <class TYPE> ALIGN<TYPE>::ALIGN( VOID )
    {
    REGISTER CHAR *Address;

	//
	//   Allocate space for the data structure.
	//
	Allocated = new CHAR[ (CacheLineSize + sizeof(TYPE)) ];

	//
	//   Call the constructor to initialize the structure.
	//
    Address = ((CHAR*) ((((LONG) Allocated) + CacheLineMask) & ~CacheLineMask));

    Aligned = PLACEMENT_NEW( Address,TYPE );
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the memory allocation.  This call is not thread safe   */
    /*   and should only be made in a single thread environment.        */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> ALIGN<TYPE>::~ALIGN( VOID )
    { 
	//
	//   Call the destructor for the allocated type.
	//
    PLACEMENT_DELETE( Aligned,TYPE );

	//
	//   Delete the data structure.
	//
	delete [] Allocated; 
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\library\common.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "Common.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Convert a divisor to a shift.                                  */
    /*                                                                  */
    /*   We know that we can convert any divide operation into a        */
    /*   shift when the divisor is a power of two.  This function       */
    /*   figures out whether we can do this and what the how far        */
    /*   we would need to shift.                               .        */
    /*                                                                  */
    /********************************************************************/

BOOLEAN COMMON::ConvertDivideToShift( SBIT32 Divisor,SBIT32 *Shift )
	{
	if ( Divisor > 0 )
		{
		REGISTER SBIT32 Count;

		for ( Count=0;(Divisor & 1) == 0;Count ++ )
			{ Divisor >>= 1; }

		if (Divisor == 1)
			{
			(*Shift) = Count;

			return True;
			}
		}

	return False;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Force to the next power of two.                                */
    /*                                                                  */
    /*   We know that we can do certain optimizations if certain        */
    /*   values are a power of two.  Here we force the issue by         */
    /*   rounding up the value to the next power of two.                */
    /*                                                                  */
    /********************************************************************/

SBIT32 COMMON::ForceToPowerOfTwo( SBIT32 Value )
	{
	//
	//   We ensure the value is positive if not we 
	//   simply return the identity value.
	//
	if ( Value > 1 )
		{
		//
		//   We only have to compute the next power of
		//   two if the value is not already a power
		//   of two.
		//
		if ( ! PowerOfTwo( Value ) )
			{
			REGISTER SBIT32 Count;

			for ( Count=0;Value > 0;Count ++ )
				{ Value >>= 1; }

			return (1 << Count);
			}
		else
			{ return Value; }
		}
	else
		{ return 1; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Convert to lower case.                                         */
    /*                                                                  */
    /*   Convert all characters to lower case until we find the         */
    /*   end of the string.                                             */
    /*                                                                  */
    /********************************************************************/

CHAR *COMMON::LowerCase( CHAR *Text )
	{
	REGISTER CHAR *Current = Text;

	for ( /* void */;(*Current) != '\0';Current ++ )
		{
		if ( isupper( (*Current) ) )
			{ (*Current) = ((CHAR) tolower( (*Current) )); }
		}

	return Text;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Convert to lower case.                                         */
    /*                                                                  */
    /*   Convert a fixed number of characters to lower case.            */
    /*                                                                  */
    /********************************************************************/

CHAR *COMMON::LowerCase( CHAR *Text,SBIT32 Size )
	{
	REGISTER CHAR *Current = Text;

	for ( /* void */;Size > 0;Current ++, Size -- )
		{
		if ( isupper( (*Current) ) )
			{ (*Current) = ((CHAR) tolower( (*Current) )); }
		}

	return Text;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Ensure value is a power of two.                                */
    /*                                                                  */
    /*   We need to ensure that certain values are an exact power       */
    /*   of two.  If this is true then the value will be positive       */
    /*   and only 1 bit will be set.  So we shift right until we        */
    /*   find the first bit on and then the value should be one.        */
    /*                                                                  */
    /********************************************************************/

BOOLEAN COMMON::PowerOfTwo( SBIT32 Value )
	{ return ((Value & (Value-1)) == 0); }
#ifndef DISABLE_ATOMIC_FLAGS

    /********************************************************************/
    /*                                                                  */
    /*   Atomically set flags.                                          */
    /*                                                                  */
    /*   We need to atomically set some flags to prevent them being     */
    /*   corrupted by concurrent updates.                               */
    /*                                                                  */
    /********************************************************************/

VOID COMMON::SetFlags( SBIT32 *CurrentFlags,SBIT32 NewFlags )
	{
	REGISTER SBIT32 StartFlags;
	REGISTER SBIT32 ResultFlags;

	do
		{ 
		StartFlags = (*CurrentFlags);
		
		ResultFlags =
			(
			AtomicCompareExchange
				(
				CurrentFlags,
				(StartFlags |= NewFlags), 
				StartFlags
				)
			);
		}
	while ( StartFlags != ResultFlags );
	}

    /********************************************************************/
    /*                                                                  */
    /*   Atomically unset flags.                                        */
    /*                                                                  */
    /*   We need to atomically unset some flags to prevent them being   */
    /*   corrupted by concurrent updates.                               */
    /*                                                                  */
    /********************************************************************/

VOID COMMON::UnsetFlags( SBIT32 *CurrentFlags,SBIT32 NewFlags )
	{
	REGISTER SBIT32 StartFlags;
	REGISTER SBIT32 ResultFlags;

	do
		{ 
		StartFlags = (*CurrentFlags);
		
		ResultFlags =
			(
			AtomicCompareExchange
				(
				CurrentFlags,
				(StartFlags &= ~NewFlags), 
				StartFlags
				)
			);
		}
	while ( StartFlags != ResultFlags );
	}

    /********************************************************************/
    /*                                                                  */
    /*   Convert to upper case.                                         */
    /*                                                                  */
    /*   Convert all characters to upper case until we find the         */
    /*   end of the string.                                             */
    /*                                                                  */
    /********************************************************************/

CHAR *COMMON::UpperCase( CHAR *Text )
	{
	REGISTER CHAR *Current = Text;

	for ( /* void */;(*Current) != '\0';Current ++ )
		{
		if ( islower( (*Current) ) )
			{ (*Current) = ((CHAR) toupper( (*Current) )); }
		}

	return Text;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Convert to upper case.                                         */
    /*                                                                  */
    /*   Convert a fixed number of characters to upper case.            */
    /*                                                                  */
    /********************************************************************/

CHAR *COMMON::UpperCase( CHAR *Text,SBIT32 Size )
	{
	REGISTER CHAR *Current = Text;

	for ( /* void */;Size > 0;Current ++, Size -- )
		{
		if ( islower( (*Current) ) )
			{ (*Current) = ((CHAR) toupper( (*Current) )); }
		}

	return Text;
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\interface\rockall.hpp ===
#ifndef _ROCKALL_HPP_
#define _ROCKALL_HPP_

#ifdef ROCKALL_DIRECTUSER
    //
    // DirectUser does not use virtuals for the API
    //

#define RAPI
#else
#define RAPI virtual
#endif


//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include <stddef.h>

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation constants.                                   */
    /*                                                                  */
    /*   The memory allocation constants are denote special situations  */
    /*   where optimizations are possible or failures have cccured.     */
    /*                                                                  */
    /********************************************************************/

const int AllocationFailure			  = 0;
const int GuardValue				  = 0xDeadBeef;
const int NoSize					  = -1;

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class CACHE;
class FIND;
class HEAP;
class NEW_PAGE;

    /********************************************************************/
    /*                                                                  */
    /*   Linkage to the DLL.                                            */
    /*                                                                  */
    /*   We need to compile the class specification slightly            */
    /*   differently if we are creating the heap DLL.                   */
    /*                                                                  */
    /********************************************************************/

#ifdef COMPILING_ROCKALL_DLL
#define ROCKALL_DLL_LINKAGE __declspec(dllexport)
#else
#ifdef NO_DEFAULT_HEAP
#define ROCKALL_DLL_LINKAGE
#else
#define ROCKALL_DLL_LINKAGE __declspec(dllimport)
#endif
#endif

    /********************************************************************/
    /*                                                                  */
    /*   The memory allocation interface.                               */
    /*                                                                  */
    /*   The memory allocator can be configured in a wide variety       */
    /*   of ways to closely match the needs of specific programs.       */
    /*   The interface outlined here can be overloaded to support       */
    /*   whatever customization is necessary.                           */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_DLL_LINKAGE ROCKALL
    {
    public:
		//
		//   Public types.
		//
		//   A heap is constructed of a collection of 
		//   fixed sized buckets each with an associated
		//   cache.  The details of these buckets are
		//   supplied to the heap using the following
		//   structure.
		//
		typedef struct
			{
			int						  AllocationSize;
			int						  CacheSize;
			int						  ChunkSize;
			int						  PageSize;
			}
		CACHE_DETAILS;

		//
		//   Public data.
		//
		//   The internals linkages in a heap are built
		//   dynamically during the execution of a heaps
		//   constructor.  The member that follow relate
		//   to key internal classes.
		//
		CACHE						  **Array;
		CACHE						  *Caches;
		FIND						  *Find;
		HEAP						  *Heap;
		NEW_PAGE					  *NewPage;

		//
		//   A heap constructor is required to preserve 
		//   a small amount of information for the heap
		//   destructor.
		//
		bool						  GlobalDelete;
		int							  GuardWord;
		int							  NumberOfCaches;
		int							  TotalSize;

        //
        //   Public functions.
		//
		//   A heaps public interface consists of a number
		//   of groups of related APIs.
        //
		ROCKALL( void );

        ROCKALL
			(
			CACHE_DETAILS			  *Caches1,
			CACHE_DETAILS			  *Caches2,
			int						  FindCacheSize,
			int						  FindCacheThreshold,
			int						  FindSize,
			int						  MaxFreeSpace,
			int						  *NewPageSizes,
			bool					  Recycle,
			bool					  SingleImage,
			int						  Stride1,
			int						  Stride2,
			bool					  ThreadSafe 
			);

		//
		//   Manipulate allocations.
		//
		//   The first group of functions manipulate 
		//   single or small arrays of allocations. 
		//
		RAPI bool Delete
			( 
			void					  *Address,
			int						  Size = NoSize 
			);

		RAPI bool Details
			( 
			void					  *Address,
			int						  *Space = NULL 
			);

		RAPI bool KnownArea( void *Address );

		RAPI bool MultipleDelete
			( 
			int						  Actual,
			void					  *Array[],
			int						  Size = NoSize
			);

		RAPI bool MultipleNew
			( 
			int						  *Actual,
			void					  *Array[],
			int						  Requested,
			int						  Size,
			int						  *Space = NULL,
			bool					  Zero = false
			);

		RAPI void *New
			( 
			int						  Size,
			int						  *Space = NULL,
			bool					  Zero = false
			);

		RAPI void *Resize
			( 
			void					  *Address,
			int						  NewSize,
			int						  Move = -64,
			int						  *Space = NULL,
			bool					  NoDelete = false,
			bool					  Zero = false
			);

		RAPI bool Check
			( 
			void					  *Address = NULL,
			int						  *Space = NULL 
			);

		//
		//   Manipulate the heap.
		//
		//   The second group of functions act upon a heap
		//   as a whole.
		//
		RAPI void DeleteAll( bool Recycle = true );

		RAPI void LockAll( void );

		RAPI bool Truncate( int MaxFreeSpace = 0 );

		RAPI void UnlockAll( void );

		RAPI bool Walk
			(
			bool					  *Active,
			void					  **Address,
			int						  *Space
			);

		//
		//   Low level heap interface.
		//
		//   The third group of functions are called by the
		//   heap to aquire or release large blocks of memory.
		//   These functions can be overloaded to enable the
		//   heap work in constrained environments.
		//
		RAPI void DeleteArea( void *Memory,int Size,bool User );

		RAPI int NaturalSize( void );

		RAPI void *NewArea( int AlignMask,int Size,bool User );

        RAPI ~ROCKALL( void );

		//
		//   Public inline functions.
		//
		inline bool Available( void )
			{ return (GuardWord == GuardValue); }

		inline bool Corrupt( void )
			{ return (GuardWord != GuardValue); }

	protected:
		//
		//   Protected inline functions.
		//
		//   A heap needs to compute the size of certain
		//   user supplied structures.  This task is 
		//   performed by the following function.
		//
		int ComputeSize( char *Array,int Stride );

		//
		//   We would like to allow access to the internal
		//   heap allocation function from classes that 
		//   inherit from the heap.  The memory supplied by
		//   this function survies all heap operations and
		//   is cleaned up as poart of heap deletion.
		//
		RAPI void *SpecialNew( int Size );

	private:
        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        ROCKALL( const ROCKALL & Copy );

        void operator=( const ROCKALL & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\library\common.hpp ===
#ifndef _COMMON_HPP_
#define _COMMON_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Assembly.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   A collection of common functions.                              */
    /*                                                                  */
    /*   This class contains common functions that are needed           */
    /*   throughout the application.                                    */
    /*                                                                  */
    /********************************************************************/

class COMMON : public ASSEMBLY
    {
    public:
        //
        //   Public functions.
        //
		COMMON( VOID )
			{ /* void */ }

		STATIC BOOLEAN ConvertDivideToShift( SBIT32 Divisor,SBIT32 *Shift );

		STATIC SBIT32 ForceToPowerOfTwo( SBIT32 Value );

		STATIC CHAR *LowerCase( CHAR *Text );

		STATIC CHAR *LowerCase( CHAR *Text,SBIT32 Size );

		STATIC BOOLEAN PowerOfTwo( SBIT32 Value );
#ifndef DISABLE_ATOMIC_FLAGS

		STATIC VOID SetFlags( SBIT32 *CurrentFlags,SBIT32 NewFlags );

		STATIC VOID UnsetFlags( SBIT32 *CurrentFlags,SBIT32 NewFlags );

		STATIC CHAR *UpperCase( CHAR *Text );

		STATIC CHAR *UpperCase( CHAR *Text,SBIT32 Size );
#endif

		~COMMON( VOID )
			{ /* void */ }

	private:
        //
        //   Disabled operations.
        //
        COMMON( CONST COMMON & Copy );

        VOID operator=( CONST COMMON & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\library\environment.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "Environment.hpp"
#include "Spinlock.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The enviroment class slaves various information to speed       */
    /*   up access to it.                                               */
    /*                                                                  */
    /********************************************************************/

CONST SBIT16 EnvironmentCacheSize	  = 16;
CONST SBIT32 SizeOfName				  = 256;

    /********************************************************************/
    /*                                                                  */
    /*   Static member initialization.                                  */
    /*                                                                  */
    /*   Static member initialization sets the initial value for all    */
    /*   static members.                                                */
    /*                                                                  */
    /********************************************************************/

SBIT32 ENVIRONMENT::Activations = 0;
SBIT32 ENVIRONMENT::AllocationGranularity = 0;
SBIT16 ENVIRONMENT::NumberOfProcessors = 0;
SBIT32 ENVIRONMENT::SizeOfMemory = 0;
SBIT32 ENVIRONMENT::SizeOfPage = 0;
#ifndef DISABLE_ENVIRONMENT_VARIABLES

CHAR *ENVIRONMENT::ProgramName = NULL;
CHAR *ENVIRONMENT::ProgramPath = NULL;
SBIT32 ENVIRONMENT::MaxVariables = 0;
SBIT32 ENVIRONMENT::VariablesUsed = 0;
ENVIRONMENT::VARIABLE *ENVIRONMENT::Variables = NULL;
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new environment and initialize it if needed.  This    */
    /*   call is not thread safe and should only be made in a single    */
    /*   thread environment.                                            */
    /*                                                                  */
    /********************************************************************/

ENVIRONMENT::ENVIRONMENT( VOID )
    {
    if ( AtomicIncrement( & Activations ) == 1 )
        {
#ifndef DISABLE_ENVIRONMENT_VARIABLES
		AUTO CHAR ProgramFullName[ SizeOfName ];
#endif
		AUTO MEMORYSTATUS MemoryStatus;
		AUTO SYSTEM_INFO SystemInformation;

		//
		//   Initialize the class members to reasonable default values.
		//
		GetSystemInfo( & SystemInformation );

		GlobalMemoryStatus( & MemoryStatus );

		AllocationGranularity = 
			((SBIT32) SystemInformation.dwAllocationGranularity);
		NumberOfProcessors = 
			((SBIT16) SystemInformation.dwNumberOfProcessors);
		SizeOfMemory = 
			((SBIT32) MemoryStatus.dwTotalPhys);
		SizeOfPage = 
			((SBIT32) SystemInformation.dwPageSize);
#ifndef DISABLE_ENVIRONMENT_VARIABLES

		//
		//   Slave interesting values like the program name and path variable.
		//
		ProgramName = NULL;
		ProgramPath = NULL;

		MaxVariables = 0;
		VariablesUsed = 0;
		Variables = NULL;

		//
		//   Get the complete file name for the current program.
		//
		if ( GetModuleFileName( NULL,ProgramFullName,SizeOfName ) > 0 )
			{
			REGISTER SBIT16 Count = (SBIT16) strlen( (char*) ProgramFullName );
			REGISTER CHAR *Characters = & ProgramFullName[ Count ];

			//
			//   Scan backwards looking for the first directory seperator.  
			//   There is guaranteed to be at least one.
			//
			for 
				( 
				/* void */;
				((Count > 0) && ((*Characters) != (*DirectorySeperator())));
				Count --, Characters -- 
				);

			(*(Characters ++)) = '\0';

			//
			//   Allocate space for the directory path and copy the  
			//   path into the newly allocated area.
			//
			ProgramPath = new CHAR [ (strlen( ((char*) ProgramFullName) )+1) ];

			if ( ProgramPath != NULL )
				{
				(VOID) strcpy
					( 
					((char*) ProgramPath),
					((char*) ProgramFullName)
					); 
				}

			//
			//   Scan the program name backwards looking for a '.'.
			//
			for 
				( 
				Count = (SBIT16) strlen( (char*) Characters );
				((Count > 0) && (Characters[ Count ] != '.'));
				Count -- 
				);

			//
			//   Remove any trailing suffix from the program name 
			//   (i.e. '*.EXE').
			//
			if ( Count > 0 )
				{ Characters[ Count ] = '\0'; }

			//
			//   Allocate space for the program name and copy the name 
			//   into the newly allocated area.
			//
			ProgramName = new CHAR [ (strlen( ((char*) Characters) )+1) ];

			if ( ProgramName != NULL )
				{
				(void) strcpy
					( 
					((char*) ProgramName),
					((char*) Characters) 
					);
				}
			}
#endif
		}
	}
#ifndef DISABLE_ENVIRONMENT_VARIABLES

    /********************************************************************/
    /*                                                                  */
    /*   Read an environment variable.                                  */
    /*                                                                  */
    /*   When we read an environment value we want to make sure that    */
    /*   it never changes and gets slaved in memory.  This routine      */
    /*   implements this functionality.                                 */
    /*                                                                  */
    /********************************************************************/

CONST CHAR *ENVIRONMENT::ReadEnvironmentVariable( CONST CHAR *Name )
	{
	if ( Activations > 0 )
		{
		REGISTER SBIT32 Count;
		REGISTER SBIT32 SizeOfName = (SBIT32) strlen( (char*) Name );
		REGISTER VARIABLE *Variable;
		STATIC SPINLOCK Spinlock;

		//
		//   The environment variables can only be scanned by one CPU at 
		//   a time because a second CPU might reallocate the storage 
		//   and cause the first CPU to fail.
		//
		Spinlock.ClaimLock();

		//
		//   Examine all existing environment variables looking for a 
		//   match. If a match is found return it to the caller.
		//
		for 
				( 
				Count = VariablesUsed, Variable = Variables;
				Count > 0; 
				Count --, Variable ++ 
				)
			{
			if 
					( 
					(SizeOfName == Variable -> SizeOfName) 
						&& 
					(strcmp( (char*) Name,(char*) Variable -> Name ) == 0) 
					)
				{
				Spinlock.ReleaseLock();

				return (Variable -> Value);
				}
			}

		//
		//  If we have filled up our array so we need to make it bigger.
		//  So lets check for this now.
		//
		if ( VariablesUsed >= MaxVariables )
			{
			REGISTER VARIABLE *PreviousAllocation = Variables;

			if ( MaxVariables > 0 )
				{
				Variables = 
					(
					(VARIABLE*) realloc
						( 
						(VOID*) Variables,
						((MaxVariables *= ExpandStore) * sizeof(VARIABLE)) 
						)
					);
				}
			else
				{ Variables = new VARIABLE [ EnvironmentCacheSize ]; }

			//
			//   Lets make sure we were successful.  If not we restore 
			//   the previous pointer as it is still valid.
			//
			if ( Variables == NULL )
				{
				Variables = PreviousAllocation;

				Failure( "Expand memory in ReadEnvironmentVariable" );
				}
			}

		//
		//  We know that we have enough memory to allocate another element and 
		//  that we are the only CPU in this section of code so just add the 
		//  new variable.
		//
		Variable = & Variables[ VariablesUsed ++ ];

		Variable -> SizeOfName = 
			(SBIT32) strlen( (char*) Name );
		Variable -> SizeOfValue = 
			(SBIT32) GetEnvironmentVariable( (char*) Name,"",0 );

		Variable -> Name = new CHAR [ (Variable -> SizeOfName + 1) ];
		(VOID) strcpy( (char*) Variable -> Name,(char*) Name );

		if ( Variable -> SizeOfValue > 0 )
			{
			Variable -> Value = new CHAR [ (Variable -> SizeOfValue + 1) ];

			(VOID) GetEnvironmentVariable
				( 
				(char*) Name,
				(char*) Variable -> Value,
				(int) (Variable -> SizeOfValue + 1)
				);
			}
		else
			{ Variable -> Value = NULL; }

		Spinlock.ReleaseLock();

		return (Variable -> Value);
		}
	else
		{ return NULL; }
	}
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory an environment.  This call is not thread safe and      */
    /*   should only be made in a single thread environment.            */
    /*                                                                  */
    /********************************************************************/

ENVIRONMENT::~ENVIRONMENT( VOID )
	{
    if ( AtomicDecrement( & Activations ) == 0 )
		{
#ifndef DISABLE_ENVIRONMENT_VARIABLES
		REGISTER SBIT32 Count;

		//
		//   Delete all of the environment variable names
		//   and values.
		//
		for ( Count = 0;Count < VariablesUsed;Count ++ )
			{
			REGISTER VARIABLE *Variable = & Variables[ Count ];

			delete [] Variable -> Name;

			if ( Variable -> Value != NULL )
				{ delete [] Variable -> Value; }
			}


		//
		//   Delete the environment array.
		//
		delete [] Variables;
		Variables = NULL;

		//
		//   Delete the program name and path.
		//
		if ( ProgramPath != NULL )
			{
			delete [] ProgramPath;
			ProgramPath = NULL;
			}

		if ( ProgramName != NULL )
			{
			delete [] ProgramName;
			ProgramName = NULL;
			}
#endif
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\library\features.hpp ===
#ifndef _FEATURES_HPP_
#define _FEATURES_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Standard.hpp"
#include "System.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Active project list.	 							            */
    /*                                                                  */
    /*   The active project list contains all of the projects that      */
    /*   are currently selected.                                        */
    /*                                                                  */
    /********************************************************************/

#define ROCKALL_II					  1

    /********************************************************************/
    /*                                                                  */
    /*   Active fetaure lists.	 							            */
    /*                                                                  */
    /*   The active features list contain all of the features that      */
    /*   are currently selected for each project.                       */
    /*                                                                  */
    /********************************************************************/

#ifdef PIPELINE_SERVER
#ifdef DEBUGGING
#define ENABLE_DEBUG_FILE             1
#define ENABLE_LOCK_STATISTICS		  1
#define PRINT_ACTIVE_PACKETS		  1
#endif
#define ENABLE_NON_STANDARD_ASSEMBLY  1
#endif

#ifdef ROCKALL_II
#ifdef DEBUGGING
#define ENABLE_DEBUG_FILE             1
#define ENABLE_HEAP_STATISTICS        1
#endif
#define DISABLE_ATOMIC_FLAGS		  1
#define DISABLE_ENVIRONMENT_VARIABLES 1
#define DISABLE_GLOBAL_NEW			  1
#endif

#ifdef WEB_SERVER
#ifdef DEBUGGING
#define ENABLE_DEBUG_FILE             1
#define ENABLE_LOCK_STATISTICS		  1
#define PRINT_ACTIVE_PACKETS		  1
#endif
#define ENABLE_NON_STANDARD_ASSEMBLY  1
#endif

#ifdef ROCKALL_DIRECTUSER
    //
    // DirectUser REQUIRES specific options:
    // No virtual's in API
    // Can not use non-standard assembly
    //

#undef ENABLE_NON_STANDARD_ASSEMBLY
#endif


    /********************************************************************/
    /*                                                                  */
    /*   The complete feature list.							            */
    /*                                                                  */
    /*   The code supports a significant number of optional features    */
    /*   which are listed in this file.  Any feature can be activated   */
    /*   by copying the approriate setting.  Please be sure to keep     */
    /*   all the flags up to date and leave at list one copy of each    */
    /*   flag below.                                                    */
    /*                                                                  */
    /********************************************************************/

#ifdef ACTIVATE_ALL_OPTIONS
	//
	//   Standard options for all code.
	//
#define ASSEMBLY_X86				  1
#define DEBUGGING                     1

#define DISABLE_GLOBAL_NEW			  1
#define DISABLE_PRECOMPILED_HEADERS	  1
#define DISABLE_STRUCTURED_EXCEPTIONS 1

	//
	//   Standard options for the library code.
	//
#define ENABLE_DEBUG_FILE             1
#define ENABLE_LOCK_STATISTICS		  1
#define ENABLE_NON_STANDARD_ASSEMBLY  1
#define ENABLE_RECURSIVE_LOCKS		  1

#define DISABLE_ATOMIC_FLAGS		  1
#define DISABLE_ENVIRONMENT_VARIABLES 1
#define DISABLE_STRING_LOCKS		  1

	//
	//   Rockall specific options.
	//
#define ENABLE_ALLOCATION_STATISTICS  1
#define ENABLE_HEAP_STATISTICS        1

	//
	//   Pipeline Server specific options.
	//
#define ENABLE_BUFFER_LOCK			  1
#define ENABLE_ZERO_WRITE_BUFFER	  1

#define PRINT_ACTIVE_PACKETS		  1

	//
	//   Pipeline Server demo specific options.
	//
#define ENABLE_DATABASE				  1
#define ENABLE_READING				  1
#define ENABLE_TRANSACTIONS			  1
#define ENABLE_WRITING				  1

	//
	//   Web Server specific options.
	//
#define DISABLE_ASYNC_IO			  1
#define DISABLE_BUFFER_COPY			  1
#define DISABLE_WEB_LOCKS			  1
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\library\librarypch.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\library\librarypch.hpp ===
#ifndef _LIBRARY_PCH_HPP_
#define _LIBRARY_PCH_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#ifndef DISABLE_PRECOMPILED_HEADERS
#include "Align.hpp"
#include "Assembly.hpp"
#include "Common.hpp"
#include "Environment.hpp"
#include "Global.hpp"
#include "List.hpp"
#include "Lock.hpp"
#include "New.hpp"
#include "Prefetch.hpp"
#include "Sharelock.hpp"
#include "Spinlock.hpp"
#include "Standard.hpp"
#include "System.hpp"
#include "Tls.hpp"

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\library\environment.hpp ===
#ifndef _ENVIRONMENT_HPP_
#define _ENVIRONMENT_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Assembly.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Environment configuration values.                              */
    /*                                                                  */
    /*   This class provides a information about the environment.       */
    /*   The information can be accessed repeatedly with very little    */
    /*   cost as the data is slaved in static memory.                   */
    /*                                                                  */
    /********************************************************************/

class ENVIRONMENT : public ASSEMBLY
    {
#ifndef DISABLE_ENVIRONMENT_VARIABLES
		//
		//   Private structures.
		//
		typedef struct
			{
			CHAR					  *Name;
			SBIT32                    SizeOfName;
			CHAR                      *Value;
			SBIT32                    SizeOfValue;
			} 
		VARIABLE;

#endif
        //
        //   Private data.
        //
        STATIC SBIT32		          Activations;

		STATIC SBIT32                 AllocationGranularity;
        STATIC SBIT16                 NumberOfProcessors;
#ifndef DISABLE_ENVIRONMENT_VARIABLES
		STATIC CHAR                   *ProgramName;
		STATIC CHAR                   *ProgramPath;
#endif
		STATIC SBIT32                 SizeOfMemory;
		STATIC SBIT32                 SizeOfPage;
#ifndef DISABLE_ENVIRONMENT_VARIABLES

		STATIC SBIT32                 MaxVariables;
		STATIC SBIT32                 VariablesUsed;
		STATIC VARIABLE               *Variables;
#endif

    public:
        //
        //   Public functions.
        //
        ENVIRONMENT( VOID );
#ifndef DISABLE_ENVIRONMENT_VARIABLES

		STATIC CONST CHAR *ReadEnvironmentVariable( CONST CHAR *Name );
#endif

        ~ENVIRONMENT( VOID );

		//
		//   Public inline functions.
		//
		STATIC INLINE  SBIT32 AllocationSize(VOID ) 
			{ return AllocationGranularity; };
	
		STATIC INLINE SBIT32 CacheAlignSize( SBIT32 Size )
			{ return ((Size + CacheLineMask) & ~CacheLineMask); }

		STATIC INLINE CONST CHAR *DirectorySeperator( VOID ) 
			{ return "\\"; };

        STATIC INLINE SBIT16 NumberOfCpus( VOID ) 
			{ return NumberOfProcessors; }

		STATIC INLINE SBIT32 MemorySize( VOID ) 
			{ return SizeOfMemory; };

		STATIC INLINE SBIT32 PageSize( VOID ) 
			{ return SizeOfPage; };
#ifndef DISABLE_ENVIRONMENT_VARIABLES

		STATIC INLINE CONST CHAR *ProgramFileName( VOID ) 
			{ return ((CONST CHAR*) ProgramName); };

		STATIC INLINE CONST CHAR *ProgramFilePath( VOID ) 
			{ return ((CONST CHAR*) ProgramPath); };
#endif

	private:
        //
        //   Disabled operations.
        //
        ENVIRONMENT( CONST ENVIRONMENT & Copy );

        VOID operator=( CONST ENVIRONMENT & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\library\global.hpp ===
#ifndef _GLOBAL_HPP_
#define _GLOBAL_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#pragma warning(disable:4505)       // unreferenced local function has been removed

#include "Features.hpp"
#include "Standard.hpp"
#include "System.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   The standard macros.                                           */
    /*                                                                  */
    /*   The following are standard macros used by various              */
    /*   classes in this program.                                       */
    /*                                                                  */
    /********************************************************************/

#define FIELDOFFSET( Type,Field )	  ((SBIT16) & (((Type *)0) -> Field))
#define TO_DO( Message ) message ( "---- To do ---->>>> " Message )

#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#define TRY							  try
#else
#define TRY							  __try
#endif

    /********************************************************************/
    /*                                                                  */
    /*   The standard constants.                                        */
    /*                                                                  */
    /*   The following are standard constants used by various           */
    /*   classes in this program.                                       */
    /*                                                                  */
    /********************************************************************/

	//
	//   The hardware cache line size.
	//
CONST SBIT32 CacheLineSize			  = 32;
CONST SBIT32 CacheLineMask			  = (CacheLineSize - 1);
CONST SBIT32 NoAlignment			  = 1;

	//
	//   The end of a linked list.
	//
CONST INT EndOfList					  = -1;

	//
	//   The boolean constants.
	//
CONST BOOLEAN False					  = 0;
CONST BOOLEAN True					  = 1;

	//
	//   Various misc constants.
	//
CONST INT DebugBufferSize			  = 8192;
CONST INT ExpandStore				  = 2;
CONST INT MaxCpus					  = 32;
CONST INT NoFlags					  = 0;

    /********************************************************************/
    /*                                                                  */
    /*   The standard functions.                                        */
    /*                                                                  */
    /*   The following are standard functions used by various           */
    /*   classes in multiple applications.                              */
    /*                                                                  */
    /********************************************************************/

VOID DebugPrint( CONST CHAR *Format,... );

VOID Failure( char *Message );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\library\global.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "Global.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Debug printing.                                                */
    /*                                                                  */
    /*   We sometimes need to print message during debugging. We        */
    /*   do this using the following 'printf' like function.            */
    /*                                                                  */
    /********************************************************************/

VOID DebugPrint( CONST CHAR *Format,... )
	{
	AUTO CHAR Buffer[ DebugBufferSize ];
#ifdef ENABLE_DEBUG_FILE
	STATIC FILE *DebugFile = NULL;
#endif


	//
	//   Start of variable arguments.
	//
	va_list Arguments;

	va_start(Arguments, Format);

	//
	//   Format the string to be printed.
	//
	(VOID) _vsnprintf( Buffer,(DebugBufferSize-1),Format,Arguments );

	//
	//   Force null termination.
	//
	Buffer[ (DebugBufferSize-1) ] = '\0';

#ifdef ENABLE_DEBUG_FILE
	//
	//   Write to the debug file.
	//
	if ( DebugFile == NULL )
		{
		if ( (DebugFile = fopen( "C:\\DebugFile.TXT","a" )) == NULL )
			{ Failure( "Debug file could not be opened" ); }
		}

	fputs( Buffer,DebugFile );

	fflush( DebugFile );
#else
	//
	//   Write the string to the debug file.
	//
	OutputDebugString( Buffer );
#endif

	//
	//   End of variable arguments.
	//
	va_end( Arguments );
	}

    /********************************************************************/
    /*                                                                  */
    /*   Software failure.                                              */
    /*                                                                  */
    /*   We know that when this function is called the application      */
    /*   has failed so we simply try to cleanly exit in the vain        */
    /*   hope that the failure can be caught and corrected.             */
    /*                                                                  */
    /********************************************************************/

VOID Failure( char *Message )
	{
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
	throw ((TEXT) Message);
#else
	RaiseException( 1,0,1,((CONST DWORD*) Message) );
#endif
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\library\list.hpp ===
#ifndef _LIST_HPP_
#define _LIST_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   A generic linked list.                                         */
    /*                                                                  */
    /*   There are a significant number of situations where objects     */
    /*   need to be linked together.  The objects may be of the same    */
    /*   or diffrent types so the class specified here is intended      */
    /*   to be used as base class so as to make supporting this easy.   */
    /*                                                                  */
    /********************************************************************/

class LIST
    {
		//
		//   Private data.
		//
 		LIST						  *Backward;
 		LIST						  *Forward;
#ifdef DEBUGGING
		LIST						  *Head;
#endif

   public:
        //
        //   Public functions.
        //
        LIST( VOID );

		VOID Delete( LIST *HeadOfList );

		VOID Insert( LIST *HeadOfList );

		VOID InsertBefore( LIST *HeadOfList,LIST *NewList );

		VOID InsertAfter( LIST *HeadOfList,LIST *NewList );

		VOID Reset( VOID );

        ~LIST( VOID );

		//
		//   Public line functions.
		//
		INLINE BOOLEAN StartOfList( VOID )
			{ return (Backward == NULL); }

		INLINE LIST *First( VOID )
			{ return Forward; }

		INLINE LIST *Last( VOID )
			{ return Backward; }

		INLINE LIST *Next( VOID )
			{ return Forward; }

		INLINE LIST *Previous( VOID )
			{ return Backward; }

		INLINE BOOLEAN EndOfList( VOID )
			{ return (Forward == NULL); }

	private:
        //
        //   Disabled operations.
        //
        LIST( CONST LIST & Copy );

        VOID operator=( CONST LIST & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\library\lock.hpp ===
#ifndef _LOCKS_HPP_
#define _LOCKS_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Sharelock.hpp"
#include "Spinlock.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Full lock structure.                                           */
    /*                                                                  */
    /*   This class provides an full locking mechanism for a            */
    /*   collection of higher level classes.                            */
    /*                                                                  */
    /********************************************************************/

class FULL_LOCK
    {
        //
        //   Private data.
        //
		SHARELOCK                     ShareLock;

    public:
        //
        //   Public inline functions.
        //
        FULL_LOCK( VOID )
			{ /* void */ }

        INLINE VOID ClaimExclusiveLock( VOID )
			{ (VOID) ShareLock.ClaimExclusiveLock(); }

        INLINE VOID ClaimSharedLock( VOID )
			{ (VOID) ShareLock.ClaimShareLock(); }

        INLINE VOID ReleaseExclusiveLock( VOID )
			{ (VOID) ShareLock.ReleaseExclusiveLock(); }

		INLINE VOID ReleaseSharedLock( VOID )
			{ (VOID) ShareLock.ReleaseShareLock(); }

        ~FULL_LOCK( VOID )
			{ /* void */ }

	private:
        //
        //   Disabled operations.
        //
        FULL_LOCK( CONST FULL_LOCK & Copy );

        VOID operator=( CONST FULL_LOCK & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   No lock structure.                                             */
    /*                                                                  */
    /*   This class provides a default locking mechanism for a          */
    /*   collection of higher level classes.                            */
    /*                                                                  */
    /********************************************************************/

class NO_LOCK
    {
    public:
        //
        //   Public inline functions.
        //
        NO_LOCK( VOID )
			{ /* void */ }

        INLINE VOID ClaimExclusiveLock( VOID )
			{ /* void */ }

        INLINE VOID ClaimSharedLock( VOID )
			{ /* void */ }

        INLINE VOID ReleaseExclusiveLock( VOID )
			{ /* void */ }

		INLINE VOID ReleaseSharedLock( VOID )
 			{ /* void */ }

        ~NO_LOCK( VOID )
			{ /* void */ }

	private:
        //
        //   Disabled operations.
        //
        NO_LOCK( CONST NO_LOCK & Copy );

        VOID operator=( CONST NO_LOCK & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Partial lock structure.                                        */
    /*                                                                  */
    /*   This class provides a partial locking mechanism for a          */
    /*   collection of higher level classes.                            */
    /*                                                                  */
    /********************************************************************/

class PARTIAL_LOCK
    {
        //
        // Private structures.
        //
		SPINLOCK                      Spinlock;

    public:
        //
        //   Public inline functions.
        //
        PARTIAL_LOCK( VOID )
			{ /* void */ }

        INLINE VOID ClaimExclusiveLock( VOID )
			{ (VOID) Spinlock.ClaimLock(); }

        INLINE VOID ClaimSharedLock( VOID )
			{ (VOID) Spinlock.ClaimLock(); }

        INLINE VOID ReleaseExclusiveLock( VOID )
			{ (VOID) Spinlock.ReleaseLock(); }

		INLINE VOID ReleaseSharedLock( VOID )
			{ (VOID) Spinlock.ReleaseLock(); }

        ~PARTIAL_LOCK( VOID )
			{ /* void */ }

	private:
        //
        //   Disabled operations.
        //
        PARTIAL_LOCK( CONST PARTIAL_LOCK & Copy );

        VOID operator=( CONST PARTIAL_LOCK & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\library\list.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "List.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new linked list element.                              */
    /*                                                                  */
    /********************************************************************/

LIST::LIST( VOID )
    {
	Forward = NULL;
	Backward = NULL;
#ifdef DEBUGGING
	Head = NULL;
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Delete an element.                                             */
    /*                                                                  */
    /*   Delete the current element.                                    */
    /*                                                                  */
    /********************************************************************/

VOID LIST::Delete( LIST *HeadOfList )
	{
#ifdef DEBUGGING
	if ( Head == HeadOfList )
		{
#endif
		//
		//   Relink the forward chain.
		//
		if ( Forward != NULL )
			{ Forward -> Backward = Backward; }
		else
			{ HeadOfList -> Backward = Backward; }

		//
		//   Relink the backward chain.
		//
		if ( Backward != NULL )
			{ Backward -> Forward = Forward; }
		else
			{ HeadOfList -> Forward = Forward; }

		//
		//   Reset the list elements.
		//
		Forward = NULL;
		Backward = NULL;
#ifdef DEBUGGING
		Head = NULL;
		}
	else
		{ Failure( "No active linked list element in Delete" ); }
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Insert a list element.                                         */
    /*                                                                  */
    /*   Insert a list element at the head of the list.                 */
    /*                                                                  */
    /********************************************************************/

VOID LIST::Insert( LIST *HeadOfList )
	{
#ifdef DEBUGGING
	if ( Head == NULL )
		{
#endif
		//
		//   Insert the new element at the front of the list.
		//
		if ( (Forward = HeadOfList -> Forward) == NULL )
			{ 
			HeadOfList -> Forward = this;
			HeadOfList -> Backward = this; 
			}
		else
			{ 
			HeadOfList -> Forward -> Backward = this; 
			HeadOfList -> Forward = this;
			}

		//
		//   Set the other pointers as needed.
		//
		Backward = NULL;
#ifdef DEBUGGING
		Head = HeadOfList;
		}
	else
		{ Failure( "List element already in use in Insert" ); }
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Insert a list element.                                         */
    /*                                                                  */
    /*   Insert a new list element before the current element.          */
    /*                                                                  */
    /********************************************************************/

VOID LIST::InsertBefore( LIST *HeadOfList,LIST *NewList )
	{
#ifdef DEBUGGING
	if ( NewList -> Head == NULL )
		{
#endif
		if ( HeadOfList -> Forward == NULL )
			{
			//
			//   When the list is empty then add the 
			//   new element at the start of the list.
			//
			HeadOfList -> Forward = NewList;
			HeadOfList -> Backward = NewList;

			NewList -> Forward = NULL;
			NewList -> Backward = NULL;
#ifdef DEBUGGING
			NewList -> Head = HeadOfList;
#endif
			}
		else
			{
#ifdef DEBUGGING
			//
			//   We want to be sure that we consistently 
			//   get the same list head otherwise the list 
			//   may become corrupted.
			//
			if ( Head == HeadOfList )
				{
#endif
				//
				//   If there is a previous element we must
				//   make it point at the new element.  If
				//   not we are the first element in the 
				//   list so update the head.
				//
				if ( Backward != NULL )
					{ Backward -> Forward = NewList; }
				else
					{ HeadOfList -> Forward = NewList; }

				//
				//   Link the new element into the list and
				//   update the current element to point to
				//   it.
				//
				NewList -> Backward = Backward;
				NewList -> Forward = this;
#ifdef DEBUGGING
				NewList -> Head = HeadOfList;
#endif

				Backward = NewList;
				}
#ifdef DEBUGGING
			else
				{ Failure( "No active linked list element in InsertBefore" ); }
			}
		}
	else
		{ Failure( "List element already in use in InsertBefore" ); }
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Insert an element.                                             */
    /*                                                                  */
    /*   Insert a new list element after the current element.           */
    /*                                                                  */
    /********************************************************************/

VOID LIST::InsertAfter( LIST *HeadOfList,LIST *NewList )
	{
#ifdef DEBUGGING
	if ( NewList -> Head == NULL )
		{
#endif
		if ( HeadOfList -> Forward == NULL )
			{
			//
			//   When the list is empty then add the 
			//   new element at the start of the list.
			//
			HeadOfList -> Forward = NewList;
			HeadOfList -> Backward = NewList;

			NewList -> Forward = NULL;
			NewList -> Backward = NULL;
#ifdef DEBUGGING
			NewList -> Head = HeadOfList;
#endif
			}
		else
			{
#ifdef DEBUGGING
			//
			//   We want to be sure that we consistently 
			//   get the same list head otherwise the list 
			//   may become corrupted.
			//
			if ( Head == HeadOfList )
				{
#endif
				//
				//   If there is a next element we must
				//   make it point at the new element.  If
				//   not we are the last element in the 
				//   list so update the head.
				//
				if ( Forward != NULL )
					{ Forward -> Backward = NewList; }
				else
					{ HeadOfList -> Backward = NewList; }

				//
				//   Link the new element into the list and
				//   update the current element to point to
				//   it.
				//
				NewList -> Forward = Forward;
				NewList -> Backward = this;
#ifdef DEBUGGING
				NewList -> Head = HeadOfList;
#endif

				Forward = NewList;
				}
#ifdef DEBUGGING
			else
				{ Failure( "No active linked list element in InsertAfter" ); }
			}
		}
	else
		{ Failure( "List element already in use in InsertAfter" ); }
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Reset a list element.                                          */
    /*                                                                  */
    /*   Reset a list element without any questions.                    */
    /*                                                                  */
    /********************************************************************/

VOID LIST::Reset( VOID )
    {
	Forward = NULL;
	Backward = NULL;
#ifdef DEBUGGING
	Head = NULL;
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory a linked list element.                                 */
    /*                                                                  */
    /********************************************************************/

LIST::~LIST( VOID )
    {
	Forward = NULL;
	Backward = NULL;
#ifdef DEBUGGING
	Head = NULL;
#endif
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\library\new.hpp ===
#ifndef _NEW_HPP_
#define _NEW_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   The placement new and delete macros.                           */
    /*                                                                  */
    /*   The placement new and delete macros allow the constructor      */
    /*   and destructos of a type to be called as needed.               */
    /*                                                                  */
    /********************************************************************/

#define PLACEMENT_NEW( Address,Type )		new( Address ) Type
#define PLACEMENT_DELETE( Address,Type )	(((Type*) Address) -> ~Type())
#ifndef DISABLE_GLOBAL_NEW

    /********************************************************************/
    /*                                                                  */
    /*   The memory allocation operator.                                */
    /*                                                                  */
    /*   The memory allocation operator 'new' is overloaded to          */
    /*   provide a consistent interface.                                */
    /*                                                                  */
    /********************************************************************/

INLINE VOID *operator new( size_t Size )
    {
    REGISTER VOID *Store = malloc( Size );

    if ( Store == NULL )
        { Failure( "Out of system memory" ); }

    return Store;
    }

    /********************************************************************/
    /*                                                                  */
    /*   The memory deallocation operator.                              */
    /*                                                                  */
    /*   The memory deallocation operator releases allocated memory.    */
    /*                                                                  */
    /********************************************************************/

INLINE VOID operator delete( VOID *Store )
    { free( Store ); }
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\library\prefetch.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "Prefetch.hpp"
#ifdef ASSEMBLY_X86

    /********************************************************************/
    /*                                                                  */
    /*   Static member initialization.                                  */
    /*                                                                  */
    /*   Static member initialization sets the initial value for all    */
    /*   static members.                                                */
    /*                                                                  */
    /********************************************************************/

BOOLEAN PREFETCH::Active =
	(
	(BOOLEAN) IsProcessorFeaturePresent
		( 
		PF_XMMI_INSTRUCTIONS_AVAILABLE
		)
	);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\library\sharelock.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "Sharelock.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The Windows NT kernel requires a maximum wakeup count when     */
    /*   creating a semaphore.                                          */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 MaxShareLockUsers		  = 256;

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new lock and initialize it.  This call is not         */
    /*   thread safe and should only be made in a single thread         */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

SHARELOCK::SHARELOCK( SBIT32 NewMaxSpins, SBIT32 NewMaxUsers )
    {
	//
	//   Check the configurable values.
	//
	if ( NewMaxSpins > 0 )
		{ MaxSpins = NewMaxSpins; }
	else
		{ Failure( "Maximum spins invalid in constructor for SHARELOCK" ); }

	if ( (NewMaxUsers > 0) && (NewMaxUsers <= MaxShareLockUsers) )
		{ MaxUsers = NewMaxUsers; }
	else
		{ Failure( "Maximum share invalid in constructor for SHARELOCK" ); }

	//
	//   Set the initial state.
	//
	Exclusive = 0;
	TotalUsers = 0;
#ifdef ENABLE_RECURSIVE_LOCKS

	Owner = NULL;
	Recursive = 0;
#endif
    Waiting = 0;

	//
	//   Create a semaphore to sleep on when the spin count exceeds
	//   its maximum.
	//
    if ( (Semaphore = CreateSemaphore( NULL,0,MaxShareLockUsers,NULL )) == NULL)
        { Failure( "Create semaphore in constructor for SHARELOCK" ); }
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Zero the statistics.
	//
    TotalExclusiveLocks = 0;
    TotalShareLocks = 0;
    TotalSleeps = 0;
    TotalSpins = 0;
    TotalTimeouts = 0;
    TotalWaits = 0;
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Sleep waiting for the lock.                                    */
    /*                                                                  */
    /*   We have decided it is time to sleep waiting for the lock       */
    /*   to become free.                                                */
    /*                                                                  */
    /********************************************************************/

BOOLEAN SHARELOCK::SleepWaitingForLock( SBIT32 Sleep )
    {
	//
	//   We have been spinning waiting for the lock but it
	//   has not become free.  Hence, it is now time to 
	//   give up and sleep for a while.
	//
	(VOID) AtomicIncrement( & Waiting );

	//
	//   Just before we go to sleep we do one final check
	//   to make sure that the lock is still busy and that
	//   there is someone to wake us up when it becomes free.
	//
	if ( TotalUsers > 0 )
		{
#ifdef ENABLE_LOCK_STATISTICS
		//
		//   Count the number of times we have slept on this lock.
		//
		(VOID) AtomicIncrement( & TotalSleeps );

#endif
		//
		//   When we sleep we awoken when the lock becomes free
		//   or when we timeout.  If we timeout we simply exit
		//   after decrementing various counters.
		//
		if 
				( 
				WaitForSingleObject( Semaphore, Sleep ) 
					!= 
				WAIT_OBJECT_0 
				)
			{ 
#ifdef ENABLE_LOCK_STATISTICS
			//
			//   Count the number of times we have timed out 
			//   on this lock.
			//
			(VOID) AtomicIncrement( & TotalTimeouts );

#endif
			return False; 
			}
		}
	else
		{
		//
		//   Lucky - the lock was just freed so lets
		//   decrement the sleep count and exit without
		//   sleeping.
		// 
		(VOID) AtomicDecrement( & Waiting );
		}
	
	return True;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Update the spin limit.                                         */
    /*                                                                  */
    /*   Update the maximum number of spins while waiting for the lock. */
    /*                                                                  */
    /********************************************************************/

BOOLEAN SHARELOCK::UpdateMaxSpins( SBIT32 NewMaxSpins )
    {
	if ( NewMaxSpins > 0 )
		{ 
		MaxSpins = NewMaxSpins; 

		return True;
		}
	else
		{ return False; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Update the sharing limit.                                      */
    /*                                                                  */
    /*   Update the maximum number of users that can share the lock.    */
    /*                                                                  */
    /********************************************************************/

BOOLEAN SHARELOCK::UpdateMaxUsers( SBIT32 NewMaxUsers )
    {
	//
	//   We need to Verify the new value makes sense.
	//
	if ( (NewMaxUsers > 0) && (NewMaxUsers <= MaxShareLockUsers) )
		{
		ClaimExclusiveLock();

		//
		//   Update the maximum number of users.
		//
		MaxUsers = NewMaxUsers;
		
		ReleaseExclusiveLock();

		return True;
		}
	else
		{ return False; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Wait for an exclusive lock.                                    */
    /*                                                                  */
    /*   Wait for the spinlock to become free and then claim it.        */
    /*                                                                  */
    /********************************************************************/

BOOLEAN SHARELOCK::WaitForExclusiveLock( SBIT32 Sleep )
    {
	REGISTER LONG Cpus = ((LONG) NumberOfCpus());
#ifdef ENABLE_LOCK_STATISTICS
	REGISTER SBIT32 Spins = 0;
	REGISTER SBIT32 Waits = 0;

#endif
	//
	//   We will loop round in this function until the
	//   following condition becomes false.
	//
	while ( TotalUsers != 1 )
		{
		//
		//   The lock is busy so release it and spin waiting
		//   for it to become free.
		//
		(VOID) AtomicDecrement( & TotalUsers );
    
		//
		//   We will only try spinning and sleeping if we
		//   are permitted to do so by the parameters.
		//   
		if ( Sleep != 0 )
			{
			REGISTER SBIT32 Count;
    
			//
			//   If there are already more threads waiting 
			//   than the number of CPUs then the odds of 
			//   getting the lock by spinning are slim, when 
			//   there is only one CPU the chance is zero, so 
			//   just bypass this step.
			//
			if ( (Cpus > 1) && (Cpus > Waiting) )
				{
				//
				//   Wait by spinning and repeatedly testing the
				//   spinlock.  We exit when the lock becomes free 
				//   or the spin limit is exceeded.
				//
				for 
					( 
						Count = MaxSpins;
						(Count > 0) && (TotalUsers > 0);
						Count -- 
					);
#ifdef ENABLE_LOCK_STATISTICS

				//
				//   Update the statistics.
				//
				Spins += (MaxSpins - Count);
				Waits ++;
#endif
				}
			else
				{ Count = 0; }

			//
			//   We have exhusted our spin count so it is time to
			//   sleep waiting for the lock to clear.
			//
			if ( Count == 0 )
				{
				//
				//   We have decide that we need to sleep but are
				//   still holding an exclusive lock so lets drop it
				//   before sleeping.
				//
				(VOID) AtomicDecrement( & Exclusive );

				//
				//   We have decied that it is time to go to sleep
				//   when we wake up the lock should be available
				//   (or just aquired) unless we have timed out in
				//   wich case we exit.
				//
				if ( ! SleepWaitingForLock( Sleep ) )
					{ return False; }

				//
				//   We have woken up again so lets reclaim the
				//   exclusive lock we had earlier.
				//
				(VOID) AtomicIncrement( & Exclusive );
				}
			}
		else
			{ 
			//
			//   We have decide that we need to exit but are still
			//   holding an exclusive lock.  so lets drop it and leave.
			//
			(VOID) AtomicDecrement( & Exclusive );

			return False; 
			} 
		//
		//   Lets test the lock again.
		//
		(VOID) AtomicIncrement( & TotalUsers );
		}

#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
	(VOID) AtomicAdd( & TotalSpins, Spins );
	(VOID) AtomicAdd( & TotalWaits, Waits );
#endif

	return True;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Wait for a shared lock.                                        */
    /*                                                                  */
    /*   Wait for the lock to become free and then claim it.            */
    /*                                                                  */
    /********************************************************************/

BOOLEAN SHARELOCK::WaitForShareLock( SBIT32 Sleep )
    {
	REGISTER LONG Cpus = ((LONG) NumberOfCpus());
#ifdef ENABLE_LOCK_STATISTICS
	REGISTER SBIT32 Spins = 0;
	REGISTER SBIT32 Waits = 0;

#endif
	//
	//   We will loop round in this function until the
	//   following condition becomes false.
	//
	while ( (Exclusive > 0) || (TotalUsers > MaxUsers) )
		{
		//
		//   The lock is busy so release it and spin waiting
		//   for it to become free.
		//
		(VOID) AtomicDecrement( & TotalUsers );

		//
		//   We will only try spinning and sleeping if we
		//   are permitted to do so by the parameters.
		//   
		if ( Sleep != 0 )
			{
			REGISTER SBIT32 Count;
    
			//
			//   If there are already more threads waiting 
			//   than the number of CPUs then the odds of 
			//   getting the lock by spinning are slim, when 
			//   there is only one CPU the chance is zero, so 
			//   just bypass this step.
			//
			if ( (Cpus > 1) && (Cpus > Waiting) )
				{
				//
				//   Wait by spinning and repeatedly testing the
				//   spinlock.  We exit when the lock becomes free 
				//   or the spin limit is exceeded.
				//
				for 
					( 
						Count = MaxSpins;
						(Count > 0) 
							&& 
						((Exclusive > 0) || (TotalUsers >= MaxUsers));
						Count -- 
					);
#ifdef ENABLE_LOCK_STATISTICS

				//
				//   Update the statistics.
				//
				Spins += (MaxSpins - Count);
				Waits ++;
#endif
				}
			else
				{ Count = 0; }

			//
			//   We have exhusted our spin count so it is time to
			//   sleep waiting for the lock to clear.
			//
			if ( Count == 0 )
				{
				//
				//   We have decied that it is time to go to sleep
				//   when we wake up the lock should be available
				//   (or just aquired) unless we have timed out in
				//   wich case we exit.
				//
				if ( ! SleepWaitingForLock( Sleep ) )
					{ return False; }
				}
			}
		else
			{ return False; }

		//
		//   Lets test the lock again.
		//
		(VOID) AtomicIncrement( & TotalUsers );
		}
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
	(VOID) AtomicAdd( & TotalSpins, Spins );
	(VOID) AtomicAdd( & TotalWaits, Waits );
#endif

	return True;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Wake all sleepers.                                             */
    /*                                                                  */
    /*   Wake all the sleepers who are waiting for the spinlock.        */
    /*   All sleepers are woken because this is much more efficent      */
    /*   and it is known that the lock latency is short.                */
    /*                                                                  */
    /********************************************************************/

VOID SHARELOCK::WakeAllSleepers( VOID )
    {
    REGISTER LONG Wakeup = AtomicExchange( & Waiting, 0 );

	//
	//   We make sure there is still someone to be woken 
	//   up if not we check that the count has not become
	//   negative.
	//
    if ( Wakeup > 0 )
        {
		REGISTER LONG Cpus = ((LONG) NumberOfCpus());

		//
		//   We will only wake enough threads to ensure that 
		//   there is one active thread per CPU.  So if an 
		//   application has hundreds of threads we will try 
		//   prevent the system from becoming swampped.
		//
		if ( Wakeup > Cpus )
			{
			(VOID) AtomicAdd( & Waiting,(Wakeup - Cpus) );
			Wakeup = Cpus; 
			}

        //
        //   Wake up all sleepers as the lock has just been freed.
        //   It is a straight race to decide who gets the lock next.
        //
        if ( ! ReleaseSemaphore( Semaphore, Wakeup, NULL ) )
            { Failure( "Wakeup failed in ReleaseLock()" ); }
        }
    else
        {
        //
        //   When multiple threads pass through the critical  
        //   section it is possible for the 'Waiting' count  
		//   to become negative.  This should be very rare but 
		//   such a negative value needs to be preserved. 
        //
		if ( Wakeup < 0 )
			{ (VOID) AtomicAdd( & Waiting, Wakeup ); }
        }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory a lock.  This call is not thread safe and should       */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

SHARELOCK::~SHARELOCK( VOID )
    {
#ifdef ENABLE_LOCK_STATISTICS
	//
	//   Print the lock statistics.
	//
	DebugPrint
		(
		"Sharelock: \t%8d exclusive, %8d shared, %8d timeouts, " 
		"%8d locks per wait, %8d spins per wait, %8d waits per sleep.\n",
		TotalExclusiveLocks,
		TotalShareLocks,
		TotalTimeouts,
		((TotalExclusiveLocks + TotalShareLocks) / ((TotalWaits <= 0) ? 1 : TotalWaits)),
		(TotalSpins / ((TotalWaits <= 0) ? 1 : TotalWaits)),
		(TotalWaits / ((TotalSleeps <= 0) ? 1 : TotalSleeps))
		);
#endif
	//
	//   Close the semaphore handle.
	//
    if ( ! CloseHandle( Semaphore ) )
        { Failure( "Close semaphore in destructor for SHARELOCK" ); }
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\library\prefetch.hpp ===
#ifndef _PREFETCH_HPP_
#define _PREFETCH_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Assembly.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The constants specified here are used to compute whether       */
    /*   the prefetch functionality is available on the current         */
    /*   processor.                                                     */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 PrefetchFeatureMask	  = (1 << 24);

    /********************************************************************/
    /*                                                                  */
    /*   Prefetch a cache line.				                            */
    /*                                                                  */
    /*   Support of data prefetch on the Pentium III or better.         */
    /*                                                                  */
    /********************************************************************/

class PREFETCH : public ASSEMBLY
    {
#ifdef ASSEMBLY_X86
        //
        //   Staic private data.
        //
        STATIC BOOLEAN		          Active;

#endif
    public:
        //
        //   Public inline functions.
        //
        PREFETCH( VOID )
			{ /* void */ }

		STATIC INLINE VOID L1( CHAR *Address,SBIT32 Size );

		STATIC INLINE VOID L2( CHAR *Address,SBIT32 Size );

		STATIC INLINE VOID L3( CHAR *Address,SBIT32 Size );

		STATIC INLINE VOID Nta( CHAR *Address,SBIT32 Size );

        ~PREFETCH( VOID )
			{ /* void */ }

	private:
        //
        //   Disabled operations.
        //
        PREFETCH( CONST PREFETCH & Copy );

        VOID operator=( CONST PREFETCH & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Prefetch to the L1.                                            */
    /*                                                                  */
    /*   Prefetch an area of memory to the L1 cache if the processor    */
    /*   supports this feature.                                         */
    /*                                                                  */
    /********************************************************************/

VOID PREFETCH::L1( CHAR *Address,SBIT32 Size )
	{
#ifdef ASSEMBLY_X86
	//
	//   We ensure the processor has prefetch functionality
	//   otherwise the instruction will fail.
	//
	if ( Active )
		{
		//
		//   We execute a prefetch for each cache line
		//   (which assumes things are alignment).
		//
		for 
				( 
				/* void */;
				Size > 0;
				Address += CacheLineSize, Size -= CacheLineSize 
				)
			{ PrefetchL1( Address ); }
		}
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Prefetch to the L2.                                            */
    /*                                                                  */
    /*   Prefetch an area of memory to the L2 cache if the processor    */
    /*   supports this feature.                                         */
    /*                                                                  */
    /********************************************************************/

VOID PREFETCH::L2( CHAR *Address,SBIT32 Size )
	{
#ifdef ASSEMBLY_X86
	//
	//   We ensure the processor has prefetch functionality
	//   otherwise the instruction will fail.
	//
	if ( Active )
		{
		//
		//   We execute a prefetch for each cache line
		//   (which assumes things are alignment).
		//
		for 
				( 
				/* void */;
				Size > 0;
				Address += CacheLineSize, Size -= CacheLineSize 
				)
			{ PrefetchL2( Address ); }
		}
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Prefetch to the L3.                                            */
    /*                                                                  */
    /*   Prefetch an area of memory to the L3 cache if the processor    */
    /*   supports this feature.                                         */
    /*                                                                  */
    /********************************************************************/

VOID PREFETCH::L3( CHAR *Address,SBIT32 Size )
	{
#ifdef ASSEMBLY_X86
	//
	//   We ensure the processor has prefetch functionality
	//   otherwise the instruction will fail.
	//
	if ( Active )
		{
		//
		//   We execute a prefetch for each cache line
		//   (which assumes things are alignment).
		//
		for 
				( 
				/* void */;
				Size > 0;
				Address += CacheLineSize, Size -= CacheLineSize 
				)
			{ PrefetchL3( Address ); }
		}
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Prefetch to the L1.                                            */
    /*                                                                  */
    /*   Prefetch an area of memory to the L1 cache if the processor    */
    /*   supports this feature.                                         */
    /*                                                                  */
    /********************************************************************/

VOID PREFETCH::Nta( CHAR *Address,SBIT32 Size )
	{
#ifdef ASSEMBLY_X86
	//
	//   We ensure the processor has prefetch functionality
	//   otherwise the instruction will fail.
	//
	if ( Active )
		{
		//
		//   We execute a prefetch for each cache line
		//   (which assumes things are alignment).
		//
		for 
				( 
				/* void */;
				Size > 0;
				Address += CacheLineSize, Size -= CacheLineSize 
				)
			{ PrefetchNta( Address ); }
		}
#endif
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\library\sharelock.hpp ===
#ifndef _SHARELOCK_HPP_
#define _SHARELOCK_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Environment.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Sharelock and Semaphore locking.                               */
    /*                                                                  */
    /*   This class provides a very conservative locking scheme.        */
    /*   The assumption behind the code is that locks will be           */
    /*   held for a very short time.  A lock can be obtained in         */
    /*   either exclusive mode or shared mode.  If the lock is not      */
    /*   available the caller waits by spinning or if that fails        */
    /*   by sleeping.                                                   */
    /*                                                                  */
    /********************************************************************/

class SHARELOCK : public ENVIRONMENT
    {
        //
        //   Private data.
        //
		SBIT32                        MaxSpins;
		SBIT32                        MaxUsers;

        VOLATILE SBIT32               Exclusive;
        VOLATILE SBIT32               TotalUsers;

#ifdef ENABLE_RECURSIVE_LOCKS
		SBIT32						  Owner;
		SBIT32						  Recursive;
#endif
        HANDLE                        Semaphore;
        VOLATILE SBIT32               Waiting;
#ifdef ENABLE_LOCK_STATISTICS

        //
        //   Counters for debugging builds.
        //
        VOLATILE SBIT32               TotalExclusiveLocks;
        VOLATILE SBIT32               TotalShareLocks;
        VOLATILE SBIT32               TotalSleeps;
        VOLATILE SBIT32               TotalSpins;
        VOLATILE SBIT32               TotalTimeouts;
        VOLATILE SBIT32               TotalWaits;
#endif

    public:
        //
        //   Public functions.
        //
        SHARELOCK( SBIT32 NewMaxSpins = 4096, SBIT32 NewMaxUsers = 256 );

        INLINE VOID ChangeExclusiveLockToSharedLock( VOID );

        INLINE BOOLEAN ChangeSharedLockToExclusiveLock( SBIT32 Sleep = INFINITE );

        INLINE BOOLEAN ClaimExclusiveLock( SBIT32 Sleep = INFINITE );

        INLINE BOOLEAN ClaimShareLock( SBIT32 Sleep = INFINITE );

        INLINE VOID ReleaseExclusiveLock( VOID );

        INLINE VOID ReleaseShareLock( VOID );

        BOOLEAN UpdateMaxSpins( SBIT32 NewMaxSpins );

        BOOLEAN UpdateMaxUsers( SBIT32 NewMaxUsers );

        ~SHARELOCK( VOID );

		//
		//   Public inline functions.
		//
        INLINE SBIT32 ActiveUsers( VOID ) 
			{ return (SBIT32) TotalUsers; }

    private:
        //
        //   Private functions.
        //
		INLINE VOID DeleteExclusiveOwner( VOID );

		INLINE VOID NewExclusiveOwner( SBIT32 NewOwner );

        BOOLEAN SleepWaitingForLock( SBIT32 Sleep );

        BOOLEAN WaitForExclusiveLock( SBIT32 Sleep );

        BOOLEAN WaitForShareLock( SBIT32 Sleep );

        VOID WakeAllSleepers( VOID );

        //
        //   Disabled operations.
        //
        SHARELOCK( CONST SHARELOCK & Copy );

        VOID operator=( CONST SHARELOCK & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Change an exclusive lock to a shared lock.                     */
    /*                                                                  */
    /*   Downgrade the existing exclusive lock to a shared lock.        */
    /*                                                                  */
    /********************************************************************/

INLINE VOID SHARELOCK::ChangeExclusiveLockToSharedLock( VOID )
    {
#ifdef ENABLE_RECURSIVE_LOCKS
	//
	//   When we have recursive lock calls we do not 
	//   release the lock until we have exited to the 
	//   top level.
	//
	if ( Recursive <= 0 )
		{
		//
		//   Delete the exclusive owner information.
		//
		DeleteExclusiveOwner();

#endif
		//
		//   Simply decrement the exclusive count.
		//   This allows the lock to be shared.
		//
		(VOID) AtomicDecrement( & Exclusive );
#ifdef ENABLE_RECURSIVE_LOCKS
		}
#endif
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
	(VOID) AtomicIncrement( & TotalShareLocks );
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Change a shared lock to an exclusive lock.                     */
    /*                                                                  */
    /*   Upgrade the existing shared lock to an exclusive lock.         */
    /*                                                                  */
    /********************************************************************/

INLINE BOOLEAN SHARELOCK::ChangeSharedLockToExclusiveLock( SBIT32 Sleep )
    {
#ifdef ENABLE_RECURSIVE_LOCKS
	REGISTER SBIT32 ThreadId = GetThreadId();

	//
	//   We may already own an exclusive lock. If so 
	//   we increment the recursive count otherwise 
	//   we have to wait.
	//
	if ( Owner != ThreadId )
		{
#endif		
		//
		//   We need to increment the exclusive count
		//   to prevent the lock from being shared.
		//
		(VOID) AtomicIncrement( & Exclusive );

		//
		//   If the total number of users is one then
		//   we have the lock exclusively otherwise we
		//   may need to wait.
		//
		if ( TotalUsers != 1 )
			{
			//
			//   We have to wait.  If we are not allowed 
			//   to sleep or we have timed out then exit.
			//
			if ( ! WaitForExclusiveLock( Sleep ) )
				{ return False; }
			}
#ifdef ENABLE_RECURSIVE_LOCKS

		//
		//   Register the new exclusive owner
		//   of the lock.
		//
		NewExclusiveOwner( ThreadId );
		}
#endif
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
	(VOID) AtomicIncrement( & TotalExclusiveLocks );
#endif

    return True;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Claim an exclusive lock.                                       */
    /*                                                                  */
    /*   Claim an exclusive lock if available else wait or exit.        */
    /*                                                                  */
    /********************************************************************/

INLINE BOOLEAN SHARELOCK::ClaimExclusiveLock( SBIT32 Sleep )
    {
#ifdef ENABLE_RECURSIVE_LOCKS
	REGISTER SBIT32 ThreadId = GetThreadId();

	//
	//   We may already own an exclusive lock. If so 
	//   we increment the recursive count otherwise 
	//   we have to wait.
	//
	if ( Owner != ThreadId )
		{
#endif
		//
		//   We need to increment the exclusive count
		//   to prevent the lock from being shared and
		//   the total number of users count.
		//
		(VOID) AtomicIncrement( & Exclusive );
		(VOID) AtomicIncrement( & TotalUsers );

		if ( TotalUsers != 1 )
			{
			//
			//   We have to wait.  If we are not allowed 
			//   to sleep or we have timed out then exit.
			//
			if ( ! WaitForExclusiveLock( Sleep ) )
				{ return False; }
			}
#ifdef ENABLE_RECURSIVE_LOCKS

		//
		//   Register the new exclusive owner
		//   of the lock.
		//
		NewExclusiveOwner( ThreadId );
		}
	else
		{ Recursive ++; }
#endif
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
	(VOID) AtomicIncrement( & TotalExclusiveLocks );
#endif

    return True;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Claim a shared lock.                                           */
    /*                                                                  */
    /*   Claim a shared lock if available else wait or exit.            */
    /*                                                                  */
    /********************************************************************/

INLINE BOOLEAN SHARELOCK::ClaimShareLock( SBIT32 Sleep )
    {
#ifdef ENABLE_RECURSIVE_LOCKS
	REGISTER SBIT32 ThreadId = GetThreadId();

	//
	//   We may already own an exclusive lock. If so 
	//   we increment the recursive count otherwise 
	//   we have to wait.
	//
	if ( Owner != ThreadId )
		{
#endif
		//
		//   We need to increment the total number of 
		//   users count to prevent the lock from being 
		//   claimed for exclusive use.
		//
		(VOID) AtomicIncrement( & TotalUsers );

		if ( (Exclusive > 0) || (TotalUsers > MaxUsers) )
			{
			//
			//   We have to wait.  If we are not allowed 
			//   to sleep or we have timed out then exit.
			//
			if ( ! WaitForShareLock( Sleep ) )
				{ return False; }
			}
#ifdef ENABLE_RECURSIVE_LOCKS
		}
	else
		{ Recursive ++; }
#endif
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
	(VOID) AtomicIncrement( & TotalShareLocks );
#endif

	return True;
    }
#ifdef ENABLE_RECURSIVE_LOCKS

    /********************************************************************/
    /*                                                                  */
    /*   New exclusive owner.                                           */
    /*                                                                  */
    /*   Delete the exclusive lock owner information.                   */
    /*                                                                  */
    /********************************************************************/

INLINE VOID SHARELOCK::DeleteExclusiveOwner( VOID )
    {
#ifdef DEBUGGING
	if ( Owner != NULL )
		{ 
#endif
		Owner = NULL; 
#ifdef DEBUGGING
		}
	else
		{ Failure( "Sharelock has no owner in DeleteExclusiveOwner" ); }
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   New exclusive owner.                                           */
    /*                                                                  */
    /*   Register new exclusive lock owner information.                 */
    /*                                                                  */
    /********************************************************************/

INLINE VOID SHARELOCK::NewExclusiveOwner( SBIT32 NewOwner )
    {
#ifdef DEBUGGING
	if ( Owner == NULL )
		{ 
#endif
		Owner = NewOwner; 
#ifdef DEBUGGING
		}
	else
		{ Failure( "Already exclusive in NewExclusiveOwner" ); }
#endif
    }
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Release an exclusive lock.                                     */
    /*                                                                  */
    /*   Release an exclusive lock and if needed wakeup any sleepers.   */
    /*                                                                  */
    /********************************************************************/

INLINE VOID SHARELOCK::ReleaseExclusiveLock( VOID )
    {
#ifdef ENABLE_RECURSIVE_LOCKS
	//
	//   When we have recursive lock calls we do not 
	//   release the lock until we have exited to the 
	//   top level.
	//
	if ( Recursive <= 0 )
		{
		//
		//   Delete the exclusive owner information.
		//
		DeleteExclusiveOwner();

#endif
		//
		//   Release an exclusive lock.
		//
#ifdef DEBUGGING
		if
				(
				(AtomicDecrement( & TotalUsers ) < 0)
					||
				(AtomicDecrement( & Exclusive ) < 0)
				)
			{ Failure( "Negative lock count in ReleaseExclusiveLock" ); }
#else
			AtomicDecrement( & TotalUsers );
			AtomicDecrement( & Exclusive );
#endif

		//
		//   Wakeup anyone who is asleep waiting.
		//
		if ( Waiting > 0 )
			{ WakeAllSleepers(); }
#ifdef ENABLE_RECURSIVE_LOCKS
		}
	else
		{ Recursive --; }
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Release a shared lock.                                         */
    /*                                                                  */
    /*   Release a shared lock and if needed wakeup any sleepers.       */
    /*                                                                  */
    /********************************************************************/

INLINE VOID SHARELOCK::ReleaseShareLock( VOID )
    {
#ifdef ENABLE_RECURSIVE_LOCKS
	//
	//   When we have recursive lock calls we do not 
	//   release the lock until we have exited to the 
	//   top level.
	//
	if ( Recursive <= 0 )
		{
#endif
#ifdef DEBUGGING
		//
		//   Release a shared lock.
		//
		if ( AtomicDecrement( & TotalUsers ) < 0 )
			{ Failure( "Negative lock count in ReleaseShareLock" ); }
#else
		AtomicDecrement( & TotalUsers );
#endif

		//
		//   Wakeup anyone who is asleep waiting.
		//
		if ( Waiting > 0 )
			{ WakeAllSleepers(); }
#ifdef ENABLE_RECURSIVE_LOCKS
		}
	else
		{ Recursive --; }
#endif
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\library\spinlock.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "Spinlock.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new lock and initialize it.  This call is not         */
    /*   thread safe and should only be made in a single thread         */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

SPINLOCK::SPINLOCK( SBIT32 NewMaxSpins,SBIT32 NewMaxUsers )
    {
	//
	//   Set the initial state.
	//
	MaxSpins = NewMaxSpins;
	MaxUsers = NewMaxUsers;
#ifdef ENABLE_RECURSIVE_LOCKS
	Owner = NULL;
	Recursive = 0;
#endif
    Spinlock = LockOpen;
    Waiting = 0;

	//
	//   Create a semaphore to sleep on when the spin count exceeds
	//   its maximum.
	//
    if ( (Semaphore = CreateSemaphore( NULL,0,NewMaxUsers,NULL )) == NULL)
        { Failure( "Create semaphore in constructor for SPINLOCK" ); }
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Zero the lock statistics.
	//
    TotalLocks = 0;
    TotalSleeps = 0;
    TotalSpins = 0;
    TotalTimeouts = 0;
    TotalWaits = 0;
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Wait for the spinlock.                                         */
    /*                                                                  */
    /*   Wait for the spinlock to become free and then claim it.        */
    /*                                                                  */
    /********************************************************************/

BOOLEAN SPINLOCK::WaitForLock( SBIT32 Sleep )
    {
	REGISTER LONG Cpus = ((LONG) NumberOfCpus());
#ifdef ENABLE_LOCK_STATISTICS
    REGISTER SBIT32 Sleeps = 0;
    REGISTER SBIT32 Spins = 0;
    REGISTER SBIT32 Waits = 0;

#endif
    do
        {
        REGISTER SBIT32 Count;
        
		//
		//   If there are already more threads waiting 
		//   than the number of CPUs then the odds of 
		//   getting the lock by spinning are slim, when 
		//   there is only one CPU the chance is zero, so 
		//   just bypass this step.
		//
		if ( (Cpus > 1) && (Cpus > Waiting) )
			{
			//
			//   Wait by spinning and repeatedly testing the
			//   spinlock.  We exit when the lock becomes free 
			//   or the spin limit is exceeded.
			//
			for 
				( 
					Count = MaxSpins;
					(Count > 0) && (Spinlock != LockOpen);
					Count -- 
				);
#ifdef ENABLE_LOCK_STATISTICS

			//
			//   Update the statistics.
			//
			Spins += (MaxSpins - Count);
			Waits ++;
#endif
			}
		else
			{ Count = 0; }

		//
		//   We have exhusted our spin count so it is time to
		//   sleep waiting for the lock to clear.
		//
        if ( Count == 0 )
            {
            //
            //   The lock is still closed so lets go to sleep on 
            //   a semaphore.  However, we must first increment
            //   the waiting count and test the lock one last time
            //   to make sure it is still busy and there is someone
            //   to wake us up later.
            //
            (VOID) AtomicIncrement( & Waiting );

            if ( ! ClaimSpinlock( & Spinlock ) )
                {
                if 
                        ( 
                        WaitForSingleObject( Semaphore, Sleep ) 
                            != 
                        WAIT_OBJECT_0 
                        )
                    {
#ifdef ENABLE_LOCK_STATISTICS
					//
					//   Count the number of times we have  
					//   timed out on this lock.
					//
					(VOID) AtomicIncrement( & TotalTimeouts );

#endif
					return False; 
					}
#ifdef ENABLE_LOCK_STATISTICS

				//
				//   Update the statistics.
				//
                Sleeps ++;
#endif
                }
            else
                {
                //
                //   Lucky - got the lock on the last attempt.
                //   Hence, lets decrement the sleep count and
                //   exit.
                // 
                (VOID) AtomicDecrement( & Waiting );
                
                break; 
                } 
            }
        }
    while ( ! ClaimSpinlock( & Spinlock ) );
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
    TotalSleeps += Sleeps;
    TotalSpins += Spins;
    TotalWaits += Waits;
#endif

    return True;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Wake all sleepers.                                             */
    /*                                                                  */
    /*   Wake all the sleepers who are waiting for the spinlock.        */
    /*   All sleepers are woken because this is much more efficent      */
    /*   and it is known that the lock latency is short.                */
    /*                                                                  */
    /********************************************************************/

VOID SPINLOCK::WakeAllSleepers( VOID )
    {
    REGISTER LONG Wakeup = AtomicExchange( & Waiting, 0 );

	//
	//   We make sure there is still someone to be woken 
	//   up if not we check that the count has not become
	//   negative.
	//
    if ( Wakeup > 0 )
        {
		REGISTER LONG Cpus = ((LONG) NumberOfCpus());

		//
		//   We will only wake enough threads to ensure that 
		//   there is one active thread per CPU.  So if an 
		//   application has hundreds of threads we will try 
		//   prevent the system from becoming swampped.
		//
		if ( Wakeup > Cpus )
			{
			(VOID) AtomicAdd( & Waiting,(Wakeup - Cpus) );
			Wakeup = Cpus; 
			}

        //
        //   Wake up all sleepers as the lock has just been freed.
        //   It is a straight race to decide who gets the lock next.
        //
        if ( ! ReleaseSemaphore( Semaphore, Wakeup, NULL ) )
            { Failure( "Wakeup failed in ReleaseLock()" ); }
        }
    else
        {
        //
        //   When multiple threads pass through the critical  
        //   section it is possible for the 'Waiting' count  
		//   to become negative.  This should be very rare but 
		//   such a negative value needs to be preserved. 
        //
		if ( Wakeup < 0 )
			{ (VOID) AtomicAdd( & Waiting, Wakeup ); }
        }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory a lock.  This call is not thread safe and should       */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

SPINLOCK::~SPINLOCK( VOID )
    {
#ifdef ENABLE_LOCK_STATISTICS
	//
	//   Print the lock statistics.
	//
	DebugPrint
		(
		"Spinlock: \t%8d locks, %d timouts, "
		"%8d locks per wait, %8d spins per wait, %8d waits per sleep.\n",
		TotalLocks,
		TotalTimeouts,
		(TotalLocks / ((TotalWaits <= 0) ? 1 : TotalWaits)),
		(TotalSpins / ((TotalWaits <= 0) ? 1 : TotalWaits)),
		(TotalWaits / ((TotalSleeps <= 0) ? 1 : TotalSleeps))
		);

#endif
	//
	//   Close the semaphore handle.
	//
    if ( ! CloseHandle( Semaphore ) )
        { Failure( "Close semaphore in destructor for SPINLOCK" ); }
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\library\standard.hpp ===
#ifndef _STANDARD_HPP_
#define _STANDARD_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard data types.                                       */
    /*                                                                  */
    /*   The standard data types should be used in preference to the    */
    /*   data types defined in the C++ language.  This is to allow      */
    /*   for easier porting.  If no suitable standard type exists       */
    /*   then one should be created and documented here.                */
    /*                                                                  */
    /********************************************************************/

#define AUTO                          auto
#define CONST						  const
#define CONSTANT                      const
#define EXTERN                        extern
#define GLOBAL                        extern
#define INLINE                        __forceinline
#define LOCAL                         auto
#define REGISTER                      register
#define STATIC                        static
#define VIRTUAL                       virtual
#define VOLATILE                      volatile

    /********************************************************************/
    /*                                                                  */
    /*   The standard C++ types.                                        */
    /*                                                                  */
    /*   The C++ standard reserves various lower case keywords.  This   */
    /*   system uses a similar standard.  All upper case words are      */
    /*   either constants or types.  All words begining with a single   */
    /*   upper case letter are variables.                               */
    /*                                                                  */
    /********************************************************************/

typedef unsigned char                 BOOLEAN;

typedef char                          CHAR;
typedef short int                     SHORT;
typedef int                           INT;
typedef long int                      LONG;

typedef signed char                   SCHAR;
typedef signed short int              SSHORT;
typedef signed int                    SINT;
typedef signed long int               SLONG;

typedef unsigned char                 UCHAR;
typedef unsigned short int            USHORT;
typedef unsigned int                  UINT;
typedef unsigned long int             ULONG;

typedef void                          *POINTER;
typedef unsigned char                 *TEXT;

    /********************************************************************/
    /*                                                                  */
    /*   The optional standard types.                                   */
    /*                                                                  */
    /*   Some of the standard types are specified in other headers.     */
    /*   We need to be careful not to redefine these specifications     */
    /*   if they already exist.                                         */
    /*                                                                  */
    /********************************************************************/

#ifndef CDECL
#define	CDECL						  _cdecl
#endif

#ifndef VOID
#define	VOID						  void
#endif

    /********************************************************************/
    /*                                                                  */
    /*   The fixed length types.                                        */
    /*                                                                  */
    /*   The above types are intended to shadow the standard C++ types  */
    /*   built into the language.  However, these types don't assure    */
    /*   any level of accuracy.  Each of following types is defined     */
    /*   to provide a minimum level of precision.                       */
    /*                                                                  */
    /********************************************************************/

typedef unsigned __int8               BIT8;
typedef unsigned __int16              BIT16;
typedef unsigned __int32              BIT32;
typedef unsigned __int64              BIT64;

typedef signed __int8                 SBIT8;
typedef signed __int16                SBIT16;
typedef signed __int32                SBIT32;
typedef signed __int64                SBIT64;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\library\system.hpp ===
#ifndef _SYSTEM_HPP_
#define _SYSTEM_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard system include files.                             */
    /*                                                                  */
    /*   The standard system include files contain various definitions  */
    /*   used throughout the system.                                    */
    /*                                                                  */
    /********************************************************************/

#include <conio.h>
#include <iostream.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <new.h>
#include <process.h>
#include <time.h>
#include <winsock2.h>
#include <windows.h>

    /********************************************************************/
    /*                                                                  */
    /*   Automatically set the debugging flag if needed.                */
    /*                                                                  */
    /*   There are various standards for enabling dedugging code.       */
    /*   Here we translate on to the standard used in this              */
    /*   application.                                                   */
    /*                                                                  */
    /********************************************************************/

#ifdef _M_IX86
#define ASSEMBLY_X86				  1
#endif

#ifdef _DEBUG
#define DEBUGGING                     1
#endif
#ifndef ALL_COMPLAINTS

    /********************************************************************/
    /*                                                                  */
    /*   Automatically disable anoying warnings.                        */
    /*                                                                  */
    /*   Some of the VC compiler warning are not very helpful so        */
    /*   we disable them here.                                          */
    /*                                                                  */
    /********************************************************************/

#pragma warning( disable : 4100 )
#pragma warning( disable : 4121 )
#pragma warning( disable : 4127 )
#pragma warning( disable : 4511 )
#pragma warning( disable : 4512 )
#pragma warning( disable : 4514 )
#pragma warning( disable : 4701 )
#pragma warning( disable : 4702 )
#pragma warning( disable : 4706 )
#pragma warning( disable : 4710 )
#pragma warning( disable : 4711 )
#pragma warning( disable : 4800 )
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\library\spinlock.hpp ===
#ifndef _SPINLOCK_HPP_
#define _SPINLOCK_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Environment.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The spinlock constants indicate when the lock is open and      */
    /*   when it is closed.                                             */
    /*                                                                  */
    /********************************************************************/

CONST LONG LockClosed				  = 1;
CONST LONG LockOpen					  = 0;

    /********************************************************************/
    /*                                                                  */
    /*   Spinlock and Semaphore locking.                                */
    /*                                                                  */
    /*   This class provides a very conservative locking scheme.        */
    /*   The assumption behind the code is that locks will be           */
    /*   held for a very short time.  When a lock is taken a memory     */
    /*   location is exchanged.  All other threads that want this       */
    /*   lock wait by spinning and sometimes sleeping on a semaphore    */
    /*   until it becomes free again.  The only other choice is not     */
    /*   to wait at all and move on to do something else.  This         */
    /*   module should normally be used in conjunction with cache       */
    /*   aligned memory in minimize cache line misses.                  */
    /*                                                                  */
    /********************************************************************/

class SPINLOCK : public ENVIRONMENT
    {
        //
        //   Private data.
        //
		SBIT32						  MaxSpins;
		SBIT32						  MaxUsers;
#ifdef ENABLE_RECURSIVE_LOCKS
		SBIT32						  Owner;
		SBIT32						  Recursive;
#endif
        HANDLE                        Semaphore;
        VOLATILE SBIT32               Spinlock;
        VOLATILE SBIT32               Waiting;
#ifdef ENABLE_LOCK_STATISTICS

        //
        //   Counters for debugging builds.
        //
        VOLATILE SBIT32               TotalLocks;
        VOLATILE SBIT32               TotalSleeps;
        VOLATILE SBIT32               TotalSpins;
        VOLATILE SBIT32               TotalTimeouts;
        VOLATILE SBIT32               TotalWaits;
#endif

    public:
        //
        //   Public functions.
        //
        SPINLOCK( SBIT32 NewMaxSpins = 4096, SBIT32 NewMaxUsers = 256 );

        INLINE BOOLEAN ClaimLock( SBIT32 Sleep = INFINITE );

        INLINE VOID ReleaseLock( VOID );

        ~SPINLOCK( VOID );

    private:
        //
        //   Private functions.
        //
        INLINE BOOLEAN ClaimSpinlock( VOLATILE SBIT32 *Spinlock );

		INLINE VOID DeleteExclusiveOwner( VOID );

		INLINE VOID NewExclusiveOwner( SBIT32 NewOwner );

        BOOLEAN WaitForLock( SBIT32 Sleep );

        VOID WakeAllSleepers( VOID );

        //
        //   Disabled operations.
        //
        SPINLOCK( CONST SPINLOCK & Copy );

        VOID operator=( CONST SPINLOCK & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   A guaranteed atomic exchange.                                  */
    /*                                                                  */
    /*   An attempt is made to claim the spinlock.  This action is      */
    /*   guaranteed to be atomic.                                       */
    /*                                                                  */
    /********************************************************************/

INLINE BOOLEAN SPINLOCK::ClaimSpinlock( VOLATILE SBIT32 *Spinlock )
    {
    return 
		(
		AtomicCompareExchange( Spinlock,LockClosed,LockOpen ) 
			== 
		LockOpen
		); 
    }

    /********************************************************************/
    /*                                                                  */
    /*   Claim the spinlock.                                            */
    /*                                                                  */
    /*   Claim the lock if available else wait or exit.                 */
    /*                                                                  */
    /********************************************************************/

INLINE BOOLEAN SPINLOCK::ClaimLock( SBIT32 Sleep )
    {
#ifdef ENABLE_RECURSIVE_LOCKS
	REGISTER SBIT32 ThreadId = GetThreadId();

	//
	//   We may already own the spin lock.  If so
	//   we increment the recursive count.  If not 
	//   we have to wait.
	//
	if ( Owner != ThreadId )
		{
#endif
		//
		//   Claim the spinlock.
		//
		if ( ! ClaimSpinlock( & Spinlock ) )
			{
			//
			//   We have to wait.  If we are not 
			//   allowed to sleep or we have timed
			//   out then exit.
			//
			if ( (Sleep == 0) || (! WaitForLock( Sleep )) )
				{ return False; }
			}
#ifdef ENABLE_RECURSIVE_LOCKS

		//
		//   Register the new owner of the lock.
		//
		NewExclusiveOwner( ThreadId );
		}
	else
		{ Recursive ++; }
#endif
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
	(VOID) AtomicIncrement( & TotalLocks );
#endif

    return True;
    }
#ifdef ENABLE_RECURSIVE_LOCKS

    /********************************************************************/
    /*                                                                  */
    /*   New exclusive owner.                                           */
    /*                                                                  */
    /*   Delete the exclusive lock owner information.                   */
    /*                                                                  */
    /********************************************************************/

INLINE VOID SPINLOCK::DeleteExclusiveOwner( VOID )
    {
#ifdef DEBUGGING
	if ( Owner != NULL )
		{ 
#endif
		Owner = NULL; 
#ifdef DEBUGGING
		}
	else
		{ Failure( "Sharelock has no owner in DeleteExclusiveOwner" ); }
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   New exclusive owner.                                           */
    /*                                                                  */
    /*   Register new exclusive lock owner information.                 */
    /*                                                                  */
    /********************************************************************/

INLINE VOID SPINLOCK::NewExclusiveOwner( SBIT32 NewOwner )
    {
#ifdef DEBUGGING
	if ( Owner == NULL )
		{ 
#endif
		Owner = NewOwner; 
#ifdef DEBUGGING
		}
	else
		{ Failure( "Already exclusive in NewExclusiveOwner" ); }
#endif
    }
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Release the spinlock.                                          */
    /*                                                                  */
    /*   Release the lock and if needed wakeup any sleepers.            */
    /*                                                                  */
    /********************************************************************/

INLINE VOID SPINLOCK::ReleaseLock( VOID )
    {
#ifdef ENABLE_RECURSIVE_LOCKS
	//
	//   When we have recursive lock calls we do not 
	//   release the lock until we have exited to the 
	//   top level.
	//
	if ( Recursive <= 0 )
		{
		//
		//   Delete the exclusive owner information.
		//
		DeleteExclusiveOwner();
#endif
#ifdef DEBUGGING

		//
		//   Release the spinlock.
		//
		if ( AtomicExchange( & Spinlock, LockOpen ) == LockClosed )
			{
#else
			(VOID) AtomicExchange( & Spinlock, LockOpen );
#endif

			//
			//   Wakeup anyone who is asleep waiting.
			//
			if ( Waiting > 0 )
				{ WakeAllSleepers(); }
#ifdef DEBUGGING
			}
		else
			{ Failure( "Spinlock released by not held in ReleaseLock" ); } 
#endif
#ifdef ENABLE_RECURSIVE_LOCKS
		}
	else
		{ Recursive --; }
#endif
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\library\stack.hpp ===
#ifndef _STACK_HPP_
#define _STACK_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Lock.hpp"
#include "Vector.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The stack constants specify the initial size of the stack.     */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 StackSize				  = 1024;

    /********************************************************************/
    /*                                                                  */
    /*   Stacks and stack management.                                   */
    /*                                                                  */
    /*   This class provides general purpose stacks along with some     */
    /*   basic management.  The stacks are optimized for very high      */
    /*   performance on SMP systems.  Whenever possible multiple        */
    /*   items should added and removed from a stack at the same time.  */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK=NO_LOCK> class STACK : public LOCK
    {
        //
        //   Private data.
        //
        SBIT32                        MaxSize;
        SBIT32                        Top;

        VECTOR<TYPE>                  Stack;

    public:
        //
        //   Public functions.
        //
        STACK( SBIT32 NewMaxSize = StackSize );

        BOOLEAN MultiplePopStack
            ( 
            SBIT32                        Requested, 
            TYPE                          Data[], 
            SBIT32                        *Size 
            );

        BOOLEAN MultiplePopStackReversed
            ( 
            SBIT32                        Requested, 
            TYPE                          Data[], 
            SBIT32                        *Size 
            );

        VOID MultiplePushStack
            ( 
            CONST TYPE					  Data[], 
            CONST SBIT32				  Size 
            );

        VOID MultiplePushStackReversed
            ( 
            CONST TYPE					  Data[], 
            CONST SBIT32				  Size 
            );

        BOOLEAN PeekStack( TYPE *Data );

        BOOLEAN PopStack( TYPE *Data );

        VOID PushStack( CONST TYPE & Data );

        BOOLEAN ReadStack( SBIT32 Index, TYPE *Data );

        VOID ReverseStack( VOID );

        BOOLEAN UpdateStack
            ( 
            CONST SBIT32				  Index, 
            CONST TYPE					  & Data 
            );

        ~STACK( VOID );

		//
		//   Public inline functions.
		//
        INLINE SBIT32 SizeOfStack( VOID ) 
			{ return Top; }

	private:
        //
        //   Disabled operations.
        //
        STACK( CONST STACK & Copy );

        VOID operator=( CONST STACK & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new stack and prepare it for use.  This call is       */
    /*   not thread safe and should only be made in a single thread     */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> STACK<TYPE,LOCK>::STACK( SBIT32 NewMaxSize ) : 
		//
		//   Call the constructors for the contained classes.
		//
		Stack( NewMaxSize,1,CacheLineSize )
    {
#ifdef DEBUGGING
    if ( NewMaxSize > 0 )
        {
#endif
        MaxSize = NewMaxSize;
        Top = 0;
#ifdef DEBUGGING
        }
    else
        { Failure( "Size in constructor for STACK" ); }
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Remove multiple items from a stack.                            */
    /*                                                                  */
    /*   We remove multiple items from a stack and check to make sure   */
    /*   that the stack is not empty.                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN STACK<TYPE,LOCK>::MultiplePopStack
        ( 
        SBIT32                        Requested, 
        TYPE                          Data[], 
        SBIT32                        *Size 
        )
    {
	REGISTER BOOLEAN Result;

	//
	//   Claim an exclisive lock (if enabled).
	//
	ClaimExclusiveLock();

	//
	//   If the stack is not empty return the 
	//   top elements.
    if ( Top > 0 )
        {
        REGISTER SBIT32 Count;

        (*Size) = (Top >= Requested) ? Requested : Top;

        for ( Count = ((*Size) - 1);Count >= 0;Count -- )
            { Data[ Count ] = Stack[ -- Top ]; }

		Result = True;
        }
    else
		{ Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
	ReleaseExclusiveLock();

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Remove multiple items from a stack in reverse order.           */
    /*                                                                  */
    /*   We remove multiple items from a stack in reverse order and     */
    /*   check to make sure that the stack is not empty.                */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN STACK<TYPE,LOCK>::MultiplePopStackReversed
        ( 
        SBIT32                        Requested, 
        TYPE                          Data[], 
        SBIT32                        *Size 
        )
    {
	REGISTER BOOLEAN Result;

	//
	//   Claim an exclisive lock (if enabled).
	//
	ClaimExclusiveLock();

	//
	//   If the stack is not empty return the 
	//   top elements.
    if ( Top > 0 )
        {
        REGISTER SBIT32 Count;

        (*Size) = (Top >= Requested) ? Requested : Top;

        for ( Count = 0;Count < (*Size);Count ++ )
            { Data[ Count ] = Stack[ -- Top ]; }

		Result = True;
        }
    else
		{ Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
	ReleaseExclusiveLock();

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Add multiple items to a stack.                                 */
    /*                                                                  */
    /*   We add multiple items to a stack and check to make sure that   */
    /*   the stack has not overflowed.  If the stack has overflowed     */
    /*   we double its size.                                            */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID STACK<TYPE,LOCK>::MultiplePushStack
        ( 
        CONST TYPE					  Data[],
        CONST SBIT32				  Size 
        )
    {
    REGISTER SBIT32 Count;

	//
	//   Claim an exclisive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   If the stack will overflow then expand it.
	//
    while ( (Top + Size) >= MaxSize )
        { Stack.Resize( (MaxSize *= ExpandStore) ); }

	//
	//   Push the new elements.
	//
    for ( Count = 0;Count < Size;Count ++ )
        { Stack[ Top ++ ] = Data[ Count ]; }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Add multiple items to a stack in reverse order.                */
    /*                                                                  */
    /*   We add multiple items to a stack in reverse order and check    */
    /*   to make sure that the stack has not overflowed.  If the stack  */
    /*   has overflowed we double its size.                             */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID STACK<TYPE,LOCK>::MultiplePushStackReversed
        ( 
        CONST TYPE					  Data[],
        CONST SBIT32				  Size 
        )
    {
    REGISTER SBIT32 Count;

	//
	//   Claim an exclisive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   If the stack will overflow then expand it.
	//
    while ( (Top + Size) >= MaxSize )
        { Stack.Resize( (MaxSize *= ExpandStore) ); }

	//
	//   Push the new elements in reverse order.
	//
    for ( Count = (Size-1);Count >= 0;Count -- )
        { Stack[ Top ++ ] = Data[ Count ]; }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Peek at the top of stack.                                      */
    /*                                                                  */
    /*   We return the top of stack with a pop but check to make sure   */
    /*   that the stack is not empty.                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN STACK<TYPE,LOCK>::PeekStack
		( 
		TYPE						  *Data 
		)
    {
    REGISTER BOOLEAN Result;

	//
	//   Claim an shared lock (if enabled).
	//
    ClaimSharedLock();

	//
	//   If the stack is not empty return a copy
	//   of the top element.
	//
    if ( Top > 0 )
		{ 
		(*Data) = Stack[ (Top - 1) ];

		Result = True;
		}
	else
		{ Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
	ReleaseSharedLock();

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Remove a single item from a stack.                             */
    /*                                                                  */
    /*   We remove a single item from a stack and check to make sure    */
    /*   that the stack is not empty.                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN STACK<TYPE,LOCK>::PopStack
		( 
		TYPE						  *Data 
		)
    {
    REGISTER BOOLEAN Result;

    //
	//   Claim an exclisive lock (if enabled).
	//
	ClaimExclusiveLock();

	//
	//   If the stack is not empty return the
	//   top element.
	//
    if ( Top > 0 )
		{ 
		(*Data) = Stack[ -- Top ];
		
		Result = True;
		}
	else
		{ Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
	ReleaseExclusiveLock();

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Add a single item to a stack.                                  */
    /*                                                                  */
    /*   We add a single item to a stack and check to make sure that    */
    /*   the stack has not overflowed.  If the stack has overflowed     */
    /*   we double its size.                                            */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID STACK<TYPE,LOCK>::PushStack
		( 
		CONST TYPE					  & Data
		)
    {    
	//
	//   Claim an exclisive lock (if enabled).
	//
	ClaimExclusiveLock();

	//
	//   If the stack is full then expand it.
	//
    while ( Top >= MaxSize )
        { Stack.Resize( (MaxSize *= ExpandStore) ); }

	//
	//   Push a new element.
	//
    Stack[ Top ++ ] = Data;

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();
	}

    /********************************************************************/
    /*                                                                  */
    /*   Read a stack value.                                            */
    /*                                                                  */
    /*   We return a single item from the stack but check to make       */
    /*   sure that it exists.            .                              */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN STACK<TYPE,LOCK>::ReadStack
        ( 
        SBIT32                        Index, 
        TYPE                          *Data 
        )
    {
	REGISTER BOOLEAN Result;

	//
	//   Claim an shared lock (if enabled).
	//
    ClaimSharedLock();

	//
	//   If the element exists then return a copy of
	//   it to the caller.
	//
    if ( Index < Top )
		{ 
		(*Data) = Stack[ Index ];
		
		Result = True;
		}
	else
		{ Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
	ReleaseSharedLock();

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Reverse the stack.                                             */
    /*                                                                  */
    /*   We reverse the order of the stack to make effectively          */
    /*   make it a queue.                .                              */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID STACK<TYPE,LOCK>::ReverseStack( VOID )
    {
	REGISTER SBIT32 Count;
	REGISTER SBIT32 MidPoint = (Top / 2);

	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   Swap all elements around the mid point.
	//
	for ( Count=0;Count < MidPoint;Count ++ )
		{
		REGISTER TYPE *Low = & Stack[ Count ];
		REGISTER TYPE *High = & Stack[ (Top - Count - 1) ];
		REGISTER TYPE Temp = (*Low);

		(*Low) = (*High);
		(*High) = Temp;
		}

	//
	//   Release any lock we claimed earlier.
	//
	ReleaseExclusiveLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Update a stack value.                                          */
    /*                                                                  */
    /*   We update a single item on the stack but check to make         */
    /*   sure that it exists.            .                              */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN STACK<TYPE,LOCK>::UpdateStack
        ( 
        CONST SBIT32				  Index, 
        CONST TYPE					  & Data 
        )
    {
	REGISTER BOOLEAN Result;

	//
	//   Claim an exclisive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   If the element exists then update it.
	//
    if ( Index < Top )
		{ 
		Stack[ Index ] = Data;

		Result = True;
		}
	else
		{ Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
	ReleaseExclusiveLock();

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the stack.  This call is not thread safe and should    */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> STACK<TYPE,LOCK>::~STACK( VOID )
    { /* void */ }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\services\buffer.cpp ===
/***************************************************************************\
*
* File: Buffer.cpp
*
* Description:
* Buffer.cpp implementats objects used in buffering operations, including 
* double buffering, DX-Transforms, etc.  These objects are maintained by a 
* central BufferManager that is available process-wide.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Services.h"
#include "Buffer.h"

#include "FastDib.h"
#include "GdiCache.h"
#include "OSAL.h"
#include "ResourceManager.h"
#include "Surface.h"
#include "Context.h"

#define DEBUG_COPYTOCLIPBOARD   0   // Copy buffer to clipboard
#define DEBUG_DUMPREGION        0   // Dump regions

#if DEBUG_DUMPREGION

#define DUMP_REGION(name, rgn)
    DumpRegion(name, rgn)

void
DumpRegion(LPCTSTR pszName, HRGN hrgn)
{
    RECT rc;
    int nType = GetRgnBox(hrgn, &rc);
    switch (nType)
    {
    case NULLREGION:
        Trace("Null region %s = 0x%p\n", pszName, hrgn);
        break;

    case SIMPLEREGION:
        Trace("Simple region %s = 0x%p (%d,%d)-(%d,%d)\n", pszName, hrgn, rc.left, rc.top, rc.right, rc.bottom);
        break;

    case COMPLEXREGION:
        Trace("Complex region %s = 0x%p (%d,%d)-(%d,%d)\n", pszName, hrgn, rc.left, rc.top, rc.right, rc.bottom);
        break;

    default:
        Trace("Illegal region %s = 0x%p\n", pszName, hrgn);
    }
}

#else

#define DUMP_REGION(name, rgn) ((void) 0)

#endif


/***************************************************************************\
*****************************************************************************
*
* class BufferManager
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
BufferManager::BufferManager()
{
#if ENABLE_DUMPCACHESTATS
    m_cacheDCBmpCached.SetName("DCBmpCached");
    m_cacheGpBmpCached.SetName("GpBmpCached");
#endif
}


//------------------------------------------------------------------------------
BufferManager::~BufferManager()
{
    if (m_pbufGpBmpShared != NULL) {
        ProcessDelete(GpBmpBuffer, m_pbufGpBmpShared);
        m_pbufGpBmpShared = NULL;
    }

    AssertMsg(m_pbufTrx == NULL, "Ensure all buffers have been destroyed");
}


//------------------------------------------------------------------------------
void        
BufferManager::Destroy()
{
    RemoveAllTrxBuffers();

    m_cacheDCBmpCached.Destroy();
    m_cacheGpBmpCached.Destroy();
}


/***************************************************************************\
*
* BufferManager::BeginTransition
*
* BeginTransition() finds a TrxBuffer to be used for a new Transition.  If
* no cached, correct-format TrxBuffers are available, a new TrxBuffer is
* created.  When the caller is finished with the buffer, it should be
* returned with EndTransition().
*
\***************************************************************************/

HRESULT
BufferManager::BeginTransition(
    IN  SIZE sizePxl,               // Minimum size of each buffer, in pixels
    IN  int cSurfaces,              // Number of buffers
    IN  BOOL fExactSize,            // Buffer size must be an exact match
    OUT TrxBuffer ** ppbuf)         // Transition Buffer
{
    AssertMsg((sizePxl.cx > 0) && (sizePxl.cy > 0) && (sizePxl.cx < 2000) && (sizePxl.cy < 2000),
            "Ensure reasonable buffer size");
    AssertMsg((cSurfaces > 0) && (cSurfaces <= 3), "Ensure reasonable number of buffers");
    AssertWritePtr(ppbuf);
    HRESULT hr;
    *ppbuf = NULL;

    //
    // Part 1: Check if an existing buffer is large enough / the correct size.
    //

    if (m_pbufTrx != NULL) {
        SIZE sizeExistPxl = m_pbufTrx->GetSize();

        if (fExactSize) {
            if ((sizePxl.cx != sizeExistPxl.cx) || (sizePxl.cy != sizeExistPxl.cy)) {
                ClientDelete(TrxBuffer, m_pbufTrx);
                m_pbufTrx = NULL;
            }
        } else {
            if ((sizePxl.cx > sizeExistPxl.cx) || (sizePxl.cy > sizeExistPxl.cy)) {
                ClientDelete(TrxBuffer, m_pbufTrx);
                m_pbufTrx = NULL;
            }
        }
    }

    //
    // Part 2: Create a new buffer, if needed
    //

    if (m_pbufTrx == NULL) {
        hr = TrxBuffer::Build(sizePxl, cSurfaces, &m_pbufTrx);
        if (FAILED(hr)) {
            return hr;
        }
    }

    AssertMsg(!m_pbufTrx->GetInUse(), "Ensure the buffer isn't already in use");
    m_pbufTrx->SetInUse(TRUE);

    *ppbuf = m_pbufTrx;
    return S_OK;
}


/***************************************************************************\
*
* BufferManager::EndTransition
*
* EndTransition() is called to return a TrxBuffer to the BufferManager
* after use.
*
\***************************************************************************/

void        
BufferManager::EndTransition(
    IN  TrxBuffer * pbufTrx,        // TrxBuffer being returned
    IN  BOOL fCache)                // Add the buffer to the available cache
{
    AssertMsg(m_pbufTrx->GetInUse(), "Ensure the buffer was being used");
    AssertMsg(m_pbufTrx == pbufTrx, "Ensure correct buffer");

    pbufTrx->SetInUse(FALSE);

    if (!fCache) {
        //
        // For now, since DxXForm's must always be the correct size, there 
        // isn't much point in caching them and we can reclaim the memory.  If 
        // this changes, reinvestigate caching them.
        //

        ClientDelete(TrxBuffer, m_pbufTrx);
        m_pbufTrx = NULL;
    }
}


/***************************************************************************\
*
* BufferManager::FlushTrxBuffers
*
* FlushTrxBuffers() is called when all TrxBuffers must be forceably released, 
* for example when DXTX shuts down.
*
\***************************************************************************/

void        
BufferManager::FlushTrxBuffers()
{
    RemoveAllTrxBuffers();
}


/***************************************************************************\
*
* BufferManager::RemoveAllTrxBuffers
*
* RemoveAllTrxBuffers() cleans up all resources associated with all
* TrxBuffers.
*
\***************************************************************************/

void        
BufferManager::RemoveAllTrxBuffers()
{
    if (m_pbufTrx != NULL) {
        AssertMsg(!m_pbufTrx->GetInUse(), "Buffer should not be in use");
        ClientDelete(TrxBuffer, m_pbufTrx);
        m_pbufTrx = NULL;
    }
}


//------------------------------------------------------------------------------
HRESULT     
BufferManager::GetCachedBuffer(DuSurface::EType type, BmpBuffer ** ppbuf)
{
    AssertWritePtr(ppbuf);

    switch (type)
    {
    case DuSurface::stDC:
        if ((*ppbuf = m_cacheDCBmpCached.Get()) == NULL) {
            return E_OUTOFMEMORY;
        }
        break;

    case DuSurface::stGdiPlus:
        if ((*ppbuf = m_cacheGpBmpCached.Get()) == NULL) {
            return E_OUTOFMEMORY;
        }
        break;

    default:
        AssertMsg(0, "Unknown surface type");
        return E_NOTIMPL;
    }

    return S_OK;
}


//------------------------------------------------------------------------------
void        
BufferManager::ReleaseCachedBuffer(BmpBuffer * pbuf)
{
    AssertReadPtr(pbuf);

    switch (pbuf->GetType())
    {
    case DuSurface::stDC:
        m_cacheDCBmpCached.Release(static_cast<DCBmpBuffer*>(pbuf));
        break;

    case DuSurface::stGdiPlus:
        m_cacheGpBmpCached.Release(static_cast<GpBmpBuffer*>(pbuf));
        break;

    default:
        AssertMsg(0, "Unknown surface type");
    }
}


/***************************************************************************\
*****************************************************************************
*
* class DCBmpBuffer
*
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* DCBmpBuffer::DCBmpBuffer
*
* DCBmpBuffer() fully initializes a new DCBmpBuffer object.
*
\***************************************************************************/

DCBmpBuffer::DCBmpBuffer()
{

}


/***************************************************************************\
*
* DCBmpBuffer::~DCBmpBuffer
*
* ~DCBmpBuffer() cleans up all resources associated with the buffer.
*
\***************************************************************************/

DCBmpBuffer::~DCBmpBuffer()
{
    EndDraw(FALSE);
    FreeBitmap();
}


/***************************************************************************\
*
* DCBmpBuffer::BeginDraw
*
* BeginDraw() sets up the DCBmpBuffer to begin a drawing cycle.  The final
* destination HDC and size are passed in, and a new "temporary" HDC is
* returned out.
*
\***************************************************************************/

HRESULT
DCBmpBuffer::BeginDraw(
    IN  DuSurface * psrfDraw,       // Final destination Surface
    IN  const RECT * prcInvalid,    // Invalid area of destination
    IN  UINT nCmd,                  // How the buffer is to be used
    OUT DuSurface ** ppsrfBuffer)   // Surface of buffer or NULL if not needed
{
    AssertMsg(prcInvalid != NULL, "Must specify a valid area");
    AssertWritePtr(ppsrfBuffer);
    *ppsrfBuffer = NULL;

    HDC hdcDraw = CastHDC(psrfDraw);


    //
    // Ensure not in the middle of drawing.
    //
    EndDraw(FALSE);

    //
    // Determine the size of the area to draw and ensure that the buffer is 
    // large enough.
    //
    SIZE sizeBmp;
    sizeBmp.cx     = prcInvalid->right - prcInvalid->left;
    sizeBmp.cy     = prcInvalid->bottom - prcInvalid->top;

    if ((sizeBmp.cx == 0) || (sizeBmp.cy == 0)) {
        //
        // Nothing to draw / buffer, so just let drawing occur in the given
        // buffer.  Signal this by returning NULL so that the caller knows
        // not to create extra, unnecessary data.
        //

        AssertMsg(!m_fChangeOrg, "Ensure valid state");
        AssertMsg(m_hdcDraw == NULL, "Ensure valid state");

        return S_OK;
    }

    if ((sizeBmp.cx > m_sizeBmp.cx) || (sizeBmp.cy > m_sizeBmp.cy)) {
        //
        // When allocating a new bitmap, make it large enough to consume the
        // existing bitmap.  This helps avoid swapping between two different
        // bitmaps.
        //
        // TODO: Need to add code into the BufferManager that maintains multiple
        // bitmaps of different sizes so that we don't get many rarely-used, 
        // giant bitmaps.
        //

        if (!AllocBitmap(hdcDraw, 
                max(sizeBmp.cx, m_sizeBmp.cx), 
                max(sizeBmp.cy, m_sizeBmp.cy))) {

            return DU_E_OUTOFGDIRESOURCES;
        }
    }

    AssertMsg((prcInvalid->right >= prcInvalid->left) && 
            (prcInvalid->bottom >= prcInvalid->top), "Check normalized");

    //
    // Setup the drawing
    //
    m_hdcBitmap = CreateCompatibleDC(hdcDraw);
    if (m_hdcBitmap == NULL) {
        return DU_E_OUTOFGDIRESOURCES;
    }

    if (SupportXForm()) {
        m_nOldGfxMode = SetGraphicsMode(m_hdcBitmap, GM_ADVANCED);
    }
    m_hbmpOld       = (HBITMAP) SelectObject(m_hdcBitmap, m_hbmpBuffer);

    HPALETTE hpal   = (HPALETTE) GetCurrentObject(hdcDraw, OBJ_PAL);
    if (hpal != NULL) {
        m_hpalOld   = SelectPalette(m_hdcBitmap, hpal, FALSE);
    } else {
        m_hpalOld   = NULL;
    }

    m_hdcDraw       = hdcDraw;
    m_ptDraw.x      = prcInvalid->left;
    m_ptDraw.y      = prcInvalid->top;
    m_sizeDraw.cx   = prcInvalid->right - prcInvalid->left;
    m_sizeDraw.cy   = prcInvalid->bottom - prcInvalid->top;
    m_nCmd          = nCmd;

    if ((m_ptDraw.x != 0) || (m_ptDraw.y != 0)) {
        /*
         * The buffer size is minimized to the painting area, so we need to
         * setup some stuff to "fake" GDI and do the right thing:
         * 1. Change the brush origin so that it the end result appears 
         *    consistent
         * 2. Change the window origin so that the drawing is in the upper
         *    left corner.
         *
         * We will set this back when we are done drawing.
         */

        POINT ptBrushOrg;
        GetBrushOrgEx(m_hdcBitmap, &ptBrushOrg);
        SetBrushOrgEx(m_hdcBitmap, 
                ptBrushOrg.x - m_ptDraw.x, ptBrushOrg.y - m_ptDraw.y, 
                &m_ptOldBrushOrg);

        m_fChangeOrg = TRUE;
    } else {
        m_fChangeOrg = FALSE;
    }

    OS()->PushXForm(m_hdcBitmap, &m_xfOldBitmap);
    OS()->PushXForm(m_hdcDraw, &m_xfOldDraw);
    m_fChangeXF     = TRUE;
    m_fClip         = FALSE;

#if DEBUG_COPYTOCLIPBOARD
#if DBG
    RECT rcFill;
    rcFill.left     = 0;
    rcFill.top      = 0;
    rcFill.right    = m_sizeBmp.cx;
    rcFill.bottom   = m_sizeBmp.cy;
    FillRect(m_hdcBitmap, &rcFill, GetStdColorBrushI(SC_Plum));
#endif // DBG
#endif // DEBUG_COPYTOCLIPBOARD


    //
    // Setup the buffer as necessary
    //

    if (m_nCmd == BmpBuffer::dcCopyBkgnd) {
        //
        // Copy the destination to the buffer to be used as a background.
        //

        BitBlt(m_hdcBitmap, 0, 0, m_sizeDraw.cx, m_sizeDraw.cy, 
                m_hdcDraw, m_ptDraw.x, m_ptDraw.y, SRCCOPY);
    }


    //
    // Clip drawing in the buffer to the actual used part of the buffer.  Since
    // this is the only part that will be copied over, we don't want to draw 
    // outside of this area since it slows down performance.
    //

    GdiCache * pgc = GetGdiCache();

    HRGN hrgnClip = pgc->GetTempRgn();
    if (hrgnClip != NULL) {
        SetRectRgn(hrgnClip, 0, 0, m_sizeDraw.cx, m_sizeDraw.cy);
        ExtSelectClipRgn(m_hdcBitmap, hrgnClip, RGN_COPY);


        //
        // If the destination surface had a clipping region, we need to 
        // propagate it over to the buffer.
        //

        HRGN hrgnDraw = pgc->GetTempRgn();
        if (hrgnDraw != NULL) {
            if (GetClipRgn(m_hdcDraw, hrgnDraw) == 1) {

                OffsetRgn(hrgnDraw, -m_ptDraw.x, -m_ptDraw.y);
                ExtSelectClipRgn(m_hdcBitmap, hrgnDraw, RGN_AND);
            }

            pgc->ReleaseTempRgn(hrgnDraw);
        }
        pgc->ReleaseTempRgn(hrgnClip);
    }


    //
    // Create a new Surface to contain the buffer.
    //

    return DuDCSurface::Build(m_hdcBitmap, (DuDCSurface **) ppsrfBuffer);
}


/***************************************************************************\
*
* DCBmpBuffer::Fill
*
* TOOD:
*
\***************************************************************************/

void        
DCBmpBuffer::Fill(COLORREF cr)
{
    HBRUSH hbr = CreateSolidBrush(cr);

    RECT rcFill;
    rcFill.left     = 0;
    rcFill.top      = 0;
    rcFill.right    = m_sizeDraw.cx;
    rcFill.bottom   = m_sizeDraw.cy;
    
    FillRect(m_hdcBitmap, &rcFill, hbr);

    DeleteObject(hbr);
}


/***************************************************************************\
*
* DCBmpBuffer::PreEndDraw
*
* PreEndDraw() finished a drawing cycle that was previously started with
* BeginDraw().  If fCommit is TRUE, the temporary buffer is prepared to be
* copied to the final destination.  The called MUST also call EndDraw()
* to properly end the drawing cycle.
*
\***************************************************************************/

void        
DCBmpBuffer::PreEndDraw(
    IN  BOOL fCommit)               // Copy to final destination
{
    //
    // Resource the destination and buffer surfaces back to where they started.
    // This is important because they will be changed during the drawing.
    //

    if (m_fChangeXF) {
        OS()->PopXForm(m_hdcBitmap, &m_xfOldBitmap);
        OS()->PopXForm(m_hdcDraw, &m_xfOldDraw);
        m_fChangeXF = FALSE;
    }

    if (m_fChangeOrg) {
        SetBrushOrgEx(m_hdcBitmap, m_ptOldBrushOrg.x, m_ptOldBrushOrg.y, NULL);
        m_fChangeOrg = FALSE;
    }

    if ((fCommit) && (m_hdcDraw != NULL)) {
        //
        // Setup any clipping region needed to limit the buffer to an area
        // in the destination surface.
        //

        if (m_fClip) {
            AssertMsg(m_hrgnDrawClip != NULL, "Must have valid region");
            AssertMsg(m_hrgnDrawOld == NULL, "Ensure no outstanding region");

            m_hrgnDrawOld = GetGdiCache()->GetTempRgn();
            if (m_hrgnDrawOld != NULL) {
                DUMP_REGION("m_hrgnDrawOld", m_hrgnDrawOld);
                if (GetClipRgn(m_hdcDraw, m_hrgnDrawOld) <= 0) {
                    GetGdiCache()->ReleaseTempRgn(m_hrgnDrawOld);
                    m_hrgnDrawOld = NULL;
                }

                DUMP_REGION("m_hrgnDrawClip", m_hrgnDrawClip);
                ExtSelectClipRgn(m_hdcDraw, m_hrgnDrawClip, RGN_COPY);
            }
        }
    }
}



/***************************************************************************\
*
* DCBmpBuffer::EndDraw
*
* EndDraw() presents a drawing cycle that was previously started with
* BeginDraw().  If fCommit is TRUE, the temporary buffer is copied to the 
* final destination.  The caller MUST first call PreEndDraw() to properly 
* setup any state needed to end the drawing cycle.
*
\***************************************************************************/

void        
DCBmpBuffer::EndDraw(
    IN  BOOL fCommit,               // Copy to final destination
    IN  BYTE bAlphaLevel,           // General alpha level
    IN  BYTE bAlphaFormat)          // Pixel alpha format
{
    if ((fCommit) && (m_hdcDraw != NULL)) {
        //
        // Copy the bits over
        //

        if (bAlphaLevel == BLEND_OPAQUE) {
            BitBlt(m_hdcDraw, m_ptDraw.x, m_ptDraw.y, m_sizeDraw.cx, m_sizeDraw.cy, 
                    m_hdcBitmap, 0, 0, SRCCOPY);
        } else {
            BLENDFUNCTION bf;
            bf.AlphaFormat  = bAlphaFormat;
            bf.BlendFlags   = 0;
            bf.BlendOp      = AC_SRC_OVER;
            bf.SourceConstantAlpha = bAlphaLevel;

            AlphaBlend(m_hdcDraw, m_ptDraw.x, m_ptDraw.y, m_sizeDraw.cx, m_sizeDraw.cy, 
                    m_hdcBitmap, 0, 0, m_sizeDraw.cx, m_sizeDraw.cy, bf);
        }
    }
}


/***************************************************************************\
*
* DCBmpBuffer::PostEndDraw
*
* PostEndDraw() finished a drawing cycle that was previously started with
* BeginDraw().  After this function finishes, the buffer is ready to be used
* again.  
*
\***************************************************************************/

void        
DCBmpBuffer::PostEndDraw()
{
    if (m_hdcDraw != NULL) {
        //
        // Cleanup the temporary clipping region.  This is VERY important to
        // do so that the destination surface can continued to be drawn on.
        // (For example, more Gadget siblings...)
        //

        if (m_fClip) {
            //
            // NOTE: m_hrgnDrawOld may be NULL if there was no previous clipping 
            // region.
            //

            ExtSelectClipRgn(m_hdcDraw, m_hrgnDrawOld, RGN_COPY);
            if (m_hrgnDrawOld != NULL) {
                GetGdiCache()->ReleaseTempRgn(m_hrgnDrawOld);
                m_hrgnDrawOld = NULL;
            }
        }
    }


    //
    // Cleanup the clipping region
    //

    if (m_fClip) {
        AssertMsg(m_hrgnDrawClip != NULL, "Must have a valid region");
        GetGdiCache()->ReleaseTempRgn(m_hrgnDrawClip);
        m_hrgnDrawClip = NULL;
        m_fClip = FALSE;
    }
    AssertMsg(m_hrgnDrawClip == NULL, "Should no longer have a clipping region");


    //
    // Cleanup associated resources
    //

    if (m_hdcBitmap != NULL) {
        if (m_hpalOld != NULL) {
            SelectPalette(m_hdcBitmap, m_hpalOld, TRUE);
            m_hpalOld = NULL;
        }

        SelectObject(m_hdcBitmap, m_hbmpOld);
        if (SupportXForm()) {
            SetGraphicsMode(m_hdcBitmap, m_nOldGfxMode);
        }
        DeleteDC(m_hdcBitmap);
        m_hdcBitmap = NULL;

#if DEBUG_COPYTOCLIPBOARD
#if DBG

        if (OpenClipboard(NULL)) {
            EmptyClipboard();
            HBITMAP hbmpCopy = (HBITMAP) CopyImage(m_hbmpBuffer, IMAGE_BITMAP, 0, 0, 0);

            HDC hdc = GetGdiCache()->GetCompatibleDC();
            HBITMAP hbmpOld = (HBITMAP) SelectObject(hdc, hbmpCopy);

            // Outline the actual drawn area
            RECT rcDraw;
            rcDraw.left     = 0;
            rcDraw.top      = 0;
            rcDraw.right    = m_sizeDraw.cx;
            rcDraw.bottom   = m_sizeDraw.cy;
            GdDrawOutlineRect(hdc, &rcDraw, GetStdColorBrushI(SC_Crimson), 1);

            SelectObject(hdc, hbmpOld);
            GetGdiCache()->ReleaseCompatibleDC(hdc);

            SetClipboardData(CF_BITMAP, hbmpCopy);
            CloseClipboard();
        }

#endif // DBG
#endif // DEBUG_COPYTOCLIPBOARD
    }

    m_hdcDraw   = NULL;
    m_hbmpOld   = NULL;

    if (GetContext()->GetPerfMode() == IGPM_SIZE) {
        FreeBitmap();
    }
}


//------------------------------------------------------------------------------
void        
DCBmpBuffer::SetupClipRgn()
{
    AssertMsg(!m_fClip, "Only should setup clip region once per cycle");
    AssertMsg(m_hrgnDrawClip == NULL, "Should not already have a clip region");

    m_hrgnDrawClip = GetGdiCache()->GetTempRgn();
    if (m_hrgnDrawClip == NULL) {
        return;
    }

    
    //
    // NOTE: GetClipRgn() does NOT return the standard region return values.
    //

    if (GetClipRgn(m_hdcBitmap, m_hrgnDrawClip) == 1) {
        DUMP_REGION("m_hrgnDrawClip", m_hrgnDrawClip);

        OffsetRgn(m_hrgnDrawClip, m_ptDraw.x, m_ptDraw.y);
        m_fClip = TRUE;
    } else {
        GetGdiCache()->ReleaseTempRgn(m_hrgnDrawClip);
        m_hrgnDrawClip = NULL;
    }
}


/***************************************************************************\
*
* DCBmpBuffer::InUse
*
* InUse() returns if the DCBmpBuffer is currently in a draw cycle started from
* BeginDraw().
*
\***************************************************************************/

BOOL        
DCBmpBuffer::InUse() const
{
    return m_hdcDraw != NULL;
}


/***************************************************************************\
*
* DCBmpBuffer::AllocBitmap
*
* AllocBitmap() allocates the internal bitmap buffer that is used to 
* temporarily draw into.  This bitmap will be compatible with the final
* destination surface.
*
\***************************************************************************/

BOOL        
DCBmpBuffer::AllocBitmap(
    IN  HDC hdcDraw,                // Final destination HDC
    IN  int cx,                     // Width of new bitmap
    IN  int cy)                     // Height of new bitmap
{
    FreeBitmap();

    //
    // When allocating a bitmap, round up to a multiple of 16 x 16.  This helps
    // to reduce unnecessary reallocations because we grew by one or two pixels.
    //

    cx = ((cx + 15) / 16) * 16;
    cy = ((cy + 15) / 16) * 16;


    //
    // Allocate the bitmap
    //

#if 0
    m_hbmpBuffer = CreateCompatibleBitmap(hdcDraw, cx, cy);
#else
    m_hbmpBuffer = ResourceManager::RequestCreateCompatibleBitmap(hdcDraw, cx, cy);
#endif
    if (m_hbmpBuffer == NULL) {
        return FALSE;
    }

    m_sizeBmp.cx = cx;
    m_sizeBmp.cy = cy;
    return TRUE;
}


/***************************************************************************\
*
* DCBmpBuffer::FreeBitmap
*
* FreeBitmap() cleans up allocated resources.
*
\***************************************************************************/

void
DCBmpBuffer::FreeBitmap()
{
    if (m_hbmpBuffer != NULL) {
        DeleteObject(m_hbmpBuffer);
        m_hbmpBuffer = NULL;
        m_sizeBmp.cx = 0;
        m_sizeBmp.cy = 0;
    }
}


/***************************************************************************\
*****************************************************************************
*
* class GpBmpBuffer
*
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* GpBmpBuffer::GpBmpBuffer
*
* GpBmpBuffer() fully initializes a new GpBmpBuffer object.
*
\***************************************************************************/

GpBmpBuffer::GpBmpBuffer()
{

}


/***************************************************************************\
*
* GpBmpBuffer::~GpBmpBuffer
*
* ~GpBmpBuffer() cleans up all resources associated with the buffer.
*
\***************************************************************************/

GpBmpBuffer::~GpBmpBuffer()
{
    EndDraw(FALSE);
    FreeBitmap();
}


/***************************************************************************\
*
* GpBmpBuffer::BeginDraw
*
* BeginDraw() sets up the GpBmpBuffer to begin a drawing cycle.  The final
* destination HDC and size are passed in, and a new "temporary" HDC is
* returned out.
*
\***************************************************************************/

HRESULT
GpBmpBuffer::BeginDraw(
    IN  DuSurface * psrfDraw,       // Final destination Surface
    IN  const RECT * prcInvalid,    // Invalid area of destination
    IN  UINT nCmd,                  // How the buffer is to be used
    OUT DuSurface ** ppsrfBuffer)   // Surface of buffer or NULL if not needed
{
    AssertMsg(prcInvalid != NULL, "Must specify a valid area");
    AssertWritePtr(ppsrfBuffer);
    *ppsrfBuffer = NULL;

    Gdiplus::Graphics * pgpgrDraw = CastGraphics(psrfDraw);

    if (!ResourceManager::IsInitGdiPlus()) {
        return DU_E_NOTINITIALIZED;
    }


    //
    // Ensure not in the middle of drawing.
    //
    EndDraw(FALSE);

    //
    // Determine the size of the area to draw and ensure that the buffer is 
    // large enough.
    //
    SIZE sizeBmp;
    sizeBmp.cx     = prcInvalid->right - prcInvalid->left;
    sizeBmp.cy     = prcInvalid->bottom - prcInvalid->top;

    if ((sizeBmp.cx == 0) || (sizeBmp.cy == 0)) {
        //
        // Nothing to draw / buffer, so just let drawing occur in the given
        // buffer.  Signal this by returning NULL so that the caller knows
        // not to create extra, unnecessary data.
        //

        AssertMsg(!m_fChangeOrg, "Ensure valid state");
        AssertMsg(m_pgpgrDraw == NULL, "Ensure valid state");

        return S_OK;
    }

    if ((sizeBmp.cx > m_sizeBmp.cx) || (sizeBmp.cy > m_sizeBmp.cy)) {
        //
        // When allocating a new bitmap, make it large enough to consume the
        // existing bitmap.  This helps avoid swapping between two different
        // bitmaps.
        //
        // TODO: Need to add code into the BufferManager that maintains multiple
        // bitmaps of different sizes so that we don't get many rarely-used, 
        // giant bitmaps.
        //

        if (!AllocBitmap(pgpgrDraw, 
                max(sizeBmp.cx, m_sizeBmp.cx), 
                max(sizeBmp.cy, m_sizeBmp.cy))) {

            return DU_E_OUTOFGDIRESOURCES;
        }
    }

    AssertMsg((prcInvalid->right >= prcInvalid->left) && 
            (prcInvalid->bottom >= prcInvalid->top), "Check normalized");

    //
    // Setup the drawing
    //
#if ENABLE_USEFASTDIB

    HDC hdcTemp     = GetGdiCache()->GetTempDC();
    m_hdcBitmap     = CreateCompatibleDC(hdcTemp);
    GetGdiCache()->ReleaseTempDC(hdcTemp);
    if (m_hdcBitmap == NULL) {
        return DU_E_OUTOFGDIRESOURCES;
    }

    m_hbmpOld       = (HBITMAP) SelectObject(m_hdcBitmap, m_hbmpBuffer);

    m_pgpgrBitmap = new Gdiplus::Graphics(m_hdcBitmap);
    if (m_pgpgrBitmap == NULL) {
        return DU_E_OUTOFGDIRESOURCES;
    }

#else

    m_pgpgrBitmap = new Gdiplus::Graphics(m_pgpbmpBuffer);
    if (m_pgpgrBitmap == NULL) {
        return DU_E_OUTOFGDIRESOURCES;
    }

#endif

#if 0
    m_pgpgrBitmap->SetAlphaLevel(pgpgrDraw->GetAlphaLevel());
#endif

    m_pgpgrBitmap->SetCompositingMode(pgpgrDraw->GetCompositingMode());
    m_pgpgrBitmap->SetCompositingQuality(pgpgrDraw->GetCompositingQuality());
    m_pgpgrBitmap->SetInterpolationMode(pgpgrDraw->GetInterpolationMode());
    m_pgpgrBitmap->SetSmoothingMode(pgpgrDraw->GetSmoothingMode());
    m_pgpgrBitmap->SetPixelOffsetMode(pgpgrDraw->GetPixelOffsetMode());

    m_pgpgrBitmap->SetTextContrast(pgpgrDraw->GetTextContrast());
    m_pgpgrBitmap->SetTextRenderingHint(pgpgrDraw->GetTextRenderingHint());


    m_pgpgrDraw     = pgpgrDraw;
    m_ptDraw.x      = prcInvalid->left;
    m_ptDraw.y      = prcInvalid->top;
    m_sizeDraw.cx   = prcInvalid->right - prcInvalid->left;
    m_sizeDraw.cy   = prcInvalid->bottom - prcInvalid->top;
    m_nCmd          = nCmd;

    m_fChangeOrg    = FALSE;

    m_pgpgrBitmap->GetTransform(&m_gpmatOldBitmap);
    m_pgpgrDraw->GetTransform(&m_gpmatOldDraw);

    m_fChangeXF     = TRUE;
    m_fClip         = FALSE;


    //
    // Setup the buffer as necessary
    //

    if (m_nCmd == BmpBuffer::dcCopyBkgnd) {
        //
        // Copy the destination to the buffer to be used as a background.
        //

        // TODO: This is not supported because GDI+ can't BLT from one 
        // Graphics directly to another.
    }


    //
    // Clip drawing in the buffer to the actual used part of the buffer.  Since
    // this is the only part that will be copied over, we don't want to draw 
    // outside of this area since it slows down performance.
    //


    Gdiplus::RectF rc(0.0f, 0.0f, (float) m_sizeDraw.cx + 1.0f, (float) m_sizeDraw.cy + 1.0f);
    m_pgpgrBitmap->SetClip(rc);

    if (!m_pgpgrDraw->IsClipEmpty()) {
        //
        // Destination surface has a clipping region, so we need to propagate
        // it over to the buffer.
        //

        Gdiplus::Region gprgn;
        m_pgpgrDraw->GetClip(&gprgn);
        gprgn.Translate(-m_ptDraw.x, -m_ptDraw.y);
        m_pgpgrBitmap->SetClip(&gprgn, Gdiplus::CombineModeIntersect);
    }


    //
    // Create a new Surface to contain the buffer.
    //

    return DuGpSurface::Build(m_pgpgrBitmap, (DuGpSurface **) ppsrfBuffer);
}


/***************************************************************************\
*
* GpBmpBuffer::Fill
*
* TOOD:
*
\***************************************************************************/

void        
GpBmpBuffer::Fill(COLORREF cr)
{
    //
    // Determine packing
    //

    HBRUSH hbr = CreateSolidBrush(cr);

    RECT rcFill;
    rcFill.left     = 0;
    rcFill.top      = 0;
    rcFill.right    = m_sizeDraw.cx;
    rcFill.bottom   = m_sizeDraw.cy;
    
    FillRect(m_hdcBitmap, &rcFill, hbr);

    DeleteObject(hbr);
}


/***************************************************************************\
*
* GpBmpBuffer::PreEndDraw
*
* PreEndDraw() finished a drawing cycle that was previously started with
* BeginDraw().  If fCommit is TRUE, the temporary buffer is prepared to be
* copied to the final destination.  The called MUST also call EndDraw()
* to properly end the drawing cycle.
*
\***************************************************************************/

void        
GpBmpBuffer::PreEndDraw(
    IN  BOOL fCommit)               // Copy to final destination
{
    //
    // Resource the destination and buffer surfaces back to where they started.
    // This is important because they will be changed during the drawing.
    //

    if (m_fChangeXF) {
        m_pgpgrDraw->SetTransform(&m_gpmatOldDraw);
        m_pgpgrBitmap->SetTransform(&m_gpmatOldBitmap);
        m_fChangeXF = FALSE;
    }

    Assert(!m_fChangeOrg);

    if ((fCommit) && (m_pgpgrDraw != NULL)) {
        //
        // Setup any clipping region needed to limit the buffer to an area
        // in the destination surface.
        //

        if (m_fClip) {
            AssertMsg(m_pgprgnDrawClip != NULL, "Must have valid region");
            AssertMsg(m_pgprgnDrawOld == NULL, "Ensure no outstanding region");

            m_pgprgnDrawOld = new Gdiplus::Region;
            if (m_pgprgnDrawOld != NULL) {
                m_pgpgrDraw->GetClip(m_pgprgnDrawOld);
                m_pgpgrDraw->SetClip(m_pgprgnDrawClip);
            }
        }
    }
}



/***************************************************************************\
*
* GpBmpBuffer::EndDraw
*
* EndDraw() finished a drawing cycle that was previously started with
* BeginDraw().  If fCommit is TRUE, the temporary buffer is copied to the 
* final destination.  After this function finishes, the GpBmpBuffer is ready
* be used again.  The called MUST first call PreEndDraw() to properly setup
* any state needed to end the drawing cycle.
*
\***************************************************************************/

void        
GpBmpBuffer::EndDraw(
    IN  BOOL fCommit,               // Copy to final destination
    IN  BYTE bAlphaLevel,           // General alpha level
    IN  BYTE bAlphaFormat)          // Pixel alpha format
{
    UNREFERENCED_PARAMETER(bAlphaFormat);

    if ((fCommit) && (m_pgpgrDraw != NULL)) {
        //
        // Copy the bits over
        //

#if ENABLE_USEFASTDIB

        HDC hdcDraw = m_pgpgrDraw->GetHDC();

        if (bAlphaLevel == BLEND_OPAQUE) {
            BitBlt(hdcDraw, m_ptDraw.x, m_ptDraw.y, m_sizeDraw.cx, m_sizeDraw.cy, 
                    m_hdcBitmap, 0, 0, SRCCOPY);
        } else {
            BLENDFUNCTION bf;
            bf.AlphaFormat  = bAlphaFormat;
            bf.BlendFlags   = 0;
            bf.BlendOp      = AC_SRC_OVER;
            bf.SourceConstantAlpha = bAlphaLevel;

            AlphaBlend(hdcDraw, m_ptDraw.x, m_ptDraw.y, m_sizeDraw.cx, m_sizeDraw.cy, 
                    m_hdcBitmap, 0, 0, m_sizeDraw.cx, m_sizeDraw.cy, bf);
        }

        m_pgpgrDraw->ReleaseHDC(hdcDraw);

#else

        if (bAlphaLevel == BLEND_OPAQUE) {
            m_pgpgrDraw->DrawImage(m_pgpbmpBuffer, m_ptDraw.x, m_ptDraw.y, 
                    0, 0, m_sizeDraw.cx, m_sizeDraw.cy, Gdiplus::UnitPixel);
        } else {
            // TODO: Need to alpha-blend using GDI+
        }

#endif
    }
}


/***************************************************************************\
*
* GpBmpBuffer::PostEndDraw
*
* PostEndDraw() finished a drawing cycle that was previously started with
* BeginDraw().  After this function finishes, the buffer is ready to be used
* again.  
*
\***************************************************************************/

void        
GpBmpBuffer::PostEndDraw()
{
    if (m_pgpgrDraw != NULL) {
        //
        // Cleanup the temporary clipping region.  This is VERY important to
        // do so that the destination surface can continued to be drawn on.
        // (For example, more Gadget siblings...)
        //

        if (m_fClip) {
            m_pgpgrDraw->SetClip(m_pgprgnDrawOld);
            if (m_pgprgnDrawOld != NULL) {
                delete m_pgprgnDrawOld;
                m_pgprgnDrawOld = NULL;
            }
        }
    }


    //
    // Cleanup the clipping region
    //

    if (m_fClip) {
        AssertMsg(m_pgprgnDrawClip!= NULL, "Must have a valid region");
        delete m_pgprgnDrawClip;
        m_pgprgnDrawClip = NULL;
        m_fClip = FALSE;
    }
    AssertMsg(m_pgprgnDrawClip == NULL, "Should no longer have a clipping region");


    //
    // Cleanup associated resources
    //

    if (m_pgpgrBitmap != NULL) {
        delete m_pgpgrBitmap;
        m_pgpgrBitmap = NULL;
    }

    if (m_hdcBitmap != NULL) {
        SelectObject(m_hdcBitmap, m_hbmpOld);
        DeleteDC(m_hdcBitmap);
        m_hdcBitmap = NULL;
    }

    m_pgpgrDraw = NULL;
    
    if (GetContext()->GetPerfMode() == IGPM_SIZE) {
        FreeBitmap();
    }
}


//------------------------------------------------------------------------------
void        
GpBmpBuffer::SetupClipRgn()
{
    AssertMsg(!m_fClip, "Only should setup clip region once per cycle");
    AssertMsg(m_pgprgnDrawClip == NULL, "Should not already have a clip region");

    m_pgprgnDrawClip = new Gdiplus::Region;
    if (m_pgprgnDrawClip == NULL) {
        return;
    }

    m_pgpgrBitmap->GetClip(m_pgprgnDrawClip);
    m_pgprgnDrawClip->Translate(m_ptDraw.x, m_ptDraw.y);
    m_fClip = TRUE;
}


/***************************************************************************\
*
* GpBmpBuffer::InUse
*
* InUse() returns if the GpBmpBuffer is currently in a draw cycle started from
* BeginDraw().
*
\***************************************************************************/

BOOL        
GpBmpBuffer::InUse() const
{
    return m_pgpgrDraw != NULL;
}


/***************************************************************************\
*
* GpBmpBuffer::AllocBitmap
*
* AllocBitmap() allocates the internal bitmap buffer that is used to 
* temporarily draw into.  This bitmap will be compatible with the final
* destination surface.
*
\***************************************************************************/

BOOL        
GpBmpBuffer::AllocBitmap(
    IN  Gdiplus::Graphics * pgpgr,  // Final destination Graphics
    IN  int cx,                     // Width of new bitmap
    IN  int cy)                     // Height of new bitmap
{
    FreeBitmap();

    Assert(ResourceManager::IsInitGdiPlus());

    //
    // When allocating a bitmap, round up to a multiple of 16 x 16.  This helps
    // to reduce unnecessary reallocations because we grew by one or two pixels.
    //

    cx = ((cx + 15) / 16) * 16;
    cy = ((cy + 15) / 16) * 16;


    //
    // Allocate the bitmap
    //

#if ENABLE_USEFASTDIB

    UNREFERENCED_PARAMETER(pgpgr);

    HPALETTE hpal   = NULL;
    HDC hdcTemp     = GetGdiCache()->GetTempDC();

    ZeroMemory(&m_bmih, sizeof(m_bmih));
    m_bmih.biSize   = sizeof(m_bmih);
    m_hbmpBuffer    = CreateCompatibleDIB(hdcTemp, hpal, cx, cy, &m_pvBits, &m_bmih);
    GetGdiCache()->ReleaseTempDC(hdcTemp);

    if (m_hbmpBuffer == NULL) {
        return FALSE;
    }

#else
    
    m_pgpbmpBuffer = new Gdiplus::Bitmap(cx, cy, pgpgr);
    if (m_pgpbmpBuffer == NULL) {
        return FALSE;
    }

#endif

    m_sizeBmp.cx = cx;
    m_sizeBmp.cy = cy;
    return TRUE;
}


/***************************************************************************\
*
* GpBmpBuffer::FreeBitmap
*
* FreeBitmap() cleans up allocated resources.
*
\***************************************************************************/

void
GpBmpBuffer::FreeBitmap()
{
#if ENABLE_USEFASTDIB

    if (m_hbmpBuffer != NULL) {
        DeleteObject(m_hbmpBuffer);
        m_hbmpBuffer = NULL;
        m_sizeBmp.cx = 0;
        m_sizeBmp.cy = 0;
    }

#else

    if (m_pgpbmpBuffer != NULL) {
        delete m_pgpbmpBuffer;
        m_pgpbmpBuffer = NULL;
        m_sizeBmp.cx = 0;
        m_sizeBmp.cy = 0;
    }

#endif
}


/***************************************************************************\
*****************************************************************************
*
* class DCBmpBufferCache
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
void *
DCBmpBufferCache::Build()
{
    return ClientNew(DCBmpBuffer);
}


//------------------------------------------------------------------------------
void        
DCBmpBufferCache::DestroyObject(void * pObj)
{
    DCBmpBuffer * pbufBmp = reinterpret_cast<DCBmpBuffer *>(pObj);
    ClientDelete(DCBmpBuffer, pbufBmp);
}


/***************************************************************************\
*****************************************************************************
*
* class GpBmpBufferCache
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
void *
GpBmpBufferCache::Build()
{
    return ClientNew(GpBmpBuffer);
}


//------------------------------------------------------------------------------
void        
GpBmpBufferCache::DestroyObject(void * pObj)
{
    GpBmpBuffer * pbufBmp = reinterpret_cast<GpBmpBuffer *>(pObj);
    ClientDelete(GpBmpBuffer, pbufBmp);
}


/***************************************************************************\
*****************************************************************************
*
* class TrxBuffer
*
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* TrxBuffer::TrxBuffer
*
* TrxBuffer() constructs a new TrxBuffer object.  To create new, initialized
* TrxBuffer's, call the Build() function instead.
*
\***************************************************************************/

TrxBuffer::TrxBuffer()
{
    ZeroMemory(m_rgpsur, sizeof(m_rgpsur));
}


/***************************************************************************\
*
* TrxBuffer::~TrxBuffer
*
* ~TrxBuffer() cleans up all resources associated with the buffer.
*
\***************************************************************************/

TrxBuffer::~TrxBuffer()
{
    RemoveAllSurfaces();
}


/***************************************************************************\
*
* TrxBuffer::Build
*
* Build() fully initializes a new TrxBuffer object that contains several
* DxSurfaces of a common size.  These buffers are used to provide both
* input and output buffers for DirectX Transforms.
*
\***************************************************************************/

HRESULT
TrxBuffer::Build(
    IN  SIZE sizePxl,               // Size of each surface in pixels
    IN  int cSurfaces,              // Number of surfaces
    OUT TrxBuffer ** ppbufNew)      // New buffer
{
    HRESULT hr;
    TrxBuffer * pbuf = ClientNew(TrxBuffer);
    if (pbuf == NULL) {
        return E_OUTOFMEMORY;
    }

    pbuf->m_cSurfaces   = cSurfaces;
    pbuf->m_sizePxl     = sizePxl;

    for (int idx = 0; idx < cSurfaces; idx++) {
        hr = pbuf->BuildSurface(idx);
        if (FAILED(hr)) {
            ClientDelete(TrxBuffer, pbuf);
            return hr;
        }
    }

    *ppbufNew = pbuf;
    return S_OK;
}


/***************************************************************************\
*
* TrxBuffer::BuildSurface
*
* BuildSurface() internally builds a new DxSurface and assigns it in the 
* specified slot.
*
\***************************************************************************/

HRESULT
TrxBuffer::BuildSurface(
    IN  int idxSurface)             // Surface slot
{
    AssertMsg((idxSurface < m_cSurfaces) && (idxSurface >= 0), "Ensure valid index");
    AssertMsg((m_sizePxl.cx <= 4000) && (m_sizePxl.cx >= 0) &&
            (m_sizePxl.cy <= 4000) && (m_sizePxl.cy >= 0), "Ensure reasonable size");
    AssertMsg(m_rgpsur[idxSurface] == NULL, "Ensure not already created");
    HRESULT hr;
    
    DxSurface * psurNew = ClientNew(DxSurface);
    if (psurNew == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = psurNew->Create(m_sizePxl);
    if (FAILED(hr)) {
        ClientDelete(DxSurface, psurNew);
        return hr;
    }

    m_rgpsur[idxSurface] = psurNew;
    return S_OK;
}


/***************************************************************************\
*
* TrxBuffer::RemoveAllSurfaces
*
* RemoveAllSurfaces() destroys all DxSurfaces owned by the TrxBuffer.
*
\***************************************************************************/

void        
TrxBuffer::RemoveAllSurfaces()
{
    for (int idx = 0; idx < MAX_Surfaces; idx++) {
        if (m_rgpsur != NULL) {
            ClientDelete(DxSurface, m_rgpsur[idx]);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\rockall\library\tls.hpp ===
#ifndef _THREAD_LOCAL_STORE_HPP_
#define _THREAD_LOCAL_STORE_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Assembly.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The environment constants indicate the state of thread         */
    /*   local store.                                                   */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 NoTLSMemory			  = -1;
CONST SBIT32 NoTLSStructure			  = 0;

    /********************************************************************/
    /*                                                                  */
    /*   Thread local store.                                            */
    /*                                                                  */
    /*   A wide range of applications use threads.  It is often very    */
    /*   valuable to be able to have some private per thread data.      */
    /*   This functionality is supported by the following class.        */
    /*                                                                  */
    /********************************************************************/

class THREAD_LOCAL_STORE : public ASSEMBLY
    {
        //
        //   Private data.
        //
		BOOLEAN						  Active;

		SBIT32						  TlsIndex;
		SBIT32						  TlsOffset;

    public:
        //
        //   Public functions.
        //
        THREAD_LOCAL_STORE( VOID )
			{
			if ( Active = ((TlsIndex = TlsAlloc()) != NoTLSMemory) )
				{ TlsOffset = ((TlsIndex * sizeof(void*)) + TebSlot); }
			else
				{ Failure( "No TLS available" ); }
			}

		INLINE BOOLEAN Available( VOID )
			{ return Active; }
#ifdef ASSEMBLY_X86
#ifdef ENABLE_NON_STANDARD_ASSEMBLY

		INLINE VOID *GetAddress( VOID )
			{ return (GetTlsAddress( TlsOffset )); }
#endif
#endif

		INLINE VOID *GetPointer( VOID )
			{ return (GetTlsValue( TlsIndex,TlsOffset )); }

		INLINE VOID SetPointer( VOID *NewPointer )
			{ SetTlsValue( TlsIndex,TlsOffset,NewPointer ); }

        ~THREAD_LOCAL_STORE( VOID )
			{
			Active = False;

			if ( TlsIndex != NoTLSMemory )
				{ 
				if ( ! TlsFree( TlsIndex ) )
					{ Failure( "Unable to free TLS memory" ); }
				}
			}

	private:
        //
        //   Disabled operations.
        //
        THREAD_LOCAL_STORE( CONST THREAD_LOCAL_STORE & Copy );

        VOID operator=( CONST THREAD_LOCAL_STORE & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\services\commanager.h ===
/***************************************************************************\
*
* File: ComManager.h
*
* Description:
* ComManager.h defines the process-wide COM manager used for all COM, OLE
* and Automation operations.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(SERVICES__ComManager_h__INCLUDED)
#define SERVICES__ComManager_h__INCLUDED
#pragma once

/***************************************************************************\
*
* class ComManager
*
* ComManager manages COM services including COM, OLE, and Automation.  This 
* class is designed to be "per-thread", automatically shared data across 
* multiple threads.
* 
* NOTE: This manager is delay-loads DLL's to manage performance and work on
* down-level platforms.
*
\***************************************************************************/

typedef HRESULT (WINAPI * CoInitializeExProc)(void * pvReserved, DWORD dwCoInit);
typedef void    (WINAPI * CoUninitializeProc)();
typedef HRESULT (WINAPI * CoCreateInstanceProc)(REFCLSID rclsid, LPUNKNOWN punkOuter,
        DWORD dwClsContext, REFIID ridd, LPVOID * ppv);

typedef HRESULT (WINAPI * OleInitializeProc)(LPVOID * pvReserved);
typedef void    (WINAPI * OleUninitializeProc)();
typedef HRESULT (WINAPI * RegisterDragDropProc)(HWND hwnd, IDropTarget * pDropTarget);
typedef HRESULT (WINAPI * RevokeDragDropProc)(HWND hwnd);
typedef void    (WINAPI * ReleaseStgMediumProc)(STGMEDIUM * pstg);

typedef BSTR    (WINAPI * SysAllocStringProc)(const OLECHAR * psz);
typedef HRESULT (WINAPI * SysFreeStringProc)(BSTR bstr);
typedef HRESULT (WINAPI * VariantInitProc)(VARIANTARG * pvarg); 
typedef HRESULT (WINAPI * VariantClearProc)(VARIANTARG * pvarg);

class ComManager
{
// Construction
public:
                ComManager();
                ~ComManager();

// Operations
public:
    enum EServices
    {
        sCOM    = 0x00000001,       // COM
        sAuto   = 0x00000002,       // OLE-Automation
        sOLE    = 0x00000004,       // OLE2
    };

    BOOL        Init(UINT nMask);

    BOOL        IsInit(UINT nMask) const;

    HRESULT     CreateInstance(REFCLSID rclsid, IUnknown * punkOuter, REFIID riid, void ** ppv);

    BSTR        SysAllocString(const OLECHAR * psz);
    HRESULT     SysFreeString(BSTR bstr);
    HRESULT     VariantInit(VARIANTARG * pvarg); 
    HRESULT     VariantClear(VARIANTARG * pvarg);

    HRESULT     RegisterDragDrop(HWND hwnd, IDropTarget * pDropTarget);
    HRESULT     RevokeDragDrop(HWND hwnd);
    void        ReleaseStgMedium(STGMEDIUM * pstg);

// Data
protected:
    //
    // Shared data that is process wide- only need to load the DLL's once.
    //

    static  int                     s_cRefs;
    static  CritLock                s_lock;

    static  HINSTANCE               s_hDllCOM;      // Core "COM" / OLE
    static  CoInitializeExProc      s_pfnCoInit;
    static  CoUninitializeProc      s_pfnCoUninit;
    static  CoCreateInstanceProc    s_pfnCreate;
    static  OleInitializeProc       s_pfnOleInit;
    static  OleUninitializeProc     s_pfnOleUninit;
    static  RegisterDragDropProc    s_pfnRegisterDragDrop;
    static  RevokeDragDropProc      s_pfnRevokeDragDrop;
    static  ReleaseStgMediumProc    s_pfnReleaseStgMedium;

    static  HINSTANCE               s_hDllAuto;     // OLE-automation
    static  SysAllocStringProc      s_pfnAllocString;
    static  SysFreeStringProc       s_pfnFreeString;
    static  VariantInitProc         s_pfnVariantInit;
    static  VariantClearProc        s_pfnVariantClear;


    //
    // Specific data that is "per-thread"- need to initialize COM / OLE on each
    // thread.
    //

            BOOL                    m_fInitCOM:1;
            BOOL                    m_fInitOLE:1;
};

#include "ComManager.inl"

#endif // SERVICES__ComManager_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\services\buffer.inl ===
/***************************************************************************\
*
* File: Buffer.inl
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(SERVICES__Buffer_inl__INCLUDED)
#define SERVICES__Buffer_inl__INCLUDED

/***************************************************************************\
*****************************************************************************
*
* class DCBmpBufferCache
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline DCBmpBuffer *
DCBmpBufferCache::Get()
{
    return static_cast<DCBmpBuffer *> (Pop());
}


//------------------------------------------------------------------------------
inline void        
DCBmpBufferCache::Release(DCBmpBuffer * pbufBmp)
{
    Push(pbufBmp);
}


/***************************************************************************\
*****************************************************************************
*
* class GpBmpBufferCache
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline GpBmpBuffer *
GpBmpBufferCache::Get()
{
    return static_cast<GpBmpBuffer *> (Pop());
}


//------------------------------------------------------------------------------
inline void        
GpBmpBufferCache::Release(GpBmpBuffer * pbufBmp)
{
    Push(pbufBmp);
}


/***************************************************************************\
*****************************************************************************
*
* class TrxBuffer
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
DxSurface * 
TrxBuffer::GetSurface(int idxSurface) const
{
    AssertMsg((idxSurface < m_cSurfaces) && (idxSurface >= 0), "Ensure valid index");

    return m_rgpsur[idxSurface];
}


//------------------------------------------------------------------------------
inline SIZE        
TrxBuffer::GetSize() const
{
    return m_sizePxl;
}


//------------------------------------------------------------------------------
inline BOOL        
TrxBuffer::GetInUse() const
{
    return m_fInUse;
}


//------------------------------------------------------------------------------
inline void        
TrxBuffer::SetInUse(BOOL fInUse)
{
    m_fInUse = fInUse;
}


/***************************************************************************\
*****************************************************************************
*
* class BufferManager
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline HRESULT
BufferManager::GetSharedBuffer(const RECT * prcInvalid, DCBmpBuffer ** ppbuf)
{
    UNREFERENCED_PARAMETER(prcInvalid);
    AssertWritePtr(ppbuf);
    AssertMsg(!m_bufDCBmpShared.InUse(), "Only should setup buffering once per subtree");

    *ppbuf = &m_bufDCBmpShared;

    return S_OK;
}


//------------------------------------------------------------------------------
inline HRESULT
BufferManager::GetSharedBuffer(const RECT * prcInvalid, GpBmpBuffer ** ppbuf)
{
    UNREFERENCED_PARAMETER(prcInvalid);
    AssertWritePtr(ppbuf);
    AssertMsg((m_pbufGpBmpShared == NULL) || !m_pbufGpBmpShared->InUse(), 
            "Only should setup buffering once per subtree");

    if (m_pbufGpBmpShared == NULL) {
        m_pbufGpBmpShared = ProcessNew(GpBmpBuffer);
        if (m_pbufGpBmpShared == NULL) {
            return E_OUTOFMEMORY;
        }
    }

    AssertMsg(m_pbufGpBmpShared != NULL, "Must be properly allocated");
    *ppbuf = m_pbufGpBmpShared;

    return S_OK;
}


//------------------------------------------------------------------------------
inline void
BufferManager::ReleaseSharedBuffer(BmpBuffer * pbuf)
{
    AssertMsg(!pbuf->InUse(), "Buffer should no longer be in use when released");

    if ((pbuf != &m_bufDCBmpShared) &&
        (pbuf != m_pbufGpBmpShared)) {

        AssertMsg(0, "Unknown shared buffer");
    }
    
}


#endif // SERVICES__Buffer_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\services\commanager.cpp ===
/***************************************************************************\
*
* File: ComManager.cpp
*
* Description:
* ComManager.cpp implements the process-wide COM manager used for all COM, OLE
* and Automation operations.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Services.h"
#include "ComManager.h"

int                     ComManager::s_cRefs = 0;
CritLock                ComManager::s_lock;

HINSTANCE               ComManager::s_hDllCOM = NULL;
CoInitializeExProc      ComManager::s_pfnCoInit = NULL;
CoUninitializeProc      ComManager::s_pfnCoUninit = NULL;
CoCreateInstanceProc    ComManager::s_pfnCreate = NULL;
OleInitializeProc       ComManager::s_pfnOleInit = NULL;
OleUninitializeProc     ComManager::s_pfnOleUninit = NULL;
RegisterDragDropProc    ComManager::s_pfnRegisterDragDrop = NULL;
RevokeDragDropProc      ComManager::s_pfnRevokeDragDrop = NULL;
ReleaseStgMediumProc    ComManager::s_pfnReleaseStgMedium = NULL;

HINSTANCE               ComManager::s_hDllAuto = NULL;
SysAllocStringProc      ComManager::s_pfnAllocString = NULL;
SysFreeStringProc       ComManager::s_pfnFreeString = NULL;
VariantInitProc         ComManager::s_pfnVariantInit = NULL;
VariantClearProc        ComManager::s_pfnVariantClear = NULL;


//------------------------------------------------------------------------------
ComManager::ComManager()
{
    m_fInitCOM = FALSE;
    m_fInitOLE = FALSE;

    s_lock.Enter();

    s_cRefs++;

    s_lock.Leave();
}


//------------------------------------------------------------------------------
ComManager::~ComManager()
{
    s_lock.Enter();

    AssertMsg(s_cRefs > 0, "Must have at least one outstanding reference");
    if (--s_cRefs == 0) {
        if ((s_pfnOleUninit != NULL) && m_fInitOLE) {
            (s_pfnOleUninit)();
        }

        if ((s_pfnCoUninit != NULL) && m_fInitCOM) {
            (s_pfnCoUninit)();
        }

        if (s_hDllAuto != NULL) {
            FreeLibrary(s_hDllAuto);
            s_hDllAuto = NULL;
        }

        if (s_hDllCOM != NULL) {
            FreeLibrary(s_hDllCOM);
            s_hDllCOM  = NULL;
        }

        s_pfnCoInit         = NULL;
        s_pfnCoUninit       = NULL;
        s_pfnCreate         = NULL;

        s_pfnOleInit        = NULL;
        s_pfnOleUninit      = NULL;
        s_pfnRegisterDragDrop = NULL;
        s_pfnRevokeDragDrop = NULL;
        s_pfnReleaseStgMedium = NULL;

        s_pfnAllocString    = NULL;
        s_pfnFreeString     = NULL;
        s_pfnVariantInit    = NULL;
        s_pfnVariantClear   = NULL;
    }

    s_lock.Leave();
}


//------------------------------------------------------------------------------
BOOL
ComManager::Init(UINT nMask)
{
    BOOL fSuccess = TRUE;

    s_lock.Enter();

    if (TestFlag(nMask, sAuto)) {
        // OLE-Automation need COM.
        SetFlag(nMask, sCOM);
    }

    if (TestFlag(nMask, sCOM | sOLE)) {
        //
        // Load the DLL
        //

        if (s_hDllCOM == NULL) {
            s_hDllCOM = LoadLibrary(_T("ole32.dll"));
            if (s_hDllCOM == NULL) {
                fSuccess = FALSE;
                goto errorexit;
            }

            s_pfnCoInit         = (CoInitializeExProc)  GetProcAddress(s_hDllCOM, _T("CoInitializeEx"));
            s_pfnCoUninit       = (CoUninitializeProc)  GetProcAddress(s_hDllCOM, _T("CoUninitialize"));
            s_pfnCreate         = (CoCreateInstanceProc)GetProcAddress(s_hDllCOM, _T("CoCreateInstance"));

            s_pfnOleInit        = (OleInitializeProc)   GetProcAddress(s_hDllCOM, _T("OleInitialize"));
            s_pfnOleUninit      = (OleUninitializeProc) GetProcAddress(s_hDllCOM, _T("OleUninitialize"));

            s_pfnRegisterDragDrop = (RegisterDragDropProc) GetProcAddress(s_hDllCOM, _T("RegisterDragDrop"));
            s_pfnRevokeDragDrop = (RevokeDragDropProc)  GetProcAddress(s_hDllCOM, _T("RevokeDragDrop"));
            s_pfnReleaseStgMedium = (ReleaseStgMediumProc) GetProcAddress(s_hDllCOM, _T("ReleaseStgMedium"));

            if ((s_pfnCoInit == NULL) || (s_pfnCoUninit == NULL) || (s_pfnCreate == NULL) || 
                (s_pfnOleInit == NULL) || (s_pfnOleUninit == NULL) ||
                (s_pfnRegisterDragDrop == NULL) || (s_pfnRevokeDragDrop == NULL) || 
                (s_pfnReleaseStgMedium == NULL)) {

                fSuccess = FALSE;
                goto errorexit;
            }
        }


        //
        // Start COM / OLE
        //

        if (TestFlag(nMask, sCOM) && (!m_fInitCOM)) {
            // UI threads can not be free-threaded, so use apartment.
            HRESULT hr = (s_pfnCoInit)(NULL, COINIT_APARTMENTTHREADED);
            if (FAILED(hr)) {
                fSuccess = FALSE;
                goto errorexit;
            }

            m_fInitCOM = TRUE;
        }

        if (TestFlag(nMask, sOLE) && (!m_fInitOLE)) {
            HRESULT hr = (s_pfnOleInit)(NULL);
            if (FAILED(hr)) {
                fSuccess = FALSE;
                goto errorexit;
            }

            m_fInitOLE = TRUE;
        }
    }

    if (TestFlag(nMask, sAuto) && (s_hDllAuto == NULL)) {
        s_hDllAuto = LoadLibrary(_T("oleaut32.dll"));
        if (s_hDllAuto == NULL) {
            fSuccess = FALSE;
            goto errorexit;
        }

        s_pfnAllocString    = (SysAllocStringProc)  GetProcAddress(s_hDllAuto, _T("SysAllocString"));
        s_pfnFreeString     = (SysFreeStringProc)   GetProcAddress(s_hDllAuto, _T("SysFreeString"));
        s_pfnVariantInit    = (VariantInitProc)     GetProcAddress(s_hDllAuto, _T("VariantInit"));
        s_pfnVariantClear   = (VariantClearProc)    GetProcAddress(s_hDllAuto, _T("VariantClear"));

        if ((s_pfnAllocString == NULL) || (s_pfnFreeString == NULL) || 
                (s_pfnVariantInit == NULL) || (s_pfnVariantClear == NULL)) {

            fSuccess = FALSE;
            goto errorexit;
        }
    }

errorexit:
    s_lock.Leave();

    return fSuccess;
}


//------------------------------------------------------------------------------
BOOL    
ComManager::IsInit(UINT nMask) const
{
    if (TestFlag(nMask, sCOM) && (s_hDllCOM != NULL) && m_fInitCOM) {
        return TRUE;
    }

    if (TestFlag(nMask, sOLE) && (s_hDllCOM != NULL) && m_fInitOLE) {
        return TRUE;
    }

    if (TestFlag(nMask, sAuto) && (s_hDllAuto != NULL)) {
        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\services\buffer.h ===
/***************************************************************************\
*
* File: Buffer.h
*
* Description:
* Buffer.h contains definitions of objects used in buffering operations, 
* including double buffering, DX-Transforms, etc.  These objects are 
* maintained by a central BufferManager that is available process-wide.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(SERVICES__Buffer_h__INCLUDED)
#define SERVICES__Buffer_h__INCLUDED
#pragma once

#include "DxManager.h"
#include "GdiCache.h"
#include "Surface.h"

#define ENABLE_USEFASTDIB           1

class DuSurface;

/***************************************************************************\
*
* class BmpBuffer
*
* BmpBuffer abstracts out drawing using a double buffer by ensuring the 
* buffer is properly setup and is used internally inside the BufferManager 
* to manage resources.  This class provides a foundation for all bitmap 
* buffers.
*
\***************************************************************************/

class BmpBuffer
{
// Construction
public:
    virtual ~BmpBuffer() { };

            enum EDrawCmd
            {
                dcNone      = 0,        // No special processing
                dcCopyBkgnd = 1,        // Copy the destination as a background
            };

// Operations
public:
    virtual HRESULT     BeginDraw(DuSurface * psrfDraw, const RECT * prcInvalid, UINT nCmd, DuSurface ** ppsrfBuffer) PURE;
    virtual void        Fill(COLORREF cr) PURE;
    virtual void        PreEndDraw(BOOL fCommit) PURE;
    virtual void        EndDraw(BOOL fCommit, BYTE bAlphaLevel = BLEND_OPAQUE, BYTE bAlphaFormat = 0) PURE;
    virtual void        PostEndDraw() PURE;
    virtual void        SetupClipRgn() PURE;
    virtual BOOL        InUse() const PURE;
    virtual DuSurface::EType
                        GetType() const PURE;

// Data
protected:
            SIZE        m_sizeBmp;
            POINT       m_ptDraw;
            SIZE        m_sizeDraw;
            UINT        m_nCmd;
            BOOL        m_fChangeOrg:1;
            BOOL        m_fChangeXF:1;
            BOOL        m_fClip:1;
};


/***************************************************************************\
*
* class DCBmpBuffer
*
* DCBmpBuffer implements a double-buffer for GDI.
*
\***************************************************************************/

class DCBmpBuffer : public BmpBuffer
{
// Construction
public:
            DCBmpBuffer();
    virtual ~DCBmpBuffer();

// Operations
public:
    virtual HRESULT     BeginDraw(DuSurface * psrfDraw, const RECT * prcInvalid, UINT nCmd, DuSurface ** ppsrfBuffer);
    virtual void        Fill(COLORREF cr);
    virtual void        PreEndDraw(BOOL fCommit);
    virtual void        EndDraw(BOOL fCommit, BYTE bAlphaLevel = BLEND_OPAQUE, BYTE bAlphaFormat = 0);
    virtual void        PostEndDraw();
    virtual void        SetupClipRgn();
    virtual BOOL        InUse() const;
    virtual DuSurface::EType
                        GetType() const { return DuSurface::stDC; }

// Implementation
protected:
            BOOL        AllocBitmap(HDC hdcDraw, int cx, int cy);
            void        FreeBitmap();

// Data
protected:
            HBITMAP     m_hbmpBuffer;
            HBITMAP     m_hbmpOld;
            HPALETTE    m_hpalOld;
            HDC         m_hdcDraw;
            HDC         m_hdcBitmap;
            HRGN        m_hrgnDrawClip;
            HRGN        m_hrgnDrawOld;

            POINT       m_ptOldBrushOrg;
            int         m_nOldGfxMode;
            XFORM       m_xfOldDraw;
            XFORM       m_xfOldBitmap;
};


/***************************************************************************\
*
* class GpBmpBuffer
*
* GpBmpBuffer implements a double-buffer for GDI.
*
\***************************************************************************/

class GpBmpBuffer : public BmpBuffer
{
// Construction
public:
            GpBmpBuffer();
    virtual ~GpBmpBuffer();

// Operations
public:
    virtual HRESULT     BeginDraw(DuSurface * psrfDraw, const RECT * prcInvalid, UINT nCmd, DuSurface ** ppsrfBuffer);
    virtual void        Fill(COLORREF cr);
    virtual void        PreEndDraw(BOOL fCommit);
    virtual void        EndDraw(BOOL fCommit, BYTE bAlphaLevel = BLEND_OPAQUE, BYTE bAlphaFormat = 0);
    virtual void        PostEndDraw();
    virtual void        SetupClipRgn();
    virtual BOOL        InUse() const;
    virtual DuSurface::EType
                        GetType() const { return DuSurface::stGdiPlus; }

// Implementation
protected:
            BOOL        AllocBitmap(Gdiplus::Graphics * pgpgr, int cx, int cy);
            void        FreeBitmap();

// Data
protected:
#if ENABLE_USEFASTDIB
    HBITMAP             m_hbmpBuffer;
    HBITMAP             m_hbmpOld;
    HDC                 m_hdcBitmap;
    BITMAPINFOHEADER    m_bmih;
    void *              m_pvBits;
#else
    Gdiplus::Bitmap *   m_pgpbmpBuffer;
#endif
    Gdiplus::Graphics * m_pgpgrBitmap;
    Gdiplus::Graphics * m_pgpgrDraw;
    Gdiplus::Region *   m_pgprgnDrawClip;
    Gdiplus::Region *   m_pgprgnDrawOld;

    Gdiplus::Matrix     m_gpmatOldDraw;
    Gdiplus::Matrix     m_gpmatOldBitmap;
};


/***************************************************************************\
*****************************************************************************
*
* class DCBmpBufferCache
*
* DCBmpBufferCache implements a DCBmpBuffer cache.
*
*****************************************************************************
\***************************************************************************/

class DCBmpBufferCache : public ObjectCache
{
public:
    inline  DCBmpBuffer*  Get();
    inline  void        Release(DCBmpBuffer * pbufBmp);

protected:
    virtual void *      Build();
    virtual void        DestroyObject(void * pObj);
};


/***************************************************************************\
*****************************************************************************
*
* class GpBmpBufferCache
*
* GpBmpBufferCache implements a GpBmpBuffer cache.
*
*****************************************************************************
\***************************************************************************/

class GpBmpBufferCache : public ObjectCache
{
public:
    inline  GpBmpBuffer*  Get();
    inline  void        Release(GpBmpBuffer * pbufBmp);

protected:
    virtual void *      Build();
    virtual void        DestroyObject(void * pObj);
};


/***************************************************************************\
*
* class TrxBuffer
*
* TrxBuffer maintains a set of DxSurfaces that are used by Transitions.  The
* BufferManager will internally build these objects, as needed, for 
* Transitions.  All of the surfaces in the buffer will be the same size, as
* this is standard for Transitions.
*
\***************************************************************************/

class TrxBuffer
{
// Construction
public:
            TrxBuffer();
            ~TrxBuffer();
    static  HRESULT     Build(SIZE sizePxl, int cSurfaces, TrxBuffer ** ppbufNew);

// Operations
public:
    inline  DxSurface * GetSurface(int idxSurface) const;
    inline  SIZE        GetSize() const;

    inline  BOOL        GetInUse() const;
    inline  void        SetInUse(BOOL fInUse);

// Implementation
protected:
            HRESULT     BuildSurface(int idxSurface);
            void        RemoveAllSurfaces();

// Data
protected:
    enum {
        MAX_Surfaces = 3                // All DxTx only use 2 In and 1 Out at most
    };

    SIZE        m_sizePxl;              // Size (in pixels) of each surface
    int         m_cSurfaces;            // Number of surfaces
    DxSurface * m_rgpsur[MAX_Surfaces]; // Collection of DX surfaces
    BOOL        m_fInUse;               // Buffer is being used
};


/***************************************************************************\
*
* class BufferManager
*
* BufferManager maintains a collection of buffers of various types across 
* the entire process (including multiple threads).
*
\***************************************************************************/

class BufferManager
{
// Construction
public:
            BufferManager();
            ~BufferManager();
            void        Destroy();

// Operations
public:
    //
    // TODO: Change the implementation of these functions so that they are
    // reentrant (multi-threaded friendly).
    //

    inline  HRESULT     GetSharedBuffer(const RECT * prcInvalid, DCBmpBuffer ** ppbuf);
    inline  HRESULT     GetSharedBuffer(const RECT * prcInvalid, GpBmpBuffer ** ppbuf);
    inline  void        ReleaseSharedBuffer(BmpBuffer * pbuf);

            HRESULT     GetCachedBuffer(DuSurface::EType type, BmpBuffer ** ppbuf);
            void        ReleaseCachedBuffer(BmpBuffer * pbuf);

            HRESULT     BeginTransition(SIZE sizePxl, int cSurfaces, BOOL fExactSize, TrxBuffer ** ppbuf);
            void        EndTransition(TrxBuffer * pbufTrx, BOOL fCache);
            
            void        FlushTrxBuffers();

// Implementation
protected:
            void        RemoveAllTrxBuffers();

// Data
protected:
            //
            // TODO: Change these to be dynamically allocated and maintained across
            // multiple threads, automatically freeing resources after not used
            // for a specified timeout (perhaps 10 minutes).
            //

            // Bitmaps used by double-buffering
            DCBmpBuffer      m_bufDCBmpShared;
            GpBmpBuffer *    m_pbufGpBmpShared;
            DCBmpBufferCache m_cacheDCBmpCached;    // Cached buffers (long ownership)
            GpBmpBufferCache m_cacheGpBmpCached;    // Cached buffers (long ownership)

            // Surfaces used by Transitions
            TrxBuffer *     m_pbufTrx;
};

#include "Buffer.inl"

#endif // SERVICES__Buffer_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\services\context.cpp ===
/***************************************************************************\
*
* File: Context.cpp
*
* Description:
* This file implements the main Context used by the ResourceManager to manage
* independent "work contexts".
*
*
* History:
*  4/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Services.h"
#include "Context.h"

#include "Thread.h"
#include "ResourceManager.h"

#if !USE_DYNAMICTLS
__declspec(thread) Context * t_pContext;
#endif


/***************************************************************************\
*****************************************************************************
*
* class Context
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
Context::Context()
{
    //
    // Immediately attach this Context to the Thread object.  This is required
    // because creation of the Context may need the Thread (for example, to
    // create the Parking Container).  If something fails during Context 
    // creation or later, the new Thread will be unlocked, destroying this new
    // Context with it.
    //
    
    GetThread()->SetContext(this);

#if DBG
    m_DEBUG_pthrLock = NULL;
#endif // DBG
}


//------------------------------------------------------------------------------
Context::~Context()
{
#if DBG_CHECK_CALLBACKS
    if (m_cLiveCallbacks > 0) {
        AutoTrace("DirectUser Context: 0x%p\n", this);
        AlwaysPromptInvalid("Can not destroy a Context while inside a callback");
    }
#endif    

    //
    // NOTE: The Context (and its SubContexts) can be destroyed on a different
    // thread during destruction.  It is advisable to allocate any dangling data
    // on the Process heap so that it can be safely destroyed at this time.
    //

    //
    // First, tear down the sub-contexts since they may rely on shared resources
    // such as the heap.
    //
    // NOTE: We need to destroy the SubContext's in multiple stages so that they
    // can refer to each other during destruction.  This provides an opportunity
    // for any callbacks to occur during the "pre-destroy" stage.  We 
    // temporarily need to increment the lock count while we pre-destroy the 
    // SubContext's because they may callback.  During these callbacks, the 
    // application may call API's to cleanup objects in the Context.
    //

    for (int idx = 0; idx < slCOUNT; idx++) {
        if (m_rgSCs[idx] != NULL) {
            ProcessDelete(SubContext, m_rgSCs[idx]);
            m_rgSCs[idx] = NULL;
        }
    }


#if DBG_CHECK_CALLBACKS
    if (m_cLiveObjects > 0) {
        AutoTrace("DirectUser Context: 0x%p\n", this);
        AlwaysPromptInvalid("Outstanding DirectUser objects after Context shutdown");
    }
#endif    


    //
    // Tear down low-level resources (such as the heap)
    //

    if (m_pHeap != NULL) {
        DestroyContextHeap(m_pHeap);
    }


    //
    // Finally, detach this Context from the Thread.  This must be done here
    // since the Context is created in Context::Build() and must be fully
    // detached from the Thread if any stage of construction fails.
    //

    GetThread()->SetContext(NULL);
}


/***************************************************************************\
*
* Context::xwDestroy
*
* xwDestroy() is called to finally delete the object.
*
\***************************************************************************/

void        
Context::xwDestroy()
{
    ProcessDelete(Context, this);
}


/***************************************************************************\
*
* Context::xwPreDestroyNL
*
* xwPreDestroyNL() is called by a Thread when the Context is about to be 
* destroyed, but before the SubTreads have been destroyed.
*
\***************************************************************************/

void
Context::xwPreDestroyNL()
{
    AssertMsg(m_cRef == 0, "Locks must initially be at 0 to be destroyed");
    m_cRef++;

    for (int idx = 0; idx < slCOUNT; idx++) {
        if (m_rgSCs[idx] != NULL) {
            m_rgSCs[idx]->xwPreDestroyNL();
        }
    }

    m_cRef--;
    AssertMsg(m_cRef == 0, "Locks should be 0 after callbacks");
}


/***************************************************************************\
*
* Context::Build
*
* Build() creates a new, fully initialized Context instance.
*
* NOTE: This function is designed to be called from the ResourceManager
* and should not normally be called directly.
*
* <error>   E_OUTOFMEMORY</>
* <error>   E_NOTIMPL</>
* <error>   E_INVALIDARG</>
*
\***************************************************************************/

HRESULT
Context::Build(
    IN  INITGADGET * pInit,             // Context description
    IN  DUserHeap * pHeap,              // Context heap to use
    OUT Context ** ppctxNew)            // Newly created Context
{
#if USE_DYNAMICTLS
    AssertMsg(!IsInitContext(), "Only call on uninitialized Context's");
#else
    AssertMsg(t_pContext == NULL, "Only call on uninitialized Context's");
#endif

    Context * pContext  = NULL;
    HRESULT hr          = E_INVALIDARG;

    //
    // Create a new Context and initialize low-level resources that other
    // initialization requires (such as a heap).
    //

    pContext = ProcessNew(Context);
    if (pContext == NULL) {
        hr = E_OUTOFMEMORY;
        goto ErrorExit;
    }

    AssertMsg(pHeap != NULL, "Must specify a valid heap");
    pContext->m_pHeap       = pHeap;
    pContext->m_nThreadMode = pInit->nThreadMode;
    pContext->m_nPerfMode   = pInit->nPerfMode;
    if ((pContext->m_nPerfMode == IGPM_BLEND) && IsRemoteSession()) {
        //
        // For "blend" models, if we are running as a TS session, optimize for
        // size.
        //

        pContext->m_nPerfMode = IGPM_SIZE;
    }

    BOOL fThreadSafe;
    switch (pInit->nThreadMode)
    {
    case IGTM_SINGLE:
    case IGTM_SEPARATE:
        fThreadSafe = FALSE;
        break;

    default:
        fThreadSafe = TRUE;
    }

    pContext->m_lock.SetThreadSafe(fThreadSafe);


    //
    // Initialize each of the sub-contexts.  These can safely use the heap
    // which has already been initialized.  We need to grab a ContextLock 
    // during this since we may make callbacks during construction of a 
    // Context.
    //

#if !USE_DYNAMICTLS
    t_pContext = pContext;  // SubContext's may need to grab the Context
#endif
    {
        ContextLock cl;
        Verify(cl.LockNL(ContextLock::edDefer, pContext));

        for (int idx = 0; idx < slCOUNT; idx++) {
            ContextPackBuilder * pBuilder = ContextPackBuilder::GetBuilder((Context::ESlot) idx);
            AssertMsg(pBuilder != NULL, "Builder not initialized using INIT_SUBCONTEXT");
            pContext->m_rgSCs[idx] = pBuilder->New(pContext);
            if (pContext->m_rgSCs[idx] == NULL) {
                hr = E_OUTOFMEMORY;
                goto ErrorExit;
            }

            hr = pContext->m_rgSCs[idx]->Create(pInit);
            if (FAILED(hr)) {
#if !USE_DYNAMICTLS
                t_pContext = NULL;
#endif
                goto ErrorExit;
            }
        }
    }

    AssertMsg(pContext != NULL, "Ensure Context is valid");

    *ppctxNew = pContext;
    return S_OK;

ErrorExit:
    AssertMsg(FAILED(hr), "Must specify failure");


    //
    // Something went wrong while creating a new context, so need to tear it 
    // down.
    //
    // NOTE: We CAN NOT use xwUnlock() or xwDeleteHandle(), since these are
    // intercepted and would go through the ResourceManager.  Instead, we need
    // bump down the ref count, pre-destroy the Context, and delete it.
    //

    if (pContext != NULL) {
        VerifyMsg(--pContext->m_cRef == 0, "Should only have initial reference");
        pContext->xwPreDestroyNL();

        ProcessDelete(Context, pContext);
    }
    *ppctxNew = NULL;

    return hr;
}


/***************************************************************************\
*
* Context::xwDeleteHandle
*
* xwDeleteHandle() is called from ::DeleteHandle() to destroy an object and 
* free its associated resources.  This function must be called on the same 
* thread as originally created the Context so that the corresponding Thread 
* object can also be destroyed.
*
\***************************************************************************/

BOOL
Context::xwDeleteHandle()
{
#if DBG
    AssertMsg(IsInitThread(), "Thread must be initialized to destroy the Context");
    Context * pctxThread = GetThread()->GetContext();
    AssertMsg(pctxThread == this, "Thread currently running on should match the Context being destroyed");
#endif // DBG


#if DBG_CHECK_CALLBACKS
    if (m_cLiveCallbacks > 0) {
        AutoTrace("DirectUser Context: 0x%p\n", this);
        AlwaysPromptInvalid("Can not DeleteHandle(Context) while inside a callback");
    }
#endif    

    //
    // We have NOT taken a ContextLock when calling DeleteHandle() on the 
    // Context.  Therefore, we are actually an NL function, but the virtual
    // function can't be renamed.
    //

    ResourceManager::xwNotifyThreadDestroyNL();

    return FALSE;
}


/***************************************************************************\
*
* Context::AddCurrentThread
*
* AddCurrentThread() sets the current thread to use the specified Context.
* 
* NOTE: This function is designed to be called from the ResourceManager
* and should not normally be called directly.
*
\***************************************************************************/

void        
Context::AddCurrentThread()
{
#if USE_DYNAMICTLS
    AssertMsg(!IsInitContext(), "Ensure Context is not already set");
#else
    AssertMsg(t_pContext == NULL, "Ensure Context is not already set");
#endif

    GetThread()->SetContext(this);
}


/***************************************************************************\
*
* Context::xwOnIdleNL
*
* xwOnIdleNL() cycles through all of the SubContext's, giving each an 
* opportunity to perform any idle-time processing.  This is time when there 
* are no more messages to process.  Each SubContext can also return a 
* "delay" count that specifies how long it will have before more processing.
* 
\***************************************************************************/

DWORD
Context::xwOnIdleNL()
{
    DWORD dwTimeOut = INFINITE;
    AssertMsg(dwTimeOut == 0xFFFFFFFF, "Ensure largest delay");

    for (int idx = 0; idx < slCOUNT; idx++) {
        DWORD dwNewTimeOut = m_rgSCs[idx]->xwOnIdleNL();
        if (dwNewTimeOut < dwTimeOut) {
            dwTimeOut = dwNewTimeOut;
        }
    }

    return dwTimeOut;
}


#if DBG

//------------------------------------------------------------------------------
void
Context::DEBUG_AssertValid() const
{
    if (IsOrphanedNL()) {
        PromptInvalid("Illegally using an orphaned Context");
        AssertMsg(0, "API layer let an Orphaned Context in");
    }
    
    if (m_DEBUG_tidLock != 0) {
        Assert(m_DEBUG_pthrLock != NULL);
    }

    Assert(m_pHeap != NULL);

    for (int idx = 0; idx < slCOUNT; idx++) {
        AssertInstance(m_rgSCs[idx]);
    }
}

#endif
    

/***************************************************************************\
*****************************************************************************
*
* class ContextPackBuilder
*
*****************************************************************************
\***************************************************************************/

PREINIT_SUBCONTEXT(CoreSC);
PREINIT_SUBCONTEXT(MotionSC);

ContextPackBuilder * ContextPackBuilder::s_rgBuilders[Context::slCOUNT] =
{
    INIT_SUBCONTEXT(CoreSC),
    INIT_SUBCONTEXT(MotionSC),
};


/***************************************************************************\
*****************************************************************************
*
* class SubContext
*
*****************************************************************************
\***************************************************************************/

#if DBG

//------------------------------------------------------------------------------
void
SubContext::DEBUG_AssertValid() const
{
    // Don't use AssertInstance since it would be recursive.
    Assert(m_pParent != NULL);
}

#endif
    

/***************************************************************************\
*****************************************************************************
*
* class ContextLock
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
BOOL
ContextLock::LockNL(ContextLock::EnableDefer ed, Context * pctxThread)
{
    AssertMsg(pctx == NULL, "Can only Lock() once");
    AssertMsg(pctxThread != NULL, "Must specify a valid Context to lock");


    //
    // Check if the Context has been orphaned __before__ entering the lock so 
    // that we access as few members as possible.
    //
    
    if (pctxThread->IsOrphanedNL()) {
        PromptInvalid("Illegally using an orphaned Context");
        return FALSE;
    }

    pctx = pctxThread;
    pctx->Enter();
    pctx->EnableDefer(ed, &fOldDeferred);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\services\commanager.inl ===
#if !defined(SERVICES__ComManager_inl__INCLUDED)
#define SERVICES__ComManager_inl__INCLUDED
#pragma once

//------------------------------------------------------------------------------
inline HRESULT
ComManager::CreateInstance(REFCLSID rclsid, IUnknown * punkOuter, REFIID riid, void ** ppv)
{
    AssertMsg(IsInit(sCOM), "Must be successfully initialized before calling");
    return (s_pfnCreate)(rclsid, punkOuter, CLSCTX_INPROC, riid, ppv);
}


//------------------------------------------------------------------------------
inline BSTR
ComManager::SysAllocString(const OLECHAR * psz)
{
    AssertMsg(IsInit(sAuto), "Must be successfully initialized before calling");
    return (s_pfnAllocString)(psz);
}


//------------------------------------------------------------------------------
inline HRESULT
ComManager::SysFreeString(BSTR bstr)
{
    AssertMsg(IsInit(sAuto), "Must be successfully initialized before calling");
    return (s_pfnFreeString)(bstr);
}


//------------------------------------------------------------------------------
inline HRESULT
ComManager::VariantInit(VARIANTARG * pvarg)
{
    AssertMsg(IsInit(sAuto), "Must be successfully initialized before calling");
    return (s_pfnVariantInit)(pvarg);
}


//------------------------------------------------------------------------------
inline HRESULT
ComManager::VariantClear(VARIANTARG * pvarg)
{
    AssertMsg(IsInit(sAuto), "Must be successfully initialized before calling");
    return (s_pfnVariantClear)(pvarg);
}


//------------------------------------------------------------------------------
inline HRESULT
ComManager::RegisterDragDrop(HWND hwnd, IDropTarget * pDropTarget)
{
    AssertMsg(IsInit(sOLE), "Must be successfully initialized before calling");
    return (s_pfnRegisterDragDrop)(hwnd, pDropTarget);
}


//------------------------------------------------------------------------------
inline HRESULT
ComManager::RevokeDragDrop(HWND hwnd)
{
    AssertMsg(IsInit(sOLE), "Must be successfully initialized before calling");
    return (s_pfnRevokeDragDrop)(hwnd);
}


//------------------------------------------------------------------------------
inline void
ComManager::ReleaseStgMedium(STGMEDIUM * pstg)
{
    AssertMsg(IsInit(sOLE), "Must be successfully initialized before calling");
    (s_pfnReleaseStgMedium)(pstg);
}


#endif // SERVICES__ComManager_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\services\context.h ===
/***************************************************************************\
*
* File: Context.h
*
* Description:
* This file declares the main Context used by the ResourceManager to manage
* independent "work contexts".
*
*
* History:
*  4/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(SERVICES__Context_h__INCLUDED)
#define SERVICES__Context_h__INCLUDED
#pragma once

class Context;
class SubContext;
class ContextPackBuilder;

#if DBG
class Thread;
#endif // DBG

/***************************************************************************\
*****************************************************************************
*
* Context defines a pool of threads that can shared objects between the 
* threads.  Inside DirectUser, only one thread is allowed to execute within 
* the context at a time UNLESS IT IS AN "NL" function.  By dividing the
* process into independent Context's, threads that are mostly unrelated can
* operate without colliding over shared locks.
*
* Context objects are not created until the application explicitly calls
* InitGadgets().  They can also be destroyed if the application calls
* ::DeleteHandle() on the HDCONTEXT.  This means that a thread may or may not
* have a Context, though usually it will.
*
*****************************************************************************
\***************************************************************************/

class Context : public BaseObject
{
public:
            Context();
            ~Context();
    static  HRESULT     Build(INITGADGET * pInit, DUserHeap * pHeap, Context ** ppctxNew);
    virtual BOOL        xwDeleteHandle();
protected:
    virtual void        xwDestroy();
public:
            void        xwPreDestroyNL();

// BaseObject Interface
public:
    virtual HandleType  GetHandleType() const { return htContext; }
    virtual UINT        GetHandleMask() const { return 0; }

// Operations
public:
    enum ESlot {
        slCore          = 0,            // Core
        slMotion,                       // Motions
        slCOUNT,                        // Number of sub-contexts
    };

    inline  void        MarkOrphaned();
    inline  BOOL        IsOrphanedNL() const;

    inline  void        Enter();        // Take shared Context lock
    inline  void        Leave();        // Release shared Context lock
    inline  void        Leave(BOOL fOldEnableDefer, BOOL * pfPending);

#if DBG_CHECK_CALLBACKS
    inline  void        BeginCallback();
    inline  void        EndCallback();
#endif    

    inline  void        BeginReadOnly();
    inline  void        EndReadOnly();
    inline  BOOL        IsReadOnly() const;
    inline  UINT        GetThreadMode() const;
    inline  UINT        GetPerfMode() const;

    inline  DUserHeap * GetHeap() const;
    inline  SubContext* GetSC(ESlot slot) const;
            void        AddCurrentThread();

    inline  BOOL        IsEnableDefer() const;
    inline  void        EnableDefer(BOOL fEnable, BOOL * pfOld);
    inline  void        MarkPending();

            DWORD       xwOnIdleNL();       // Idle time processing


#if DBG_CHECK_CALLBACKS
            int         m_cLiveObjects;     // Live objects outstanding
            int         m_cTotalObjects;    // Total objects allocated
#endif

// Implementation
#if DBG
public:
    virtual void        DEBUG_AssertValid() const;
#endif    

// Data
protected:
#if DBG
            Thread *    m_DEBUG_pthrLock; // DEBUG: Thread that locked Context
            DWORD       m_DEBUG_tidLock;// Thread ID of thread that locks
#endif // DBG
            long        m_cEnterLock;   // Count of outstanding Enter()'s
#if DBG_CHECK_CALLBACKS
            int         m_cLiveCallbacks; // Outstanding callbacks
#endif            
            CritLock    m_lock;         // Shared access lock
            DUserHeap * m_pHeap;        // Initialized heap
            UINT        m_cReadOnly;    // Count of pending "read-only" operations
            BOOL        m_fPending;     // Deferred callbacks are pending (GIVE THIS A FULL BOOL)
            BOOL        m_fEnableDefer:1; // Enabled deferred messages
            BOOL        m_fPreDestroy:1;// Have pre-destroyed the Context
            BOOL        m_fOrphaned:1;  // Context has been orphaned
            UINT        m_nThreadMode;  // Threading model for Context
            UINT        m_nPerfMode;    // Performance model

            SubContext* m_rgSCs[slCOUNT];   // Sub-context information
};


/***************************************************************************\
*****************************************************************************
*
* SubContext defines a "extensibility" mechanism that allows individual
* projects in DirectUser to provide additional data to store on the context.
* To use this, the project must add a new slot in Context, derive a class
* from SubContext that is created per Context instance, and derive a class
* from ContextPackBuilder to register the extension.
*
*****************************************************************************
\***************************************************************************/

class SubContext
{
// Construction
public:
    virtual ~SubContext() { }
    virtual HRESULT     Create(INITGADGET * pInit) { UNREFERENCED_PARAMETER(pInit); return S_OK; }
    virtual void        xwPreDestroyNL() PURE;

// Operations
public:
    inline  void        SetParent(Context * pParent);

    virtual DWORD       xwOnIdleNL() { return INFINITE; }

// Implementation
#if DBG
public:
    virtual void        DEBUG_AssertValid() const;
#endif    

// Data
protected:
            Context *   m_pParent;
};


/***************************************************************************\
*****************************************************************************
*
* ContextPackBuilder registers an SubContext "extension" to be created 
* whenever a new Context is created.  The constructor is expected to set the
* slot corresponding to the ESlot value.
*
*****************************************************************************
\***************************************************************************/

class ContextPackBuilder
{
// Construction
public:

// Operations
public:
    virtual SubContext* New(Context * pContext) PURE;
    static  inline ContextPackBuilder *
                        GetBuilder(Context::ESlot slot);

// Data
protected:
    static  ContextPackBuilder * 
                        s_rgBuilders[Context::slCOUNT];
};


#define IMPLEMENT_SUBCONTEXT(id, obj)                       \
    class obj##Builder : public ContextPackBuilder          \
    {                                                       \
    public:                                                 \
        virtual SubContext * New(Context * pParent)         \
        {                                                   \
            SubContext * psc = ProcessNew(obj);             \
            if (psc != NULL) {                              \
                psc->SetParent(pParent);                    \
            }                                               \
            return psc;                                     \
        }                                                   \
    } g_##obj##B                                            \

#define PREINIT_SUBCONTEXT(obj)                             \
    class obj##Builder;                                     \
    extern obj##Builder g_##obj##B                          \

#define INIT_SUBCONTEXT(obj)                                \
    (ContextPackBuilder *) &g_##obj##B                      \
    


inline  Context *   GetContext();
inline  BOOL        IsInitContext();

/***************************************************************************\
*****************************************************************************
*
* ContextLock provides a convenient mechanism of locking the Context and
* automatically unlocking when finished.  Because ContextLock perform 
* additional Context-specific actions, it is important to use a ContextLock 
* to lock a Context instead of using an ObjectLock.
*
*****************************************************************************
\***************************************************************************/

class ContextLock
{
public:
    enum EnableDefer
    {
        edNone  = FALSE,        // Enabled deferred messages
        edDefer = TRUE,         // Don't enable deferred messages
    };

    inline  ContextLock();
    inline  ~ContextLock();

            BOOL    LockNL(ContextLock::EnableDefer ed, Context * pctxThread = GetContext());

// Data (public access)
            Context *   pctx;
            BOOL        fOldDeferred;
};


class ReadOnlyLock
{
public:
    inline  ReadOnlyLock(Context * pctxThread = GetContext());
    inline  ~ReadOnlyLock();

    Context *   pctx;
};


#if DBG_CHECK_CALLBACKS

#define BEGIN_CALLBACK()                \
    __try {                             \
        if (!IsInitThread()) {          \
            AlwaysPromptInvalid("DirectUser has been uninitialized before processing a callback (1)"); \
        }                               \
        GetContext()->BeginCallback();  \
        

#define END_CALLBACK()                  \
    } __finally {                       \
        GetContext()->EndCallback();    \
        if (!IsInitThread()) {          \
            AlwaysPromptInvalid("DirectUser has been uninitialized while processing a Message (2)"); \
        }                               \
    }

#endif // DBG_CHECK_CALLBACKS

#include "Context.inl"

#endif // SERVICES__Context_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\services\context.inl ===
/***************************************************************************\
*
* File: Context.inl
*
* History:
*  4/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(SERVICES__Context_inl__INCLUDED)
#define SERVICES__Context_inl__INCLUDED
#pragma once

#include "Thread.h"

#if !USE_DYNAMICTLS
extern __declspec(thread) Context * t_pContext;
#endif

/***************************************************************************\
*****************************************************************************
*
* class Context
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline Context * 
GetContext()
{
#if USE_DYNAMICTLS
    Assert(IsInitThread());
    
    Context * pContext = GetThread()->GetContext();
#else
    Context * pContext = t_pContext;
#endif
    AssertMsg(pContext != NULL, "Using uninitialized Context");
    return pContext;
}


//------------------------------------------------------------------------------
__forceinline Context * 
RawGetContext()
{
#if USE_DYNAMICTLS
    Thread * pthr = RawGetThread();
    if (pthr != NULL) {
        return pthr->GetContext();
    } else {
        return (Context *) pthr;
    }
#else
    return t_pContext;
#endif
}


//------------------------------------------------------------------------------
inline BOOL        
IsInitContext()
{
#if USE_DYNAMICTLS
    Thread * pthr = RawGetThread();
    return (pthr != NULL) && (pthr->GetContext() != NULL);
#else
    return t_pContext != NULL;
#endif
}


//------------------------------------------------------------------------------
inline Context * 
CastContext(BaseObject * pbase)
{
    if ((pbase != NULL) && (pbase->GetHandleType() == htContext)) {
        return (Context *) pbase;
    }
    return NULL;
}


//------------------------------------------------------------------------------
inline const Context * 
CastContext(const BaseObject * pbase)
{
    if ((pbase != NULL) && (pbase->GetHandleType() == htContext)) {
        return (const Context *) pbase;
    }
    return NULL;
}


//------------------------------------------------------------------------------
inline void
Context::MarkOrphaned()
{
    // NOTE: A Context may be orphaned multiple times from different threads.
    m_fOrphaned = TRUE;
}


//------------------------------------------------------------------------------
inline BOOL
Context::IsOrphanedNL() const
{
    return m_fOrphaned;
}


//------------------------------------------------------------------------------
inline void   
Context::Enter()
{
    AssertMsg(m_cRef > 0, "Context must be valid to be locked");
    m_lock.Enter();
    Lock();
    if (m_cEnterLock++ == 0) {
        //
        // Just entered, so no deferred callbacks yet.
        // 
        m_fPending = FALSE;
    }

#if DBG
    if (m_cEnterLock > 30) {
        Trace("WARNING: DUser: m_cEnterLock is getting high (%d) for Context 0x%p.\n", m_cEnterLock, this);
        Trace("                Probably have an Enter() without an matching Leave().\n");
    }
#endif

#if DBG
    m_DEBUG_pthrLock    = IsInitThread() ? GetThread() : (Thread *) (void *) 0x12345678;
    m_DEBUG_tidLock     = GetCurrentThreadId();
#endif // DBG
}


//------------------------------------------------------------------------------
inline void   
Context::Leave()
{
#if DBG
    m_DEBUG_pthrLock    = NULL;
    m_DEBUG_tidLock     = 0;
#endif // DBG

    AssertMsg(m_cEnterLock > 0, "Must have a matching Enter() for every Leave()");
    --m_cEnterLock;

    AssertMsg(m_cRef > 0, "Context should still be valid when unlocked");
    if (xwUnlock()) {
        //
        // Only can access the object if it is still valid after being 
        // xwUnlock()'d.
        //

        m_lock.Leave();
    }
}


//------------------------------------------------------------------------------
inline void   
Context::Leave(BOOL fOldEnableDefer, BOOL * pfPending)
{
#if DBG
    m_DEBUG_pthrLock    = NULL;
    m_DEBUG_tidLock     = 0;
#endif // DBG

    AssertMsg(m_cEnterLock > 0, "Must have a matching Enter() for every Leave()");
    *pfPending      = (--m_cEnterLock == 0) && m_fPending && m_fEnableDefer;  // Must --m_cEnterLock first
    m_fEnableDefer  = fOldEnableDefer;

    AssertMsg(m_cRef > 0, "Context should still be valid when unlocked");
    if (xwUnlock()) {
        //
        // Only can access the object if it is still valid after being 
        // xwUnlock()'d.
        //

        m_lock.Leave();
    }
}


//------------------------------------------------------------------------------
inline DUserHeap * 
Context::GetHeap() const
{
    AssertMsg(m_pHeap != NULL, "Heap should be specified for Context");
    return m_pHeap;
}


//------------------------------------------------------------------------------
inline SubContext *
Context::GetSC(ESlot slot) const
{
    return m_rgSCs[slot];
}


#if DBG_CHECK_CALLBACKS

//------------------------------------------------------------------------------
inline void
Context::BeginCallback()
{
    m_cLiveCallbacks++;
}


//------------------------------------------------------------------------------
inline void        
Context::EndCallback()
{
    Assert(m_cLiveCallbacks > 0);
    m_cLiveCallbacks--;
}

#endif // DBG_CHECK_CALLBACKS


//------------------------------------------------------------------------------
inline void
Context::BeginReadOnly()
{
    AssertMsg(m_cEnterLock > 0, "Must have Enter()'d the context before making read-only");
    m_cReadOnly++;
}


//------------------------------------------------------------------------------
inline void        
Context::EndReadOnly()
{
    Assert(m_cEnterLock > 0);
    m_cReadOnly--;
}


//------------------------------------------------------------------------------
inline BOOL        
Context::IsReadOnly() const
{
    return m_cReadOnly;
}


//------------------------------------------------------------------------------
inline UINT
Context::GetThreadMode() const
{
    return m_nThreadMode;
}


//------------------------------------------------------------------------------
inline UINT
Context::GetPerfMode() const
{
    return m_nPerfMode;
}


//------------------------------------------------------------------------------
inline BOOL
Context::IsEnableDefer() const
{
    return m_fEnableDefer;
}


//------------------------------------------------------------------------------
__forceinline void
Context::EnableDefer(BOOL fEnable, BOOL * pfOld)
{
    if (pfOld != NULL) {
        *pfOld = m_fEnableDefer;
    }

    m_fEnableDefer = fEnable;
}


//------------------------------------------------------------------------------
inline void
Context::MarkPending()
{
    AssertMsg(m_fEnableDefer, "Deferred callbacks must be enabled");
    m_fPending = TRUE;
}


/***************************************************************************\
*****************************************************************************
*
* class SubContext
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline void
SubContext::SetParent(Context * pParent)
{
    AssertMsg(m_pParent == NULL, "Must set only once");
    m_pParent = pParent;
}


/***************************************************************************\
*****************************************************************************
*
* class ContextPackBuilder
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline ContextPackBuilder *
ContextPackBuilder::GetBuilder(Context::ESlot slot)
{
    AssertMsg(s_rgBuilders[slot] != NULL, "Build must be defined");
    return s_rgBuilders[slot];
}


/***************************************************************************\
*****************************************************************************
*
* Various lock helpers
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline  
ContextLock::ContextLock()
{
    pctx = NULL;
}


//------------------------------------------------------------------------------
inline  
ContextLock::~ContextLock()
{
    if (pctx != NULL) {
        //
        // Leaving the lock, so notify the Thread and give it a chance to do 
        // anything it needed afterwards.
        //

        BOOL fPending;
        pctx->Leave(fOldDeferred, &fPending);

        if (fPending) {
            GetThread()->xwLeftContextLockNL();
        }
    }
}


//------------------------------------------------------------------------------
inline  
ReadOnlyLock::ReadOnlyLock(Context * pctxThread)
{
    pctx = pctxThread;
    pctx->BeginReadOnly();
}


//------------------------------------------------------------------------------
inline  
ReadOnlyLock::~ReadOnlyLock()
{
    pctx->EndReadOnly();
}


#endif // SERVICES__Context_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\services\dxmanager.inl ===
/***************************************************************************\
*
* File: DxManager.inl
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(SERVICES__DxManager_inl__INCLUDED)
#define SERVICES__DxManager_inl__INCLUDED

/***************************************************************************\
*****************************************************************************
*
* class DxManager
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline BOOL        
DxManager::IsInit() const
{
    return m_hDllDxDraw != NULL;
}


//------------------------------------------------------------------------------
inline BOOL        
DxManager::IsDxTxInit() const
{
    return m_pdxXformFac != NULL;
}


//------------------------------------------------------------------------------
inline IDXTransformFactory *   
DxManager::GetTransformFactory() const
{
    AssertMsg(IsDxTxInit(), "DxTx must first be initialized");
    AssertMsg(m_pdxXformFac != NULL, "Should have valid TxF");

    return m_pdxXformFac;
}


//------------------------------------------------------------------------------
inline IDXSurfaceFactory *     
DxManager::GetSurfaceFactory() const
{
    AssertMsg(IsDxTxInit(), "DxTx must first be initialized");
    AssertMsg(m_pdxSurfFac != NULL, "Should have valid SxF");

    return m_pdxSurfFac;
}


/***************************************************************************\
*****************************************************************************
*
* class DxSurface
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline  IDXSurface *    
DxSurface::GetSurface() const
{
    Assert(m_pdxSurface != NULL);
    return m_pdxSurface;
}


//------------------------------------------------------------------------------
inline SIZE
DxSurface::GetSize() const
{
    return m_sizePxl;
}


#endif // SERVICES__DxManager_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\services\gdicache.cpp ===
/***************************************************************************\
*
* File: GdiCache.cpp
*
* Description:
* GdiCache.cpp implements the process-wide GDI cache that manages cached and
* temporary GDI objects.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Services.h"
#include "GdiCache.h"

/***************************************************************************\
*****************************************************************************
*
* class ObjectCache
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
void
ObjectCache::Destroy()
{
    //
    // Remove all temporary regions.  These MUST all be released by this point.
    //
    AssertMsg(m_arAll.GetSize() == m_arFree.GetSize(), "All objects should be free");

#if ENABLE_DUMPCACHESTATS
    AutoTrace("%s ObjectCache statistics: %d items\n", m_szName, m_arAll.GetSize());
#endif // ENABLE_DUMPCACHESTATS

    int cObjs = m_arAll.GetSize();
    for (int idx = 0; idx < cObjs; idx++) {
        DestroyObject(m_arAll[idx]);
    }
    m_arAll.RemoveAll();
    m_arFree.RemoveAll();
}


//------------------------------------------------------------------------------
void *
ObjectCache::Pop()
{
    void * pObj;

    //
    // Check if any objects are already freed.
    //

    if (!m_arFree.IsEmpty()) {
        int idxObj = m_arFree.GetSize() - 1;
        pObj = m_arFree[idxObj];
        Verify(m_arFree.RemoveAt(idxObj));

        goto Exit;
    }


    //
    // No cached regions, so create a new one.
    //

    pObj = Build();
    if (pObj == NULL) {
        AssertMsg(0, "Could not create a new object- something is probably wrong");
        goto Exit;
    }

    {
        int idxAdd = m_arAll.Add(pObj);
        if (idxAdd == -1) {
            AssertMsg(0, "Could not add object to array- something is probably wrong");
            DestroyObject(pObj);
            pObj = NULL;
            goto Exit;
        }
    }

Exit:
    return pObj;
}


//------------------------------------------------------------------------------
void        
ObjectCache::Push(void * pObj)
{
#if DBG
    //
    // Ensure this object was previously given out, but is not currently listed 
    // as free.
    //

    {
        BOOL fValid;
        int cItems, idx;

        fValid = FALSE;
        cItems = m_arAll.GetSize();
        for (idx = 0; idx < cItems; idx++) {
            if (m_arAll[idx] == pObj) {
                fValid = TRUE;
                break;
            }
        }

        AssertMsg(fValid, "Object not in list of all temporary regions");

        cItems = m_arFree.GetSize();
        for (idx = 0; idx < cItems; idx++) {
            AssertMsg(m_arFree[idx] != pObj, "Object must not be free object list");
        }
    }

#endif // DBG

    //
    // Add this object to the list of free objects.
    //

    if (m_arFree.GetSize() < m_cMaxFree) {
        VerifyMsg(m_arFree.Add(pObj) >= 0, "Should be able to add object to list");
    } else {
        DestroyObject(pObj);
    }
}


/***************************************************************************\
*****************************************************************************
*
* class GdiCache
*
*****************************************************************************
\***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\services\fastdib.h ===
/******************************Module*Header*******************************\
* Module Name: fastdib.h
*
* CreateCompatibleDIB definitions.
*
* Created: 02-Feb-1996 19:30:45
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

/*
This application draws a spinning RGB color cube into a bitmap and
copies this bitmap to the display window, demonstrating the use
of optimized DIBs with OpenGL.  Note that pressing any of the number
keys from 2-9 while the app is running will set a zoom factor which
will cause the app to shrink the bitmap and to use StretchBlt to copy
the bitmap to the display.

The FastDIB API functions are implemented in fastdib.c.  It is
merely an interface layer to existing Win32 functions.  It goal is
to encapsulate some of the complexity of determing formats, initializing
color tables, etc.

Note that use of optimized DIBs on palettized (i.e., 8bpp) display devices
on OpenGL/95 version 1.0 is broken.  If running on Win95, the following
line in timecube.c should be commented out:

    #define _COMPATIBLE_DIB_FIX_

------------------------------------------------------------------------------

CreateCompatibleDIB
-------------------

HBITMAP APIENTRY CreateCompatibleDIB(hdc, hpal, ulWidth, ulHeight, ppvBits)
HDC hdc;
HPALETTE hpal;
ULONG ulWidth;
ULONG ulHeight;
PVOID *ppvBits;

Create a DIB section bitmap with an optimized format with respect to the
specified display DC.  Optimized in this case means that the bitmap format
(and palette, if applicable) are matched to the display and will ensure
the highest possible Blt performance.

Parameters

    hdc

        Specifies display DC used to determine format.  If hpal is NULL,
        this hdc is used to retrieve the system palette entries with which
        the DIB color table is initialized (on palettized display devices
        only).

    hpal

        Optional palette that, if specified, is used to initialize the DIB
        color table.  If NULL, the system palette is used.  Ignored for
        non-palettized display devices.

    ulWidth

        Specifies the width of the bitmap.

    ulHeight

        Specifies the height of the bitmap.

    ppvBits

        Returns a pointer to the DIB section bits with which the application
        can draw directly into the bitmap.

Return Value

    The return value is the handle to the bitmap created.  If the function
    fails, the return value is NULL.

------------------------------------------------------------------------------

UpdateDIBColorTable
-------------------

BOOL APIENTRY UpdateDIBColorTable(hdcMem, hdc, hpal)
HDC hdcMem;
HDC hdc;
HPALETTE hpal;

Synchronize the color table of DIB bitmap selected into the specified
memory DC with either the current system palette or the optionally
specified logical palette.

This function need only be invoked on palettized display devices.

Parameters

    hdcMem

        Specified the memory DC into which the DIB of interest is selected.

    hdc

        Specifies the display DC for which the DIB is formatted.  If hpal
        is NULL this hdc is used to retrieve the system palette entries
        with which the DIB color table is initialized (on palettized display
        devices only).

    hpal

        Optional palette that, if specified, is used to initialize the DIB
        color table.  If NULL, the system palette is used.  Ignored for
        non-palettized display devices.

Return Value

    The return value is TRUE if the DIB color table is successfully updated.
    If the function fails, the return value is FALSE.

Comments

    Typically, this function is called only if the logical palette in the
    display DC changes.  For OpenGL apps, the logical palette is set only
    once for RGB modes, which implies that this function normally does not
    need to be used with RGB modes.  Color index modes, however, may change
    the logical palette at any time.  If that happens, then the application
    should invoke this function after the new palette has been realized.

------------------------------------------------------------------------------

GetCompatibleDIBInfo
--------------------

BOOL APIENTRY GetCompatibleDIBInfo(hbm, ppvBase, plStride)
HBITMAP hbm;
PVOID *ppvBase;
LONG *plStride;

Returns information about the specified DIB section that allows the
application to compute the address of a desired (x, y) pixel within
the bitmap.

Parameters

    hbm

        Specifies the DIB section bitmap of interest.

    ppvBase

        Returns a pointer to the origin of the bitmap.  If the DIB
        is top-down, then this is the same as the ppvBits returned
        by the intial call to CreateCompatibleDIB.  The default,
        however, is bottom-up.

    plStride

        Returns the stride or pitch of the bitmap (i.e., the difference
        in address between two vertically adjacent pixels).  If the bitmap
        is top-down, this value is positive; if the bitmap is bottom-up,
        this value is negative.

Return Value

    The return value is TRUE if the DIB color table is successfully updated.
    If the function fails, the return value is FALSE.

Comments

    The ppvBase and plStride value returned will allow the application to
    compute the address any given pixel (x, y) in the bitmap as follows:

    PIXEL *ppix;

    ppix = (PIXEL *) (((BYTE *)*ppvBase) + (y * *plStride) + (x * sizeof(PIXEL)));

------------------------------------------------------------------------------

GetDIBTranslationVector
-----------------------

BOOL APIENTRY GetDIBTranslationVector(HDC hdcMem, HPALETTE hpal, BYTE *pbVector)
HDC hdcMem;
HPALETTE hpal;
BYTE *pbVector;

Returns the translation vector that maps colors in the specified palette,
hpal, to the DIB selected into the specified DC, hdcMem.  This information
is needed so that applications that draw directly into the DIB can translate
the logical color indices into physical bitmap indices.

This function should only be invoked on palettized display devices.

Parameters

    hdcMem

        Specified the memory DC into which the DIB of interest is selected.

    hpal

        Specifies the logical palette which will be mapped to the DIB.

    pbVector

        Points to a buffer into which the translation vector will be copied.

Return Value

    The return value is TRUE if the DIB color table is successfully updated.
    If the function fails, the return value is FALSE.


Comments

    This function does not try to validate the buffer size.  It is up to
    the application to allocate enough memory for the call.  The amount of
    memory required in bytes equal in value to the number of entries
    in the logical palette:

        bufferSize = GetPaletteEntries(hpal, 0, 1, NULL) * sizeof(BYTE);

*/

#ifndef SERVICES__FastDib_h__INCLUDED
#define SERVICES__FastDib_h__INCLUDED

HBITMAP APIENTRY CreateCompatibleDIB(HDC hdc, HPALETTE hpal, ULONG ulWidth, ULONG ulHeight, PVOID *ppvBits, BITMAPINFOHEADER * pbmih = NULL);
BOOL APIENTRY UpdateDIBColorTable(HDC hdcMem, HDC hdc, HPALETTE hpal);
BOOL APIENTRY GetCompatibleDIBInfo(HBITMAP hbm, PVOID *ppvBase, LONG *plStride);
BOOL APIENTRY GetDIBTranslationVector(HDC hdcMem, HPALETTE hpal, BYTE *pbVector);

#endif //SERVICES__FastDib_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\services\dxmanager.cpp ===
/***************************************************************************\
*
* File: DxManager.cpp
*
* Description:
* DxManager.cpp implements the process-wide DirectX manager used for all 
* DirectDraw, Direct3D, and DirectX Transforms services.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Services.h"
#include "DxManager.h"

#include "GdiCache.h"
#include "Buffer.h"
#include "ResourceManager.h"

/***************************************************************************\
*****************************************************************************
*
* class DxManager
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
DxManager::DxManager()
{
    m_cDDrawRef = 0;
    m_cDxTxRef  = 0;
}


//------------------------------------------------------------------------------
DxManager::~DxManager()
{
#if DBG
    if (m_hDllDxDraw != NULL) {
        Trace("DUser Warning: Application did not call UninitGadgetComponent() to\n");
        Trace("    deinitialize properly\n");
    }
#endif // DBG
}


/***************************************************************************\
*
* DxManager::Init
*
* Init() initializes the DxManager by loading COM and core DirectX services.
*
\***************************************************************************/

HRESULT    
DxManager::Init(GUID * pguidDriver)
{
    if (m_hDllDxDraw == NULL) {
        //
        // Normal DirectDraw does not need COM to be initialized.
        //

        m_hDllDxDraw = LoadLibrary("ddraw.dll");
        if (m_hDllDxDraw == NULL) {
            return DU_E_GENERIC;
        }
    
        //
        // Load the functions.
        //
        // NOTE: On older versions of DirectDraw, DirectDrawCreateEx() doesn't
        // exist.  We need to specifically check this.
        //

        m_pfnCreate     = (DirectDrawCreateProc)    GetProcAddress(m_hDllDxDraw, _T("DirectDrawCreate"));
        m_pfnCreateEx   = (DirectDrawCreateExProc)  GetProcAddress(m_hDllDxDraw, _T("DirectDrawCreateEx"));

        if (m_pfnCreate == NULL) {
            goto errorexit;
        }

        //
        // First, try creating the most advance interface.
        //
        HRESULT hr;

        if (m_pfnCreateEx != NULL) {
            hr = (m_pfnCreateEx)(pguidDriver, (void **) &m_pDD7, IID_IDirectDraw7, NULL);
            if (SUCCEEDED(hr)) {
                AssertReadPtr(m_pDD7);

                m_pDD7->SetCooperativeLevel(NULL, DDSCL_NORMAL);

                //
                // Try to get an IDirectDraw interface as well.
                //

                m_pDD7->QueryInterface(IID_IDirectDraw, (void **) &m_pDD);


                {
                    HRESULT hRet;
                    DDSURFACEDESC2 ddsd;
                    IDirectDrawSurface7 * pDD;

                    ZeroMemory(&ddsd, sizeof(ddsd));
                    ddsd.dwSize = sizeof(ddsd);
                    ddsd.dwFlags = DDSD_CAPS;
                    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;
                    hRet = m_pDD7->CreateSurface(&ddsd, &pDD, NULL);
                    if (hRet == DD_OK)
                        pDD->Release();                        
                }

            } else {
                //
                // Explicitly set to NULL
                //

                m_pDD7 = NULL;
            }
        }

        //
        // If can't create advanced interface, go for backup
        //

        if (m_pDD7 == NULL) {
            AssertReadPtr(m_pfnCreate);
            hr = (m_pfnCreate)(pguidDriver, &m_pDD, NULL);
            if (SUCCEEDED(hr)) {
                m_pDD->SetCooperativeLevel(NULL, DDSCL_NORMAL);
            } else {
                //
                // Unable to initialize DirectDraw, so need to bail.
                //

                goto errorexit;
            }
        }
    }

    m_cDDrawRef++;
    return S_OK;

errorexit:
    Uninit();
    return DU_E_GENERIC;
}


//------------------------------------------------------------------------------
void    
DxManager::Uninit()
{
    if (m_cDDrawRef <= 0) {
        return;
    }

    m_cDDrawRef--;
    if (m_cDDrawRef <= 0) {
        //
        // Can't call Release() on the IDirectDraw interfaces here b/c we are 
        // shutting down and their v-tbl's are messed up.  Bummer.
        //

        SafeRelease(m_pDD7);
        SafeRelease(m_pDD);

        if (m_hDllDxDraw != NULL) {
            FreeLibrary(m_hDllDxDraw);
            m_hDllDxDraw  = NULL;
        }

        m_pfnCreate     = NULL;
        m_pfnCreateEx   = NULL;
    }
}


//------------------------------------------------------------------------------
HRESULT
DxManager::InitDxTx()
{
    AssertMsg(IsInit(), "DxManager must be first initialized");

    if (m_pdxXformFac == NULL) {
        //
        // DxTx needs COM to be initialized first.
        //
        if (!GetComManager()->Init(ComManager::sCOM)) {
            return DU_E_GENERIC;
        }

        // Build and initialize a Transform Factory
        HRESULT hr;
        hr = GetComManager()->CreateInstance(CLSID_DXTransformFactory, NULL, 
                IID_IDXTransformFactory, (void **)&m_pdxXformFac);
        if (FAILED(hr) || (m_pdxXformFac == NULL)) {
            goto Error;
        }

        hr = m_pdxXformFac->SetService(SID_SDirectDraw, m_pDD, FALSE);
        if (FAILED(hr)) {
            goto Error;
        }

        // Build a Surface Factory
        hr = m_pdxXformFac->QueryService(SID_SDXSurfaceFactory, IID_IDXSurfaceFactory, 
                (void **)&m_pdxSurfFac);
        if (FAILED(hr) || (m_pdxSurfFac  == NULL)) {
            goto Error;
        }
    }

    m_cDxTxRef++;
    return S_OK;

Error:
    SafeRelease(m_pdxSurfFac);
    SafeRelease(m_pdxXformFac);
    return DU_E_GENERIC;
}


//------------------------------------------------------------------------------
void 
DxManager::UninitDxTx()
{
    if (m_cDxTxRef <= 0) {
        return;
    }

    m_cDxTxRef--;
    if (m_cDxTxRef <= 0) {
        GetBufferManager()->FlushTrxBuffers();

        SafeRelease(m_pdxSurfFac);
        SafeRelease(m_pdxXformFac);
    }
}


//------------------------------------------------------------------------------
HRESULT
DxManager::BuildSurface(SIZE sizePxl, IDirectDrawSurface7 * pddSurfNew)
{
    AssertMsg(IsInit(), "DxManager must be first initialized");
    AssertMsg(m_pDD7 != NULL, "Must have DX7");

#if 0
    HDC hdc = GetGdiCache()->GetTempDC();
    int nBitDepth = GetDeviceCaps(hdc, BITSPIXEL);
#endif

    DDSURFACEDESC2 ddsd;
    ZeroMemory(&ddsd, sizeof(ddsd));
    ddsd.dwSize         = sizeof(ddsd);
    ddsd.dwFlags        = DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT;
    ddsd.dwWidth        = sizePxl.cx;
    ddsd.dwHeight       = sizePxl.cy;
    ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN;

#if 0
    GetGdiCache()->ReleaseTempDC(hdc);
#endif

    // TODO: Want to optimize where this surface is being created

    return m_pDD7->CreateSurface(&ddsd, &pddSurfNew, NULL);
}


//------------------------------------------------------------------------------
HRESULT
DxManager::BuildDxSurface(SIZE sizePxl, REFGUID guidFormat, IDXSurface ** ppdxSurfNew)
{
    AssertWritePtr(ppdxSurfNew);

    CDXDBnds bnds;
    bnds.SetXYSize(sizePxl.cx, sizePxl.cy);

    HRESULT hr = GetSurfaceFactory()->CreateSurface(m_pDD, NULL, 
            &guidFormat, &bnds, 0, NULL, IID_IDXSurface, (void**)ppdxSurfNew);
    if (FAILED(hr)) {
        return hr;
    }
    AssertMsg(*ppdxSurfNew != NULL, "Ensure valid surface");

    return TRUE;
}


/***************************************************************************\
*****************************************************************************
*
* class DxSurface
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
DxSurface::DxSurface()
{
    m_pdxSurface    = NULL;
    m_sizePxl.cx    = 0;
    m_sizePxl.cy    = 0;
}


//------------------------------------------------------------------------------
DxSurface::~DxSurface()
{
    SafeRelease(m_pdxSurface);
}


/***************************************************************************\
*
* DxSurface::Create
*
* Create() initializes a new instance of DxSurface.
*
\***************************************************************************/

HRESULT
DxSurface::Create(SIZE sizePxl)
{
    HRESULT hr;

    //
    // Build the surface
    //

#if 0
    m_guidFormat    = DDPF_ARGB32;
    m_sf            = DXPF_ARGB32;
#elif 0
    m_guidFormat    = DDPF_PMARGB32
    m_sf            = DXPF_PMARGB32
#elif 1
    m_guidFormat    = DDPF_RGB565;
    m_sf            = DXPF_RGB565;
#elif 0
    m_guidFormat    = DDPF_RGB555;
    m_sf            = DXPF_RGB555;
#elif 0
    m_guidFormat    = DDPF_ARGB4444;
    m_sf            = DXPF_ARGB4444;
#endif

    hr = GetDxManager()->BuildDxSurface(sizePxl, m_guidFormat, &m_pdxSurface);
    if (FAILED(hr)) {
        return hr;
    }

    DXPMSAMPLE sam;
    sam.Red     = 0xC0;
    sam.Green   = 0x00;
    sam.Blue    = 0x00;
    sam.Alpha   = 0xFF;

    DXFillSurface(m_pdxSurface, sam, FALSE);

    m_sizePxl.cx  = sizePxl.cx;
    m_sizePxl.cy  = sizePxl.cy;

    return S_OK;
}


/***************************************************************************\
*
* DxSurface::CopyDC
*
* CopyDC() copies a given HDC into the DxSurface, converting properly from 
* the GDI object into the Dx object.
*
\***************************************************************************/

BOOL        
DxSurface::CopyDC(
        IN  HDC hdcSrc,                 // HDC to copy bits from 
        IN  const RECT & rcCrop)        // Area to copy
{
    HRESULT hr;

    // Check parameters
    if (m_pdxSurface == NULL) {
        return FALSE;
    }
    if (hdcSrc == NULL) {
        return FALSE;
    }

    //
    // Copy the bitmap to the surface
    //
    BOOL fSuccess = FALSE;
    IDXDCLock * pdxLock = NULL;

#if 0
    {
        DXPMSAMPLE sam;
        sam.Red     = 0x00;
        sam.Green   = 0x00;
        sam.Blue    = 0x00;
        sam.Alpha   = 0xFF;

        DXFillSurface(m_pdxSurface, sam, FALSE);
    }
#endif

    pdxLock = NULL;
    hr = m_pdxSurface->LockSurfaceDC(NULL, INFINITE, DXLOCKF_READWRITE, &pdxLock);
    if (FAILED(hr) || (pdxLock == NULL)) {
        goto Cleanup;
    }

    {
        HDC hdcSurface = pdxLock->GetDC();
        BitBlt(hdcSurface, 0, 0, rcCrop.right - rcCrop.left, rcCrop.bottom - rcCrop.top, 
                hdcSrc, rcCrop.left, rcCrop.top, SRCCOPY);
    }

    pdxLock->Release();

    fSuccess = FixAlpha();

Cleanup:
    return fSuccess;
}


/***************************************************************************\
*
* DxSurface::CopyBitmap
*
* CopyBitmap() copies a given HBITMAP into the DxSurface, converting 
* properly from the GDI object into the Dx object.
*
\***************************************************************************/

BOOL            
DxSurface::CopyBitmap(
        IN  HBITMAP hbmpSrc,            // Bitmap to copy from
        IN  const RECT * prcCrop)       // Optional cropping area
{
    HRESULT hr;

    // Check parameters
    if (m_pdxSurface == NULL) {
        return FALSE;
    }
    if (hbmpSrc == NULL) {
        return FALSE;
    }


    //
    // Determine the area to copy
    //

    BITMAP bmpInfo;
    if (GetObject(hbmpSrc, sizeof(bmpInfo), &bmpInfo) == 0) {
        return FALSE;
    }

    POINT ptSrcOffset;
    SIZE sizeBmp;

    ptSrcOffset.x   = 0;
    ptSrcOffset.y   = 0;
    sizeBmp.cx      = bmpInfo.bmWidth;
    sizeBmp.cy      = bmpInfo.bmHeight;

    if (prcCrop != NULL) {
        SIZE sizeCrop;
        sizeCrop.cx = prcCrop->right - prcCrop->left;
        sizeCrop.cy = prcCrop->bottom - prcCrop->top;

        ptSrcOffset.x   = prcCrop->left;
        ptSrcOffset.y   = prcCrop->top;
        sizeBmp.cx      = min(sizeBmp.cx, sizeCrop.cx);
        sizeBmp.cy      = min(sizeBmp.cy, sizeCrop.cy);
    }


    //
    // Copy the bitmap to the surface
    //
    BOOL fSuccess = FALSE;
    HDC hdcBitmap = NULL;
    IDXDCLock * pdxLock = NULL;

    hdcBitmap = GetGdiCache()->GetCompatibleDC();
    if (hdcBitmap == NULL) {
        goto Cleanup;
    }

#if 0
    {
        DXPMSAMPLE sam;
        sam.Red     = 0x00;
        sam.Green   = 0x00;
        sam.Blue    = 0x00;
        sam.Alpha   = 0xFF;

        DXFillSurface(m_pdxSurface, sam, FALSE);
    }
#endif
    hr = m_pdxSurface->LockSurfaceDC(NULL, INFINITE, DXLOCKF_READWRITE, &pdxLock);
    if (FAILED(hr) || (pdxLock == NULL)) {
        goto Cleanup;
    }

    {
        HDC hdcSurface = pdxLock->GetDC();
        HBITMAP hbmpOld = (HBITMAP) SelectObject(hdcBitmap, hbmpSrc);
        BitBlt(hdcSurface, 0, 0, sizeBmp.cx, sizeBmp.cy, 
                hdcBitmap, ptSrcOffset.x, ptSrcOffset.y, SRCCOPY);
        SelectObject(hdcBitmap, hbmpOld);
    }

    pdxLock->Release();

    fSuccess = FixAlpha();

Cleanup:
    if (hdcBitmap != NULL) {
        GetGdiCache()->ReleaseCompatibleDC(hdcBitmap);
    }

    return fSuccess;
}


/***************************************************************************\
*
* DxSurface::FixAlpha
*
* FixAlpha() fixes the alpha values in a surface.  This usually needs to be 
* done after copying a GDI HBITMAP to a DXSurface, depending on the format.
*
\***************************************************************************/

BOOL
DxSurface::FixAlpha()
{
    IDXARGBReadWritePtr * pRW;

    HRESULT hr = m_pdxSurface->LockSurface(NULL, INFINITE, DXLOCKF_READWRITE,
            __uuidof(IDXARGBReadWritePtr), (void **)&pRW, NULL);
    if (FAILED(hr)) {
        return FALSE;
    }

    BOOL fSuccess = FALSE;

    if (!TestFlag(m_sf, DXPF_TRANSLUCENCY)) {
        //
        // Sample doesn't have any alpha, so okay
        //

        fSuccess = TRUE;
    } else if (m_sf == DXPF_ARGB32) {
        //
        // Format is 8:8:8:8 with alpha in MSB.  
        // Need to use Unpack() to get bits.
        // Each pixel is 32 bits.
        //

        DXSAMPLE * psam;
        for (int y = 0; y < m_sizePxl.cy; y++) {
            pRW->MoveToRow(y);
            psam = pRW->Unpack(NULL, m_sizePxl.cx, FALSE);
            Assert(psam != NULL);

            int x = m_sizePxl.cx;
            while (x-- > 0) {
                *psam = *psam | 0xFF000000;
                psam++;
            }
        }  

        fSuccess = TRUE;
    } else if (m_sf == DXPF_PMARGB32) {
        //
        // Format is 8:8:8:8 with alpha in MSB.  
        // Need to use UnpackPremult() to get bits.
        // Each pixel is 32 bits
        //

        DXPMSAMPLE * psam;
        for (int y = 0; y < m_sizePxl.cy; y++) {
            pRW->MoveToRow(y);
            psam = pRW->UnpackPremult(NULL, m_sizePxl.cx, FALSE);
            Assert(psam != NULL);

            int x = m_sizePxl.cx;
            while (x-- > 0) {
                *psam = *psam | 0xFF000000;
                psam++;
            }
        }  

        fSuccess = TRUE;
    } else if (m_sf == DXPF_ARGB4444) {
        //
        // Format is 4:4:4:4 with alpha in MSN.  
        // Need to use Unpack() to get bits.
        // Each pixel is 16 bits
        //

        int cb  = m_sizePxl.cx * sizeof(DXSAMPLE);
        DXSAMPLE * rgam = (DXSAMPLE *) _alloca(cb);
        DXSAMPLE * psam;
        for (int y = 0; y < m_sizePxl.cy; y++) {
            pRW->MoveToRow(y);
            psam = pRW->Unpack(rgam, m_sizePxl.cx, FALSE);
            Assert(psam != NULL);

            int x = m_sizePxl.cx;
            while (x-- > 0) {
                *psam = *psam | 0xFF000000;
                psam++;
            }

            pRW->PackAndMove(rgam, m_sizePxl.cx);
        }  

        fSuccess = TRUE;
    }

    pRW->Release();

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\services\gdicache.h ===
/***************************************************************************\
*
* File: GdiCache.h
*
* Description:
* GdiCache.h defines the process-wide GDI cache that manages cached and
* temporary GDI objects.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(SERVICES__GdiCache_h__INCLUDED)
#define SERVICES__GdiCache_h__INCLUDED
#pragma once

#define ENABLE_DUMPCACHESTATS       0   // Dump ObjectCache statistics

/***************************************************************************\
*****************************************************************************
*
* class ObjectCache
*
* ObjectCache declares a standard container used to cache temporary objects.  
* As new objects are requested, objects will be returned from the free list 
* of cached objects.  If this list is empty, new objects will be created.  
* When an object is released, it is added to the free list, ready to be used 
* again.
*
*****************************************************************************
\***************************************************************************/

class ObjectCache
{
// Construction
public:
    inline  ObjectCache();
    inline  ~ObjectCache();
            void        Destroy();

// Operations
public:
#if ENABLE_DUMPCACHESTATS
    inline  void        SetName(LPCSTR pszName);
#endif

// Implementation
protected:
            void *      Pop();
            void        Push(void * pObj);

    virtual void *      Build() PURE;
    virtual void        DestroyObject(void * pObj) PURE;

// Data
private:
            GArrayF<void *>
                        m_arAll;        // Collection of all temporary objects
            GArrayF<void *>
                        m_arFree;       // Indicies of available temporary objects
            int         m_cMaxFree;     // Maximum number of free objects

#if ENABLE_DUMPCACHESTATS
            char        m_szName[256];
#endif
};


/***************************************************************************\
*****************************************************************************
*
* class GdiObjectCacheT
*
* GdiObjectCacheT implements an ObjectCache for GDI objects.  To use this
* class, derive from GdiObjectCacheT and provide a Build() function to 
* create new object instance.
*
*****************************************************************************
\***************************************************************************/

template <class T>
class GdiObjectCacheT : public ObjectCache
{
public:
    inline  T           Get();
    inline  void        Release(T hObj);

protected:
    virtual void        DestroyObject(void * pObj);
};


/***************************************************************************\
*****************************************************************************
*
* Specific implementations of GdiObjectCacheT<>
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
class RgnCache : public GdiObjectCacheT<HRGN>
{
protected:
    virtual void *      Build()
    {
        return ::CreateRectRgn(0, 0, 0, 0);
    }
};


//------------------------------------------------------------------------------
class DisplayDCCache : public GdiObjectCacheT<HDC>
{
protected:
    virtual void *      Build()
    {
        return CreateDC("DISPLAY", NULL, NULL, NULL);
    }
};


//------------------------------------------------------------------------------
class CompatibleDCCache : public GdiObjectCacheT<HDC>
{
protected:
    virtual void *      Build()
    {
        HDC hdcDesk = ::GetDC(NULL);
        HDC hdc = ::CreateCompatibleDC(hdcDesk);
        ::ReleaseDC(NULL, hdcDesk);

        return hdc;
    }
};


/***************************************************************************\
*****************************************************************************
*
* class GdiCache 
* 
* GdiCache caches frequently used GDI objects.  By abstracting out how these
* objects are created and maintained, the large number of temporary objects
* used in DirectUser can be easily tweaked for performance and memory tuning.
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
class GdiCache
{
// Construction
public:
    inline  GdiCache();
    inline  ~GdiCache();
    inline  void        Destroy();

// Operations
public:
    inline  HRGN        GetTempRgn();
    inline  void        ReleaseTempRgn(HRGN hrgn);

    inline  HDC         GetTempDC();
    inline  void        ReleaseTempDC(HDC hdc);

    inline  HDC         GetCompatibleDC();
    inline  void        ReleaseCompatibleDC(HDC hdc);

// Data
private:
    RgnCache            m_gocTempRgn;   // Temporary regions
    DisplayDCCache      m_gocDisplayDC; // Display DC's
    CompatibleDCCache   m_gocCompatDC;  // Compatible DC's
};

#include "GdiCache.inl"

#endif // SERVICES__GdiCache_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\services\dxmanager.h ===
/***************************************************************************\
*
* File: DxManager.h
*
* Description:
* DxManager.h defines the process-wide DirectX manager used for all 
* DirectDraw, Direct3D, and DirectX Transforms services.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(SERVICES__DXManager_h__INCLUDED)
#define SERVICES__DXManager_h__INCLUDED
#pragma once

#pragma comment(lib, "dxguid.lib")  // Include DirectX GUID's

struct IDirectDraw;
struct IDXTransformFactory;
struct IDXSurfaceFactory;
struct IDXSurface;

typedef HRESULT (WINAPI * DirectDrawCreateProc)(GUID * pguid, IDirectDraw ** ppDD, IUnknown * punkOuter);
typedef HRESULT (WINAPI * DirectDrawCreateExProc)(GUID * pguid, void ** ppvDD, REFIID iid, IUnknown * punkOuter);

class DxSurface;

/***************************************************************************\
*
* class DxManager
*
* DxManager maintains interaction with DirectX technologies including:
* - DirectDraw
* - Direct3D
* - DirectTransforms
*
* By using this class instead of directly accessing DX, bettern coordination
* is maintained throughout SERVICES.
*
* NOTE: This manager is delay-loads DLL's to manage performance and work on
* down-level platforms.
*
\***************************************************************************/

class DxManager
{
// Construction
public:
            DxManager();
            ~DxManager();

// Operations
public:
            HRESULT     Init(GUID * pguidDriver = NULL);
            void        Uninit();
    inline  BOOL        IsInit() const;

            HRESULT     InitDxTx();
            void        UninitDxTx();
    inline  BOOL        IsDxTxInit() const;

    inline  IDXTransformFactory *   GetTransformFactory() const;
    inline  IDXSurfaceFactory *     GetSurfaceFactory() const;

            HRESULT     BuildSurface(SIZE sizePxl, IDirectDrawSurface7 * pddSurfNew);
            HRESULT     BuildDxSurface(SIZE sizePxl, REFGUID guidFormat, IDXSurface ** ppdxSurfNew);

// Data
protected:
    // DirectDraw
    UINT                    m_cDDrawRef;
    HINSTANCE               m_hDllDxDraw;   // DirectDraw DLL
    DirectDrawCreateProc    m_pfnCreate;
    DirectDrawCreateExProc  m_pfnCreateEx;
    IDirectDraw *           m_pDD;
    IDirectDraw7 *          m_pDD7;

    // DX Transforms
    UINT                    m_cDxTxRef;
    IDXTransformFactory *   m_pdxXformFac;
    IDXSurfaceFactory   *   m_pdxSurfFac;
};


/***************************************************************************\
*
* class DxSurface
*
* DxSurface maintains a single DXTX Surface.
*
\***************************************************************************/

class DxSurface
{
// Construction
public:
            DxSurface();
            ~DxSurface();
            HRESULT     Create(SIZE sizePxl);

// Operations
public:
    inline  IDXSurface* GetSurface() const;
            BOOL        CopyDC(HDC hdcSrc, const RECT & rcCrop);
            BOOL        CopyBitmap(HBITMAP hbmpSrc, const RECT * prcCrop);
    inline  SIZE        GetSize() const;

// Implementation
protected:
            BOOL        FixAlpha();

// Data
protected:
    IDXSurface *    m_pdxSurface;
    SIZE            m_sizePxl;      // (Cached) size of surface in pixels
    GUID            m_guidFormat;   // (Cached) format of the surface
    DXSAMPLEFORMATENUM  m_sf;       // Sample Format
};

#include "DxManager.inl"

#endif // SERVICES__DXManager_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\services\fastdib.cpp ===
/******************************Module*Header*******************************\
* Module Name: fastdib.c
*
* CreateCompatibleDIB implementation.
*
* Created: 23-Jan-1996 21:08:18
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1996 Microsoft Corporation
*
\**************************************************************************/

#include "stdafx.h"
#include <Services.h>

#include "FastDib.h"

static BOOL bFillBitmapInfo(HDC hdc, HPALETTE hpal, BITMAPINFO *pbmi);
static BOOL bFillColorTable(HDC hdc, HPALETTE hpal, BITMAPINFO *pbmi);
static UINT MyGetSystemPaletteEntries(HDC hdc, UINT iStartIndex, UINT nEntries,
                                      LPPALETTEENTRY lppe);
static BOOL bComputeLogicalToSurfaceMap(HDC hdc, HPALETTE hpal,
                                        BYTE *pajVector);

/******************************Public*Routine******************************\
* CreateCompatibleDIB
*
* Create a DIB section with an optimal format w.r.t. the specified hdc.
*
* If DIB <= 8bpp, then the DIB color table is initialized based on the
* specified palette.  If the palette handle is NULL, then the system
* palette is used.
*
* Note: The hdc must be a direct DC (not an info or memory DC).
*
* Note: On palettized displays, if the system palette changes the
*       UpdateDIBColorTable function should be called to maintain
*       the identity palette mapping between the DIB and the display.
*
* Returns:
*   Valid bitmap handle if successful, NULL if error.
*
* History:
*  23-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

HBITMAP APIENTRY
CreateCompatibleDIB(
    IN  HDC hdc, 
    IN  HPALETTE hpal, 
    IN  ULONG ulWidth, 
    IN  ULONG ulHeight,
    OUT PVOID *ppvBits, 
    OUT BITMAPINFOHEADER * pbmih)
{
    HBITMAP hbmRet = (HBITMAP) NULL;
    BYTE aj[sizeof(BITMAPINFO) + (sizeof(RGBQUAD) * 255)];
    BITMAPINFO *pbmi = (BITMAPINFO *) aj;

    //
    // Validate hdc.
    //

    if ( GetObjectType(hdc) != OBJ_DC )
    {
        Trace("CreateCompatibleDIB: not OBJ_DC\n");
        return hbmRet;
    }

    ZeroMemory(aj, sizeof(aj));
    if ( bFillBitmapInfo(hdc, hpal, pbmi) )
    {
        //
        // Change bitmap size to match specified dimensions.
        //

        pbmi->bmiHeader.biWidth = ulWidth;
        pbmi->bmiHeader.biHeight = ulHeight;
        if (pbmi->bmiHeader.biCompression == BI_RGB)
        {
            pbmi->bmiHeader.biSizeImage = 0;
        }
        else
        {
            if ( pbmi->bmiHeader.biBitCount == 16 )
                pbmi->bmiHeader.biSizeImage = ulWidth * ulHeight * 2;
            else if ( pbmi->bmiHeader.biBitCount == 32 )
                pbmi->bmiHeader.biSizeImage = ulWidth * ulHeight * 4;
            else
                pbmi->bmiHeader.biSizeImage = 0;
        }
        pbmi->bmiHeader.biClrUsed = 0;
        pbmi->bmiHeader.biClrImportant = 0;


        if (pbmih != NULL) {
            DWORD cbSize = min(pbmih->biSize, pbmi->bmiHeader.biSize);
            CopyMemory(pbmih, &pbmi->bmiHeader, cbSize);
            pbmih->biSize = cbSize;
        }
        

        //
        // Create the DIB section.  Let Win32 allocate the memory and return
        // a pointer to the bitmap surface.
        //

        hbmRet = CreateDIBSection(hdc, pbmi, DIB_RGB_COLORS, ppvBits, NULL, 0);

        if ( !hbmRet )
        {
            Trace("CreateCompatibleDIB: CreateDIBSection failed\n");
        }
    }
    else
    {
        Trace("CreateCompatibleDIB: bFillBitmapInfo failed\n");
    }

    return hbmRet;
}

/******************************Public*Routine******************************\
* UpdateDIBColorTable
*
* Synchronize the DIB color table to the specified palette hpal.
* If hpal is NULL, then use the system palette.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  23-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY
UpdateDIBColorTable(HDC hdcMem, HDC hdc, HPALETTE hpal)
{
    BOOL bRet = FALSE;
    HBITMAP hbm;
    DIBSECTION ds;
    BYTE aj[(sizeof(RGBQUAD) + sizeof(PALETTEENTRY)) * 256];
    LPPALETTEENTRY lppe = (LPPALETTEENTRY) aj;
    LPRGBQUAD prgb = (LPRGBQUAD) (lppe + 256);
    ULONG cColors;

    //
    // Validate hdc.
    //

    if ( GetObjectType(hdc) != OBJ_DC )
    {
        Trace("UpdateDIBColorTable: not OBJ_DC\n");
        return bRet;
    }
    if ( GetObjectType(hdcMem) != OBJ_MEMDC )
    {
        Trace("UpdateDIBColorTable: not OBJ_MEMDC\n");
        return bRet;
    }

    //
    // Get the bitmap handle out of the memdc.
    //

    hbm = (HBITMAP) GetCurrentObject(hdcMem, OBJ_BITMAP);

    //
    // Validate bitmap (must be DIB section).
    //

    if ( (GetObject(hbm, sizeof(ds), &ds) == sizeof(ds)) &&
         ds.dsBm.bmBits )
    {
        //
        // Get palette entries from specified palette or system palette.
        //

        cColors = 1 << ds.dsBmih.biBitCount;

        if ( hpal ? GetPaletteEntries(hpal, 0, cColors, lppe)
                  : MyGetSystemPaletteEntries(hdc, 0, cColors, lppe)
           )
        {
            UINT i;

            //
            // Convert to RGBQUAD.
            //

            for (i = 0; i < cColors; i++)
            {
                prgb[i].rgbRed      = lppe[i].peRed;
                prgb[i].rgbGreen    = lppe[i].peGreen;
                prgb[i].rgbBlue     = lppe[i].peBlue;
                prgb[i].rgbReserved = 0;
            }

            //
            // Set the DIB color table.
            //

            bRet = (BOOL) SetDIBColorTable(hdcMem, 0, cColors, prgb);

            if (!bRet)
            {
                Trace("UpdateDIBColorTable: SetDIBColorTable failed\n");
            }
        }
        else
        {
            Trace("UpdateDIBColorTable: MyGetSystemPaletteEntries failed\n");
        }
    }
    else
    {
        Trace("UpdateDIBColorTable: GetObject failed\n");
    }

    return bRet;
}

/******************************Public*Routine******************************\
* GetCompatibleDIBInfo
*
* Copies pointer to bitmap origin to ppvBase and bitmap stride to plStride.
* Win32 DIBs can be created bottom-up (the default) with the origin at the
* lower left corner or top-down with the origin at the upper left corner.
* If the bitmap is top-down, *plStride is positive; if bottom-up, *plStride
* us negative.
*
* Also, because of restrictions on the alignment of scan lines the width
* the bitmap is often not the same as the stride (stride is the number of
* bytes between vertically adjacent pixels).
*
* The ppvBase and plStride value returned will allow you to address any
* given pixel (x, y) in the bitmap as follows:
*
* PIXEL *ppix;
*
* ppix = (PIXEL *) (((BYTE *)*ppvBase) + (y * *plStride) + (x * sizeof(PIXEL)));
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  02-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY
GetCompatibleDIBInfo(HBITMAP hbm, PVOID *ppvBase, LONG *plStride)
{
    BOOL bRet = FALSE;
    DIBSECTION ds;

    //
    // Call GetObject to return a DIBSECTION.  If successful, the
    // bitmap is a DIB section and we can retrieve the pointer to
    // the bitmap bits and other parameters.
    //

    if ( (GetObject(hbm, sizeof(ds), &ds) == sizeof(ds))
         && ds.dsBm.bmBits )
    {
        //!!!dbug -- GDI Bug 19374: bmWidthBytes returns pitch assuming
        //!!!        that DIB scanlines are WORD aligned (as they
        //!!!        are in Win95).  But NT DIBs are DWORD aligned.
        //!!!        When bug if corrected, we can remove this block of
        //!!!        code.
        {
            OSVERSIONINFO osvi;

            osvi.dwOSVersionInfoSize = sizeof(osvi);
            if (GetVersionEx(&osvi))
            {
                if ( osvi.dwPlatformId == VER_PLATFORM_WIN32_NT )
                {
                    ds.dsBm.bmWidthBytes = (ds.dsBm.bmWidthBytes + 3) & ~3;
                }
            }
            else
            {
                Trace("GetCompatibleDIBInfo: GetVersionEx failed with %d\n", GetLastError());
                return bRet;
            }
        }

        //
        // If biHeight is positive, then the bitmap is a bottom-up DIB.
        // If biHeight is negative, then the bitmap is a top-down DIB.
        //

        if ( ds.dsBmih.biHeight > 0 )
        {
            *ppvBase  = (PVOID) (((BYTE *) ds.dsBm.bmBits) + (ds.dsBm.bmWidthBytes * (ds.dsBm.bmHeight - 1)));
            *plStride = (ULONG) (-ds.dsBm.bmWidthBytes);
        }
        else
        {
            *ppvBase  = ds.dsBm.bmBits;
            *plStride = ds.dsBm.bmWidthBytes;
        }

        bRet = TRUE;
    }
    else
    {
        Trace("GetCompatibleDIBInfo: cannot get pointer to DIBSECTION bmBits\n");
    }

    return bRet;
}

/******************************Public*Routine******************************\
* GetDIBTranslationVector
*
* Copies the translation vector that maps colors in the specified palette,
* hpal, to the DIB selected into the specified DC, hdcMem.
*
* Effects:
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  02-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY
GetDIBTranslationVector(HDC hdcMem, HPALETTE hpal, BYTE *pbVector)
{
    BOOL bRet = FALSE;
    HBITMAP hbm;
    DIBSECTION ds;

    //
    // Validate parameters.
    //

    if ( GetObjectType(hdcMem) != OBJ_MEMDC ||
         GetObjectType(hpal) != OBJ_PAL ||
         !pbVector )
    {
        Trace("GetDIBTranslationVector: bad parameter\n");
        return bRet;
    }

    //
    // The function bComputeLogicalToSurfaceMap cannot handle palettes
    // greater than 256 entries.
    //

    if ( GetPaletteEntries(hpal, 0, 1, NULL) > 256 )
    {
        Trace("GetDIBTranslationVector: palette too big\n");
        return bRet;
    }

    //
    // The DIB must have a color table.
    //

    hbm = (HBITMAP) GetCurrentObject(hdcMem, OBJ_BITMAP);
    if ( (GetObject(hbm, sizeof(ds), &ds) == sizeof(ds))
         && (ds.dsBmih.biBitCount <= 8) )
    {
        bRet = bComputeLogicalToSurfaceMap(hdcMem, hpal, pbVector);
    }
    else
    {
        Trace("GetDIBTranslationVector: not a DIB section\n");
        return bRet;
    }

    return bRet;
}

//////////////////// Below here are internal-only routines ////////////////////

/******************************Public*Routine******************************\
* bFillBitmapInfo
*
* Fills in the fields of a BITMAPINFO so that we can create a bitmap
* that matches the format of the display.
*
* This is done by creating a compatible bitmap and calling GetDIBits
* to return the color masks.  This is done with two calls.  The first
* call passes in biBitCount = 0 to GetDIBits which will fill in the
* base BITMAPINFOHEADER data.  The second call to GetDIBits (passing
* in the BITMAPINFO filled in by the first call) will return the color
* table or bitmasks, as appropriate.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  07-Jun-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static BOOL
bFillBitmapInfo(HDC hdc, HPALETTE hpal, BITMAPINFO *pbmi)
{
    HBITMAP hbm;
    BOOL    bRet = FALSE;

    //
    // Create a dummy bitmap from which we can query color format info
    // about the device surface.
    //

    if ( (hbm = CreateCompatibleBitmap(hdc, 1, 1)) != NULL )
    {
        pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);

        //
        // Call first time to fill in BITMAPINFO header.
        //

        GetDIBits(hdc, hbm, 0, 0, NULL, pbmi, DIB_RGB_COLORS);

        if ( pbmi->bmiHeader.biBitCount <= 8 )
        {
            bRet = bFillColorTable(hdc, hpal, pbmi);
        }
        else
        {
            if ( pbmi->bmiHeader.biCompression == BI_BITFIELDS )
            {
                //
                // Call a second time to get the color masks.
                // It's a GetDIBits Win32 "feature".
                //

                GetDIBits(hdc, hbm, 0, pbmi->bmiHeader.biHeight, NULL, pbmi,
                          DIB_RGB_COLORS);
            }

            bRet = TRUE;
        }

        DeleteObject(hbm);
    }
    else
    {
        Trace("bFillBitmapInfo: CreateCompatibleBitmap failed\n");
    }

    return bRet;
}

/******************************Public*Routine******************************\
* bFillColorTable
*
* Initialize the color table of the BITMAPINFO pointed to by pbmi.  Colors
* are set to the current system palette.
*
* Note: call only valid for displays of 8bpp or less.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  23-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static BOOL
bFillColorTable(HDC hdc, HPALETTE hpal, BITMAPINFO *pbmi)
{
    BOOL bRet = FALSE;
    BYTE aj[sizeof(PALETTEENTRY) * 256];
    LPPALETTEENTRY lppe = (LPPALETTEENTRY) aj;
    RGBQUAD *prgb = (RGBQUAD *) &pbmi->bmiColors[0];
    ULONG cColors;

    cColors = 1 << pbmi->bmiHeader.biBitCount;
    if ( cColors <= 256 )
    {
        if ( hpal ? GetPaletteEntries(hpal, 0, cColors, lppe)
                  : MyGetSystemPaletteEntries(hdc, 0, cColors, lppe) )
        {
            UINT i;

            for (i = 0; i < cColors; i++)
            {
                prgb[i].rgbRed      = lppe[i].peRed;
                prgb[i].rgbGreen    = lppe[i].peGreen;
                prgb[i].rgbBlue     = lppe[i].peBlue;
                prgb[i].rgbReserved = 0;
            }

            bRet = TRUE;
        }
        else
        {
            Trace("bFillColorTable: MyGetSystemPaletteEntries failed\n");
        }
    }

    return bRet;
}

/******************************Public*Routine******************************\
* MyGetSystemPaletteEntries
*
* Internal version of GetSystemPaletteEntries.
*
* GetSystemPaletteEntries fails on some 4bpp devices.  This version
* will detect the 4bpp case and supply the hardcoded 16-color VGA palette.
* Otherwise, it will pass the call on to GDI's GetSystemPaletteEntries.
*
* It is expected that this call will only be called in the 4bpp and 8bpp
* cases as it is not necessary for OpenGL to query the system palette
* for > 8bpp devices.
*
* History:
*  17-Aug-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static PALETTEENTRY gapeVgaPalette[16] =
{
    { 0,   0,   0,    0 },
    { 0x80,0,   0,    0 },
    { 0,   0x80,0,    0 },
    { 0x80,0x80,0,    0 },
    { 0,   0,   0x80, 0 },
    { 0x80,0,   0x80, 0 },
    { 0,   0x80,0x80, 0 },
    { 0x80,0x80,0x80, 0 },
    { 0xC0,0xC0,0xC0, 0 },
    { 0xFF,0,   0,    0 },
    { 0,   0xFF,0,    0 },
    { 0xFF,0xFF,0,    0 },
    { 0,   0,   0xFF, 0 },
    { 0xFF,0,   0xFF, 0 },
    { 0,   0xFF,0xFF, 0 },
    { 0xFF,0xFF,0xFF, 0 }
};

static UINT
MyGetSystemPaletteEntries(HDC hdc, UINT iStartIndex, UINT nEntries,
                          LPPALETTEENTRY lppe)
{
    int nDeviceBits;

    nDeviceBits = GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES);

    //
    // Some 4bpp displays will fail the GetSystemPaletteEntries call.
    // So if detected, return the hardcoded table.
    //

    if ( nDeviceBits == 4 )
    {
        if ( lppe )
        {
            nEntries = min(nEntries, (16 - iStartIndex));

            memcpy(lppe, &gapeVgaPalette[iStartIndex],
                   nEntries * sizeof(PALETTEENTRY));
        }
        else
            nEntries = 16;

        return nEntries;
    }
    else
    {
        return GetSystemPaletteEntries(hdc, iStartIndex, nEntries, lppe);
    }
}

/******************************Public*Routine******************************\
* bComputeLogicalToSurfaceMap
*
* Copy logical palette to surface palette translation vector to the buffer
* pointed to by pajVector.  The logical palette is specified by hpal.  The
* surface is specified by hdc.
*
* Note: The hdc may identify either a direct (display) dc or a DIB memory dc.
* If hdc is a display dc, then the surface palette is the system palette.
* If hdc is a memory dc, then the surface palette is the DIB color table.
*
* History:
*  27-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static BOOL bComputeLogicalToSurfaceMap(HDC hdc, HPALETTE hpal, BYTE *pajVector)
{
    BOOL bRet = FALSE;
    HPALETTE hpalSurf;
    ULONG cEntries, cSysEntries;
    DWORD dwDcType = GetObjectType(hdc);
    LPPALETTEENTRY lppeTmp, lppeEnd;

    BYTE aj[sizeof(LOGPALETTE) + (sizeof(PALETTEENTRY) * 512) + (sizeof(RGBQUAD) * 256)];
    LOGPALETTE *ppal = (LOGPALETTE *) aj;
    LPPALETTEENTRY lppeSurf = &ppal->palPalEntry[0];
    LPPALETTEENTRY lppe = lppeSurf + 256;
    RGBQUAD *prgb = (RGBQUAD *) (lppe + 256);

    //
    // Determine number of colors in each palette.
    //

    cEntries = GetPaletteEntries(hpal, 0, 1, NULL);
    if ( dwDcType == OBJ_DC )
        cSysEntries = MyGetSystemPaletteEntries(hdc, 0, 1, NULL);
    else
        cSysEntries = 256;

    //
    // Get the logical palette entries.
    //

    cEntries = GetPaletteEntries(hpal, 0, cEntries, lppe);

    //
    // Get the surface palette entries.
    //

    if ( dwDcType == OBJ_DC )
    {
        cSysEntries = MyGetSystemPaletteEntries(hdc, 0, cSysEntries, lppeSurf);

        lppeTmp = lppeSurf;
        lppeEnd = lppeSurf + cSysEntries;

        for (; lppeTmp < lppeEnd; lppeTmp++)
            lppeTmp->peFlags = 0;
    }
    else
    {
        RGBQUAD *prgbTmp;

        //
        // First get RGBQUADs from DIB color table...
        //

        cSysEntries = GetDIBColorTable(hdc, 0, cSysEntries, prgb);

        //
        // ...then convert RGBQUADs into PALETTEENTRIES.
        //

        prgbTmp = prgb;
        lppeTmp = lppeSurf;
        lppeEnd = lppeSurf + cSysEntries;

        while ( lppeTmp < lppeEnd )
        {
            lppeTmp->peRed   = prgbTmp->rgbRed;
            lppeTmp->peGreen = prgbTmp->rgbGreen;
            lppeTmp->peBlue  = prgbTmp->rgbBlue;
            lppeTmp->peFlags = 0;

            lppeTmp++;
            prgbTmp++;

        }
    }

    //
    // Construct a translation vector by using GetNearestPaletteIndex to
    // map each entry in the logical palette to the surface palette.
    //

    if ( cEntries && cSysEntries )
    {
        //
        // Create a temporary logical palette that matches the surface
        // palette retrieved above.
        //

        ppal->palVersion = 0x300;
        ppal->palNumEntries = (USHORT) cSysEntries;

        if ((hpalSurf = CreatePalette(ppal)) != NULL)
        {
            //
            // Translate each logical palette entry into a surface palette
            // index.
            //

            lppeTmp = lppe;
            lppeEnd = lppe + cEntries;

            for ( ; lppeTmp < lppeEnd; lppeTmp++, pajVector++)
            {
                *pajVector = (BYTE) GetNearestPaletteIndex(
                                        hpalSurf,
                                        RGB(lppeTmp->peRed,
                                            lppeTmp->peGreen,
                                            lppeTmp->peBlue)
                                        );
            }

            bRet = TRUE;

            DeleteObject(hpalSurf);
        }
        else
        {
            Trace("bComputeLogicalToSurfaceMap: CreatePalette failed\n");
        }
    }
    else
    {
        Trace("bComputeLogicalToSurfaceMap: failed to get pal info\n");
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\services\globals.h ===
#if !defined(SERVICES__Globals_h__INCLUDED)
#define SERVICES__Globals_h__INCLUDED
#pragma once

extern  HINSTANCE   g_hDll;
#if USE_DYNAMICTLS
extern  DWORD       g_tlsThread;    // TLS Slot for Thread data
#endif

#if ENABLE_MPH
extern  MESSAGEPUMPHOOK
                    g_mphReal;
#endif

class GdiCache;
class BufferManager;
class ComManager;
class TicketManager;

inline  GdiCache *      GetGdiCache();
inline  BufferManager * GetBufferManager();
inline  ComManager *    GetComManager();
        DuTicketManager * GetTicketManager();

#include "Globals.inl"

#endif // SERVICES__Globals_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\services\globals.cpp ===
#include "stdafx.h"
#include "Services.h"
#include "Globals.h"

#include "GdiCache.h"
#include "Thread.h"
#include "Context.h"
#include "TicketManager.h"

//
// The order that the global variables are declared here is VERY important 
// because it determines their destruction order during shutdown.
// Variables declared first will be destroyed AFTER all of the variables 
// declared after them.
//
// Thread objects are very low-level and should be at the top of this list.  
// This helps to ensure that new Thread objects are not accidentally created
// during shutdown.
//


HINSTANCE   g_hDll      = NULL;
#if USE_DYNAMICTLS
DWORD       g_tlsThread = (DWORD) -1;   // TLS Slot for Thread data
#endif


#if ENABLE_MPH

//
// Setup the MPH to point to the original USER functions.  If a MPH is
// installed, these will be replaced to point to the real implementations.
//

MESSAGEPUMPHOOK 
            g_mphReal = 
{
    sizeof(g_mphReal),
    NULL,
    NULL,
    NULL,
    NULL,
};

#endif // ENABLE_MPH


DuTicketManager g_TicketManager;


//------------------------------------------------------------------------------
DuTicketManager *
GetTicketManager()
{
    return &g_TicketManager;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\services\gdicache.inl ===
/***************************************************************************\
*
* File: GdiCache.inl
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(SERVICES__GdiCache_inl__INCLUDED)
#define SERVICES__GdiCache_inl__INCLUDED
#pragma once

#include "OSAL.h"

/***************************************************************************\
*****************************************************************************
*
* class ObjectCache
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline 
ObjectCache::ObjectCache()
{
#if ENABLE_DUMPCACHESTATS
    m_szName[0] = '\0';
#endif // ENABLE_DUMPCACHESTATS

    m_cMaxFree = IsRemoteSession() ? 2 : 4;
}


//------------------------------------------------------------------------------
inline
ObjectCache::~ObjectCache()
{
    AssertMsg(m_arAll.IsEmpty(), "Must have already free'd Context memory");
    AssertMsg(m_arFree.IsEmpty(), "Must have already free'd Context memory");
}


#if ENABLE_DUMPCACHESTATS

//------------------------------------------------------------------------------
inline void
ObjectCache::SetName(LPCSTR pszName)
{
    strcpy(m_szName, pszName);
}

#endif // ENABLE_DUMPCACHESTATS


/***************************************************************************\
*****************************************************************************
*
* GdiObjectCacheT<>
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
template <class T>
inline T
GdiObjectCacheT<T>::Get()
{
    return static_cast<T> (Pop());
}


//------------------------------------------------------------------------------
template <class T>
inline void        
GdiObjectCacheT<T>::Release(T hObj)
{
    Push(hObj);
}


//------------------------------------------------------------------------------
template <class T>
void
GdiObjectCacheT<T>::DestroyObject(void * pObj)
{
#if DBG
    SetLastError(0);
    BOOL fSuccess = ::DeleteObject((HGDIOBJ) pObj);
    if (!fSuccess) {
        DWORD dwErr = GetLastError();
        Trace("LastError: %d (0x%p)\n", dwErr, dwErr);
    }
    AssertMsg(fSuccess, "Ensure successfully deleted");
#else // DBG
    ::DeleteObject((HGDIOBJ) pObj);
#endif // DBG
}


/***************************************************************************\
*****************************************************************************
*
* class GdiCache
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline 
GdiCache::GdiCache()
{
#if ENABLE_DUMPCACHESTATS
    m_gocTempRgn.SetName("TempRgn");
    m_gocDisplayDC.SetName("DisplayDC");
    m_gocCompatDC.SetName("CompatDC");
#endif // ENABLE_DUMPCACHESTATS
}


//------------------------------------------------------------------------------
inline 
GdiCache::~GdiCache()
{

}


//------------------------------------------------------------------------------
inline void        
GdiCache::Destroy()
{
    m_gocTempRgn.Destroy();
    m_gocDisplayDC.Destroy();
    m_gocCompatDC.Destroy();
}


//------------------------------------------------------------------------------
inline HRGN        
GdiCache::GetTempRgn()
{
    return m_gocTempRgn.Get();
}


//------------------------------------------------------------------------------
inline void        
GdiCache::ReleaseTempRgn(HRGN hrgn)
{
    m_gocTempRgn.Release(hrgn);
}


//------------------------------------------------------------------------------
inline HDC         
GdiCache::GetTempDC()
{
    return m_gocDisplayDC.Get();
}


//------------------------------------------------------------------------------
inline void        
GdiCache::ReleaseTempDC(HDC hdc)
{
    m_gocDisplayDC.Release(hdc);
}


//------------------------------------------------------------------------------
inline HDC         
GdiCache::GetCompatibleDC()
{
    return m_gocCompatDC.Get();
}


//------------------------------------------------------------------------------
inline void        
GdiCache::ReleaseCompatibleDC(HDC hdc)
{
    m_gocCompatDC.Release(hdc);
}


#endif // SERVICES__GdiCache_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\services\hook.h ===
#if !defined(SERVICES__Hook_h__INCLUDED)
#define SERVICES__Hook_h__INCLUDED
#pragma once

#if ENABLE_MPH

BOOL        InitMPH();
BOOL        UninitMPH();

BOOL        CALLBACK DUserInitHook(DWORD dwCmd, void* pvParam);

#endif // ENABLE_MPH

#endif // SERVICES__Hook_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\services\osal.h ===
/***************************************************************************\
*
* File: OSAL.h
*
* Description:
* OSAL.h defines the process-wide Operating System Abstraction Layer that
* allows DirectUser to run on different platforms.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(SERVICES__OSAL_h__INCLUDED)
#define SERVICES__OSAL_h__INCLUDED
#pragma once

/***************************************************************************\
*
* class OS
*
* OS abstracts out differences between various OS's including:
* - Unicode / ANSI
* - Platform implementation differences
* - Version specific bugs
*
\***************************************************************************/

class OSAL
{
// Construction
public:
    virtual ~OSAL() { };

    static  HRESULT     Init();

// USER Operations
public:
    virtual int         DrawText(HDC hDC, LPCWSTR lpString, int nCount, LPRECT lpRect, UINT uFormat) PURE;

// GDI Operations
public:
    virtual BOOL        TextOut(HDC, int, int, LPCWSTR, int) PURE;
    virtual BOOL        ExtTextOut(HDC, int, int, UINT, const RECT *, LPCWSTR, int, const int *) PURE;
    virtual HFONT       CreateFontIndirect(CONST LOGFONTW *) PURE;
    virtual BOOL        GetTextExtentPoint32(HDC, LPCWSTR, int, LPSIZE) PURE;
    virtual BOOL        GetTextExtentExPoint(HDC, LPCWSTR, int, int, LPINT, LPINT, LPSIZE) PURE;

// DirectUser/Core
public:
    virtual void        PushXForm(HDC hdc, XFORM * pxfOld) PURE;
    virtual void        PopXForm(HDC hdc, const XFORM * pxfOld) PURE;
    virtual void        RotateDC(HDC hdc, float flRotationRad) PURE;
    virtual void        ScaleDC(HDC hdc, float flScaleX, float flScaleY) PURE;
    virtual void        TranslateDC(HDC hdc, float flOffsetX, float flOffsetY) PURE;
    virtual void        SetWorldTransform(HDC hdc, const XFORM * pxf) PURE;
    virtual void        SetIdentityTransform(HDC hdc) PURE;

// DirectUser/Services
public:
    virtual BOOL        IsInsideLoaderLock() PURE;

// Implementation
protected:
    static inline 
            BOOL        IsWin98orWin2000(OSVERSIONINFO * povi);
    static inline 
            BOOL        IsWhistler(OSVERSIONINFO * povi);
};

inline  BOOL    SupportUnicode();
inline  BOOL    SupportXForm();
inline  BOOL    SupportQInputAvailable();
inline  BOOL    IsRemoteSession();

        LONG    WINAPI StdExceptionFilter(PEXCEPTION_POINTERS pei);

#include "OSAL.inl"

#endif // SERVICES__OSAL_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\services\globals.inl ===
#if !defined(SERVICES__Globals_inl__INCLUDED)
#define SERVICES__Globals_inl__INCLUDED
#pragma once

#include "Thread.h"

//------------------------------------------------------------------------------
inline GdiCache * 
GetGdiCache()
{
    return GetThread()->GetGdiCache();
}


//------------------------------------------------------------------------------
inline BufferManager * 
GetBufferManager()
{
    return GetThread()->GetBufferManager();
}


//------------------------------------------------------------------------------
inline ComManager * 
GetComManager()
{
    return GetThread()->GetComManager();
}


#endif // SERVICES__Globals_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\services\hook.cpp ===
#include "stdafx.h"
#include "Services.h"
#include "Hook.h"

#if ENABLE_MPH

typedef BOOL (WINAPI * RegisterMPHProc)(INITMESSAGEPUMPHOOK pfnInitMPH);
typedef BOOL (WINAPI * UnregisterMPHProc)();

//------------------------------------------------------------------------------
// Forward declarations of implementation functions declared in other modules.
//
BOOL CALLBACK MphProcessMessage(MSG * pmsg, HWND hwnd, 
        UINT wMsgFilterMin, UINT wMsgFilterMax, UINT flags, BOOL fGetMessage);
BOOL CALLBACK MphWaitMessageEx(UINT fsWakeMask, DWORD dwTimeOut);


//------------------------------------------------------------------------------
BOOL InitMPH()
{
    BOOL fSuccess = FALSE;

    HINSTANCE hinst = LoadLibrary("user32.dll");
    if (hinst != NULL) {
        RegisterMPHProc pfnInit = (RegisterMPHProc) GetProcAddress(hinst, "RegisterMessagePumpHook");
        if (pfnInit != NULL) {
            fSuccess = (pfnInit)(DUserInitHook);
        }
    }

    return fSuccess;
}


//------------------------------------------------------------------------------
BOOL UninitMPH()
{
    BOOL fSuccess = FALSE;

    HINSTANCE hinst = LoadLibrary("user32.dll");
    if (hinst != NULL) {
        UnregisterMPHProc pfnUninit = (UnregisterMPHProc) GetProcAddress(hinst, "UnregisterMessagePumpHook");
        AssertMsg(pfnUninit != NULL, "Must have Uninit function");
        if (pfnUninit != NULL) {
            fSuccess = (pfnUninit)();
        }
    }

    return fSuccess;
}


//------------------------------------------------------------------------------
BOOL CALLBACK DUserInitHook(DWORD dwCmd, void* pvParam)
{
    BOOL fSuccess = FALSE;

    switch (dwCmd)
    {
    case UIAH_INITIALIZE:
        {
            //
            // Setting up the hooks:
            // - Copy the "real" functions over so that DUser can call them later
            // - Replace the functions that DUser needs to override
            //

            MESSAGEPUMPHOOK * pmphReal = reinterpret_cast<MESSAGEPUMPHOOK *>(pvParam);
            if ((pmphReal == NULL) || (pmphReal->cbSize < sizeof(MESSAGEPUMPHOOK))) {
                break;
            }

            CopyMemory(&g_mphReal, pmphReal, pmphReal->cbSize);

            pmphReal->cbSize            = sizeof(MESSAGEPUMPHOOK);
            pmphReal->pfnInternalGetMessage
                                        = MphProcessMessage;
            pmphReal->pfnWaitMessageEx  = MphWaitMessageEx;

            fSuccess = TRUE;
        }
        break;

    case UIAH_UNINITIALIZE:
        //
        // When uninitializing, NULL our function pointers.
        //

        ZeroMemory(&g_mphReal, sizeof(g_mphReal));
        fSuccess = TRUE;

        break;

    default:
        Trace("DUSER: Unknown dwCmd: %d\n", dwCmd);
    }

    return fSuccess;
}

#endif // ENABLE_MPH
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\services\osal.cpp ===
/***************************************************************************\
*
* File: OSAL.cpp
*
* Description:
* OSAL.cpp implements the process-wide Operating System Abstraction Layer 
* that allows DirectUser to run on different platforms.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Services.h"
#include "OSAL.h"

#define ENABLE_WINNT        1

/***************************************************************************\
*****************************************************************************
*
* Define OSAL's for different operating systems.
*
*****************************************************************************
\***************************************************************************/

#if ENABLE_WINNT

//------------------------------------------------------------------------------
class WinNT : public OSAL
{
// USER Operations
public:
    virtual int         DrawText(HDC hDC, LPCWSTR lpString, int nCount, LPRECT lpRect, UINT uFormat);

// GDI Operations
public:
    virtual BOOL        TextOut(HDC, int, int, LPCWSTR, int);
    virtual BOOL        ExtTextOut(HDC, int, int, UINT, const RECT *, LPCWSTR, int, const int *);
    virtual HFONT       CreateFontIndirect(CONST LOGFONTW *);
    virtual BOOL        GetTextExtentPoint32(HDC, LPCWSTR, int, LPSIZE);
    virtual BOOL        GetTextExtentExPoint(HDC, LPCWSTR, int, int, LPINT, LPINT, LPSIZE);

// DirectUser/Core
public:
    virtual void        PushXForm(HDC hdc, XFORM * pxfOld);
    virtual void        PopXForm(HDC hdc, const XFORM * pxfOld);
    virtual void        RotateDC(HDC hdc, float flRotationRad);
    virtual void        ScaleDC(HDC hdc, float flScaleX, float flScaleY);
    virtual void        TranslateDC(HDC hdc, float flOffsetX, float flOffsetY);
    virtual void        SetWorldTransform(HDC hdc, const XFORM * pxfOld);
    virtual void        SetIdentityTransform(HDC hdc);

// DirectUser/Services
public:
    virtual BOOL        IsInsideLoaderLock();
};

#endif


//------------------------------------------------------------------------------
class Win9x : public OSAL
{
// USER Operations
public:
    virtual int         DrawText(HDC hDC, LPCWSTR lpString, int nCount, LPRECT lpRect, UINT uFormat);

// GDI Operations
public:
    virtual BOOL        TextOut(HDC, int, int, LPCWSTR, int);
    virtual BOOL        ExtTextOut(HDC, int, int, UINT, const RECT *, LPCWSTR, int, const int *);
    virtual HFONT       CreateFontIndirect(CONST LOGFONTW *);
    virtual BOOL        GetTextExtentPoint32(HDC, LPCWSTR, int, LPSIZE);
    virtual BOOL        GetTextExtentExPoint(HDC, LPCWSTR, int, int, LPINT, LPINT, LPSIZE);

// DirectUser/Core
public:
    virtual void        PushXForm(HDC hdc, XFORM * pxfOld);
    virtual void        PopXForm(HDC hdc, const XFORM * pxfOld);
    virtual void        RotateDC(HDC hdc, float flRotationRad);
    virtual void        ScaleDC(HDC hdc, float flScaleX, float flScaleY);
    virtual void        TranslateDC(HDC hdc, float flOffsetX, float flOffsetY);
    virtual void        SetWorldTransform(HDC hdc, const XFORM * pxfOld);
    virtual void        SetIdentityTransform(HDC hdc);

// DirectUser/Services
public:
    virtual BOOL        IsInsideLoaderLock();
};


/***************************************************************************\
*****************************************************************************
*
* String Conversion Macros
*
* These macros are extensions of the normal ATLCONV that are designed to
* take the length of the string as a parameter instead of computing it.  
* This gives better performance, and gives parity on platforms when the 
* string has embedded '\0's.
*
*****************************************************************************
\***************************************************************************/

#ifdef _CONVERSION_USES_THREAD_LOCALE
	#define W2AN(lpw, cch) (\
		((_lpw = lpw) == NULL) ? NULL : (\
			_convert = (cch+1)*2,\
			ATLW2AHELPER((LPSTR) alloca(_convert), _lpw, _convert, _acp)))
#else
	#define W2AN(lpw, cch) (\
		((_lpw = lpw) == NULL) ? NULL : (\
			_convert = (cch+1)*2,\
			ATLW2AHELPER((LPSTR) alloca(_convert), _lpw, _convert)))
#endif


/***************************************************************************\
*****************************************************************************
*
* class OSAL
*
*****************************************************************************
\***************************************************************************/

OSAL *      g_pOS = NULL;
OSInfo      g_OSI;
PTOP_LEVEL_EXCEPTION_FILTER
            g_pfnRtlUnhandledExceptionFilter = NULL;

class OSALCleanup
{
public:
    ~OSALCleanup()
    {
        ProcessDelete(OSAL, g_pOS);
        g_pOS = NULL;
    };
} g_OSALCleanup;


//------------------------------------------------------------------------------
HRESULT
OSAL::Init()
{
    AssertMsg(g_pOS == NULL, "Only init one time");

    OSVERSIONINFO ovi;
    ZeroMemory(&ovi, sizeof(ovi));
    ovi.dwOSVersionInfoSize = sizeof(ovi);

    VerifyMsg(GetVersionEx(&ovi), "Must always be able to get the version");

    g_OSI.fQInputAvailableFlag = IsWin98orWin2000(&ovi);

#if ENABLE_WINNT
    if (ovi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) {
        //
        // Running on Win9x, so don't have UNICODE
        //

        g_OSI.fUnicode  = FALSE;
        g_OSI.fXForm    = FALSE;
        g_pOS           = ProcessNew(Win9x);
    } else if (ovi.dwPlatformId == VER_PLATFORM_WIN32_NT) {
        //
        // Running on NT, so have UNICODE
        //

        g_OSI.fUnicode  = TRUE;
        g_OSI.fXForm    = TRUE;
        g_pOS           = ProcessNew(WinNT);

        HINSTANCE hinst = LoadLibrary("ntdll.dll");
        if (hinst != NULL) {
            g_pfnRtlUnhandledExceptionFilter = (PTOP_LEVEL_EXCEPTION_FILTER)
                    GetProcAddress(hinst, "RtlUnhandledExceptionFilter");
        }
    } else {
        AssertMsg(0, "Unsupported OS");
        return E_NOTIMPL;
    }
#else  // ENABLE_WINNT
    g_OSI.fUnicode  = FALSE;
    g_OSI.fXForm    = FALSE;
    g_pOS           = ProcessNew(Win9x);
#endif  // ENABLE_WINNT

    return g_pOS != NULL ? S_OK : E_OUTOFMEMORY;
}


//------------------------------------------------------------------------------
LONG WINAPI
StdExceptionFilter(PEXCEPTION_POINTERS pei)
{
    AutoTrace("ERROR: Unhandled exception during callback.\n");
    AutoTrace("ERROR: This is not a problem with DirectUser.\n");

    //
    // Output Exception information
    //

    LONG nResult;

    if (g_pfnRtlUnhandledExceptionFilter != NULL) {
        nResult = (g_pfnRtlUnhandledExceptionFilter)(pei);
    } else {
        AutoTrace(" *** enter .exr %p for the exception record\n", pei->ExceptionRecord);
        AutoTrace(" *** enter .cxr %p for the context\n", pei->ContextRecord);

        nResult = EXCEPTION_CONTINUE_SEARCH;
    }

    if (nResult == EXCEPTION_CONTINUE_SEARCH) {
        return UnhandledExceptionFilter(pei);
    } else {
        return nResult;
    }
}


/***************************************************************************\
*****************************************************************************
*
* class WinNT
*
*****************************************************************************
\***************************************************************************/

#if ENABLE_WINNT

//------------------------------------------------------------------------------
int     
WinNT::DrawText(HDC hDC, LPCWSTR lpString, int nCount, LPRECT lpRect, UINT uFormat)
{
    return ::DrawTextW(hDC, lpString, nCount, lpRect, uFormat);
}


//------------------------------------------------------------------------------
BOOL    
WinNT::TextOut(HDC hdc, int x, int y, LPCWSTR psz, int cch)
{
    return ::TextOutW(hdc, x, y, psz, cch);
}


//------------------------------------------------------------------------------
BOOL        
WinNT::ExtTextOut(HDC hdc, int x, int y, UINT fuOptions, const RECT * prc, LPCWSTR psz, int cch, const int * pDx)
{
    return ::ExtTextOutW(hdc, x, y, fuOptions, prc, psz, cch, pDx);
}


//------------------------------------------------------------------------------
HFONT   
WinNT::CreateFontIndirect(CONST LOGFONTW * plf)
{
    return ::CreateFontIndirectW(plf);
}


//------------------------------------------------------------------------------
BOOL    
WinNT::GetTextExtentPoint32(HDC hdc, LPCWSTR psz, int cch, LPSIZE psize)
{
    return ::GetTextExtentPoint32W(hdc, psz, cch, psize);
}


//------------------------------------------------------------------------------
BOOL    
WinNT::GetTextExtentExPoint(HDC hdc, LPCWSTR psz, int cch, int nMax, 
        LPINT pnFit, LPINT apDx, LPSIZE psize)
{
    return ::GetTextExtentExPointW(hdc, psz, cch, nMax, pnFit, apDx, psize);
}


//------------------------------------------------------------------------------
void        
WinNT::PushXForm(HDC hdc, XFORM * pxfOld)
{
    ::GetWorldTransform(hdc, pxfOld);
}


//------------------------------------------------------------------------------
void        
WinNT::PopXForm(HDC hdc, const XFORM * pxfOld)
{
    ::SetWorldTransform(hdc, pxfOld);
}


//------------------------------------------------------------------------------
void        
WinNT::RotateDC(HDC hdc, float flRotationRad)
{
    AssertMsg(GetGraphicsMode(hdc) == GM_ADVANCED, "Only can do in advanced mode");

    float flCos     = (float) cos(flRotationRad);
    float flSin     = (float) sin(flRotationRad);

    XFORM xf;
    xf.eM11 = flCos;
    xf.eM12 = flSin;
    xf.eM21 = - flSin;
    xf.eM22 = flCos;
    xf.eDx  = 0;
    xf.eDy  = 0;

    ::ModifyWorldTransform(hdc, &xf, MWT_LEFTMULTIPLY);
}


//------------------------------------------------------------------------------
void        
WinNT::ScaleDC(HDC hdc, float flScaleX, float flScaleY)
{
    AssertMsg(GetGraphicsMode(hdc) == GM_ADVANCED, "Only can do in advanced mode");

    XFORM xf;
    xf.eM11 = flScaleX;
    xf.eM12 = 0;
    xf.eM21 = 0;
    xf.eM22 = flScaleY;
    xf.eDx  = 0;
    xf.eDy  = 0;

    ::ModifyWorldTransform(hdc, &xf, MWT_LEFTMULTIPLY);
}


//------------------------------------------------------------------------------
void        
WinNT::TranslateDC(HDC hdc, float flOffsetX, float flOffsetY)
{
    AssertMsg(GetGraphicsMode(hdc) == GM_ADVANCED, "Only can do in advanced mode");

    XFORM xf;
    xf.eM11 = 1.0;
    xf.eM12 = 0;
    xf.eM21 = 0;
    xf.eM22 = 1.0;
    xf.eDx  = flOffsetX;
    xf.eDy  = flOffsetY;

    ::ModifyWorldTransform(hdc, &xf, MWT_LEFTMULTIPLY);
}


//------------------------------------------------------------------------------
void        
WinNT::SetWorldTransform(HDC hdc, const XFORM * pxf)
{
    ::SetWorldTransform(hdc, pxf);
}


//------------------------------------------------------------------------------
void        
WinNT::SetIdentityTransform(HDC hdc)
{
    ModifyWorldTransform(hdc, NULL, MWT_IDENTITY);
}


//------------------------------------------------------------------------------
BOOL
WinNT::IsInsideLoaderLock()
{
    RTL_CRITICAL_SECTION * pCS = reinterpret_cast<RTL_CRITICAL_SECTION *>(NtCurrentPeb()->LoaderLock);
    AssertMsg(pCS != NULL, "Must have the Loader Lock");

    return HandleToUlong(pCS->OwningThread) == GetCurrentThreadId();
}


#endif  // ENABLE_WINNT


/***************************************************************************\
*****************************************************************************
*
* class Win9x
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
int     
Win9x::DrawText(HDC hDC, LPCWSTR lpString, int nCount, LPRECT lpRect, UINT uFormat)
{
    USES_CONVERSION;
    return ::DrawTextA(hDC, W2AN(lpString, nCount), nCount, lpRect, uFormat);
}


//------------------------------------------------------------------------------
BOOL    
Win9x::TextOut(HDC hdc, int x, int y, LPCWSTR psz, int cch)
{
    return ::TextOutW(hdc, x, y, psz, cch);
}


//------------------------------------------------------------------------------
BOOL        
Win9x::ExtTextOut(HDC hdc, int x, int y, UINT fuOptions, const RECT * prc, LPCWSTR psz, int cch, const int * pDx)
{
    return ::ExtTextOutW(hdc, x, y, fuOptions, prc, psz, cch, pDx);
}


//------------------------------------------------------------------------------
HFONT   
Win9x::CreateFontIndirect(CONST LOGFONTW * plf)
{
    USES_CONVERSION;

    LOGFONT lf;
    lf.lfHeight         = plf->lfHeight;
    lf.lfWidth          = plf->lfWidth;
    lf.lfEscapement     = plf->lfEscapement;
    lf.lfOrientation    = plf->lfOrientation;
    lf.lfWeight         = plf->lfWeight;
    lf.lfItalic         = plf->lfItalic;
    lf.lfUnderline      = plf->lfUnderline;
    lf.lfStrikeOut      = plf->lfStrikeOut;
    lf.lfCharSet        = plf->lfCharSet;
    lf.lfOutPrecision   = plf->lfOutPrecision;
    lf.lfClipPrecision  = plf->lfClipPrecision;
    lf.lfQuality        = plf->lfQuality;
    lf.lfPitchAndFamily = plf->lfPitchAndFamily;
    AtlW2AHelper(lf.lfFaceName, plf->lfFaceName, lstrlenW(plf->lfFaceName) + 1);

    return ::CreateFontIndirectA(&lf);
}


//------------------------------------------------------------------------------
BOOL    
Win9x::GetTextExtentPoint32(HDC hdc, LPCWSTR psz, int cch, LPSIZE psize)
{
    USES_CONVERSION;
    return ::GetTextExtentPoint32A(hdc, W2AN(psz, cch), cch, psize);
}


//------------------------------------------------------------------------------
BOOL    
Win9x::GetTextExtentExPoint(HDC hdc, LPCWSTR psz, int cch, int nMax, 
        LPINT pnFit, LPINT apDx, LPSIZE psize)
{
    USES_CONVERSION;
    return ::GetTextExtentExPointA(hdc, W2AN(psz, cch), cch, nMax, pnFit, apDx, psize);
}


//------------------------------------------------------------------------------
void        
Win9x::PushXForm(HDC hdc, XFORM * pxfOld)
{
    POINT pt;
    ::GetWindowOrgEx(hdc, &pt);
    pxfOld->eM11    = 1.0f;
    pxfOld->eM12    = 0.0f;
    pxfOld->eM21    = 0.0f;
    pxfOld->eM22    = 1.0f;
    pxfOld->eDx     = (float) pt.x;
    pxfOld->eDy     = (float) pt.y;
}


//------------------------------------------------------------------------------
void        
Win9x::PopXForm(HDC hdc, const XFORM * pxfOld)
{
    POINT pt;
    pt.x    = (long) pxfOld->eDx;
    pt.y    = (long) pxfOld->eDy;
    ::SetWindowOrgEx(hdc, pt.x, pt.y, NULL);
}


//------------------------------------------------------------------------------
void        
Win9x::RotateDC(HDC hdc, float flRotationRad)
{
    UNREFERENCED_PARAMETER(hdc);
    UNREFERENCED_PARAMETER(flRotationRad);
}


//------------------------------------------------------------------------------
void        
Win9x::ScaleDC(HDC hdc, float flScaleX, float flScaleY)
{
    UNREFERENCED_PARAMETER(hdc);
    UNREFERENCED_PARAMETER(flScaleX);
    UNREFERENCED_PARAMETER(flScaleY);
}


//------------------------------------------------------------------------------
void        
Win9x::TranslateDC(HDC hdc, float flOffsetX, float flOffsetY)
{
    ::OffsetWindowOrgEx(hdc, -(int) flOffsetX, -(int) flOffsetY, NULL);
}


//------------------------------------------------------------------------------
void        
Win9x::SetWorldTransform(HDC hdc, const XFORM * pxf)
{
    ::SetWindowOrgEx(hdc, -(int) pxf->eDx, -(int) pxf->eDy, NULL);
}


//------------------------------------------------------------------------------
void        
Win9x::SetIdentityTransform(HDC hdc)
{
    ::SetWindowOrgEx(hdc, 0, 0, NULL);
}


//------------------------------------------------------------------------------
BOOL
Win9x::IsInsideLoaderLock()
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\services\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	Services.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\services\public.h ===
/***************************************************************************\
*
* File: Public.h
*
* Description:
* Public.h contains a list of definitions that are exposed and available
* outside this project.  Any other DirectUser project that wishes to use
* these services directly instead of going through public API's can include
* a corresponding [Project]P.h available in the \inc directory.  
* 
* Definitions that are not exposed through this file are considered project 
* specific implementation details and should not used in other projects.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(SERVICES__Public_h__INCLUDED)
#define SERVICES__Public_h__INCLUDED

#include "ComManager.h"
#include "Context.h"
#include "DxManager.h"
#include "Buffer.h"
#include "GdiCache.h"
#include "Surface.h"
#include "OSAL.h"
#include "Thread.h"
#include "ResourceManager.h"
#include "TicketManager.h"
#include "Globals.h"
#include "Hook.h"

#endif // SERVICES__Public_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\services\resourcemanager.cpp ===
/***************************************************************************\
*
* File: ResourceManager.cpp
*
* Description:
* This file implements the ResourceManager used to setup and maintain all 
* Thread, Contexts, and other resources used by and with DirectUser.
*
*
* History:
*  4/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Services.h"
#include "ResourceManager.h"

#include "Thread.h"
#include "Context.h"
#include "OSAL.h"
#include "Hook.h"

#include <Delayimp.h>               // For error handling & advanced features

static const GUID guidCreateBuffer  = { 0xd2139559, 0x458b, 0x4ba8, { 0x82, 0x28, 0x34, 0xd7, 0x57, 0x3d, 0xa, 0x8 } };     // {D2139559-458B-4ba8-8228-34D7573D0A08}
static const GUID guidInitGdiplus   = { 0x49f9b12e, 0x846b, 0x4973, { 0xab, 0xfb, 0x7b, 0xe3, 0x4b, 0x52, 0x31, 0xfe } };   // {49F9B12E-846B-4973-ABFB-7BE34B5231FE}


/***************************************************************************\
*****************************************************************************
*
* class ResourceManager
*
*****************************************************************************
\***************************************************************************/

#if DBG
static  BOOL    g_fAlreadyShutdown  = FALSE;
#endif // DBG

long        ResourceManager::s_fInit            = FALSE;
HANDLE      ResourceManager::s_hthSRT           = NULL;
DWORD       ResourceManager::s_dwSRTID          = 0;
HANDLE      ResourceManager::s_hevReady         = NULL;
HGADGET     ResourceManager::s_hgadMsg          = NULL;
MSGID       ResourceManager::s_idCreateBuffer   = 0;
MSGID       ResourceManager::s_idInitGdiplus    = 0;
RMData *    ResourceManager::s_pData            = NULL;
CritLock    ResourceManager::s_lockContext;
CritLock    ResourceManager::s_lockComponent;
Thread *    ResourceManager::s_pthrSRT          = NULL;
GList<Thread> 
            ResourceManager::s_lstAppThreads;
int         ResourceManager::s_cAppThreads      = 0;
GList<ComponentFactory>
            ResourceManager::s_lstComponents;
BOOL        ResourceManager::s_fInitGdiPlus     = FALSE;
ULONG_PTR   ResourceManager::s_gplToken = 0;
Gdiplus::GdiplusStartupOutput 
            ResourceManager::s_gpgso;

#if DBG_CHECK_CALLBACKS
int         ResourceManager::s_cTotalAppThreads = 0;
BOOL        ResourceManager::s_fBadMphInit      = FALSE;
#endif


BEGIN_STRUCT(GMSG_CREATEBUFFER, EventMsg)
    IN  HDC         hdc;            // DC to be compatible with
    IN  SIZE        sizePxl;     // Size of bitmap
    OUT HBITMAP     hbmpNew;        // Allocated bitmap
END_STRUCT(GMSG_CREATEBUFFER)


/***************************************************************************\
*
* ResourceManager::Create
*
* Create() is called when DUser.DLL is loaded to initialize low-level
* services in DirectUser.  
* 
* NOTE: It is very important to keep this function small and to 
* delay-initialize to help keep starting costs low.
*
* NOTE: This function is automatically synchronized because it is called
* in PROCESS_ATTACH in DllMain().  Therefore, only one thread will ever be
* in this function at one time.
*
\***************************************************************************/

HRESULT
ResourceManager::Create()
{
    AssertMsg(!g_fAlreadyShutdown, "Ensure shutdown has not already occurred");

#if USE_DYNAMICTLS
    g_tlsThread = TlsAlloc();
    if (g_tlsThread == (DWORD) -1) {
        return E_OUTOFMEMORY;
    }
#endif

    if (InterlockedCompareExchange(&s_fInit, TRUE, FALSE) == TRUE) {
        return S_OK;
    }

    
    //
    // Initialize low-level resources (such as the heap).  This must be 
    // carefully done since many objects have not been constructed yet.
    //

    s_hthSRT    = NULL;
    s_fInit     = FALSE;
    s_hevReady  = NULL;

    HRESULT hr = OSAL::Init();
    if (FAILED(hr)) {
        return hr;
    }


    //
    // Create global services / managers
    //

    s_pData = ProcessNew(RMData);
    if (s_pData == NULL) {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}


/***************************************************************************\
*
* ResourceManager::xwDestroy
*
* xwDestroy() is called when DUser.DLL is unloaded to perform final clean-up
* in DirectUser.
*
* NOTE: This function is automatically synchronized because it is called
* in PROCESS_ATTACH in DllMain().  Therefore, only one thread will ever be
* in this function at one time.
* 
\***************************************************************************/

void
ResourceManager::xwDestroy()
{
    AssertMsg(!g_fAlreadyShutdown, "Ensure shutdown has not already occurred");

#if DBG
    g_fAlreadyShutdown = TRUE;
#endif // DBG

    //
    // Check if there are any remaining Contexts.  Unfortunately, we CAN NOT
    // perform any cleanup work since we are in User mode and are limited by
    // what we can do while inside the "Loader Lock" in DllMain().  We can not
    // clean up any objects because these may cause deadlocks, such as freeing
    // another library.  We also must be very cautious about waiting on 
    // anything, since we can easily get into a deadlock.
    //
    // This is a serious application error.  The application MUST call 
    // ::DeleteHandle() on the Context before the thread exits.
    //

    if (s_cAppThreads != 0) {
        OutputDebugString("ERROR: Not all DirectUser Contexts were destroyed before EndProcess().\n");
        PromptInvalid("Not all DirectUser Contexts were destroyed before EndProcess().");

        while (!s_lstAppThreads.IsEmpty()) {
            Thread * pthr = s_lstAppThreads.UnlinkHead();
            pthr->MarkOrphaned();
            pthr->GetContext()->MarkOrphaned();
        }
        s_cAppThreads = 0;
    } else {
        //
        // If there are no leaked application threads, there should no longer be
        // any SRT, since it should be cleaned up when the last application 
        // thread is cleaned up.
        //
        
        AssertMsg(s_pthrSRT == NULL, "Destruction should reset s_pthrSRT");
        AssertMsg(s_lstAppThreads.IsEmpty(), "Should not have any threads");
    }

    ForceSetContextHeap(NULL);
#if USE_DYNAMICTLS
    Verify(TlsSetValue(g_tlsThread, NULL));
#else
    t_pContext  = NULL;
    t_pThread   = NULL;
#endif


    //
    // Clean up remaining resources.
    // NOTE: This can NOT use the Context heaps (via new / delete) because they
    // have already been destroyed.
    //

    ProcessDelete(RMData, s_pData);
    s_pData = NULL;

    if (s_hevReady != NULL) {
        CloseHandle(s_hevReady);
        s_hevReady = NULL;
    }


    //
    // Because they are global variables, we need to manually unlink all of the
    // Component Factories so that they don't get deleted.
    //

    s_lstComponents.UnlinkAll();

#if USE_DYNAMICTLS
    Verify(TlsFree(g_tlsThread));
    g_tlsThread = (DWORD) -1;  // TLS slot no longer valid
#endif
}


/***************************************************************************\
*
* ResourceManager::ResetSharedThread
*
* ResetSharedThread() cleans up SRT data.
*
\***************************************************************************/

void
ResourceManager::ResetSharedThread()
{
    //
    // Access to the SRT is normally serialized through DirectUser's queues.
    // In the case where the data is directly being cleaned up, we need to
    // guarantee that only one thread is accessing this data.  This should
    // always be true since it will either be the SRT properly shutting down
    // or the main application's thread that is cleaning up dangling Contexts.
    //
    
    AssertMsg(s_cAppThreads == 0, "Must not have any outstanding application threads");
    
    s_dwSRTID = 0;

    if (s_hgadMsg != NULL) {
        ::DeleteHandle(s_hgadMsg);
        s_hgadMsg = NULL;
    }
    
    s_pthrSRT = NULL;

    //
    // NOTE: It is important not to call DeleteHandle() on the SRT's Context
    // here since this function may be called by the application thread which
    // is already cleaning up the Context.
    //
}


/***************************************************************************\
*
* ResourceManager::SharedThreadProc
*
* SharedThreadProc() provides a "Shared Resource Thread" that is processes
* requests from other DirectUser threads.  The SRT is created in the first
* call to InitContextNL().
*
* NOTE: The SRT is ONLY created when SEPARATE or MULTIPLE threading models
* are used.  The SRT is NOT created for SINGLE threading model.
*
\***************************************************************************/

unsigned __stdcall 
ResourceManager::SharedThreadProc(
    IN  void * pvArg)
{
    UNREFERENCED_PARAMETER(pvArg);

    AssertMsg(s_dwSRTID == 0, "SRT should not already be initialized");
    s_dwSRTID = GetCurrentThreadId();

    Context * pctx;
    INITGADGET ig;
    ZeroMemory(&ig, sizeof(ig));
    ig.cbSize       = sizeof(ig);
    ig.nThreadMode  = IGTM_SEPARATE;
    ig.nMsgMode     = IGMM_ADVANCED;
    HRESULT hr      = InitContextNL(&ig, TRUE /* SRT */, &pctx);
    if (FAILED(hr)) {
        return hr;
    }


    //
    // Setup a Gadget to receive custom requests to execute on this thread.
    // Each of these requests uses a registered message.
    //

    if (((s_idCreateBuffer = RegisterGadgetMessage(&guidCreateBuffer)) == 0) ||
        ((s_idInitGdiplus = RegisterGadgetMessage(&guidInitGdiplus)) == 0) ||
        ((s_hgadMsg = CreateGadget(NULL, GC_MESSAGE, SharedEventProc, NULL)) == 0)) {

        hr = GetLastError();
        goto Exit;
    }


    //
    // The SRT is fully initialized and can start processing messages.  Signal 
    // the calling thread and start the message loop.
    //
    // NOTE: See MSDN docs for PostThreadMessage() that explain why we need the
    // extra PeekMessage() in the beginning to force User to create a queue for
    // us.
    //
    
    MSG msg;
    PeekMessage(&msg, NULL, WM_USER, WM_USER, PM_NOREMOVE);

    Verify(SetEvent(s_hevReady));


    BOOL fQuit = FALSE;
    while ((!fQuit) && GetMessageEx(&msg, NULL, 0, 0)) {
        AssertMsg(IsMultiThreaded(), "Must remain multi-threaded if using SRT");

        if (msg.message == WM_QUIT) {
            fQuit = TRUE;
        }
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }


    //
    // Uninitialize GDI+
    //
    // If GDI+ has been initialized on any thread, we need to uninitialize it
    // when the SRT is going away.
    //

    if (IsInitGdiPlus()) {
        (s_gpgso.NotificationUnhook)(s_gplToken);
    }


    hr = S_OK;

Exit:    
    //
    // The SRT is going away:
    // - Clean up remaining SRT data
    // - Destroy the SRT's Context
    //

    ResetSharedThread();
    DeleteHandle(pctx->GetHandle());

    return hr;
}


/***************************************************************************\
*
* ResourceManager::SharedEventProc
*
* SharedEventProc() processes LPC requests sent to the SRT.
*
* NOTE: The SRT is ONLY created when SEPARATE or MULTIPLE threading models
* are used.  The SRT is NOT created for SINGLE threading model.
*
\***************************************************************************/

HRESULT
ResourceManager::SharedEventProc(
    IN  HGADGET hgadCur,
    IN  void * pvCur,
    IN  EventMsg * pMsg)
{
    UNREFERENCED_PARAMETER(hgadCur);
    UNREFERENCED_PARAMETER(pvCur);

    AssertMsg(IsMultiThreaded(), "Must remain multi-threaded if using SRT");

    if (pMsg->nMsg == s_idCreateBuffer) {
        //
        // Create a new bitmap
        //

        GMSG_CREATEBUFFER * pmsgCB = (GMSG_CREATEBUFFER *) pMsg;
        pmsgCB->hbmpNew = CreateCompatibleBitmap(pmsgCB->hdc, 
                pmsgCB->sizePxl.cx, pmsgCB->sizePxl.cy);

#if DBG
        if (pmsgCB->hbmpNew == NULL) {
            Trace("CreateCompatibleBitmap failed: LastError = %d\n", GetLastError());
        }
#endif // DBG
        return DU_S_COMPLETE;
    } else if (pMsg->nMsg == s_idInitGdiplus) {
        //
        // Initialize GDI+
        //

        (s_gpgso.NotificationHook)(&s_gplToken);

        return DU_S_COMPLETE;
    }

    return DU_S_NOTHANDLED;
}


/***************************************************************************\
*
* ResourceManager::InitContextNL
*
* InitContextNL() initializes a thread into either a new or existing 
* DirectUser Context.  The Context is valid in the Thread until it is 
* explicitely destroyed with ::DeleteHandle() or the thread exits.
*
* NOTE: It is VERY important that the first time this function is called is
* NOT in DllMain() because we need to initialize the SRT.  DllMain() 
* serializes access across all threads, so we will deadlock.  After the first
* Context is successfully created, additional Contexts can be created inside
* DllMain().
*
* <error>   DU_E_GENERIC</>
* <error>   E_OUTOFMEMORY</>
* <error>   E_NOTIMPL</>
* <error>   E_INVALIDARG</>
* <error>   DU_E_THREADINGALREADYSET</>
*
\***************************************************************************/

HRESULT
ResourceManager::InitContextNL(
    IN  INITGADGET * pInit,             // Context description
    IN  BOOL fSharedThread,             // Context is for the shared thread
    OUT Context ** ppctxNew)            // New context
{
    HRESULT hr  = DU_E_GENERIC;
    *ppctxNew   = NULL;

#if DBG_CHECK_CALLBACKS
    BOOL fInitMPH = FALSE;
#endif


    //
    // Can not initialize inside DllMain()
    //

    if (OS()->IsInsideLoaderLock()) {
        PromptInvalid("Can not initialize DirectUser inside DllMain()");
        return E_INVALIDARG;
    }


    //
    // If Context is already initialized, increment the number of times this
    // THREAD has been initialized.  We need to remember each thread 
    // individually.  Since we only lock individual threads, we don't need to
    // worry about synchronization yet.
    //

    if (IsInitContext()) {
        Thread * pthrExist = GetThread();
        AssertInstance(pthrExist);  // Initialized Context must already initialize Thread

        pthrExist->Lock();
        *ppctxNew = pthrExist->GetContext();
        return S_OK;
    }

    
    //
    // Before initializing the new Context, ensure that the Shared Resource 
    // Thread has been created.  We want to create the shared thread Context 
    // before creating this thread's Context so that as soon as we return, 
    // everything is valid.
    //
    // If we are initializing the Shared Resource Thread, don't take the lock.
    // This is because we are already inside the lock in InitContextNL() on 
    // another thread waiting for the SRT to initialize.
    //

    if (fSharedThread) {
        AssertMsg(s_pthrSRT == NULL, "Only should initialize a single SRT");
    } else {
        s_lockContext.Enter();
    }

#if DBG
    int DEBUG_cOldAppThreads = s_cAppThreads;
#endif

    if (pInit->nThreadMode != IGTM_NONE) {
        //
        // Setup the threading model.  By default, we start in multi-threading
        // model.  We can only change to single threaded if no threads are 
        // already initialized.
        //

        BOOL fAlreadyInit = (!s_lstAppThreads.IsEmpty()) && (s_pthrSRT == NULL);

        switch (pInit->nThreadMode)
        {
        case IGTM_SINGLE:
            if (fAlreadyInit) {
                hr = DU_E_THREADINGALREADYSET;
                goto RawErrorExit;
            } else {
                g_fThreadSafe = FALSE;
            }
            break;

        case IGTM_SEPARATE:
        case IGTM_MULTIPLE:
            if (!g_fThreadSafe) {
                hr = DU_E_THREADINGALREADYSET;
                goto RawErrorExit;
            }
            break;

        default:
            AssertMsg(0, "Unknown threading model");
            hr = E_INVALIDARG;
            goto RawErrorExit;
        }
    }


    if (IsMultiThreaded() && (!fSharedThread)) {
        hr = InitSharedThread();
        if (FAILED(hr)) {
            goto RawErrorExit;
        }
    }

    {
        DUserHeap * pHeapNew    = NULL;
        Context * pctxShare     = NULL;
        Context * pctxNew       = NULL;
        Context * pctxActual    = NULL;
        Thread * pthrNew        = NULL;
#if ENABLE_MPH
        BOOL fDanglingMPH       = FALSE;
#endif


        //
        // If the Context being created is separate, then it can't be shared.
        //

        if ((pInit->nThreadMode == IGTM_SEPARATE) && (pInit->hctxShare != NULL)) {
            PromptInvalid("Can not use IGTM_SEPARATE for shared Contexts");
            hr = E_INVALIDARG;
            goto RawErrorExit;
        }


        //
        // Initialize low-level resources (such as the heap).  If a Context is 
        // specified to share resources with, use the existing one.  If no Context 
        // is specified, need to create new resources.
        //
        // NOTE: If this is running on the main thread, the heap will already have
        // been created.
        //

        BOOL fThreadSafe;
        switch (pInit->nThreadMode)
        {
        case IGTM_SINGLE:
        case IGTM_SEPARATE:
            fThreadSafe = FALSE;
            break;

        default:
            fThreadSafe = TRUE;
        }

        DUserHeap::EHeap idHeap;
#ifdef _DEBUG

        idHeap = DUserHeap::idCrtDbgHeap;

#else // _DEBUG

        switch (pInit->nPerfMode)
        {
        case IGPM_SPEED:
#ifdef _X86_
            idHeap = DUserHeap::idRockAllHeap;
#else
            idHeap = DUserHeap::idNtHeap;
#endif
            break;

        case IGPM_BLEND:
            if (IsRemoteSession()) {
                idHeap = DUserHeap::idProcessHeap;
            } else {
#ifdef _X86_
                idHeap = DUserHeap::idRockAllHeap;
#else
                idHeap = DUserHeap::idNtHeap;
#endif
            }
            break;
            
        case IGPM_SIZE:
        default:            
            idHeap = DUserHeap::idProcessHeap;
            break;
        }

#endif // _DEBUG

        if (pInit->hctxShare != NULL) {
            BaseObject * pObj = BaseObject::ValidateHandle(pInit->hctxShare);
            if (pObj != NULL) {
                //
                // Note: We need to manually enter the Context here- can not use
                // a ContextLock object because the thread is not initialized yet.
                //

                pctxShare = CastContext(pObj);
                if (pctxShare == NULL) {
                    hr = E_INVALIDARG;
                    goto ErrorExit;
                }

                BOOL fError = FALSE;
                pctxShare->Enter();

                if (pctxShare->GetThreadMode() == IGTM_SEPARATE) {
                    PromptInvalid("Can not share with an IGTM_SEPARATE Context");
                    hr = E_INVALIDARG;
                    fError = TRUE;
                } else {
                    pctxShare->Lock();
                    DUserHeap * pHeapExist = pctxShare->GetHeap();
                    DUserHeap * pHeapTemp;  // Use temp b/c don't destroy if failure
                    VerifyMsgHR(CreateContextHeap(pHeapExist, fThreadSafe, idHeap, &pHeapTemp), "Always should be able to copy the heap");
                    VerifyMsg(pHeapTemp == pHeapExist, "Ensure heaps match");
                }

                pctxShare->Leave();

                if (fError) {
                    Assert(FAILED(hr));
                    goto ErrorExit;
                }
            }
        } else {
            if (FAILED(CreateContextHeap(NULL, fThreadSafe, idHeap, &pHeapNew))) {
                hr = E_OUTOFMEMORY;
                goto ErrorExit;
            }
        }

      
#if ENABLE_MPH
        //
        // Setup the WindowManagerHooks.  We do this BEFORE setting up the 
        // thread, since the MPH's will always be "uninit" in the Thread's
        // destructor.  However, until the thread is successfully setup, the
        // MPH's are dangling and need to be cleaned up manually.
        //

        if (pInit->nMsgMode == IGMM_STANDARD) {
            if (!InitMPH()) {
                hr = DU_E_CANNOTUSESTANDARDMESSAGING;
                goto ErrorExit;
            }
            fDanglingMPH = TRUE;

#if DBG_CHECK_CALLBACKS
            s_fBadMphInit = TRUE;
            fInitMPH = TRUE;
#endif            
        }
#endif


        //
        // Initialize the Thread
        //

        AssertMsg(!IsInitThread(), "Thread should not already be initialized");

        hr = Thread::Build(fSharedThread, &pthrNew);
        if (FAILED(hr)) {
            goto ErrorExit;
        }
        
        if (fSharedThread) {
            Assert(s_pthrSRT == NULL);
            s_pthrSRT = pthrNew;
        } else {
            s_lstAppThreads.Add(pthrNew);
            s_cAppThreads++;

#if DBG_CHECK_CALLBACKS
            s_cTotalAppThreads++;
#endif
        }
        
#if ENABLE_MPH
        fDanglingMPH = FALSE;
#endif


        //
        // Initialize the actual Context.
        //
        // NOTE: pHeapNew will only be initialized if we are building a new 
        // Context.  If we are linking into an existing Context, we do not
        // create a _new_ Context heap.
        //

        if (pctxShare == NULL) {
            AssertMsg(pHeapNew != NULL, "Must create a new heap for a new Context");

            hr = Context::Build(pInit, pHeapNew, &pctxNew);
            if (FAILED(hr)) {
                goto ErrorExit;
            }
            pctxActual = pctxNew;
        } else {
            //
            // Linking this thread to a shared Context, so just use the existing 
            // Context.  We have already Lock()'d the Context earlier.
            //

            AssertMsg(pHeapNew == NULL, "Should not create a new heap for existing Context");

            pctxShare->AddCurrentThread();
            pctxActual = pctxShare;
        }

        AssertMsg(fSharedThread || ((s_cAppThreads - DEBUG_cOldAppThreads) == 1), 
                "Should have created a single new app threads on success");
        
#if DBG_CHECK_CALLBACKS
        s_fBadMphInit = FALSE;
#endif

        if (!fSharedThread) {
            s_lockContext.Leave();

            //
            // NOTE: Can no longer goto ErrorExit or RawErrorExit for cleanup 
            // because we have left s_lockContext.
            //
        }
        *ppctxNew = pctxActual;

        return S_OK;

ErrorExit:
        //
        // NOTE: Do NOT destroy pctxNew on failure, since it was already 
        // attached to the newly created Thread object.  When this Thread is
        // unlocked (destroyed), it will also destroy the Context.
        //
        // If we try and unlock the Context here, it will be unlocked twice.
        // See Context::Context() for more information.
        //
        
        if (pthrNew != NULL) {
            xwDoThreadDestroyNL(pthrNew);
            pthrNew = NULL;
        }

        AssertMsg(DEBUG_cOldAppThreads == s_cAppThreads, 
                "Should have same number of app threads on failure");

#if ENABLE_MPH
        if (fDanglingMPH) {
#if DBG_CHECK_CALLBACKS
            if (UninitMPH()) {
                s_fBadMphInit = FALSE;
            }
#else // DBG_CHECK_CALLBACKS
            UninitMPH();
#endif // DBG_CHECK_CALLBACKS
        }
#endif // ENABLE_MPH

        if (pHeapNew != NULL) {
            DestroyContextHeap(pHeapNew);
            pHeapNew = NULL;
        }
    }

RawErrorExit:

#if DBG_CHECK_CALLBACKS
    if (fInitMPH) {
        if (s_fBadMphInit) {
            AlwaysPromptInvalid("Unsuccessfully uninitialized MPH on Context creation failure");
        }
    }
#endif // DBG_CHECK_CALLBACKS
    
    if (!fSharedThread) {
        s_lockContext.Leave();
    }

    AssertMsg(FAILED(hr), "ErrorExit requires a failure code");
    return hr;
}


/***************************************************************************\
*
* ResourceManager::InitComponentNL
*
* InitComponentNL() initializes an optional DirectUser component to be shared
* across all Contexts.  The component is valid until either it is explicitely
* uninitialized with UninitComponent() or the process ends.
*
* NOTE: InitComponentNL() doesn't actually synchronize on a Context, but needs
* a context to be initialized so that the threading model is determined.
*
* <error>   DU_E_GENERIC</>
* <error>   DU_E_CANNOTLOADGDIPLUS</>
*
\***************************************************************************/

HRESULT
ResourceManager::InitComponentNL(
    IN  UINT nOptionalComponent)        // Optional component to load
{
    //
    // NOTE: Initializing and unintializaing Components CAN NOT use the 
    // s_lockContext since they may destroy Threads.  This will call
    // xwNotifyThreadDestroyNL() to cleanup the thread's Context and would 
    // create a deadlock.  Therefore, we must be very careful when 
    // initializing and uninitializing components because Contexts may be 
    // created and destroyed in the middle of this.
    //

    HRESULT hr;

    AssertMsg(IsInitContext(), "Context must be initialized to determine threading model");

    s_lockComponent.Enter();

    switch (nOptionalComponent)
    {
    case IGC_DXTRANSFORM:
        hr = s_pData->manDX.Init();
        if (FAILED(hr)) {
            goto Exit;
        }

        hr = s_pData->manDX.InitDxTx();
        if (FAILED(hr)) {
            goto Exit;
        }

        hr = S_OK;
        break;

    case IGC_GDIPLUS:
        if (s_fInitGdiPlus) {
            hr = S_OK;  // GDI+ is already loaded
        } else {
            //
            // GDI+ has not already been loaded, so safely load and initialize 
            // it.
            //

            hr = DU_E_CANNOTLOADGDIPLUS;  // Assume failure unless pass all tests
            Gdiplus::GdiplusStartupInput gpgsi(NULL, TRUE);
            if (Gdiplus::GdiplusStartup(&s_gplToken, &gpgsi, &s_gpgso) == Gdiplus::Ok) {
                s_fInitGdiPlus = TRUE;
                RequestInitGdiplus();
                hr = S_OK;
            }
        }
        break;

    default:
        {
            hr = E_NOTIMPL;
            ComponentFactory * pfac = s_lstComponents.GetHead();
            while (pfac != NULL) {
                hr = pfac->Init(nOptionalComponent);
                if (hr != E_NOTIMPL) {
                    break;
                }

                pfac = pfac->GetNext();
            }
        }
    }

Exit:
    s_lockComponent.Leave();
    return hr;
}


/***************************************************************************\
*
* ResourceManager::UninitComponentNL
*
* UninitComponentNL() frees up resources associated with a previously 
* initialized optional component.
*
\***************************************************************************/

HRESULT
ResourceManager::UninitComponentNL(
    IN  UINT nOptionalComponent)        // Optional component to unload
{
    //
    // NOTE: See warning in InitComponent() about locks and re-entrancy issues.
    //

    HRESULT hr;
    s_lockComponent.Enter();

    switch (nOptionalComponent)
    {
    case IGC_DXTRANSFORM:
        s_pData->manDX.UninitDxTx();
        s_pData->manDX.Uninit();

        hr = S_OK;
        break;

    case IGC_GDIPLUS:
        //
        // GDI+ can not be uninitialized by the application.  Since various
        // DirectUser objects create and cache GDI+ objects, we have to 
        // postpone uninitializing GDI+ until all of the Contexts have been
        // destroyed.
        //

        hr = S_OK;
        break;

    default:
        {
            hr = E_NOTIMPL;
            ComponentFactory * pfac = s_lstComponents.GetHead();
            while (pfac != NULL) {
                hr = pfac->Init(nOptionalComponent);
                if (hr != E_NOTIMPL) {
                    break;
                }

                pfac = pfac->GetNext();
            }
        }
    }

    s_lockComponent.Leave();

    return hr;
}


/***************************************************************************\
*
* ResourceManager::UninitAllComponentsNL
*
* UninitAllComponentsNL() uninitializes all dynamically initialized 
* components and other global services.  This is called when all application
* threads have been destroyed and DirectUser is shutting down.  
*
* NOTE: This may or may not happen inside DllMain().
*
\***************************************************************************/

void        
ResourceManager::UninitAllComponentsNL()
{
    s_lockComponent.Enter();

    s_pData->manDX.Uninit();

    if (IsInitGdiPlus()) {
        if (!IsMultiThreaded()) {
            //
            // GDI+ has been initialized, but we are running in single 
            // threaded mode, so we need to uninitialize GDI+ here 
            // because there is no SRT.
            //

            (s_gpgso.NotificationUnhook)(s_gplToken);
        }

        Gdiplus::GdiplusShutdown(s_gplToken);
    }

    s_lockComponent.Leave();
}


/***************************************************************************\
*
* ResourceManager::RegisterComponentFactory
*
* RegisterComponentFactory() adds a ComponentFactory to the list of 
* factories queried when a dynamic component needs to be initialized.
*
\***************************************************************************/

void
ResourceManager::RegisterComponentFactory(
    IN  ComponentFactory * pfac)
{
    s_lstComponents.Add(pfac);
}


/***************************************************************************\
*
* ResourceManager::InitSharedThread
*
* InitSharedThread() ensures that the SRT for the process has been 
* initialized.  If it has not already been initialized, the SRT will be
* created and initialized.  The SRT is valid until the process shuts down.
*
* NOTE: It is VERY important that the SRT is NOT initialized while processing
* DllMain() because it creates a new thread and blocks until the thread is
* ready to process requests.  DllMain() serializes access across all threads,
* so we will deadlock.
*
\***************************************************************************/

HRESULT
ResourceManager::InitSharedThread()
{
    AssertMsg(IsMultiThreaded(), "Only initialize when multi-threaded");

    if (s_hthSRT != NULL) {
        return S_OK;
    }

    //
    // TODO: Need to LoadLibrary() to keep the SRT from going away underneath
    // us.  We also need to FreeLibrary(), but can not do this inside DllMain().
    // Also need to modify all exit paths to properly FreeLibrary() after this.


    //
    // Create a thread to handle these requests.  Wait until an event has been
    // signaled that the thread is ready to start receiving events.  We need to 
    // do this to ensure that the msgid's have been properly setup.
    //
    // This function is already called inside the lock, so we don't need to take
    // it again.
    //

    HRESULT hr;
    HINSTANCE hinstLoad = NULL;

    AssertMsg(s_hthSRT == NULL, "Ensure Thread is not already initialized");

    if (s_hevReady == NULL) {
        s_hevReady = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (s_hevReady == NULL) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    }

    AssertMsg(WaitForSingleObject(s_hevReady, 0) == WAIT_TIMEOUT, "Event was not Reset() after used last");

    //
    // Start the Thread.  DirectUser uses the CRT, so we use _beginthreadex().
    //

    hinstLoad = LoadLibrary("DUser.dll");
    AssertMsg(hinstLoad == g_hDll, "Must load the same DLL");
    
    unsigned thrdaddr;
    s_hthSRT = (HANDLE) _beginthreadex(NULL, 0, SharedThreadProc, NULL, 0, &thrdaddr);
    if (s_hthSRT == NULL) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    HANDLE rgh[2];
    rgh[0]  = s_hevReady;
    rgh[1]  = s_hthSRT;

    switch (WaitForMultipleObjects(_countof(rgh), rgh, FALSE, INFINITE))
    {
    case WAIT_OBJECT_0:
        //
        // SRT is now properly setup and ready to process requests.
        //
        hr = S_OK;
        break;
        
    case WAIT_OBJECT_0 + 1:
        //
        // SRT thread was successfully created, but it failed to setup.
        //

        {
            DWORD dwExitCode;
            Verify(GetExitCodeThread(s_hthSRT, &dwExitCode));
            hr = (HRESULT) dwExitCode;


            //
            // NOTE: Calling UninitSharedThread() will clean up both the 
            // dangling thread handle and DLL hinstances.
            //

            UninitSharedThread(TRUE /* Aborting */);
        }
        
        break;

    default:
        AssertMsg(0, "Unknown return code");
        hr = E_FAIL;
    }

    ResetEvent(s_hevReady);  // Clean up the event for the next user / next time

    //
    // TODO: May need to change to have a message loop in 
    // MsgWaitForMultipleObjects() so that we can process UI requests while this
    // thread is being created.  It may actually be important if this thread 
    // creates objects that may signal other objects in other threads and could
    // potentially dead-lock.
    //

    hinstLoad = NULL;

Exit:
    //
    // Need to FreeLibrary() on any errors.
    //
    
    if (hinstLoad != NULL) {
        FreeLibrary(hinstLoad);
    }
    
    return hr;
}


/***************************************************************************\
*
* ResourceManager::UninitSharedThread
*
* UninitSharedThread() uninitializes the SRT and is called when all 
* application threads have been uninitialized.
*
\***************************************************************************/

void
ResourceManager::UninitSharedThread(
    IN  BOOL fAbortInit)                // Aborting SRT thread initialization
{
    AssertMsg(IsMultiThreaded(), "Only initialize when multi-threaded");

    //    
    // When destroying the SRT, we need to wait until the SRT has properly 
    // cleaned up.  Because we are waiting, we need to worry about dead-locks.
    // Practically, this means that we can not be inside DllMain(), because
    // the Loader Lock will be a problem when the SRT tries to unload any
    // dynamically loaded DLL's.
    //
    // To ensure against this, we check that the caller doesn't call 
    // DeleteHandle() inside the Loader Lock.  We will still allow it (and 
    // dead-lock the app), but we Prompt and notify the developer that their
    // application is busted and needs to properly call DeleteHandle() before
    // entering the Loader Lock.
    //

    AssertMsg(s_dwSRTID != 0, "Must have valid SRT Thread ID");

    if (!fAbortInit) {
        Verify(PostThreadMessage(s_dwSRTID, WM_QUIT, 0, 0));
        WaitForSingleObject(s_hthSRT, INFINITE);
    }

    FreeLibrary(g_hDll);
    
    CloseHandle(s_hthSRT);
    s_hthSRT = NULL;
}


/***************************************************************************\
*
* ResourceManager::xwNotifyThreadDestroyNL
*
* xwNotifyThreadDestroyNL() is called by DllMain when a thread has been 
* destroyed.  This provides DirectUser an opportunity to clean up resources
* associated with the Thread before all Thread's are cleaned up at the end
* of the application.
*
\***************************************************************************/

void        
ResourceManager::xwNotifyThreadDestroyNL()
{
    Thread * pthrDestroy = RawGetThread();
    if (pthrDestroy != NULL) {
        BOOL fValid = pthrDestroy->Unlock();
        if (!fValid) {
            //
            // The Thread has finally been unlocked, so we can start its 
            // destruction
            //

            BOOL fSRT = pthrDestroy->IsSRT();
            if (!fSRT) {
                s_lockContext.Enter();
            }

            xwDoThreadDestroyNL(pthrDestroy);

            if (!fSRT) {
                s_lockContext.Leave();
            }
        }
    }
}


/***************************************************************************\
*
* ResourceManager::xwDoThreadDestroyNL
*
* xwDoThreadDestroyNL() provides the heart of thread destruction.  This may
* be called in several situations:
* - When DirectUser notices a thread has been destroyed in DllMain()
* - When the application calls DeleteHandle() on a Context.
* - When DirectUser is destroying the ResourceManager in DllMain() and is
*   destroying any outstanding threads.
*
\***************************************************************************/

void        
ResourceManager::xwDoThreadDestroyNL(
    IN  Thread * pthrDestroy)           // Thread to destroy
{
    //
    // Can not uninitialize inside DllMain(), but we can't just return.  
    // Instead, the process is very likely to dead-lock.
    //

    if (OS()->IsInsideLoaderLock()) {
        PromptInvalid("Can not uninitialize DirectUser inside DllMain()");
    }

    
    BOOL fSRT = pthrDestroy->IsSRT();

    //
    // Destroy the Thread object and reset the t_pThread pointer.  As each is 
    // extracted, set the current Thread and Context pointers so that the 
    // cleanup code can reference these.  When finished, set t_pThread and 
    // t_pContext to NULL since there is no Thread or Context for this thread.
    //

#if USE_DYNAMICTLS
    Verify(TlsSetValue(g_tlsThread, pthrDestroy));
    Context * pContext = pthrDestroy->GetContext();
    if (pContext != NULL) {
        ForceSetContextHeap(pContext->GetHeap());
    }
#else
    t_pThread   = pthrDestroy;
    t_pContext  = pthrDestroy->GetContext();
    if (t_pContext != NULL) {
        ForceSetContextHeap(t_pContext->GetHeap());
    }
#endif

    if (fSRT) {
        ResetSharedThread();
    } else {
        s_lstAppThreads.Unlink(pthrDestroy);
    }
    
    ProcessDelete(Thread, pthrDestroy);     // This is the "xw" function

    ForceSetContextHeap(NULL);
#if USE_DYNAMICTLS
    pContext = NULL;
    Verify(TlsSetValue(g_tlsThread, NULL));
#else
    t_pContext  = NULL;
    t_pThread   = NULL;
#endif


    //
    // Clean-up when there are no longer any application threads:
    // - Destroy the SRT
    // - Destroy global services / managers
    //

    if (!fSRT) {
        if (--s_cAppThreads == 0) {
            if (IsMultiThreaded()) {
                UninitSharedThread(FALSE /* Proper shutdown */);
            } else {
                AssertMsg(s_hthSRT == NULL, "Should never have initialized SRT for single-threaded");
            }

            UninitAllComponentsNL();
        }
    } 
}


//------------------------------------------------------------------------------
HBITMAP     
ResourceManager::RequestCreateCompatibleBitmap(
    IN  HDC hdc, 
    IN  int cxPxl, 
    IN  int cyPxl)
{
    if (IsMultiThreaded()) {
        GMSG_CREATEBUFFER msg;
        msg.cbSize      = sizeof(msg);
        msg.nMsg        = s_idCreateBuffer;
        msg.hgadMsg     = s_hgadMsg;

        msg.hdc         = hdc;
        msg.sizePxl.cx  = cxPxl;
        msg.sizePxl.cy  = cyPxl;
        msg.hbmpNew     = NULL;

        if (DUserSendEvent(&msg, 0) == DU_S_COMPLETE) {
            return msg.hbmpNew;
        }

        OutputDebugString("ERROR: RequestCreateCompatibleBitmap failed\n");
        return NULL;
    } else {
        return CreateCompatibleBitmap(hdc, cxPxl, cyPxl);
    }
}


//------------------------------------------------------------------------------
void
ResourceManager::RequestInitGdiplus()
{
    AssertMsg(s_fInitGdiPlus, "Only should call when GDI+ is just initialized");

    if (IsMultiThreaded()) {
        EventMsg msg;
        msg.cbSize      = sizeof(msg);
        msg.nMsg        = s_idInitGdiplus;
        msg.hgadMsg     = s_hgadMsg;

        if (DUserSendEvent(&msg, 0) != DU_S_COMPLETE) {
            OutputDebugString("ERROR: RequestInitGdiplus failed\n");
        }
    } else {
        (s_gpgso.NotificationHook)(&s_gplToken);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\services\resourcemanager.h ===
/***************************************************************************\
*
* File: ResourceManager.h
*
* Description:
* This file declares the ResourceManager used to setup and maintain all 
* Thread, Contexts, and other resources used by and with DirectUser.
*
*
* History:
*  4/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(SERVICES__ResourceManager_h__INCLUDED)
#define SERVICES__ResourceManager_h__INCLUDED
#pragma once

#include "ComManager.h"
#include "DxManager.h"

struct RMData
{
    DxManager   manDX;
};


class ComponentFactory : public ListNodeT<ComponentFactory>
{
public:
    virtual HRESULT     Init(UINT nComponent) PURE;
};

/***************************************************************************\
*
* ResourceManager manages all shared resources within DirectUser, including
* initializing Threads and Contexts.
*
\***************************************************************************/

class ResourceManager
{
// Construction
public:
    static  HRESULT     Create();
    static  void        xwDestroy();

// Operations
public:
    static  HRESULT     InitContextNL(INITGADGET * pInit, BOOL fSharedThread, Context ** ppctxNew);
    static  HRESULT     InitComponentNL(UINT nOptionalComponent);
    static  HRESULT     UninitComponentNL(UINT nOptionalComponent);
    static  void        UninitAllComponentsNL();
    static  void        RegisterComponentFactory(ComponentFactory * pfac);
    inline static  
            BOOL        IsInitGdiPlus() { return s_fInitGdiPlus; }

    static  void        xwNotifyThreadDestroyNL();

    static  RMData *    GetData();

    static  HBITMAP     RequestCreateCompatibleBitmap(HDC hdc, int cxPxl, int cyPxl);
    static  void        RequestInitGdiplus();

// Implementation
protected:
    static  HRESULT     InitSharedThread();
    static  void        UninitSharedThread(BOOL fAbortInit);
    static  void        ResetSharedThread();
    static  unsigned __stdcall 
                        SharedThreadProc(void * pvArg);
    static  HRESULT CALLBACK 
                        SharedEventProc(HGADGET hgadCur, void * pvCur, EventMsg * pMsg);
    static  void        xwDoThreadDestroyNL(Thread * pthrDestroy);

// Data
protected:
    static  long        s_fInit;        // RM has been initialized
    static  HANDLE      s_hthSRT;       // Shared Resource Thread
    static  DWORD       s_dwSRTID;      // Thread ID of SRT
    static  HANDLE      s_hevReady;     // SRT has been initialized
    static  HGADGET     s_hgadMsg;
    static  RMData *    s_pData;        // Dynamic RM data
    static  CritLock    s_lockContext;  // Context creation / destruction
    static  CritLock    s_lockComponent;// Component creation / destruction
    static  Thread *    s_pthrSRT;      // SRT thread
    static  GList<Thread> s_lstAppThreads; 
                                        // Set of non-SRT DU-enabled threads
    static  int         s_cAppThreads;  // Non-SRT thread count

#if DBG_CHECK_CALLBACKS
    static  int         s_cTotalAppThreads;
                                        // Number of application threads created during lifetime
    static  BOOL        s_fBadMphInit;  // Initialization of MPH failed
#endif

    // Requests
    static  MSGID       s_idCreateBuffer; // Create a new bitmap buffer
    static  MSGID       s_idInitGdiplus;  // Initialize GDI+

    // Optional Components
    static  GList<ComponentFactory>
                        s_lstComponents; // Dynamic component initializers
    static  BOOL        s_fInitGdiPlus; // GDI+ is initialized
    static  ULONG_PTR   s_gplToken;
    static  Gdiplus::GdiplusStartupOutput 
                        s_gpgso;
};

inline  DxManager *     GetDxManager();

#include "ResourceManager.inl"

#endif // SERVICES__ResourceManager_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\services\osal.inl ===
/***************************************************************************\
*
* File: OSAL.inl
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(SERVICES__OSAL_inl__INCLUDED)
#define SERVICES__OSAL_inl__INCLUDED
#pragma once

struct OSInfo
{
    BOOL    fUnicode;               // Unicode support is available
    BOOL    fXForm;                 // GDI X-Forms are avaialble
    BOOL    fQInputAvailableFlag;   // MWMO_INPUTAVAILABLE is available
};

extern  OSInfo  g_OSI;
extern  OSAL *  g_pOS;

//------------------------------------------------------------------------------
inline OSAL * 
OS()
{
    AssertMsg(g_pOS != NULL, "OSAL must be initialized by now");
    return g_pOS;
}


//------------------------------------------------------------------------------
inline BOOL
SupportUnicode()
{
    return g_OSI.fUnicode;
}


//------------------------------------------------------------------------------
inline BOOL
SupportXForm()
{
    return g_OSI.fXForm;
}


//------------------------------------------------------------------------------
inline BOOL
SupportQInputAvailable()
{
    return g_OSI.fQInputAvailableFlag;
}


//------------------------------------------------------------------------------
inline BOOL        
OSAL::IsWin98orWin2000(OSVERSIONINFO * povi)
{
    return povi->dwMajorVersion >= 5;
}


//------------------------------------------------------------------------------
inline BOOL        
OSAL::IsWhistler(OSVERSIONINFO * povi)
{
    return (povi->dwMajorVersion >= 5) && (povi->dwMinorVersion >= 1);
}


//------------------------------------------------------------------------------
inline BOOL
IsRemoteSession()
{
    return GetSystemMetrics(SM_REMOTESESSION);
}

#endif // SERVICES__OSAL_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\services\services.h ===
/***************************************************************************\
*
* File: Services.h
*
* Description:
* This file provides a project-wide header that is included in all source 
* files specific to this project.  It is similar to a precompiled header, 
* but is designed for more rapidly changing headers.
*
* The primary purpose of this file is to determine which DirectUser 
* projects this project has direct access to instead of going through public
* API's.  It is VERY IMPORTANT that this is as minimal as possible since
* adding a new project unnecessarily reduces the benefit of project 
* partitioning.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(SERVICES__Services_h__INCLUDED)
#define SERVICES__Services_h__INCLUDED
#pragma once

#define GADGET_ENABLE_DX
#define GADGET_ENABLE_COM
#include <DUser.h>

#include <DUserBaseP.h>
#include "TicketManager.h"

#include "Globals.h"

#if DBG

#define PromptInvalid(comment) \
    do \
    { \
        if (IDebug_Prompt(GetDebug(), "Validation error:\r\n" comment, __FILE__, __LINE__, "DirectUser/Services Notification")) \
            AutoDebugBreak(); \
    } while (0) \

#else // DBG

#define PromptInvalid(comment) ((void) 0)

#endif // DBG

#endif // SERVICES__Services_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\services\resourcemanager.inl ===
/***************************************************************************\
*
* File: ResourceManager.inl
*
* History:
*  4/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(SERVICES__ResourceManager_inl__INCLUDED)
#define SERVICES__ResourceManager_inl__INCLUDED
#pragma once

//------------------------------------------------------------------------------
inline RMData *    
ResourceManager::GetData()
{
    AssertMsg(s_pData != NULL, "Data must be initialized before using");
    return s_pData;
}


//------------------------------------------------------------------------------
inline DxManager *     
GetDxManager()
{
    return &(ResourceManager::GetData()->manDX);
}


#endif // SERVICES__ResourceManager_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\services\surface.cpp ===
#include "stdafx.h"
#include "Services.h"
#include "Surface.h"

#include "GdiCache.h"
#include "OSAL.h"
#include "ResourceManager.h"

/***************************************************************************\
*****************************************************************************
*
* class DuDCSurface
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
HRESULT
DuDCSurface::Build(
    IN  DuDCSurface::ESource src,
    OUT DuDCSurface ** ppsrfNew)
{
    DuDCSurface * psrfNew = ClientNew(DuDCSurface);
    if (psrfNew == NULL) {
        return E_OUTOFMEMORY;
    }

    switch (src)
    {
    case srcTempDC:
        psrfNew->m_hdc = GetGdiCache()->GetTempDC();
        psrfNew->m_fTempDC = TRUE;
        break;

    case srcCompatibleDC:
        psrfNew->m_hdc = GetGdiCache()->GetCompatibleDC();
        psrfNew->m_fCompatibleDC = TRUE;
        break;

    default:
        AssertMsg(0, "Unknown DC Source");
    }

    if (psrfNew->m_hdc == NULL) {
        ClientDelete(DuDCSurface, psrfNew);
        return DU_E_OUTOFGDIRESOURCES;
    }

    *ppsrfNew = psrfNew;
    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
DuDCSurface::Build(
    IN  HDC hdc,
    OUT DuDCSurface ** ppsrfNew)
{
    Assert(hdc != NULL);

    DuDCSurface * psrfNew = ClientNew(DuDCSurface);
    if (psrfNew == NULL) {
        return E_OUTOFMEMORY;
    }

    psrfNew->m_hdc = hdc;

    *ppsrfNew = psrfNew;
    return S_OK;
}


//------------------------------------------------------------------------------
void
DuDCSurface::Destroy()
{
    if (m_hdc != NULL) {
        if (m_fTempDC) {
            GetGdiCache()->ReleaseTempDC(m_hdc);
        } else if (m_fCompatibleDC) {
            GetGdiCache()->ReleaseCompatibleDC(m_hdc);
        }
    }

    ClientDelete(DuDCSurface, this);
}


//------------------------------------------------------------------------------
void
DuDCSurface::SetIdentityTransform()
{
    OS()->SetIdentityTransform(m_hdc);
}


//------------------------------------------------------------------------------
void
DuDCSurface::SetWorldTransform(const XFORM * pxf)
{
    OS()->SetWorldTransform(m_hdc, pxf);
}


//------------------------------------------------------------------------------
void *
DuDCSurface::Save()
{
    return IntToPtr(SaveDC(m_hdc));
}


//------------------------------------------------------------------------------
void
DuDCSurface::Restore(void * pvState)
{
    RestoreDC(m_hdc, PtrToInt(pvState));
}


/***************************************************************************\
*****************************************************************************
*
* class DuGpSurface
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
HRESULT
DuGpSurface::Build(
    IN  Gdiplus::Graphics * pgpgr,
    OUT DuGpSurface ** ppsrfNew)
{
    Assert(pgpgr != NULL);

    DuGpSurface * psrfNew = ClientNew(DuGpSurface);
    if (psrfNew == NULL) {
        return E_OUTOFMEMORY;
    }

    psrfNew->m_pgpgr = pgpgr;


    //
    // Initialize common settings on the GDI+ surface
    //

    pgpgr->SetSmoothingMode(Gdiplus::SmoothingModeHighSpeed);
    pgpgr->SetPixelOffsetMode(Gdiplus::PixelOffsetModeHighSpeed);
    pgpgr->SetCompositingQuality(Gdiplus::CompositingQualityHighSpeed);

    *ppsrfNew = psrfNew;
    return S_OK;
}


//------------------------------------------------------------------------------
void
DuGpSurface::Destroy()
{
    ClientDelete(DuGpSurface, this);
}


//------------------------------------------------------------------------------
void
DuGpSurface::SetIdentityTransform()
{
    m_pgpgr->ResetTransform();
}


//------------------------------------------------------------------------------
void
DuGpSurface::SetWorldTransform(const XFORM * pxf)
{
    Gdiplus::Matrix mat(pxf->eM11, pxf->eM12, pxf->eM21, pxf->eM22, pxf->eDx, pxf->eDy);
    m_pgpgr->SetTransform(&mat);
}


//------------------------------------------------------------------------------
void *
DuGpSurface::Save()
{
    return ULongToPtr(m_pgpgr->Save());
}


//------------------------------------------------------------------------------
void
DuGpSurface::Restore(void * pvState)
{
    m_pgpgr->Restore(static_cast<Gdiplus::GraphicsState>(PtrToUlong(pvState)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\services\stdafx.h ===
#if !defined(SERVICES__StdAfx_h__INCLUDED)
#define SERVICES__StdAfx_h__INCLUDED
#pragma once

#include "CommonStdAfx.h"
#include <atlconv.h>            // String conversion routines

#endif // SERVICES__StdAfx_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\services\thread.h ===
/***************************************************************************\
*
* File: Thread.h
*
* Description:
* This file declares the main Thread that is maintained by the 
* ResourceManager to store per-thread information.
*
*
* History:
*  4/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(SERVICES__Thread_h__INCLUDED)
#define SERVICES__Thread_h__INCLUDED
#pragma once

#include "GdiCache.h"
#include "Buffer.h"
#include "ComManager.h"

class Context;
class Thread;
class SubThread;
class ThreadPackBuilder;

struct ReturnMem
{
    ReturnMem * pNext;
    int         cbSize;
};

const POOLBLOCK_SIZE = 128;

/***************************************************************************\
*****************************************************************************
*
* Thread provides a mechanism to store per-thread information.  This object
* is only used by its own thread and should not be directly accessed from
* other threads.  This object is created when a thread is registered with
* the ResourceManager to create a Context.
*
*****************************************************************************
\***************************************************************************/

#pragma warning(disable:4324)  // structure was padded due to __declspec(align())

class Thread : public ListNodeT<Thread>
{
// Construction
public:
    inline  Thread();
            ~Thread();
    static  HRESULT     Build(BOOL fSRT, Thread ** ppthrNew);

// Operations
public:
    enum ESlot {
        slCore          = 0,            // Core
        slCOUNT                         // Number of sub-contexts
    };

    inline  BOOL        IsSRT() const;
    inline  void        Lock();
    inline  BOOL        Unlock();

    inline  void        MarkOrphaned();

    inline  GdiCache *  GetGdiCache() const;
    inline  BufferManager *
                        GetBufferManager() const;
    inline  ComManager* GetComManager() const;
    inline  Context *   GetContext() const;
    inline  void        SetContext(Context * pContext);
    inline  SubThread * GetST(ESlot slot) const;

    inline  void        xwLeftContextLockNL();
    inline  TempHeap *  GetTempHeap() const;

            ReturnMem * AllocMemoryNL(int cbSize);
    inline  void        ReturnMemoryNL(ReturnMem * prMem);

// Implementation
#if DBG
public:
    virtual void        DEBUG_AssertValid() const;
#endif    

// Data
public:
            HRGN        hrgnClip;

protected:
            void        xwDestroySubThreads();
    static  void CALLBACK xwContextFinalUnlockProc(BaseObject * pobj, void * pvData);

            void        ReturnAllMemoryNL();

            struct PoolMem : public ReturnMem
            {
                BYTE        rgbData[POOLBLOCK_SIZE - sizeof(ReturnMem)];
            };
            AllocPoolNL<PoolMem, 512>
                        m_poolReturn;   // Pool of reserved memory

            GdiCache    m_GdiCache;
            BufferManager m_manBuffer;
            ComManager  m_manCOM;
            Context *   m_pContext;     // Current Context for this Thread
            TempHeap    m_heapTemp;     // Temporary heap
            GInterlockedList<ReturnMem> 
                        m_lstReturn;    // Returned memory list

            SubThread*  m_rgSTs[slCOUNT]; // Sub-context information

            UINT        m_cRef;         // Outstanding references on this Thread
            UINT        m_cMemAlloc;    // Outstanding ReturnMem allocations
            BOOL        m_fSRT:1;       // Thread is an SRT
            BOOL        m_fStartDestroy:1;      // Thread has started destruction
            BOOL        m_fDestroySubThreads:1; // Sub-threads have been destroyed
            BOOL        m_fOrphaned:1;  // Thread was orphaned
};

#pragma warning(default:4324)  // structure was padded due to __declspec(align())

/***************************************************************************\
*****************************************************************************
*
* SubThread defines a "extensibility" mechanism that allows individual
* projects in DirectUser to provide additional data to store on the thread.
* To use this, the project must add a new slot in Thread, derive a class
* from SubThread that is created per Thread instance, and derive a class
* from ThreadPackBuilder to register the extension.
*
*****************************************************************************
\***************************************************************************/

class SubThread
{
// Construction
public:
    virtual ~SubThread() { }
    virtual HRESULT     Create() { return S_OK; }

// Operations
public:
    inline  Thread *    GetParent() const { return m_pParent; }
    inline  void        SetParent(Thread * pParent);
    virtual void        xwLeftContextLockNL() { }

// Implementation
#if DBG
public:
    virtual void        DEBUG_AssertValid() const;
#endif    

// Data
protected:
            Thread *   m_pParent;
};


/***************************************************************************\
*****************************************************************************
*
* ThreadPackBuilder registers an SubThread "extension" to be created 
* whenever a new Thread is created.  The constructor is expected to set the
* slot corresponding to the ESlot value.
*
*****************************************************************************
\***************************************************************************/

class ThreadPackBuilder
{
// Construction
public:

// Operations
public:
    virtual SubThread*  New(Thread * pThread) PURE;
    static  inline ThreadPackBuilder *
                        GetBuilder(Thread::ESlot slot);

// Data
protected:
    static  ThreadPackBuilder * 
                        s_rgBuilders[Thread::slCOUNT];
};


#define IMPLEMENT_SUBTHREAD(id, obj)                        \
    class obj##Builder : public ThreadPackBuilder           \
    {                                                       \
    public:                                                 \
        virtual SubThread * New(Thread * pParent)           \
        {                                                   \
            SubThread * psc = ProcessNew(obj);              \
            if (psc != NULL) {                              \
                psc->SetParent(pParent);                    \
            }                                               \
            return psc;                                     \
        }                                                   \
    } g_##obj##B                                            \

#define PREINIT_SUBTHREAD(obj)                              \
    class obj##Builder;                                     \
    extern obj##Builder g_##obj##B                          \

#define INIT_SUBTHREAD(obj)                                 \
    (ThreadPackBuilder *) &g_##obj##B                       \


inline  Thread *    GetThread();
inline  BOOL        IsInitThread();

#include "Thread.inl"

#endif // SERVICES__Thread_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\services\thread.inl ===
/***************************************************************************\
*
* File: Thread.inl
*
* History:
*  4/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(SERVICES__Thread_inl__INCLUDED)
#define SERVICES__Thread_inl__INCLUDED
#pragma once

#if USE_DYNAMICTLS
extern  DWORD           g_tlsThread;    // TLS Slot for Thread data
#else
extern __declspec(thread) Thread * t_pThread;
#endif


/***************************************************************************\
*****************************************************************************
*
* class Thread
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline Thread * 
GetThread()
{
#if USE_DYNAMICTLS
    Thread * pThread = reinterpret_cast<Thread *> (TlsGetValue(g_tlsThread));
#else
    Thread * pThread = t_pThread;
#endif
    AssertMsg(pThread != NULL, "Thread must already be initialized");
    return pThread;
}


//------------------------------------------------------------------------------
inline Thread * 
RawGetThread()
{
#if USE_DYNAMICTLS
    Thread * pThread = reinterpret_cast<Thread *> (TlsGetValue(g_tlsThread));
#else
    Thread * pThread = t_pThread;
#endif
    // Don't check if pThread == NULL
    return pThread;
}


//------------------------------------------------------------------------------
inline BOOL
IsInitThread()
{
#if USE_DYNAMICTLS
    return TlsGetValue(g_tlsThread) != NULL;
#else
    return t_pThread != NULL;
#endif
}


//------------------------------------------------------------------------------
inline  
Thread::Thread()
{
    m_cRef = 1;
}


//------------------------------------------------------------------------------
inline BOOL        
Thread::IsSRT() const
{
    return m_fSRT;
}


//------------------------------------------------------------------------------
inline void
Thread::Lock()
{
    AssertMsg(m_cRef > 0, "Must have a valid reference");
    m_cRef++;
}


//------------------------------------------------------------------------------
inline BOOL
Thread::Unlock()
{
    AssertMsg(m_cRef > 0, "Must have a valid reference");
    return --m_cRef != 0;
}


//------------------------------------------------------------------------------
inline void
Thread::MarkOrphaned()
{
    AssertMsg(!m_fOrphaned, "Thread should only be orphaned once");
    m_fOrphaned = TRUE;
}


//------------------------------------------------------------------------------
inline GdiCache *  
Thread::GetGdiCache() const
{
    return const_cast<GdiCache *> (&m_GdiCache);
}


//------------------------------------------------------------------------------
inline BufferManager *
Thread::GetBufferManager() const
{
    return const_cast<BufferManager *> (&m_manBuffer);
}


//------------------------------------------------------------------------------
inline ComManager *    
Thread::GetComManager() const
{
    return const_cast<ComManager *> (&m_manCOM);
}


//------------------------------------------------------------------------------
inline Context *   
Thread::GetContext() const
{
    return m_pContext;
}


//------------------------------------------------------------------------------
inline void        
Thread::SetContext(Context * pContext)
{
    AssertMsg(((pContext == NULL) && (m_pContext != NULL)) ||
            ((pContext != NULL) && (m_pContext == NULL)) ||
            ((pContext == NULL) && (m_pContext == NULL)), 
            "Must reset Context before changing to a new Context");

    m_pContext = pContext;
}


//------------------------------------------------------------------------------
inline SubThread *
Thread::GetST(ESlot slot) const
{
    return m_rgSTs[slot];
}


//------------------------------------------------------------------------------
inline void        
Thread::xwLeftContextLockNL()
{
    for (int idx = 0; idx < slCOUNT; idx++) {
        m_rgSTs[idx]->xwLeftContextLockNL();
    }
}


//------------------------------------------------------------------------------
inline TempHeap *
Thread::GetTempHeap() const
{
    return const_cast<TempHeap *> (&m_heapTemp);
}


//------------------------------------------------------------------------------
inline void
Thread::ReturnMemoryNL(ReturnMem * prMem)
{
    prMem->pNext = NULL;

    AssertMsg(!m_fDestroySubThreads, 
            "All memory should be returned before the thread gets destroyed");

    m_lstReturn.AddHeadNL(prMem);
}


/***************************************************************************\
*****************************************************************************
*
* class SubThread
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline void
SubThread::SetParent(Thread * pParent)
{
    AssertMsg(m_pParent == NULL, "Must set only once");
    m_pParent = pParent;
}


/***************************************************************************\
*****************************************************************************
*
* class ThreadPackBuilder
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline ThreadPackBuilder *
ThreadPackBuilder::GetBuilder(Thread::ESlot slot)
{
    AssertMsg(s_rgBuilders[slot] != NULL, "Build must be defined");
    return s_rgBuilders[slot];
}


#endif // SERVICES__Thread_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\services\ticketmanager.cpp ===
/***************************************************************************\
*
* File: TicketManager.cpp
*
* Description:
*
* This file contains the implementation of relevant classes, structs, and 
* types for the DUser Ticket Manager.
*
* The following classes are defined for public use:
*
*   DuTicketManager
*       A facility which can assign a unique "ticket" to a BaseObject.
*
* History:
*  9/20/2000: DwayneN:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Services.h"
#include "TicketManager.h"

#define INIT_OUT_PARAM(p,v) if(p != NULL) *p = v
#define VALIDATE_REQUIRED_OUT_PARAM(p) if(p == NULL) return E_POINTER;
#define VALIDATE_IN_PARAM_NOT_VALUE(p,v) if(p == v) return E_INVALIDARG;

//------------------------------------------------------------------------------
DuTicketManager::DuTicketManager()
{
    Assert(sizeof(DuTicket) == sizeof(DWORD));

    m_idxFreeStackTop = -1;
    m_idxFreeStackBottom = -1;
}


//------------------------------------------------------------------------------
DuTicketManager::~DuTicketManager()
{
}


//------------------------------------------------------------------------------
HRESULT
DuTicketManager::Add(
    IN BaseObject * pObject,
    OUT DWORD * pdwTicket)
{
    HRESULT hr = S_OK;
    int idxFree = 0;

    //
    // Parameter checking.
    // - Initialize all out parameters
    // - Validate in parameters
    //
    INIT_OUT_PARAM(pdwTicket, 0);
    VALIDATE_REQUIRED_OUT_PARAM(pdwTicket);
    VALIDATE_IN_PARAM_NOT_VALUE(pObject, NULL);

    m_crit.Enter();

    //
    // Scan to make sure the object isn't already in the array.
    // This is too expensive to do outside of DEBUG builds.
    //
    Assert(FAILED(Find(pObject, idxFree)));

    hr = PopFree(idxFree);
    if (SUCCEEDED(hr)) {
        DuTicket ticket;

        m_arTicketData[idxFree].pObject = pObject;

        ticket.Unused = 0;
        ticket.Uniqueness = m_arTicketData[idxFree].cUniqueness;
        ticket.Type = pObject->GetHandleType();
        ticket.Index = idxFree;

        *pdwTicket = DuTicket::CastToDWORD(ticket);
    }
    
    m_crit.Leave();

    return hr;
}


//------------------------------------------------------------------------------
HRESULT
DuTicketManager::Remove(
    IN DWORD dwTicket,
    OUT OPTIONAL BaseObject ** ppObject)
{
    HRESULT hr = S_OK;
    
    //
    // Parameter checking.
    // - Initialize all out parameters
    // - Validate in parameters
    //
    INIT_OUT_PARAM(ppObject, NULL);
    VALIDATE_IN_PARAM_NOT_VALUE(dwTicket, 0);

    m_crit.Enter();

    hr = Lookup(dwTicket, ppObject);
    if (SUCCEEDED(hr)) {
        DuTicket ticket = DuTicket::CastFromDWORD(dwTicket);

        //
        // Clear out the object at this index just in case.
        //
        m_arTicketData[ticket.Index].pObject = NULL;
        
        //
        // Increment the uniqueness to invalidate any outstanding tickets.
        //
        m_arTicketData[ticket.Index].cUniqueness++;
        if (m_arTicketData[ticket.Index].cUniqueness == 0) {
            m_arTicketData[ticket.Index].cUniqueness = 1;
        }

        //
        // Push this index back onto the free stack.
        //
        PushFree(ticket.Index);
    }

    m_crit.Leave();

    return(hr);
}


//------------------------------------------------------------------------------
HRESULT
DuTicketManager::Lookup(
    IN DWORD dwTicket,
    OUT OPTIONAL BaseObject ** ppObject)
{
    HRESULT hr = S_OK;
    DuTicket ticket = DuTicket::CastFromDWORD(dwTicket);
    
    //
    // Parameter checking.
    // - Initialize all out parameters
    // - Validate in parameters
    // - Check for manifest errors in the ticket
    //
    INIT_OUT_PARAM(ppObject, NULL);
    VALIDATE_IN_PARAM_NOT_VALUE(dwTicket, 0);
    if (ticket.Unused != 0 ||
        ticket.Uniqueness == 0 ||
        ticket.Index >= WORD(m_arTicketData.GetSize())) {
        return E_INVALIDARG;
    }
    
    m_crit.Enter();

    //
    // Look up the information in the tables and see if the
    // ticket still looks valid.
    //
    if (m_arTicketData[ticket.Index].cUniqueness == ticket.Uniqueness) {
        if (ppObject != NULL && m_arTicketData[ticket.Index].pObject != NULL) {
            if (ticket.Type == BYTE(m_arTicketData[ticket.Index].pObject->GetHandleType())) {
                *ppObject = m_arTicketData[ticket.Index].pObject;
            }
        }
    } else {
        //
        // It seems like the ticket has gone stale.
        //
        hr = DU_E_NOTFOUND;
    }

    m_crit.Leave();

    return hr;
}


//------------------------------------------------------------------------------
HRESULT
DuTicketManager::Expand()
{
    //
    // We only need to resize our internal arrays when the free stack is empty.
    //
    Assert(m_idxFreeStackBottom == -1 && m_idxFreeStackTop == -1);

    //
    // Get the old size of the array, and calculate a new size.
    // Note that we limit how big the table can grow.
    //
    int cOldSize = m_arTicketData.GetSize();
    int cNewSize;
    if (cOldSize > 0) {
        if (cOldSize < USHRT_MAX) {
            cNewSize = min(cOldSize * 2, USHRT_MAX);
        } else {
            return E_OUTOFMEMORY;
        }
    } else {
        cNewSize = 16;
    }

    //
    // Resize the array of objects.  The contents of the new items will
    // be set to NULL;
    //
    if (m_arTicketData.SetSize(cNewSize)) {
        //
        // Initialize the new data.
        //
        for (int i = cOldSize; i < cNewSize; i++) {
            m_arTicketData[i].pObject = NULL;
            m_arTicketData[i].cUniqueness = 1;
            m_arTicketData[i].idxFree = WORD(i);
        }

        m_idxFreeStackBottom = cOldSize;
        m_idxFreeStackTop = cNewSize - 1;
    } else {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
DuTicketManager::PushFree(int idxFree)
{
    if (m_idxFreeStackBottom == -1 && m_idxFreeStackTop == -1) {
        Assert(m_arTicketData.GetSize() > 0);

        m_idxFreeStackBottom = 0;
        m_idxFreeStackTop = 0;
        m_arTicketData[0].idxFree = WORD(idxFree);
    } else {
        int iNewTop = (m_idxFreeStackTop + 1) % m_arTicketData.GetSize();
        
        AssertMsg(iNewTop != m_idxFreeStackBottom, "Probably more pushes than pops!");

        m_arTicketData[iNewTop].idxFree = WORD(idxFree);
        m_idxFreeStackTop = iNewTop;
    }

    return S_OK;
}

//------------------------------------------------------------------------------
HRESULT
DuTicketManager::PopFree(int & idxFree)
{
    HRESULT hr = S_OK;

    //
    // Resize our arrays if our stack of available slots is empty.
    //
    if (m_idxFreeStackBottom == -1 || m_idxFreeStackTop == -1) {
        hr = Expand();
        Assert(SUCCEEDED(hr));

        if (FAILED(hr)) {
            return hr;
        }
    }

    Assert(m_idxFreeStackBottom >=0 && m_idxFreeStackTop >=0 );

    //
    // Take the available slot from the bottom of the stack.
    //
    idxFree = m_arTicketData[m_idxFreeStackBottom].idxFree;

    //
    // Increment the bottom of the stack.  If the stack is now empty,
    // indicate so by setting the top and bottom to -1.
    //
    if (m_idxFreeStackBottom == m_idxFreeStackTop) {
        m_idxFreeStackBottom = -1;
        m_idxFreeStackTop = -1;
    } else {
        m_idxFreeStackBottom = (m_idxFreeStackBottom + 1) % m_arTicketData.GetSize();
    }

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
DuTicketManager::Find(BaseObject * pObject, int & iFound)
{
    HRESULT hr = DU_E_NOTFOUND;

    iFound = -1;

    //
    // Note: This is a brute-force find.  It does a linear search for the
    // specified pointer.  This is very, very slow so don't use it unless
    // you absolutely have to.  The BaseObject itself should remember what
    // its ticket is so it doesn't have to search.
    //
    for (int i = 0; i < m_arTicketData.GetSize(); i++) {
        if (m_arTicketData[i].pObject == pObject) {
            hr = S_OK;
            iFound = i;
            break;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\services\surface.h ===
#if !defined(SERVICES__Surface_h__INCLUDED)
#define SERVICES__Surface_h__INCLUDED
#pragma once

/***************************************************************************\
*****************************************************************************
*
* Pure Virtual Base Classes
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
class DuSurface
{
public:
    virtual void        Destroy() PURE;

    enum EType
    {
        stDC        = GSURFACE_HDC,
        stGdiPlus   = GSURFACE_GPGRAPHICS
    };

    virtual EType       GetType() const PURE;
    virtual void        SetIdentityTransform() PURE;
    virtual void        SetWorldTransform(const XFORM * pxf) PURE;
    virtual void *      Save() PURE;
    virtual void        Restore(void * pvState) PURE;

    inline static DuSurface::EType       
                        GetSurfaceType(UINT nSurfaceType);
    inline static UINT  GetSurfaceType(DuSurface::EType type);
};


//------------------------------------------------------------------------------
class DuRegion
{
public:
    virtual void        Destroy() PURE;

    virtual DuSurface::EType
                        GetType() const PURE;
};


/***************************************************************************\
*****************************************************************************
*
* GDI (Win32) Specific Implementation
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
class DuDCSurface : public DuSurface
{
public:
    enum ESource
    {
        srcTempDC,
        srcCompatibleDC
    };
            
    static  HRESULT     Build(ESource src, DuDCSurface ** ppsrfNew);
    static  HRESULT     Build(HDC hdc, DuDCSurface ** ppsrfNew);
    virtual void        Destroy();

    inline  HDC         GetHDC();

    virtual EType       GetType() const { return DuSurface::stDC; }
    virtual void        SetIdentityTransform();
    virtual void        SetWorldTransform(const XFORM * pxf);
    virtual void *      Save();
    virtual void        Restore(void * pvState);
    
protected:
            HDC         m_hdc;
            BOOL        m_fTempDC:1;
            BOOL        m_fCompatibleDC:1;
};


/***************************************************************************\
*****************************************************************************
*
* GDI+ Specific Implementation
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
class DuGpSurface : public DuSurface
{
public:
    static  HRESULT     Build(Gdiplus::Graphics * pgpgr, DuGpSurface ** ppsrfNew);
    virtual void        Destroy();

    inline  Gdiplus::Graphics *
                        GetGraphics();

    virtual EType       GetType() const { return DuSurface::stGdiPlus; }
    virtual void        SetIdentityTransform();
    virtual void        SetWorldTransform(const XFORM * pxf);
    virtual void *      Save();
    virtual void        Restore(void * pvState);
    
protected:
            Gdiplus::Graphics *
                        m_pgpgr;
};


#include "Surface.inl"

#endif // SERVICES__Surface_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\services\surface.inl ===
#if !defined(SERVICES__Surface_inl__INCLUDED)
#define SERVICES__Surface_inl__INCLUDED
#pragma once

//------------------------------------------------------------------------------
inline DuSurface::EType
DuSurface::GetSurfaceType(UINT nSurfaceType)
{
    AssertMsg(stDC == GSURFACE_HDC, "ID's must match");
    return (EType) nSurfaceType;
}


//------------------------------------------------------------------------------
inline UINT
DuSurface::GetSurfaceType(DuSurface::EType type)
{
    AssertMsg(stDC == GSURFACE_HDC, "ID's must match");
    return (UINT) type;
}


//------------------------------------------------------------------------------
inline HDC
DuDCSurface::GetHDC()
{
    return m_hdc;
}


//------------------------------------------------------------------------------
inline Gdiplus::Graphics *
DuGpSurface::GetGraphics()
{
    return m_pgpgr;
}


//------------------------------------------------------------------------------
inline
HDC
CastHDC(DuSurface * psrf)
{
    AssertMsg(psrf->GetType() == DuSurface::stDC, "Must be an HDC surface");
    return ((DuDCSurface *) psrf)->GetHDC();
}


//------------------------------------------------------------------------------
inline
Gdiplus::Graphics *
CastGraphics(DuSurface * psrf)
{
    AssertMsg(psrf->GetType() == DuSurface::stGdiPlus, "Must be a GDI+ surface");
    return ((DuGpSurface *) psrf)->GetGraphics();
}


#endif // SERVICES__Surface_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\services\thread.cpp ===
/***************************************************************************\
*
* File: Thread.cpp
*
* Description:
* This file implements the main Thread that is maintained by the 
* ResourceManager to store per-thread information.
*
*
* History:
*  4/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#include "stdafx.h"
#include "Services.h"
#include "Thread.h"

#include "Context.h"

#if !USE_DYNAMICTLS
__declspec(thread) Thread * t_pThread;
#endif


/***************************************************************************\
*****************************************************************************
*
* class Thread
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
Thread::~Thread()
{
    m_fStartDestroy = TRUE;

    //
    // NOTE: The Thread object may be destroyed on its own thread or on another
    // thread.  Therefore, t_pThread may or may not be == this.
    //

    //
    // Notify the Context that one less thread is using it.  Want to do near
    // the end since the Context heap may be destroyed after calling this.
    // This means that (new / delete) will no longer be valid.
    //
    // Need to call Context::xwUnlock() directly because 
    // Context::DeleteObject() will call the ResourceManager to destroy the 
    // Thread (which is where we already are.)
    //

    //
    // NOTE: We can only destroy the SubThread's when the Thread has a Context.
    // This is because destruction of the SubThread's is an "xw" function that
    // requires a Context.  This unfortunately means that if we were unable
    // to create the Context, we're going to leak the SubTread's, but there is
    // little we can do about it.
    //

    m_poolReturn.Destroy();
    
    if (m_pContext != NULL) {
        if (m_pContext->xwUnlockNL(xwContextFinalUnlockProc, this)) {
            xwDestroySubThreads();
        }

        m_pContext = NULL;
    }


    //
    // Cleanup cached GDI objects
    //

    if (hrgnClip != NULL) {
        DeleteObject(hrgnClip);
    }


    //
    // NOTE: When m_lstReturn's destructor is called, it will check that all 
    // memory has been returned.  It is possible this may not be empty if memory
    // was returned after we emptied m_lstReturn in xwDestroySubThreads().  This
    // is an application error since the memory wasn't allocated using
    // SGM_RECEIVECONTEXT.
    //
    // This is actually a serious application problem, since T2 is still using 
    // memory owned by T1 when T1 is being destroyed.  Unfortunately, DirectUser
    // can not really do that much about it since the application is using DUser
    // in an invalid manner and there are significant performance costs and 
    // design complications by changing this.
    //
}


//------------------------------------------------------------------------------
void        
Thread::xwDestroySubThreads()
{
    if (m_fDestroySubThreads) {
        return;
    }
    m_fDestroySubThreads = TRUE;

    //
    // Notify the sub-threads that the Thread and (potentially) the Context
    // are being destroyed.  This gives them an opportunity to perform any
    // necessary callbacks to the application.
    //

    for (int idx = 0; idx < slCOUNT; idx++) {
        if (m_rgSTs[idx] != NULL) {
            ProcessDelete(SubThread, m_rgSTs[idx]);
            m_rgSTs[idx] = NULL;
        }
    }

    //
    // Destroy any other objects that may depend on the Context (and the 
    // Context heap).
    //

    m_GdiCache.Destroy();
    m_manBuffer.Destroy();
    m_heapTemp.Destroy();


    //
    // Clean up any outstanding returned memory.  We need to keep track of all
    // the memory this Thread gives out since we can not go away until it has
    // all returned.  If we were to go away before then, the heap would be 
    // destroyed and the other Thread would be using bad data.
    //
    // Therefore, we will make an attempt to get all of the memory back.  If
    // it takes longer than one minute, we'll have to bail.
    //
    
    int cAttempts = 60 * 1000;  // Wait a maximum of 60 seconds
    while ((m_cMemAlloc > 0) && (cAttempts-- > 0)) {
        while (!m_lstReturn.IsEmptyNL()) {
            ReturnAllMemoryNL();
        }

        if (m_cMemAlloc > 0) {
            Sleep(1);
        }
    }
    m_poolReturn.Destroy();
}


//------------------------------------------------------------------------------
void CALLBACK 
Thread::xwContextFinalUnlockProc(BaseObject * pobj, void * pvData)
{
    Thread * pthr = reinterpret_cast<Thread *> (pvData);
    Context * pctx = static_cast<Context *> (pobj);

    pctx->xwPreDestroyNL();
    pthr->xwDestroySubThreads();
}


//------------------------------------------------------------------------------
HRESULT
Thread::Build(
    IN  BOOL fSRT,                      // Thread is an SRT
    OUT Thread ** ppthrNew)             // Newly created thread
{
    //
    // Check if this Thread is already initialized
    //
#if USE_DYNAMICTLS
    Thread * pThread = reinterpret_cast<Thread *> (TlsGetValue(g_tlsThread));
    if (pThread != NULL) {
        *ppthrNew = pThread;
#else
    Thread * pThread = t_pThread;
    if (pThread != NULL) {
        *ppthrNew = pThread;
#endif
        return S_OK;
    }


    HRESULT hr = E_INVALIDARG;

    //
    // Create a new Thread
    //

    pThread = ProcessNew(Thread);
    if (pThread == NULL) {
        hr = E_OUTOFMEMORY;
        goto ErrorExit;
    }

    pThread->hrgnClip = CreateRectRgn(0, 0, 0, 0);
    if (pThread->hrgnClip == NULL) {
        hr = E_OUTOFMEMORY;
        goto ErrorExit;
    }
    pThread->m_fSRT = fSRT;


    //
    // Initialize each of the sub-contexts.  These can safely use the heap
    // which has already been initialized.
    //

    {
        for (int idx = 0; idx < slCOUNT; idx++) {
            ThreadPackBuilder * pBuilder = ThreadPackBuilder::GetBuilder((Thread::ESlot) idx);
            AssertMsg(pBuilder != NULL, "Builder not initialized using INIT_SUBTHREAD");
            SubThread * pST = pBuilder->New(pThread);
            pThread->m_rgSTs[idx] = pST;
            if ((pThread->m_rgSTs[idx] == NULL) || 
                FAILED(hr = pThread->m_rgSTs[idx]->Create())) {

                goto ErrorExit;
            }
        }
    }

    AssertMsg(pThread != NULL, "Ensure Thread is valid");
#if USE_DYNAMICTLS
    AssertMsg(TlsGetValue(g_tlsThread) == NULL, "Ensure TLS is still empty");
    Verify(TlsSetValue(g_tlsThread, pThread));
#else
    AssertMsg(t_pThread == NULL, "Ensure TLS is still empty");
    t_pThread   = pThread;
#endif
    *ppthrNew   = pThread;

    return S_OK;

ErrorExit:
    //
    // An error occurred while initializing the thread, so need to tear down
    // the object.
    //

    if (pThread != NULL) {
        if (pThread->hrgnClip != NULL) {
            DeleteObject(pThread->hrgnClip);
        }

        if (pThread != NULL) {
            ProcessDelete(Thread, pThread);
        }
    }

    *ppthrNew = NULL;
    return hr;
}


//------------------------------------------------------------------------------
ReturnMem *
Thread::AllocMemoryNL(
    IN  int cbSize)                     // Size of allocating, including ReturnMem
{
    AssertMsg(cbSize >= sizeof(ReturnMem), 
            "Allocation must be at least sizeof(ReturnMem)");
    AssertMsg(!m_fDestroySubThreads, "Must be before subtreads start destruction");

    //
    // Before allocating memory from our pool, return memory back to the pool if
    // the pool is already empty.  Only do this if the pool is empty.  
    // Otherwise, the effort is unnecessary and just slows things down.
    //

    if (m_poolReturn.IsEmpty()) {
        ReturnAllMemoryNL();
    }


    //
    // Now, allocate the memory.  Allocate from our pool if it is within the 
    // pool size.
    //

    ReturnMem * prMem;
    if (cbSize <= POOLBLOCK_SIZE) {
        cbSize = POOLBLOCK_SIZE;
        prMem = m_poolReturn.New();
    } else {
        prMem = reinterpret_cast<ReturnMem *> (ContextAlloc(GetContext()->GetHeap(), cbSize));
    }

    if (prMem != NULL) {
        prMem->cbSize = cbSize;
        m_cMemAlloc++;
    }
    return prMem;
}


//------------------------------------------------------------------------------
void
Thread::ReturnAllMemoryNL()
{
    //
    // Check if any memory has been returned.  If so, we need to add it back 
    // into the pool if it is the right size.  Only need to ExtractNL() once.  
    // If we loop, we unnecessarily hit the S-List memory, causing more 
    // slow-downs.
    //
    // As we return the memory, we decrement the number of outstanding 
    // allocations to keep track of how many are remaining.
    //

    ReturnMem * pNode = m_lstReturn.ExtractNL();
    while (pNode != NULL) {
        ReturnMem * pNext = pNode->pNext;
        if (pNode->cbSize == POOLBLOCK_SIZE) {
            PoolMem * pPoolMem = static_cast<PoolMem *> (pNode);
            m_poolReturn.Delete(pPoolMem);
        } else {
            ContextFree(GetContext()->GetHeap(), pNode);
        }

        AssertMsg(m_cMemAlloc > 0, "Must have a remaining memory allocation");
        m_cMemAlloc--;
        
        pNode = pNext;
    }
}


#if DBG

//------------------------------------------------------------------------------
void
Thread::DEBUG_AssertValid() const
{
    Assert(hrgnClip != NULL);
    AssertInstance(m_pContext);

    for (int idx = 0; idx < slCOUNT; idx++) {
        AssertInstance(m_rgSTs[idx]);
    }

    if (!m_fStartDestroy) {
        Assert(m_cRef > 0);
        Assert(!m_fDestroySubThreads);
    }
}

#endif
    

/***************************************************************************\
*****************************************************************************
*
* class SubThread
*
*****************************************************************************
\***************************************************************************/

#if DBG

//------------------------------------------------------------------------------
void
SubThread::DEBUG_AssertValid() const
{
    // Don't use AssertInstance since it would be recursive.
    Assert(m_pParent != NULL);
}

#endif
    

/***************************************************************************\
*****************************************************************************
*
* class ThreadPackBuilder
*
*****************************************************************************
\***************************************************************************/

PREINIT_SUBTHREAD(CoreST);

ThreadPackBuilder * ThreadPackBuilder::s_rgBuilders[Thread::slCOUNT] =
{
    INIT_SUBTHREAD(CoreST),
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\services\ticketmanager.h ===
/***************************************************************************\
*
* File: TicketManager.h
*
* Description:
*
* This file contains the definition of relevant classes, structs, and types
* for the DUser Ticket Manager.
*
* The following classes are defined for public use:
*
*   TicketManager
*       A facility which can assign a unique "ticket" to a BaseObject.
*
* History:
*  9/20/2000: DwayneN:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(SERVICES__TicketManager_h__INCLUDED)
#define SERVICES__TicketManager_h__INCLUDED
#pragma once


/***************************************************************************\
*
* DuTicket
*
* Tickets are created to give an external identity to a gadget.  However,
* this identity is not necessarily permanent, and may have a limited 
* lifetime.  External apps should not hold on to these temporary tickets
* for long periods of time because they will eventually expire.
*
* One primary consumer of these tickets is the ActiveAccessibility APIs.
* Because of this, we must work within some constraints:
* - Tickets must be 32-bits in size.
* - Tickets can't be negative, so the upper bit must be clear.
* - Tickets can't be zero.
*
* A description of the fields in a ticket follow:
*
* Unused:
* As explained above, the upper bit can not be used, and must be 0.
*
* Type:
* We encode the actual type of the BaseObject so that we can further
* validate uses of the ticket.
*
* Uniqueness:
* We encode a uniqueness value that is essentially an ever-increasing number
* to provide some temporal distance between subsequent uses of the same
* index.  The uniqueness can never be 0 - to satisfy the requirement that
* the ticket itself can never be 0.
*
* Index
* The actual BaseObject is stored in a table in the TicketManager.  This
* index is stored here.
*
\***************************************************************************/
struct DuTicket
{
    DWORD Index : 16;
    DWORD Uniqueness : 8;
    DWORD Type : 7;
    DWORD Unused : 1;

    inline static DuTicket & CastFromDWORD(DWORD & dw);
    inline static DWORD & CastToDWORD(DuTicket & ticket);
};


/***************************************************************************\
*
* DuTicketData
*
* The DuTicketData structure is used to store the data inside the ticket
* manager. A brief description of the fields follows:
*
* pObject
* A pointer to the actual BaseObject associated with a given ticket.
*
* dwExpirationTick
* How many ticks until the ticket is invalidated.
*
* idxFree
* This is actually a logically separate array that contains a "free stack"
* to make inserting into the ticket manager quick.
*
* cUniqueness
* The uniqueness value for this entry in the ticket manager.  Tickets must
* have a matching uniqueness in order for them to actually access the 
* object.
*
\***************************************************************************/

struct DuTicketData
{
    BaseObject * pObject;
    WORD idxFree;
    BYTE cUniqueness;
};

//
// Note: This class is only defined this way because its the only way I
// could get the debugger extensions to recognize the symbol name.
//
class DuTicketDataArray : public GArrayF<DuTicketData, ProcessHeap>
{
public:
};

/***************************************************************************\
*
* DuTicketManager
*
* The DuTicketManager class provides a mechanism by which a relatively
* permanent "ticket" can be assigned to a given BaseObject.  This "ticket"
* can be used later to safely access the BaseObject.  If the BaseObject has
* been destroyed, an error will be returned but the system will not fault.
*
* This is especially important when you must pass the identity of a DUser
* object to an outside program.  It would be unsafe to pass the raw pointer
* since doing so may require an unsafe dereference when the outside program
* attempts to extract information about the object.
*
* This is a one-way mapping only.  The TicketManager class can correctly
* return the BaseObject assigned to a given ticket.  However, to find the
* ticket associated with a BaseObject is an expensive operation and is
* best stored on the BaseObject itself.
*
\***************************************************************************/

class DuTicketManager
{
// Construction
public:
                        DuTicketManager();
                        ~DuTicketManager();
                        SUPPRESS(DuTicketManager);

// Operations
public:
            HRESULT     Add(IN BaseObject * pObject, OUT DWORD * pdwTicket);
            HRESULT     Remove(IN DWORD dwTicket, OUT OPTIONAL BaseObject ** ppObject);
            HRESULT     Lookup(IN DWORD dwTicket, OUT OPTIONAL BaseObject ** ppObject);

// Implementation
protected:
            HRESULT     Expand();
            HRESULT     PushFree(int idxFree);
            HRESULT     PopFree(int & idxFree);
            HRESULT     Find(BaseObject * pObject, int & iFound);

// Data
private:
            DuTicketDataArray 
                        m_arTicketData;
            int         m_idxFreeStackTop;
            int         m_idxFreeStackBottom;
            CritLock    m_crit;
};

#include "TicketManager.inl"

#endif // SERVICES__TicketManager_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\services\ticketmanager.inl ===
/***************************************************************************\
*
* File: TicketManager.inl
*
* History:
*  9/20/2000: DwayneN:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/

#if !defined(SERVICES__TicketManager_inl__INCLUDED)
#define SERVICES__TicketManager_inl__INCLUDED
#pragma once

//------------------------------------------------------------------------------
DuTicket &
DuTicket::CastFromDWORD(
    DWORD & dw)
{
    return *(reinterpret_cast<DuTicket*>(&dw));
}

//------------------------------------------------------------------------------
DWORD &
DuTicket::CastToDWORD(
    DuTicket & ticket)
{
    return *(reinterpret_cast<DWORD*>(&ticket));
}

#endif // SERVICES__TicketManager_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\winapi\dwpex.h ===
#if !defined(WINAPI__DWPEx_h__INCLUDED)
#define WINAPI__DWPEx_h__INCLUDED
#pragma once

class HWndContainer;
class DuRootGadget;
class Gadget;

HWndContainer * GdGetContainer(HWND hwnd);
HRESULT     GdCreateHwndRootGadget(HWND hwndContainer, CREATE_INFO * pci, DuRootGadget ** ppgadRoot);
HRESULT     GdCreateNcRootGadget(HWND hwndContainer, CREATE_INFO * pci, DuRootGadget ** ppgadRoot);
HRESULT     GdCreateDxRootGadget(const RECT * prcContainerPxl, CREATE_INFO * pci, DuRootGadget ** ppgadRoot);
BOOL        GdForwardMessage(DuVisual * pgadRoot, UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT * pr);


#endif // WINAPI__DWPEx_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\winapi\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	WinAPI.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\winapi\dwpex.cpp ===
#include "stdafx.h"
#include "WinAPI.h"
#include "DwpEx.h"

/***************************************************************************\
*****************************************************************************
*
* DefWindowProcEx Extensions
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
struct ExtraInfo
{
    HWND            hwnd;           // For easy reference
    WNDPROC         pfnOldWndProc;  // Original wndproc before subclassing
    HWndContainer * pconOwner;      // Gadget container for this window
};


//------------------------------------------------------------------------------
ExtraInfo *
RawGetExtraInfo(HWND hwnd)
{
    return (ExtraInfo *) GetWindowLongPtr(hwnd, GWLP_USERDATA);
}


LRESULT ExtraInfoWndProc(HWND hwnd, UINT nMsg, WPARAM wParam, LPARAM lParam);


/***************************************************************************\
*
* GetExtraInfo
*
* GetExtraInfo() returns an ExtraInfo block for a given window.  If the
* window does not already have an EI block, a new one is allocated, attached
* to the window and subclassed.
*
\***************************************************************************/

ExtraInfo *
GetExtraInfo(HWND hwnd)
{
    if (!ValidateHWnd(hwnd)) {
        return NULL;
    }

    // First, check if the info already exists
    ExtraInfo * pei = RawGetExtraInfo(hwnd);
    if (pei != NULL) {
        return pei;
    }

    pei = ProcessNew(ExtraInfo);
    pei->hwnd           = hwnd;
    pei->pfnOldWndProc  = (WNDPROC) GetWindowLongPtr(hwnd, GWLP_WNDPROC);
    pei->pconOwner      = NULL;

    SetWindowLongPtrW(hwnd, GWLP_USERDATA, (LONG_PTR) pei);
    SetWindowLongPtrW(hwnd, GWLP_WNDPROC, (LONG_PTR) ExtraInfoWndProc);

    return pei;
}


/***************************************************************************\
*
* RemoveExtraInfo
*
* RemoveExtraInfo() cleans up any objects allocated in a HWND's ExtraInfo data
* block.
*
\***************************************************************************/

void
RemoveExtraInfo(HWND hwnd)
{
    if (!ValidateHWnd(hwnd)) {
        return;
    }

    ExtraInfo * pei = RawGetExtraInfo(hwnd);
    if (pei == NULL) {
        return;
    }

    if (pei->pconOwner != NULL) {
        pei->pconOwner->xwUnlock();
    }

    SetWindowLongPtrW(hwnd, GWLP_WNDPROC, (LONG_PTR) pei->pfnOldWndProc);
    SetWindowLongPtrW(hwnd, GWLP_USERDATA, NULL);

    ProcessDelete(ExtraInfo, pei);
}


//---------------------------------------------------------------------------
void
DestroyContainer(ExtraInfo * pei)
{
    if (pei->pconOwner != NULL) {
        pei->pconOwner->xwUnlock();
        pei->pconOwner = NULL;
    }
}


/***************************************************************************\
*
* ExtraInfoWndProc
*
* ExtraInfoWndProc() provides a TEMPORARY mechanism of adding ExtraInfo into
* an HWND.  Eventually, this should be moved into DefWindowProc().
*
\***************************************************************************/

LRESULT
ExtraInfoWndProc(HWND hwnd, UINT nMsg, WPARAM wParam, LPARAM lParam)
{
    //
    // Check if the window has ExtraInfo (without allocating any if it
    // doesn't).  If we don't "own" it, just pass on to DefWindowProc().
    //
    ExtraInfo * pei = RawGetExtraInfo(hwnd);
    if (pei == NULL) {
        return DefWindowProc(hwnd, nMsg, wParam, lParam);
    }


    //
    // This window has ExtraInfo, so handle as necessary.
    //
    // Also, grab any info that we will need to call the original windowproc
    // later.
    //

    WNDPROC pfnOldWndProc = pei->pfnOldWndProc;

    switch (nMsg)
    {
    case WM_NCDESTROY:
        //
        // This is the last message that we will get, so need to clean-up now.
        // We need to be very careful since we will detatch ourself from the
        // window.
        //

        RemoveExtraInfo(hwnd);
        break;

    default:
        if (pei->pconOwner != NULL) {
            LRESULT r;
            if (pei->pconOwner->xdHandleMessage(nMsg, wParam, lParam, &r, 0)) {
                return r;
            }
        }
    }

    return CallWindowProc(pfnOldWndProc, hwnd, nMsg, wParam, lParam);
}


//**************************************************************************************************
//
// Public Functions
//
//**************************************************************************************************

/***************************************************************************\
*
* GdGetContainer (Public)
*
* GdGetContainer() returns the associated Gadget Container for a given
* window.  If the window does not yet have a gadget container, NULL is
* returned.
*
\***************************************************************************/

HWndContainer *
GdGetContainer(HWND hwnd)
{
    ExtraInfo * pei = RawGetExtraInfo(hwnd);
    if (pei == NULL) {
        return NULL;
    }

    return pei->pconOwner;
}


/***************************************************************************\
*
* GdCreateHwndRootGadget (Public)
*
* GdCreateHwndRootGadget() creates a new RootGadget for an existing HWND.  If
* the HWND already has a gadget or container, this function will destroy
* the previous container and gadget and create new instances.
*
\***************************************************************************/

HRESULT
GdCreateHwndRootGadget(
    IN  HWND hwndContainer,             // Window to be hosted inside
    IN  CREATE_INFO * pci,              // Creation information
    OUT DuRootGadget ** ppgadNew)       // New Gadget
{
    HRESULT hr;

    ExtraInfo * pei = GetExtraInfo(hwndContainer);
    if (pei == NULL) {
        return NULL;
    }

    DestroyContainer(pei);

    //
    // Build a new container and top gadget
    //

    HWndContainer * pconNew;
    hr = HWndContainer::Build(pei->hwnd, &pconNew);
    if (FAILED(hr)) {
        return hr;
    }

    DuRootGadget * pgadNew;
    hr = DuRootGadget::Build(pconNew, FALSE, pci, &pgadNew);
    if (FAILED(hr)) {
        pconNew->xwUnlock();
        return hr;
    }

    pgadNew->SetFill(GetStdColorBrushI(SC_White));

    pei->pconOwner = pconNew;
    *ppgadNew = pgadNew;
    return S_OK;
}


//------------------------------------------------------------------------------
BOOL
GdForwardMessage(DuVisual * pgadRoot, UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT * pr)
{
    DuContainer * pcon = pgadRoot->GetContainer();
    return pcon->xdHandleMessage(nMsg, wParam, lParam, pr, DuContainer::mfForward);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\winapi\public.h ===
#if !defined(WINAPI__Public_h__INCLUDED)
#define WINAPI__Public_h__INCLUDED

#endif // WINAPI__Public_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\winapi\apistubs.cpp ===
/***************************************************************************\
*
* File: ApiStubs.cpp
*
* Description:
* ApiStubs.cpp exposes all public DirectUser API's in the Win32 world.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/

#include "stdafx.h"
#include "WinAPI.h"

#include "DwpEx.h"


#define DUSER_API
#pragma warning(disable: 4296)      // expression is always false


//
// Undefine the macros declared in ObjectAPI because they will be redefined 
// here for the WinAPI handle-based API's.
//

#undef BEGIN_API
#undef END_API
#undef BEGIN_API_NOLOCK
#undef END_API_NOLOCK
#undef BEGIN_API_NOCONTEXT
#undef END_API_NOCONTEXT

#undef CHECK_MODIFY

#undef VALIDATE_GADGETCONTEXT
#undef VALIDATE_VALUE
#undef VALIDATE_HWND
#undef VALIDATE_REGION
#undef VALIDATE_OBJECT
#undef VALIDATE_EVENTGADGET
#undef VALIDATE_EVENTGADGET_NOCONTEXT
#undef VALIDATE_VISUAL
#undef VALIDATE_ROOTGADGET
#undef VALIDATE_VISUAL_OR_NULL
#undef VALIDATE_TRANSITION

#undef VALIDATE_FLAGS
#undef VALIDATE_RANGE
#undef VALIDATE_CODE_PTR
#undef VALIDATE_CODE_PTR_OR_NULL
#undef VALIDATE_READ_PTR
#undef VALIDATE_READ_PTR_
#undef VALIDATE_READ_PTR_OR_NULL_
#undef VALIDATE_READ_STRUCT
#undef VALIDATE_WRITE_PTR
#undef VALIDATE_WRITE_PTR_
#undef VALIDATE_WRITE_PTR_OR_NULL_
#undef VALIDATE_WRITE_STRUCT
#undef VALIDATE_STRING_PTR
#undef VALIDATE_STRINGA_PTR
#undef VALIDATE_STRINGW_PTR


//
// SET_RETURN is a convenient macro that converts from DirectUser error 
// conditions and sets up the return value.
//
// NOTE: This MUST be a macro (and not an inline function) because we CANNOT
// evaluate success unless hr was actually successful.  Unfortunately with 
// function calls, success would need to be evaluated to call the function.
//

#define SET_RETURN(hr, success)     \
    do {                            \
        if (SUCCEEDED(hr)) {        \
            retval = success;       \
        } else {                    \
            SetError(hr);           \
        }                           \
    } while (0)                     \



template <class T>
inline void SetError(T dwErr)
{
    SetLastError((DWORD) dwErr);
}


//
// API Entry / Exit setup rountines
//

#define BEGIN_RECV(type, value, defermsg)       \
    type retval = value;                        \
    type errret = value;                        \
    UNREFERENCED_PARAMETER(errret);             \
                                                \
    if (!IsInitContext()) {                     \
        PromptInvalid("Must initialize Context before using thread"); \
        SetError(DU_E_NOCONTEXT);               \
        goto rawErrorExit;                      \
    }                                           \
                                                \
    {                                           \
        ContextLock cl;                         \
        if (!cl.LockNL(defermsg)) {             \
            SetError(E_INVALIDARG);             \
            goto ErrorExit;                     \
        }                                       \
        Context * pctxThread  = cl.pctx;        \
        AssertInstance(pctxThread);            \
        UNREFERENCED_PARAMETER(pctxThread);     \

#define END_RECV()                              \
        goto ErrorExit;                         \
ErrorExit:                                      \
        /* Unlocks the Context here */          \
        ;                                       \
    }                                           \
rawErrorExit:                                   \
    return retval;


#define BEGIN_RECV_NOLOCK(type, value)          \
    type retval = value;                        \
    type errret = value;                        \
    UNREFERENCED_PARAMETER(errret);             \
                                                \
    if (!IsInitContext()) {                     \
        PromptInvalid("Must initialize Context before using thread"); \
        SetError(DU_E_NOCONTEXT);               \
        goto rawErrorExit;                      \
    }                                           \
                                                \
    {                                           \
        Context * pctxThread  = ::GetContext(); \
        AssertInstance(pctxThread);            \


#define END_RECV_NOLOCK()                       \
        goto ErrorExit;                         \
ErrorExit:                                      \
        ;                                       \
    }                                           \
rawErrorExit:                                   \
    return retval;



#define BEGIN_RECV_NOCONTEXT(type, value)       \
    type retval = value;                        \
    type errret = value;                        \
    UNREFERENCED_PARAMETER(errret);             \


#define END_RECV_NOCONTEXT()                    \
    goto ErrorExit;                             \
ErrorExit:                                      \
    return retval;



#define CHECK_MODIFY()                          \
    if (pctxThread->IsReadOnly()) {             \
        PromptInvalid("Can not call modifying function while in read-only state / callback"); \
        SetError(DU_E_READONLYCONTEXT);         \
        goto ErrorExit;                         \
    }                                           \


//
// Individual parameter validation rountines
//

#define VALIDATE_GADGETCONTEXT(gad)                         \
    {                                                       \
        Context * pctxGad = (p##gad)->GetContext();         \
        if (pctxThread != pctxGad) {                        \
            PromptInvalid("Must use Gadget inside correct Context"); \
            SetError(DU_E_INVALIDCONTEXT);                  \
            goto ErrorExit;                                 \
        }                                                   \
    }


#define VALIDATE_VALUE(x, v)                                \
    if (x != v) {                                           \
        SetError(E_INVALIDARG);                             \
        goto ErrorExit;                                     \
    }

#define VALIDATE_HWND(wnd)                                  \
    if ((h##wnd == NULL) || (!IsWindow(h##wnd))) {          \
        PromptInvalid("Handle is not a valid Window");             \
        SetError(E_INVALIDARG);                             \
        goto ErrorExit;                                     \
    }

#define VALIDATE_REGION(rgn)                                \
    if (h##rgn == NULL) {                                   \
        PromptInvalid("Handle is not a valid region");             \
        SetError(E_INVALIDARG);                             \
        goto ErrorExit;                                     \
    }

#define VALIDATE_OBJECT(obj)                                \
    {                                                       \
        p##obj = BaseObject::ValidateHandle(h##obj);        \
        if (p##obj == NULL) {                               \
            PromptInvalid("Handle is not a valid object"); \
            SetError(E_INVALIDARG);                         \
            goto ErrorExit;                                 \
        }                                                   \
    }

#define VALIDATE_EVENTGADGET(gad)                            \
    {                                                       \
        p##gad = ValidateBaseGadget(h##gad);                \
        if (p##gad == NULL) {                               \
            PromptInvalid("Handle is not a valid Gadget"); \
            SetError(E_INVALIDARG);                         \
            goto ErrorExit;                                 \
        }                                                   \
        VALIDATE_GADGETCONTEXT(gad)                         \
    }

#define VALIDATE_EVENTGADGET_NOCONTEXT(gad)                  \
    {                                                       \
        p##gad = ValidateBaseGadget(h##gad);                \
        if (p##gad == NULL) {                               \
            PromptInvalid("Handle is not a valid Gadget"); \
            SetError(E_INVALIDARG);                         \
            goto ErrorExit;                                 \
        }                                                   \
    }

#define VALIDATE_VISUAL(gad)                                \
    {                                                       \
        p##gad = ValidateVisual(h##gad);                    \
        if (p##gad == NULL) {                               \
            PromptInvalid("Handle is not a valid Gadget"); \
            SetError(E_INVALIDARG);                         \
            goto ErrorExit;                                 \
        }                                                   \
        VALIDATE_GADGETCONTEXT(gad)                         \
    }

#define VALIDATE_ROOTGADGET(gad)                            \
    {                                                       \
        {                                                   \
            DuVisual * pgadTemp = ValidateVisual(h##gad);   \
            if (pgadTemp == NULL) {                         \
                PromptInvalid("Handle is not a valid Gadget"); \
                SetError(E_INVALIDARG);                     \
                goto ErrorExit;                             \
            }                                               \
            if (!pgadTemp->IsRoot()) {                      \
                goto ErrorExit;                             \
            }                                               \
            VALIDATE_GADGETCONTEXT(gadTemp)                 \
            p##gad = (DuRootGadget *) pgadTemp;             \
        }                                                   \
    }

#define VALIDATE_VISUAL_OR_NULL(gad)                        \
    {                                                       \
        if (h##gad == NULL) {                               \
            p##gad = NULL;                                  \
        } else {                                            \
            p##gad = ValidateVisual(h##gad);                \
            if (p##gad == NULL) {                           \
                PromptInvalid("Handle is not a valid Gadget");     \
                SetError(E_INVALIDARG);                     \
                goto ErrorExit;                             \
            }                                               \
            VALIDATE_GADGETCONTEXT(gad)                     \
        }                                                   \
    }

#define VALIDATE_TRANSITION(trx)                            \
    {                                                       \
        BaseObject * pbase##trx = BaseObject::ValidateHandle(h##trx);   \
        p##trx = CastTransition(pbase##trx);                \
        if (p##trx == NULL) {                               \
            PromptInvalid("Handle is not a valid Transition");     \
            SetError(E_INVALIDARG);                         \
            goto ErrorExit;                                 \
        }                                                   \
    }

#define VALIDATE_FLAGS(f, m)                                \
    if ((f & m) != f) {                                     \
        PromptInvalid("Specified flags are invalid");      \
        SetError(E_INVALIDARG);                             \
        goto ErrorExit;                                     \
    }

#define VALIDATE_RANGE(i, a, b)                             \
    if (((i) < (a)) || ((i) > (b))) {                       \
        PromptInvalid("Value is outside expected range");  \
        SetError(E_INVALIDARG);                             \
        goto ErrorExit;                                     \
    }                                                       \

#define VALIDATE_CODE_PTR(p)                                \
    if ((p == NULL) || IsBadCode(p)) {                      \
        PromptInvalid("Bad code pointer: " STRINGIZE(p));  \
        SetError(E_INVALIDARG);                             \
        goto ErrorExit;                                     \
    }                                                       \

#define VALIDATE_CODE_PTR_OR_NULL(p)                        \
    if ((p != NULL) && IsBadCode((FARPROC) p)) {            \
        PromptInvalid("Bad code pointer: " STRINGIZE(p));  \
        SetError(E_INVALIDARG);                             \
        goto ErrorExit;                                     \
    }                                                       \

#define VALIDATE_READ_PTR(p)                                \
    if ((p == NULL) || IsBadRead(p, sizeof(char *))) {      \
        PromptInvalid("Bad read pointer: " STRINGIZE(p));  \
        SetError(E_INVALIDARG);                             \
        goto ErrorExit;                                     \
    }                                                       \

#define VALIDATE_READ_PTR_(p, b)                            \
    if ((p == NULL) || IsBadRead(p, b)) {                   \
        PromptInvalid("Bad read pointer: " STRINGIZE(p));  \
        SetError(E_INVALIDARG);                             \
        goto ErrorExit;                                     \
    }                                                       \

#define VALIDATE_READ_PTR_OR_NULL_(p, b)                    \
    if ((p != NULL) && IsBadRead(p, b)) {                   \
        PromptInvalid("Bad read pointer: " STRINGIZE(p));          \
        SetError(E_INVALIDARG);                             \
        goto ErrorExit;                                     \
    }                                                       \

#define VALIDATE_READ_STRUCT(p, s)                          \
    if ((p == NULL) || IsBadRead(p, sizeof(s))) {           \
        PromptInvalid("Bad read pointer: " STRINGIZE(p));  \
        SetError(E_INVALIDARG);                             \
        goto ErrorExit;                                     \
    }                                                       \
    if (p->cbSize != sizeof(s)) {                           \
        PromptInvalid("Structure is not expected size for " STRINGIZE(s)); \
        SetError(E_INVALIDARG);                             \
        goto ErrorExit;                                     \
    }
    
#define VALIDATE_WRITE_PTR(p)                               \
    if ((p == NULL) || IsBadWrite(p, sizeof(char *))) {     \
        PromptInvalid("Bad write pointer: " STRINGIZE(p));         \
        SetError(E_INVALIDARG);                             \
        goto ErrorExit;                                     \
    }                                                       \

#define VALIDATE_WRITE_PTR_(p, b)                           \
    if ((p == NULL) || IsBadWrite(p, b)) {                  \
        PromptInvalid("Bad write pointer: " STRINGIZE(p));         \
        SetError(E_INVALIDARG);                             \
        goto ErrorExit;                                     \
    }                                                       \

#define VALIDATE_WRITE_PTR_OR_NULL_(p, b)                   \
    if ((p != NULL) && IsBadWrite(p, b)) {                  \
        PromptInvalid("Bad write pointer: " STRINGIZE(p));         \
        SetError(E_INVALIDARG);                             \
        goto ErrorExit;                                     \
    }                                                       \

#define VALIDATE_WRITE_STRUCT(p, s)                         \
    if ((p == NULL) || IsBadWrite(p, sizeof(s))) {          \
        PromptInvalid("Bad write pointer: " STRINGIZE(p)); \
        SetError(E_INVALIDARG);                             \
        goto ErrorExit;                                     \
    }                                                       \
    if (p->cbSize != sizeof(s)) {                           \
        PromptInvalid("Structure is not expected size for " STRINGIZE(s)); \
        SetError(E_INVALIDARG);                             \
        goto ErrorExit;                                     \
    }
    
#define VALIDATE_STRING_PTR(p, cch)                         \
    if ((p == NULL) || IsBadString(p, cch)) {               \
        PromptInvalid("Bad string pointer: " STRINGIZE(p));        \
        SetError(E_INVALIDARG);                             \
        goto ErrorExit;                                     \
    }                                                       \

#define VALIDATE_STRINGA_PTR(p, cch)                        \
    if ((p == NULL) || IsBadStringA(p, cch)) {              \
        PromptInvalid("Bad string pointer: " STRINGIZE(p));        \
        SetError(E_INVALIDARG);                             \
        goto ErrorExit;                                     \
    }                                                       \

#define VALIDATE_STRINGW_PTR(p, cch)                        \
    if ((p == NULL) || IsBadStringW(p, cch)) {              \
        PromptInvalid("Bad string pointer: " STRINGIZE(p));        \
        SetError(E_INVALIDARG);                             \
        goto ErrorExit;                                     \
    }                                                       \


/***************************************************************************\
*****************************************************************************
*
* DirectUser CORE API
*
* InitGadgets() initializes a DirectUser Context.  The Context is valid in
* the Thread until it is explicitely destroyed with ::DeleteHandle() or the
* thread exits.
*
* NOTE: It is VERY important that the first time this function is called is
* NOT in DllMain() because we need to initialize the SRT.  DllMain()
* serializes access across all threads, so we will deadlock.  After the first
* Context is successfully created, additional Contexts can be created inside
* DllMain().
*
* <package name="Core"/>
*
*****************************************************************************
\***************************************************************************/

DUSER_API HDCONTEXT WINAPI
InitGadgets(
    IN  INITGADGET * pInit)
{
    Context * pctxNew;
    HRESULT hr;

    BEGIN_RECV_NOCONTEXT(HDCONTEXT, NULL);
    VALIDATE_READ_STRUCT(pInit, INITGADGET);
    VALIDATE_RANGE(pInit->nThreadMode, IGTM_MIN, IGTM_MAX);
    VALIDATE_RANGE(pInit->nMsgMode, IGMM_MIN, IGMM_MAX);
    VALIDATE_RANGE(pInit->nPerfMode, IGPM_MIN, IGPM_MAX);

    hr = ResourceManager::InitContextNL(pInit, FALSE, &pctxNew);
    SET_RETURN(hr, (HDCONTEXT) GetHandle(pctxNew));

    END_RECV_NOCONTEXT();
}


/***************************************************************************\
*
* InitGadgetComponent (API)
*
* InitGadgetComponent() initializes optional DirectUser/Gadget components
* that are not initialized by default.  It is usually best to call this
* function separately for each optional component to track individual
* failures when initializing.
*
* <return type="BOOL">      Components were successfully initialized.</>
* <see type="function">     CreateTransition</>
* <see type="function">     UninitializeGadgetComponent</>
*
\***************************************************************************/
DUSER_API BOOL WINAPI
InitGadgetComponent(
    IN  UINT nOptionalComponent)    // Optional component ID
{
    HRESULT hr;

    //
    // InitComponentNL() doesn't actually synchronize on a Context, but needs
    // a context to be initialized so that the threading model is determined.
    //

    BEGIN_RECV(BOOL, FALSE, ContextLock::edNone);
    VALIDATE_RANGE(nOptionalComponent, IGC_MIN, IGC_MAX);
    CHECK_MODIFY();

    hr = ResourceManager::InitComponentNL(nOptionalComponent);
    SET_RETURN(hr, TRUE);

    END_RECV();
}


/***************************************************************************\
*
* UninitGadgetComponent (API)
*
* UninitGadgetComponent() shuts down and cleans up optional DirectUser/Gadget
* components that were previously initialized.
*
* <return type="BOOL">      Components were successfully uninitialized.</>
* <see type="function">     InitGadgetComponent</>
*
\***************************************************************************/
DUSER_API BOOL WINAPI
UninitGadgetComponent(
    IN  UINT nOptionalComponent)    // Optional component
{
    HRESULT hr;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_RANGE(nOptionalComponent, IGC_MIN, IGC_MAX);
    CHECK_MODIFY();

    hr = ResourceManager::UninitComponentNL(nOptionalComponent);
    SET_RETURN(hr, TRUE);

    END_RECV();
}


/***************************************************************************\
*
* DeleteHandle (API)
*
* DeleteHandle() deletes any DirectUser handle by destroying the object and
* cleaning up associated resources.  After calling, the specified handle is
* no longer valid.  It may be used again later by another object.
*
* It is very important that only valid handles are given to ::DeleteHandle().
* Passing invalid handles (including previously deleted handles) will crash
* DirectUser.
*
* <return type="BOOL">      Object was successfully deleted.</>
* <see type="function">     CreateGadget</>
* <see type="function">     CreateTransition</>
* <see type="function">     CreateAction</>
*
\***************************************************************************/

DUSER_API BOOL WINAPI
DeleteHandle(
    IN  HANDLE h)                   // Handle to delete
{
    BEGIN_RECV_NOLOCK(BOOL, FALSE);
    BaseObject * pobj = BaseObject::ValidateHandle(h);
    if (pobj != NULL) {
        if (pobj->GetHandleType() == htContext) {
            //
            // When destroying a Context, we can't lock it or it won't get
            // destroyed.  This is okay since the ResourceManager serialize
            // the requests when it locks the thread-list.
            //

            pobj->xwDeleteHandle();
            retval = TRUE;
        } else {
            //
            // When destroying a normal object, lock the Context that the 
            // object resides in.
            //

            ContextLock cl;
            if (cl.LockNL(ContextLock::edDefer, pctxThread)) {
                ObjectLock ol(pobj);
                CHECK_MODIFY();

                pobj->xwDeleteHandle();
                retval = TRUE;
            }
        }
    }

    //
    // NOTE: The object may not be deleted yet if there are any outstanding
    // locks against it.  If it is a Gadget, it may be locked by one of the
    // message queues.
    //

    END_RECV_NOLOCK();
}


/***************************************************************************\
*
* DUserDeleteGadget (API)
*
* TODO: Document this API
*
\***************************************************************************/

DUSER_API HRESULT WINAPI
DUserDeleteGadget(
    IN  DUser::Gadget * pg)
{
    BEGIN_RECV_NOLOCK(HRESULT, E_INVALIDARG);

    MsgObject * pmo = MsgObject::CastMsgObject(pg);
    if (pmo == NULL) {
        PromptInvalid("Must specify a valid Gadget to delete");
        return E_INVALIDARG;
    }

    {
        //
        // When destroying a normal object, lock the Context that the 
        // object resides in.
        //

        ContextLock cl;
        if (cl.LockNL(ContextLock::edDefer, pctxThread)) {
            ObjectLock ol(pmo);
            CHECK_MODIFY();

            pmo->xwDeleteHandle();
            retval = S_OK;
        }
    }

    //
    // NOTE: The object may not be deleted yet if there are any outstanding
    // locks against it.  If it is a Gadget, it may be locked by one of the
    // message queues.
    //

    END_RECV_NOLOCK();
}


/***************************************************************************\
*
* IsStartDelete (API)
*
* TODO: Document this API
*
\***************************************************************************/

DUSER_API BOOL WINAPI
IsStartDelete(
    IN  HANDLE hobj, 
    IN  BOOL * pfStarted)
{
    BaseObject * pobj;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edNone);
    VALIDATE_WRITE_PTR(pfStarted);
    VALIDATE_OBJECT(obj);

    *pfStarted = pobj->IsStartDelete();
    retval = TRUE;

    END_RECV();
}


/***************************************************************************\
*
* GetContext (API)
*
* TODO: Document this API
*
\***************************************************************************/

DUSER_API HDCONTEXT WINAPI
GetContext(
    IN HANDLE h)
{
    BEGIN_RECV_NOCONTEXT(HDCONTEXT, NULL);

    // TODO: Totally rewrite this nonsense.
    {
        DuEventGadget * pgad;
        HGADGET hgad = (HGADGET) h;
        VALIDATE_EVENTGADGET_NOCONTEXT(gad);
        if (pgad != NULL) {
            retval = (HDCONTEXT) GetHandle(pgad->GetContext());
        }
    }

    END_RECV_NOCONTEXT();
}


/***************************************************************************\
*
* IsInsideContext (API)
*
* TODO: Document this API
*
\***************************************************************************/

DUSER_API BOOL WINAPI
IsInsideContext(HANDLE h)
{
    BOOL fInside = FALSE;

    if ((h != NULL) && IsInitThread()) {
        __try
        {
            DuEventGadget * pgad = ValidateBaseGadget((HGADGET) h);
            if (pgad != NULL) {
                Context * pctxThread = GetContext();
                fInside = (pctxThread == pgad->GetContext());
            } else if (BaseObject::ValidateHandle(h) != NULL) {
                fInside = TRUE;
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            fInside = FALSE;
        }
    }

    return fInside;
}


/***************************************************************************\
*
* CreateGadget (API)
*
* CreateGadget() creates a new Gadget of a given type.  Depending on the
* specific flags, different Gadgets will actually be instantiated.  Once a
* Gadget of a specific type has been created, it can not be changed into a
* different type without being deleted and recreated.
*
* <param name="nFlags">
*       Specifies both what type of Gadget to created and any creation-time
*       properties of that Gadget
*       <table item="Value" desc="Action">
*           GC_HWNDHOST     Creates a top-level Gadget that can host a
*                           GadgetTree inside the client area of a given
*                           HWND.  hParent must be a valid HWND.
*           GC_NCHOST       Creates a top-level Gadget that can host a
*                           GadgetTree inside the non-client area of a given
*                           HWND.  hParent must be a valid HWND.
*           GC_DXHOST       Creates a top-level Gadget that can host a
*                           GadgetTree inside a DXSurface.  hParent must be
*                           an LPCRECT specifying the area of the surface
*                           the tree will be displayed on.
*           GC_COMPLEX      Creates a sub-level Gadget that is optimized for
*                           a complex subtree below it containing many other
*                           Gadgets.  More expensive than a Simple Gadget,
*                           Complex Gadgets provide optimized region management
*                           and are more equivalent to HWND's in both
*                           functionality and design.  hParent must specify a
*                           valid HGADGET.
*           GC_SIMPLE       Creates a sub-level Gadget that is optimized for
*                           a simple subtree below it containing a few Gadgets.
*                           Simple Gadgets are cheaper to create and often use
*                           than Complex Gadgets if optimized region management
*                           is not needed.  hParent must specify a valid
*                           HGADGET.
*           GC_DETACHED     Creates a Gadget not integrated into a given Gadget
*                           tree.  Since they are separated from a tree,
*                           operations must be explicitely forwarded to
*                           Detached Gadgets during processing.  hParent is
*                           ignored.
*           GC_MESSAGE      Creates a message-only Gadget that can receive and
*                           send messages, but does not participate in any
*                           visual or interactive manner.  hParent is ignored.
*       </table>
* </param>
*
* <return type="HGADGET">   Returns a handle to the newly created Gadget
*                           or NULL if the creation failed.</>
* <see type="function">     DeleteHandle</>
*
\***************************************************************************/

DUSER_API HGADGET WINAPI
CreateGadget(
    IN  HANDLE hParent,             // Handle to parent
    IN  UINT nFlags,                // Creation flags
    IN  GADGETPROC pfnProc,         // Pointer to the Gadget procedure
    IN  void * pvGadgetData)        // User data associated with this Gadget
{
    BEGIN_RECV(HGADGET, NULL, ContextLock::edDefer);

    HRESULT hr;
    CREATE_INFO ci;
    ci.pfnProc  = pfnProc;
    ci.pvData   = pvGadgetData;

    switch (nFlags & GC_TYPE)
    {
    case GC_HWNDHOST:
        {
            HWND hwndContainer = (HWND) hParent;
            VALIDATE_HWND(wndContainer);

            DuRootGadget * pgadRoot;
            hr = GdCreateHwndRootGadget(hwndContainer, &ci, &pgadRoot);
            SET_RETURN(hr, (HGADGET) GetHandle(pgadRoot));
        }
        break;

    case GC_NCHOST:
        {
            HWND hwndContainer = (HWND) hParent;
            VALIDATE_HWND(wndContainer);

            DuRootGadget * pgadRoot;
            hr = GdCreateNcRootGadget(hwndContainer, &ci, &pgadRoot);
            SET_RETURN(hr, (HGADGET) GetHandle(pgadRoot));
        }
        break;

    case GC_DXHOST:
        {
            const RECT * prcContainerRect = (const RECT *) hParent;
            VALIDATE_READ_PTR_(prcContainerRect, sizeof(RECT));

            DuRootGadget * pgadRoot;
            hr = GdCreateDxRootGadget(prcContainerRect, &ci, &pgadRoot);
            SET_RETURN(hr, (HGADGET) GetHandle(pgadRoot));
        }
        break;

    case GC_COMPLEX:
        PromptInvalid("Complex Gadgets are not yet implemented");
        SetError(E_NOTIMPL);
        break;

    case GC_SIMPLE:
        {
            DuVisual * pgadParent;
            HGADGET hgadParent = (HGADGET) hParent;
            VALIDATE_VISUAL_OR_NULL(gadParent);

            if (pgadParent == NULL) {
                pgadParent = GetCoreSC()->pconPark->GetRoot();
                if (pgadParent == NULL) {
                    //
                    // The Parking Gadget has already been destroyed, so can not
                    // create a new child.
                    //

                    SetError(E_INVALIDARG);
                    goto ErrorExit;
                }
            }

            DuVisual * pgadChild;
            hr = pgadParent->AddChild(&ci, &pgadChild);
            SET_RETURN(hr, (HGADGET) GetHandle(pgadChild));
        }
        break;

    case GC_DETACHED:
        PromptInvalid("Detached Gadgets are not yet implemented");
        SetError(E_NOTIMPL);
        break;

    case GC_MESSAGE:
        {
            VALIDATE_VALUE(hParent, NULL);
            VALIDATE_CODE_PTR(pfnProc);    // MsgGadget's must have a GadgetProc

            DuListener * pgadNew;
            hr = DuListener::Build(&ci, &pgadNew);
            SET_RETURN(hr, (HGADGET) GetHandle(pgadNew));
        }
        break;

    default:
        PromptInvalid("Invalid Gadget type");
        SetError(E_INVALIDARG);
    }

    END_RECV();
}


/***************************************************************************\
*
* GetGadgetFocus (API)
*
* GetGadgetFocus() returns the Gadget with current keyboard focus or NULL
* if no Gadget currently has focus.
*
* <return type="HGADGET">   Gadget with keyboard focus.</>
* <see type="function">     SetGadgetFocus</>
* <see type="message">      GM_CHANGESTATE</>
*
\***************************************************************************/

DUSER_API HGADGET WINAPI
GetGadgetFocus()
{
    BEGIN_RECV(HGADGET, NULL, ContextLock::edNone);

    retval = (HGADGET) GetHandle(DuRootGadget::GetFocus());

    END_RECV();
}


/***************************************************************************\
*
* SetGadgetFocus (API)
*
* SetGadgetFocus() moves keyboard focus to the specified Gadget.  Both the
* current Gadget with keyboard focus and the Gadget being specified will be
* sent a GM_CHANGESTATE message with nCode=GSTATE_KEYBOARDFOCUS notifying of 
* the focus change.
*
* <return type="BOOL">      Focus was successfully moved.</>
* <see type="function">     GetGadgetFocus</>
* <see type="message">      GM_CHANGESTATE</>
*
\***************************************************************************/

DUSER_API BOOL WINAPI
SetGadgetFocus(
    IN  HGADGET hgadFocus)          // Gadget to receive focus.
{
    DuVisual * pgadFocus;
    DuRootGadget * pgadRoot;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_VISUAL(gadFocus);
    CHECK_MODIFY();

    //
    // TODO: Do we need to only allow the app to change focus if on the same
    // thread?  USER does this.
    //

    pgadRoot = pgadFocus->GetRoot();
    if (pgadRoot != NULL) {
        retval = pgadRoot->xdSetKeyboardFocus(pgadFocus);
    }

    END_RECV();
}


/***************************************************************************\
*
* IsGadgetParentChainStyle (API)
*
* IsGadgetParentChainStyle() checks if a Gadget parent change has the
* specified style bits set.
*
* <return type="BOOL">      Gadget was successfully checked.</>
* <see type="function">     GetGadgetStyle</>
* <see type="function">     SetGadgetStyle</>
*
\***************************************************************************/

DUSER_API BOOL WINAPI
IsGadgetParentChainStyle(
    IN  HGADGET hgad,               // Gadget to check visibility
    IN  UINT nStyle,                // Style bits to check
    OUT BOOL * pfChain,             // Chain state
    IN  UINT nFlags)                // Optional flags
{
    DuVisual * pgad;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edNone);
    VALIDATE_VISUAL(gad);
    VALIDATE_VALUE(nFlags, 0);
    VALIDATE_FLAGS(nStyle, GS_VALID);
    VALIDATE_WRITE_PTR_(pfChain, sizeof(BOOL));
    CHECK_MODIFY();

    *pfChain = pgad->IsParentChainStyle(nStyle);
    retval = TRUE;

    END_RECV();
}



/***************************************************************************\
*
* SetGadgetFillI (API)
*
* SetGadgetFillI() specifies an optional brush to fill the Gadget's
* background with when drawing.  The background will be filled before the
* Gadget is given the GM_PAINT message to draw.
*
* <return type="BOOL">      Fill was successfully set.</>
* <see type="function">     UtilDrawBlendRect</>
* <see type="message">      GM_PAINT</>
*
\***************************************************************************/

DUSER_API BOOL WINAPI
SetGadgetFillI(
    IN  HGADGET hgadChange,         // Gadget to change
    IN  HBRUSH hbrFill,             // Brush to fill with or NULL to remove
    IN  BYTE bAlpha,                // Alpha level to apply brush
    IN  int w,                      // Optional width of brush when
                                    // alpha-blending or 0 for default
    IN  int h)                      // Optional height of brush when
                                    // alpha-blending or 0 for default
{
    DuVisual * pgadChange;
    HRESULT hr;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_VISUAL(gadChange);
    CHECK_MODIFY();

    hr = pgadChange->SetFill(hbrFill, bAlpha, w, h);
    SET_RETURN(hr, TRUE);

    END_RECV();
}


/***************************************************************************\
*
* SetGadgetFillF (API)
*
* SetGadgetFillF() specifies an optional brush to fill the Gadget's
* background with when drawing.  The background will be filled before the
* Gadget is given the GM_PAINT message to draw.
*
* <return type="BOOL">      Fill was successfully set.</>
* <see type="function">     UtilDrawBlendRect</>
* <see type="message">      GM_PAINT</>
*
\***************************************************************************/

DUSER_API BOOL WINAPI
SetGadgetFillF(
    IN  HGADGET hgadChange,         // Gadget to change
    IN  Gdiplus::Brush * pgpbr)     // Brush to fill with or NULL to remove
{
    DuVisual * pgadChange;
    HRESULT hr;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_VISUAL(gadChange);
    CHECK_MODIFY();

    hr = pgadChange->SetFill(pgpbr);
    SET_RETURN(hr, TRUE);

    END_RECV();
}


/***************************************************************************\
*
* GetGadgetScale (API)
*
* GetGadgetScale() returns the Gadget's scaling factor.  If the Gadget is
* not scaled, the factors will be X=1.0, Y=1.0.
*
* <return type="BOOL">      Successfully returned scaling factor</>
* <see type="function">     SetGadgetScale</>
* <see type="function">     GetGadgetRotation</>
* <see type="function">     SetGadgetRotation</>
* <see type="function">     GetGadgetRect</>
* <see type="function">     SetGadgetRect</>
*
\***************************************************************************/

DUSER_API BOOL WINAPI
GetGadgetScale(
    IN  HGADGET hgad,               // Gadget to check
    OUT float * pflX,               // Horizontal scaling factor
    OUT float * pflY)               // Vertical scaling factor
{
    DuVisual * pgad;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edNone);
    VALIDATE_VISUAL(gad);
    VALIDATE_WRITE_PTR_(pflX, sizeof(float));
    VALIDATE_WRITE_PTR_(pflY, sizeof(float));

    pgad->GetScale(pflX, pflY);
    retval = TRUE;

    END_RECV();
}


/***************************************************************************\
*
* SetGadgetScale (API)
*
* SetGadgetScale() changes the specified Gadget's scaling factor.  Scaling
* is determined from the upper-left corner of the Gadget and is applied
* dynamically during painting and hit-testing.  The Gadget's logical
* rectangle set by SetGadgetRect() does not change.
*
* When scaling is applied to a Gadget, the entire subtree of that Gadget is
* scaled.  To remove any scaling factor, use X=1.0, Y=1.0.
*
* <return type="BOOL">      Successfully changed scaling factor</>
* <see type="function">     GetGadgetScale</>
* <see type="function">     GetGadgetRotation</>
* <see type="function">     SetGadgetRotation</>
* <see type="function">     GetGadgetRect</>
* <see type="function">     SetGadgetRect</>
*
\***************************************************************************/

DUSER_API BOOL WINAPI
SetGadgetScale(
    IN  HGADGET hgadChange,         // Gadget to change
    IN  float flX,                  // New horizontal scaling factor
    IN  float flY)                  // New vertical scaling factor
{
    DuVisual * pgadChange;
    HRESULT hr;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_VISUAL(gadChange);
    CHECK_MODIFY();

    hr = pgadChange->xdSetScale(flX, flY);
    SET_RETURN(hr, TRUE);

    END_RECV();
}


/***************************************************************************\
*
* GetGadgetRotation (API)
*
* GetGadgetRotation() returns the Gadget's rotation factor in radians.  If
* a Gadget is not rotated, the factor will be 0.0.
*
* <return type="BOOL">      Successfully returned rotation factor</>
* <see type="function">     GetGadgetScale</>
* <see type="function">     SetGadgetScale</>
* <see type="function">     SetGadgetRotation</>
* <see type="function">     GetGadgetRect</>
* <see type="function">     SetGadgetRect</>
*
\***************************************************************************/

DUSER_API BOOL WINAPI
GetGadgetRotation(
    IN  HGADGET hgad,               // Gadget to check
    OUT float * pflRotationRad)     // Rotation factor in radians
{
    DuVisual * pgad;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edNone);
    VALIDATE_VISUAL(gad);
    VALIDATE_WRITE_PTR_(pflRotationRad, sizeof(float));

    *pflRotationRad = pgad->GetRotation();
    retval = TRUE;

    END_RECV();
}


/***************************************************************************\
*
* SetGadgetRotation (API)
*
* SetGadgetRotation() changes the specified Gadget's rotation factor in
* radians.  Scaling is determined from the upper-left corner of the Gadget
* and is applied dynamically during painting and hit-testing.  The Gadget's
* logical rectangle set by SetGadgetRect() does not change.
*
* When rotation is applied to a Gadget, the entire subtree of that Gadget is
* rotated.  To remove any rotation factor, use 0.0.
*
* <return type="BOOL">      Successfully changed scaling factor</>
* <see type="function">     GetGadgetScale</>
* <see type="function">     SetGadgetScale</>
* <see type="function">     GetGadgetRotation</>
* <see type="function">     GetGadgetRect</>
* <see type="function">     SetGadgetRect</>
*
\***************************************************************************/

DUSER_API BOOL WINAPI
SetGadgetRotation(
    IN  HGADGET hgadChange,         // Gadget to change
    IN  float flRotationRad)        // New rotation factor in radians
{
    DuVisual * pgadChange;
    HRESULT hr;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_VISUAL(gadChange);
    CHECK_MODIFY();

    hr = pgadChange->xdSetRotation(flRotationRad);
    SET_RETURN(hr, TRUE);

    END_RECV();
}


//------------------------------------------------------------------------------
DUSER_API BOOL WINAPI
GetGadgetCenterPoint(HGADGET hgad, float * pflX, float * pflY)
{
    DuVisual * pgad;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edNone);
    VALIDATE_VISUAL(gad);
    VALIDATE_WRITE_PTR_(pflX, sizeof(float));
    VALIDATE_WRITE_PTR_(pflY, sizeof(float));

    pgad->GetCenterPoint(pflX, pflY);
    retval = TRUE;

    END_RECV();
}


//------------------------------------------------------------------------------
DUSER_API BOOL WINAPI
SetGadgetCenterPoint(HGADGET hgadChange, float flX, float flY)
{
    DuVisual * pgadChange;
    HRESULT hr;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_VISUAL(gadChange);
    CHECK_MODIFY();

    hr = pgadChange->xdSetCenterPoint(flX, flY);
    SET_RETURN(hr, TRUE);

    END_RECV();
}


//------------------------------------------------------------------------------
DUSER_API BOOL WINAPI  
GetGadgetBufferInfo(
    IN  HGADGET hgad,               // Gadget to check
    OUT BUFFER_INFO * pbi)          // Buffer information
{
    DuVisual * pgad;
    HRESULT hr;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edNone);
    VALIDATE_VISUAL(gad);
    VALIDATE_WRITE_STRUCT(pbi, BUFFER_INFO);
    VALIDATE_FLAGS(pbi->nMask, GBIM_VALID);

    if (!pgad->IsBuffered()) {
        PromptInvalid("Gadget is not GS_BUFFERED");
        SetError(DU_E_NOTBUFFERED);
        goto ErrorExit;
    }

    hr = pgad->GetBufferInfo(pbi);
    SET_RETURN(hr, TRUE);

    END_RECV();
}


//------------------------------------------------------------------------------
DUSER_API BOOL WINAPI  
SetGadgetBufferInfo(
    IN  HGADGET hgadChange,         // Gadget to change
    IN  const BUFFER_INFO * pbi)    // Buffer information
{
    DuVisual * pgadChange;
    HRESULT hr;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_VISUAL(gadChange);
    VALIDATE_READ_STRUCT(pbi, BUFFER_INFO);
    VALIDATE_FLAGS(pbi->nMask, GBIM_VALID);

    if (!pgadChange->IsBuffered()) {
        PromptInvalid("Gadget is not GS_BUFFERED");
        SetError(DU_E_NOTBUFFERED);
        goto ErrorExit;
    }

    hr = pgadChange->SetBufferInfo(pbi);
    SET_RETURN(hr, TRUE);

    END_RECV();
}


//------------------------------------------------------------------------------
DUSER_API BOOL WINAPI  
GetGadgetRgn(
    IN  HGADGET hgad,               // Gadget to get region of
    IN  UINT nRgnType,              // Type of region
    OUT HRGN hrgn,                  // Specified region
    IN  UINT nFlags)                // Modifying flags
{
    DuVisual * pgad;
    HRESULT hr;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edNone);
    VALIDATE_VISUAL(gad);
    VALIDATE_RANGE(nRgnType, GRT_MIN, GRT_MAX);
    VALIDATE_REGION(rgn);
    
    hr = pgad->GetRgn(nRgnType, hrgn, nFlags);
    SET_RETURN(hr, TRUE);

    END_RECV();
}


//------------------------------------------------------------------------------
DUSER_API BOOL WINAPI
GetGadgetRootInfo(
    IN  HGADGET hgadRoot,           // RootGadget to modify
    IN  ROOT_INFO * pri)      // Information
{
    DuRootGadget * pgadRoot;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edNone);
    VALIDATE_ROOTGADGET(gadRoot);
    VALIDATE_WRITE_STRUCT(pri, ROOT_INFO);
    VALIDATE_FLAGS(pri->nMask, GRIM_VALID);

    pgadRoot->GetInfo(pri);
    retval = TRUE;

    END_RECV();
}


//------------------------------------------------------------------------------
DUSER_API BOOL WINAPI
SetGadgetRootInfo(
    IN  HGADGET hgadRoot,           // RootGadget to modify
    IN  const ROOT_INFO * pri)      // Information
{
    DuRootGadget * pgadRoot;
    HRESULT hr;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_ROOTGADGET(gadRoot);
    VALIDATE_READ_STRUCT(pri, ROOT_INFO);
    VALIDATE_FLAGS(pri->nMask, GRIM_VALID);
    VALIDATE_FLAGS(pri->nOptions, GRIO_VALID);
    VALIDATE_RANGE(pri->nSurface, GSURFACE_MIN, GSURFACE_MAX);
    VALIDATE_RANGE(pri->nDropTarget, GRIDT_MIN, GRIDT_MAX);

    hr = pgadRoot->SetInfo(pri);
    SET_RETURN(hr, TRUE);

    END_RECV();
}


//------------------------------------------------------------------------------
DUSER_API HRESULT WINAPI
DUserSendMethod(
    IN  MethodMsg * pmsg)               // Message to send
{
    Context * pctxGad, * pctxSend;
    HGADGET hgadMsg;
    MsgObject * pmo;
    UINT nResult;
    HRESULT hr;
    UINT hm;

    //
    // Validation for DUserSendMethod() is a little unusual because the
    // caller doesn't need to be in the same Context as the Gadget itself.  This
    // means we need to get the Context from the Gadget and not use TLS.
    //
    // The Caller must be initialized, but we WON'T take the context-lock.
    // TODO: Investigate whether we should actually do this because it may
    // allow us to take off the lock on the DUserHeap.
    //
    // NOTE: This code has been HIGHLY optimized so that in-context Send 
    // messages will be as fast as possible.
    //

    nResult = DU_S_NOTHANDLED;
    if ((pmsg == NULL) || ((hgadMsg = pmsg->hgadMsg) == NULL) || (pmsg->nMsg >= GM_EVENT)) {
        PromptInvalid("Invalid parameters to SendGadgetMethod()");
        hr = E_INVALIDARG;
        goto Exit;
    }

    pmo = reinterpret_cast<MsgObject *>(hgadMsg);
    hm  = pmo->GetHandleMask();
    if (!TestFlag(hm, hmMsgObject)) {
        PromptInvalid("Object is not a valid Gadget");
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (TestFlag(hm, hmEventGadget)) {
        DuEventGadget * pgadMsg = static_cast<DuEventGadget *>(pmo);
        pctxSend    = RawGetContext();
        pctxGad     = pgadMsg->GetContext();
        AssertMsg(pctxGad != NULL, "Fully created DuEventGadget must have a Context");

        if (pctxSend->IsOrphanedNL() || pctxGad->IsOrphanedNL()) {
            PromptInvalid("Illegally using an orphaned Context");
            hr = E_INVALIDARG;
            goto Exit;
        }

        if (pctxSend == pctxGad) {
            pmo->InvokeMethod(pmsg);
            hr = S_OK;
            goto Exit;
        } else {
            hr = GetCoreSC(pctxSend)->xwSendMethodNL(GetCoreSC(pctxGad), pmsg, pmo);
        }
    } else {
        //
        // For non-BaseGadgets, use the current context.  This means that we can 
        // invoke directly.
        //

        pmo->InvokeMethod(pmsg);
        hr = S_OK;
    }

Exit:
    return hr;
}


/***************************************************************************\
*
* SendGadgetEvent (API)
*
* SendGadgetEvent() sends a message to the specified Gadget.  The function
* calls the Gadget procedure and does not return until the Gadget has
* processed the message.
*
* <param name="pmsg">
*       Several members of the GMSG must be previously filled to correctly send
*       the message to the specified Gadget.
*       <table item="Field" desc="Description">
*           cbSize          Size of the message being sent in bytes.
*           nMsg            ID of the message.
*           hgadMsg         Gadget that the message is being sent to.
*           result          Default result value.
*       </table>
* </param>
*
* <param nane="nFlags">
*       Specifies optional flags to modify how the message is sent to the Gadget.
*       <table item="Value" desc="Action">
*           SGM_BUBBLE      The message will be fully routed and bubbled inside
*                           the Gadget Tree.  If this flag is not specified, the
*                           message will only be sent directly to the Gadget and
*                           any attached Message Handlers.
*       </table>
* </param>
*
* <return type="UINT">
*       Return value specifying how message was handled:
*       <table item="Value" desc="Action">
*           GPR_COMPLETE    The message was completely handled by a Gadget
*                           in the processing loop.
*           GPR_PARTIAL     The message was partially handled by one or
*                           more Gadget in the processing loop, but was never
*                           completely handled.
*           GPR_NOTHANDLED  The message was never handled by any Gadgets in
*                           the processing loop.
*       </table>
* </return>
*
* <see type="function">     RegisterGadgetMessage</>
* <see type="function">     RegisterGadgetMessageString</>
* <see type="function">     UnregisterGadgetMessage</>
* <see type="function">     UnregisterGadgetMessageString</>
* <see type="function">     AddGadgetMessageHandler</>
* <see type="function">     RemoveGadgetMessageHandler</>
* <see type="struct">       GMSG</>
* <see type="article">      GadgetMessaging</>
*
\***************************************************************************/

DUSER_API HRESULT WINAPI
DUserSendEvent(
    IN  EventMsg * pmsg,          // Message to send
    IN  UINT nFlags)                // Optional flags to modifying sending
{
    Context * pctxGad, * pctxSend;
    HGADGET hgadMsg;
    DuEventGadget * pgad;
    HRESULT nResult;
    UINT hm;

    //
    // Validation for SendGadgetEvent() is a little unusual because the
    // caller doesn't need to be in the same Context as the Gadget itself.  This
    // means we need to get the Context from the Gadget and not use TLS.
    //
    // The Caller must be initialized, but we WON'T take the context-lock.
    // TODO: Investigate whether we should actually do this because it may
    // allow us to take off the lock on the DUserHeap.
    //
    // NOTE: This code has been HIGHLY optimized so that in-context Send 
    // messages will be as fast as possible.
    //

    nResult = E_INVALIDARG;
    if ((pmsg == NULL) || ((hgadMsg = pmsg->hgadMsg) == NULL) || (pmsg->nMsg < GM_EVENT)) {
        PromptInvalid("Invalid parameters to SendGadgetEvent()");
        goto Error;
    }

    pgad    = reinterpret_cast<DuEventGadget *>(hgadMsg);
    hm      = pgad->GetHandleMask();
    if (!TestFlag(hm, hmEventGadget)) {
        PromptInvalid("Object is not a valid BaseGadget");
        goto Error;
    }

    pctxSend    = RawGetContext();
    pctxGad     = pgad->GetContext();
    AssertMsg(pctxGad != NULL, "Fully created DuEventGadget must have a Context");

    if (pctxSend->IsOrphanedNL() || pctxGad->IsOrphanedNL()) {
        PromptInvalid("Illegally using an orphaned Context");
        goto Error;
    }

    if (pctxSend == pctxGad) {
        const GPCB & cb = pgad->GetCallback();
        if (TestFlag(nFlags, SGM_FULL) && TestFlag(hm, hmVisual)) {
            nResult = cb.xwInvokeFull((const DuVisual *) pgad, pmsg, 0);
        } else {
            nResult = cb.xwInvokeDirect(pgad, pmsg, 0);
        }
    } else {
        nResult = GetCoreSC(pctxSend)->xwSendEventNL(GetCoreSC(pctxGad), pmsg, pgad, nFlags);
    }

    return nResult;

Error:
    return E_INVALIDARG;
}


//------------------------------------------------------------------------------
DUSER_API HRESULT WINAPI
DUserPostMethod(
    IN  MethodMsg * pmsg)               // Message to post
{
    Context * pctxGad, * pctxSend;
    HGADGET hgadMsg;
    MsgObject * pmo;
    UINT nResult;
    HRESULT hr;
    UINT hm;

    //
    // Validation for PostGadgetEvent() is a little unusual because the
    // caller doesn't need to be in the same Context as the Gadget itself.  This
    // means we need to get the Context from the Gadget and not use TLS.
    //

    nResult = DU_S_NOTHANDLED;
    if ((pmsg == NULL) || ((hgadMsg = pmsg->hgadMsg) == NULL) || (pmsg->nMsg >= GM_EVENT)) {
        PromptInvalid("Invalid parameters to DUserPostMethod()");
        hr = E_INVALIDARG;
        goto Exit;
    }

    pmo = reinterpret_cast<MsgObject *>(hgadMsg);
    hm  = pmo->GetHandleMask();
    if (!TestFlag(hm, hmMsgObject)) {
        PromptInvalid("Object is not a valid Gadget");
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (TestFlag(hm, hmEventGadget)) {
        DuEventGadget * pgad = static_cast<DuEventGadget *>(pmo);
        pctxSend    = RawGetContext();
        pctxGad     = pgad->GetContext();
        AssertMsg(pctxGad != NULL, "Fully created Gadgets must have a Context");
    } else {
        //
        // For non-BaseGadgets, use the current context.
        //

        pctxSend = pctxGad = GetContext();
        if (pctxGad == NULL) {
            PromptInvalid("Must initialize Context before using thread");
            hr = DU_E_NOCONTEXT;
            goto Exit;
        }
    }

    if (pctxSend->IsOrphanedNL() || pctxGad->IsOrphanedNL()) {
        PromptInvalid("Illegally using an orphaned Context");
        hr = E_INVALIDARG;
        goto Exit;
    }

    hr = GetCoreSC(pctxSend)->PostMethodNL(GetCoreSC(pctxGad), pmsg, pmo);

Exit:
    return hr;
}


/***************************************************************************\
*
* DUserPostEvent (API)
*
* DUserPostEvent() posts a message to the specified Gadget.  The function
* calls the Gadget procedure and returns after the message has bee successfully
* posted to the owning messsage queue.
*
* <param name="pmsg">
*       Several members of the GMSG must be previously filled to correctly send
*       the message to the specified Gadget.
*       <table item="Field" desc="Description">
*           cbSize          Size of the message being sent in bytes.
*           nMsg            ID of the message.
*           hgadMsg         Gadget that the message is being sent to.
*           result          Default result value.
*       </table>
* </param>
*
* <param nane="nFlags">
*       Specifies optional flags to modify how the message is sent to the Gadget.
*       <table item="Value" desc="Action">
*           SGM_BUBBLE      The message will be fully routed and bubbled inside
*                           the Gadget Tree.  If this flag is not specified, the
*                           message will only be sent directly to the Gadget and
*                           any attached Message Handlers.
*       </table>
* </param>
*
* <return type="BOOL">
*       Message was successfully posted to the destination Gadget's queue.
* </return>
*
* <see type="function">     SendGadgetEvent</>
* <see type="function">     RegisterGadgetMessage</>
* <see type="function">     RegisterGadgetMessageString</>
* <see type="function">     UnregisterGadgetMessage</>
* <see type="function">     UnregisterGadgetMessageString</>
* <see type="function">     AddGadgetMessageHandler</>
* <see type="function">     RemoveGadgetMessageHandler</>
* <see type="struct">       GMSG</>
* <see type="article">      GadgetMessaging</>
*
\***************************************************************************/

DUSER_API HRESULT WINAPI
DUserPostEvent(
    IN  EventMsg * pmsg,          // Message to post
    IN  UINT nFlags)                // Optional flags modifiying posting
{
    Context * pctxGad;
    HGADGET hgad;
    DuEventGadget * pgad;
    HRESULT hr;

    //
    // Validation for PostGadgetEvent() is a little unusual because the
    // caller doesn't need to be in the same Context as the Gadget itself.  This
    // means we need to get the Context from the Gadget and not use TLS.
    //

    BEGIN_RECV_NOCONTEXT(BOOL, FALSE);
    VALIDATE_READ_PTR_(pmsg, pmsg->cbSize);
    VALIDATE_FLAGS(nFlags, SGM_VALID);

    if (pmsg->nMsg < GM_EVENT) {
        PromptInvalid("Can not post private messages");
        SetError(E_INVALIDARG);
        goto ErrorExit;
    }

    if (!IsInitContext()) {
        PromptInvalid("Must initialize Context before using thread");
        SetError(DU_E_NOCONTEXT);
        goto ErrorExit;
    }

    hgad = pmsg->hgadMsg;
    VALIDATE_EVENTGADGET_NOCONTEXT(gad);
    pctxGad = pgad->GetContext();

    if (pctxGad->IsOrphanedNL()) {
        PromptInvalid("Illegally using an orphaned Context");
        goto ErrorExit;
    }

    hr = GetCoreSC()->PostEventNL(GetCoreSC(pctxGad), pmsg, pgad, nFlags);
    SET_RETURN(hr, TRUE);

    END_RECV_NOCONTEXT();
}


//------------------------------------------------------------------------------
DUSER_API BOOL WINAPI  
FireGadgetMessages(
    IN  FGM_INFO * rgFGM,           // Collection of messsages to fire
    IN  int cMsgs,                  // Number of messages
    IN  UINT idQueue)               // Queue to send messages
{
    Context * pctxGad, * pctxCheck;
    HGADGET hgad;
    DuEventGadget * pgad;
    HRESULT hr;
    int idx;

    //
    // Validation for FireGadgetMessages() is a little unusual because the
    // caller doesn't need to be in the same Context as the Gadget itself.  This
    // means we need to get the Context from the Gadget and not use TLS.
    //

    BEGIN_RECV_NOCONTEXT(BOOL, FALSE);
    if (cMsgs <= 0) {
        PromptInvalid("Must specify a valid number of messages to process.");
        SetError(E_INVALIDARG);
        goto ErrorExit;
    }

    hgad = rgFGM[0].pmsg->hgadMsg;
    VALIDATE_EVENTGADGET_NOCONTEXT(gad);
    pctxGad = pgad->GetContext();

    for (idx = 0; idx < cMsgs; idx++) {
        FGM_INFO & fgm = rgFGM[idx];

        EventMsg * pmsg = fgm.pmsg;
        VALIDATE_READ_PTR_(pmsg, pmsg->cbSize);
        VALIDATE_FLAGS(fgm.nFlags, SGM_VALID);
        if (pmsg->nMsg <= 0) {
            PromptInvalid("Can not post private messages");
            SetError(E_INVALIDARG);
            goto ErrorExit;
        }

        if (TestFlag(fgm.nFlags, SGM_RECEIVECONTEXT)) {
            PromptInvalid("Can not use SGM_RECEIVECONTEXT with FireGadgetMessage");
            SetError(E_INVALIDARG);
            goto ErrorExit;
        }

        hgad = pmsg->hgadMsg;
        VALIDATE_EVENTGADGET_NOCONTEXT(gad);
        pctxCheck = pgad->GetContext();
        if (pctxCheck != pctxGad) {
            PromptInvalid("All Gadgets must be inside the same Context");
            SetError(DU_E_INVALIDCONTEXT);
            goto ErrorExit;
        }


        //
        // Store the validated Gadget back so that it doesn't need to be 
        // revalidated.
        //

        fgm.pvReserved = pgad;
    }

    hr = GetCoreSC()->xwFireMessagesNL(GetCoreSC(pctxGad), rgFGM, cMsgs, idQueue);
    SET_RETURN(hr, TRUE);

    END_RECV_NOCONTEXT();
}


/***************************************************************************\
*
* GetMessageEx (API)
*
\***************************************************************************/

DUSER_API BOOL WINAPI
GetMessageExA(
    IN  LPMSG lpMsg,
    IN  HWND hWnd,
    IN  UINT wMsgFilterMin,
    IN  UINT wMsgFilterMax)
{
    BEGIN_RECV_NOCONTEXT(BOOL, FALSE);

    Context * pctxThread = RawGetContext();
    if (pctxThread == NULL) {
        retval = GetMessageA(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);
    } else {
        retval = GetCoreSC(pctxThread)->xwProcessNL(lpMsg, hWnd,
                wMsgFilterMin, wMsgFilterMax, PM_REMOVE, CoreSC::smGetMsg | CoreSC::smAnsi);
    }

    END_RECV_NOCONTEXT();
}


DUSER_API BOOL WINAPI
GetMessageExW(
    IN  LPMSG lpMsg,
    IN  HWND hWnd,
    IN  UINT wMsgFilterMin,
    IN  UINT wMsgFilterMax)
{
    BEGIN_RECV_NOCONTEXT(BOOL, FALSE);

    Context * pctxThread = RawGetContext();
    if (pctxThread == NULL) {
        retval = GetMessageW(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);
    } else {
        retval = GetCoreSC(pctxThread)->xwProcessNL(lpMsg, hWnd,
                wMsgFilterMin, wMsgFilterMax, PM_REMOVE, CoreSC::smGetMsg);
    }

    END_RECV_NOCONTEXT();
}


/***************************************************************************\
*
* PeekMessageEx (API)
*
\***************************************************************************/

DUSER_API BOOL WINAPI
PeekMessageExA(
    IN  LPMSG lpMsg,
    IN  HWND hWnd,
    IN  UINT wMsgFilterMin,
    IN  UINT wMsgFilterMax,
    IN  UINT wRemoveMsg)
{
    BEGIN_RECV_NOCONTEXT(BOOL, FALSE);

    Context * pctxThread = RawGetContext();
    if (pctxThread == NULL) {
        retval = PeekMessageA(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);
    } else {
        retval = GetCoreSC(pctxThread)->xwProcessNL(lpMsg, hWnd,
                wMsgFilterMin, wMsgFilterMax, wRemoveMsg, CoreSC::smAnsi);
    }

    END_RECV_NOCONTEXT();
}


DUSER_API BOOL WINAPI
PeekMessageExW(
    IN  LPMSG lpMsg,
    IN  HWND hWnd,
    IN  UINT wMsgFilterMin,
    IN  UINT wMsgFilterMax,
    IN  UINT wRemoveMsg)
{
    BEGIN_RECV_NOCONTEXT(BOOL, FALSE);

    Context * pctxThread = RawGetContext();
    if (pctxThread == NULL) {
        retval = PeekMessageW(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);
    } else {
        retval = GetCoreSC(pctxThread)->xwProcessNL(lpMsg, hWnd,
                wMsgFilterMin, wMsgFilterMax, wRemoveMsg, 0);
    }

    END_RECV_NOCONTEXT();
}


/***************************************************************************\
*
* WaitMessageEx (API)
*
\***************************************************************************/

DUSER_API BOOL WINAPI
WaitMessageEx()
{
    BEGIN_RECV_NOCONTEXT(BOOL, FALSE);

    Context * pctxThread = RawGetContext();
    if (pctxThread == NULL) {
        retval = WaitMessage();
    } else {
        AssertInstance(pctxThread);
        GetCoreSC(pctxThread)->WaitMessage();
        retval = TRUE;
    }

    END_RECV_NOCONTEXT();
}


/***************************************************************************\
*
* RegisterGadgetMessage (API)
*
* RegisterGadgetMessage() defines a new private Gadget message that is
* guaranteed to be unique throughout the process.  This MSGID can be used
* when calling SendGadgetEvent or PostGadgetEvent.  The MSGID is only
* valid for the lifetime of the process.
*
* <remarks>
* Multiple calls to RegisterGadgetMessage() with the same ID will produce
* the same MSGID.
*
* RegisterGadgetMessage() differs in use from RegisterWindowMessage() in
* that Gadgets are encouraged to use RegisterGadgetMessage() for all
* private messages.  This helps with version compatibility problems where
* newer Gadget control implementations may use additional message and could
* potentially overrun any static MSGID assignments.
*
* The MSGID's returned from RegisterGadgetMessage() and
* RegisterGadgetMessageString() are guaranteed to not conflict with each
* other.  However, RegisterGadgetMessage() is the preferred mechanism for
* registering private messages because of the reduced likelihood of
* ID conflicts.
* </remarks>
*
* <return type="MSGID">     ID of new message or 0 if failed.</>
* <see type="function">     SendGadgetEvent</>
* <see type="function">     RegisterGadgetMessageString</>
* <see type="function">     UnregisterGadgetMessage</>
* <see type="function">     UnregisterGadgetMessageString</>
* <see type="function">     AddGadgetMessageHandler</>
* <see type="function">     RemoveGadgetMessageHandler</>
* <see type="struct">       GMSG</>
* <see type="article">      GadgetMessaging</>
*
\***************************************************************************/

DUSER_API MSGID WINAPI
RegisterGadgetMessage(
    IN  const GUID * pguid)         // Unique GUID of message to register
{
    HRESULT hr;
    MSGID msgid;

    BEGIN_RECV_NOCONTEXT(MSGID, PRID_Unused);

    hr = DuEventPool::RegisterMessage(pguid, ptGlobal, &msgid);
    SET_RETURN(hr, msgid);

    END_RECV_NOCONTEXT();
}


/***************************************************************************\
*
* RegisterGadgetMessageString (API)
*
* RegisterGadgetMessageString() defines a new private Gadget message that is
* guaranteed to be unique throughout the process.  This MSGID can be used
* when calling SendGadgetEvent() or PostGadgetEvent().  The MSGID is only
* valid for the lifetime of the process.
*
* <remarks>
* See RegisterGadgetMessage() for more information about MSGID's.
* </remarks>
*
* <return type="MSGID">     ID of new message or 0 if failed.</>
* <see type="function">     SendGadgetEvent</>
* <see type="function">     RegisterGadgetMessage</>
* <see type="function">     UnregisterGadgetMessage</>
* <see type="function">     UnregisterGadgetMessageString</>
* <see type="function">     AddGadgetMessageHandler</>
* <see type="function">     RemoveGadgetMessageHandler</>
* <see type="struct">       GMSG</>
* <see type="article">      GadgetMessaging</>
*
\***************************************************************************/

DUSER_API MSGID WINAPI
RegisterGadgetMessageString(
    IN  LPCWSTR pszName)            // Unique string ID of message to register
{
    HRESULT hr;
    MSGID msgid;

    BEGIN_RECV_NOCONTEXT(MSGID, PRID_Unused);
    VALIDATE_STRINGW_PTR(pszName, 128);

    hr = DuEventPool::RegisterMessage(pszName, ptGlobal, &msgid);
    SET_RETURN(hr, msgid);

    END_RECV_NOCONTEXT();
}


/***************************************************************************\
*
* UnregisterGadgetMessage (API)
*
* UnregisterGadgetMessage() decreases the reference count of a private
* message by one.  When the reference count reaches 0, resources allocated
* to store information about that private message are released, and the
* MSGID is no longer valid.
*
* <return type="BOOL">      Message was successfully unregistered.</>
* <see type="function">     SendGadgetEvent</>
* <see type="function">     RegisterGadgetMessage</>
* <see type="function">     RegisterGadgetMessageString</>
* <see type="function">     UnregisterGadgetMessageString</>
* <see type="function">     AddGadgetMessageHandler</>
* <see type="function">     RemoveGadgetMessageHandler</>
* <see type="struct">       GMSG</>
* <see type="article">      GadgetMessaging</>
*
\***************************************************************************/

DUSER_API BOOL WINAPI
UnregisterGadgetMessage(
    IN  const GUID * pguid)         // Unique GUID of message to unregister
{
    HRESULT hr;

    BEGIN_RECV_NOCONTEXT(BOOL, FALSE);

    hr = DuEventPool::UnregisterMessage(pguid, ptGlobal);
    SET_RETURN(hr, TRUE);

    END_RECV_NOCONTEXT();
}


/***************************************************************************\
*
* UnregisterGadgetMessageString (API)
*
* UnregisterGadgetMessageString() decreases the reference count of a private
* message by one.  When the reference count reaches 0, resources allocated
* to store information about that private message are released, and the
* MSGID is no longer valid.
*
* <return type="BOOL">      Message was successfully unregistered.</>
* <see type="function">     SendGadgetEvent</>
* <see type="function">     RegisterGadgetMessage</>
* <see type="function">     RegisterGadgetMessageString</>
* <see type="function">     UnregisterGadgetMessage</>
* <see type="function">     AddGadgetMessageHandler</>
* <see type="function">     RemoveGadgetMessageHandler</>
* <see type="struct">       GMSG</>
* <see type="article">      GadgetMessaging</>
*
\***************************************************************************/

DUSER_API BOOL WINAPI
UnregisterGadgetMessageString(
    IN  LPCWSTR pszName)            // Unique string ID of message to register
{
    HRESULT hr;

    BEGIN_RECV_NOCONTEXT(BOOL, FALSE);
    VALIDATE_STRINGW_PTR(pszName, 128);

    hr = DuEventPool::UnregisterMessage(pszName, ptGlobal);
    SET_RETURN(hr, TRUE);

    END_RECV_NOCONTEXT();
}


//------------------------------------------------------------------------------
DUSER_API BOOL WINAPI
FindGadgetMessages(
    IN  const GUID ** rgpguid,      // GUID's of messages to find
    OUT MSGID * rgnMsg,             // MSGID's of corresponding to messages
    IN  int cMsgs)                  // Number of messages
{
    HRESULT hr;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edNone);
    VALIDATE_RANGE(cMsgs, 1, 1000); // Ensure don't have an excessive number of lookups

    hr = DuEventPool::FindMessages(rgpguid, rgnMsg, cMsgs, ptGlobal);
    SET_RETURN(hr, TRUE);

    END_RECV();
}


/***************************************************************************\
*
* AddGadgetMessageHandler (API)
*
* AddGadgetMessageHandler() adds a given Gadget to the list of message
* handlers for another Gadget.  Messages that are sent directly to hgadMsg
* will also be sent to hgadHandler as an GMF_EVENT.
*
* <remarks>
* A message handler can be any Gadget.  Once registered, hgadHandler will
* receive all messages sent to hgadMsg with a corresponding MSGID.  Any
* valid public or private message can be listened it.  If nMsg==0, all
* messages will be sent to hgadHandler.
*
* A single hgadHandler may be registered multiple times to handle different
* messages from hgadMsg.
* </remarks>
*
* <return type="BOOL">      Handler was successfully added.</>
* <see type="function">     SendGadgetEvent</>
* <see type="function">     RegisterGadgetMessage</>
* <see type="function">     RegisterGadgetMessageString</>
* <see type="function">     UnregisterGadgetMessage</>
* <see type="function">     UnregisterGadgetMessageString</>
* <see type="function">     RemoveGadgetMessageHandler</>
* <see type="struct">       GMSG</>
* <see type="article">      GadgetMessaging</>
*
\***************************************************************************/

DUSER_API BOOL WINAPI
AddGadgetMessageHandler(
    IN  HGADGET hgadMsg,            // Gadget to attach to
    IN  MSGID nMsg,                 // Message to watch for
    IN  HGADGET hgadHandler)        // Gadget to notify
{
    DuEventGadget * pgadMsg;
    DuEventGadget * pgadHandler;
    HRESULT hr;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_EVENTGADGET(gadMsg);
    VALIDATE_EVENTGADGET(gadHandler);
    if (((nMsg < PRID_GlobalMin) && (nMsg > 0)) || (nMsg < 0)) {
        PromptInvalid("nMsg must be a valid MSGID");
        goto ErrorExit;
    }
    CHECK_MODIFY();

    hr = pgadMsg->AddMessageHandler(nMsg, pgadHandler);
    SET_RETURN(hr, TRUE);

    END_RECV();
}


/***************************************************************************\
*
* RemoveGadgetMessageHandler (API)
*
* RemoveGadgetMessageHandler() removes the specified hgadHandler from the
* list of message handlers attached to hgadMsg.  Only the first hgadHandler
* with a corresponding nMsg will be removed.
*
* <return type="BOOL">      Handler was successfully removed.</>
* <see type="function">     SendGadgetEvent</>
* <see type="function">     RegisterGadgetMessage</>
* <see type="function">     RegisterGadgetMessageString</>
* <see type="function">     UnregisterGadgetMessage</>
* <see type="function">     UnregisterGadgetMessageString</>
* <see type="function">     AddGadgetMessageHandler</>
* <see type="struct">       GMSG</>
* <see type="article">      GadgetMessaging</>
*
\***************************************************************************/

DUSER_API BOOL WINAPI
RemoveGadgetMessageHandler(
    IN  HGADGET hgadMsg,            // Gadget to detach from
    IN  MSGID nMsg,                 // Message being watched for
    IN  HGADGET hgadHandler)        // Gadget being notified
{
    DuEventGadget * pgadMsg;
    DuEventGadget * pgadHandler;
    HRESULT hr;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_EVENTGADGET(gadMsg);
    VALIDATE_EVENTGADGET(gadHandler);
    if (((nMsg < PRID_GlobalMin) && (nMsg > 0)) || (nMsg < 0)) {
        PromptInvalid("nMsg must be a valid MSGID");
        goto ErrorExit;
    }
    CHECK_MODIFY();

    hr = pgadMsg->RemoveMessageHandler(nMsg, pgadHandler);
    SET_RETURN(hr, TRUE);

    END_RECV();
}


/***************************************************************************\
*
* GetGadgetStyle (API)
*
* GetGadgetStyle() returns the current style of the given Gadget.
*
* <remarks>
* For a list of Gadget styles, see SetGadgetStyle().
* </remarks>
*
* <return type="UINT">      Current style of Gadget.</>
* <see type="function">     SetGadgetStyle</>
* <see type="article">      GadgetStyles</>
*
\***************************************************************************/

DUSER_API UINT WINAPI
GetGadgetStyle(
    IN  HGADGET hgad)               // Handle of Gadget
{
    DuVisual * pgad;

    BEGIN_RECV(UINT, 0, ContextLock::edNone);
    VALIDATE_VISUAL(gad);

    retval = pgad->GetStyle();

    END_RECV();
}


/***************************************************************************\
*
* SetGadgetStyle (API)
*
* SetGadgetStyle() changes the current style of the given Gadget.  Only the
* styles specified by nMask are actually changed.  If multiple style changes
* are requested, but any changes fail, the successfully change styles will
* not be reverted back.
*
* <param name="nNewStyle">
*       nNewStyle can be a combination of the following flags:
*       <table item="Value" desc="Meaning">
*           GS_RELATIVE     The position of the Gadget is internally stored
*                           relative to parent.  This is the preferred style
*                           if the Gadget will be moved more frequently,
*                           such as when scrolling.
*           GS_VISIBLE      The Gadget is visible.
*           GS_ENABLED      The Gadget can receive input.
*           GS_BUFFERED     Drawing of the Gadget is double-buffered.
*           GS_ALLOWSUBCLASS Gadget supports being subclassed.
*           GS_WANTFOCUS    Gadget can receive keyboard focus.
*           GS_CLIPINSIDE   Drawing of this Gadget will be clipped inside
*                           the Gadget.
*           GS_CLIPSIBLINGS Drawing of this Gadget will exclude any area of
*                           overlapping siblings that are higher in z-order.
*           GS_OPAQUE       HINT: Support for composited drawing is
*                           unnecessary.
*           GS_ZEROORIGIN   Set the origin to (0,0)
*       </table>
* </param>
*
* <return type="BOOL">      All style changes were successful.</>
* <see type="function">     GetGadgetStyle</>
* <see type="article">      GadgetStyles</>
*
\***************************************************************************/

DUSER_API BOOL WINAPI
SetGadgetStyle(
    IN  HGADGET hgadChange,         // Gadget to change
    IN  UINT nNewStyle,             // New style
    IN  UINT nMask)                 // Style bits to change
{
    DuVisual * pgadChange;
    HRESULT hr;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_VISUAL(gadChange);
    VALIDATE_FLAGS(nNewStyle, GS_VALID);
    VALIDATE_FLAGS(nMask, GS_VALID);
    CHECK_MODIFY();

    hr = pgadChange->xdSetStyle(nNewStyle, nMask);
    SET_RETURN(hr, TRUE);

    END_RECV();
}


//------------------------------------------------------------------------------
DUSER_API PRID WINAPI  
RegisterGadgetProperty(
    IN  const GUID * pguid)         // Unique GUID of message to register
{
    HRESULT hr;
    PRID prid;

    BEGIN_RECV_NOCONTEXT(PRID, PRID_Unused);

    hr = DuVisual::RegisterPropertyNL(pguid, ptGlobal, &prid);
    SET_RETURN(hr, prid);

    END_RECV_NOCONTEXT();
}


//------------------------------------------------------------------------------
DUSER_API BOOL WINAPI  
UnregisterGadgetProperty(
    const GUID * pguid)
{
    HRESULT hr;

    BEGIN_RECV_NOCONTEXT(BOOL, FALSE);

    hr = DuVisual::UnregisterPropertyNL(pguid, ptGlobal);
    SET_RETURN(hr, TRUE);

    END_RECV_NOCONTEXT();
}


//------------------------------------------------------------------------------
DUSER_API BOOL WINAPI  
GetGadgetProperty(HGADGET hgad, PRID id, void ** ppvValue)
{
    DuVisual * pgad;
    HRESULT hr;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edNone);
    VALIDATE_VISUAL(gad);
    VALIDATE_WRITE_PTR_(ppvValue, sizeof(ppvValue));
    CHECK_MODIFY();

    hr = pgad->GetProperty(id, ppvValue);
    SET_RETURN(hr, TRUE);

    END_RECV();
}


//------------------------------------------------------------------------------
DUSER_API BOOL WINAPI  
SetGadgetProperty(HGADGET hgad, PRID id, void * pvValue)
{
    DuVisual * pgad;
    HRESULT hr;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_VISUAL(gad);
    CHECK_MODIFY();

    hr = pgad->SetProperty(id, pvValue);
    SET_RETURN(hr, TRUE);

    END_RECV();
}


//---------------------------------------------------------------------------
DUSER_API BOOL WINAPI  
RemoveGadgetProperty(HGADGET hgad, PRID id)
{
    DuVisual * pgad;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_VISUAL(gad);
    CHECK_MODIFY();

    pgad->RemoveProperty(id, FALSE /* Can't free memory for Global property*/);
    retval = TRUE;

    END_RECV();
}


//---------------------------------------------------------------------------
DUSER_API BOOL WINAPI
EnumGadgets(HGADGET hgadEnum, GADGETENUMPROC pfnProc, void * pvData, UINT nFlags)
{
    DuVisual * pgadEnum;
    HRESULT hr;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_FLAGS(nFlags, GENUM_VALID);
    VALIDATE_VISUAL(gadEnum);
    VALIDATE_CODE_PTR(pfnProc);
    CHECK_MODIFY();

    hr = pgadEnum->xwEnumGadgets(pfnProc, pvData, nFlags);
    SET_RETURN(hr, TRUE);

    END_RECV();
}


/***************************************************************************\
*
* GetGadgetSize (API)
*
* GetGadgetSize() is a high-performance mechanism of retreiving the Gadget's
* logical size.
*
* <return type="BOOL">      Successfully returned size in logical pixels.</>
* <see type="function">     GetGadgetRect</>
* <see type="function">     SetGadgetRect</>
* <see type="article">      GadgetStyles</>
*
\***************************************************************************/

DUSER_API BOOL WINAPI
GetGadgetSize(
    IN  HGADGET hgad,               // Handle of Gadget
    OUT SIZE * psizeLogicalPxl)     // Size in logical pixels
{
    DuVisual * pgad;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edNone);
    VALIDATE_VISUAL(gad);
    VALIDATE_WRITE_PTR_(psizeLogicalPxl, sizeof(SIZE));

    pgad->GetSize(psizeLogicalPxl);
    retval = TRUE;

    END_RECV();
}


/***************************************************************************\
*
* GetGadgetRect (API)
*
* GetGadgetRect() is a flexible mechanism of retreiving the Gadget's
* logical rectangle or actual bounding box.
*
* <param name=nFlags>
*       nFlags can be a combination of the following flags:
*       <table item="Value" desc="Meaning">
*           SGR_CLIENT      Coordinates are relative to the Gadget itself.
*           SGR_PARENT      Coordinates are relative to the Gadget's parent.
*           SGR_CONTAINER   Coordinates are relative to the Gadget's root
*                           container.
*           SGR_DESKTOP     Coordinates are relative to the Windows desktop.
*           SGR_ACTUAL      Return the bounding rectangle of the Gadget.  If
*                           this flag is specified, a bounding box is
*                           computed from all transformations applied from
*                           the root to the Gadget itself.  If this flag is
*                           not specified, the rectangle returned will be in
*                           logical coordinates.
*       </table>
* </param>
*
* <return type="BOOL">      Rectangle was successfully retreived.</>
* <see type="function">     SetGadgetRect</>
* <see type="function">     GetGadgetRotation</>
* <see type="function">     SetGadgetRotation</>
* <see type="function">     GetGadgetScale</>
* <see type="function">     SetGadgetScale</>
*
\***************************************************************************/

DUSER_API BOOL WINAPI
GetGadgetRect(
    IN  HGADGET hgad,               // Handle of Gadget
    OUT RECT * prcPxl,              // Rectangle in specified pixels
    IN  UINT nFlags)                // Rectangle to retrieve
{
    DuVisual * pgad;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edNone);
    VALIDATE_FLAGS(nFlags, SGR_VALID_GET);
    VALIDATE_VISUAL(gad);
    VALIDATE_WRITE_PTR_(prcPxl, sizeof(RECT));

    if (TestFlag(nFlags, SGR_ACTUAL)) {
        AssertMsg(0, "TODO: Not Implemented");
    } else {
        pgad->GetLogRect(prcPxl, nFlags);
        retval = TRUE;
    }

    END_RECV();
}


/***************************************************************************\
*
* SetGadgetRect (API)
*
* SetGadgetRect() changes the size or position of a given Gadget.
*
* <param name=nFlags>
*       nFlags can be a combination of the following flags:
*       <table item="Value" desc="Meaning">
*           SGR_MOVE        Move to Gadget to a new location specified by
*                           x, y.
*           SGR_SIZE        Change the Gadget's size to width w and height h.
*           SGR_CLIENT      Coordinates are relative to the Gadget itself.
*           SGR_PARENT      Coordinates are relative to the Gadget's parent.
*           SGR_CONTAINER   Coordinates are relative to the Gadget's root
*                           container.
*           SGR_DESKTOP     Coordinates are relative to the Windows desktop.
*           SGR_OFFSET      Coordinates are relative to the Gadget's current
*                           location.
*           SGR_ACTUAL      Return the bounding rectangle of the Gadget.  If
*                           this flag is specified, a bounding box is
*                           computed from all transformations applied from
*                           the root to the Gadget itself.  If this flag is
*                           not specified, the rectangle returned will be in
*                           logical coordinates.
*       </table>
* </param>
*
* <return type="BOOL">      Rectangle was successfully retreived.</>
* <see type="function">     SetGadgetRect</>
* <see type="function">     GetGadgetRotation</>
* <see type="function">     SetGadgetRotation</>
* <see type="function">     GetGadgetScale</>
* <see type="function">     SetGadgetScale</>
*
\***************************************************************************/

DUSER_API BOOL WINAPI
SetGadgetRect(
    IN  HGADGET hgadChange,         // Gadget to change
    IN  int x,                      // New horizontal position
    IN  int y,                      // New vertical position
    IN  int w,                      // New width
    IN  int h,                      // New height
    IN  UINT nFlags)                // Flags specifying what to change
{
    DuVisual * pgadChange;
    HRESULT hr;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_FLAGS(nFlags, SGR_VALID_SET);
    VALIDATE_VISUAL(gadChange);
    CHECK_MODIFY();

    if (pgadChange->IsRoot()) {
        if (TestFlag(nFlags, SGR_MOVE)) {
            PromptInvalid("Can not move a RootGadget");
            SetError(E_INVALIDARG);
            goto ErrorExit;
        }
    }


    //
    // Ensure that size is non-negative
    //

    if (TestFlag(nFlags, SGR_SIZE)) {
        if (w < 0) {
            w = 0;
        }
        if (h < 0) {
            h = 0;
        }
    }

    if (TestFlag(nFlags, SGR_ACTUAL)) {
//        AssertMsg(0, "TODO: Not Implemented");
        ClearFlag(nFlags, SGR_ACTUAL);
        hr = pgadChange->xdSetLogRect(x, y, w, h, nFlags);
    } else {
        hr = pgadChange->xdSetLogRect(x, y, w, h, nFlags);
    }
    SET_RETURN(hr, TRUE);

    END_RECV();
}


/***************************************************************************\
*
* FindGadgetFromPoint (API)
*
* FindGadgetFromPoint() determines which Gadget a contains the specified
* point.
*
* <return type="HGADGET">   Gadget containing point or NULL for none.</>
*
\***************************************************************************/

DUSER_API HGADGET WINAPI
FindGadgetFromPoint(
    IN  HGADGET hgad,               // Gadget to search from
    IN  POINT ptContainerPxl,       // Point to search from in container pixels
    IN  UINT nStyle,                // Required style flags
    OUT POINT * pptClientPxl)       // Optional translated point in client pixels.
{
    DuVisual * pgad;

    BEGIN_RECV(HGADGET, NULL, ContextLock::edNone);
    VALIDATE_FLAGS(nStyle, GS_VALID);
    VALIDATE_VISUAL(gad);
    VALIDATE_WRITE_PTR_OR_NULL_(pptClientPxl, sizeof(POINT));

    retval = (HGADGET) GetHandle(pgad->FindFromPoint(ptContainerPxl, nStyle, pptClientPxl));

    END_RECV();
}


/***************************************************************************\
*
* MapGadgetPoints (API)
*
* MapGadgetPoints() converts a set of points in client-pixels relative to 
* one Gadget into points in client-pixels relative to another Gadget.
*
* <return type="HGADGET">   Gadget containing point or NULL for none.</>
*
\***************************************************************************/

DUSER_API BOOL WINAPI
MapGadgetPoints(
    IN  HGADGET hgadFrom, 
    IN  HGADGET hgadTo, 
    IN OUT POINT * rgptClientPxl, 
    IN  int cPts)
{
    DuVisual * pgadFrom, * pgadTo;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edNone);
    VALIDATE_VISUAL(gadFrom);
    VALIDATE_VISUAL(gadTo);
    VALIDATE_WRITE_PTR_(rgptClientPxl, sizeof(POINT) * cPts);

    if (pgadFrom->GetRoot() != pgadTo->GetRoot()) {
        PromptInvalid("Must be in the same tree");
        SetError(E_INVALIDARG);
        goto ErrorExit;
    }

    DuVisual::MapPoints(pgadFrom, pgadTo, rgptClientPxl, cPts);
    retval = TRUE;

    END_RECV();
}



/***************************************************************************\
*
* SetGadgetOrder (API)
*
* SetGadgetOrder() changes the Gadget's z-order relative to its siblings.
* The parent of the Gadget is not changed.
*
* <param name=nFlags>
*       nFlags can be a combination of the following flags:
*       <table item="Value" desc="Meaning">
*           GORDER_ANY      The order does not matter.
*           GORDER_BEFORE   Move this gadget in-front of sibling hgadOther.
*           GORDER_BEHIND   Move this gadget behind sibling hgadOther.
*           GORDER_TOP      Move this gadget to front of sibling z-order.
*           GORDER_BOTTOM   Move this gadget to bottom of sibling z-order.
*           GORDER_FORWARD  Move this gadget forward in sibling z-order.
*           GORDER_BACKWARD Move this gadget backward in sibling z-order.
*       </table>
* </param>
*
* <return type="BOOL">      Gadget z-order was successfully changed.</>
* <see type="function">     SetGadgetParent</>
*
\***************************************************************************/

DUSER_API BOOL WINAPI
SetGadgetOrder(
    IN  HGADGET hgadMove,           // Gadget to be moved
    IN  HGADGET hgadOther,          // Gadget to moved relative to
    IN  UINT nCmd)                  // Type of move
{
    DuVisual * pgadMove;
    DuVisual * pgadOther;
    HRESULT hr;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_RANGE(nCmd, GORDER_MIN, GORDER_MAX);
    VALIDATE_VISUAL(gadMove);
    VALIDATE_VISUAL_OR_NULL(gadOther);
    CHECK_MODIFY();

    hr = pgadMove->xdSetOrder(pgadOther, nCmd);
    SET_RETURN(hr, TRUE);

    END_RECV();
}


/***************************************************************************\
*
* SetGadgetParent (API)
*
* SetGadgetParent() changes the Gadget's parent.
*
* <param name=nFlags>
*       nFlags can be a combination of the following flags:
*       <table item="Value" desc="Meaning">
*           GORDER_ANY      The order does not matter.
*           GORDER_BEFORE   Move this gadget in-front of sibling hgadOther.
*           GORDER_BEHIND   Move this gadget behind sibling hgadOther.
*           GORDER_TOP      Move this gadget to front of sibling z-order.
*           GORDER_BOTTOM   Move this gadget to bottom of sibling z-order.
*           GORDER_FORWARD  Move this gadget forward in sibling z-order.
*           GORDER_BACKWARD Move this gadget backward in sibling z-order.
*       </table>
* </param>
*
* <return type="BOOL">      Gadget parent and z-order were successfully changed.</>
* <see type="function">     SetGadgetOrder</>
* <see type="function">     GetGadget</>
*
\***************************************************************************/

DUSER_API BOOL WINAPI
SetGadgetParent(
    IN  HGADGET hgadMove,           // Gadget to be moved
    IN  HGADGET hgadParent,         // New parent
    IN  HGADGET hgadOther,          // Gadget to moved relative to
    IN  UINT nCmd)                  // Type of move
{
    DuVisual * pgadMove;
    DuVisual * pgadParent;
    DuVisual * pgadOther;
    HRESULT hr;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_RANGE(nCmd, GORDER_MIN, GORDER_MAX);
    VALIDATE_VISUAL(gadMove);
    VALIDATE_VISUAL_OR_NULL(gadParent);
    VALIDATE_VISUAL_OR_NULL(gadOther);
    CHECK_MODIFY();

    if (pgadMove->IsRoot()) {
        PromptInvalid("Can not change a RootGadget's parent");
        SetError(E_INVALIDARG);
        goto ErrorExit;
    }

    //
    // Check that can become a child of the specified parent
    //

    if ((!pgadMove->IsRelative()) && pgadParent->IsRelative()) {
        PromptInvalid("Can not set non-relative child to a relative parent");
        SetError(DU_E_BADCOORDINATEMAP);
        goto ErrorExit;
    }

    //
    // DuVisual::xdSetParent() handles if pgadParent is NULL and will move to the
    // parking window.
    //

    hr = pgadMove->xdSetParent(pgadParent, pgadOther, nCmd);
    SET_RETURN(hr, TRUE);

    END_RECV();
}


/***************************************************************************\
*
* GetGadget (API)
*
* GetGadget() retrieves the Gadget that has the specified relationship to
* the specified Gadget.
*
* <param name=nFlags>
*       nFlags can be a combination of the following flags:
*       <table item="Value" desc="Meaning">
*           GG_PARENT       Return the parent of the specified Gadget.
*           GG_NEXT         Return the next sibling behind the specified
*                           Gadget.
*           GG_PREV         Return the previous sibling before the
*                           specified Gadget.
*           GG_TOPCHILD     Return the Gadget's top z-ordered child.
*           GG_BOTTOMCHILD  Return the Gadget's bottom z-ordered child.
*       </table>
* </param>
*
* <return type="BOOL">      Related Gadget or NULL for none.</>
* <see type="function">     SetGadgetOrder</>
* <see type="function">     SetGadgetParent</>
*
\***************************************************************************/

DUSER_API HGADGET WINAPI
GetGadget(
    IN  HGADGET hgad,               // Handle of Gadget
    IN  UINT nCmd)                  // Relationship
{
    DuVisual * pgad;

    BEGIN_RECV(HGADGET, NULL, ContextLock::edNone);
    VALIDATE_VISUAL(gad);
    VALIDATE_RANGE(nCmd, GG_MIN, GG_MAX);

    retval = (HGADGET) GetHandle(pgad->GetGadget(nCmd));

    END_RECV();
}


/***************************************************************************\
*
* InvalidateGadget (API)
*
* InvalidateGadget() marks a Gadget to be repainted during the next painting
* cycle.
*
* <return type="BOOL">      Gadget was successfully invalidated.</>
* <see type="message">      GM_PAINT</>
*
\***************************************************************************/

DUSER_API BOOL WINAPI
InvalidateGadget(
    IN  HGADGET hgad)               // Gadget to repaint
{
    DuVisual * pgad;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_VISUAL(gad);
    CHECK_MODIFY();

    pgad->Invalidate();
    retval = TRUE;

    END_RECV();
}


//---------------------------------------------------------------------------
DUSER_API UINT WINAPI
GetGadgetMessageFilter(HGADGET hgad, void * pvCookie)
{
    DuEventGadget * pgad;

    BEGIN_RECV(UINT, 0, ContextLock::edNone);
    VALIDATE_EVENTGADGET(gad);
    VALIDATE_VALUE(pvCookie, NULL);

    retval = (pgad->GetFilter() & GMFI_VALID);

    END_RECV();
}


//---------------------------------------------------------------------------
DUSER_API BOOL WINAPI
SetGadgetMessageFilter(HGADGET hgadChange, void * pvCookie, UINT nNewFilter, UINT nMask)
{
    DuEventGadget * pgadChange;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_EVENTGADGET(gadChange);
    VALIDATE_FLAGS(nNewFilter, GMFI_VALID);
    VALIDATE_VALUE(pvCookie, NULL);
    CHECK_MODIFY();

    pgadChange->SetFilter(nNewFilter, nMask);
    retval = TRUE;

    END_RECV();
}


//---------------------------------------------------------------------------
DUSER_API BOOL WINAPI
ForwardGadgetMessage(HGADGET hgadRoot, UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT * pr)
{
    DuVisual * pgadRoot;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_VISUAL(gadRoot);
    VALIDATE_WRITE_PTR(pr);
    CHECK_MODIFY();

    retval = GdForwardMessage(pgadRoot, nMsg, wParam, lParam, pr);

    END_RECV();
}


//---------------------------------------------------------------------------
DUSER_API BOOL WINAPI
DrawGadgetTree(HGADGET hgadDraw, HDC hdcDraw, const RECT * prcDraw, UINT nFlags)
{
    DuVisual * pgadDraw;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_VISUAL(gadDraw);
    VALIDATE_READ_PTR_OR_NULL_(prcDraw, sizeof(RECT));
    VALIDATE_FLAGS(nFlags, GDRAW_VALID);

    retval = GdxrDrawGadgetTree(pgadDraw, hdcDraw, prcDraw, nFlags);

    END_RECV();
}


/***************************************************************************\
*****************************************************************************
*
* DirectUser GADGET API
*
* <package name="Msg"/>
*
*****************************************************************************
\***************************************************************************/

/***************************************************************************\
*
* DUserRegisterGuts
*
* DUserRegisterGuts() registers the implementation of a MsgClass.
* 
\***************************************************************************/

DUSER_API HCLASS WINAPI
DUserRegisterGuts(
    IN OUT DUser::MessageClassGuts * pmcInfo) // Class information
{
    MsgClass * pmcNew;
    HRESULT hr;

    BEGIN_RECV_NOCONTEXT(HCLASS, NULL);
    VALIDATE_WRITE_STRUCT(pmcInfo, DUser::MessageClassGuts);

    hr = GetClassLibrary()->RegisterGutsNL(pmcInfo, &pmcNew);
    SET_RETURN(hr, (HCLASS) GetHandle(pmcNew));

    END_RECV_NOCONTEXT();
}


/***************************************************************************\
*
* DUserRegisterStub
*
* DUserRegisterStub() registers a Stub for a MsgClass
* 
\***************************************************************************/

DUSER_API HCLASS WINAPI
DUserRegisterStub(
    IN OUT DUser::MessageClassStub * pmcInfo) // Class information
{
    MsgClass * pmcFind;
    HRESULT hr;

    BEGIN_RECV_NOCONTEXT(HCLASS, NULL);
    VALIDATE_WRITE_STRUCT(pmcInfo, DUser::MessageClassStub);

    hr = GetClassLibrary()->RegisterStubNL(pmcInfo, &pmcFind);
    SET_RETURN(hr, (HCLASS) GetHandle(pmcFind));

    END_RECV_NOCONTEXT();
}


/***************************************************************************\
*
* DUserRegisterSuper
*
* DUserRegisterSuper() registers a Super for a MsgClass
* 
\***************************************************************************/

DUSER_API HCLASS WINAPI
DUserRegisterSuper(
    IN OUT DUser::MessageClassSuper * pmcInfo) // Class information
{
    MsgClass * pmcFind;
    HRESULT hr;

    BEGIN_RECV_NOCONTEXT(HCLASS, NULL);
    VALIDATE_WRITE_STRUCT(pmcInfo, DUser::MessageClassSuper);

    hr = GetClassLibrary()->RegisterSuperNL(pmcInfo, &pmcFind);
    SET_RETURN(hr, (HCLASS) GetHandle(pmcFind));

    END_RECV_NOCONTEXT();
}


/***************************************************************************\
*
* DUserFindClass
*
* DUserFindClass() finds a previously registered Gadget Class
* 
\***************************************************************************/

DUSER_API HCLASS WINAPI
DUserFindClass(
    IN  LPCWSTR pszName, 
    IN  DWORD nVersion)
{
    const MsgClass * pmcFind = NULL;
    ATOM atom;
    HRESULT hr;

    BEGIN_RECV_NOCONTEXT(HCLASS, NULL);
    VALIDATE_VALUE(nVersion, 1);        // Currently, all classes are version 1

    atom = FindAtomW(pszName);
    if (atom == 0) {
        hr = DU_E_NOTFOUND;
    } else {
        pmcFind = GetClassLibrary()->FindClass(atom);
        hr = S_OK;
    }
    SET_RETURN(hr, (HCLASS) GetHandle(pmcFind));

    END_RECV_NOCONTEXT();
}


/***************************************************************************\
*
* DUserBuildGadget
*
* DUserBuildGadget() creates a fully initialized Gadget using the specified
* MsgClass.
* 
\***************************************************************************/

DUSER_API DUser::Gadget * WINAPI  
DUserBuildGadget(
    IN  HCLASS hcl,                     // Class to construct
    IN  DUser::Gadget::ConstructInfo * pciData) // Construction data
{
    MsgClass * pmc = ValidateMsgClass(hcl);
    if (pmc == NULL) {
        return NULL;
    }

    MsgObject * pmoNew;
    HRESULT hr = pmc->xwBuildObject(&pmoNew, pciData);
    if (FAILED(hr)) {
        return NULL;
    }

    return pmoNew->GetGadget();
}


//------------------------------------------------------------------------------
DUSER_API BOOL WINAPI
DUserInstanceOf(DUser::Gadget * pg, HCLASS hclTest)
{
    MsgObject * pmo;
    MsgClass * pmcTest;

    pmo = MsgObject::CastMsgObject(pg);
    if (pmo == NULL) {
        PromptInvalid("The specified Gadget is invalid");
        goto Error;
    }

    pmcTest = ValidateMsgClass(hclTest);
    if (pmcTest == NULL) {
        PromptInvalid("The specified class is invalid");
        goto Error;
    }

    return pmo->InstanceOf(pmcTest);

Error:
    SetError(E_INVALIDARG);
    return FALSE;
}


//------------------------------------------------------------------------------
DUSER_API DUser::Gadget * WINAPI
DUserCastClass(DUser::Gadget * pg, HCLASS hclTest)
{
    MsgObject * pmo;
    MsgClass * pmcTest;

    //
    // A NULL MsgObject is a valid input, so return NULL.
    //

    pmo = MsgObject::CastMsgObject(pg);
    if (pmo == NULL) {
        return NULL;
    }


    //
    // The HCLASS must be valid.
    //

    pmcTest = ValidateMsgClass(hclTest);
    if (pmcTest == NULL) {
        PromptInvalid("The specified class is invalid");
        goto Error;
    }

    return pmo->CastClass(pmcTest);

Error:
    SetError(E_INVALIDARG);
    return NULL;
}


//------------------------------------------------------------------------------
DUSER_API DUser::Gadget * WINAPI
DUserCastDirect(HGADGET hgad)
{
    return MsgObject::CastGadget(hgad);
}


//------------------------------------------------------------------------------
DUSER_API HGADGET WINAPI
DUserCastHandle(DUser::Gadget * pg)
{
    return MsgObject::CastHandle(pg);
}


//------------------------------------------------------------------------------
DUSER_API void * WINAPI
DUserGetGutsData(DUser::Gadget * pg, HCLASS hclData)
{
    MsgObject * pmo;
    MsgClass * pmcData;

    pmo = MsgObject::CastMsgObject(pg);
    if (pmo == NULL) {
        PromptInvalid("The specified Gadget is invalid");
        goto Error;
    }

    pmcData = ValidateMsgClass(hclData);
    if (pmcData == NULL) {
        PromptInvalid("The specified class is invalid");
        goto Error;
    }

    return pmo->GetGutsData(pmcData);

Error:
    SetError(E_INVALIDARG);
    return NULL;
}



/***************************************************************************\
*****************************************************************************
*
* DirectUser GADGET API
*
* <package name="Lava"/>
*
*****************************************************************************
\***************************************************************************/

//---------------------------------------------------------------------------
DUSER_API BOOL WINAPI  
AttachWndProcA(HWND hwnd, ATTACHWNDPROC pfn, void * pvThis)
{
    HRESULT hr = GdAttachWndProc(hwnd, pfn, pvThis, TRUE);
    if (SUCCEEDED(hr)) {
        return TRUE;
    } else {
        SetError(hr);
        return FALSE;
    }
}

//---------------------------------------------------------------------------
DUSER_API BOOL WINAPI  
AttachWndProcW(HWND hwnd, ATTACHWNDPROC pfn, void * pvThis)
{
    HRESULT hr = GdAttachWndProc(hwnd, pfn, pvThis, FALSE);
    if (SUCCEEDED(hr)) {
        return TRUE;
    } else {
        SetError(hr);
        return FALSE;
    }
}

//---------------------------------------------------------------------------
DUSER_API BOOL WINAPI  
DetachWndProc(HWND hwnd, ATTACHWNDPROC pfn, void * pvThis)
{
    HRESULT hr = GdDetachWndProc(hwnd, pfn, pvThis);
    if (SUCCEEDED(hr)) {
        return TRUE;
    } else {
        SetError(hr);
        return FALSE;
    }
}


/***************************************************************************\
*****************************************************************************
*
* DirectUser MOTION API
*
* <package name="Motion"/>
*
*****************************************************************************
\***************************************************************************/

//---------------------------------------------------------------------------
DUSER_API HTRANSITION WINAPI
CreateTransition(const GTX_TRXDESC * ptx)
{
    BEGIN_RECV(HTRANSITION, NULL, ContextLock::edDefer);
    VALIDATE_READ_PTR_(ptx, sizeof(GTX_TRXDESC));
    CHECK_MODIFY();

    retval = (HTRANSITION) GetHandle(GdCreateTransition(ptx));

    END_RECV();
}


//---------------------------------------------------------------------------
DUSER_API BOOL WINAPI
PlayTransition(HTRANSITION htrx, const GTX_PLAY * pgx)
{
    Transition * ptrx;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_TRANSITION(trx);
    VALIDATE_READ_PTR_(pgx, sizeof(GTX_PLAY));
    VALIDATE_FLAGS(pgx->nFlags, GTX_EXEC_VALID);

    retval = ptrx->Play(pgx);

    END_RECV();
}


//---------------------------------------------------------------------------
DUSER_API BOOL WINAPI
GetTransitionInterface(HTRANSITION htrx, IUnknown ** ppUnk)
{
    Transition * ptrx;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edNone);
    VALIDATE_TRANSITION(trx);
    VALIDATE_WRITE_PTR(ppUnk);

    retval = ptrx->GetInterface(ppUnk);

    END_RECV();
}


//---------------------------------------------------------------------------
DUSER_API BOOL WINAPI
BeginTransition(HTRANSITION htrx, const GTX_PLAY * pgx)
{
    Transition * ptrx;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_TRANSITION(trx);
    VALIDATE_READ_PTR_(pgx, sizeof(GTX_PLAY));

    retval = ptrx->Begin(pgx);

    END_RECV();
}


//---------------------------------------------------------------------------
DUSER_API BOOL WINAPI
PrintTransition(HTRANSITION htrx, float fProgress)
{
    Transition * ptrx;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_TRANSITION(trx);

    retval = ptrx->Print(fProgress);

    END_RECV();
}


//---------------------------------------------------------------------------
DUSER_API BOOL WINAPI
EndTransition(HTRANSITION htrx, const GTX_PLAY * pgx)
{
    Transition * ptrx;

    BEGIN_RECV(BOOL, FALSE, ContextLock::edDefer);
    VALIDATE_TRANSITION(trx);
    VALIDATE_READ_PTR_(pgx, sizeof(GTX_PLAY));

    retval = ptrx->End(pgx);

    END_RECV();
}


//---------------------------------------------------------------------------
DUSER_API HACTION WINAPI
CreateAction(const GMA_ACTION * pma)
{
    BEGIN_RECV(HACTION, NULL, ContextLock::edNone);
    VALIDATE_READ_STRUCT(pma, GMA_ACTION);

    retval = GdCreateAction(pma);

    END_RECV();
}


//---------------------------------------------------------------------------
DUSER_API BOOL WINAPI
GetActionTimeslice(DWORD * pdwTimeslice)
{
    BEGIN_RECV(BOOL, FALSE, ContextLock::edNone);
    VALIDATE_WRITE_PTR(pdwTimeslice);

    *pdwTimeslice = GetMotionSC()->GetTimeslice();
    retval = TRUE;

    END_RECV();
}


//---------------------------------------------------------------------------
DUSER_API BOOL WINAPI
SetActionTimeslice(DWORD dwTimeslice)
{
    BEGIN_RECV(BOOL, FALSE, ContextLock::edNone);

    GetMotionSC()->SetTimeslice(dwTimeslice);
    retval = TRUE;

    END_RECV();
}


/***************************************************************************\
*****************************************************************************
*
* DirectUser UTIL API
*
* <package name="Util"/>
*
*****************************************************************************
\***************************************************************************/

//---------------------------------------------------------------------------
DUSER_API COLORREF WINAPI
GetStdColorI(UINT c)
{
    BEGIN_RECV_NOCONTEXT(COLORREF, RGB(0, 0, 0));
    VALIDATE_RANGE(c, 0, SC_MAXCOLORS);

    retval = GdGetColorInfo(c)->GetColorI();

    END_RECV_NOCONTEXT();
}


//---------------------------------------------------------------------------
DUSER_API Gdiplus::Color WINAPI
GetStdColorF(UINT c)
{
    BEGIN_RECV_NOCONTEXT(Gdiplus::Color, Gdiplus::Color((Gdiplus::ARGB) Gdiplus::Color::Black));
    VALIDATE_RANGE(c, 0, SC_MAXCOLORS);

    retval = GdGetColorInfo(c)->GetColorF();

    END_RECV_NOCONTEXT();
}


//---------------------------------------------------------------------------
DUSER_API HBRUSH WINAPI
GetStdColorBrushI(UINT c)
{
    BEGIN_RECV(HBRUSH, NULL, ContextLock::edNone);
    VALIDATE_RANGE(c, 0, SC_MAXCOLORS);

    retval = GetMotionSC()->GetBrushI(c);

    END_RECV();
}


//---------------------------------------------------------------------------
DUSER_API Gdiplus::Brush * WINAPI
GetStdColorBrushF(UINT c)
{
    BEGIN_RECV(Gdiplus::Brush *, NULL, ContextLock::edNone);
    VALIDATE_RANGE(c, 0, SC_MAXCOLORS);

    retval = GetMotionSC()->GetBrushF(c);

    END_RECV();
}


//---------------------------------------------------------------------------
DUSER_API HPEN WINAPI
GetStdColorPenI(UINT c)
{
    BEGIN_RECV(HPEN, NULL, ContextLock::edNone);
    VALIDATE_RANGE(c, 0, SC_MAXCOLORS);

    retval = GetMotionSC()->GetPenI(c);

    END_RECV();
}


//---------------------------------------------------------------------------
DUSER_API Gdiplus::Pen * WINAPI
GetStdColorPenF(UINT c)
{
    BEGIN_RECV(Gdiplus::Pen *, NULL, ContextLock::edNone);
    VALIDATE_RANGE(c, 0, SC_MAXCOLORS);

    retval = GetMotionSC()->GetPenF(c);

    END_RECV();
}


//---------------------------------------------------------------------------
DUSER_API LPCWSTR WINAPI
GetStdColorName(UINT c)
{
    BEGIN_RECV_NOCONTEXT(LPCWSTR, NULL);
    VALIDATE_RANGE(c, 0, SC_MAXCOLORS);

    retval = GdGetColorInfo(c)->GetName();

    END_RECV_NOCONTEXT();
}


//---------------------------------------------------------------------------
DUSER_API UINT WINAPI
FindStdColor(LPCWSTR pszName)
{
    BEGIN_RECV_NOCONTEXT(UINT, SC_Black);
    VALIDATE_STRINGW_PTR(pszName, 50);

    retval = GdFindStdColor(pszName);

    END_RECV_NOCONTEXT();
}


//---------------------------------------------------------------------------
DUSER_API HPALETTE WINAPI
GetStdPalette()
{
    BEGIN_RECV_NOCONTEXT(HPALETTE, NULL);

    retval = GdGetStdPalette();

    END_RECV_NOCONTEXT();
}


//---------------------------------------------------------------------------
DUSER_API BOOL WINAPI
UtilSetBackground(HGADGET hgadChange, HBRUSH hbrBack)
{
    BOOL fSuccess = FALSE;

    if (SetGadgetFillI(hgadChange, hbrBack, BLEND_OPAQUE, 0, 0)) {
        UINT nStyle = hbrBack != NULL ? GS_OPAQUE : 0;
        fSuccess = SetGadgetStyle(hgadChange, nStyle, GS_OPAQUE);
    }

    return fSuccess;
}


//---------------------------------------------------------------------------
DUSER_API HFONT WINAPI
UtilBuildFont(LPCWSTR pszName, int idxDeciSize, DWORD nFlags, HDC hdcDevice)
{
    return GdBuildFont(pszName, idxDeciSize, nFlags, hdcDevice);
}


//---------------------------------------------------------------------------
DUSER_API BOOL WINAPI
UtilDrawBlendRect(HDC hdcDest, const RECT * prcDest, HBRUSH hbrFill, BYTE bAlpha, int wBrush, int hBrush)
{
    return GdDrawBlendRect(hdcDest, prcDest, hbrFill, bAlpha, wBrush, hBrush);
}


//---------------------------------------------------------------------------
DUSER_API BOOL WINAPI
UtilDrawOutlineRect(HDC hdc, const RECT * prcPxl, HBRUSH hbrDraw, int nThickness)
{
    return GdDrawOutlineRect(hdc, prcPxl, hbrDraw, nThickness);
}


//---------------------------------------------------------------------------
DUSER_API COLORREF WINAPI
UtilGetColor(HBITMAP hbmp, POINT * pptPxl)
{
    return GdGetColor(hbmp, pptPxl);
}


/***************************************************************************\
*
* GetGadgetTicket
*
* The GetGadgetTicket function returns the ticket that can be used to 
* identify the specified gadget.
*
* <param name="hgad">
*     A handle to the gadget to retrieve the ticket for.
* </param>
*
* <return type="DWORD">
*     If the function succeeds, the return value is a 32-bit ticket that
*     can be used to identify the specified gadget.
*     If the function fails, the return value is zero.
* </return>
*
* <remarks>
*     Tickets are created to give an external identity to a gadget.  A
*     is guaranteed to be 32 bits on all platforms.  If no ticket is
*     currently associated with this gadget, one is allocated.
* </remarks>
*
* <see type="function">LookupGadgetTicket</>
*
\***************************************************************************/

DUSER_API DWORD WINAPI
GetGadgetTicket(
    IN  HGADGET hgad)               // Handle of Gadget
{
    DuVisual * pgad;
    DWORD dwTicket;
    HRESULT hr;

    BEGIN_RECV(DWORD, 0, ContextLock::edNone);
    VALIDATE_VISUAL(gad);

    hr = pgad->GetTicket(&dwTicket);
    SET_RETURN(hr, dwTicket);

    END_RECV();
}


/***************************************************************************\
*
* LookupGadgetTicket
*
* The LookupGadgetTicket function returns the gadget that is associated with
* the specified ticket.
*
* <param name="dwTicket">
*     A ticket that has been associated with a gadget via the
*     GetGadgetTicket function.
* </param>
*
* <return type="HGADGET">
*     If the function succeeds, the return value is a handle to the gadget
*     associated with the ticket.
*     If the function fails, the return value is NULL.
* </return>
*
* <see type="function">GetGadgetTicket</>
*
\***************************************************************************/

DUSER_API HGADGET WINAPI
LookupGadgetTicket(
    IN  DWORD dwTicket)             // Ticket
{
    BEGIN_RECV(HGADGET, NULL, ContextLock::edNone);

    retval = DuVisual::LookupTicket(dwTicket);

    END_RECV();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\winapi\stdafx.h ===
#if !defined(WINAPI__StdAfx_h__INCLUDED)
#define WINAPI__StdAfx_h__INCLUDED

#pragma once

#include "CommonStdAfx.h"

#endif // WINAPI__StdAfx_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\engine\winapi\winapi.h ===
/***************************************************************************\
*
* File: WinAPI.h
*
* Description:
* This file provides a project-wide header that is included in all source 
* files specific to this project.  It is similar to a precompiled header, 
* but is designed for more rapidly changing headers.
*
* The primary purpose of this file is to determine which DirectUser 
* projects this project has direct access to instead of going through public
* API's.  It is VERY IMPORTANT that this is as minimal as possible since
* adding a new project unnecessarily reduces the benefit of project 
* partitioning.
*
*
* History:
*  1/18/2000: JStall:       Created
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
* 
\***************************************************************************/


#if !defined(WINAPI__WinAPI_h__INCLUDED)
#define WINAPI__WinAPI_h__INCLUDED

#define GADGET_ENABLE_DX
#define GADGET_ENABLE_COM
#define GADGET_ENABLE_TRANSITIONS
#include <DUser.h>

#include <DUserBaseP.h>
#include <DUserObjectAPIP.h>
#include <DUserServicesP.h>
#include <DUserMsgP.h>
#include <DUserCoreP.h>
#include <DUserLavaP.h>
#include <DUserMotionP.h>
#include <DUserCtrlP.h>

#if DBG

#define PromptInvalid(comment) \
    do \
    { \
        if (IDebug_Prompt(GetDebug(), "Validation error:\r\n" comment, __FILE__, __LINE__, "DirectUser/WinAPI Notification")) \
            AutoDebugBreak(); \
    } while (0) \

#else // DBG

#define PromptInvalid(comment) ((void) 0)

#endif // DBG

#endif // WINAPI__WinAPI_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\inc\commonstdafx.h ===
#if !defined(INC__CommonStdAfx_h__INCLUDED)
#define INC__CommonStdAfx_h__INCLUDED

#if !defined(WIN32_LEAN_AND_MEAN)
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

#if !defined(_WIN32_WINNT)
#define _WIN32_WINNT 0x0500		// TODO: Remove this when updated headers are available
#endif

#define ENABLE_MSGTABLE_API 1   // Enable MsgTable based API's
#define ENABLE_MPH          1   // Enable Whistler MPH's
#define DUSER_INCLUDE_SLIST 1   // Include S-List functions inside DUser project

#define DBG_CHECK_CALLBACKS DBG // Extra validation for checking callbacks
#define DBG_STORE_NAMES     0   // Extra validation to store names

// Windows Header Files
#ifndef WINVER
#define WINVER 0x0500
#endif 

#include <nt.h>                 // S-List definitions in ntrtl.h
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>            // Windows
#include <windowsx.h>           // User macros
#include <winuserp.h>           // User privates

// COM Header Files
#include <ObjBase.h>            // CoCreateInstance, IUnknown
#include <DDraw.h>              // DirectDraw
#include <oleidl.h>             // OLE2 Interfaces

#include <AtlBase.h>            // CComPtr
#include <AtlConv.h>            // String conversion routines


// Related services
#pragma warning(push, 3)
#include <GdiPlus.h>            // GDI+
#pragma warning(pop)


// TODO: Move DxXForms out
#pragma warning(push, 3)

#include <dxtrans.h>
#include <dxterror.h>
#include <dxbounds.h>
#include <dxhelper.h>

#pragma warning(pop)


// C RunTime Header Files
#include <stdlib.h>             // Standard library
#include <malloc.h>             // Memory allocation
#include <tchar.h>              // Character routines
#include <process.h>            // Multi-threaded routines

#if DBG
#include <memory.h>             // Debug memory routines
#endif // DBG

// Gadgets Header Files
#include <AutoUtil.h>           // External debugging support

#endif // INC__CommonStdAfx_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\inc\duserbasep.h ===
#if !defined(INC__DUserBaseP_h__INCLUDED)
#define INC__DUserBaseP_h__INCLUDED
#pragma once

#define AUTO_INLINE inline

#include "..\Engine\Base\Public.h"

#endif // INC__DUserBaseP_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\inc\autoutil.h ===
/***************************************************************************\
*
* File: AutoUtil.h
*
* Description:
* AutoUtil.h defines routinues common to most projects, including
* - Macros
* - Disabling known compiler warnings
* - Debugging / Assert
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/

#if !defined(INC__AutoUtil_h__INCLUDED)
#define INC__AutoUtil_h__INCLUDED


//
// Ensure that DBG is defined for DEBUG builds.  This is used throughout
// DirectUser for DEBUG-only code, but is only defined (by default) in the
// NT-BUILD environment.  If we are compiling using the DSP's, we need to 
// ensure that it is defined.
//

#ifdef _DEBUG
#ifndef DBG
#define DBG 1
#endif // !DBG
#endif // !_DEBUG

#include <crtdbg.h>
#include <BaseTyps.h>

#ifdef DUSER_EXPORTS
#define AUTOUTIL_API
#else  // DUSER_EXPORTS
#define AUTOUTIL_API __declspec(dllimport)
#endif // DUSER_EXPORTS


/***************************************************************************\
*
* Macros
*
\***************************************************************************/

#define QUOTE(s) #s
#define STRINGIZE(s) QUOTE(s)
#define _countof(x) (sizeof(x) / sizeof(x[0]))


/***************************************************************************\
*
* Warnings
*
\***************************************************************************/

// warnings generated with common MFC/Windows code
#pragma warning(disable: 4127)  // constant expression for Trace/Assert
#pragma warning(disable: 4134)  // message map member fxn casts
#pragma warning(disable: 4201)  // nameless unions are part of C++
#pragma warning(disable: 4511)  // private copy constructors are good to have
#pragma warning(disable: 4512)  // private operator= are good to have
#pragma warning(disable: 4514)  // unreferenced inlines are common
#pragma warning(disable: 4710)  // private constructors are disallowed
#pragma warning(disable: 4705)  // statement has no effect in optimized code
#pragma warning(disable: 4191)  // pointer-to-function casting

#pragma warning(disable: 4204)  // initialize structures with non-constant members
#pragma warning(disable: 4221)  // initialize structures using address of automatic variable 

// warnings caused by normal optimizations
#if DBG
#else // DBG
#pragma warning(disable: 4701)  // local variable *may* be used without init
#pragma warning(disable: 4702)  // unreachable code caused by optimizations
#pragma warning(disable: 4791)  // loss of debugging info in release version
#pragma warning(disable: 4189)  // initialized but unused variable
#pragma warning(disable: 4390)  // empty controlled statement
#endif // DBG

#define UNREFERENCED_MSG_PARAMETERS(uMsg, wParam, lParam, bHandled)\
    UNREFERENCED_PARAMETER(uMsg); \
    UNREFERENCED_PARAMETER(wParam); \
    UNREFERENCED_PARAMETER(lParam); \
    UNREFERENCED_PARAMETER(bHandled)



/***************************************************************************\
*
* Debugging
*
\***************************************************************************/

#undef INTERFACE
#define INTERFACE IDebug
DECLARE_INTERFACE(IDebug)
{
    STDMETHOD_(BOOL, AssertFailedLine)(THIS_ LPCSTR pszExpression, LPCSTR pszFileName, UINT idxLineNum) PURE;
    STDMETHOD_(BOOL, IsValidAddress)(THIS_ const void * lp, UINT nBytes, BOOL bReadWrite) PURE;
    STDMETHOD_(void, BuildStack)(THIS_ HGLOBAL * phStackData, UINT * pcCSEntries) PURE;
    STDMETHOD_(BOOL, Prompt)(THIS_ LPCSTR pszExpression, LPCSTR pszFileName, UINT idxLineNum, LPCSTR pszTitle) PURE;
};

EXTERN_C AUTOUTIL_API IDebug * WINAPI GetDebug();
EXTERN_C AUTOUTIL_API void _cdecl AutoTrace(const char * pszFormat, ...);

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDebug_AssertFailedLine(p, a, b, c)         (p)->lpVtbl->AssertFailedLine(p, a, b, c)
#define IDebug_IsValidAddress(p, a, b, c)           (p)->lpVtbl->IsValidAddress(p, a, b, c)
#define IDebug_BuildStack(p, a, b)                  (p)->lpVtbl->BuildStack(p, a, b)
#define IDebug_Prompt(p, a, b, c, d)                (p)->lpVtbl->Prompt(p, a, b, c, d)
#else
#define IDebug_AssertFailedLine(p, a, b, c)         (p)->AssertFailedLine(a, b, c)
#define IDebug_IsValidAddress(p, a, b, c)           (p)->IsValidAddress(a, b, c)
#define IDebug_BuildStack(p, a, b)                  (p)->BuildStack(a, b)
#define IDebug_Prompt(p, a, b, c, d)                (p)->Prompt(a, b, c, d)
#endif

// Define AutoDebugBreak

#ifndef AutoDebugBreak
#define AutoDebugBreak() _CrtDbgBreak()
#endif

// Undefine previous definitions

#ifdef ASSERT
#undef ASSERT
#endif

#ifdef Assert
#undef Assert
#endif

#ifdef AssertMsg
#undef AssertMsg
#endif

#ifdef Verify
#undef Verify
#endif

#ifdef VerifyMsg
#undef VerifyMsg
#endif

#ifdef AssertHR
#undef AssertHR
#endif

#ifdef AssertMsgHR
#undef AssertMsgHR
#endif

#ifdef VerifyHR
#undef VerifyHR
#endif

#ifdef VerifyMsgHR
#undef VerifyMsgHR
#endif

#ifdef Trace
#undef Trace
#endif


// Define Assert, Verify, etc.

#if DBG

// AutoDebug functions that are only available in DEBUG builds

#define Assert(f) \
    do \
    { \
    if (!((f)) && IDebug_AssertFailedLine(GetDebug(), STRINGIZE((f)), __FILE__, __LINE__)) \
            AutoDebugBreak(); \
    } while (0) \

#define AssertMsg(f, comment) \
    do \
    { \
        if (!((f)) && IDebug_AssertFailedLine(GetDebug(), STRINGIZE((f)) "\r\n" comment, __FILE__, __LINE__)) \
            AutoDebugBreak(); \
    } while (0) \

#define AssertHR(f) \
    do \
    { \
    if (FAILED((f)) && IDebug_AssertFailedLine(GetDebug(), STRINGIZE((f)), __FILE__, __LINE__)) \
            AutoDebugBreak(); \
    } while (0) \

#define AssertMsgHR(f, comment) \
    do \
    { \
        if (FAILED((f)) && IDebug_AssertFailedLine(GetDebug(), STRINGIZE((f)) "\r\n" comment, __FILE__, __LINE__)) \
            AutoDebugBreak(); \
    } while (0) \

#define Verify(f)               Assert((f))
#define VerifyMsg(f, comment)   AssertMsg((f), comment)
#define VerifyHR(f)             AssertHR((f))
#define VerifyMsgHR(f, comment) AssertMsgHR((f), comment)
#define DEBUG_ONLY(f)           (f)

#define ASSERT(f)               Assert((f))

#define Trace                   AutoTrace

#define AssertReadPtr(p) \
    AssertMsg(IDebug_IsValidAddress(GetDebug(), p, sizeof(char *), FALSE), "Check pointer memory is valid"); \
    AssertMsg(p != NULL, "Check pointer is not NULL")

#define AssertReadPtrSize(p, s) \
    AssertMsg(IDebug_IsValidAddress(GetDebug(), p, s, FALSE), "Check pointer memory is valid"); \
    AssertMsg(p != NULL, "Check pointer is not NULL")

#define AssertWritePtr(p) \
    AssertMsg(IDebug_IsValidAddress(GetDebug(), p, sizeof(char *), TRUE), "Check pointer memory is valid"); \
    AssertMsg(p != NULL, "Check pointer is not NULL")

#define AssertWritePtrSize(p, s) \
    AssertMsg(IDebug_IsValidAddress(GetDebug(), p, s, TRUE), "Check pointer memory is valid"); \
    AssertMsg(p != NULL, "Check pointer is not NULL")

#define AssertIndex(idx, nMax) \
    AssertMsg((idx < nMax) && (idx >= 0), "Check pointer is not NULL")

#define AssertHWND(hwnd) \
    AssertMsg(IsWindow(hwnd), "Check valid window")

#define AssertHandle(h) \
    AssertMsg(h != NULL, "Check valid handle")

#define AssertInstance(p) \
    do \
    { \
        AssertWritePtr(p); \
        p->DEBUG_AssertValid(); \
    } while (0)

#define AssertString(s) \
    do \
    { \
        Assert(s != NULL); \
    } while (0)

#else // DBG

#define Assert(f)                   ((void) 0)
#define AssertMsg(f, comment)       ((void) 0)
#define Verify(f)                   ((void)(f))
#define VerifyMsg(f, comment)       ((void)(f, comment))
#define AssertHR(f)                 ((void) 0)
#define AssertMsgHR(f, comment)     ((void) 0)
#define VerifyHR(f)                 ((void)(f))
#define VerifyMsgHR(f, comment)     ((void)(f, comment))
#define DEBUG_ONLY(f)               ((void) 0)

#define ASSERT(f)                   ((void) 0)

#define Trace               1 ? (void) 0 : AutoTrace

#define AssertReadPtr(p)            ((void) 0)
#define AssertReadPtrSize(p, s)     ((void) 0)
#define AssertWritePtr(p)           ((void) 0)
#define AssertWritePtrSize(p, s)    ((void) 0)
#define AssertIndex(idx, nMax)      ((void) 0)
#define AssertHWND(hwnd)            ((void) 0)
#define AssertHandle(h)             ((void) 0)
#define AssertInstance(p)           ((void) 0)
#define AssertString(s)             ((void) 0)

#endif // DBG


#if DBG_CHECK_CALLBACKS

#define AlwaysPromptInvalid(comment) \
    do \
    { \
        if (IDebug_Prompt(GetDebug(), "Validation error:\r\n" comment, __FILE__, __LINE__, "DirectUser/Msg Notification")) \
            AutoDebugBreak(); \
    } while (0) \

#endif // DBG_CHECK_CALLBACKS


#define CHECK_VALID_READ_PTR(p) \
    do \
    { \
        AssertReadPtr(p); \
        if (p == NULL) \
            return E_POINTER; \
    } while (0)

#define CHECK_VALID_WRITE_PTR(p) \
    do \
    { \
        AssertWritePtr(p); \
        if (p == NULL) \
            return E_POINTER; \
    } while (0)

#define SUPPRESS(ClassName) \
private: \
ClassName(const ClassName & copy); \
ClassName & operator=(const ClassName & rhs); \
public:

#endif // INC__AutoUtil_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\inc\dusercorep.h ===
#if !defined(INC__DUserCoreP_h__INCLUDED)
#define INC__DUserCoreP_h__INCLUDED
#pragma once

#define AUTO_INLINE inline

#include "..\Engine\Core\Public.h"

#endif // INC__DUserCoreP_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\inc\duserctrlp.h ===
#if !defined(INC__DUserCtrlP_h__INCLUDED)
#define INC__DUserCtrlP_h__INCLUDED
#pragma once

#define AUTO_INLINE inline

#include "..\Engine\Ctrl\Public.h"

#endif // INC__DUserCtrlP_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\inc\duser.cs ===
//-----------------------------------------------------------------------------
//
// DirectUser COM+ API
//
// Copyright (C) 2000 by Microsoft Corporation
// 
//-----------------------------------------------------------------------------

namespace DUser
{
using System;
using System.Runtime.InteropServices;

public class Common
{
    public enum StructFormat
    {
        Ansi = 1,
        Unicode = 2,
        Auto = 3,
    }

    [System.Runtime.InteropServices.ComVisible(false), sysstruct(format=StructFormat.Auto)]
    public class INITGADGET
    {
        public  uint        cbSize;
        public  uint        nThreadMode;
        public  uint        nMsgMode;
        public  int         hctxShare;
    }

    [dllimport("DUser.dll", EntryPoint="InitGadgets", SetLastError=true)]
    public static extern bool InitGadgets(INITGADGET ig);

    [dllimport("DUserCP.dll", EntryPoint="InitBridge", SetLastError=true)]
    public static extern bool InitBridge();

    [dllimport("kernel32.dll", EntryPoint="GetLastError")]
    public static extern uint GetLastError();

    public static void Init()
    {
        //
        // Initialize DUser
        //

        INITGADGET ig = new INITGADGET();
        ig.cbSize       = 12;
        ig.nThreadMode  = 1;
        ig.nMsgMode     = 2;
        ig.hctxShare    = 0;
        if (!InitGadgets(ig)) {
            throw new DUserException(GetLastError(), "Unable to initialized DUser");
        }

        if (!InitBridge()) {
            throw new DUserException(GetLastError(), "Unable to initialized DUser Bridge");
        }


        //
        // Initialize all of the DUser classes
        //

        BaseGadget.InitBaseGadget();
        MsgGadget.InitMsgGadget();
        Extension.InitExtension();
        DropTarget.InitDropTarget();
        Visual.InitVisual();
        Root.InitRoot();
    }

    public const int gmEvent            = 32768;
    public const int gmDestroy          = gmEvent + 1;
    public const int gmPaint            = gmEvent + 2;
    public const int gmInput            = gmEvent + 3;
    public const int gmChangeState      = gmEvent + 4;
    public const int gmChangeRect       = gmEvent + 5;
    public const int gmChangeStyle      = gmEvent + 6;
    public const int gmQuery            = gmEvent + 7;
    public const int gmSyncAdaptor      = gmEvent + 8;

    [System.Runtime.InteropServices.ComVisible(false), sysstruct(format=StructFormat.Auto)]
    public class Msg
    {
        public  uint        cbSize;
        public  int         nMsg;
        public  int         hgadMsg;
    }

    [System.Runtime.InteropServices.ComVisible(false), sysstruct(format=StructFormat.Auto)]
    public class EventMsg : Msg
    {
		public  uint        nMsgFlags;
    }

    [System.Runtime.InteropServices.ComVisible(false), sysstruct(format=StructFormat.Auto)]
    public class MethodMsg : Msg
    {

    }

    [dllimport("DUser.dll", EntryPoint="FindGadgetClass", SetLastError=true)]
    public static extern int FindGadgetClass([marshal(UnmanagedType.LPWStr)] string sName, uint nVersion);

    [System.Runtime.InteropServices.ComVisible(false), sysstruct(format=StructFormat.Auto)]
    public class ContructInfo
    {
    }

    public const uint gprFailed     = 0xFFFFFFFF;
    public const uint gprNotHandled = 0;
    public const uint gprComplete   = 1;
    public const uint gprPartial    = 2;

    public delegate uint GadgetEventProc(Common.EventMsg pmsg);
    public delegate void GadgetMethodProc(Common.MethodMsg pmsg);

    [dllimport("DUser.dll", EntryPoint="BuildGadget", SetLastError=true)]
    public static extern int BuildGadget(int hClass, ContructInfo ci);

    [dllimport("DUserCP.dll", EntryPoint="BuildBridgeGadget", SetLastError=true)]
    public static extern int BuildBridgeGadget(int hClass, ContructInfo ci, 
            GadgetEventProc pfnEvent, GadgetMethodProc pfnMethod);

    [dllimport("DUser.dll", EntryPoint="CastGadgetDirect", SetLastError=true)]
    public static extern int CastGadgetDirect(int hgad);

    [System.Runtime.InteropServices.ComVisible(false), sysstruct(format=StructFormat.Auto)]
    public class POINT
    {
		public  int     x;
        public  int     y;
    }

    [System.Runtime.InteropServices.ComVisible(false), sysstruct(format=StructFormat.Auto)]
    public class SIZE
    {
		public  int     cx;
        public  int     cy;
    }

    [System.Runtime.InteropServices.ComVisible(false), sysstruct(format=StructFormat.Auto)]
    public class RECT
    {
		public  int     left;
        public  int     top;
        public  int     right;
        public  int     bottom;
    }

    [dllimport("DUser.dll", EntryPoint="GetStdColorBrushI")]
    public static extern int GetStdColorBrush(int idColor);
};


public class Gadget
{
    public int pgad;

    protected int h(Gadget g)
    {
        return g != null ? g.pgad : 0;
    }

    protected bool s(uint hr)
    {
        return (hr & 0x80000000) == 0;
    }

    protected bool f(uint hr)
    {
        return (hr & 0x80000000) != 0;
    }

    public virtual uint OnEvent(Common.EventMsg pmsg)
    {
        return 0;
    }

    protected uint RawEventProc(Common.EventMsg pmsg)
    {
        return OnEvent(pmsg);
    }

    public virtual void OnMethod(Common.MethodMsg pmsg)
    {

    }

    protected void RawMethodProc(Common.MethodMsg pmsg)
    {
        OnMethod(pmsg);
    }
};


class DUserException : System.SystemException
{
    public DUserException(uint error)
    {
        this.error = error;
    }

    public DUserException(uint error, string sReason) : base(sReason)
    {
        this.error = error;
    }

    public uint error;
};

//---------------------------------------------------------------------------
//
// Stub class BaseGadget
//

class BaseGadget : Gadget
{
    private static int idBaseGadget;

    public static void InitBaseGadget()
    {
        idBaseGadget = Common.FindGadgetClass("BaseGadgetBridge", 1);
        if (idBaseGadget == 0) {
            throw new DUserException(Common.GetLastError(), "Unable to find registered BaseGadget");
        }
    }

    [dllimport("DUserCP.dll")]
    public static extern uint SBaseGadgetOnEvent(Common.EventMsg pmsg);

    public override uint OnEvent(Common.EventMsg pmsg)
    {
        return SBaseGadgetOnEvent(pmsg);
    }

    [dllimport("DUser.dll", EntryPoint="BaseGadgetOnEvent", SetLastError=true)]
    public static extern uint BaseGadgetOnEvent(Common.EventMsg pmsg);

    [dllimport("DUser.dll", EntryPoint="BaseGadgetGetFilter", SetLastError=true)]
    public static extern uint BaseGadgetGetFilter([@out] uint pnFilter);

    public const uint gmfiPaint             = 0x00000001;
    public const uint gmfiInputKeyboard     = 0x00000002;
    public const uint gmfiInputMouse        = 0x00000004;
    public const uint gmfiInputMouseMove    = 0x00000008;
    public const uint gmfiChangeState       = 0x00000010;
    public const uint gmfiChangeRect        = 0x00000020;
    public const uint gmfiChangeStyle       = 0x00000040;
    public const uint gmfiAll               = 0xFFFFFFFF;

    public void GetFilter(ref uint nFilter)
    {
        uint hr = BaseGadgetGetFilter(nFilter);
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }

    [dllimport("DUser.dll", EntryPoint="BaseGadgetSetFilter", SetLastError=true)]
    public static extern uint BaseGadgetSetFilter(uint nNewFilter, uint nMask);

    public void SetFilter(uint nNewFilter, uint nMask)
    {
        uint hr = BaseGadgetSetFilter(nNewFilter, nMask);
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }

    [dllimport("DUser.dll", EntryPoint="BaseGadgetAddHandler", SetLastError=true)]
    public static extern uint BaseGadgetAddHandler(int nMsg, int pgbHandler);

    public void AddHandler(int nMsg, BaseGadget vb)
    {
        uint hr = BaseGadgetAddHandler(nMsg, h(vb));
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }

    [dllimport("DUser.dll", EntryPoint="BaseGadgetRemoveHandler", SetLastError=true)]
    public static extern uint BaseGadgetRemoveHandler(int nMsg, int pgbHandler);

    public void RemoveHandler(int nMsg, BaseGadget vb)
    {
        uint hr = BaseGadgetRemoveHandler(nMsg, h(vb));
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }
}


//---------------------------------------------------------------------------
//
// Stub class MsgGadget
//

class MsgGadget : BaseGadget
{
    private static int idMsgGadget;

    public static void InitMsgGadget()
    {
        idMsgGadget = Common.FindGadgetClass("MsgGadgetBridge", 1);
        if (idMsgGadget == 0) {
            throw new DUserException(Common.GetLastError(), "Unable to find registered MsgGadget");
        }
    }

    [dllimport("DUserCP.dll")]
    protected static extern uint SMsgGadgetOnEvent(Common.EventMsg pmsg);

    public override uint OnEvent(Common.EventMsg pmsg)
    {
        return SMsgGadgetOnEvent(pmsg);
    }
}


//---------------------------------------------------------------------------
//
// Stub class Extension
//

class Extension : MsgGadget
{
    private static int idExtension;

    public static void InitExtension()
    {
        idExtension = Common.FindGadgetClass("ExtensionBridge", 1);
        if (idExtension == 0) {
            throw new System.SystemException("Unable to find registered Extension");
        }
    }

    [dllimport("DUser.dll", EntryPoint="ExtensionOnRemoveExisting", SetLastError=true)]
    public static extern int ExtensionOnRemoveExisting();

    [dllimport("DUser.dll", EntryPoint="ExtensionOnDestroySubject", SetLastError=true)]
    public static extern int ExtensionOnDestroySubject();

    [dllimport("DUser.dll", EntryPoint="ExtensionOnAsyncDestroy", SetLastError=true)]
    public static extern int ExtensionOnAsyncDestroy();

}


//---------------------------------------------------------------------------
//
// Stub class DropTarget
//

class DropTarget : Extension
{
    private static int idDropTarget;

    public static void InitDropTarget()
    {
        idDropTarget = Common.FindGadgetClass("DropTargetBridge", 1);
        if (idDropTarget == 0) {
            throw new System.SystemException("Unable to find registered DropTarget");
        }
    }

}


//---------------------------------------------------------------------------
//
// Stub class Visual
//

class Visual : BaseGadget
{
    private static int idVisual;

    public static void InitVisual()
    {
        idVisual = Common.FindGadgetClass("VisualBridge", 1);
        if (idVisual == 0) {
            throw new System.SystemException("Unable to find registered Visual");
        }
    }

    public class VisualCI : Common.ContructInfo
    {
        public  int         pgadParent;
    };

    public Visual(Visual vParent)
    {
        CommonBuild(vParent.pgad, idVisual);
    }

    public Visual(Visual vParent, int idClass)
    {
        CommonBuild(vParent.pgad, idClass);
    }

    public Visual(HGadget gadParent)
    {
        CommonBuild(Common.CastGadgetDirect(gadParent.hgad), idVisual);
    }

    public Visual(HGadget gadParent, int idClass)
    {
        CommonBuild(Common.CastGadgetDirect(gadParent.hgad), idClass);
    }

    protected Visual(int pgv)
    {
        this.pgad = pgv;
    }

    private void CommonBuild(int pgadParent, int idClass)
    {
        VisualCI ci = new VisualCI();
        ci.pgadParent = pgadParent;
        int pgvThis = Common.BuildBridgeGadget(idClass, ci,
                new Common.GadgetEventProc(this.RawEventProc), new Common.GadgetMethodProc(this.RawMethodProc));
        //int pgvThis = Common.BuildGadget(idClass, ci);
        if (pgvThis != 0) {
            this.pgad = pgvThis;
        } else {
            throw new DUserException(Common.GetLastError(), "Unable to create new Visual");
        }
    }

    [dllimport("DUserCP.dll")]
    public static extern uint SVisualOnEvent(Common.EventMsg pmsg);

    public override uint OnEvent(Common.EventMsg pmsg)
    {
        return SVisualOnEvent(pmsg);
    }

    public enum EOrder
    {
        voAny           = 0,
        voBefore        = 1,
        voBehind        = 2,
        voTop           = 3,
        voBottom        = 4,
    };

    [dllimport("DUser.dll", EntryPoint="VisualSetOrder", SetLastError=true)]
    public static extern uint VisualSetOrder(int pgvThis, int pgvOther, uint nCmd);

    public void SetOrder(Visual vOther, EOrder o)
    {
        uint hr = VisualSetOrder(this.pgad, h(vOther), (uint) o);
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }

    [dllimport("DUser.dll", EntryPoint="VisualSetParent", SetLastError=true)]
    public static extern uint VisualSetParent(int pgvThis, int pgvParent, int pgvOther, uint nCmd);

    public void SetParent(Visual vParent, Visual vOther, uint nCmd)
    {
        uint hr = VisualSetParent(this.pgad, h(vParent), h(vOther), nCmd);
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }

    public enum EGadget
    {
        vgParent        = 0,
        vgNext          = 1,
        vgPrev          = 2,
        vgTopChild      = 3,
        vgBottomChild   = 4,
        vgRoot          = 5,
    };

    [dllimport("DUser.dll", EntryPoint="VisualGetGadget", SetLastError=true)]
    public static extern uint VisualGetGadget(int pgvThis, uint nCmd, [@out] int ppgv);

    public Visual GetGadget(EGadget nCmd)
    {
        int pgv = 0;
        uint hr = VisualGetGadget(this.pgad, (uint) nCmd, pgv);
        if (f(hr)) {
            throw new DUserException(hr);
        }
        return new Visual(pgv);
    }

    public const uint gsRelative        = 0x00000001;
    public const uint gsVisible         = 0x00000002;
    public const uint gsEnabled         = 0x00000004;
    public const uint gsBuffered        = 0x00000008;
    public const uint gsAllowSubClass   = 0x00000010;
    public const uint gsKeyboardFocus   = 0x00000020;
    public const uint gsMouseFocus      = 0x00000040;
    public const uint gsClipInside      = 0x00000080;
    public const uint gsClipSiblings    = 0x00000100;
    public const uint gsHRedraw         = 0x00000200;
    public const uint gsVRedraw         = 0x00000400;
    public const uint gsOpaque          = 0x00000800;
    public const uint gsZeroOrigin      = 0x00001000;
    public const uint gsCustomHitTest   = 0x00002000;
    public const uint gsAdaptor         = 0x00004000;
    public const uint gsCached          = 0x00008000;

    [dllimport("DUser.dll", EntryPoint="VisualGetStyle", SetLastError=true)]
    public static extern uint VisualGetStyle(int pgvThis, [@out] uint pnStyle);

    public uint GetStyle()
    {
        uint nStyle = 0;
        uint hr = VisualGetStyle(this.pgad, nStyle);
        if (f(hr)) {
            throw new DUserException(hr);
        }
        return nStyle;
    }

    [dllimport("DUser.dll", EntryPoint="VisualSetStyle", SetLastError=true)]
    public static extern uint VisualSetStyle(int pgvThis, uint nNewStyle, uint nMask);

    public void SetStyle(uint nNewStyle, uint nMask)
    {
        uint hr = VisualSetStyle(this.pgad, nNewStyle, nMask);
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }

    [dllimport("DUser.dll", EntryPoint="VisualSetKeyboardFocus", SetLastError=true)]
    public static extern uint VisualSetKeyboardFocus(int pgvThis);

    public void SetKeyboardFocus()
    {
        uint hr = VisualSetKeyboardFocus(this.pgad);
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }

    [dllimport("DUser.dll", EntryPoint="VisualIsParentChainStyle", SetLastError=true)]
    public static extern uint VisualIsParentChainStyle(int pgvThis, uint nStyle, [@out] int pfResult, uint nFlags);

    [dllimport("DUser.dll", EntryPoint="VisualGetProperty", SetLastError=true)]
    public static extern uint VisualGetProperty(int pgvThis, int id, [@out] int ppvValue);

    public int GetProperty(int id)
    {
        int pvValue = 0;
        uint hr = VisualGetProperty(this.pgad, id, pvValue);
        if (f(hr)) {
            throw new DUserException(hr);
        }
        return pvValue;
    }

    [dllimport("DUser.dll", EntryPoint="VisualSetProperty", SetLastError=true)]
    public static extern uint VisualSetProperty(int pgvThis, int id, int pvValue);

    public void SetProperty(int id, int pvValue)
    {
        uint hr = VisualSetProperty(this.pgad, id, pvValue);
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }

    [dllimport("DUser.dll", EntryPoint="VisualRemoveProperty", SetLastError=true)]
    public static extern uint VisualRemoveProperty(int pgvThis, int id);

    public void RemoveProperty(int id)
    {
        uint hr = VisualRemoveProperty(this.pgad, id);
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }

    [dllimport("DUser.dll", EntryPoint="VisualInvalidate", SetLastError=true)]
    public static extern uint VisualInvalidate(int pgvThis);

    public void Invalidate()
    {
        uint hr = VisualInvalidate(this.pgad);
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }

    [dllimport("DUser.dll", EntryPoint="VisualSetFillI", SetLastError=true)]
    public static extern uint VisualSetFillI(int pgvThis, int hbrFill, byte bAlpha, int w, int h);

    public void SetFill(int hbrFill, byte bAlpha)
    {
        uint hr = VisualSetFillI(this.pgad, hbrFill, bAlpha, 0, 0);
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }

    [dllimport("DUser.dll", EntryPoint="VisualGetScale", SetLastError=true)]
    public static extern uint VisualGetScale(int pgvThis, [@out] float pflX, [@out] float pflY);

    public void GetScale(ref float flX, ref float flY)
    {
        uint hr = VisualGetScale(this.pgad, flX, flY);
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }

    [dllimport("DUser.dll", EntryPoint="VisualSetScale", SetLastError=true)]
    public static extern uint VisualSetScale(int pgvThis, float flX, float flY);

    public void VisualSetScale(float flX, float flY)
    {
        uint hr = VisualSetScale(this.pgad, flX, flY);
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }

    [dllimport("DUser.dll", EntryPoint="VisualGetRotation", SetLastError=true)]
    public static extern uint VisualGetRotation(int pgvThis, [@out] float pflRotationRad);

    public void GetRotation(ref float flRotationRad)
    {
        uint hr = VisualGetRotation(this.pgad, flRotationRad);
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }

    [dllimport("DUser.dll", EntryPoint="VisualSetRotation", SetLastError=true)]
    public static extern uint VisualSetRotation(int pgvThis, float flRotationRad);

    public void SetRotation(float flRotationRad)
    {
        uint hr = VisualSetRotation(this.pgad, flRotationRad);
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }

    [dllimport("DUser.dll", EntryPoint="VisualGetCenterPoint", SetLastError=true)]
    public static extern uint VisualGetCenterPoint(int pgvThis, [@out] float pflX, [@out] float pflY);

    public void GetCenterPoint(ref float flX, ref float flY)
    {
        uint hr = VisualGetCenterPoint(this.pgad, flX, flY);
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }

    [dllimport("DUser.dll", EntryPoint="VisualSetCenterPoint", SetLastError=true)]
    public static extern uint VisualSetCenterPoint(int pgvThis, float flX, float flY);

    public void SetCenterPoint(float flX, float flY)
    {
        uint hr = VisualSetCenterPoint(this.pgad, flX, flY);
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }

    [System.Runtime.InteropServices.ComVisible(false), sysstruct(format=Common.StructFormat.Auto)]
    public class BUFFER_INFO
    {
        public  uint        cbSize;
        public  uint        nMask;
        public  uint        nStyle;
        public  byte        bAlpha;
    }

    [dllimport("DUser.dll", EntryPoint="VisualGetBufferInfo", SetLastError=true)]
    public static extern uint VisualGetBufferInfo(int pgvThis, [@out] BUFFER_INFO pbi);

    [dllimport("DUser.dll", EntryPoint="VisualSetBufferInfo", SetLastError=true)]
    public static extern uint VisualSetBufferInfo(int pgvThis, BUFFER_INFO pbi);

    [dllimport("DUser.dll", EntryPoint="VisualGetSize", SetLastError=true)]
    public static extern uint VisualGetSize(int pgvThis, [@out] Common.SIZE psizeLogicalPxl);


    public const uint sgrMove       = 0x00000001;
    public const uint sgrSize       = 0x00000002;
    public const uint sgrClient     = 0x00000004;
    public const uint sgrParent     = 0x00000008;

    [dllimport("DUser.dll", EntryPoint="VisualGetRect", SetLastError=true)]
    public static extern uint VisualGetRect(int pgvThis, uint nFlags, [@out] Common.RECT prcPxl);

    public void GetRect(uint nFlags, ref Common.RECT rcPxl)
    {
        uint hr = VisualGetRect(this.pgad, nFlags, rcPxl);
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }

    [dllimport("DUser.dll", EntryPoint="VisualSetRect", SetLastError=true)]
    public static extern uint VisualSetRect(int pgvThis, uint nFlags, Common.RECT prcPxl);

    public void SetRect(uint nFlags, Common.RECT rc)
    {
        uint hr = VisualSetRect(this.pgad, nFlags, rc);
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }

    public void SetRect(uint nFlags, int x, int y, int w, int h)
    {
        Common.RECT rc = new Common.RECT();
        rc.left = x;
        rc.top = y;
        rc.right = x + w;
        rc.bottom = y + h;
        uint hr = VisualSetRect(this.pgad, nFlags, rc);
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }

    [dllimport("DUser.dll", EntryPoint="VisualMapPoints", SetLastError=true)]
    public static extern uint VisualMapPoints(int pgvThis, Visual pgvTo, [@out] Common.POINT rgptClientPxl, int cPts);
}


//---------------------------------------------------------------------------
//
// Stub class Root
//

class Root : Visual
{
    private static int idRoot;

    public static void InitRoot()
    {
        idRoot = Common.FindGadgetClass("RootBridge", 1);
        if (idRoot == 0) {
            throw new DUserException(Common.GetLastError(), "Unable to find registered Root");
        }
    }

    public Root(Visual vParent) : base(vParent, idRoot)
    {

    }

    [dllimport("DUserCP.dll")]
    public static extern uint SRootOnEvent(Common.EventMsg pmsg);

    public override uint OnEvent(Common.EventMsg pmsg)
    {
        return SRootOnEvent(pmsg);
    }

    [dllimport("DUser.dll", EntryPoint="RootGetFocus", SetLastError=true)]
    public static extern uint RootGetFocus(int pgvThis, [@out] int ppgvFocus);

    public Visual GetFocus()
    {
        int pgvFocus = 0;
        uint hr = RootGetFocus(this.pgad, pgvFocus);
        if (f(hr)) {
            throw new DUserException(hr);
        }
        return new Visual(pgvFocus);
    }

    [dllimport("DUser.dll", EntryPoint="RootFindFromPoint", SetLastError=true)]
    public static extern uint RootFindFromPoint(int pgvThis, Common.POINT ptContainerPxl, uint nFlags, [@out] Common.POINT pptClientPxl, [@out] int ppgvFound);

    public void FindFromPoint(Common.POINT ptContainerPxl, uint nFlags, ref Common.POINT ptClientPxl, ref Visual vFound)
    {
        int pgvFound = 0;
        uint hr = RootFindFromPoint(this.pgad, ptContainerPxl, nFlags, ptClientPxl, pgvFound);
        if (f(hr)) {
            throw new DUserException(hr);
        }
        vFound = new Visual(pgvFound);
    }

    [System.Runtime.InteropServices.ComVisible(false), sysstruct(format=Common.StructFormat.Auto)]
    public class ROOT_INFO
    {
        public  uint        cbSize;
        public  uint        nMask;
        public  uint        nOptions;
        public  uint        nSurface;
        public  uint        nDropTarget;
        public  int         pal;
    }

    [dllimport("DUser.dll", EntryPoint="RootGetRootInfo", SetLastError=true)]
    public static extern uint RootGetRootInfo(int pgvThis, ROOT_INFO pri);

    public void GetRootInfo(ref ROOT_INFO ri)
    {
        uint hr = RootGetRootInfo(this.pgad, ri);
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }

    [dllimport("DUser.dll", EntryPoint="RootSetRootInfo", SetLastError=true)]
    public static extern uint RootSetRootInfo(int pgvThis, ROOT_INFO pri);

    public void SetRootInfo(ROOT_INFO ri)
    {
        uint hr = RootSetRootInfo(this.pgad, ri);
        if (f(hr)) {
            throw new DUserException(hr);
        }
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\inc\duserlavap.h ===
#if !defined(INC__DUserLavaP_h__INCLUDED)
#define INC__DUserLavaP_h__INCLUDED
#pragma once

#define AUTO_INLINE inline

#include "..\Engine\Lava\Public.h"

#endif // INC__DUserLavaP_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\inc\dusermotionp.h ===
#if !defined(INC__DUserMotionP_h__INCLUDED)
#define INC__DUserMotionP_h__INCLUDED
#pragma once

#define AUTO_INLINE inline

#include "..\Engine\Motion\Public.h"

#endif // INC__DUserMotionP_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\inc\duserobjectapip.h ===
#if !defined(INC__DUserGIDLP_h__INCLUDED)
#define INC__DUserGIDLP_h__INCLUDED
#pragma once

#define AUTO_INLINE inline

#include "..\Engine\ObjectAPI\Public.h"

#endif // INC__DUserGIDLP_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\inc\duserservicesp.h ===
#if !defined(INC__DUserServicesP_h__INCLUDED)
#define INC__DUserServicesP_h__INCLUDED
#pragma once

#define AUTO_INLINE inline

#include "..\Engine\Services\Public.h"

#endif // INC__DUserServicesP_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\inc\duserwinapip.h ===
#if !defined(INC__DUserWinAPIP_h__INCLUDED)
#define INC__DUserWinAPIP_h__INCLUDED
#pragma once

#define AUTO_INLINE inline

#include "..\Engine\WinAPI\Public.h"

#endif // INC__DUserWinAPIP_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\inc\duserx.h ===
#if !defined(DUSER__DUserX_h__INCLUDED)
#define DUSER__DUserX_h__INCLUDED
#pragma once

#include "..\..\Util\DUserX\Public.h"

#endif // DUSER__DUserX_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\inc\dusermsgp.h ===
#if !defined(INC__DUserMsgP_h__INCLUDED)
#define INC__DUserMsgP_h__INCLUDED
#pragma once

#define AUTO_INLINE inline

#include "..\Engine\Msg\Public.h"

#endif // INC__DUserMsgP_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\inc\dusergadget.cs ===
namespace DUser
{
using System;
using System.Runtime.InteropServices;

public class HGadget
{
    public int hgad;

    public HGadget(int hwnd)
    {
        int hgad = CreateGadget(hwnd, gcHwndHost, new GADGETPROC(this.RawGadgetProc), 0);
        if (hgad != 0)
        {
            this.hgad = hgad;
        }
        else
        {
            uint error = Common.GetLastError();
            throw new System.SystemException("Unable to create new HGadget");
        }
    }

    public HGadget(HGadget gadParent)
    {
        int hgad = CreateGadget(gadParent.hgad, gcSimple, 
                new GADGETPROC(this.RawGadgetProc), 0);
        if (hgad != 0)
        {
            this.hgad = hgad;
        }
        else
        {
            uint error = Common.GetLastError();
            throw new System.SystemException("Unable to create new HGadget");
        }
    }

    public static uint gprFailed        = 0xFFFFFFFF;
    public static uint gprNotHandled    = 0;
    public static uint gprComplete      = 1;
    public static uint gprPartial       = 2;

    public delegate uint GADGETPROC(int hgadCur, int pvCur, Common.EventMsg pmsg);

    public static uint gcHwndHost   = 0x00000001;
    public static uint gcSimple     = 0x00000005;

    [dllimport("duser.dll", EntryPoint="CreateGadget", SetLastError=true)]
    public static extern int CreateGadget(int hParent, uint nFlags, GADGETPROC pfn, int pvData);

    [dllimport("user32.dll")]
    public static extern int MessageBox(int h, string m, string c, int type);

    public virtual uint GadgetProc(Common.EventMsg pmsg)
    {
/*
        switch (pmsg.nMsg)
        {
        case Common.gmInput:
            MessageBox(0, "gmInput", "Gadget::GadgetProc()", 0);
            break;

        case Common.gmChangeState:
            MessageBox(0, "gmChangeState", "Gadget::GadgetProc()", 0);
            break;
        }
*/
        return gprNotHandled;
    }

    [dllimport("kernel32.dll", EntryPoint="OutputDebugString")]
    public static extern void OutputDebugString(string s);

    private uint RawGadgetProc(int hgadCur, int pvCur, Common.EventMsg pmsg)
    {
        System.Text.StringBuilder sb = new System.Text.StringBuilder();
        sb.Append("hgad: ");
        sb.Append(pmsg.hgadMsg);
        sb.Append("  MSG: ");
        sb.Append(pmsg.nMsg);
        sb.Append('\n');
        OutputDebugString(sb.ToString());

        return this.GadgetProc(pmsg);
    }

    public static uint gmfiPaint            = 0x00000001;
    public static uint gmfiInputKeyboard    = 0x00000002;
    public static uint gmfiInputMouse       = 0x00000004;
    public static uint gmfiInputMouseMove   = 0x00000008;
    public static uint gmfiChangeState      = 0x00000010;
    public static uint gmfiChangeRect       = 0x00000020;
    public static uint gmfiChangeStyle      = 0x00000040;
    public static uint gmfiAll              = 0xFFFFFFFF;

    [dllimport("duser.dll", EntryPoint="SetGadgetMessageFilter")]
    public static extern bool SetGadgetMessageFilter(int hgadChange, int pvCookie, uint nNewFilter, uint nMask);

    public void SetMessageFilter(uint nNewFilter, uint nMask)
    {
        SetGadgetMessageFilter(this.hgad, 0, nNewFilter, nMask);
    }

    public const uint gsRelative        = 0x00000001;
    public const uint gsVisible         = 0x00000002;
    public const uint gsEnabled         = 0x00000004;
    public const uint gsBuffered        = 0x00000008;
    public const uint gsAllowSubClass   = 0x00000010;
    public const uint gsKeyboardFocus   = 0x00000020;
    public const uint gsMouseFocus      = 0x00000040;
    public const uint gsClipInside      = 0x00000080;
    public const uint gsClipSiblings    = 0x00000100;
    public const uint gsHRedraw         = 0x00000200;
    public const uint gsVRedraw         = 0x00000400;
    public const uint gsOpaque          = 0x00000800;
    public const uint gsZeroOrigin      = 0x00001000;
    public const uint gsCustomHitTest   = 0x00002000;
    public const uint gsAdaptor         = 0x00004000;
    public const uint gsCached          = 0x00008000;

    [dllimport("duser.dll", EntryPoint="SetGadgetStyle")]
    public static extern bool SetGadgetStyle(int hgadChange, uint nNewStyle, uint nMask);

    public bool SetStyle(uint nNewStyle, uint nMask)
    {
        return SetGadgetStyle(this.hgad, nNewStyle, nMask);
    }

    [dllimport("duser.dll", EntryPoint="SetGadgetFillI")]
    public static extern bool SetGadgetFill(int hgadChange, int hbr, byte bAlpha, int w, int h);

    public bool SetFill(int hbr)
    {
        return SetGadgetFill(this.hgad, hbr, 255, 0, 0);
    }

    public const uint sgrMove       = 0x00000001;
    public const uint sgrSize       = 0x00000002;
    public const uint sgrClient     = 0x00000004;
    public const uint sgrParent     = 0x00000008;
    
    [dllimport("duser.dll", EntryPoint="SetGadgetRect", SetLastError=true)]
    public static extern bool SetGadgetRect(int hgadChange, int x, int y, int w, int h, uint nFlags);

    public bool SetRect(int x, int y, int w, int h, uint nFlags)
    {
        return SetGadgetRect(this.hgad, x, y, w, h, nFlags);
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\inc\dxtransguid.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.03.0285 */
/* Compiler settings for dxtrans.idl:
    Oicf (OptLev=i2), W0, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IDXBaseObject,0x17B59B2B,0x9CC8,0x11d1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTransformFactory,0x6A950B2B,0xA971,0x11d1,0x81,0xC8,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXTransform,0x30A5FB78,0xE11F,0x11d1,0x90,0x64,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXSurfacePick,0x30A5FB79,0xE11F,0x11d1,0x90,0x64,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTBindHost,0xD26BCE55,0xE9DC,0x11d1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTaskManager,0x254DBBC1,0xF922,0x11d0,0x88,0x3A,0x3C,0x8B,0x00,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDXSurfaceFactory,0x144946F5,0xC4D4,0x11d1,0x81,0xD1,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXSurfaceModifier,0x9EA3B637,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXSurface,0xB39FD73F,0xE139,0x11d1,0x90,0x65,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXSurfaceInit,0x9EA3B639,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXARGBSurfaceInit,0x9EA3B63A,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXARGBReadPtr,0xEAAAC2D6,0xC290,0x11d1,0x90,0x5D,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXARGBReadWritePtr,0xEAAAC2D7,0xC290,0x11d1,0x90,0x5D,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXDCLock,0x0F619456,0xCF39,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTScaleOutput,0xB2024B50,0xEE77,0x11d1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXGradient,0xB2024B51,0xEE77,0x11d1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXGradient2,0xd0ef2a80,0x61dc,0x11d2,0xb2,0xeb,0x00,0xa0,0xc9,0x36,0xb2,0x12);


MIDL_DEFINE_GUID(IID, IID_IDXTScale,0xB39FD742,0xE139,0x11d1,0x90,0x65,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTLabel,0xC0C17F0E,0xAE41,0x11d1,0x9A,0x3B,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(IID, IID_IDXRasterizer,0x9EA3B635,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXEffect,0xE31FB81B,0x1335,0x11d1,0x81,0x89,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXLookupTable,0x01BAFC7F,0x9E63,0x11d1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDX2DDebug,0x03BB2457,0xA279,0x11d1,0x81,0xC6,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDX2D,0x9EFD02A9,0xA996,0x11d1,0x81,0xC9,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXRawSurface,0x09756C8A,0xD96A,0x11d1,0x90,0x62,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, LIBID_DXTRANSLib,0x54314D1D,0x35FE,0x11d1,0x81,0xA1,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTransformFactory,0xD1FE6762,0xFC48,0x11D0,0x88,0x3A,0x3C,0x8B,0x00,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTaskManager,0x4CB26C03,0xFF93,0x11d0,0x81,0x7E,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTScale,0x555278E2,0x05DB,0x11D1,0x88,0x3A,0x3C,0x8B,0x00,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTLabel,0x54702535,0x2606,0x11D1,0x99,0x9C,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_DX2D,0x473AA80B,0x4577,0x11D1,0x81,0xA8,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXSurface,0x0E890F83,0x5F79,0x11D1,0x90,0x43,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_DXSurfaceModifier,0x3E669F1D,0x9C23,0x11d1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_DXRasterizer,0x8652CE55,0x9E80,0x11D1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_DXGradient,0xC6365470,0xF667,0x11d1,0x90,0x67,0x00,0xC0,0x4F,0xD9,0x18,0x9D);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.03.0285 */
/* Compiler settings for dxtrans.idl:
    Oicf (OptLev=i2), W0, Zp8, env=Win64 (32b run,appending), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IDXBaseObject,0x17B59B2B,0x9CC8,0x11d1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTransformFactory,0x6A950B2B,0xA971,0x11d1,0x81,0xC8,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXTransform,0x30A5FB78,0xE11F,0x11d1,0x90,0x64,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXSurfacePick,0x30A5FB79,0xE11F,0x11d1,0x90,0x64,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTBindHost,0xD26BCE55,0xE9DC,0x11d1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTaskManager,0x254DBBC1,0xF922,0x11d0,0x88,0x3A,0x3C,0x8B,0x00,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDXSurfaceFactory,0x144946F5,0xC4D4,0x11d1,0x81,0xD1,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXSurfaceModifier,0x9EA3B637,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXSurface,0xB39FD73F,0xE139,0x11d1,0x90,0x65,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXSurfaceInit,0x9EA3B639,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXARGBSurfaceInit,0x9EA3B63A,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXARGBReadPtr,0xEAAAC2D6,0xC290,0x11d1,0x90,0x5D,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXARGBReadWritePtr,0xEAAAC2D7,0xC290,0x11d1,0x90,0x5D,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXDCLock,0x0F619456,0xCF39,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTScaleOutput,0xB2024B50,0xEE77,0x11d1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXGradient,0xB2024B51,0xEE77,0x11d1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXGradient2,0xd0ef2a80,0x61dc,0x11d2,0xb2,0xeb,0x00,0xa0,0xc9,0x36,0xb2,0x12);


MIDL_DEFINE_GUID(IID, IID_IDXTScale,0xB39FD742,0xE139,0x11d1,0x90,0x65,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTLabel,0xC0C17F0E,0xAE41,0x11d1,0x9A,0x3B,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(IID, IID_IDXRasterizer,0x9EA3B635,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXEffect,0xE31FB81B,0x1335,0x11d1,0x81,0x89,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXLookupTable,0x01BAFC7F,0x9E63,0x11d1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDX2DDebug,0x03BB2457,0xA279,0x11d1,0x81,0xC6,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDX2D,0x9EFD02A9,0xA996,0x11d1,0x81,0xC9,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXRawSurface,0x09756C8A,0xD96A,0x11d1,0x90,0x62,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, LIBID_DXTRANSLib,0x54314D1D,0x35FE,0x11d1,0x81,0xA1,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTransformFactory,0xD1FE6762,0xFC48,0x11D0,0x88,0x3A,0x3C,0x8B,0x00,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTaskManager,0x4CB26C03,0xFF93,0x11d0,0x81,0x7E,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTScale,0x555278E2,0x05DB,0x11D1,0x88,0x3A,0x3C,0x8B,0x00,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTLabel,0x54702535,0x2606,0x11D1,0x99,0x9C,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_DX2D,0x473AA80B,0x4577,0x11D1,0x81,0xA8,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXSurface,0x0E890F83,0x5F79,0x11D1,0x90,0x43,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_DXSurfaceModifier,0x3E669F1D,0x9C23,0x11d1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_DXRasterizer,0x8652CE55,0x9E80,0x11D1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_DXGradient,0xC6365470,0xF667,0x11d1,0x90,0x67,0x00,0xC0,0x4F,0xD9,0x18,0x9D);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\inc\renderutil.h ===
#if !defined(DUSER__RenderUtil_h__INCLUDED)
#define DUSER__RenderUtil_h__INCLUDED
#pragma once

#include "..\..\Util\RenderUtil\Public.h"

#endif // DUSER__RenderUtil_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\inc\rockall.hpp ===
#if !defined(INC__RockAll_hpp__INCLUDED)
#define INC__RockAll_hpp__INCLUDED
#pragma once

#include "..\Engine\RockAll\Interface\RockAll.hpp"

#endif // INC__RockAll_hpp__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\inc\icecap.h ===
//-----------------------------------------------------------------------------
//
//  File: Icecap.h
//  Copyright (C) 1997-1998 Microsoft Corporation
//  All rights reserved.
//
//  This header file is part of IceCAP {{rmj}}.{{rmm}}.{{rup}}.  It is
//  MICROSOFT CONFIDENTIAL, and should not be distributed except under NDA.
//
//-----------------------------------------------------------------------------

// ICECAP.H
// interface to the Datalocality APIs

#ifndef __ICECAP_H__
#define __ICECAP_H__

#ifndef DONTUSEICECAPLIB
#pragma comment(lib, "IceCAP.lib")
#endif	// USEICECAPLIB

#ifdef __cplusplus
extern "C" {
#endif

// Defines for Levels and Id's
#define PROFILE_GLOBALLEVEL 1
#define PROFILE_PROCESSLEVEL 2
#define PROFILE_THREADLEVEL 3
#define PROFILE_FIBERLEVEL 4
#define PROFILE_CURRENTID ((unsigned long)0xFFFFFFFF)

// Start/Stop Api's
int _declspec(dllimport) _stdcall StopProfile(int nLevel, unsigned long dwId);
int _declspec(dllimport) _stdcall StartProfile(int nLevel, unsigned long dwId);

// Suspend/Resume Api's
int _declspec(dllimport) _stdcall SuspendProfile(int nLevel, unsigned long dwId);
int _declspec(dllimport) _stdcall ResumeProfile(int nLevel, unsigned long dwId);

// Mark Api's
int _declspec(dllimport) _stdcall MarkProfile(long lMarker);
int _declspec(dllimport) _stdcall CommentMarkProfile(long lMarker, const char *szComment);
int _declspec(dllimport) _stdcall CommentMarkAtProfile(__int64 dnTimestamp, long lMarker, const char *szComment);
int _declspec(dllimport) _stdcall DlpMarkProfile(long lMarker0, long lMarker1);

// Named Profiling Elements Api's
int _declspec(dllimport) _stdcall NameProfile(const char *pszName, int nLevel, unsigned long dwId);

// Security Api's
// NOTE: please contact ICAPSUP before using this function
int _declspec(dllimport) _stdcall ClearProcessSecurityAcl(int fImpersonatingUser);

// xxxProfile return codes
#define PROFILE_OK 0						// xxxProfile call successful
#define PROFILE_ERROR_NOT_YET_IMPLEMENTED 1 // api or level,id combination not supported yet
#define PROFILE_ERROR_MODE_NEVER 2		// mode was never when called
#define PROFILE_ERROR_LEVEL_NOEXIST 3	// level doesn't exist
#define PROFILE_ERROR_ID_NOEXIST 4		// id doesn't exist
#define PROFILE_ERROR_NO_WMI_UPDATE 5	// failed to update the WMI (pagefault collection) state

// MarkProfile return codes
#define MARK_OK					0	// Mark was taken successfully
#define MARK_ERROR_MODE_NEVER	1	// Profiling was never when MarkProfile called
#define MARK_ERROR_MODE_OFF		2	// Profiling was off when MarkProfile called
#define MARK_ERROR_MARKER_RESERVED	3	// Mark value passed is a reserved value
#define MARK_TEXTTOOLONG		4	// Comment text was truncated
#define MARK_ERROR_OUTOFMEMORY	6	// no memory was available in which to record the event

// NameProfile return codes
#define NAME_OK						0	// Name was registered sucessfullly
#define NAME_ERROR_TEXTTRUNCATED	1	// The name text was too long and was therefore truncated
#define NAME_ERROR_REDEFINITION		2	// The given profile element has already been named
#define NAME_ERROR_LEVEL_NOEXIST	3	// level doesn't exist
#define NAME_ERROR_ID_NOEXIST 		4	// id doesn't exist
#define NAME_ERROR_INVALID_NAME		5	// name does not meet the specification's requirements
#define NAME_ERROR_OUTOFMEMORY		6	// no memory was available in which to record the event
#define NAME_ERROR_NO_SUPPORT		7	// the given operation is not supported

// Icecap 3.x Compatibility defines
#define StartCAP() StartProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID)
#define StopCAP() StopProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID)
#define SuspendCAP() SuspendProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID)
#define ResumeCAP() ResumeProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID)

#define StartCAPAll() StartProfile(PROFILE_PROCESSLEVEL, PROFILE_CURRENTID)
#define StopCAPAll() StopProfile(PROFILE_PROCESSLEVEL, PROFILE_CURRENTID)
#define SuspendCAPAll() SuspendProfile(PROFILE_PROCESSLEVEL, PROFILE_CURRENTID)
#define ResumeCAPAll() ResumeProfile(PROFILE_PROCESSLEVEL, PROFILE_CURRENTID)

#define MarkCAP(mark) MarkProfile(mark)

#define AllowCAP() 

// DataLocality 1.x Compatibility defines
#define StartDLP() StartCAP()
#define StopDLP() StopCAP()
#define MarkDLP(mark) MarkCAP(mark)

//
// USER DEFINED COUNTER HELPERS AND TYPES
//

// COUNTER_FUNCTION_PROLOGE and EPILOGE
//
// These functions are supplied to protect the state of registers
// that the IceCAP collection probes rely on.  We did everything we
// could to eliminate instructions during collection.  Your mission,
// if you choose to accept it, is the same.
//
#define COUNTER_FUNCTION_PROLOGE	_asm push ecx _asm push ebx _asm push ebp
#define COUNTER_FUNCTION_EPILOGE	_asm pop ebp _asm pop ebx _asm pop ecx _asm ret

#ifndef USER_COUNTER_INFO_DEFINED
#define USER_COUNTER_INFO_DEFINED

// CONSTS AND ENUMS
//

// UserCounterType
//
// These enumerations describe how the counter works.
//
// MonotonicallyIncreasing	--	This describes a counter that will increment
//								by one each time some 'event' occurs.  An
//								example would be a counter that tracks the
//								number of memory allocations.  Each allocation
//								increments the number by one.
//
// MonotonicallyDecreasint	--	This describes a counter that will decrement
//								by one each time some 'event' occurs.  An
//								example would be a counter that tracks a limited
//								resource.  Each use of the resource decrements
//								the number by one.
//
// RandomIncreasing --			This describes a counter that will increase for
//								each 'event' that occurs, but by an undetermined
//								amount.  An example would be the total memory
//								allocated.  Each allocation would add it's size
//								to the counter, but each allocation being potentially
//								different, causes the counter to go up by a random
//								amount each time.
//
// RandomDecreasing --			This describes a coutner that will decrease for
//								each 'event' that occurs, but by an undetermined
//								amount.  An example would be a limited resource
//								that can be used in bunches.  Each use fo the
//								the resource would cause the number to descrease
//								by a random amount.
//
// Random --					This number can either go up, or go down.  An
//								example would be the total amount of available
//								memory, which can either go up (as memory is
//								free'd), or go down (as memory is allocated).
//
enum UserCounterType
{
	MonotonicallyIncreasing,
	MonotonicallyDecreasing,
	RandomIncreasing,
	RandomDecreasing,
	Random
};

// TYPEDEFS
//

typedef signed __int64	COUNTER, *PCOUNTER;

///////////////////////////////////////////////////////////////
// USERCOUNTERINFO
//
// This structure descibes a user defined counter so that
// IceCAP can use it during profiling runs.
//
// History:  9-21-98 BarryNo Created
//
///////////////////////////////////////////////////////////////
typedef struct _USERCOUNTERINFO
{
	unsigned long dwSize;			// Size of this structure (for version control)
	char  szCounterFuncName[32];	// Name of the function
	enum UserCounterType	ct;		// Describes the type of number we will be collecting
	char szName[32];				// Name of user counter
	int bSynchronized;				// Is this counter synchronized

} USERCOUNTERINFO, *PUSERCOUNTERINFO;

#endif  // USER_COUNTER_INFO_DEFINED

#ifdef __cplusplus
}
#endif

#endif // __ICECAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\inc\slist.h ===
#if !defined(INC__SList_h__INCLUDED)
#define INC__SList_h__INCLUDED
#pragma once

#if !defined(FASTCALL)
    #if defined(_X86_)
        #define FASTCALL    _fastcall
    #else // defined(_X86_)
        #define FASTCALL
    #endif // defined(_X86_)
#endif // !defined(FASTCALL)

#define _NTSLIST_DIRECT_
#include <ntslist.h>

#endif // INC__SList_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\util\renderutil\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  AutoUtil.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\inc\smgadget.inl ===
#if !defined(INC__SmGadget_inl__INCLUDED)
#define INC__SmGadget_inl__INCLUDED

//------------------------------------------------------------------------------
inline
SmGadget::SmGadget()
{
    m_hgad = NULL;
}


//------------------------------------------------------------------------------
inline
SmGadget::~SmGadget()
{

}


//------------------------------------------------------------------------------
inline BOOL 
SmGadget::PostBuild()
{
    return TRUE;
}


//------------------------------------------------------------------------------
inline HRESULT
SmGadget::GadgetProc(EventMsg * pmsg)
{
    if (pmsg->hgadMsg == m_hgad) {
        switch (pmsg->nMsg)
        {
        case GM_PAINT:
            {
                GMSG_PAINT * pmsgPaint = (GMSG_PAINT *) pmsg;
                if (pmsgPaint->nCmd == GPAINT_RENDER) {
                    switch (pmsgPaint->nSurfaceType)
                    {
                    case GSURFACE_HDC:
                        {
                            GMSG_PAINTRENDERI * pmsgR = (GMSG_PAINTRENDERI *) pmsgPaint;
                            OnDraw(pmsgR->hdc, pmsgR);
                        }
                        break;

#ifdef GADGET_ENABLE_GDIPLUS
                    case GSURFACE_GPGRAPHICS:
                        {
                            GMSG_PAINTRENDERF * pmsgR = (GMSG_PAINTRENDERF *) pmsgPaint;
                            OnDraw(pmsgR->pgpgr, pmsgR);
                        }
                        break;
#endif // GADGET_ENABLE_GDIPLUS
                    default:
                        Trace("WARNING: Unknown surface type\n");
                    }

                    return DU_S_PARTIAL;
                }
            }
            break;
        }
    }

    return DU_S_NOTHANDLED;
}


//------------------------------------------------------------------------------
inline void
SmGadget::Invalidate()
{
    InvalidateGadget(m_hgad);
}


#endif // INC__SmGadget_inl__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\inc\smgadget.h ===
#if !defined(CTRL__SmGadget_h__INCLUDED)
#define CTRL__SmGadget_h__INCLUDED
#pragma once

#include <SmObject.h>

namespace Gdiplus
{
    class Graphics;
};

/***************************************************************************\
*
* class SmGadget
*
* SmGadget provides a core implementation of a simple gadget and is used as
* as base for all of the simple gadget controls in DUser.
*
\***************************************************************************/

class SmGadget
{
// Construction
protected:
            SmGadget();
    virtual ~SmGadget();
            BOOL        PostBuild();

public:

// Operations
public:
    __declspec(property(get=RawGetHandle)) HGADGET h;
            HGADGET     RawGetHandle() const { return m_hgad; }

    virtual HRESULT     GadgetProc(EventMsg * pmsg);
    virtual void        OnDraw(HDC hdc, GMSG_PAINTRENDERI * pmsgR) 
                                {  UNREFERENCED_PARAMETER(hdc);  UNREFERENCED_PARAMETER(pmsgR);  }
#ifdef GADGET_ENABLE_GDIPLUS
    virtual void        OnDraw(Gdiplus::Graphics * pgpgr, GMSG_PAINTRENDERF * pmsgR) 
                                {  UNREFERENCED_PARAMETER(pgpgr);  UNREFERENCED_PARAMETER(pmsgR);  }
#endif // GADGET_ENABLE_GDIPLUS

            void        Invalidate();

// Data
protected:
    HGADGET m_hgad;
};


#define GBEGIN_COM_MAP(x)                           \
    STDMETHODIMP                                    \
    QueryInterface(REFIID riid, void ** ppv)        \
    {                                               \
        if (ppv == NULL) {                          \
            return E_POINTER;                       \
        }                                           \
        if (IsEqualIID(riid, __uuidof(IUnknown)) || \

#define GCOM_INTERFACE_ENTRY(x)                     \
            IsEqualIID(riid, __uuidof(x))) {        \
                                                    \
            x * p = (x *) this;                     \
            p->AddRef();                            \
            *ppv = p;                               \
            return S_OK;                            \
        }                                           \
                                                    \
        if (                                        \

#define GEND_COM_MAP()                              \
            0) { }                                  \
        return E_NOINTERFACE;                       \
    }                                               \



/***************************************************************************\
*
* class SmGadgetFull
*
* SmGadgetFull is a "Mix-in" (see Design Patterns) class designed for 
* providing SmGadget's with a standard COM-class implementation.  Creation
* of SmGadget instances should derive from this class at the point of 
* creation.
*
\***************************************************************************/

template <class base, class iface>
class SmGadgetFull : public base
{
public:
    static SmGadgetFull<base, iface> *
    Build(HGADGET hgadParent, REFIID riid = __uuidof(IUnknown), void ** ppvUnk = NULL)
    {
        return CommonBuild(new SmGadgetFull<base, iface>, hgadParent, riid, ppvUnk);
    }

    static SmGadgetFull<base, iface> *
    CommonBuild(SmGadgetFull<base, iface> * pgadNew, HGADGET hgadParent, REFIID riid, void ** ppvUnk)
    {
        if (pgadNew == NULL) {
            return NULL;
        }
        pgadNew->m_cRef = 1;

        HGADGET hgad = CreateGadget(hgadParent, GC_SIMPLE, SmGadgetFull<base, iface>::RawGadgetProc, pgadNew);
        if (hgad == NULL) {
            pgadNew->Release();
            return NULL;
        }

        pgadNew->m_hgad = hgad;

        if (!pgadNew->PostBuild()) {
            // Delete from parent and destroy

            ::DeleteHandle(hgad);
            pgadNew->Release();
            return NULL;
        }

        if (ppvUnk != NULL) {
            pgadNew->QueryInterface(riid, ppvUnk);
        }

        return pgadNew;
    }

// Implementation
protected:
    inline 
    SmGadgetFull()
    {
    }

    static HRESULT CALLBACK 
    RawGadgetProc(HGADGET hgadCur, void * pvCur, EventMsg * pmsg)
    {
        UNREFERENCED_PARAMETER(hgadCur);
        AssertReadPtrSize(pmsg, pmsg->cbSize);

        SmGadgetFull<base, iface> * p = (SmGadgetFull<base, iface> *) pvCur;
        AssertMsg(hgadCur == p->m_hgad, "Ensure correct gadget");

        if (p->m_hgad == pmsg->hgadMsg) {
            switch (pmsg->nMsg)
            {
            case GM_DESTROY:
                {
                    GMSG_DESTROY * pmsgD = (GMSG_DESTROY *) pmsg;
                    if (pmsgD->nCode == GDESTROY_FINAL) {
                        //
                        // When getting a GM_DESTROY message, Release() and return 
                        // immediately.  The base class should put its cleanup code in
                        // its destructor.
                        //

                        p->Release();
                        return DU_S_PARTIAL; 
                    }
                }
                break;

            case GM_QUERY:
                {
                    GMSG_QUERY * pmsgQ = (GMSG_QUERY *) pmsg;
                    if (pmsgQ->nCode == GQUERY_INTERFACE) {
                        GMSG_QUERYINTERFACE * pmsgQI = (GMSG_QUERYINTERFACE *) pmsg;
                        pmsgQI->punk = (iface *) p;
                        return DU_S_COMPLETE;
                    }
                }
                break;
            }
        }

        return p->GadgetProc(pmsg);
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return ++m_cRef;
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        ULONG ul = --m_cRef;
        if (ul == 0) {
            delete this;
        }
        return ul;
    }


    STDMETHODIMP_(HGADGET)
    GetHandle() const
    {
        return m_hgad;
    }

// Data
protected:
    ULONG   m_cRef;
};

#include "SmGadget.inl"

#endif // CTRL__SmGadget_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\inc\smobject.h ===
#if !defined(CTRL__SmObject_h__INCLUDED)
#define CTRL__SmObject_h__INCLUDED
#pragma once

/***************************************************************************\
*****************************************************************************
*
* class SmObjectT
*
* SmObjectT defines a common implementation class for building COM objects.
* To create a new object type
* - Define an interface
* - Create a class that implements that interface except the COM functions
* - Derive a class from SmObjectT that provides a Build() function to create
*   new instances.
*
*****************************************************************************
\***************************************************************************/

template <class base, class iface>
class SmObjectT : public base
{
// Operations
public:
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppv)
    {
        if (ppv == NULL) {
            return E_POINTER;
        }

        int idx = 0;
        while (1) {
            if (IsEqualIID(riid, *base::s_rgpIID[idx])) {
                AddRef();
                iface * p = (iface *) this;
                *ppv = p;
                return S_OK;
            }

            idx++;

            if (base::s_rgpIID[idx] == NULL) {
                break;
            }
        }

        return E_NOINTERFACE;
    }

    STDMETHOD_(ULONG, AddRef)()
    {
        return ++m_cRef;
    }

    STDMETHOD_(ULONG, Release)()
    {
        ULONG ul = --m_cRef;
        if (ul == 0) {
            delete this;
        }
        return ul;
    }


// Data
protected:
    ULONG       m_cRef;
};

#endif // CTRL__SmObject_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\util\renderutil\public.h ===
#if !defined(RENDERUTIL__Public_h__INCLUDED)
#define RENDERUTIL__Public_h__INCLUDED
#pragma once


namespace DUser
{

namespace RenderUtil
{

enum EBorderAlignment
{
    baOutside,
    baCenter,
    baInside
};


void ComputeBorder(Gdiplus::Pen * pgppen, const Gdiplus::RectF * prcGadgetPxl,
        EBorderAlignment ba, Gdiplus::RectF * prcBorderPxl);
void ComputeRoundRect(const Gdiplus::RectF * prc, const Gdiplus::SizeF sizeCorner,
        Gdiplus::GraphicsPath * pgppath);

void DrawRoundRect(Gdiplus::Graphics * pgpgr, Gdiplus::Pen * pgppenBorder,
        const Gdiplus::RectF & rc, const Gdiplus::SizeF sizeCorner, EBorderAlignment ba = baCenter);
void FillRoundRect(Gdiplus::Graphics * pgpgr, Gdiplus::Brush * pgpbrFill,
        const Gdiplus::RectF & rc, const Gdiplus::SizeF sizeCorner);


} // namespace DUser
} // namespace RenderUtil

#endif // RENDERUTIL__Public_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\util\renderutil\stdafx.h ===
#if !defined(RENDERUTIL__StdAfx_h__INCLUDED)
#define RENDERUTIL__StdAfx_h__INCLUDED
#pragma once

#if !defined(WIN32_LEAN_AND_MEAN)
#define WIN32_LEAN_AND_MEAN
#endif

#if !defined(_WIN32_WINNT)
#define _WIN32_WINNT 0x0500     // Only compile for NT5
#endif

// Windows
#include <windows.h>
#include <objbase.h>            // CoCreateInstance, IUnknown

#pragma warning(push, 3)
#include <GdiPlus.h>            // GDI+
#pragma warning(pop)

// CRT
#include <math.h>

// DirectUser
#include <AutoUtil.h>

#endif // !defined(RENDERUTIL__StdAfx_h__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\duser\util\renderutil\roundrect.cpp ===
#include "stdafx.h"
#include "RenderUtil.h"

namespace DUser
{

namespace RenderUtil
{

//------------------------------------------------------------------------------
void
ComputeBorder(
    IN  Gdiplus::Pen * pgppen,
    IN  const Gdiplus::RectF * prcGadgetPxl,
    IN  EBorderAlignment ba,
    OUT Gdiplus::RectF * prcBorderPxl)
{
    float flPenThickness    = pgppen->GetWidth();

    BOOL fEven = fabs(fmod(flPenThickness, 2.0f)) < 0.0001f;

    float flOffset, flSize;

    switch (ba) {
    case baOutside:
        flOffset    = (flPenThickness + (fEven ? 0.0f : 1.0f)) / 2.0f + (fEven ? 0.5f : 0.0f);
        flSize      = flPenThickness;
        break;

    case baCenter:
        flOffset    = (fEven ? 0.5f : 0.0f);
        flSize      = (fEven ? 1.0f : 0.0f);
        break;

    case baInside:
        // Inside is opposite of outside
        flOffset    = -((flPenThickness + (fEven ? 0.0f : 1.0f)) / 2.0f + (fEven ? 0.5f : 0.0f));
        flSize      = -flPenThickness;
        break;

    default:
        AssertMsg(0, "Unknown alignment");
        return;
    }

    prcBorderPxl->X         = prcGadgetPxl->X - flOffset;
    prcBorderPxl->Y         = prcGadgetPxl->Y - flOffset;
    prcBorderPxl->Width     = prcGadgetPxl->Width + flSize;
    prcBorderPxl->Height    = prcGadgetPxl->Height + flSize;
}


//------------------------------------------------------------------------------
void
ComputeRoundRect(
    IN  const Gdiplus::RectF * prc,
    IN  const Gdiplus::SizeF sizeCorner,
    IN OUT Gdiplus::GraphicsPath * pgppath)
{
    float W     = (prc->Width > (sizeCorner.Width * 2)) ? sizeCorner.Width : prc->Width / 2.0f;
    float H     = (prc->Height > (sizeCorner.Height * 2)) ? sizeCorner.Width : prc->Height / 2.0f;
    float W2    = W * 2.0f;
    float H2    = H * 2.0f;

    float LX1   = prc->X;
    float LY1   = prc->Y;
    float LX2   = prc->X + prc->Width;
    float LY2   = prc->Y + prc->Height;

    float RX1   = prc->X + W;
    float RY1   = prc->Y + H;
    float RX2   = prc->X + prc->Width - W;
    float RY2   = prc->Y + prc->Height - H;

    pgppath->AddLine(RX1, LY1, RX2, LY1);
    pgppath->AddArc(RX2-W, RY1-H, W2, H2, 270.0f, 90.0f);

    pgppath->AddLine(LX2, RY1, LX2, RY2);
    pgppath->AddArc(RX2-W, RY2-H, W2, H2, 0.0f, 90.0f);

    pgppath->AddLine(RX2, LY2, RX1, LY2);
    pgppath->AddArc(RX1-W, RY2-H, W2, H2, 90.0f, 90.0f);

    pgppath->AddLine(LX1, RY2, LX1, RY1);
    pgppath->AddArc(RX1-W, RY1-H, W2, H2, 180.0f, 90.0f);

    pgppath->CloseFigure();

}


//------------------------------------------------------------------------------
void
DrawRoundRect(
    IN  Gdiplus::Graphics * pgpgr,
    IN  Gdiplus::Pen * pgppenBorder,
    IN  const Gdiplus::RectF & rc,
    IN  const Gdiplus::SizeF sizeCorner,
    IN  EBorderAlignment ba)
{
    Assert(pgppenBorder != NULL);

    Gdiplus::RectF rcUse;
    ComputeBorder(pgppenBorder, &rc, ba, &rcUse);

    Gdiplus::GraphicsPath gppath;
    ComputeRoundRect(&rcUse, sizeCorner, &gppath);
    pgpgr->DrawPath(pgppenBorder, &gppath);
}


//------------------------------------------------------------------------------
void
FillRoundRect(
    IN  Gdiplus::Graphics * pgpgr,
    IN  Gdiplus::Brush * pgpbrFill,
    IN  const Gdiplus::RectF & rc,
    IN  const Gdiplus::SizeF sizeCorner)
{
    Assert(pgpbrFill != NULL);

    Gdiplus::GraphicsPath gppath;
    ComputeRoundRect(&rc, sizeCorner, &gppath);
    pgpgr->FillPath(pgpbrFill, &gppath);
}


} // namespace DUser

} // namespace RenderUtil
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\sources.inc ===
# Common 'sources' file for gdiplus

# [agodfrey] Guard against multiple inclusion. When I fixed this file to
# add to C_DEFINES instead of stomping on it, I found that multiple inclusion
# caused C_DEFINES to be duplicated.

# For release build, turn this on. It disables things like Monitor tracking.
GP_RELEASE_BUILD=1

!ifndef GDIPROOT_SOURCES
GDIPROOT_SOURCES=moo

!ifndef GDIPROOT
GDIPROOT=$(ADVCORE_PATH)\gdiplus
!endif

GDIPIMG=$(GDIPROOT)\engine\imaging

C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE
MSC_WARNING_LEVEL=/W3

# GP_ICECAP:
#   0: Normal GDI+ build
#   1: IceCAP-enabled build. This means you can run gppick.bat on our binary.
#      You should be able to keep this set permanently.
#   2: IceCAP-enabled build, plus we link to ICECAP.DLL. Use this during
#      profiling work if you want to call the IceCAP API's.

!ifndef GP_ICECAP
GP_ICECAP=0
!endif

!if $(GP_ICECAP) > 0
NTBBT=1

!if $(GP_ICECAP) > 1
INCLUDES=$(INCLUDES);$(ICECAP)\Include
!endif

!endif

# PROFILE_MEMORY_USAGE
#   Enables logging of memory usage for our IceCAP user counter
#   See gdiplus\tools\memcounter\memcounter.cpp

!ifndef PROFILE_MEMORY_USAGE
PROFILE_MEMORY_USAGE=0
!endif

# The "monitors" are a performance measurement tool, designed to be
# lightweight enough to leave enabled all the time during development.
# They're currently disabled in preparation for shipping V1.

# GP_ENABLE_MONITORS=1

!ifdef GP_ENABLE_MONITORS
C_DEFINES=$(C_DEFINES) -DGP_ENABLE_MONITORS
!endif

!if $(PROFILE_MEMORY_USAGE)
# There's trouble with "cross-jumping" (a compiler optimization which replaces
# "call foo; ret" with "jmp foo" if possible.)
# First, if a non-instrumented app calls GdipFree, which cross-jumps to
# GpFree, which cross-jumps to LocalFree, IceCAP screws up and thinks that
# LocalFree calls loads of other GDI+ exports.
#
# Second, my -EXCLUDE:GpMalloc trick (which folds allocation information
# into the caller's exclusive count) doesn't work when GdipAlloc cross-jumps
# to GpMalloc.
#
# So, we want to disable cross-jumping. The only way I know is to disable
# most optimizations. So, don't do performance testing on this build! Ignore
# IceCAP's performance data if you use this switch!

MSC_OPTIMIZATION=/Odib1

!endif

!ifndef HW_ACCELERATION_SUPPORT
HW_ACCELERATION_SUPPORT=0
!endif

C_DEFINES=$(C_DEFINES) -DHW_ACCELERATION_SUPPORT=$(HW_ACCELERATION_SUPPORT) -DGP_ICECAP=$(GP_ICECAP) -DPROFILE_MEMORY_USAGE=$(PROFILE_MEMORY_USAGE)

!ifndef GDIPPRIVATEBUILD
GDIPPRIVATEBUILD=0
!endif

C_DEFINES=$(C_DEFINES) -DGDIPPRIVATEBUILD=$(GDIPPRIVATEBUILD) -DUSERNAME=\"$(USERNAME)\"

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\archive\widen\dynarray.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   dynarray.hpp
*
* Abstract:
*
*   Dynamic array template classes. See DynamicArrays.doc in the Specs 
*   directory.
*
*   DynArray is a container which keeps its contents in a contiguous buffer,
*   reallocating memory as necessary. It accepts an optional initial
*   allocation, which is used unless it is too small to accommodate the
*   elements.
*
*   DynArrayIA is a cosmetic wrapper which encapsulates the intial allocation,
*   allowing the dynamic array to be treated like a normal class.
*
* Revision History:
*
*   12/02/1998 davidx
*       Created it.
*   02/26/1999 agodfrey
*       Revamped it to use an implementation class (DynArrayImpl). 
*       Now the template part of it can compile to nothing, or be small enough
*       to inline efficiently, so that using the template with many different
*       types doesn't cause code bloat.
*
*       Also, I added a version (DynArrayIA) which makes using an initial
*       allocation much easier.
*
*   06/10/1999 t-wehunt
*       Added AddXXAt, DeletXXAt, and InsertAt methods.
*
* Notes:
*
*   12/02/1998 davidx
*   Changes from the previous version in gdiplus prototype:
*   + getData: Use &dynarr[index] instead.
*   + increaseCount: Use addMultiple instead (2nd variation).
*   + replace: Use dynarr[index] = newItem.
*   + attachData: Use dynarr.replaceWith(dynarr2).
*   + constructor: No longer takes initialCapacity, use ReserveSpace instead
*   + new constructor: Takes a stack array which is used for buffer (faster).
*
*   02/26/1999 agodfrey
*   + Use the 'implementation class' to avoid code bloat for out-of-line
*     functions.
*   + GetCapacity: Unused, not useful - removed.
*   + Reset: Added 'shrink' flag (default true). If it's false, Reset sets the
*     count to zero but doesn't free the memory. This is preferable to
*     SetCount(0).
*   + Made ShrinkToSize() reuse the initial allocation. This also makes the
*     growing and shrinking logic simpler - 'no initial allocation' is treated
*     like an initial allocation of size zero (at memory location 'NULL').
*
*   06/10/1999 t-wehunt
*   + AddXXAt, DeletXXAt, and InsertAt methods shift elements around in memory 
*     to keep the array contiguous.
*   + CAUTION: This could cause a big performance hit if the array is very large. 
*     Use care when calling these methods!!!
*
\**************************************************************************/

#ifndef _DYNARRAY_HPP
#define _DYNARRAY_HPP

#include "dynArrayImpl.hpp"

template <class T> class DynArray : public DynArrayImpl
{
public:
    
    // Constructor
    //
    //   initalAllocation - the initial allocation, which can be global,
    //                      static or dynamic memory (or NULL)
    //   allocSize        - size of the initial allocation 
    //                      (0 if there is none)
    //   count            - the initial count
    //

    DynArray(
        T *initialAllocation, 
        UINT allocSize,
        UINT count = 0):
        DynArrayImpl(initialAllocation, allocSize, count)
    {
    }

    // Constructor (no initial allocation)
    //

    DynArray(void):
        DynArrayImpl(NULL, 0, 0)
    {
    }

    // Destructor

    ~DynArray()
    {
        if (DataBuffer != InitialAllocation)
        {
           GpFree(DataBuffer);
        }
    }

    // Return a pointer to the array data
    //   NOTE: We intentionally avoid type conversion operator here
    //   to reduce the chances for confusion.

    T *GetDataBuffer() const
    {
        return static_cast<T *>(DataBuffer);
    }

    // Index operator

    T &operator[](INT n) const
    {
        ASSERT(n >= 0 && (UINT)n < Count);
        return GetDataBuffer()[n];
    }

    // First/last element of the array

    T &First() const
    {
        ASSERT(Count > 0);
        return GetDataBuffer()[0];
    }

    T &Last() const
    {
        ASSERT(Count > 0);
        return GetDataBuffer()[Count-1];
    }
        
    // Number of elements in the array

    INT GetCount() const
    {
        return Count;
    }

    UINT GetCapacity() const
    {
        return Capacity;
    }

    // Reset the dynamic array to empty state
    //
    // shrink - If FALSE, don't free the current buffer.

    VOID Reset(BOOL shrink=TRUE)
    {
        Count = 0;
        if (shrink)
        {
            ShrinkToSize();
        }
    }

    // Shrink the dynamic array capacity to be just big enough
    // for the number of existing elements in the array.
    //
    // This reuses the initial allocation if possible.

    VOID ShrinkToSize()
    {
        DynArrayImpl::ShrinkToSize(sizeof(T));
    }

    // Add a new element to the end of the dynamic array

    GpStatus Add(const T& newItem)
    {
        return DynArrayImpl::AddMultiple(sizeof(T), 1, &newItem);
    }

    // Add a new element to the array at position index.
    // index'th element moves index + 1.
    // CAUTION! could cause a big performance hit if the array is large!
    
    GpStatus InsertAt(INT index, const T& newItem)
    {
        return DynArrayImpl::AddMultipleAt(sizeof(T), index, 1, &newItem);
    }
    
    // Add multiple items to the end of the dynamic array

    GpStatus AddMultiple(const T* newItems, INT n)
    {
        return DynArrayImpl::AddMultiple(sizeof(T), n, newItems);
    }
    
    // Another variation of addMultiple above
    //
    // In this case, the data for the new elements are
    // not available. Instead, we'll do the following:
    //  (1) reserve the space for additional elements
    //  (2) increase the Count by the number of additional elements
    //  (3) return a pointer to the first new elements

    T *AddMultiple(INT n)
    {
        return static_cast<T *>(DynArrayImpl::AddMultiple(sizeof(T), n));
    }

    // Insert multiple items starting at index'th element.
    // index'th element moves index + n, etc...
    // CAUTION! could cause a big performance hit if the array is large!

    GpStatus AddMultipleAt(INT index, const T* newItems, INT n)
    {
        return DynArrayImpl::AddMultipleAt(sizeof(T), index, n, newItems);
    }
    
    // Another variation of AddMultipleAt above.
    //
    // In this case, the data for the new elements are
    // not available. Instead, we'll do the following:
    //  (1) shift the old data over just as AddMultipleAt
    //  (2) reserve the space for additional elements
    //  (3) increase the Count by the number of additional elements
    //  (4) return a pointer to the first new elements
    // CAUTION! could cause a big performance hit if the array is large!

    T *AddMultipleAt(INT index, INT n)
    {
        return static_cast<T *>(DynArrayImpl::AddMultipleAt(sizeof(T), index, n));
    }

    // Deletes n items from the array starting at the index'th position.
    // CAUTION! could cause a big performance hit if the array is large!

    GpStatus DeleteMultipleAt(INT index, INT n)
    {
        return DynArrayImpl::DeleteMultipleAt(sizeof(T), index, n);
    }

    // Deletes one item from the array at the index'th position.
    // CAUTION! could cause a big performance hit if the array is large!
    
    GpStatus DeleteAt(INT index)
    {
        return DynArrayImpl::DeleteMultipleAt(sizeof(T), index, 1);
    }

    // Detach the data buffer from the dynamic array
    // Cannot be used if there is an initial allocation

    T *DetachData()
    {
        return static_cast<T *>(DynArrayImpl::DetachData(sizeof(T)));
    }
    
    // Detatch the buffer from another array, and set this array
    // to point to it. NOTE: This modifies the other array.

    VOID ReplaceWith(DynArray<T> *dynarr)
    {
        if (DataBuffer != InitialAllocation)
        {
            GpFree(DataBuffer);
        }

        Count = dynarr->Count;
        Capacity = dynarr->Capacity;
        DataBuffer = dynarr->DetachData();
    }
    
    // More dangerous interface:
    //
    // These functions are alternatives to Add/AddMultiple.
    // They can be used to reduce overhead, but you have to know what
    // you're doing.
    //
    // AdjustCount/SetCount - modify the count directly, without growing or
    //   shrinking the array.
    // ReserveSpace - grow the buffer, but don't actually add any elements to
    //   the array.
    
    VOID AdjustCount(UINT addElts)
    {
        Count += addElts;
        
        ASSERT(Count <= Capacity);
    }

    VOID SetCount(UINT count)
    {
        ASSERT(Count <= Capacity);
        
        Count = count;
    }
    
    GpStatus ReserveSpace(UINT newElements, BOOL exact = FALSE)
    {
        return Grow(sizeof(T), newElements, exact);
    }
};

// DynArrayIA: A version of DynArray which encapsulates the initial allocation.
//
// For example:
//
// DynArrayIA<MyType, 10> array;
//
// This declares a DynArray of MyType objects, with an initial allocation of
// 10 elements. Such a declaration can be used on the stack or in another
// object.

template <class T, int ALLOCSIZE> class DynArrayIA : public DynArray<T>
{
public:

    // Constructor
    //

    DynArrayIA(void):
        DynArray<T>(InitialAllocationBuffer, ALLOCSIZE, 0)
    {
    }

    DynArrayIA(T * initialAllocationBuffer, UINT initialAllocationSize, UINT count = 0) :
        DynArray<T>(initialAllocationBuffer, initialAllocationSize, count)
    {
    }

private:
    T InitialAllocationBuffer[ALLOCSIZE];
};

#endif // !_DYNARRAY_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\archive\widen\ddiplus.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   ddiplus.hpp
*
* Abstract:
*
*   Contains the interface definition for the high-level GDI+ device
*   driver interface.
*
* Revision History:
*
*   12/01/1998 andrewgo
*       Created it.
*                                 
*   03/11/1999 agodfrey
*       Changed the DDI model. For this version, I'm not using COM, and
*       we'll use the result to decide whether we should be using COM.
\**************************************************************************/

#ifndef _DDIPLUS_HPP
#define _DDIPLUS_HPP

// !! shift this to dpflat.hpp ?? 
// !! do we want to bother with namespaces for driver, they may link to
//    other stuff in GDI, and hence name clashes.

class EpPaletteMap;

template<class T> class EpScanBufferNative;
#define DpScanBuffer EpScanBufferNative<ARGB>

class DpOutputSpan;
class DpClipRegion;
class DpContext;
struct DpBrush;
struct DpPen;
class DpBitmap;
class DpDriver;
class DpRegion;
class DpDevice;
class EpScan;
class DpPath;
class DpCustomLineCap;
struct DpImageAttributes;
class DpCachedBitmap;

#define WINGDIPAPI __stdcall

// The naming convention is Dpc<function><object> for Driver callbacks
DpPath* WINGDIPAPI 
DpcCreateWidenedPath(
        const DpPath* path, 
        const DpPen* pen,
        DpContext* context,
        BOOL removeSelfIntersect,
        BOOL regionToPath
        );
    
VOID WINGDIPAPI 
DpcDeletePath(
        DpPath* path
        );

DpPath* WINGDIPAPI
DpcClonePath(
        DpPath* path
        );

VOID WINGDIPAPI
DpcTransformPath(
        DpPath* path,
        GpMatrix* transform
        );

#include "dpregion.hpp"

// Hack: DpContext depends on GpRegion
#include "..\Entry\object.hpp"
#include "..\Entry\region.hpp"
// EndHack

#include "dpbitmap.hpp"
#include "dpbrush.hpp"
#include "dpcontext.hpp"
#include "dpdriver.hpp"
#include "dppath.hpp"
#include "dpcustomlinecap.hpp"
#include "dppen.hpp"
#include "dpscan.hpp"
#include "dppathiterator.hpp"
#include "dpimageattributes.hpp"
#include "dpcachedbitmap.hpp"

#endif // !_DDIPLUS_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\archive\widen\driverprint.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Abstract:
*
*   Contains the GDI virtual driver that takes DDI calls and leverages
*   existing GDI calls wherever possible to improve performance.
*
* History:
*
*   10/28/1999 ericvan
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

#include "..\Render\scan.hpp"
#include "..\entry\device.hpp"
#include "..\entry\metafile.hpp"

#include "..\fondrv\tt\ttfd\fontddi.h"

#include "..\entry\graphics.hpp"
#include "..\entry\regiontopath.hpp"


// font stuff

#define _NO_DDRAWINT_NO_COM

// This is to use GpGlyphPath

extern "C" {
#include "..\fondrv\tt\ttfd\fdsem.h"
#include "..\fondrv\tt\ttfd\mapfile.h"
};

#include "..\entry\intMap.hpp"
#include "..\entry\fontface.hpp"
#include "..\entry\facerealization.hpp"
#include "..\entry\fontfile.hpp"
#include "..\entry\fontable.hpp"
#include "..\entry\FontLinking.hpp"
#include "..\entry\family.hpp"
#include "..\entry\font.hpp"

#include <ole2.h>
#include <objidl.h>
#include <winerror.h>
#include <tchar.h>

//#define NO_PS_CLIPPING 1
//#define DO_PS_COALESING 1

//
// Structures necessary for (postscript) escape clipping setup

/* Types for postscript written to metafiles */
#define CLIP_SAVE       0
#define CLIP_RESTORE    1
#define CLIP_INCLUSIVE  2
#define CLIP_EXCLUSIVE  3

#define RENDER_NODISPLAY 0
#define RENDER_OPEN      1
#define RENDER_CLOSED    2

#define FILL_ALTERNATE   1          // == ALTERNATE
#define FILL_WINDING     2          // == WINDING

#pragma pack(2)

/* Win16 structures for escapes. */
struct POINT16
    {
    SHORT x;
    SHORT y;
    };

struct LOGPEN16
    {
    WORD        lopnStyle;
    POINT16     lopnWidth;
    COLORREF    lopnColor;
    };

struct LOGBRUSH16
    {
    WORD        lbStyle;
    COLORREF    lbColor;
    SHORT       lbHatch;
    };

struct PathInfo16
    {
    WORD       RenderMode;
    BYTE       FillMode;
    BYTE       BkMode;
    LOGPEN16   Pen;
    LOGBRUSH16 Brush;
    DWORD      BkColor;
    };

#pragma pack()

/**************************************************************************\
*
* Function Description:
*
*   MemoryStream class.  Wrap an IStream* around an existing chunk of memory
*
*
* History:
*
*   6/14/1999 ericvan
*       Created it.
*
\**************************************************************************/

class MemoryStream : public IStream
{
public:

    LPBYTE memory;
    LPBYTE position;
    DWORD size;
    DWORD count;

    MemoryStream(LPBYTE memoryPtr, DWORD memorySize)
    {
       memory = memoryPtr;
       position = memory;
       size = memorySize;
       count = 1;
    }

    virtual HRESULT STDMETHODCALLTYPE QueryInterface(
                /* [in] */ REFIID riid,
                /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject)
    {
        return STG_E_UNIMPLEMENTEDFUNCTION;
    };

    virtual ULONG STDMETHODCALLTYPE AddRef( void)
    {
       InterlockedIncrement((LPLONG)&count);
       return count;
    };

    virtual ULONG STDMETHODCALLTYPE Release( void)
    {
       InterlockedDecrement((LPLONG)&count);
       if (!count)
       {
           delete this;
           return 0;
       }
       else
           return count;
    };


    virtual /* [local] */ HRESULT STDMETHODCALLTYPE Read(
            /* [length_is][size_is][out] */ void __RPC_FAR *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG __RPC_FAR *pcbRead)
    {
       if (!pv)
          return STG_E_INVALIDPOINTER;

       DWORD readBytes = cb;

       if ((ULONG)cb > (ULONG)(memory+size-position))
           // !!! IA64 - it's theoretically possible that memory and position
           // more than maxint apart and then this arithmetic breaks down.
           // We need to verify that this is not possible.
           readBytes = (DWORD)(memory+size-position);

       if (!readBytes)
       {
          if (pcbRead)
             *pcbRead = 0;

          return S_OK;
       }

       memcpy((LPVOID) pv, (LPVOID) position, readBytes);
       position += readBytes;

       if (pcbRead)
           *pcbRead += readBytes;

       return S_OK;
    }

    virtual /* [local] */ HRESULT STDMETHODCALLTYPE Write(
            /* [size_is][in] */ const void __RPC_FAR *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG __RPC_FAR *pcbWritten)
    {
       return STG_E_WRITEFAULT;
    }

    virtual /* [local] */ HRESULT STDMETHODCALLTYPE Seek(
            /* [in] */ LARGE_INTEGER dlibMove,
            /* [in] */ DWORD dwOrigin,
            /* [out] */ ULARGE_INTEGER __RPC_FAR *plibNewPosition)
    {
       switch (dwOrigin)
       {
       case STREAM_SEEK_SET:
          position = memory+dlibMove.QuadPart;
          break;

       case STREAM_SEEK_CUR:
          position = position+dlibMove.QuadPart;
          break;

       case STREAM_SEEK_END:
          if (dlibMove.QuadPart<0) dlibMove.QuadPart = -dlibMove.QuadPart;
          position = memory+size-dlibMove.QuadPart;
          break;

       default:
          return STG_E_INVALIDPARAMETER;
       }

       if (position>memory+size)
       {
           position = memory+size;
           return S_FALSE;
       }

       if (position<0)
       {
           position = 0;
           return S_FALSE;
       }

       return S_OK;
    }

    virtual HRESULT STDMETHODCALLTYPE SetSize(
            /* [in] */ ULARGE_INTEGER libNewSize)
    {
       return STG_E_UNIMPLEMENTEDFUNCTION;
    }

    virtual /* [local] */ HRESULT STDMETHODCALLTYPE CopyTo(
            /* [unique][in] */ IStream __RPC_FAR *pstm,
            /* [in] */ ULARGE_INTEGER cb,
            /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbRead,
            /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbWritten)
    {
       return STG_E_UNIMPLEMENTEDFUNCTION;
    }

    virtual HRESULT STDMETHODCALLTYPE Commit(
            /* [in] */ DWORD grfCommitFlags)
    {
       return STG_E_UNIMPLEMENTEDFUNCTION;
    }

    virtual HRESULT STDMETHODCALLTYPE Revert( void)
    {
       return STG_E_UNIMPLEMENTEDFUNCTION;
    }


    virtual HRESULT STDMETHODCALLTYPE LockRegion(
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType)
    {
       return STG_E_UNIMPLEMENTEDFUNCTION;
    }

    virtual HRESULT STDMETHODCALLTYPE UnlockRegion(
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType)
    {
       return STG_E_UNIMPLEMENTEDFUNCTION;
    }

    virtual HRESULT STDMETHODCALLTYPE Stat(
            /* [out] */ STATSTG __RPC_FAR *pstatstg,
            /* [in] */ DWORD grfStatFlag)
    {
       return STG_E_UNIMPLEMENTEDFUNCTION;
    }

    virtual HRESULT STDMETHODCALLTYPE Clone(
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm)
    {
       return STG_E_UNIMPLEMENTEDFUNCTION;
    }
};

/**************************************************************************\
*
* Function Description:
*
*   GDI+ Printer callback
*
* Arguments:
*
*   [IN] GDIPPRINTDATA block
*
* Return Value:
*
*   status
*
* History:
*
*   6/14/1999 ericvan
*       Created it.
*
\**************************************************************************/

#ifndef DCR_REMOVE_OLD_186091
GpStatus
__stdcall
GdipDecodePrinterCallback(DWORD size,
                          LPVOID emfBlock,
                          SURFOBJ* surfObj,
                          HDC hdc,
                          RECTL* bandClip,
                          SIZEL* bandSize
                          )
{
#ifdef DCR_DISABLE_OLD_186091
    WARNING(("DCR: Using disabled functionality 186091"));
    return NotImplemented;
#else
   INT numBits = 4;

   if (!emfBlock || size == 0 || !surfObj || hdc == NULL || !bandClip ||!bandSize)
   {
      return InvalidParameter;
   }

   FPUStateSaver fpuState;

   // create Graphics and draw Metafile into it.

   GpMetafile* metafile;
   GpGraphics* graphics;

   // use banding information to create a temporary pseudo-HDC surface
   graphics = GpGraphics::GetFromHdcSurf(hdc, surfObj, bandClip);

   if (CheckValid(graphics))
   {
      {
         GpLock lockGraphics(graphics->GetObjectLock());

         // wrap memory block in stream object
         MemoryStream *emfStream = new MemoryStream((LPBYTE)emfBlock, size);

         // create metafile
         metafile = new GpMetafile((IStream *)emfStream);

         if (metafile)
         {
            // play metafile into the printer graphics DC
            // !! destination point - relative to band or surface origin (0,0) ??
            graphics->DrawImage(metafile,
                                GpPointF(0.0, 0.0));

            metafile->Dispose();
         }

         emfStream->Release();
      }

      delete graphics;
   }

   return Ok;
#endif
}
#endif

BOOL
DriverPrint::SetupBrush(
        DpBrush*            brush,
        DpContext*          context,
        DpBitmap*           surface
    )
{
    GpBrush *gpBrush = GpBrush::GetBrush(brush);

    if (IsSolid = gpBrush->IsSolid())
    {
        ASSERT(gpBrush->GetBrushType() == BrushTypeSolidColor);
        if (((GpSolidFill *)gpBrush)->GetColor().GetAlpha() == 0)
        {
            // yes, this did come up... hey it's a cheap test.
            return TRUE;
        }
        SolidColor = gpBrush->ToCOLORREF();
    }

    IsOpaque = (context->CompositingMode == CompositingModeSourceCopy) ||
                gpBrush->IsOpaque(TRUE);

    // Currently only DriverPS uses this
    //IsNearConstant = gpBrush->IsNearConstant(&MinAlpha, &MaxAlpha);
    IsNearConstant = FALSE;

    if (!IsOpaque &&
        (brush->Type == BrushTypeTextureFill))
    {
        GpTexture *textureBrush;
        DpTransparency transparency;

        textureBrush = static_cast<GpTexture*>(GpBrush::GetBrush(brush));

        GpBitmap* bitmap = textureBrush->GetBitmap();

        Is01Bitmap = ((bitmap != NULL) &&
                      (bitmap->GetTransparencyHint(&transparency) == Ok) &&
                      (transparency == TransparencySimple));
    }
    else
    {
        Is01Bitmap = FALSE;
    }

    return FALSE;
}

VOID
DriverPrint::RestoreBrush(
        DpBrush *             brush,
        DpContext *           context,
        DpBitmap *            surface
    )
{
}

/**************************************************************************\
*
* Function Description:
*
*   GDI driver class constructor.
*
* Arguments:
*
*   [IN] device - Associated device
*
* Return Value:
*
*   IsValid() is FALSE in the event of failure.
*
* History:
*
*   12/04/1998 andrewgo
*       Created it.
*
\**************************************************************************/

DriverPrint::DriverPrint(
    GpPrinterDevice *device
    )
{
    IsLockable = FALSE;
    SetValid(TRUE);
    Device = (GpDevice*)device;
    Uniqueness = -1;
    ImageCache = NULL;

    IsPathClip = FALSE;

    REAL dpix = TOREAL(GetDeviceCaps(device->DeviceHdc, LOGPIXELSX));
    REAL dpiy = TOREAL(GetDeviceCaps(device->DeviceHdc, LOGPIXELSY));
    if (dpix > PostscriptImagemaskDPICap)
        PostscriptScalerX = GpCeiling(dpix / PostscriptImagemaskDPICap);
    else
        PostscriptScalerX = 1;

    if (dpiy > PostscriptImagemaskDPICap)
        PostscriptScalerY = GpCeiling(dpiy / PostscriptImagemaskDPICap);
    else
        PostscriptScalerY = 1;

#ifdef DBG
    OutputText("GDI+ PrintDriver Created\n");
#endif
}

/**************************************************************************\
*
* Function Description:
*
*   GDI driver class destructor.
*
* History:
*
*   10/28/1999 ericvan
*       Created it.
*
\**************************************************************************/

DriverPrint::~DriverPrint(
    VOID
    )
{
   if (ImageCache)
       delete ImageCache;
}

/**************************************************************************\
*
* Function Description:
*
*   Computes band size and saves original clipping bounds
*
* Arguments:
*
*   [IN] - DDI parameters.
*
* Return Value:
*
*   GpStatus
*
* History:
*
*   11/23/1999 ericvan
*       Created it.
*
\**************************************************************************/

GpStatus
DriverPrint::SetupPrintBanding(
           DpContext* context,
           GpRect* drawBoundsCap,
           GpRect* drawBoundsDev
           )
{
    // determine band size from MAX_BAND_ALLOC
    NumBands = GpCeiling((REAL)(drawBoundsCap->Width *
                                drawBoundsCap->Height *
                                sizeof(ARGB)) / (REAL)MAX_BAND_ALLOC);

    BandHeightCap = GpCeiling((REAL)drawBoundsCap->Height / (REAL)NumBands);
    BandHeightDev = BandHeightCap * ScaleY;

    // Band bounds for capped DPI rendering
    BandBoundsCap.X      = drawBoundsCap->X;
    BandBoundsCap.Y      = drawBoundsCap->Y;
    BandBoundsCap.Width  = drawBoundsCap->Width;
    BandBoundsCap.Height = BandHeightCap;

    // Band bounds for device DPI rendering
    BandBoundsDev.X      = drawBoundsDev->X;
    BandBoundsDev.Y      = drawBoundsDev->Y;
    BandBoundsDev.Width  = drawBoundsDev->Width;
    BandBoundsDev.Height = BandHeightDev;

    ASSERT(NumBands >= 1 && BandHeightCap >= 1 && BandHeightDev >= 1);

    context->VisibleClip.StartBanding();

    // Tweak the original capped and device bounds to force
    // DpOutputClipRegion in our rendering pipeline.  This is necessary since
    // we clip to each band.
    drawBoundsCap->Y--; drawBoundsCap->Height += 2;
    drawBoundsCap->X--; drawBoundsCap->Width += 2;

    drawBoundsDev->Y--; drawBoundsDev->Height += 2;
    drawBoundsDev->X--; drawBoundsDev->Width += 2;

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Computes band size and sets up clipping bounds
*
* Arguments:
*
*   [IN] - DDI parameters.
*
* Return Value:
*
*   GpStatus
*
* History:
*
*   11/23/1999 ericvan
*       Created it.
*
\**************************************************************************/

VOID DriverPrint::EndPrintBanding(
           DpContext* context
           )
{
    // restore state of clip region
    context->VisibleClip.EndBanding();
}

/**************************************************************************\
*
* Function Description:
*
*   Helper function for SetupEscapeClipping (see return value section)
*
* Arguments:
*
*   points - array of POINTs
*   types - array of BYTE types
*
* Return Value:
*
*   1 if the points indicate a clockwise described rectangle, 2 if
*   counterclockwise and 0 if not a rectangle
*
* History:
*
*   10/10/2000 ericvan
*       Created it.
*
\**************************************************************************/

INT isSimpleRect(DynPointArray &points, DynByteArray &types)
{
    if (points.GetCount() != 4)
    {
        return 0;
    }

    //specified in clockwise order
    if (points[0].Y == points[1].Y && points[2].Y == points[3].Y &&
        points[0].X == points[3].X && points[1].X == points[2].X &&
        types[0] == PathPointTypeStart &&
        types[1] == PathPointTypeLine &&
        types[2] == PathPointTypeLine &&
        types[3] == (PathPointTypeLine | PathPointTypeCloseSubpath))
        return 1;

    //specified in counterclockwise order
    if (points[0].X == points[1].X && points[2].X == points[3].X &&
        points[0].Y == points[3].Y && points[1].Y == points[2].Y &&
        types[0] == PathPointTypeStart &&
        types[1] == PathPointTypeLine &&
        types[2] == PathPointTypeLine &&
        types[3] == (PathPointTypeLine | PathPointTypeCloseSubpath))
        return 2;

    return 0;
}

/**************************************************************************\
*
* Function Description:
*
*   Setup clipping to a given arbitrary path.  On Win98 the path must already
*   be flattened.  The points are specified in POINT units (not floating point),
*   consistent with output of RegionToPath.
*
*   The path can contain subpaths.  For Win9x, we coalesce the subpaths into
*   a single path to avoid poor performance on GDI.  The path is ANDed into
*   any existing postscript clip paths.
*
* Arguments:
*
*   HDC - hdc to send escapes to.
*   points - array of POINTs
*   types - array of BYTE types
*
*   CLIP_SAVE
*   BEGIN_PATH
*   Render path using GDI (use NULL pen + brush to ensure nothings drawn)
*   END_PATH
*   CLIP_RESTORE
*
* Return Value:
*
*   GpStatus
*
* History:
*
*   3/3/2000 ericvan
*       Created it.
*
\**************************************************************************/
VOID
DriverPrint::SetupEscapeClipping(
        HDC                 hdc,
        DynPointArray&      points,
        DynByteArray&       types,
        GpFillMode          fillMode
        )
{
    PathInfo16 pi;

    pi.RenderMode       = RENDER_NODISPLAY;
    pi.FillMode         = (fillMode == FillModeAlternate) ?
                            FILL_ALTERNATE : FILL_WINDING;
    pi.BkMode           = TRANSPARENT;
    pi.Pen.lopnStyle    = PS_NULL;
    pi.Pen.lopnWidth.x  = 0;
    pi.Pen.lopnWidth.y  = 0;
    pi.Pen.lopnColor    = RGB(0,0,0);
    pi.Brush.lbStyle    = BS_NULL;
    pi.Brush.lbColor    = RGB(0,0,0);
    pi.Brush.lbHatch    = 0;

    ASSERT((fillMode == FillModeAlternate) || (fillMode == FillModeWinding));

    GpPoint* pointPtr = points.GetDataBuffer();
    BYTE* typePtr = types.GetDataBuffer();
    GpPoint* freeThisPtr = NULL;

    INT count = points.GetCount();

    // We are partially visible, so we expect something!
    ASSERT(count > 0);
    if (count <= 1)
    {
        return;
    }

    // There is a bug on some printers (eg. hplj8550) where they incorrectly
    // cache simple clipping regions.  To work around this we take simple
    // clipping regions and make them complex.
    GpPoint simplerect[5];
    BYTE simpletypes[] = {
        PathPointTypeStart,
        PathPointTypeLine,
        PathPointTypeLine,
        PathPointTypeLine,
        PathPointTypeLine | PathPointTypeCloseSubpath};

    if (isSimpleRect(points, types)>0)
    {
        //inserting a new point between the third and fourth points which is
        //between the two of them
        simplerect[0] = points[0];
        simplerect[1] = points[1];
        simplerect[2] = points[2];
        simplerect[4] = points[3];
        //we take the average of the two last points to make a point inbetween
        //them.  This works whether the rectangle is specified clockwise or
        //counterclockwise
        simplerect[3].X = (points[2].X + points[3].X) / 2;
        simplerect[3].Y = (points[2].Y + points[3].Y) / 2;
        count = 5;
        pointPtr = simplerect;
        typePtr = simpletypes;
    }

    INT subCount;
    BYTE curType;

    // save original clip
    WORD clipMode = CLIP_SAVE;
    Escape(hdc, CLIP_TO_PATH, sizeof(clipMode), (LPSTR)&clipMode, NULL);

    // send path to PS printer as an escape
    Escape(hdc, BEGIN_PATH, 0, NULL, NULL);

    // !! Notice the lack of error checking when we call GDI...

    // Win95 and WinNT are subtly different in processing postscript escapes.
    if (Globals::IsNt)
    {
       BYTE lastType = 0;

       ::BeginPath(hdc);

       INT startIndex;
       while (count-- > 0)
       {
           switch ((curType = *typePtr++) & PathPointTypePathTypeMask)
           {
           case PathPointTypeStart:
               ::MoveToEx(hdc, pointPtr->X, pointPtr->Y, NULL);
               pointPtr++;
               ASSERT(count > 0);      // no illformed paths please...
               lastType = *typePtr & PathPointTypePathTypeMask;
               subCount = 0;
               break;

           case PathPointTypeLine:
               if (lastType == PathPointTypeBezier)
               {
                   ASSERT(subCount % 3 == 0);
                   if (subCount % 3 == 0)
                   {
                       ::PolyBezierTo(hdc, (POINT*)pointPtr, subCount);
                   }
                   pointPtr += subCount;
                   subCount = 1;
                   lastType = PathPointTypeLine;
               }
               else
               {
                   subCount++;
               }
               break;

           case PathPointTypeBezier:
               if (lastType == PathPointTypeLine)
               {
                   ::PolylineTo(hdc, (POINT*)pointPtr, subCount);
                   pointPtr += subCount;
                   subCount = 1;
                   lastType = PathPointTypeBezier;
               }
               else
               {
                   subCount++;
               }
               break;
           }

           if (curType & PathPointTypeCloseSubpath)
           {
               ASSERT(subCount > 0);

               if (lastType == PathPointTypeBezier)
               {
                   ASSERT(subCount % 3 == 0);
                   if (subCount % 3 == 0)
                   {
                       ::PolyBezierTo(hdc, (POINT*)pointPtr, subCount);
                   }
               }
               else
               {
                   ASSERT(lastType == PathPointTypeLine);
                   ::PolylineTo(hdc, (POINT*)pointPtr, subCount);
               }

               pointPtr += subCount;
               subCount = 0;

               ::CloseFigure(hdc);
           }
       }

       ::EndPath(hdc);
       ::StrokePath(hdc);
    }
    else
    {
        while (count-- > 0)
        {
            curType = *typePtr++;
            ASSERT((curType & PathPointTypePathTypeMask) != PathPointTypeBezier);

            if ((curType & PathPointTypePathTypeMask) == PathPointTypeStart)
            {
                subCount = 1;
            }
            else
            {
                subCount ++;
            }

            if (curType & PathPointTypeCloseSubpath)
            {
                ASSERT(subCount > 0);

                if (subCount == 4)
                {
                    // Win98 postscript drivers are known for recognizing
                    // rectangle polygons at driver level and converting them
                    // to rectfill or rectclip calls.  Unfortunately, there is
                    // a bug that they don't preserve the orientation and so
                    // when winding fill is used, the fill is bad.

                    // We fix this by hacking it into a path of five points.
                    GpPoint rectPts[5];

                    rectPts[0].X = pointPtr[0].X;
                    rectPts[0].Y = pointPtr[0].Y;
                    rectPts[1].X = (pointPtr[0].X + pointPtr[1].X)/2;
                    rectPts[1].Y = (pointPtr[0].Y + pointPtr[1].Y)/2;
                    rectPts[2].X = pointPtr[1].X;
                    rectPts[2].Y = pointPtr[1].Y;
                    rectPts[3].X = pointPtr[2].X;
                    rectPts[3].Y = pointPtr[2].Y;
                    rectPts[4].X = pointPtr[3].X;
                    rectPts[4].Y = pointPtr[3].Y;

                    ::Polygon(hdc, (POINT*)&rectPts[0], 5);
                }
                else
                {
                    ::Polygon(hdc, (POINT*)pointPtr, subCount);
                }

                pointPtr += subCount;
                subCount = 0;

                // send END_PATH, BEGIN_PATH escapes
                if (count > 0)
                {
                    Escape(hdc, END_PATH, sizeof(PathInfo16), (LPSTR)&pi, NULL);
                    Escape(hdc, BEGIN_PATH, 0, NULL, NULL);
                }
            }
        }
    }

    // we should end on a closed subpath
    Escape(hdc, END_PATH, sizeof(PathInfo16), (LPSTR)&pi, NULL);

    // end the path and set up for clipping
    // NT driver ignoes the high WORD - always uses eoclip, but according to
    // Win31 documentation it should be set to the fillmode.
    DWORD inclusiveMode = CLIP_INCLUSIVE | pi.FillMode <<16;
    Escape(hdc, CLIP_TO_PATH, sizeof(inclusiveMode), (LPSTR)&inclusiveMode, NULL);

#if 0
    SelectObject(hdc, oldhPen);
    SelectObject(hdc, oldhBrush);
    SetPolyFillMode(hdc, oldFillMode);
#endif

#ifdef DBG
    OutputText("GDI+ End Setup Escape Clipping");
#endif
}

/**************************************************************************\
*
* Function Description:
*
*   Setup simple path clipping.  On Win98 the path must already
*   be flattened.  The points are specified in POINT units (not floating point),
*   consistent with output of RegionToPath.
*
*   This differs from SetupEscapeClipping() in following way.  The API can
*   be called multiple times, each time specifying a new path, which is ORed
*   into the previous path.  On Win98, no coalescing of the subpath is done.
*
* Arguments:
*
*   HDC - hdc to send escapes to.
*   points - array of POINTs
*   types - array of BYTE types
*
* Return Value:
*
*   GpStatus
*
* History:
*
*   5/22/2000 ericvan
*       Created it.
*
\**************************************************************************/

VOID
DriverPrint::SimpleEscapeClipping(
        HDC                 hdc,
        DynPointArray&      points,
        DynByteArray&       types,
        GpFillMode          fillMode,
        DWORD               flags
        )
{
#ifdef NO_PS_CLIPPING
    return;
#endif
    PathInfo16 pi;
    WORD clipMode;

    pi.RenderMode       = RENDER_NODISPLAY;
    pi.FillMode         = (fillMode == FillModeAlternate) ?
                            FILL_ALTERNATE : FILL_WINDING;
    pi.BkMode           = TRANSPARENT;
    pi.Pen.lopnStyle    = PS_NULL;
    pi.Pen.lopnWidth.x  = 0;
    pi.Pen.lopnWidth.y  = 0;
    pi.Pen.lopnColor    = RGB(0,0,0);
    pi.Brush.lbStyle    = BS_NULL;
    pi.Brush.lbColor    = RGB(0,0,0);
    pi.Brush.lbHatch    = 0;

    ASSERT((fillMode == FillModeAlternate) || (fillMode == FillModeWinding));

#ifdef DBG
    OutputText("GDI+ Setup Simple Escape Clipping");
#endif

    GpPoint* pointPtr = points.GetDataBuffer();
    BYTE* typePtr = types.GetDataBuffer();
    GpPoint* freeThisPtr = NULL;

    INT count = points.GetCount();
    INT subCount = 0;

    BYTE curType;

    // we are partially visible, so we expect something!
    ASSERT(count > 0);
    if (count <= 1)
    {
        return;
    }

    // Win95 and WinNT are subtly different in processing postscript escapes.
    if (Globals::IsNt)
    {
       BYTE lastType = 0;

       INT startIndex;
       while (count-- > 0)
       {
           switch ((curType = *typePtr++) & PathPointTypePathTypeMask)
           {
           case PathPointTypeStart:
               ::MoveToEx(hdc, pointPtr->X, pointPtr->Y, NULL);
               pointPtr++;
               ASSERT(count > 0);      // no illformed paths please...
               lastType = *typePtr & PathPointTypePathTypeMask;
               subCount = 0;
               break;

           case PathPointTypeLine:
               if (lastType == PathPointTypeBezier)
               {
                   ASSERT(subCount % 3 == 0);
                   if (subCount % 3 == 0)
                   {
                       ::PolyBezierTo(hdc, (POINT*)pointPtr, subCount);
                   }
                   pointPtr += subCount;
                   subCount = 1;
                   lastType = PathPointTypeLine;
               }
               else
               {
                   subCount++;
               }
               break;

           case PathPointTypeBezier:
               if (lastType == PathPointTypeLine)
               {
                   ::PolylineTo(hdc, (POINT*)pointPtr, subCount);
                   pointPtr += subCount;
                   subCount = 1;
                   lastType = PathPointTypeBezier;
               }
               else
               {
                   subCount++;
               }
               break;
           }

           if (curType & PathPointTypeCloseSubpath)
           {
               ASSERT(subCount > 0);

               if (lastType == PathPointTypeBezier)
               {
                   ASSERT(subCount % 3 == 0);
                   if (subCount % 3 == 0)
                   {
                       ::PolyBezierTo(hdc, (POINT*)pointPtr, subCount);
                   }
               }
               else
               {
                   ASSERT(lastType == PathPointTypeLine);
                   ::PolylineTo(hdc, (POINT*)pointPtr, subCount);
               }

               pointPtr += subCount;
               subCount = 0;

               ::CloseFigure(hdc);
           }
       }

    }
    else
    {
        // Win98 equivalent code

        // !! Win98 doesn't support bezier points in postscript clipping

        while (count-- > 0)
        {
            curType = *typePtr++;
            ASSERT((curType & PathPointTypePathTypeMask) != PathPointTypeBezier);

            if ((curType & PathPointTypePathTypeMask) == PathPointTypeStart)
            {
                subCount = 1;
            }
            else
            {
                subCount ++;
            }

            if (curType & PathPointTypeCloseSubpath)
            {
                ASSERT(subCount > 0);

                ::Polygon(hdc, (POINT*)pointPtr, subCount);

                pointPtr += subCount;
                subCount = 0;

                // send END_PATH, BEGIN_PATH escapes
                if (count > 0)
                {
                    Escape(hdc, END_PATH, sizeof(PathInfo16), (LPSTR)&pi, NULL);
                    Escape(hdc, BEGIN_PATH, 0, NULL, NULL);
                }
            }
        }
    }

}

/**************************************************************************\
*
* Function Description:
*
*   Setups up postscript clipping path given GlyphPos (outline of glyph
*   characters).
*
* Arguments:
*
*
* Return Value:
*
*   status
*
* History:
*
*   3/20/2k ericvan
*       Created it.
*
\**************************************************************************/

VOID
DriverPrint::SetupGlyphPathClipping(
    HDC                hdc,
    DpContext *        context,
    const GpGlyphPos * glyphPathPos,
    INT                glyphCount
)
{
    ASSERT(hdc != NULL);
    ASSERT(glyphCount > 0);
    ASSERT(glyphPathPos != NULL);

    DynByteArray flattenTypes;
    DynPointFArray flattenPoints;

    GpPointF *pointsPtr;
    BYTE *typesPtr;
    INT count;

    REAL m[6];

    PathInfo16 pi;
    DWORD clipMode;

    pi.RenderMode       = RENDER_NODISPLAY;
    pi.FillMode         = FILL_ALTERNATE;
    pi.BkMode           = TRANSPARENT;
    pi.Pen.lopnStyle    = PS_NULL;
    pi.Pen.lopnWidth.x  = 0;
    pi.Pen.lopnWidth.y  = 0;
    pi.Pen.lopnColor    = RGB(0,0,0);
    pi.Brush.lbStyle    = BS_NULL;
    pi.Brush.lbColor    = RGB(0,0,0);
    pi.Brush.lbHatch    = 0;

    GpGlyphPos *curGlyph = const_cast<GpGlyphPos*>(&glyphPathPos[0]);

    if (glyphCount > 0)
    {
        // save original clip
        // NT driver ignoes the high WORD - always uses eoclip, but according to
        // Win31 documentation it should be set to the fillmode.
        clipMode = CLIP_SAVE;
        Escape(hdc, CLIP_TO_PATH, sizeof(clipMode), (LPSTR)&clipMode, NULL);


        if (Globals::IsNt)
        {
            // send path to PS printer as an escape
            Escape(hdc, BEGIN_PATH, 0, NULL, NULL);

            ::BeginPath(hdc);
        }
    }

    for (INT pos=0; pos<glyphCount; pos++, curGlyph++)
    {

        // get path for glyph character
        GpGlyphPath *glyphPath = (GpGlyphPath*)curGlyph->GetPath();

        if ((glyphPath != NULL) && glyphPath->IsValid() && !glyphPath->IsEmpty())
        {
            // !! Perf improvement.  Avoid copying this point array somehow.

            GpPath path(glyphPath->points,
                        glyphPath->types,
                        glyphPath->pointCount,
                        FillModeAlternate);         // !! Is this right?

            ASSERT(path.IsValid());
            if (path.IsValid())
            {
                // create transform to translate path to correct position
                GpMatrix matrix;

                BOOL doFlatten = !Globals::IsNt && path.HasCurve();

                if (doFlatten)
                {
                    // This makes a Flattened copy of the points... (stored
                    // independent of the original points)

                    path.Flatten(&flattenTypes, &flattenPoints, &matrix);

                    pointsPtr = flattenPoints.GetDataBuffer();
                    typesPtr = flattenTypes.GetDataBuffer();
                    count = flattenPoints.GetCount();
                }
                else
                {
                    pointsPtr = const_cast<GpPointF*>(path.GetPathPoints());
                    typesPtr = const_cast<BYTE*>(path.GetPathTypes());
                    count = path.GetPointCount();
                }

                DynPointArray points;
                DynByteArray types(typesPtr, count, count);

                POINT * transformedPointsPtr = (POINT *) points.AddMultiple(count);

                // !!! bhouse This call can fail yet it returns void
                if(!transformedPointsPtr)
                    return;

                // translate to proper position in device space.
                matrix.Translate(TOREAL(curGlyph->GetLeft()),
                                 TOREAL(curGlyph->GetTop()),
                                 MatrixOrderAppend);

                // path is already in device space, but relative to bounding
                // box of glyph character.
                matrix.Transform(pointsPtr,
                                 transformedPointsPtr,
                                 count);

                // send path to PS printer as an escape
                if (!Globals::IsNt)
                {
                    Escape(hdc, BEGIN_PATH, 0, NULL, NULL);
                }


                SimpleEscapeClipping(hdc,
                                     points,
                                     types,
                                     FillModeAlternate,
                                     0);
                if (!Globals::IsNt)
                {
                    // we should end on a closed subpath
                    Escape(hdc, END_PATH, sizeof(PathInfo16), (LPSTR)&pi, NULL);
                }

                GlyphClipping = TRUE;
            }
        }

    }

    if (glyphCount > 0)
    {
        if (Globals::IsNt)
        {
            ::EndPath(hdc);
            ::StrokePath(hdc);

            // we should end on a closed subpath
            Escape(hdc, END_PATH, sizeof(PathInfo16), (LPSTR)&pi, NULL);
        }


        // end the path and set up for clipping
        // NT driver ignoes the high WORD - always uses eoclip, but according to
        // Win31 documentation it should be set to the fillmode.
        DWORD inclusiveMode = CLIP_INCLUSIVE | pi.FillMode<<16;
        Escape(hdc, CLIP_TO_PATH, sizeof(inclusiveMode), (LPSTR)&inclusiveMode, NULL);

    }
}

/**************************************************************************\
*
* Function Description:
*
*   Restore postscript escape clipping.  For use with simple and complex
*   clipping.
*
* Arguments:
*
* HDC             - printer HDC to send escapes to
*
* Return Value:
*
*   GpStatus
*
* History:
*
*   3/3/2000 ericvan - Created it.
*
\**************************************************************************/

VOID
DriverPrint::RestoreEscapeClipping(
        HDC                 hdc
        )
{
     WORD clipMode = CLIP_RESTORE;
     Escape(hdc, CLIP_TO_PATH, sizeof(clipMode), (LPSTR)&clipMode, NULL);
}

/**************************************************************************\
*
* Function Description:
*
*   Setup clipping.  If the printer (PS and apparently some PCL printers)
*   support escape clippings, then use them.  Otherwise, revert to GDI
*   to do our clipping.  NOTE:  This is only necessary for cases where
*   GDI is doing the rendering.
*
* Arguments:
*
* HDC             - printer HDC to send escapes to
* clipRegion      - clip region to send
* drawBounds      - bounding box for drawing region
* IsClip [OUT]    - whether was necessary to send clip region
* hRgnSaveClip    - HRGN to save old clip region
*
* Return Value:
*
*   GpStatus
*
* History:
*
*   10/28/1999 ericvan - Created it.
*   1/25/2k ericvan - Switch on escape clipping or GDI clipping
*
\**************************************************************************/

VOID
DriverPrint::SetupClipping(
    HDC                 hdc,
    DpContext *         context,
    const GpRect *      drawBounds,
    BOOL &              isClip,
    BOOL &              usePathClipping, // ignored here
    BOOL                forceClipping
    )
{
    // the visible clip is at device resolution so there is no benefit to using paths here.
    ASSERT(usePathClipping == FALSE);

    DpClipRegion *      clipRegion = &(context->VisibleClip);

    isClip = FALSE;

    if (UseClipEscapes)
    {
        if (forceClipping ||
            (clipRegion->GetRectVisibility(drawBounds->X,
                                         drawBounds->Y,
                                         drawBounds->GetRight(),
                                         drawBounds->GetBottom())
          != DpRegion::TotallyVisible))
        {
            // If it is a simple region, we draw it directly.

            if (Uniqueness != clipRegion->GetUniqueness())
            {
                RegionToPath convertRegion;

                if (convertRegion.ConvertRegionToPath(clipRegion,
                                              ClipPoints,
                                              ClipTypes) == FALSE)
                {
                    ClipPoints.Reset();
                    ClipTypes.Reset();
                    UseClipEscapes = FALSE;
                    goto UseGDIClipping;
                }

                Uniqueness = clipRegion->GetUniqueness();
            }

            SetupEscapeClipping(hdc, ClipPoints, ClipTypes);

            isClip = TRUE;
        }
    }
    else
    {
UseGDIClipping:
        DpDriver::SetupClipping(hdc, context, drawBounds, isClip,
                                usePathClipping, forceClipping);
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Restore clipping
*
* Arguments:
*
*   dstHdc - destination printer device
*   surface - surface
*   drawBounds - rectangular section of surface to paint
*
* Return Value:
*
*   status
*
* History:
*
*   11/30/1999 ericvan
*       Created it.
*
\**************************************************************************/

VOID
DriverPrint::RestoreClipping(
    HDC  hdc,
    BOOL isClip,
    BOOL usePathClipping
    )
{
   if (isClip)
   {
       if (UseClipEscapes)
       {
           RestoreEscapeClipping(hdc);
       }
       else
       {
           DpDriver::RestoreClipping(hdc, isClip, usePathClipping);
       }
   }
}

/**************************************************************************\
*
* Function Description:
*
*   Setup Path Clipping.  This routine ANDs the given path into the
*   the current clip region.
*
* Arguments:
*
* HDC             - printer HDC
* clipPath        - path to clip
* IsClip [OUT]    - whether was necessary to send clip region
* hRgnSaveClip    - HRGN to save old clip region
*
* Return Value:
*
*   GpStatus
*
* History:
*
*   8/17/2k ericvan - Created it.
*
\**************************************************************************/

VOID
DriverPrint::SetupPathClipping(
        HDC                 hdc,
        DpContext *         context,
        const DpPath*       clipPath
        )
{
    ASSERT(IsPathClip == FALSE);

    if (UseClipEscapes)
    {
        BOOL doFlatten = !Globals::IsNt && clipPath->HasCurve();

        GpPointF *pointsPtr;
        BYTE *typesPtr;
        INT count;

        DynByteArray flattenTypes;
        DynPointFArray flattenPoints;

        if (doFlatten)
        {
            // This makes a Flattened copy of the points... (stored independent
            // of original points.

            clipPath->Flatten(
                            &flattenTypes,
                            &flattenPoints,
                            &(context->WorldToDevice));

            pointsPtr = flattenPoints.GetDataBuffer();
            typesPtr = flattenTypes.GetDataBuffer();
            count = flattenPoints.GetCount();
        }
        else
        {
            pointsPtr = const_cast<GpPointF*>(clipPath->GetPathPoints());
            typesPtr = const_cast<BYTE*>(clipPath->GetPathTypes());
            count = clipPath->GetPointCount();
        }

        DynPointArray points;
        DynByteArray types(typesPtr, count, count);

        POINT * transformedPointsPtr = (POINT *) points.AddMultiple(count);

        // !!! bhouse This call can fail yet it returns void
        if(!transformedPointsPtr)
            return;

        if (doFlatten || context->WorldToDevice.IsIdentity())
        {
            GpMatrix idMatrix;

            idMatrix.Transform(pointsPtr, transformedPointsPtr, count);
        }
        else
        {
            // We transform the points here to avoid an extra potentially
            // large memory alloc (not flattened, we can't transform in place)

            context->WorldToDevice.Transform(pointsPtr, transformedPointsPtr, count);
        }

        SetupEscapeClipping(hdc, points, types, clipPath->GetFillMode());

        IsPathClip = TRUE;
    }
    else
    {
        ::SaveDC(hdc);

        // Windows98 ExtCreateRegion has a 64kb limit, so we can't use
        // Region->GetHRgn() to create the HRGN.  Incidentlly there is
        // also an NT4 SPx bug where ExtCreateRegion fails sometimes.
        // Instead we use SelectClipPath()

        ConvertPathToGdi gdiPath(clipPath,
                                 &(context->WorldToDevice),
                                 0);

        if (gdiPath.IsValid())
        {
            gdiPath.AndClip(hdc);
        }

        IsPathClip = TRUE;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Restore Path Clipping.  This routine restore clip region to original
*   representation.
*
* Arguments:
*
* HDC             - printer HDC
* clipPath        - path to clip
* hRgnSaveClip    - HRGN to save old clip region
*
* Return Value:
*
*   GpStatus
*
* History:
*
*   8/17/2k ericvan - Created it.
*
\**************************************************************************/

VOID
DriverPrint::RestorePathClipping(HDC hdc)
{
    DriverPrint::RestoreClipping(hdc, IsPathClip, FALSE);

    IsPathClip = FALSE;
}

/**************************************************************************\
*
* Function Description:
*
*   Fills a rectangular region with a pen.  Sets the clipping appropriately
*   as path INTERSECT visible clip.
*
* Arguments:
*
*   [IN] - DDI parameters.
*
* Return Value:
*
*   GpStatus
*
* History:
*
*   10/28/1999 ericvan
*       Created it.
*
\**************************************************************************/

GpStatus
DriverPrint::PrivateFillRect(
                DpContext *context,
                DpBitmap *surface,
                const GpRect *drawBounds,
                const DpPath *outlinePath,
                const DpBrush *brush
                )
{
    GpStatus status = Ok;
    ASSERT(outlinePath != NULL);

    // Optimization for LinearGradientBrush fills.  We rasterize to a small
    // DIB and send that to the printer.  For horizontal and vertical gradients
    // in particular, this results in significant savings.

    GpMatrix savedmatrix;

    GpBrush *gpBrush = GpBrush::GetBrush(brush);
    GpSpecialGradientType gradientType;

    if (IsOpaque &&
        ((gradientType = gpBrush->GetSpecialGradientType(&context->WorldToDevice))
         != GradientTypeNotSpecial))
    {
        GpRect       bitmapBounds = *drawBounds;
        GpBitmap *   gpBitmap = NULL;

        switch (gradientType)
        {
        case GradientTypeHorizontal:
            bitmapBounds.Width = 1;
            break;

        case GradientTypeVertical:
            bitmapBounds.Height = 1;
            break;

        case GradientTypePathTwoStep:
        case GradientTypeDiagonal:
            bitmapBounds.Width = min(drawBounds->Width, 256);
            bitmapBounds.Height = min(drawBounds->Height, 256);
            break;

        case GradientTypePathComplex:
            // send the whole drawBounds for now.
            break;

        default:
            ASSERT(0);
            break;
        }

        HDC hdc = context->GetHdc(surface);

        if (hdc != NULL)
        {
            // Transform the destination drawBounds rectangle to
            // bitmapBounds size.
            bitmapBounds.X = 0;
            bitmapBounds.Y = 0;

            RectF destRect(0.0f,
                           0.0f,
                           TOREAL(bitmapBounds.Width),
                           TOREAL(bitmapBounds.Height));
            RectF srcRect(TOREAL(drawBounds->X),
                          TOREAL(drawBounds->Y),
                          TOREAL(drawBounds->Width),
                          TOREAL(drawBounds->Height));

            GpMatrix transform;
            transform.InferAffineMatrix(destRect, srcRect);

            GpMatrix::MultiplyMatrix(transform,
                                     context->WorldToDevice,
                                     transform);

            status = GpBitmap::CreateBitmapAndFillWithBrush(
                             context->FilterType,
                             &transform,
                             &bitmapBounds,
                             gpBrush,
                             &gpBitmap);

            if ((status == Ok) && (gpBitmap != NULL))
            {
                GpRect & srcRect = bitmapBounds;
                PixelFormatID lockFormat = PixelFormat32bppARGB;
                BitmapData bmpDataSrc;

                // Lock the bits.
                if (gpBitmap->LockBits(NULL,
                                       IMGLOCK_READ,
                                       lockFormat,
                                       &bmpDataSrc) == Ok)
                {
                    DpBitmap driverSurface;

                    // Fake up a DpBitmap for the driver call.
                    // We do this because the GpBitmap doesn't maintain the
                    // DpBitmap as a driver surface - instead it uses a
                    // GpMemoryBitmap.
                    gpBitmap->InitializeSurfaceForGdipBitmap(
                        &driverSurface,
                        bmpDataSrc.Width,
                        bmpDataSrc.Height
                    );

                    driverSurface.Bits         = (BYTE*)bmpDataSrc.Scan0;

                    driverSurface.Width        = bmpDataSrc.Width;
                    driverSurface.Height       = bmpDataSrc.Height;
                    driverSurface.Delta        = bmpDataSrc.Stride;

                    // Pixel format to match the lockbits above.

                    driverSurface.PixelFormat  = lockFormat;

                    driverSurface.NumBytes     = bmpDataSrc.Width  *
                                                 bmpDataSrc.Height * 3;

                    // Must be transparent to get here.
                    driverSurface.SurfaceTransparency = TransparencyOpaque;

                    ConvertBitmapToGdi  gdiBitmap(hdc,
                                                  &driverSurface,
                                                  &srcRect,
                                                  IsPrinting);

                    status = GenericError;

                    if (gdiBitmap.IsValid())
                    {
                        BOOL        isClip;
                        BOOL        usePathClipping = FALSE;

                        // Clip to visible region
                        SetupClipping(hdc, context, drawBounds, isClip, usePathClipping, FALSE);

                        // Clip to outline path (fill shape)
                        SetupPathClipping(hdc, context, outlinePath);

                        // Destination points in POINT co-ordinates
                        POINT destPoints[3];
                        destPoints[0].x = drawBounds->X;
                        destPoints[0].y = drawBounds->Y;
                        destPoints[1].x = drawBounds->X + drawBounds->Width;
                        destPoints[1].y = drawBounds->Y;
                        destPoints[2].x = drawBounds->X;
                        destPoints[2].y = drawBounds->Y + drawBounds->Height;

                        // Perform StretchDIBits of bitmap
                        status = gdiBitmap.StretchBlt(hdc, destPoints) ? Ok : GenericError;

                        // restore clipping from outline of shape
                        RestorePathClipping(hdc);

                        // restore from visible clip region
                        RestoreClipping(hdc, isClip, usePathClipping);
                    }

                    gpBitmap->UnlockBits(&bmpDataSrc);
                }

                gpBitmap->Dispose();

                context->ReleaseHdc(hdc);

                return status;
            }

            context->ReleaseHdc(hdc);
        }
    }

    BOOL SetVisibleClip;
    DWORD options = 0;

    BOOL AdjustWorldTransform = FALSE;

    switch (DriverType)
    {
    case DriverPCL:
        if (IsSolid)
        {
            options = ScanDeviceBounds;
            if (!IsOpaque)
            {
                options |= ScanDeviceAlpha;
            }
        }
        else
        {
            if (Is01Bitmap)
            {
                // rasterize at 32bpp
                options = ScanCappedBounds | ScanCapped32bpp;
            }
            else if (IsOpaque)
            {
                // rasterize at 24bpp
                options = ScanCappedBounds;
            }
            else
            {
                // rasterize 24bpp @ cap dpi & 1bpp @ device api
                options = ScanCappedBounds | ScanDeviceBounds | ScanDeviceAlpha;
            }
        }
        SetVisibleClip = IsOpaque || Is01Bitmap;
        break;

    case DriverPostscript:
        SetVisibleClip = !IsSolid;

        if (IsSolid)
        {
            options = ScanDeviceBounds;
            if (!IsOpaque)
            {
                options |= ScanDeviceAlpha;
            }

            if (PostscriptScalerX != 1 || PostscriptScalerY != 1)
            {
                AdjustWorldTransform = TRUE;
                savedmatrix = context->WorldToDevice;
            }
        }
        else
        {
            // For postscript we currently only support 0-1 alpha or complete
            // opaque.
            if (Is01Bitmap)
            {
                options |= ScanCappedBounds | ScanCapped32bpp;
            }
            else if (IsOpaque)
            {
                options |= ScanCappedBounds;
            }
            else
            {
                options |= ScanCappedBounds | ScanCappedOver | ScanDeviceZeroOut;
            }
        }
        break;

    default:
        ASSERT(FALSE);
        return NotImplemented;
    }

    EpScanDIB *scanPrint = (EpScanDIB*) surface->Scan;
    REAL w2dDev[6];
    REAL w2dCap[6];

    // To avoid round off errors causing
    GpRect roundedBounds;

    INT oldScaleX = ScaleX;
    INT oldScaleY = ScaleY;

    // For texture brush, rasterize at the texture image DPI.
    if (brush->Type == BrushTypeTextureFill)
    {
        GpTexture *gpBrush = (GpTexture*)GpBrush::GetBrush(brush);
        ASSERT(gpBrush != NULL);

        GpBitmap *gpBitmap = gpBrush->GetBitmap();

        if (gpBitmap != NULL)
        {
            REAL dpiX, dpiY;

            gpBitmap->GetResolution(&dpiX, &dpiY);

            ScaleX = GpFloor(surface->GetDpiX()/dpiX);
            ScaleY = GpFloor(surface->GetDpiY()/dpiY);

            // don't rasterize at a dpi higher than the destination surface
            if (ScaleX < 1) ScaleX = 1;
            if (ScaleY < 1) ScaleY = 1;
        }
    }

    if ((ScaleX == 1) && (ScaleY == 1))
    {
        roundedBounds.X = drawBounds->X;
        roundedBounds.Y = drawBounds->Y;
        roundedBounds.Width = drawBounds->Width;
        roundedBounds.Height = drawBounds->Height;
    }
    else
    {
        // round X,Y to multiple of ScaleX,Y
        roundedBounds.X = (drawBounds->X / ScaleX) * ScaleX;
        roundedBounds.Y = (drawBounds->Y / ScaleY) * ScaleY;

        // adjust width and height to compensate for smaller X,Y.
        roundedBounds.Width = drawBounds->Width + (drawBounds->X % ScaleX);
        roundedBounds.Height = drawBounds->Height + (drawBounds->Y % ScaleY);

        // round width, height to multiple of ScaleX,Y
        roundedBounds.Width += (ScaleX - (roundedBounds.Width % ScaleX));
        roundedBounds.Height += (ScaleY - (roundedBounds.Height % ScaleY));
    }

    // DrawBounds in Capped Space
    GpRect boundsCap(roundedBounds.X / ScaleX,
                     roundedBounds.Y / ScaleY,
                     roundedBounds.Width / ScaleX,
                     roundedBounds.Height / ScaleY);
    GpRect& boundsDev = roundedBounds;

    if (AdjustWorldTransform)
    {
        boundsDev.X = GpCeiling((REAL)boundsDev.X / PostscriptScalerX);
        boundsDev.Y = GpCeiling((REAL)boundsDev.Y / PostscriptScalerY);
        boundsDev.Width = GpCeiling((REAL)boundsDev.Width / PostscriptScalerX);
        boundsDev.Height = GpCeiling((REAL)boundsDev.Height / PostscriptScalerY);
        context->WorldToDevice.Scale(1.0f/PostscriptScalerX,
            1.0f/PostscriptScalerY,
            MatrixOrderAppend);
    }

    context->WorldToDevice.GetMatrix(&w2dDev[0]);
    context->WorldToDevice.Scale(1.0f/TOREAL(ScaleX),
                                 1.0f/TOREAL(ScaleY),
                                 MatrixOrderAppend);
    context->WorldToDevice.GetMatrix(&w2dCap[0]);
    context->InverseOk = FALSE;

    // Infer a rectangle in world space which under the w2dCap transform
    // covers our bounding box.

    GpPointF dstPts[2];

    dstPts[0].X = TOREAL(boundsCap.X);
    dstPts[0].Y = TOREAL(boundsCap.Y);
    dstPts[1].X = TOREAL(boundsCap.X + boundsCap.Width);
    dstPts[1].Y = TOREAL(boundsCap.Y + boundsCap.Height);

    GpMatrix matrix;
    context->GetDeviceToWorld(&matrix);
    matrix.Transform(&dstPts[0], 2);

    GpRectF rectCap;
    rectCap.X = dstPts[0].X;
    rectCap.Y = dstPts[0].Y;
    rectCap.Width = dstPts[1].X - dstPts[0].X;
    rectCap.Height = dstPts[1].Y - dstPts[0].Y;

    // Reorient destination rectangle in the event that it has flipped by
    // World to Device transform.
    if (rectCap.Width < 0)
    {
        rectCap.X += rectCap.Width;
        rectCap.Width = -rectCap.Width;
    }

    if (rectCap.Height < 0)
    {
        rectCap.Y += rectCap.Height;
        rectCap.Height = -rectCap.Height;
    }

    SetupPrintBanding(context, &boundsCap, &boundsDev);

    HDC hdc = context->GetHdc(surface);

    if (hdc != NULL)
    {
        status = scanPrint->CreateBufferDIB(&BandBoundsCap,
                                            &BandBoundsDev,
                                            options,
                                            ScaleX,
                                            ScaleY);

        if (status == Ok)
        {
            BOOL isClip = FALSE;
            BOOL usePathClipping = FALSE;

            if (SetVisibleClip)
            {
                DriverPrint::SetupClipping(hdc, context, drawBounds,
                                           isClip, usePathClipping, FALSE);
            }

            ASSERT(NumBands > 0);
            for (Band = 0; Band<NumBands; Band++)
            {
                if (options & ScanCappedFlags)
                {
                    context->VisibleClip.DisableComplexClipping(BandBoundsCap);

                    // Render at capped DPI
                    context->InverseOk = FALSE;
                    context->WorldToDevice.SetMatrix(&w2dCap[0]);
                    scanPrint->SetRenderMode(FALSE, &BandBoundsCap);

                    status = DpDriver::FillRects(context,
                                                 surface,
                                                 &boundsCap,
                                                 1,
                                                 &rectCap,
                                                 brush);
                    context->VisibleClip.ReEnableComplexClipping();
                }

                context->InverseOk = FALSE;
                context->WorldToDevice.SetMatrix(&w2dDev[0]);

                if (status != Ok)
                    break;

                if (options & ScanDeviceFlags)
                {
                    context->VisibleClip.SetBandBounds(BandBoundsDev);
                    scanPrint->SetRenderMode(TRUE, &BandBoundsDev);

                    status = DpDriver::FillPath(context,
                                                surface,
                                                &boundsDev,
                                                outlinePath,
                                                brush);
                }

                if (status == Ok)
                {
                    status = OutputBufferDIB(hdc,
                                             context,
                                             surface,
                                             &BandBoundsCap,
                                             &BandBoundsDev,
                                             const_cast<DpPath*>(outlinePath));

                    if (status != Ok)
                        break;
                }
                else
                    break;

                BandBoundsCap.Y += BandHeightCap;
                BandBoundsDev.Y += BandHeightDev;
            }

            if (SetVisibleClip)
            {
                DriverPrint::RestoreClipping(hdc, isClip, usePathClipping);
            }

            scanPrint->DestroyBufferDIB();
        }

        context->ReleaseHdc(hdc);
    }
    else
    {
        context->InverseOk = FALSE;
        context->WorldToDevice.SetMatrix(&w2dDev[0]);
    }

    EndPrintBanding(context);

    if (AdjustWorldTransform)
    {
        context->InverseOk = FALSE;
        context->WorldToDevice = savedmatrix;
    }

    ScaleX = oldScaleX;
    ScaleY = oldScaleY;

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Draws filled paths.
*
* Arguments:
*
*   [IN] - DDI parameters.
*
* Return Value:
*
*   GpStatus
*
* History:
*
*   10/28/1999 ericvan
*       Created it.
*
\**************************************************************************/

GpStatus
DriverPrint::FillPath(
    DpContext *context,
    DpBitmap *surface,
    const GpRect *drawBounds,
    const DpPath *path,
    const DpBrush *brush
    )
{
    if (SetupBrush(const_cast<DpBrush*>(brush), context, surface))
        return Ok;

    GpStatus status;

    if (IsOpaque)
    {
        DWORD       convertFlags = IsPrinting | ForFill |
                      ((DriverType == DriverPostscript) ? IsPostscript : 0);

        HBRUSH      hBrush  = GetBrush(brush, convertFlags);

        if (hBrush)
        {
            HDC         hdc     = context->GetHdc(surface);

            if (hdc != NULL)
            {
                BOOL success = FALSE;

                ConvertPathToGdi gdiPath(path,
                                         &context->WorldToDevice,
                                         convertFlags,
                                         drawBounds);

                if (gdiPath.IsValid())
                {
                    BOOL        isClip;
                    BOOL        usePathClipping = FALSE;

                    SetupClipping(hdc, context, drawBounds, isClip,
                                  usePathClipping, FALSE);

                    success = gdiPath.Fill(hdc, hBrush);

                    RestoreClipping(hdc, isClip, usePathClipping);
                }
                else
                {
                    // Path is too complicated to use GDI printing with FillPath
                    // semantics.  Instead we AND the outline path into the clip
                    // path and do a PatBlt.

                    BOOL        isClip;
                    BOOL        usePathClipping = FALSE;

                    // clip to the visible region
                    SetupClipping(hdc, context, drawBounds, isClip, usePathClipping);

                    // clip to the outline path
                    SetupPathClipping(hdc, context, path);

                    HBRUSH oldHbr = (HBRUSH)SelectObject(hdc, hBrush);

                    // PatBlt the destination hdc with outline clip path
                    success = (BOOL)PatBlt(hdc,
                                           drawBounds->X,
                                           drawBounds->Y,
                                           drawBounds->Width,
                                           drawBounds->Height,
                                           PATCOPY);

                    SelectObject(hdc, oldHbr);

                    // restore clipping from outline path
                    RestorePathClipping(hdc);

                    // restore clipping from visible region
                    RestoreClipping(hdc, isClip, usePathClipping);
                }

                context->ReleaseHdc(hdc);

                if (success)
                {
                    status = Ok;
                    goto Exit;
                }
            }
        }
    }

    status = PrivateFillRect(context,
                             surface,
                             drawBounds,
                             path,
                             brush);

Exit:
    RestoreBrush(const_cast<DpBrush*>(brush), context, surface);

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Draws filled rectangles.
*
* Arguments:
*
*   [IN] - DDI parameters.
*
* Return Value:
*
*   GpStatus
*
* History:
*
*   10/28/1999 ericvan
*       Created it.
*
\**************************************************************************/

GpStatus
DriverPrint::FillRects(
    DpContext *context,
    DpBitmap *surface,
    const GpRect *drawBounds,
    INT numRects,
    const GpRectF *rects,
    const DpBrush *brush
    )
{
    ASSERT(numRects > 0);

    ASSERT(context->WorldToDevice.IsTranslateScale());

    if (SetupBrush(const_cast<DpBrush*>(brush), context, surface))
        return Ok;

    GpStatus status;

    if (IsOpaque)
    {
        DWORD       convertFlags = IsPrinting | ForFill |
                      ((DriverType == DriverPostscript) ? IsPostscript : 0);

        HBRUSH      hBrush  = GetBrush(brush, convertFlags);

        if (hBrush)
        {
            ConvertRectFToGdi gdiRects(rects, numRects, &context->WorldToDevice);

            if (gdiRects.IsValid())
            {
                HDC         hdc     = context->GetHdc(surface);

                if (hdc != NULL)
                {
                    BOOL        isClip;
                    BOOL        success;
                    BOOL        usePathClipping = FALSE;

                    SetupClipping(hdc, context, drawBounds, isClip,
                                  usePathClipping, FALSE);

                    success = gdiRects.Fill(hdc, hBrush);

                    RestoreClipping(hdc, isClip, usePathClipping);

                    context->ReleaseHdc(hdc);

                    if (success)
                    {
                        status = Ok;
                        goto Exit;
                    }
                }
            }
        }
    }

    // Setting the rectangles to a path is somewhat problematic because their
    // intersection may not be interpreted properly.  Also, this should result
    // in fewer bits being sent and more computation.  Here we just set each
    // rectangle as the drawBounds and no outline path to clip.
    {
        PointF pts[4];
        BYTE types[4] = {
            PathPointTypeStart,
            PathPointTypeLine,
            PathPointTypeLine,
            PathPointTypeLine | PathPointTypeCloseSubpath
        };

        pts[0].X = rects->X;
        pts[0].Y = rects->Y;
        pts[1].X = rects->X + rects->Width;
        pts[1].Y = rects->Y;
        pts[2].X = rects->X + rects->Width;
        pts[2].Y = rects->Y + rects->Height;
        pts[3].X = rects->X;
        pts[3].Y = rects->Y + rects->Height;

        GpPath rectPath(&pts[0],
                        &types[0],
                        4,
                        FillModeWinding);

        if (rectPath.IsValid())
        {
            while (numRects > 0)
            {
                GpRectF rectf = *rects;

                context->WorldToDevice.TransformRect(rectf);

                GpRect rect(GpRound(rectf.X), GpRound(rectf.Y),
                            GpRound(rectf.Width), GpRound(rectf.Height));

                status = PrivateFillRect(context,
                                         surface,
                                         (GpRect *)&rect,
                                         &rectPath,
                                         brush);

                if (--numRects)
                {
                    rects++;
                    // !! Safer and more efficient way to do this?
                    GpPointF* pathPts = const_cast<GpPointF*>(rectPath.GetPathPoints());

                    pathPts[0].X = rects->X;
                    pathPts[0].Y = rects->Y;
                    pathPts[1].X = rects->X + rects->Width;
                    pathPts[1].Y = rects->Y;
                    pathPts[2].X = rects->X + rects->Width;
                    pathPts[2].Y = rects->Y + rects->Height;
                    pathPts[3].X = rects->X;
                    pathPts[3].Y = rects->Y + rects->Height;
                }
            }
        }
    }

Exit:
    RestoreBrush(const_cast<DpBrush*>(brush), context, surface);

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Draws filled regions.
*
* Arguments:
*
*   [IN] - DDI parameters.
*
* Return Value:
*
*   GpStatus
*
* History:
*
*   10/28/1999 ericvan
*       Created it.
*
\**************************************************************************/

GpStatus
DriverPrint::FillRegion(
    DpContext *context,
    DpBitmap *surface,
    const GpRect *drawBounds,
    const DpRegion *region,
    const DpBrush *brush
    )
{
    if (SetupBrush(const_cast<DpBrush*>(brush), context, surface))
        return Ok;

    GpStatus status;

    if (IsOpaque)
    {
        DWORD       convertFlags = IsPrinting | ForFill |
                      ((DriverType == DriverPostscript) ? IsPostscript : 0);

        HBRUSH      hBrush  = GetBrush(brush, convertFlags);

        if (hBrush)
        {
            ConvertRegionToGdi gdiRegion(region);

            if (gdiRegion.IsValid())
            {
                HDC         hdc     = context->GetHdc(surface);

                if (hdc != NULL)
                {
                    BOOL        isClip;
                    BOOL        success;
                    BOOL        usePathClipping = FALSE;

                    SetupClipping(hdc, context, drawBounds, isClip,
                                  usePathClipping, FALSE);

                    success = gdiRegion.Fill(hdc, hBrush);

                    RestoreClipping(hdc, isClip, usePathClipping);

                    context->ReleaseHdc(hdc);

                    if (success)
                    {
                        status = Ok;
                        goto Exit;
                    }
                }
            }
        }
    }

    {
        // convert region to path
        RegionToPath convertRegion;

        DynPointArray points;
        DynByteArray types;

        if (convertRegion.ConvertRegionToPath(const_cast<DpRegion*>(region),
                                              points,
                                              types) == FALSE)
        {
            status = GenericError;
            goto Exit1;
        }

        {
            // unfortunately to create path, our points must be floating point,
            // so we allocate and convert

            GpPointF *pointFArray;
            GpPoint *pointArray = points.GetDataBuffer();
            INT numPoints = points.GetCount();

            pointFArray = (GpPointF*) GpMalloc(numPoints * sizeof(GpPointF));

            if (pointFArray == NULL)
            {
                status = OutOfMemory;
                goto Exit12;
            }

            {
                for (INT i=0; i<numPoints; i++)
                {
                    pointFArray[i].X = TOREAL(pointArray[i].X);
                    pointFArray[i].Y = TOREAL(pointArray[i].Y);
                }

                // !! We compute path from region in device space to ensure
                // our output is high quality. Perhaps add an option here
                // dependent on the QualityMode to convert in world space and
                // then transform to device space.

                // This is not a high frequency API so I don't care too much
                // about perf, but perhaps it could be improved by reworking
                // where this transform occurs.

                GpMatrix deviceToWorld;
                context->GetDeviceToWorld(&deviceToWorld);
                deviceToWorld.Transform(pointFArray, numPoints);

                // !! What's the fillMode?
                // !! Create a DpPath, do we require the knowledge of the inheritance anywhere?
                {
                    GpPath path(pointFArray,
                                types.GetDataBuffer(),
                                numPoints);

                    if (path.IsValid())
                    {
                        GpRect newBounds;

                        path.GetBounds(&newBounds,
                                       &context->WorldToDevice);

                        status = FillPath(context,
                                          surface,
                                          &newBounds,
                                          (DpPath*)&path,
                                          brush);
                    }
                }

                GpFree(pointFArray);
            }

Exit12:
            ;
        } // pointFArray

Exit1:
        ;
    } // RegionToPath

Exit:
    RestoreBrush(const_cast<DpBrush*>(brush), context, surface);

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Strokes paths.
*
* Arguments:
*
*   [IN] - DDI parameters.
*
* Return Value:
*
*   GpStatus.
*
* History:
*
*   10/28/1999 ericvan
*       Created it.
*
\**************************************************************************/

GpStatus
DriverPrint::StrokePath(
    DpContext *context,
    DpBitmap *surface,
    const GpRect *drawBounds,
    const DpPath *path,
    const DpPen *pen
    )
{
    if (SetupBrush(const_cast<DpBrush*>(pen->Brush), context, surface))
        return Ok;

    GpStatus status;

    // GDI doesn't seem to support HPENs which PATTERN type HBRUSHes
    if (IsOpaque && IsSolid)
    {
        DWORD convertFlags = IsPrinting |
                     ((DriverType == DriverPostscript) ? IsPostscript : 0);

        HBRUSH hBrush = GetBrush(pen->Brush, convertFlags);

        if (hBrush)
        {
            HDC         hdc = context->GetHdc(surface);
            BOOL        success = FALSE;

            if (hdc != NULL)
            {
                // Handle non compound pen case
                if ((pen->PenAlignment == PenAlignmentCenter) &&
                    (pen->CompoundCount == 0))
                {
                    ConvertPenToGdi gdiPen(hdc,
                                           pen,
                                           &context->WorldToDevice,
                                           context->GetDpiX(),
                                           convertFlags,
                                           const_cast<LOGBRUSH*>(CachedBrush.GetGdiBrushInfo()));

                    if (gdiPen.IsValid())
                    {
                        ConvertPathToGdi gdiPath(path,
                                                 &context->WorldToDevice,
                                                 convertFlags,
                                                 drawBounds);

                        if (gdiPath.IsValid())
                        {
                            BOOL        isClip, success = FALSE;
                            BOOL        usePathClipping = FALSE;

                            SetupClipping(hdc,
                                          context,
                                          drawBounds,
                                          isClip,
                                          usePathClipping,
                                          FALSE);

                            success = gdiPath.Draw(hdc, gdiPen.GetGdiPen());

                            RestoreClipping(hdc,
                                            isClip,
                                            usePathClipping);
                        }
                    }
                }

                context->ReleaseHdc(hdc);

                if (success)
                {
                    status = Ok;
                    goto Exit;
                }
            }
        }
    }

    // get the widened path, then fill path with pen's interal brush
    //
    // also the bitmap can be quite hugh for a simple path

    {
        GpRect newBounds;
        GpMatrix identity;
        GpMatrix savedMatrix = context->WorldToDevice;

        DpBrush *brush = const_cast<DpBrush*>(pen->Brush);
        GpMatrix savedBrushTransform = brush->Xform;

        // Widening the path transforms the points
        DpPath* newPath = path->CreateWidenedPath(
            pen,
            context,
            DriverType == DriverPostscript,
            pen->PenAlignment != PenAlignmentInset
        );

        if (!newPath || !newPath->IsValid())
        {
             status = OutOfMemory;
             goto Exit1;
        }

        // The path is in device space, which is convenient because the World
        // to device is an identity transform.  However, because W2D is I, the
        // brush transform is composed improperly and so device to texture
        // map results in wrong size textures.
        GpMatrix::MultiplyMatrix(brush->Xform,
                                 savedBrushTransform,
                                 savedMatrix);


        {
            HDC hdc = NULL;

            if(pen->PenAlignment == PenAlignmentInset)
            {
                hdc = context->GetHdc(surface);
                if(hdc != NULL)
                {
                    SetupPathClipping(hdc, context, path);
                }
            }

            // The widened path is already transformed to the device coordinates.
            // Hence, use the identity matrix for the context. 05/23/00 -- ikkof
            // Set up the state for the FillPath after setting up the path
            // clipping for the inset pen if necessary.

            newPath->GetBounds(&newBounds);
            context->InverseOk = FALSE;
            context->WorldToDevice = identity;

            status = FillPath(context, surface, &newBounds, newPath, brush);

            context->InverseOk = FALSE;
            context->WorldToDevice = savedMatrix;

            if(pen->PenAlignment == PenAlignmentInset)
            {
                if(hdc != NULL)
                {
                    RestorePathClipping(hdc);
                    context->ReleaseHdc(hdc);
                }
            }
        }


        brush->Xform = savedBrushTransform;

        newPath->DeletePath();

Exit1:
        ;
    }

Exit:
    RestoreBrush(const_cast<DpBrush*>(pen->Brush), context, surface);

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Draw the image at the specified location
*
* Arguments:
*
*   [IN]  context    - The drawing context
*   [IN]  surface    - The surface to draw to
*   [IN]  drawBounds - The bounds of the object being drawn
*   [IN]  srcSurface - The image to draw
*   [IN]  mapMode    - The map mode
*   [IN]  numPoints  - The number of points in dstPoints
*   [IN]  dstPoints  - Where to draw the image
*   [IN]  srcRect    - The portion of the image to draw
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   10/28/1999 ericvan
*
\**************************************************************************/

GpStatus
DriverPrint::DrawImage(
    DpContext *          context,
    DpBitmap *           srcSurface,
    DpBitmap *           dstSurface,
    const GpRect *       drawBounds,
    DpImageAttributes    imageAttributes,
    INT                  numPoints,
    const GpPointF *     dstPoints,
    const GpRectF *      srcRect,
    DriverDrawImageFlags flags
    )
{
    GpStatus status = GenericError;
    ASSERT(numPoints == 3);

    if (context->CompositingMode == CompositingModeSourceCopy)
    {
        IsOpaque = TRUE;
        Is01Bitmap = FALSE;
    }
    else if (srcSurface->SurfaceTransparency == TransparencySimple)
    {
        Is01Bitmap = TRUE;
        IsNearConstant = FALSE;
        IsOpaque = FALSE;
    }
    else if ((srcSurface->SurfaceTransparency == TransparencyUnknown) ||
             (srcSurface->SurfaceTransparency == TransparencyComplex))
    {
        // PCL driver doesn't treat 0-1 bitmaps any different.
        if (DriverType == DriverPostscript)
        {
            IsOpaque = FALSE;
            IsNearConstant = FALSE;
            Is01Bitmap = TRUE;
        }
        else
        {
            IsOpaque = FALSE;
            IsNearConstant = FALSE;
            Is01Bitmap = FALSE;
        }
    }
    else if (srcSurface->SurfaceTransparency == TransparencyNearConstant)
    {
        if (DriverType == DriverPostscript)
        {
            IsOpaque = FALSE;
            IsNearConstant = FALSE;
            Is01Bitmap = TRUE;
        }
#if 0
        // Disable IsNearConstant right now
        if (DriverType == DriverPostscript)
        {
            IsNearConstant = TRUE;
            IsOpaque = FALSE;
            Is01Bitmap = FALSE;
            MinAlpha = srcSurface->MinAlpha;
            MaxAlpha = srcSurface->MaxAlpha;
            ASSERT(MinAlpha <= MaxAlpha);
        }
#endif
        else
        {
            IsOpaque = FALSE;
            IsNearConstant = FALSE;
            Is01Bitmap = FALSE;
        }
    }
    else
    {
        // TransparencyOpaque || TransparencyNoAlpha
        IsOpaque = TRUE;
        IsNearConstant = FALSE;
        Is01Bitmap = FALSE;
    }
    IsSolid = FALSE;

    BOOL tryPassthrough = (srcSurface->CompressedData != NULL) &&
                          (srcSurface->CompressedData->buffer != NULL);
    if (IsOpaque || tryPassthrough)
    {
        // Scale/translated stretched opaque image, use GDI.

        if (context->WorldToDevice.IsTranslateScale() &&
            (numPoints == 3) &&
            (REALABS(dstPoints[0].X - dstPoints[2].X) < REAL_EPSILON) &&
            (REALABS(dstPoints[0].Y - dstPoints[1].Y) < REAL_EPSILON) &&
            (dstPoints[1].X > dstPoints[0].X) &&
            (dstPoints[2].Y > dstPoints[0].Y))
        {
            CachedBackground back;

            HDC hdc = context->GetHdc(dstSurface);

            // Ack, this is just before the Office M1 release, and we want
            // blts when printing to have half-decent performance.  So we
            // convert to a straight GDI StretchBlt.  But we only want to
            // do this for printers (so that we get bilinear stretches to
            // the screen), but DriverPrint is also used for the screen.  So
            // we hack a check here on the DC.

            BOOL    success = FALSE;
            POINT   gdiPoints[3];
            context->WorldToDevice.Transform(dstPoints, gdiPoints, 3);

            // Make sure there is no flipping
            if ((gdiPoints[1].x > gdiPoints[0].x) &&
                (gdiPoints[2].y > gdiPoints[0].y))
            {
                DWORD       convertFlags = IsPrinting |
                             ((DriverType == DriverPostscript) ? IsPostscript : 0) |
                             ((!IsOpaque && tryPassthrough) ? IsPassthroughOnly : 0);

                GpRect rect(GpRound(srcRect->X),
                            GpRound(srcRect->Y),
                            GpRound(srcRect->Width),
                            GpRound(srcRect->Height));

                ConvertBitmapToGdi  gdiBitmap(hdc,
                                              srcSurface,
                                              &rect,
                                              convertFlags);

                if (gdiBitmap.IsValid())
                {
                    BOOL        isClip;
                    BOOL        usePathClipping = FALSE;

                    DriverPrint::SetupClipping(hdc, context, drawBounds,
                                               isClip, usePathClipping, FALSE);

                    success = gdiBitmap.StretchBlt(hdc, gdiPoints);

                    DriverPrint::RestoreClipping(hdc, isClip, usePathClipping);
                }
            }

            if (success)
            {
                context->ReleaseHdc(hdc);

                return Ok;
            }

            context->ReleaseHdc(hdc);
        }
    }

    // We only process remaining code path if pixel format is >= 32bpp.
    if (GetPixelFormatSize(srcSurface->PixelFormat) != 32)
    {
        return GenericError;
    }

    // Setup ScanDIB class correctly by specifying proper flags
    BOOL SetVisibleClip;
    DWORD options = 0;

    switch (DriverType)
    {
    case DriverPCL:
        if (Is01Bitmap)
        {
            // rasterize @ 32bpp
            // Due to filtering, we want to blend with WHITENESS, only very
            // transparent portions are cut.
            options = ScanCappedBounds | ScanCapped32bppOver;
        }
        else if (IsOpaque)
        {
            // rasterize @ 24bpp
            options = ScanCappedBounds;
        }
        else
        {
            options = ScanCappedBounds | ScanDeviceBounds | ScanDeviceAlpha;
        }

        SetVisibleClip = IsOpaque || Is01Bitmap;
        break;

    case DriverPostscript:
        if (Is01Bitmap)
        {
            // rasterize @ 32bpp (this 0-1 bitmaps or complex alpha)
            options = ScanCappedBounds | ScanCapped32bppOver;
        }
        else if (IsOpaque || IsNearConstant)
        {
            // rasterize @ 24bpp
            options = ScanCappedBounds;
        }
        else
        {
            ASSERT(FALSE);
        }
        SetVisibleClip = TRUE;
        break;

    default:
        ASSERT(FALSE);

        return NotImplemented;
    }

    EpScanDIB *scanPrint = (EpScanDIB*) dstSurface->Scan;
    REAL w2dDev[6];
    REAL w2dCap[6];

    // If there is alpha blending or 0-1 bitmap,
    // it REALLY REALLY helps that the capped DPI divides the device DPI,
    // otherwise it's hard to find every other one to output!

    ASSERT(srcSurface->DpiX != 0 && srcSurface->DpiY != 0);
    ASSERT(dstSurface->DpiY != 0 && dstSurface->DpiY != 0);

    REAL srcDpiX = srcSurface->GetDpiX();
    REAL srcDpiY = srcSurface->GetDpiY();

    INT oldScaleX = ScaleX;
    INT oldScaleY = ScaleY;

    // !!! what if context->GetDpiX has a different value than the surface?
    ScaleX = GpFloor(dstSurface->GetDpiX()/srcDpiX);
    ScaleY = GpFloor(dstSurface->GetDpiY()/srcDpiY);

    // don't rasterize at a dpi higher than the device.
    if (ScaleX < 1) ScaleX = 1;
    if (ScaleY < 1) ScaleY = 1;

    // Some images have incorrect DPI information, to combat this, we check
    // for a lower threshold on the image DPI, DEF_RES/4 seems reasonable.  If
    // the DPI is lower then we assume it's not accurate and rasterize at
    // the default capped dpi for this device.  If the DPI is above DEF_RES/4
    // then the image should at least look reasonable.
    if (srcDpiX < TOREAL((DEFAULT_RESOLUTION/4)))
    {
        ScaleX = oldScaleX;
    }

    if (srcDpiY < TOREAL((DEFAULT_RESOLUTION/4)))
    {
        ScaleY = oldScaleY;
    }

    // To avoid rounding errors with the underlying DpDriver code, we
    // compute the destination bounds in capped device space.
    context->WorldToDevice.GetMatrix(&w2dDev[0]);
    context->WorldToDevice.Scale(1.0f/TOREAL(ScaleX),
                                 1.0f/TOREAL(ScaleY), MatrixOrderAppend);
    context->WorldToDevice.GetMatrix(&w2dCap[0]);
    context->InverseOk = FALSE;

    GpMatrix xForm;
    xForm.InferAffineMatrix(&dstPoints[0], *srcRect);
    xForm.Append(context->WorldToDevice);       // includes 1/ScaleX,Y

    GpPointF corners[4];

    corners[0].Y = max(srcRect->Y, 0);
    corners[1].Y = min(srcRect->Y + srcRect->Height,
                       srcSurface->Height);
    corners[0].X = max(srcRect->X, 0);
    corners[1].X = min(srcRect->X + srcRect->Width,
                       srcSurface->Width);
    corners[2].X = corners[0].X;
    corners[2].Y = corners[1].Y;
    corners[3].X = corne