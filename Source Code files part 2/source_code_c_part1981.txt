KerbConvertUnicodeStringToRealm(
                      &LocalRealm,
                      pKerbReq->GetRequestRealm()
                      );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto    Cleanup;
        }
//        Status = KdcRealmGetName(piKdb, &LocalRealm);

        //
        // Verify the realm of the ticket
        //

        if (!KerbCompareRealmNames(
                &LocalRealm,
                &Ticket->realm
            ))
        {
            D_DebugLog((DEB_ERROR,"KLIN(%x) Additional ticket realm is wrong: %s instead of %s\n",
                        KLIN(FILENO, __LINE__), Ticket->realm, LocalRealm));
            KerbErr = KDC_ERR_POLICY;
            goto Cleanup;
        }

        //
        // Verify the realm of the client is the same as our realm
        //

        if (!KerbCompareRealmNames(
                &LocalRealm,
                &EncryptedTicket->client_realm
            ))
        {
            D_DebugLog((DEB_ERROR,"KLIN(%x) Additional ticket client realm is wrong: %s instead of %s\n",
                        KLIN(FILENO, __LINE__),EncryptedTicket->client_realm, LocalRealm));
            KerbErr = KDC_ERR_POLICY;
            goto Cleanup;
        }

        *U2UTicket = EncryptedTicket;
        EncryptedTicket = NULL;

        //
        // Pickup the next additional ticket
        //

        TicketList = TicketList->next;
    }


    //
    // Handle Service4User additional ticket
    //

    if ((KdcOptions & KERB_KDC_OPTIONS_cname_in_addl_tkt) != 0)
    {

        //
        // Ticket is encrypted in the service key
        //


        //
        // Locate and extract the PAC in the ticket, then save (replace)
        // the current PAC in the context.
        //
    }


Cleanup:
    KerbFreeString(&ServerNames[0]);
    KerbFreeRealm(&LocalRealm);

    if (EncryptedTicket != NULL)
    {
        KerbFreeTicket(EncryptedTicket);
    }

    return(KerbErr);

}

//--------------------------------------------------------------------
//
//  Name:       KdcFindS4UClientAndRealm
//
//  Synopsis:   Decodes PA DATA to find PA_DATA_FOR_USER entry.
//
//  Effects:    Get a client name and realm for processing S4U request
//
//  Arguments:  PAList       - Preauth data list from TGS_REQ
//              ClientRealm  - Target for client realm
//              ClientName   - Principal to get S4U ticket for
//
//  Requires:
//
//  Returns:    KDC_ERR_ or KRB_AP_ERR errors only
//
//  Notes:  Free client name and realm w/
//
//
//--------------------------------------------------------------------------
KERBERR
KdcFindS4UClientAndRealm(
    IN      PKERB_PA_DATA_LIST PaList,
    IN OUT  PUNICODE_STRING ClientRealm,
    IN OUT  PKERB_INTERNAL_NAME * ClientName
    )
{

    KERBERR KerbErr = KRB_ERR_GENERIC;
    PKERB_PA_DATA PaData = NULL;
    PKERB_PA_FOR_USER S4URequest = NULL;
    TRACER(L"KdcFindS4UClientAndRealm", (PVOID *) &KerbErr);

    *ClientName = NULL;
    RtlInitUnicodeString(
        ClientRealm,
        NULL
        );


    PaData = KerbFindPreAuthDataEntry(
                KRB5_PADATA_S4U,
                PaList
                );

    if (NULL == PaData)
    {
        KerbErr = KDC_ERR_BADOPTION;
        goto Cleanup;
    }

    KerbErr = KerbUnpackData(
                    PaData->preauth_data.value,
                    PaData->preauth_data.length,
                    KERB_PA_FOR_USER_PDU,
                    (PVOID* ) &S4URequest
                    );


    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR, "Failed to unpack PA_FOR_USER\n"));
        goto Cleanup;
    }


    KerbErr = KerbConvertRealmToUnicodeString(
                    ClientRealm,
                    &S4URequest->userRealm
                    );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }


    KerbErr = KerbConvertPrincipalNameToKdcName(
                    ClientName,
                    &S4URequest->userName
                    );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }


Cleanup:


    if (S4URequest != NULL)
    {
        KerbFreeData(
            KERB_PA_FOR_USER_PDU,
            S4URequest
            );

    }

    return KerbErr;

}


//--------------------------------------------------------------------
//
//  Name:       HandleTGSRequest
//
//  Synopsis:   Gets a ticket using a KDC ticket (TGT).
//
//  Effects:    Allocates and encrypts a KDC reply
//
//  Arguments:  IN ClientAddress - Optionally contains client IP address
//              IN RequestMessage - contains the TGS request message
//              IN RequestRealm - The realm of the request, from the request
//                      message
//              OUT OutputMessage - Contains the buffer to send back to the client
//  Requires:
//
//  Returns:    KDC_ERR_ or KRB_AP_ERR errors only
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
HandleTGSRequest(
    IN OPTIONAL SOCKADDR * ClientAddress,
    IN PKERB_TGS_REQUEST RequestMessage,
    IN PUNICODE_STRING RequestRealm,
    OUT PKERB_MESSAGE_BUFFER OutputMessage,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status;

    IKdbProvider *piKdb = NULL;                // RequestRealm

    PIKerbPrincipal ServerInfo = NULL;          // i.e. server
    PIKerbPrincipal TgtClientInfo = NULL;       // i.e. user
    PIKerbPrincipal TgtServerInfo = NULL;       // i.e. krbtgt

    KERB_TICKET SourceTicket = {0};
    KERB_TICKET NewTicket = {0};
    KERB_ENCRYPTED_TICKET EncryptedTicket = {0};
    PKERB_ENCRYPTED_TICKET SourceEncryptPart = NULL;
    PKERB_ENCRYPTED_TICKET User2UserTicket = NULL;

    PKERB_KDC_REQUEST_BODY RequestBody = &RequestMessage->request_body;
    KERB_TGS_REPLY Reply = {0};
    KERB_ENCRYPTED_KDC_REPLY ReplyBody = {0};
    PKERB_AP_REQUEST UnmarshalledApRequest = NULL;
    PKERB_PA_DATA ApRequest = NULL;
    PKERB_PA_DATA_LIST ReplyPaData = NULL;
    PKERB_PA_DATA_LIST OutputPreAuthData = NULL;
    KERB_ENCRYPTION_KEY ReplyKey = {0};
    KERB_ENCRYPTION_KEY EncryptionKey = {0};
    PIKerbPrincipal Tgt = NULL;
    KERB_KEY_DATA SessionKey = {0};
    PKERB_KEY_DATA ServerKey;
    PKERB_INTERNAL_NAME ServerName = NULL;
    PKERB_INTERNAL_NAME ClientName = NULL;
    UNICODE_STRING ClientRealm = {0};
    UNICODE_STRING ClientStringName = {0};
    UNICODE_STRING ServerStringName = {0};

    ULONG CommonEType;
    ULONG KdcOptions = 0;
    ULONG TicketFlags = 0;
    ULONG ReplyTicketFlags = 0;
    ULONG PreAuthType = 0;

    BOOLEAN Validating = FALSE;
    BOOLEAN UseSubKey = FALSE;
    BOOLEAN Renew = FALSE;
    BOOLEAN CheckAdditionalTicketMatch = FALSE;

    CKerbRequest KdcReq;
    KdcReq.m_pKdcRequest = RequestMessage;
    KdcReq.m_pClientAddress = ClientAddress;

#ifdef KDC_WMI_TRACING
    KDC_TGS_EVENT_INFO TGSEventTraceInfo = {0};
#endif

    TRACE(KDC, HandleTGSRequest, DEB_FUNCTION);
    TRACER(L"HandleTGSRequest", (PVOID *) &KerbErr);
    //
    // Initialize [out] structures, so if we terminate early, they can
    // be correctly marshalled by the stub
    //

    NewTicket.encrypted_part.cipher_text.value = (PUCHAR) &EncryptedTicket;

    EncryptedTicket.flags.value = (PUCHAR) &TicketFlags;
    EncryptedTicket.flags.length = sizeof(ULONG) * 8;
    ReplyBody.flags.value = (PUCHAR) &ReplyTicketFlags;
    ReplyBody.flags.length = sizeof(ULONG) * 8;

    KdcOptions = KerbConvertFlagsToUlong( &RequestBody->kdc_options );

    //
    // Initialize the Request context
    //
    Status = KdcReq.CreateHandlerInstances();
    if (!NT_SUCCESS(Status))
    {
        //  todo: BUGBUG log/trace?
        KerbErr =   KRB_ERR_GENERIC;
        goto Cleanup;
    }
    KdcReq.m_ServId = KerbTgs;
    KdcReq.m_pETypes= (PKERB_CRYPT_LIST)(RequestBody->encryption_type);

    //
    // Start event tracing
    //
#ifdef KDC_WMI_TRACING
    if (KdcEventTraceFlag){

        TGSEventTraceInfo.EventTrace.Guid = KdcHandleTGSRequestGuid;
        TGSEventTraceInfo.EventTrace.Class.Type = EVENT_TRACE_TYPE_START;
        TGSEventTraceInfo.EventTrace.Flags = WNODE_FLAG_TRACED_GUID;
        TGSEventTraceInfo.EventTrace.Size = sizeof (EVENT_TRACE_HEADER) + sizeof (ULONG);
        TGSEventTraceInfo.KdcOptions = KdcOptions;

        TraceEvent(
            KdcTraceLoggerHandle,
            (PEVENT_TRACE_HEADER)&TGSEventTraceInfo
            );
    }
#endif

    //
    // Get IKdbProvider interface for RequestRealm
    //
    KerbErr = KdbRealmLocate(RequestRealm, &piKdb);
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"KLIN(%x) Failed to locate database for realm %wZ",
                  KLIN(FILENO,__LINE__), RequestRealm));
        goto Cleanup;
    }
    KdbPerfCount(piKdb, KerbKdcTgsReqCounter);

    //
    // The TGS and authenticator are in an AP request in the pre-auth data.
    // Find it and decode the AP request now.
    //

    if ((RequestMessage->bit_mask & KERB_KDC_REQUEST_preauth_data_present) == 0)
    {
        D_DebugLog((DEB_ERROR,
                  "KLIN(%x) No pre-auth data in TGS request - not allowed.\n",
                  KLIN(FILENO, __LINE__)));
        KerbErr = KDC_ERR_PADATA_TYPE_NOSUPP;
        goto Cleanup;
    }

    //
    // Get the TGT from the PA data.
    //

    ApRequest = KerbFindPreAuthDataEntry(
                    KRB5_PADATA_TGS_REQ,
                    RequestMessage->KERB_KDC_REQUEST_preauth_data
                    );
    if (ApRequest == NULL)
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x) No pre-auth data in TGS request - not allowed.\n",
                  KLIN(FILENO, __LINE__)));
        FILL_EXT_ERROR(pExtendedError, STATUS_NO_PA_DATA, FILENO, __LINE__);
        KerbErr = KDC_ERR_PADATA_TYPE_NOSUPP;
        goto Cleanup;
    }

    //
    // Verify the request. This includes decoding the AP request,
    // finding the appropriate key to decrypt the ticket, and checking
    // the ticket.
    //

    KerbErr = KdcVerifyKdcRequest(
                piKdb,
                &KdcReq,
                ApRequest->preauth_data.value,
                ApRequest->preauth_data.length,
                ClientAddress,
                TRUE,                           // this is a kdc request
                &UnmarshalledApRequest,
                &KdcReq.m_pUnmarshalledAuthenticator,
                &SourceEncryptPart,
                &ReplyKey,
                &TgtServerInfo,                 // Info about service in AP-REQ
                &UseSubKey,
                pExtendedError
                );

    //
    // If you want to validate a ticket, then it's OK if it isn't
    // currently valid.
    //

    if (KerbErr == KRB_AP_ERR_TKT_NYV && (KdcOptions & KERB_KDC_OPTIONS_validate))
    {
        D_DebugLog((DEB_TRACE,"Validating a not-yet-valid ticket\n"));
        KerbErr = KDC_ERR_NONE;
    }
    else if (KerbErr == KRB_AP_ERR_MODIFIED)
    {
        //
        // Bug 276943: When the authenticator is encrypted with something other
        //             than the session key, KRB_AP_ERR_BAD_INTEGRITY must be
        //             returned per RFC 1510
        //
        D_DebugLog((DEB_TRACE,"Could not decrypt the ticket\n"));
        KerbErr = KRB_AP_ERR_BAD_INTEGRITY;
    }

    //
    // Verify the checksum on the ticket, if present
    //

    if ( KERB_SUCCESS(KerbErr) &&
        (KdcReq.m_pUnmarshalledAuthenticator != NULL) &&
        (KdcReq.m_pUnmarshalledAuthenticator->bit_mask & checksum_present) != 0)
    {
        KerbErr = KdcVerifyTgsChecksum(
                    &RequestMessage->request_body,
                    &ReplyKey,
                    &KdcReq.m_pUnmarshalledAuthenticator->checksum
                    );

    }

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"KLIN(%x) Failed to verify TGS request: 0x%x\n",
                  KLIN(FILENO, __LINE__),KerbErr));
        FILL_EXT_ERROR(pExtendedError, STATUS_KDC_INVALID_REQUEST, FILENO, __LINE__);
        goto Cleanup;
    }
    //
    //  if everything went well save what we got in the req.
    //

    // LSG bug 6999. Found crash during fuzzing. TgtServerInfo is NULL at this point when 
    // clearly it shoudn't be. Root cause unknown so far.
    assert(TgtServerInfo);
    if (!TgtServerInfo)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    //
    //  Don't release TgtServerInfo since it belongs to KdcReq now.
    //
    KdcReq.m_piClientPrincipal = TgtServerInfo;
    KdcReq.m_pSessionKey = &ReplyKey;
    KdcReq.m_pEncTicket = SourceEncryptPart;
    KdcReq.m_pustrRealm = const_cast<PUNICODE_STRING>
                (TgtServerInfo->GetRealm());
    CommonEType = KdcReq.m_ulCommonEType = ReplyKey.keytype;

    //
    // Now that we've validated the request,
    // Check to see if the cname in padata bit is set, and
    // we have the KDC option set.
    //
    KerbErr = KdcCheckPreAuthData(
                  piKdb,
                  KerbTgs,
                  TgtServerInfo,
                  RequestMessage->KERB_KDC_REQUEST_preauth_data,
                  RequestBody,
                  &PreAuthType,
                  &OutputPreAuthData,
                  &EncryptionKey,
                  NULL,
                  pExtendedError,
                  &KdcReq
                  );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = KerbConvertPrincipalNameToKdcName(
                  &ClientName,
                  &SourceEncryptPart->client_name
                  );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = KerbConvertKdcNameToString(
                  &ClientStringName,
                  ClientName,
                  NULL
                  );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // And the realm
    //

    KerbErr = KerbConvertRealmToUnicodeString(
                  &ClientRealm,
                  &SourceEncryptPart->client_realm
                  );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Build a ticket struture to pass to the worker functions
    //

    SourceTicket = UnmarshalledApRequest->ticket;
    SourceTicket.encrypted_part.cipher_text.value = (PUCHAR) SourceEncryptPart;

    //
    // Check any authorization data in the krbtgt ticket.
    //

    if (SourceEncryptPart->bit_mask & KERB_ENCRYPTED_TICKET_authorization_data_present)
    {
        PKERB_AUTHORIZATION_DATA AuthData = NULL;

        AuthData = SourceEncryptPart->KERB_ENCRYPTED_TICKET_authorization_data;

        KerbErr = KdcCheckAuthData(
                     TgtServerInfo,
                     &KdcReq,
                     AuthData,
                     pExtendedError);

        if (!KERB_SUCCESS(KerbErr))
        {
            //  do anything with the status
            goto Cleanup;
        }
    }


    //
    // Check for additional tickets (User2User and Service4User)
    //

    if ((RequestBody->bit_mask & additional_tickets_present) != 0)
    {
        //
        // The ticket must be unpacked with the krbtgt key
        //

        KerbErr = KdcUnpackAdditionalTickets(
                    piKdb,
                    KdcOptions,
                    RequestBody->additional_tickets,
                    &User2UserTicket,
                    &KdcReq,
                    pExtendedError
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            D_DebugLog((DEB_ERROR,"KLIN(%x) Failed to unpack additional tickets: 0x%x\n",
                      KLIN(FILENO, __LINE__),KerbErr));
            goto Cleanup;
        }
    }

    //
    // Make sure that if there is a ticket, then enc_tkt_in_skey is set and
    // if not, then it isn't set
    //

    if ((((KdcOptions & KERB_KDC_OPTIONS_enc_tkt_in_skey) != 0) ^
        (User2UserTicket != NULL)))
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x) Client didn't match enc_tkt_in_skey with additional tickts : %d vs %d\n",
                  KLIN(FILENO, __LINE__),((KdcOptions & KERB_KDC_OPTIONS_enc_tkt_in_skey) != 0),
                  (User2UserTicket != NULL)));
        KerbErr = KDC_ERR_BADOPTION;
        goto Cleanup;
    }


    //
    // The server name is optional only for the enc_tkt_in_skey case.
    // When not present the cname of the user2user ticket is the server name.
    // Otherwise it is required.
    //

    if ((RequestBody->bit_mask & KERB_KDC_REQUEST_BODY_server_name_present) != 0)
    {
        KerbErr = KerbConvertPrincipalNameToKdcName(
                    &ServerName,
                    &RequestBody->KERB_KDC_REQUEST_BODY_server_name
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

#ifdef KDC_BUG
        //
        // According to the RFC, this can't happen. For u2u, the sname is not
        // present and should not be used.
        //

        //
        // Verify that the server name is the same as the client name
        // from the additional ticket by getting the ticket info for supplied
        // TGT for the server. Later on we will compare it against the real
        // ticket info.
        //

        if (User2UserTicket != NULL)
        {
            PKERB_INTERNAL_NAME TgtClientName = NULL;
            UNICODE_STRING TgtRealmName = {0};

            KerbErr = KerbConvertPrincipalNameToKdcName(
                        &TgtClientName,
                        &User2UserTicket->client_name
                        );

            if (KERB_SUCCESS(KerbErr))
            {

                KerbErr = KerbConvertRealmToUnicodeString(
                            &TgtRealmName,
                            &User2UserTicket->client_realm
                            );
                if (KERB_SUCCESS(KerbErr))
                {

                    // TBD:  make sure GetPrincipal takes into account
                    // deleg restrictions, but not here, for god' sake.

                    KerbErr = KdbGetPrincipal(
                                 KdbHandle,
                                 TgtClientName,
                                 &TgtRealmName,
                                 KDC_KDB_GET_PRINC_CLIENT,
                                 KerbTgs,
                                 &TgtClientInfo,
                                 pExtendedError
                                 );

                    if (!KERB_SUCCESS(KerbErr))
                    {
                        DebugLog((DEB_ERROR,"KLIN(%x) Failed to find client name from supplied ticket\n",
                                  KLIN(FILENO, __LINE__)));
                        KerbPrintKdcName(DEB_WARN, TgtClientName);
                        DebugLog((DEB_WARN,"\t 0x%x\n",KerbErr));
                        FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
                        goto Cleanup;
                    }

                    KerbFreeString(&TgtRealmName);
                }

                CheckAdditionalTicketMatch = FALSE;

                KerbFreeKdcName(&TgtClientName);
            }
        }
#endif
    }
    else
    {

        //
        // There must be an additional ticket if no server name is present
        //

        if (User2UserTicket == NULL)
        {
            KerbErr = KDC_ERR_S_PRINCIPAL_UNKNOWN;
            goto Cleanup;
        }
        KerbErr = KerbConvertPrincipalNameToKdcName(
                    &ServerName,
                    &User2UserTicket->client_name
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }


    //
    // Convert the server name to a string for auditing.
    //

    KerbErr = KerbConvertKdcNameToString(
                &ServerStringName,
                ServerName,
                NULL
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    D_DebugLog((DEB_TRACE, "GetTGSTicket called. Service=" ));
    D_KerbPrintKdcName(DEB_TRACE, ServerName );

    //
    // Build the new ticket
    //
#if DBG
    {
        D_DebugLog((DEB_TRACE, "Handle TGS request: Client = %wZ,\n ",&ClientRealm));
        D_KerbPrintKdcName(DEB_TRACE, ClientName);
        D_DebugLog((DEB_TRACE, "\t ServerName = \n"));
        D_KerbPrintKdcName(DEB_TRACE, ServerName);
    }
#endif

    //
    // Pass off the work to the worker routines
    //

    if (KdcOptions & KERB_KDC_OPTIONS_renew)
    {
        D_DebugLog((DEB_T_KDC,"Renewing ticket ticket\n"));

        Renew = TRUE;
        KerbErr = I_RenewTicket(
                    piKdb,
                    &SourceTicket,
                    ServerName,
                    TgtServerInfo,
                    RequestBody,
                    &KdcReq,
                    &CommonEType,
                    &NewTicket,
                    pExtendedError
                    );
    }
    else if (KdcOptions & KERB_KDC_OPTIONS_validate)
    {
        D_DebugLog((DEB_T_KDC,"Validating ticket\n"));

        KerbErr = I_Validate(
                    piKdb,
                    &SourceTicket,
                    ServerName,
                    &ClientRealm,
                    RequestBody,
                    &KdcReq,
                    &CommonEType,
                    &NewTicket,
                    pExtendedError
                    );

        Validating = TRUE;

    }
    else
    {
        D_DebugLog((DEB_T_KDC,"Getting TGS ticket\n"));


        KerbErr = I_GetTGSTicket(
                    piKdb,
                    &SourceTicket,
                    ClientName,
                    ServerName,
                    RequestRealm,
                    RequestBody,
                    TgtServerInfo,
                    User2UserTicket != NULL ? &User2UserTicket->key : NULL,
                    &ServerInfo,
                    &KdcReq,
                    &CommonEType,
                    &NewTicket,
                    &ReplyPaData,
                    pExtendedError
                    );
    }

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_WARN,"KLIN(%x) TGS ticket worker failed: 0x%x\n",
                  KLIN(FILENO, __LINE__),KerbErr));
        goto Cleanup;
    }
    //  set the common etype again
    KdcReq.m_ulCommonEType = CommonEType;

    //  no server info keys
//    DsysAssert(ServerInfo->Keys != NULL);


    //
    // Check to see if the additional ticket supplied is the one for this
    // server, if necessary
    //

    if (CheckAdditionalTicketMatch)
    {
        //  this is kerb_internal_name comparison ... maybe the
        //  names should be made simpler
        if (!KerbEqualKdcNames(
                    ServerInfo->GetName(),
                    TgtClientInfo->GetName()))
        {
            D_DebugLog((DEB_ERROR,"KLIN(%x) Supplied ticket is not for server: server vs. tgt\n",
                        KLIN(FILENO, __LINE__)));
            D_KerbPrintKdcName(DEB_ERROR,
                ServerInfo->GetName());
            D_KerbPrintKdcName(DEB_ERROR,
                TgtClientInfo->GetName());
            KerbErr = KRB_AP_ERR_BADMATCH;
            goto Cleanup;
        }
    }

    //
    // Determine the keys to encrypt the ticket with.  (The key to encrypt the
    // reply with was determined by CheckTicket.)

    if ((KdcOptions & KERB_KDC_OPTIONS_enc_tkt_in_skey) &&
        (User2UserTicket != NULL))
    {

        //
        // Use the session key from the tgt
        //

        SessionKey.Key = User2UserTicket->key;
        SessionKey.KeyVersion = KERB_NO_KEY_VERSION;
        SessionKey.SaltType = KerbKdbSaltTypeDefault;
        ServerKey = &SessionKey;

    }

    KerbErr = BuildReply(
                NULL,
                RequestBody->nonce,
                &NewTicket.server_name,
                NewTicket.realm,
                ((EncryptedTicket.bit_mask & KERB_ENCRYPTED_TICKET_client_addresses_present) != 0) ?
                    EncryptedTicket.KERB_ENCRYPTED_TICKET_client_addresses : NULL,
                &NewTicket,
                &ReplyBody
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Get any PA-DATA to return
    //

    KerbErr = KdcReturnPreAuthData(
                 &KdcReq,
                 &OutputPreAuthData
                 );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Put in any encrypted PA data for the reply (non-standard - deprecate)
    //

    if (ReplyPaData != NULL)
    {
        ReplyBody.encrypted_pa_data = (struct KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data_s *) ReplyPaData;
        ReplyBody.bit_mask |= encrypted_pa_data_present;
    }

    //
    // Now build the real reply and return it.
    //

    Reply.version = KERBEROS_VERSION;
    Reply.message_type = KRB_TGS_REP;
    Reply.KERB_KDC_REPLY_preauth_data = NULL;
    Reply.bit_mask = 0;


    //
    // Put the client name into the reply
    //

    Reply.client_realm = SourceEncryptPart->client_realm;
    Reply.client_name = SourceEncryptPart->client_name;


    //
    // Put in any PA data for the reply
    //
    if (OutputPreAuthData != NULL)
    {
        Reply.KERB_KDC_REPLY_preauth_data = (PKERB_REPLY_PA_DATA_LIST) OutputPreAuthData;
        Reply.bit_mask |= KERB_KDC_REPLY_preauth_data_present;

        //
        // Zero this out so we don't free the preauth data twice
        //

        OutputPreAuthData = NULL;
    }


    //
    // Copy in the ticket
    //

    KerbErr = KerbPackTicket(
                &KdcReq,
                &NewTicket,
                ServerInfo,
                //  where do we get the common etype from?
                RequestBody->encryption_type,
                &Reply.ticket,
                pExtendedError
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x) Failed to pack ticket: 0x%x\n",
                  KLIN(FILENO, __LINE__),KerbErr));
        goto Cleanup;
    }

    //
    // Copy in the encrypted part of the reply
    //

    KerbErr = KerbPackKdcReplyBody(
                &KdcReq,
                &ReplyBody,
                &ReplyKey,
                NULL,           // no principal
                // KERB_NO_KEY_VERSION, // no version
                NULL,           // no keytypes - replykey has all
                KERB_ENCRYPTED_TGS_REPLY_PDU,
                &Reply.encrypted_part,
                pExtendedError
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x)Failed to pack KDC reply body: 0x%x\n",
                KLIN(FILENO, __LINE__),KerbErr));
        goto Cleanup;
    }

    //
    // Now build the real reply message
    //

    KerbErr = KerbPackData(
                &Reply,
                KERB_TGS_REPLY_PDU,
                &OutputMessage->BufferSize,
                &OutputMessage->Buffer
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }


    //
    // Audit the successful ticket generation
    //
   Status = KdbAuditEvent(
                            piKdb,
                            (Renew) ? TicketRenewSuccess : TgsTicketRequest,
                            (PIKerbRequest)&KdcReq,
                            NULL,
                            &KdcOptions,
                            RequestBody->encryption_type,
                            NULL,
                            ClientAddress
                            );

    if (!NT_SUCCESS(Status))
        {
            KerbErr = KDC_ERR_SERVICE_REVOKED;
            goto Cleanup;
        }


Cleanup:

    //
    // Complete the event
    //
#ifdef KDC_WMI_TRACING
    if (KdcEventTraceFlag){

        //These variables point to either a unicode string struct containing
        //the corresponding string or a pointer to KdcNullString

        PUNICODE_STRING pStringToCopy;
        WCHAR   UnicodeNullChar = 0;
        UNICODE_STRING UnicodeEmptyString = {sizeof(WCHAR),sizeof(WCHAR),&UnicodeNullChar};

        TGSEventTraceInfo.EventTrace.Class.Type = EVENT_TRACE_TYPE_END;
        TGSEventTraceInfo.EventTrace.Flags = WNODE_FLAG_USE_MOF_PTR |
                                             WNODE_FLAG_TRACED_GUID;

        // Always output error code.  KdcOptions was captured on the start event

        TGSEventTraceInfo.eventInfo[0].DataPtr = (ULONGLONG) &KerbErr;
        TGSEventTraceInfo.eventInfo[0].Length  = sizeof(ULONG);
        TGSEventTraceInfo.EventTrace.Size =
            sizeof (EVENT_TRACE_HEADER) + sizeof(MOF_FIELD);

        // Build counted MOF strings from the unicode strings.
        // If data is unavailable then output a NULL string

        if (ClientStringName.Buffer != NULL &&
            ClientStringName.Length > 0)
        {
            pStringToCopy = &ClientStringName;
        }
        else {
            pStringToCopy = &UnicodeEmptyString;
        }

        TGSEventTraceInfo.eventInfo[1].DataPtr =
            (ULONGLONG) &pStringToCopy->Length;
        TGSEventTraceInfo.eventInfo[1].Length  =
            sizeof(pStringToCopy->Length);
        TGSEventTraceInfo.eventInfo[2].DataPtr =
            (ULONGLONG) pStringToCopy->Buffer;
        TGSEventTraceInfo.eventInfo[2].Length =
            pStringToCopy->Length;
        TGSEventTraceInfo.EventTrace.Size += sizeof(MOF_FIELD)*2;

        if (ServerStringName.Buffer != NULL &&
            ServerStringName.Length > 0)
        {
            pStringToCopy = &ServerStringName;

        }
        else
        {
            pStringToCopy = &UnicodeEmptyString;
        }

        TGSEventTraceInfo.eventInfo[3].DataPtr =
            (ULONGLONG) &pStringToCopy->Length;
        TGSEventTraceInfo.eventInfo[3].Length  =
            sizeof(pStringToCopy->Length);
        TGSEventTraceInfo.eventInfo[4].DataPtr =
            (ULONGLONG) pStringToCopy->Buffer;
        TGSEventTraceInfo.eventInfo[4].Length =
            pStringToCopy->Length;
        TGSEventTraceInfo.EventTrace.Size += sizeof(MOF_FIELD)*2;


        if (ClientRealm.Buffer != NULL &&
            ClientRealm.Length > 0)
        {
            pStringToCopy = &ClientRealm;
        }
        else
        {
            pStringToCopy = &UnicodeEmptyString;
        }

        TGSEventTraceInfo.eventInfo[5].DataPtr =
            (ULONGLONG) &pStringToCopy->Length;
        TGSEventTraceInfo.eventInfo[5].Length  =
            sizeof(pStringToCopy->Length);
        TGSEventTraceInfo.eventInfo[6].DataPtr =
            (ULONGLONG) pStringToCopy->Buffer;
        TGSEventTraceInfo.eventInfo[6].Length =
            pStringToCopy->Length;
        TGSEventTraceInfo.EventTrace.Size += sizeof(MOF_FIELD)*2;


        TraceEvent(
             KdcTraceLoggerHandle,
             (PEVENT_TRACE_HEADER)&TGSEventTraceInfo
             );
    }
#endif

    //
    // Audit *most* failures (see bug 37126)
    //

    if (piKdb &&
        !KERB_SUCCESS(KerbErr) &&
        KerbErr != KDC_ERR_S_PRINCIPAL_UNKNOWN)
    {
        Status = KdbAuditEvent(
                            piKdb,
                            TgsFailure,
                            (PIKerbRequest)&KdcReq,
                            &KerbErr,
                            &KdcOptions,
                            NULL,
                            NULL,
                            ClientAddress
                            );
    }

    KerbFreeKdcName(
        &ClientName
        );
    KerbFreeString(
        &ClientRealm
        );

    KerbFreeKdcName(
        &ServerName
        );
    KerbFreeKey(
        &ReplyKey
        );

    KdcFreeKdcReplyBody(
        &ReplyBody
        );
    KerbFreeString(
        &ClientStringName
        );
    KerbFreeString(
        &ServerStringName
        );

    //
    // If we are validating the ticket key is in the serverinfo
    //

    if (User2UserTicket != NULL)
    {
        KerbFreeTicket(User2UserTicket);
    }

    if (ReplyPaData != NULL)
    {
        KerbFreePreAuthData(ReplyPaData);
    }

    if (OutputPreAuthData != NULL)
    {
        KerbFreePreAuthData(OutputPreAuthData);
    }

    KerbFreeApRequest(UnmarshalledApRequest);
    KerbFreeTicket(SourceEncryptPart);

    KdcFreeInternalTicket(&NewTicket);

    //
    //  ownership could be transferred in I_GetTGSTicket( )
    //
#ifdef DBG
    assert(!ServerInfo || !KdcReq.m_piServerPrincipal || (ServerInfo == KdcReq.m_piServerPrincipal));
#endif
    if (ServerInfo && !KdcReq.m_piServerPrincipal)
        ServerInfo->Release();

    //
    //  only release if ownership has not been transferred
    //
#ifdef DBG
    assert(!TgtServerInfo || !KdcReq.m_piClientPrincipal || (TgtServerInfo == KdcReq.m_piClientPrincipal));
#endif
    if (TgtServerInfo && !KdcReq.m_piClientPrincipal)
        TgtServerInfo->Release();

    if (TgtClientInfo)
        TgtClientInfo->Release();

    KdcFreeKdcReply(
        &Reply
        );

    if (Tgt)
        Tgt->Release();

    if (!NT_SUCCESS(Status))
    {
        D_DebugLog(( DEB_ERROR, "HandleTGSRequest(): KdcFreeContext failed 0x%x\n",
                     Status ));
    }

    return(KerbErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\server\kdc.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        KDC.CXX
//
// Contents:    Base part of the KDC.  Global vars, main functions, init
//
//
// History:
//
//------------------------------------------------------------------------

#include "kdcsvr.hxx"
//  service interface
#include <kerbserv.hxx>

extern "C" {
#include <lmserver.h>
#include <dsgetdc.h>
#include <windns.h>
}
//#include <alloca.h>
#include "rpcif.h"
#include "fileno.h"
#define  FILENO FILENO_KDC

#ifndef SERVICE_KDC
#define SERVICE_KDC TEXT("KDC")
#endif

#include "kdctrace.hxx"
#include "kdceventinterface.hxx"
#include "kdccoreEvents.h"
#include "kerbinterface.h"
#include "kerbcrypt.hxx"

#include "kdcmem.hxx"
#include "kdccore.hxx"

//
// Global data
//

KDC_STATE KdcState = Stopped;                   // used to signal when
                                                // authenticated RPC is
                                                // ready to use - e.g.
                                                // spmgr has found the
                                                // kdc

NTSTATUS ShutdownStatus = STATUS_SUCCESS;

//  KdcService supplied functions
//  set status using this fn ptr
VOID (WINAPI *g_pfnSetStatus)(DWORD);
//  start/stop transport
FNKDC_START_TRANSPORT g_pfnStartTransport;
FNKDC_STOP_TRANSPORT  g_pfnStopTransport;

UNICODE_STRING KDCMachineName;                  // The computer name of this KDC

#if DBG
LARGE_INTEGER tsIn,tsOut;
#endif

//
// Registry config values
//

const BOOL KdcUseClientAddressesDefault = FALSE;
const BOOL KdcDontCheckAddressesDefault = TRUE;

BOOL KdcUseClientAddresses = KdcUseClientAddressesDefault;
BOOL KdcDontCheckAddresses = KdcDontCheckAddressesDefault;
LPTSTR_ARRAY KdcGlobalProviderDlls = NULL;
LPTSTR_ARRAY KdcParamProviders = NULL;


//
// This keeps a registry key handle to the
// HKLM\System\CCSet\Services\Kdc\Paramters key
//

HKEY hKdcParams = NULL;

//
// This keeps a registry key handle to the
// HKLM\System\CCSet\Services\Kdc\Paramters\Atq key
//

HKEY hAtqParams = NULL;

//
// This keeps any ATQ config params loaded
// from the registry.
//

ATQ_CONFIG_PARM AtqParms = {
    ATQ_CONFIG_PARM_DEFAULT,
    ATQ_CONFIG_PARM_DEFAULT,
    ATQ_CONFIG_PARM_DEFAULT,
    ATQ_CONFIG_PARM_DEFAULT
};

HANDLE hKdcWait = NULL;
HANDLE hKdcParamEvent = NULL ;


CRITICAL_SECTION ApiCriticalSection;
ULONG CurrentApiCallers;
HANDLE hKdcHandles[MAX_KDC_HANDLE] = {0};
HANDLE hKdcShutdownCompleteEvent = NULL;

//
//  TBD: move it elsewhere ?
//
CKerbCryptDll       g_cKerbCryptDll;
IKerbCrypt   *g_piKerbCrypt = &g_cKerbCryptDll;

//
//  KDCCore interface
//
IKdcCore g_KdcCore = {
    KdcAllocMemory,
    KdcFreeMemory,
    KdcRegisterProvider,
    KdcRegisterPAHandlerFactory,
    KdcRegisterADHandlerFactory,
    KdcRegisterPACHandler,
    KdcGetProvider,
    KdcGetICrypt,
    KdcCreateADHandlerInstance,
    KerbUnpackData,
    KerbPackData,
    KerbFreeData,
    KerbHashPasswordEx,
    KerbEqualKdcNames,
    KerbBuildKeySalt,
    KerbConvertStringToKdcName,
    KerbBuildFullServiceKdcName,
    KerbUnicodeStringToKerbString,
    KerbDuplicateKdcName,
    KerbConvertKdcNameToString,
    KerbConvertSidToString,
    KdcInitializeEventObject,
    KdcFreeEventObject,
    KerbConvertFlagsToUlong,
    KerbComputePaCompIdentityKeyForPrincipal,
}, *g_piKdcCore = &g_KdcCore;

IEvent  *coreEventObject;
//
// Prototypes
//

//+---------------------------------------------------------------------------
//
//  Function:   GetServiceStatus
//
//  Synopsis:   returns current service status
//
//  Effects:    none
//
//  Arguments:  none
//
//  History:    Oct-03-2001 yordanr Created
//
//  Notes:
//
//----------------------------------------------------------------------------
ULONG   WINAPI KdcGetServiceStatus()
{
    switch(KdcState)
    {
    case Running:
        return SERVICE_RUNNING;

    case Starting:
        return SERVICE_START_PENDING;

    case Stopped:
    default:
        return  SERVICE_STOPPED;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   UpdateStatus
//
//  Synopsis:   Hook to update the KDC's service status with the registered
//              service controller
//
//  Effects:
//
//  Arguments:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOLEAN
UpdateStatus(DWORD   dwState)
{
    if (g_pfnSetStatus)
    {
        (*g_pfnSetStatus)(dwState);
    }
    return(TRUE);
}

//+-------------------------------------------------------------------------
//
//  Name:       KerbGetKdcRegParams
//
//  Synopsis:   Gets the debug paramaters from the registry
//
//  Arguments:  HKEY to HKLM/System/CCS/Services/Kdc/Parameters
//
//  Notes:      Sets KDCInfolevel for debug spew
//
//--------------------------------------------------------------------------

void
KerbGetKdcRegParams(HKEY ParamKey)
{
    DWORD       cbType, Value, cbSize;
    DWORD       dwErr;
    LPTSTR_ARRAY String = NULL;


    //
    // Check if KDC is to propogate addresses to tickets (in as-req)
    //
    // HKLM/System/CCS/Services/Kdc/Parameters/KdcUseClientAddresses [DWORD] 0
    //

    cbSize = sizeof(Value);

    dwErr = RegQueryValueExW(
               ParamKey,
               L"KdcUseClientAddresses",
               NULL,
               &cbType,
               (LPBYTE)&Value,
               &cbSize
               );

    if (dwErr == ERROR_SUCCESS)
    {
        if ( Value != 0 )
        {
            KdcUseClientAddresses = TRUE;
        }
        else
        {
            KdcUseClientAddresses = FALSE;
        }
    }
    else if (dwErr == ERROR_FILE_NOT_FOUND)
    {
       KdcUseClientAddresses = KdcUseClientAddressesDefault;
    }


    //
    // Check if KDC is not to check addresses in tickets
    //
    // HKLM/System/CCS/Services/Kdc/Parameters/KdcDontCheckAddresses [DWORD] 0
    //

    cbSize = sizeof(Value);

    dwErr = RegQueryValueExW(
               ParamKey,
               L"KdcDontCheckAddresses",
               NULL,
               &cbType,
               (LPBYTE)&Value,
               &cbSize
               );

    if (dwErr == ERROR_SUCCESS)
    {
        if ( Value != 0 )
        {
            KdcDontCheckAddresses = TRUE;
        }
        else
        {
            KdcDontCheckAddresses = FALSE;
        }
    }
    else if (dwErr == ERROR_FILE_NOT_FOUND)
    {
       KdcDontCheckAddresses = KdcDontCheckAddressesDefault;
    }


    //
    // Check if ATQ configuration parameters are specified
    //
    // HKLM/System/CCS/Services/Kdc/Parameters/Atq/Threads [DWORD] 128
    // HKLM/System/CCS/Services/Kdc/Parameters/Atq/ConcurrentThreads [DWORD] 0
    // HKLM/System/CCS/Services/Kdc/Parameters/Atq/SecThreadTimeOut [DWORD] 43200
    // HKLM/System/CCS/Services/Kdc/Parameters/Atq/MinKBTimeOut [DWORD] 1
    //
    if ( NULL == hAtqParams )
    {
        dwErr = RegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   L"System\\CurrentControlSet\\Services\\Kdc\\Parameters\\Atq",
                   0,
                   KEY_READ,
                   &hAtqParams
                   );

        if ( dwErr == ERROR_SUCCESS )
        {
            DWORD dwThreads = 0;
            DWORD dwConcurrentThreads = 0;
            DWORD dwSecThreadTimeOut = 0;
            DWORD dwMinKBTimeOut = 0;

            cbSize = sizeof(dwThreads);
            dwErr = RegQueryValueExW(
                       hAtqParams,
                       L"Threads",
                       NULL,
                       &cbType,
                       (LPBYTE)&dwThreads,
                       &cbSize
                       );

            if (dwErr == ERROR_SUCCESS &&
                cbType == REG_DWORD &&
                cbSize == sizeof(DWORD))
            {
                AtqParms.dwThreads = dwThreads;
            }
            else
            {
                AtqParms.dwThreads = ATQ_CONFIG_PARM_DEFAULT;
            }

            cbSize = sizeof(dwConcurrentThreads);
            dwErr = RegQueryValueExW(
                       hAtqParams,
                       L"ConcurrentThreads",
                       NULL,
                       &cbType,
                       (LPBYTE)&dwConcurrentThreads,
                       &cbSize
                       );

            if (dwErr == ERROR_SUCCESS &&
                cbType == REG_DWORD &&
                cbSize == sizeof(DWORD))
            {
                AtqParms.dwConcurrentThreads = dwConcurrentThreads;
            }
            else
            {
                AtqParms.dwConcurrentThreads = ATQ_CONFIG_PARM_DEFAULT;
            }

            cbSize = sizeof(dwSecThreadTimeOut);
            dwErr = RegQueryValueExW(
                       hAtqParams,
                       L"SecThreadTimeOut",
                       NULL,
                       &cbType,
                       (LPBYTE)&dwSecThreadTimeOut,
                       &cbSize
                       );

            if (dwErr == ERROR_SUCCESS &&
                cbType == REG_DWORD &&
                cbSize == sizeof(DWORD))
            {
                AtqParms.dwsecThreadTimeOut = dwSecThreadTimeOut;
            }
            else
            {
                AtqParms.dwsecThreadTimeOut = ATQ_CONFIG_PARM_DEFAULT;
            }

            cbSize = sizeof(dwMinKBTimeOut);
            dwErr = RegQueryValueExW(
                       hAtqParams,
                       L"MinKBTimeOut",
                       NULL,
                       &cbType,
                       (LPBYTE)&dwMinKBTimeOut,
                       &cbSize
                       );

            if (dwErr == ERROR_SUCCESS &&
                cbType == REG_DWORD &&
                cbSize == sizeof(DWORD))
            {
                AtqParms.dwMinKBTimeOut = dwMinKBTimeOut;
            }
            else
            {
                AtqParms.dwMinKBTimeOut = ATQ_CONFIG_PARM_DEFAULT;
            }

        }
    }

    //  see if provider list was passed in ...
    if (KdcParamProviders != NULL)
    {
        KdcGlobalProviderDlls = KdcParamProviders;
    }
    else
    {
        //
        // Get list of Providers to load from registry
        //
        // HKLM/System/CCS/Services/Kdc/Parameters/Providers [REG_MULTI_SZ] kdckdb.dll
        //

        cbSize = 0;

        dwErr = RegQueryValueExW(
                   ParamKey,
                   L"Providers",
                   NULL,
                   &cbType,
                   NULL,
                   &cbSize
                   );

        if (dwErr == ERROR_SUCCESS)
        {
            if (cbType == REG_MULTI_SZ && cbSize > 0)
            {
                String = (LPTSTR_ARRAY)MIDL_user_allocate(cbSize);
                if (String == NULL)
                    return;
            }

            dwErr = RegQueryValueExW(
                       ParamKey,
                       L"Providers",
                       NULL,
                       &cbType,
                       (LPBYTE)String,
                       &cbSize
                       );

            if (dwErr == ERROR_SUCCESS &&
                cbType == REG_MULTI_SZ &&
                cbSize > 0)
            {
                if (KdcGlobalProviderDlls != NULL)
                {
                    MIDL_user_free(KdcGlobalProviderDlls);
                }
                KdcGlobalProviderDlls = String;

                // XXX - (Re)load Providers, but need to be careful about
                // requests in progress. For now just load once at startup

                //LoadKdcProviders();
            }
        }
    }

    return;
}


////////////////////////////////////////////////////////////////////
//
//  Name:       KerbWatchKdcParamKey
//
//  Synopsis:   Sets RegNotifyChangeKeyValue() on param key, initializes
//              debug level, then utilizes thread pool to wait on
//              changes to this registry key.  Enables dynamic debug
//              level changes, as this function will also be callback
//              if registry key modified.
//
//  Arguments:  pCtxt is actually a HANDLE to an event.  This event
//              will be triggered when key is modified.
//
//  Notes:      .
//
VOID
NTAPI
KerbWatchKdcParamKey(PVOID    pCtxt,
                  BOOLEAN  fWaitStatus)
{

    NTSTATUS    Status;
    LONG        lRes = ERROR_SUCCESS;

    if (NULL == hKdcParams)  // first time we've been called.
    {
        lRes = RegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   L"System\\CurrentControlSet\\Services\\Kdc\\Parameters",
                   0,
                   KEY_READ,
                   &hKdcParams
                   );

        if (ERROR_SUCCESS != lRes)
        {
            DebugLog((DEB_WARN,"Failed to open kerberos key: 0x%x\n", lRes));
            goto Reregister;
        }
    }

    if (NULL != hKdcWait)
    {
        Status = UnregisterWait(hKdcWait);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_WARN, "Failed to Deregister wait on registry key: 0x%x\n", Status));
            goto Reregister;
        }

    }

    lRes = RegNotifyChangeKeyValue(
                hKdcParams,
                FALSE,
                REG_NOTIFY_CHANGE_LAST_SET,
                (HANDLE) pCtxt,
                TRUE);

    if (ERROR_SUCCESS != lRes)
    {
        DebugLog((DEB_ERROR,"Debug RegNotify setup failed: 0x%x\n", lRes));
        // we're tanked now. No further notifications, so get this one
    }

    KerbGetKdcRegParams(hKdcParams);

Reregister:

    Status = RegisterWaitForSingleObject(&hKdcWait,
                             (HANDLE) pCtxt,
                             KerbWatchKdcParamKey,
                             (HANDLE) pCtxt,
                             INFINITE,
                             WT_EXECUTEONLYONCE);

}

////////////////////////////////////////////////////////////////////
//
//  Name:       WaitKdcCleanup
//
//  Synopsis:   Cleans up for KerbWatchKdcParamKey
//
//  Arguments:  <none>
//
//  Notes:      .
//
VOID
WaitKdcCleanup(HANDLE hEvent)
{
    NTSTATUS    Status = STATUS_SUCCESS;

    if (NULL != hKdcWait) {
        Status = UnregisterWait(hKdcWait);
        hKdcWait = NULL;
    }

    if (NT_SUCCESS(Status) && NULL != hEvent) {
        CloseHandle(hEvent);
        hEvent = NULL;
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   LoadKdcProviders
//
//  Synopsis:   Load all extension and KDB provider DLLs.
//
//  Effects:    Creates a list of all loaded providers.
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      If there are no providers listed under the "Providers" rgy
//              key, then just load kdckdb.dll.
//
//
//--------------------------------------------------------------------------

typedef struct _KDC_PROVIDER {
    BOOL                DllLoaded;
    LPTSTR              DllName;
    HINSTANCE           DllHandle;
    KDC_EXT_MAIN_FN     DllExtMain;
} KDC_PROVIDER, *PKDC_PROVIDER;

PKDC_PROVIDER KdcProviders = NULL;
INT NumberOfProviders = 0;

LPTSTR KdcKdbDll = L"kdckdb.dll\0\0";

NTSTATUS
LoadKdcProviders(
    VOID
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    LPTSTR CurrentEntry;
    INT i;
    TRACER(L"LoadKdcProviders", (PVOID *) &Status);

    for (CurrentEntry = (LPTSTR) KdcGlobalProviderDlls;
         CurrentEntry && *CurrentEntry != L'\0';
         CurrentEntry += ( wcslen( CurrentEntry ) + 1 ))
    {
        TRACE_FILELINE(TRACE_VERB, (FILE_AND_LINE, L"%s", CurrentEntry));
        D_DebugLog((DEB_TRACE, "%s\n", CurrentEntry));
        NumberOfProviders++;
    }
    TRACE_FILELINE(TRACE_VERB, ( FILE_AND_LINE,
                                    L"%d Providers to load", NumberOfProviders));
    D_DebugLog((DEB_TRACE, "%d Providers to load\n", NumberOfProviders));

    if (NumberOfProviders == 0)
    {
        //
        // Just load the default kdckdb.dll
        //
        TRACE_FILELINE(TRACE_VERB, ( FILE_AND_LINE, L"Loading default KDB provider."));
        D_DebugLog((DEB_TRACE, "Loading default KDB provider.\n"));

        CurrentEntry = KdcKdbDll;
        NumberOfProviders = 1;
    }
    else
    {
        CurrentEntry = (LPTSTR) KdcGlobalProviderDlls;
    }

    KdcProviders = (PKDC_PROVIDER) MIDL_user_allocate(
        NumberOfProviders * sizeof(KDC_PROVIDER));

    if (KdcProviders == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    for (i = 0; i < NumberOfProviders; i++)
    {
        KdcProviders[i].DllName = CurrentEntry;
        KdcProviders[i].DllLoaded = FALSE;

        KdcProviders[i].DllHandle = LoadLibrary(CurrentEntry);
        if (KdcProviders[i].DllHandle == NULL)
        {
            DebugLog((DEB_ERROR, "LoadKDCProviders: Cannot find DLL %S\n",
                      CurrentEntry));
            Status = STATUS_DLL_NOT_FOUND;

            KdbReportEventW(
                                        IEvent::ERROR_TYPE,
                                        PROVIDER_LOAD_FAILED,
                                        0,
                                        NULL,
                                        1,
                                        CurrentEntry
                                        );
            goto Cleanup;
        }

        KdcProviders[i].DllLoaded = TRUE;
        KdcProviders[i].DllExtMain = (KDC_EXT_MAIN_FN) GetProcAddress(
                                         KdcProviders[i].DllHandle,
                                         KDC_EXT_MAIN
                                         );

        if (KdcProviders[i].DllExtMain)
        {

            Status = KdcProviders[i].DllExtMain(DLL_PROCESS_ATTACH,
                                                g_piKdcCore);
            if (!NT_SUCCESS(Status))
            {
                TRACE_FILELINE(TRACE_ERR, (FILE_AND_LINE,
                                                L"LoadKDCProviders: %s failed to initialize - %x",
                                                CurrentEntry, Status));
                DebugLog((DEB_ERROR, "LoadKDCProviders: %S failed to initialize - %x\n",
                          CurrentEntry, Status));

                KdbReportEventW(
                                    IEvent::ERROR_TYPE,
                                    PROVIDER_LOAD_FAILED,
                                    0,
                                    NULL,
                                    1,
                                    CurrentEntry
                                    );

                goto Cleanup;
            }
            else {
// Xbox Ops doesn't want this informational event generated since it tells
// us nothing that we don't already know from our own provider's events.
#ifndef XBOX_KDC
                KdbReportEventW(
                                        IEvent::INFORMATION_TYPE,
                                        PROVIDER_LOADED,
                                        0,
                                        NULL,
                                        1,
                                        CurrentEntry
                                        );
#endif
                }
        }

        CurrentEntry += (wcslen(CurrentEntry) + 1);
    }

Cleanup:

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   UnloadKdcProviders
//
//  Synopsis:   return the UNICODE_STRING of the KDC machine name
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
UnloadKdcProviders(
    VOID
    )
{
    INT i;
    TRACER(L"UnloadKdcProviders", NULL);

    if (!KdcProviders)
    {
        return;
    }

    for (i = 0; i < NumberOfProviders; i++)
    {
        if (KdcProviders[i].DllLoaded)
        {
            if (KdcProviders[i].DllExtMain)
            {
                (VOID) KdcProviders[i].DllExtMain(DLL_PROCESS_DETACH, NULL);
            }

            FreeLibrary(KdcProviders[i].DllHandle);
        }
    }

    MIDL_user_free(KdcProviders);
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcMachineName
//
//  Synopsis:   return the UNICODE_STRING of the KDC machine name
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

extern "C"
PUNICODE_STRING
NTAPI
KdcMachineName(
    VOID
    )
{
    return &KDCMachineName;
}

//+-------------------------------------------------------------------------
//
//  Name:       KdcServiceMain
//
//  Synopsis:   This is the main KDC thread.
//
//  Arguments:  dwArgc   -
//              pszArgv  -
//
//  Notes:      This intializes everything, and starts the working threads.
//
//--------------------------------------------------------------------------

extern "C"
NTSTATUS
WINAPI KdcServiceMain(PKDCCORE_PARAMS pParams)
{
    HANDLE    hKerbParamEvent = NULL ;
    ULONG     ulStates = 0;
    NTSTATUS  NtStatus = STATUS_SUCCESS;

    //
    // Initialize the Safe alloca package
    //

    if (pParams)
    {
        if(!KdcInitializeMemoryManager(  g_piKdcCore, pParams->pszMemMgr))
        {
            D_DebugLog((DEB_ERROR, "Failed to initialize memory manager: LastError=0x%X\n", GetLastError()));
            goto Shutdown;
        }

        g_pfnSetStatus = pParams->pfnSetStatus;
        KdcParamProviders = pParams->pszProviders;
        KdcGlobalProviderDlls = KdcParamProviders;
        //  Initialize tracing....if pszTraceDll is NULL, initializes default
        NtStatus = KdcInitializeTrace(pParams->pszTraceDll);
    }
    else
    {
        NtStatus = KdcInitializeTrace(NULL);                                //Initialize tracing
    }

    if (!NT_SUCCESS(NtStatus))
    {
        D_DebugLog((DEB_ERROR, "Failed to initialize trace: 0x%X\n", NtStatus));
        goto Shutdown;
    }
    CheckIfTraceInitialized();

    //Initialize Events
    KdcInitializeEventObject(
            L"KDC Core",
            EVCAT_CORE,
            NULL,
            NULL,
            &coreEventObject
            );

    //  initialize transport entry points
    if (!pParams || !pParams->pfnStartTransport || !pParams->pfnStopTransport)
    {
        D_DebugLog((DEB_ERROR, "No transport entry points found"));
        NtStatus = STATUS_INVALID_PARAMETER;
        goto Shutdown;
    }

    //  use supplied transport
    g_pfnStartTransport = pParams->pfnStartTransport;
    g_pfnStopTransport = pParams->pfnStopTransport;

#define RPCDONE        0x1
#define LOCATORSTARTED 0x2
#define CRITSECSDONE   0x4

    KdcState = Starting;


    //
    // Get the debugging parameters
    //

    GetDebugParams();

    //
    // Get other parameters, register wait on registry keys
    //

    //if (KdcParamProviders == NULL)
    //{
        hKdcParamEvent = CreateEvent(
                        NULL,
                        FALSE,
                        FALSE,
                        NULL
                        );

        if (NULL == hKdcParamEvent)
        {
            D_DebugLog((DEB_WARN, "CreateEvent for KdcParamEvent failed - 0x%x\n", GetLastError()));
        }
        else
        {
            KerbWatchKdcParamKey( hKdcParamEvent, FALSE );
        }

        hKerbParamEvent = CreateEvent(
                          NULL,
                          FALSE,
                          FALSE,
                          NULL
                          );

        if (NULL == hKerbParamEvent)
        {
            D_DebugLog((DEB_WARN, "CreateEvent for ParamEvent failed - 0x%x\n", GetLastError()));
        }
        else
        {
            KerbWatchKerbParamKey( hKerbParamEvent, FALSE );
        }
    //}
    //else
    //{
        //KdcGlobalProviderDlls = KdcParamProviders;
    //}
    D_DebugLog((DEB_TRACE, "Start KdcServiceMain\n"));

    //
    // Notify the service controller that we are starting.
    //

    if (!UpdateStatus(SERVICE_START_PENDING) )
    {
        goto Shutdown;
    }

#ifdef KPASSWD
    //
    // Build our Kpasswd name, so we don't have to alloc on
    // every TGS request.
    //
    NtStatus = KerbBuildKpasswdName(
                  &GlobalKpasswdName
                  );

    if (!NT_SUCCESS(NtStatus))
    {
        D_DebugLog((DEB_ERROR, "Failed to build KPASSWED name, error 0x%X\n", NtStatus));
        goto Shutdown;
    }
#endif

    if (!UpdateStatus(SERVICE_START_PENDING) )
    {
        goto Shutdown;
    }

    //
    // Get KDC computer name
    //

    WCHAR TempMachineName[DNS_MAX_NAME_BUFFER_LENGTH];
    ULONG MachineNameLength = sizeof(TempMachineName)/sizeof(TempMachineName[0]);

    if (!GetComputerNameEx(
            ComputerNameDnsHostname,
            TempMachineName,
            &MachineNameLength
            ))
    {
        DebugLog((DEB_ERROR, "Failed to get computer name: 0x%x\n",GetLastError()));
        goto Shutdown;
    }

    RtlInitUnicodeString(
        &KDCMachineName,
        TempMachineName
        );

    //
    //  Initalize whatever that is needed by the provider
    //
    g_piKerbCrypt = static_cast<IKerbCrypt*>(&g_cKerbCryptDll);
    RtlInitUnicodeString(&KrbtgtName, KDC_PRINCIPAL_NAME);

    //
    // Load the KDC providers
    //

    NtStatus = LoadKdcProviders();

    if (!NT_SUCCESS(NtStatus))
    {

        DebugLog((DEB_ERROR, "Failed to load providers: 0x%x\n",NtStatus));
        goto Shutdown;
    }

    if (!UpdateStatus(SERVICE_START_PENDING) )
    {
        goto Shutdown;
    }

    //
    // Initialize internal extension handlers
    //
    NtStatus = RegisterCorePAHandlerFactories();
    if (NT_SUCCESS(NtStatus))
        NtStatus = KdcInitializeInternalADHandlers();
    if (NT_SUCCESS(NtStatus))
        NtStatus = KdcInitializeInternalPacHandlers();

    if (!NT_SUCCESS(NtStatus))
    {

        DebugLog((DEB_ERROR, "Failed to initialize internal handlers: 0x%x\n",NtStatus));
        goto Shutdown;
    }

    if (!UpdateStatus(SERVICE_START_PENDING) )
    {
        goto Shutdown;
    }

    //
    // Load all global data into the SecData structure.
    //

    NtStatus = SecData.Init();
    if (!NT_SUCCESS(NtStatus))
    {

        D_DebugLog((DEB_ERROR, "Failed to init SecData error 0x%X\n", NtStatus));
        goto Shutdown;
    }


    //
    // Set the flag to indicate this is a trust account
    //

    // KdcTicketInfo.UserAccountControl |= USER_INTERDOMAIN_TRUST_ACCOUNT;



    if (!UpdateStatus(SERVICE_START_PENDING) )
    {
        goto Shutdown;
    }

    //
    // Create the KDC shutdown event, set to FALSE
    //
    hKdcShutdownEvent = CreateEvent( NULL,      // no security attributes
                                     TRUE,      // manual reset
                                     FALSE,     // initial state
                                     NULL );    // unnamed event.
    if (hKdcShutdownEvent == NULL)
    {
        NtStatus = (NTSTATUS) GetLastError();

        D_DebugLog(( DEB_ERROR, "KDC can't create shutdown event: wincode=%d.\n",
                    NtStatus ));

        goto Shutdown;
    }


    //
    // Create the KDC shutdown complete event, set to FALSE
    //
    hKdcShutdownCompleteEvent = CreateEvent( NULL,  // no security attributes
                                     TRUE,      // manual reset
                                     FALSE,     // initial state
                                     NULL );    // unnamed event.
    if (hKdcShutdownCompleteEvent == NULL)
    {
        NtStatus = (NTSTATUS) GetLastError();

        D_DebugLog(( DEB_ERROR, "KDC can't create shutdown-complete event: wincode=%d.\n",
                    NtStatus ));

        goto Shutdown;
    }

    if (!UpdateStatus(SERVICE_START_PENDING) )
    {
        goto Shutdown;
    }


    ulStates |= RPCDONE;

    //
    // 1 is the minimum number of threads.
    // TRUE means the call will return, rather than waiting until the
    //     server shuts down.
    //

    //
    // We combine the callers params with default on individual basis
    // The caller gets precedence when providing a value.
    //
    ATQ_CONFIG_PARM AtqCurrentParmeters;
    memcpy(&AtqCurrentParmeters, &AtqParms, sizeof(AtqCurrentParmeters));
    if( pParams && pParams->pAtqConfigParm )
    {
        if (ATQ_CONFIG_PARM_DEFAULT != pParams->pAtqConfigParm->dwThreads )
        {
            AtqCurrentParmeters.dwThreads = pParams->pAtqConfigParm->dwThreads;
        }

        if (ATQ_CONFIG_PARM_DEFAULT != pParams->pAtqConfigParm->dwConcurrentThreads )
        {
            AtqCurrentParmeters.dwConcurrentThreads = pParams->pAtqConfigParm->dwConcurrentThreads;
        }

        if (ATQ_CONFIG_PARM_DEFAULT != pParams->pAtqConfigParm->dwsecThreadTimeOut )
        {
            AtqCurrentParmeters.dwsecThreadTimeOut = pParams->pAtqConfigParm->dwsecThreadTimeOut;
        }

        if (ATQ_CONFIG_PARM_DEFAULT != pParams->pAtqConfigParm->dwMinKBTimeOut )
        {
            AtqCurrentParmeters.dwMinKBTimeOut = pParams->pAtqConfigParm->dwMinKBTimeOut;
        }
    }

    NtStatus = g_pfnStartTransport((FNKdcGetTicket)KdcGetTicket,// callback for transport
                                    &g_KdcCore,                 // table of utility fcns for transport
                                    &AtqCurrentParmeters);       // transport configuration
    if (!NT_SUCCESS(NtStatus))
    {

        D_DebugLog((DEB_ERROR, "Failed to initialize sockets\n"));
        goto Shutdown;
    }

    if (!UpdateStatus(SERVICE_START_PENDING) )
    {
        goto Shutdown;
    }

    //
    // Check to see if there is a CSP registered for replacing the StringToKey calculation
    //
    CheckForOutsideStringToKey();

    if (!UpdateStatus(SERVICE_START_PENDING) )
    {
        goto Shutdown;
    }

    //
    // At this point the KDC is officially started.
    // 3 * ( 2*(hip) horray! )
    //

    if (!UpdateStatus(SERVICE_RUNNING) )
    {
        goto Shutdown;
    }

#if DBG
    GetSystemTimeAsFileTime((PFILETIME)&tsOut);
    D_DebugLog((DEB_TRACE, "Time required for KDC to start up: %d ms\n",
                         (tsOut.LowPart-tsIn.LowPart) / 10000));
#endif


    KdcState = Running;

    // This function will loop until the event is true.

    // WAS BUG: turn off cache manager for now.
    // This bug comment is a stale piece of code from
    // Cairo days - per MikeSw
    //


    // XXX Need to wait for multiple events - like KdcWinsockPnpEvent

    WaitForSingleObject(hKdcShutdownEvent, INFINITE);

    D_DebugLog((DEB_TRACE, "KDC shutting down.\n" ));

Shutdown:

#ifdef KPASSWD
    if (NULL != GlobalKpasswdName)
    {
       KerbFreeKdcName(&GlobalKpasswdName);
    }
#endif

    UpdateStatus(SERVICE_STOP_PENDING);


    if (g_pfnStopTransport)
    {
        g_pfnStopTransport();
    }

    UpdateStatus(SERVICE_STOP_PENDING);

    //
    // Close all of the events.
    //

    {
        PHANDLE ph = &hKdcHandles[0];

        for(;ph < &hKdcHandles[MAX_KDC_HANDLE]; ph++)
        {
            if(*ph)
            {
                CloseHandle(*ph);
                *ph = NULL;
            }
        }
    }

#ifdef  RETAIL_LOG_SUPPORT
    if (hKerbParamEvent) {
        WaitKerbCleanup( hKerbParamEvent );
    }
#endif

    if ( hKdcParamEvent ) {
        WaitKdcCleanup( hKdcParamEvent );
    }

    //
    // Cleanup handles to SAM & LSA and global variables
    //

    UpdateStatus(SERVICE_STOP_PENDING);

    //
    // Unload providers
    //

    UnloadKdcProviders();

    //  and clear factory lists
    KdcDeleteAllHandlerLists();

    UpdateStatus(SERVICE_STOP_PENDING);


    //
    // Cleanup allocated memory
    //  if providers were read from registry, not provided as param
    //

    if (KdcGlobalProviderDlls && KdcGlobalProviderDlls != KdcParamProviders)
    {
        MIDL_user_free(KdcGlobalProviderDlls);
        KdcGlobalProviderDlls = NULL;
    }


    ShutdownStatus = NtStatus;

    KdcShutdownTrace();

    if (!SetEvent( hKdcShutdownCompleteEvent ) )
    {

        //D_DebugLog(( DEB_ERROR, "Couldn't set KDC shutdown-complete event.  winerr=%d.\n",
              //       GetLastError() ));
    }

    //D_DebugLog((DEB_TRACE, "End KdcServiceMain\n"));
    KdcFreeEventObject(coreEventObject);

    return  NtStatus;
}



////////////////////////////////////////////////////////////////////
//
//  Name:       KdcShutDown
//
//  Synopsis:   Shuts the KDC down.
//
//  Arguments:  pszMessage   - message to print to debug port
//
//  Notes:      Stops RPC from accepting new calls, waits for pending calls
//              to finish, and sets the global event "hKdcShutDownEvent".
//
extern "C"
NTSTATUS
WINAPI
KdcShutDown(LPWSTR pszMessage)
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    D_DebugLog((DEB_WARN, "Server Shutdown:  %ws\n", pszMessage));


    //
    // Notify the all threads that we are exiting.
    //


    //
    // First set the started flag to false so nobody will try any more
    // direct calls to the KDC.
    //

    KdcState = Stopped;

    //
    // If there are any outstanding calls, let them trigger the shutdown event.
    // Otherwise set the shutdown event ourselves.
    //

    EnterCriticalSection(&ApiCriticalSection);
    if (CurrentApiCallers == 0)
    {

        if (!SetEvent( hKdcShutdownEvent ) )
        {

            D_DebugLog(( DEB_ERROR, "Couldn't set KDC shutdown event.  winerr=%d.\n",
                        GetLastError() ));
            NtStatus = STATUS_UNSUCCESSFUL;
        }

        //
        // Wait for the KDC to shutdown
        //

        WaitForSingleObject(hKdcShutdownCompleteEvent, 10*1000 ); // 10 Seconds

        CloseHandle(hKdcShutdownCompleteEvent);

        SecData.Cleanup();

#ifdef KDC_WMI_TRACING
        if (KdcTraceRegistrationHandle != (TRACEHANDLE)0)
        {
            UnregisterTraceGuids( KdcTraceRegistrationHandle );
        }
#endif
        /* TODO: call KdcShutdownTrace(); ? */
    }
    LeaveCriticalSection(&ApiCriticalSection);
    UpdateStatus(SERVICE_STOPPED);
    return(NtStatus);
}


//+-------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   DLL initialization routine
//
//--------------------------------------------------------------------------

extern "C" BOOL WINAPI
DllMain (
    HINSTANCE hInstance,
    DWORD dwReason,
    PVOID lpReserved
    )
{
    BOOL bReturn = TRUE;

    if ( dwReason == DLL_PROCESS_ATTACH )
    {
        DisableThreadLibraryCalls ( hInstance );

        //
        // WAS BUG: call the Rtl version here because it returns an error
        // instead of throwing an exception.  Leave it here, as we don't
        // really need to put a try/except around InitCritSec.
        //

        InitializeCriticalSection( &ApiCriticalSection );
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        DeleteCriticalSection(&ApiCriticalSection);
        KdcShutdownMemoryManager(  );
    }

    return bReturn;
    UNREFERENCED_PARAMETER(lpReserved);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\server\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\server\KdcEvent.cxx ===
//------------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//
// File Name    :   KerbEvent.cxx
// Abstract :   interface for the IEvent class.
// Created  :   vikask on 9/27/01   
// Revision History:
//
//------------------------------------------------------------------------------

#include "kdcsvr.hxx"
#include "KdcEventInterface.hxx"

#ifndef ARGUMENT_PRESENT
#define ARGUMENT_PRESENT(ArgPtr) ( (CHAR*)(ArgPtr) != (CHAR*)(NULL) )
#endif

#define HKEY_EVENTLOG TEXT("System\\CurrentControlSet\\Services\\Eventlog\\Application")
#define TYPES_SUPPORTED TEXT("TypesSupported")
#define EVENT_MSGFILE TEXT("EventMessageFile")
#define CATEGORY_COUNT TEXT("CategoryCount")
#define DISABLE_EVENTS TEXT("DisableEvents")

class CEvent : public IEvent
{
private:
    static WORD convertEvent ( 
        const IEvent::TYPE type )
    {
        switch (type)
        {
            case IEvent::ERROR_TYPE:
                return EVENTLOG_ERROR_TYPE;
            case IEvent::WARNING_TYPE:
                return EVENTLOG_WARNING_TYPE;
            case IEvent::INFORMATION_TYPE:
                return EVENTLOG_INFORMATION_TYPE;
            case IEvent::AUDIT_SUCCESS:
                return EVENTLOG_AUDIT_SUCCESS;
            case IEvent::AUDIT_FAILURE:
                return EVENTLOG_AUDIT_FAILURE;
            default:
                return EVENTLOG_ERROR_TYPE;
        }
    };
public:
    CEvent(){};
    ~CEvent(){};

    //
    //    IEvent methods
    //
    
    virtual BOOL ReportEventFullU(
                IN IEvent::TYPE                     EventType,
                IN DWORD                            EventId,
                IN DWORD                            dwRawDataSize,
                IN const VOID                      *pvRawData,
                IN ULONG                              uUnicodeStringCount,
                ...
                ) ;
    
        virtual BOOL ReportEventFullW(
                IN IEvent::TYPE                     EventType,
                IN DWORD                            EventId,
                IN DWORD                            dwRawDataSize,
                IN const VOID                      *pvRawData,
                IN ULONG                             uStringCount,
                ...
                ) ;
};

//+-------------------------------------------------------------------------
//
//  Function:   CEvent::ReportEventFullU
//
//  Synopsis:   Report an Event, i.e. writes an entry at the end of the event
//              log (IEvent::m_eventSource - Handle to the event log)
//
//  Effects:
//
//  Arguments:  EventType          - {INFORMATION,WARNING,ERROR}_TYPE
//              EventId            -    Message that goes with this event
//              dwRawDataSize      - # of VOIDs of event-specific raw data
//              pvRawData           - Raw Data
//              uUnicodeStringCount - # of unicode strings 
//
//  Returns:    TRUE    success
//              FALSE   failure
//
//  Notes:
//
//--------------------------------------------------------------------------
          
BOOL CEvent::ReportEventFullU(
                IN IEvent::TYPE                     EventType,
                IN DWORD                            dwEventId,
                IN DWORD                            dwRawDataSize,
                IN const VOID                      *pvRawData,
                IN ULONG                              uUnicodeStringCount,
                ...
                )
{
    if(IEvent::m_bDisabled)
    {
        return TRUE;
    }
    
    if (!IEvent::m_inited)
    {
        return FALSE;
    }
    
    BOOL result;
    WCHAR **pszStrings = NULL;

    pszStrings = (WCHAR **)
                LocalAlloc(0, uUnicodeStringCount * sizeof(WCHAR *));  
    if (!pszStrings) 
    {
        return FALSE;
    }
    
    va_list     parms;
    va_start(parms, uUnicodeStringCount);
    
    for (int i = 0; i < (WORD)uUnicodeStringCount; i++ ) 
    {
        PUNICODE_STRING pustrTempStr = va_arg(parms, PUNICODE_STRING);   
        pszStrings[i] = (WCHAR *) LocalAlloc(0, MAX_STR * sizeof(WCHAR));
        if (!pszStrings[i]) 
        {
            for (int j = 0; j < i; j++) 
            {
                LocalFree(pszStrings[j]);            
            }
            LocalFree(pszStrings);
            return FALSE;
        }
        wcsncpy(pszStrings[i], pustrTempStr->Buffer, pustrTempStr->Length);
        pszStrings[i][pustrTempStr->Length] = L'\0';
    }
    
    result = ReportEvent(IEvent::m_eventSource,
                        (WORD)convertEvent(EventType),
                        (WORD)IEvent::m_defaultCategoryID,
                        dwEventId,
                        NULL,                   
                        (WORD)uUnicodeStringCount,
                        dwRawDataSize,
                        (LPCTSTR*)pszStrings,
                        (LPVOID)pvRawData
                        );  
    for (int i =0; i < (WORD)uUnicodeStringCount; i++ ) 
    {
        LocalFree(pszStrings[i]);
    }
    LocalFree(pszStrings);
    return result;
}

//+-------------------------------------------------------------------------
//
//  Function:   CEvent::ReportEventFullW
//
//  Synopsis:   Report an Event, i.e. writes an entry at the end of the event
//              log (IEvent::m_eventSource - Handle to the event log)
//
//  Effects:
//
//  Arguments:  
//              EventType          - {INFORMATION,WARNING,ERROR}_TYPE
//              dwEventId            -    Message that goes with this event
//              dwRawDataSize      - # of VOIDs of event-specific raw data
//              pvRawData           - Raw Data
//              uStringCount - # of unicode strings 
//
//  Returns:    TRUE    success
//              FALSE   failure
//
//  Notes:
//
//--------------------------------------------------------------------------
          
BOOL CEvent::ReportEventFullW(
                IN IEvent::TYPE                     EventType,
                IN DWORD                            dwEventId,
                IN DWORD                            dwRawDataSize,
                IN const VOID                      *pvRawData,
                IN ULONG                              uStringCount,
                ...
                )
{
    if(IEvent::m_bDisabled)
    {
        return TRUE;
    }
    
    if (!IEvent::m_inited)
    {
        return FALSE;
    }
    
    BOOL result;
    WCHAR **pszStrings;
    pszStrings = (WCHAR **)
                LocalAlloc(0, uStringCount * sizeof(WCHAR *));  
    if (!pszStrings) 
    {
        return FALSE;
    }
    
    va_list     parms;
    va_start(parms, uStringCount);
    
    for (int i=0; i < (WORD)uStringCount; i++ ) 
    {
        pszStrings[i] = va_arg(parms, LPWSTR);
    }
    
    result = ReportEvent(
                        IEvent::m_eventSource,
                        (WORD)convertEvent(EventType),
                        (WORD)IEvent::m_defaultCategoryID,
                        dwEventId,
                        NULL,       //OPTIONAL: current user's security identifier
                        (WORD)uStringCount,
                        dwRawDataSize,
                        (LPCTSTR*)pszStrings,
                        (LPVOID)pvRawData
                        );  

    LocalFree(pszStrings);
    return result;
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcInitializeEventObject
//
//  Synopsis:   Initializes the event object, the registry key & retrieves
//              a handle to the event log.
//
//  Effects:
//
//  Arguments:  applicationName      - Source name
//              defaultCategoryID    - Optional Event Category (default 0)
//              eventResourceDllName - Optional EventMessageFile (default NULL)
//              numberCategories     - Optional Category Count (default 0)
//              ppObject                   - pointer to pointer to IEvent object
//
//  Returns:    TRUE    success
//              FALSE   failure
//
//  Notes:
//
//--------------------------------------------------------------------------
BOOL KdcInitializeEventObject(
                        IN LPWSTR                   applicationName,
                        IN OPTIONAL DWORD   defaultCategoryID,
                        IN OPTIONAL LPWSTR  eventResourceDllName,  // full path
                        IN OPTIONAL DWORD   numberCategories,
                        OUT IEvent                  **ppObject                        
                        )
{
    CEvent  *pCEvent = NULL;
    pCEvent = new CEvent;

    if (!pCEvent) 
    {
        return FALSE;
    }
    
    *ppObject = pCEvent;
    
    HKEY hkResult = NULL;
    
    if ( !ARGUMENT_PRESENT(defaultCategoryID) )
    {
        defaultCategoryID = 0;
    }
    
    if ( !ARGUMENT_PRESENT(eventResourceDllName) )
    {
        eventResourceDllName = NULL;
    }
    
    if ( !ARGUMENT_PRESENT(numberCategories) )
    {
        numberCategories = 0;
    }
    
    if (pCEvent->m_inited)
    {
        return FALSE;
    }

    pCEvent->m_defaultCategoryID = defaultCategoryID;

    WCHAR szEventLogKey[MAX_STR];   //TODO: Must allocate using safe alloc    
    size_t length = 0, tempLen = 0;
    while ((length < (MAX_STR-1)) && (tempLen < wcslen(HKEY_EVENTLOG)))
    {
        szEventLogKey[length++] = applicationName[tempLen++];
    }
    if (length < (MAX_STR-1))
    {
        szEventLogKey[length++] = L'\\';
    }
    tempLen = 0;
    while ((length < (MAX_STR-1)) && (tempLen < wcslen(applicationName)))
    {
        szEventLogKey[length++] = HKEY_EVENTLOG[tempLen++];
    }
    szEventLogKey[length] = L'\0';
   
    if (RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    szEventLogKey,
                    0,
                    KEY_READ,
                    &hkResult
                    ) != ERROR_SUCCESS)
    {
        ;//this is OK, events can still be logged w/o strings
    }

    const DWORD dwType = 0x07;  //bitmask of supported types
    DWORD dwLen = sizeof(DWORD);

    
    // TODO : Check for hkResult
    if (!hkResult || (RegSetValueEx(
                                hkResult, 
                                TYPES_SUPPORTED, 
                                0,
                                REG_DWORD,
                                (UCHAR*)&dwType, 
                                 dwLen
                                ) != ERROR_SUCCESS
                            )
        ) 
    {
        ;////this is OK, events can still be logged w/o strings
    }

    if (eventResourceDllName)
    {
        if (!hkResult || (RegSetValueEx(
                                hkResult, 
                                EVENT_MSGFILE, 
                                0,
                                REG_SZ, 
                                (const BYTE *)eventResourceDllName,
                                lstrlen(eventResourceDllName) * sizeof(WCHAR)
                                ) != ERROR_SUCCESS)
            )
        {
            ;////this is OK, events can still be logged w/o strings
        }
       
        if (!hkResult || (RegSetValueEx(
                                hkResult,
                                CATEGORY_COUNT,
                                0,
                                REG_DWORD,
                                (UCHAR*)&numberCategories,
                                dwLen
                                ) != ERROR_SUCCESS)
            )                      
        {
            ;////this is OK, events can still be logged w/o strings
        }
    }

    if (hkResult) {
        RegQueryValueEx(hkResult,
                    DISABLE_EVENTS,
                    0,
                    NULL,
                    (UCHAR*)&pCEvent->m_bDisabled,
                    &dwLen
                    );
        RegCloseKey(hkResult);
        }

    pCEvent->m_eventSource = RegisterEventSource(NULL, applicationName);
    
    if ( pCEvent->m_eventSource != NULL )
    {
        pCEvent->m_inited = TRUE;
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


void 
KdcFreeEventObject ( IN IEvent * pObject )
{
    if (pObject) 
    {
        DeregisterEventSource(pObject->m_eventSource);
        delete (pObject);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\server\getas.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001.
//
//  File:       getas.cxx
//
//  Contents:   GetASTicket and support functions
//
//  Classes:
//
//  Functions:
//
//  History:    04-Mar-94   wader   Created
//              16-Sept-2001 yordanr    modified for new interfaces
//
//----------------------------------------------------------------------------

#include "kdcsvr.hxx"
//#include "kdctrace.h"
#include "krb5p.h"
#include "traceinterface.hxx"
#include "kdctrace.hxx"

#include "fileno.h"
#define FILENO FILENO_GETAS

//
//  Interface methods to the memory manager to signal start/end of request processing.
//
#include "kdcmem.hxx"

LARGE_INTEGER tsInfinity = {0xffffffff,0x7fffffff};
LONG lInfinity = 0x7fffffff;

#ifdef DBG
ULONG
NetpDcElapsedTime(
    IN ULONG StartTime
)

/*++

Routine Description:

    Returns the time (in milliseconds) that has elapsed is StartTime.

Arguments:

    StartTime - A time stamp from GetTickCount()

Return Value:

    Returns the time (in milliseconds) that has elapsed is StartTime.

--*/
{
    ULONG CurrentTime;

    //
    // If time has has wrapped,
    //  account for it.
    //

    CurrentTime = GetTickCount();

    if ( CurrentTime >= StartTime ) {
        return CurrentTime - StartTime;
    } else {
        return (0xFFFFFFFF-StartTime) + CurrentTime;
    }
}
#endif  // DBG

//+---------------------------------------------------------------------------
//
//  Function:   FailedLogon
//
//  Synopsis:   Processes a failed logon.
//
//  Effects:    May raise an exception, audit, event, lockout, etc.
//
//  Arguments:  [PrincInfo] -- [in] Client who didn't log on.
//              [ClientAddress] -- Address of client making request
//
//  Requires:
//
//  Returns:    HRESULT to return to client.
//
//  Algorithm:
//
//  History:    03-May-94   wader   Created
//
//  Notes:      This usually returns hrReason, but it may map it to
//              something else.
//              yordanr - has to be changed to use new Aidut interfaces
//
//----------------------------------------------------------------------------

VOID
FailedLogon(
    IN PIKdbProvider        piKdb,
    IN PIKerbPrincipal      UserInfo,
    IN OPTIONAL PSOCKADDR   ClientAddress,
    OUT PKERB_EXT_ERROR     pExtendedError
    )
{

    //  BUGBUG todo: fix failed logon auditing
#if 0
    LARGE_INTEGER CurrentTime = {0};
    KDB_PRINC_INFO UpdateInfo = {0};
    KERBERR KerbErr;

    GetSystemTimeAsFileTime((PFILETIME)&CurrentTime);

    UpdateInfo.DataFlags = KERB_KDB_DATA_LOGON_TIME;
    UpdateInfo.LastFailedLogon = CurrentTime;
    UpdateInfo.LastLogon.QuadPart = KERB_KDB_TIME_NEVER;
    UpdateInfo.LastLogonClient = *ClientAddress;

    KerbErr = piKdb->PutPrincipal(
                 UserInfo->GetName(),
                 KerbAs,
                 &UpdateInfo,
                 pExtendedError
                 );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"KLIN(%x) Failed to update failed logon time for ",KLIN(FILENO,__LINE__)));
        KerbPrintKdcName(DEB_ERROR, UserInfo->Princ);
    }
#endif
}


//+---------------------------------------------------------------------------
//
//  Function:   SuccessfulLogon
//
//  Synopsis:   Processes a successful logon.
//
//  Effects:    May raise an event, create an audit, throw a party.
//
//  Arguments:  [UserInfo] -- Client who logged on.
//              [ClientAddress] -- Address of client making request
//
//
//  Algorithm:
//
//  History:    03-May-94   wader   Created
//
//  Notes:      On successful logon, we discard the history of failed logons
//              (as far as lockout is concerned).
//              yordanr - has to be changed for new audit interfaces
//
//----------------------------------------------------------------------------

VOID
SuccessfulLogon(
    IN PIKdbProvider      KdbHandle,
    IN PIKerbPrincipal    UserInfo,
    IN PSOCKADDR OPTIONAL ClientAddress,
    OUT PKERB_EXT_ERROR   pExtendedError
    )
{
    //  BUGBUG todo: fix successful logon audit
#if 0
    LARGE_INTEGER CurrentTime = {0};
    KDB_PRINC_INFO UpdateInfo = {0};
    KERBERR KerbErr;

    GetSystemTimeAsFileTime((PFILETIME)&CurrentTime);

    UpdateInfo.DataFlags = KERB_KDB_DATA_LOGON_TIME;
    UpdateInfo.LastLogon = CurrentTime;
    UpdateInfo.LastFailedLogon.QuadPart = KERB_KDB_TIME_NEVER;
    UpdateInfo.LastLogonClient = *ClientAddress;

    KerbErr = KdbPutPrincipal(
                 KdbHandle,
                 UserInfo->Princ,
                 KerbAs,
                 &UpdateInfo,
                 pExtendedError
                 );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"KLIN(%x) Failed to update successful logon time for ",KLIN(FILENO,__LINE__)));
        KerbPrintKdcName(DEB_ERROR, UserInfo->Princ);
    }
#endif
}

//+---------------------------------------------------------------------------
//
//  Function:   BuildTicketAS
//
//  Synopsis:   Builds an AS ticket, including filling inthe name fields
//              and flag fields.
//
//  Arguments:  IN ClientInfo  -- client principal interface
//              IN ClientName  -- name of client from the request
//              IN ClientRealm -- realm from the request
//              IN ServiceInfo -- service ticket is for
//              IN ServerName  -- name of service
//              IN OPTIONAL  HostAddresses -- client host
//              IN RequestBody   -- ticket request body
//              IN PreAuthenticated -- is the client preauth
//              IN TransitedRealm --
//              OUT NewTicket    -- (out) ticket
//              OUT pExtendedError - extended error info
//
//  History:    24-May-93   WadeR   Created
//              12-Sept-2001 yordanr    modified for new interfaces
//
//  Notes:      See 3.1.3, A.2 of the Kerberos V5 R5.2 spec
//              (yordanr) does not make sence to take both client info and name
//              as params. Same for the server
//              only explanation is that with name canonicalization the
//              client name in the req and actual client name may differ.
//              but why have the former?
//
//----------------------------------------------------------------------------

KERBERR
BuildTicketAS(
    IN CKerbRequest          *pReq,
    IN PIKdbProvider          piProv,
    IN PKERB_REALM            ClientRealm,
    IN BOOLEAN                PreAuthenticated,
    IN PUNICODE_STRING        TransitedRealm,
    OUT PKERB_TICKET          NewTicket,
    OUT PKERB_EXT_ERROR       pExtendedError
    )
{
    KERBERR Status = KDC_ERR_NONE;
    PKERB_ENCRYPTED_TICKET EncryptedTicket = NULL;
    LARGE_INTEGER TicketLifespan;
    LARGE_INTEGER TicketRenewspan, Expire;
    ULONG KdcOptions = 0;
    ULONG CommonEType = 0;
    PKERB_INTERNAL_NAME pkinClient;
    PIKerbPrincipal  ClientInfo = pReq->GetIPrincClient();
    PIKerbPrincipal ServiceInfo = pReq->GetIPrincService();
    const KERB_KDC_REQUEST_BODY *RequestBody = &pReq->GetKdcRequest()->request_body;

    TRACER(L"BuildTicketAS", (PVOID *) &Status);

    TRACE(KDC, BuildTicketAS, DEB_FUNCTION);

    EncryptedTicket = (PKERB_ENCRYPTED_TICKET) NewTicket->encrypted_part.cipher_text.value;

    KdcOptions = KerbConvertFlagsToUlong(&RequestBody->kdc_options);

    NewTicket->ticket_version = KERBEROS_VERSION;

    D_DebugLog(( DEB_T_TICKETS, "Building an AS ticket to %ws for %ws\n",
                ClientInfo->GetName()->Names[0].Buffer,
                ServiceInfo->GetName()->Names[0].Buffer ));

    //
    // Pickup the lifespan from the client principal. KDB enforces
    // any global restrictions.
    //

    TicketLifespan = ClientInfo->MaxLifeTime();
    TicketRenewspan = ClientInfo->MaxRenewTime();
    Expire = ClientInfo->Expiration();

    Status = KdcBuildTicketTimesAndFlags(
                ClientInfo->GetPrincFlags(),
                ServiceInfo->GetPrincFlags(),
                piProv->GetKdcPolicy(),
                &TicketLifespan,
                &TicketRenewspan,
                &Expire,
                RequestBody,
                NULL,           // no source ticket
                EncryptedTicket,
                pExtendedError
                );

    if (!KERB_SUCCESS(Status))
    {
        D_DebugLog((DEB_TRACE,"KLIN(%x) Failed to build ticket times and flags: 0x%x\n",
                  KLIN(FILENO,__LINE__), Status));
        FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
        goto Cleanup;
    }


    //
    // Make this an Initial ticket (issued by the AS)
    //

    *((PULONG)EncryptedTicket->flags.value) |= KerbConvertUlongToFlagUlong(KERB_TICKET_FLAGS_initial);

    //
    // Turn on preauth flag if necessary
    //

    if (PreAuthenticated)
    {
        *((PULONG)EncryptedTicket->flags.value) |= KerbConvertUlongToFlagUlong(KERB_TICKET_FLAGS_pre_authent);
    }

    //  compute the common ETYPE
    const ETYPE*    pETypes = NULL;
    ULONG   cEtypes = 0;
    ClientInfo->GetEtypes(&pETypes, &cEtypes);
    Status = KerbFindCommonEType(RequestBody->encryption_type,
                                  cEtypes,
                                  pETypes,
                                  &CommonEType);
    if (!KERB_SUCCESS(Status))
    {
        //  BUGBUG todo: log/trace
        goto    Cleanup;
    }

    Status = KerbMakeKey(
                CommonEType,
                &EncryptedTicket->key
                );

    if (!KERB_SUCCESS(Status))
    {
       FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
       goto Cleanup;
    }


    //
    // Insert the service names. If the client requested canoncalization,
    // return our realm name & sam account name. Otherwise copy what the
    // client requested
    //
#ifdef DO_NAME_CANONICALIZATION
    if (((KdcOptions & KERB_KDC_OPTIONS_name_canonicalize) != 0) &&
        ((ServiceTicketInfo->UserAccountControl & USER_USE_DES_KEY_ONLY) == 0))
    {
        PKERB_INTERNAL_NAME TempServiceName = NULL;
        //
        // Build the service name for the ticket. For interdomain trust
        // accounts, this is "krbtgt / domain name"
        //

        if (ServiceTicketInfo->UserId == DOMAIN_USER_RID_KRBTGT)
        {

            Status = KerbBuildFullServiceKdcName(
                        KdcDnsRealmName(KdbHandle),
                        KdcServiceName(KdbHandle),
                        KRB_NT_SRV_INST,
                        &TempServiceName
                        );

            if (!KERB_SUCCESS(Status))
            {
                FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
                goto Cleanup;
            }

            Status = KerbConvertKdcNameToPrincipalName(
                        &NewTicket->server_name,
                        TempServiceName
                        );

            KerbFreeKdcName(&TempServiceName);

            if (!KERB_SUCCESS(Status))
            {
                goto Cleanup;
            }
        }
        else if ((ServiceTicketInfo->UserAccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT) != 0)
        {

            Status = KerbBuildFullServiceKdcName(
                        &ServiceTicketInfo->AccountName,
                        KdcServiceName(),
                        KRB_NT_SRV_INST,
                        &TempServiceName
                        );

            if (!KERB_SUCCESS(Status))
            {
                FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
                goto Cleanup;
            }

            Status = KerbConvertKdcNameToPrincipalName(
                        &NewTicket->server_name,
                        TempServiceName
                        );

            KerbFreeKdcName(&TempServiceName);

            if (!KERB_SUCCESS(Status))
            {
               FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
               goto Cleanup;
            }
        }
        else
        {
            Status = KerbConvertStringToPrincipalName(
                        &NewTicket->server_name,
                        &ServiceTicketInfo->AccountName,
                        KRB_NT_PRINCIPAL
                        );
            if (!KERB_SUCCESS(Status))
            {
               FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
               goto Cleanup;
            }
        }

    }
    else
#endif
    {
        //
        // No canonicalzation, so copy in all the names as the client
        // requested them.
        //

        Status = KerbDuplicatePrincipalName(
                    &NewTicket->server_name,
                    &RequestBody->KERB_KDC_REQUEST_BODY_server_name
                    );
        if (!KERB_SUCCESS(Status))
        {
            goto Cleanup;
        }

    }

    Status = KerbConvertUnicodeStringToRealm(
                 &NewTicket->realm,
                 ClientInfo->GetRealm()
                 );

    if ( !KERB_SUCCESS( Status ))
    {
       FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
       goto Cleanup;
    }

    //
    // Insert the client names. If the client requested canoncalization,
    // return our realm name & sam account name. Otherwise copy what the
    // client requested
    //
    if (((KdcOptions & KERB_KDC_OPTIONS_name_canonicalize) != 0) &&
        (pkinClient = ClientInfo->GetCanonicalName())
        )
    {
        Status = KerbConvertKdcNameToPrincipalName(
                    &EncryptedTicket->client_name,
                    pkinClient
                    );
    }
    else
    {
        Status = KerbConvertKdcNameToPrincipalName(
                     &EncryptedTicket->client_name,
                     ClientInfo->GetName()
                     );
    }

    if (!KERB_SUCCESS(Status))
    {
       FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
       goto Cleanup;
    }

    //
    //  convert unicode realm to kerb realm
    //

    EncryptedTicket->client_realm = *ClientRealm;

    if ((RequestBody->bit_mask & addresses_present) != 0 &&
        RequestBody->addresses &&
        KdcUseClientAddresses)
    {
        EncryptedTicket->bit_mask |= KERB_ENCRYPTED_TICKET_client_addresses_present;
        EncryptedTicket->KERB_ENCRYPTED_TICKET_client_addresses = RequestBody->addresses;
    }
    else
    {
        EncryptedTicket->bit_mask &= ~KERB_ENCRYPTED_TICKET_client_addresses_present;
        EncryptedTicket->KERB_ENCRYPTED_TICKET_client_addresses = NULL;
    }

    if (TransitedRealm->Length > 0)
    {
        STRING TempString;
        Status = KerbUnicodeStringToKerbString(
                    &TempString,
                    TransitedRealm
                    );
        if (!KERB_SUCCESS(Status))
        {
           FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
           goto Cleanup;
        }
        EncryptedTicket->transited.transited_type = DOMAIN_X500_COMPRESS;
        EncryptedTicket->transited.contents.value = (PUCHAR) TempString.Buffer;
        EncryptedTicket->transited.contents.length = (int) TempString.Length;

    }
    else
    {
        ZeroMemory(
            &EncryptedTicket->transited,
            sizeof(KERB_TRANSITED_ENCODING)
            );
    }

    EncryptedTicket->KERB_ENCRYPTED_TICKET_authorization_data = NULL;

#if DBG
    PrintTicket( DEB_T_TICKETS, "BuildTicketAS: Final ticket", NewTicket );
#endif
Cleanup:
    if (!KERB_SUCCESS(Status))
    {
        KdcFreeInternalTicket(NewTicket);
    }
    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   I_GetASTicket
//
//  Synopsis:   Gets an authentication service ticket to the requested
//              service.
//
//  Effects:    Allocates and encrypts a KDC reply
//
//  Arguments:
//              IN ClientAddress
//              IN RequestMessage - Contains the AS request message
//              IN RequestRealm -- client realm
//              IN Pdu - PDU to pack the reply body with.
//              IN ReplyPdu -- outer Pdu
//              IN InputMessage - buffer client sent, used for replay detection
//              OUT OutputMessage - Contains the AS reply message
//              OUT ErrorData - contains any error data for an error message
//              OUT pExtendedError - ext. err
//              OUT ClientRealm - client realm from the principal interface
//
//  Requires:
//
//  Returns:    KDC_ERR_ or KRB_AP_ERR errors only
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
I_GetASTicket(
    IN OPTIONAL PSOCKADDR ClientAddress,
    IN PKERB_AS_REQUEST RequestMessage,
    IN PUNICODE_STRING RequestRealm,
    IN ULONG Pdu,
    IN ULONG ReplyPdu,
    IN PKERB_MESSAGE_BUFFER InputMessage,
    OUT PKERB_MESSAGE_BUFFER OutputMessage,
    OUT PKERB_MESSAGE_BUFFER ErrorData,
    OUT PKERB_EXT_ERROR pExtendedError,
    OUT PUNICODE_STRING ClientRealm
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status;

    IKdbProvider *piKdb = NULL;

    PIKerbPrincipal ClientInfo = NULL;
    PIKerbPrincipal ServiceInfo = NULL;

    KERB_ENCRYPTION_KEY EncryptionKey = {0};

    KERB_TICKET Ticket = {0};
    KERB_ENCRYPTED_TICKET EncryptedTicket = {0};
    KERB_ENCRYPTED_KDC_REPLY ReplyBody = {0};
    KERB_KDC_REPLY Reply = {0};
    PKERB_KDC_REQUEST_BODY RequestBody = NULL;
    KERB_REALM ClientRealmName = {0};

    PKERB_AUTHORIZATION_DATA AuthData = NULL;
    PKERB_PA_DATA_LIST OutputPreAuthData = NULL;

    PKERB_INTERNAL_NAME ClientName = NULL;
    PKERB_INTERNAL_NAME ServerName = NULL;

    UNICODE_STRING ServerStringName = {0};
    UNICODE_STRING ClientStringName = {0};
    UNICODE_STRING TransitedRealm = {0};

    ULONG NameFlags = 0;
    ULONG PreAuthType = 0;
    ULONG KdcOptions = 0;
    ULONG TicketFlags = 0;
    ULONG ReplyTicketFlags = 0;

    BOOLEAN AuditedFailure = FALSE;
    BOOLEAN LoggedFailure = FALSE;

    CKerbRequest KdcReq;
    KdcReq.m_pKdcRequest = RequestMessage;
    KdcReq.m_pClientAddress = ClientAddress;
    PUNICODE_STRING ReferralRealm = NULL;

#ifdef KDC_WMI_TRACING
    KDC_AS_EVENT_INFO ASEventTraceInfo = {0};
#endif

    TRACE(KDC, I_GetASTicket, DEB_FUNCTION);
    TRACER(L"I_GetASTicket", (PVOID *) &KerbErr);

    //  init KDC request and handlers
    Status = KdcReq.CreateHandlerInstances();
    if (Status != STATUS_SUCCESS)
    {
        //  todo: BUGBUG log/trace?
        return  KRB_ERR_GENERIC;
    }
    KdcReq.m_ServId = KerbAs;

    //
    //  Initialize local variables
    //

    EncryptedTicket.flags.value = (PUCHAR) &TicketFlags;
    EncryptedTicket.flags.length = sizeof(ULONG) * 8;
    ReplyBody.flags.value = (PUCHAR) &ReplyTicketFlags;
    ReplyBody.flags.length = sizeof(ULONG) * 8;
    RtlInitUnicodeString( ClientRealm, NULL );
    Ticket.encrypted_part.cipher_text.value = (PUCHAR) &EncryptedTicket;

    //
    // Initialize return variables
    //
    ClientRealm->Length = ClientRealm->MaximumLength = 0;


    //
    // Assume that this isn't a logon request.  If we manage to fail before
    // we've determined it's a logon attempt, we won't mark it as a failed
    // logon.
    //

    RequestBody = &RequestMessage->request_body;

    //
    // There are many options that are invalid for an AS ticket.
    //

    KdcOptions = KerbConvertFlagsToUlong(&RequestBody->kdc_options);

    //
    // Start event tracing (capture error cases too)
    //
#ifdef KDC_WMI_TRACING
    if (KdcEventTraceFlag){

        ASEventTraceInfo.EventTrace.Guid = KdcGetASTicketGuid;
        ASEventTraceInfo.EventTrace.Class.Type = EVENT_TRACE_TYPE_START;
        ASEventTraceInfo.EventTrace.Flags = WNODE_FLAG_TRACED_GUID;
        ASEventTraceInfo.EventTrace.Size = sizeof (EVENT_TRACE_HEADER) + sizeof (ULONG);
        ASEventTraceInfo.KdcOptions = KdcOptions;

        TraceEvent(
            KdcTraceLoggerHandle,
            (PEVENT_TRACE_HEADER)&ASEventTraceInfo
            );
    }
#endif

    if (KdcOptions &
        (KERB_KDC_OPTIONS_forwarded |
         KERB_KDC_OPTIONS_proxy |
         KERB_KDC_OPTIONS_unused7 |
         KERB_KDC_OPTIONS_unused9 |
         KERB_KDC_OPTIONS_renew |
         KERB_KDC_OPTIONS_validate |
         KERB_KDC_OPTIONS_reserved |
         KERB_KDC_OPTIONS_enc_tkt_in_skey ) )
    {
        KerbErr = KDC_ERR_BADOPTION;
        goto Cleanup;
    }

    if (( RequestBody->bit_mask & addresses_present ) &&
        ( RequestBody->addresses == NULL ))
    {
        KerbErr = KDC_ERR_BADOPTION;
        goto Cleanup;
    }

    //
    // Make sure a client name was supplied
    //


    if ((RequestBody->bit_mask & KERB_KDC_REQUEST_BODY_client_name_present) != 0)
    {
        KerbErr = KerbConvertPrincipalNameToKdcName(
                    &ClientName,
                    &RequestBody->KERB_KDC_REQUEST_BODY_client_name
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
        KerbErr = KerbConvertKdcNameToString(
                    &ClientStringName,
                    ClientName,
                    NULL
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }
    else
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x) No principal name supplied to AS request - not allowed\n",
                  KLIN(FILENO,__LINE__)));
        KerbErr = KDC_ERR_C_PRINCIPAL_UNKNOWN;
        goto Cleanup;
    }


    //
    // Copy out the service name. This is not an optional field.
    //

    if ((RequestBody->bit_mask & KERB_KDC_REQUEST_BODY_server_name_present) == 0)
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x) Client %wZ sent AS request with no server name\n",
                  KLIN(FILENO,__LINE__),
                  &ClientStringName));
        FILL_EXT_ERROR(pExtendedError, STATUS_KDC_INVALID_REQUEST, FILENO, __LINE__);
        KerbErr = KDC_ERR_BADOPTION;
        goto Cleanup;
    }

    KerbErr = KerbConvertPrincipalNameToKdcName(
                &ServerName,
                &RequestBody->KERB_KDC_REQUEST_BODY_server_name
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = KerbConvertKdcNameToString(
                &ServerStringName,
                ServerName,
                NULL
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Check if the client said to canonicalize the name
    //

    if ((KdcOptions & KERB_KDC_OPTIONS_name_canonicalize) != 0)
    {
        NameFlags |= KDC_KDB_GET_PRINC_CANONICALIZE;
    }

    D_DebugLog((DEB_TRACE, "Getting an AS ticket to "));
    D_KerbPrintKdcName( DEB_TRACE, ServerName );
    D_DebugLog((DEB_TRACE, "\tfor " ));
    D_KerbPrintKdcName( DEB_TRACE, ClientName );

    KerbErr = KdbRealmLocate(RequestRealm, &piKdb);
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"KLIN(%x) Failed to locate handle for realm %wZ",
                  KLIN(FILENO,__LINE__), &RequestRealm));
        goto Cleanup;
    }

    KdbPerfCount(piKdb, KerbKdcAsReqCounter);

    KerbErr = piKdb->GetPrincipal(
                 NameFlags | KDC_KDB_GET_PRINC_CLIENT | KDC_KDB_GET_PRINC_FOLLOW_REFERRALS,
                 ClientName,
                 RequestRealm->Buffer,
                 &KdcReq,
                 &ClientInfo,
                 pExtendedError,
                 &ReferralRealm
                 );

    // Store principal regardless of whether an error occurred. Our Xbox ASKDC 
    // hangs logging data off the principal object. It's weird, but since it 
    // does all its work in GetPrincipal(), it makes some sense.
    KdcReq.m_piClientPrincipal = ClientInfo;

    if (!KERB_SUCCESS(KerbErr))
    {
        //
        // The Xbox KDC has co-opted the KDC_ERR_PREAUTH_REQUIRED and made it an expected 
        // error code, for the echo preauth system in the ASKDC. So let's not spew stuff 
        // in that case.
        //
        if (KerbErr == KDC_ERR_PREAUTH_REQUIRED)
        {
            goto Cleanup;
        }

        //
        //  Do AS-referral if KerbErr == KDC_ERR_WRONG_REALM
        //
        if (KerbErr == KDC_ERR_WRONG_REALM)
        {
            DsysAssert(NameFlags & KDC_KDB_GET_PRINC_CANONICALIZE);
            DsysAssert(ReferralRealm);
            TRACE_FILELINE(TRACE_ERR,
                        (FILE_AND_LINE, L"Failed to get client name but doing a referral")
                        );
            DebugLog((DEB_ERROR,"KLIN(%x) Failed to get client name but doing a referral",KLIN(FILENO,__LINE__)));

            KerbErr = KerbDuplicateStringEx(
                          ClientRealm,
                          ReferralRealm,
                          FALSE
                          );

            if ( !KERB_SUCCESS( KerbErr ))
            {
                goto Cleanup;
            }
        }
        else
        {
            TRACE_FILELINE(TRACE_ERR,
                        (FILE_AND_LINE, L"Failed to get client name")
                        );
            DebugLog((DEB_ERROR,"KLIN(%x) Failed to get client name ",KLIN(FILENO,__LINE__)));
        }
        KerbPrintKdcName(DEB_ERROR,ClientName);
        goto Cleanup;
    }

    //
    //  fill in the req. struct. Ultimately, get rid
    //  of the local vars
    //
    KdcReq.m_pETypes           = (PKERB_CRYPT_LIST)(RequestBody->encryption_type);

    KerbErr = KerbDuplicateStringEx(
                  ClientRealm,
                  ClientInfo->GetRealm(),
                  FALSE
                  );

    if ( !KERB_SUCCESS( KerbErr ))
    {
        goto Cleanup;
    }

    KerbErr = KerbConvertUnicodeStringToRealm(
                  &ClientRealmName,
                  ClientRealm
                  );

    if ( !KERB_SUCCESS( KerbErr ))
    {
        goto Cleanup;
    }

    //
    //  client keys are not accessible anymore
    //

    //
    // Setup some reasonable defaults for expiry
    //
    //  all info is in the principal. No need to carry extra stuff
    //    AccountExpiry = ClientInfo->Expiration;

    KerbErr = KerbProcessPaCompoundIdentity(&KdcReq, pExtendedError);
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;

    }

    //
    // Unpack the pre-auth data.
    //

    KerbErr = KdcCheckPreAuthData(
                 piKdb,
                 KerbAs,
                 ClientInfo,
                 RequestMessage->KERB_KDC_REQUEST_preauth_data,
                 RequestBody,
                 &PreAuthType,
                 &OutputPreAuthData,
                 &EncryptionKey,
                 &TransitedRealm,
                 pExtendedError,
                 &KdcReq
                 );

    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KdbAuditEvent(
                    piKdb,
                    PreauthFailure,
                    (PIKerbRequest)&KdcReq,
                    &KerbErr,
                    &KdcOptions,
                    NULL,
                    &PreAuthType,
                    ClientAddress
                    );

        if (NT_SUCCESS(Status))
        {
            AuditedFailure = TRUE;
        }

        //
        // Only handle failed logon if pre-auth fails. Otherwise the error
        // was something the client couldn't control, such as memory
        // allocation or clock skew.
        //
        if (KerbErr == KDC_ERR_PREAUTH_FAILED)
        {
            FailedLogon(
                piKdb,
                ClientInfo,
                ClientAddress,
                pExtendedError
                );
        }
        LoggedFailure = TRUE;
        DebugLog((DEB_ERROR,"KLIN(%x) Failed to check pre-auth data: 0x%x\n",
                  KLIN(FILENO,__LINE__), KerbErr));
        goto Cleanup;
    }

    //
    // Figure out who the ticket is for. First break the name into
    // a local name and a referral realm
    //

    //
    //  Note:   We don't allow referrals here, because we should only get AS
    //          requests for our realm, and the krbtgt\server should always be
    //          in our realm.

    KerbErr = piKdb->GetPrincipal(
                 NameFlags | KDC_KDB_GET_PRINC_SERVER,
                 ServerName,
                 RequestRealm->Buffer,
                 &KdcReq,
                 &ServiceInfo,
                 pExtendedError,
                 NULL
                 );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"KLIN(%x) Failed to get principal 0x%x ",
                  KLIN(FILENO,__LINE__), KerbErr ));
        KerbPrintKdcName(DEB_ERROR, ServerName);
        goto Cleanup;
    }
    KdcReq.m_piServerPrincipal = ServiceInfo;

    //
    // Check KDB ticket restrictions - unless you are requesting a ticket
    // to yourself.
    //

    if (!KerbEqualKdcNames(ClientName, ServerName))
    {
        if (ServiceInfo->GetPrincFlags() & KERB_KDB_DISALLOW_SVR)
        {
            KerbErr = KDC_ERR_SVC_UNAVAILABLE;

            DebugLog((DEB_ERROR,"KLIN(%x) Service principal not allowed ",
                      KLIN(FILENO,__LINE__), KerbErr ));
            KerbPrintKdcName(DEB_ERROR, ServerName);
            goto Cleanup;
        }

        if (ServiceInfo->GetPrincFlags() & KERB_KDB_REQUIRE_USER2USER)
        {
            KerbErr = KDC_ERR_MUST_USE_USER2USER;

            DebugLog((DEB_ERROR,"KLIN(%x) Service principal requires user2user ",
                      KLIN(FILENO,__LINE__), KerbErr ));
            KerbPrintKdcName(DEB_ERROR, ServerName);
            goto Cleanup;
        }
    }

#if 0
    //  core does not deal with principal keys any more
    //
    // Find a common crypto system.  Do it now in case we need
    // to return the password for a service.
    //
    if (EncryptionKey.keyvalue.value == NULL)
    {
        KerbErr = KerbFindCommonCryptSystem(
                    RequestBody->encryption_type,
                    ClientInfo->Keys,
                    NULL, //ServiceInfo.Keys,
                    &ClientEType,
                    &ClientKey
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            KdcReportKeyError(
                KdbHandle,
                ClientInfo->Princ,
                ClientInfo->Realm,
                NULL,
                NULL,
                KDCEVENT_NO_KEY_UNION_AS,
                RequestBody->encryption_type,
                ClientInfo->Keys
                );

            DebugLog((DEB_ERROR,"KLIN(%x) Failed to find common ETYPE: 0x%x\n",
                      KLIN(FILENO,__LINE__),KerbErr));
            goto Cleanup;
        }
    }
    else
    {
        //
        // BUG 453284: this doesn't take into account the service ticket
        // info. If the PKINIT code generated a key that the service
        // doesn't suport, this key may not be usable by the client &
        // server. However, in the pkinit code it is hard to know what
        // types the server supports.
        //

        ClientEType = EncryptionKey.keytype;
    }
    KdcReq.m_ulCommonEType = ClientEType;
    //
    // Get the etype to use for the ticket itself from the server's
    // list of keys
    //

    KerbErr = KerbFindCommonCryptSystem(
                RequestBody->encryption_type,
                ServiceInfo->Keys,
                NULL,   // no additional passwords
                &CommonEType,
                &ServerKey
                );


    if (!KERB_SUCCESS(KerbErr))
    {
        KdcReportKeyError(
            KdbHandle,
            ServiceInfo->Princ,
            ServiceInfo->Realm,
            NULL,
            NULL,
            KDCEVENT_NO_KEY_UNION_AS,
            RequestBody->encryption_type,
            ServiceInfo->Keys
            );

        DebugLog((DEB_ERROR,"KLIN(%x) Failed to find common ETYPE: 0x%x\n",
                  KLIN(FILENO,__LINE__), KerbErr));
        goto Cleanup;
    }
#endif

    //
    // We need to save the full domain name of the service regardless
    // of whether it was provided or not. This is so name changes
    // can be detected. Instead of creating a mess of trying to figure out
    // which deallocator to use, allocate new memory and copy data.
    //

    KerbErr = BuildTicketAS(
                &KdcReq,
                piKdb,
                &ClientRealmName,
                (PreAuthType != 0),
                &TransitedRealm,
                &Ticket,
                pExtendedError
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_WARN , "KLIN(%x) Failed to build AS ticket: 0x%x\n",
                  KLIN(FILENO,__LINE__),KerbErr));
        goto Cleanup;
    }
    //  save the (to be) encrypted tgt part
    KdcReq.m_pEncTicket = &EncryptedTicket;
    //  and common etype
    KdcReq.m_ulCommonEType = EncryptedTicket.key.keytype;

    //
    // Return any authorization data for the ticket
    //

    AuthData = NULL;    // authdata starts out clean for AS

    //
    //  build auth data to return in the ticket
    //
    KerbErr = KdcReturnAuthData(
                 &KdcReq,
                 &AuthData,
                 pExtendedError);


    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x) Failed to return auth data : 0x%x\n",
                    KLIN(FILENO,__LINE__),KerbErr));
        goto Cleanup;
    }

    //
    // Stick the auth data into the AS ticket
    //

    if (AuthData)
    {
        EncryptedTicket.KERB_ENCRYPTED_TICKET_authorization_data = AuthData;
        EncryptedTicket.bit_mask |= KERB_ENCRYPTED_TICKET_authorization_data_present;
        AuthData = NULL;        // Leak??
    }

    //
    // Now build the reply
    //

    KerbErr = BuildReply(
                ClientInfo,
                RequestBody->nonce,
                &Ticket.server_name,
                Ticket.realm,
                ((RequestBody->bit_mask & addresses_present) != 0) ? RequestBody->addresses : NULL,
                &Ticket,
                &ReplyBody
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Now build the real reply and return it.
    //

    Reply.version = KERBEROS_VERSION;
    Reply.message_type = KRB_AS_REP;
    Reply.KERB_KDC_REPLY_preauth_data = NULL;
    Reply.bit_mask = 0;

    Reply.client_realm = EncryptedTicket.client_realm;

    //
    // Return any PA-DATA (like pw-salt)
    //

    KerbErr = KdcReturnPreAuthData(
                 &KdcReq,
                 &OutputPreAuthData
                 );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    if (OutputPreAuthData != NULL)
    {
        Reply.bit_mask |= KERB_KDC_REPLY_preauth_data_present;
        Reply.KERB_KDC_REPLY_preauth_data = (PKERB_REPLY_PA_DATA_LIST) OutputPreAuthData;

        //
        // Zero this out so we don't free the preauth data twice
        //

        OutputPreAuthData = NULL;
    }


    //
    // Copy in the ticket
    //

    KerbErr = KerbPackTicket(
                &KdcReq,
                &Ticket,
                ServiceInfo,
                RequestBody->encryption_type,    // use to figure out enc type
                &Reply.ticket,
                pExtendedError
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x) Failed to pack ticket: 0x%x\n",
                  KLIN(FILENO,__LINE__), KerbErr));
        goto Cleanup;
    }

    //
    // Note: these are freed elsewhere, so zero them out after
    // using them
    //

    Reply.client_name = EncryptedTicket.client_name;

    //
    // Copy in the encrypted part
    //

    KerbErr = KerbPackKdcReplyBody(
                &KdcReq,
                &ReplyBody,
                //  pass the client info if there's no session key to use
                &EncryptionKey,
                ClientInfo,
                //  no key version for session keys
                //  version for client key will come from the principal
//                (EncryptionKey.keyvalue.value != NULL) ? KERB_NO_KEY_VERSION : ClientKey->KeyVersion,
                RequestBody->encryption_type, // chose etype of using client
                Pdu,
                &Reply.encrypted_part,
                pExtendedError
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x) Failed to pack KDC reply body: 0x%x\n",
                  KLIN(FILENO,__LINE__), KerbErr));
        goto Cleanup;
    }

    Status = KdbAuditEvent(
        piKdb,
        AsTicket,
        (PIKerbRequest)&KdcReq,
        &KerbErr,
        &KdcOptions,
        NULL,
        &PreAuthType,
        ClientAddress
        );

    if (!NT_SUCCESS(Status))
        {
            LoggedFailure = TRUE;
            KerbErr = KDC_ERR_CLIENT_REVOKED;
            goto Cleanup;
        }

    //
    // Pack the reply
    //

    KerbErr = KerbPackData(
                &Reply,
                ReplyPdu,
                &OutputMessage->BufferSize,
                &OutputMessage->Buffer
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }


Cleanup:

    if (!KERB_SUCCESS(KerbErr))
    {
        DsysAssert(RequestBody != NULL);

        if (!AuditedFailure)
        {
            KdbAuditEvent(
                piKdb,
                AsFailure,
                (PIKerbRequest)&KdcReq,
                &KerbErr,
                &KdcOptions,
                NULL,
                NULL,
                ClientAddress
                );
        }

        //
        // If there was any preauth data to return, pack it for return now.
        //

        if (OutputPreAuthData != NULL)
        {
            if (ErrorData->Buffer != NULL)
            {
                D_DebugLog((DEB_ERROR,
                          "KLIN(%x) Freeing return error data to return preauth data\n",
                          KLIN(FILENO,__LINE__)));
                MIDL_user_free(ErrorData->Buffer);
                ErrorData->Buffer = NULL;
                ErrorData->BufferSize = 0;
            }

            (VOID) KerbPackData(
                    &OutputPreAuthData,
                    PKERB_PREAUTH_DATA_LIST_PDU,
                    &ErrorData->BufferSize,
                    &ErrorData->Buffer
                    );
        }

    }

    if (piKdb && (ClientInfo != NULL))
    {
        if (!KERB_SUCCESS(KerbErr))
        {
            // XXX Call krb-error hook

            if (!LoggedFailure && KerbErr == KDC_ERR_PREAUTH_FAILED)
            {
                FailedLogon(
                    piKdb,
                    ClientInfo,
                    ClientAddress,
                    pExtendedError
                    );
            }
        }
        else
        {
            SuccessfulLogon(
                piKdb,
                ClientInfo,
                ClientAddress,
                pExtendedError
                );
        }
    }

    //
    // Complete the WMI event
    //
#ifdef KDC_WMI_TRACING

    if (KdcEventTraceFlag){

        //These variables point to either a unicode string struct containing
        //the corresponding string or a pointer to KdcNullString

        PUNICODE_STRING pStringToCopy;
        WCHAR   UnicodeNullChar = 0;
        UNICODE_STRING UnicodeEmptyString = {sizeof(WCHAR),sizeof(WCHAR),&UnicodeNullChar};

        ASEventTraceInfo.EventTrace.Class.Type = EVENT_TRACE_TYPE_END;
        ASEventTraceInfo.EventTrace.Flags = WNODE_FLAG_USE_MOF_PTR |
                                            WNODE_FLAG_TRACED_GUID;

        // Always output error code.  KdcOptions was captured on the start event

        ASEventTraceInfo.eventInfo[0].DataPtr = (ULONGLONG) &KerbErr;
        ASEventTraceInfo.eventInfo[0].Length  = sizeof(ULONG);
        ASEventTraceInfo.EventTrace.Size =
            sizeof (EVENT_TRACE_HEADER) + sizeof(MOF_FIELD);

        // Build counted MOF strings from the unicode strings

        if (ClientStringName.Buffer != NULL &&
            ClientStringName.Length > 0)
        {
            pStringToCopy = &ClientStringName;
        }
        else {
            pStringToCopy = &UnicodeEmptyString;
        }

        ASEventTraceInfo.eventInfo[1].DataPtr =
            (ULONGLONG) &pStringToCopy->Length;
        ASEventTraceInfo.eventInfo[1].Length  =
            sizeof(pStringToCopy->Length);
        ASEventTraceInfo.eventInfo[2].DataPtr =
            (ULONGLONG) pStringToCopy->Buffer;
        ASEventTraceInfo.eventInfo[2].Length =
            pStringToCopy->Length;
        ASEventTraceInfo.EventTrace.Size += sizeof(MOF_FIELD)*2;


        if (ServerStringName.Buffer != NULL &&
            ServerStringName.Length > 0)
        {
            pStringToCopy = &ServerStringName;
        }
        else
        {
            pStringToCopy = &UnicodeEmptyString;
        }


        ASEventTraceInfo.eventInfo[3].DataPtr =
            (ULONGLONG) &pStringToCopy->Length;
        ASEventTraceInfo.eventInfo[3].Length  =
            sizeof(pStringToCopy->Length);
        ASEventTraceInfo.eventInfo[4].DataPtr =
            (ULONGLONG) pStringToCopy->Buffer;
        ASEventTraceInfo.eventInfo[4].Length =
            pStringToCopy->Length;
        ASEventTraceInfo.EventTrace.Size += sizeof(MOF_FIELD)*2;


        if (RequestRealm->Buffer != NULL &&
            RequestRealm->Length > 0)
        {
            pStringToCopy = RequestRealm;
        }
        else
        {
            pStringToCopy = &UnicodeEmptyString;
        }

        ASEventTraceInfo.eventInfo[5].DataPtr =
            (ULONGLONG) &(pStringToCopy->Length);
        ASEventTraceInfo.eventInfo[5].Length  =
            sizeof(pStringToCopy->Length);
        ASEventTraceInfo.eventInfo[6].DataPtr =
            (ULONGLONG) (pStringToCopy->Buffer);
        ASEventTraceInfo.eventInfo[6].Length =
            (pStringToCopy->Length);
        ASEventTraceInfo.EventTrace.Size += sizeof(MOF_FIELD)*2;


        TraceEvent(
            KdcTraceLoggerHandle,
            (PEVENT_TRACE_HEADER)&ASEventTraceInfo
            );
    }
#endif
    //  principals are deleted in the req.
    //  ultimately get rid of teh local vars
    if (ClientInfo)
    {
//        ClientInfo->Release();
    }
    if (ServiceInfo  && !KdcReq.m_piServerPrincipal)
    {
        ServiceInfo->Release();
    }
    KerbFreeAuthData( AuthData );
    KdcFreeInternalTicket( &Ticket );
    KerbFreeKey( &EncryptionKey );
    KerbFreeKdcName( &ClientName );
    KerbFreeString( &ClientStringName );
    KerbFreeString( &TransitedRealm );
    KerbFreeString( &ServerStringName );
    KerbFreeKdcName( &ServerName );
    KdcFreeKdcReplyBody( &ReplyBody );
    KdcFreeKdcReply( &Reply );
    KerbFreePreAuthData( OutputPreAuthData );
    KerbFreeRealm(&ClientRealmName);

    if (ReferralRealm)
        MIDL_user_free(ReferralRealm);


    //  destructor takes care of CKdcRequest


    D_DebugLog(( DEB_TRACE, "I_GetASTicket() returning 0x%x\n", KerbErr ));

    return KerbErr;
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcGetTicket
//
//  Synopsis:   Generic ticket getting entrypoint to get a ticket from the KDC
//
//  Effects:
//
//  Arguments:  IN Context       - ATQ context - only present for TCP/IP callers
//              IN ClientAddress - Client's IP addresses. Only present for UDP & TPC callers
//              IN ServerAddress - address the client used to contact this KDC.
//                      Only present for UDP & TPC callers
//              IN InputMessage  - the input KDC request message, in ASN.1 format
//              OUT OutputMessage - Receives the KDC reply message, allocated by
//                  the KDC.
//
//  Requires:
//
//  Returns:
//
//  Notes:      This routine is exported from the DLL and called from the
//              client dll.
//
//
//--------------------------------------------------------------------------

extern "C"
KERBERR
NTAPI
KdcGetTicket(
    IN OPTIONAL PVOID Context,
    IN OPTIONAL PSOCKADDR ClientAddress,
    IN OPTIONAL PSOCKADDR ServerAddress,
    IN PKERB_MESSAGE_BUFFER InputMessage,
    OUT PKERB_MESSAGE_BUFFER OutputMessage
    )
{
    KERBERR KerbErr;
    KERB_EXT_ERROR  ExtendedError = {0,0};
    PKERB_EXT_ERROR pExtendedError = &ExtendedError; // needed for macro
    PKERB_KDC_REQUEST RequestMessage = NULL;
    KERB_KDC_REPLY ReplyMessage = {0};
    KERB_MESSAGE_BUFFER ErrorData = {0};
    ULONG InputPdu = KERB_TGS_REQUEST_PDU;
    ULONG OutputPdu = KERB_TGS_REPLY_PDU;
    ULONG InnerPdu = KERB_ENCRYPTED_TGS_REPLY_PDU;
    UNICODE_STRING RequestRealm = {0};
    PKERB_INTERNAL_NAME RequestServer = NULL;
    UNICODE_STRING ClientRealm = {0};
    PUNICODE_STRING ExtendedErrorServerRealm = NULL;
    PKERB_INTERNAL_NAME ExtendedErrorServerName = NULL;

#if DBG
    DWORD StartTime = 0;
#endif

    InitializeTlsPerRequest();
    TRACER(L"KdcGetTicket", (PVOID *) &KerbErr);
    TRACE_FILELINE(TRACE_VERB, ( FILE_AND_LINE, L"Entered KdcGetTicket"));

    //
    // Make sure we are allowed to execute
    //

    if (!NT_SUCCESS(EnterApiCall()))
    {
        return(KDC_ERR_NOT_RUNNING);
    }

    ZeroMemory(
        &ReplyMessage,
        sizeof(KERB_KDC_REPLY)
        );

    //
    // First initialize the return parameters.
    //

    OutputMessage->Buffer = NULL;
    OutputMessage->BufferSize = 0;

    //
    // Check the first byte of the message to indicate the type of message
    //

    if ((InputMessage->BufferSize > 0) && (
        (InputMessage->Buffer[0] & KERB_BER_APPLICATION_TAG) != 0))
    {
        if ((InputMessage->Buffer[0] & KERB_BER_APPLICATION_MASK) == KERB_AS_REQ_TAG)
        {
            InputPdu = KERB_AS_REQUEST_PDU;
            OutputPdu = KERB_AS_REPLY_PDU;
            InnerPdu = KERB_ENCRYPTED_AS_REPLY_PDU;
        }
        else if ((InputMessage->Buffer[0] & KERB_BER_APPLICATION_MASK) != KERB_TGS_REQ_TAG)
        {
        TRACE_FILELINE(TRACE_ERR, ( FILE_AND_LINE, L"Bad message sent to KDC - not AS or TGS request\n"));
            D_DebugLog((DEB_T_SOCK,
                      "KLIN(%x) Bad message sent to KDC - not AS or TGS request\n",
                      KLIN(FILENO,__LINE__)));

            KerbErr = KRB_ERR_FIELD_TOOLONG;
            goto NoMsgCleanup;
        }
    }
    else
    {
        TRACE_FILELINE(TRACE_ERR, ( FILE_AND_LINE, L"Bad message sent to KDC - length too short or bad first byte\n"));
        D_DebugLog((DEB_T_SOCK,"KLIN(%x) Bad message sent to KDC - length to short or bad first byte\n",
                  KLIN(FILENO,__LINE__)));
        KerbErr = KRB_ERR_FIELD_TOOLONG;
        goto NoMsgCleanup;

    }

    //
    // First decode the input message
    //

    KerbErr = (KERBERR) KerbUnpackData(
                            InputMessage->Buffer,
                            InputMessage->BufferSize,
                            InputPdu,
                            (PVOID *) &RequestMessage
                            );

    if (KerbErr == KDC_ERR_MORE_DATA || !KERB_SUCCESS(KerbErr))
    {
        //  ERR_MORE_DATA is unacceptable at this point.
        //  the transport layer guarantees the whole packet is received
        D_DebugLog((DEB_ERROR,"KLIN(%x) Failed to unpack KDC request: 0x%x\n",
                  KLIN(FILENO,__LINE__),KerbErr));

        //
        // We don't want to return an error on a badly formed
        // packet,as it can be used to set up a flood attack
        //

        goto NoMsgCleanup;
    }

    //
    // First check the version of the request.
    //

    if (RequestMessage->version != KERBEROS_VERSION)
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x) Bad request version: 0x%x\n",
                  KLIN(FILENO,__LINE__), RequestMessage->version));
        //
        //  We don't want to return an error when a bad version is encountered.
        //  This adheres to MIT version.
        //
        KerbErr = KDC_ERR_NONE;
        goto NoMsgCleanup;
    }

    //
    // now call the internal version to do all the hard work
    //

    //
    // Verify the realm name in the request
    //

    KerbErr = KerbConvertRealmToUnicodeString(
                  &RequestRealm,
                  &RequestMessage->request_body.realm
                  );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    if (RequestMessage->request_body.bit_mask & KERB_KDC_REQUEST_BODY_server_name_present)
    {
        KerbErr = KerbConvertPrincipalNameToKdcName(
                      &RequestServer,
                      &RequestMessage->request_body.server_name
                      );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }
    else if (RequestMessage->message_type != KRB_TGS_REQ)
    {
        //  missing server name allowed only for TGS
        KerbErr = KDC_ERR_S_PRINCIPAL_UNKNOWN;
        goto    Cleanup;
    }

    //
    // Now that we have the request realm and request server, any subsequent
    // error will result in those values being placed into the extended error
    //

    ExtendedErrorServerRealm = &RequestRealm;
    ExtendedErrorServerName = RequestServer;

    if (RequestMessage->message_type == KRB_AS_REQ)
    {
        if (InputPdu != KERB_AS_REQUEST_PDU) {
            KerbErr = KRB_ERR_FIELD_TOOLONG;
            FILL_EXT_ERROR(pExtendedError, STATUS_KDC_INVALID_REQUEST,FILENO,__LINE__);
            goto Cleanup;
        }

        //
        // If WMI event tracing is enabled, notify it of the begin and end
        // of the ticket request
        //

#if DBG
        StartTime = GetTickCount();
#endif

        KerbErr = I_GetASTicket(
                      ClientAddress,
                      RequestMessage,
                      &RequestRealm,
                      InnerPdu,
                      OutputPdu,
                      InputMessage,
                      OutputMessage,
                      &ErrorData,
                      &ExtendedError,
                      &ClientRealm
                      );
#if DBG
        D_DebugLog((DEB_T_PERF_STATS, "I_GetASTicket took %d m seconds\n", NetpDcElapsedTime(StartTime)));
#endif
        TRACE_FILELINE(TRACE_VERB, (FILE_AND_LINE,
                                        L"I_GetASTicket returned with 0x%x", KerbErr)
                                    );
    }
    else if (RequestMessage->message_type == KRB_TGS_REQ)
    {

#if DBG
        StartTime = GetTickCount();
#endif

        KerbErr = HandleTGSRequest(
                      ClientAddress,
                      RequestMessage,
                      &RequestRealm,
                      OutputMessage,
                      &ExtendedError
                      );
#if DBG
        D_DebugLog((DEB_T_PERF_STATS, "HandleTGSRequest took %d m seconds\n", NetpDcElapsedTime(StartTime)));
#endif
        }
    else
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x) Invalid message type: %d\n",
                  KLIN(FILENO,__LINE__),
                  RequestMessage->message_type));
        FILL_EXT_ERROR(pExtendedError, STATUS_KDC_INVALID_REQUEST,FILENO,__LINE__);
        KerbErr = KRB_AP_ERR_MSG_TYPE;
        goto Cleanup;
    }


    //
    // If the response is too big and we are using UDP, make the client
    // change transports. We can tell the caller is UDP because it doesn't
    // have an ATQ context but it does provide the client address.
    //

    if ((Context == NULL) && (ClientAddress != NULL))
    {
        if (OutputMessage->BufferSize >= KERB_MAX_KDC_RESPONSE_SIZE)
        {
            D_DebugLog((DEB_WARN,"KLIN(%x) KDC response too big for UDP: %d bytes\n",
                      KLIN(FILENO,__LINE__), OutputMessage->BufferSize ));
            TRACE_FILELINE(TRACE_ERR,
                                            (FILE_AND_LINE,
                                            L"KDC response too big for UDP: %d bytes",
                                            OutputMessage->BufferSize
                                            )
                                        );
            KerbErr = KRB_ERR_RESPONSE_TOO_BIG;
            MIDL_user_free(OutputMessage->Buffer);
            OutputMessage->Buffer = NULL;
            OutputMessage->BufferSize = 0;
        }
    }

Cleanup:

    // TBD:  Put in extended error return goo here for client
    //
    // If the KerbErr is KDC_ERR_MORE_DATA, we don't want to return anything. This is a 
    // malformed packet that *should* never be received since we use UDP and all packets 
    // should be complete. Fuzzers or hackers may generate this error, though, and rather 
    // than put in a bajillion checks elsewhere, we're just putting the check in here.

    if (!KERB_SUCCESS(KerbErr) && KerbErr != KDC_ERR_MORE_DATA)
    {
        //
        // We may have a message built by someone else - the PDC
        //
        if (OutputMessage->Buffer == NULL)
        {
#ifdef XBOX_KDC
            DWORD SaveBufferSize = ErrorData.BufferSize;
            BYTE* SaveBuffer = ErrorData.Buffer;
            
            if (RequestMessage)
            {
                ErrorData.Buffer = (PUCHAR)&(RequestMessage->request_body.nonce);
                ErrorData.BufferSize = sizeof(RequestMessage->request_body.nonce);
            }
#endif
            KerbBuildErrorMessageEx(
                KerbErr,
                &ExtendedError,
                ExtendedErrorServerRealm,
                ExtendedErrorServerName,
                &ClientRealm,
                ErrorData.Buffer,
                ErrorData.BufferSize,
                &OutputMessage->BufferSize,
                &OutputMessage->Buffer
                );
#ifdef XBOX_KDC
            ErrorData.BufferSize = SaveBufferSize;
            ErrorData.Buffer = SaveBuffer;
#endif
        }
     }

NoMsgCleanup:

    KerbFreeString(&RequestRealm);
    MIDL_user_free(RequestServer);

    KerbFreeString(&ClientRealm);

    if (RequestMessage != NULL)
    {
        KerbFreeData(InputPdu,RequestMessage);
    }

    if (ErrorData.Buffer != NULL)
    {
        MIDL_user_free(ErrorData.Buffer);
    }
    LeaveApiCall();



  //PTRACE_INFO_BLOCK newBlock = (PTRACE_INFO_BLOCK)TlsGetValue(g_TraceTlsIndex);
    //LocalFree(newBlock);
    return(KerbErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\server\kdcmem.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2001 - 2002
//
// File:        KDCMEM.CXX
//
// Contents:    KDC memory management interfaces
//
//------------------------------------------------------------------------

#include "kdcsvr.hxx"
#include "kdcmem.hxx"

//
// Memory management functions (NULL unless overloaded by a custom memory manager)
//

PFN_KDC_MEM_INIT g_pfnKdcMemInit = NULL;
PFN_KDC_MEM_SHUTDOWN g_pfnKdcMemShutdown = NULL;
PFN_KDC_MEM_ALLOCATE g_pfnKdcMemAllocate = NULL;
PFN_KDC_MEM_REALLOC g_pfnKdcMemRealloc = NULL;
PFN_KDC_MEM_FREE g_pfnKdcMemFree = NULL;

//
// Handle to the custom memory management DLL
//

HMODULE g_hMemoryManagerLib;


//+-------------------------------------------------------------------------
//
//  Function:   KdcInitializeMemoryManager
//
//  Synopsis:   Initializes the custom memory manager if appropriate
//              From Registry:
//                  HKLM\CurrentControlSet\Services\KDC\Parameters\Static\MemoryManagerDll
//                  Which should be a value of type REG_SZ
//              Or passed in form provider (pszMemMgr)
//              The DLL should expose five entry points:
//                  o InitializeMemoryManager
//                  o ShutdownMemoryManager
//                  o AllocateMemory
//                  o ReallocateMemory
//                  o FreeMemory
//
//              If any other error occurs during initialization, the deafult
//              memory manager will be used.
//
//              This routine must be called first thing during service startup,
//              before any memory management activity has taken place.
//
//  Effects:    All subsequent memory operations will be performed using
//              the loaded memory manager
//
//  Arguments:  hInstance   instance of the process being initialized
//                      pszMemMgr - full path of the memory manger dll if any.
//
//  Returns:    TRUE or FALSE; caller can call GetLastError() to get
//              the reason for failure if FALSE is returned
//
//  Notes:      A default memory manager will be used if this routine fails;
//              The caller need not fail initialization in that case.
//
//--------------------------------------------------------------------------

BOOL
KdcInitializeMemoryManager(
    IN IKdcCore  *pIKdcCore,
    IN LPWSTR  pszMemMgr
    )
{
    DWORD       dwErr = ERROR_SUCCESS;
    NTSTATUS    Status = STATUS_SUCCESS;
    BOOL        fDoSetLastErr = TRUE;

    //
    //  if null, TRY to find it from reg.
    //  Since the mem. mgr is OPTIONAL, failure to locate the registry value is NOT an error
    //  condition
    //
    if(!pszMemMgr)
    {
        HKEY hKey;
        DWORD dwType;
        WCHAR Buffer[MAX_PATH];
        DWORD dwSize= sizeof( Buffer );

        //
        // The name of the memory manager DLL is under
        // HKLM\System\CurrentControlSet\Services\KDC\Parameters\Static\MemoryManagerDll
        //

        dwErr = RegOpenKeyW(
                    HKEY_LOCAL_MACHINE,
                    L"System\\CurrentControlSet\\Services\\KDC\\Parameters\\Static",
                    &hKey
                    );

        if ( dwErr != ERROR_SUCCESS ) {
            //
            //  Memory manager not specified in registry either
            //  Use default in this case
            //
            dwErr = ERROR_SUCCESS;
            goto Cleanup;
        }

        dwErr = RegQueryValueExW(
                    hKey,
                    L"MemoryManagerDll",
                    NULL,
                    &dwType,
                    ( LPBYTE )Buffer,
                    &dwSize
                    );

        RegCloseKey(hKey);

        if ( dwErr != ERROR_SUCCESS ) {

            dwErr = ERROR_SUCCESS;
            goto Cleanup;

        } else if ( dwType != REG_SZ ) {

            dwErr = ERROR_INVALID_PARAMETER;
            goto Error;
        }
        pszMemMgr = Buffer;
    }

    if (!pszMemMgr)
        goto Cleanup;

    g_hMemoryManagerLib = LoadLibraryW((LPCWSTR)pszMemMgr);
    if ( g_hMemoryManagerLib == NULL )
    {
        dwErr = GetLastError();
        goto Error;
    }

    g_pfnKdcMemInit = ( PFN_KDC_MEM_INIT )GetProcAddress( g_hMemoryManagerLib, "InitializeMemoryManager" );
    g_pfnKdcMemShutdown = ( PFN_KDC_MEM_SHUTDOWN )GetProcAddress( g_hMemoryManagerLib, "ShutdownMemoryManager" );
    g_pfnKdcMemAllocate = ( PFN_KDC_MEM_ALLOCATE )GetProcAddress( g_hMemoryManagerLib, "AllocateMemory" );
    g_pfnKdcMemRealloc = ( PFN_KDC_MEM_REALLOC )GetProcAddress( g_hMemoryManagerLib, "ReallocateMemory" );
    g_pfnKdcMemFree = ( PFN_KDC_MEM_FREE )GetProcAddress( g_hMemoryManagerLib, "FreeMemory" );

    if ( g_pfnKdcMemInit == NULL ||
         g_pfnKdcMemShutdown == NULL ||
         g_pfnKdcMemAllocate == NULL ||
         g_pfnKdcMemRealloc == NULL ||
         g_pfnKdcMemFree == NULL )
    {
        dwErr = ERROR_PROC_NOT_FOUND;
        goto Error;
    }

    //
    //  InitializeMemoryMemory( ) will return STATUS_RESOURCE_REQUIREMENTS_CHANGED if
    //  the default memory manager should be used, i.e., InitializeMemoryMemory( ) has
    //  decided, perhaps from its configuration, that its dll should be unloaded and the
    //  default manager be used.
    //
    Status = g_pfnKdcMemInit(pIKdcCore);
    if (STATUS_RESOURCE_REQUIREMENTS_CHANGED == Status)
    {
        //
        //  Shuts down the memory manager, free library and clear global pointers.
        //  But we are returning OK for the core to continue with service startup.
        //
        dwErr = ERROR_SUCCESS;
        goto Error;
    }

    if (!NT_SUCCESS(Status))
    {
        // g_pfnKdcMemInit is expected to have set last error in this case
        fDoSetLastErr = FALSE;
        goto Error;
    }
    else
    {
        dwErr = ERROR_SUCCESS;
    }


Cleanup:

    return ( dwErr == ERROR_SUCCESS );

Error:

    KdcShutdownMemoryManager( );

    if (fDoSetLastErr)
    {
        SetLastError( dwErr );
    }
    goto Cleanup;
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcShutdownMemoryManager
//
//  Synopsis:   Terminates the memory manager.  Can only be called as part
//              of application shutdown, after all memory management activity
//              has ceased.
//
//  Effects:    Sets all global memory management functions to NULL
//              Unloads the custom memory manager DLL
//
//  Arguments:  hInstance           instance being shut down
//
//  Returns:    Nothing
//
//  Notes:
//
//--------------------------------------------------------------------------

void
KdcShutdownMemoryManager(
    )
{
    if ( g_pfnKdcMemShutdown ) {

        g_pfnKdcMemShutdown( );
    }

    g_pfnKdcMemInit = NULL;
    g_pfnKdcMemShutdown = NULL;
    g_pfnKdcMemAllocate = NULL;
    g_pfnKdcMemRealloc = NULL;
    g_pfnKdcMemFree = NULL;

    if ( g_hMemoryManagerLib ) {

        FreeLibrary( g_hMemoryManagerLib );
        g_hMemoryManagerLib = NULL;
    }

    return;
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcAllocMemory
//
//  Synopsis:   Allocates a block of memory, using either the default allocator
//              or the loaded custom memory manager
//
//  Effects:
//
//  Arguments:  Size        size of block to allocate
//
//  Returns:    Address of allocated block of memory or NULL if out of memory
//
//  Notes:
//
//--------------------------------------------------------------------------

extern "C"
void *
WINAPI
KdcAllocMemory(
    IN size_t Size
    )
{
    if ( !g_pfnKdcMemAllocate ) {

        return HeapAlloc(
                   GetProcessHeap(),
                   0, // do not zeroinit
                   Size
                   );

    } else {

        return g_pfnKdcMemAllocate( Size );
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcReallocMemory
//
//  Synopsis:   Reallocates a block of memory to a new size
//
//  Effects:
//
//  Arguments:  Address     address of an existing block to reallocate
//              Size        new size of the block
//
//  Returns:    Address of allocated block of memory or NULL if out of memory
//
//  Notes:      Address parameter must not be NULL, it must be allocated
//              with KdcAllocateMemory
//
//--------------------------------------------------------------------------

extern "C"
void *
WINAPI
KdcReallocMemory(
    IN void * Address,
    IN size_t Size
    )
{
    if ( !g_pfnKdcMemRealloc ) {

        //
        // ISSUE-markpu-10/03/01
        // Should really stop zero-initializing allocated memory
        //

        return HeapReAlloc(
                   GetProcessHeap(),
                   0, // do not zeroinit
                   Address,
                   Size
                   );

    } else {

        return g_pfnKdcMemRealloc( Address, Size );
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcFreeMemory
//
//  Synopsis:   Frees a block of memory allocated with KdcAllocateMemory
//
//  Effects:
//
//  Arguments:  Address     address of a block to free
//
//  Returns:    Nothing
//
//  Notes:
//
//--------------------------------------------------------------------------

extern "C"
VOID
WINAPI
KdcFreeMemory(
    IN void * Address
    )
{
    if ( Address ) {

        if ( !g_pfnKdcMemFree ) {

            HeapFree(
                GetProcessHeap(),
                0,
                Address
                );

        } else {

            g_pfnKdcMemFree( Address );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\server\kdcext.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       kdcext.cxx
//
//  Contents:   KDC Extensions Support functions
//
//  Classes:
//
//  Functions:
//
//  History:    21-June-2001    JBrezak
//
//----------------------------------------------------------------------------

#include "kdcsvr.hxx"

//
// List for Context data
//
typedef struct _KDC_CONTEXT_LIST_ENTRY 
{
    LIST_ENTRY  Next;
    LONG        Id;
    KDC_CTX_FREE_FN FreeFn;
} KDC_CONTEXT_LIST_ENTRY, *PKDC_CONTEXT_LIST_ENTRY;

LIST_ENTRY KdcContextList;
LONG NextContextId = 0;
LONG CurrentContextCount = 0;

#define NO_CONTEXT_ID (-1)


CRWLock KdcContextListLock;
BOOLEAN KdcContextListInitialized = FALSE;

VOID KdcInitializeContextList(
    VOID
    )
{
    InitializeListHead(&KdcContextList);
    KdcContextListInitialized = TRUE;
}

//
// List for Pre-auth data handlers
//
typedef struct _KDC_PA_HANDLER_LIST_ENTRY 
{
    LIST_ENTRY  Next;
    LONG        Id;
    PKDC_PADATA_HANDLER Handler;
} KDC_PA_HANDLER_LIST_ENTRY, *PKDC_PA_HANDLER_LIST_ENTRY;


LIST_ENTRY KdcPAHandlerList;
BOOLEAN KdcPAHandlerListInitialized = FALSE;
CRWLock KdcPAHandlerListLock;

//
// List for auth data handlers
//
typedef struct _KDC_AD_HANDLER_LIST_ENTRY 
{
    LIST_ENTRY  Next;
    LONG        Id;
    PKDC_AD_HANDLER     Handler;
} KDC_AD_HANDLER_LIST_ENTRY, *PKDC_AD_HANDLER_LIST_ENTRY;


LIST_ENTRY KdcADHandlerList;
BOOLEAN KdcADHandlerListInitialized = FALSE;
CRWLock KdcADHandlerListLock;

//
// List for ticket ext handlers
//
typedef struct _KDC_TE_HANDLER_LIST_ENTRY 
{
    LIST_ENTRY  Next;
    LONG        Id;
    PKDC_TICKET_EXT_HANDLER     Handler;
} KDC_TE_HANDLER_LIST_ENTRY, *PKDC_TE_HANDLER_LIST_ENTRY;


LIST_ENTRY KdcTEHandlerList;
BOOLEAN KdcTEHandlerListInitialized = FALSE;
CRWLock KdcTEHandlerListLock;

//
// List for PAC handlers
//
typedef struct _KDC_PAC_HANDLER_LIST_ENTRY 
{
    LIST_ENTRY  Next;
    LONG        Id;
    PKDC_PAC_HANDLER     Handler;
} KDC_PAC_HANDLER_LIST_ENTRY, *PKDC_PAC_HANDLER_LIST_ENTRY;


LIST_ENTRY KdcPacHandlerList;
BOOLEAN KdcPacHandlerListInitialized = FALSE;
CRWLock KdcPacHandlerListLock;
LONG KdcPacHandlerCount = 0;

//
// Allocate and save a new Context
//
LONG
KdcAllocContextId(
    IN KDC_CTX_FREE_FN CtxFreeFn
    )
{
    PKDC_CONTEXT_LIST_ENTRY NewEntry = NULL;
    LONG Id = 0;
    
    if (!KdcContextListInitialized)
    {
        KdcInitializeContextList();
    }

    NewEntry = (PKDC_CONTEXT_LIST_ENTRY) MIDL_user_allocate(sizeof(KDC_CONTEXT_LIST_ENTRY));
    if (NewEntry == NULL) {
        Id = NO_CONTEXT_ID;
        goto Cleanup;
    }

    Id = NewEntry->Id = NextContextId;
    InterlockedIncrement(&NextContextId);
    NewEntry->FreeFn = CtxFreeFn;
    
    KdcContextListLock.WriteLock();
    InsertTailList(&KdcContextList, &NewEntry->Next);
    InterlockedIncrement(&CurrentContextCount);
    KdcContextListLock.WriteUnlock();

Cleanup:
    if (NewEntry && Id == NO_CONTEXT_ID)
    {
        MIDL_user_free(NewEntry);
    }

    return Id;
}

//
// Free and release a context
//
NTSTATUS
KdcFreeContextId(
    IN LONG Id
    )
{
    NTSTATUS Status = STATUS_NOT_FOUND;
    PLIST_ENTRY ListEntry;
    PKDC_CONTEXT_LIST_ENTRY Entry;

    if (Id == NO_CONTEXT_ID)
        return STATUS_SUCCESS;
    
    KdcContextListLock.ReadLock();

    for (ListEntry = KdcContextList.Flink;
         ListEntry && (ListEntry != &KdcContextList);
         ListEntry = ListEntry->Flink)
    {
        Entry = (PKDC_CONTEXT_LIST_ENTRY) CONTAINING_RECORD(ListEntry, KDC_CONTEXT_LIST_ENTRY, Next);

        if (Entry->Id == Id)
        {
            KdcContextListLock.ReadToWriteLock();

            RemoveEntryList(&Entry->Next);
            // Don't adjust NextContextID

            InterlockedDecrement(&CurrentContextCount);
            MIDL_user_free(Entry);

            Status = STATUS_SUCCESS;
            break;
        }
    }

    KdcContextListLock.ReadUnlock();
    
    return Status;
}

//
// Allocate a complete context state
//
NTSTATUS
KdcAllocContext(
    OUT PKDC_REQUEST_CONTEXT *Context
    )
{
    PLIST_ENTRY ListEntry;
    PKDC_CONTEXT_LIST_ENTRY Entry;
    PKDC_REQUEST_CONTEXT RetContext;
    INT ReqContextSize = 0;
    INT Index = 0;
    
    if (!KdcContextListInitialized)
    {
        KdcInitializeContextList();
    }

    // Allocate the context blob

    ReqContextSize = sizeof(KDC_REQUEST_CONTEXT) + 
                        (sizeof(KDC_REQUEST_CTX_PRIVATE) *
                         (CurrentContextCount - ANYSIZE_ARRAY));

    RetContext = (PKDC_REQUEST_CONTEXT) MIDL_user_allocate(ReqContextSize);

    if (RetContext == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ZeroMemory(
        RetContext, 
        ReqContextSize
        );

    RetContext->NumberOfContexts = CurrentContextCount;
    
    // Setup return structure
    KdcContextListLock.ReadLock();
    for (ListEntry = KdcContextList.Flink;
         ListEntry && (ListEntry != &KdcContextList);
         ListEntry = ListEntry->Flink)
    {
        Entry = (PKDC_CONTEXT_LIST_ENTRY) CONTAINING_RECORD(ListEntry, KDC_CONTEXT_LIST_ENTRY, Next);

        RetContext->Contexts[Index].FreeFn = Entry->FreeFn;
        RetContext->Contexts[Index].Context = NULL;
        Index++;
    }
    KdcContextListLock.ReadUnlock();
    
    *Context = RetContext;
    
    return STATUS_SUCCESS;
}

//
// Free a context state - also call the deallocators if
//      any private data has been allocated
//
NTSTATUS
KdcFreeContext(
    IN PKDC_REQUEST_CONTEXT Context
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS FreeStatus;
    INT Index;
    
    for (Index = 0; Index < Context->NumberOfContexts; Index++)
    {
        if (Context->Contexts[Index].Context &&
            Context->Contexts[Index].FreeFn)
        {
            FreeStatus = Context->Contexts[Index].FreeFn(
                             &Context->Contexts[Index]
                             );
            if (!NT_SUCCESS(FreeStatus))
            {
                // Remember first error
                if (NT_SUCCESS(Status))
                    Status = FreeStatus;
            }
        }
    }
    MIDL_user_free(Context);    // Allocated as a blob
    
    return Status;
}

NTSTATUS
KdcAddContextData(
    IN PKDC_REQUEST_CONTEXT Context,
    IN LONG Id,
    IN PVOID Data
    )
{
    DsysAssert(Context->NumberOfContexts > Id);
    Context->Contexts[Id].Context = Data;

    return STATUS_SUCCESS;
}

//
// Helper functions for add/delete handlers
//
NTSTATUS
WINAPI
KdcAddPADataHandler(
    IN SHORT            NumberOfHandlers,
    IN PKDC_PADATA_HANDLER Handlers,
    OUT OPTIONAL LONG   *ContextIndex
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    LONG ContextId = NO_CONTEXT_ID;    
    INT i;
    PKDC_PA_HANDLER_LIST_ENTRY NewHandler;
    
    if (!KdcPAHandlerListInitialized)
    {
        InitializeListHead(&KdcPAHandlerList);
        KdcPAHandlerListInitialized = TRUE;
    }

    if (NumberOfHandlers == 0)
    {
        return STATUS_INVALID_PARAMETER;
    }
    
    // All handlers share the same context ID and free function
    // Note: Context ID is only allocated if needed. If omitted
    // There is no context data space reserved.
    if (ARGUMENT_PRESENT(ContextIndex))
    {
        ContextId = KdcAllocContextId(
                       Handlers[0].ctx_free
                       );
        if (ContextId == NO_CONTEXT_ID)
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    
    // Register the handlers
    for (i = 0; i < NumberOfHandlers; i++)
    {
        NewHandler = (PKDC_PA_HANDLER_LIST_ENTRY)
            MIDL_user_allocate(sizeof(KDC_PA_HANDLER_LIST_ENTRY));

        if (NewHandler == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        NewHandler->Id = ContextId;
        NewHandler->Handler = &Handlers[i];

        KdcPAHandlerListLock.WriteLock();
        InsertTailList(&KdcPAHandlerList, &NewHandler->Next);
        KdcPAHandlerListLock.WriteUnlock();
    }
    
    if (ARGUMENT_PRESENT(ContextIndex))
    {
        *ContextIndex = ContextId;
    }

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        KdcFreeContextId(ContextId);
    }
    return Status;
}


NTSTATUS
WINAPI
KdcDeletePADataHandler(
    IN LONG ContextIndex
    )
{
    NTSTATUS Status = STATUS_NOT_FOUND;
    PLIST_ENTRY ListEntry;
    PKDC_PA_HANDLER_LIST_ENTRY Handler;
    BOOL WriteLock = FALSE ;
    
    KdcPAHandlerListLock.ReadLock();
    for (ListEntry = KdcPAHandlerList.Flink;
         ListEntry && (ListEntry != &KdcPAHandlerList);
         ListEntry = ListEntry->Flink)
    {
        Handler = (PKDC_PA_HANDLER_LIST_ENTRY) CONTAINING_RECORD(ListEntry, KDC_PA_HANDLER_LIST_ENTRY, Next);

        if (Handler->Id == ContextIndex)
        {
            KdcPAHandlerListLock.ReadToWriteLock();
            WriteLock = TRUE ;
            RemoveEntryList(&Handler->Next);
            MIDL_user_free(Handler);
            Status = STATUS_SUCCESS;
            break;
        }
    }
    if ( !WriteLock )
    {
        KdcPAHandlerListLock.ReadUnlock();
        
    }
    else
    {
        KdcPAHandlerListLock.WriteUnlock();
    }
    
    return Status;
}

PKDC_PADATA_HANDLER
KdcLocatePADataHandler(
    IN DWORD PaType,
    IN BOOLEAN IsTgs
    )
{
    PLIST_ENTRY ListEntry;
    PKDC_PA_HANDLER_LIST_ENTRY HandlerEntry;
    PKDC_PADATA_HANDLER RetHandler = NULL;
    
    KdcPAHandlerListLock.ReadLock();
    for (ListEntry = KdcPAHandlerList.Flink;
         ListEntry && (ListEntry != &KdcPAHandlerList);
         ListEntry = ListEntry->Flink)
    {
        HandlerEntry = (PKDC_PA_HANDLER_LIST_ENTRY) CONTAINING_RECORD(ListEntry, KDC_PA_HANDLER_LIST_ENTRY, Next);

        if ((HandlerEntry->Handler->pa_type == PaType) &&
            (((HandlerEntry->Handler->pa_flags & KERB_PADATA_TGS) && IsTgs) ||
             ((HandlerEntry->Handler->pa_flags & KERB_PADATA_AS) && !IsTgs)))
        {
            RetHandler = HandlerEntry->Handler;
            break;
        }
    }
    KdcPAHandlerListLock.ReadUnlock();
    
    return RetHandler;
}

//
// Iterate over each registered PA handler can call the supplied
// function with the supplied data
//

KERBERR
KdcIteratePADataHandler(
    IN KDB_HANDLE Kdb,
    IN KERB_SERVICE_ID ServiceId,
    IN PKDB_PRINC_INFO ClientPrinc,
    IN OPTIONAL PKDB_PRINC_INFO ServicePrinc,
    IN PKERB_KDC_REQUEST_BODY Request,
    IN CONST ULONG PreAuthType,
    IN OPTIONAL PKERB_ENCRYPTION_KEY SessionKey,
    IN OPTIONAL PKERB_ENCRYPTION_KEY ServiceKey,
    IN OUT PKDC_REQUEST_CONTEXT ReqContext,
    IN KDC_PADATA_ITERATE_FN Func,
    IN OUT PVOID Data
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PLIST_ENTRY ListEntry;
    PKDC_PA_HANDLER_LIST_ENTRY HandlerEntry;
    
    KdcPAHandlerListLock.ReadLock();
    for (ListEntry = KdcPAHandlerList.Flink;
         ListEntry && (ListEntry != &KdcPAHandlerList);
         ListEntry = ListEntry->Flink)
    {
        HandlerEntry = (PKDC_PA_HANDLER_LIST_ENTRY) CONTAINING_RECORD(ListEntry, KDC_PA_HANDLER_LIST_ENTRY, Next);

        // Call holding PA-DATA lock
        KerbErr = (*Func)(
                      Kdb,
                      ServiceId,
                      ClientPrinc,
                      ServicePrinc,
                      Request,
                      PreAuthType,
                      SessionKey,
                      ServiceKey,
                      ReqContext,
                      HandlerEntry->Handler,
                      Data
                      );
        
        if (!KERB_SUCCESS(KerbErr))
        {
            break;
        }
    }
    KdcPAHandlerListLock.ReadUnlock();
    
    return KerbErr;
}


NTSTATUS
WINAPI
KdcAddADHandler(
    IN SHORT            NumberOfHandlers,
    IN PKDC_AD_HANDLER  Handlers,
    OUT LONG            *ContextIndex
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    LONG ContextId = NO_CONTEXT_ID;    
    INT i;
    PKDC_AD_HANDLER_LIST_ENTRY NewHandler;
    
    if (!KdcADHandlerListInitialized)
    {
        InitializeListHead(&KdcADHandlerList);
        KdcADHandlerListInitialized = TRUE;
    }

    if (NumberOfHandlers == 0)
    {
        return STATUS_INVALID_PARAMETER;
    }
    
    // All handlers share the same context ID and free function
    // Note: Context ID is only allocated if needed. If omitted
    // There is no context data space reserved.
    if (ARGUMENT_PRESENT(ContextIndex))
    {
        ContextId = KdcAllocContextId(
                       Handlers[0].ctx_free
                       );
        if (ContextId == NO_CONTEXT_ID)
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    
    // Register the handlers
    for (i = 0; i < NumberOfHandlers; i++)
    {
        NewHandler = (PKDC_AD_HANDLER_LIST_ENTRY)
            MIDL_user_allocate(sizeof(KDC_AD_HANDLER_LIST_ENTRY));

        if (NewHandler == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        NewHandler->Id = ContextId;
        NewHandler->Handler = &Handlers[i];

        KdcADHandlerListLock.WriteLock();
        InsertTailList(&KdcADHandlerList, &NewHandler->Next);
        KdcADHandlerListLock.WriteUnlock();
    }
    
    if (ARGUMENT_PRESENT(ContextIndex))
    {
        *ContextIndex = ContextId;
    }

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        KdcFreeContextId(ContextId);
    }
    return Status;
}


NTSTATUS
WINAPI
KdcDeleteADHandler(
    IN LONG ContextIndex
    )
{
    NTSTATUS Status = STATUS_NOT_FOUND;
    PLIST_ENTRY ListEntry;
    PKDC_AD_HANDLER_LIST_ENTRY Handler;
    BOOL WriteLock = FALSE ;
    
    KdcADHandlerListLock.ReadLock();
    for (ListEntry = KdcADHandlerList.Flink;
         ListEntry && (ListEntry != &KdcADHandlerList);
         ListEntry = ListEntry->Flink)
    {
        Handler = (PKDC_AD_HANDLER_LIST_ENTRY) CONTAINING_RECORD(ListEntry, KDC_AD_HANDLER_LIST_ENTRY, Next);

        if (Handler->Id == ContextIndex)
        {
            KdcADHandlerListLock.ReadToWriteLock();
            WriteLock = TRUE ;
            RemoveEntryList(&Handler->Next);
            MIDL_user_free(Handler);
            Status = STATUS_SUCCESS;
            break;
        }
    }

    if ( !WriteLock )
    {
        KdcADHandlerListLock.ReadUnlock();
        
    }
    else 
    {
        KdcADHandlerListLock.WriteUnlock();
    }
    
    return Status;
}

//
// Iterate over each registered PA handler can call the supplied
// function with the supplied data
//

KERBERR
KdcIterateAuthDataHandler(
    IN KDB_HANDLE		KdbHandle,
    IN KERB_SERVICE_ID		Service,
    IN PKDB_PRINC_INFO		ClientInfo,
    IN PKDB_PRINC_INFO		ServiceInfo,
    IN PKERB_KDC_REQUEST_BODY	RequestBody,
    IN CONST ULONG    		PreAuthType,
    IN PKERB_ENCRYPTION_KEY	SessionKey,
    IN PKERB_ENCRYPTION_KEY 	OldServiceKey,
    IN PKERB_ENCRYPTION_KEY 	NewServiceKey,
    IN OUT PKERB_ENCRYPTED_TICKET EncryptedTicket,
    OUT PKERB_EXT_ERROR         ExtendedError,
    IN OUT PKDC_REQUEST_CONTEXT ReqContext,
    IN KDC_AD_ITERATE_FN        Func,
    IN OUT PVOID                Data
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PLIST_ENTRY ListEntry;
    PKDC_AD_HANDLER_LIST_ENTRY HandlerEntry;
    
    KdcADHandlerListLock.ReadLock();
    for (ListEntry = KdcADHandlerList.Flink;
         ListEntry && (ListEntry != &KdcADHandlerList);
         ListEntry = ListEntry->Flink)
    {
        HandlerEntry = (PKDC_AD_HANDLER_LIST_ENTRY) CONTAINING_RECORD(ListEntry, KDC_AD_HANDLER_LIST_ENTRY, Next);

        // Called holding AUTHDATA lock
        KerbErr = (*Func)(
                      KdbHandle,
                      Service,
                      ClientInfo,
                      ServiceInfo,
                      RequestBody,
                      PreAuthType,
                      SessionKey,
                      OldServiceKey,
                      NewServiceKey,
                      EncryptedTicket,
                      ExtendedError,
                      ReqContext,
                      HandlerEntry->Handler,
                      Data
                      );
        
        if (!KERB_SUCCESS(KerbErr))
        {
            break;
        }
    }
    KdcADHandlerListLock.ReadUnlock();
    
    return KerbErr;
}

NTSTATUS
WINAPI
KdcAddPacHandler(
    IN SHORT            NumberOfHandlers,
    IN PKDC_PAC_HANDLER  Handlers,
    OUT LONG            *ContextIndex
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    LONG ContextId = NO_CONTEXT_ID;    
    INT i;
    PKDC_PAC_HANDLER_LIST_ENTRY NewHandler;
    
    if (!KdcPacHandlerListInitialized)
    {
        InitializeListHead(&KdcPacHandlerList);
        KdcPacHandlerListInitialized = TRUE;
    }

    if (NumberOfHandlers == 0)
    {
        return STATUS_INVALID_PARAMETER;
    }
    
    // All handlers share the same context ID and free function
    // Note: Context ID is only allocated if needed. If omitted
    // There is no context data space reserved.
    if (ARGUMENT_PRESENT(ContextIndex))
    {
        ContextId = KdcAllocContextId(
                       Handlers[0].ctx_free
                       );
        if (ContextId == NO_CONTEXT_ID)
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    
    // Register the handlers
    for (i = 0; i < NumberOfHandlers; i++)
    {
        NewHandler = (PKDC_PAC_HANDLER_LIST_ENTRY)
            MIDL_user_allocate(sizeof(KDC_PAC_HANDLER_LIST_ENTRY));

        if (NewHandler == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        NewHandler->Id = ContextId;
        NewHandler->Handler = &Handlers[i];

        KdcPacHandlerListLock.WriteLock();
        InsertTailList(&KdcPacHandlerList, &NewHandler->Next);
        InterlockedIncrement(&KdcPacHandlerCount);
        KdcPacHandlerListLock.WriteUnlock();
    }
    
    if (ARGUMENT_PRESENT(ContextIndex))
    {
        *ContextIndex = ContextId;
    }

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        KdcFreeContextId(ContextId);
    }
    return Status;
}


NTSTATUS
WINAPI
KdcDeletePacHandler(
    IN LONG ContextIndex
    )
{
    NTSTATUS Status = STATUS_NOT_FOUND;
    PLIST_ENTRY ListEntry;
    PKDC_PAC_HANDLER_LIST_ENTRY Handler;
    BOOL WriteLock = FALSE ;
    
    KdcPacHandlerListLock.ReadLock();
    for (ListEntry = KdcPacHandlerList.Flink;
         ListEntry && (ListEntry != &KdcPacHandlerList);
         ListEntry = ListEntry->Flink)
    {
        Handler = (PKDC_PAC_HANDLER_LIST_ENTRY) CONTAINING_RECORD(ListEntry, KDC_PAC_HANDLER_LIST_ENTRY, Next);

        if (Handler->Id == ContextIndex)
        {
            KdcPacHandlerListLock.ReadToWriteLock();
            WriteLock = TRUE ;
            RemoveEntryList(&Handler->Next);
            MIDL_user_free(Handler);
            InterlockedDecrement(&KdcPacHandlerCount);
            Status = STATUS_SUCCESS;
            break;
        }
    }

    if ( !WriteLock )
    {
        KdcPacHandlerListLock.ReadUnlock();
        
    }
    else 
    {
        KdcPacHandlerListLock.WriteUnlock();
    }

    
    return Status;
}

//
// Iterate over each registered Pac handler can call the supplied
// function with the supplied data
//

KERBERR
KdcIteratePacHandler(
    IN KDB_HANDLE               KdbHandle,
    IN PKDB_PRINC_INFO          User,
    IN BOOLEAN                  IsUpdate,
    IN PKERB_ENCRYPTED_TICKET   EncryptedTicket,
    IN OPTIONAL PKERB_ENCRYPTION_KEY CredentialKey,
    OUT PPAC_INFO_BUFFER        *Info,
    OUT PKERB_EXT_ERROR         pExtendedError,
    IN OUT PKDC_REQUEST_CONTEXT ReqContext,
    IN KDC_PAC_ITERATE_FN       Func,
    IN OUT PVOID                Data
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PLIST_ENTRY ListEntry;
    PKDC_PAC_HANDLER_LIST_ENTRY HandlerEntry;
    
    KdcPacHandlerListLock.ReadLock();
    for (ListEntry = KdcPacHandlerList.Flink;
         ListEntry && (ListEntry != &KdcPacHandlerList);
         ListEntry = ListEntry->Flink)
    {
        HandlerEntry = (PKDC_PAC_HANDLER_LIST_ENTRY) CONTAINING_RECORD(ListEntry, KDC_PAC_HANDLER_LIST_ENTRY, Next);

        // Called holding PAC lock
        KerbErr = (*Func)(
                      KdbHandle,
                      User,
                      IsUpdate,
                      EncryptedTicket,
                      CredentialKey,
                      Info,
                      pExtendedError,
                      ReqContext,
                      HandlerEntry->Handler,
                      Data
                      );
        
        if (!KERB_SUCCESS(KerbErr))
        {
            break;
        }
    }
    KdcPacHandlerListLock.ReadUnlock();
    
    return KerbErr;
}


INT
KdcNumberOfPacHandlers(
    VOID
    )
{
    return KdcPacHandlerCount;
}


NTSTATUS
WINAPI
KdcAddTicketExtHandler(
    IN SHORT            num_handlers,
    IN PKDC_TICKET_EXT_HANDLER handlers,
    OUT LONG            *ContextHandleIndex
    )
{
    return STATUS_SUCCESS;
}


NTSTATUS
WINAPI
KdcDeleteTicketExtHandler(
    IN LONG ContextHandleIndex
    )
{
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\server\pacint.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       pacint.h
//
//  Contents:   KDC pacint function interfaces
//
//  Classes:
//
//  Functions:
//
//  History:    19-July-2001    JBrezak
//
//----------------------------------------------------------------------------

#ifndef _PACINT_H_
#define _PACINT_H_

NTSTATUS
KdcInitializeInternalPacHandlers(
    VOID
    );

//
typedef KERBERR (*KDC_PAC_ITERATE_FN) (
    IN PIKdbProvider            piKdb,
    IN PIKerbPrincipal              User,
    IN BOOLEAN                  IsUpdate,
    IN PKERB_ENCRYPTED_TICKET   EncryptedTicket,
    IN OPTIONAL PKERB_ENCRYPTION_KEY CredentialKey,
    OUT PPAC_INFO_BUFFER        *Info,
    OUT PKERB_EXT_ERROR         pExtendedError,
    IN CKerbRequest*            pReq,
    IN PIPACHandler             pHandler,
    IN OUT PVOID                pData
    );

KERBERR
KdcIteratePacHandler(
    IN PIKdbProvider            pKdb,
    IN PIKerbPrincipal              User,
    IN BOOLEAN                  IsUpdate,
    IN PKERB_ENCRYPTED_TICKET   EncryptedTicket,
    IN OPTIONAL PKERB_ENCRYPTION_KEY CredentialKey,
    OUT PPAC_INFO_BUFFER        *Info,
    OUT PKERB_EXT_ERROR         pExtendedError,
    IN CKerbRequest*            pReq,
    IN KDC_PAC_ITERATE_FN       Func,
    IN OUT PVOID                Data
    );


INT
KdcNumberOfPacHandlers(
    VOID
    );

#endif // _PACINT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\server\midluser.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       midluser.cxx
//
//  Contents:   KDC core memory allocation routines
//
//  Classes:
//
//  Functions:
//
//  History:    17-August-2001    JBrezak
//
//----------------------------------------------------------------------------

#include "kdcsvr.hxx"

void * __RPC_USER
MIDL_user_allocate(size_t size)
{
//    TRACE(KDC, MIDL_user_allocate, DEB_FUNCTION);

    PVOID pvMem;

    //
    // The ASN.1 marshalling code may allocate odd sizes that can't be
    // encrypted with a block cipher. By rounding up the size to 8 we can
    // handle block sizes up to 8 bytes.
    //

    pvMem = KdcAllocMemory(
                ROUND_UP_COUNT(size,8)
                );

    if ( pvMem == NULL )
    {
        DebugLog((DEB_ERROR, "MIDL allocate failed\n"));
    }
    else
    {
        ZeroMemory(pvMem, ROUND_UP_COUNT(size,8));
    }

    return(pvMem);


}

void __RPC_USER
MIDL_user_free(void * ptr)
{
//    TRACE(KDC, MIDL_user_free, DEB_FUNCTION);

    KdcFreeMemory( ptr );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\server\pachandlers.cxx ===
//+-----------------------------------------------------------------------
//
// File:        pachandlers.cxx
//
// Contents:    KDC core internal PAC handlers
//
//
// History:     13-Aug-2001   yordanr   Created.
//              22-Jul-2011   splante   Updated for Xbox Identity
//------------------------------------------------------------------------

#include "kdcsvr.hxx"

//
//  pac interface ...
//
#include "pac.hxx"
#define DEFINE_GUIDS
#include "pacext.h"

#include "kerbinterface.h"
#include "kerbhelper.h"
#include "pachandlers.hxx"

//
// Xbox Identity
// 
CPACHandlerXboxIdentity::CPACHandlerXboxIdentity()
{
}

CPACHandlerXboxIdentity::~CPACHandlerXboxIdentity()
{
}

KERBERR
__stdcall
CPACHandlerXboxIdentity::AddClientPrincipal(
    IN  IKerbRequest    *pIKerbRequest,
    OUT PXBOX_IDENTITY   pXboxIdentity,
    OUT BOOL            *pbIdentityPresent
    )
/*++

Routine Description:

    Query the current principal for identity information and
    use id to build the XBOX_IDENTITY

Arguments:

    pIKerbRequest     - Where to find the current principal
    PXboxIdentity     - Current Xbox Identity
    pbIdentityPresent - Where or not hte Xbox Identity was modified

Return Value:

    KERBERR

--*/
{
    HRESULT         hr;
    IKerbPrincipal *pIPrincClient  = NULL;
    IKDBLogonInfo  *pIKdbLogonInfo = NULL;
    KERBERR         kerbErr        = KDC_ERR_NONE;
    NTSTATUS        status         = STATUS_SUCCESS;
    PCIDENTITY      pIdentityInfo  = NULL;

    //
    // Assume that we won't find anything
    // 
    *pbIdentityPresent = FALSE;

    //
    // Get the principal client so that we can figure out
    // what the main identity will be
    // 
    pIPrincClient = pIKerbRequest->GetIPrincClient();
    if (NULL == pIPrincClient)
    {
        status = STATUS_INVALID_PARAMETER_3;
        goto Cleanup;
    }

    //
    // Get the main identity from the client principal
    //
    hr = pIPrincClient->QueryInterface(
        IID_IKDBLogonInfo, 
        (PVOID*)&pIKdbLogonInfo
        );
    if (S_OK != hr || NULL == pIKdbLogonInfo)
    {
        status = STATUS_INVALID_USER_BUFFER;
        goto Cleanup;
    }

    status = pIKdbLogonInfo->GetIdentityInfo(&pIdentityInfo);
    if (NULL == pIdentityInfo)
    {
        goto Cleanup;
    }

    // 
    // We have identity info, remember that
    // 
    *pbIdentityPresent = TRUE;

    //
    // Merge in the IDENTITY into the XBOX_IDENTITY
    // 
    if (pIdentityInfo->IdentityAttributes == IA_MACHINE) 
    {
        pXboxIdentity->MachineIdentity           = * (ULONGLONG *) pIdentityInfo->Identity;
        pXboxIdentity->MachineIdentityCredential =   (BYTE)        pIdentityInfo->CredentialIdType;
    }
    else
    {
        // Find the next available slot
        for (DWORD i = 0; i < XBOX_IDENTITY_MAX_USERS; ++i) 
        {
            if (pXboxIdentity->UserIdentity[i] == 0) 
            {
                pXboxIdentity->UserIdentity[i]           = * (ULONGLONG *) pIdentityInfo->Identity;
                pXboxIdentity->UserIdentityCredential[i] =   (BYTE)        pIdentityInfo->CredentialIdType;
                break;
            }
        }
    }

Cleanup:
    if ( !NT_SUCCESS(status) )
    {
        kerbErr = KRB_ERR_GENERIC;
    }
    return kerbErr;
}

KERBERR
__stdcall
CPACHandlerXboxIdentity::AddClientIdentity(
    IN  IKerbRequest    *pIKerbRequest,
    OUT PXBOX_IDENTITY   pXboxIdentity,
    OUT BOOL            *pbIdentityPresent
    )
/*++

Routine Description:

    Query the current request for identity information and
    use id to build the XBOX_IDENTITY.

    Translation: This copies in data from the PAC_COMPOUND_IDENTITY
    sent for the current request into the XBOX_IDENTITY for
    current request.

Arguments:

    pIKerbRequest     - Where to find the current client
    PXboxIdentity     - Current Xbox Identity
    pbIdentityPresent - Where or not hte Xbox Identity was modified

Return Value:

    KERBERR

--*/
{
    DWORD                i,j;
    HRESULT              hr;
    IPAIdentity         *pIPAIdentity   = NULL;
    KERBERR              kerbErr        = KDC_ERR_NONE;
    NTSTATUS             status         = STATUS_SUCCESS;
    const XBOX_IDENTITY *pXboxId        = NULL;
    XBOX_IDENTITY        tempIdentity;

    //
    // Assume that we won't find anything
    // 
    *pbIdentityPresent = FALSE;

    //
    // Get the current identity handler for this request
    //
    status = pIKerbRequest->GetPAHandler(IID_IPAIdentity, (PVOID*)&pIPAIdentity);
    if (!NT_SUCCESS(status) || NULL == pIPAIdentity)
    {
        goto Cleanup;
    }

    //
    // Get the current identity for this request
    // 
    status = pIPAIdentity->GetXboxIdentity( &pXboxId );
    if (!NT_SUCCESS(status) || NULL == pXboxId) 
    {
        goto Cleanup;
    }

    // 
    // We have identity info, remember that
    // 
    *pbIdentityPresent = TRUE;

    //
    // We are going to build a temporary identity. Start with a copy
    // of the new one
    // 
    memcpy( &tempIdentity, pXboxId, sizeof(XBOX_IDENTITY) );

    //
    // Copy over the machine identity if none is set
    // 
    if (pXboxIdentity->MachineIdentity != 0) 
    {
        if (tempIdentity.MachineIdentity == 0) 
        {
            tempIdentity.MachineIdentity           = pXboxIdentity->MachineIdentity;
            tempIdentity.MachineIdentityCredential = pXboxIdentity->MachineIdentityCredential;
        }
        else
        {
            status = STATUS_OBJECT_NAME_EXISTS;
            goto Cleanup;
        }
    }

    //
    // We already have the new identities in the structure. We did this
    // in order to make sure that the test code could find the identities
    // in the order that that it expects.
    // 
    // At this point, fill in all the identies that were passed into
    // the current request on a no-duplicates, no overwrites manner
    // 
    for (i = 0; i < XBOX_IDENTITY_MAX_USERS; ++i) 
    {
        if (pXboxIdentity->UserIdentity[i] == 0) 
        {
            continue;
        }

        for (j = 0; j < XBOX_IDENTITY_MAX_USERS; ++j) 
        {
            if (tempIdentity.UserIdentity[j] == pXboxIdentity->UserIdentity[i]) 
            {
                break;
            }
            if (tempIdentity.UserIdentity[j] != 0) 
            {
                continue;
            }
            tempIdentity.UserIdentity[j]           = pXboxIdentity->UserIdentity[i];
            tempIdentity.UserIdentityCredential[j] = pXboxIdentity->UserIdentityCredential[i];
            break;
        }

        //
        // Did we find a slot?
        // 
        if (j >= XBOX_IDENTITY_MAX_USERS) 
        {
            status = STATUS_TOO_MANY_NAMES;
            goto Cleanup;
        }
    }

    //
    // Copy the temp identity structure to the output
    // 
    memcpy( pXboxIdentity, &tempIdentity, sizeof(XBOX_IDENTITY) );

Cleanup:
    if (status == STATUS_OBJECT_NAME_EXISTS ||
        status == STATUS_TOO_MANY_NAMES) 
    {
        kerbErr = KDC_ERR_PREAUTH_FAILED;
    }
    else if ( !NT_SUCCESS(status) )
    {
        kerbErr = KRB_ERR_GENERIC;
    }
    return kerbErr;

}


KERBERR
__stdcall
CPACHandlerXboxIdentity::Build(
    IN  IKerbRequest     *pIKerbRequest,
    IN  BOOLEAN          fUpdatePac,
    OUT PPAC_INFO_BUFFER *ppPacInfo,
    OUT NTSTATUS         *pNTStatus
    )
{
    BOOL                 bHaveXboxIdentity   = FALSE;
    BOOL                 bHaveXboxPrincipal  = FALSE;
    KERBERR              kerbErr             = KDC_ERR_NONE;
    NTSTATUS             status              = STATUS_SUCCESS;
    PPAC_INFO_BUFFER     pPacInfoReturn      = NULL;
    ULONG                cbReturn            = 0;
    XBOX_IDENTITY        xboxIdentity        = { 0 };

    //
    // If we aren't updating the PAC, then we need to check for a client principal
    // 

    if (FALSE == fUpdatePac)
    {
        if (NULL != *ppPacInfo) 
        {
            //
            // We expected no previous pac. This is an error condition
            // from the old KDC code
            // 
            status = STATUS_INVALID_PARAMETER_3;
            goto Cleanup;
        }

        kerbErr = AddClientPrincipal( pIKerbRequest, &xboxIdentity, &bHaveXboxPrincipal );
        if (!KERB_SUCCESS(kerbErr))
        {
            status = STATUS_INVALID_PARAMETER_1;
            goto Cleanup;
        }
    }

    //
    // We expect an empty previous pac here, but it a do-nothing condition
    // 
    if (NULL != *ppPacInfo) 
    {
        goto Cleanup;
    }

    //
    // We probably have a client identity
    // 
    kerbErr = AddClientIdentity( pIKerbRequest, &xboxIdentity, &bHaveXboxIdentity );
    if (!KERB_SUCCESS(kerbErr)) 
    {
        status = STATUS_INVALID_PARAMETER_2;
        goto Cleanup;
    }

    //
    // Do we have an interesting identity?
    // 
    // The previous KDC code didn't return a failure for this
    // condition, so continue that trend
    // 
    if (FALSE == bHaveXboxIdentity &&
        FALSE == bHaveXboxPrincipal) 
    {
       goto Cleanup; 
    }

    //
    // Compute the size of the blob returned and allocate it
    //
    cbReturn       = sizeof(PAC_INFO_BUFFER) + sizeof(XBOX_IDENTITY);
    pPacInfoReturn = (PPAC_INFO_BUFFER) MIDL_user_allocate(cbReturn);
    if (NULL == pPacInfoReturn)
    {
        status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // Fill in the outer structure.  Encoded in little endian.
    //
    pPacInfoReturn->ulType       = PAC_XBOX_IDENTITY;
    pPacInfoReturn->cbBufferSize = cbReturn - sizeof(PAC_INFO_BUFFER);
    pPacInfoReturn->Data         = (PBYTE)(pPacInfoReturn + 1);

    //
    // Fill in the inner structure.
    // 
    memcpy( pPacInfoReturn->Data, &xboxIdentity, sizeof(XBOX_IDENTITY) );

    //
    // Let the caller know
    // 
    *ppPacInfo = pPacInfoReturn;
    pPacInfoReturn = NULL;

Cleanup:
    if (!NT_SUCCESS(status) && KERB_SUCCESS(kerbErr))
    {
        kerbErr = KRB_ERR_GENERIC;
    }

    *pNTStatus = status;

    if (pPacInfoReturn)
    {
        MIDL_user_free(pPacInfoReturn);
    }

    return kerbErr;
}

//
//  global PAC handlers
//
CPACHandlerXboxIdentity     g_PACHandlerXboxIdentity;
IPACHandler                *g_rgpIPACHandlers[] = {
    &g_PACHandlerXboxIdentity
    };

NTSTATUS
KdcInitializeInternalPacHandlers(
    VOID
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;
    TRACER(L"KdcInitializeInternalPacHandlers", (PVOID *) &Status);

    //
    //  register all PAC handlers
    //
    for (int i = 0;
         i < sizeof(g_rgpIPACHandlers)/sizeof(IPACHandler*);
         i++)
    {
        Status = KdcRegisterPACHandler(g_rgpIPACHandlers[i]);
        if (!NT_SUCCESS(Status))
        {
            break;
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\server\kdcreq.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       kdcext.cxx
//
//  Contents:   KDC Extensions Support functions
//
//  Classes:
//
//  Functions:
//
//  History:    21-June-2001    JBrezak
//              09-Sept-2001    yordanr - modified for new Kdc interface
//
//----------------------------------------------------------------------------

#include "kdcsvr.hxx"

#include "traceinterface.hxx"

//  handler factory lists
CKerbList KdcPAHandlerFactoryList;
CKerbList KdcADHandlerFactoryList;
extern IKerbCrypt   *g_piKerbCrypt;

#if 0   // add these later
//
// List for ticket ext handlers
//  add these as needed. unused for now (yordanr)
//
typedef struct _KDC_TE_HANDLER_LIST_ENTRY
{
    LIST_ENTRY  Next;
    LONG        Id;
    PKDC_TICKET_EXT_HANDLER     Handler;
} KDC_TE_HANDLER_LIST_ENTRY, *PKDC_TE_HANDLER_LIST_ENTRY;


LIST_ENTRY KdcTEHandlerList;
BOOLEAN KdcTEHandlerListInitialized = FALSE;
CRWLock KdcTEHandlerListLock;
#endif

//
// List for PAC handlers
//
CKerbList g_KdcPacHandlerList;


//
//  Create handler instances for the request
//
NTSTATUS CKerbRequest::CreateHandlerInstances()
{
    NTSTATUS    Status = STATUS_SUCCESS;

    if (KdcPAHandlerFactoryList.cElem > 0)
    {
        m_ppiPAHandlers = (PIPAHandler*)MIDL_user_allocate(KdcPAHandlerFactoryList.cElem *
                                                sizeof(IPAHandler*));
        if (m_ppiPAHandlers == NULL)
            return  STATUS_NO_MEMORY;
        memset(m_ppiPAHandlers,
               0,
               KdcPAHandlerFactoryList.cElem * sizeof(IPAHandler*));
    }
    if (KdcADHandlerFactoryList.cElem > 0)
    {
        m_ppiADHandlers = (IADHandler**)MIDL_user_allocate(KdcADHandlerFactoryList.cElem *
                                                sizeof(IADHandler*));
        if (m_ppiADHandlers == NULL)
            return  STATUS_NO_MEMORY;
        memset(m_ppiADHandlers,
               0,
               KdcADHandlerFactoryList.cElem * sizeof(IADHandler*));
    }
    //  walk the factory lists and instantiate handlers
    PLIST_ENTRY ListEntry;
    ULONG iha = 0;
    KdcPAHandlerFactoryList.Lock.ReadLock();
    for (ListEntry = KdcPAHandlerFactoryList.Head.Flink, iha = 0;
         ListEntry && (ListEntry != &KdcPAHandlerFactoryList.Head);
         ListEntry = ListEntry->Flink, iha++)
    {
        PKDC_LIST_ENTRY HandlerEntry =
            (PKDC_LIST_ENTRY) CONTAINING_RECORD(ListEntry, KDC_LIST_ENTRY, Next);
        Status = ((IPAHandlerFactory*)HandlerEntry->pData)->
                CreateInstance(this, &m_ppiPAHandlers[iha]);
        if (Status != STATUS_SUCCESS)
            break;
    }
    KdcPAHandlerFactoryList.Lock.ReadUnlock();
    if (Status != STATUS_SUCCESS)
    {
        //  memory will be dealloc'd by destructor
        return  Status;
    }
    //
    //  alloc AD handlers as well
    //
    KdcADHandlerFactoryList.Lock.ReadLock();
    for (ListEntry = KdcADHandlerFactoryList.Head.Flink, iha = 0;
         ListEntry && (ListEntry != &KdcADHandlerFactoryList.Head);
         ListEntry = ListEntry->Flink, iha++)
    {
        PKDC_LIST_ENTRY pHandlerEntry =
            (PKDC_LIST_ENTRY) CONTAINING_RECORD(ListEntry, KDC_LIST_ENTRY, Next);
        Status = ((IADHandlerFactory*)pHandlerEntry->pData)->
                CreateInstance(this, &m_ppiADHandlers[iha]);
        if (Status != STATUS_SUCCESS)
            break;
    }
    KdcADHandlerFactoryList.Lock.ReadUnlock();

    return  Status;
}


//
//  Allocate a complete context state
//  A context is a list of AD and PA handler instances
//
NTSTATUS
KdcAllocContext(
    IN OUT CKerbRequest& Context
    )
{
    return  Context.CreateHandlerInstances();
}

//
//  should we expand this to allow for multiple handlers?
//
NTSTATUS WINAPI KdcRegisterPAHandlerFactory(
    // factory to create the IPAHandler
    IN  IPAHandlerFactory   *piPAHandlerFactory
    )
{
    if (piPAHandlerFactory == NULL)
        return  STATUS_INVALID_PARAMETER;
    PKDC_LIST_ENTRY pNewHandler = (PKDC_LIST_ENTRY)
        MIDL_user_allocate(sizeof(KDC_LIST_ENTRY));
    if (pNewHandler == NULL)
        return  STATUS_NO_MEMORY;
    pNewHandler->pData = (PVOID)piPAHandlerFactory;
    KdcPAHandlerFactoryList.InsertElement(&pNewHandler->Next);

    return  STATUS_SUCCESS;
}


//
//  clear the lists for the factories
//
void
WINAPI
KdcDeleteAllHandlerLists(
    )
{
    //  lists to clear
    CKerbList* pLists[] = {
            &KdcPAHandlerFactoryList,
            &KdcADHandlerFactoryList,
            &g_KdcPacHandlerList
                          };
    //
    //  loop thru all lists

    for (ULONG iList = 0; iList < sizeof(pLists)/sizeof(CKerbList*); iList++)
    {
        pLists[iList]->Lock.WriteLock();
        //  loop thru all list elements
        for (PLIST_ENTRY pNext = pLists[iList]->Head.Flink;
            pNext != NULL && pNext != &pLists[iList]->Head;
            )
        {
            //  get the ptr to delete
            PKDC_LIST_ENTRY pEntry =
                (PKDC_LIST_ENTRY)
                ((PBYTE)pNext - FIELD_OFFSET(KDC_LIST_ENTRY, Next));
            //  move to the next
            pNext = pNext->Flink;
            //  all elements are allocated with midl_user_xxx
            MIDL_user_free(pEntry);
        }
        //  finally reset the list
        InitializeListHead(&pLists[iList]->Head);
        pLists[iList]->cElem = 0;
        pLists[iList]->Lock.WriteUnlock();
    }
}


//
//  locate a handler of specific type
//
NTSTATUS __stdcall CKerbRequest::GetADHandler(REFIID intf, PVOID *ppv)
{
    IADHandler **iAD = m_ppiADHandlers;
    ULONG cHandlers = KdcADHandlerFactoryList.cElem;
    NTSTATUS Status = STATUS_NOT_FOUND;

    *ppv = NULL;
    while(cHandlers-- && *iAD)
    {
        if ((*iAD)->QueryInterface(intf, ppv) == S_OK)
        {
            Status = S_OK;
            break;
        }
        iAD++;
    }

    return  Status;
}
//
//  get AD handler by AD type
//
NTSTATUS __stdcall CKerbRequest::GetADHandler(ULONG ulADType, PIADHandler *pph)
{
    IADHandler **iAD = m_ppiADHandlers;
    ULONG cHandlers = KdcADHandlerFactoryList.cElem;
    NTSTATUS Status = STATUS_NOT_FOUND;

    *pph = NULL;
    while(cHandlers-- && *iAD)
    {
        if ((*iAD)->GetADType() == ulADType)
        {
            *pph = *iAD;
            Status = S_OK;
            break;
        }
        iAD++;
    }

    return  Status;
}

//
//  get PAC handler based on the PAC type
//
NTSTATUS __stdcall CKerbRequest::GetPACHandler(ULONG ulPacType, PIPACHandler *pph)
{
    NTSTATUS    Status = STATUS_NOT_FOUND;
    g_KdcPacHandlerList.Lock.ReadLock();
    for (PLIST_ENTRY ListEntry = g_KdcPacHandlerList.Head.Flink;
         ListEntry && (ListEntry != &g_KdcPacHandlerList.Head);
         ListEntry = ListEntry->Flink)
    {
        PKDC_LIST_ENTRY HandlerEntry =
            (PKDC_LIST_ENTRY) CONTAINING_RECORD(ListEntry, KDC_LIST_ENTRY, Next);

        if (((IPACHandler*)HandlerEntry->pData)->GetPacType() == ulPacType)
        {
            *pph = (IPACHandler*)HandlerEntry->pData;
            Status = STATUS_SUCCESS;
            break;
        }
    }
    g_KdcPacHandlerList.Lock.ReadUnlock();

    return  Status;
}

NTSTATUS __stdcall CKerbRequest::GetPAHandler(REFIID intf, PVOID *ppv)
{
    IPAHandler **iPA = m_ppiPAHandlers;
    ULONG cHandlers = KdcPAHandlerFactoryList.cElem;
    NTSTATUS Status = STATUS_NOT_FOUND;
    TRACER(L"CKerbRequest::GetPAHandler", (PVOID *) &Status);
    *ppv = NULL;
    while(cHandlers-- && *iPA)
    {
        if ((*iPA)->QueryInterface(intf, ppv) == S_OK)
        {
            Status = S_OK;
            break;
        }
        iPA++;
    }

    return  Status;
}
//
//  get specific PA handler type
//
NTSTATUS __stdcall CKerbRequest::GetPAHandler(ULONG ulPAType, IPAHandler **pph)
{
    IPAHandler **iPA = m_ppiPAHandlers;
    ULONG cHandlers = KdcPAHandlerFactoryList.cElem;
    NTSTATUS Status = STATUS_NOT_FOUND;
    TRACER(L"CKerbRequest::GetPAHandler", (PVOID *) &Status);

    *pph = NULL;
    while(cHandlers-- && *iPA)
    {
        if ((*iPA)->GetPAType() == ulPAType)
        {
            Status = S_OK;
            (*pph) = *iPA;
            break;
        }
        iPA++;
    }
    return  Status;
}




NTSTATUS WINAPI KdcRegisterADHandlerFactory(
        IN  IADHandlerFactory   *piADHandlerFactory   // factory to create the IADHandler
    )
{
    if (piADHandlerFactory == NULL)
        return  STATUS_INVALID_PARAMETER;
    PKDC_LIST_ENTRY pNewHandler = (PKDC_LIST_ENTRY)
        MIDL_user_allocate(sizeof(KDC_LIST_ENTRY));
    if (pNewHandler == NULL)
        return  STATUS_NO_MEMORY;
    pNewHandler->pData = (PVOID)piADHandlerFactory;
    KdcADHandlerFactoryList.InsertElement(&pNewHandler->Next);

    return  STATUS_SUCCESS;
}




//
//  PAC handlers are static. Registration is for a handler, not a factory
//
NTSTATUS
WINAPI
KdcRegisterPACHandler(
    IN IPACHandler      *piPacHandler
    )
{
    if (piPacHandler == NULL)
        return  STATUS_INVALID_PARAMETER;
    PKDC_LIST_ENTRY pNewHandler = (PKDC_LIST_ENTRY)
        MIDL_user_allocate(sizeof(KDC_LIST_ENTRY));
    if (pNewHandler == NULL)
        return  STATUS_NO_MEMORY;
    pNewHandler->pData = (PVOID)piPacHandler;
    g_KdcPacHandlerList.InsertElement(&pNewHandler->Next);

    return STATUS_SUCCESS;
}

//  global crypt interface
//  it is a bit more complicated, since a crypt is per provider ...
//  but how would extensions that do not have crypt acquire the intf?
//  for now it's ok cause there's a single crypt
IKerbCrypt * __stdcall KdcGetICrypt(void)
{
    return  g_piKerbCrypt;
}



#if 0
//  unused API. Replace with PAC enum if necessary
//
// Iterate over each registered Pac handler can call the supplied
// function with the supplied data
//
KERBERR
KdcIteratePacHandler(
    IN PIKdbProvider            piKdb,
    IN PIKerbPrincipal          User,
    IN PIKerbRequest            pReq,
    IN BOOLEAN                  IsUpdate,
    OUT PPAC_INFO_BUFFER        *Info,
    OUT PKERB_EXT_ERROR         pExtendedError,
    IN KDC_PAC_ITERATE_FN       Func,
    IN OUT PVOID                Data
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PLIST_ENTRY ListEntry;
    PKDC_LIST_ENTRY HandlerEntry;

    g_KdcPacHandlerList.Lock.ReadLock();
    for (ListEntry = g_KdcPacHandlerList.Head.Flink;
         ListEntry && (ListEntry != &g_KdcPacHandlerList.Head);
         ListEntry = ListEntry->Flink)
    {
        HandlerEntry = (PKDC_LIST_ENTRY) CONTAINING_RECORD(ListEntry, KDC_LIST_ENTRY, Next);

        // Called holding PAC lock
        KerbErr = (*Func)(
                      piKdb,
                      User,
                      IsUpdate,
                      Info,
                      pExtendedError,
                      pReq,
                      (IPACHandler*)HandlerEntry->pData,
                      Data
                      );

        if (!KERB_SUCCESS(KerbErr))
        {
            break;
        }
    }
    g_KdcPacHandlerList.Lock.ReadUnlock();

    return KerbErr;
}
#endif


# if 0 // do later
NTSTATUS
WINAPI
KdcAddTicketExtHandler(
    IN SHORT            num_handlers,
    IN PKDC_TICKET_EXT_HANDLER handlers,
    OUT LONG            *ContextHandleIndex
    )
{
    return STATUS_SUCCESS;
}


NTSTATUS
WINAPI
KdcDeleteTicketExtHandler(
    IN LONG ContextHandleIndex
    )
{
    return STATUS_SUCCESS;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\server\kerbcrypt.cxx ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    KerbCrypt.cpp

Abstract:

    This module wraps cryptdll with IKerbCrypt using the
    CKerbCryptDll

Revision History:

--*/
#include "kdcsvr.hxx"

//
//    omit KDC_AUDIT_EVENT and KERB_PERF_COUNTERS
//
#include "kerbinterface.h"
#include "kerbcrypt.hxx"
#include "cryptdll.h"
#include <malloc.h>

//
//  for alloca( )
//
#include <malloc.h>

//
//    max. cryptos (same as KERB_MAX_CRYPTO_SYSTEMS)
//
#define MAX_ETYPES    20

CKerbCryptDll::CKerbCryptDll()
    : m_cEtypes( 0 ),
      m_pEtypes( NULL )
{
}

CKerbCryptDll::~CKerbCryptDll()
{
    if ( m_pEtypes ) {

        assert( m_cEtypes > 0 );
        MIDL_user_free( m_pEtypes );
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   CKerbCryptDll::GetEtypes
//
//  Synopsis:   Get the encryption types supported by this implementation
//              of IKerbCrypt.
//
//  Effects:
//
//  Arguments:  ppEtypes -  array of ETYPEs that is supported.
//              pcEtypes -  number of ETYPEs in the array
//
//  Returns:    STATUS_SUCCESS              indicates success
//              STATUS_INVALID_PARAMETER    parms are bad pointers
//              STATUS_NO_MEMORY            out of memory
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS
__stdcall
CKerbCryptDll::GetEtypes(
    OUT ETYPE const             **ppEtypes,
    OUT PULONG                    pcEtypes
    )
{
    NTSTATUS Status;

    if ( NULL == ppEtypes ||
         NULL == pcEtypes ) {

        assert( FALSE );
        return STATUS_INVALID_PARAMETER;
    }

    *ppEtypes = NULL;
    *pcEtypes = 0;

    if (m_pEtypes == NULL)
    {
        assert(m_cEtypes == 0);

        m_pEtypes = ( ETYPE * )MIDL_user_allocate( sizeof( ETYPE ) * MAX_ETYPES );

        if ( !m_pEtypes ) {

            Status = STATUS_NO_MEMORY;
            goto Error;
        }

        Status = CDBuildIntegrityVect(
                     &m_cEtypes,
                     m_pEtypes
                     );

        if ( !NT_SUCCESS( Status )) {

            goto Error;
        }
    }

    assert( m_cEtypes <= MAX_ETYPES );
    assert( m_cEtypes > 0 );

    *ppEtypes = m_pEtypes;
    *pcEtypes = m_cEtypes;

    Status = STATUS_SUCCESS;

Cleanup:

    return Status;

Error:

    assert( !NT_SUCCESS( Status ));

    MIDL_user_free( m_pEtypes );
    m_pEtypes = NULL;
    m_cEtypes = 0;

    goto Cleanup;
}


//+-------------------------------------------------------------------------
//
//  Function:   CKerbCryptDll::GetAttributes
//
//  Synopsis:   Retrieves the attributes of a given encryption type
//
//  Effects:
//
//  Arguments:  Etype       - encryption type
//              Attributes  - used to return the attributes of the Etype
//
//  Returns:    KDC_ERR_NONE            indicates success
//              KDC_ERR_ETYPE_NOTSUPP   encryption type not supported
//
//  Notes:
//
//--------------------------------------------------------------------------

KERBERR
__stdcall
CKerbCryptDll::GetAttributes(
    IN  ETYPE                     Etype,
    OUT PCRYPTATT                 Attributes
    )
{
    KERBERR KerbErr;
    NTSTATUS Status;
    PCRYPTO_SYSTEM pcsCrypt  = NULL;

    Status = CDLocateCSystem(
                 Etype,
                 &pcsCrypt
                 );

    if ( !NT_SUCCESS( Status )) {

        KerbErr = KDC_ERR_ETYPE_NOTSUPP;
        goto Error;
    }

    *Attributes = pcsCrypt->Attributes;

    KerbErr = KDC_ERR_NONE;

Cleanup:

    return KerbErr;

Error:

    assert( !KERB_SUCCESS( KerbErr ));

    *Attributes = 0;

    goto Cleanup;
}


//+-------------------------------------------------------------------------
//
//  Function:   CKerbCryptDll::GetCiphertextSize
//
//  Synopsis:   Computes the number of bytes necessary to encrypt a given buffer
//
//  Effects:
//
//  Arguments:  Etype                   encryption type
//              cbIn                    size of cleartext
//              pcbOut                  used to return size of ciphertext
//
//  Returns:    KDC_ERR_NONE            indicates success
//              KDC_ERR_ETYPE_NOTSUPP   encryption type not supported
//
//  Notes:
//
//--------------------------------------------------------------------------

KERBERR
__stdcall
CKerbCryptDll::GetCiphertextSize(
    IN  ETYPE                     Etype,
    IN  ULONG                     cbIn,
    OUT PULONG                    pcbOut
    )
{
    KERBERR KerbErr;
    NTSTATUS Status;
    PCRYPTO_SYSTEM pcsCrypt;
    ULONG Overhead;
    ULONG BlockSize;

    assert( pcbOut );
    if (!pcbOut)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    Status = CDLocateCSystem(
                 Etype,
                 &pcsCrypt
                 );

    if ( !NT_SUCCESS( Status )) {

        KerbErr = KDC_ERR_ETYPE_NOTSUPP;
        goto Error;
    }

    Overhead = pcsCrypt->HeaderSize;
    BlockSize = pcsCrypt->BlockSize;

    *pcbOut  = ROUND_UP_COUNT( Overhead + cbIn, BlockSize );

    KerbErr = KDC_ERR_NONE;

Cleanup:

    return KerbErr;

Error:

    assert( !KERB_SUCCESS( KerbErr ));

    *pcbOut = 0;

    goto Cleanup;
}


//+-------------------------------------------------------------------------
//
//  Function:   CKerbCryptDll::Encrypt
//
//  Synopsis:   Encrypts a given buffer using the given key.
//                The etype comes from the given key.
//
//  Effects:
//
//  Arguments:  pKey           - encryption key
//              saltflags      - usage flags
//              KeyVersion     - key version (or KERB_NO_KEY_VERSION)
//              pbIn           - data to encrypt
//              cbIn           - number of bytes to encrypt
//              EncryptedData  - used to return the encrypted buffer
//
//  Returns:    KDC_ERR_NONE            indicates success
//              KDC_ERR_ETYPE_NOTSUPP   encryption type not supported
//              KRB_ERR_GENERIC         out of memory, internal error
//                                      bad pointer
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
__stdcall
CKerbCryptDll::Encrypt(
    IN  PKERB_ENCRYPTION_KEY      pKey,
    IN  ULONG                     ulKeyVersion,
    IN  SALTFLAGS                 saltflags,
    IN  PBYTE                     pbIn,
    IN  ULONG                     cbIn,
    OUT PKERB_ENCRYPTED_DATA      pEncryptedData
    )
{
    KERBERR KerbErr;
    NTSTATUS Status;
    PCRYPTO_SYSTEM pcsCrypt = NULL;
    PCRYPT_STATE_BUFFER psbCryptBuffer = NULL;

    TRACER(L"CKerbCryptDll::Encrypt", (PVOID *) &KerbErr);
    if ( NULL == pKey ||
         NULL == pEncryptedData ||
         NULL == pbIn ||
         0 == cbIn ) {

        assert( FALSE );
        return KRB_ERR_GENERIC;
    }

    Status = CDLocateCSystem(
                 pKey->keytype,
                 &pcsCrypt
                 );

    if ( !NT_SUCCESS( Status )) {

        KerbErr = KDC_ERR_ETYPE_NOTSUPP;
        goto Error;
    }

    //
    // Initialize header
    //

    pEncryptedData->encryption_type = pKey->keytype;

    Status = pcsCrypt->Initialize(
                 ( PUCHAR )pKey->keyvalue.value,
                 pKey->keyvalue.length,
                 saltflags,
                 &psbCryptBuffer
                 );

    if ( !NT_SUCCESS( Status )) {

        KerbErr = KRB_ERR_GENERIC;
        goto Error;
    }

    Status =  pcsCrypt->Encrypt(
                  psbCryptBuffer,
                  pbIn,
                  cbIn,
                  pEncryptedData->cipher_text.value,
                  &pEncryptedData->cipher_text.length
                  );

    ( VOID )pcsCrypt->Discard( &psbCryptBuffer );

    if ( !NT_SUCCESS( Status )) {

        KerbErr = KRB_ERR_GENERIC;
        goto Error;
    }

    if ( ulKeyVersion != KERB_NO_KEY_VERSION ) {

        pEncryptedData->version = ulKeyVersion;
        pEncryptedData->bit_mask |= version_present;
    }

    KerbErr = KDC_ERR_NONE;

Cleanup:

    return KerbErr;

Error:

    assert( !KERB_SUCCESS( KerbErr ));
    goto Cleanup;
}


//+-------------------------------------------------------------------------
//
//  Function:   CKerbCryptDll::Decrypt
//
//  Synopsis:   Decrypts a given buffer
//
//  Effects:
//
//  Arguments:  pKey           - encryption key
//              saltflags      - usage flags
//              EncryptedData  - buffer to decrypt
//              pbOut          - used to return the decrypted buffer
//              pcbOut         - used to return the size of decrypted buffer
//
//  Returns:    KDC_ERR_NONE            indicates success
//              KDC_ERR_ETYPE_NOTSUPP   encryption type not supported
//              KRB_ERR_GENERIC         out of memory, internal error or parameters
//                                      are bad
//              KRB_AP_ERR_MODIFIED     decryption failed -- the key is wrong
//
//  Notes:      this routine allows in-place decryption
//
//--------------------------------------------------------------------------

KERBERR
__stdcall
CKerbCryptDll::Decrypt(
    IN  const KERB_ENCRYPTED_DATA * pEncryptedData,
    IN  const KERB_ENCRYPTION_KEY * pKey,
    IN  SALTFLAGS saltflags,
    OUT PBYTE pbOut,
    OUT PULONG pcbOut
    )
{
    KERBERR KerbErr;
    NTSTATUS Status;
    PCRYPTO_SYSTEM pcsCrypt = NULL;
    PCRYPT_STATE_BUFFER psbCryptBuffer = NULL;

    TRACER(L"CKerbCryptDll::Decrypt", (PVOID *) &KerbErr);
    if ( NULL == pEncryptedData ||
         NULL == pKey ||
         NULL == pbOut ||
         NULL == pcbOut ) {

        assert( FALSE );
        KerbErr = KRB_ERR_GENERIC;
        goto Error;
    }

    Status = CDLocateCSystem(
                 pEncryptedData->encryption_type,
                 &pcsCrypt
                 );

    if ( !NT_SUCCESS( Status )) {

        KerbErr = KDC_ERR_ETYPE_NOTSUPP;
        goto Error;
    }

    //
    // This check makes sure that the length of EncryptedData->cipher_text is a
    // multiple of pcsCrypt->BlockSize.  In this case, it looks like an
    // "almost catch-all" check to make sure that the encryption_type is correct
    // since it's definitely incorrect if the returned pcsCrypt->BlockSize won't
    // line up with the length of the passed-in cipher text.
    // ( Explanation courtesy of JSchwart )
    //

    if ( pEncryptedData->cipher_text.length & ( pcsCrypt->BlockSize - 1 )) {

        KerbErr = KRB_ERR_GENERIC;
        goto Error;
    }

    Status = pcsCrypt->Initialize(
                 ( PUCHAR )pKey->keyvalue.value,
                 pKey->keyvalue.length,
                 saltflags,
                 &psbCryptBuffer
                 );

    if ( !NT_SUCCESS( Status )) {

        KerbErr = KRB_ERR_GENERIC;
        goto Error;
    }

    Status = pcsCrypt->Decrypt(
                 psbCryptBuffer,
                 pEncryptedData->cipher_text.value,
                 pEncryptedData->cipher_text.length,
                 pbOut,
                 pcbOut
                 );

    ( VOID )pcsCrypt->Discard( &psbCryptBuffer );

    if ( !NT_SUCCESS( Status )) {

        KerbErr = KRB_AP_ERR_MODIFIED;
        goto Error;
    }

    KerbErr = KDC_ERR_NONE;

Cleanup:

    return KerbErr;

Error:
    assert( !KERB_SUCCESS( KerbErr ));
    goto Cleanup;
}


//+-------------------------------------------------------------------------
//
//  Function:   CKerbCryptDll::GetKeySize
//
//  Synopsis:   Retrieves the key size for given encryption type
//
//  Effects:
//
//  Arguments:  Etype       - encryption type
//              pcbOut      - used to return the size of the key
//
//  Returns:    KDC_ERR_NONE            indicates success
//              KDC_ERR_ETYPE_NOTSUPP   encryption type not supported
//
//  Notes:
//
//--------------------------------------------------------------------------

KERBERR
__stdcall
CKerbCryptDll::GetKeySize(
    IN  ETYPE                     Etype,
    OUT PULONG                    pcbOut
    )
{
    KERBERR KerbErr;
    NTSTATUS Status;
    PCRYPTO_SYSTEM pcsCrypt  = NULL;

    Status = CDLocateCSystem(
                 Etype,
                 &pcsCrypt
                 );

    if ( !NT_SUCCESS( Status )) {

        KerbErr = KDC_ERR_ETYPE_NOTSUPP;
        goto Error;
    }

    *pcbOut = pcsCrypt->KeySize;

    KerbErr = KDC_ERR_NONE;

Cleanup:

    return KerbErr;

Error:

    assert( !KERB_SUCCESS( KerbErr ));

    *pcbOut = 0;

    goto Cleanup;
}

//+-------------------------------------------------------------------------
//
//  Function:   CKerbCryptDll::MakeKey
//
//  Synopsis:   Creates a key for an encryption type
//
//  Effects:
//
//  Arguments:  Etype - encryption type requested
//              ppKey - returned key that should be freed with
//                      CKerbCryptDll::FreeKey
//
//  Returns:    KDC_ERR_NONE            indicates success
//              KDC_ERR_ETYPE_NOTSUPP   encryption type not supported
//              KRB_ERR_GENERIC         out of memory, internal error or parameters
//                                      are bad
//
//--------------------------------------------------------------------------

KERBERR
__stdcall
CKerbCryptDll::MakeKey(
    IN  ETYPE                     Etype,
    OUT KERB_ENCRYPTION_KEY     **ppKey
    )
{
    KERBERR KerbErr;
    NTSTATUS Status;
    PCRYPTO_SYSTEM pcsCrypt  = NULL;
    PKERB_ENCRYPTION_KEY pKey = NULL;

    TRACER(L"CKerbCryptDll::MakeKey", (PVOID *) &KerbErr);

    if ( NULL == ppKey ) {

        assert( FALSE );
        return KRB_ERR_GENERIC;
    }

    pKey = ( PKERB_ENCRYPTION_KEY )MIDL_user_allocate( sizeof( KERB_ENCRYPTION_KEY ));

    if ( NULL == pKey ) {

        KerbErr = KRB_ERR_GENERIC;
        goto Error;
    }

    ZeroMemory( pKey, sizeof( KERB_ENCRYPTION_KEY ));
    pKey->keyvalue.value = NULL;

    //
    // Locate the crypto system
    //

    Status = CDLocateCSystem(
                 Etype,
                 &pcsCrypt
                 );

    if ( !NT_SUCCESS( Status )) {

        KerbErr = KDC_ERR_ETYPE_NOTSUPP;
        goto Error;
    }

    pKey->keyvalue.value = ( PUCHAR )MIDL_user_allocate( pcsCrypt->KeySize );

    if ( pKey->keyvalue.value == NULL ) {

        KerbErr = KRB_ERR_GENERIC;
        goto Error;
    }

    Status = pcsCrypt->RandomKey(
                 NULL,   // no seed
                 0,      // no seed length
                 pKey->keyvalue.value
                 );

    if ( !NT_SUCCESS( Status )) {

        KerbErr = KRB_ERR_GENERIC;
        goto Error;
    }

    pKey->keyvalue.length = pcsCrypt->KeySize;
    pKey->keytype = Etype;

    KerbErr = KDC_ERR_NONE;

Cleanup:

    *ppKey = pKey;

    return KerbErr;

Error:

    assert( !KERB_SUCCESS( KerbErr ));

    FreeKey( pKey );
    pKey = NULL;

    goto Cleanup;
}


//+-------------------------------------------------------------------------
//
//  Function:   CKerbCryptDll::FreeKey
//
//  Synopsis:   Frees memory for key created using CKerbCryptDll::MakeKey
//
//  Arguments:  pKey - key to free, can be NULL
//
//  Returns:    nothing
//
//--------------------------------------------------------------------------

void
__stdcall
CKerbCryptDll::FreeKey(
    IN  PKERB_ENCRYPTION_KEY      pKey
    )
{
    if ( pKey )
    {
        MIDL_user_free(pKey->keyvalue.value);
        MIDL_user_free(pKey);
    }

    return;
}



//+-------------------------------------------------------------------------
//
//  Function:   CKerbCryptDll::GetChecksumSize
//
//  Synopsis:   Calculates the checksum length for a given checksum type
//
//  Effects:
//
//  Arguments:  Ctype                 - checksum type requested
//              pcbOut                - used to return the checksum size
//
//  Returns:    STATUS_SUCCESS              indicates success
//
//--------------------------------------------------------------------------

NTSTATUS
__stdcall
CKerbCryptDll::GetChecksumSize(
    IN  CTYPE                     Ctype,
    OUT PULONG                    pcbOut
    )
{
    NTSTATUS Status;
    PCHECKSUM_FUNCTION pcsChecksum = NULL;

    Status = CDLocateCheckSum(
                 Ctype,
                 &pcsChecksum
                 );

    if ( !NT_SUCCESS( Status )) {

        goto Error;
    }

    *pcbOut = pcsChecksum->CheckSumSize;

Cleanup:

    return Status;

Error:

    assert( !NT_SUCCESS( Status ));

    *pcbOut = 0;

    goto Cleanup;
}


//+-------------------------------------------------------------------------
//
//  Function:   CKerbCryptDll::Checksum
//
//  Synopsis:   Calculates the checksum for a CTYPE (checksum type) using the
//                key, pKey across cBuffers number of buffers.  The sum operation
//                will start with ppbBuffers[0].  The resulting
//                checksum is written to ppbChecksum and pcbChecksum
//                If pbVerify and cbVerify are present, the resulting checksum
//                is compared against pbVerify and pfVerified is set TRUE if
//                it is a match.
//
//  Effects:
//
//  Arguments:  Ctype                 - checksum type requested
//              saltflags             - salt flags
//              pKey                  - key to use.  If this is NULL, no key is used.
//              rgpbBuffers           - array of buffers to checksum
//              rgcbBuffers           - array of byte lengths for each corresponding buffer
//              cBuffers              - number of buffers
//              pbChecksum            - used to return calculated checksum
//              pcbChecksum           - used to return length of checksum
//              pbVerify              - checksum that needs to be verified ( OPTIONAL )
//              cbVerify              - byte length of the checksum to be verified ( OPTIONAL )
//              pfVerified            - did the checksum verify ? ( OPTIONAL )
//
//  Returns:    STATUS_SUCCESS              indicates success
//              STATUS_INVALID_PARAMETER    one or more invalid parameter
//              SEC_E_CHECKSUM_NOT_SUPP     checksum type is not supported
//              STATUS_NO_MEMORY            out of memory
//              STATUS_BUFFER_TOO_SMALL     passed in buffer insufficient
//                                          to compute the checksum
//
//--------------------------------------------------------------------------

NTSTATUS
__stdcall
CKerbCryptDll::Checksum(
    IN  CTYPE                     Ctype,
    IN  SALTFLAGS                 saltflags,
    IN  PKERB_ENCRYPTION_KEY      pKey,
    IN  PBYTE                    *rgpbBuffers,
    IN  ULONG                    *rgcbBuffers,
    IN  ULONG                     cBuffers,
    IN  PBYTE                     pbVerify,
    IN  ULONG                     cbVerify,
    OUT PBYTE                     pbChecksum,
    OUT PULONG                    pcbChecksum,
    OUT PBOOLEAN                  pfVerified
    )
{
    NTSTATUS Status;
    PCHECKSUM_FUNCTION pcsChecksum = NULL;
    PCHECKSUM_BUFFER pcsBuffer = NULL;
    ULONG i;
    ULONG cbChecksum;

    if (( NULL == rgpbBuffers || cBuffers == 0 || rgcbBuffers == NULL ) ||
        (( pbChecksum != NULL ) ^ ( pcbChecksum != NULL )) ||
        (( pbVerify != NULL ) ^ ( cbVerify != 0 ))) {

        return STATUS_INVALID_PARAMETER;
    }

    Status = CDLocateCheckSum(
                 Ctype,
                 &pcsChecksum
                 );

    if ( !NT_SUCCESS( Status )) {

        goto Error;
    }

    //
    // TBD: do we always want to use InitializeEx2 ?
    //

    if (pcsChecksum->InitializeEx2)
    {
        Status = pcsChecksum->InitializeEx2(
                     pKey->keyvalue.value,
                     pKey->keyvalue.length,
                     NULL,
                     saltflags,
                     &pcsBuffer
                     );
    }
    else
    {
        Status = pcsChecksum->InitializeEx(
                     pKey->keyvalue.value,
                     pKey->keyvalue.length,
                     saltflags,
                     &pcsBuffer
                     );
    }

    if ( !NT_SUCCESS( Status )) {

        goto Error;
    }

    //
    // Do the checksumming
    //

    for ( i = 0; i < cBuffers; i++ ) {

        Status = pcsChecksum->Sum(
                     pcsBuffer,
                     rgcbBuffers[i],
                     rgpbBuffers[i]
                     );

        if ( !NT_SUCCESS( Status )) {

            goto Error;
        }
    }

    if ( pcbChecksum == NULL ) {

        cbChecksum = pcsChecksum->CheckSumSize;
        pcbChecksum = &cbChecksum;
    }

    if ( *pcbChecksum < pcsChecksum->CheckSumSize ) {

        Status = STATUS_BUFFER_TOO_SMALL;
        goto Error;
    }

    if ( pbChecksum == NULL ) {
        __try
        {
            pbChecksum = ( BYTE * ) _alloca( *pcbChecksum );
        }
         __except ( GetExceptionCode() == STATUS_STACK_OVERFLOW )
        {    
            _resetstkoflw();
            Status = STATUS_NO_MEMORY;
            goto Error;
        }
    }

    ZeroMemory( pbChecksum, *pcbChecksum );

    Status = pcsChecksum->Finalize( pcsBuffer, pbChecksum );

    if ( !NT_SUCCESS( Status )) {

        goto Error;
    }

    //
    //    Is verification required ?
    //

    if ( pfVerified ) {

        *pfVerified = ( pcsChecksum->CheckSumSize == cbVerify ) &&
                      ( pbVerify != NULL ) &&
                      ( memcmp( pbChecksum, pbVerify, cbVerify ) == 0 );
    }

    *pcbChecksum = pcsChecksum->CheckSumSize;

    Status = STATUS_SUCCESS;

Cleanup:

    if ( pcsBuffer ) {

        pcsChecksum->Finish( &pcsBuffer );
    }

    return Status;

Error:

    assert( !NT_SUCCESS( Status ));
    if ( pcsBuffer ) {

        pcsChecksum->Finish( &pcsBuffer );
    }

    if ( pcbChecksum ) {

        *pcbChecksum = 0;
    }

    if ( pfVerified ) {

        *pfVerified = FALSE;
    }

    goto Cleanup;
}


//+-------------------------------------------------------------------------
//
//  Function:   CKerbCryptDll::HashString
//
//  Synopsis:   Hashes a given string
//
//  Effects:
//
//  Arguments:  Etype       - encryption type requested
//              String      - string to hash
//              pbOut       - buffer used to return the hash
//              pcbOut      - used to return the size of the hash,
//                            contains the number of bytes in pbOut on input
//                            this number should be at least as the key size
//                            for Etype (use GetKeySize to figure that out)
//
//  Returns:    KDC_ERR_NONE            indicates success
//              KDC_ERR_ETYPE_NOTSUPP   encryption type not supported
//              KRB_ERR_GENERIC         internal error or parameters are bad
//
//--------------------------------------------------------------------------

KERBERR
__stdcall
CKerbCryptDll::HashString(
    IN  ETYPE                     Etype,
    IN  PUNICODE_STRING           String,
    OUT PBYTE                     pbOut,
    OUT PULONG                    pcbOut
    )
{
    KERBERR KerbErr;
    NTSTATUS Status;
    PCRYPTO_SYSTEM pcsCrypt  = NULL;

    Status = CDLocateCSystem(
                 Etype,
                 &pcsCrypt
                 );

    if ( !NT_SUCCESS( Status )) {

        KerbErr = KDC_ERR_ETYPE_NOTSUPP;
        goto Error;
    }

    if ( *pcbOut < pcsCrypt->KeySize ) {

        assert( FALSE );
        KerbErr = KRB_ERR_GENERIC;
        goto Error;
    }

    Status = pcsCrypt->HashString(
                 String,
                 pbOut
                 );

    if ( !NT_SUCCESS( Status )) {

        KerbErr = KRB_ERR_GENERIC;
        goto Error;
    }

    *pcbOut = pcsCrypt->KeySize;

    KerbErr = KDC_ERR_NONE;

Cleanup:

    return KerbErr;

Error:

    assert( !KERB_SUCCESS( KerbErr ));

    *pcbOut = NULL;

    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\server\kdctrace.cxx ===
//------------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//
// File Name    :   kdctrace.cxx
// Abstract :   Core Trace initialization and globals.
// Created  :   vikask on 10/23/01   
// Revision History:
//
//------------------------------------------------------------------------------

#include "kdcsvr.hxx"
#include "kdctrace.hxx"

static HKEY hKdcParams = NULL;
static HMODULE hTraceLib = NULL;

//  GlobalTlsIndex
DWORD                   g_TraceTlsIndex = TLS_OUT_OF_INDEXES;
TRACE_INFO_BLOCK        g_tlsBlock;
PTRACE_INFO_BLOCK       g_ptlsBlock     = NULL;
TLS_BLOCK_LIST          g_tlsBlockList, *g_ptlsBlockList = NULL;
CRITICAL_SECTION    g_CriticalTlsSection;

//  This flag is needed to indicate whether a TLS index has been allocated by 
//  the core, in which case it needs to be freed during shutdown
BOOL                    g_fDefaultTracing                   = FALSE;
BOOL                    g_fCriticalTlsSectionInitialized    = FALSE;

//+-------------------------------------------------------------------------
//
//  Function:   KdcInitializeTrace
//
//  Synopsis:   Initializes Tracing for the core
//              Initializes the TLS index, either by obtaining it from a trace 
//              dll if provided, or by allocating one.
//
//  Effects:    Initializes tracing
//
//  Arguments:  TraceDll    Dll from which to obtain the TlsIndex
//
//  Returns:    NTSTATUS
//                  STATUS_DLL_NOT_FOUND
//                  STATUS_PROCEDURE_NOT_FOUND
//                  STATUS_SUCCESS
//  Notes:                  
//
//--------------------------------------------------------------------------
NTSTATUS KdcInitializeTrace(
        IN OPTIONAL LPWSTR TraceDll
        )
{
    NTSTATUS NtStatus           = STATUS_SUCCESS;
    LPWSTR String               = NULL;
    DWORD cbSize                = 0;
    DWORD cbType;
    DWORD dwErr;
    
    g_ptlsBlockList             = &g_tlsBlockList;
    g_ptlsBlockList->next       = NULL;
    g_ptlsBlockList->infoBlock  = NULL;
    
    g_fCriticalTlsSectionInitialized = FALSE;
    InitializeCriticalSection(&g_CriticalTlsSection);

    g_fCriticalTlsSectionInitialized = TRUE;

    if (TraceDll)
    {
        g_fDefaultTracing = FALSE;
        hTraceLib = LoadLibraryW( TraceDll );
        if ( NULL == hTraceLib )
        {
            NtStatus = STATUS_DLL_NOT_FOUND;
        }
    }
    else
    {
        if (NULL == hKdcParams)
        {
            LONG lRes = RegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   L"System\\CurrentControlSet\\Services\\Kdc\\Parameters",
                   0,
                   KEY_READ,
                   &hKdcParams
                   );

            if (ERROR_SUCCESS != lRes)
            {
                DebugLog((DEB_WARN,"Failed to open kerberos key: 0x%x\n", lRes));
            }
            else
            {
            }
        }
            
        //
        // Get trace DLL to load from registry
        //
        // HKLM/System/CCS/Services/Kdc/Parameters/TraceDll [REG_SZ] kdctrace.dll
        //
        
        dwErr = RegQueryValueExW(
                       hKdcParams,
                       L"TraceDll",
                       NULL,
                       &cbType,
                       NULL,
                       &cbSize
                       );

        if (dwErr == ERROR_SUCCESS)
        {
            if (cbType == REG_SZ && cbSize > 0)
            {
                String = (LPWSTR)MIDL_user_allocate(cbSize);
                if (NULL == String)
                {
                    goto Init;
                }
            }
            
            dwErr = RegQueryValueExW(
                          hKdcParams,
                          L"TraceDll",
                          NULL,
                          &cbType,
                          (LPBYTE)String,
                          &cbSize
                          );

            if (dwErr == ERROR_SUCCESS &&
                cbType == REG_SZ &&
                cbSize > 0)
            {
                g_fDefaultTracing = FALSE;
                hTraceLib = LoadLibraryW( String );
                if ( NULL == hTraceLib )
                {
                    NtStatus = STATUS_DLL_NOT_FOUND;
                }
                if (String != NULL)
                {
                    MIDL_user_free(String);
                }
            }
        }
    }

Init:
    if (NT_SUCCESS(NtStatus) && hTraceLib) 
    {
        g_fDefaultTracing = FALSE;

        INITIALIZE_TRACE pfnInitializeTrace = (INITIALIZE_TRACE) GetProcAddress(
                                                hTraceLib, 
                                                "InitializeTrace"
                                                );
        if ( pfnInitializeTrace == NULL ) 
        {
            NtStatus = STATUS_PROCEDURE_NOT_FOUND;                
            goto Exit; 
        }
        else
        {
            if ( !pfnInitializeTrace() )
            {
                NtStatus = STATUS_DATA_ERROR;
                goto Exit;
            }
        }
            
        GET_TLS_INDEX pfnGetTlsIndex = (GET_TLS_INDEX) GetProcAddress(
                                                hTraceLib, 
                                                "GetTlsIndex"
                                                );
        if ( pfnGetTlsIndex == NULL ) 
        {
            NtStatus = STATUS_PROCEDURE_NOT_FOUND;                
            goto Exit; 
        } 
        else 
        {
            g_TraceTlsIndex = pfnGetTlsIndex();
            g_ptlsBlock  = (PTRACE_INFO_BLOCK)TlsGetValue(g_TraceTlsIndex);
            if (g_ptlsBlock) 
            {   
                //Tracing successfully initialized
                goto Exit;
            }
            //TlsBlock not initialized                
        }
    }
    else 
    {
        // Provide default implementation
        g_fDefaultTracing = TRUE;
        g_TraceTlsIndex = TlsAlloc();
        if (g_TraceTlsIndex == TLS_OUT_OF_INDEXES) 
        {
            NtStatus = STATUS_NO_MEMORY;
            goto Exit;
        }
    }
    
    g_ptlsBlock = &g_tlsBlock;
    g_ptlsBlock->Categories = 0;    //Default Trace level
    g_ptlsBlock->pfnTrace   = NULL; //TODO : Write a default fn which calls debuglog
    g_ptlsBlock->pfnShutdown  = NULL;
    g_ptlsBlock->Buffer[0]  = L'\0';
    
    if (!TlsSetValue(g_TraceTlsIndex, (LPVOID)g_ptlsBlock)) 
    {                
        TlsFree(g_TraceTlsIndex);
        NtStatus = STATUS_DATA_ERROR;                
    }
    //end default
            
Exit:
    return NtStatus;
    
}

//+-------------------------------------------------------------------------
//
//  Function:   CheckIfTraceInitialized
//
//  Synopsis:   Prints trace message in the function which is doing intialization
//
//  Effects:    Initializes tracing
//
//  Notes:      This fn has been created because the TRACER utility cannot be 
//              used anywhere in the function which initializes tracing                 
//
//--------------------------------------------------------------------------

VOID CheckIfTraceInitialized() {
    TRACER(L"CheckIfTraceInitialized", NULL);
    TRACE_FILELINE(TRACE_VERB, (FILE_AND_LINE, L"Tracing initialized in Core"));   
}

//+-------------------------------------------------------------------------
//
//  Function:   AddTlsBlockToGlobalList
//
//  Synopsis:   Adds the newly allocated TlsBlock to the global list so that it
//              can be freed, or modified later
//
//  Arguments:  newBlock - ptr to TRACE_INFO_BLOCK to be added to the global list
//
//  Effects:    
//
//  Notes:                       
//
//--------------------------------------------------------------------------
NTSTATUS AddTlsBlockToGlobalList(
        IN PTRACE_INFO_BLOCK newBlock
        )
{
    NTSTATUS        NtStatus    = STATUS_SUCCESS;
    PTLS_BLOCK_LIST newNode     = 
            (PTLS_BLOCK_LIST)LocalAlloc(LPTR, sizeof(TLS_BLOCK_LIST));
    if (!newNode)
    {
        NtStatus = STATUS_NO_MEMORY;
        goto exit;
    }
    newNode->infoBlock = newBlock;
    EnterCriticalSection(&g_CriticalTlsSection);
    newNode->next = g_ptlsBlockList;
    g_ptlsBlockList = newNode;
    LeaveCriticalSection(&g_CriticalTlsSection);
exit:
    return NtStatus;
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcShutdownTrace
//
//  Synopsis:   Frees the TLS block allocated to each thread serving KDC 
//              requests, and the TLS index if it was allocated by the core
//
//  Effects:    Tracing is disabled once this function is executed
//
//  Notes:                       
//
//--------------------------------------------------------------------------
VOID KdcShutdownTrace() 
{
    PTLS_BLOCK_LIST temp;

    if (g_fCriticalTlsSectionInitialized)
    {
        DeleteCriticalSection(&g_CriticalTlsSection);
    }
    
    if (g_ptlsBlock && g_ptlsBlock->pfnShutdown != NULL) 
    {
        g_ptlsBlock->pfnShutdown();
    }
    
    if (!g_ptlsBlockList)
    {
        return;
    }

    if (g_fDefaultTracing && (g_TraceTlsIndex != TLS_OUT_OF_INDEXES))
    {
        TlsFree(g_TraceTlsIndex);
    }
    
    while(g_ptlsBlockList && g_ptlsBlockList->infoBlock) 
    {    
        LocalFree(g_ptlsBlockList->infoBlock);
        temp = g_ptlsBlockList->next;
        LocalFree(g_ptlsBlockList);
        g_ptlsBlockList = temp;
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   InitializeTlsPerRequest
//
//  Synopsis:   Copies global data to tls
//
//  Effects:
//
//  Arguments:  
//
//  Returns:   NTSTATUS : Request need not fail in case of error, 
//                 but no tracing will be done for that thread
//
//  Notes:     written by vikask (10.22.01)
//
//--------------------------------------------------------------------------
NTSTATUS InitializeTlsPerRequest() 
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    PTRACE_INFO_BLOCK newBlock;

    newBlock = (PTRACE_INFO_BLOCK) TlsGetValue(g_TraceTlsIndex);
    if (!newBlock) 
    {
        //This thread is being accessed for the first time
        newBlock = (PTRACE_INFO_BLOCK) LocalAlloc(LPTR, sizeof(TRACE_INFO_BLOCK));
        if (newBlock == NULL) 
        {
            NtStatus = STATUS_NO_MEMORY;
            goto Error;
        }
        
        assert(g_ptlsBlock);
        if (!g_ptlsBlock)
        {
            //Need to find more appropriate error code - initialization no done
            NtStatus = STATUS_INVALID_SERVER_STATE;                                    
            goto Error;
        }
        newBlock->Categories = g_ptlsBlock->Categories;   
        newBlock->pfnTrace   = g_ptlsBlock->pfnTrace;

        if (!TlsSetValue(g_TraceTlsIndex, (LPVOID)newBlock)) 
        {
            //TODO: Find out if some other error code is more appropriate
            NtStatus = STATUS_NO_MEMORY;
            goto Error;
        }
        
        // Add this block synchronously to global list so that it can be freed 
        // during shutdown
        NtStatus = AddTlsBlockToGlobalList(newBlock);
        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }
    }
    else 
    {
        //This thread's TLS was initialized by a previous request
        //Any modifications on a per request basis can be done here
    }
    return NtStatus;
        
Error:
    if (newBlock) 
    {
        LocalFree(newBlock);
    } 
    TlsSetValue(g_TraceTlsIndex, NULL);
    return NtStatus;
}

//+-------------------------------------------------------------------------
//
//  Function:   UpdateTraceTLS
//
//  Synopsis:   Updates the Trace Level in all the threads
//
//  Effects:    
//
//  Arguments:  dwLevel - Trace level of TLS blocks in all threads is set to 
//              this
//
//  Returns:    None
//
//  Notes:      written by vikask (02.04.02)
//
//--------------------------------------------------------------------------
VOID KdcUpdateTraceLevel(IN DWORD dwLevel) 
{
    PTLS_BLOCK_LIST temp = g_ptlsBlockList;
    if (!temp)
    {
        return;
    }

    EnterCriticalSection(&g_CriticalTlsSection);
    while(temp && temp->infoBlock) 
    {
        (temp->infoBlock)->Categories = dwLevel;
        temp = temp->next;
    }
    LeaveCriticalSection(&g_CriticalTlsSection);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\server\padata.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       preauth.cxx
//
//  Contents:   KDC Internal Preauth types
//
//  Classes:
//
//  Functions:
//
//  History:    21-June-2001    JBrezak
//
//----------------------------------------------------------------------------

#include "kdcsvr.hxx"

#include <wininet.h>    // for SECURITY_FLAG_xxx
#include <sclogon.h>    // ScHelperXXX
//#include <certca.h>     // for CA*XXX

#define FILENO FILENO_PKSERV
#include "fileno.h"

#include "kerbinterface.h"
#include "kerbhelper.h"
#include "padata.hxx"
#include "pkserv.h"
//
//  global PA handler factories
//

CPAHandlerETypeFactory  PAf1;
CPAHandlerPwSaltFactory PAf2;
CPAHandlerEncryptedTimeFactory PAf3;
CPAHandlerPACReqExFactory PAf4;
CPAHandlerPkinitFactory PAf5;
CPAHandlerPkinitCompatFactory   PAf6;
CPAHandlerIdentityFactory   PAf7;

IPAHandlerFactory*   g_pIPAHandlerFactories[] = {&PAf1,
//                                                 &PAf2,
                                                 &PAf3,
                                                 &PAf4,
                                                 &PAf5,
                                                 &PAf6,
                                                 &PAf7};


//
//    Helper routine to register handlers
//

NTSTATUS
__stdcall
RegisterCorePAHandlerFactories(
    VOID
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;
    int         i;


    for ( i = 0;
        i < sizeof(g_pIPAHandlerFactories)/sizeof(IPAHandlerFactory*);
        i++ )
    {
        Status = KdcRegisterPAHandlerFactory(g_pIPAHandlerFactories[i]);
        if (!NT_SUCCESS(Status))
        {
            break;
        }
    }


    return Status;
}




//+-------------------------------------------------------------------------
//
//  Function:   KdcBuildEtypeInfo
//
//  Synopsis:   Builds a list of supported etypes & salts
//
//  Effects:
//
//  Arguments:  TicketInfo - client's ticket info
//              OutputPreAuth - receives any preauth data to return to client
//
//  Requires:
//
//  Returns:    kerberr
//
//  Notes:
//
//
//--------------------------------------------------------------------------
CPAHandlerETypeInfo::CPAHandlerETypeInfo( )
{
}

CPAHandlerETypeInfo::~CPAHandlerETypeInfo( )
{
}

KERBERR
__stdcall
CPAHandlerETypeInfo::Get(
    IN  IKerbRequest        *pIKerbRequest,
    OUT PKERB_PA_DATA_LIST  *ppPADataList)
{
    KERBERR                 KerbErr             = KDC_ERR_NONE;
    IKerbPrincipal          *pIPrincipalClient  = NULL;
    PKERB_ETYPE_INFO        petypeinfo          = NULL;
    PKERB_CRYPT_LIST        pEtypes             = NULL;
    PKERB_PA_DATA_LIST      pPADataList         = NULL;

    *ppPADataList = NULL;

    pIPrincipalClient = pIKerbRequest->GetIPrincClient();
    if (NULL == pIPrincipalClient)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    pEtypes = pIKerbRequest->GetEncryptionTypes();
    if (NULL == pEtypes)
        goto Cleanup;

    KerbErr = pIPrincipalClient->GetEtypeMatch(
                    pEtypes,
                    &petypeinfo);


    if ( !KERB_SUCCESS(KerbErr) || NULL == petypeinfo )
    {
           KerbErr = KDC_ERR_ETYPE_NOTSUPP;
           DebugLog((DEB_ERROR,"There is no union between client and server Etypes!\n"));

        //
        //    TBD:
        //
#ifdef TBD
           KdcReportKeyError(
            KdbHandle,
            ClientInfo->Princ,
            ClientInfo->Realm,
            NULL,
            NULL,
            KDCEVENT_NO_KEY_UNION_AS,
            RequestBody->encryption_type,
            ClientInfo->Keys
            );
#endif
    }

    else
    {
       pPADataList = (PKERB_PA_DATA_LIST) MIDL_user_allocate(sizeof(KERB_PA_DATA_LIST));
       if (pPADataList == NULL)
       {
          KerbErr = KRB_ERR_GENERIC;
          goto Cleanup;
       }

       ZeroMemory(
          pPADataList,
          sizeof(KERB_PA_DATA_LIST)
          );

       pPADataList->value.preauth_data_type = KRB5_PADATA_ETYPE_INFO;

       KerbErr = KerbPackData(
          &petypeinfo,
          PKERB_ETYPE_INFO_PDU,
          (PULONG) &pPADataList->value.preauth_data.length,
          &pPADataList->value.preauth_data.value
          );

       if (!KERB_SUCCESS(KerbErr))
       {
          goto Cleanup;
       }

       // Link to other PA-DATA if present
       pPADataList->next = *ppPADataList;
       *ppPADataList = pPADataList;
       pPADataList = NULL;       // So it doesn't get freed in cleanup
    }


Cleanup:
    while (petypeinfo != NULL)
    {
        PKERB_ETYPE_INFO petypeinfoNextEntry = petypeinfo->next;
        if (petypeinfo->value.salt.value != NULL)
        {
            STRING strTemp;

            strTemp.Buffer = (PCHAR) petypeinfo->value.salt.value;
            strTemp.Length = (USHORT) petypeinfo->value.salt.length;
            KerbFreeString((PUNICODE_STRING) &strTemp);
        }

        KdcFreeMemory(petypeinfo);
        petypeinfo = petypeinfoNextEntry;
    }

    if (pPADataList != NULL)
    {
        KerbFreePreAuthData(pPADataList);
    }
    return KerbErr;
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcBuildPwSalt
//
//  Synopsis:   builds the pw-salt pa data type
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

CPAHandlerPwSalt::CPAHandlerPwSalt()
{
}

CPAHandlerPwSalt::~CPAHandlerPwSalt()
{
}

//
//    TBD: currently just use default salt.
//
KERBERR
__stdcall
CPAHandlerPwSalt::ReturnToClient(
        IN  IKerbRequest            *pIKerbRequest,
        OUT PKERB_PA_DATA_LIST      *ppPADataList
)
{
    KERBERR             KerbErr             = KDC_ERR_NONE;
#if 0
    PKERB_PA_DATA_LIST  pPADataList         = NULL;
    PUNICODE_STRING     pustrSaltUsed       = NULL;
    STRING              strSalt             = {0};
    IKerbPrincipal      *pIPrincClient      = NULL;
    UNICODE_STRING      ustrDummySalt           = {0};


    //  this handler breaks w2k clients for no apparent reason
    //  take out the functionality
    //
    //  This handler should never be invoked for TGS request
    //
    //  TBD: temporarily remove this assert since the iterator goes through
    //  all handlers regardless of serv. id.
    // assert(KerbAs == pIKerbRequest->GetServId());
    //
    if (pIKerbRequest->GetServId() != KerbAs)
        goto Cleanup;

    //
    //  If pre-authentication is done, then don't have to do this
    //
#ifdef TBD
    if (pIKerbRequest->IsPreAuthenticated())
    {
        KerbErr = KDC_ERR_NONE;
        goto Cleanup;
    }


    //
    //
    //  The service key is from the client (for AS)
    //
    pIPrincClient = pIKerbRequest->GetIPrincClient();
    if (NULL == pIPrincClient)
    {
        //TBD: log error
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    //
    //  Get salt for the first common key in the ecnryption types from the request
    //  only if the request does not have a session key already
    //
    if (pIKerbRequest->GetSessionKey() == NULL)
    {
        KerbErr = pIPrincClient->GetSaltForFirstEType(
                        pIKerbRequest->GetEncryptionTypes(),
                        pustrSaltUsed);
    }
    if (!KERB_SUCCESS(KerbErr))
        goto Cleanup;

#else
    // use empty salt
    pustrSaltUsed = &ustrDummySalt;
#endif

    //
    // Convert the salt to a kerb string
    //

    KerbErr = KerbUnicodeStringToKerbString(
                &strSalt,
                pustrSaltUsed
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Allocate and fill in the first item
    //

    pPADataList = (PKERB_PA_DATA_LIST) MIDL_user_allocate(sizeof(KERB_PA_DATA_LIST));
    if (pPADataList == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    ZeroMemory(
        pPADataList,
        sizeof(KERB_PA_DATA_LIST)
        );

    pPADataList->value.preauth_data_type = KRB5_PADATA_PW_SALT;
    pPADataList->value.preauth_data.length = strSalt.Length;
    pPADataList->value.preauth_data.value = (PUCHAR) strSalt.Buffer;
    strSalt.Buffer = NULL;

    pPADataList->next = *ppPADataList;
    *ppPADataList = pPADataList;
    pPADataList = NULL;

Cleanup:

    if (pPADataList != NULL)
    {
        KerbFreePreAuthData((PKERB_PA_DATA_LIST)pPADataList);
    }

    if (strSalt.Buffer != NULL)
    {
        MIDL_user_free(strSalt.Buffer);
    }

#endif

    return(KerbErr);

}

//+-------------------------------------------------------------------------
//
//  Function:   KdcCheckEncryptedTimeStamp
//
//  Synopsis:   Verifies an encrypted time stamp pre-auth data
//
//  Effects:
//
//  Arguments:  PreAuthData - preauth data from client
//              TicketInfo - client's ticket info
//              UserHandle - handle to client's account
//              OutputPreAuth - receives any preauth data to return to client
//
//  Requires:
//
//  Returns:    KDC_ERR_PREAUTH_FAILED - the password was bad
//              Other errors - preauth failed but shouldn't trigger lockout
//
//  Notes:
//
//
//--------------------------------------------------------------------------
CPAHandlerEncryptedTime::CPAHandlerEncryptedTime()
{
    m_ClientTime.LowPart = m_ClientTime.HighPart = 0;
}

CPAHandlerEncryptedTime::~CPAHandlerEncryptedTime()
{
}

KERBERR
__stdcall
CPAHandlerEncryptedTime::Check(
        IN  IKerbRequest                *pIKerbRequest,
        IN  PKERB_PA_DATA_LIST           pPreAuthData,
        OUT PKERB_ENCRYPTION_KEY         pEncryptionKey,
        OUT PKERB_PA_DATA_LIST          *ppOutPadata,
        OUT BOOLEAN*                    pbSufficient,
        OUT PKERB_EXT_ERROR pExtendedError
)
{
    KERBERR                     KerbErr;
    PIKerbPrincipal             pIPrincipal    = NULL;
    KERB_SERVICE_ID             ServId;
    PRINC_FLAGS                 princflags = 0;
    PKERB_ENCRYPTED_DATA        pEncryptedData = NULL;
    PKERB_ENCRYPTED_TIMESTAMP   pEncryptedTime = NULL;
    LARGE_INTEGER               CurrentTime;
    KERB_CRYPT_LIST             Etype;
    LARGE_INTEGER               SkewTime;
    PKERB_ENCRYPTION_KEY        pNewKey = NULL;
    IPAHandler*                 piPA = NULL;
    IPAIdentity*                pICompId = NULL;
    IKDCPrincipalWithMultipleKeys* piMK = NULL;
    BYTE*                       pbScratch = NULL;
    DWORD                       cbScratch = 0;
    
    ServId = pIKerbRequest->GetServId();
    switch(ServId)
    {
        case KerbAs:
            pIPrincipal = pIKerbRequest->GetIPrincClient();
            break;

        case KerbTgs:
            pIPrincipal = pIKerbRequest->GetIPrincService();
            break;

        default:
            //TBD: log ?
            assert(FALSE);
            break;
    }

    if (NULL == pIPrincipal)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    princflags = pIPrincipal->GetPrincFlags();

    if ((princflags & KERB_KDB_DISALLOW_ALL_TIX))
    {
        KerbErr = KDC_ERR_CLIENT_REVOKED;
        goto Cleanup;
    }

    //
    // Unpack the pre-auth data into an encrypted data first.
    //

    KerbErr = KerbUnpackEncryptedData(
                pPreAuthData->value.preauth_data.value,
                pPreAuthData->value.preauth_data.length,
                &pEncryptedData
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    // Support principals with multiple keys
    pIPrincipal->QueryInterface(IID_IKDCPrincipalWithMultipleKeys, (void**)&piMK);

lComputeCompoundKey:    
    
    if (NT_SUCCESS(pIKerbRequest->GetPAHandler(KRB5_PADATA_COMPOUND_IDENTITY, &piPA)))
    {
        //  save the handler in the request for easier access later on
        piPA->QueryInterface(IID_IPAIdentity, (PVOID*)&pICompId);

        //
        //  finally check if the session key in the ecrypted part needs
        //  to be changed
        //  that will be the case if compound identity is present
        //
        if (pICompId)
        {
            ULONG   cKeys = 0;
            const KERB_ENCRYPTION_KEY *pcKeys;
            NTSTATUS    Status = pICompId->GetTgtKeys(&cKeys, &pcKeys);
            if (NT_SUCCESS(Status))
            {
                //  change the session key
                Status = KerbComputePaCompIdentityKeyForPrincipal(
                                                  pEncryptedData->encryption_type,
                                                  pIKerbRequest,
                                                  &pNewKey,
                                                  cKeys,
                                                  pcKeys);
                if (!NT_SUCCESS(Status))
                {
                    //  key derivation failed
                    //  treat this as preauth error
                    KerbErr = KDC_ERR_PREAUTH_FAILED;
                    DebugLog(( DEB_WARN,
                    "KLIN(%x) CPAHandlerEncryptedTime::Check: failed to derived compid key 0x%lx.\n",
                    KLIN(FILENO, __LINE__), Status));
                    goto    Cleanup;
                }
            }
        }
    }
    
    //
    // Now decrypt the encrypted data
    //
    if (pNewKey != NULL)
    {
        // Use the session key of the request
        IKerbCrypt *piCrypt = NULL;
        pIPrincipal->GetIKdbProvider()->GetIKerbCrypt(&piCrypt);

        // We can't decrypt in place because decryption might fail and change the
        // original cyphertext making it impossible to try to decrypt using a 
        // different key. Allocate a buffer to copy the ciphertext
        if(!pbScratch)
        {
            pbScratch = (BYTE*) MIDL_user_allocate(pEncryptedData->cipher_text.length);
            if(!pbScratch)
            {
                KerbErr = KDC_ERR_PREAUTH_FAILED;
                goto Cleanup;
            }            
        }

        cbScratch = pEncryptedData->cipher_text.length;
        memcpy(pbScratch, pEncryptedData->cipher_text.value, cbScratch);

        KerbErr = piCrypt->Decrypt(
                    pEncryptedData,
                    pNewKey,
                    KERB_ENC_TIMESTAMP_SALT,
                    pbScratch,
                    (PULONG) &cbScratch);

        if (KERB_SUCCESS(KerbErr))
        {
            // Copy cleartext back in
            assert(cbScratch <= pEncryptedData->cipher_text.length);
            memcpy(pEncryptedData->cipher_text.value, pbScratch, cbScratch);

            *pEncryptionKey = *pNewKey;
            MIDL_user_free(pNewKey);
            pNewKey = NULL;
        }
        else
        {
            MIDL_user_free(pNewKey->keyvalue.value);
            MIDL_user_free(pNewKey);
            pNewKey = NULL;

            // If principal supports multiple keys (piMK != NULL), try a 
            // different key to generate the compound key.
            if(piMK && piMK->NextKey())
            {
                goto lComputeCompoundKey;
            }
        }
    }
    else
    {
        Etype.next = NULL;
        Etype.value= pEncryptedData->encryption_type;
        KerbErr = pIPrincipal->Decrypt(
                    &Etype,
                    KERB_ENC_TIMESTAMP_SALT,
                    pEncryptedData,
                    pEncryptedData->cipher_text.value,
                    (PULONG) &pEncryptedData->cipher_text.length,
                    NULL,
                    pExtendedError);
    }
    
    //
    //    if the no keys were found for the preferred etype
    //
    if (KDC_ERR_ETYPE_NOTSUPP == KerbErr)
    {
        // fakeit
        KERB_CRYPT_LIST pcryptlistFake;
        pcryptlistFake.next = NULL;
        pcryptlistFake.value = pEncryptedData->encryption_type ;

#ifdef TBD
        KdcReportKeyError(
            KdbHandle,
            TicketInfo->Princ,
            TicketInfo->Realm,
            NULL,
            NULL,
            KDCEVENT_NO_KEY_UNION_AS,
            &FakeList,
            TicketInfo->Keys
            );
#endif
        KerbErr = KDC_ERR_ETYPE_NOTSUPP;
        goto Cleanup;
    }

    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_WARN,
                  "KLIN(%x) Failed to decrypt timestamp pre-auth data: 0x%x\n",
                  KLIN(FILENO,__LINE__),
                  KerbErr));
        KerbErr = KDC_ERR_PREAUTH_FAILED;
        goto Cleanup;
    }


    //
    // unpack the decrypted data into a KERB_ENCRYPTED_TIMESTAMP
    //

    KerbErr = KerbUnpackData(
                pEncryptedData->cipher_text.value,
                pEncryptedData->cipher_text.length,
                KERB_ENCRYPTED_TIMESTAMP_PDU,
                (PVOID *) &pEncryptedTime
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_WARN,"KLIN(%x) Failed to unpack preauth data to encrpyted_time\n",
                  KLIN(FILENO,__LINE__)));

        goto Cleanup;
    }

    //
    // Now verify the time.
    //

    KerbConvertGeneralizedTimeToLargeInt(
        &m_ClientTime,
        &pEncryptedTime->timestamp,
        ((pEncryptedTime->bit_mask & KERB_ENCRYPTED_TIMESTAMP_usec_present) != 0) ?
          pEncryptedTime->KERB_ENCRYPTED_TIMESTAMP_usec : 0
        );

    GetSystemTimeAsFileTime(
        (PFILETIME) &CurrentTime
        );

    //
    // We don't want to check too closely, so allow for skew
    //
    SkewTime = pIPrincipal->GetIKdbProvider()->GetKdcPolicy()->TimeSkew;

    if ((CurrentTime.QuadPart + SkewTime.QuadPart < m_ClientTime.QuadPart) ||
        (CurrentTime.QuadPart - SkewTime.QuadPart > m_ClientTime.QuadPart))
    {
#ifdef TBD
        D_DebugLog((DEB_ERROR, "KLIN(%x) Client %wZ time is incorrect:\n",
                  KLIN(FILENO,__LINE__),
                  &TicketInfo->Princ));
#endif
        PrintTime(DEB_ERROR, "Client Time is", &m_ClientTime );
        PrintTime(DEB_ERROR, "KDC Time is", &CurrentTime );

        //
        // We don't want to lockout the account if the time is off
        //

        KerbErr = KRB_AP_ERR_SKEW;
        goto Cleanup;
    }

    KerbErr = KDC_ERR_NONE;

Cleanup:
    if (KERB_SUCCESS(KerbErr))
    {
        *pbSufficient = TRUE;
    }
    if (pEncryptedData != NULL)
    {
        KerbFreeEncryptedData(pEncryptedData);
    }
    if (pEncryptedTime != NULL)
    {
        KerbFreeData(KERB_ENCRYPTED_TIMESTAMP_PDU, pEncryptedTime);
    }
    if (pNewKey != NULL)
    {
        if (pNewKey->keyvalue.value != NULL)
        {
            MIDL_user_free(pNewKey->keyvalue.value);
        }        
        MIDL_user_free(pNewKey);
    }
    if(pbScratch != NULL)
    {
        MIDL_user_free(pbScratch);
    }

    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcCheckPacRequestPreAuthData
//
//  Synopsis:   Gets the status of whether the client wants a PAC from the
//              pre-auth data
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
CPAHandlerPACRequestEx::CPAHandlerPACRequestEx()
    : m_pPacContext(NULL),
      m_cDefaultSections(NUM_PA_PACREQ_DEFAULT_SECTIONS)
{
    //
    //  Default to only client identity section
    //
    m_rgulDefaultSections[0] = PAC_XBOX_IDENTITY;
}

CPAHandlerPACRequestEx::~CPAHandlerPACRequestEx()
{
    if (m_pPacContext)
        MIDL_user_free( m_pPacContext );

}

HRESULT
__stdcall
CPAHandlerPACRequestEx::QueryInterface(REFIID intf, PVOID *ppv)
{
    HRESULT    hr = E_NOINTERFACE;

    *ppv = NULL;
    if ( IsEqualGUID( intf, IID_IPAPacReqEx ) )
    {
        *ppv = static_cast<IPAPacReqEx*>(this);
        hr = S_OK;
    }
    return hr;
}


KERBERR
__stdcall
CPAHandlerPACRequestEx::Check(
        IN  IKerbRequest                *pIKerbRequest,
        IN  PKERB_PA_DATA_LIST          pPreAuthData,
        OUT PKERB_ENCRYPTION_KEY        pEncryptionKey,
        OUT PKERB_PA_DATA_LIST          *ppOutPadata,
        OUT BOOLEAN*                    pbSufficient,
        OUT PKERB_EXT_ERROR pExtendedError
)
{
    KERBERR                     KerbErr         = KDC_ERR_NONE;
    PKERB_PA_PAC_REQUEST_EX     pPacRequest     = NULL;
    BUILD_PAC_OPTIONS           BuildPac;
    PKERB_PA_PAC_REQUEST_EX_pac_sections pSect  = NULL;
    INT                         iSectionCount   = 0;
    INT                         i;
    PPAC_CONTEXT                pPacContext     = NULL;

    DsysAssert(
        pPreAuthData->value.preauth_data_type == KRB5_PADATA_PAC_REQUEST ||
        pPreAuthData->value.preauth_data_type == KRB5_PADATA_PAC_REQUEST_EX
        );

    //
    // Multiple PACs are strictly not allowed
    // 

    if (m_pPacContext != NULL) 
    {
        KerbErr = KDC_ERR_PREAUTH_FAILED;
        goto Cleanup;
    }

    //
    // New KERB_PA_PAC_REQUEST_EX_PDU can decode KERB_PA_PAC_REQUEST_PDU
    //

    KerbErr = KerbUnpackData(
                pPreAuthData->value.preauth_data.value,
                pPreAuthData->value.preauth_data.length,
                KERB_PA_PAC_REQUEST_EX_PDU,
                (PVOID *) &pPacRequest
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    if (pPacRequest->include_pac)
    {
        BuildPac = IncludePac;

        if (pPacRequest->bit_mask & pac_sections_present)
        {
            for (pSect = pPacRequest->pac_sections;
                 pSect;
                 pSect = pSect->next)
            {
                iSectionCount++;
            }
        }
    }
    else
    {
        BuildPac = DontIncludePac;
    }

    D_DebugLog((DEB_T_TICKETS,"Setting BuildPac from pa-data to %d for %d sections\n",BuildPac,iSectionCount));

    if (iSectionCount > 0)
    {
        pPacContext = (PPAC_CONTEXT) MIDL_user_allocate(
                                sizeof(*pPacContext) +
                                (sizeof(ULONG) * (iSectionCount - ANYSIZE_ARRAY))
                                );
    }
    else
    {
        pPacContext = (PPAC_CONTEXT) MIDL_user_allocate( sizeof( PAC_CONTEXT ));
    }

    if (pPacContext == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    pPacContext->PacOptions     = BuildPac;
    pPacContext->SectionCount     = iSectionCount;

    if (iSectionCount)
    {
        i = 0;
        for (pSect = pPacRequest->pac_sections;
             pSect;
             pSect = pSect->next)
        {
            pPacContext->Sections[i++] = pSect->value;
        }
    }

    m_pPacContext = pPacContext;
    pPacContext   = NULL;

Cleanup:
    if (pPacContext)
        MIDL_user_free( pPacContext );

    if (pPacRequest != NULL)
    {
        KerbFreeData(
            KERB_PA_PAC_REQUEST_EX_PDU,
            pPacRequest
            );
    }
    return(KerbErr);
}



//
//    IPAPacReqEx methods
//

//  not allocating. The info is maintained by the interface
//  and released when it goes away
NTSTATUS __stdcall CPAHandlerPACRequestEx::GetRequestedPacSections(
    OUT    ULONG&   cSections,
    OUT    PULONG&  pulSections
)
{
    if (m_pPacContext)
    {
        cSections   = m_pPacContext->SectionCount;
        pulSections = m_pPacContext->Sections;
    }
    else
    {
        //
        //  default to Passport Puid section
        //
        cSections   = m_cDefaultSections;
        pulSections = m_rgulDefaultSections;
    }
    return STATUS_SUCCESS;
}


//
// allows provs to query for specific PAC sections
//
BOOL __stdcall CPAHandlerPACRequestEx::IsPacSectionRequested(
    IN    ULONG ulSectionId)
{
    ULONG   i;
    BOOL    fRC = FALSE;
    ULONG   cSec = 0, *pulSec = NULL;

    //  compound identity does not have to be requested
    //
    if (ulSectionId == PAC_COMPOUND_IDENTITY)
    {
        return  TRUE;
    }

    if (m_pPacContext)
    {
        //  use passed in PA data
        cSec = m_pPacContext->SectionCount;
        pulSec = m_pPacContext->Sections;
    }
    else
    {
        //  if not present, use defaults
        cSec = m_cDefaultSections;
        pulSec = m_rgulDefaultSections;
    }
    for (i = 0; i < cSec; i++)
    {
        if (ulSectionId == pulSec[i])
        {
            fRC = TRUE;
            break;
        }
    }

    return fRC;
}

BOOL
__stdcall
CPAHandlerPACRequestEx::IsPacRequested()
{
    //
    //  default to returning the Passport PUID section
    //
    BOOL fRC = TRUE;

    if (m_pPacContext)
    {
        fRC = m_pPacContext->PacOptions != DontIncludePac;
    }
    else
    {
        fRC = (m_cDefaultSections > 0);
    }
    return fRC;
}

CPAHandlerPkinit::CPAHandlerPkinit()
{
}

CPAHandlerPkinit::~CPAHandlerPkinit()
{
}


//+-------------------------------------------------------------------------
//
//  Function:   CPAHandlerPkinit::Check
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Returns:    KDC_ERR_NONE                indicates success
//              KDC_ERR_PADATA_TYPE_NOSUPP  no support for KDC cert
//              KRB_AP_ERR_MODIFIED         ScHelperVerifyPkcsMessage failed
//                                              & the return code is in *pNTStatus
//              KDC_ERR_BADOPTION           cert type is not supported
//              KDC_ERR_SUMTYPE_NOSUPP      signature did not match
//              KDC_ERR_S_PRINCIPAL_UNKNOWN realm name in the authenticator does not match the
//                                          request
//
//  Notes:      this routine allows in-place decryption
//
//--------------------------------------------------------------------------
KERBERR __stdcall CPAHandlerPkinit::Check(
        IN  IKerbRequest                *pIKerbRequest,
        IN  PKERB_PA_DATA_LIST          pPreAuthData,
        OUT PKERB_ENCRYPTION_KEY        pEncryptionKey,
        OUT PKERB_PA_DATA_LIST          *ppOutPadata,
        OUT BOOLEAN*                    pbSufficient,
        OUT PKERB_EXT_ERROR pExtendedError
)
{
    return KdcCheckPkinitPreAuthData(
                    pIKerbRequest,
                    pPreAuthData,
                    pEncryptionKey,
                    ppOutPadata,
                    pExtendedError);
}

CPAHandlerPkinitCompat::CPAHandlerPkinitCompat()
{
}

CPAHandlerPkinitCompat::~CPAHandlerPkinitCompat()
{
}


//+-------------------------------------------------------------------------
//
//  Function:   CPAHandlerPkinitCompat::Check
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Returns:    KDC_ERR_NONE                indicates success
//              KDC_ERR_PADATA_TYPE_NOSUPP  no support for KDC cert
//              KRB_AP_ERR_MODIFIED         ScHelperVerifyPkcsMessage failed
//                                              & the return code is in *pNTStatus
//              KDC_ERR_BADOPTION           cert type is not supported
//              KDC_ERR_SUMTYPE_NOSUPP      signature did not match
//              KDC_ERR_S_PRINCIPAL_UNKNOWN realm name in the authenticator does not match the
//                                          request
//
//  Notes:      this routine allows in-place decryption
//
//--------------------------------------------------------------------------
KERBERR __stdcall CPAHandlerPkinitCompat::Check(
        IN  IKerbRequest                *pIKerbRequest,
        IN  PKERB_PA_DATA_LIST          pPreAuthData,
        OUT PKERB_ENCRYPTION_KEY        pEncryptionKey,
        OUT PKERB_PA_DATA_LIST          *ppOutPadata,
        OUT BOOLEAN*                    pbSufficient,
        OUT PKERB_EXT_ERROR pExtendedError
)
{
    return KdcCheckPkinitPreAuthData(
                    pIKerbRequest,
                    pPreAuthData,
                    pEncryptionKey,
                    ppOutPadata,
                    pExtendedError);
}

//------------------------------------------------------------------------------------------
//                            F a c t o r i e s
//------------------------------------------------------------------------------------------



//
//  Since CPAHandlerEType is stateless, the factory will just use a member var. for
//  the handler.
//
//  Obviously, the factory must be released only when all PA handling is completed.
//
NTSTATUS __stdcall CPAHandlerETypeFactory::CreateInstance(
        IN  IKerbRequest    *pIKerbRequest,     //it might be helpful to pass IKerbRequest along
        OUT IPAHandler      **ppIPAHandler)
{
    *ppIPAHandler = &m_PAHandler;
    return STATUS_SUCCESS;
}

NTSTATUS __stdcall CPAHandlerPwSaltFactory::CreateInstance(
        IN  IKerbRequest    *pIKerbRequest,     //it might be helpful to pass IKerbRequest along
        OUT IPAHandler      **ppIPAHandler
)
{
    *ppIPAHandler = &m_PAHandler;
    return STATUS_SUCCESS;
}

NTSTATUS __stdcall CPAHandlerEncryptedTimeFactory::CreateInstance(
        IN  IKerbRequest    *pIKerbRequest,     //it might be helpful to pass IKerbRequest along
        OUT IPAHandler      **ppIPAHandler
)
{
    *ppIPAHandler = &m_PAHandler;
    return STATUS_SUCCESS;
}

NTSTATUS __stdcall CPAHandlerPACReqExFactory::CreateInstance(
        IN  IKerbRequest    *pIKerbRequest,     //it might be helpful to pass IKerbRequest along
        OUT IPAHandler      **ppIPAHandler
)
{
    *ppIPAHandler= new CPAHandlerPACRequestEx;
    if (*ppIPAHandler == NULL)
        return  STATUS_NO_MEMORY;

    return STATUS_SUCCESS;
}

NTSTATUS __stdcall CPAHandlerPkinitFactory::CreateInstance(
        IN  IKerbRequest    *pIKerbRequest,     //it might be helpful to pass IKerbRequest along
        OUT IPAHandler      **ppIPAHandler
)
{
    *ppIPAHandler = &m_PAHandler;
    return STATUS_SUCCESS;
}

NTSTATUS __stdcall CPAHandlerPkinitCompatFactory::CreateInstance(
        IN  IKerbRequest    *pIKerbRequest,     //it might be helpful to pass IKerbRequest along
        OUT IPAHandler      **ppIPAHandler
)
{
    *ppIPAHandler = &m_PAHandler;
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\server\preauth.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       preauth.h
//
//  Contents:   KDC Preauth function interfaces
//
//  Classes:
//
//  Functions:
//
//  History:    21-June-2001    JBrezak
//              12-Sept-2001    yordanr modified for new interface
//
//----------------------------------------------------------------------------

#ifndef _PREAUTH_H_
#define _PREAUTH_H_

KERBERR
KdcCheckPreAuthData(
    IN PIKdbProvider            piKdb,
    IN KERB_SERVICE_ID          Service,
    IN PIKerbPrincipal              ClientInfo,
    IN OPTIONAL PKERB_PA_DATA_LIST PreAuthData,
    IN PKERB_KDC_REQUEST_BODY   RequestBody,
    OUT OPTIONAL PULONG         PreAuthType,
    OUT PKERB_PA_DATA_LIST      *OutputPreAuthData,
    OUT OPTIONAL PKERB_ENCRYPTION_KEY EncryptionKey,
    OUT OPTIONAL PUNICODE_STRING TransitedRealms,
    OUT PKERB_EXT_ERROR pExtendedError,
    IN  CKerbRequest*            pKerbReq
    );

KERBERR
KdcReturnPreAuthData(
    IN CKerbRequest             *pReq,
    OUT PKERB_PA_DATA_LIST      *OutputPreAuthData
    );


NTSTATUS __stdcall
RegisterCorePAHandlerFactories(
    VOID
    );



#endif // _PREAUTH_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\server\pkserv.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        pkserv.cxx
//
// Contents:    Server side public key support for Kerberos
//
//
// History:     24-Nov-1997     MikeSw          Created
//
//------------------------------------------------------------------------

#include "kdcsvr.hxx"
#include <wininet.h>    // for SECURITY_FLAG_xxx
#include <sclogon.h>    // ScHelperXXX
//#include <certca.h>     // for CA*XXX

//
//  do avoid typedef collision
//
#include "kerbinterface.h"

#define FILENO FILENO_PKSERV
//
// This is the cert store containing the CTL used to verify client certificates
//

HCERTSTORE  g_hCryptCertStore = NULL;
HCRYPTPROV g_hCryptClientProvider = NULL;

PCCERT_CONTEXT GlobalKdcCert = NULL;
HANDLE   KdcCertStoreChangeEvent = NULL;
TimeStamp KdcLastChangeEventTime;

CRITICAL_SECTION KdcGlobalCertCritSect;
BOOLEAN              KdcGlobalCertCritSectInitialized = FALSE;

HANDLE KdcCertStoreWait = NULL;
BOOLEAN KdcPKIInitialized = FALSE;

BOOLEAN g_fKdc3DesSupported = TRUE;
HANDLE KdcCaNotificationHandle = NULL;
#define KDC_ROOT_STORE L"ROOT"
#define KDC_PRIVATE_MY_STORE L"MY"

#define MAX_TEMPLATE_NAME_VALUE_SIZE             80 // sizeof (CERT_NAME_VALUE) + wcslen(SmartcardLogon)

KERB_OBJECT_ID g_KdcSignatureAlg[10];


NTSTATUS
KdcGetKdcCertificate(PCCERT_CONTEXT *KdcCert);

//+-------------------------------------------------------------------------
//
//  Function:   KdcCheckCertificate
//
//  Synopsis:   a helper routine to verify the certificate. It will check
//              CRLs, CTLs
//
//  Effects:
//
//  Arguments:
//          CertContext - the certificate to check
//          EmbeddedUPNOk - returns TRUE if the certificate can
//                           be translated to a user by looking at the
//                           subject name.
//                           returns FALSE if the certificate must be
//                           mapped by looking in the user's mapped certificate
//                           ds attribute.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcCheckCertificate(
    IN PCCERT_CONTEXT  CertContext,
    OUT PBOOLEAN EmbeddedUPNOk,
    IN OUT PKERB_EXT_ERROR pExtendedError,
    IN OUT OPTIONAL PCERT_CHAIN_POLICY_STATUS FinalChainStatus,
    IN BOOLEAN KdcCert
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    CERT_CHAIN_PARA ChainParameters = {0};
    LPSTR Usage = (KdcCert ? KERB_PKINIT_KDC_CERT_TYPE : KERB_PKINIT_CLIENT_CERT_TYPE);
    PCCERT_CHAIN_CONTEXT ChainContext = NULL;
    CERT_CHAIN_POLICY_STATUS PolicyStatus ={0};

    ChainParameters.cbSize = sizeof(CERT_CHAIN_PARA);
    ChainParameters.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
    ChainParameters.RequestedUsage.Usage.cUsageIdentifier = 1;
    ChainParameters.RequestedUsage.Usage.rgpszUsageIdentifier = &Usage;

    *EmbeddedUPNOk = FALSE;


    if (!CertGetCertificateChain(
                          HCCE_LOCAL_MACHINE,
                          CertContext,
                          NULL,                 // evaluate at current time
                          NULL,                 // no additional stores
                          &ChainParameters,
                          CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT,
                          NULL,                 // reserved
                          &ChainContext
                          ))
    {
        D_DebugLog((DEB_WARN,"Failed to verify certificate chain: %0x%x\n",GetLastError()));
        KerbErr = KDC_ERR_CLIENT_NOT_TRUSTED;
        goto Cleanup;

    }
    else
    {
        CERT_CHAIN_POLICY_PARA ChainPolicy;
        ZeroMemory(&ChainPolicy, sizeof(ChainPolicy));

        ChainPolicy.cbSize = sizeof(ChainPolicy);

        ZeroMemory(&PolicyStatus, sizeof(PolicyStatus));
        PolicyStatus.cbSize = sizeof(PolicyStatus);
        PolicyStatus.lChainIndex = -1;
        PolicyStatus.lElementIndex = -1;


        if (!CertVerifyCertificateChainPolicy(
                                        CERT_CHAIN_POLICY_NT_AUTH,
                                        ChainContext,
                                        &ChainPolicy,
                                        &PolicyStatus))
        {
           D_DebugLog((DEB_WARN,"CertVerifyCertificateChainPolicy failure: %0x%x\n", GetLastError()));
           KerbErr = KDC_ERR_CLIENT_NOT_TRUSTED;
           goto Cleanup;
        }

        if(PolicyStatus.dwError == S_OK)
        {
            *EmbeddedUPNOk = TRUE;
        }
        else if(CERT_E_UNTRUSTEDCA == PolicyStatus.dwError)
        {
            // We can't use this cert for fast-mapping, but we can still
            // slow-map it.
            *EmbeddedUPNOk = FALSE;
        }
        else
        {
            D_DebugLog((DEB_WARN,"CertVerifyCertificateChainPolicy - Chain Status failure: %0x%x\n",PolicyStatus.dwError));
            KerbErr = KDC_ERR_CLIENT_NOT_TRUSTED;
            goto Cleanup;
        }
    }

Cleanup:
    if (PolicyStatus.dwError != S_OK)
    {
       FILL_EXT_ERROR_EX(pExtendedError, PolicyStatus.dwError,FILENO,__LINE__);
       if (ARGUMENT_PRESENT(FinalChainStatus))
       {
           memcpy(
               FinalChainStatus,
               &PolicyStatus,
               sizeof(CERT_CHAIN_POLICY_STATUS)
               );
       }
    }

    if (ChainContext != NULL)
    {
        CertFreeCertificateChain(ChainContext);
    }

    return(KerbErr);
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcVerifyClientCertName
//
//  Synopsis:   Verifies that the mapping of a client's cert name matches
//              the mapping of the client name from the AS request
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------



KERBERR
KdcVerifyClientCertName(
    IN  IKdbProvider        *pIKdbProvider,
    IN  IKerbRequest        *pIKerbRequest,
    IN  PCCERT_CONTEXT      ClientCert,
    IN  PKERB_INTERNAL_NAME pkinClientName,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    UNICODE_STRING      NameString = {0};
    PKERB_INTERNAL_NAME ClientName = NULL;
    KERBERR             KerbErr = KDC_ERR_NONE;
    IKerbPrincipal      *pIPrincTicket = NULL;

    //
    // Get the client name from the cert
    //
    if (STATUS_SUCCESS != KerbGetPrincipalNameFromCertificate(ClientCert, &NameString))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    D_DebugLog((DEB_TRACE,"Email name from certificate is %wZ\n",&NameString));

    KerbErr = KerbConvertStringToKdcName(
                &ClientName,
                &NameString
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    ClientName->NameType = KRB_NT_ENTERPRISE_PRINCIPAL;


    //
    // Now crack the name & see if it refers to us
    //

    KerbErr = pIKdbProvider->GetPrincipal(
                 KDC_KDB_GET_PRINC_CLIENT,
                 ClientName,
                 NULL,
                 pIKerbRequest,
                 &pIPrincTicket,
                 pExtendedError,
                 NULL
                 );


    //
    // If this is a referral, return an error and the true realm name
    // of the client
    //
    if (KerbErr == KDC_ERR_WRONG_REALM)
    {
        DebugLog((DEB_WARN,"Client tried to logon to account in another realm\n"));
        goto Cleanup;
    }

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to lookup client name "));
        KerbPrintKdcName(DEB_ERROR,ClientName);
        goto Cleanup;
    }

    //
    // Verify the client cert matches the client
    //
    //
    // Compare the princ and realm names since the UserID is not visable
    //
    if (!KerbEqualKdcNames((PKERB_INTERNAL_NAME)pIPrincTicket->GetName(), pkinClientName))
    {
        DebugLog((DEB_ERROR,"Cert name doesn't match user name: %wZ\n",
            &NameString));
        KerbErr = KDC_ERR_CLIENT_NAME_MISMATCH;
        goto Cleanup;
    }

Cleanup:

    KerbFreeString( &NameString);
    KerbFreeKdcName( &ClientName );

    if (pIPrincTicket)
        pIPrincTicket->Release();

    return(KerbErr);


}


//+-------------------------------------------------------------------------
//
//  Function:   KdcConvertNameString
//
//  Synopsis:   Converts the cr-lf to , in a dn
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


void
KdcConvertNameString(
    IN PUNICODE_STRING Name,
    IN WCHAR ReplacementChar
    )
{
    PWCHAR Comma1, Comma2;

    //
    // Scan through the name, converting "\r\n" to the replacement char.  This
    // should be done by the CertNameToStr APIs, but that won't happen for
    // a while.
    //

    Comma1 = Comma2 = Name->Buffer ;
    while ( *Comma2 )
    {
        *Comma1 = *Comma2 ;

        if ( *Comma2 == L'\r' )
        {
            if ( *(Comma2 + 1) == L'\n' )
            {
                *Comma1 = ReplacementChar;
                Comma2++ ;
            }
        }

        Comma1++;
        Comma2++;
    }

    *Comma1 = L'\0';

    Name->Length = (USHORT) wcslen( Name->Buffer ) * sizeof( WCHAR );
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcVerifyMappedClientCertIdentity
//
//  Synopsis:   Verifies that the mapping of a client's cert identity
//              the mapping of the client name from the AS request.  The
//              cert should be in the list of mapped ceritificates for this
//              user.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


#define ISSUER_HEADER       L"<I>"
#define CCH_ISSUER_HEADER   3
#define SUBJECT_HEADER      L"<S>"
#define CCH_SUBJECT_HEADER  3

KERBERR
KdcVerifyMappedClientCertIdentity(
    IN PCCERT_CONTEXT ClientCert,
    IN PKERB_INTERNAL_NAME  pkinClient,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    KERBERR KerbErr = KDC_ERR_CLIENT_NAME_MISMATCH;
    //
    // Disable this code for now
    //
#ifdef notdef
    UNICODE_STRING CompoundName = {0};
    ULONG SubjectLength ;
    ULONG IssuerLength ;
    NTSTATUS Status ;
    PWCHAR Current ;
    KDC_PRINC_INFO TicketInfo = {0};
    DWORD dwNameToStrFlags = CERT_X500_NAME_STR |
                                   CERT_NAME_STR_NO_PLUS_FLAG |
                                   CERT_NAME_STR_CRLF_FLAG;


    //
    // Build the name of the form <i>issuer <s> subject
    //

    IssuerLength = CertNameToStr( ClientCert->dwCertEncodingType,
                                   &ClientCert->pCertInfo->Issuer,
                                   dwNameToStrFlags,
                                   NULL,
                                   0 );

    SubjectLength = CertNameToStr( ClientCert->dwCertEncodingType,
                            &ClientCert->pCertInfo->Subject,
                            dwNameToStrFlags,
                            NULL,
                            0 );

    if ( ( IssuerLength == 0 ) ||
         ( SubjectLength == 0 ) )
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    CompoundName.MaximumLength = (USHORT) (SubjectLength + IssuerLength +
                                 CCH_ISSUER_HEADER + CCH_SUBJECT_HEADER) *
                                 sizeof( WCHAR ) ;

    CompoundName.Buffer = (LPWSTR) MIDL_user_allocate( CompoundName.MaximumLength );

    if ( CompoundName.Buffer == NULL )
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    wcscpy( CompoundName.Buffer, ISSUER_HEADER );
    Current = CompoundName.Buffer + CCH_ISSUER_HEADER ;

    IssuerLength = CertNameToStr( ClientCert->dwCertEncodingType,
                               &ClientCert->pCertInfo->Issuer,
                               dwNameToStrFlags,
                               Current,
                               IssuerLength );

    Current += IssuerLength - 1 ;
    wcscpy( Current, SUBJECT_HEADER );
    Current += CCH_SUBJECT_HEADER ;

    SubjectLength = CertNameToStr( ClientCert->dwCertEncodingType,
                        &ClientCert->pCertInfo->Subject,
                        dwNameToStrFlags,
                        Current,
                        SubjectLength );

    KdcConvertNameString(
        &CompoundName,
        L','
        );

    //
    // Get ticket info for this name
    //

    KerbErr = KdbGetPrincipalInfo(
                &CompoundName,
                SAM_OPEN_BY_ALTERNATE_ID,
                NULL,                   // no kerb principal name
                NULL,
                &TicketInfo,
                NULL,                   // no handle
                0L,                     // no fields to fetch
                0L,                     // no extended fields
                NULL,                   // no user all
                NULL                    // no membership
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"Failed to get ticket info for %wZ to verify certZ\n",
            &CompoundName));
        goto Cleanup;
    }

    if (TicketInfo.UserId != ClientTicketInfo->UserId)
    {
        D_DebugLog((DEB_ERROR,"Cert name doesn't match user name: %wZ, %wZ\n",
            &TicketInfo.AccountName, &ClientTicketInfo->AccountName));
        KerbErr = KRB_AP_ERR_BADMATCH;
        goto Cleanup;
    }


Cleanup:
    KerbFreeString(&CompoundName);
    FreeTicketInfo( &TicketInfo );
#endif
    return(KerbErr);
}




//+-------------------------------------------------------------------------
//
//  Function:   KdcCheckForEtype
//
//  Synopsis:   Checks if a client supports a particular etype
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:    TRUE if it does, false if it doesn't
//
//  Notes:
//
//
//--------------------------------------------------------------------------

BOOLEAN
KdcCheckForEtype(
    IN PKERB_CRYPT_LIST CryptList,
    IN ULONG Etype
    )
{
    PKERB_CRYPT_LIST List = CryptList;

    while (List != NULL)
    {
        if ((ULONG) List->value == Etype)
        {
            return(TRUE);
        }
        List=List->next;
    }

    return(FALSE);
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcCheckPkinitPreAuthData
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
KERBERR
KdcCheckPkinitPreAuthData(
        IN  IKerbRequest                *pIKerbRequest,
        IN  PKERB_PA_DATA_LIST           pPreAuthData,
        OUT PKERB_ENCRYPTION_KEY         pEncryptionKey,
        OUT PKERB_PA_DATA_LIST          *ppOutPadata,
        OUT PKERB_EXT_ERROR pExtendedError
)
{
    NTSTATUS                    Status;
    KERBERR                     KerbErr                 = KDC_ERR_NONE;
    PCCERT_CONTEXT              pKdcCert                = NULL;
    LARGE_INTEGER               CurrentTime;
    PKERB_PA_PK_AS_REQ          pPkAsReq                = NULL;
    PKERB_PA_PK_AS_REQ2         pPkAsReq2               = NULL;
    PBYTE                       pbPackedAuthenticator    = NULL;
    ULONG                       cbPackedAuthenticator= NULL;
    PKERB_AUTH_PACKAGE          pAuthPack               = NULL;
    PKERB_PK_AUTHENTICATOR      pPkAuthenticator        = NULL;
    PKERB_CERTIFICATE           pUserCert               = NULL;
    PCCERT_CONTEXT              pCertContext            = NULL;
    PKERB_SIGNATURE             pSignature              = NULL;
    HCRYPTKEY                   hClientKey              = NULL;
    KERB_EXT_ERROR              ExtendedError           = {0};
    IKerbPrincipal              *pIPrincipalClient      = NULL;
    PKERB_INTERNAL_NAME         pkinClient              = NULL;
    UNICODE_STRING              ustrClientKdcName = {0};
    ULONG                       ulClientKdcNameType;
    UNICODE_STRING              ustrKdcKrbTgtName={0};
    LARGE_INTEGER               ClientTime;
    ULONG                       Nonce                   = 0L;
    PULONG                      pulEtypeArray           = NULL;
    ULONG                       cEtypes                 = 0;
    ULONG                       CommonEtype;
    IKerbCrypt                  *pIKerbCrypt            = NULL;
    PKERB_PA_DATA_LIST          pPackedPkAsRep          = NULL;
    KERB_SIGNED_REPLY_KEY_PACKAGE KeyPack               = {0};
    PBYTE                       pbPackedKeyPack         = NULL;
    ULONG                       cbPackedKeyPack;
    HCRYPTPROV                  hKdcProvider            = NULL;
    BOOL                        fFreeProvider           = FALSE;
    PBYTE                       pbSignedKeyPack         = NULL;
    ULONG                       cbSignedKeyPack;
    PBYTE                       pbPackedKey             = NULL;
    ULONG                       cbPackedKey             = 0;
    ULONG                       cbRequired              = 0;
    BOOLEAN                     fUsed3Des               = FALSE;
    CERT_CHAIN_POLICY_STATUS    FinalChainStatus        = {0};
    BOOLEAN                     fEmbeddedUPNOk          = FALSE;
    KERB_REPLY_KEY_PACKAGE      ReplyKey                = {0};

#define KERB_PK_MAX_SIGNATURE_SIZE 128
    BYTE                        rgbPkSignature[KERB_PK_MAX_SIGNATURE_SIZE];
    ULONG                       cbPkSignature           = KERB_PK_MAX_SIGNATURE_SIZE;
    CRYPT_ALGORITHM_IDENTIFIER  CryptAlg                = {0};
    PBYTE                       pbEncryptedKeyPack      = NULL;
    PKERB_CERTIFICATE_LIST      CertList                = NULL;
    PUNICODE_STRING             pustrClientRealm        = NULL;
    IKdbProvider                *pIKdbProvider          = NULL;


    //
    // Prepare the output variables
    //

    *ppOutPadata = NULL;
    ZeroMemory(
        pEncryptionKey,
        sizeof(KERB_ENCRYPTION_KEY)
        );

    //
    // If we don't do this preauth, return such
    //

    Status = KdcGetKdcCertificate(&pKdcCert);
    if (!NT_SUCCESS(Status))
    {
#ifdef TBD
       //
       // Log an event
       //
       KdbReportEventW(
           IEvent::ERROR_TYPE,
           KDCEVENT_NO_KDC_CERTIFICATE,
           0,
           NULL,
           0
           );
#endif
       FILL_EXT_ERROR_EX(&ExtendedError, STATUS_PKINIT_FAILURE, FILENO, __LINE__);
       return(KDC_ERR_PADATA_TYPE_NOSUPP);
    }


    GetSystemTimeAsFileTime((PFILETIME) &CurrentTime );

    //
    // First, unpack the outer KRB-PA-PK-AS-REQ
    //


    KerbErr = KerbUnpackData(
                pPreAuthData->value.preauth_data.value,
                pPreAuthData->value.preauth_data.length,
                KERB_PA_PK_AS_REQ_PDU,
                (PVOID *) &pPkAsReq
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        //
        // Try the older variation
        //

        KerbErr = KerbUnpackData(
                    pPreAuthData->value.preauth_data.value,
                    pPreAuthData->value.preauth_data.length,
                    KERB_PA_PK_AS_REQ2_PDU,
                    (PVOID *) &pPkAsReq2
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            DebugLog((DEB_ERROR,"Failed to unpack PA-PK-AS-REQ(2): 0x%x\n",KerbErr));
            goto Cleanup;
        }
    }

    if (pPkAsReq != NULL)
    {
        //
        // Verify the signature
        //

        Status = ScHelperVerifyPkcsMessage(
                    NULL,
                    g_hCryptClientProvider,
                    pPkAsReq->signed_auth_pack.value,
                    pPkAsReq->signed_auth_pack.length,
                    pbPackedAuthenticator,
                    &cbPackedAuthenticator,
                    NULL        // don't return certificate context
                    );

        if ((Status != ERROR_MORE_DATA) && (Status != STATUS_SUCCESS))
        {
            DebugLog((DEB_ERROR,"Failed to verify message: %x\n",Status));
            FILL_EXT_ERROR(&ExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_AP_ERR_MODIFIED;
            goto Cleanup;
        }

        pbPackedAuthenticator = (PBYTE) MIDL_user_allocate(cbPackedAuthenticator);
        if (pbPackedAuthenticator == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        Status = ScHelperVerifyPkcsMessage(
                    NULL,
                    g_hCryptClientProvider,
                    pPkAsReq->signed_auth_pack.value,
                    pPkAsReq->signed_auth_pack.length,
                    pbPackedAuthenticator,
                    &cbPackedAuthenticator,
                    &pCertContext
                    );
        if (Status != STATUS_SUCCESS)
        {
            DebugLog((DEB_ERROR,"Failed to verify message: %x\n",Status));
            FILL_EXT_ERROR(&ExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_AP_ERR_MODIFIED;
            goto Cleanup;
        }

        //
        // Unpack the auth package
        //

        KerbErr = KerbUnpackData(
                    pbPackedAuthenticator,
                    cbPackedAuthenticator,
                    KERB_AUTH_PACKAGE_PDU,
                    (PVOID *)&pAuthPack
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        pPkAuthenticator = &pAuthPack->pk_authenticator;

    }
    else
    {
        DsysAssert(pPkAsReq2 != NULL);
        if (!pPkAsReq2)
        {
            // TODO: Put more appropriate error code
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        //
        // Get the user certificate & verify
        //

        if ((pPkAsReq2->bit_mask & user_certs_present) == 0)
        {
            DebugLog((DEB_ERROR,"Client tried to use pkinit w/o client cert\n"));
            KerbErr = KDC_ERR_BADOPTION;
            goto Cleanup;
        }

        //
        // Just use the first of the certificates
        //

        pUserCert = &pPkAsReq2->user_certs->value;

        //
        // We only handle x509 certificates
        //

        if (pUserCert->cert_type != KERB_CERTIFICATE_TYPE_X509)
        {
            DebugLog((DEB_ERROR,"User supplied bad cert type: %d\n",pUserCert->cert_type));
            KerbErr = KDC_ERR_BADOPTION;
            goto Cleanup;
        }

        //
        // Decode the certificate.
        //

        pCertContext = CertCreateCertificateContext(
                        X509_ASN_ENCODING,
                        pUserCert->cert_data.value,
                        pUserCert->cert_data.length
                        );
        if (pCertContext == NULL)
        {
            Status = GetLastError();
            DebugLog((DEB_ERROR,"Failed to create certificate context: 0x%x\n",Status));
            FILL_EXT_ERROR(&ExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }



        //
        // Verify the authenticator
        //

        pSignature = &pPkAsReq2->signed_auth_pack.auth_package_signature;

        //
        // Now import the key from the certificate
        //

        if (!CryptImportPublicKeyInfo(
                g_hCryptClientProvider,
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                &pCertContext->pCertInfo->SubjectPublicKeyInfo,
                &hClientKey
                ))
        {
            DebugLog((DEB_ERROR,"Failed to import public key: 0x%x\n",GetLastError()));
            FILL_EXT_ERROR(&ExtendedError, GetLastError(), FILENO, __LINE__);
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        //
        // Encode the data to be verified
        //

        KerbErr = KerbPackData(
                    &pPkAsReq2->signed_auth_pack.auth_package,
                    KERB_AUTH_PACKAGE_PDU,
                    &cbPackedAuthenticator,
                    &pbPackedAuthenticator
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        //
        // Verify the signature on the message
        //

        if (!KerbCompareObjectIds(
                pSignature->signature_algorithm.algorithm,
                g_KdcSignatureAlg
                ))
        {
            DebugLog((DEB_ERROR,"Unsupported signature algorithm (not MD5)\n"));
            KerbErr = KDC_ERR_SUMTYPE_NOSUPP;
            goto Cleanup;
        }

        Status = ScHelperVerifyMessage(
                    NULL,                           // no logon info
                    g_hCryptClientProvider,
                    pCertContext,
                    KERB_PKINIT_SIGNATURE_ALG,
                    pbPackedAuthenticator,
                    cbPackedAuthenticator,
                    pSignature->pkcs_signature.value,
                    pSignature->pkcs_signature.length / 8            // because it is a bit string
                    );
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to verify message: 0x%x\n",Status));
            FILL_EXT_ERROR(&ExtendedError, Status, FILENO, __LINE__);
            KerbErr = KDC_ERR_INVALID_SIG;
            goto Cleanup;
        }

        //
        // Now check the information in the authenticator itself.
        //

        pPkAuthenticator = &pPkAsReq2->signed_auth_pack.auth_package.pk_authenticator;

    }

    //
    // Call a helper routine to verify the certificate. It will check
    // CRLs, CTLs,
    //

    KerbErr = KdcCheckCertificate(
                pCertContext,
                &fEmbeddedUPNOk,
                &ExtendedError,
                &FinalChainStatus,
                FALSE // not a kdc certificate
                );

    //
    // Assume B3 certs aren't being used
    // anymore
    //
    /*if(!KERB_SUCCESS(KerbErr))
    {
        KerbErr = KdcCheckB3Certificate(
                    CertContext,
                    &EmbeddedUPNOk
                    );
    } */

    //
    //  get the client principal. This is only for AS request
    //
    assert( pIKerbRequest->GetServId() == KerbAs );
    pIPrincipalClient = pIKerbRequest->GetIPrincClient();
    if ( NULL == pIPrincipalClient )
    {
        KerbErr = KRB_ERR_GENERIC;
        DebugLog((DEB_ERROR,"Failed to get CLIENT Principal : 0x%x\n",KerbErr));
        goto Cleanup;
    }

    pkinClient = (const PKERB_INTERNAL_NAME)pIPrincipalClient->GetName();
    if ( NULL == pkinClient )
    {
        KerbErr = KRB_ERR_GENERIC;
        DebugLog((DEB_ERROR,"Failed to get Client principal name: 0x%x\n",KerbErr));
        goto Cleanup;
    }

    if (!KERB_SUCCESS(KerbErr))
    {
        //
        // Dumb this down for release?  FESTER
        //
        if ((KDCInfoLevel & DEB_T_PKI) != 0)
        {
            UNICODE_STRING UTmp = {0};
            LPWSTR Tmp = NULL;

            KerbConvertKdcNameToString(&UTmp, pkinClient, NULL);
            if (UTmp.Buffer != NULL)
                Tmp = KerbBuildNullTerminatedString(&UTmp);

            if (Tmp != NULL)
            {
#ifdef TBD
                KdbReportEventW(
                    IEvent::WARNING_TYPE,
                    KDCEVENT_INVALID_CLIENT_CERTIFICATE,
                    sizeof(FinalChainStatus) - sizeof(void*),  // don't need ptr.
                    &FinalChainStatus,
                    1,
                    Tmp
                    );
#endif
                MIDL_user_free(Tmp);
            }
            KerbFreeString(&UTmp);
        }

        DebugLog((DEB_ERROR,"Failed to check CLIENT certificate: 0x%x\n",KerbErr));
        goto Cleanup;
    }

    //
    // Verify the cert is for the right client
    //
    pustrClientRealm = (const PUNICODE_STRING)pIPrincipalClient->GetRealm();
    if ( !pustrClientRealm )
    {
        DebugLog((DEB_ERROR,"KLIN(%x) Failed to locate handle for referral realm",
                  KLIN(FILENO,__LINE__)));
        KerbErr = KDC_ERR_WRONG_REALM;
        goto Cleanup;
    }
    pIKdbProvider = KdcGetProvider(pustrClientRealm);

    if(fEmbeddedUPNOk)
    {
        KerbErr = KdcVerifyClientCertName(
                    pIKdbProvider,
                    pIKerbRequest,
                    pCertContext,
                    pkinClient,
                    pExtendedError
                    );
    }
    else
    {
        KerbErr = KdcVerifyMappedClientCertIdentity(
                    pCertContext,
                    pkinClient,
                    &ExtendedError
                    );
    }

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"KDC failed to verify client's identity from cert\n"));
        goto Cleanup;
    }

#ifdef later
    //
    // BUG 455112: this code breaks MIT KDCs, which can't handle a strange
    // x.500 name in the transited field. So, for NT5, disable the code
    //

    //
    // Put the issuer name in as a transited realm, as it is invovled in
    // the authentication decision.
    //

    TransitedLength = CertNameToStr( CertContext->dwCertEncodingType,
                                   &CertContext->pCertInfo->Issuer,
                                   dwNameToStrFlags,
                                   NULL,
                                   0 );


    if ( TransitedLength == 0 )
    {
        D_DebugLog((DEB_ERROR,"Failed to get issuer name: 0x%x\n",GetLastError()));
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }


    TransitedRealm->MaximumLength = (USHORT) TransitedLength * sizeof(WCHAR) + sizeof(WCHAR);
    TransitedRealm->Length = (USHORT) TransitedLength * sizeof(WCHAR);
    TransitedRealm->Buffer = (LPWSTR) MIDL_user_allocate( TransitedRealm->MaximumLength );

    if ( TransitedRealm->Buffer == NULL )
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }


    TransitedLength = CertNameToStr( CertContext->dwCertEncodingType,
                               &CertContext->pCertInfo->Issuer,
                               dwNameToStrFlags,
                               TransitedRealm->Buffer,
                               TransitedLength );

    if ( TransitedLength == 0 )
    {
        D_DebugLog((DEB_ERROR,"Failed to get issuer name: 0x%x\n",GetLastError()));
        FILL_EXT_ERROR(&ExtendedError, GetLastError(), FILENO, __LINE__);
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    //
    // Convert the "." to "/"
    //


    KdcConvertNameString(
        TransitedRealm,
        L'/'
        );

#endif // later

    KerbErr = KerbConvertPrincipalNameToString(
                &ustrClientKdcName,
                &ulClientKdcNameType,
                &pPkAuthenticator->kdc_name
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Verify the realm name is correct
    //
    if (!KerbCompareUnicodeRealmNames(
            pustrClientRealm,
            &ustrClientKdcName
            ))

    {
        DebugLog((DEB_ERROR,"Client used wrong realm in PK authenticator: %s\n",
            pPkAuthenticator->kdc_realm
            ));

        KerbErr = KDC_ERR_S_PRINCIPAL_UNKNOWN;
        goto Cleanup;

    }


    KerbErr = KerbBuildFullServiceName(
                pustrClientRealm,
                &KrbtgtName,
                &ustrKdcKrbTgtName);
    if (!KERB_SUCCESS(KerbErr))
    {
        //TBD:log ?
        goto Cleanup;
    }
    if (!RtlEqualUnicodeString(
            &ustrKdcKrbTgtName,
            &ustrClientKdcName,
            TRUE))
    {
        DebugLog((DEB_ERROR,"Client provided KDC name is wrong: %wZ\n",
                  &ustrClientKdcName));

        KerbErr = KDC_ERR_KDC_NAME_MISMATCH;
        goto Cleanup;
    }

    //
    // Now verify the time
    //

    KerbConvertGeneralizedTimeToLargeInt(
        &ClientTime,
        &pPkAuthenticator->client_time,
        pPkAuthenticator->cusec
        );

    if (!KerbCheckTimeSkew(
            &CurrentTime,
            &ClientTime,
            &pIKdbProvider->GetKdcPolicy()->TimeSkew))
    {
        KerbErr = KRB_AP_ERR_SKEW;
        goto Cleanup;
    }

    Nonce = pPkAuthenticator->nonce;

    //
    // Generate a temporary key. First find a good encryption type
    //
    KerbErr = KerbConvertCryptListToArray(
                &pulEtypeArray,
                &cEtypes,
                pIKerbRequest->GetEncryptionTypes()
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    Status = CDFindCommonCSystem(
                cEtypes,
                pulEtypeArray,
                &CommonEtype
                );
    if (!NT_SUCCESS(Status))
    {
        KerbErr = KDC_ERR_ETYPE_NOTSUPP;
        goto Cleanup;
    }

    //
    //  get to the IKerbCrypt
    //
    pIKerbCrypt = KdcGetICrypt();

    assert(pIKerbCrypt);
    assert(pEncryptionKey);
    KerbErr = pIKerbCrypt->MakeKey(
                CommonEtype,
                &pEncryptionKey
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Build the return structure
    //

    pPackedPkAsRep = (PKERB_PA_DATA_LIST) MIDL_user_allocate(sizeof(KERB_PA_DATA_LIST));
    if (pPackedPkAsRep == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    ZeroMemory(
        pPackedPkAsRep,
        sizeof(KERB_PA_DATA_LIST)
        );

    pPackedPkAsRep->next = NULL;
    pPackedPkAsRep->value.preauth_data_type = KRB5_PADATA_PK_AS_REP;

    //
    // Success. Now build the reply
    //

    if (pPkAsReq2 != NULL)
    {
        KERB_PA_PK_AS_REP2 Reply = {0};

        //
        // Create the reply key package
        //

        //
        // Create the reply key package, which contains the key used to encrypt
        // the AS_REPLY.
        //

        KeyPack.reply_key_package.nonce = Nonce;
        KeyPack.reply_key_package.reply_key = *pEncryptionKey;

        KerbErr = KerbPackData(
                    &KeyPack.reply_key_package,
                    KERB_REPLY_KEY_PACKAGE2_PDU,
                    &cbPackedKeyPack,
                    &pbPackedKeyPack
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        //
        // Acquire a crypt context for the private key of the certificate
        //

        if (!CryptAcquireCertificatePrivateKey(
                    pKdcCert,
                    0,              // no flags
                    NULL,           // reserved
                    &hKdcProvider,
                    NULL,           // no key spec
                    &fFreeProvider
                    ))
        {
            DebugLog((DEB_ERROR,"Failed to acquire KDC certificate private key: 0x%x\n",GetLastError()));
            FILL_EXT_ERROR(&ExtendedError, GetLastError(), FILENO, __LINE__);
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        //
        // Now, to sign the reply key package
        //

        Status = ScHelperSignMessage(
                    NULL,                       // no pin
                    NULL,                       // no logon info
                    hKdcProvider,
                    KERB_PKINIT_SIGNATURE_ALG,
                    pbPackedKeyPack,
                    cbPackedKeyPack,
                    rgbPkSignature,
                    &cbPkSignature
                    );
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to sign keypack: 0x%x\n",Status));
            FILL_EXT_ERROR(&ExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_AP_ERR_MODIFIED;
            goto Cleanup;
        }

        //
        // Copy the temporary signature into the return structure
        //

        KeyPack.reply_key_signature.pkcs_signature.length = cbPkSignature * 8;  // because it is a bit string
        KeyPack.reply_key_signature.pkcs_signature.value = rgbPkSignature;
        KeyPack.reply_key_signature.signature_algorithm.algorithm = g_KdcSignatureAlg;

        //
        // Now marshall the signed key package
        //

        KerbErr = KerbPackData(
                    &KeyPack,
                    KERB_SIGNED_REPLY_KEY_PACKAGE_PDU,
                    &cbSignedKeyPack,
                    &pbSignedKeyPack
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        //
        // Just encrypt the key package
        //

        pbPackedKey = pbSignedKeyPack;
        cbPackedKey = cbSignedKeyPack;

        //
        // Zero these out so we don't free them twice
        //

        pbSignedKeyPack = NULL;
        cbSignedKeyPack = 0;


        //
        // Compute the size of the encrypted temp key
        //
        //


ChangeCryptAlg2:

        if (g_fKdc3DesSupported && KdcCheckForEtype(pIKerbRequest->GetEncryptionTypes(), KERB_PKINIT_SEAL_ETYPE))
        {
            fUsed3Des = TRUE;
            CryptAlg.pszObjId = KERB_PKINIT_SEAL_OID;
        }
        else
        {
            CryptAlg.pszObjId = KERB_PKINIT_EXPORT_SEAL_OID;
            if (!KdcCheckForEtype(pIKerbRequest->GetEncryptionTypes(), KERB_PKINIT_EXPORT_SEAL_ETYPE))
            {
                DebugLog((DEB_WARN,"Client doesn't claim to support exportable pkinit encryption type %d\n",
                    KERB_PKINIT_EXPORT_SEAL_ETYPE));
            }
        }

        cbRequired = 0;
        Status = ScHelperEncryptMessage(
                    NULL,
                    g_hCryptClientProvider,
                    pCertContext,
                    &CryptAlg,
                    pbPackedKey,
                    cbPackedKey,
                    NULL,
                    (PULONG) &cbRequired
                    );
        if ((Status != ERROR_MORE_DATA) && (Status != STATUS_SUCCESS))
        {
            //
            // 3des is only supported on domestic builds with the
            // strong cryptography pack installed.
            //

            if ((Status == NTE_BAD_ALGID) && (fUsed3Des))
            {
                g_fKdc3DesSupported = FALSE;
                goto ChangeCryptAlg2;
            }
            DebugLog((DEB_ERROR,"Failed to encrypt message: %x\n",Status));
            FILL_EXT_ERROR(&ExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_AP_ERR_MODIFIED;
            goto Cleanup;
        }


        //
        // Allocate the output size
        //

        pbEncryptedKeyPack  = (PBYTE) MIDL_user_allocate(cbRequired);
        if (pbEncryptedKeyPack == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        //
        // Really do the encryption
        //


        Status = ScHelperEncryptMessage(
                    NULL,
                    g_hCryptClientProvider,
                    pCertContext,
                    &CryptAlg,
                    pbPackedKey,
                    cbPackedKey,
                    pbEncryptedKeyPack,
                    &cbRequired
                    );
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to encrypt message: %x\n",Status));
            FILL_EXT_ERROR(&ExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_AP_ERR_MODIFIED;
            goto Cleanup;
        }

        //
        // Create the cert list for the reply
        //

        KerbErr = KerbCreateCertificateList(
                    &CertList,
                    pKdcCert
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }


        //
        // We will be returning the KDC cert as well as a package containing
        // a temporary key
        //

        Reply.bit_mask |= KERB_PA_PK_AS_REP2_kdc_cert_present;


        //
        // Now, to finish the reply, we need a handle to the KDCs certificate
        //

        Reply.kdc_cert = (KERB_PA_PK_AS_REP2_kdc_cert) CertList;

        Reply.temp_key_package.choice = pkinit_enveloped_data_chosen;
        Reply.temp_key_package.u.pkinit_enveloped_data.length = (int) cbRequired;
        Reply.temp_key_package.u.pkinit_enveloped_data.value = pbEncryptedKeyPack;

        KerbErr = KerbPackData(
                    &Reply,
                    KERB_PA_PK_AS_REP2_PDU,
                    (PULONG) &pPackedPkAsRep->value.preauth_data.length,
                    &pPackedPkAsRep->value.preauth_data.value
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }
    else
    {
        KERB_PA_PK_AS_REP Reply = {0};

        //
        // Create the reply key package
        //

        //
        // Create the reply key package, which contains the key used to encrypt
        // the AS_REPLY.
        //

        ReplyKey.nonce = Nonce;
        ReplyKey.reply_key = *pEncryptionKey;

        KerbErr = KerbPackData(
                    &ReplyKey,
                    KERB_REPLY_KEY_PACKAGE_PDU,
                    &cbPackedKeyPack,
                    &pbPackedKeyPack
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        //
        // Acquire a crypt context for the private key of the certificate
        //

        if (!CryptAcquireCertificatePrivateKey(
                    pKdcCert,
                    0,              // no flags
                    NULL,           // reserved
                    &hKdcProvider,
                    NULL,           // no key spec
                    &fFreeProvider
                    ))
        {
            DebugLog((DEB_ERROR,"Failed to acquire KDC certificate private key: 0x%x\n",GetLastError()));
            FILL_EXT_ERROR(&ExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        //
        // Now, to sign the reply key package
        //

        CryptAlg.pszObjId = KERB_PKINIT_SIGNATURE_OID;

        Status = ScHelperSignPkcsMessage(
                    NULL,                       // no pin
                    NULL,                       // no logon info
                    hKdcProvider,
                    pKdcCert,
                    &CryptAlg,
                    CRYPT_MESSAGE_SILENT_KEYSET_FLAG, // dwSignMessageFlags
                    pbPackedKeyPack,
                    cbPackedKeyPack,
                    pbSignedKeyPack,
                    &cbSignedKeyPack
                    );



        if ((Status != ERROR_MORE_DATA) && (Status != STATUS_SUCCESS))
        {
            DebugLog((DEB_ERROR,"Failed to encrypt message: %x\n",Status));
            FILL_EXT_ERROR(&ExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_AP_ERR_MODIFIED;
            goto Cleanup;
        }

        pbSignedKeyPack = (PBYTE) MIDL_user_allocate(cbSignedKeyPack);
        if (pbSignedKeyPack == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        Status = ScHelperSignPkcsMessage(
                    NULL,                       // no pin
                    NULL,                       // no logon info
                    hKdcProvider,
                    pKdcCert,
                    &CryptAlg,
                    CRYPT_MESSAGE_SILENT_KEYSET_FLAG, // dwSignMessageFlags
                    pbPackedKeyPack,
                    cbPackedKeyPack,
                    pbSignedKeyPack,
                    &cbSignedKeyPack
                    );

        if (Status != STATUS_SUCCESS)
        {
            DebugLog((DEB_ERROR,"Failed to sign pkcs message: 0x%x\n",Status));
            FILL_EXT_ERROR(&ExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        //
        // Now encrypt the content
        //

        //
        // Compute the size of the encrypted temp key
        //
        //


ChangeCryptAlg:
        if (g_fKdc3DesSupported && KdcCheckForEtype(pIKerbRequest->GetEncryptionTypes(), KERB_PKINIT_SEAL_ETYPE))
        {
            fUsed3Des = TRUE;
            CryptAlg.pszObjId = KERB_PKINIT_SEAL_OID;
        }
        else
        {
            CryptAlg.pszObjId = KERB_PKINIT_EXPORT_SEAL_OID;
            if (!KdcCheckForEtype(pIKerbRequest->GetEncryptionTypes(), KERB_PKINIT_EXPORT_SEAL_ETYPE))
            {
                DebugLog((DEB_WARN,"Client doesn't claim to support exportable pkinit encryption type %d\n",
                    KERB_PKINIT_EXPORT_SEAL_ETYPE));
            }
        }

        cbRequired = 0;
        Status = ScHelperEncryptMessage(
                    NULL,
                    g_hCryptClientProvider,
                    pCertContext,
                    &CryptAlg,
                    pbSignedKeyPack,
                    cbSignedKeyPack,
                    NULL,
                    (PULONG) &cbRequired
                    );
        if ((Status != ERROR_MORE_DATA) && (Status != STATUS_SUCCESS))
        {
            //
            // 3des is only supported on domestic builds with the
            // strong cryptography pack installed.
            //

            if ((Status == NTE_BAD_ALGID) && (fUsed3Des))
            {
                g_fKdc3DesSupported = FALSE;
                goto ChangeCryptAlg;
            }

            DebugLog((DEB_ERROR,"Failed to encrypt message (crypto mismatch?): %x\n",Status));
            FILL_EXT_ERROR_EX(&ExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_AP_ERR_MODIFIED;
            goto Cleanup;
        }


        //
        // Allocate the output size
        //

        pbEncryptedKeyPack  = (PBYTE) MIDL_user_allocate(cbRequired);
        if (pbEncryptedKeyPack == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        //
        // Really do the encryption
        //


        Status = ScHelperEncryptMessage(
                    NULL,
                    g_hCryptClientProvider,
                    pCertContext,
                    &CryptAlg,
                    pbSignedKeyPack,
                    cbSignedKeyPack,
                    pbEncryptedKeyPack,
                    &cbRequired
                    );
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to encrypt message: %x\n",Status));
            FILL_EXT_ERROR(&ExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_AP_ERR_MODIFIED;
            goto Cleanup;
        }

        Reply.u.key_package.value = pbEncryptedKeyPack;
        Reply.u.key_package.length = cbRequired;
        Reply.choice = pkinit_enveloped_data_chosen;

        KerbErr = KerbPackData(
                    &Reply,
                    KERB_PA_PK_AS_REP_PDU,
                    (PULONG) &pPackedPkAsRep->value.preauth_data.length,
                    &pPackedPkAsRep->value.preauth_data.value
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

    }

#ifdef TBD
    if (Nonce != 0)
        pIKerbRequest->SetNonce(Nonce);
        ClientRequest->nonce = Nonce;
#endif

    *ppOutPadata = pPackedPkAsRep;
    pPackedPkAsRep = NULL;

Cleanup:

    if (fFreeProvider)
    {
        CryptReleaseContext(
            hKdcProvider,
            0
            );
    }
    if (pPkAsReq != NULL)
    {
        KerbFreeData(
            KERB_PA_PK_AS_REQ_PDU,
            pPkAsReq
            );
    }
    if (pPkAsReq2 != NULL)
    {
        KerbFreeData(
            KERB_PA_PK_AS_REQ2_PDU,
            pPkAsReq2
            );
    }
    if (pbSignedKeyPack != NULL)
    {
        KdcFreeEncodedData(pbSignedKeyPack);
    }
    if (pbPackedKeyPack != NULL)
    {
        KdcFreeEncodedData(pbPackedKeyPack);
    }
    if (pbPackedAuthenticator != NULL)
    {
        KdcFreeEncodedData(pbPackedAuthenticator);
    }
    if (hClientKey != NULL)
    {
        CryptDestroyKey(hClientKey);
    }
    if (pCertContext != NULL)
    {
        CertFreeCertificateContext(pCertContext);
    }
    if(pKdcCert)
    {
        CertFreeCertificateContext(pKdcCert);
    }
    if (pbEncryptedKeyPack != NULL)
    {
        MIDL_user_free(pbEncryptedKeyPack);
    }
    if (pulEtypeArray != NULL)
    {
        MIDL_user_free(pulEtypeArray);
    }
    KerbFreeCertificateList(
        CertList
        );
    if (pbPackedKey != NULL)
    {
        MIDL_user_free(pbPackedKey);
    }
    if (pPackedPkAsRep != NULL)
    {
        if (pPackedPkAsRep->value.preauth_data.value != NULL)
        {
            MIDL_user_free(pPackedPkAsRep->value.preauth_data.value);
        }
        MIDL_user_free(pPackedPkAsRep);
    }

    KerbFreeString(&ustrKdcKrbTgtName);
    KerbFreeString(&ustrClientKdcName);

    if (pIPrincipalClient)
        pIPrincipalClient->Release();

    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcGetKdcCertificate
//
//  Synopsis:   Retrieves a copy of the KDC cert
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KdcGetKdcCertificate(
    PCCERT_CONTEXT *KdcCert
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    if(!KdcGlobalCertCritSectInitialized)
    {
        return STATUS_OBJECT_NAME_NOT_FOUND;
    }
    EnterCriticalSection(&KdcGlobalCertCritSect);


    if (GlobalKdcCert == NULL)
    {
        DebugLog((DEB_WARN,"Unable to find KDC certificate in KDC store\n"));
        Status = STATUS_OBJECT_NAME_NOT_FOUND;
        goto Cleanup;
    }

    // Increment the ref count, so if we change certs while the caller of this
    // is still using this cert, we won't delete it out from under.

    *KdcCert = CertDuplicateCertificateContext(GlobalKdcCert);
    if(*KdcCert == NULL)
    {
        Status = STATUS_OBJECT_NAME_NOT_FOUND;
        goto Cleanup;
    }

Cleanup:


    LeaveCriticalSection(&KdcGlobalCertCritSect);

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\server\paid.cxx ===
//+-----------------------------------------------------------------------
//
// File:        paid.cxx
//
// Contents:    PA IDentities handler
//
//
// History:     3-Sept-2001   yordanr   Created.
//
//------------------------------------------------------------------------

#include <kdcsvr.hxx>
#include <malloc.h>


#include <krb5.h>
#include <krb5p.h>
#include <kerberr.h>

//  the new interface
#include <kerbinterface.h>
#include <padata.hxx>

//
//  interface implementation of IPAHandler for PA-Identity
//
class CPAIdentityHandler : public IPAHandler, public IPAIdentity
{
//  prealloc a number of ids
public:
    CPAIdentityHandler() :
        m_cKeys(0),
        m_pKeys(NULL),
        m_pXboxId(NULL)
    {
    }

    ~CPAIdentityHandler()
    {
        if (m_pKeys)
        {
            while(m_cKeys--)
            {
                KdcFreeMemory(m_pKeys[m_cKeys].keyvalue.value);
            }
            KdcFreeMemory(m_pKeys);
        }
        if (m_pXboxId) 
        {
            KdcFreeMemory(m_pXboxId);
        }
    }

    void __stdcall Release(void)
    {
        delete  this;
    };

    //
    // Implement IPAHandler
    //
    virtual ULONG GetPAType()
    {
        return  KRB5_PADATA_COMPOUND_IDENTITY ;
    }

    //
    // We support the IPAIdentity interface
    //
    virtual HRESULT __stdcall QueryInterface(
        REFIID intf,
        PVOID *ppv
        )
    {
        if (IsEqualIID(intf, IID_IPAIdentity))
        {
            *ppv = (PVOID)(IPAIdentity*)this;
            return  S_OK;
        }
        return  E_NOINTERFACE;
    }

    virtual KERBERR __stdcall Check(
        IN  IKerbRequest               *pIKerbRequest,
        IN  PKERB_PA_DATA_LIST          pPreAuthData,
        OUT PKERB_ENCRYPTION_KEY        pEncryptionKey,
        OUT PKERB_PA_DATA_LIST         *ppOutPadata,
        OUT BOOLEAN                    *pbSufficient,
        OUT PKERB_EXT_ERROR pExtendedError
        );

    virtual NTSTATUS __stdcall GetCompoundIdentity(
        OUT const COMPOUND_IDENTITY  **ppCompId
        )
    {
        *ppCompId = NULL;
        return  STATUS_NOT_IMPLEMENTED;
    }

    virtual NTSTATUS __stdcall GetXboxIdentity(
        OUT const XBOX_IDENTITY      **ppXboxId
        )
    {
        *ppXboxId = m_pXboxId;
        return  STATUS_SUCCESS;
    }

    //  return number of logon info structs present in compound identity
    virtual ULONG __stdcall GetNumLogonInfos()
    {
        return 0;
    }

    virtual NTSTATUS __stdcall GetTgtKeys(
        OUT PULONG                      pcKeys,
        OUT const KERB_ENCRYPTION_KEY **pKeys
        )
    {
        if (m_pKeys == 0)
        {
            return  STATUS_NOT_FOUND;
        }
        *pcKeys = m_cKeys;
        *pKeys = m_pKeys;

        return  STATUS_SUCCESS;
    }

private:

    PXBOX_IDENTITY          m_pXboxId;   //  compacted identity
    ULONG                   m_cKeys;     //  stored session keys
    PKERB_ENCRYPTION_KEY    m_pKeys;

    //  private APIs

    //  add an identity from XBOX_IDENTITY
    NTSTATUS AddXboxIdentity(PXBOX_IDENTITY pXboxIdentity);

    //  Build the identity
    KERBERR CheckCredsAndGetAuthData(
        PKERB_TICKET              pTicket,
        ULONG                     iTicket,
        IKerbRequest             *piReq,
        PKERB_EXT_ERROR pExtendedError
        );
};


//+-------------------------------------------------------------------------
//
//  Function:   CPAIdentityHandler::Check
//
//  Synopsis:   Extracts the krb_cred msg, decrypts and unpacks it after which
//              Identities are extracted from the PAC and stored for further use.
//              Verification is performed to ensure the cred msg is legit by
//              comparing the keys in the msg to the keys in the tickets.
//
//  Effects:
//
//  Arguments:  pIKerbRequest
//              pPreAuthData
//              pEncryptionKey
//              ppOutPadata
//              pbSufficient
//              pStatus
//
//              See IPAHandler::Check documentation for parameter descriptions
//
//  Requires:
//
//  Returns:    KDC_ERR_GENERIC        - pStatus contains the reason for failure
//
//  Notes:
//
//--------------------------------------------------------------------------

KERBERR
__stdcall
CPAIdentityHandler::Check(
    IN  IKerbRequest                *pIKerbRequest,
    IN  PKERB_PA_DATA_LIST           pPreAuthData,
    OUT PKERB_ENCRYPTION_KEY         pEncryptionKey,
    OUT PKERB_PA_DATA_LIST          *ppOutPadata,
    OUT BOOLEAN                     *pbSufficient,
    OUT PKERB_EXT_ERROR              pExtendedError
    )
{
    KERBERR                     KerbErr = KDC_ERR_NONE;
    NTSTATUS                    Status = STATUS_SUCCESS;
    PKERB_PA_COMPOUND_IDENTITY  pPaTemp = NULL;
    PKERB_PA_COMPOUND_IDENTITY *pPaCompId = NULL;
    ULONG                       iTicket;

    *pbSufficient = FALSE;

    if ( pPreAuthData->value.preauth_data_type != KRB5_PADATA_COMPOUND_IDENTITY)
    {
        //
        // Called with wrong PA
        //

        KerbErr = KDC_ERR_PREAUTH_FAILED;
        goto Cleanup;
    }

    //
    //  decrypt the preauth
    //  KerbUnpack is exported by the core, but what is the free function
    //

    KerbErr = KerbUnpackData(
        pPreAuthData->value.preauth_data.value,
        pPreAuthData->value.preauth_data.length,
        KERB_PA_COMPOUND_IDENTITY_PDU,
        (PVOID*)&pPaCompId
        );
    if ( !KERB_SUCCESS( KerbErr ) )
    {
        goto Cleanup;
    }


    //
    // count the tickets
    //

    pPaTemp = *pPaCompId;
    for (iTicket = 0; pPaTemp != NULL; iTicket++, pPaTemp = pPaTemp->next);

    if (m_pKeys)
    {
        KdcFreeMemory(m_pKeys);
        m_pKeys = NULL;
    }

    //
    //  alloc space for the keys
    // 

    m_pKeys = (PKERB_ENCRYPTION_KEY)KdcAllocMemory(iTicket * sizeof(KERB_ENCRYPTION_KEY));
    if (m_pKeys == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        Status = STATUS_NO_MEMORY;
        goto    Cleanup;
    }
    m_cKeys = iTicket;
    memset(m_pKeys, 0, iTicket * sizeof(KERB_ENCRYPTION_KEY));

    //
    // Free existing structures
    // 

    if (m_pXboxId) 
    {
        KdcFreeMemory(m_pXboxId);
    }

    //
    // Alloc the Xbox Identity
    // 

    m_pXboxId = (PXBOX_IDENTITY)KdcAllocMemory( sizeof(XBOX_IDENTITY) );
    if (m_pXboxId == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // Initialize the fields to empty
    // 

    memset( m_pXboxId, 0, sizeof(XBOX_IDENTITY) );

    //
    // check tickets and auth data
    //

    for (pPaTemp = *pPaCompId, iTicket = 0;
         pPaTemp != NULL;
         pPaTemp = pPaTemp->next, iTicket++)
    {
        KerbErr = CheckCredsAndGetAuthData(
            &pPaTemp->value,
            iTicket,
            pIKerbRequest,
            pExtendedError
            );
        if (!KERB_SUCCESS(KerbErr))
        {
            break;
        }
    }

Cleanup:

    D_DebugLog((
        DEB_TRACE,
        "PAIdentity::Check returning 0x%lx Status=0x%lx\n",
        KerbErr,
        Status
        ));

    if (pPaCompId)
    {
        KerbFreeData(KERB_PA_COMPOUND_IDENTITY_PDU, pPaCompId);
    }

    pExtendedError->status = Status;

    return  KerbErr;
}


//+-------------------------------------------------------------------------
//
//  Function:   CPAIdentityHandler::CheckCredsAndGetAuthData
//
//  Synopsis:   Checks the ticket against the cred and if there's a match
//              fills in the auth data at the index passed in
//
//  Effects:
//
//  Arguments:  pTicket     - TGT containing identities
//              iCred       - ticket index
//              piReq       - request in the context of which the operation
//                            takes place
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE if happy
//              KDC_ERR_GENERIC     - out of memory or some other generic error
//              KDC_ERR_PREAUTH_FAILED
//
//  Notes:
//
//--------------------------------------------------------------------------

KERBERR
CPAIdentityHandler::CheckCredsAndGetAuthData(
    IN  PKERB_TICKET              pTicket,
    IN  ULONG                     iTicket,
    IN  IKerbRequest             *piReq,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    KERBERR                 KerbErr     = KDC_ERR_NONE;
    IADHandler             *piAuthData  = NULL;
    IADPacSection          *iPacSect    = NULL;
    IKdbProvider           *iProv       = NULL;
    IKerbPrincipal         *piPrinc     = NULL;
    NTSTATUS                Status      = STATUS_SUCCESS;
    const PAC_INFO_BUFFER  *pPacBuf     = NULL;
    PKERB_ENCRYPTED_TICKET  pEncTicket  = NULL;
    PKERB_INTERNAL_NAME     pServerName = NULL;
    UNICODE_STRING          ustrRealm   = {0};


    KerbErr = KerbConvertRealmToUnicodeString(
        &ustrRealm,
        &pTicket->realm
        );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Get server principal to decrypt the ticket
    //

    iProv = KdcGetProvider(&ustrRealm);
    if (iProv == NULL)
    {
        //
        // No realm for this ticket
        //
        goto Cleanup;
    }

    KerbErr = KerbConvertPrincipalNameToKdcName(
        &pServerName,
        &pTicket->server_name
        );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = iProv->GetPrincipal(
        KDC_KDB_GET_PRINC_SERVER,
        pServerName,
        ustrRealm.Buffer,
        piReq,
        &piPrinc,
        pExtendedError,
        NULL
        );
    if ( !KERB_SUCCESS( KerbErr ))
    {
        goto Cleanup;
    }

    //
    //  Decrypt the ticket with the principal's key
    //
    //  Note that the implicit assumption is that the
    //  ticket is encrypted with the same etype as the request
    //

    Status = piPrinc->Decrypt(
        piReq->GetEncryptionTypes(),
        KERB_TICKET_SALT,
        &pTicket->encrypted_part,
        pTicket->encrypted_part.cipher_text.value,
        &pTicket->encrypted_part.cipher_text.length,
        NULL, // don't care what etype?
        pExtendedError
        );
    if ( !NT_SUCCESS( Status ) )
    {
        KerbErr = KDC_ERR_ETYPE_NOTSUPP;
        goto Cleanup;
    }

    //
    //  unpack encrypted ticket
    //

    KerbErr = KerbUnpackData(
        pTicket->encrypted_part.cipher_text.value,
        pTicket->encrypted_part.cipher_text.length,
        KERB_ENCRYPTED_TICKET_PDU,
        (PVOID*)&pEncTicket
        );

    if ( !KERB_SUCCESS( KerbErr ) )
    {
        goto Cleanup;
    }

    //
    //  save the session key from the ticket
    //  need to copy the ticket value
    //

    m_pKeys[iTicket] = pEncTicket->key;
    m_pKeys[iTicket].keyvalue.value = (ASN1octet_t *)KdcAllocMemory(pEncTicket->key.keyvalue.length);
    if (m_pKeys[iTicket].keyvalue.value == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        Status = STATUS_NO_MEMORY;
        goto    Cleanup;
    }
    memcpy(
        m_pKeys[iTicket].keyvalue.value,
        pEncTicket->key.keyvalue.value,
        pEncTicket->key.keyvalue.length
        );

    //
    // extract auth data from ticket
    //

    Status = KdcCreateADHandlerInstance(
        KERB_AUTH_DATA_PAC,
        &piAuthData
        );
    if ( !NT_SUCCESS( Status ) )
    {
        //
        // Failed to create a handler???
        //

        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    //
    // Check the auth Data
    //
    KerbErr = piAuthData->Check(
        piReq,
        piPrinc,
        pEncTicket->authorization_data,
        pExtendedError
        );
    if ( !KERB_SUCCESS( KerbErr ))
    {
        goto Cleanup;
    }

    //
    // Checked out ok, now get the auth data
    //
    //
    // Query PUIDs PAC section
    //

    Status = piAuthData->QueryInterface(
        IID_IADPacSection,
        (PVOID*)&iPacSect
        );
    if ( !NT_SUCCESS( Status ))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    //
    // If we find a CLIENT_IDENTITY or COMPOUND_IDENTITY then this
    // this pre-auth is invalid
    // 

    Status = iPacSect->GetPacSection(
        PAC_CLIENT_IDENTITY,
        &pPacBuf
        );
    if (NT_SUCCESS( Status ) ) 
    {
        KerbErr = KDC_ERR_PREAUTH_FAILED;
        goto Cleanup;
    }
    Status = iPacSect->GetPacSection(
        PAC_COMPOUND_IDENTITY,
        &pPacBuf
        );
    if (NT_SUCCESS( Status ) ) 
    {
        KerbErr = KDC_ERR_PREAUTH_FAILED;
        goto Cleanup;
    }

    //
    // We only care about XBOX_IDENTITY
    // 

    Status = iPacSect->GetPacSection(
        PAC_XBOX_IDENTITY,
        &pPacBuf
        );
    if ( NT_SUCCESS( Status ) ) 
    {
        //
        // PAC Buffer contains the XBOX_IDENTITY. Extract and save
        // it 'as-is'
        // 

        Status = AddXboxIdentity( (PXBOX_IDENTITY) pPacBuf->Data );
        if ( !NT_SUCCESS( Status) ) 
        {
            KerbErr = KDC_ERR_PREAUTH_FAILED;
        }

        //
        // Do not attempt to look at the other IDENTITY types
        // 

        goto Cleanup;
    }
    else if ( Status != STATUS_NOT_FOUND ) 
    {
        KerbErr = KDC_ERR_PREAUTH_FAILED;
        goto Cleanup;
    }

Cleanup:

    if ( piAuthData )
    {
        piAuthData->Release();
    }
    if (piPrinc)
    {
        piPrinc->Release();
    }

    //
    // Free data allocated by asn1 decoding
    //

    KerbFreeData(KERB_ENCRYPTED_TICKET_PDU, pEncTicket);

    if (pServerName)
    {
        //  hmm... KdcFreeName is not part of the core.
        //  use KdcFreeMemory, but is it the same ...
        KerbFreeKdcName(&pServerName);
    }

    KdcFreeMemory( ustrRealm.Buffer );

    return  KerbErr;
}


//+-------------------------------------------------------------------------
//
//  Function:   CPAHandlerIdentityFactory::CreateInstance
//
//  Synopsis:   Constructor-like function for creating a new object instance
//
//  Effects:
//
//  Arguments:  pIKerbRequest     - unused
//              ppIPAHandler      - used to return the new instance
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS if happy
//              STATUS_NO_MEMORY if out of memory
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS
__stdcall
CPAHandlerIdentityFactory::CreateInstance(
    IN  IKerbRequest     *pIKerbRequest,
    OUT IPAHandler      **ppIPAHandler
    )
{
    *ppIPAHandler = new CPAIdentityHandler;

    if (*ppIPAHandler == NULL)
    {
        return  STATUS_NO_MEMORY;
    }

    return  STATUS_SUCCESS;
}

//+-------------------------------------------------------------------------
//
//  Function:   CPAIdentityHandler::AddXboxIdentity
//
//  Synopsis:   Appends the identities in XboxIdentity to m_pXboxId
//
//  Effects:
//
//  Arguments:  pXboxId - compound identity to add
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS if happy
//              STATUS_NO_MEMORY if out of memory
//              STATUS_INVALID_PARAMETER if unhappy
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS
CPAIdentityHandler::AddXboxIdentity(
    IN PXBOX_IDENTITY pXboxIdentity
    )
{
    if ( NULL == pXboxIdentity) 
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Copy over the fields one at a time, after they are
    // sanity checked
    // 

    if (pXboxIdentity->MachineIdentity != 0) 
    {
        m_pXboxId->MachineIdentity           = pXboxIdentity->MachineIdentity;
        m_pXboxId->MachineIdentityCredential = pXboxIdentity->MachineIdentityCredential;
    }

    for (DWORD i = 0; i < XBOX_IDENTITY_MAX_USERS; ++i) 
    {
        if (pXboxIdentity->UserIdentity[i] != 0) 
        {
            m_pXboxId->UserIdentity[i]           = pXboxIdentity->UserIdentity[i];
            m_pXboxId->UserIdentityCredential[i] = pXboxIdentity->UserIdentityCredential[i];
        }
    }
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\server\pkserv.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        pkserv.h
//
// Contents:    types and prototypes for pk authentication
//
//
// History:     1-Dec-1997      MikeSw          Created
//
//------------------------------------------------------------------------

#ifndef __PKSERV_H__
#define __PKSERV_H__


KERBERR
KdcCheckPkinitPreAuthData(
        IN  IKerbRequest                *pIKerbRequest,
        IN  PKERB_PA_DATA_LIST           pPreAuthData,
        OUT PKERB_ENCRYPTION_KEY         pEncryptionKey,
        OUT PKERB_PA_DATA_LIST          *ppOutPadata,
        OUT PKERB_EXT_ERROR pExtendedError      
	);

BOOLEAN
KdcCheckForEtype(
    IN PKERB_CRYPT_LIST CryptList,
    IN ULONG Etype
    );

#endif // __PKSERV_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\server\refer.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        refer.h
//
// Contents:    Structurs and prototypes for interdomain referrals
//
//
// History:     26-Mar-1997     MikeSw          Created
//
//------------------------------------------------------------------------

#ifndef __REFER_H__
#define __REFER_H__

extern LIST_ENTRY KdcDomainList;
extern LIST_ENTRY KdcReferralCache;

//
// For NT5 domains in the enterprise the dns name will contain the
// real DNS name. For non- tree domains it will contain the name from
// the trusted domain object
//

#define KDC_DOMAIN_US           0x0001
#define KDC_DOMAIN_TREE_ROOT    0x0002
#define KDC_TRUST_INBOUND       0x0004

// cache flags
#define KDC_NO_ENTRY            0x0000
#define KDC_UNTRUSTED_REALM     0x0001
#define KDC_TRUSTED_REALM       0x0002

typedef struct _KDC_DOMAIN_INFO {
    LIST_ENTRY Next;
    UNICODE_STRING DnsName;
    UNICODE_STRING NetbiosName;
    struct _KDC_DOMAIN_INFO * ClosestRoute;     // Points to referral target for this domain or NULL if unreachable
    ULONG Flags;
    ULONG Attributes;
    ULONG Type;
    LONG References;

    //
    // Types used during building the tree
    //

    struct _KDC_DOMAIN_INFO * Parent;
    ULONG Touched;
    PSID Sid;
} KDC_DOMAIN_INFO, *PKDC_DOMAIN_INFO;


typedef struct _REFERRAL_CACHE_ENTRY {
    LIST_ENTRY ListEntry;
    LONG References;
    TimeStamp EndTime;
    UNICODE_STRING RealmName;
    ULONG CacheFlags;
} REFERRAL_CACHE_ENTRY, *PREFERRAL_CACHE_ENTRY;


VOID
KdcFreeReferralCache(
    IN PLIST_ENTRY ReferralCache
    );

KERBERR
KdcCheckForCrossForestReferral(
    OUT PIKerbPrincipal ReferralTarget,
    OUT OPTIONAL PUNICODE_STRING ReferralRealm,
    OUT PKERB_EXT_ERROR pExtendedError,
    IN PUNICODE_STRING DestinationDomain,
    IN ULONG NameFlags
    );


KERBERR
KdcFindReferralTarget(
    OUT PIKerbPrincipal *pReferralTarget,
    OUT OPTIONAL PUNICODE_STRING ReferralRealm,
    OUT PKERB_EXT_ERROR pExtendedError,
    IN PUNICODE_STRING DestinationDomain,
    IN BOOLEAN ExactMatch,
    IN BOOLEAN InboundWanted
    );


KERBERR
KdcGetTicketInfoForDomain(
    OUT PIKerbPrincipal *TicketInfo,
    OUT PKERB_EXT_ERROR pExtendedError,
    IN PKDC_DOMAIN_INFO DomainInfo,
    IN KDC_DOMAIN_INFO_DIRECTION Direction
    );

KERBERR
KdcLookupDomainName(
    OUT PKDC_DOMAIN_INFO * DomainInfo,
    IN PUNICODE_STRING DomainName,
    IN PLIST_ENTRY DomainList
    );

KERBERR
KdcLookupDomainRoute(
    OUT PKDC_DOMAIN_INFO * DomainInfo,
    OUT PKDC_DOMAIN_INFO * ClosestRoute,
    IN PUNICODE_STRING DomainName,
    IN PLIST_ENTRY DomainList
    );

NTSTATUS
KdcBuildDomainTree(
    );

ULONG __stdcall
KdcReloadDomainTree(
    PVOID Dummy
    );

VOID
KdcFreeDomainList(
    IN PLIST_ENTRY DomainList
    );

VOID
KdcDereferenceDomainInfo(
    IN PKDC_DOMAIN_INFO DomainInfo
    );

VOID
KdcLockDomainListFn(
   );

VOID
KdcUnlockDomainListFn(
   );

#endif // __REFER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\server\realm.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       realm.cxx
//
//  Contents:   Manage realm to KDB associations
//
//  Classes:
//
//  Functions:
//
//  History:    21-June-2001    JBrezak
//
//----------------------------------------------------------------------------

#include "kdcsvr.hxx"

//
// Return: "realm.com"
//
#if 0
//  that is really unnecessary
//  realm is present in the request and that's how the
//  provider was located
NTSTATUS
KdcRealmGetName(
    IN  KdbHandle,
    OUT PKERB_REALM Realm
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKDB_REALM pRealm;

    pRealm = KdbGetRealm(KdbHandle);
    if (!pRealm)
        return STATUS_NO_SUCH_DOMAIN;

    Status = KerbConvertUnicodeStringToRealm(
                 Realm,
                 &pRealm->Name
                 );

    return Status;
}
#endif

#if 0
//  same here
BOOLEAN
KdcIsOurRealm(
    IN KDB_HANDLE KdbHandle,
    IN PKERB_REALM Realm
    )
{
    BOOLEAN Result;
    KERB_REALM RealmName = {0};

    if (!NT_SUCCESS(KdcRealmGetName(
                       KdbHandle,
                       &RealmName)))
    {
        return(FALSE);
    }

    Result = KerbCompareRealmNames(
                Realm,
                &RealmName
                );

    KerbFreeRealm(&RealmName);

    return(Result);
}

//
// Return "krbtgt/realm.com"
//
NTSTATUS
KdcRealmGetKrbTgtName(
    IN PKERB_INTERNAL_NAME pRealm,
    OUT PUNICODE_STRING KrbtgtString
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKDB_REALM pRealm;

    pRealm = KdbGetRealm(KdbHandle);
    if (!pRealm)
        return STATUS_NO_SUCH_DOMAIN;

    if (!KERB_SUCCESS(KerbConvertKdcNameToString(
                         KrbtgtString,
                         pRealm->KrbtgtName,
                         NULL)))
    {
        return STATUS_NO_MEMORY;
    }

    return Status;
}

NTSTATUS
KdcRealmGetKrbTgtName(
    IN PKERB_INTERNAL_NAME pRealmName,
    OUT PKERB_INTERNAL_NAME *KrbtgtServiceName
    )
{
    return KerbBuildFullServiceKdcName(
                                &pRealmName,
                                &KrbtgtName,
                                KRB_NT_SRV_INST,
                                KrbtgtServiceName
            );
}
#endif

#if 0
// Not supporting these - update the certs!
// KdcFullServiceDnsName: TEST.COM\krbtgt
PUNICODE_STRING
KdcFullServiceDnsName(
    KDB_HANDLE KdbHandle
    )
{
    return NULL;
}

// KdcFullServiceName: TEST.COM\krbtgt
PUNICODE_STRING
KdcFullServiceName(
    KDB_HANDLE KdbHandle
    )
{
    return NULL;
}
#endif

#if 0
//  not sure what this means ....
// KdcDnsRealmName: TEST.COM
PUNICODE_STRING
KdcDnsRealmName(
    KDB_HANDLE KdbHandle
    )
{
    PKDB_REALM pRealm;

    pRealm = KdbGetRealm(KdbHandle);
    if (!pRealm)
        return NULL;

    return (&pRealm->Name);
}

//  not really needed.
//  provider has a method for this
BOOLEAN
KdcRealmSupportsPac(
    KDB_HANDLE KdbHandle
    )
{
    PKDB_REALM pRealm;

    pRealm = KdbGetRealm(KdbHandle);
    if (!pRealm)
        return FALSE;

    return ((pRealm->Flags & KERB_KDB_REALM_DOES_PAC) != 0);
}
#endif


KERBERR
KdcRealmGetKrbTGT(
    PIKerbProvider KdbHandle,
    PKDB_PRINC_INFO *KrbtgtInfo
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    KERB_EXT_ERROR ExtendedError;
    PKERB_INTERNAL_NAME KrbtgtName;
    NTSTATUS Status;

    TRACER(L"KdcRealmGetKrbTGT", (PVOID *) &KerbErr);
    
    Status = KdcRealmGetKrbTgtName(
                KdbHandle,
                &KrbtgtName
                );

    if (!NT_SUCCESS(Status))
    {
        KerbErr = KDC_ERR_S_PRINCIPAL_UNKNOWN;
        goto Cleanup;
    }

    KerbErr =  KdbGetPrincipal(
                  KdbHandle,
                  KrbtgtName,
                  NULL,
                  KDC_KDB_GET_PRINC_CLIENT,
                  KerbTgs,
                  KrbtgtInfo,
                  &ExtendedError
                  );

Cleanup:

    KerbFreeKdcName(&KrbtgtName);

    return KerbErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\server\realm.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       realm.h
//
//  Contents:   KdcRealm interfaces
//
//  Classes:
//
//  Functions:
//
//  History:    21-June-2001    JBrezak
//
//----------------------------------------------------------------------------

#ifndef _REALM_H_
#define _REALM_H_

#if 0
//  this should not be needed!
NTSTATUS
KdcRealmGetName(
    IN PIKdbProvider    piKdb,
    OUT PKERB_REALM     Realm
    );

BOOLEAN
KdcIsOurRealm(
    IN PIKdbProvider    piKdb,
    IN PKERB_REALM Realm
    );

//
//  hmm... this may take a realm as a param ...
NTSTATUS
KdcRealmGetKrbTgtName(
    IN PIKdbProvider    piKdb,
    OUT PUNICODE_STRING KrbtgtString
    );


//
//  should take realm name ...
//  
PUNICODE_STRING
KdcDnsRealmName(
    IN PIKdbProvider    piKdb
    );

//
//  should take realm name ...
//  
KERBERR
KdcRealmGetKrbTGT(
    IN PIKdbProvider    piKdb,
    PIKerbPrincipal         *KrbtgtInfo
    );
#endif

#if 0
//  not needed
BOOLEAN
KdcRealmSupportsPac(
    KDB_HANDLE KdbHandle
    );
#endif
#endif // _REALM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\server\preauth.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       preauth.cxx
//
//  Contents:   KDC Internal Preauth types
//
//  Classes:
//
//  Functions:
//
//  History:    21-June-2001    JBrezak
//
//----------------------------------------------------------------------------

#include "kdcsvr.hxx"

#include "traceinterface.hxx"
#include "fileno.h"
#define FILENO FILENO_GETAS

//+-------------------------------------------------------------------------
//
//  Function:   KdcBuildPreauthTypeList
//
//  Synopsis:   For returning with a PREAUTH-REQUIRED message
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
KERBERR
KdcBuildPreauthTypeList(
    IN CKerbRequest           *pReq,
    IN OUT PKERB_PA_DATA_LIST *PreauthTypeList
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    IPAHandler **iPA = pReq->m_ppiPAHandlers;
    ULONG cHandlers = KdcPAHandlerFactoryList.cElem;
    TRACER(L"KdcBuildPreauthTypeList", (PVOID *) &KerbErr);

    while(cHandlers-- && *iPA)
    {
        PKERB_PA_DATA_LIST DataList = NULL;
        KerbErr = (*iPA)->Get(pReq, &DataList);

        if (!KERB_SUCCESS(KerbErr))
        {
            break;
        }
        if (!DataList)
        {
            //  if the handler did not allocate anything, do
            //  it on its behalf
            DataList = (PKERB_PA_DATA_LIST)
                    MIDL_user_allocate(sizeof(KERB_PA_DATA_LIST));
            if (DataList == NULL)
            {
                KerbErr = KRB_ERR_GENERIC;
                goto Cleanup;
            }
            ZeroMemory(
                DataList,
                sizeof(KERB_PA_DATA_LIST)
                );

            DataList->value.preauth_data_type = (*iPA)->GetPAType();
        }
        //  and finally put in the list
        DataList->next = *PreauthTypeList;
        *PreauthTypeList = DataList;
        iPA++;
    }

Cleanup:

    return(KerbErr);
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcCheckPreAuthData
//
//  Synopsis:   Checks the pre-auth data in an AS request. This routine
//              may return pre-auth data to caller on both success and
//              failure.
//
//  Effects:
//
//  Arguments:  ClientTicketInfo - client account's ticket info
//              UserHandle - Handle to client's user object
//              PreAuthData - Pre-auth data supplied by client
//              PreAuthType - The type of pre-auth used
//              OutputPreAuthData - pre-auth data to return to client
//
//  Requires:
//
//  Returns:    KDC_ERR_PREAUTH_REQUIRED, KDC_ERR_PREAUTH_FAILED
//
//
//--------------------------------------------------------------------------

KERBERR
KdcCheckPreAuthData(
    IN PIKdbProvider piKdb,
    IN KERB_SERVICE_ID ServiceId,
    IN PIKerbPrincipal ClientInfo,
    IN OPTIONAL PKERB_PA_DATA_LIST PreAuthData,
    IN PKERB_KDC_REQUEST_BODY RequestBody,
    OUT PULONG PreAuthType,
    OUT PKERB_PA_DATA_LIST * OutputPreAuthData,
    OUT PKERB_ENCRYPTION_KEY EncryptionKey,
    OUT PUNICODE_STRING TransitedRealms,
    OUT PKERB_EXT_ERROR pExtendedError,
    IN CKerbRequest *pReq
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    KERBERR TempKerbErr = KDC_ERR_NONE;
    PKERB_PA_DATA_LIST OutputElement = NULL;
    PKERB_PA_DATA_LIST ListElement = NULL;
    BOOLEAN ValidPreauthPresent = FALSE;
    IPAHandler *piPAHandler;
    TRACER(L"KdcCheckPreAuthData", (PVOID *) &KerbErr);

    *OutputPreAuthData = NULL;

    //
    // Loop through the supplied pre-auth data elements and handle each one
    //

    for (ListElement = PreAuthData;
         ListElement != NULL ;
         ListElement = ListElement->next )
    {
        if (
           ListElement->value.preauth_data_type == KRB5_PADATA_COMPOUND_IDENTITY &&
           (ServiceId == KerbTgs || ServiceId == KerbAs)
        )
        {
            //  for as and tgs, this PA handler is already processed
            continue;
        }

        NTSTATUS Status = pReq->GetPAHandler(
                           ListElement->value.preauth_data_type,
                           &piPAHandler
                           );
        BOOLEAN bSufficient = FALSE;

        if (!NT_SUCCESS(Status))
        {
            //
            //  handler not found, ignore this PA then
            //
            Status = STATUS_SUCCESS;
            continue;
        }
        //  skip AS/TGS checks
        KerbErr = piPAHandler->Check(pReq,
                                    ListElement,
                                    EncryptionKey,
                                    &OutputElement,
                                    &bSufficient,
                                    pExtendedError);
        if (!KERB_SUCCESS(KerbErr))
        {
            break;
        }

        if (bSufficient)
        {
            ValidPreauthPresent = TRUE;
            *PreAuthType = ListElement->value.preauth_data_type;
        }

        if (OutputElement != NULL)
        {
            OutputElement->next = *OutputPreAuthData;
            *OutputPreAuthData = OutputElement;
            OutputElement = NULL;
        }
    }

    //
    // We need to check preauth data by default, unless the account tells
    // us not to or preauth failed.
    //

    if (ClientInfo &&
        ((ClientInfo->GetPrincFlags() & KERB_KDB_REQUIRES_PRE_AUTH) &&
         !ValidPreauthPresent))
    {
        if (KERB_SUCCESS(KerbErr))
            KerbErr = KDC_ERR_PREAUTH_REQUIRED;

        //
        // Return the list of supported types, if we don't have other
        // data to return.
        //

        if (*OutputPreAuthData == NULL)
        {

            TempKerbErr = KdcBuildPreauthTypeList(
                             pReq,
                             OutputPreAuthData
                             );

            //
            // In this case, we can't find any ETypes that both the client and
            // server support, so we've got to bail w/ proper error message...
            //
            if (TempKerbErr == KDC_ERR_ETYPE_NOTSUPP)
            {
                KerbErr = KDC_ERR_ETYPE_NOTSUPP;
            }
        }
    }

    return(KerbErr);
}


//
//  iterate on all handlers passing the output preauth data
//
KERBERR
KdcReturnPreAuthData(
    IN CKerbRequest             *pReq,
    OUT PKERB_PA_DATA_LIST      *OutputPreAuthData
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    IPAHandler **iPA = pReq->m_ppiPAHandlers;
    ULONG cHandlers = KdcPAHandlerFactoryList.cElem;

    while(cHandlers-- && *iPA)
    {
        KerbErr = (*iPA)->ReturnToClient(pReq, OutputPreAuthData);

        if (!KERB_SUCCESS(KerbErr))
        {
            break;
        }
        iPA++;
    }


    return KerbErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\server\rpcif.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        rpcif.h
//
// Contents:    RPC interface support functions
//
//
// History:     20-May-1996     Labeled         MikeSw
//
//------------------------------------------------------------------------

#ifndef __RPCIF_H__
#define __RPCIF_H__

// #define USE_SECURE_RPC

#define MAX_CONCURRENT_CALLS 10

NTSTATUS   StartRPC(LPTSTR, LPTSTR);
NTSTATUS   StartAllProtSeqs(void);
NTSTATUS   StopRPC(void);
NTSTATUS   SetAuthData();
NTSTATUS RegisterKdcEps();
NTSTATUS UnRegisterKdcEps();

NTSTATUS   RpcTransportNameRegister();
NTSTATUS   RpcTransportNameDeRegister();
BOOLEAN    RpcTransportCheckRegistrations();
LPSTR   RpcString(LPSTR);
SECURITY_STATUS   RPC_SECNTSTATUS(ULONG);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\server\transit.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        transit.h
//
// Contents:    Prototypes for transited realm encoding
//
//
// History:     2-April-1997    MikeSw          Created
//
//------------------------------------------------------------------------

#ifndef __TRANSIT_H__
#define __TRANSIT_H__

KERBERR
KdcInsertTransitedRealm(
    OUT PUNICODE_STRING NewTransitedField,
    IN PUNICODE_STRING OldTransitedField,
    IN PUNICODE_STRING ClientRealm,
    IN PUNICODE_STRING TransitedRealm,
    IN const UNICODE_STRING * OurRealm
    );

KERBERR
KdcExpandTransitedRealms(
    OUT PUNICODE_STRING * FullRealmList,
    OUT PULONG CountOfRealms,
    IN PUNICODE_STRING TransitedList
    );


#endif // __TRANSIT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\server\srvbuf.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1995
//
// File:        sockutil.cxx
//
// Contents:    Server support routines for sockets
//
//
// History:     10-July-1996    MikeSw  Created
//
//------------------------------------------------------------------------


#include "kdcsvr.hxx"
#include <atq.h>
extern "C"
{
}
#include <issched.hxx>


ULONGLONG   TotalBytes ;
ULONG       Messages ;
ULONG       DefaultMessageSize ;


typedef struct _KDC_ATQ_BUFFER_REGION {
    LIST_ENTRY List ;
    PVOID   RegionBase ;
    SIZE_T  RegionSize ;
    ULONG   Count ;
    ULONG   Granularity ;
    LONG    Active ;
} KDC_ATQ_BUFFER_REGION, * PKDC_ATQ_BUFFER_REGION ;

typedef struct _KDC_ATQ_BUFFER {
    SINGLE_LIST_ENTRY List ;
    PKDC_ATQ_BUFFER_REGION Region ;
    ULONG   Size ;
} KDC_ATQ_BUFFER, * PKDC_ATQ_BUFFER ;

typedef struct _KDC_ATQ_BUFFER_CONTROL {

    ULONG                   Granularity ;
    LIST_ENTRY              BufferPools ;
    SLIST_HEADER            BufferList ;
    CRITICAL_SECTION    PoolLock ;

    PKDC_ATQ_BUFFER_REGION  SpillRegion ;
    CRITICAL_SECTION    SpillLock ;
    SINGLE_LIST_ENTRY       SpillList ;

} KDC_ATQ_BUFFER_CONTROL, *PKDC_ATQ_BUFFER_CONTROL ;



NTSTATUS
KdcInitializeDatagramSockets(
    VOID
    );

NTSTATUS
KdcShutdownDatagramSockets(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\server\win2000.cxx ===
#include "kdcsvr.hxx"

typedef ULONG (*DBGPRINTEX)(ULONG, ULONG, PCH, va_list);

extern "C" ULONG
vDbgPrintEx(
    ULONG ComponentId,
    ULONG Level,
    PCH Format,
    va_list arglist
    )
/*++

Routine Description:

    This routine has been written to help load the service on Win2K machines.
    The debug version of some libraries call vDbgPrintfEx which has been
    implemented in Whistler and hence does not exist in Win2k's ntdll.dll.
    BryanT added it to help solve this problem.

Arguments:

    ComponentId -
    
    Level -
    
    Format -
    
    arglist -

Return Value:

    ERROR_SUCCESS or the Win32 error code.

--*/
{

    DBGPRINTEX pfnDbgPrintEx = (DBGPRINTEX) GetProcAddress(GetModuleHandle(L"ntdll"), "vDbgPrintEx");
    if (pfnDbgPrintEx) {
        return (*pfnDbgPrintEx)(ComponentId, Level, Format, arglist);
    } else {
        char Buf[2048];
        _vsnprintf(Buf, sizeof(Buf), Format, arglist);
        Buf[ (sizeof(Buf)/sizeof(Buf[0])) - 1 ] = '\0';
        DbgPrint(Buf);
        return 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\server\transit.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        transit.cxx
//
// Contents:    Code for compressing transitive realm list
//
//
// History:
//
//------------------------------------------------------------------------
#include "kdcsvr.hxx"


//+-----------------------------------------------------------------------
//
// Function:    KerbAppendString
//
// Synopsis:    Appends to unicode strings together and allocates the output
//
// Effects:
//
// Parameters:  Output - Output appended String
//              InputTail - Trailing portion of input
//              InputHead - Head potion of input
//
//
// Return:
//
// Notes:
//
//------------------------------------------------------------------------
NTSTATUS
KerbAppendString(
    OUT PUNICODE_STRING Output,
    IN const UNICODE_STRING * InputTail,
    IN const UNICODE_STRING * InputHead
    )
{
    Output->Buffer = NULL;
    Output->Length = InputHead->Length + InputTail->Length;
    if ((InputHead->Buffer == NULL) || (InputTail->Buffer == NULL))
    {
        Output->MaximumLength = 0;
        return STATUS_SUCCESS;
    }
    else
    {
        Output->MaximumLength = Output->Length + sizeof(WCHAR);
    }

    Output->Buffer = (LPWSTR) MIDL_user_allocate(Output->MaximumLength);
    if (Output->Buffer == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    memcpy(
        Output->Buffer,
        InputHead->Buffer,
        InputHead->Length
        );

    memcpy(
        Output->Buffer + InputHead->Length / sizeof(WCHAR),
        InputTail->Buffer,
        InputTail->Length
        );

    Output->Buffer[Output->Length/sizeof(WCHAR)] = L'\0';

    return STATUS_SUCCESS;
}


typedef enum _KERB_DOMAIN_COMPARISON {
    Above,
    Below,
    Equal,
    NotEqual
} KERB_DOMAIN_COMPARISON, *PKERB_DOMAIN_COMPARISON;

//+-----------------------------------------------------------------------
//
// Function:    KerbCompareDomains
//
// Synopsis:    Compares two domain names and returns whether one is a
//              prefix of the other, and the offset of the prefix.
//
// Effects:
//
// Parameters:
//
// Return:      Above - domain1 is a postfix of domain2
//              Below - domain2 is a postfix of domain1
//              Equal - the domains are equal
//              NotEqual - the domains are not equal and not above or below
//
// Notes:       This does not work for x-500 realm names (/foo/bar)
//
//------------------------------------------------------------------------

KERB_DOMAIN_COMPARISON
KerbCompareDomains(
    IN const UNICODE_STRING * Domain1,
    IN const UNICODE_STRING * Domain2,
    OUT PULONG PostfixOffset
    )
{
    UNICODE_STRING TempString;

    if (Domain1->Length > Domain2->Length)
    {
        TempString.Length = TempString.MaximumLength = Domain2->Length;
        TempString.Buffer = Domain1->Buffer + (Domain1->Length - Domain2->Length) / sizeof(WCHAR);

        if (RtlEqualUnicodeString(
                &TempString,
                Domain2,
                TRUE) && TempString.Buffer[-1] == '.')
        {
            *PostfixOffset = (Domain1->Length - Domain2->Length) / sizeof(WCHAR);
            return Below;
        }
        else
        {
            return NotEqual;
        }
    }
    else if (Domain1->Length < Domain2->Length)
    {
        TempString.Length = TempString.MaximumLength = Domain1->Length;
        TempString.Buffer = Domain2->Buffer + (Domain2->Length - Domain1->Length) / sizeof(WCHAR);

        if (RtlEqualUnicodeString(
                &TempString,
                Domain1,
                TRUE) && TempString.Buffer[-1] == '.')
        {
            *PostfixOffset = (Domain2->Length - Domain1->Length) / sizeof(WCHAR);
            return Above;
        }
        else
        {
            return NotEqual;
        }
    }
    else if (RtlEqualUnicodeString(Domain1,Domain2, TRUE))
    {
        *PostfixOffset = 0;
        return Equal;
    }
    else
    {
        return NotEqual;
    }
}

//+-----------------------------------------------------------------------
//
// Function:    KdcExpandTranistedRealms
//
// Synopsis:    Expands the transited realm field into an array of realms
//
// Effects:     Allocates an array of realm names
//
// Parameters:  FullRealmList - receives the full list of realms
//              CountOfRealms - receveies the number of entries in the list
//              TranistedList - The transited field to expand
//
// Return:
//
// Notes:
//
//------------------------------------------------------------------------

KERBERR
KdcExpandTransitedRealms(
    OUT PUNICODE_STRING * FullRealmList,
    OUT PULONG CountOfRealms,
    IN PUNICODE_STRING TransitedList
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    ULONG RealmCount;
    ULONG Index;
    ULONG RealmIndex;
    PUNICODE_STRING RealmList = NULL;
    UNICODE_STRING CurrentRealm;

    TRACER(L"KdcExpandTransitedRealms", (PVOID *) &KerbErr);
    *FullRealmList = NULL;
    *CountOfRealms = 0;

    //
    // First count the number of realms in the tranisted list. We can do
    // this by counting the number of ',' in the list. Note: if the encoding
    // is compressed by using a null entry to include all domains in a path
    // up or down a hierarchy, this code will fail.
    //

    if (TransitedList->Length == 0)
    {
        return(KDC_ERR_NONE);
    }


    RealmCount = 1;
    for (Index = 0; Index < TransitedList->Length / sizeof(WCHAR) ; Index++ )
    {
        if (TransitedList->Buffer[Index] == ',')
        {
            RealmCount++;

            //
            // Check for a ',,' compression indicating that all the
            // realms between two names have been traversed.
            // BUG 453997: we don't handle this yet.
            //

            if ( (Index == 0) ||
                 (Index == (TransitedList->Length / sizeof(WCHAR)) -1) ||
                 (TransitedList->Buffer[Index-1] == L','))

            {
                DebugLog((DEB_ERROR,"BUG 453997:: hit overcompressed transited encoding: %wZ\n",
                    TransitedList ));
                KerbErr = KRB_ERR_GENERIC;
                goto Cleanup;
            }
        }
    }

    //
    // We now have a the count of realms. Allocate an array of UNICODE_STRING
    // structures to hold the realms.
    //

    RealmList = (PUNICODE_STRING) MIDL_user_allocate(RealmCount * sizeof(UNICODE_STRING));
    if (RealmList == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    ZeroMemory(
        RealmList,
        RealmCount * sizeof(UNICODE_STRING)
        );



    //
    // Now loop through and insert the full names of all the domains into
    // the list
    //

    RealmIndex = 0;
    CurrentRealm = *TransitedList;
    for (Index = 0; Index <= TransitedList->Length / sizeof(WCHAR) ; Index++ )
    {
        //
        // If we hit the end of the string or found a ',', split off a
        // new realm.
        //

        if ((Index == TransitedList->Length / sizeof(WCHAR)) ||
            (TransitedList->Buffer[Index] == ',' ))
        {

            //
            // Check for a ',,' compression indicating that all the
            // realms between two names have been traversed.
            // BUG 453997:: we don't handle this yet.
            //

            if ( (Index == 0) ||
                 (Index == (TransitedList->Length / sizeof(WCHAR)) -1) ||
                 (TransitedList->Buffer[Index-1] == L','))

            {
                DebugLog((DEB_ERROR,"BUG 453997:: hit overcompressed transited encoding: %wZ\n",
                    TransitedList ));
                KerbErr = KRB_ERR_GENERIC;
                goto Cleanup;
            }

            CurrentRealm.Length = CurrentRealm.MaximumLength =
                (USHORT)(&TransitedList->Buffer[Index] - CurrentRealm.Buffer) * sizeof(WCHAR);

            //
            // Check for a trailing '.' - if so, append it
            // to the parent
            //

            if (TransitedList->Buffer[Index-1] == '.')
            {
                //
                // This is a compressed name, so append it to the previous
                // name
                //
                if (RealmIndex == 0)
                {
                    DebugLog((DEB_ERROR,"First element in transited encoding has a trailing '.': %wZ\n",
                        TransitedList ));
                    KerbErr = KRB_ERR_GENERIC;
                    goto Cleanup;
                }
                if (!NT_SUCCESS(KerbAppendString(
                        &RealmList[RealmIndex],
                        &RealmList[RealmIndex-1],
                        &CurrentRealm)))
                {
                    KerbErr = KRB_ERR_GENERIC;
                    goto Cleanup;
                }
            }
            else if ((RealmIndex != 0) && (CurrentRealm.Buffer[0] == '/'))
            {
                if (!NT_SUCCESS(KerbAppendString(
                        &RealmList[RealmIndex],
                        &CurrentRealm,
                        &RealmList[RealmIndex-1]
                        )))
                {
                    KerbErr = KRB_ERR_GENERIC;
                    goto Cleanup;
                }
            }
            else if (!NT_SUCCESS(KerbDuplicateString(
                    &RealmList[RealmIndex],
                    &CurrentRealm)))
            {
                KerbErr = KRB_ERR_GENERIC;
                goto Cleanup;
            }

            CurrentRealm.Buffer =CurrentRealm.Buffer + 1 + CurrentRealm.Length/sizeof(WCHAR);
            RealmIndex++;
        }
    }
    DsysAssert(RealmIndex == RealmCount);

    *FullRealmList = RealmList;
    *CountOfRealms = RealmCount;
Cleanup:

    if (!KERB_SUCCESS(KerbErr))
    {
        if (RealmList != NULL)
        {
            for (RealmIndex = 0; RealmIndex < RealmCount ; RealmIndex++ )
            {
                KerbFreeString(&RealmList[RealmIndex]);
            }
            MIDL_user_free(RealmList);
        }
    }

    return(KerbErr);
}


//+-----------------------------------------------------------------------
//
// Function:    KdcCompressTransitedRealms
//
// Synopsis:    Compresses an ordered list of realms by removing
//              redundant information.
//
// Effects:     Allocates an output string
//
// Parameters:  CompressedRealms - receives the compressed list of realms
//              RealmList - List of domains to compress
//              RealmCount - number of entries in realm list
//              NewRealm - new realm to add to the lsit
//              NewRealmIndex - Location before which to insert the new
//                      realm
//
// Return:
//
// Notes:
//
//------------------------------------------------------------------------

KERBERR
KdcCompressTransitedRealms(
    OUT PUNICODE_STRING CompressedRealms,
    IN PUNICODE_STRING RealmList,
    IN ULONG RealmCount,
    IN PUNICODE_STRING NewRealm,
    IN ULONG NewRealmIndex
    )
{
    UNICODE_STRING OutputRealms;
    WCHAR OutputRealmBuffer[1000];
    KERBERR KerbErr = KDC_ERR_NONE;
    ULONG Index;
    ULONG InsertionIndex = NewRealmIndex;
    PWCHAR Where;
    PUNICODE_STRING PreviousName = NULL;
    PUNICODE_STRING CurrentName = NULL;
    ULONG PostfixOffset;
    UNICODE_STRING NameToAdd;

    TRACER(L"KdcCompressTransitedRealms", (PVOID *) &KerbErr);
    
    RtlInitUnicodeString(
        CompressedRealms,
        NULL
        );

    OutputRealms.Buffer = OutputRealmBuffer;
    OutputRealms.MaximumLength = sizeof(OutputRealmBuffer);
    OutputRealms.Length = 0;
    Where = OutputRealms.Buffer;

    Index = 0;
    while (Index <= RealmCount)
    {
        PreviousName = CurrentName;

        //
        // If this is the index to insert, add the new realm
        //

        if (InsertionIndex == Index)
        {
            CurrentName = NewRealm;
        }
        else if (Index == RealmCount)
        {
            //
            // If we already added all the original realms, get out now
            //

            break;
        }
        else
        {
            CurrentName = &RealmList[Index];
        }

        NameToAdd = *CurrentName;

        //
        // If the previous name is above this one, lop off the postfix from
        // this name
        //

        if ((PreviousName != NULL) &&
            KerbCompareDomains(
                PreviousName,
                CurrentName,
                &PostfixOffset
                ) == Above)
        {
            NameToAdd.Length = (USHORT) PostfixOffset * sizeof(WCHAR);
        }


        DsysAssert(OutputRealms.Length + NameToAdd.Length + sizeof(WCHAR) < OutputRealms.MaximumLength);
        if (OutputRealms.Length + NameToAdd.Length + sizeof(WCHAR) > OutputRealms.MaximumLength)
        {
            //
            // BUG 453652: wrong error
            //

            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        if (OutputRealms.Length != 0)
        {
            *Where++ = L',';
            OutputRealms.Length += sizeof(WCHAR);

        }
        memcpy(
            Where,
            NameToAdd.Buffer,
            NameToAdd.Length
            );
        Where += NameToAdd.Length/sizeof(WCHAR);
        OutputRealms.Length = OutputRealms.Length + NameToAdd.Length;

        //
        // If we inserted the transited realm here, run through the loop
        // again with the same index.
        //

        if (InsertionIndex == Index)
        {
            InsertionIndex = 0xffffffff;
        }
        else
        {
            Index++;
        }
    }

    *Where++ = L'\0';


    if (!NT_SUCCESS(KerbDuplicateString(
            CompressedRealms,
            &OutputRealms)))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
Cleanup:
    return(KerbErr);
}


//+-----------------------------------------------------------------------
//
// Function:    KdcInsertTransitedRealm
//
// Synopsis:    Inserts the referree's realm into the tranisted encoding
//              in a ticket. This uses domain-x500-compress which
//              eliminates redundant information when one domain is the
//              prefix or suffix of another.
//
// Effects:     Allocates output buffer
//
// Parameters:  NewTransitedField - receives the new tranisted field, to
//                      be freed with KerbFreeString
//              OldTransitedField - the existing transited frield.
//              ClientRealm - Realm of client (from ticket)
//              TransitedRealm - Realm of referring domain
//              OurRealm - Our realm name
//
// Return:
//
// Notes:
//
//------------------------------------------------------------------------

KERBERR
KdcInsertTransitedRealm(
    OUT PUNICODE_STRING NewTransitedField,
    IN PUNICODE_STRING OldTransitedField,
    IN PUNICODE_STRING ClientRealm,
    IN PUNICODE_STRING TransitedRealm,
    IN const UNICODE_STRING * OurRealm
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PUNICODE_STRING FullDomainList = NULL;
    ULONG CountOfDomains;
    ULONG NewEntryIndex = 0xffffffff;
    ULONG PostfixOffset;
    ULONG Index;
    KERB_DOMAIN_COMPARISON Comparison = NotEqual;
    KERB_DOMAIN_COMPARISON LastComparison;

    TRACER(L"KdcInsertTransitedRealm", (PVOID *) &KerbErr);
    
    //
    // The first thing to do is to expand the existing transited field. This
    // is because the compression scheme does not allow new domains to simply
    // append or insert information - the encoding of existing realms
    // can change. For example, going from a domain to its parent means
    // that the original domain can be encoded as a prefix of the parent
    // whereas originally it was a name unto itself.
    //

    D_DebugLog((DEB_T_TRANSIT, "Inserted realm %wZ into list %wZ for client fomr %wZ\n",
        TransitedRealm, OldTransitedField, ClientRealm ));

    KerbErr = KdcExpandTransitedRealms(
                &FullDomainList,
                &CountOfDomains,
                OldTransitedField
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Now loop through the domains. Based on the compression, we know that
    // higher up domains come first.
    //

    for (Index = 0; Index < CountOfDomains ; Index++ )
    {
        LastComparison = Comparison;

        Comparison = KerbCompareDomains(
                        TransitedRealm,
                        &FullDomainList[Index],
                        &PostfixOffset
                        );
        if (Comparison == Above)
        {
            //
            // If the new domain is above an existing domain, it gets inserted
            // before the existing domain because all the existing domains
            // are ordered from top to bottom
            //
            NewEntryIndex = Index;
            break;
        }
        else if (Comparison == Below)
        {
            //
            // There may be other domains below which are closer, so
            // store the result and continue.
            //
            LastComparison = Comparison;
        }
        else if (Comparison == NotEqual)
        {
            //
            // The domains aren't above or below each other. If the last
            // comparison was below, stick the domain underneath it.
            //
            if (LastComparison == Below)
            {
                NewEntryIndex = Index;
                break;
            }
        }
    }

    //
    // If we didn't find a place for it, stick it in at the end.
    //

    if (NewEntryIndex == 0xffffffff)
    {
        NewEntryIndex = Index;
    }

    //
    // Now build the new encoding
    //

    KerbErr = KdcCompressTransitedRealms(
                NewTransitedField,
                FullDomainList,
                CountOfDomains,
                TransitedRealm,
                NewEntryIndex
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

Cleanup:
    if (FullDomainList != NULL)
    {
        for (Index = 0; Index < CountOfDomains ; Index++ )
        {
            KerbFreeString(&FullDomainList[Index]);
        }
        MIDL_user_free(FullDomainList);
    }

    return(KerbErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\server\secdata.cxx ===
//+-----------------------------------------------------------------------
//
// File:        secdata.cxx
//
// Contents:    Global data and methods on it.
//
//
// History:
//
//------------------------------------------------------------------------

#include "kdcsvr.hxx"

#include <tostring.hxx>
#include <kpasswd.h>

///////////////////////////////////////////////////////////////
//
//
// Global data
//

// This is all the security information that gets cached.

CSecurityData SecData;

CAuthenticatorList * Authenticators;
CAuthenticatorList * FailedRequests;

////////////////////////////////////////////////////////////////////
//
//  Name:       CSecurityData::CSecurityData
//
//  Synopsis:   Constructor.
//
//  Arguments:  <none>
//
//  Notes:      .
//
CSecurityData::CSecurityData()
{
    TRACE(KDC, CSecurityData::CSecurityData, DEB_FUNCTION);

    InitializeCriticalSection(&_Monitor);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSecurityData::Init
//
//  Synopsis:   Initializes the global data.
//
//  Effects:    Allocates memory
//
//  Arguments:  (none)
//
//  Returns:    STATUS_SUCCESS or error code
//
//  Signals:    May raise exception on out of memory.
//
//  History:    4-02-93   WadeR   Created
//
//  Notes:      This must be called before any other method of
//              CSecurityData.  It gets data from the registry, the domain
//              object, and the kdc.ini file.
//
//----------------------------------------------------------------------------

NTSTATUS
CSecurityData::Init()
{
    TRACE(KDC, CSecurityData::Init, DEB_FUNCTION);

    NTSTATUS Status = STATUS_SUCCESS;
    LARGE_INTEGER MaxAuthenticatorAge;


    D_DebugLog(( DEB_TRACE, "Entered CSecurityData::Init()\n" ));


    //
    // Create the authenticators.
    //

    //
    //  In reality, set skew time to 5 minutes and same for authenticators.
    //  this is default skew time. providers can override
    //

    MaxAuthenticatorAge.QuadPart = (LONGLONG) 10000000 * 60 * 5;


    //
    // Create the authenticator list
    //

    Authenticators = new CAuthenticatorList( MaxAuthenticatorAge );
    if (Authenticators == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Setup a list to track failed requests - we don't fail the
    // same request twice for the timeout time
    //

    FailedRequests = new CAuthenticatorList( MaxAuthenticatorAge );
    if (FailedRequests == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

Cleanup:
    return(Status);

}

//+---------------------------------------------------------------------------
//
//  Member:     CSecurityData::~CSecurityData
//
//  Synopsis:   Destructor
//
//  Effects:    Frees memory
//
//  Arguments:  (none)
//
//  History:    4-02-93   WadeR   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

VOID
CSecurityData::Cleanup()
{
    TRACE(KDC, CSecurityData::Cleanup, DEB_FUNCTION);

    if (Authenticators != NULL)
    {
        delete Authenticators;
        Authenticators = NULL;
    }
    if (FailedRequests != NULL)
    {
        delete FailedRequests;
        FailedRequests = NULL;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CSecurityData::~CSecurityData
//
//  Synopsis:   Destructor
//
//  Effects:    Frees memory
//
//  Arguments:  (none)
//
//  History:    4-02-93   WadeR   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CSecurityData::~CSecurityData()
{
    TRACE(KDC, CSecurityData::~CSecurityData, DEB_FUNCTION);

    Cleanup();

    //
    // This doesn't happen during Cleanup() because we want to
    // make sure it only happens once.
    //

    DeleteCriticalSection(&_Monitor);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\server\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_kdccore_none_12.4.56.0_none_c1f80ced840241ed
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_kdccore_no-public-key_12.4.56.0_x-ww_e78a463f
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=kdccore
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_kdccore_no-public-key_12.4.56.0_x-ww_e78a463f
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_kdccore_no-public-key_12.4.56.0_x-ww_e78a463f.manifest
XP_MANIFEST_PATH=manifests\x86_kdccore_no-public-key_12.4.56.0_x-ww_e78a463f.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_kdccore_no-public-key_12.4.56.0_x-ww_e78a463f.cat
XP_CATALOG_PATH=manifests\x86_kdccore_no-public-key_12.4.56.0_x-ww_e78a463f.cat
XP_PAYLOAD_PATH=x86_kdccore_no-public-key_12.4.56.0_x-ww_e78a463f
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=kdccore,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\server\tktutil.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       tktutil.cxx
//
//  Contents:   x//  Classes:
//
//  Functions:
//
//  History:    04-Mar-94   wader   Created
//
//----------------------------------------------------------------------------


// Place any local #includes files here.

#include "kdcsvr.hxx"

#include "malloc.h"

//#include <kdctrace.h>

#define FILENO FILENO_TKTUTIL

#define MAX_ETYPE_LONG   999
#define MIN_ETYPE_LONG  -999
#define MAX_ETYPE_STRING 16  // 4wchar + , + 2 space
#define WSZ_NO_KEYS L"< >"

//  local functions
KERBERR
KerbProcessPaCompoundIdentity(CKerbRequest *pKdcReq,
                              PKERB_EXT_ERROR pExtErr);

//
// Static data
//



//
// Fudge factor for comparing timestamps, because network clocks may
// be out of sync.
// Note: The lowpart is first!
//

//LARGE_INTEGER SkewTime;

//+---------------------------------------------------------------------------
//
//  Function:   GetTimeStamps
//
//  Synopsis:   Gets the current time and clock skew envelope.
//
//  Arguments:  [ptsFudge]    -- (in) amount of clock skew to allow.
//              [ptsNow]      -- (out) the current time
//              [ptsNowPlus]  -- (out) the current time plus the skew.
//              [ptsNowMinus] -- (out) the current time less the skew
//
//  History:    4-23-93   WadeR   Created
//
//----------------------------------------------------------------------------
void
GetTimeStamps(  IN  PLARGE_INTEGER ptsFudge,
                OUT PLARGE_INTEGER ptsNow,
                OUT PLARGE_INTEGER ptsNowPlus,
                OUT PLARGE_INTEGER ptsNowMinus )
{
    TRACE(KDC, GetTimeStamps, DEB_FUNCTION);

    GetSystemTimeAsFileTime((PFILETIME) ptsNow );
    ptsNowPlus->QuadPart = ptsNow->QuadPart + ptsFudge->QuadPart;
    ptsNowMinus->QuadPart = ptsNow->QuadPart - ptsFudge->QuadPart;
}




//+-------------------------------------------------------------------------
//
//  Function:   KdcBuildTicketTimesAndFlags
//
//  Synopsis:   Computes the times and flags for a new ticket
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR
KdcBuildTicketTimesAndFlags(
    IN ULONG ClientPolicyFlags,
    IN ULONG ServerPolicyFlags,
    IN const KDC_POLICY_VALUES* pKdcPolicy,
    IN PLARGE_INTEGER MaxTicketLifespan,
    IN PLARGE_INTEGER MaxTicketRenewspan,
    IN OPTIONAL PLARGE_INTEGER AccountExpiry,
    IN const KERB_KDC_REQUEST_BODY *RequestBody,
    IN OPTIONAL PKERB_ENCRYPTED_TICKET SourceTicket,
    IN OUT PKERB_ENCRYPTED_TICKET Ticket,
    IN OUT OPTIONAL PKERB_EXT_ERROR ExtendedError
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    LARGE_INTEGER RequestEndTime;
    LARGE_INTEGER RequestStartTime;
    LARGE_INTEGER RequestRenewTime;

    LARGE_INTEGER SourceEndTime;
    LARGE_INTEGER SourceRenewTime;
    LARGE_INTEGER SourceStartTime;
    ULONG SourceTicketFlags = 0;
    ULONG FinalTicketFlags = 0;
    ULONG KdcOptions = 0;

    LARGE_INTEGER FinalEndTime;
    LARGE_INTEGER FinalStartTime;
    LARGE_INTEGER FinalRenewTime;
    BOOLEAN Renewable = FALSE;

    LARGE_INTEGER CurrentTime;

    TRACER(L"KdcBuildTicketTimesAndFlags", (PVOID *) &KerbErr);
    TRACE(KDC, KdcBuildTicketTimesAndFlags, DEB_FUNCTION);

    GetSystemTimeAsFileTime((PFILETIME)&CurrentTime);
    FinalEndTime.QuadPart = 0;
    FinalStartTime.QuadPart = 0;
    FinalRenewTime.QuadPart = 0;

    KdcOptions = KerbConvertFlagsToUlong(&RequestBody->kdc_options);

    //
    // Get the request times out of the request
    //

    if (RequestBody->bit_mask & KERB_KDC_REQUEST_BODY_starttime_present)
    {
        //  start time can be present only in postdated ticket
        //  request
        if ((KdcOptions & KERB_KDC_OPTIONS_postdated) == 0)
        {
            KerbErr = KDC_ERR_BADOPTION;
            goto    Cleanup;
        }
        KerbConvertGeneralizedTimeToLargeInt(
            &RequestStartTime,
            &RequestBody->KERB_KDC_REQUEST_BODY_starttime,
            NULL
            );
    }
    else
    {
        RequestStartTime.QuadPart = 0;
    }

    KerbConvertGeneralizedTimeToLargeInt(
        &RequestEndTime,
        &RequestBody->endtime,
        NULL
        );

    if (RequestBody->bit_mask & KERB_KDC_REQUEST_BODY_renew_until_present)
    {
        KerbConvertGeneralizedTimeToLargeInt(
            &RequestRenewTime,
            &RequestBody->KERB_KDC_REQUEST_BODY_renew_until,
            NULL
            );
    }
    else
    {
        RequestRenewTime.QuadPart = 0;
    }

    //
    // Get the times out of the source ticket (if present)
    //

    if (ARGUMENT_PRESENT(SourceTicket))
    {
        if (SourceTicket->bit_mask & KERB_ENCRYPTED_TICKET_starttime_present)
        {
            KerbConvertGeneralizedTimeToLargeInt(
                &SourceStartTime,
                &SourceTicket->KERB_ENCRYPTED_TICKET_starttime,
                NULL
                );

        }
        else
        {
            SourceStartTime.QuadPart = 0;
        }

        KerbConvertGeneralizedTimeToLargeInt(
            &SourceEndTime,
            &SourceTicket->endtime,
            NULL
            );

        if (SourceTicket->bit_mask & KERB_ENCRYPTED_TICKET_renew_until_present)
        {
            KerbConvertGeneralizedTimeToLargeInt(
                &SourceRenewTime,
                &SourceTicket->KERB_ENCRYPTED_TICKET_renew_until,
                NULL
                );

        }
        else
        {
            SourceRenewTime.QuadPart = 0;
        }
        SourceTicketFlags = KerbConvertFlagsToUlong(&SourceTicket->flags);
    }
    else
    {
        //
        // Set the maximums in this case, which is probably an AS request.
        //

        SourceStartTime = CurrentTime;
        SourceEndTime = tsInfinity;
        SourceRenewTime = tsInfinity;
        SourceTicketFlags = 0;

        //
        // Fill in the source flags from what the client policy & domain policy
        // allow
        //

        if ((ClientPolicyFlags & KERB_KDB_DISALLOW_FORWARDABLE) == 0)
        {
            SourceTicketFlags |= KERB_TICKET_FLAGS_forwardable;
        }
        if ((ClientPolicyFlags & KERB_KDB_DISALLOW_PROXIABLE) == 0)
        {
            SourceTicketFlags |= KERB_TICKET_FLAGS_proxiable;
        }
        if ((ClientPolicyFlags & KERB_KDB_DISALLOW_POSTDATED) == 0)
        {
            SourceTicketFlags |= KERB_TICKET_FLAGS_may_postdate;
        }
        if ((ClientPolicyFlags & KERB_KDB_DISALLOW_RENEWABLE) == 0)
        {
            SourceTicketFlags |= KERB_TICKET_FLAGS_renewable;
        }

    }

    //
    // Start computing the flags, from algorithm in RFC1510 appendix A.6
    //

    //
    // Delegation flags
    //

    if ((ServerPolicyFlags & KERB_KDB_OK_AS_DELEGATE) != 0)
    {
        FinalTicketFlags |= KERB_TICKET_FLAGS_ok_as_delegate;
    }

    //
    // Forward flags
    //

    if (KdcOptions & KERB_KDC_OPTIONS_forwardable)
    {
        if ((SourceTicketFlags & KERB_TICKET_FLAGS_forwardable) &&
            ((ServerPolicyFlags & KERB_KDB_DISALLOW_FORWARDABLE) == 0))
        {
            FinalTicketFlags |= KERB_TICKET_FLAGS_forwardable;
        }
        else
        {
            DebugLog((DEB_ERROR,"Asked for forwardable but not allowed\n"));
//            KerbErr = KDC_ERR_BADOPTION;
//            goto Cleanup;
        }
    }

    if (KdcOptions & KERB_KDC_OPTIONS_forwarded)
    {
        if ((SourceTicketFlags & KERB_TICKET_FLAGS_forwardable) &&
            ((ServerPolicyFlags & KERB_KDB_DISALLOW_FORWARDABLE) == 0))
        {
            FinalTicketFlags |= KERB_TICKET_FLAGS_forwarded;
        }
        else
        {
            DebugLog((DEB_ERROR,"Asked for forwarded but not allowed\n"));
            KerbErr = KDC_ERR_BADOPTION;
            goto Cleanup;
        }
    }

    if (SourceTicketFlags & KERB_TICKET_FLAGS_forwarded)
    {
        FinalTicketFlags |= KERB_TICKET_FLAGS_forwarded;
    }

    //
    // preauth flags
    //

    if (SourceTicketFlags & KERB_TICKET_FLAGS_pre_authent)
    {
        FinalTicketFlags |= KERB_TICKET_FLAGS_pre_authent;
    }

    //  hw-auth flag has to be carried fwd
    if (SourceTicketFlags & KERB_TICKET_FLAGS_hw_authent)
    {
        FinalTicketFlags |= KERB_TICKET_FLAGS_hw_authent;
    }

    //
    // Proxy flags
    //

    if (KdcOptions & KERB_KDC_OPTIONS_proxiable)
    {
        if ((SourceTicketFlags & KERB_TICKET_FLAGS_proxiable) &&
            ((ServerPolicyFlags & KERB_KDB_DISALLOW_PROXIABLE) == 0))
        {
            FinalTicketFlags |= KERB_TICKET_FLAGS_proxiable;
        }
        else
        {
            DebugLog((DEB_ERROR,"Asked for proxiable but not allowed\n"));
//            KerbErr = KDC_ERR_BADOPTION;
//            goto Cleanup;
        }
    }

    if (KdcOptions & KERB_KDC_OPTIONS_proxy)
    {
        if ((SourceTicketFlags & KERB_TICKET_FLAGS_proxiable) &&
            ((ServerPolicyFlags & KERB_KDB_DISALLOW_PROXIABLE) == 0))
        {
            FinalTicketFlags |= KERB_TICKET_FLAGS_proxy;
        }
        else
        {
            DebugLog((DEB_ERROR,"Asked for proxy but not allowed\n"));
            KerbErr = KDC_ERR_BADOPTION;
            goto Cleanup;
        }
    }

    //
    // Postdate
    //

    if (KdcOptions & KERB_KDC_OPTIONS_allow_postdate)
    {
        if ((SourceTicketFlags & KERB_TICKET_FLAGS_may_postdate) &&
            ((ServerPolicyFlags & KERB_KDB_DISALLOW_POSTDATED) == 0))
        {
            FinalTicketFlags |= KERB_TICKET_FLAGS_may_postdate;
        }
        else
        {
            DebugLog((DEB_ERROR,"Asked for postdate but not allowed\n"));
            KerbErr = KDC_ERR_BADOPTION;
            goto Cleanup;
        }
    }

    if (KdcOptions & KERB_KDC_OPTIONS_postdated)
    {
        if ((SourceTicketFlags & KERB_TICKET_FLAGS_may_postdate) &&
            ((ServerPolicyFlags & KERB_KDB_DISALLOW_POSTDATED) == 0))
        {
            FinalTicketFlags |= KERB_TICKET_FLAGS_postdated | KERB_TICKET_FLAGS_invalid;

            //
            // Start time is required here
            //

            if (RequestStartTime.QuadPart == 0)
            {
                DebugLog((DEB_ERROR, "Asked for postdate but start time not present\n"));
                KerbErr = KDC_ERR_CANNOT_POSTDATE;
                goto Cleanup;
            }

        }
        else if ((ServerPolicyFlags & KERB_KDB_DISALLOW_POSTDATED))
        {
            KerbErr = KDC_ERR_POLICY;
        }
        else
        {
            KerbErr = KDC_ERR_BADOPTION;
        }
    }

    //
    // Validate
    //

    if (KdcOptions & KERB_KDC_OPTIONS_validate)
    {
        if ((SourceTicketFlags & KERB_TICKET_FLAGS_invalid) == 0)
        {
            DebugLog((DEB_ERROR,"Trying to validate a valid ticket\n"));
            KerbErr = KDC_ERR_POLICY;
            goto Cleanup;
        }
        if ((SourceStartTime.QuadPart == 0) ||
            (SourceStartTime.QuadPart <
                CurrentTime.QuadPart - pKdcPolicy->TimeSkew.QuadPart))
        {
            DebugLog((DEB_ERROR,"Trying to validate a ticket before it is valid\n"));
            KerbErr = KRB_AP_ERR_TKT_NYV;
            goto Cleanup;
        }
    }

    //
    // Start filling in time fields
    //

    if (ARGUMENT_PRESENT(SourceTicket))
    {
        Ticket->authtime = SourceTicket->authtime;
    }
    else
    {
        KerbConvertLargeIntToGeneralizedTime(
            &Ticket->authtime,
            NULL,
            &CurrentTime
            );

    }

    //
    // The times are computed differently for renewing a ticket and for
    // getting a new ticket.
    //

    if ((KdcOptions & KERB_KDC_OPTIONS_renew) != 0)
    {
        if ((SourceRenewTime.QuadPart == 0) ||
            (SourceStartTime.QuadPart == 0) ||
            ((SourceTicketFlags & KERB_TICKET_FLAGS_renewable) == 0) ||
            ((ServerPolicyFlags & KERB_KDB_DISALLOW_RENEWABLE) != 0))
        {
            DebugLog((DEB_ERROR,"Trying to renew a non-renewable ticket or against policy\n"));
            KerbErr = KDC_ERR_BADOPTION;
            goto Cleanup;
        }

        //
        // Make sure the renew time is in the future
        //

        if (SourceRenewTime.QuadPart < CurrentTime.QuadPart)
        {
            DebugLog((DEB_ERROR, "Trying to renew a ticket past its renew time\n"));
#ifdef XBOX_KDC
            KerbErr = KDC_ERR_TGT_REVOKED;
#else           
            KerbErr = KRB_AP_ERR_TKT_EXPIRED;
#endif
            goto Cleanup;
        }

        //
        // Make sure the end time is in the past
        //

        if (SourceEndTime.QuadPart < CurrentTime.QuadPart)
        {
            DebugLog((DEB_ERROR, "Trying to renew an expired ticket\n"));
#ifdef XBOX_KDC
            KerbErr = KDC_ERR_TGT_REVOKED;
#else           
            KerbErr = KRB_AP_ERR_TKT_EXPIRED;
#endif
            goto Cleanup;
        }
        FinalStartTime = CurrentTime;

        //
        // The end time is the minimum of the current time plus lifespan
        // of the old ticket and the renew until time of the old ticket
        //

        FinalEndTime.QuadPart = CurrentTime.QuadPart + (SourceEndTime.QuadPart - SourceStartTime.QuadPart);
        if (FinalEndTime.QuadPart > SourceRenewTime.QuadPart)
        {
            FinalEndTime = SourceRenewTime;
        }
        FinalRenewTime = SourceRenewTime;
        FinalTicketFlags = SourceTicketFlags;

        Renewable = TRUE;
    }
    else
    {
        //
        // Compute start and end times for normal tickets
        //

        //
        // Set the start time
        //

        if (RequestStartTime.QuadPart == 0)
        {
            FinalStartTime = CurrentTime;
        }
        else
        {
            FinalStartTime = RequestStartTime;
        }

        //
        // Set the end time
        //

        if (RequestEndTime.QuadPart == 0)
        {
            FinalEndTime = tsInfinity;
        }
        else
        {
            FinalEndTime = RequestEndTime;
        }

        if (FinalEndTime.QuadPart > SourceEndTime.QuadPart)
        {
            FinalEndTime = SourceEndTime;
        }

        if (FinalEndTime.QuadPart > CurrentTime.QuadPart + MaxTicketLifespan->QuadPart)
        {
            FinalEndTime.QuadPart = CurrentTime.QuadPart + MaxTicketLifespan->QuadPart;
        }

        //
        // Check for renewable-ok
        //

        if ((KdcOptions & KERB_KDC_OPTIONS_renewable_ok) &&
            (FinalEndTime.QuadPart < RequestEndTime.QuadPart) &&
            (SourceTicketFlags & KERB_TICKET_FLAGS_renewable))
        {
            KdcOptions |= KERB_KDC_OPTIONS_renewable;
            RequestRenewTime = RequestEndTime;

            //
            // Make sure that the source ticket had a renewtime (it
            // should because it is renewable)
            //

            DsysAssert(SourceRenewTime.QuadPart != 0);
            if (RequestRenewTime.QuadPart > SourceRenewTime.QuadPart)
            {
                RequestRenewTime = SourceRenewTime;
            }
        }
    }

    if (!Renewable)
    {
        //
        // Compute renew times
        //

        if (RequestRenewTime.QuadPart == 0)
        {
            RequestRenewTime = tsInfinity;
        }

        if ((KdcOptions & KERB_KDC_OPTIONS_renewable) &&
            (SourceTicketFlags & KERB_TICKET_FLAGS_renewable) &&
            ((ServerPolicyFlags & KERB_KDB_DISALLOW_RENEWABLE) == 0))
        {
            FinalRenewTime = RequestRenewTime;
            if (FinalRenewTime.QuadPart > FinalStartTime.QuadPart + MaxTicketRenewspan->QuadPart)
            {
                FinalRenewTime.QuadPart = FinalStartTime.QuadPart + MaxTicketRenewspan->QuadPart;
            }

            DsysAssert(SourceRenewTime.QuadPart != 0);

            if (FinalRenewTime.QuadPart > SourceRenewTime.QuadPart)
            {
                FinalRenewTime = SourceRenewTime;
            }
            FinalTicketFlags |= KERB_TICKET_FLAGS_renewable;

        }
        else
        {
            FinalRenewTime.QuadPart = 0;
        }
    }

    //
    // Make sure the final ticket is valid
    //

    if (FinalStartTime.QuadPart > FinalEndTime.QuadPart)
    {
        DebugLog((DEB_ERROR,"Client asked for endtime before starttime\n"));
        KerbErr = KDC_ERR_BADOPTION;

        FILL_EXT_ERROR_EX(ExtendedError, STATUS_TIME_DIFFERENCE_AT_DC, FILENO, __LINE__);
        goto Cleanup;
    }

    //
    // Don't bother with this check - it doesn't really hurt to have a
    // renew time less than an end time
    //
//
//    if ((FinalRenewTime.QuadPart != 0) &&
//        (FinalRenewTime.QuadPart < FinalEndTime.QuadPart))
//    {
//        DebugLog((DEB_ERROR,"Client asked for renew time before endtime\n"));
//        KerbErr = KDC_ERR_BADOPTION;
//        goto Cleanup;
//    }
//

    //
    // Incorporate the logoff time (according to logon hours) by reseting
    // both the final end time and final renew time
    //

    //
    //  Tickets good only until acct expires.
    //  We make the assumption that the sam has
    //  already checked this against the current time
    //  when we're checking the logon restrictions.
    //
    if ((ARGUMENT_PRESENT(AccountExpiry) &&
         (AccountExpiry->QuadPart != KERB_KDB_TIME_NEVER)))
    {
        if (FinalEndTime.QuadPart > AccountExpiry->QuadPart)
        {
            FinalEndTime.QuadPart = AccountExpiry->QuadPart;
        }


        if (FinalRenewTime.QuadPart > AccountExpiry->QuadPart)
        {
            FinalRenewTime.QuadPart = AccountExpiry->QuadPart;
        }

    }


    //
    // Fill in the times in the ticket
    //

    KerbConvertLargeIntToGeneralizedTime(
        &Ticket->KERB_ENCRYPTED_TICKET_starttime,
        NULL,
        &FinalStartTime
        );
    Ticket->bit_mask |= KERB_ENCRYPTED_TICKET_starttime_present;

    KerbConvertLargeIntToGeneralizedTime(
        &Ticket->endtime,
        NULL,
        &FinalEndTime
        );

    if (FinalRenewTime.QuadPart != 0)
    {
        KerbConvertLargeIntToGeneralizedTime(
            &Ticket->KERB_ENCRYPTED_TICKET_renew_until,
            NULL,
            &FinalRenewTime
            );
        Ticket->bit_mask |= KERB_ENCRYPTED_TICKET_renew_until_present;


    }

    //
    // Copy in the flags
    //

    DsysAssert(Ticket->flags.length == sizeof(ULONG) * 8);
    *((PULONG) Ticket->flags.value) = KerbConvertUlongToFlagUlong(FinalTicketFlags);
Cleanup:
    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbDuplicateCredentials
//
//  Synopsis:   Copies a set of credentials (passwords)
//
//  Effects:    allocates output with MIDL_user_allocate
//
//  Arguments:  NewCredentials - recevies new set of credentials
//              OldCredentials - contains credentials to copy
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR
KdcDuplicateCredentials(
    OUT PKERB_STORED_CREDENTIAL * NewCredentials,
    OUT PULONG ReturnCredentialSize,
    IN PKERB_STORED_CREDENTIAL OldCredentials,
    IN BOOLEAN MarshallKeys
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_STORED_CREDENTIAL Credential = NULL;
    ULONG CredentialSize;
    USHORT Index;
    PBYTE Where;
    LONG_PTR Offset;

    TRACE(KDC, KdcDuplicateCredentials, DEB_FUNCTION);
    TRACER(L"KdcDuplicateCredentials", (PVOID *) &KerbErr);

    //
    // If there were no credentials, so be it. We can live with that.
    //

    if (OldCredentials == NULL)
    {
        *NewCredentials = NULL;
        goto Cleanup;
    }

    //
    // Calculate the size of the new credentials by summing the size of
    // the base structure plus the keys
    //

    CredentialSize = sizeof(KERB_STORED_CREDENTIAL)
                        - ANYSIZE_ARRAY * sizeof(KERB_KEY_DATA)
                        + OldCredentials->CredentialCount * sizeof(KERB_KEY_DATA)
                        + OldCredentials->DefaultSalt.Length;
    for ( Index = 0;
          Index < OldCredentials->CredentialCount;
          Index++ )
    {
        CredentialSize += OldCredentials->Credentials[Index].Key.keyvalue.length +
                          OldCredentials->Credentials[Index].Salt.Length;
    }

    //
    // Allocate the new credential and copy over the old credentials
    //


    Credential = (PKERB_STORED_CREDENTIAL) MIDL_user_allocate(CredentialSize);
    if (Credential == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    Credential->CredentialCount = OldCredentials->CredentialCount;

    //
    // Set the offset for data to be after the last array element
    //

    memcpy(
        &Credential->Credentials[0],
        &OldCredentials->Credentials[0],
        OldCredentials->CredentialCount * sizeof(KERB_KEY_DATA)
        );

    Where = (PBYTE) &Credential->Credentials[Credential->CredentialCount];

    if (MarshallKeys)
    {
        Offset = (LONG_PTR) Credential;
    }
    else
    {
        Offset = 0;
    }

    Credential->DefaultSalt = OldCredentials->DefaultSalt;
    if (Credential->DefaultSalt.Buffer != NULL)
    {
        Credential->DefaultSalt.Buffer = (LPWSTR) (Where - Offset);
        memcpy(
            Where,
            OldCredentials->DefaultSalt.Buffer,
            Credential->DefaultSalt.Length
            );
        Where +=  Credential->DefaultSalt.Length;
    }

    for ( Index = 0;
          Index < OldCredentials->CredentialCount;
          Index++ )
    {
        Credential->Credentials[Index] = OldCredentials->Credentials[Index];
        Credential->Credentials[Index].Key.keyvalue.value = (Where - Offset);
        memcpy(
            Where,
            OldCredentials->Credentials[Index].Key.keyvalue.value,
            OldCredentials->Credentials[Index].Key.keyvalue.length
            );
        Where += OldCredentials->Credentials[Index].Key.keyvalue.length;

        if (Credential->Credentials[Index].Salt.Buffer != NULL)
        {
            Credential->Credentials[Index].Salt.Buffer = (LPWSTR) (Where - Offset);

            memcpy(
                Where,
                OldCredentials->Credentials[Index].Salt.Buffer,
                OldCredentials->Credentials[Index].Salt.Length
                );
            Where += OldCredentials->Credentials[Index].Salt.Length;
        }
    }
    DsysAssert(Where - (PUCHAR) Credential == (LONG) CredentialSize);

    *NewCredentials = Credential;
    Credential = NULL;
    *ReturnCredentialSize = CredentialSize;

Cleanup:
    if (Credential != NULL)
    {
        MIDL_user_free(Credential);
    }
    return(KerbErr);
}


//--------------------------------------------------------------------
//
//  Name:       BuildReply
//
//  Synopsis:   Extracts reply information from an internal ticket
//
//  Arguments:  pkitTicket  - (in) ticket data comes from
//              dwNonce     - (in) goes into the reply
//              pkrReply    - (out) reply that is built
//
//  Notes:      BUG 456265: Need to set tsKeyExpiry properly.
//              See 3.1.3, 3.3.3 of the Kerberos V5 R5.2 spec
//              tsKeyExpiry is zero for GetTGSTicket, and the
//              expiry time of the client's key for GetASTicket.
//
//--------------------------------------------------------------------

KERBERR
BuildReply(
    IN OPTIONAL PIKerbPrincipal ClientInfo,
    IN ULONG Nonce,
    IN PKERB_PRINCIPAL_NAME ServerName,
    IN KERB_REALM ServerRealm,
    IN PKERB_HOST_ADDRESSES HostAddresses,
    IN PKERB_TICKET Ticket,
    OUT PKERB_ENCRYPTED_KDC_REPLY ReplyMessage
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_ENCRYPTED_TICKET EncryptedTicket = (PKERB_ENCRYPTED_TICKET) Ticket->encrypted_part.cipher_text.value;
    KERB_ENCRYPTED_KDC_REPLY ReplyBody;
    LARGE_INTEGER CurrentTime;

    TRACE(KDC, BuildReply, DEB_FUNCTION);
    TRACER(L"BuildReply", (PVOID *) &KerbErr);

    ZeroMemory(
        &ReplyBody,
        sizeof(KERB_ENCRYPTED_KDC_REPLY)
        );

    //
    // Use the same flags field
    //

    ReplyBody.flags = ReplyMessage->flags;



    ReplyBody.session_key = EncryptedTicket->key;


    ReplyBody.last_request = (PKERB_LAST_REQUEST) MIDL_user_allocate(sizeof(KERB_LAST_REQUEST));
    if (ReplyBody.last_request == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    ZeroMemory(
        ReplyBody.last_request,
        sizeof(KERB_LAST_REQUEST)
        );

    ReplyBody.last_request->next = NULL;
    ReplyBody.last_request->value.last_request_type = 0;
    GetSystemTimeAsFileTime((PFILETIME)&CurrentTime);

    KerbConvertLargeIntToGeneralizedTime(
        &ReplyBody.last_request->value.last_request_value,
        NULL,           // no usec
        &CurrentTime
        );

    ReplyBody.nonce = Nonce;

    DsysAssert((ReplyBody.flags.length == EncryptedTicket->flags.length) &&
               (ReplyBody.flags.length== 8 * sizeof(ULONG)));

    //
    // Assign the flags over
    //

    *((PULONG)ReplyBody.flags.value) = *((PULONG)EncryptedTicket->flags.value);

    if (ARGUMENT_PRESENT(ClientInfo) &&
    ClientInfo->Expiration().QuadPart != KERB_KDB_TIME_NEVER)
    {
        LARGE_INTEGER Exp =  ClientInfo->Expiration();
        KerbConvertLargeIntToGeneralizedTime(
            &ReplyBody.key_expiration,
            NULL,
            &Exp);
        ReplyBody.bit_mask |= key_expiration_present;
    }


    //
    // Fill in the times
    //


    ReplyBody.authtime = EncryptedTicket->authtime;
    ReplyBody.endtime = EncryptedTicket->endtime;

    if (EncryptedTicket->bit_mask & KERB_ENCRYPTED_TICKET_starttime_present)
    {
        ReplyBody.KERB_ENCRYPTED_KDC_REPLY_starttime =
            EncryptedTicket->KERB_ENCRYPTED_TICKET_starttime;
        ReplyBody.bit_mask |= KERB_ENCRYPTED_KDC_REPLY_starttime_present;

    }

    if (EncryptedTicket->bit_mask & KERB_ENCRYPTED_TICKET_renew_until_present)
    {
        ReplyBody.KERB_ENCRYPTED_KDC_REPLY_renew_until =
            EncryptedTicket->KERB_ENCRYPTED_TICKET_renew_until;
        ReplyBody.bit_mask |= KERB_ENCRYPTED_KDC_REPLY_renew_until_present;
    }

    ReplyBody.server_realm = ServerRealm;

    ReplyBody.server_name = *ServerName;

    //
    // Fill in the host addresses
    //


    if (HostAddresses != NULL)
    {
        ReplyBody.KERB_ENCRYPTED_KDC_REPLY_client_addresses = HostAddresses;
        ReplyBody.bit_mask |= KERB_ENCRYPTED_KDC_REPLY_client_addresses_present;
    }

    *ReplyMessage = ReplyBody;
Cleanup:

    if (!KERB_SUCCESS(KerbErr))
    {
        if (ReplyBody.last_request != NULL)
        {
            MIDL_user_free(ReplyBody.last_request);
            ReplyBody.last_request = NULL;
        }

    }

    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcFreeInternalTicket
//
//  Synopsis:   frees a constructed ticket
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KdcFreeInternalTicket(
    IN PKERB_TICKET Ticket
    )
{
    PKERB_ENCRYPTED_TICKET EncryptedTicket = (PKERB_ENCRYPTED_TICKET) Ticket->encrypted_part.cipher_text.value;

    TRACE(KDC, KdcFreeInternalTicket, DEB_FUNCTION);
    TRACER(L"KdcAtqRetrySocketRead", NULL);

    if (EncryptedTicket != NULL)
    {
        KerbFreeKey(
            &EncryptedTicket->key
            );
        KerbFreePrincipalName(&EncryptedTicket->client_name);
        if (EncryptedTicket->KERB_ENCRYPTED_TICKET_authorization_data != NULL)
        {
            KerbFreeAuthData(EncryptedTicket->KERB_ENCRYPTED_TICKET_authorization_data);
        }
        if (EncryptedTicket->transited.contents.value != NULL)
        {
            MIDL_user_free(EncryptedTicket->transited.contents.value);
        }
    }


    KerbFreePrincipalName(
        &Ticket->server_name
        );

    KerbFreeRealm(
        &Ticket->realm
        );

}

//+-------------------------------------------------------------------------
//
//  Function:   KdcFreeKdcReply
//
//  Synopsis:   frees a kdc reply
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KdcFreeKdcReply(
    IN PKERB_KDC_REPLY Reply
    )
{
    TRACE(KDC, KdcFreeKdcReply, DEB_FUNCTION);
    TRACER(L"KdcFreeKdcReply", NULL);

    KerbFreePrincipalName(&Reply->ticket.server_name);

    KerbFreeRealm(&Reply->ticket.realm);

    if (Reply->ticket.encrypted_part.cipher_text.value != NULL)
    {
        MIDL_user_free(Reply->ticket.encrypted_part.cipher_text.value);
    }

    if (Reply->encrypted_part.cipher_text.value != NULL)
    {
        MIDL_user_free(Reply->encrypted_part.cipher_text.value);
    }
    if (Reply->KERB_KDC_REPLY_preauth_data != NULL)
    {
        KerbFreePreAuthData((PKERB_PA_DATA_LIST) Reply->KERB_KDC_REPLY_preauth_data);
    }


}

//+-------------------------------------------------------------------------
//
//  Function:   KdcFreeKdcReplyBody
//
//  Synopsis:   frees a constructed KDC reply body
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KdcFreeKdcReplyBody(
    IN PKERB_ENCRYPTED_KDC_REPLY ReplyBody
    )
{

    TRACE(KDC, KdcFreeKdcReplyBody, DEB_FUNCTION);
    TRACER(L"KdcFreeKdcReplyBody", NULL);
    //
    // The names & the session key are just pointers into the ticket,
    // so they don't need to be freed.
    //

    if (ReplyBody->last_request != NULL)
    {
        MIDL_user_free(ReplyBody->last_request);
        ReplyBody->last_request = NULL;
    }
    ReplyBody->KERB_ENCRYPTED_KDC_REPLY_client_addresses = NULL;

}

//+-------------------------------------------------------------------------
//
//  Function:   KdcVerifyClientAddress
//
//  Synopsis:   Verifies that the client address is an allowed sender of
//              the KDC request.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------



KERBERR
KdcVerifyClientAddress(
    IN SOCKADDR * ClientAddress,
    IN PKERB_HOST_ADDRESSES Addresses
    )
{
    TRACER(L"KdcVerifyClientAddress", NULL);

    PKERB_HOST_ADDRESSES TempAddress = Addresses;

    //
    // ISSUE-2001/03/05-markpu
    // This routine is wholly inadequate in that it only deals with IPv4
    // addresses.  Address matching has to be more elaborate than that
    //

    while (TempAddress != NULL)
    {
        if ( TempAddress->value.address_type == KERB_ADDRTYPE_INET &&
             ClientAddress->sa_family == AF_INET )
        {
            struct sockaddr_in * InetAddress = (struct sockaddr_in *) ClientAddress;

            //
            // Check that the addresses match
            //

            if (TempAddress->value.address.length == sizeof(ULONG))
            {
                if (!memcmp(
                        TempAddress->value.address.value,
                        &InetAddress->sin_addr.S_un.S_addr,
                        sizeof(ULONG)
                        ))
                {
                    return(KDC_ERR_NONE);
                }
            }

        }

        TempAddress = TempAddress->next;
    }

    D_DebugLog((DEB_WARN,"Client address not in address list\n"));

    //
    // Need to return KRB_AP_ERR_BADADDR but a couple of things must
    // be fixed first (client code notified of changes to the machine's IP
    // address, copying addresses from the TGT into the TGS request)
    //

    return(KDC_ERR_NONE);
}




//+-------------------------------------------------------------------------
//
//  Function:   KdcVerifyTgsChecksum
//
//  Synopsis:   Verify the checksum on a TGS request
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcVerifyTgsChecksum(
    IN PKERB_KDC_REQUEST_BODY RequestBody,
    IN PKERB_ENCRYPTION_KEY Key,
    IN PKERB_CHECKSUM OldChecksum
    )
{
    PCHECKSUM_FUNCTION ChecksumFunction;
    PCHECKSUM_BUFFER CheckBuffer = NULL;
    KERB_MESSAGE_BUFFER MarshalledRequestBody = {0, NULL};
    NTSTATUS Status;
    KERBERR KerbErr = KDC_ERR_NONE;
    KERB_CHECKSUM Checksum = {0};

    TRACER(L"KdcVerifyTgsChecksum", (PVOID *) &KerbErr);

    Status = CDLocateCheckSum(
                OldChecksum->checksum_type,
                &ChecksumFunction
                );
    if (!NT_SUCCESS(Status))
    {
        KerbErr = KDC_ERR_SUMTYPE_NOSUPP;
        goto Cleanup;
    }

    //
    // Allocate enough space for the checksum
    //

    Checksum.checksum.value = (PUCHAR) MIDL_user_allocate(ChecksumFunction->CheckSumSize);
    if (Checksum.checksum.value == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    Checksum.checksum.length = ChecksumFunction->CheckSumSize;

    //
    // Initialize the checksum
    //

    if ((OldChecksum->checksum_type == KERB_CHECKSUM_REAL_CRC32) ||
        (OldChecksum->checksum_type == KERB_CHECKSUM_CRC32))
    {
        if (ChecksumFunction->Initialize)
        {
            Status = ChecksumFunction->Initialize(
                        0,
                        &CheckBuffer
                        );
            }
        else
        {

            KerbErr = KRB_ERR_GENERIC;
        }
    }
    else
    {
        if (NULL != ChecksumFunction->InitializeEx2)
        {
            Status = ChecksumFunction->InitializeEx2(
                        Key->keyvalue.value,
                        (ULONG) Key->keyvalue.length,
                        OldChecksum->checksum.value,
                        KERB_TGS_REQ_AP_REQ_AUTH_CKSUM_SALT,
                        &CheckBuffer
                        );
        }
        else if (ChecksumFunction->InitializeEx)
        {
            Status = ChecksumFunction->InitializeEx(
                        Key->keyvalue.value,
                        (ULONG) Key->keyvalue.length,
                        KERB_TGS_REQ_AP_REQ_AUTH_CKSUM_SALT,
                        &CheckBuffer
                        );
        }
        else
        {
            KerbErr = KRB_ERR_GENERIC;
        }
    }

    if (!NT_SUCCESS(Status))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = KerbPackData(
                        RequestBody,
                        KERB_MARSHALLED_REQUEST_BODY_PDU,
                        &MarshalledRequestBody.BufferSize,
                        &MarshalledRequestBody.Buffer
                        );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Now checksum the buffer
    //

    ChecksumFunction->Sum(
        CheckBuffer,
        MarshalledRequestBody.BufferSize,
        MarshalledRequestBody.Buffer
        );

    ChecksumFunction->Finalize(
        CheckBuffer,
        Checksum.checksum.value
        );

    //
    // Now compare
    //

    if ((OldChecksum->checksum.length != Checksum.checksum.length) ||
        memcmp(
            OldChecksum->checksum.value,
            Checksum.checksum.value,
            Checksum.checksum.length
            ))
    {
        DebugLog((DEB_ERROR,"Checksum on TGS request body did not match\n"));
        KerbErr = KRB_AP_ERR_MODIFIED;
        goto Cleanup;
    }

Cleanup:
    if (CheckBuffer != NULL)
    {
        ChecksumFunction->Finish(&CheckBuffer);
    }
    if (MarshalledRequestBody.Buffer != NULL)
    {
        MIDL_user_free(MarshalledRequestBody.Buffer);
    }
    if (Checksum.checksum.value != NULL)
    {
        MIDL_user_free(Checksum.checksum.value);
    }
    return(KerbErr);

}


//+-------------------------------------------------------------------------
//
//  Function:   KdcVerifyKdcRequest
//
//  Synopsis:   Verifies that the AP request accompanying a TGS or PAC request
//              is valid.
//
//  Effects:
//
//  Arguments:  ApRequest - The AP request to verify
//              UnmarshalledRequest - The unmarshalled request,
//                      returned to avoid needing to
//              EncryptedTicket - Receives the ticket granting  ticket
//              SessionKey - receives the key to use in the reply
//
//  Requires:
//
//  Returns:    kerberos errors
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR
KdcVerifyKdcRequest(
    IN PIKdbProvider piKdb,
    IN CKerbRequest*    pKdcReq,
    IN PUCHAR RequestMessage,
    IN ULONG RequestSize,
    IN OPTIONAL SOCKADDR * ClientAddress,
    IN BOOLEAN IsKdcRequest,
    OUT OPTIONAL PKERB_AP_REQUEST * UnmarshalledRequest,
    OUT OPTIONAL PKERB_AUTHENTICATOR * UnmarshalledAuthenticator,
    OUT PKERB_ENCRYPTED_TICKET *EncryptedTicket,
    OUT PKERB_ENCRYPTION_KEY SessionKey,
    OUT PIKerbPrincipal *RetServerInfo,
    OUT PBOOLEAN UseSubKey,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    PIKerbPrincipal ServerInfo = NULL;
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_AP_REQUEST Request = NULL;
    PKERB_ENCRYPTED_TICKET EncryptPart = NULL;
    PKERB_AUTHENTICATOR Authenticator = NULL;
    PKERB_INTERNAL_NAME ServerName = NULL;
    UNICODE_STRING ServerRealm = {0};
    //NTSTATUS    Status = STATUS_SUCCESS;

    TRACE(KDC, KdcVerifyKdcRequest, DEB_FUNCTION);
    TRACER(L"KdcVerifyKdcRequest", (PVOID *) &KerbErr);

    *RetServerInfo = NULL;

    ServerRealm.Buffer = NULL;


    //
    // First unpack the KDC request.
    //

    KerbErr = KerbUnpackApRequest(
                RequestMessage,
                RequestSize,
                &Request
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to unpack KDC request: 0x%x\n",KerbErr));
        KerbErr = KDC_ERR_NO_RESPONSE;
        goto Cleanup;
    }

    //  check version and msg type
    if (Request->version != KERBEROS_VERSION)
    {
        KerbErr = KRB_AP_ERR_BADVERSION;
        goto    Cleanup;
    }
    if (Request->message_type != KRB_AP_REQ)
    {
        KerbErr = KRB_AP_ERR_MSG_TYPE;
        goto    Cleanup;
    }

    KerbErr = KerbConvertPrincipalNameToKdcName(
                &ServerName,
                &Request->ticket.server_name
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = KerbConvertRealmToUnicodeString(
                &ServerRealm,
                &Request->ticket.realm
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;

    }

    KerbErr = KerbProcessPaCompoundIdentity(pKdcReq, pExtendedError);
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;

    }

    //
    // Get ticket info for the server
    //

    KerbErr = piKdb->GetPrincipal(
    KDC_KDB_GET_PRINC_SERVER | KDC_KDB_GET_PRINC_TRUST_INBOUND,
                  ServerName,
                  ServerRealm.Buffer,
                  pKdcReq,
                  &ServerInfo,
                  //&Status,
                  pExtendedError,
                  NULL
                 );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_WARN, "Trying to get TGS ticket to service in another realm: "));
        KerbPrintKdcName(DEB_WARN, ServerName);
        goto Cleanup;
    }


    //
    // Now Check the ticket
    //


    //
    // We don't need to supply a service name or service because we've looked up
    // the account locally.
    //

    KerbErr = KerbCheckTicket(
                pKdcReq,
                &Request->ticket,
                &Request->authenticator,
                ServerInfo,
                Authenticators,
                &piKdb->GetKdcPolicy()->TimeSkew,
                0,                      // zero service names
                NULL,                   // any service
                NULL,
                FALSE,                  // don't check for replay
                IsKdcRequest,
                &EncryptPart,
                &Authenticator,
                NULL,
                SessionKey,
                UseSubKey,
                pExtendedError
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to check ticket : 0x%x for",KerbErr));
        KerbPrintKdcName(DEB_ERROR,ServerName );


        //
        //  Here's the case where we're trying to use an expired TGT.  Have
        // the client retry using a new TGT
        //
#ifdef XBOX_KDC
        if (KerbErr == KRB_AP_ERR_TKT_EXPIRED || KerbErr == KDC_ERR_TGT_REVOKED)
#else           
        if (KerbErr == KRB_AP_ERR_TKT_EXPIRED)
#endif          
        {
            FILL_EXT_ERROR_EX(pExtendedError, STATUS_TIME_DIFFERENCE_AT_DC, FILENO, __LINE__);
        }

        goto Cleanup;
    }

    //
    // Verify the address from the ticket
    //

    if ((EncryptPart->bit_mask & KERB_ENCRYPTED_TICKET_client_addresses_present) &&
        ARGUMENT_PRESENT(ClientAddress))

    {
        ULONG TicketFlags = KerbConvertFlagsToUlong(&EncryptPart->flags);

        //
        // Only check initial tickets
        //

        if ((TicketFlags & (KERB_TICKET_FLAGS_forwarded | KERB_TICKET_FLAGS_proxy)) == 0)
        {
            KerbErr = KdcVerifyClientAddress(
                        ClientAddress,
                        EncryptPart->KERB_ENCRYPTED_TICKET_client_addresses
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                DebugLog((DEB_ERROR,"Client sent request with wrong address\n"));
                goto Cleanup;
            }
        }
    }

    //
    // Verify that if the server is a trusted domain account, that it is an
    // acceptable ticket (transitively). Verify that for non transitive
    // trust the client realm is the same as the requesting ticket realm
    //

    *EncryptedTicket = EncryptPart;
    EncryptPart = NULL;
    if (ARGUMENT_PRESENT(UnmarshalledRequest))
    {
        *UnmarshalledRequest = Request;
        Request = NULL;
    }
    if (ARGUMENT_PRESENT(UnmarshalledAuthenticator))
    {
        *UnmarshalledAuthenticator = Authenticator;
        Authenticator = NULL;
    }

Cleanup:
    if (!KERB_SUCCESS(KerbErr))
    {
        //  do we really need to free it
        //  or save it in the req.
        if (ServerInfo)
            ServerInfo->Release();
    }
    else
    *RetServerInfo = ServerInfo;

    KerbFreeApRequest(Request);
    KerbFreeKdcName(&ServerName);
    KerbFreeString(&ServerRealm);
    KerbFreeAuthenticator(Authenticator);
    KerbFreeTicket(EncryptPart);

    return(KerbErr);
}

//+-------------------------------------------------------------------------
//
//  Function:   EnterApiCall
//
//  Synopsis:   Makes sure that the KDC service is initialized and running
//              and won't terminate during the call.
//
//  Effects:    increments the CurrentApiCallers count.
//
//  Arguments:
//
//  Requires:
//
//  Returns:    STATUS_INVALID_SERVER_STATE - the KDC service is not
//                      running
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
EnterApiCall(
    VOID
    )
{
    NTSTATUS hrRet = STATUS_SUCCESS;
    EnterCriticalSection(&ApiCriticalSection);
    if (KdcState != Stopped)
    {
        CurrentApiCallers++;
    }
    else
    {
        hrRet = STATUS_INVALID_SERVER_STATE;
    }
    LeaveCriticalSection(&ApiCriticalSection);
    return(hrRet);
}


//+-------------------------------------------------------------------------
//
//  Function:   LeaveApiCall
//
//  Synopsis:   Decrements the count of active calls and if the KDC is
//              shutting down sets an event to let it continue.
//
//  Effects:    Deccrements the CurrentApiCallers count.
//
//  Arguments:
//
//  Requires:
//
//  Returns:    Nothing
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
LeaveApiCall(
    VOID
    )
{
    EnterCriticalSection(&ApiCriticalSection);
    CurrentApiCallers--;

    if (KdcState == Stopped)
    {
        if (CurrentApiCallers == 0)
        {
            if (!SetEvent(hKdcShutdownEvent))
            {
                D_DebugLog((DEB_ERROR,"Failed to set shutdown event from LeaveApiCall: 0x%d\n",GetLastError()));
            }
            else
            {
                UpdateStatus(SERVICE_STOP_PENDING);
            }

            //
            // Free any DS libraries in use
            //

            SecData.Cleanup();
#ifdef KDC_WMI_TRACING
            if (KdcTraceRegistrationHandle != (TRACEHANDLE)0)
            {
                UnregisterTraceGuids( KdcTraceRegistrationHandle );
            }
#endif
        }

    }
    LeaveCriticalSection(&ApiCriticalSection);
}


NTSTATUS
KdcBuildEtypeStringFromStoredCredential(
    IN PKERB_STORED_CREDENTIAL Cred,
    IN OUT PWSTR * EtypeString
    )
{

    ULONG BuffSize;
    PWSTR Ret = NULL;
    WCHAR Buff[12];
    TRACER(L"KdcBuildEtypeStringFromStoredCredential", NULL);

    *EtypeString = NULL;


    if (Cred == NULL
         || (Cred->CredentialCount == 0))
    {
        BuffSize = (ULONG) sizeof(WCHAR) * (ULONG) (wcslen(WSZ_NO_KEYS)+1);
        *EtypeString = (LPWSTR)MIDL_user_allocate(BuffSize);

        if (NULL == *EtypeString)
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        wcscpy(*EtypeString, WSZ_NO_KEYS);

        return STATUS_SUCCESS;
    }

    // Guess maximum buffer... Etypes are 4 chars at most
    BuffSize = (Cred->CredentialCount* MAX_ETYPE_STRING);
    Ret = (LPWSTR)MIDL_user_allocate(BuffSize);
    if (NULL == Ret)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    *Ret = L'\0';
    for (LONG Index = 0;Index < Cred->CredentialCount; Index++ )
    {
        if (Cred->Credentials[Index].Key.keytype > MAX_ETYPE_LONG ||
            Cred->Credentials[Index].Key.keytype < MIN_ETYPE_LONG)
        {
            DebugLog((DEB_ERROR, "Keytype too large for string conversion\n"));
            DsysAssert(FALSE);
        }
        else
        {
            _itow(Cred->Credentials[Index].Key.keytype, Buff, 10);
            wcscat(Ret, Buff);
            wcscat(Ret, L"  ");
        }
    }
    *EtypeString = Ret;
    return STATUS_SUCCESS;
}

NTSTATUS
KdcBuildEtypeStringFromCryptList(
    IN PKERB_CRYPT_LIST CryptList,
    IN OUT LPWSTR * EtypeString
    )
{

    ULONG BuffSize = 0;
    PWSTR Ret = NULL;
    WCHAR Buff[30];

    TRACER(L"KdcBuildEtypeStringFromCryptList", NULL);

    PKERB_CRYPT_LIST ListPointer = CryptList;

    *EtypeString = NULL;


    if (CryptList == NULL)
    {
        BuffSize = (ULONG) sizeof(WCHAR) * (ULONG) (wcslen(WSZ_NO_KEYS)+1);
        *EtypeString = (LPWSTR)MIDL_user_allocate(BuffSize);

        if (NULL == *EtypeString)
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        wcscpy(*EtypeString, WSZ_NO_KEYS);

        return STATUS_SUCCESS;
    }

    while (TRUE)
    {
        if (ListPointer->value > MAX_ETYPE_LONG || ListPointer->value < MIN_ETYPE_LONG)
        {
           DebugLog((DEB_ERROR, "Maximum etype exceeded\n"));
           return STATUS_INVALID_PARAMETER;
        }

        BuffSize += MAX_ETYPE_STRING;
        if (NULL == ListPointer->next)
        {
            break;
        }
        ListPointer = ListPointer->next;

    }

    Ret = (LPWSTR) MIDL_user_allocate(BuffSize);
    if (NULL == Ret)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    *Ret = L'\0';
    while (TRUE)
    {
        _itow(CryptList->value, Buff, 10);
        wcscat(Ret,Buff);
        wcscat(Ret, L"  ");
        if (NULL == CryptList->next)
        {
            break;
        }

        CryptList = CryptList->next;

    }

    *EtypeString = Ret;

    return STATUS_SUCCESS;
}

void
KdcReportKeyError(
    IN PIKdbProvider KdbHandle,
    IN PKERB_INTERNAL_NAME ClientName,
    IN OPTIONAL PUNICODE_STRING ClientRealm,
    IN OPTIONAL PKERB_INTERNAL_NAME ServerName,
    IN OPTIONAL PUNICODE_STRING ServerRealm,
    IN ULONG EventId,
    IN OPTIONAL PKERB_CRYPT_LIST RequestEtypes
    //  actuall keys are not available. If necessary
    //  call the corresponding log/trace method in the provider
//    IN OPTIONAL PKERB_STORED_CREDENTIAL StoredCredential
    )
{
    ULONG NumberOfStrings;
    NTSTATUS Status;
    PWSTR Strings[ 4 ] = {NULL,NULL,NULL,NULL};
    PWSTR RequestEtypeString = NULL;
    PWSTR AccountNameEtypeString = NULL;
    UNICODE_STRING ClientString = {0};
    UNICODE_STRING ServerString = {0};

    TRACER(L"KdcReportKeyError", NULL);

    KerbConvertKdcNameToString(
    &ClientString,
    ClientName,
    ClientRealm
    );

    if (ARGUMENT_PRESENT(ServerName))
    {
    KerbConvertKdcNameToString(
        &ServerString,
        ServerName,
        ServerRealm
        );
    }

    Status = KdcBuildEtypeStringFromCryptList(
                    RequestEtypes,
                    &RequestEtypeString
                    );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "KdcBuildEtypeFromCryptList failed\n"));
        goto cleanup;
    }

#if 0
    Status = KdcBuildEtypeStringFromStoredCredential(
                    StoredCredential,
                    &AccountNameEtypeString
                    );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "KdcBuildEtypeFromStoredCredential failed\n"));
        goto cleanup;
    }
#endif

    if (EventId == KDCEVENT_NO_KEY_UNION_AS )
    {
        Strings[0] = ClientString.Buffer;
        Strings[1] = RequestEtypeString;
        Strings[2] = AccountNameEtypeString;
        NumberOfStrings = 3;
    }
    else if (EventId == KDCEVENT_NO_KEY_UNION_TGS )
    {
        if (!ARGUMENT_PRESENT(ServerName))
        {
            DebugLog((DEB_ERROR, "Invalid arg to KdcReportKeyError!\n"));
            DsysAssert(FALSE);
            goto cleanup;
        }
        Strings[0] = ServerString.Buffer;
        Strings[1] = ClientString.Buffer;
        Strings[2] = RequestEtypeString;
        Strings[3] = AccountNameEtypeString;
        NumberOfStrings = 4;

    }
    else
    {
        goto cleanup;
    }

    KdbReportEventW(
        IEvent::ERROR_TYPE,
        EventId,
        0,
        NULL,
        NumberOfStrings,
        Strings[0],
        Strings[1],
        Strings[2],
        Strings[3]
    );

cleanup:
    KerbFreeString(&ClientString);
    KerbFreeString(&ServerString);

    if (NULL != RequestEtypeString )
    {
        MIDL_user_free(RequestEtypeString);
    }

    if (NULL != AccountNameEtypeString )
    {
        MIDL_user_free(AccountNameEtypeString);
    }

    return;

}

BOOLEAN
KdcIsKrbtgt(
    IN const KERB_INTERNAL_NAME * Name
    )
{
    return ((Name->NameType == KRB_NT_SRV_INST) &&
            (Name->NameCount == 2) &&
            (RtlEqualUnicodeString(&Name->Names[0], &KrbtgtName, FALSE)));
}

#if DBG

void
PrintRequest( ULONG ulDebLevel, PKERB_KDC_REQUEST_BODY Request )
{
    TRACE(KDC, PrintRequest, DEB_FUNCTION);
}

void
PrintTicket( ULONG ulDebLevel,
             char * pszMessage,
             PKERB_TICKET pkitTicket)
{
    TRACE(KDC, PrintTicket, DEB_FUNCTION);
}

#endif // DBG

//+---------------------------------------------------------------------------
//
//  Function:   KerbProcessPaCompoundIdentity
//
//  Synopsis:   searches for PA-Compound-Identity and if found,
//              instantiatiates a handler to process it
//
//  Arguments:  [pKdcReq]    -- (in, out) ptr to kdc request
//
//  History:    11-15-01   yordanr   Created
//
//  remarks:    ptr to this PA handler is saved in the request for
//              future use
//
//----------------------------------------------------------------------------

KERBERR
KerbProcessPaCompoundIdentity(CKerbRequest *pKdcReq,
                              PKERB_EXT_ERROR pExtErr)
{
    PKERB_KDC_REQUEST_preauth_data pPAData = pKdcReq->m_pKdcRequest->preauth_data;

    while (pPAData)
    {
        if (pPAData->value.preauth_data_type == KRB5_PADATA_COMPOUND_IDENTITY )
            break;
        pPAData = pPAData->next;
    }
    if (pPAData)
    {
        IPAHandler *piPA = NULL;
        if (!NT_SUCCESS(
            pKdcReq->GetPAHandler(pPAData->value.preauth_data_type, &piPA)
            ))
        {
            DsysAssert(FALSE);
            return  KDC_ERR_PREAUTH_FAILED;
        }
        //  save the handler in the request for easier access later on
        piPA->QueryInterface(IID_IPAIdentity, (PVOID*)&pKdcReq->m_piCompId);

        //  have the PA handler process the data
        BOOLEAN fSuff;
        return  piPA->Check(pKdcReq,
                           pPAData,
                           //   no enc key
                           NULL,
                           //   no output
                           NULL,
                           &fSuff,
                           pExtErr);

    }

    //  no PA Identity data is ok
    return  KDC_ERR_NONE;
}


NTSTATUS
NTAPI
KerbComputePaCompIdentityKeyForPrincipal(
    IN ULONG                      etype,
    IN IKerbRequest*              pIKdcReq,
    OUT KERB_ENCRYPTION_KEY**     ppNewKey,
    IN ULONG                      cKeys,
    IN const KERB_ENCRYPTION_KEY  *ppPAKeys
    )
{
    CTYPE ctype;
    NTSTATUS Status;
    KERB_EXT_ERROR  ExtendedError = {0,0};
    PIKerbPrincipal pIPrinc = pIKdcReq->GetIPrincClient();
    PBYTE pHmacBuffer = NULL;
    ULONG ulHmacBufferSize;
    ULONG iKey;
    ULONG ulTotalKeyLen;
    ULONG* rgcbBuffers = NULL;
    PBYTE* rgpbBuffers;
    PBYTE pConcatKeys = NULL;
    PBYTE p;
    PCHECKSUM_FUNCTION pcsChecksum = NULL;
    PCRYPTO_SYSTEM  pCSystem = NULL;
    PKERB_ENCRYPTION_KEY pKey = NULL;
    
    //
    //  figure out what chksum type to use
    //

    switch (etype)
    {
    //  hmac for DES types
    case KERB_ETYPE_DES_CBC_MD5_NT:
    case KERB_ETYPE_DES_CBC_CRC:
    case KERB_ETYPE_DES_CBC_MD4:
    case KERB_ETYPE_DES_CBC_MD5:
        ctype = (CTYPE)KERB_CHECKSUM_MD5_DES;
        break;
    default:
        //  anything else is rc4_md5
        ctype = (CTYPE)KERB_CHECKSUM_HMAC_MD5;
    }

    Status = CDLocateCSystem(etype, &pCSystem);
    if (!NT_SUCCESS(Status))
    {
        return Status;
    }

    Status = CDLocateCheckSum(
                 ctype,
                 &pcsChecksum
                 );
    if ( !NT_SUCCESS( Status ))
    {
        goto Error;
    }

    //
    //  now check if the chksum size is big enough
    //
    if (pcsChecksum->CheckSumSize < pCSystem->KeySize)
    {
        DsysAssert(FALSE);
        Status = STATUS_INVALID_PARAMETER;
        goto Error;
    }

    // alloc various buffers on the stack
    ulHmacBufferSize = pcsChecksum->CheckSumSize;
    pHmacBuffer = (PBYTE)_alloca(ulHmacBufferSize);

    rgcbBuffers = (ULONG*)_alloca(cKeys * sizeof(ULONG));
    rgpbBuffers = (PBYTE*)_alloca(cKeys * sizeof(PBYTE));
    ulTotalKeyLen = 0;
    for (iKey = 0; iKey < cKeys; iKey++)
    {
        rgcbBuffers[iKey] = ppPAKeys[iKey].keyvalue.length;
        ulTotalKeyLen += ppPAKeys[iKey].keyvalue.length;
    }

    pConcatKeys = (PBYTE)_alloca(ulTotalKeyLen);
    p = pConcatKeys;
    for (iKey = 0; iKey < cKeys; iKey++)
    {
        memcpy(p, ppPAKeys[iKey].keyvalue.value, rgcbBuffers[iKey]);
        rgpbBuffers[iKey] = p;
        p += rgcbBuffers[iKey];
    }

    Status = pIPrinc->Checksum( ctype,
                              KERB_PA_COMPOUND_IDENTITY_REPLY_SALT,
                              pIKdcReq->GetEncryptionTypes(),
                              rgpbBuffers,
                              rgcbBuffers,
                              cKeys,
                              NULL, 
                              NULL,
                              pHmacBuffer,
                              &ulHmacBufferSize,
                              NULL,
                              &ExtendedError);
    if ( !NT_SUCCESS( Status ))
    {
        goto Error;
    }

    //
    //  now check again if the chksum size is big enough
    //
    if (ulHmacBufferSize < pCSystem->KeySize)
    {
        DsysAssert(FALSE);
        Status = STATUS_INVALID_PARAMETER;
        goto Error;
    }

    pKey = ( PKERB_ENCRYPTION_KEY )MIDL_user_allocate( sizeof( KERB_ENCRYPTION_KEY ));
    if ( NULL == pKey ) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    ZeroMemory( pKey, sizeof( KERB_ENCRYPTION_KEY ));
    pKey->keyvalue.value = ( PUCHAR )MIDL_user_allocate( pCSystem->KeySize );
    if ( pKey->keyvalue.value == NULL ) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }
    pKey->keyvalue.length = pCSystem->KeySize;
    pKey->keytype = etype;


    memcpy(pKey->keyvalue.value,
           pHmacBuffer,
           pKey->keyvalue.length);

    *ppNewKey = pKey;
    pKey = NULL;

Error:
    if (pKey != NULL)
    {
        if (pKey->keyvalue.value != NULL)
        {
            MIDL_user_free(pKey->keyvalue.value);
        }        
        MIDL_user_free(pKey);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\server\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_kdccore_none_12.4.56.0_none_c1f80ced840241ed
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_kdccore_no-public-key_12.4.56.0_x-ww_e78a463f
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=kdccore
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_kdccore_no-public-key_12.4.56.0_x-ww_e78a463f
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_kdccore_no-public-key_12.4.56.0_x-ww_e78a463f.manifest
XP_MANIFEST_PATH=manifests\x86_kdccore_no-public-key_12.4.56.0_x-ww_e78a463f.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_kdccore_no-public-key_12.4.56.0_x-ww_e78a463f.cat
XP_CATALOG_PATH=manifests\x86_kdccore_no-public-key_12.4.56.0_x-ww_e78a463f.cat
XP_PAYLOAD_PATH=x86_kdccore_no-public-key_12.4.56.0_x-ww_e78a463f
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=kdccore,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\simple\kdbsample.cxx ===
#define DEFINE_GUIDS
//  from SDK
#include <windows.h>
#include <winsock2.h>
#include <stdarg.h>
#include <stdio.h>
//#include <kerbcon.h>

//  shared headers
#include <krb5.h>
#include <krb5p.h>
#include <kerberr.h>
#include <kerbcred.h>
#include "kerbinterface.h"
#include "kerbhelper.h" // define GUIDs for IKerbCrypt/ILog

#include <kdccore.hxx>

#include <pacext.h>
#include <pacpat.hxx>   //for NETLOGON_SID_AND_ATTRIBUTES


#include "pw2keys.h"    //KdcBuildPasswordList

#include "kdbsample.hxx"

#define DsysAssert(cond)    XOMASSERT(cond)

//
//    Global literals
//
#define REALM_NAME TEXT("PASSPORT.NET")

#define PASSPORT_DA     42              // I made this up
#define PASSPORT_RID    1001            // Keep out of well-known range
#define PASSPORT_GROUP  1002            // Use for primary group ID


//
//    Global vars to the provider
//
CSampleProvider    *g_pIKdbProvider    = NULL;
IKerbCrypt      *g_pIKerbCrypt         = NULL;

LARGE_INTEGER g_OneHour, g_SevenDays, g_TenHours;

//
//  this is defined in ntseapi,
//
#ifndef  SECURITY_PASSPORT_AUTHORITY
#define SECURITY_PASSPORT_AUTHORITY         {0,0,0,0,0,10}
#endif

SID_IDENTIFIER_AUTHORITY g_PassportIA = SECURITY_PASSPORT_AUTHORITY;
PSID             g_DomainAuthoritySid;

UNICODE_STRING   g_ustrEmpty = {0};

//
// A very simple in memory database of principals
//
#define MAX_PRINCIPALS     10

KDB g_rgPrincipals[MAX_PRINCIPALS];
LONG g_cPrincipals = 0;

//
//    Interface for the provider info on the principal object
//
// {CF6EFF09-EA5A-4672-BBEA-96E0EF479AD2}
const GUID IID_IKdbProviderInfo =
{ 0xcf6eff09, 0xea5a, 0x4672, { 0xbb, 0xea, 0x96, 0xe0, 0xef, 0x47, 0x9a, 0xd2 } };

//
//  TBD: Memory allocators by the provider.
//
//  If the provider does not supply a memory allocator, then it should use
//  KdcAlloc/FreeMem (?).
//

//  global interface to the core
IKdcCore    *g_piKdcCore;

//
//    Exported entry point into provider dll.  When the dll is loaded or unloaded by the service,
//    this function is called.
//
//    Purpose:
//        instantiates the provider
//
extern "C" NTSTATUS
KdcExtMain (
    IN DWORD dwReason,
    IN IKdcCore *piKdcCoreInterface
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    CSampleProvider *pcSampleProvider = NULL;

    if ( dwReason == DLL_PROCESS_ATTACH )
    {
        g_piKdcCore = piKdcCoreInterface;
        //  the core must provide an interface
        if (!g_piKdcCore)
        {
            return  STATUS_INVALID_PARAMETER_2;
        }

        //
        //    Initialize global objects that the provider is serving up
        //
        pcSampleProvider = new CSampleProvider;
        if (NULL == pcSampleProvider)
           {
            Status = STATUS_NO_MEMORY;
               goto Error;
           }

        //
        //    Bringing up the provider
        //
        Status = pcSampleProvider->Initialize();
        if (!NT_SUCCESS(Status))
            goto Error;

        //
        //    Let the core know about this provider
        //
        g_pIKdbProvider = pcSampleProvider;

        Status = g_piKdcCore->pfnKdcRegisterProvider(g_pIKdbProvider);
        if (!NT_SUCCESS(Status))
            goto Error;

        //
        //    ownership belongs to g_pIKdbProvider
        //
        pcSampleProvider = NULL;

    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        if (g_pIKdbProvider)
        {
            g_pIKdbProvider->Unload();

            delete g_pIKdbProvider;

            g_pIKdbProvider = NULL;
        }
    }

Done:
    return Status;

Error:
    delete pcSampleProvider;

    g_pIKdbProvider = NULL;

    goto Done;
}

//------------------------------------------------------------------------------------
//                        IKdbProvider
//------------------------------------------------------------------------------------
CSampleProvider::CSampleProvider()
{
    m_rgrealmflags[0] = 0;
    ZeroMemory(&m_rgustrNames[0], sizeof(UNICODE_STRING));
}

CSampleProvider::~CSampleProvider()
{
}


NTSTATUS __stdcall CSampleProvider::GetRealms(
    OUT ULONG            *pcrealms,
    OUT LPCWSTR const   **prgpwszRealms
)
{
    //
    //    only support a single realm
    //
    *pcrealms       = 1;
    *prgpwszRealms = m_rgpwszNames;
    return STATUS_SUCCESS;
}

//
//    Returns STATUS_INVALID_SERVER_STATE if the provider is not initialized
//    with an IKerbCrypt
//
NTSTATUS __stdcall CSampleProvider::GetIKerbCrypt(
    OUT    IKerbCrypt** ppIKerbCrypt)
{
    *ppIKerbCrypt = g_pIKerbCrypt;
    return (*ppIKerbCrypt) ? STATUS_SUCCESS : STATUS_INVALID_SERVER_STATE;
}


//
//    Returns a IKerbPrincipal object based on ulFlags and principal name in
//    IRequest *
//
KERBERR __stdcall CSampleProvider::GetPrincipal(
        IN  GET_PRINC_FLAGS      getprincflags,
        IN  PKERB_INTERNAL_NAME  pkinName,
        IN  LPCWSTR              pcwszRealm,
        IN  IKerbRequest        *pIKerbRequest,
        OUT PIKerbPrincipal     *ppIPrincipal,
        OUT PKERB_EXT_ERROR pExtendedError,
        OUT OPTIONAL PUNICODE_STRING *ppustrReferredRealm
)
{
    UNREFERENCED_PARAMETER (pcwszRealm);
    UNREFERENCED_PARAMETER (pIKerbRequest);

    KERBERR                 KerbErr = KDC_ERR_NONE;
    INT                     Index;
    NTSTATUS            Status;

    //DsysAssert(pNTStatus);

    Status = STATUS_NOT_FOUND;
    *ppIPrincipal = NULL;

    //
    //  Dont do referrals
    //
    if (ppustrReferredRealm)
        *ppustrReferredRealm = NULL;

    for (Index = 0; Index < g_cPrincipals; Index++)
    {
        if (g_piKdcCore->pfnKerbEqualKdcNames(g_rgPrincipals[Index].pkinName, pkinName)) {

            Status = GetPrinc(
                         &g_rgPrincipals[Index],
                         ppIPrincipal
                         );

            if (!NT_SUCCESS(Status))
            {
                KerbErr = KRB_ERR_GENERIC;
                goto Cleanup;
            }

            Status = STATUS_SUCCESS;
            break;
        }
    }

    if (Status != STATUS_SUCCESS)
    {
        goto Cleanup;
    }

Cleanup:
    pExtendedError->status = Status;
    //pExtendedError->klininfo =
    //pExtendedError->flags =

    if (Status == STATUS_NOT_FOUND)
    {
        if (getprincflags & KDC_KDB_GET_PRINC_CLIENT)
            KerbErr = KDC_ERR_C_PRINCIPAL_UNKNOWN;
        else if (getprincflags & KDC_KDB_GET_PRINC_SERVER)
            KerbErr = KDC_ERR_S_PRINCIPAL_UNKNOWN;
        else
            KerbErr = KRB_ERR_GENERIC;
    }
    return KerbErr;
}

//
//    Non IProvider methods for CSampleProvider
//

//
//    Initialize the global array g_cPrincipals
//
NTSTATUS CSampleProvider::InitPrincipal(
    LPTSTR pwszName,
    LPTSTR pwszInst,
    LPTSTR pwszPassword,
    SHORT sNameType,
    PRINC_FLAGS PrincFlags
)
{
    NTSTATUS            Status     = STATUS_SUCCESS;
    PKDB                pkdbNew    = NULL;
    UNICODE_STRING      ustrName;
    UNICODE_STRING      ustrInstance;
    UNICODE_STRING      ustrPassword;
    UNICODE_STRING      ustrSalt = {0};

    RtlInitUnicodeString(&ustrName, pwszName);
    RtlInitUnicodeString(&ustrInstance, pwszInst);
    RtlInitUnicodeString(&ustrPassword, pwszPassword);

    //
    //  Assuming no re-entrancy
    //
    pkdbNew = &g_rgPrincipals[g_cPrincipals];

    //
    // Initialize Principal name
    //
    if (ARGUMENT_PRESENT(pwszInst))
    {
        if (lstrcmp(pwszInst, TEXT("ThisRealm")) == 0)
        {
            g_piKdcCore->pfnKerbBuildFullServiceKdcName(
                &m_rgustrNames[0],
                &ustrName,
                KRB_NT_SRV_INST,
                &pkdbNew->pkinName
                );
        }
        else
        {
            g_piKdcCore->pfnKerbBuildFullServiceKdcName(
                &ustrInstance,
                &ustrName,
                KRB_NT_SRV_INST,
                &pkdbNew->pkinName
                );
        }
    }
    else
    {
        g_piKdcCore->pfnKerbConvertStringToKdcName(
            &pkdbNew->pkinName,
            &ustrName);
    }
    pkdbNew->pkinName->NameType = sNameType;
    pkdbNew->ServFlags          = PrincFlags;

    //
    // Allocate a PUID
    //

    pkdbNew->Puid.LowPart = g_cPrincipals + 1;
    pkdbNew->Puid.HighPart = 0;

    //
    // Build key salt - needs to return the SaltType
    // Key salt is wrong for the krbtgt, but that is ok for now
    //

    Status = g_piKdcCore->pfnKerbBuildKeySalt(
                &m_rgustrNames[0],
                &ustrName,
                UserAccount,
                &ustrSalt
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = KdcBuildPasswordList(
                         &ustrPassword,
                         &ustrSalt,
                         KerbKdbSaltTypeDefault,// SaltType
                         1,                     // kvno
                         NULL,                  // Old keys
                         0,                     // sz Old keys
                         TRUE,                  // Include builtin types
                         &pkdbNew->pKeys,
                         &pkdbNew->ulKeySize
                         );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Frequently changing fields
    //

    pkdbNew->LastLogon.QuadPart = KERB_KDB_TIME_NEVER;
    pkdbNew->LastFailedLogon.QuadPart = KERB_KDB_TIME_NEVER;

    g_cPrincipals++;

Cleanup:
    if (ustrSalt.Buffer)
    {
        //
        //    use KdcFreeMemory instead of delete since KerbBuildSalt uses MIDL_user_allocate
        //
        g_piKdcCore->pfnKdcFreeMemory(ustrSalt.Buffer);
    }
    return Status;
}


//
//    Create (hardwired) principals
//
void CSampleProvider::InitRealm(
    void
)
{
    //
    // Default ticket lifetimes
    //
    g_OneHour.QuadPart     = (LONGLONG) 10000000 * 60 * 60 * 1;
    g_SevenDays.QuadPart     = (LONGLONG) 10000000 * 60 * 60 * 24 * 7;
    g_TenHours.QuadPart     = (LONGLONG) 10000000 * 60 * 60 * 10;

    RtlInitUnicodeString(&g_ustrEmpty, TEXT(""));

    RtlAllocateAndInitializeSid(
        &g_PassportIA,
        2,           // count of authorities; leave a Rid of 0
        PASSPORT_DA, // Passport DA
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        &g_DomainAuthoritySid
        );

    InitPrincipal(
        TEXT("krbtgt"),
        TEXT("ThisRealm"),
        TEXT("trustme"),
        KRB_NT_SRV_INST,
        KERB_KDB_DISALLOW_ALL_TIX
        );
    InitPrincipal(
        TEXT("user"),
        NULL,
        TEXT("fred"),
        KRB_NT_PRINCIPAL,
        KERB_KDB_REQUIRE_USER2USER
        );
    InitPrincipal(
        TEXT("admin"),
        NULL,
        TEXT("wilma"),
        KRB_NT_PRINCIPAL,
        KERB_KDB_DISALLOW_FORWARDABLE|KERB_KDB_REQUIRES_PRE_AUTH
        );
    InitPrincipal(
        TEXT("stevepen@microsoft.com"),
        NULL,
        TEXT("123456"),
        KRB_NT_PRINCIPAL,
        KERB_KDB_REQUIRE_USER2USER|KERB_KDB_REQUIRES_PRE_AUTH
        );
    InitPrincipal(
        TEXT("service"),
        NULL,
        TEXT("barney"),
        KRB_NT_PRINCIPAL,
        0
        );
    InitPrincipal(
        TEXT("host"),
        TEXT("jbrezak1.dns.microsoft.com"),
        TEXT("host"),
        KRB_NT_PRINCIPAL,
        0
        );
    InitPrincipal(
        TEXT("host"),
        TEXT("gamezone.com"),
        TEXT("thezone"),
        KRB_NT_PRINCIPAL,
        0
        );
    InitPrincipal(
        TEXT("krbtgt"),
        TEXT("MIT.NTDEV.MICROSOFT.COM"),
        TEXT("TrustMe!"),
        KRB_NT_SRV_INST,
        0
        );
}


NTSTATUS __stdcall CSampleProvider::Initialize(
    void
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    //  TBD: use the KdcAlloc/FreeMem and MIDL_user* for now
    //
    //KdcSetKerbMem(kerbAlloc, kerbFree);

    //
    //    This provider does not implement its IKerbCrypt, and would use the
    //    core's version.
    //
    g_pIKerbCrypt = g_piKdcCore->pfnKdcGetICrypt();
    if (!g_pIKerbCrypt)
    {
        Status = STATUS_SERVER_DISABLED;
        goto Cleanup;
    }

    //
    //    TBD: get ILog
    //

    //
    //    Only support 1 realm
    //    note that the pointer in m_rgustrNames[] points at REALM_NAME
    //
    RtlInitUnicodeString(&m_rgustrNames[0], REALM_NAME);
    m_rgpwszNames[0]     = REALM_NAME;
    m_rgrealmflags[0]     = KERB_KDB_REALM_DOES_PAC | KERB_KDB_REALM_REFERRAL;

    //
    //    Create global principals
    //
    InitRealm();

Done:
    return Status;

Cleanup:
    goto Done;
}

NTSTATUS __stdcall CSampleProvider::GetPrinc(
    IN     PKDB             pKdb,
    OUT PIKerbPrincipal *ppIPrincipal
)
{
    NTSTATUS         Status             = STATUS_SUCCESS;
    CPrincipal        *pcPrincipal     = NULL;

    pcPrincipal = new CPrincipal;
    if (!pcPrincipal)
    {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    Status = pcPrincipal->Initialize(
                this,
                &m_rgustrNames[0],    //realm name
                pKdb,
                g_TenHours,         //maxlifetime
                g_SevenDays,        //maxrenewtime
                KERB_KDB_TIME_NEVER,//lastmodified
                KERB_KDB_TIME_NEVER,//expiration
                KERB_KDB_DATA_ALL); //PRINC_DATA_FLAGS
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    *ppIPrincipal = static_cast<IKerbPrincipal*>(pcPrincipal);
    pcPrincipal = NULL;

Cleanup:
    delete pcPrincipal;

    return Status;
}

//------------------------------------------------------------------------------------
//                                IKerbPrincipal
//------------------------------------------------------------------------------------
CPrincipal::CPrincipal()
    : m_PrincDataFlags(0),
      m_pkinName(NULL),
      m_pustrRealm(NULL),
      m_PrincFlags(0),
      m_PrincipalType(UnknownAccount),
      m_pcLogonInfo(NULL),
      m_pKeys(NULL),
      m_pOldKeys(NULL),
      m_pIKdbProvider(NULL),
      m_petypes(NULL),
      m_cEtypes(0)
{
    m_MaxLifeTime.QuadPart = 0;
    m_MaxRenewTime.QuadPart = 0;
    m_LastModified.QuadPart = 0;
    m_Expiration.QuadPart = 0;
    m_LastLogon.QuadPart = 0;
    m_LastFailedLogon.QuadPart = 0;
    m_LastFailedLogon.QuadPart = 0;
    ZeroMemory(&m_saLastLogonClient, sizeof(SOCKADDR));
}

CPrincipal::~CPrincipal()
{
    delete m_pcLogonInfo;
    g_piKdcCore->pfnKdcFreeMemory(m_pkinName);

    //
    //    keys are global, so no free ....
    //
//    KdcFreeMemory(m_pKeys);

    delete m_petypes;
}


void
__stdcall
CPrincipal::Release(void)
{
    delete static_cast<CPrincipal*>(this);
}


//
//    The core will use QueryInterface with guids like IID_IKDBLogonInfo
//    to get at the data.
//
HRESULT
__stdcall
CPrincipal::QueryInterface(
    IN    REFIID    refiid,
    OUT    PVOID    *ppv
)
{
    HRESULT    hr = E_NOINTERFACE;

    *ppv = NULL;
    if ( IsEqualGUID(refiid, IID_IKDBLogonInfo ))
    {
        if ( m_pcLogonInfo )
        {
            *ppv = (PVOID)( static_cast<IKDBLogonInfo*>(this) );
            hr = S_OK;
        }
        else
        {
            hr = E_FAIL;
        }
    }
    return hr;
}

IKdbProvider *
__stdcall
CPrincipal::GetIKdbProvider(void)
{
    return m_pIKdbProvider;
}

KERBERR
__stdcall
CPrincipal::GetCiphertextSize(
            IN  PKERB_CRYPT_LIST     pEtypes,
            IN  ULONG                cbIn,
            OUT PULONG               pcbOut)
{
    XOMASSERT(g_pIKerbCrypt);
    KERBERR         KerbErr;
    NTSTATUS        Status;
    PKERB_KEY_DATA  pKeydata = NULL;

    Status = FindCommonEtype(
                pEtypes,
                &pKeydata
                );

    if (!NT_SUCCESS(Status))
    {
        KerbErr = KDC_ERR_ETYPE_NOTSUPP;
        goto Cleanup;
    }

    KerbErr = g_pIKerbCrypt->GetCiphertextSize(
                    pKeydata->Key.keytype,
                    cbIn,
                    pcbOut);
Cleanup:
    return KerbErr;
}


KERBERR
__stdcall
CPrincipal::Encrypt(
                IN PKERB_CRYPT_LIST pEtypes,//types preferred
                IN  SALTFLAGS   saltflags,  //salt flags
                IN  PBYTE       pbIn,       //buffer to encrypt
                IN  ULONG       cbIn,       //size of buffer to encrypt
                OUT PKERB_ENCRYPTED_DATA      pData,   //encrypted data
                OUT PKERB_EXT_ERROR pExtendedError
)
{
    XOMASSERT(g_pIKerbCrypt);
    KERBERR         KerbErr;
    PKERB_KEY_DATA  pKeydata = NULL;
    NTSTATUS        Status;

    Status = FindCommonEtype(
                pEtypes,
                &pKeydata
                );

    if (!NT_SUCCESS(Status))
    {
        KerbErr = KDC_ERR_ETYPE_NOTSUPP;
        pExtendedError->flags = __LINE__;
        goto Cleanup;
    }

    KerbErr = g_pIKerbCrypt->Encrypt(
                        &pKeydata->Key,
                        pKeydata->KeyVersion,
                        saltflags,
                        pbIn, cbIn,
                        pData);
    if (!KERB_SUCCESS(KerbErr))
    {
        //
        //    TBD: log the problem.
        //

        pExtendedError->flags = __LINE__;
        goto Cleanup;
    }


Cleanup:
    //pExtendedError->klininfo = file number;
    pExtendedError->status = Status;
    return KerbErr;

}

KERBERR
__stdcall
CPrincipal::Decrypt(
    IN  const KERB_CRYPT_LIST * pEtypes,
    IN  SALTFLAGS saltflags,
    IN  const KERB_ENCRYPTED_DATA * pData,
    OUT PBYTE pbOut,
    OUT PULONG pcbOut,
    OUT OPTIONAL PETYPE pEtype,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    XOMASSERT(g_pIKerbCrypt);
    KERBERR          KerbErr;
    PKERB_KEY_DATA   pKeydata = NULL;
    NTSTATUS         Status;

    Status = FindCommonEtype(
                 pEtypes,
                 &pKeydata
                 );

    if (!NT_SUCCESS(Status))
    {
        KerbErr = KDC_ERR_ETYPE_NOTSUPP;
        pExtendedError->flags = __LINE__;
        goto Cleanup;
    }

    KerbErr = g_pIKerbCrypt->Decrypt(
                  pData,
                  &pKeydata->Key,
                  saltflags,
                  pbOut, pcbOut
                  );

    if (!KERB_SUCCESS(KerbErr))
    {
        //
        //    TBD: log the problem.
        //

        pExtendedError->flags = __LINE__;
        goto Cleanup;
    }

    //
    //    return the common Etype
    //
    if (pEtype)
        *pEtype = (ETYPE)(pKeydata->Key.keytype);

Cleanup:
    //pExtendedError->klininfo = file number;
    pExtendedError->status = Status;
    return KerbErr;

}


NTSTATUS
__stdcall
CPrincipal::GetChecksumSize(
            IN  CTYPE                Ctype,
            OUT PULONG               pcbOut)
{
    XOMASSERT(g_pIKerbCrypt);

    return g_pIKerbCrypt->GetChecksumSize(Ctype, pcbOut);
}



NTSTATUS
__stdcall
CPrincipal::Checksum(
            IN  CTYPE                Ctype,
            IN  SALTFLAGS            saltflags,
            IN  PKERB_CRYPT_LIST     pEtypes,
            IN  PBYTE               *rgpbBuffers,
            IN  ULONG               *rgcbBuffers,
            IN  ULONG                cBuffers,
            IN  PBYTE                pbVerify,     // OPTIONAL
            IN  ULONG                cbVerify,     // OPTIONAL
            OUT PBYTE                pbChecksum,   // OPTIONAL
            OUT PULONG               pcbChecksum,  // OPTIONAL
            OUT PBOOLEAN             pfVerified,   // OPTIONAL
            OUT PKERB_EXT_ERROR pExtendedError
)
{
    XOMASSERT(g_pIKerbCrypt);

    PKERB_KEY_DATA   pKeydata = NULL;
    NTSTATUS         Status;

    Status = FindCommonEtype(
                pEtypes,
                &pKeydata
                );

    //
    //  TBD: Deal with keyless or should we return error ?
    //
    if (!NT_SUCCESS(Status))
    {
        pExtendedError->flags = __LINE__;
        goto Cleanup;
    }

    Status = g_pIKerbCrypt->Checksum(
                    Ctype,
                    saltflags,
                    pKeydata ? &pKeydata->Key : NULL,
                    rgpbBuffers, rgcbBuffers,
                    cBuffers,
                    pbVerify, cbVerify,
                    pbChecksum, pcbChecksum,
                    pfVerified );

Cleanup:
    //pExtendedError->klininfo = //line number
    pExtendedError->status = Status;
    return Status;
}

//
//    Return the list of etypes.
//
NTSTATUS
__stdcall
CPrincipal::GetEtypes(
            OUT  const ETYPE **ppEtypes,
            OUT PULONG         pcEtypes
)
{
    *pcEtypes = m_cEtypes;
    *ppEtypes = m_petypes;

    return ( 0 == *pcEtypes ) ? STATUS_NO_USER_KEYS : STATUS_SUCCESS;
}


//
//    Given a list of etypes, return the list of common etypes.
//    Ported from preauth.cxx KdcBuildEtypeInfo
//
KERBERR
__stdcall
CPrincipal::GetEtypeMatch(
    IN  PKERB_CRYPT_LIST  pEtypes,
    OUT PKERB_ETYPE_INFO *ppEtypeInfo
)
{
    KERBERR               KerbErr = KDC_ERR_NONE;
    ULONG                 Index;
    PKERB_ETYPE_INFO      petypeinfoNextEntry = NULL;
    PKERB_ETYPE_INFO      petypeinfo          = NULL;
    UNICODE_STRING        ustrTempSalt        = {0};
    STRING                strTemp             = {0};

    //
    // Build the array of etypes, in reverse order because we are adding
    // to the front of the list
    //
    if (!m_pKeys)
        goto Cleanup;

    XOMASSERT(m_cEtypes == m_pKeys->CredentialCount);

    //
    //  TBD: we should order it according to pEtypes and not m_pKeys
    //
    for ( Index = m_pKeys->CredentialCount; Index > 0; Index-- )
    {
        //
        // Only return types that the client supports.
        //
        XOMASSERT(m_petypes[Index-1] == (ETYPE)(m_pKeys->Credentials[Index-1].Key.keytype));

        if (!CheckForEtype(
                pEtypes,
                m_pKeys->Credentials[Index-1].Key.keytype
                ))
        {
            continue;
        }
        petypeinfoNextEntry = (PKERB_ETYPE_INFO)g_piKdcCore->pfnKdcAllocMemory
                            (
                    sizeof(KERB_ETYPE_INFO)
                            );
        if (petypeinfoNextEntry == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        ZeroMemory(
            petypeinfoNextEntry,
            sizeof(KERB_ETYPE_INFO)
            );

        //
        // Copy in the etype
        //

        petypeinfoNextEntry->value.encryption_type =
            m_pKeys->Credentials[Index-1].Key.keytype;

        //
        // add the salt - check the per-key salt and then the default salt.
        //

        if (m_pKeys->Credentials[Index-1].Salt.Buffer != NULL)
        {
            ustrTempSalt = m_pKeys->Credentials[Index-1].Salt;
        }
        else if (m_pKeys->DefaultSalt.Buffer != NULL)
        {
            ustrTempSalt = m_pKeys->DefaultSalt;
        }
        else
        {
            ustrTempSalt.Buffer = NULL ;
            ustrTempSalt.Length = 0 ;
            ustrTempSalt.MaximumLength = 0 ;
        }

        //
        // If we have a salt, convert it to ansi & return it.
        //

        if (ustrTempSalt.Buffer != NULL)
        {
            ustrTempSalt.Buffer = NULL;
            ustrTempSalt.Length = 0;
            ustrTempSalt.MaximumLength = 0;

            KerbErr = g_piKdcCore->pfnKerbUnicodeStringToKerbString(
                        &strTemp,
                        &ustrTempSalt
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }

            petypeinfoNextEntry->value.bit_mask |= salt_present;
            petypeinfoNextEntry->value.salt.length = strTemp.Length;
            petypeinfoNextEntry->value.salt.value = (PUCHAR) strTemp.Buffer;
        }

        petypeinfoNextEntry->next = petypeinfo;
        petypeinfo = petypeinfoNextEntry;
    }

    *ppEtypeInfo = petypeinfo;
    petypeinfo = NULL;

Cleanup:
    while (petypeinfo != NULL)
    {
        petypeinfoNextEntry = petypeinfo->next;
        if (petypeinfo->value.salt.value != NULL)
        {
            strTemp.Buffer = (PCHAR) petypeinfo->value.salt.value;
            strTemp.Length = (USHORT) petypeinfo->value.salt.length;
            g_piKdcCore->pfnKdcFreeMemory(strTemp.Buffer);
        }

        delete petypeinfo;
        petypeinfo = petypeinfoNextEntry;
    }

    return KerbErr;
}

#ifdef IMPL_PWSALT_PAHANDLER
//
//
//
KERBERR
__stdcall
CPrincipal::GetSaltForFirstCommonEtype(
    IN  OPTIONAL PKERB_CRYPT_LIST        petypelist,
    OUT UNICODE_STRING  const          * pustrSaltUsed
)
{
    KERBERR         KerbErr = KDC_ERR_NONE;
    int             i;
    ETYPE           etypeForSalt;
    PKERB_KEY_DATA  pkeydata= NULL;

    *ppustrSaltUsed = NULL;

    if ( NULL == petypelist )
        goto Cleanup;

    //
    //  find the first common encryption type
    //
    KerbErr = KerbFindCommonCryptSystem(
                petypelist,
                m_pKeys,
                NULL, //ServiceInfo.Keys,
                &etypeForSalt,
                &pkeydata
                );
    if (!KERB_SUCCESS(KerbErr))
    {
#ifdef TBD
        KdcReportKeyError(
            KdbHandle,
            ClientInfo->Princ,
            ClientInfo->Realm,
            NULL,
            NULL,
            KDCEVENT_NO_KEY_UNION_AS,
            RequestBody->encryption_type,
            ClientInfo->Keys
            );
        DebugLog((DEB_ERROR,"KLIN(%x) Failed to find common ETYPE: 0x%x\n",
                  KLIN(FILENO,__LINE__),KerbErr));

#endif
        goto Cleanup;
    }

    if (pkeydata == NULL)
    {
        goto Cleanup;
    }

    //
    // Locate the salt used
    //

    if (pkeydata->SaltType != KerbKdbSaltTypeDefault)
    {
        DsysAssert(pkeydata->Salt.Buffer != NULL);
        *pustrSaltUsed = pkeydata->Salt;
    }
    else if (m_pKeys->DefaultSalt.Buffer != NULL)
    {
        *pustrSaltUsed = m_pKeys->DefaultSalt;
    }


Cleanup:
    return KerbErr;
}
#endif

//
//    CPrincipal methods internal to the provider
//
NTSTATUS
__stdcall
CPrincipal::Initialize(
    IN    IKdbProvider      *pIKdbProvider,
    IN    PUNICODE_STRING   pustrRealm,
    IN    PKDB              pKdb,
    IN    LARGE_INTEGER     maxlifetime,
    IN    LARGE_INTEGER     maxrenewtime,
    IN    int               lastmodified,
    IN    int               expiration,
    IN    PRINC_DATA_FLAGS  princdataflags
)
{
    NTSTATUS         Status       = STATUS_SUCCESS;
    int              i;
    ETYPE            *petypes     = NULL;



    //
    //    Create the provider info and keeps that in m_pcLogonInfo
    //
    m_pcLogonInfo = new CLogonInfo;
    if (!m_pcLogonInfo)
       {
           Status = STATUS_NO_MEMORY;
           goto Cleanup;
       }

    //
    // Copy the principal name
    //
    Status = g_piKdcCore->pfnKerbDuplicateKdcName(
                &m_pkinName,
                pKdb->pkinName
                );
    if (!NT_SUCCESS(Status))
        goto Cleanup;

    //
    //    This string lives in the provider
    //
    m_pustrRealm    = pustrRealm;
    m_PrincFlags    = pKdb->ServFlags;

    m_MaxLifeTime   = maxlifetime;
    m_MaxRenewTime  = maxrenewtime;

    m_LastModified.QuadPart = lastmodified;
    m_Expiration.QuadPart   = expiration;

    m_LastLogon         = pKdb->LastLogon;
    m_LastFailedLogon   = pKdb->LastFailedLogon;
    m_saLastLogonClient = pKdb->saLastLogonClient;

    m_PrincDataFlags    = princdataflags;
    m_pOldKeys          = NULL;

    m_pIKdbProvider     = pIKdbProvider;

    //  just make the keys point to whatever was passed in
    m_pKeys = pKdb->pKeys;

    //
    //  setup the etypes present in the credential
    //
    petypes = new ETYPE[m_pKeys->CredentialCount];
    if (!petypes)
    {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    XOMASSERT(m_pKeys);
    for ( i = 0; i < m_pKeys->CredentialCount; i++ )
    {
        petypes[i] = m_pKeys->Credentials[i].Key.keytype;
    }
    m_cEtypes = m_pKeys->CredentialCount;
    m_petypes = petypes;
    petypes   = NULL;

    //
    //    Initialize the ProvInfo (replaces GetProvInfos)
    //
    Status = m_pcLogonInfo->Initialize(
        m_pkinName, m_pustrRealm, &pKdb->Puid, m_LastModified, m_LastLogon
            );
    if (!NT_SUCCESS(Status))
        goto Cleanup;

Cleanup:
    if (petypes)
        delete petypes;

    return Status;
}

NTSTATUS
__stdcall
CPrincipal::FindCommonEtype(
        IN  const KERB_CRYPT_LIST * pCryptList,
        OUT PKERB_KEY_DATA  *ppKeydata
)
{
    NTSTATUS        Status = STATUS_NOT_FOUND;
    PKERB_KEY_DATA  pKeydata = NULL;

    *ppKeydata = NULL;

    //
    //  walk the given list against the list that we have
    //
    if (!m_pKeys || m_pKeys->CredentialCount == 0)
        goto Cleanup;


    for (; pCryptList; pCryptList = pCryptList->next)
    {
        ULONG i;
        for (i = 0; i < m_pKeys->CredentialCount; i++)
        {
            pKeydata = &m_pKeys->Credentials[i];
            XOMASSERT(i < m_cEtypes);
            XOMASSERT((ETYPE)(pKeydata->Key.keytype) == m_petypes[i]);
            if ((ETYPE)(pKeydata->Key.keytype) == (ETYPE)(pCryptList->value))
            {
                *ppKeydata = pKeydata;
                Status = STATUS_SUCCESS;
                goto Cleanup;
            }
        }
    }

Cleanup:

    return Status;
}

BOOLEAN
__stdcall
CPrincipal::CheckForEtype(
    IN const KERB_CRYPT_LIST * pCryptList,
    IN ULONG            Etype
    )
{
    const KERB_CRYPT_LIST * pList = pCryptList;

    while (pList != NULL)
    {
        if ((ULONG) pList->value == Etype)
        {
            return TRUE;
        }
        pList=pList->next;
    }

    return FALSE;
}


//
//    IKDBLogonInfo
//
NTSTATUS
__stdcall
CPrincipal::GetWindowsLogonInfo(
    IN const KERB_PAC_USER_ALL_INFORMATION**ppKerbPacUserAllInfo
    )
{
    NTSTATUS    Status;

    if (NULL == ppKerbPacUserAllInfo)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    *ppKerbPacUserAllInfo = NULL;

    if (m_pcLogonInfo)
        *ppKerbPacUserAllInfo = m_pcLogonInfo->GetLogonInfo();

    Status = (*ppKerbPacUserAllInfo) ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;

Cleanup:

    return Status;
}

//
//    TBD: no PUID info
//
NTSTATUS
__stdcall
CPrincipal::GetIdentityInfo(
    IN const IDENTITY **ppId
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;
    LARGE_INTEGER   SamplePuid = {11,42};
    static IDENTITY SampleInfo = {FIELD_OFFSET(IDENTITY, Identity) +
                                    sizeof(LARGE_INTEGER),
                                  0,
                                  ID_PUID,
                                  CT_Password};
    *(LARGE_INTEGER*)SampleInfo.Identity = SamplePuid;

    if (NULL == ppId)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }
    *ppId = &SampleInfo;

Cleanup:
    return Status;
}


//
//    Moved from kdb.cxx.
//
CLogonInfo::CLogonInfo()
    : m_pLogonInfo(NULL)
{
}

CLogonInfo::~CLogonInfo()
{
    if ( m_pLogonInfo->FullName.Buffer )
    {
        g_piKdcCore->pfnKdcFreeMemory(m_pLogonInfo->FullName.Buffer);
        m_pLogonInfo->FullName.Buffer = NULL;
    }
    delete m_pLogonInfo;     // Single allocation
}

NTSTATUS
__stdcall
CLogonInfo::Initialize(
        IN    PKERB_INTERNAL_NAME    pkinPrincName,
        IN    PUNICODE_STRING        pustrRealmName,
        IN    LARGE_INTEGER        *pPuid,
        IN    LARGE_INTEGER        &rLastModified,
        IN    LARGE_INTEGER        &rLastLogon
)
{
    NTSTATUS        Status            = STATUS_SUCCESS;
    PSID_AND_ATTRIBUTES    pGroups        = NULL;


    //
    // alloc windows logon info
    //

    m_pLogonInfo = (PKERB_PAC_USER_ALL_INFORMATION)
            new BYTE [
                sizeof(KERB_PAC_USER_ALL_INFORMATION) +
                (2 * sizeof(SID_AND_ATTRIBUTES)) +
                RtlLengthRequiredSid(4)
                    ];
    if (!m_pLogonInfo)
    {
        return STATUS_NO_MEMORY;
    }


    m_pLogonInfo->PasswordLastSet =  rLastModified;
    m_pLogonInfo->LastLogon = rLastLogon;

    m_pLogonInfo->ProfilePath = g_ustrEmpty;
    m_pLogonInfo->ScriptPath = g_ustrEmpty;
    m_pLogonInfo->HomeDirectory = g_ustrEmpty;
    m_pLogonInfo->HomeDirectoryDrive = g_ustrEmpty;
    m_pLogonInfo->UserName = g_ustrEmpty;

    //
    // Fill in relative Domain SIDs
    //

    m_pLogonInfo->RealmSid = g_DomainAuthoritySid;

    // UserId is always 0 for Passport; look in
    // first group for SID
    m_pLogonInfo->UserId = 0;

    // This gets turned into a group
    // using RealmSid+PrimaryGroupId
    m_pLogonInfo->PrimaryGroupId = PASSPORT_GROUP;

    //
    // Fill in the full name
    //

    g_piKdcCore->pfnKerbConvertKdcNameToString(
        (PUNICODE_STRING)&m_pLogonInfo->FullName,
        pkinPrincName,
        pustrRealmName
        );

    //
    // The first SID is the User SID (since UserId=0). Any other SIDs are
    // groups. You get a free groups from the RealmSid+PrimaryGroupId also.
    //

    pGroups = (PSID_AND_ATTRIBUTES)(m_pLogonInfo + 1);

    m_pLogonInfo->GroupCount = 2;
    m_pLogonInfo->Groups = pGroups;

    pGroups[0].Sid = (PSID)(&pGroups[2].Sid);
    MakePassportSid(pGroups[0].Sid, pPuid);
    pGroups[0].Attributes = SidTypeUser;

    pGroups[1].Sid = g_DomainAuthoritySid;
    pGroups[1].Attributes = SidTypeGroup;


    return (Status);
}

//
// Generate a Passport SID from a PUID. Sid allocation is passed in.
//
// Uses the form: S-1-10-x-y-z-r
//      x = Passport DA (42 for this example)
//      y = HIDWORD(Puid)
//      z = LODWORD(Puid)
//      r = well known Rid (1000)
//
VOID
__stdcall
CLogonInfo::MakePassportSid(
    IN OUT  PSID pSid,
    IN      PLARGE_INTEGER pPuid
    )
{
    RtlInitializeSid(pSid, &g_PassportIA, 4);
    *(RtlSubAuthoritySid(pSid, 0)) = PASSPORT_DA;
    *(RtlSubAuthoritySid(pSid, 1)) = pPuid->HighPart;
    *(RtlSubAuthoritySid(pSid, 2)) = pPuid->LowPart;
    *(RtlSubAuthoritySid(pSid, 3)) = PASSPORT_RID;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\simple\pw2keys.h ===
#ifndef _PW2KEYS_H
#define _PW2KEYS_H

NTSTATUS
KdcBuildPasswordList(
    IN PUNICODE_STRING Password,
    IN PUNICODE_STRING KeySalt,
    IN KERB_KDB_SALTTYPE SaltType,
    IN ULONG KeyVersion,
    IN PKERB_STORED_CREDENTIAL StoredCreds,
    IN ULONG StoredCredSize,
    IN BOOLEAN IncludeBuiltinTypes,
    OUT PKERB_STORED_CREDENTIAL * PasswordList,
    OUT PULONG PasswordListSize
    );

KERBERR
KdcDuplicateCredentials(
    OUT PKERB_STORED_CREDENTIAL * NewCredentials,
    OUT PULONG ReturnCredentialSize,
    IN PKERB_STORED_CREDENTIAL OldCredentials,
    IN BOOLEAN MarshallKeys
    );

BOOLEAN
KdcCheckForEtype(
    IN PKERB_CRYPT_LIST CryptList,
    IN ULONG Etype
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\simple\pw2keys.cxx ===
//+-------------------------------------------------------------------------
//
//  Function:   KdcBuildPasswordList
//
//  Synopsis:   Builds a list of keys from a user's password
//              their password.
//
//  Effects:    allocates memory
//
//  Arguments:  Password - clear or OWF password
//              PrincipalName - Name of principal
//              IncludeBuiltinTypes - if TRUE, include MD4 & LM hashes
//              PasswordList - Receives new password list
//              PasswordListSize - Size of list in bytes.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

//  from sdk
#include "windows.h"
#include "winsock2.h"

//  headers shared with provider
#include <krb5.h>
#include <krb5p.h>
#include <kerberr.h>
#include <kerbcred.h>

#include "kerbinterface.h"
#include "kdccore.hxx"
#define KERB_MAX_CRYPTO_SYSTEMS 20

extern  IKdcCore    *g_piKdcCore;

//
//  provider globals
//
extern IKerbCrypt *g_pIKerbCrypt;

NTSTATUS
KdcBuildPasswordList(
    IN PUNICODE_STRING              pustrPassword,
    IN PUNICODE_STRING              pustrKeySalt,
    IN KERB_KDB_SALTTYPE            SaltType,
    IN ULONG                        ulKeyVersion,
    IN PKERB_STORED_CREDENTIAL      pStoredCreds,
    IN ULONG                        cbStoredCred,
    IN BOOLEAN                      fIncludeBuiltinTypes,
    OUT PKERB_STORED_CREDENTIAL *   ppPasswordList,
    OUT PULONG                      pcbPasswordList
    )
{
    cbStoredCred;

    NTSTATUS        Status      = STATUS_SUCCESS;
    ETYPE           *pEtypes    = NULL;
    ULONG           cEtypes      = 0;
    ULONG           Index, CredentialIndex = 0;
    ULONG           cbCredential= 0;
    ULONG           cKerbEncryptionKeys = 0;
    ULONG           cKerbKeyData= 0;
    ULONG           cOldCreds   = 0;
    PKERB_STORED_CREDENTIAL pCredentials = NULL;
    PUCHAR          pbKeyBase;
    ULONG           ulOffset;
    PKERB_ENCRYPTION_KEY pTempKey  = NULL;
    UNICODE_STRING      ustrEmptySalt = {0};
    ULONG           cbKey;

    //
    //  Provider side code
    //
    XOMASSERT(g_pIKerbCrypt);

    *ppPasswordList     = NULL;
    *pcbPasswordList    = 0;

    //  replace with different tracing utility
//    D_DebugLog((DEB_TRACE,"Building key list with salt %wZ\n",&pustrKeySalt));

    //
    // For a cleartext password, build a list of encryption types and
    // create a key for each one
    //
    Status = g_pIKerbCrypt->GetEtypes(
                                (ETYPE const**)(&pEtypes),
                                &cEtypes);

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    //  providers do not share core asserts
    XOMASSERT(cEtypes <= KERB_MAX_CRYPTO_SYSTEMS);

    //
    // Now find the size of the key for each crypto system
    //

    for (Index = 0; Index < cEtypes; Index++ )
    {
        //
        // Skip etypes stored as normal passwords
        //

        if (!fIncludeBuiltinTypes &&
            ((pEtypes[Index] == KERB_ETYPE_RC4_LM) ||
             (pEtypes[Index] == KERB_ETYPE_RC4_MD4) ||
             (pEtypes[Index] == KERB_ETYPE_RC4_HMAC_OLD) ||
             (pEtypes[Index] == KERB_ETYPE_RC4_HMAC_OLD_EXP) ||
             (pEtypes[Index] == KERB_ETYPE_RC4_HMAC_NT) ||
             (pEtypes[Index] == KERB_ETYPE_RC4_HMAC_NT_EXP) ||
             (pEtypes[Index] == KERB_ETYPE_NULL)))
        {
            continue;
        }

        Status = g_pIKerbCrypt->GetKeySize(
                            pEtypes[Index],
                            &cbKey
                            );

        if (!NT_SUCCESS(Status))
        {
//            D_DebugLog((DEB_ERROR, "CDLocateCSystem failed for etype: %d\n", pEtypes[Index]));
            continue;
        }

        cbCredential += sizeof(KERB_KEY_DATA) + cbKey;
        cKerbEncryptionKeys++;
    }


    //
    // Add in space for oldcreds
    //

    if (ARGUMENT_PRESENT(pStoredCreds))
    {
        if (pStoredCreds->CredentialCount != 0)
        {
            for (Index = 0; Index < pStoredCreds->CredentialCount ; Index++ )
            {
                cbCredential += sizeof(KERB_KEY_DATA) + pStoredCreds->Credentials[Index].Key.keyvalue.length +
                                    pStoredCreds->Credentials[Index].Salt.Length;
                cKerbKeyData++;
            }

            cOldCreds = pStoredCreds->CredentialCount;
        }
    }

    //
    // Add in the size of the base structure
    //

    cbCredential += sizeof(KERB_STORED_CREDENTIAL) - (ANYSIZE_ARRAY * sizeof(KERB_KEY_DATA));
    cbCredential += pustrKeySalt->Length;

    pCredentials = (PKERB_STORED_CREDENTIAL) g_piKdcCore->pfnKdcAllocMemory(cbCredential);
    if (pCredentials == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Fill in the base structure
    //
    pCredentials->PreferredKeyIndex = 0;

    //
    // Now fill in the individual keys
    //

    pbKeyBase = (PUCHAR) pCredentials;
    ulOffset  = sizeof(KERB_STORED_CREDENTIAL) - (ANYSIZE_ARRAY * sizeof(KERB_KEY_DATA)) +
                ((cKerbEncryptionKeys + cKerbKeyData) * sizeof(KERB_KEY_DATA));

    //
    // Add the default salt
    //

    pCredentials->DefaultSalt.Length =
        pCredentials->DefaultSalt.MaximumLength = pustrKeySalt->Length;
    pCredentials->DefaultSalt.Buffer = (LPWSTR) (pbKeyBase+ulOffset);

    memcpy(
        pbKeyBase + ulOffset,
        pustrKeySalt->Buffer,
        pustrKeySalt->Length
        );
    ulOffset += pCredentials->DefaultSalt.Length;


    //
    // Now find the size of the key for each crypto system
    //

    for (Index = 0; Index < cEtypes; Index++)
    {
        if (!fIncludeBuiltinTypes &&
            ((pEtypes[Index] == KERB_ETYPE_RC4_LM) ||
             (pEtypes[Index] == KERB_ETYPE_RC4_MD4) ||
             (pEtypes[Index] == KERB_ETYPE_RC4_HMAC_OLD) ||
             (pEtypes[Index] == KERB_ETYPE_RC4_HMAC_OLD_EXP) ||
             (pEtypes[Index] == KERB_ETYPE_RC4_HMAC_NT) ||
             (pEtypes[Index] == KERB_ETYPE_RC4_HMAC_NT_EXP) ||
             (pEtypes[Index] == KERB_ETYPE_NULL)))
        {
            continue;
        }

        if (!KERB_SUCCESS(g_piKdcCore->pfnKerbHashPasswordEx(
                g_pIKerbCrypt,
                pustrPassword,
                pustrKeySalt,
                pEtypes[Index],
                &pTempKey)))
        {
            //
            // It is possible that the password can't be used for every
            // encryption scheme, so skip failures
            //

//            D_DebugLog((DEB_WARN, "Failed to hash pasword %wZ with type 0x%x\n",
//                pustrPassword, pEtypes[Index] ));

            XOMASSERT(!pTempKey);
            continue;
        }


        pCredentials->Credentials[CredentialIndex].Key = *pTempKey;
        pCredentials->Credentials[CredentialIndex].Key.keyvalue.value =
            pbKeyBase + ulOffset;

        memcpy(
            pbKeyBase + ulOffset,
            pTempKey->keyvalue.value,
            pTempKey->keyvalue.length
            );

        ulOffset += pTempKey->keyvalue.length;
        g_piKdcCore->pfnKdcFreeMemory(pTempKey);
        pTempKey = NULL;

        pCredentials->Credentials[CredentialIndex].Salt         = ustrEmptySalt;
        pCredentials->Credentials[CredentialIndex].SaltType     = SaltType;
        pCredentials->Credentials[CredentialIndex].KeyVersion   = ulKeyVersion;

        CredentialIndex++;
    }
    pCredentials->CredentialCount = (USHORT) CredentialIndex;

    //
    // Now add in the old creds, if there were any
    //

    if (cOldCreds != 0)
    {
        for (Index = 0; Index < cOldCreds; Index++ )
        {

            pCredentials->Credentials[CredentialIndex] = pStoredCreds->Credentials[Index];
            pCredentials->Credentials[CredentialIndex].Key.keyvalue.value = pbKeyBase + ulOffset;
            memcpy(
                pbKeyBase + ulOffset,
                pStoredCreds->Credentials[Index].Key.keyvalue.value + (ULONG_PTR) pStoredCreds, //BUGBUG: why + pStoreCreds ?
                pStoredCreds->Credentials[Index].Key.keyvalue.length
                );
            ulOffset += pStoredCreds->Credentials[Index].Key.keyvalue.length;

            //
            // Copy the salt
            //

            if (pCredentials->Credentials[CredentialIndex].Salt.Buffer != NULL)
            {
                pCredentials->Credentials[CredentialIndex].Salt.Buffer = (LPWSTR) pbKeyBase+ulOffset;

                memcpy(
                    pbKeyBase + ulOffset,
                    (PBYTE) pStoredCreds->Credentials[Index].Salt.Buffer + (ULONG_PTR) pStoredCreds, //BUGBUG
                    pStoredCreds->Credentials[Index].Salt.Length
                    );
                ulOffset += pStoredCreds->Credentials[Index].Salt.Length;
                SaltType = pStoredCreds->Credentials[Index].SaltType;
            }
            else
            {
                pCredentials->Credentials[CredentialIndex].Salt = ustrEmptySalt;
                SaltType = KerbKdbSaltTypeDefault;
            }
            pCredentials->Credentials[CredentialIndex].SaltType = SaltType;
            pCredentials->Credentials[CredentialIndex].KeyVersion =
            pStoredCreds->Credentials[Index].KeyVersion;

            CredentialIndex++;
        }
        pCredentials->CredentialCount = pCredentials->CredentialCount + (USHORT)cOldCreds;
    }
    *ppPasswordList = pCredentials;
    *pcbPasswordList = cbCredential;
    pCredentials = NULL;

Cleanup:
    if (pCredentials != NULL)
    {
         g_piKdcCore->pfnKdcFreeMemory(pCredentials);
    }
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\simple\INC\samimp.h ===
//
//#include <ntrpcnew.h>
//#include <lsass.h>
#include <pacext.h>
#include <ntsam.h>
#include <ntsamp.h>


#ifdef MIDL_PASS
// put any typedef redefinitions in here...
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\simple\INC\ntsamp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ntsamp.h

Abstract:

    This file contains structures that would normally be part of ntsam.h
    but are intended for system use only.

Author:

    David Chalmers (Davidc) 27-Mar-1992

Environment:

    User Mode - Win32

Revision History:


--*/


#ifndef _NTSAMPRIVATE_
#define _NTSAMPRIVATE_



#include <crypt.h>
#include <pacext.h>
//#include <lsass.h>




//
// Structures usable in SetUserInformation and QueryUserInformation API calls
// by trusted clients only
//


typedef struct _USER_INTERNAL1_INFORMATION {
    NT_OWF_PASSWORD             NtOwfPassword;
    LM_OWF_PASSWORD             LmOwfPassword;
    BOOLEAN                     NtPasswordPresent;
    BOOLEAN                     LmPasswordPresent;
    BOOLEAN                     PasswordExpired; // A 'write-only' flag
} USER_INTERNAL1_INFORMATION, *PUSER_INTERNAL1_INFORMATION;


typedef struct _USER_INTERNAL2_INFORMATION {
    ULONG StatisticsToApply;
    OLD_LARGE_INTEGER LastLogon;
    OLD_LARGE_INTEGER LastLogoff;
    USHORT BadPasswordCount;
    USHORT LogonCount;
} USER_INTERNAL2_INFORMATION;

typedef struct _USER_INTERNAL2A_INFORMATION {
    ULONG StatisticsToApply;
    OLD_LARGE_INTEGER LastLogon;
    OLD_LARGE_INTEGER LastLogoff;
    USHORT BadPasswordCount;
    USHORT LogonCount;
    UNICODE_STRING Workstation;
} USER_INTERNAL2A_INFORMATION, *PUSER_INTERNAL2A_INFORMATION;

//
//
//
// The following flags may be used in the StatisticsToApply field.
//
//   USER_LOGON_STAT_LAST_LOGOFF - Replace the LastLogoff time in the
//      user record.
//
//  USER_LOGON_STATUS_LAST_LOGON - Replace the LastLogon time in the
//      user record.
//
//  USER_LOGON_STATUS_BAD_PWD_COUNT  - Replace the BadPasswordCount
//      field in the user record.
//
//  USER_LOGON_STATUS_LOGON_COUNT - Replace the LogonCount field in the
//      user record.
//
//  USER_LOGON_SUCCESSFUL_LOGON - Change user field values to indicate
//      that a successful logon has occurred.
//
//  USER_LOGON_SUCCESSFUL_LOGOFF - Change user field values to indicate
//      that a successful logoff has occurred.
//
//  USER_LOGON_BAD_PASSWORD - Change user field values to indicate that
//      an attempt was made to logon to the account with a bad password.
//
//  USER_LOGON_BAD_PASSWORD_WKSTA - Change user field values to indicate that
//      an attempt was made to logon to the account with a bad password.
//      The client workstation name is being supplied in the INTERNAL2A
//      structure.
//
//  USER_LOGON_TYPE_KERBEROS - Indicates the authentication type was
//                             KERBEROS.
//
//  USER_LOGON_TYPE_NTLM - Indicates the authentication type was NTLM.
//
//  USER_LOGON_NO_LOGON_SERVERS -- Indicates that no logon servers could be
//                                 found (specifically no GC's could be found)
//                                 (this is a failure case).
//
//  USER_LOGON_NO_WRITE -- Indicates to SAM not to update the logon statistics
//                         This can be useful to notify SAM that a logon 
//                         has completed, but not have the penalty of writing
//                         to the disk
//
//  USER_LOGON_INTER_FAILURE -- this indicates that it was an interactive
//                              logon that failed
//
// NOTE:
//          USER_LOGON_INTER_SUCCESS_LOGOFF
//          USER_LOGON_NET_SUCCESS_LOGOFF
//
// may not be used in conjunction with ANY other flags (including
// each other).  That is, when one of these flags is used, there
// may be NO other flags set in StatisticsToApply.
//
// NOTE2:
//
//          USER_LOGON_BAD_PASSWORD
//          USER_LOGON_INTER_SUCCESS_LOGON
//          USER_LOGON_NET_SUCCESS_LOGON
//
// may be used in conjunction ONLY with ONE of USER_LOGON_TYPE_KERBEROS or
// USER_LOGON_TYPE_NTLM.

#define USER_LOGON_STAT_LAST_LOGOFF      (0x00000001L)
#define USER_LOGON_STAT_LAST_LOGON       (0x00000002L)
#define USER_LOGON_STAT_BAD_PWD_COUNT    (0x00000004L)
#define USER_LOGON_STAT_LOGON_COUNT      (0x00000008L)

#define USER_LOGON_INTER_FAILURE         (0x00200000L)
#define USER_LOGON_NO_WRITE              (0x00400000L)
#define USER_LOGON_NO_LOGON_SERVERS      (0x00800000L)
#define USER_LOGON_TYPE_NTLM             (0x02000000L)
#define USER_LOGON_TYPE_KERBEROS         (0x04000000L)
#define USER_LOGON_BAD_PASSWORD          (0x08000000L)
#define USER_LOGON_INTER_SUCCESS_LOGON   (0x01000000L)
#define USER_LOGON_BAD_PASSWORD_WKSTA    (0x10000000L)
#define USER_LOGON_INTER_SUCCESS_LOGOFF  (0x20000000L)
#define USER_LOGON_NET_SUCCESS_LOGON     (0x40000000L)
#define USER_LOGON_NET_SUCCESS_LOGOFF    (0x80000000L)


typedef struct _USER_INTERNAL3_INFORMATION {
    USER_ALL_INFORMATION I1;
    LARGE_INTEGER       LastBadPasswordTime;
} USER_INTERNAL3_INFORMATION,  *PUSER_INTERNAL3_INFORMATION;


typedef struct _USER_ALLOWED_TO_DELEGATE_TO_LIST {
    ULONG		Size;
    ULONG		NumSPNs;
	UNICODE_STRING SPNList[ANYSIZE_ARRAY];
} USER_ALLOWED_TO_DELEGATE_TO_LIST, *PUSER_ALLOWED_TO_DELEGATE_TO_LIST; 

typedef struct _USER_INTERNAL6_INFORMATION {
	USER_ALL_INFORMATION I1;
	LARGE_INTEGER       LastBadPasswordTime;
	ULONG               ExtendedFields;
	BOOLEAN             UPNDefaulted;
	UNICODE_STRING      UPN;
	PUSER_ALLOWED_TO_DELEGATE_TO_LIST A2D2List;
} USER_INTERNAL6_INFORMATION, *PUSER_INTERNAL6_INFORMATION;

//
// The following fields are to be used in the extended fields
// member of USER_INTERNAL6_INFORMATION
//


#define USER_EXTENDED_FIELD_UPN			(0x00000001L)
#define USER_EXTENDED_FIELD_A2D2		(0x00000002L)

//
// The following is for SamrGetUserDomainPasswordInformation(), which is
// only used in wrappers.c.
//

typedef struct _USER_DOMAIN_PASSWORD_INFORMATION {
    USHORT MinPasswordLength;
    ULONG PasswordProperties;
} USER_DOMAIN_PASSWORD_INFORMATION, *PUSER_DOMAIN_PASSWORD_INFORMATION;


//
// This flag may be or'd with the length field of SAMP_USER_PASSWORD to
// indicate that the password is not case sensitive.
//

#define SAM_PASSWORD_CASE_INSENSITIVE 0x80000000

//
// Structure to pass an encrypted password over the wire.  The Length is the
// length of the password, which should be placed at the end of the buffer.
// The size of the buffer (256) should be kept in sync with
// SAM_MAX_PASSWORD_LENGTH, which is defined in ntsam.h.  Unfortunately,
// MIDL does not let #define'd constants be imported, so we have to
// use 256 instead of the constant here.
//

typedef struct _SAMPR_USER_PASSWORD {
    WCHAR Buffer[SAM_MAX_PASSWORD_LENGTH];
    ULONG Length;
} SAMPR_USER_PASSWORD, *PSAMPR_USER_PASSWORD;

typedef struct _SAMPR_USER_PASSWORD_NEW {
    WCHAR Buffer[SAM_MAX_PASSWORD_LENGTH];
    ULONG Length;
    UCHAR ClearSalt[SAM_PASSWORD_ENCRYPTION_SALT_LEN];
} SAMPR_USER_PASSWORD_NEW, *PSAMPR_USER_PASSWORD_NEW;


//
// Buffer - contains random fill with the password filling up the end
//          of the buffer (the last Length bytes).
// Length - Length, in bytes, of the buffer.
//

//
// This is the encrypted version of the above structure, and is passed
// on the wire.
//

typedef struct _SAMPR_ENCRYPTED_USER_PASSWORD {
    UCHAR Buffer[ (SAM_MAX_PASSWORD_LENGTH * 2) + 4 ];
} SAMPR_ENCRYPTED_USER_PASSWORD, *PSAMPR_ENCRYPTED_USER_PASSWORD;


typedef struct _SAMPR_ENCRYPTED_USER_PASSWORD_NEW {
    UCHAR Buffer[ (SAM_MAX_PASSWORD_LENGTH * 2) + 4 + 16];
} SAMPR_ENCRYPTED_USER_PASSWORD_NEW, *PSAMPR_ENCRYPTED_USER_PASSWORD_NEW;


typedef enum _SAMPR_BOOT_TYPE {
    SamBootKeyNone = 0,
    SamBootKeyStored,
    SamBootKeyPassword,
    SamBootKeyDisk,
    SamBootChangePasswordEncryptionKey
} SAMPR_BOOT_TYPE, *PSAMPR_BOOT_TYPE;


//
// ChangePassword API for One-Way-Function-aware clients
//

NTSTATUS
SamiChangePasswordUser(
    IN SAM_HANDLE UserHandle,
    IN BOOLEAN LmOldPresent,
    IN PLM_OWF_PASSWORD LmOldOwfPassword,
    IN PLM_OWF_PASSWORD LmNewOwfPassword,
    IN BOOLEAN NtPresent,
    IN PNT_OWF_PASSWORD NtOldOwfPassword,
    IN PNT_OWF_PASSWORD NtNewOwfPassword
    );


NTSTATUS
SamiLmChangePasswordUser(
    IN SAM_HANDLE UserHandle,
    IN PENCRYPTED_LM_OWF_PASSWORD LmOldEncryptedWithLmNew,
    IN PENCRYPTED_LM_OWF_PASSWORD LmNewEncryptedWithLmOld
    );

NTSTATUS
SamiEncryptPasswords(
    IN PUNICODE_STRING OldPassword,
    IN PUNICODE_STRING NewPassword,
    OUT PSAMPR_ENCRYPTED_USER_PASSWORD NewEncryptedWithOldNt,
    OUT PENCRYPTED_NT_OWF_PASSWORD OldNtOwfEncryptedWithNewNt,
    OUT PBOOLEAN LmPresent,
    OUT PSAMPR_ENCRYPTED_USER_PASSWORD NewEncryptedWithOldLm,
    OUT PENCRYPTED_NT_OWF_PASSWORD OldLmOwfEncryptedWithNewNt
);

NTSTATUS
SamiChangePasswordUser2(
    PUNICODE_STRING ServerName,
    PUNICODE_STRING UserName,
    PSAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldNt,
    PENCRYPTED_NT_OWF_PASSWORD OldNtOwfPasswordEncryptedWithNewNt,
    BOOLEAN LmPresent,
    PSAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldLm,
    PENCRYPTED_LM_OWF_PASSWORD OldLmOwfPasswordEncryptedWithNewLmOrNt
    );

NTSTATUS
SamiOemChangePasswordUser2(
    PSTRING ServerName,
    PSTRING UserName,
    PSAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldLm,
    PENCRYPTED_LM_OWF_PASSWORD OldLmOwfPasswordEncryptedWithNewLm
    );

NTSTATUS
SamiGetBootKeyInformation(
    IN SAM_HANDLE DomainHandle,
    OUT PSAMPR_BOOT_TYPE BootOptions
    );

NTSTATUS
SamiSetBootKeyInformation(
    IN SAM_HANDLE DomainHandle,
    IN SAMPR_BOOT_TYPE BootOptions,
    IN PUNICODE_STRING OldBootKey, OPTIONAL
    IN PUNICODE_STRING NewBootKey OPTIONAL
    );

NTSTATUS
SamiSetDSRMPassword(
    IN PUNICODE_STRING  ServerName,
    IN ULONG            UserId,
    IN PUNICODE_STRING  ClearPassword
    );

NTSTATUS
SamiSetDSRMPasswordOWF(
    IN PUNICODE_STRING  ServerName,
    IN ULONG            UserId,
    IN PNT_OWF_PASSWORD NtPassword
    );


#endif  // _NTSAMPRIVATE_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\simple\INC\samrpc.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for samrpc.idl, samsrv.acf:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __samrpc_h__
#define __samrpc_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "samimp.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __samr_INTERFACE_DEFINED__
#define __samr_INTERFACE_DEFINED__

/* interface samr */
/* [strict_context_handle][implicit_handle][unique][ms_union][version][uuid] */ 

typedef struct _RPC_UNICODE_STRING
    {
    USHORT Length;
    USHORT MaximumLength;
    /* [length_is][size_is] */ PWCH Buffer;
    } 	RPC_UNICODE_STRING;

typedef struct _RPC_UNICODE_STRING *PRPC_UNICODE_STRING;

typedef struct _RPC_CYPHER_DATA
    {
    ULONG Length;
    ULONG MaximumLength;
    /* [length_is][size_is] */ PCHAR Buffer;
    } 	RPC_CYPHER_DATA;

typedef struct _RPC_CYPHER_DATA *PRPC_CYPHER_DATA;

typedef struct _RPC_STRING
    {
    USHORT Length;
    USHORT MaximumLength;
    /* [length_is][size_is] */ PCHAR Buffer;
    } 	RPC_STRING;

typedef struct _RPC_STRING *PRPC_STRING;

typedef struct _RPC_STRING RPC_ANSI_STRING;

typedef struct _RPC_STRING *PRPC_ANSI_STRING;

typedef struct _RPC_SID
    {
    UCHAR Revision;
    UCHAR SubAuthorityCount;
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
    /* [size_is] */ ULONG SubAuthority[ 1 ];
    } 	RPC_SID;

typedef struct _RPC_SID *PRPC_SID;

typedef struct _RPC_SID **PPRPC_SID;

typedef /* [handle] */ LPWSTR PSAMPR_SERVER_NAME;

typedef /* [context_handle] */ PVOID SAMPR_HANDLE;

#define SAM_NETWORK_REVISION_1      (1)
#define SAM_NETWORK_REVISION_2      (2)
#define SAM_NETWORK_REVISION_3      (3)
#define SAM_NETWORK_REVISION_LATEST SAM_NETWORK_REVISION_3
#define SAM_CLIENT_PRE_NT5 SAM_NETWORK_REVISION_1
#define SAM_CLIENT_NT5     SAM_NETWORK_REVISION_2
#define SAM_CLIENT_LATEST  SAM_NETWORK_REVISION_LATEST
#define SAM_EXTENDED_SID_DOMAIN          0x00000001
#define SAM_EXTENDED_SID_DOMAIN_COMPAT_1 0x00000002
#define SAM_EXTENDED_SID_DOMAIN_COMPAT_2 0x00000004
typedef struct _SAMPR_RID_ENUMERATION
    {
    ULONG RelativeId;
    RPC_UNICODE_STRING Name;
    } 	SAMPR_RID_ENUMERATION;

typedef struct _SAMPR_RID_ENUMERATION *PSAMPR_RID_ENUMERATION;

typedef struct _SAMPR_SID_ENUMERATION
    {
    PSID Sid;
    RPC_UNICODE_STRING Name;
    } 	SAMPR_SID_ENUMERATION;

typedef struct _SAMPR_SID_ENUMERATION *PSAMPR_SID_ENUMERATION;

typedef struct _SAMPR_ENUMERATION_BUFFER
    {
    ULONG EntriesRead;
    /* [size_is] */ PSAMPR_RID_ENUMERATION Buffer;
    } 	SAMPR_ENUMERATION_BUFFER;

typedef struct _SAMPR_ENUMERATION_BUFFER *PSAMPR_ENUMERATION_BUFFER;

typedef struct _SAMPR_SR_SECURITY_DESCRIPTOR
    {
    ULONG Length;
    /* [size_is] */ PUCHAR SecurityDescriptor;
    } 	SAMPR_SR_SECURITY_DESCRIPTOR;

typedef struct _SAMPR_SR_SECURITY_DESCRIPTOR *PSAMPR_SR_SECURITY_DESCRIPTOR;

typedef struct _SAMPR_GET_GROUPS_BUFFER
    {
    ULONG MembershipCount;
    /* [size_is] */ PGROUP_MEMBERSHIP Groups;
    } 	SAMPR_GET_GROUPS_BUFFER;

typedef struct _SAMPR_GET_GROUPS_BUFFER *PSAMPR_GET_GROUPS_BUFFER;

typedef struct _SAMPR_GET_MEMBERS_BUFFER
    {
    ULONG MemberCount;
    /* [size_is] */ PULONG Members;
    /* [size_is] */ PULONG Attributes;
    } 	SAMPR_GET_MEMBERS_BUFFER;

typedef struct _SAMPR_GET_MEMBERS_BUFFER *PSAMPR_GET_MEMBERS_BUFFER;

typedef struct _SAMPR_LOGON_HOURS
    {
    USHORT UnitsPerWeek;
    /* [length_is][size_is] */ PUCHAR LogonHours;
    } 	SAMPR_LOGON_HOURS;

typedef struct _SAMPR_LOGON_HOURS *PSAMPR_LOGON_HOURS;

typedef struct _SAMPR_ULONG_ARRAY
    {
    ULONG Count;
    /* [size_is] */ ULONG *Element;
    } 	SAMPR_ULONG_ARRAY;

typedef struct _SAMPR_ULONG_ARRAY *PSAMPR_ULONG_ARRAY;

typedef struct _SAMPR_SID_INFORMATION
    {
    PRPC_SID SidPointer;
    } 	SAMPR_SID_INFORMATION;

typedef /* [allocate] */ struct _SAMPR_SID_INFORMATION *PSAMPR_SID_INFORMATION;

typedef struct _SAMPR_PSID_ARRAY
    {
    ULONG Count;
    /* [size_is] */ PSAMPR_SID_INFORMATION Sids;
    } 	SAMPR_PSID_ARRAY;

typedef struct _SAMPR_PSID_ARRAY *PSAMPR_PSID_ARRAY;

typedef struct _SAMPR_UNICODE_STRING_ARRAY
    {
    ULONG Count;
    /* [size_is] */ RPC_UNICODE_STRING *Element;
    } 	SAMPR_UNICODE_STRING_ARRAY;

typedef struct _SAMPR_UNICODE_STRING_ARRAY *PSAMPR_UNICODE_STRING_ARRAY;

typedef RPC_UNICODE_STRING SAMPR_RETURNED_STRING;

typedef RPC_UNICODE_STRING *PSAMPR_RETURNED_STRING;

typedef STRING SAMPR_RETURNED_NORMAL_STRING;

typedef STRING *PSAMPR_RETURNED_NORMAL_STRING;

typedef struct _SAMPR_RETURNED_USTRING_ARRAY
    {
    ULONG Count;
    /* [size_is] */ PSAMPR_RETURNED_STRING Element;
    } 	SAMPR_RETURNED_USTRING_ARRAY;

typedef struct _SAMPR_RETURNED_USTRING_ARRAY *PSAMPR_RETURNED_USTRING_ARRAY;

typedef struct _SAMPR_REVISION_INFO_V1
    {
    ULONG Revision;
    ULONG SupportedFeatures;
    } 	SAMPR_REVISION_INFO_V1;

typedef struct _SAMPR_REVISION_INFO_V1 *PSAMPR_REVISION_INFO_V1;

typedef /* [public][public][public][switch_type] */ union __MIDL_samr_0001
    {
    /* [case()] */ SAMPR_REVISION_INFO_V1 V1;
    } 	SAMPR_REVISION_INFO;

typedef /* [switch_type] */ union __MIDL_samr_0001 *PSAMPR_REVISION_INFO;


#pragma pack(4)
typedef struct _SAMPR_DOMAIN_GENERAL_INFORMATION
    {
    OLD_LARGE_INTEGER ForceLogoff;
    RPC_UNICODE_STRING OemInformation;
    RPC_UNICODE_STRING DomainName;
    RPC_UNICODE_STRING ReplicaSourceNodeName;
    OLD_LARGE_INTEGER DomainModifiedCount;
    ULONG DomainServerState;
    ULONG DomainServerRole;
    BOOLEAN UasCompatibilityRequired;
    ULONG UserCount;
    ULONG GroupCount;
    ULONG AliasCount;
    } 	SAMPR_DOMAIN_GENERAL_INFORMATION;

typedef struct _SAMPR_DOMAIN_GENERAL_INFORMATION *PSAMPR_DOMAIN_GENERAL_INFORMATION;


#pragma pack()

#pragma pack(4)
typedef struct _SAMPR_DOMAIN_GENERAL_INFORMATION2
    {
    SAMPR_DOMAIN_GENERAL_INFORMATION I1;
    LARGE_INTEGER LockoutDuration;
    LARGE_INTEGER LockoutObservationWindow;
    USHORT LockoutThreshold;
    } 	SAMPR_DOMAIN_GENERAL_INFORMATION2;

typedef struct _SAMPR_DOMAIN_GENERAL_INFORMATION2 *PSAMPR_DOMAIN_GENERAL_INFORMATION2;


#pragma pack()
typedef struct _SAMPR_DOMAIN_OEM_INFORMATION
    {
    RPC_UNICODE_STRING OemInformation;
    } 	SAMPR_DOMAIN_OEM_INFORMATION;

typedef struct _SAMPR_DOMAIN_OEM_INFORMATION *PSAMPR_DOMAIN_OEM_INFORMATION;

typedef struct _SAMPR_DOMAIN_NAME_INFORMATION
    {
    RPC_UNICODE_STRING DomainName;
    } 	SAMPR_DOMAIN_NAME_INFORMATION;

typedef struct _SAMPR_DOMAIN_NAME_INFORMATION *PSAMPR_DOMAIN_NAME_INFORMATION;

typedef struct SAMPR_DOMAIN_REPLICATION_INFORMATION
    {
    RPC_UNICODE_STRING ReplicaSourceNodeName;
    } 	SAMPR_DOMAIN_REPLICATION_INFORMATION;

typedef struct SAMPR_DOMAIN_REPLICATION_INFORMATION *PSAMPR_DOMAIN_REPLICATION_INFORMATION;

typedef struct _SAMPR_DOMAIN_LOCKOUT_INFORMATION
    {
    LARGE_INTEGER LockoutDuration;
    LARGE_INTEGER LockoutObservationWindow;
    USHORT LockoutThreshold;
    } 	SAMPR_DOMAIN_LOCKOUT_INFORMATION;

typedef struct _SAMPR_DOMAIN_LOCKOUT_INFORMATION *PSAMPR_DOMAIN_LOCKOUT_INFORMATION;

typedef /* [switch_type] */ union _SAMPR_DOMAIN_INFO_BUFFER
    {
    /* [case()] */ DOMAIN_PASSWORD_INFORMATION Password;
    /* [case()] */ SAMPR_DOMAIN_GENERAL_INFORMATION General;
    /* [case()] */ DOMAIN_LOGOFF_INFORMATION Logoff;
    /* [case()] */ SAMPR_DOMAIN_OEM_INFORMATION Oem;
    /* [case()] */ SAMPR_DOMAIN_NAME_INFORMATION Name;
    /* [case()] */ DOMAIN_SERVER_ROLE_INFORMATION Role;
    /* [case()] */ SAMPR_DOMAIN_REPLICATION_INFORMATION Replication;
    /* [case()] */ DOMAIN_MODIFIED_INFORMATION Modified;
    /* [case()] */ DOMAIN_STATE_INFORMATION State;
    /* [case()] */ SAMPR_DOMAIN_GENERAL_INFORMATION2 General2;
    /* [case()] */ SAMPR_DOMAIN_LOCKOUT_INFORMATION Lockout;
    /* [case()] */ DOMAIN_MODIFIED_INFORMATION2 Modified2;
    } 	SAMPR_DOMAIN_INFO_BUFFER;

typedef /* [switch_type] */ union _SAMPR_DOMAIN_INFO_BUFFER *PSAMPR_DOMAIN_INFO_BUFFER;

typedef struct _SAMPR_GROUP_GENERAL_INFORMATION
    {
    RPC_UNICODE_STRING Name;
    ULONG Attributes;
    ULONG MemberCount;
    RPC_UNICODE_STRING AdminComment;
    } 	SAMPR_GROUP_GENERAL_INFORMATION;

typedef struct _SAMPR_GROUP_GENERAL_INFORMATION *PSAMPR_GROUP_GENERAL_INFORMATION;

typedef struct _SAMPR_GROUP_NAME_INFORMATION
    {
    RPC_UNICODE_STRING Name;
    } 	SAMPR_GROUP_NAME_INFORMATION;

typedef struct _SAMPR_GROUP_NAME_INFORMATION *PSAMPR_GROUP_NAME_INFORMATION;

typedef struct _SAMPR_GROUP_ADM_COMMENT_INFORMATION
    {
    RPC_UNICODE_STRING AdminComment;
    } 	SAMPR_GROUP_ADM_COMMENT_INFORMATION;

typedef struct _SAMPR_GROUP_ADM_COMMENT_INFORMATION *PSAMPR_GROUP_ADM_COMMENT_INFORMATION;

typedef /* [switch_type] */ union _SAMPR_GROUP_INFO_BUFFER
    {
    /* [case()] */ SAMPR_GROUP_GENERAL_INFORMATION General;
    /* [case()] */ SAMPR_GROUP_NAME_INFORMATION Name;
    /* [case()] */ GROUP_ATTRIBUTE_INFORMATION Attribute;
    /* [case()] */ SAMPR_GROUP_ADM_COMMENT_INFORMATION AdminComment;
    } 	SAMPR_GROUP_INFO_BUFFER;

typedef /* [switch_type] */ union _SAMPR_GROUP_INFO_BUFFER *PSAMPR_GROUP_INFO_BUFFER;

typedef struct _SAMPR_ALIAS_GENERAL_INFORMATION
    {
    RPC_UNICODE_STRING Name;
    ULONG MemberCount;
    RPC_UNICODE_STRING AdminComment;
    } 	SAMPR_ALIAS_GENERAL_INFORMATION;

typedef struct _SAMPR_ALIAS_GENERAL_INFORMATION *PSAMPR_ALIAS_GENERAL_INFORMATION;

typedef struct _SAMPR_ALIAS_NAME_INFORMATION
    {
    RPC_UNICODE_STRING Name;
    } 	SAMPR_ALIAS_NAME_INFORMATION;

typedef struct _SAMPR_ALIAS_NAME_INFORMATION *PSAMPR_ALIAS_NAME_INFORMATION;

typedef struct _SAMPR_ALIAS_ADM_COMMENT_INFORMATION
    {
    RPC_UNICODE_STRING AdminComment;
    } 	SAMPR_ALIAS_ADM_COMMENT_INFORMATION;

typedef struct _SAMPR_ALIAS_ADM_COMMENT_INFORMATION *PSAMPR_ALIAS_ADM_COMMENT_INFORMATION;

typedef /* [switch_type] */ union _SAMPR_ALIAS_INFO_BUFFER
    {
    /* [case()] */ SAMPR_ALIAS_GENERAL_INFORMATION General;
    /* [case()] */ SAMPR_ALIAS_NAME_INFORMATION Name;
    /* [case()] */ SAMPR_ALIAS_ADM_COMMENT_INFORMATION AdminComment;
    } 	SAMPR_ALIAS_INFO_BUFFER;

typedef /* [switch_type] */ union _SAMPR_ALIAS_INFO_BUFFER *PSAMPR_ALIAS_INFO_BUFFER;


#pragma pack(4)
typedef struct _SAMPR_USER_ALL_INFORMATION
    {
    OLD_LARGE_INTEGER LastLogon;
    OLD_LARGE_INTEGER LastLogoff;
    OLD_LARGE_INTEGER PasswordLastSet;
    OLD_LARGE_INTEGER AccountExpires;
    OLD_LARGE_INTEGER PasswordCanChange;
    OLD_LARGE_INTEGER PasswordMustChange;
    RPC_UNICODE_STRING UserName;
    RPC_UNICODE_STRING FullName;
    RPC_UNICODE_STRING HomeDirectory;
    RPC_UNICODE_STRING HomeDirectoryDrive;
    RPC_UNICODE_STRING ScriptPath;
    RPC_UNICODE_STRING ProfilePath;
    RPC_UNICODE_STRING AdminComment;
    RPC_UNICODE_STRING WorkStations;
    RPC_UNICODE_STRING UserComment;
    RPC_UNICODE_STRING Parameters;
    RPC_UNICODE_STRING LmOwfPassword;
    RPC_UNICODE_STRING NtOwfPassword;
    RPC_UNICODE_STRING PrivateData;
    SAMPR_SR_SECURITY_DESCRIPTOR SecurityDescriptor;
    ULONG UserId;
    ULONG PrimaryGroupId;
    ULONG UserAccountControl;
    ULONG WhichFields;
    SAMPR_LOGON_HOURS LogonHours;
    USHORT BadPasswordCount;
    USHORT LogonCount;
    USHORT CountryCode;
    USHORT CodePage;
    BOOLEAN LmPasswordPresent;
    BOOLEAN NtPasswordPresent;
    BOOLEAN PasswordExpired;
    BOOLEAN PrivateDataSensitive;
    } 	SAMPR_USER_ALL_INFORMATION;

typedef struct _SAMPR_USER_ALL_INFORMATION *PSAMPR_USER_ALL_INFORMATION;


#pragma pack()

#pragma pack(4)
typedef struct _SAMPR_USER_INTERNAL3_INFORMATION
    {
    SAMPR_USER_ALL_INFORMATION I1;
    LARGE_INTEGER LastBadPasswordTime;
    } 	SAMPR_USER_INTERNAL3_INFORMATION;

typedef struct _SAMPR_USER_INTERNAL3_INFORMATION *PSAMPR_USER_INTERNAL3_INFORMATION;


#pragma pack()
typedef struct _SAMPR_USER_GENERAL_INFORMATION
    {
    RPC_UNICODE_STRING UserName;
    RPC_UNICODE_STRING FullName;
    ULONG PrimaryGroupId;
    RPC_UNICODE_STRING AdminComment;
    RPC_UNICODE_STRING UserComment;
    } 	SAMPR_USER_GENERAL_INFORMATION;

typedef struct _SAMPR_USER_GENERAL_INFORMATION *PSAMPR_USER_GENERAL_INFORMATION;

typedef struct _SAMPR_USER_PREFERENCES_INFORMATION
    {
    RPC_UNICODE_STRING UserComment;
    RPC_UNICODE_STRING Reserved1;
    USHORT CountryCode;
    USHORT CodePage;
    } 	SAMPR_USER_PREFERENCES_INFORMATION;

typedef struct _SAMPR_USER_PREFERENCES_INFORMATION *PSAMPR_USER_PREFERENCES_INFORMATION;

typedef struct _SAMPR_USER_PARAMETERS_INFORMATION
    {
    RPC_UNICODE_STRING Parameters;
    } 	SAMPR_USER_PARAMETERS_INFORMATION;

typedef struct _SAMPR_USER_PARAMETERS_INFORMATION *PSAMPR_USER_PARAMETERS_INFORMATION;


#pragma pack(4)
typedef struct _SAMPR_USER_LOGON_INFORMATION
    {
    RPC_UNICODE_STRING UserName;
    RPC_UNICODE_STRING FullName;
    ULONG UserId;
    ULONG PrimaryGroupId;
    RPC_UNICODE_STRING HomeDirectory;
    RPC_UNICODE_STRING HomeDirectoryDrive;
    RPC_UNICODE_STRING ScriptPath;
    RPC_UNICODE_STRING ProfilePath;
    RPC_UNICODE_STRING WorkStations;
    OLD_LARGE_INTEGER LastLogon;
    OLD_LARGE_INTEGER LastLogoff;
    OLD_LARGE_INTEGER PasswordLastSet;
    OLD_LARGE_INTEGER PasswordCanChange;
    OLD_LARGE_INTEGER PasswordMustChange;
    SAMPR_LOGON_HOURS LogonHours;
    USHORT BadPasswordCount;
    USHORT LogonCount;
    ULONG UserAccountControl;
    } 	SAMPR_USER_LOGON_INFORMATION;

typedef struct _SAMPR_USER_LOGON_INFORMATION *PSAMPR_USER_LOGON_INFORMATION;


#pragma pack()

#pragma pack(4)
typedef struct _SAMPR_USER_ACCOUNT_INFORMATION
    {
    RPC_UNICODE_STRING UserName;
    RPC_UNICODE_STRING FullName;
    ULONG UserId;
    ULONG PrimaryGroupId;
    RPC_UNICODE_STRING HomeDirectory;
    RPC_UNICODE_STRING HomeDirectoryDrive;
    RPC_UNICODE_STRING ScriptPath;
    RPC_UNICODE_STRING ProfilePath;
    RPC_UNICODE_STRING AdminComment;
    RPC_UNICODE_STRING WorkStations;
    OLD_LARGE_INTEGER LastLogon;
    OLD_LARGE_INTEGER LastLogoff;
    SAMPR_LOGON_HOURS LogonHours;
    USHORT BadPasswordCount;
    USHORT LogonCount;
    OLD_LARGE_INTEGER PasswordLastSet;
    OLD_LARGE_INTEGER AccountExpires;
    ULONG UserAccountControl;
    } 	SAMPR_USER_ACCOUNT_INFORMATION;

typedef struct _SAMPR_USER_ACCOUNT_INFORMATION *PSAMPR_USER_ACCOUNT_INFORMATION;


#pragma pack()
typedef struct _SAMPR_USER_A_NAME_INFORMATION
    {
    RPC_UNICODE_STRING UserName;
    } 	SAMPR_USER_A_NAME_INFORMATION;

typedef struct _SAMPR_USER_A_NAME_INFORMATION *PSAMPR_USER_A_NAME_INFORMATION;

typedef struct _SAMPR_USER_F_NAME_INFORMATION
    {
    RPC_UNICODE_STRING FullName;
    } 	SAMPR_USER_F_NAME_INFORMATION;

typedef struct _SAMPR_USER_F_NAME_INFORMATION *PSAMPR_USER_F_NAME_INFORMATION;

typedef struct _SAMPR_USER_NAME_INFORMATION
    {
    RPC_UNICODE_STRING UserName;
    RPC_UNICODE_STRING FullName;
    } 	SAMPR_USER_NAME_INFORMATION;

typedef struct _SAMPR_USER_NAME_INFORMATION *PSAMPR_USER_NAME_INFORMATION;

typedef struct _SAMPR_USER_HOME_INFORMATION
    {
    RPC_UNICODE_STRING HomeDirectory;
    RPC_UNICODE_STRING HomeDirectoryDrive;
    } 	SAMPR_USER_HOME_INFORMATION;

typedef struct _SAMPR_USER_HOME_INFORMATION *PSAMPR_USER_HOME_INFORMATION;

typedef struct _SAMPR_USER_SCRIPT_INFORMATION
    {
    RPC_UNICODE_STRING ScriptPath;
    } 	SAMPR_USER_SCRIPT_INFORMATION;

typedef struct _SAMPR_USER_SCRIPT_INFORMATION *PSAMPR_USER_SCRIPT_INFORMATION;

typedef struct _SAMPR_USER_PROFILE_INFORMATION
    {
    RPC_UNICODE_STRING ProfilePath;
    } 	SAMPR_USER_PROFILE_INFORMATION;

typedef struct _SAMPR_USER_PROFILE_INFORMATION *PSAMPR_USER_PROFILE_INFORMATION;

typedef struct _SAMPR_USER_ADMIN_COMMENT_INFORMATION
    {
    RPC_UNICODE_STRING AdminComment;
    } 	SAMPR_USER_ADMIN_COMMENT_INFORMATION;

typedef struct _SAMPR_USER_ADMIN_COMMENT_INFORMATION *PSAMPR_USER_ADMIN_COMMENT_INFORMATION;

typedef struct _SAMPR_USER_WORKSTATIONS_INFORMATION
    {
    RPC_UNICODE_STRING WorkStations;
    } 	SAMPR_USER_WORKSTATIONS_INFORMATION;

typedef struct _SAMPR_USER_WORKSTATIONS_INFORMATION *PSAMPR_USER_WORKSTATIONS_INFORMATION;

typedef struct _SAMPR_USER_LOGON_HOURS_INFORMATION
    {
    SAMPR_LOGON_HOURS LogonHours;
    } 	SAMPR_USER_LOGON_HOURS_INFORMATION;

typedef struct _SAMPR_USER_LOGON_HOURS_INFORMATION *PSAMPR_USER_LOGON_HOURS_INFORMATION;

typedef struct _SAMPR_USER_INTERNAL1_INFORMATION
    {
    ENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword;
    ENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword;
    BOOLEAN NtPasswordPresent;
    BOOLEAN LmPasswordPresent;
    BOOLEAN PasswordExpired;
    } 	SAMPR_USER_INTERNAL1_INFORMATION;

typedef struct _SAMPR_USER_INTERNAL1_INFORMATION *PSAMPR_USER_INTERNAL1_INFORMATION;

typedef struct _SAMPR_USER_INTERNAL4_INFORMATION
    {
    SAMPR_USER_ALL_INFORMATION I1;
    SAMPR_ENCRYPTED_USER_PASSWORD UserPassword;
    } 	SAMPR_USER_INTERNAL4_INFORMATION;

typedef struct _SAMPR_USER_INTERNAL4_INFORMATION *PSAMPR_USER_INTERNAL4_INFORMATION;

typedef struct _SAMPR_USER_INTERNAL4_INFORMATION_NEW
    {
    SAMPR_USER_ALL_INFORMATION I1;
    SAMPR_ENCRYPTED_USER_PASSWORD_NEW UserPassword;
    } 	SAMPR_USER_INTERNAL4_INFORMATION_NEW;

typedef struct _SAMPR_USER_INTERNAL4_INFORMATION_NEW *PSAMPR_USER_INTERNAL4_INFORMATION_NEW;

typedef struct _SAMPR_USER_INTERNAL5_INFORMATION
    {
    SAMPR_ENCRYPTED_USER_PASSWORD UserPassword;
    BOOLEAN PasswordExpired;
    } 	SAMPR_USER_INTERNAL5_INFORMATION;

typedef struct _SAMPR_USER_INTERNAL5_INFORMATION *PSAMPR_USER_INTERNAL5_INFORMATION;

typedef struct _SAMPR_USER_INTERNAL5_INFORMATION_NEW
    {
    SAMPR_ENCRYPTED_USER_PASSWORD_NEW UserPassword;
    BOOLEAN PasswordExpired;
    } 	SAMPR_USER_INTERNAL5_INFORMATION_NEW;

typedef struct _SAMPR_USER_INTERNAL5_INFORMATION_NEW *PSAMPR_USER_INTERNAL5_INFORMATION_NEW;

typedef /* [switch_type] */ union _SAMPR_USER_INFO_BUFFER
    {
    /* [case()] */ SAMPR_USER_GENERAL_INFORMATION General;
    /* [case()] */ SAMPR_USER_PREFERENCES_INFORMATION Preferences;
    /* [case()] */ SAMPR_USER_LOGON_INFORMATION Logon;
    /* [case()] */ SAMPR_USER_LOGON_HOURS_INFORMATION LogonHours;
    /* [case()] */ SAMPR_USER_ACCOUNT_INFORMATION Account;
    /* [case()] */ SAMPR_USER_NAME_INFORMATION Name;
    /* [case()] */ SAMPR_USER_A_NAME_INFORMATION AccountName;
    /* [case()] */ SAMPR_USER_F_NAME_INFORMATION FullName;
    /* [case()] */ USER_PRIMARY_GROUP_INFORMATION PrimaryGroup;
    /* [case()] */ SAMPR_USER_HOME_INFORMATION Home;
    /* [case()] */ SAMPR_USER_SCRIPT_INFORMATION Script;
    /* [case()] */ SAMPR_USER_PROFILE_INFORMATION Profile;
    /* [case()] */ SAMPR_USER_ADMIN_COMMENT_INFORMATION AdminComment;
    /* [case()] */ SAMPR_USER_WORKSTATIONS_INFORMATION WorkStations;
    /* [case()] */ USER_CONTROL_INFORMATION Control;
    /* [case()] */ USER_EXPIRES_INFORMATION Expires;
    /* [case()] */ SAMPR_USER_INTERNAL1_INFORMATION Internal1;
    /* [case()] */ USER_INTERNAL2_INFORMATION Internal2;
    /* [case()] */ SAMPR_USER_PARAMETERS_INFORMATION Parameters;
    /* [case()] */ SAMPR_USER_ALL_INFORMATION All;
    /* [case()] */ SAMPR_USER_INTERNAL3_INFORMATION Internal3;
    /* [case()] */ SAMPR_USER_INTERNAL4_INFORMATION Internal4;
    /* [case()] */ SAMPR_USER_INTERNAL5_INFORMATION Internal5;
    /* [case()] */ SAMPR_USER_INTERNAL4_INFORMATION_NEW Internal4New;
    /* [case()] */ SAMPR_USER_INTERNAL5_INFORMATION_NEW Internal5New;
    } 	SAMPR_USER_INFO_BUFFER;

typedef /* [switch_type] */ union _SAMPR_USER_INFO_BUFFER *PSAMPR_USER_INFO_BUFFER;

typedef struct _SAMPR_DOMAIN_DISPLAY_USER
    {
    ULONG Index;
    ULONG Rid;
    ULONG AccountControl;
    SAMPR_RETURNED_STRING LogonName;
    SAMPR_RETURNED_STRING AdminComment;
    SAMPR_RETURNED_STRING FullName;
    } 	SAMPR_DOMAIN_DISPLAY_USER;

typedef struct _SAMPR_DOMAIN_DISPLAY_USER *PSAMPR_DOMAIN_DISPLAY_USER;

typedef struct _SAMPR_DOMAIN_DISPLAY_MACHINE
    {
    ULONG Index;
    ULONG Rid;
    ULONG AccountControl;
    SAMPR_RETURNED_STRING Machine;
    SAMPR_RETURNED_STRING Comment;
    } 	SAMPR_DOMAIN_DISPLAY_MACHINE;

typedef struct _SAMPR_DOMAIN_DISPLAY_MACHINE *PSAMPR_DOMAIN_DISPLAY_MACHINE;

typedef struct _SAMPR_DOMAIN_DISPLAY_GROUP
    {
    ULONG Index;
    ULONG Rid;
    ULONG Attributes;
    SAMPR_RETURNED_STRING Group;
    SAMPR_RETURNED_STRING Comment;
    } 	SAMPR_DOMAIN_DISPLAY_GROUP;

typedef struct _SAMPR_DOMAIN_DISPLAY_GROUP *PSAMPR_DOMAIN_DISPLAY_GROUP;

typedef struct _SAMPR_DOMAIN_DISPLAY_OEM_USER
    {
    ULONG Index;
    SAMPR_RETURNED_NORMAL_STRING OemUser;
    } 	SAMPR_DOMAIN_DISPLAY_OEM_USER;

typedef struct _SAMPR_DOMAIN_DISPLAY_OEM_USER *PSAMPR_DOMAIN_DISPLAY_OEM_USER;

typedef struct _SAMPR_DOMAIN_DISPLAY_OEM_GROUP
    {
    ULONG Index;
    SAMPR_RETURNED_NORMAL_STRING OemGroup;
    } 	SAMPR_DOMAIN_DISPLAY_OEM_GROUP;

typedef struct _SAMPR_DOMAIN_DISPLAY_OEM_GROUP *PSAMPR_DOMAIN_DISPLAY_OEM_GROUP;

typedef struct _SAMPR_DOMAIN_DISPLAY_USER_BUFFER
    {
    ULONG EntriesRead;
    /* [size_is] */ PSAMPR_DOMAIN_DISPLAY_USER Buffer;
    } 	SAMPR_DOMAIN_DISPLAY_USER_BUFFER;

typedef struct _SAMPR_DOMAIN_DISPLAY_USER_BUFFER *PSAMPR_DOMAIN_DISPLAY_USER_BUFFER;

typedef struct _SAMPR_DOMAIN_DISPLAY_MACHINE_BUFFER
    {
    ULONG EntriesRead;
    /* [size_is] */ PSAMPR_DOMAIN_DISPLAY_MACHINE Buffer;
    } 	SAMPR_DOMAIN_DISPLAY_MACHINE_BUFFER;

typedef struct _SAMPR_DOMAIN_DISPLAY_MACHINE_BUFFER *PSAMPR_DOMAIN_DISPLAY_MACHINE_BUFFER;

typedef struct _SAMPR_DOMAIN_DISPLAY_GROUP_BUFFER
    {
    ULONG EntriesRead;
    /* [size_is] */ PSAMPR_DOMAIN_DISPLAY_GROUP Buffer;
    } 	SAMPR_DOMAIN_DISPLAY_GROUP_BUFFER;

typedef struct _SAMPR_DOMAIN_DISPLAY_GROUP_BUFFER *PSAMPR_DOMAIN_DISPLAY_GROUP_BUFFER;

typedef struct _SAMPR_DOMAIN_DISPLAY_OEM_USER_BUFFER
    {
    ULONG EntriesRead;
    /* [size_is] */ PSAMPR_DOMAIN_DISPLAY_OEM_USER Buffer;
    } 	SAMPR_DOMAIN_DISPLAY_OEM_USER_BUFFER;

typedef struct _SAMPR_DOMAIN_DISPLAY_OEM_USER_BUFFER *PSAMPR_DOMAIN_DISPLAY_OEM_USER_BUFFER;

typedef struct _SAMPR_DOMAIN_DISPLAY_OEM_GROUP_BUFFER
    {
    ULONG EntriesRead;
    /* [size_is] */ PSAMPR_DOMAIN_DISPLAY_OEM_GROUP Buffer;
    } 	SAMPR_DOMAIN_DISPLAY_OEM_GROUP_BUFFER;

typedef struct _SAMPR_DOMAIN_DISPLAY_OEM_GROUP_BUFFER *PSAMPR_DOMAIN_DISPLAY_OEM_GROUP_BUFFER;

typedef /* [switch_type] */ union _SAMPR_DISPLAY_INFO_BUFFER
    {
    /* [case()] */ SAMPR_DOMAIN_DISPLAY_USER_BUFFER UserInformation;
    /* [case()] */ SAMPR_DOMAIN_DISPLAY_MACHINE_BUFFER MachineInformation;
    /* [case()] */ SAMPR_DOMAIN_DISPLAY_GROUP_BUFFER GroupInformation;
    /* [case()] */ SAMPR_DOMAIN_DISPLAY_OEM_USER_BUFFER OemUserInformation;
    /* [case()] */ SAMPR_DOMAIN_DISPLAY_OEM_GROUP_BUFFER OemGroupInformation;
    } 	SAMPR_DISPLAY_INFO_BUFFER;

typedef /* [switch_type] */ union _SAMPR_DISPLAY_INFO_BUFFER *PSAMPR_DISPLAY_INFO_BUFFER;

NTSTATUS SamrConnect( 
    /* [unique][in] */ PSAMPR_SERVER_NAME ServerName,
    /* [out] */ SAMPR_HANDLE *ServerHandle,
    /* [in] */ ACCESS_MASK DesiredAccess);

NTSTATUS SamrCloseHandle( 
    /* [out][in] */ SAMPR_HANDLE *SamHandle);

NTSTATUS SamrSetSecurityObject( 
    /* [in] */ SAMPR_HANDLE ObjectHandle,
    /* [in] */ SECURITY_INFORMATION SecurityInformation,
    /* [in] */ PSAMPR_SR_SECURITY_DESCRIPTOR SecurityDescriptor);

NTSTATUS SamrQuerySecurityObject( 
    /* [in] */ SAMPR_HANDLE ObjectHandle,
    /* [in] */ SECURITY_INFORMATION SecurityInformation,
    /* [out] */ PSAMPR_SR_SECURITY_DESCRIPTOR *SecurityDescriptor);

NTSTATUS SamrShutdownSamServer( 
    /* [in] */ SAMPR_HANDLE ServerHandle);

NTSTATUS SamrLookupDomainInSamServer( 
    /* [in] */ SAMPR_HANDLE ServerHandle,
    /* [in] */ PRPC_UNICODE_STRING Name,
    /* [out] */ PRPC_SID *DomainId);

NTSTATUS SamrEnumerateDomainsInSamServer( 
    /* [in] */ SAMPR_HANDLE ServerHandle,
    /* [out][in] */ PSAM_ENUMERATE_HANDLE EnumerationContext,
    /* [out] */ PSAMPR_ENUMERATION_BUFFER *Buffer,
    /* [in] */ ULONG PreferedMaximumLength,
    /* [out] */ PULONG CountReturned);

NTSTATUS SamrOpenDomain( 
    /* [in] */ SAMPR_HANDLE ServerHandle,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [in] */ PRPC_SID DomainId,
    /* [out] */ SAMPR_HANDLE *DomainHandle);

NTSTATUS SamrQueryInformationDomain( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ DOMAIN_INFORMATION_CLASS DomainInformationClass,
    /* [switch_is][out] */ PSAMPR_DOMAIN_INFO_BUFFER *Buffer);

NTSTATUS SamrSetInformationDomain( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ DOMAIN_INFORMATION_CLASS DomainInformationClass,
    /* [switch_is][in] */ PSAMPR_DOMAIN_INFO_BUFFER DomainInformation);

NTSTATUS SamrCreateGroupInDomain( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ PRPC_UNICODE_STRING Name,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [out] */ SAMPR_HANDLE *GroupHandle,
    /* [out] */ PULONG RelativeId);

NTSTATUS SamrEnumerateGroupsInDomain( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [out][in] */ PSAM_ENUMERATE_HANDLE EnumerationContext,
    /* [out] */ PSAMPR_ENUMERATION_BUFFER *Buffer,
    /* [in] */ ULONG PreferedMaximumLength,
    /* [out] */ PULONG CountReturned);

NTSTATUS SamrCreateUserInDomain( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ PRPC_UNICODE_STRING Name,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [out] */ SAMPR_HANDLE *UserHandle,
    /* [out] */ PULONG RelativeId);

NTSTATUS SamrEnumerateUsersInDomain( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [out][in] */ PSAM_ENUMERATE_HANDLE EnumerationContext,
    /* [in] */ ULONG UserAccountControl,
    /* [out] */ PSAMPR_ENUMERATION_BUFFER *Buffer,
    /* [in] */ ULONG PreferedMaximumLength,
    /* [out] */ PULONG CountReturned);

NTSTATUS SamrCreateAliasInDomain( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ PRPC_UNICODE_STRING AccountName,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [out] */ SAMPR_HANDLE *AliasHandle,
    /* [out] */ PULONG RelativeId);

NTSTATUS SamrEnumerateAliasesInDomain( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [out][in] */ PSAM_ENUMERATE_HANDLE EnumerationContext,
    /* [out] */ PSAMPR_ENUMERATION_BUFFER *Buffer,
    /* [in] */ ULONG PreferedMaximumLength,
    /* [out] */ PULONG CountReturned);

NTSTATUS SamrGetAliasMembership( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ PSAMPR_PSID_ARRAY SidArray,
    /* [out] */ PSAMPR_ULONG_ARRAY Membership);

NTSTATUS SamrLookupNamesInDomain( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ ULONG Count,
    /* [length_is][size_is][in] */ RPC_UNICODE_STRING Names[  ],
    /* [out] */ PSAMPR_ULONG_ARRAY RelativeIds,
    /* [out] */ PSAMPR_ULONG_ARRAY Use);

NTSTATUS SamrLookupIdsInDomain( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ ULONG Count,
    /* [length_is][size_is][in] */ PULONG RelativeIds,
    /* [out] */ PSAMPR_RETURNED_USTRING_ARRAY Names,
    /* [out] */ PSAMPR_ULONG_ARRAY Use);

NTSTATUS SamrOpenGroup( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [in] */ ULONG GroupId,
    /* [out] */ SAMPR_HANDLE *GroupHandle);

NTSTATUS SamrQueryInformationGroup( 
    /* [in] */ SAMPR_HANDLE GroupHandle,
    /* [in] */ GROUP_INFORMATION_CLASS GroupInformationClass,
    /* [switch_is][out] */ PSAMPR_GROUP_INFO_BUFFER *Buffer);

NTSTATUS SamrSetInformationGroup( 
    /* [in] */ SAMPR_HANDLE GroupHandle,
    /* [in] */ GROUP_INFORMATION_CLASS GroupInformationClass,
    /* [switch_is][in] */ PSAMPR_GROUP_INFO_BUFFER Buffer);

NTSTATUS SamrAddMemberToGroup( 
    /* [in] */ SAMPR_HANDLE GroupHandle,
    /* [in] */ ULONG MemberId,
    /* [in] */ ULONG Attributes);

NTSTATUS SamrDeleteGroup( 
    /* [out][in] */ SAMPR_HANDLE *GroupHandle);

NTSTATUS SamrRemoveMemberFromGroup( 
    /* [in] */ SAMPR_HANDLE GroupHandle,
    /* [in] */ ULONG MemberId);

NTSTATUS SamrGetMembersInGroup( 
    /* [in] */ SAMPR_HANDLE GroupHandle,
    /* [out] */ PSAMPR_GET_MEMBERS_BUFFER *Members);

NTSTATUS SamrSetMemberAttributesOfGroup( 
    /* [in] */ SAMPR_HANDLE GroupHandle,
    /* [in] */ ULONG MemberId,
    /* [in] */ ULONG Attributes);

NTSTATUS SamrOpenAlias( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [in] */ ULONG AliasId,
    /* [out] */ SAMPR_HANDLE *AliasHandle);

NTSTATUS SamrQueryInformationAlias( 
    /* [in] */ SAMPR_HANDLE AliasHandle,
    /* [in] */ ALIAS_INFORMATION_CLASS AliasInformationClass,
    /* [switch_is][out] */ PSAMPR_ALIAS_INFO_BUFFER *Buffer);

NTSTATUS SamrSetInformationAlias( 
    /* [in] */ SAMPR_HANDLE AliasHandle,
    /* [in] */ ALIAS_INFORMATION_CLASS AliasInformationClass,
    /* [switch_is][in] */ PSAMPR_ALIAS_INFO_BUFFER Buffer);

NTSTATUS SamrDeleteAlias( 
    /* [out][in] */ SAMPR_HANDLE *AliasHandle);

NTSTATUS SamrAddMemberToAlias( 
    /* [in] */ SAMPR_HANDLE AliasHandle,
    /* [in] */ PRPC_SID MemberId);

NTSTATUS SamrRemoveMemberFromAlias( 
    /* [in] */ SAMPR_HANDLE AliasHandle,
    /* [in] */ PRPC_SID MemberId);

NTSTATUS SamrGetMembersInAlias( 
    /* [in] */ SAMPR_HANDLE AliasHandle,
    /* [out] */ PSAMPR_PSID_ARRAY Members);

NTSTATUS SamrOpenUser( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [in] */ ULONG UserId,
    /* [out] */ SAMPR_HANDLE *UserHandle);

NTSTATUS SamrDeleteUser( 
    /* [out][in] */ SAMPR_HANDLE *UserHandle);

NTSTATUS SamrQueryInformationUser( 
    /* [in] */ SAMPR_HANDLE UserHandle,
    /* [in] */ USER_INFORMATION_CLASS UserInformationClass,
    /* [switch_is][out] */ PSAMPR_USER_INFO_BUFFER *Buffer);

NTSTATUS SamrSetInformationUser( 
    /* [in] */ SAMPR_HANDLE UserHandle,
    /* [in] */ USER_INFORMATION_CLASS UserInformationClass,
    /* [switch_is][in] */ PSAMPR_USER_INFO_BUFFER Buffer);

NTSTATUS SamrChangePasswordUser( 
    /* [in] */ SAMPR_HANDLE UserHandle,
    /* [in] */ BOOLEAN LmPresent,
    /* [unique][in] */ PENCRYPTED_LM_OWF_PASSWORD LmOldEncryptedWithLmNew,
    /* [unique][in] */ PENCRYPTED_LM_OWF_PASSWORD LmNewEncryptedWithLmOld,
    /* [in] */ BOOLEAN NtPresent,
    /* [unique][in] */ PENCRYPTED_NT_OWF_PASSWORD NtOldEncryptedWithNtNew,
    /* [unique][in] */ PENCRYPTED_NT_OWF_PASSWORD NtNewEncryptedWithNtOld,
    /* [in] */ BOOLEAN NtCrossEncryptionPresent,
    /* [unique][in] */ PENCRYPTED_NT_OWF_PASSWORD NtNewEncryptedWithLmNew,
    /* [in] */ BOOLEAN LmCrossEncryptionPresent,
    /* [unique][in] */ PENCRYPTED_LM_OWF_PASSWORD LmNtNewEncryptedWithNtNew);

NTSTATUS SamrGetGroupsForUser( 
    /* [in] */ SAMPR_HANDLE UserHandle,
    /* [out] */ PSAMPR_GET_GROUPS_BUFFER *Groups);

NTSTATUS SamrQueryDisplayInformation( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ DOMAIN_DISPLAY_INFORMATION DisplayInformationClass,
    /* [in] */ ULONG Index,
    /* [in] */ ULONG EntryCount,
    /* [in] */ ULONG PreferredMaximumLength,
    /* [out] */ PULONG TotalAvailable,
    /* [out] */ PULONG TotalReturned,
    /* [switch_is][out] */ PSAMPR_DISPLAY_INFO_BUFFER Buffer);

NTSTATUS SamrGetDisplayEnumerationIndex( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ DOMAIN_DISPLAY_INFORMATION DisplayInformationClass,
    /* [in] */ PRPC_UNICODE_STRING Prefix,
    /* [out] */ PULONG Index);

NTSTATUS SamrTestPrivateFunctionsDomain( 
    /* [in] */ SAMPR_HANDLE DomainHandle);

NTSTATUS SamrTestPrivateFunctionsUser( 
    /* [in] */ SAMPR_HANDLE UserHandle);

NTSTATUS SamrGetUserDomainPasswordInformation( 
    /* [in] */ SAMPR_HANDLE UserHandle,
    /* [out] */ PUSER_DOMAIN_PASSWORD_INFORMATION PasswordInformation);

NTSTATUS SamrRemoveMemberFromForeignDomain( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ PRPC_SID MemberSid);

NTSTATUS SamrQueryInformationDomain2( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ DOMAIN_INFORMATION_CLASS DomainInformationClass,
    /* [switch_is][out] */ PSAMPR_DOMAIN_INFO_BUFFER *Buffer);

NTSTATUS SamrQueryInformationUser2( 
    /* [in] */ SAMPR_HANDLE UserHandle,
    /* [in] */ USER_INFORMATION_CLASS UserInformationClass,
    /* [switch_is][out] */ PSAMPR_USER_INFO_BUFFER *Buffer);

NTSTATUS SamrQueryDisplayInformation2( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ DOMAIN_DISPLAY_INFORMATION DisplayInformationClass,
    /* [in] */ ULONG Index,
    /* [in] */ ULONG EntryCount,
    /* [in] */ ULONG PreferredMaximumLength,
    /* [out] */ PULONG TotalAvailable,
    /* [out] */ PULONG TotalReturned,
    /* [switch_is][out] */ PSAMPR_DISPLAY_INFO_BUFFER Buffer);

NTSTATUS SamrGetDisplayEnumerationIndex2( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ DOMAIN_DISPLAY_INFORMATION DisplayInformationClass,
    /* [in] */ PRPC_UNICODE_STRING Prefix,
    /* [out] */ PULONG Index);

NTSTATUS SamrCreateUser2InDomain( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ PRPC_UNICODE_STRING Name,
    /* [in] */ ULONG AccountType,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [out] */ SAMPR_HANDLE *UserHandle,
    /* [out] */ PULONG GrantedAccess,
    /* [out] */ PULONG RelativeId);

NTSTATUS SamrQueryDisplayInformation3( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ DOMAIN_DISPLAY_INFORMATION DisplayInformationClass,
    /* [in] */ ULONG Index,
    /* [in] */ ULONG EntryCount,
    /* [in] */ ULONG PreferredMaximumLength,
    /* [out] */ PULONG TotalAvailable,
    /* [out] */ PULONG TotalReturned,
    /* [switch_is][out] */ PSAMPR_DISPLAY_INFO_BUFFER Buffer);

NTSTATUS SamrAddMultipleMembersToAlias( 
    /* [in] */ SAMPR_HANDLE AliasHandle,
    /* [in] */ PSAMPR_PSID_ARRAY MembersBuffer);

NTSTATUS SamrRemoveMultipleMembersFromAlias( 
    /* [in] */ SAMPR_HANDLE AliasHandle,
    /* [in] */ PSAMPR_PSID_ARRAY MembersBuffer);

NTSTATUS SamrOemChangePasswordUser2( 
    /* [in] */ handle_t BindingHandle,
    /* [unique][in] */ PRPC_STRING ServerName,
    /* [in] */ PRPC_STRING UserName,
    /* [unique][in] */ PSAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldLm,
    /* [unique][in] */ PENCRYPTED_LM_OWF_PASSWORD OldLmOwfPassswordEncryptedWithNewLm);

NTSTATUS SamrUnicodeChangePasswordUser2( 
    /* [in] */ handle_t BindingHandle,
    /* [unique][in] */ PRPC_UNICODE_STRING ServerName,
    /* [in] */ PRPC_UNICODE_STRING UserName,
    /* [unique][in] */ PSAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldNt,
    /* [unique][in] */ PENCRYPTED_NT_OWF_PASSWORD OldNtOwfPasswordEncryptedWithNewNt,
    /* [in] */ BOOLEAN LmPresent,
    /* [unique][in] */ PSAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldLm,
    /* [unique][in] */ PENCRYPTED_LM_OWF_PASSWORD OldLmOwfPassswordEncryptedWithNewLmOrNt);

NTSTATUS SamrGetDomainPasswordInformation( 
    /* [in] */ handle_t BindingHandle,
    /* [unique][in] */ PRPC_UNICODE_STRING ServerName,
    /* [out] */ PUSER_DOMAIN_PASSWORD_INFORMATION PasswordInformation);

NTSTATUS SamrConnect2( 
    /* [string][unique][in] */ PSAMPR_SERVER_NAME ServerName,
    /* [out] */ SAMPR_HANDLE *ServerHandle,
    /* [in] */ ACCESS_MASK DesiredAccess);

NTSTATUS SamrSetInformationUser2( 
    /* [in] */ SAMPR_HANDLE UserHandle,
    /* [in] */ USER_INFORMATION_CLASS UserInformationClass,
    /* [switch_is][in] */ PSAMPR_USER_INFO_BUFFER Buffer);

NTSTATUS SamrSetBootKeyInformation( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ SAMPR_BOOT_TYPE BootOptions,
    /* [unique][in] */ PRPC_UNICODE_STRING OldBootKey,
    /* [unique][in] */ PRPC_UNICODE_STRING NewBootKey);

NTSTATUS SamrGetBootKeyInformation( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [out] */ PSAMPR_BOOT_TYPE BootOptions);

NTSTATUS SamrConnect3( 
    /* [string][unique][in] */ PSAMPR_SERVER_NAME ServerName,
    /* [out] */ SAMPR_HANDLE *ServerHandle,
    /* [in] */ ULONG ClientRevision,
    /* [in] */ ACCESS_MASK DesiredAccess);

NTSTATUS SamrConnect4( 
    /* [string][unique][in] */ PSAMPR_SERVER_NAME ServerName,
    /* [out] */ SAMPR_HANDLE *ServerHandle,
    /* [in] */ ULONG ClientRevision,
    /* [in] */ ACCESS_MASK DesiredAccess);

NTSTATUS SamrUnicodeChangePasswordUser3( 
    /* [in] */ handle_t BindingHandle,
    /* [unique][in] */ PRPC_UNICODE_STRING ServerName,
    /* [in] */ PRPC_UNICODE_STRING UserName,
    /* [unique][in] */ PSAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldNt,
    /* [unique][in] */ PENCRYPTED_NT_OWF_PASSWORD OldNtOwfPasswordEncryptedWithNewNt,
    /* [in] */ BOOLEAN LmPresent,
    /* [unique][in] */ PSAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldLm,
    /* [unique][in] */ PENCRYPTED_LM_OWF_PASSWORD OldLmOwfPassswordEncryptedWithNewLmOrNt,
    /* [unique][in] */ PSAMPR_ENCRYPTED_USER_PASSWORD AdditionalData,
    /* [out] */ PDOMAIN_PASSWORD_INFORMATION *EffectivePasswordPolicy,
    /* [out] */ PUSER_PWD_CHANGE_FAILURE_INFORMATION *PasswordChangeInfo);

NTSTATUS SamrConnect5( 
    /* [string][unique][in] */ PSAMPR_SERVER_NAME ServerName,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [in] */ ULONG InVersion,
    /* [switch_is][in] */ SAMPR_REVISION_INFO *InRevisionInfo,
    /* [out] */ ULONG *OutVersion,
    /* [switch_is][out] */ SAMPR_REVISION_INFO *OutRevisionInfo,
    /* [out] */ SAMPR_HANDLE *ServerHandle);

NTSTATUS SamrRidToSid( 
    /* [in] */ SAMPR_HANDLE ObjectHandle,
    /* [in] */ ULONG Rid,
    /* [out] */ PRPC_SID *Sid);

NTSTATUS SamrSetDSRMPassword( 
    /* [in] */ handle_t BindingHandle,
    /* [unique][in] */ PRPC_UNICODE_STRING ServerName,
    /* [in] */ ULONG UserId,
    /* [unique][in] */ PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword);


extern handle_t samsrv_handle;


extern RPC_IF_HANDLE samr_ClientIfHandle;
extern RPC_IF_HANDLE samr_ServerIfHandle;
#endif /* __samr_INTERFACE_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

handle_t __RPC_USER PSAMPR_SERVER_NAME_bind  ( PSAMPR_SERVER_NAME );
void     __RPC_USER PSAMPR_SERVER_NAME_unbind( PSAMPR_SERVER_NAME, handle_t );

void __RPC_USER SAMPR_HANDLE_rundown( SAMPR_HANDLE );

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\KDCCore\test\kdctest.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       ticktest.cxx
//
//  Contents:   KDC Ticket granting service test code.
//
//  Classes:
//
//  Functions:
//
//  History:    19-Aug-93   WadeR   Created
//
//----------------------------------------------------------------------------

#include <secpch2.hxx>
#pragma hdrstop
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>
#include <kerbcomm.h>
#include <kerbinterface.h>
#include <kerbhelper.h>
#include <kerbcred.h>
#include <pac.hxx>
#include <pacext.h>
#include "kerbcrypt.hxx"

extern "C"
{
#include <dsgetdc.h>
//#include <kdcdbg.h>
}

//#define SHOW_KEYS 1

UNICODE_STRING ClientName;
UNICODE_STRING ServiceName;
UNICODE_STRING ServiceRealm;
UNICODE_STRING ClientRealm;
UNICODE_STRING ClientPassword;
UNICODE_STRING ServicePassword;
UNICODE_STRING KdcName;
WCHAR KdcNameString[100];
ULONG AddressType = DS_NETBIOS_ADDRESS;
ULONG CryptType = KERB_ETYPE_RC4_HMAC_NT;
//PVOID KdcBinding;

//added by Vikas
IKerbCrypt *g_pIKerbCrypt;

#include <kdccore.hxx>
//  not needed, but need to define
IKdcCore *g_piKdcCore;

//end decl by vikas

INT RequestPAC = -1;
INT NoEncTimeStamp = FALSE;
INT NameCanonicalize = FALSE;

BOOLEAN UseDg = TRUE;
BOOLEAN RequestReferrals = TRUE;

//  how many tickets to pack in PA_Compound_Identity
LONG    NumPaIds = 0;


#define KerbGetTime(_x_) ((_x_).QuadPart)
#define KerbSetTime(_d_, _s_) (_d_)->QuadPart = (_s_)

VOID
PrintBytes(
    IN PBYTE Bytes,
    IN UINT Len
    );

BOOLEAN
KerbVerifyPacChecksum(
    IN CHAR *Comment,
    IN PPACTYPE Pac,
    IN ULONG PacSize,
    IN PKERB_ENCRYPTION_KEY Key
    );

VOID
PrintTime(
    IN CHAR *Comment,
    IN COMPAT_LARGE_INTEGER *Time
    )
{
    printf("%s: %x.%x\n", Comment, Time->HighPart, Time->LowPart);
}

VOID
PrintSid(
    IN CHAR *Comment,
    IN PSID Sid
    )
{
    PISID sp = (PISID)Sid;
    PSID_IDENTIFIER_AUTHORITY sia;
    int n;

    printf("%s", Comment);

    if ( sp != NULL && (sp->Revision & 0x0f) == SID_REVISION) {
      if (sp->SubAuthorityCount <= SID_MAX_SUB_AUTHORITIES) {
        if (sp->SubAuthorityCount > 0) {
          printf("S-%lu-", sp->Revision);

          /* Warning little-endian code here */
          sia = &sp->IdentifierAuthority;
          if ( (sia->Value[0] != 0) || (sia->Value[1] != 0) ) {
            printf("0x%02hx%02hx%02hx%02hx%02hx%02hx",
                   (unsigned short)sia->Value[0],
                   (unsigned short)sia->Value[1],
                   (unsigned short)sia->Value[2],
                   (unsigned short)sia->Value[3],
                   (unsigned short)sia->Value[4],
                   (unsigned short)sia->Value[5]);
          }
          else {
            printf("%lu",
                   (unsigned long)(sia->Value[5]      )   +
                   (unsigned long)(sia->Value[4] <<  8)   +
                   (unsigned long)(sia->Value[3] << 16)   +
                   (unsigned long)(sia->Value[2] << 24)   );
          }

          for (n = 0; n < sp->SubAuthorityCount; n++) {
            printf("-%lu", sp->SubAuthority[n]);
          }
        }
      }
    }
    printf("\n");
}

VOID
PrintGroup(
    IN CHAR *Comment,
    IN PPAC_NETLOGON_SID_AND_ATTRIBUTES Group,
    IN ULONG Count
    )
{
    ULONG i;

    for (i = 0; i < Count; i++)
    {
        PrintSid(Comment, Group[i].Sid);
    }
}

VOID
PrintGroupRID(
    IN CHAR *Comment,
    IN PPAC_GROUP_MEMBERSHIP Group,
    IN ULONG Count
    )
{
    ULONG i;

    for (i = 0; i < Count; i++)
    {
        printf("%s %d", Comment, Group[i].RelativeId);
    }
}

VOID
PrintPacBuffer(
    IN PPAC_INFO_BUFFER Info
    )
{
    PPAC_SIGNATURE_DATA Sig;
    PPAC_CLIENT_INFO CInfo;
    //PPAC_CREDENTIAL_INFO CredInfo;
    //PPAC_CREDENTIAL_DATA CredData;
    ULONG Tag = Info->ulType;
    PPAC_NETLOGON_VALIDATION_SAM_INFO3 ClientInfo = NULL;

    switch (Tag) {
    case PAC_LOGON_INFO:
        printf("PAC_LOGON_INFO: ");
        if (!NT_SUCCESS(PAC_UnmarshallValidationInfo(
            &ClientInfo, Info->Data, Info->cbBufferSize)))
        {
            printf("Unable to unmarshall validation info.");
        }
        else
        {
            printf("\n");
            printf("\tEffectiveName: %wZ\n", &ClientInfo->EffectiveName);
            printf("\tFullName: %wZ\n", &ClientInfo->FullName);
            printf("\tLogonScript: %wZ\n", &ClientInfo->LogonScript);
            printf("\tProfilePath: %wZ\n", &ClientInfo->ProfilePath);
            printf("\tHomeDirectory: %wZ\n", &ClientInfo->HomeDirectory);
            printf("\tHomeDirectoryDrive: %wZ\n", &ClientInfo->HomeDirectoryDrive);
            PrintTime("\tLogonTime: ", &ClientInfo->LogonTime);
            PrintTime("\tLogoffTime: ", &ClientInfo->LogoffTime);
            PrintTime("\tKickOffTime: ", &ClientInfo->KickOffTime);
            PrintTime("\tPasswordLastSet: ", &ClientInfo->PasswordLastSet);
            PrintTime("\tPasswordCanChange: ", &ClientInfo->PasswordCanChange);
            PrintTime("\tPasswordMustChange: ", &ClientInfo->PasswordMustChange);
            printf("\tUserFlags: 0x%x\n", ClientInfo->UserFlags);
            printf("\tUserSessionKey:\n", ClientInfo->UserSessionKey);
            printf("\tLogonCount: %d\n", ClientInfo->LogonCount);
            printf("\tBadPasswordCount: %d\n", ClientInfo->BadPasswordCount);
            printf("\tLogonServer: %wZ\n", &ClientInfo->LogonServer);
            printf("\tLogonDomainName: %wZ\n", &ClientInfo->LogonDomainName);
            PrintSid("\tLogonDomainId: ", ClientInfo->LogonDomainId);
            printf("\tUserId: %u\n", ClientInfo->UserId);
            printf("\tPrimaryGroupId: %u\n", ClientInfo->PrimaryGroupId);
            printf("\tGroupCount: %u\n", ClientInfo->GroupCount);
            printf("\tGroupIds:\n");
            PrintGroupRID("\t\t", ClientInfo->GroupIds, ClientInfo->GroupCount);
            PrintSid("\tResourceGroupDomainSid: ", ClientInfo->ResourceGroupDomainSid);
            printf("\tResourceGroupCount: %u\n", ClientInfo->ResourceGroupCount);
            printf("\tResourceGroupIds:\n");
            PrintGroupRID("\t\t", ClientInfo->ResourceGroupIds, ClientInfo->ResourceGroupCount);
            printf("\tSidCount: %u\n", ClientInfo->SidCount);
            printf("\tExtraSids:\n");
            PrintGroup("\t\t", ClientInfo->ExtraSids, ClientInfo->SidCount);
        }
        break;

    case PAC_CREDENTIAL_TYPE:
        printf("PAC_CREDENTIAL_TYPE");
        break;

    case PAC_CLIENT_INFO_TYPE:
        CInfo = (PPAC_CLIENT_INFO) Info->Data;
        printf("PAC_CLIENT_INFO_TYPE: Id=%x.%x name=\"%*S\"",
               CInfo->ClientId.HighPart,
               CInfo->ClientId.LowPart,
               (CInfo->NameLength/sizeof(WCHAR)),
               CInfo->Name
               );
        break;

    case PAC_SERVER_CHECKSUM:
        Sig = (PPAC_SIGNATURE_DATA) Info->Data;
        printf("PAC_SERVER_CHECKSUM: cksum=%d data(%d)=",
               Sig->SignatureType,
               PAC_CHECKSUM_SIZE(Info->cbBufferSize));
        PrintBytes(Sig->Signature, PAC_CHECKSUM_SIZE(Info->cbBufferSize));
        break;

    case PAC_PRIVSVR_CHECKSUM:
        Sig = (PPAC_SIGNATURE_DATA) Info->Data;
        printf("PAC_PRIVSVR_CHECKSUM: cksum=%d data(%d)=",
               Sig->SignatureType,
               PAC_CHECKSUM_SIZE(Info->cbBufferSize));
        PrintBytes(Sig->Signature, PAC_CHECKSUM_SIZE(Info->cbBufferSize));
        break;

    default:
        printf("Unknown tag (%d), (%d): ", Tag, Info->cbBufferSize);
        PrintBytes(Info->Data, Info->cbBufferSize);
        break;
    }

    printf("\n");
}

VOID
PrintPac(
    IN PKERB_AUTHORIZATION_DATA AuthData,
    IN PKERB_ENCRYPTION_KEY Key
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_IF_RELEVANT_AUTH_DATA *IfRelevant;
    const KERB_AUTHORIZATION_DATA * PacAuthData;
    PPACTYPE Pac;
    ULONG PacLen;
    UINT i;

    KerbErr = KerbGetPacFromAuthData(AuthData, &IfRelevant, &PacAuthData);
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("No PAC\n");
        return;
    }

    Pac = (PPACTYPE) PacAuthData->value.auth_data.value;
    PacLen = PacAuthData->value.auth_data.length;

    if (PAC_UnMarshal(Pac, PacLen) == 0)
    {
        printf("Failed to unmarshal PAC\n");
        return;
    }

    printf("\tPAC: version=%d cBuffers=%d\n", Pac->Version, Pac->cBuffers);

    if (KerbVerifyPacChecksum("\t", Pac, PacLen, Key)) {
        printf("\tPac server checksum valid\n");
    }

    printf("\n");

    for (i = 0; i < Pac->cBuffers; i++)
    {
        PPAC_INFO_BUFFER Info = &Pac->Buffers[i];

        printf("\t[%d] ",  i);
        PrintPacBuffer(Info);
    }

}

VOID
PrintTime(
    IN LPSTR Comment,
    IN PKERB_TIME Time
    )
{
    TimeStamp ConvertTime;

    printf( "%s : ", Comment );

    KerbConvertGeneralizedTimeToLargeInt(&ConvertTime, Time, 0);

    //
    // If the time is infinite,
    //  just say so.
    //
    if ( ConvertTime.HighPart == 0x7FFFFFFF && ConvertTime.LowPart == 0xFFFFFFFF ) {
        printf( "Infinite\n" );

    }
    else if ( ConvertTime.HighPart == 0 && ConvertTime.LowPart == 0 ) {
        printf( "0\n" );
    //
    // Otherwise print it more clearly
    //
    } else {

        SYSTEMTIME SystemTime;
        FILETIME LocalFileTime;

        FileTimeToLocalFileTime(
            (PFILETIME) &ConvertTime,
            &LocalFileTime
            );
        FileTimeToSystemTime(
            &LocalFileTime,
            &SystemTime
            );

        printf( "%ld/%ld/%ld %ld:%2.2ld:%2.2ld\n",
                SystemTime.wMonth,
                SystemTime.wDay,
                SystemTime.wYear,
                SystemTime.wHour,
                SystemTime.wMinute,
                SystemTime.wSecond );
    }

}

VOID
PrintTktFlags(
    PKERB_TICKET_FLAGS Flags
    )
{
    ULONG flags;

    flags = KerbConvertFlagsToUlong(Flags);

#define PrintFlag(f) \
    if (flags & KERB_TICKET_FLAGS_##f) printf(" %s", #f);

    PrintFlag(forwardable);
    PrintFlag(forwarded);
    PrintFlag(proxiable);
    PrintFlag(proxy);
    PrintFlag(may_postdate);
    PrintFlag(postdated);
    PrintFlag(renewable);
    PrintFlag(initial);
    PrintFlag(pre_authent);
    PrintFlag(hw_authent);
    PrintFlag(ok_as_delegate);
    PrintFlag(name_canonicalize);
    printf("\n");
}

VOID
PrintEType(
    IN INT etype
    )
{
    switch (etype)
    {
        case KERB_ETYPE_NULL:
            printf("NULL CS\n");
            break;
        case KERB_ETYPE_DES_CBC_CRC:
            printf("Kerberos DES-CBC-CRC\n");
            break;
        case KERB_ETYPE_DES_CBC_MD5:
            printf("Kerberos DES-CBC-MD5\n");
            break;
        case KERB_ETYPE_RC4_MD4:
            printf("RSADSI RC4-MD4\n");
            break;
        case KERB_ETYPE_RC4_PLAIN2:
            printf("RSADSI RC4-PLAIN\n");
            break;
        case KERB_ETYPE_RC4_LM:
            printf("RSADSI RC4-LM\n");
            break;
        case KERB_ETYPE_DES_PLAIN:
            printf("Kerberos DES-Plain\n");
            break;
        case KERB_ETYPE_RC4_HMAC_NT:
            printf("RSADSI RC4-HMAC(NT)\n");
            break;
        case KERB_ETYPE_RC4_PLAIN:
            printf("RSADSI RC4\n");
            break;
        case KERB_ETYPE_RC4_HMAC_NT_EXP:
            printf("RSADSI RC4-HMAC(NT)(Export)\n");
            break;
        case KERB_ETYPE_RC4_PLAIN_EXP:
            printf("RSADSI RC4(Export)\n");
            break;
        case KERB_ETYPE_RC4_HMAC_OLD:
            printf("RSADSI RC4-HMAC(Old)\n");
            break;
        default:
            printf("Unknown (%d)\n",etype);
            break;
    }
}

VOID
PrintBytes(
    IN PBYTE Bytes,
    IN UINT Len
    )
{
    UINT i;

    for (i = 0; i < Len; i++)
    {
        printf("%02x", Bytes[i]);
    }
    printf("\n");
}

VOID
PrintKey(
    IN PKERB_ENCRYPTION_KEY Key
    )
{
    PrintEType(Key->keytype); printf("\t\t");
    PrintBytes((PBYTE)Key->keyvalue.value, Key->keyvalue.length);
}

VOID
PrintPrincipal(
    IN PKERB_PRINCIPAL_NAME Principal,
    IN KERB_REALM Realm
    )
{
    UNICODE_STRING PrincipalString = {0};

    KerbConvertPrincipalNameToFullServiceString(
        &PrincipalString,
        Principal,
        Realm
        );

    printf("%wZ\n", &PrincipalString);

    KerbFreeString(&PrincipalString);
}

VOID
PrintResult(
    IN PKERB_KDC_REPLY Reply,
    IN PKERB_ENCRYPTED_KDC_REPLY ReplyEnc,
    IN PKERB_TICKET Ticket,
    IN PKERB_ENCRYPTED_TICKET TicketEnc,
    IN PKERB_ENCRYPTION_KEY Key
    )
{
    if (Reply)
    {
        printf("Reply:\n");
        printf("\tversion=%d\n", Reply->version);
        if (Reply->bit_mask & KERB_KDC_REPLY_preauth_data_present)
        {
            printf("preauth_data: 0x%p\n", Reply->preauth_data);
        }

        printf("\tclient_name@realm: ");
        PrintPrincipal(&Reply->client_name, Reply->client_realm);

        printf("\tencrypted_part: ");
        if (Reply->encrypted_part.bit_mask & version_present)
            printf("kvno=%d ", Reply->encrypted_part.version);
        PrintEType(Reply->encrypted_part.encryption_type);
    }

    if (ReplyEnc)
    {
        printf("Reply (encpart):\n");
        printf("\tnonce=%lu\n", ReplyEnc->nonce);
        printf("\tsession_key: "); PrintKey(&ReplyEnc->session_key);
        // ReplyEnc->last_request

        if (ReplyEnc->bit_mask & key_expiration_present)
        {
            PrintTime("\tkey_expiration ", &ReplyEnc->key_expiration);
        }
        PrintTime("\tauthtime ", &ReplyEnc->authtime);
        if (ReplyEnc->bit_mask & KERB_ENCRYPTED_KDC_REPLY_starttime_present)
        {
            PrintTime("\tstarttime ", &ReplyEnc->starttime);
        }
        PrintTime("\tendtime ", &ReplyEnc->endtime);
        if (ReplyEnc->bit_mask & KERB_ENCRYPTED_KDC_REPLY_renew_until_present)
        {
            PrintTime("\trenew_until ", &ReplyEnc->renew_until);
        }
        printf("\tflags: "); PrintTktFlags(&ReplyEnc->flags);
        printf("\tserver_name@realm: ");
        PrintPrincipal(&ReplyEnc->server_name, ReplyEnc->server_realm);
        if (ReplyEnc->bit_mask & KERB_ENCRYPTED_KDC_REPLY_client_addresses_present)
        {
            printf("\tclient_addresses: 0x%p\n", ReplyEnc->client_addresses);
        }
        if (ReplyEnc->bit_mask & encrypted_pa_data_present)
        {
            printf("\tencrypted_pa_data: 0x%p\n",  ReplyEnc->encrypted_pa_data);
        }
    }

    if (Ticket)
    {
        printf("Ticket:\n");
        printf("\tserver_name@realm: ");
        PrintPrincipal(&Ticket->server_name, Ticket->realm);
        if (Ticket->bit_mask & ticket_extensions_present)
        {
            printf("\tticket_extensions: 0x%p\n", Ticket->ticket_extensions);
        }
        printf("\tencrypted_part: ");
        if (Ticket->encrypted_part.bit_mask & version_present)
            printf("kvno=%d ", Ticket->encrypted_part.version);
        PrintEType(Ticket->encrypted_part.encryption_type);
    }

    if (TicketEnc)
    {
        printf("Ticket (enc):\n");
        printf("\tflags: ");PrintTktFlags(&TicketEnc->flags);
        printf("\tkey: "); PrintKey(&TicketEnc->key);
        printf("\tclient_name@realm: ");
        PrintPrincipal(&TicketEnc->client_name, TicketEnc->client_realm);
        //  transited
        PrintTime("\tauthtime ", &TicketEnc->authtime);
        if (TicketEnc->bit_mask & KERB_ENCRYPTED_TICKET_starttime_present)
        {
            PrintTime("\tstarttime ", &TicketEnc->starttime);
        }
        PrintTime("\tendtime ", &TicketEnc->endtime);
        if (TicketEnc->bit_mask & KERB_ENCRYPTED_TICKET_renew_until_present)
        {
            PrintTime("\trenew_until ", &TicketEnc->renew_until);
        }
        if (TicketEnc->bit_mask & KERB_ENCRYPTED_TICKET_client_addresses_present)
        {
            printf("\tclient_addresses: 0x%p\n", TicketEnc->client_addresses);
        }
        if (TicketEnc->bit_mask & KERB_ENCRYPTED_TICKET_authorization_data_present)
        {
            printf("\tauthorization_data: 0x%p\n", TicketEnc->authorization_data);
            PrintPac(TicketEnc->authorization_data, Key);
        }
    }
}


BOOLEAN
KerbVerifyPacChecksum(
    IN CHAR *Comment,
    IN PPACTYPE Pac,
    IN ULONG PacSize,
    IN PKERB_ENCRYPTION_KEY EncryptionKey
    )
{
    NTSTATUS Status;
    PCHECKSUM_FUNCTION Check = NULL ;
    PCHECKSUM_BUFFER CheckBuffer = NULL;
    PPAC_SIGNATURE_DATA ServerSignature = NULL;
    PPAC_SIGNATURE_DATA PrivSvrSignature = NULL;
    PPAC_INFO_BUFFER ServerBuffer = NULL;
    PPAC_INFO_BUFFER PrivSvrBuffer = NULL;
    UCHAR LocalChecksum[20];
    UCHAR LocalServerChecksum[20];
    UCHAR LocalPrivSvrChecksum[20];
    BOOLEAN Retval = FALSE;

    if (EncryptionKey == NULL)
        return FALSE;

    ServerBuffer = PAC_Find(
                        Pac,
                        PAC_SERVER_CHECKSUM,
                        NULL
                        );

    PrivSvrBuffer = PAC_Find(
                        Pac,
                        PAC_PRIVSVR_CHECKSUM,
                        NULL
                        );

    if ((ServerBuffer == NULL) || (PrivSvrBuffer == NULL))
    {

        printf("%sPac found with no signature!\n", Comment);
        goto Cleanup;
    }


    //
    // Now verify the server checksum. First compute the checksum
    // over the logon info.
    //

    ServerSignature = (PPAC_SIGNATURE_DATA) ServerBuffer->Data;
    if ((sizeof(*ServerSignature) > ServerBuffer->cbBufferSize) ||
        (PAC_CHECKSUM_SIZE(ServerBuffer->cbBufferSize) > sizeof(LocalServerChecksum)))
    {
        printf("%sInvalid server signature\n", Comment);
        goto Cleanup;
    }

    PrivSvrSignature = (PPAC_SIGNATURE_DATA) PrivSvrBuffer->Data;
    if ((sizeof(*PrivSvrSignature) > PrivSvrBuffer->cbBufferSize) ||
        (PAC_CHECKSUM_SIZE(PrivSvrBuffer->cbBufferSize) > sizeof(LocalPrivSvrChecksum)))

    {
        printf("%sInvalid KDC signature\n", Comment);
        goto Cleanup;
    }

    //
    // Copy out the signature so we can zero the signature fields before
    // checksumming
    //

    memcpy(
        LocalServerChecksum,
        ServerSignature->Signature,
        PAC_CHECKSUM_SIZE(ServerBuffer->cbBufferSize)
        );

    ZeroMemory(
        ServerSignature->Signature,
        PAC_CHECKSUM_SIZE(ServerBuffer->cbBufferSize)
        );

    memcpy(
        LocalPrivSvrChecksum,
        PrivSvrSignature->Signature,
        PAC_CHECKSUM_SIZE(PrivSvrBuffer->cbBufferSize)
        );
    ZeroMemory(
        PrivSvrSignature->Signature,
        PAC_CHECKSUM_SIZE(PrivSvrBuffer->cbBufferSize)
        );

    //
    // Now remarshal the PAC before checksumming.
    //

    if (!PAC_ReMarshal(Pac,PacSize))
    {
        printf("%sPAC_Remarhsal failed\n", Comment);
        return FALSE;
    }

    //
    // Locate the checksum of the logon info & compute it.
    //

    Status = CDLocateCheckSum(
                ServerSignature->SignatureType,
                &Check
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if (Check->CheckSumSize > sizeof(LocalChecksum))
    {
        goto Cleanup;
    }

    //
    // if available use the Ex2 version for keyed checksums where checksum
    // must be passed in on verification
    //
    if (NULL != Check->InitializeEx2)
    {
        Status = Check->InitializeEx2(
                    EncryptionKey->keyvalue.value,
                    EncryptionKey->keyvalue.length,
                    LocalServerChecksum,
                    KERB_NON_KERB_CKSUM_SALT,
                    &CheckBuffer
                    );
    }
    else
    {
        Status = Check->InitializeEx(
                    EncryptionKey->keyvalue.value,
                    EncryptionKey->keyvalue.length,
                    KERB_NON_KERB_CKSUM_SALT,
                    &CheckBuffer
                    );
    }

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Check->Sum(
        CheckBuffer,
        PacSize,
        (PUCHAR) Pac
        );

    Check->Finalize(
        CheckBuffer,
        LocalChecksum
        );

    Check->Finish(&CheckBuffer);

    //
    // Put back the original sums
    //

    memcpy(
        ServerSignature->Signature,
        LocalServerChecksum,
        PAC_CHECKSUM_SIZE(ServerBuffer->cbBufferSize)
        );

    memcpy(
        PrivSvrSignature->Signature,
        LocalPrivSvrChecksum,
        PAC_CHECKSUM_SIZE(PrivSvrBuffer->cbBufferSize)
        );

    //
    // Now compare the local checksum to the supplied checksum.
    //

    if (Check->CheckSumSize != PAC_CHECKSUM_SIZE(ServerBuffer->cbBufferSize))
    {
        printf("%sChecksum size wrong %d != %d\n",
               Comment,
               Check->CheckSumSize,
               PAC_CHECKSUM_SIZE(ServerBuffer->cbBufferSize)
               );
        goto Cleanup;
    }

    if (memcmp(
            LocalChecksum,
            LocalServerChecksum,
            Check->CheckSumSize
            ))
    {
        printf("%sServer checksum on the PAC does not match : ", Comment);
        PrintBytes(LocalChecksum, Check->CheckSumSize);
        goto Cleanup;
    }

    Retval = TRUE;

Cleanup:
    //
    // Now unmarshal the PAC so that the caller will have it back the
    // way they started.
    //

    if (!PAC_UnMarshal(Pac,PacSize))
    {
        printf("%sPAC_UnMarshal failed\n", Comment);
        Retval = FALSE;
    }

    return Retval;
}


NTSTATUS
KerbAddPacRequestPreAuth(
    OUT PKERB_PA_DATA_LIST * PreAuthData,
    IN BOOLEAN AddPac,
    IN BOOLEAN OldPac
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_PA_DATA_LIST ListElement = NULL;
    PKERB_PA_DATA_LIST LastElement = NULL;
    KERB_PA_PAC_REQUEST PacRequest = {0};
    KERB_PA_PAC_REQUEST_EX PacRequestEx = {0};
    KERB_PA_PAC_REQUEST_EX_pac_sections_Element PacSections[2] = {0,0};

    ListElement = (PKERB_PA_DATA_LIST) MIDL_user_allocate(sizeof(KERB_PA_DATA_LIST));
    if (ListElement == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    if (OldPac)
        PacRequest.include_pac = AddPac;
    else
        PacRequestEx.include_pac = AddPac;

    if (AddPac && !OldPac)
    {
        PacRequestEx.bit_mask = pac_sections_present;
        PacRequestEx.pac_sections = &PacSections[0];

#if 0
        PacSections[0].next = &PacSections[1];
        PacSections[1].next = NULL;

        PacSections[0].value = PAC_LOGON_INFO;
        PacSections[1].value = PAC_CLIENT_INFO_TYPE;
#else
        PacSections[0].next = NULL;
        PacSections[0].value = PAC_LOGON_INFO; //PAC_CLIENT_INFO_TYPE;
#endif
    }

    //
    // Marshall the type into the list element.
    //

    if (!KERB_SUCCESS(KerbPackData(
                        (OldPac)? (&PacRequest) : (PKERB_PA_PAC_REQUEST)(&PacRequestEx),
                        (OldPac)? KERB_PA_PAC_REQUEST_PDU : KERB_PA_PAC_REQUEST_EX_PDU,
                        (PULONG) &ListElement->value.preauth_data.length,
                        (PUCHAR *) &ListElement->value.preauth_data.value
                        )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    if (OldPac)
        ListElement->value.preauth_data_type = KRB5_PADATA_PAC_REQUEST;
    else
        ListElement->value.preauth_data_type = KRB5_PADATA_PAC_REQUEST_EX;

    //
    // We want this to go at the end, so that it will override any other
    // pa-data that may enable a PAC.
    //

    LastElement = *PreAuthData;
    if (LastElement != NULL)
    {
        while (LastElement->next != NULL)
        {
            LastElement = LastElement->next;
        }
        LastElement->next = ListElement;
    }
    else
    {
        *PreAuthData = ListElement;
    }

    ListElement->next = NULL;
    ListElement = NULL;

Cleanup:
    if (ListElement != NULL)
    {
        KerbFreePreAuthData(
            ListElement
            );
    }

    return(Status);
}

NTSTATUS
KerbAddEncTimestampPreAuth(
    OUT PKERB_PA_DATA_LIST * PreAuthData,
    PKERB_ENCRYPTION_KEY UserKey,
    IN PTimeStamp TimeSkew
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_PA_DATA_LIST ListElement = NULL;
    KERB_ENCRYPTED_TIMESTAMP Timestamp = {0};
    TimeStamp CurrentTime;
    PBYTE EncryptedTime = NULL;
    ULONG EncryptedTimeSize = 0;
    KERB_ENCRYPTED_DATA EncryptedData;
    KERBERR KerbErr;

    ListElement = (PKERB_PA_DATA_LIST) MIDL_user_allocate(sizeof(KERB_PA_DATA_LIST));
    if (ListElement == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Now build the encrypted timestamp
    //

    GetSystemTimeAsFileTime((PFILETIME) &CurrentTime);

    KerbSetTime(&CurrentTime, KerbGetTime(CurrentTime) + KerbGetTime(*TimeSkew));

    KerbConvertLargeIntToGeneralizedTime(
        &Timestamp.timestamp,
        &Timestamp.KERB_ENCRYPTED_TIMESTAMP_usec,
        &CurrentTime
        );

    Timestamp.bit_mask = KERB_ENCRYPTED_TIMESTAMP_usec_present;

    KerbErr = KerbPackEncryptedTime(
                 &Timestamp,
                 &EncryptedTimeSize,
                 &EncryptedTime
                 );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Now encrypt the time
    //

    KerbErr = KerbAllocateEncryptionBufferWrapper(
                 g_pIKerbCrypt,
                 UserKey->keytype,
                 EncryptedTimeSize,
                 &EncryptedData.cipher_text.length,
                 &EncryptedData.cipher_text.value
                 );

    if (!KERB_SUCCESS(KerbErr))
    {
        MIDL_user_free(EncryptedTime);
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    KerbErr = KerbEncryptDataEx(
                 &EncryptedData,
                 EncryptedTimeSize,
                 EncryptedTime,
                 UserKey->keytype,
                 KERB_NO_KEY_VERSION,
                 KERB_ENC_TIMESTAMP_SALT,
                 UserKey
                 );
    MIDL_user_free(EncryptedTime);

    if (!KERB_SUCCESS(KerbErr))
    {
        MIDL_user_free(EncryptedData.cipher_text.value);
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Marshall the type into the list element.
    //

    KerbErr = KerbPackEncryptedData(
                 &EncryptedData,
                 (PULONG) &ListElement->value.preauth_data.length,
                 (PUCHAR *) &ListElement->value.preauth_data.value
                 );

    MIDL_user_free(EncryptedData.cipher_text.value);

    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    ListElement->value.preauth_data_type = KRB5_PADATA_ENC_TIMESTAMP;

    ListElement->next = *PreAuthData;
    *PreAuthData = ListElement;
    ListElement = NULL;

Cleanup:
    if (ListElement != NULL)
    {
        KerbFreePreAuthData(
            ListElement
            );
    }

    return(Status);
}

BOOLEAN
BindToKdc()
{
    if (KdcName.Buffer == NULL)
    {
#if 0
        ULONG NetStatus;
        PDOMAIN_CONTROLLER_INFO DcInfo = NULL;

        // Need to LoadLibrary advapi32.dll to avoid WinXP dependencies

        //
        // No kdc specified, use DSGetDCName
        //

        NetStatus = DsGetDcName(
                        NULL,
                        ClientRealm.Buffer,
                        NULL,
                        NULL,
                        DS_KDC_REQUIRED,
                        &DcInfo
                        );
        if (NetStatus != NO_ERROR)
        {
            printf("DsGetDcName returned %d\n",NetStatus);
            return(FALSE);
        }

        RtlInitUnicodeString(
            &KdcName,
            DcInfo->DomainControllerAddress+2
            );

        AddressType = DcInfo->DomainControllerAddressType;
#else
        printf("You need to specify a KDC with the -kdc argument\n");
        return(FALSE);
#endif

    }
    return(TRUE);
}

//+---------------------------------------------------------------------------
//
//  Function:   KerbUnpackTicket
//
//  Synopsis:   Decrypts and unpacks the encyrpted part of aticket.
//
//  Effects:    Allocates memory, decrypts pktTicket in place
//
//  Arguments:  [PackedTicket]  -- ticket to unpack
//              [PackedTicketSize] -- length of packed ticket
//              [pkKey]      -- key to unpack it with
//              [InternalTicket] -- (out) unpacked ticket
//
//  Returns:    KDC_ERR_NONE or error from decrypt
//
//  Signals:    Any exception the MIDL unpacking code throws.
//
//  History:    09-Jun-93   WadeR   Created
//
//  Notes:      Free InternalTicket with KerbFreeTicket, below.
//
//----------------------------------------------------------------------------

KERBERR NTAPI
KerbUnpackTicket(
    IN PKERB_TICKET PackedTicket,
    IN PKERB_ENCRYPTION_KEY pkKey,
    OUT PKERB_ENCRYPTED_TICKET * InternalTicket
    )
{
    KERBERR   KerbErr = KDC_ERR_NONE;
    PUCHAR EncryptedPart = NULL;
    ULONG EncryptSize;
    PKERB_ENCRYPTED_TICKET EncryptedTicket = NULL;


    //
    // Now decrypt the encrypted part of the ticket
    //

    EncryptedPart = (PUCHAR) MIDL_user_allocate(PackedTicket->encrypted_part.cipher_text.length);
    if (EncryptedPart == NULL)
    {
        return(KRB_ERR_GENERIC);
    }

    EncryptSize = PackedTicket->encrypted_part.cipher_text.length;
    KerbErr = KerbDecryptDataEx(
                &PackedTicket->encrypted_part,
                pkKey,
                KERB_TICKET_SALT,
                &EncryptSize,
                EncryptedPart
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to decrypt ticket: 0x%x\n",KerbErr);

#if DBG

        //
        // Who's this ticket *supposed* to be for?
        //
        KerbPrintPrincipalName(DEB_ERROR, &PackedTicket->server_name);
        KerbPrintKerbRealm(DEB_ERROR, &PackedTicket->realm);

#endif

        goto Cleanup;
    }

    KerbErr = KerbUnpackData(
                EncryptedPart,
                EncryptSize,
                KERB_ENCRYPTED_TICKET_PDU,
                (PVOID *) &EncryptedTicket
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to unmarshall ticket: 0x%x\n",KerbErr);
        goto Cleanup;
    }

    *InternalTicket = EncryptedTicket;
Cleanup:
    if (EncryptedPart != NULL)
    {
        MIDL_user_free(EncryptedPart);
    }
    return(KerbErr);
}


NTSTATUS
KerbAddCompoundIdentityPreAuth(
    IN PKERB_ENCRYPTION_KEY ClientKey,
    IN PKERB_TICKET pTicket,
    //IN PXKERB_TGT_CONTEXT pSingleTGTContexts, // Array of dwNumTGT
    IN OUT PKERB_PA_DATA_LIST * PreAuthData
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_PA_DATA_LIST ListElement;
    KERB_ENCRYPTED_DATA EncryptedData;

    //  unreferenced
    ClientKey;

    //RIP_ON_NOT_TRUE("KerbAddIdentityPreAuth", (pSingleTGTContexts != NULL));

    ZeroMemory( &EncryptedData, sizeof(KERB_ENCRYPTED_DATA) );

    ListElement = (PKERB_PA_DATA_LIST) MIDL_user_allocate(sizeof(KERB_PA_DATA_LIST));
    if (ListElement == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Stick the ticket into the ticket list.
    //
    //  to make it interesting, pack multiple creds
    //  this could be made cmdline param ...
    PKERB_PA_COMPOUND_IDENTITY TicketList = (PKERB_PA_COMPOUND_IDENTITY)
        _alloca(sizeof(KERB_PA_COMPOUND_IDENTITY_Element) * NumPaIds);

    for (LONG iTicket = 0; iTicket < NumPaIds; iTicket++)
    {
        TicketList[iTicket].value = *pTicket;
        //  point to the next, last one points to NULL
        TicketList[iTicket].next = iTicket < NumPaIds - 1 ?
                &TicketList[iTicket + 1] : NULL;
    }


    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to KerbBuildKerbCompoundCred\n");
        Status = KerbErr;
        goto Cleanup;
    }

    KerbErr = KerbPackData(&TicketList,
                           KERB_PA_COMPOUND_IDENTITY_PDU,
                           &ListElement->value.preauth_data.length,
                           &ListElement->value.preauth_data.value);

    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto    Cleanup;
    }

    ListElement->value.preauth_data_type = KRB5_PADATA_COMPOUND_IDENTITY;
    ListElement->next = *PreAuthData;
    *PreAuthData = ListElement;

Cleanup:
    return(Status);
}

BOOLEAN
GetAnAsTicket(
    IN PUNICODE_STRING ServerName,
    OUT PKERB_TICKET Ticket,
    OUT PKERB_ENCRYPTED_KDC_REPLY * ReplyBody,
    OUT PKERB_KDC_REPLY * Reply
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_ENCRYPTION_KEY UserKey;
    KERB_MESSAGE_BUFFER InputMessage;
    KERB_MESSAGE_BUFFER OutputMessage;
    KERB_KDC_REQUEST Request;
    PKERB_KDC_REQUEST_BODY RequestBody;
    ULONG CryptArray[KERB_MAX_CRYPTO_SYSTEMS];
    ULONG CryptArraySize;
    UNICODE_STRING FullServiceName;
//  UNICODE_STRING FullClientName;
    PKERB_ERROR ErrorMessage = NULL;
    LARGE_INTEGER TempTime;
    ULONG KdcFlagOptions = 0;
    ULONG KdcOptions = 0;

    ZeroMemory(
        &OutputMessage,
        sizeof(KERB_MESSAGE_BUFFER)
        );

    ZeroMemory(
        &InputMessage,
        sizeof(KERB_MESSAGE_BUFFER)
        );



    //
    // Build the request
    //

    ZeroMemory(
        &Request,
        sizeof( KERB_KDC_REQUEST )
        );
    RequestBody = &Request.request_body;

    KdcOptions =
                            KERB_KDC_OPTIONS_forwardable |
                            KERB_KDC_OPTIONS_proxiable |
                            KERB_KDC_OPTIONS_renewable |
                            KERB_KDC_OPTIONS_renewable_ok;

    if (NameCanonicalize)
    {
        KdcOptions |= KERB_KDC_OPTIONS_name_canonicalize;
    }

    KdcFlagOptions = KerbConvertUlongToFlagUlong(KdcOptions);
    RequestBody->kdc_options.value = (PUCHAR) &KdcFlagOptions ;
    RequestBody->kdc_options.length = sizeof(ULONG) * 8;

    RequestBody->nonce = 3;

    TempTime.QuadPart = 0;

    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->KERB_KDC_REQUEST_BODY_starttime,
        NULL,
        &TempTime
        );


    TempTime.LowPart = 0xffffffff;
    TempTime.HighPart = 0x7fffffff;
    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->KERB_KDC_REQUEST_BODY_renew_until,
        NULL,
        &TempTime
        );
    RequestBody->bit_mask |= KERB_KDC_REQUEST_BODY_renew_until_present;

    TempTime.QuadPart = 0;
    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->endtime,
        NULL,
        &TempTime
        );

    //
    // Build crypt vector.
    //

    CryptArraySize = KERB_MAX_CRYPTO_SYSTEMS;
    CDBuildVect( &CryptArraySize, CryptArray );

    KerbErr = KerbConvertArrayToCryptList(
                    &RequestBody->encryption_type,
                    CryptArray,
                    CryptArraySize
                    );

    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to convert array to crypt list: 0x%x\n",KerbErr);
        goto Cleanup;
    }

    //
    // BUGBUG: don't build pre-auth data
    //


    KerbBuildFullServiceName(
        &ClientRealm,
        ServerName,
        &FullServiceName
        );

    KerbErr = KerbConvertStringToPrincipalName(
                    &RequestBody->KERB_KDC_REQUEST_BODY_server_name,
                    &FullServiceName,
                    KRB_NT_SRV_INST
                    );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to convert string to principal name: 0x%x\n",KerbErr);
        goto Cleanup;

    }

    RequestBody->bit_mask |= KERB_KDC_REQUEST_BODY_server_name_present;
#if 0
    KerbBuildFullServiceName(
        &ClientRealm,
        &ClientName,
        &FullClientName
        );
    KerbErr = KerbConvertStringToPrincipalName(
                &RequestBody->KERB_KDC_REQUEST_BODY_client_name,
                &FullClientName,
                KRB_NT_PRINCIPAL
                );
#else
    KerbErr = KerbConvertStringToPrincipalName(
                &RequestBody->KERB_KDC_REQUEST_BODY_client_name,
                &ClientName,
                NameCanonicalize?KRB_NT_MS_PRINCIPAL:KRB_NT_PRINCIPAL
                );
#endif
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to convert string to principal name: 0x%x\n",KerbErr);
        goto Cleanup;
    }

    RequestBody->bit_mask |= KERB_KDC_REQUEST_BODY_client_name_present;

    KerbErr = KerbConvertUnicodeStringToRealm(
                &RequestBody->realm,
                &ClientRealm
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to convert unicde string to realm: 0x%x\n",KerbErr);
        goto Cleanup;
    }

    Request.version = KERBEROS_VERSION;
    Request.message_type = KRB_AS_REQ;

    if (!NoEncTimeStamp)
    {
        KerbErr = KerbHashPassword(
                     g_pIKerbCrypt,
                     &ClientPassword,
                     CryptType,
                     &UserKey
                     );
        if (!KERB_SUCCESS(KerbErr))
        {
            printf("Failed to hash password with 0x%x alg\n", CryptType);
            goto Cleanup;
        }

        TimeStamp TimeSkew = {0};

        Status = KerbAddEncTimestampPreAuth(
                    &Request.KERB_KDC_REQUEST_preauth_data,
                    UserKey,
                    &TimeSkew
                    );

        if (!NT_SUCCESS(Status))
        {
            printf("KerbAddEncTimeStampPreAuth failed: 0x%x\n",Status);
            goto Cleanup;
        }
    }

    if (RequestPAC != -1)
    {
        Status = KerbAddPacRequestPreAuth(
                    &Request.KERB_KDC_REQUEST_preauth_data,
                    (RequestPAC == TRUE),
                    FALSE       // New PAC
                    );

        if (!NT_SUCCESS(Status))
        {
            printf("KerbAddPacRequestPreAuth failed: 0x%x\n",Status);
            goto Cleanup;
        }
    }

    if (Request.KERB_KDC_REQUEST_preauth_data != NULL)
    {
        Request.bit_mask |= KERB_KDC_REQUEST_preauth_data_present;
    }

    KerbErr = KerbPackAsRequest(
                &Request,
                &InputMessage.BufferSize,
                &InputMessage.Buffer
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to pack KDC request: 0x%x\n",KerbErr);
        goto Cleanup;
    }


    Status = KerbCallKdc(
                &KdcName,
                AddressType,
                10,
                UseDg,
                88,
                &InputMessage,
                &OutputMessage
                );


    if (!NT_SUCCESS(Status))
    {
        printf("KerbCallKdc failed: 0x%x\n",Status);
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    KerbErr = KerbUnpackAsReply(
                OutputMessage.Buffer,
                OutputMessage.BufferSize,
                Reply
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        KERBERR OldKerbErr = KerbErr;

        KerbErr = KerbUnpackKerbError(
                    OutputMessage.Buffer,
                    OutputMessage.BufferSize,
                    &ErrorMessage
                    );
        if (KERB_SUCCESS(KerbErr))
        {
            printf("Kerb-Error: Failed to get AS ticket: 0x%x\n",ErrorMessage->error_code);
            KerbErr = (KERBERR) ErrorMessage->error_code;
        }
        else
        {
            printf("Failed to unpack KDC reply: 0x%x\n", OldKerbErr);
            KerbErr = OldKerbErr;
        }

        goto Cleanup;
    }

    KerbErr = KerbHashPassword(
                g_pIKerbCrypt,
                &ClientPassword,
                (*Reply)->encrypted_part.encryption_type,
                &UserKey
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to hash password with 0x%x alg\n",(*Reply)->encrypted_part.encryption_type);
        goto Cleanup;
    }

#ifdef SHOW_KEYS
    printf("UserKey: ");
    PrintKey(UserKey);
#endif

    KerbErr = KerbUnpackKdcReplyBody(
                &(*Reply)->encrypted_part,
                UserKey,
                KERB_ENCRYPTED_AS_REPLY_PDU,
                ReplyBody
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to unpack KDC reply body: 0x%x\n",KerbErr);
        goto Cleanup;
    }


    *Ticket = (*Reply)->ticket;

Cleanup:

    //
    // BUGBUG: memory leak here
    //

    if (KERB_SUCCESS(KerbErr))
    {
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}

extern NTSTATUS NTAPI  KerbComputePaCompIdentityKey(
                                   IN  OUT PKERB_ENCRYPTION_KEY pSessionKey,
                                   IN   ULONG                cKeys,
                                   IN const KERB_ENCRYPTION_KEY *ppPAKeys
                                    );

BOOLEAN
GetATgsTicket(
    IN PKERB_TICKET TicketGrantingTicket,
    IN PKERB_ENCRYPTED_KDC_REPLY TgtReplyBody,
    IN PKERB_KDC_REPLY TgtReply,
    IN BOOLEAN Renew,
    OUT PKERB_TICKET Ticket,
    OUT PKERB_ENCRYPTED_KDC_REPLY * ReplyBody,
    OUT PKERB_KDC_REPLY * Reply,
    OUT PKERB_ENCRYPTED_TICKET *TicketBody,
    OUT PKERB_ENCRYPTION_KEY *Key
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERB_KDC_REQUEST Request;
    PKERB_KDC_REQUEST_BODY RequestBody = &Request.request_body;
    PKERB_INTERNAL_NAME FullClientName;
    KERBERR KerbErr = KDC_ERR_NONE;
    KERB_PA_DATA_LIST  PaData;
    ULONG CryptArray[KERB_MAX_CRYPTO_SYSTEMS];
    ULONG CryptArraySize = 0;
    LARGE_INTEGER TempTime;
    KERB_MESSAGE_BUFFER InputMessage;
    KERB_MESSAGE_BUFFER OutputMessage;
    PKERB_ERROR ErrorMessage = NULL;
    ULONG KdcFlagOptions = 0;
    ULONG KdcOptions = 0;
    static PKERB_ENCRYPTION_KEY ServiceKey;

    //
    // Build the request
    //

    ZeroMemory( &Request, sizeof( KERB_KDC_REQUEST ) );

    KdcOptions =
        KERB_KDC_OPTIONS_forwardable |
        KERB_KDC_OPTIONS_proxiable |
        KERB_KDC_OPTIONS_renewable |
        KERB_KDC_OPTIONS_renewable_ok |
        ((RequestReferrals == TRUE)?KERB_KDC_OPTIONS_name_canonicalize:0);

    if (Renew)
    {
        KdcOptions |= KERB_KDC_OPTIONS_renew;
    }


    KdcFlagOptions = KerbConvertUlongToFlagUlong(KdcOptions);
    RequestBody->kdc_options.value = (PUCHAR) &KdcFlagOptions ;
    RequestBody->kdc_options.length = sizeof(ULONG) * 8;



    RequestBody->nonce = 4;

    //
    // Build an AP request inside an encrypted data structure.
    //

    KerbConvertPrincipalNameToKdcName(
        &FullClientName,
        &TgtReply->client_name
        );

    PaData.next = NULL;
    PaData.value.preauth_data_type = KRB5_PADATA_TGS_REQ;

    //Get all the session keys
    PKERB_ENCRYPTION_KEY SessionKeyList = (PKERB_ENCRYPTION_KEY)
        _alloca(sizeof(KERB_ENCRYPTION_KEY) * NumPaIds);
    for (LONG iCred = 0; iCred < NumPaIds; iCred++)
    {
        SessionKeyList[iCred] = TgtReplyBody->session_key;
    }

    if (NumPaIds)
    {
        Status = KerbComputePaCompIdentityKey(
                    &TgtReplyBody->session_key,
                    NumPaIds,
                    SessionKeyList
                    );

        if (!NT_SUCCESS(Status))
        {
            KerbErr = KRB_ERR_GENERIC; //TODO: Find appropriate error code
            goto Cleanup;
        }
    }

    KerbErr = KerbCreateApRequest(
                g_pIKerbCrypt,
                FullClientName,
                &ClientRealm,
                &TgtReplyBody->session_key,
                NULL,                           // no sub session key
                5,                              // nonce
                TicketGrantingTicket,
                0,                              // AP options
                NULL,                           // gss checksum
                NULL,                           // server time
                TRUE,                           // KDC request
                (PULONG) &PaData.value.preauth_data.length,
                &PaData.value.preauth_data.value
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to create AP request: 0x%x\n",KerbErr);
        goto Cleanup;
    }

    Request.KERB_KDC_REQUEST_preauth_data = &PaData;
    Request.bit_mask |= KERB_KDC_REQUEST_preauth_data_present;

    //
    // Build crypt vector.
    //

    CDBuildVect( &CryptArraySize, CryptArray );

    KerbErr = KerbConvertArrayToCryptList(
                    &RequestBody->encryption_type,
                    CryptArray,
                    CryptArraySize
                    );

    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to convert array to crypt list: 0x%x\n",KerbErr);
        goto Cleanup;
    }


    KerbErr = KerbDuplicatePrincipalName(
                    &RequestBody->KERB_KDC_REQUEST_BODY_client_name,
                    &TgtReply->client_name
                    );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    RequestBody->bit_mask |= KERB_KDC_REQUEST_BODY_client_name_present;

    KerbErr = KerbConvertUnicodeStringToRealm(
                &RequestBody->realm,
                &ServiceRealm
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }


    KerbErr = KerbConvertStringToPrincipalName(
                &RequestBody->KERB_KDC_REQUEST_BODY_server_name,
                &ServiceName,
                KRB_NT_PRINCIPAL
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }
    RequestBody->bit_mask |= KERB_KDC_REQUEST_BODY_server_name_present;


    TempTime.QuadPart = 0;

    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->KERB_KDC_REQUEST_BODY_starttime,
        NULL,
        &TempTime
        );

    TempTime.LowPart = 0xffffffff;
    TempTime.HighPart = 0x7fffffff;
    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->KERB_KDC_REQUEST_BODY_renew_until,
        NULL,
        &TempTime
        );
    RequestBody->bit_mask |= KERB_KDC_REQUEST_BODY_renew_until_present;


    TempTime.LowPart  = 0xffffffff;
    TempTime.HighPart = 0x7fffffff;

    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->endtime,
        NULL,
        &TempTime
        );

    //
    // Add PA-COMPOUND-IDENTITY pre-auth info
    //
    if (NumPaIds > 0)
    {
        Status = KerbAddCompoundIdentityPreAuth(
                    &TgtReplyBody->session_key,
                    TicketGrantingTicket,
                    &Request.KERB_KDC_REQUEST_preauth_data
                    );
        if (!NT_SUCCESS(Status))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
    }
    if (RequestPAC != -1)
    {
        Status = KerbAddPacRequestPreAuth(
                    &Request.KERB_KDC_REQUEST_preauth_data,
                    (RequestPAC == TRUE),
                    FALSE       // New PAC
                    );

        if (!NT_SUCCESS(Status))
        {
            printf("KerbAddPacRequestPreAuth failed: 0x%x\n",Status);
            goto Cleanup;
        }
    }

    Request.version = KERBEROS_VERSION;
    Request.message_type = KRB_TGS_REQ;


    KerbErr = KerbPackTgsRequest(
                &Request,
                &InputMessage.BufferSize,
                &InputMessage.Buffer
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to pack KDC request: 0x%x\n",KerbErr);
        goto Cleanup;
    }

    //
    // Get the ticket.
    //

    OutputMessage.Buffer = NULL;
    OutputMessage.BufferSize = 0;
    KerbErr = (KERBERR) KerbCallKdc(
                            &KdcName,
                            AddressType,
                            10,
                            UseDg,
                            88,
                            &InputMessage,
                            &OutputMessage
                            );


    if (!KERB_SUCCESS(KerbErr))
    {
        printf("KerbCallKdc failed: 0x%x\n",KerbErr);
        goto Cleanup;
    }

    KerbErr = KerbUnpackTgsReply(
                OutputMessage.Buffer,
                OutputMessage.BufferSize,
                Reply
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        KERBERR OldKerbErr = KerbErr;

        KerbErr = KerbUnpackKerbError(
                    OutputMessage.Buffer,
                    OutputMessage.BufferSize,
                    &ErrorMessage
                    );
        if (KERB_SUCCESS(KerbErr))
        {
            printf("Kerb-Error: Failed to get TGS ticket: 0x%x\n",ErrorMessage->error_code);
            KerbErr = (KERBERR) ErrorMessage->error_code;
        }
        else
        {
            printf("Failed to unpack KDC reply: 0x%x\n", OldKerbErr);
            KerbErr = OldKerbErr;
        }

        goto Cleanup;
    }

#ifdef SHOW_KEYS
    printf("TgtReplySessionKey: ");
    PrintKey(&TgtReplyBody->session_key);
#endif

    KerbErr = KerbUnpackKdcReplyBody(
                &(*Reply)->encrypted_part,
                &TgtReplyBody->session_key,
                KERB_ENCRYPTED_TGS_REPLY_PDU,
                ReplyBody
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        printf("Failed to unpack KDC reply body: 0x%x\n",KerbErr);
        goto Cleanup;
    }

    *Ticket = (*Reply)->ticket;

    if (ServicePassword.Length)
    {
        KerbErr = KerbHashPasswordEx(
                     g_pIKerbCrypt,
                     &ServicePassword,
                     &ServiceName,
                     Ticket->encrypted_part.encryption_type,
                     &ServiceKey
                     );
        if (!KERB_SUCCESS(KerbErr))
        {
            printf("Failed to hash server password with 0x%x alg\n",(*Reply)->encrypted_part.encryption_type);
            goto Cleanup;
        }

#ifdef SHOW_KEYS
        printf("ServiceKey: ");
        PrintKey(ServiceKey);
#endif
        KERBERR TmpErr;

        TmpErr = KerbUnpackTicket(
                    Ticket,
                    ServiceKey,
                    TicketBody
                    );

        if (!KERB_SUCCESS(TmpErr))
        {
            printf("Failed to unpack ticket: 0x%x\n",TmpErr);
            *TicketBody = NULL;
            goto Cleanup;
        }

        *Key = ServiceKey;
    }


Cleanup:
    //
    // BUGBUG: memory leak here
    //

    if (KERB_SUCCESS(KerbErr))
    {
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}


BOOLEAN
UStringFromAnsi(
    OUT PUNICODE_STRING UnicodeString,
    IN LPSTR String
    )
{
    STRING AnsiString;

    RtlInitString(
        &AnsiString,
        String
        );
    if (!NT_SUCCESS(RtlAnsiStringToUnicodeString(
                        UnicodeString,
                        &AnsiString,
                        TRUE
                        )))
    {
        return(FALSE);
    }
    else
    {
        return(TRUE);
    }
}

void
SetDefaultOpts()
{
    LPSTR String;
    BOOLEAN NoTcp = FALSE;

    KerbInitializeSockets(0x0101,5,&NoTcp);

    //
    // Username
    //

    String = getenv( "USERNAME" );
    if (String == NULL)
    {
        String = "mikesw";
    }

    UStringFromAnsi(
        &ClientName,
        String
        );


    String = getenv( "USERDOMAIN" );
    if (String == NULL)
    {
        String = "NTDS";
    }

    UStringFromAnsi(
        &ClientRealm,
        String
        );

    UStringFromAnsi(
        &ServiceRealm,
        String
        );


}

#ifdef KDCDBG_RPC
VOID
SetPassword(
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING PrincipalName,
    IN PUNICODE_STRING Password,
    IN BOOLEAN UnixOnly
    )
{
    NTSTATUS Status;
    DWORD  sc;
    LPTSTR   pszBinding;
    RPC_IF_HANDLE   ifh = KdcDebug_ClientIfHandle;
    handle_t        hBinding;
    sc = RpcStringBindingCompose(0, L"ncalrpc",L"",NULL,
                0, &pszBinding);
    if (sc) {
        printf("error:rpcstringbindingcompose\n" );
        return;
    }
    sc = RpcBindingFromStringBinding(pszBinding, &hBinding);
    (void) RpcStringFree(&pszBinding);
    if (sc) {
        printf("error:rpcbindingfromstringbinding\n" );
        return;
    }
    sc = RpcEpResolveBinding(hBinding, ifh);
    if (sc) {
        printf("error:rpcepresolvebinding\n" );
        return;
    }

    Status = KDC_SetPassword(
                hBinding,
                UserName,
                PrincipalName,
                Password,
                UnixOnly ? KERB_PRIMARY_CRED_RFC1510_ONLY : 0
                );
    RpcBindingFree(&hBinding);
    printf("SetPassword returned 0x%x\n",Status);

}

BOOLEAN
BindToKdcRpc(
    handle_t * hBinding
    )
{
    DWORD  sc;
    LPTSTR   pszBinding;
    RPC_IF_HANDLE   ifh = KdcDebug_ClientIfHandle;
    if (KdcName.Buffer == NULL)
    {
        sc = RpcStringBindingCompose(0, L"ncalrpc",L"",NULL,
                0, &pszBinding);
    }
    else
    {
        sc = RpcStringBindingCompose(0, L"ncacn_ip_tcp",KdcNameString,NULL,
                0, &pszBinding);
    }
    if (sc) {
        printf("error:rpcstringbindingcompose\n" );
        return FALSE;
    }
    sc = RpcBindingFromStringBinding(pszBinding, hBinding);
    (void) RpcStringFree(&pszBinding);
    if (sc) {
        printf("error:rpcbindingfromstringbinding\n" );
        return FALSE;
    }
    sc = RpcEpResolveBinding(*hBinding, ifh);
    if (sc) {
        printf("error:rpcepresolvebinding\n" );
        return FALSE;
    }
    return TRUE;

}

VOID
DumpKdc(
    VOID
    )
{
    NTSTATUS Status;
    DWORD  sc;
    LPTSTR   pszBinding;
    RPC_IF_HANDLE   ifh = KdcDebug_ClientIfHandle;
    handle_t        hBinding;
    sc = RpcStringBindingCompose(0, L"ncalrpc",L"",NULL,
                0, &pszBinding);
    if (sc) {
        printf("error:rpcstringbindingcompose\n" );
        return;
    }
    sc = RpcBindingFromStringBinding(pszBinding, &hBinding);
    (void) RpcStringFree(&pszBinding);
    if (sc) {
        printf("error:rpcbindingfromstringbinding\n" );
        return;
    }
    sc = RpcEpResolveBinding(hBinding, ifh);
    if (sc) {
        printf("error:rpcepresolvebinding\n" );
        return;
    }

    Status = KDC_Dump(
                hBinding
                );
    RpcBindingFree(&hBinding);

}


VOID
DumpKdcDomains( VOID )
{
    NTSTATUS Status;
    PKDC_DBG_DOMAIN_LIST DomainList = NULL;
    ULONG Index;

    handle_t hBinding = NULL;

    if (!BindToKdcRpc(&hBinding))
    {
        printf("Failed to bind to kdc\n");
        return;
    }

    Status = KDC_GetDomainList(
                hBinding,
                &DomainList
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed toget domain list: 0x%x\n",Status);
    }
    else
    {
         for (Index = 0; Index < DomainList->Count ; Index++ )
         {
             printf("Domain %d:\n",Index);
             printf("\tDnsName = %wZ\n",&DomainList->Domains[Index].DnsName);
             printf("\tNetbiosName = %wZ\n",&DomainList->Domains[Index].NetbiosName);
             printf("\tClosestRoute = %wZ\n",&DomainList->Domains[Index].ClosestRoute);
             printf("\tType = 0x%x, Attributes = 0x%x\n",DomainList->Domains[Index].Type, DomainList->Domains[Index].Attributes);
         }
    }

}

VOID
KdcNormalize(
    ULONG Flags,
    PKERB_DBG_INTERNAL_NAME Name
    )
{
    NTSTATUS Status;
    PKDC_DBG_DOMAIN_LIST DomainList = NULL;
    ULONG Index;

    handle_t hBinding = NULL;

    if (!BindToKdcRpc(&hBinding))
    {
        printf("Failed to bind to kdc\n");
        return;
    }

    Status = KDC_Normalize(
                hBinding,
                Name,
                Flags
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed toget domain list: 0x%x\n",Status);
    }
    else
    {
        printf("Success\n");
    }

}


VOID
KdcSetState(
    ULONG Lifetime,
    ULONG RenewTime
    )
{
    NTSTATUS Status;
    LARGE_INTEGER FudgeFactor = {0};

    handle_t hBinding = NULL;

    if (!BindToKdcRpc(&hBinding))
    {
        printf("Failed to bind to kdc\n");
        return;
    }

    Status = KDC_SetState(
                hBinding,
                0,              // no flags
                Lifetime,
                RenewTime,
                FudgeFactor
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to set kdc options: 0x%x\n",Status);
    }
    else
    {
        printf("Success\n");
    }

}
#endif

void
Usage(char * Name)
{
    printf("%s\n",Name);
    printf("-cname, -sname : set client & service names\n");
    printf("-crealm, -srealm : set client & service realms\n");
    printf("-cpass, -spass : set client & service passwords\n");
    printf("-crypt : set encryption type\n");
    printf("-gettgt : get a TGT in client's realm, incompat. with -getas\n");
    printf("-getas : get an AS ticket to a service, incompat. with -gettgt\n");
    printf("-gettgs : get a TGS ticket to a service, requires a TGT\n");
    printf("-renew : renew last ticket acquired\n");
//    printf("-dump : dump kdc heap trace\n");
    printf("-kdc : set kdc name\n");
    printf("-paid : PA_COMPOUND_IDENTITY. default is 0(no PA_COMPOUND_IDENTITY)\n");
    printf("-des : Use DES enctype\n");
    printf("-PAC : request a PAC\n");
    printf("-NOPAC : suppress PAC\n");
    printf("-NC : request name canonicalization - uses NT_ENTERPRISE for cname\n");
    printf("-tcp: use TCP transport\n");
    printf("-rep n: do n requests\n");
    printf("-ref: do NOT request referrals\n");
    printf("-noencts : no enc-timestamp preauth\n");
//    printf("-norm 0xFlags type name1 name2 name3 ... : normalize a name\n");
//    printf("-domains : dump domain list\n");
//    printf("-setstate lifespan renewspan : set ticket lifetime\n");
    printf("\n");
//    printf("-setpass username principalname password  : sets KRB5 password\n");
}

ULONG
ElapsedTime(
    IN ULONG StartTime
)
{
    ULONG CurrentTime;

    //
    // If time has has wrapped,
    //  account for it.
    //

    CurrentTime = GetTickCount();

    if ( CurrentTime >= StartTime ) {
        return CurrentTime - StartTime;
    } else {
        return (0xFFFFFFFF-StartTime) + CurrentTime;
    }
}


void
__cdecl main(int argc, char *argv[])
{
    int Index;
    BOOLEAN GetAsTicket = FALSE;
    BOOLEAN GetTgsTicket = FALSE;
    BOOLEAN GetTgt = FALSE;
    BOOLEAN RenewTicket = FALSE;
//    BOOLEAN SetPass = FALSE;
//    BOOLEAN Dump = FALSE;
//    BOOLEAN Normalize= FALSE;
//    BOOLEAN DumpDomains = FALSE;
//    BOOLEAN SetState = FALSE;
//    ULONG Lifespan = 0;
//    ULONG RenewSpan = 0;
//    UNICODE_STRING UserName;
//    UNICODE_STRING PrincipalName;
//    UNICODE_STRING Password;
//    STRING AnsiString;
    UNICODE_STRING AsServerName;
    PKERB_ENCRYPTED_KDC_REPLY AsReplyBody = NULL;
    PKERB_KDC_REPLY AsReply = NULL;
    KERB_TICKET AsTicket;

    PKERB_ENCRYPTED_KDC_REPLY TgsReplyBody = NULL;
    PKERB_KDC_REPLY TgsReply = NULL;
    PKERB_ENCRYPTED_TICKET TgsTicketBody = NULL;
    KERB_TICKET TgsTicket;
    BOOLEAN UnixOnly = FALSE;
    INT Repeat = 0;
//    KERB_DBG_INTERNAL_NAME Name = {0};
//    ULONG Flags;
//    UNICODE_STRING NameParts[20];
//    WCHAR NameBuffers[20][100];
//    ULONG Index2;
    PKERB_ENCRYPTION_KEY Key;


    SetDefaultOpts();
    if (argc <= 1)
    {
        goto Usage;
    }

    for (Index = 1; Index < argc ; Index++ )
    {
        //
        // First the principal name features
        //

        if (!_stricmp(argv[Index],"-crealm"))
        {
            if (Index+1 == argc)
            {
                goto Usage;
            }
            UStringFromAnsi(
                &ClientRealm,
                argv[++Index]
                );
        } else
        if (!_stricmp(argv[Index],"-srealm"))
        {
            if (Index+1 == argc)
            {
                goto Usage;
            }

            UStringFromAnsi(
                &ServiceRealm,
                argv[++Index]
                );
        } else
        if (!_stricmp(argv[Index],"-cname"))
        {
            if (Index+1 == argc)
            {
                goto Usage;
            }
            UStringFromAnsi(
                &ClientName,
                argv[++Index]
                );
        } else
        if (!_stricmp(argv[Index],"-sname"))
        {
            if (Index+1 == argc)
            {
                goto Usage;
            }
            UStringFromAnsi(
                &ServiceName,
                argv[++Index]
                );
        } else
        if (!_stricmp(argv[Index],"-cpass"))
        {
            if (Index+1 == argc)
            {
                goto Usage;
            }
            UStringFromAnsi(
                &ClientPassword,
                argv[++Index]
                );
        } else
        if (!_stricmp(argv[Index],"-spass"))
        {
            if (Index+1 == argc)
            {
                goto Usage;
            }
            UStringFromAnsi(
                &ServicePassword,
                argv[++Index]
                );
        } else
        if (!_stricmp(argv[Index],"-crypt"))
        {
            if (Index+1 == argc)
            {
                goto Usage;
            }
            sscanf(argv[++Index],"%d",&CryptType);

        } else
        if (!_stricmp(argv[Index],"-gettgt"))
        {
            GetTgt = TRUE;
        } else
        if (!_stricmp(argv[Index],"-getas"))
        {
            GetAsTicket = TRUE;
        } else
        if (!_stricmp(argv[Index],"-gettgs"))
        {
            GetTgsTicket = TRUE;
        } else
        if (!_stricmp(argv[Index],"-renew"))
        {
            RenewTicket = TRUE;
        }
#ifdef KDCDBG_RPC
        else if (!_stricmp(argv[Index],"-setpass"))
        {
            if (Index+4 > argc)
            {
                printf("Not enough args: %d instead of %d\n", argc, Index+3);
                goto Usage;
            }
            SetPass = TRUE;
            UStringFromAnsi(
                &UserName,
                argv[++Index]
                );
            UStringFromAnsi(
                &PrincipalName,
                argv[++Index]
                );
            UStringFromAnsi(
                &Password,
                argv[++Index]
                );
        }
#endif
#ifdef KDCDBG_RPC
        else if (!_stricmp(argv[Index],"-dump"))
        {
            Dump = TRUE;
        }
#endif
        else if (!_stricmp(argv[Index],"-unix"))
        {
            UnixOnly = TRUE;
        }
        else if (!_stricmp(argv[Index],"-des"))
        {
            CryptType = KERB_ETYPE_DES_CBC_MD5;
        }
        else if (!_stricmp(argv[Index],"-tcp"))
        {
            UseDg = FALSE;
        }
        else if (!_stricmp(argv[Index],"-ref"))
        {
            RequestReferrals = FALSE;
        }
        else if (!_stricmp(argv[Index],"-PAC"))
        {
            RequestPAC = TRUE;
        }
        else if (!_stricmp(argv[Index],"-NOPAC"))
        {
            RequestPAC = FALSE;
        }
        else if (!_stricmp(argv[Index],"-NC"))
        {
            NameCanonicalize = TRUE;
        }
        else if (!_stricmp(argv[Index],"-rep"))
        {
            if (Index+2 > argc)
            {
                goto Usage;
            }
            Repeat = atoi(argv[++Index]);
        }
        else if (!_stricmp(argv[Index],"-noencts"))
        {
            NoEncTimeStamp = TRUE;
        }
        else if (!_stricmp(argv[Index],"-kdc"))
        {
            if (Index+2 > argc)
            {
                goto Usage;
            }
            mbstowcs(KdcNameString,argv[++Index],100);
            RtlInitUnicodeString(
                &KdcName,
                KdcNameString
                );
        }
#ifdef KDCDBG_RPC
        else if (!_stricmp(argv[Index],"-norm"))
        {
            Normalize = TRUE;
            if (Index+4 > argc)
            {
                goto Usage;
            }
            sscanf(argv[++Index],"0x%x",&Flags);
            sscanf(argv[++Index],"%d",&Name.NameType);
            Name.NameCount = 0;
            Name.References = 0;
            Name.Names = NameParts;
            Index2 = 0;
            while (Index < argc-1)
            {
                mbstowcs(NameBuffers[Index2],argv[++Index],100);
                RtlInitUnicodeString(
                    &NameParts[Index2],
                    NameBuffers[Index2]
                    );
                Index2++;
                Name.NameCount++;
            }


        }
        else if (!_stricmp(argv[Index],"-domains"))
        {
            DumpDomains = TRUE;
        }
        else if (!_stricmp(argv[Index],"-setstate"))
        {
            if (Index+3 > argc)
            {
                goto Usage;
            }
            sscanf(argv[++Index],"%d",&Lifespan);
            sscanf(argv[++Index],"%d",&RenewSpan);
            SetState = TRUE;
        }
#endif
        else if (!_stricmp(argv[Index],"-paid"))
        {
            NumPaIds = atol(argv[++Index]);
        }
        else
        {
            goto Usage;
        }

    }

    if (GetTgsTicket && !GetTgt)
    {
        printf("ERROR: Can't get a TGS ticket without a TGT\n");
        goto Usage;
    }

    if (GetAsTicket && GetTgt)
    {
        printf("ERROR: Can't get both an AS ticket and a TGT\n");
        goto Usage;
    }


#ifdef KDCDBG_RPC
    if (SetPass)
    {
        SetPassword( &UserName, &PrincipalName, &Password, UnixOnly );
        goto Cleanup;
    }
    if (Dump)
    {
        DumpKdc();
        goto Cleanup;
    }
    if (DumpDomains)
    {
        DumpKdcDomains();
        goto Cleanup;
    }
    if (SetState)
    {
        KdcSetState(
            Lifespan,
            RenewSpan
            );
        goto Cleanup;
    }
    if (Normalize)
    {
        KdcNormalize(
            Flags,
            &Name
            );
        goto Cleanup;
    }
#endif
    //
    // Bind to the KDC
    //

    if (!BindToKdc())
    {
        printf("ERROR: Failed to bind to KDC\n");
        goto Cleanup;
    }
    //
    // Now try to get the AS ticket
    //

    if (GetAsTicket)
    {
        AsServerName = ServiceName;
    }
    else if (GetTgt)
    {
        RtlInitUnicodeString(
            &AsServerName,
            KDC_PRINCIPAL_NAME
            );
    }

    //
    // Try as-req
    //

    INT IterCount = Repeat;

    ULONG StartTime = ElapsedTime(0L);
    g_pIKerbCrypt = KdcGetICrypt();
    printf("g_pIKerbCrypt = %d \n", g_pIKerbCrypt);
    /*
    if (!g_pIKerbCrypt)
    {
        Status = STATUS_SERVER_DISABLED;
        goto Cleanup;
    }
    */
    do
    {

        if (!GetAnAsTicket(
                &AsServerName,
                &AsTicket,
                &AsReplyBody,
                &AsReply
                ))
        {
            printf("ERROR: Failed to get AS ticket\n");
            goto Cleanup;
        }
        else
        {
            if (Repeat <= 0)
            {
                printf("SUCCESS: got an AS ticket\n");
                PrintResult(AsReply, AsReplyBody, &AsTicket, NULL, NULL);
            }
            else
            {
                if ((Repeat % 10) == 0)
                    printf(".");
            }
        }

    }
    while(!GetTgsTicket && Repeat--);

    if (Repeat < 0)
        Repeat = 0;

    //
    // Now a TGS-REQ
    //

    if (GetTgsTicket)
    {
        do
        {
            if (!GetATgsTicket(
                    &AsTicket,
                    AsReplyBody,
                    AsReply,
                    FALSE,          // don't renew
                    &TgsTicket,
                    &TgsReplyBody,
                    &TgsReply,
                    &TgsTicketBody,
                    &Key))
            {
                printf("ERROR: Failed to get TGS ticket\n");
                goto Cleanup;
            }
            else
            {
                if (Repeat <= 0)
                {
                    printf("SUCCESS: got a TGS ticket\n");
                    PrintResult(TgsReply, TgsReplyBody, &TgsTicket, TgsTicketBody, Key);
                }
                else
                {
                    if ((Repeat % 10) == 0)
                        printf(".");
                }
            }
        }
        while (Repeat--);
    }


    if (IterCount)
    {
        printf("%d iterations took %g seconds.\n",
               IterCount,
               (float)(ElapsedTime(StartTime)) / 100.
            );
    }

#ifdef KDCDBG_RPC
    if (Dump)
    {
        DumpKdc();
    }
#endif
    goto Cleanup;

Usage:
    Usage(argv[0]);

Cleanup:

    //KerbCleanupTickets();

    return;
}



void *
NTAPI MIDL_user_allocate( size_t cb )
{
    return LocalAlloc( 0, ROUND_UP_COUNT(cb,8) );
}

void
NTAPI
MIDL_user_free( void * pv )
{
    LocalFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\tracelib\tracer.cxx ===
#include "tracerp.h"


void
CTraceFn::TraceFunctionEnter()
{
    wchar_t buf[KERB_TRACE_MAXSTR];
       
    _snwprintf(buf, KERB_TRACE_MAXSTR-1, L"+%s()", m_funcName);

    m_traceInfo->pfnTrace( TRACE_FUNC, buf );
}

void
CTraceFn::TraceFunctionLeave()
{
    wchar_t buf[KERB_TRACE_MAXSTR];
    
    if (m_ret)
    {
        _snwprintf(buf, KERB_TRACE_MAXSTR-1, L"-%s()=0x%p", m_funcName, *m_ret);
    }
    else
    {
        _snwprintf(buf, KERB_TRACE_MAXSTR-1, L"-%s()", m_funcName);
    }
    
    m_traceInfo->pfnTrace( TRACE_FUNC, buf );
}


//+-------------------------------------------------------------------------
//
//  Function:   CTraceFn::Trace
//
//  Synopsis:   Traces an error, using either the default tracing 
//              routines or the loaded custom tracing routines
//
//  Effects:
//
//  Arguments:  
//              FileAndLine     KLIN macro(File number in upper 16 bits and line
//                              number in bottom 16 bits
//              ParameterList   Format String for the message to be printed
//
//  Returns:    Nothing
// 
//  Notes:      Use Macros defined in TraceInterface.hxx to pass level and
//              FileAndLine
//
//--------------------------------------------------------------------------

void
CTraceFn::Trace(
    IN DWORD FileAndLine,    
    IN OPTIONAL LPCWSTR ParameterList,
    ...
    )
{ 
    va_list parms;
    int len, count;
    wchar_t buf[KERB_TRACE_MAXSTR];
      
    len = _snwprintf(
              buf, 
              KERB_TRACE_MAXSTR-1 , 
              L"(KLIN(%x) ",
              FileAndLine
              );
                
    if (ParameterList != NULL)
    {
        va_start(parms, ParameterList);
        
        //
        // The following function will cause an error if the format 
        // specification in ParameterList doesn't match the parameters given
        //
        count = _vsnwprintf(
                buf+len, 
                KERB_TRACE_MAXSTR-len-1, 
                (WCHAR*)ParameterList, 
                parms
                );
        len = (count > 0) ? len + count : KERB_TRACE_MAXSTR - 1;
        va_end(parms);
    }
    
    if (len < (KERB_TRACE_MAXSTR - 1))
    {
        // Bug fix #18424 - rahuln - swprintf replaced by wcsncpy
        wcsncpy(buf+len, L")", KERB_TRACE_MAXSTR - 1 - len);
    }
    
    m_traceInfo->pfnTrace( m_level, buf );
}


//+-------------------------------------------------------------------------
//
//  Function:   CTraceFn::TraceFl
//
//  Synopsis:   Traces an error, using either the default tracing 
//              routines or the loaded custom tracing routines
//
//  Effects:
//
//  Arguments:  Level           Tracing Level
//              FileAndLine     File Name and Line Number
//              ParameterList   Format String for the message to be printed
//
//  Returns:    Nothing, caller can call GetLastError() to get reason for error
// 
//  Notes:      Use Macros defined in TraceInterface.hxx to pass level and
//              FileAndLine
//
//--------------------------------------------------------------------------

void
CTraceFn::TraceFl(
    IN LPCSTR FileAndLine,    
    IN OPTIONAL LPCWSTR ParameterList,
    ...
    )
{ 
    va_list parms;
    int len=0, count=0;
    wchar_t buf[KERB_TRACE_MAXSTR];
    wchar_t wFileAndLine[KERB_TRACE_MAXNAME];
    
    // Bug fix #18426 - rahuln
    if(strlen(FileAndLine))
    {
        MultiByteToWideChar(
            CP_ACP,
            0,
            FileAndLine,
            strlen(FileAndLine)+1,
            wFileAndLine,
            sizeof(wFileAndLine)/sizeof(wFileAndLine[0])
            );
    }
    
    WCHAR* pStr = wcsrchr(wFileAndLine, L'\\');
    if (pStr)
    {
        pStr++; //remove '\'
        len = _snwprintf(buf, KERB_TRACE_MAXSTR-1, L"(%s ", pStr);
        // bug fix #18429 - rahuln.
        // _snwprintf returns a -ve no. if the 'count' is less than required no. of bytes.
        if(len < 0)
            len = KERB_TRACE_MAXSTR-1;
    }
                
    if (ParameterList != NULL)
    {
        va_start(parms, ParameterList);
        
        //
        // The following function will cause an error if the format 
        // specification in ParameterList doesn't match the parameters given
        //
        count = _vsnwprintf(
                buf+len, 
                KERB_TRACE_MAXSTR-len-1, 
                (WCHAR*)ParameterList, 
                parms
                );
        len = (count > 0) ? len + count : KERB_TRACE_MAXSTR - 1;
        va_end(parms);
    }
    
    if (len < (KERB_TRACE_MAXSTR - 1))
    {
        // Bug fix #18427 - rahuln - swprintf replaced by wcsncpy    
        wcsncpy(buf+len, L")", KERB_TRACE_MAXSTR - 1- len);
    }
    
    m_traceInfo->pfnTrace( m_level, buf );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\tracelib\tracerp.h ===
#pragma once


#include <TraceInterface.hxx>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\tracelib\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_tracelib_none_12.4.56.0_none_75c564fcf24f27aa
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_tracelib_no-public-key_12.4.56.0_x-ww_b0dd3ff6
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=tracelib
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_tracelib_no-public-key_12.4.56.0_x-ww_b0dd3ff6
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_tracelib_no-public-key_12.4.56.0_x-ww_b0dd3ff6.manifest
XP_MANIFEST_PATH=manifests\x86_tracelib_no-public-key_12.4.56.0_x-ww_b0dd3ff6.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_tracelib_no-public-key_12.4.56.0_x-ww_b0dd3ff6.cat
XP_CATALOG_PATH=manifests\x86_tracelib_no-public-key_12.4.56.0_x-ww_b0dd3ff6.cat
XP_PAYLOAD_PATH=x86_tracelib_no-public-key_12.4.56.0_x-ww_b0dd3ff6
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=tracelib,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\DoS\kdcdos.cpp ===
// -------------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
// 
// kdcdos.cpp
//
// Xbox Live KDC Denial-of-Service detection library
// 
// Because we're using templates, this file is included in the kdcdos.h file. Yes it is 
// odd. But otherwise we get linker errors. Feel free to search the internet for info, or 
// read http://www.parashift.com/c++-faq-lite/templates.html.
//
// -------------------------------------------------------------------------------------

#pragma once

// -------------------------------------------------------------------------------------
// CKdcDosBase::CKdcDosBase
// constructor
// -------------------------------------------------------------------------------------
template <typename KdcDosRecordType>
CKdcDosBase<KdcDosRecordType>::CKdcDosBase() :
    _enabled(FALSE),
    _pDosTable(NULL),
    _sizeDosTable(0),
    _pDosRecords(NULL),
    _countDosRecords(0),
    _maxRequests(0),
    _interval(0),
    _blockingTime(0),
    _pAlloc(NULL),
    _baseFileTime(0)
{
}

// -------------------------------------------------------------------------------------
// CKdcDosBase::~CKdcDosBase
// destructor
// -------------------------------------------------------------------------------------
template <typename KdcDosRecordType>
CKdcDosBase<KdcDosRecordType>::~CKdcDosBase()
{
    if(_pDosTable)
    {
        _pAlloc->Free(_pDosTable);
    }

    if(_pDosRecords)
    {
        _pAlloc->Free(_pDosRecords);
    }
}


// -------------------------------------------------------------------------------------
// CKdcDosBase::Init
// Initialize object. Must be called before the object is used.
//   * enabled - indicates whether the DoS detection is enabled. If DoS detection is 
//   disabled, Check will always return OK. This value can be changed later with 
//   SetEnabled()
//   * maxRecords - the number of records to be allocated. This is effectively the size 
//   of the cache. Must be greater than 0 and less than 25000000.
//   * sizeRatio - the size ration between the number of records and the number of slots 
//   in the hash-table. Must be a value between 0.1 and 2.0 (inclusive).
//   * maxRequests - the usage limit is specified as the maximum number of requests that 
//   a client is allowed to do in a given interval. This is the max number of requests 
//   part. It can't be zero.
//   * interval - see above. Can't be zero.
//   * blockingTime - If a client passes the limit, it will be temporarily banned by the 
//   number of seconds specified in blockingTime.
// Returns:
//   TRUE on success, FALSE on failure
// -------------------------------------------------------------------------------------
template <typename KdcDosRecordType> 
BOOL CKdcDosBase<KdcDosRecordType>::Init(
    BOOL   enabled,
    UINT32 maxRecords, 
    double sizeRatio, 
    UINT32 maxRequests, 
    UINT32 interval,
    UINT32 blockingTime
    )
{
    BOOL ok = FALSE;

    _lock.Lock();

    if(maxRecords == 0 || maxRecords > 25000000)
    {
        goto Exit;
    }

    if(sizeRatio < 0.1 || sizeRatio > 2.0)
    {
        goto Exit;
    }

    if(maxRequests == 0)
    {
        goto Exit;
    }

    if(interval == 0)
    {
        goto Exit;
    }

    _enabled            = enabled;
    _maxRequests        = maxRequests;
    _interval           = interval;
    _blockingTime       = blockingTime;
    _countDosRecords    = maxRecords;
    
    // Use default memory allocator
    
    _pAlloc = CMemAlloc::Default();

    // Get base time

    C_ASSERT(sizeof(_baseFileTime) == sizeof(FILETIME));
    GetSystemTimeAsFileTime((FILETIME*)&_baseFileTime);

    // Allocate hashtable

    _sizeDosTable = GetNearestPrime((DWORD)(maxRecords * sizeRatio));

    _pDosTable = (CList*) _pAlloc->Alloc(_sizeDosTable * sizeof(CList));
    if(!_pDosTable)
    {
        goto Exit;
    }

    for(UINT32 i = 0; i < _sizeDosTable; i++)
    {
        _pDosTable[i].Init();
    }

    // Allocate DoS records

    _pDosRecords = (KdcDosRecordType*) _pAlloc->Alloc(_countDosRecords * sizeof(KdcDosRecordType));

    if(!_pDosRecords)
    {
        goto Exit;
    }
    
    memset(_pDosRecords, 0, _countDosRecords * sizeof(KdcDosRecordType));

    // Add DoS records to Lru list

    for(UINT32 i = 0; i < _countDosRecords; i++)
    {
        _lruList.InsertTail(&_pDosRecords[i].leLru);
    }

    ok = TRUE;

Exit:

    _lock.Unlock();

    return ok;
}

// -------------------------------------------------------------------------------------
// CKdcDosBase::Check
// Updates the activity record for the given key and returns whether the client 
// associated to that key should be allowed access or not.
//   * key: uniquely identifies the client
// Returns:
//   * KDCDOS_OK - client should be allowed access
//   * KDCDOS_LIMIT_EXCEEDED - client has just exceeded the usage limitation and should 
//   not be allowed access. It's also an indication that the client will be temporarily 
//   banned.
//   * KDCDOS_TEMP_BANNED - client was temporarily banned in a previous call. The ban 
//   still hasn't expired. The client should not be allowed access.
// -------------------------------------------------------------------------------------
template <typename KdcDosRecordType>
KDCDOS_STATUS CKdcDosBase<KdcDosRecordType>::Check(UINT64 key)
{
    KDCDOS_STATUS ret = KDCDOS_OK;

    if(!_enabled)
    {
        // DoS detection is disabled. Always return OK
        return KDCDOS_OK;
    }

    _lock.Lock();

    KdcDosRecordType* pRecord = GetDosRecord(key);

    // There is a small but unlikely chance that when we tried to allocate a record, it 
    // was already in-use (the cache item was). If this happens, the caller gets a free 
    // pass on the DOS check.
    //
    // @@@ TODO: if pRecord == NULL, should we return KDCDOS_NO_RECORD? This would require 
    // changing existing uses of the cache code.
    if (pRecord != NULL)
    {
        ret = UpdateRequestTime(pRecord);
    }

    _lock.Unlock();

    return ret;
}

// -------------------------------------------------------------------------------------
// CKdcDosBase::UpdateRequestTime
// The internal version of Check(). It's called by Check() after it acquires the _lock and 
// finds a record. This will increment the request count and check for banned records.
// -------------------------------------------------------------------------------------
template <typename KdcDosRecordType>
KDCDOS_STATUS CKdcDosBase<KdcDosRecordType>::UpdateRequestTime(KdcDosRecordType* pRecord)
{
    UINT32 now          = GetTime();
    UINT32 fractionNow  = TimeToFraction(now);
    UINT32 fractionLast = TimeToFraction(pRecord->lastRequestTime);
    UINT32 fractionDiff = fractionNow - fractionLast;

    if(fractionDiff > KDCDOS_REQUEST_COUNT_FRACTIONS)
    {
        // More time than current window size has elapsed. Clear all fractions.
        
        for(UINT32 i=0; i < KDCDOS_REQUEST_COUNT_FRACTIONS; i++)
        {
            pRecord->countFractions[i] = 0;
        }
    }
    else if(fractionDiff > 0)
    {
        // Clear only the difference in fractions since the last access

        UINT32 fractionClearStart = fractionLast + 1;
        UINT32 fractionClearEnd   = fractionClearStart + fractionDiff - 1;
        
        for(UINT32 i=fractionClearStart; i <= fractionClearEnd; i++)
        {
            pRecord->countFractions[i % KDCDOS_REQUEST_COUNT_FRACTIONS] = 0;
        }
    }
    
    // Increment current fraction. Be careful not to overflow

    UINT32 fractionSlot = fractionNow % KDCDOS_REQUEST_COUNT_FRACTIONS;
    
    if(pRecord->countFractions[fractionSlot] != 255)
    {
        pRecord->countFractions[fractionSlot]++;
    }
    
    // Update last request time

    pRecord->lastRequestTime = now;

    // Finally we get to decide whether to allow access or not. First we check if the 
    // record is already temporarily banned.

    if(pRecord->allowTime > now)
    {
        // Record is temporarily banned
        return KDCDOS_TEMP_BANNED;
    }

    // Next, compare the current window's request count against the configured maximum

    UINT32 requestCount = 0;
    for(UINT32 i=0; i < KDCDOS_REQUEST_COUNT_FRACTIONS; i++)
    {
        requestCount += pRecord->countFractions[i];
    }

    if(requestCount > _maxRequests)
    {
        // This record is violating the quota. Ban it temporarily and deny access
        pRecord->allowTime = now + _blockingTime;
        return KDCDOS_LIMIT_EXCEEDED;
    }
    
    return KDCDOS_OK;
}
    
// -------------------------------------------------------------------------------------
// CKdcDosBase::HashUINT64
// Simple function to generate a 32 bit hash from a 64 bit integer
//   * key : the key
// Returns:
//   The hash
// -------------------------------------------------------------------------------------
template <typename KdcDosRecordType>
inline UINT32 CKdcDosBase<KdcDosRecordType>::HashUINT64(UINT64 key)
{
    return ((UINT32*)&key)[0] ^ ((UINT32*)&key)[1];
}

// -------------------------------------------------------------------------------------
// CKdcDosBase::TimeToFraction
// Converts a time value in seconds to the corresponding time fraction in 
// KdcDosRecord::countFractions
//   - time: time value in seconds
// Returns:
//   A value between 0 and KDCDOS_REQUEST_COUNT_FRACTIONS-1 (inclusive)
// -------------------------------------------------------------------------------------
template <typename KdcDosRecordType>
inline UINT32 CKdcDosBase<KdcDosRecordType>::TimeToFraction(UINT32 time)
{
    return (time * KDCDOS_REQUEST_COUNT_FRACTIONS) / _interval; 
}

// -------------------------------------------------------------------------------------
// CKdcDosBase::FindDosRecord
// Finds a KdcDosRecord in the DoS table given a key.
// - key: the key of the record to look for
// Returns:
//   The found KdcDosRecord. Returns NULL if no record found.
// -------------------------------------------------------------------------------------
template <typename KdcDosRecordType>
KdcDosRecordType* CKdcDosBase<KdcDosRecordType>::FindDosRecord(UINT64 key)
{
    // Pick the table slot based on the hash of the key
    
    UINT32 slot = HashUINT64(key) % _sizeDosTable;
    CList* pList = &_pDosTable[slot];

    // Look for the entry 

    KdcDosRecordType* pRecord = NULL;
    
    for(CListEntry* ple = pList->GetFirst(); !ple->IsTail(); ple = ple->GetNext())
    {
        KdcDosRecordType* pRec = CONTAINING_RECORD(ple, KdcDosRecordType, leTable);

        if(pRec->key == key)
        {
            // Found a match
            pRecord = pRec;
            break;
        }
    }

    return pRecord;
}

// -------------------------------------------------------------------------------------
// CKdcDosBase::GetDosRecord
// Finds a KdcDosRecord in the DoS table given a key. If no records exist with that key, 
// a new record is allocated by "refurbishing" the least-recently-used record in the 
// table. This is all transparent to the caller. The record will always be updated in the 
// LRU list.
//   - key: the key of the record to look for
// Returns:
//   The found/allocated KdcDosRecord. This function will always return a valid record 
//   unless it tried to allocate a new entry that was marked as in-use. In that case, NULL 
//   is returned.
// -------------------------------------------------------------------------------------
template <typename KdcDosRecordType>
KdcDosRecordType* CKdcDosBase<KdcDosRecordType>::GetDosRecord(UINT64 key)
{
    // Look for record. May or may not find it.
    KdcDosRecordType* pRecord = FindDosRecord(key);

    if(pRecord)
    {
        // If a record was found, refresh its position in the LRU list. Just remove 
        // itself and add itself back to the head of the list.

        pRecord->leLru.Remove();
        _lruList.InsertHead(&pRecord->leLru);

        // Mark record as being found. This means it wasn't allocated (refurbished).

        pRecord->fRecordFound = TRUE;
    }
    else
    {
        // If no record was not found, let's allocate a new one (no allocation is really 
        // being made. Instead the least-recently-used record will be reused). May return 
        // NULL if LRU entry is in-use.

        pRecord = AllocateRecord(key);
    }

    return pRecord;
}

// -------------------------------------------------------------------------------------
// CKdcDosBase::AllocateRecord
// Get the least-recently-used record in the DoS table and refurbish it with the new 
// specified key and a clean status.
//   - key: the key of the record that is to be created
// Returns:
//   The newly refurbished KdcDosRecord, or NULL if the cache item was still in use
// -------------------------------------------------------------------------------------
template <typename KdcDosRecordType>
KdcDosRecordType* CKdcDosBase<KdcDosRecordType>::AllocateRecord(UINT64 key)
{
    CListEntry* ple = _lruList.RemoveTail();

    // This list will never be empty. In fact, it will contain *all* records at all 
    // times in order of last usage.

    DBGASSERT(ple);
    KdcDosRecordType* pRecord = CONTAINING_RECORD(ple, KdcDosRecordType, leLru);

    // There is a very small chance that this record is still in use (rather, the cache 
    // item is still in use).  We could continue walking the LRU list for an entry not in 
    // use, or we could return an error. For simplicity, we're going to return an error.
    if (pRecord->fInUse)
    {
        // Put back to head of LRU list - something rather odd went on, so let's cycle 
        // this thing around.
        _lruList.InsertHead(&pRecord->leLru);
        return NULL;
    }

    // Remove record from _pDosTable - record will only not be in _pDosTable if it has 
    // never been used. This should only happen right after the service was initialized.

    if(pRecord->leTable.GetNext() != NULL)
    {
        pRecord->leTable.Remove();
    }

    // Initialize record with the new key

    memset(pRecord, 0, sizeof(*pRecord));
    pRecord->key = key;

    // Put record back to LRU list

    _lruList.InsertHead(&pRecord->leLru);

    // Put record in DoS table

    UINT32 slot = HashUINT64(key) % _sizeDosTable;
    CList* pList = &_pDosTable[slot];
    pList->InsertHead(&pRecord->leTable);

    return pRecord;
}

// -------------------------------------------------------------------------------------
// CKdcDosBase::GetTime
// Returns the number of seconds since CKdcDosBase::Init() was called. This function is used 
// to generate all time values used in this class.
// Returns:
//   Number of seconds since CKdcDosBase::Init() was called.
// -------------------------------------------------------------------------------------
template <typename KdcDosRecordType>
UINT32 CKdcDosBase<KdcDosRecordType>::GetTime()
{
    // Calculate the number of seconds elapsed since CKdcDosBase was initialized.
    // By the way, in my tests GetSystemTimeAsFiletime performs exactly the same as 
    // GetTickCount (in my machine) but I don't have to worry about wrapping.  
    // Furthermore, it's 5x faster than QueryPerformanceCounter (again, in my machine 
    // running Windows Server 2003).
    //
    // Storing seconds in 32 bits will represent around 136 years.

    UINT64 ftnow;
    C_ASSERT(sizeof(ftnow) == sizeof(FILETIME));
    GetSystemTimeAsFileTime((FILETIME*)&ftnow);

    // Calculate the difference and convert it to the number of seconds. FILETIME 
    // contains nano-seconds.
    
    UINT64 diffsec = (ftnow - _baseFileTime) / 10000000;

    return (UINT32) diffsec;
}



// -------------------------------------------------------------------------------------
// CKdcDosCache::CheckAndAcquire
// Updates the activity record for the given key and returns whether the client associated 
// to that key should be allowed access or not. Also returns the associated cache item, or 
// a newly allocated one.
//   * key: uniquely identifies the client
//   * pData: output, cache item
//   * pfValid: output, whether cache item contains valid data or not
// Returns:
//   * KDCDOS_OK - client should be allowed access
//   * KDCDOS_LIMIT_EXCEEDED - client has just exceeded the usage limitation and should 
//   not be allowed access. It's also an indication that the client will be temporarily 
//   banned.
//   * KDCDOS_TEMP_BANNED - client was temporarily banned in a previous call. The ban 
//   still hasn't expired. The client should not be allowed access.
//   * KDCDOS_CACHE_INUSE - the DOS check succeeded but the cache item is in use by 
//   another thread. The pData should not be used.
//   * KDCDOS_NO_RECORD - no record could be allocated (no dos update, no valid cache 
//   data). Do not use pData.
// -------------------------------------------------------------------------------------
template <typename CacheDataType>
KDCDOS_STATUS CKdcDosCache<CacheDataType>::CheckAndAcquire(
    UINT64 key,
    CacheDataType **ppData,
    BOOL *pfCacheDataValid)
{
    DBGASSERT(ppData);
    DBGASSERT(pfCacheDataValid);
   
    // Default return values
    KDCDOS_STATUS ret = KDCDOS_OK; 
    *ppData = NULL;
    *pfCacheDataValid = FALSE;

    if(!_enabled)
    {
        // DoS detection is disabled. Always return OK
        return KDCDOS_OK;
    }

    _lock.Lock();

    KdcDosRecordCache<CacheDataType>* pRecord = GetDosRecord(key);

    // NULL is returned if we tried to allocate a new item but it was already in use.  
    // Caller gets a free pass on DOS check.
    if (pRecord == NULL)
    {
        ret = KDCDOS_NO_RECORD;
        goto Exit;
    }

    // Update DOS time
    DBGASSERT(pRecord);
    ret = UpdateRequestTime(pRecord);

    // Only do cache stuff if sucessful
    if (ret != KDCDOS_OK)
    {
        goto Exit;
    }

    // We return an error if the record is already in use by another thread. This 
    // implies to the caller that the cachedata is invalid and the record shouldn't be 
    // touched at all.
    if (pRecord->fInUse)
    {
        ret = KDCDOS_CACHE_INUSE;

        // If in use, we did not allocate a new record. We don't allocate records if they 
        // are in use (see the KDCDOS_NO_RECORD error above).
        DBGASSERT(pRecord->fRecordFound);

        // Go ahead and return cache entry, even though it shouldn't be used at this 
        // point
        *pfCacheDataValid = TRUE;
        *ppData = &pRecord->cacheData;
    }
    else
    {
        // If we found the record, versus allocating a new one, then the data is valid.
        if (pRecord->fRecordFound)
        {
            *pfCacheDataValid = TRUE;
        }

        // mark as in-use and return cache data
        pRecord->fInUse = TRUE;
        *ppData = &pRecord->cacheData;
    }
   
Exit:

    _lock.Unlock();

    return ret;
}

// -------------------------------------------------------------------------------------
// CKdcDosCache::Release
// Find record and mark as not in use. That's all.
//   * key: uniquely identifies the client
// Returns:
//   TRUE if record was found and it was in use
//   FALSE if record not found or it was not in use. This should only apply for testing.
// -------------------------------------------------------------------------------------
template <typename CacheDataType>
BOOL CKdcDosCache<CacheDataType>::Release(
    UINT64 key)
{
    BOOL ret = FALSE;
    _lock.Lock();
    
    KdcDosRecordCache<CacheDataType>* pRecord = FindDosRecord(key);

    // Since we don't allocate in-use items off the LRU list, we should always find our 
    // entry, assuming it really was marked as in-use. If you called Release() twice, then 
    // this may fail, or if there is some bug in the internal state, or if you called 
    // Release() before acquiring. These negative cases only apply in testing.

#ifndef _TEST
    DBGASSERT(pRecord);
    DBGASSERT(pRecord->fInUse);
#endif

    // Allow for testing and be nice to retail builds
    if (pRecord == NULL)
        goto Exit;
    if (!pRecord->fInUse)
        goto Exit;

    pRecord->fInUse = FALSE;
    ret = TRUE;

Exit:
    _lock.Unlock();

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\tracelib\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_tracelib_none_12.4.56.0_none_75c564fcf24f27aa
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_tracelib_no-public-key_12.4.56.0_x-ww_b0dd3ff6
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=tracelib
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_tracelib_no-public-key_12.4.56.0_x-ww_b0dd3ff6
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_tracelib_no-public-key_12.4.56.0_x-ww_b0dd3ff6.manifest
XP_MANIFEST_PATH=manifests\x86_tracelib_no-public-key_12.4.56.0_x-ww_b0dd3ff6.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_tracelib_no-public-key_12.4.56.0_x-ww_b0dd3ff6.cat
XP_CATALOG_PATH=manifests\x86_tracelib_no-public-key_12.4.56.0_x-ww_b0dd3ff6.cat
XP_PAYLOAD_PATH=x86_tracelib_no-public-key_12.4.56.0_x-ww_b0dd3ff6
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=tracelib,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\DoS\kdcdosp.h ===
// -------------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
// 
// kdcdosp.h
//
// Xbox Live KDC Denial-of-Service detection library
// 
// -------------------------------------------------------------------------------------

#pragma once

#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\DoS\kdcdos.h ===
// -------------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
// 
// kdcdos.h
//
// Xbox Live KDC Denial-of-Service detection library
// 
// Summary:
//
// The problem we're trying to solve here is the following: we need a way to detect 
// excessive request activity from a client. The client may be an user (xuid), a console 
// (machine-id or console-id) or a PC (machine-id). Excessive activity is established as 
// more than a configurable ammount requests occurring in an also configurable time 
// window from a single client. If excessive activity is detected, the client must be 
// temporarily banned for a configurable ammount of time.
//
// We're going to use a hashtable with chaining to store request count information keyed 
// keyed by UINT64 which can be a xuid, machine-id or console-id. We're going to store in 
// each record the time of the last request and a granular request count.
//
// The time will be stored in a DWORD as the number of seconds elapsed since the service 
// started. Thus we won't have to worry about overflowing or wrapping.
//
// The request count will be stored in an array size X where each entry in the array 
// stores 1/X of the number of requests that occurred in the last Y seconds. X is 
// determined by the constant KDCDOS_REQUEST_COUNT_TRACKING_GRANULARITY and Y is 
// configurable. This scheme allows us to calculate, with a certain precision, the number 
// of requests that occurred during a period of Y seconds. Each fraction of the count 
// will be stored in a single byte so some precision might be lost if count fractions 
// greater than 256 are relatively common.
//
// Each node will also be stored in a list ordered by usage. This way, we can use a 
// finite (configurable) number of nodes and reuse nodes on a LRU base. 
//
// Usage:
//
// Declare a instance of CKdcDos. Use Init() to initalize the object before using it.  
// It will allocate all the memory required by the object at this point. No memory will be 
// allocated afterwards. This is also where the initial usage limits should be specified.  
// The ammount of memory required by the object can be approximated by the following 
// formula:
//  total_memory_in_bytes = (maxRecords * 40) + ((maxRecords * sizeRatio) * 8)
//
// So, if you use maxRecords=100000 and sizeRatio=0.5 (reasonable parameters), the 
// ammount of memory required is 4.4MB. Not, bad, huh?
//
// Use Check() whenever the client makes a request. Check() should be called as early as 
// possible to save as much work on the server as possible in case of an attack. Check 
// will update the usage record and it will also verify if the client exceeded the limit 
// or if it's temporarily banned.
//
// -------------------------------------------------------------------------------------
// KdcDos with caching
//
// Summary:
//
// This is the same KdcDos class and behavior as described above but with an optional 
// cache item included. This is an opaque, templated type, so the caller can insert 
// whatever it wants. 
// 
// It is simple to use. Create the CKdcDosCache<yourtype> object. If you want a simple DOS 
// check, call Check(). If you want to take advantage of the cache, call CheckAndAcquire() 
// to perform a DOS check and acquire a pointer to the cache item. If the call succeeds, 
// remember to call Release() when done with the item. Between these two calls, your cache 
// item is protected from access by other threads.
//
// New return codes:
// KDCDOS_CACHE_INUSE - another thread is using this cache item. It should be considered 
// invalid.
//
// KDCDOS_CACHE_NORECORD - a new record had to be allocated from the LRU list, but the 
// cache item is in use. This is highly unusual.
// -------------------------------------------------------------------------------------

#pragma once

#include <cutil.h>

// Number of fractions of request counts tracked per Dos node
const UINT32 KDCDOS_REQUEST_COUNT_FRACTIONS  = 8;

// @@@ Do we want pack(1)? (4)? Or should we leave at default pack(16)?
//#pragma pack(1) 

// Basic structure for maintaining time-of-last-request information. lastRequestTime must 
// not be MAXINT, as it is involved in some math. It gets multipled by 
// KDCDOS_REQUEST_COUNT_FRACTIONS (8 right now), it's max value is really MAXINT/8. It is 
// safe, and even desirable, to steal some bits from it.
struct KdcDosRecord
{
    CListEntry leTable;          // list entry in _pDosTable[]
    CListEntry leLru;            // list entry in _lruList
    UINT64 key;                  // key = xuid, machineId, consoleId, etc
    UINT32 lastRequestTime : 30; // time of last request in seconds since CKdcDos was initialized
    UINT32 fRecordFound    : 1;  // entry existed already or recently allocated?
    UINT32 fInUse          : 1;  // is this (cache) entry currently in use?
    UINT32 allowTime;            // time when key is allowed access again
    BYTE countFractions[KDCDOS_REQUEST_COUNT_FRACTIONS]; // Request count fractions
};

// Templated structure that also, in addition to the DoS functionality, allows one to 
// include cached data.
template <typename CacheDataType>
struct KdcDosRecordCache : public KdcDosRecord
{
    CacheDataType cacheData;   // Arbitrary data to cache in this record
};

enum KDCDOS_STATUS
{
    KDCDOS_OK             = 0,  // Indicates client is good
    KDCDOS_LIMIT_EXCEEDED = 1,  // Limit has just been exceeded and client will be temporarily banned
    KDCDOS_TEMP_BANNED    = 2,  // Client is temporarily banned
    KDCDOS_CACHE_INUSE    = 3,  // Cache is in use by another thread, proceed with caution
    KDCDOS_NO_RECORD      = 4,  // No record could be allocated. This is likely b/c the cache item is in use.
};

// -------------------------------------------------------------------------------------
// CKdcDos
//
// Typical usage (these 2 are equivalent):
// CKdcDosBase<> kdcdos;
// CKdcDos kdcdos;
//
// And then you get all the fine DoS prevention code with none of the caching memory 
// bloat.
// -------------------------------------------------------------------------------------
template <typename KdcDosRecordType = KdcDosRecord>
class CKdcDosBase
{
public:

    USE_ALLOC((*CMemAlloc::Default()));

    CKdcDosBase();
    
    virtual ~CKdcDosBase();
    
    BOOL Init(
        BOOL   enabled,
        UINT32 maxRecords, 
        double sizeRatio, 
        UINT32 maxRequests, 
        UINT32 interval,
        UINT32 blockingTime);
    
    KDCDOS_STATUS Check(UINT64 key);
    
    BOOL   GetEnabled() const { return _enabled; }
    BOOL   SetEnabled(BOOL enabled) 
    { 
        _lock.Lock(); 
        _enabled = enabled; 
        _lock.Unlock(); 
        return TRUE;
    }
    
    UINT32 GetMaxRequests() const { return _maxRequests; }
    BOOL   SetMaxRequests(UINT32 maxRequests) 
    {
        if (maxRequests == 0) 
            return FALSE;
        _lock.Lock(); 
        _maxRequests = maxRequests; 
        _lock.Unlock(); 
        return TRUE;
    }
    
    UINT32 GetInterval() const { return _interval; }
    BOOL   SetInterval(UINT32 interval) 
    { 
        if (interval == 0)
            return FALSE;
        _lock.Lock(); 
        _interval = interval; 
        _lock.Unlock(); 
        return TRUE;
    }

    UINT32 GetBlockingTime() const { return _blockingTime; }
    BOOL   SetBlockingTime(UINT32 blockingTime)
    {
        // this gets added to, should never be max
        if (blockingTime == UINT_MAX)
            return FALSE;
        _lock.Lock(); 
        _blockingTime = blockingTime; 
        _lock.Unlock(); 
        return TRUE;
    }

#ifdef _TEST
    virtual BOOL HasRecord(UINT64 key) { return FALSE; }

    virtual void SetTime(UINT32 time) { };
#endif
    // no HasRecord in non-test version

protected:

    KDCDOS_STATUS UpdateRequestTime(KdcDosRecordType* pRecord);
    
    static UINT32 HashUINT64(UINT64 key);
    
    UINT32 TimeToFraction(UINT32 time);

    KdcDosRecordType* FindDosRecord(UINT64 key);

    KdcDosRecordType* GetDosRecord(UINT64 key);

    KdcDosRecordType* AllocateRecord(UINT64 key);

#ifdef _TEST
    virtual UINT32 GetTime();
#else
    UINT32 GetTime();
#endif
    
    BOOL            _enabled;           // Dos detection is enabled (if FALSE, Check always returns TRUE)
    CList*          _pDosTable;         // Hash table with CLists (for chaining) of KdcDosRecord records
    UINT32          _sizeDosTable;      // Number of slots in _pDosTable
    CList           _lruList;           // List of records in usage order
    UINT32          _countDosRecords;   // Number of records in _pDosRecords
    UINT32          _maxRequests;       // Max number of requests allowed during _interval seconds
    UINT32          _interval;          // The aforementioned interval
    UINT32          _blockingTime;      // Number of seconds to block key if it violates the maximum quota
    IMemAlloc*      _pAlloc;            // Memory allocator
    UINT64          _baseFileTime;      // FILETIME of when CKdcDosBase was initialized 

    KdcDosRecordType* _pDosRecords;     // Array of DoS records

    // None of these data-structures are thread safe. We'll use this lock to serialize 
    // access
    CFastLock       _lock;              
};

// ----------------------------------------------------------------------
// CKdcDosCache<CacheDataType>
//
// This class should be used for both DoS throttling and data caching. The template 
// parameter should be the object type you want to cache. 
//
// Call Check() if you only care about DOS detection.
//
// Call CheckAndAcquire() if you want DOS detection and caching. This will return a 
// pointer to the cache item and indicate if it may be valid or not. It is up to the 
// caller to do any checks of the data contained in the cache item to check for validity.
//
// If CheckAndAcquire() succeeds with KDCDOS_OK, remember to call Release().
//
// ---------------------------------------------------------------------- 
template <typename CacheDataType>
class CKdcDosCache : public CKdcDosBase< KdcDosRecordCache<CacheDataType> >
{
public:

    KDCDOS_STATUS CheckAndAcquire(UINT64 key, CacheDataType **ppData, BOOL *pfCacheDataValid);

    BOOL Release(UINT64 key);

protected:


};

// Handy typedefs for the mainline, no-cache, DoS use case.
typedef CKdcDosBase<> CKdcDos;

//
// Yes, this is right. See comments at top of kdcdos.cpp for why this is necessary. Thanks 
// templates!
//
#include <kdcdos.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\DoS\sources.inc ===
# Copyright (c) Microsoft Corporation.  All rights reserved

INCLUDES=\
    .\..\; \
    $(INCLUDES)

SOURCES=\
#    kdcdos.cpp \
    
USE_LIBCMT=1
XLUSE_CUTIL=1

PRECOMPILED_INCLUDE=..\kdcdosp.h
PRECOMPILED_CXX=1
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\DoS\test\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_kdcdostest_none_12.4.56.0_none_47e0d8d9396f9088
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_kdcdostest_no-public-key_12.4.56.0_x-ww_0f4782a6
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=kdcdostest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_kdcdostest_no-public-key_12.4.56.0_x-ww_0f4782a6
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_kdcdostest_no-public-key_12.4.56.0_x-ww_0f4782a6.manifest
XP_MANIFEST_PATH=manifests\x86_kdcdostest_no-public-key_12.4.56.0_x-ww_0f4782a6.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_kdcdostest_no-public-key_12.4.56.0_x-ww_0f4782a6.cat
XP_CATALOG_PATH=manifests\x86_kdcdostest_no-public-key_12.4.56.0_x-ww_0f4782a6.cat
XP_PAYLOAD_PATH=x86_kdcdostest_no-public-key_12.4.56.0_x-ww_0f4782a6
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=kdcdostest,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\DoS\test\test.cpp ===
// -------------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
// 
// test.cpp
//
// Xbox Live KDC Denial-of-Service detection library
// 
// -------------------------------------------------------------------------------------

#include "kdcdosp.h"
#include "kdcdos.h"
#include "kdcdostest.h"
#include <crtdbg.h>


template <typename KdcDosRecordType>
void TestDetectionBasic(CKdcDosBase<KdcDosRecordType> &dos)
{
    TEST_HEADER();

    // Basic
    {
        TVER(dos.Init(TRUE, 1000, 0.5, 5, 10, 60));

        dos.SetTime(5);
        TVER(dos.Check(0xFA00000000000001) == KDCDOS_OK);
        TVER(dos.Check(0xFA00000000000001) == KDCDOS_OK);
        TVER(dos.Check(0xFA00000000000001) == KDCDOS_OK);
        TVER(dos.Check(0xFA00000000000001) == KDCDOS_OK);
        TVER(dos.Check(0xFA00000000000001) == KDCDOS_OK);
        TVER(dos.Check(0xFA00000000000001) == KDCDOS_LIMIT_EXCEEDED);
        TVER(dos.Check(0xFA00000000000001) == KDCDOS_TEMP_BANNED);
    }
    
Exit:
    return;
}

template <typename KdcDosRecordType>
void TestDetectionDistributed(CKdcDosBase<KdcDosRecordType> &dos)
{
    TEST_HEADER();

    // Distributed 
    {
        TVER(dos.Init(TRUE, 1000, 0.5, 5, 10, 60));

        dos.SetTime(3);
        TVER(dos.Check(0xFA00000000000001) == KDCDOS_OK);
        TVER(dos.Check(0xFA00000000000001) == KDCDOS_OK);
        dos.SetTime(8);
        TVER(dos.Check(0xFA00000000000001) == KDCDOS_OK);
        TVER(dos.Check(0xFA00000000000001) == KDCDOS_OK);
        dos.SetTime(13);
        TVER(dos.Check(0xFA00000000000001) == KDCDOS_OK);
        TVER(dos.Check(0xFA00000000000001) == KDCDOS_OK);
        TVER(dos.Check(0xFA00000000000001) == KDCDOS_OK);
        dos.SetTime(20);
        TVER(dos.Check(0xFA00000000000001) == KDCDOS_OK);
        TVER(dos.Check(0xFA00000000000001) == KDCDOS_OK);
        TVER(dos.Check(0xFA00000000000001) == KDCDOS_LIMIT_EXCEEDED);
        TVER(dos.Check(0xFA00000000000001) == KDCDOS_TEMP_BANNED);
    }
    
Exit:
    return;
}

template <typename KdcDosRecordType>
void TestDetectionBanning(CKdcDosBase<KdcDosRecordType> &dos)
{
    TEST_HEADER();

    // Temporary banning
    {
        TVER(dos.Init(TRUE, 1000, 0.5, 5, 10, 60));

        dos.SetTime(5);
        TVER(dos.Check(0xFA00000000000001) == KDCDOS_OK);
        TVER(dos.Check(0xFA00000000000001) == KDCDOS_OK);
        TVER(dos.Check(0xFA00000000000001) == KDCDOS_OK);
        TVER(dos.Check(0xFA00000000000001) == KDCDOS_OK);
        TVER(dos.Check(0xFA00000000000001) == KDCDOS_OK);
        TVER(dos.Check(0xFA00000000000001) == KDCDOS_LIMIT_EXCEEDED);
        dos.SetTime(30);
        TVER(dos.Check(0xFA00000000000001) == KDCDOS_TEMP_BANNED);
        dos.SetTime(66);
        TVER(dos.Check(0xFA00000000000001) == KDCDOS_OK);
        TVER(dos.Check(0xFA00000000000001) == KDCDOS_OK);
        TVER(dos.Check(0xFA00000000000001) == KDCDOS_OK);
        TVER(dos.Check(0xFA00000000000001) == KDCDOS_OK);
        TVER(dos.Check(0xFA00000000000001) == KDCDOS_OK);
        TVER(dos.Check(0xFA00000000000001) == KDCDOS_LIMIT_EXCEEDED);
    }
    
Exit:
    return;
}

template <typename KdcDosRecordType>
void TestMultipleClients(CKdcDosBase<KdcDosRecordType> &dos)
{
    TEST_HEADER();

    const UINT32 maxRecords = 10000;
    
    TVER(dos.Init(TRUE, maxRecords, 0.5, 1000, 10, 60));

    // Simulate calls from a maximum number of clients

    for(UINT32 i=0; i < maxRecords; i++)
    {
        TVER(dos.Check(0xFA00000000000000 + i) == KDCDOS_OK);
    }

    // Each one of them should have a record

    for(UINT32 i=0; i < maxRecords; i++)
    {
        TVER(dos.HasRecord(0xFA00000000000000 + i))
    }

    // Simulate calls from a second group of clients of size maxClients / 2

    for(UINT32 i=0; i < maxRecords / 2; i++)
    {
        TVER(dos.Check(0xFB00000000000000 + i) == KDCDOS_OK);
    }

    // Each one of them should have a record

    for(UINT32 i=0; i < maxRecords / 2; i++)
    {
        TVER(dos.HasRecord(0xFB00000000000000 + i))
    }

    // But that should have "kicked" half of the clients in first group
    
    for(UINT32 i=0; i < maxRecords / 2; i++)
    {
        TVER(!dos.HasRecord(0xFA00000000000000 + i));
    }

    // The second half should have a record, though
    
    for(UINT32 i=0; i < maxRecords / 2; i++)
    {
        TVER(dos.HasRecord(0xFA00000000000000 + (maxRecords / 2) + i));
    }

Exit:

    return;
}

template <typename KdcDosRecordType>
void TestLruList(CKdcDosBase<KdcDosRecordType> &dos)
{
    TEST_HEADER();
    
    const UINT32 maxRecords = 10000;

    TVER(dos.Init(TRUE, maxRecords, 0.5, 1000, 10, 60));

    // Simulate calls from a maximum number of clients

    for(UINT32 i=0; i < maxRecords; i++)
    {
        TVER(dos.Check(0xFA00000000000000 + i) == KDCDOS_OK);
    }

    // Each one of them should have a record

    for(UINT32 i=0; i < maxRecords; i++)
    {
        TVER(dos.HasRecord(0xFA00000000000000 + i));
    }

    // Simulate extra activity from a hand full of "random" clients

    TVER(dos.Check(0xFA00000000000000 + 1234) == KDCDOS_OK);
    TVER(dos.Check(0xFA00000000000000 + 2134) == KDCDOS_OK);
    TVER(dos.Check(0xFA00000000000000 + 3124) == KDCDOS_OK);
    TVER(dos.Check(0xFA00000000000000 + 4123) == KDCDOS_OK);

    // Introduce a new group of size maxRecords - 4

    for(UINT32 i=0; i < maxRecords - 4; i++)
    {
        TVER(dos.Check(0xFB00000000000000 + i) == KDCDOS_OK);
    }

    // Each one of them should have a record

    for(UINT32 i=0; i < maxRecords - 4; i++)
    {
        TVER(dos.HasRecord(0xFB00000000000000 + i));
    }

    // Only the last 4 of the first group should have remained

    TVER(dos.HasRecord(0xFA00000000000000 + 1234));
    TVER(dos.HasRecord(0xFA00000000000000 + 2134));
    TVER(dos.HasRecord(0xFA00000000000000 + 3124));
    TVER(dos.HasRecord(0xFA00000000000000 + 4123));

Exit:

    return;
}

template <typename CacheType>
void TestCacheInUse(CKdcDosCache<CacheType> &dos)
{
    TEST_HEADER();
    
    const UINT32 maxRecords = 1000;
    CacheType *pData;
    BOOL fValid;

    TVER(dos.Init(TRUE, maxRecords, 0.5, 1000, 10, 60));

    // Acquire but don't release
    TVER(dos.CheckAndAcquire(0xFA00000000000000, &pData, &fValid) == KDCDOS_OK);
    TVER(fValid == FALSE);

    // Simulate calls from a maximum - 1 number of clients

    for(UINT32 i=1; i < maxRecords; i++)
    {
        TVER(dos.CheckAndAcquire(0xFA00000000000000 + i, &pData, &fValid) == KDCDOS_OK);
        // None of these existed prior
        TVER(fValid == FALSE);
    }

    // Each one of them should have a record. Let's release all but last one.

    for(UINT32 i=1; i < maxRecords - 1; i++)
    {
        TVER(dos.Release(0xFA00000000000000 + i));
    }

    // First one should still be in use
    TVER(dos.CheckAndAcquire(0xFA00000000000000, &pData, &fValid) == KDCDOS_CACHE_INUSE);
    
    // Last one should also be in use
    TVER(dos.CheckAndAcquire(0xFA00000000000000 + maxRecords - 1, &pData, &fValid) == KDCDOS_CACHE_INUSE);

    // Release them
    TVER(dos.Release(0xFA00000000000000));
    TVER(dos.Release(0xFA00000000000000 + maxRecords - 1));

    // Ensure nothing is still in use by acquiring again. As a bonus, these all 'exist' 
    // now, so the data should be valid.
    
    for(UINT32 i=0; i < maxRecords; i++)
    {
        TVER(dos.CheckAndAcquire(0xFA00000000000000 + i, &pData, &fValid) == KDCDOS_OK);
        TVER(fValid == TRUE);
    }

Exit:

    return;

}

template <typename CacheType>
void TestCacheNoRecord(CKdcDosCache<CacheType> &dos)
{
    TEST_HEADER();
    
    const UINT32 maxRecords = 1000;
    CacheType *pData;
    BOOL fValid;

    TVER(dos.Init(TRUE, maxRecords, 0.5, 1000, 10, 60));

    // Acquire but don't release
    TVER(dos.CheckAndAcquire(0xFA00000000000000, &pData, &fValid) == KDCDOS_OK);
    TVER(fValid == FALSE);

    // Simulate calls from a maximum - 1 number of clients

    for(UINT32 i=1; i < maxRecords; i++)
    {
        TVER(dos.CheckAndAcquire(0xFA00000000000000 + i, &pData, &fValid) == KDCDOS_OK);
        TVER(fValid == FALSE);
        TVER(dos.Release(0xFA00000000000000 + i));
    }

    // Now check for a new client, which will hit the LRU. But it should be in use.
    
    TVER(dos.CheckAndAcquire(0xFA00000000000000 + maxRecords, &pData, &fValid) == KDCDOS_NO_RECORD);

    // That record got moved to top of LRU. Loop until we hit it, again.

    for(UINT32 i=1; i < maxRecords; i++)
    {
        TVER(dos.CheckAndAcquire(0xFA00000000000000 + maxRecords + i, &pData, &fValid) == KDCDOS_OK);
        TVER(fValid == FALSE);
        TVER(dos.Release(0xFA00000000000000 + maxRecords + i));
    }
    
    // Now check for a new client, which will hit the LRU. But it should be in use.
    
    TVER(dos.CheckAndAcquire(0xFA00000000000000 + maxRecords, &pData, &fValid) == KDCDOS_NO_RECORD);

    // Final release and check

    TVER(dos.Release(0xFA00000000000000));
    TVER(dos.CheckAndAcquire(0xFA00000000000000 + maxRecords, &pData, &fValid) == KDCDOS_OK);
    TVER(fValid == FALSE);
    TVER(dos.CheckAndAcquire(0xFA00000000000000, &pData, &fValid) == KDCDOS_OK);
    TVER(fValid == TRUE);

Exit:

    return;

}

template <typename CacheType>
void TestCacheRelease(CKdcDosCache<CacheType> &dos)
{
    TEST_HEADER();
    
    const UINT32 maxRecords = 1000;
    CacheType *pData;
    BOOL fValid;

    TVER(dos.Init(TRUE, maxRecords, 0.5, 1000, 10, 60));

    TVER(!dos.Release(0xFA00000000000003));

    TVER(dos.CheckAndAcquire(0xFA00000000000000, &pData, &fValid) == KDCDOS_OK);
    TVER(fValid == FALSE);

    TVER(dos.CheckAndAcquire(0xFA00000000000001, &pData, &fValid) == KDCDOS_OK);
    TVER(fValid == FALSE);
    
    TVER(dos.Release(0xFA00000000000000));
    
    TVER(dos.CheckAndAcquire(0xFA00000000000002, &pData, &fValid) == KDCDOS_OK);
    TVER(fValid == FALSE);

    TVER(dos.CheckAndAcquire(0xFA00000000000000, &pData, &fValid) == KDCDOS_OK);
    TVER(fValid == TRUE);

    TVER(dos.Release(0xFA00000000000000));
    TVER(dos.Release(0xFA00000000000001));
    TVER(dos.Release(0xFA00000000000002));
    TVER(!dos.Release(0xFA00000000000003));

    // Flush out history
    for(UINT32 i=0; i < maxRecords; i++)
    {
        TVER(dos.CheckAndAcquire(0xFA00000000000000 + maxRecords + i, &pData, &fValid) == KDCDOS_OK);
        TVER(fValid == FALSE);
        TVER(dos.Release(0xFA00000000000000 + maxRecords + i));
    }

    TVER(!dos.Release(0xFA00000000000000));
    TVER(!dos.Release(0xFA00000000000001));
    TVER(!dos.Release(0xFA00000000000002));
    TVER(!dos.Release(0xFA00000000000003));

Exit:

    return;

}


static void RunDosTests()
{
    printf("Running RunDosTests(), using CKdcDosTest<>\n");
    printf("Info: sizeof(KdcDosRecord) = %u\n", sizeof(KdcDosRecord));
    {
        CKdcDosTest<> dos;
        TestDetectionBasic(dos);
    }

    {
        CKdcDosTest<> dos;
        TestDetectionDistributed(dos);
    }

    {
        CKdcDosTest<> dos;
        TestDetectionBanning(dos);
    }

    {
        CKdcDosTest<> dos;
        TestMultipleClients(dos);
    }

    {
        CKdcDosTest<> dos;
        TestLruList(dos);
    }
}

template <typename CacheType>
static void RunDosCacheTests()
{
    // Repeat existing tests exactly, but use the CKdcDosCache class
    {
        CKdcDosCacheTest<CacheType> dos;
        TestDetectionBasic(dos);
    }

    {
        CKdcDosCacheTest<CacheType> dos;
        TestDetectionDistributed(dos);
    }

    {
        CKdcDosCacheTest<CacheType> dos;
        TestDetectionBanning(dos);
    }

    {
        CKdcDosCacheTest<CacheType> dos;
        TestMultipleClients(dos);
    }

    {
        CKdcDosCacheTest<CacheType> dos;
        TestLruList(dos);
    }

    // Cache-specific tests
    {
        CKdcDosCacheTest<CacheType> dos;
        TestCacheInUse(dos);
    }

    {
        CKdcDosCacheTest<CacheType> dos;
        TestCacheNoRecord(dos);
    }

    {
        CKdcDosCacheTest<CacheType> dos;
        TestCacheRelease(dos);
    }
}


int __cdecl main(int argc, char** argv)
{
    // Set the Crt allocator to debug mode
    _CrtSetReportMode(_CRT_WARN,    _CRTDBG_MODE_FILE);
    _CrtSetReportFile(_CRT_WARN,    _CRTDBG_FILE_STDERR);
    _CrtSetReportMode(_CRT_ERROR,   _CRTDBG_MODE_FILE);
    _CrtSetReportFile(_CRT_ERROR,   _CRTDBG_FILE_STDERR);
    _CrtSetReportMode(_CRT_ASSERT,  _CRTDBG_MODE_FILE);
    _CrtSetReportFile(_CRT_ASSERT,  _CRTDBG_FILE_STDERR);
    _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF ); 
   
    CMemAlloc::Init(CMemAlloc::Crt());
    
    printf("\n");
    printf("------------------------------------------------------------\n");
    printf("Testing CKdcDos (CKdcDosBase<>):\n");
    printf("------------------------------------------------------------\n");
    printf("\n");
    RunDosTests();


    printf("\n");
    printf("------------------------------------------------------------\n");
    printf("Testing CKdcDosCache<...>:\n");
    printf("------------------------------------------------------------\n");
    RUNIT(RunDosCacheTests, BYTE);
    RUNIT(RunDosCacheTests, BigCache);


    printf("\n");
    printf("------------------------------------------------------------\n");
    printf("Testing CKdcDosCache<...>:\n");
    printf("------------------------------------------------------------\n");
    RUNIT(RunDosCacheTests, BYTE);
    RUNIT(RunDosCacheTests, BigCache);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\DoS\test\kdcdostest.h ===
// -------------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
// 
// test.y
//
// Xbox Live KDC Denial-of-Service detection library
// 
// -------------------------------------------------------------------------------------

#pragma once

#define RUNIT(func, type) \
    printf("\nRunning %s<%s>(), using CKdcDosCacheTest<%s>\n", #func, #type, #type); \
    printf("Info: sizeof(%s) = %u\n", #type, sizeof(type)); \
    printf("Info: sizeof(KdcDosRecordCache<%s>) = %u\n", #type, sizeof(KdcDosRecordCache<type>)); \
    (func<type>()); 

#define TEST_HEADER()\
    printf("  Running test %s\n", __FUNCTION__);

#define TVER(x) \
    if(!(x)) { \
        printf("------------------------------------------------------------------------------\n"); \
        printf("Test assertion failed: %s\n", #x); \
        printf("File:%s Line:%u Function:%s \n", __FILE__, __LINE__, __FUNCTION__); \
        printf("------------------------------------------------------------------------------\n"); \
        goto Exit; \
    } 


template <typename KdcDosRecordType = KdcDosRecord>
class CKdcDosTest : public CKdcDos
{
public:

    CKdcDosTest() : 
        _currentTime(0)
    {
    }

    virtual UINT32 GetTime()
    {
        return _currentTime;
    }

    virtual void SetTime(UINT32 time)
    {
        _currentTime = time;
    }

    virtual BOOL HasRecord(UINT64 key)
    {
        // Pick the table slot based on the hash of the key

        UINT32 slot = HashUINT64(key) % _sizeDosTable;
        CList* pList = &_pDosTable[slot];

        // Look for the entry 

        for(CListEntry* ple = pList->GetFirst(); !ple->IsTail(); ple = ple->GetNext())
        {
            KdcDosRecordType* pRec = CONTAINING_RECORD(ple, KdcDosRecordType, leTable);

            if(pRec->key == key)
            {
                // Found a match
                return TRUE;
            }
        }

        return FALSE;
    }

    UINT32 _currentTime;
};


template <typename CacheDataType>
class CKdcDosCacheTest : public CKdcDosCache<CacheDataType>
{
public:

    CKdcDosCacheTest() : 
        _currentTime(0)
    {
    }

    virtual UINT32 GetTime()
    {
        return _currentTime;
    }

    virtual void SetTime(UINT32 time)
    {
        _currentTime = time;
    }

    virtual BOOL HasRecord(UINT64 key)
    {
        // Pick the table slot based on the hash of the key

        UINT32 slot = HashUINT64(key) % _sizeDosTable;
        CList* pList = &_pDosTable[slot];

        // Look for the entry 

        for(CListEntry* ple = pList->GetFirst(); !ple->IsTail(); ple = ple->GetNext())
        {
            KdcDosRecordCache<CacheDataType>* pRec = CONTAINING_RECORD(ple, KdcDosRecordCache<CacheDataType>, leTable);

            if(pRec->key == key)
            {
                // Found a match
                return TRUE;
            }
        }

        return FALSE;
    }

    UINT32 _currentTime;
};


struct BigCache
{
    ULONGLONG qw;
    BYTE b;
    DWORD dw;
    WORD w;
    BYTE array[100];
};


// Prototypes
template <typename KdcDosRecordType> void TestDetectionBasic(CKdcDosBase<KdcDosRecordType> &dos);
template <typename KdcDosRecordType> void TestDetectionDistributed(CKdcDosBase<KdcDosRecordType> &dos);
template <typename KdcDosRecordType> void TestDetectionBanning(CKdcDosBase<KdcDosRecordType> &dos);
template <typename KdcDosRecordType> void TestMultipleClients(CKdcDosBase<KdcDosRecordType> &dos);
template <typename KdcDosRecordType> void TestLruList(CKdcDosBase<KdcDosRecordType> &dos);


// Silly template workarounds
template class CKdcDosCacheTest<BYTE>;
template class CKdcDosCacheTest<BigCache>;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\DoS\test\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_kdcdostest_none_12.4.56.0_none_47e0d8d9396f9088
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_kdcdostest_no-public-key_12.4.56.0_x-ww_0f4782a6
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=kdcdostest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_kdcdostest_no-public-key_12.4.56.0_x-ww_0f4782a6
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_kdcdostest_no-public-key_12.4.56.0_x-ww_0f4782a6.manifest
XP_MANIFEST_PATH=manifests\x86_kdcdostest_no-public-key_12.4.56.0_x-ww_0f4782a6.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_kdcdostest_no-public-key_12.4.56.0_x-ww_0f4782a6.cat
XP_CATALOG_PATH=manifests\x86_kdcdostest_no-public-key_12.4.56.0_x-ww_0f4782a6.cat
XP_PAYLOAD_PATH=x86_kdcdostest_no-public-key_12.4.56.0_x-ww_0f4782a6
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=kdcdostest,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\help\BasePerfCtrs.cpp ===
#include "kdchelpp.h"

//////////////////////////////////////////////////////////////////////////////
CKDCPERFCounters g_Counters;


//////////////////////////////////////////////////////////////////////////////
CKDCPERFCounters::CKDCPERFCounters() :
    m_dwServerObj(0),
    m_hPerfCtr( NULL ),
    m_dwNumPerfCtrs(0),
    m_hServerPerfObj( NULL )
{
}


//////////////////////////////////////////////////////////////////////////////
CKDCPERFCounters::~CKDCPERFCounters()
{
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CKDCPERFCounters::Init()
{
    return E_FAIL;
    //return Init(KDCPERF_SERVER_OBJECT, s_ServerPerfCtrs, NUM_SERVER_PERF_COUNTERS);
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CKDCPERFCounters::Init(DWORD dwServerObj, PERFCOUNTER *hPerfCtr, DWORD dwNumPerfCtrs)
{
	return( S_OK );
}


//////////////////////////////////////////////////////////////////////////////
DWORD CKDCPERFCounters::GetCurrentValue32( DWORD dwCounterID )
{
	return 0;
}


//////////////////////////////////////////////////////////////////////////////
void CKDCPERFCounters::SetCurrentValue32(
                                    DWORD dwCounterID,
                                    DWORD dwVal )
{

}


//////////////////////////////////////////////////////////////////////////////
void CKDCPERFCounters::IncrementValue32(
                                    DWORD dwCounterID,
                                    DWORD dwAmount )
{

}


//////////////////////////////////////////////////////////////////////////////
void CKDCPERFCounters::DecrementValue32(
                                    DWORD dwCounterID,
                                    DWORD dwAmount )
{

}


//////////////////////////////////////////////////////////////////////////////
QWORD CKDCPERFCounters::GetCurrentValue64( DWORD dwCounterID )
{
	return 0;
}


//////////////////////////////////////////////////////////////////////////////
void CKDCPERFCounters::SetCurrentValue64(
                                    DWORD dwCounterID,
                                    QWORD qwVal )
{

}


//////////////////////////////////////////////////////////////////////////////
void CKDCPERFCounters::IncrementValue64(
                                    DWORD dwCounterID,
                                    QWORD qwAmount )
{

}


//////////////////////////////////////////////////////////////////////////////
void CKDCPERFCounters::DecrementValue64(
                                    DWORD dwCounterID,
                                    QWORD qwAmount )
{

}


//////////////////////////////////////////////////////////////////////////////
NTSTATUS
__stdcall
CKDCPERFCounters::Increment(IN KERB_PERF_COUNTER Counter)
{
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\help\BaseAudit.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved
//

#ifndef __BASEAUDIT_H__
#define __BASEAUDIT_H__

#pragma once

//
//  base auditing interface provider
//
class CBaseAudit : public IAudit
{
public:
    NTSTATUS __stdcall Audit(
        IN KDC_AUDIT_EVENT      AuditId,
        IN PIKerbRequest        pIKerbRequest,
        IN PSOCKADDR            ClientAddress,
        IN PKERBERR             pExtError,
        IN PULONG               pKdcOptions,
        IN PKERB_CRYPT_LIST     EncryptionType,
        IN PULONG               pulPreauthType
    );
};

#endif // __BASEAUDIT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\help\BaseLog.h ===
#ifndef   __BASELOG_H__
#define   __BASELOG_H__

#pragma once

#include <stdlib.h>
#include "xmgmt.h"

#ifdef DEFINE_AREAS
#import "CommonConfig.tlb" raw_interfaces_only, no_smart_pointers

XomDefineArea(KdcBase);
#else
XomImportArea(KdcBase);
#endif

#endif // __BASELOG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\help\BasePerfCtrs.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#ifndef PERFCTRS_H_INCLUDED
#define PERFCTRS_H_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//////////////////////////////////////////////////////////////////////////////
enum KDCPC_TYPES
{
    KDCPC_DWORD = 1,
    KDCPC_QWORD = 2
};

struct PERFCOUNTER
{
    KDCPC_TYPES ctrType;
    DWORD dwPerfType;
    DWORD dwDataSize;
    DWORD dwPerfIndex;
    LONG  lDataScale;
    BYTE *pbPerfCtrData;
};

#define DWORD_AVERAGE( INDEX, SCALE ) \
{ KDCPC_DWORD, PERF_AVERAGE_TIMER, sizeof(DWORD), INDEX, SCALE, NULL }

#define DWORD_BASE( INDEX, SCALE ) \
{ KDCPC_DWORD, PERF_AVERAGE_BASE, sizeof(DWORD), INDEX, SCALE, NULL }

#define DWORD_COUNTER( INDEX, SCALE ) \
{ KDCPC_DWORD, PERF_COUNTER_RAWCOUNT, sizeof(DWORD), INDEX, SCALE, NULL }

#define DWORD_RATE( INDEX, SCALE ) \
{ KDCPC_DWORD, PERF_COUNTER_COUNTER, sizeof(DWORD), INDEX, SCALE, NULL }

#define QWORD_AVERAGE( INDEX, SCALE ) \
{ KDCPC_QWORD, PERF_AVERAGE_BULK, sizeof(QWORD), INDEX, SCALE, NULL }

#define QWORD_COUNTER( INDEX, SCALE ) \
{ KDCPC_QWORD, PERF_COUNTER_LARGE_RAWCOUNT, sizeof(QWORD), INDEX, SCALE, NULL }

#define QWORD_RATE( INDEX, SCALE ) \
{ KDCPC_QWORD, PERF_COUNTER_BULK_COUNT, sizeof(QWORD), INDEX, SCALE,  NULL }


//////////////////////////////////////////////////////////////////////////////
class CKDCPERFCounters : public IPerfctr
{
public:
    CKDCPERFCounters();
    ~CKDCPERFCounters();

    HRESULT Init();
    HRESULT Init(DWORD dwServerObj, PERFCOUNTER *hPerfCtr, DWORD cNumPerfCtrs);

    //
    // DWORD counter manipulation routines
    //
    DWORD GetCurrentValue32( DWORD dwCounterID );

    void SetCurrentValue32( DWORD dwCounterID, DWORD dwVal );

    void IncrementValue32( DWORD dwCounterID, DWORD dwAmount );

    void DecrementValue32( DWORD dwCounterID, DWORD dwAmount );

    //
    // QWORD counter manipulation routines
    //
    QWORD GetCurrentValue64( DWORD dwCounterID );

    void SetCurrentValue64( DWORD dwCounterID, QWORD qwVal );

    void IncrementValue64( DWORD dwCounterID, QWORD qwAmount );

    void DecrementValue64( DWORD dwCounterID, QWORD qwAmount );

    // IPerfctr methods required by KDCCore
    NTSTATUS __stdcall Increment( IN KERB_PERF_COUNTER Counter );

protected:
    DWORD       m_dwServerObj;
    PERFCOUNTER *m_hPerfCtr;
    DWORD       m_dwNumPerfCtrs;
    HANDLE      m_hServerPerfObj;
};

extern CKDCPERFCounters g_Counters;


class XAutoCounter
{
public:

    XAutoCounter(DWORD dwCounterID, DWORD dwAmount) :
        m_dwCounterID(dwCounterID),
        m_dwAmount(dwAmount)
    {
        g_Counters.IncrementValue32(m_dwCounterID,
                                    m_dwAmount);
    }

    ~XAutoCounter()
    {
        g_Counters.DecrementValue32(m_dwCounterID,
                                    m_dwAmount);
    }

protected:

    DWORD   m_dwCounterID;
    DWORD   m_dwAmount;
};


#endif  // PERFCTRS_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\help\BaseAudit.cpp ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved
//

#include "kdchelpp.h"
#include "xkdc.h"
#include "xmacsprovider.h"
#include "xmacspreauth.h"

#define MAX_AUDIT_NAME_SIZE  256

//
// changes all none printable characters to '?'
//
void MakeAllPrintableCharacters( WCHAR *wszBuffer );

//
// Determines if the authentication failure is because it's an Xbox 1, and we no longer allow those.
//
BOOL IsXbox1DecommissionFailure(IN PIKerbRequest piReq);


//
//  auditing interface not doing anything ....
//
NTSTATUS __stdcall
CBaseAudit::Audit(
    IN KDC_AUDIT_EVENT      AuditId,
    IN PIKerbRequest        piReq,
    IN PSOCKADDR            ClientAddress,
    IN PKERBERR             pKerbError,
    IN PULONG               pKdcOptions,
    IN PKERB_CRYPT_LIST     EncryptionType,
    IN PULONG               pulPreauthType
)
{
    NTSTATUS status = STATUS_SUCCESS;
    PSOCKADDR_IN ClientAddr = (PSOCKADDR_IN) ClientAddress;
    IKerbPrincipal *piPrinc = NULL;
    const KERB_INTERNAL_NAME *pName = NULL;
    WCHAR wszName[MAX_AUDIT_NAME_SIZE];
    DWORD dwKerbErr = (DWORD) KDC_ERR_NONE;

    XOMASSERT( piReq );
    XOMASSERT( ClientAddress );

    if ( NULL == piReq || NULL == ClientAddress )
    {
        status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    // the core passes NULL for pKerbError in the success cases
    if ( pKerbError )
    {
        dwKerbErr = (DWORD) *pKerbError;
    }
    else
    {
        XOMASSERT( AsFailure != AuditId );
        XOMASSERT( PreauthFailure != AuditId );
        XOMASSERT( TgsFailure != AuditId );
    }

    wszName[0] = L'\0';

    // if client principal was not found, it will be NULL
    piPrinc = piReq->GetIPrincClient();
    if ( NULL != piPrinc )
    {
        pName = piPrinc->GetName();
        if ( NULL == pName )
        {
            status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        if ( 1 == pName->NameCount )
        {
            lstrcpynW(wszName, pName->Names[0].Buffer, ARRAYSIZE(wszName));
        }
        else if ( 2 == pName->NameCount )
        {
            _snwprintf(wszName, ARRAYSIZE(wszName)-1, L"%s/%s", pName->Names[0].Buffer, pName->Names[1].Buffer);
        }
        else
        {
            status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
    }
    else
    {
        KERB_KDC_REQUEST *pkdcReq = (KERB_KDC_REQUEST *)piReq->GetKdcRequest();

        // ensure the pointers we have are valid.
        if ( pkdcReq != NULL && pkdcReq->request_body.client_name.name_string != NULL )
        {
            _snwprintf( wszName, ARRAYSIZE(wszName)-1, L"%S", pkdcReq->request_body.client_name.name_string->value );
            MakeAllPrintableCharacters( wszName );
        }
    }

    switch (AuditId)
    {
    case AsTicket:
        XomTrace( KdcBase, L_HIGH, "KDC Audit: AsTicket. Client: %s, Name: %S",
                  inet_ntoa(ClientAddr->sin_addr),
                  wszName
                  );
        g_Counters.IncrementValue32(ASKDCPERF_SERVER_AS_SUCCESS_COUNTER, 1);
        g_Counters.IncrementValue32(ASKDCPERF_SERVER_AS_SUCCESS_RATE, 1);
        break;

    case AsFailure:
        XomTrace( KdcBase, L_ERROR, "KDC Audit: AsFailure. Client: %s, Name: %S, KerbErr: 0x%02X (%S)",
                  inet_ntoa(ClientAddr->sin_addr),
                  wszName,
                  dwKerbErr,
                  CXBaseProvider::KerbErrToString(dwKerbErr)
                  );
        // don't show an audit log for these types.
        if (   KRB_AP_ERR_SKEW          != dwKerbErr
            && KDC_ERR_SVC_UNAVAILABLE  != dwKerbErr
            && KDC_ERR_SERVICE_NOTYET   != dwKerbErr
            && KDC_ERR_NO_RESPONSE      != dwKerbErr
            && KDC_ERR_TGT_REVOKED      != dwKerbErr
            && KDC_ERR_PREAUTH_REQUIRED != dwKerbErr
            && !IS_KDC_XBOX_ERROR(dwKerbErr)
            && !IsXbox1DecommissionFailure(piReq)
            )
        {
            XomNtEvent( XEVENT_KDC_HACK_6,
                      "KDC Audit: AS Failure.  Client IP: %s, Name: %S, KerbErr: 0x%02X (%S)",
                      inet_ntoa(ClientAddr->sin_addr),
                      wszName,
                      dwKerbErr,
                      CXBaseProvider::KerbErrToString(dwKerbErr)
                      );
        }

        if (KDC_ERR_PREAUTH_REQUIRED != dwKerbErr)
        {
            g_Counters.IncrementValue32(ASKDCPERF_SERVER_AS_FAILURE_COUNTER, 1);
            g_Counters.IncrementValue32(ASKDCPERF_SERVER_AS_FAILURE_RATE, 1);
        }
        break;

    case PreauthFailure:
        XomTrace( KdcBase, L_ERROR, "KDC Audit: PreauthFailure. Client: %s, Name: %S, KerbErr: 0x%02X (%S)",
                  inet_ntoa(ClientAddr->sin_addr),
                  wszName,
                  dwKerbErr,
                  CXBaseProvider::KerbErrToString(dwKerbErr)
                  );

        // don't log NT events for time skew errors as those are expected
        if ( KRB_AP_ERR_SKEW == dwKerbErr )
        {
            g_Counters.IncrementValue32(ASKDCPERF_SERVER_TIMESKEW_COUNTER, 1);
            g_Counters.IncrementValue32(ASKDCPERF_SERVER_TIMESKEW_RATE, 1);
        }
        else if(!IS_KDC_XBOX_ERROR(dwKerbErr) &&
                KDC_ERR_PREAUTH_REQUIRED != dwKerbErr)
        {
            //
            // don't log NT events for preauth failures; data from production shows
            // a steady 1-2% of these errors and that floods the event log. Besides
            // there is an app log line for each if we ever need that data.
            //
            if ( KerbTgs == piReq->GetServId() )
            {
                g_Counters.IncrementValue32(ASKDCPERF_SERVER_TGS_FAILURE_COUNTER, 1);
                g_Counters.IncrementValue32(ASKDCPERF_SERVER_TGS_FAILURE_RATE, 1);
            }
            else if ( KerbAs == piReq->GetServId() )
            {
                g_Counters.IncrementValue32(ASKDCPERF_SERVER_AS_FAILURE_COUNTER, 1);
                g_Counters.IncrementValue32(ASKDCPERF_SERVER_AS_FAILURE_RATE, 1);
            }
            else
            {
                // this shouldn't happen but nothing to worry about on retail builds
                XOMASSERT( FALSE );
            }
        }
        break;

    case TgsSuccess:
        // KDC core does not appear to generate audit events with event id
        // of TgsSuccess.  Instead it uses TgsTicketRequest.  So this code
        // will likely never be called unless the KDC core behavior changes.
        XomTrace( KdcBase, L_HIGH, "Audit: TgsSuccess. Client: %s, Name: %S",
                  inet_ntoa(ClientAddr->sin_addr),
                  wszName
                  );
        g_Counters.IncrementValue32(ASKDCPERF_SERVER_TGS_SUCCESS_COUNTER, 1);
        g_Counters.IncrementValue32(ASKDCPERF_SERVER_TGS_SUCCESS_RATE, 1);
        break;

    case TgsFailure:
        XomTrace( KdcBase, L_ERROR, "KDC Audit: TgsFailure. Client: %s, Name: %S, KerbErr: 0x%02X (%S)",
                  inet_ntoa(ClientAddr->sin_addr),
                  wszName,
                  dwKerbErr,
                  CXBaseProvider::KerbErrToString(dwKerbErr)
                  );
        // don't show an audit log for these types.
        if (   KRB_AP_ERR_SKEW          != dwKerbErr
            && KDC_ERR_SVC_UNAVAILABLE  != dwKerbErr
            && KDC_ERR_SERVICE_NOTYET   != dwKerbErr
            && KDC_ERR_NO_RESPONSE      != dwKerbErr
            && KDC_ERR_TGT_REVOKED      != dwKerbErr
            && !IS_KDC_XBOX_ERROR(dwKerbErr)
            && !IsXbox1DecommissionFailure(piReq)
            )
        {
            XomNtEvent( XEVENT_KDC_HACK_8,
                      "KDC Audit: TGS Failure.  Client IP: %s, Name: %S, KerbErr: 0x%02X (%S)",
                      inet_ntoa(ClientAddr->sin_addr),
                      wszName,
                      dwKerbErr,
                      CXBaseProvider::KerbErrToString(dwKerbErr)
                      );
        }

        g_Counters.IncrementValue32(ASKDCPERF_SERVER_TGS_FAILURE_COUNTER, 1);
        g_Counters.IncrementValue32(ASKDCPERF_SERVER_TGS_FAILURE_RATE, 1);
        break;

    case TicketRenewSuccess:
        // we do not use renewal so log an event in retail if this happens
        XOMASSERT( 0 );
        XomNtEvent( XEVENT_KDC_BASE_AUDIT_TICKET_RENEWAL,
                  "KDC Audit: Ticket Renew Success.  Client IP: %s, Name: %S (this should not happen!)",
                  inet_ntoa(ClientAddr->sin_addr),
                  wszName
                  );
        break;

    case TgsTicketRequest:
        XomTrace( KdcBase, L_HIGH, "KDC Audit: TgsTicketRequest. Client: %s, Name: %S",
                  inet_ntoa(ClientAddr->sin_addr),
                  wszName
                  );
        g_Counters.IncrementValue32(ASKDCPERF_SERVER_TGS_SUCCESS_COUNTER, 1);
        g_Counters.IncrementValue32(ASKDCPERF_SERVER_TGS_SUCCESS_RATE, 1);
        break;
    }

Cleanup:
    return status;
}

//------------------------------------------------------------------
//  MakeAllPrintableCharacters:  Makes all the character printable.
//------------------------------------------------------------------
void MakeAllPrintableCharacters( WCHAR *wszBuffer )
{
    WCHAR nCurChar = 0;
    int nX = 0;                              // look counter

    if ( wszBuffer == NULL )
    {
        return;
    }

    nCurChar = wszBuffer[0];             // current character

    while ( nCurChar != 0 )
    {
        // check if this is a printable character.
        if ( iswprint( nCurChar ) == 0 )
        {
            wszBuffer[nX] = L'?';
        }

        // inc to next position.
        nX++;
        nCurChar = wszBuffer[nX];
    }

}

//------------------------------------------------------------------
// Determines if the authentication failure is because it's an Xbox 1,
// and we no longer allow those.
//
// This is a best guess, based on the logging status in the request.
//
// Any failures just result in returning FALSE.
//------------------------------------------------------------------
BOOL IsXbox1DecommissionFailure(IN PIKerbRequest piReq)
{
    NTSTATUS status = STATUS_SUCCESS;
    IPAXMACSRequest *pReqInf = NULL;
    IPAXboxLogData *piXboxLog = NULL;

    // The GetPAHandler calls return objects in all cases here, so I need
    // to try the different methods until we return true or run out of methods.

    // Try the XMACS version...
    if (NT_SUCCESS(piReq->GetPAHandler(IID_IPAXMACSRequest, ((PVOID*)&pReqInf))))
    {
        QWORD qwXmacsRequestStatus = 0;
        if (NT_SUCCESS(pReqInf->GetRequestStatus(&qwXmacsRequestStatus)))
        {
            if ((qwXmacsRequestStatus & REQSTAT_XBOX1_DECOMMISSION) == REQSTAT_XBOX1_DECOMMISSION)
            {
                return TRUE;
            }
        }
    }

    // Nope. Try the XKDC version...
    status = piReq->GetPAHandler(IID_IPAXboxLogData, (PVOID*)&piXboxLog);
    if (NT_SUCCESS(status) && (piXboxLog != NULL))
    {
        XKDC_LOGGINGDATA *pLogData = NULL;
        status = piXboxLog->GetLogData( &pLogData );
        if (NT_SUCCESS(status) && (pLogData != NULL))
        {
            if ((pLogData->m_qwReqStatus & XKDC_REQSTATUS_XBOX1_DECOMMISSION) == XKDC_REQSTATUS_XBOX1_DECOMMISSION)
            {
                return TRUE;
            }
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\help\BasePrincipal.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved
//

#ifndef __BASEPRINCIPAL_H__
#define __BASEPRINCIPAL_H__

#pragma once

#include "KdcProvider.h"
#include "cryptoHelper.h"

// these should really be defined in a KDCCore header file
#ifndef KERB_KDB_DATA_ALL
typedef DWORD PRINC_DATA_FLAGS;
#define KERB_KDB_DATA_ALL               0xffffffff
#define KERB_KDB_DATA_LOGON_TIME        0x00000001
#define KERB_KDB_DATA_KEYS              0x00000002
#endif

// forward declarations
struct XKDC_PRINCIPAL;
struct XKDC_KEY;


#define XKDC_KEYSIZE 16

struct XkdcKey
{
    DWORD dwKeyVersion;
    KERB_ENCRYPTION_KEY Key;
};

struct XkdcCredential
{
    DWORD dwKeyCount;
    XkdcKey Key[ANYSIZE_ARRAY];
};

// Xbox basic implementation of the IKerbPrincipal interface.  This can
// be subclassed if additional functionality is required (additional 
// encryption types, etc.)
class CXBasePrincipal : public IKerbPrincipal, public IKDBLogonInfo, public IKDCPrincipalWithMultipleKeys
{
public:
    CXBasePrincipal();
    virtual ~CXBasePrincipal();

    //
    //    IKerbPrincipal methods
    //
    virtual void __stdcall Release(void);

    const KERB_INTERNAL_NAME * __stdcall GetName()
    {
        return m_pkinName;
    };

    //
    //  does not do canonicalization - so just return the name
    //
    PKERB_INTERNAL_NAME  __stdcall GetCanonicalName()
    {
        return m_pkinName;
    };

    const UNICODE_STRING * __stdcall GetRealm()
    {
        return m_pustrRealm;
    };

    PRINC_FLAGS GetPrincFlags(void)
    {
        return m_PrincFlags;
    }

    //
    //  Principal's expiry, lifespan and max time for ticket renewal
    //
    virtual LARGE_INTEGER __stdcall Expiration()
    {
        LARGE_INTEGER ret;
        ret.QuadPart = KERB_KDB_TIME_NEVER;
        return  ret;
    };

    virtual LARGE_INTEGER __stdcall MaxLifeTime()
    {
        return m_MaxLifeTime;
    };

    virtual LARGE_INTEGER __stdcall MaxRenewTime()
    {
        LARGE_INTEGER ret;
        ret.QuadPart = KERB_KDB_TIME_NEVER;
        return  ret;
    };

    virtual void __stdcall SetMaxLifeTime(LARGE_INTEGER liMaxLifeTime)
    {
        m_MaxLifeTime = liMaxLifeTime;
    }

    //
    // By default don't return a PAC
    // 
    virtual BOOL __stdcall IsPacRequested()
    {
        return FALSE;
    }

    KERBERR __stdcall GetCiphertextSize(
                IN  PKERB_CRYPT_LIST     pEtypes,
                IN  ULONG                cbIn,
                OUT PULONG               pcbOut);

    NTSTATUS __stdcall Encrypt(
        IN PKERB_CRYPT_LIST         pEtypes,    //types preferred
        IN  SALTFLAGS               saltflags,  //salt flags
        IN  PBYTE                   pbIn,       //buffer to encrypt
        IN  ULONG                   cbIn,       //size of buffer to encrypt
        OUT PKERB_ENCRYPTED_DATA    pData,      //encrypted data
        OUT PKERB_EXT_ERROR         pExtendedError);

    NTSTATUS __stdcall Decrypt(
        IN  const KERB_CRYPT_LIST *      pEtypes,
        IN  SALTFLAGS               saltflags,
        IN  const KERB_ENCRYPTED_DATA *   pData,
        OUT PBYTE                   pbOut,
        OUT PULONG                  pcbOut,
        OUT OPTIONAL PETYPE         pEtype,
        OUT PKERB_EXT_ERROR         pExtendedError);


    NTSTATUS __stdcall GetChecksumSize(
                IN  CTYPE                Ctype,
                OUT PULONG               pcbOut);

    NTSTATUS __stdcall Checksum(
                IN  CTYPE                Ctype,
                IN  SALTFLAGS            saltflags,
                IN  PKERB_CRYPT_LIST     pEtypes,
                IN  PBYTE               *rgpbBuffers,
                IN  ULONG               *rgcbBuffers,
                IN  ULONG                cBuffers,
                IN  PBYTE                pbVerify,     // OPTIONAL
                IN  ULONG                cbVerify,     // OPTIONAL
                OUT PBYTE                pbChecksum,   // OPTIONAL
                OUT PULONG               pcbChecksum,  // OPTIONAL
                OUT PBOOLEAN             pfVerified,   // OPTIONAL
                OUT PKERB_EXT_ERROR      pExtendedError);

    NTSTATUS __stdcall GetEtypes(
                OUT const ETYPE **ppEtypes,
                OUT PULONG      pcEtypes
    );

    KERBERR __stdcall GetEtypeMatch(
        IN  PKERB_CRYPT_LIST pEtypes,
        OUT PKERB_ETYPE_INFO *ppEtypeInfo
    );

    // IKDBLogonInfo methods
    HRESULT __stdcall QueryInterface(
        IN    REFIID    refiid,
        OUT    PVOID    *ppv
    );

    // Exposed from the IKerbPrincipal using QueryInterface method with
    // refiid == const GUID IID_IKDBLogonInfo
    NTSTATUS __stdcall GetWindowsLogonInfo(const KERB_PAC_USER_ALL_INFORMATION**);
    NTSTATUS __stdcall GetIdentityInfo(const IDENTITY **ppId);
    NTSTATUS __stdcall SetCredentialType(CREDTYPE credType);

    //
    //    Implementation specific methods - not part of IKerbPrincipal but
    //    used by the provider
    //
    NTSTATUS __stdcall Initialize(
        IN    IKdbProvider             *pIKdbProvider,
        IN    IKdcCore                 *pIKdcCore,
        IN    PUNICODE_STRING           pustrRealm,
        IN    XKDC_PRINCIPAL           *pKdbPrinc,
        IN    XkdcCredential           *pCred,
        IN    LARGE_INTEGER             MaxLifeTime,
        IN    LARGE_INTEGER             MaxRenewTime,
        IN    INT                       LastModified,
        IN    INT                       Expiration,
        IN    PRINC_DATA_FLAGS          PrincDataFlags
    );

    IKdbProvider * __stdcall GetIKdbProvider(void);

    // IKDCPrincipalWithMultipleKeys
    virtual BOOL __stdcall NextKey();

protected:
    // These methods are not part of the IKerbPrincipal interface but are
    // likely to be common to any Xbox KDC.

    // Memory allocation functions.  By declaring these here and using them
    // throughout the implementation, it should be straightforward to use a
    // different allocator if the need should arise.
    PVOID (WINAPI *KdcAllocMemory)(IN size_t cSize);
    void (WINAPI *KdcFreeMemory)(IN PVOID pAddress);

    IKdbProvider            *m_pIKdbProvider;       // the IKdbProvider that created this object.
    IKdcCore                *m_pIKdcCore;           // the Kdc Core associated with the provider
    IKerbCrypt              *m_pIKerbCrypt;         // the IKerbCrypt provider

    ETYPE                   m_Etype;
    ULONG                   m_cEtypes;              // same as m_pKey->CredentialCount

    PKERB_INTERNAL_NAME         m_pkinName;
    PUNICODE_STRING             m_pustrRealm;

    // the index of the key which successfully decrypted
    DWORD                   m_dwKeyIndex;

    // array containing versions of all keys for the principal
    XkdcCredential          *m_pCred;
    
private:    
    //
    //    Private data matches KDB_PRINC_INFO
    //
    PRINC_DATA_FLAGS               m_PrincDataFlags;  // What data is present
    //#define KERB_KDB_DATA_ALL               0xffffffff
    //#define KERB_KDB_DATA_LOGON_TIME        0x00000001
    //#define KERB_KDB_DATA_KEYS              0x00000002

    PRINC_FLAGS                 m_PrincFlags;
    //#define KERB_KDB_DISALLOW_POSTDATED     0x00000001
    //#define KERB_KDB_DISALLOW_FORWARDABLE   0x00000002
    //#define KERB_KDB_DISALLOW_RENEWABLE     0x00000004
    //#define KERB_KDB_DISALLOW_PROXIABLE     0x00000008
    //#define KERB_KDB_REQUIRE_USER2USER      0x00000010
    //#define KERB_KDB_DISALLOW_S4U2PROXY     0x00000020
    //#define KERB_KDB_DISALLOW_ALL_TIX       0x00000040
    //#define KERB_KDB_REQUIRES_PRE_AUTH      0x00000080
    //#define KERB_KDB_REQUIRES_PWCHANGE      0x00000100
    //#define KERB_KDB_DISALLOW_SVR           0x00000200
    //#define KERB_KDB_OK_AS_DELEGATE         0x00000400

    KERB_ACCOUNT_TYPE   m_PrincipalType;          // Special account type


    LARGE_INTEGER       m_MaxLifeTime;            // Max ticket lifetime
    LARGE_INTEGER       m_MaxRenewTime;           // Max renew lifetime
    LARGE_INTEGER       m_LastModified;           // Time principal modified
    LARGE_INTEGER       m_Expiration;             // Time principal expires
    LARGE_INTEGER       m_LastLogon;              // KERB_KDB_DATA_LOGON_TIME
    LARGE_INTEGER       m_LastFailedLogon;        // KERB_KDB_DATA_LOGON_TIME
    //#define KERB_KDB_TIME_NEVER (-1)

    SOCKADDR            m_saLastLogonClient;        // KERB_KDC_DATA_LOGON_TIME

    //
    //    Private methods
    //
    BOOLEAN __stdcall CheckForEtype(
            IN const KERB_CRYPT_LIST * pEtypes,
            IN ULONG            Etype);


};

// Xbox-specifc data structures used to represent principals as stored in
// our database.  Used by BaseProvider to build KDC specific types and
// instantiate a new principal.  This may need to be augmented with new
// fields such as last logon time, etc. for use in a provider other than
// the Xkdc.

// miscellaneous constants
#define XKDC_PRINCIPAL_MAX 100
#define XKDC_KEYSIZE 16
#define XKDC_MAX_KEY_VERSIONS 2
#define XKDC_SERVICE_NAME_MAX 30

// principal and key structures
typedef struct XKDC_KEY
{
    LONG    lKeyVersion;
    BYTE    binKey[XKDC_KEYSIZE];
} XKDC_KEY;

typedef struct XKDC_PRINCIPAL
{
    WCHAR       wszServiceName[XKDC_PRINCIPAL_MAX+1];
    WCHAR       wszDomainName[XKDC_PRINCIPAL_MAX+1];
    INT         iType;
    INT         iFlags;
    INT         iNumKeys;
    XKDC_KEY    rgKey[XKDC_MAX_KEY_VERSIONS];
} XKDC_PRINCIPAL, *PXKDC_PRINCIPAL;

typedef struct XKDC_SERVICE_INFO
{
    DWORD   dwServiceId;
    DWORD   dwSiteIPAddress;
    WORD    wServicePort;
    WCHAR   wszName[XKDC_SERVICE_NAME_MAX+1];
} XKDC_SERVICE_INFO;

#endif // __BASEPRINCIPAL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\help\BasePrincipal.cpp ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved
//
#include "kdchelpp.h"


//-----------------------------------------------------------------------------
//                                IKerbPrincipal
//-----------------------------------------------------------------------------
CXBasePrincipal::CXBasePrincipal()
    : m_PrincDataFlags(0),
      m_pkinName(NULL),
      m_pustrRealm(NULL),
      m_PrincFlags(0),
      m_PrincipalType(UnknownAccount),
      m_pCred(NULL),
      m_dwKeyIndex(0),
      m_pIKdbProvider(NULL),
      m_pIKerbCrypt(NULL),
      m_Etype(KERB_ETYPE_RC4_HMAC_NT),
      m_cEtypes(0),
      KdcAllocMemory(NULL),
      KdcFreeMemory(NULL)
{
    m_MaxLifeTime.QuadPart = 0;
    m_MaxRenewTime.QuadPart = 0;
    m_LastModified.QuadPart = 0;
    m_Expiration.QuadPart = 0;
    m_LastLogon.QuadPart = 0;
    m_LastFailedLogon.QuadPart = 0;
    m_LastFailedLogon.QuadPart = 0;
    ZeroMemory(&m_saLastLogonClient, sizeof(SOCKADDR));
}

CXBasePrincipal::~CXBasePrincipal()
{
    if ( KdcFreeMemory )
    {
        if ( m_pkinName )
        {
            KdcFreeMemory(m_pkinName);
            m_pkinName = NULL;
        }

        if ( m_pCred )
        {
            KdcFreeMemory(m_pCred);
            m_pCred = NULL;
        }
    }
}


void
__stdcall
CXBasePrincipal::Release(void)
{
    delete this;
}


//
//    The core will use QueryInterface with guids like IID_IKDBLogonInfo
//    to get at the data.
//
HRESULT
__stdcall
CXBasePrincipal::QueryInterface(
    IN    REFIID    refiid,
    OUT    PVOID    *ppv
)
{
    HRESULT    hr = E_NOINTERFACE;

    *ppv = NULL;
    if ( IsEqualGUID(refiid, IID_IKDBLogonInfo ))
    {
        *ppv = (PVOID)( static_cast<IKDBLogonInfo*>(this) );
        hr = S_OK;
    }
    else if ( IsEqualGUID(refiid, IID_IKDCPrincipalWithMultipleKeys) )
    {
        *ppv = (PVOID)( static_cast<IKDCPrincipalWithMultipleKeys*>(this) );
        hr = S_OK;
    }
    
    return hr;
}


//
//    IKDBLogonInfo
//
NTSTATUS
__stdcall
CXBasePrincipal::GetWindowsLogonInfo(const KERB_PAC_USER_ALL_INFORMATION**ppKerbPacUserAllInfo)
{
    NTSTATUS status = STATUS_SUCCESS;
    static KERB_PAC_USER_ALL_INFORMATION KerbPacUALL = {0};

    if ( ppKerbPacUserAllInfo == NULL )
    {
        status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    // TODO: should only need to zero this once but this is a kludge after all
    ZeroMemory(&KerbPacUALL, sizeof(KerbPacUALL));

    *ppKerbPacUserAllInfo = &KerbPacUALL;

Cleanup:
    return status;
}


NTSTATUS
__stdcall
CXBasePrincipal::GetIdentityInfo(const IDENTITY **ppId)
{
    NTSTATUS status = STATUS_SUCCESS;
    LARGE_INTEGER SamplePuid = {0,0};
    static IDENTITY SampleInfo = {
        FIELD_OFFSET(IDENTITY, Identity) + sizeof(LARGE_INTEGER),
        0,
        ID_PUID,
        CT_Password
    };

    *(LARGE_INTEGER*)SampleInfo.Identity = SamplePuid;
    return status;
}

NTSTATUS
__stdcall
CXBasePrincipal::SetCredentialType(CREDTYPE credType)
{
    return STATUS_NOT_IMPLEMENTED;
}

IKdbProvider *
__stdcall
CXBasePrincipal::GetIKdbProvider(void)
{
    return m_pIKdbProvider;
}


KERBERR
__stdcall
CXBasePrincipal::GetCiphertextSize(
    IN  PKERB_CRYPT_LIST     pEtypes,
    IN  ULONG                cbIn,
    OUT PULONG               pcbOut)
{
    XOMASSERT(m_pIKerbCrypt);
    KERBERR KerbErr = KDC_ERR_NONE;

    if ( !CheckForEtype(pEtypes, KERB_ETYPE_RC4_HMAC_NT) )
    {
        KerbErr = KDC_ERR_ETYPE_NOTSUPP;
        goto Cleanup;
    }

    KerbErr = m_pIKerbCrypt->GetCiphertextSize(
                    KERB_ETYPE_RC4_HMAC_NT,
                    cbIn,
                    pcbOut);
Cleanup:
    return KerbErr;
}


KERBERR
__stdcall
CXBasePrincipal::Encrypt(
    IN PKERB_CRYPT_LIST pEtypes,//types preferred
    IN  SALTFLAGS   saltflags,  //salt flags
    IN  PBYTE       pbIn,       //buffer to encrypt
    IN  ULONG       cbIn,       //size of buffer to encrypt
    OUT PKERB_ENCRYPTED_DATA      pData,   //encrypted data
    OUT PKERB_EXT_ERROR pExtendedError
)
{
    KERBERR         KerbErr;
    PKERB_KEY_DATA  pKeydata = NULL;
    NTSTATUS        status = STATUS_SUCCESS;

    XOMASSERT( m_pCred && m_pCred->dwKeyCount > 0 );
    if ( NULL == m_pCred || 0 == m_pCred->dwKeyCount )
    {
        // TODO: log the error
        KerbErr = KDC_ERR_NULL_KEY;
        pExtendedError->flags = __LINE__;
        goto Cleanup;
    }

    XOMASSERT( m_dwKeyIndex < m_pCred->dwKeyCount );
    if ( m_dwKeyIndex >= m_pCred->dwKeyCount )
    {
        // TODO: log the error
        KerbErr = KDC_ERR_NULL_KEY;
        pExtendedError->flags = __LINE__;
        goto Cleanup;
    }

    XOMASSERT( m_pIKerbCrypt );
    if ( NULL == m_pIKerbCrypt )
    {
        XomNtEvent( XEVENT_KDC_BASE_BAD_KERBCRYPT_1, "CXBasePrincipal::Encrypt invalid KerbCrypt provider.");
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    KerbErr = m_pIKerbCrypt->Encrypt(
                        &m_pCred->Key[m_dwKeyIndex].Key,
                        m_pCred->Key[m_dwKeyIndex].dwKeyVersion,
                        saltflags,
                        pbIn,
                        cbIn,
                        pData);

    if (!KERB_SUCCESS(KerbErr))
    {
        //
        //    TBD: log the problem.
        //
        pExtendedError->flags = __LINE__;
        goto Cleanup;
    }

    if ( m_pCred->dwKeyCount > 1 )
    {
        XOMASSERT( m_pkinName->NameCount > 1 );
        if ( m_pkinName->NameCount > 1 )
        {
            XomTrace( KdcBase, L_LOW, "(%s:%d) CXBasePrincipal::Encrypt: '%S/%S' encrypted successfully using key version %d.",
                __FILE__,
                __LINE__,
                m_pkinName->Names[0].Buffer,
                m_pkinName->Names[1].Buffer,
                m_pCred->Key[m_dwKeyIndex].dwKeyVersion);
        }
    }

Cleanup:
    //pExtendedError->klininfo = file number;
    pExtendedError->status = status;
    return KerbErr;

}


KERBERR
__stdcall
CXBasePrincipal::Decrypt(
    IN  const KERB_CRYPT_LIST * pEtypes,
    IN  SALTFLAGS               saltflags,
    IN  const KERB_ENCRYPTED_DATA *   pData,
    OUT PBYTE                   pbOut,
    OUT PULONG                  pcbOut,
    OUT OPTIONAL PETYPE         pEtype,
    OUT PKERB_EXT_ERROR pExtendedError)
{
    KERBERR          KerbErr = KDC_ERR_NONE;
    PKERB_KEY_DATA   pKeydata = NULL;
    NTSTATUS         status = STATUS_SUCCESS;

    PBYTE pScratch = NULL;
    ULONG cScratch = 0;

    XOMASSERT( pEtypes );
    XOMASSERT( pbOut );
    XOMASSERT( pcbOut );
    XOMASSERT( pExtendedError );

    if ( NULL == pEtypes || NULL == pbOut || NULL == pcbOut || NULL == pExtendedError )
    {
        XomTrace( KdcBase, L_ERROR, "CXBasePrincipal::Decrypt: invalid parameter.");
        status = STATUS_INVALID_PARAMETER;
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    XOMASSERT( m_pIKerbCrypt );
    if ( NULL == m_pIKerbCrypt )
    {
        XomTrace( KdcBase, L_ERROR, "CXBasePrincipal::Decrypt invalid KerbCrypt provider.");
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    XOMASSERT( m_pCred );
    if ( NULL == m_pCred )
    {
        XomTrace( KdcBase, L_ERROR, "CXBasePrincipal::Decrypt no credential list.");
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    // make sure that RC4-HMAC is supported
    if ( !CheckForEtype(pEtypes, KERB_ETYPE_RC4_HMAC_NT) )
    {
        // TODO: fix event id
        XomNtEvent( XEVENT_KDC_BASE_BAD_ETYPE, "CXBasePrincipal::Decrypt: RC4-HMAC not supported by client.  Request possibly from non-Xbox client.");
        status = STATUS_NOT_FOUND;
        KerbErr = KDC_ERR_ETYPE_NOTSUPP;
        goto Cleanup;
    }

    // Allocate a buffer to decrypt into.  If the caller is trying to decrypt
    // in place, we can't overwrite the ciphertext in case there are multiple
    // keys and the one that decrypts the ciphertext is not the first one.
    cScratch = pData->cipher_text.length;
    pScratch = (PBYTE) KdcAllocMemory( cScratch );

    for (DWORD i=0; i<m_pCred->dwKeyCount; i++)
    {
        KerbErr = m_pIKerbCrypt->Decrypt(
                            pData,
                            &m_pCred->Key[i].Key,
                            saltflags,
                            pScratch,
                            &cScratch);

        // if this key version decrypts successfully, leave now
        if ( KERB_SUCCESS(KerbErr) )
        {
            // save the index of which key successfully decrypted
            // so it can be used later for encryption
            m_dwKeyIndex = i;

            // copy the decrypted data into the output buffer
            memcpy(pbOut, pScratch, cScratch);

            if ( m_pCred->dwKeyCount > 1 )
            {
                XOMASSERT( m_pkinName->NameCount > 1 );
                if ( m_pkinName->NameCount > 1 )
                {
                    XomTrace( KdcBase, L_LOW, "(%s:%d) CXBasePrincipal::Decrypt: '%S/%S' decrypted successfully using key version %d.",
                        __FILE__,
                        __LINE__,
                        m_pkinName->Names[0].Buffer,
                        m_pkinName->Names[1].Buffer,
                        m_pCred->Key[m_dwKeyIndex].dwKeyVersion);
                }
            }

            break;
        }
    }

    // none of the keys decrypted successfully
    if ( !KERB_SUCCESS(KerbErr) )
    {
        // TODO: log an error?
        pExtendedError->flags = __LINE__;
        goto Cleanup;
    }

Cleanup:
    if ( pScratch )
    {
        KdcFreeMemory( pScratch );
    }

    pExtendedError->status = status;
    return KerbErr;
}


NTSTATUS
__stdcall
CXBasePrincipal::GetChecksumSize(
    IN  CTYPE                Ctype,
    OUT PULONG               pcbOut)
{
    XOMASSERT(m_pIKerbCrypt);
    return m_pIKerbCrypt->GetChecksumSize(Ctype, pcbOut);
}


NTSTATUS
__stdcall
CXBasePrincipal::Checksum(
    IN  CTYPE                Ctype,
    IN  SALTFLAGS            saltflags,
    IN  PKERB_CRYPT_LIST     pEtypes,
    IN  PBYTE               *rgpbBuffers,
    IN  ULONG               *rgcbBuffers,
    IN  ULONG                cBuffers,
    IN  PBYTE                pbVerify,     // OPTIONAL
    IN  ULONG                cbVerify,     // OPTIONAL
    OUT PBYTE                pbChecksum,   // OPTIONAL
    OUT PULONG               pcbChecksum,  // OPTIONAL
    OUT PBOOLEAN             pfVerified,   // OPTIONAL
    OUT PKERB_EXT_ERROR      pExtendedError
)
{
    const KERB_ENCRYPTION_KEY *pKey = NULL;
    NTSTATUS status = STATUS_SUCCESS;

    XOMASSERT( pEtypes );
    XOMASSERT( rgpbBuffers );
    XOMASSERT( rgcbBuffers );
    XOMASSERT( pExtendedError );

    if ( NULL == pEtypes || NULL == rgpbBuffers || NULL == rgcbBuffers || NULL == pExtendedError )
    {
        XomTrace( KdcBase, L_ERROR, "CXBasePrincipal::Checksum: invalid parameter.");
        status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    XOMASSERT( m_pIKerbCrypt );
    if ( NULL == m_pIKerbCrypt )
    {
        XomTrace( KdcBase, L_ERROR, "CXBasePrincipal::Checksum invalid KerbCrypt provider.");
        status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    XOMASSERT( m_pCred );
    if ( NULL == m_pCred )
    {
        XomTrace( KdcBase, L_ERROR, "CXBasePrincipal::Checksum no credential list.");
        status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    status = m_pIKerbCrypt->Checksum(
                    Ctype,
                    saltflags,
                    &m_pCred->Key[m_dwKeyIndex].Key,
                    rgpbBuffers,
                    rgcbBuffers,
                    cBuffers,
                    pbVerify,
                    cbVerify,
                    pbChecksum,
                    pcbChecksum,
                    pfVerified );

Cleanup:
    pExtendedError->status = status;
    return status;
}


//
//    Return the list of etypes.
//
NTSTATUS
__stdcall
CXBasePrincipal::GetEtypes(
    OUT  const ETYPE **ppEtypes,
    OUT PULONG         pcEtypes
)
{
    // we only have the single etype - KERB_ETYPE_RC4_HMAC_NT
    *ppEtypes = &m_Etype;
    *pcEtypes = 1;

    return ( 0 == *pcEtypes ) ? STATUS_NO_USER_KEYS : STATUS_SUCCESS;
}


//
//    Given a list of etypes, return the list of common etypes.
//    Most of the original code removed since we only support RC4-HMAC.
//
KERBERR
__stdcall
CXBasePrincipal::GetEtypeMatch(
    IN  PKERB_CRYPT_LIST  pEtypes,
    OUT PKERB_ETYPE_INFO *ppEtypeInfo
)
{
    PKERB_ETYPE_INFO pEtypeInfo = NULL;
    KERBERR KerbErr = KDC_ERR_NONE;

    // we only support RC4-HMAC
    if ( CheckForEtype(pEtypes, KERB_ETYPE_RC4_HMAC_NT) )
    {
        pEtypeInfo = (PKERB_ETYPE_INFO) KdcAllocMemory(sizeof(KERB_ETYPE_INFO));
        if ( NULL == pEtypeInfo )
        {
            KerbErr = KRB_ERR_GENERIC;
        }
        else
        {
            ZeroMemory(pEtypeInfo, sizeof(KERB_ETYPE_INFO));

            pEtypeInfo->value.encryption_type = KERB_ETYPE_RC4_HMAC_NT;

            *ppEtypeInfo = pEtypeInfo;
            pEtypeInfo = NULL;
        }
    }

    return KerbErr;
}


//
//    CXBasePrincipal methods internal to the provider
//
NTSTATUS
__stdcall
CXBasePrincipal::Initialize(
    IN    IKdbProvider     *pIKdbProvider,
    IN    IKdcCore         *pIKdcCore,
    IN    PUNICODE_STRING   pustrRealm,
    IN    PXKDC_PRINCIPAL   pKdbPrinc,
    IN    XkdcCredential   *pCred,
    IN    LARGE_INTEGER     MaxLifeTime,
    IN    LARGE_INTEGER     MaxRenewTime,
    IN    INT               LastModified,
    IN    INT               Expiration,
    IN    PRINC_DATA_FLAGS  PrincDataFlags
)
{
    CXBaseProvider *pProv = NULL;
    UNICODE_STRING ServiceName = {0};
    UNICODE_STRING DomainName = {0};

    NTSTATUS status = STATUS_SUCCESS;

    XOMASSERT( pIKdbProvider );
    if ( NULL == pIKdbProvider )
    {
        return STATUS_INVALID_PARAMETER;
    }
    pProv = (CXBaseProvider*) pIKdbProvider;

    XOMASSERT( pIKdcCore );
    XOMASSERT( pustrRealm );
    XOMASSERT( pKdbPrinc );
    if ( NULL == pIKdcCore || NULL == pustrRealm || NULL == pKdbPrinc )
    {
        XomTrace( KdcBase, L_ERROR, "CXBasePrincipal::Initialize: invalid parameter.");
        return STATUS_INVALID_PARAMETER;
    }

    m_pIKdcCore = pIKdcCore;
    m_pIKdbProvider = pIKdbProvider;

    KdcAllocMemory = pProv->KdcAllocMemory;
    KdcFreeMemory = pProv->KdcFreeMemory;

    XOMASSERT( KdcAllocMemory && KdcFreeMemory );
    if ( NULL == KdcAllocMemory || NULL == KdcFreeMemory )
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Build the principal name components
    //
    RtlInitUnicodeString(&ServiceName, pKdbPrinc->wszServiceName);
    RtlInitUnicodeString(&DomainName, pKdbPrinc->wszDomainName);

    status = m_pIKdcCore->pfnKerbBuildFullServiceKdcName(
                &DomainName,
                &ServiceName,
                KRB_NT_SRV_INST,
                &m_pkinName
                );
    if (!NT_SUCCESS(status))
    {
        goto Cleanup;
    }

    //
    //    This string lives in the provider
    //
    m_pustrRealm = pustrRealm;
    m_PrincFlags = pKdbPrinc->iFlags;

    m_MaxLifeTime = MaxLifeTime;
    m_MaxRenewTime = MaxRenewTime;

    m_LastModified.QuadPart = LastModified;
    m_Expiration.QuadPart = Expiration;

    m_LastLogon.QuadPart = KERB_KDB_TIME_NEVER;
    m_LastFailedLogon.QuadPart = KERB_KDB_TIME_NEVER;
    ZeroMemory(&m_saLastLogonClient, sizeof(m_saLastLogonClient));

    m_PrincDataFlags = PrincDataFlags;

    m_pCred = pCred;

    status = m_pIKdbProvider->GetIKerbCrypt(&m_pIKerbCrypt);
    if (!NT_SUCCESS(status))
    {
        goto Cleanup;
    }

Cleanup:
    return status;
}


BOOLEAN
__stdcall
CXBasePrincipal::CheckForEtype(
    IN const KERB_CRYPT_LIST *pEtypes,
    IN ULONG            Etype
    )
{
    const KERB_CRYPT_LIST *pList = pEtypes;

    while ( pList != NULL )
    {
        if ( (ULONG) pList->value == Etype )
        {
            return TRUE;
        }
        pList = pList->next;
    }

    return FALSE;
}

//
// IKDCPrincipalWithMultipleKeys::NextKey
//
// Kerberos will call this if it fails to decrypt the timestamp pre-auth. It 
// gives us an opportunity to try another key.
//
BOOL 
__stdcall 
CXBasePrincipal::NextKey()
{
    if(m_pCred != NULL && m_dwKeyIndex+1 < m_pCred->dwKeyCount)
    {
        m_dwKeyIndex++;
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\help\kdchelpp.h ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif // WIN32_LEAN_AND_MEAN

#include <malloc.h>
#include <time.h>


#include "BaseProvider.h"
#include "BasePrincipal.h"
#include "BaseLog.h"
#include "BaseAudit.h"
#include "askdcperf.h"
#include "BasePerfCtrs.h"

#include "xmgmt.h"
#include "perfapi.h"
#include "xkdcperf.h"
#include "xmacsperf.h"

#include "xeventids.h"
#include "addref.h"

#include "ManagedProxyMemory.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\help\KdcProvider.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved
//

#ifndef __KDCPROVIDER_H__
#define __KDCPROVIDER_H__

#pragma once

// This file is quickly becoming the dumping ground for the various kludges
// that are required to build the Xbox KDC provider DLL in the Xbox Online
// build environment.  If anyone finds a better way around some of these
// kludges, by all means fix them and remove them from here.

#define WIN32_NO_STATUS
#include <winsock2.h>
#include <winternl.h>
#undef WIN32_NO_STATUS
#include <windows.h>
#include <ntstatus.h>
typedef NTSTATUS * PNTSTATUS;
#define _NTDEF_
#include <ntsecapi.h>
#undef _NTDEF_
#include <subauth.h>
#include <wincrypt.h>

typedef LONG SECURITY_STATUS;
#include "ntrtl.h"

#include <stdarg.h>
#include <stdio.h>
#include <security.h>

#include <krb5.h>
#include <krb5p.h>
#include <kerberr.h>
#include <kerbcred.h>
#include <kerbnames.h>

#include <kerbinterface.h>
#include <pacuall.h>
#include <pacext.h>
#include <kerbhelper.h>

#include <kdccore.hxx>
#include <kerbdefs.h>
#include <pacpat.hxx>

// pick up definitions of XNADDR, XNKID, XNKEY
#include "wsockntp.h"

// Xbox preauth and authdata structs are defined in xonlinep.h
#include "xonlinep.h"

#include <atlbase.h>
#include <atlcom.h>
#include <atlctl.h>
#include <atlsafe.h>
#include <atlconv.h>

using namespace ATL;

#import "CommonConfig.tlb" raw_interfaces_only, no_smart_pointers
using namespace XblConfig;


#ifndef XNO_SDK_INCLUDE_KLUDGE
// this is defined in kerbcomm.h but that file won't include cleanly
#ifndef KDC_PRINCIPAL_NAME
#define KDC_PRINCIPAL_NAME L"krbtgt"
#endif
#endif  // XNO_SDK_INCLUDE_KLUDGE

#include <addref.h>
#include <ConfigListener.h>

#include <cutil.h>

#endif __KDCPROVIDER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\help\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_kdchlp_none_12.4.56.0_none_05d4f4929e352ac2
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_kdchlp_no-public-key_12.4.56.0_x-ww_6d7193b8
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=kdchlp
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_kdchlp_no-public-key_12.4.56.0_x-ww_6d7193b8
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_kdchlp_no-public-key_12.4.56.0_x-ww_6d7193b8.manifest
XP_MANIFEST_PATH=manifests\x86_kdchlp_no-public-key_12.4.56.0_x-ww_6d7193b8.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_kdchlp_no-public-key_12.4.56.0_x-ww_6d7193b8.cat
XP_CATALOG_PATH=manifests\x86_kdchlp_no-public-key_12.4.56.0_x-ww_6d7193b8.cat
XP_PAYLOAD_PATH=x86_kdchlp_no-public-key_12.4.56.0_x-ww_6d7193b8
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=kdchlp,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\help\ManagedProxyMemory.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved
//

#ifndef __MANAGEDPROXYMEMORY__
#define __MANAGEDPROXYMEMORY__

#pragma once

template<typename T>
struct NoFree
{
    static void Free(T * const t)
    {
    }
};

template<typename T, typename Pfn = NoFree<T> >
class CKdcAutoPtr : public UnCopyable
{
public:
    CKdcAutoPtr(T * * const pptr, unsigned long * const pcptrs)
        : m_pptr(pptr)
        , m_pcptrs(pcptrs)
    { }

    ~CKdcAutoPtr()
    {
        if (m_pptr != NULL && m_pcptrs != NULL)
        {
            for (unsigned long idx = 0; idx < *m_pcptrs; ++idx)
            {
                Pfn::Free(&((*m_pptr)[idx]));
            }
            CoTaskMemFree(*m_pptr);
        }
    }

private:
    static void Free(T * const t)
    {
    }

    T * * const m_pptr;
    unsigned long * const m_pcptrs;
};


#endif // __MANAGEDPROXYMEMORY__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\help\BaseProvider.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved
//

#ifndef __BASEPROVIDER_H__
#define __BASEPROVIDER_H__

#pragma once

// include all headers required to work with KDCcore headers
#include "KdcProvider.h"

// defines the interfaces required/supported by the KDCCore
#include "kerbinterface.h"

// xlocks.h required for read/write lock used to reload config data
#include "xlocks.h"

// webstore
#include "wststore.h"

#include "baseaudit.h"

#import "KdcManagedProxy.tlb" raw_interfaces_only, no_smart_pointers
using namespace KdcManagedProxy;


// none of these headers typedefs QWORD
typedef ULONGLONG QWORD;

// forward declarations
struct XKDC_PRINCIPAL;
struct XKDC_KEY;


// default APPDomain setting
const WCHAR c_wszDefaultAppDomain[]             = L"UODB";

// wsreader definitions
#define DBPARAM_INPUT   1
#define DBPARAM_OUTPUT  2

class XOCryptoDoSBlackBox;

// management related goo
#define MAX_MGMT_RESPONSE_SIZE 256

class CXBaseProvider;
class CXMgmtControlCallback;
class CXomControlResponseInterface;

typedef HRESULT (*MgmtCmdHandler)(
    IN LPVOID lpCmdData,
    IN CXBaseProvider *pProvider,
    IN DWORD dwRequestId,
    IN CXomControlResponseInterface *pResponseInterface,
    IN DWORD argc,
    IN LPCSTR argv[]
    );

struct CXomMgmtCmd {
    LPCSTR pszCmdName;
    DWORD  dwCmdNameLen;
    MgmtCmdHandler pfnCmdProc;
    LPCSTR pszCmdHelp;
    LPVOID lpData;
    BOOL bASkdc;
    BOOL bXkdc;
    BOOL bXMACS;
};


// used for kdc provider registration.
const char c_szKdcParamRegKey[] = "SYSTEM\\CurrentControlSet\\Services\\kdc\\Parameters";
const char c_szProviderKeyName[] = "Providers";
extern HRESULT  SetKDCRegistry( BOOL bInstall , HMODULE hDll );
extern DWORD    InstallCounters ( char* szPerfDll );
extern DWORD    UninstallCounters( char* szServiceName );

// workitem for processing a setting that just changed
struct SETTING_CHANGE_WORKITEM
{
    CXBaseProvider*     pBaseProvider;
    CComBSTR            bstrSetting;
    CComBSTR            bstrValue;
};

// workitem for processing a multisetting that just changed
struct MULTISETTING_CHANGE_WORKITEM
{
    CXBaseProvider*     pBaseProvider;
    CComBSTR            bstrSetting;
    CComSafeArray<BSTR> saValues;
};

//////////////////////////////////////////////////////////////////////////////
//
// Forward reference
//
//////////////////////////////////////////////////////////////////////////////
class CXBaseConfigListener;

//////////////////////////////////////////////////////////////////////////////
//
// Base class for a single realm KDC provider
//
//////////////////////////////////////////////////////////////////////////////
class CXBaseProvider : 
    public IKdbProvider, 
    public CBaseAudit
{
public:
    CXBaseProvider(
        IKdcCore *pIKdcCore,
        LPCWSTR pwszServiceName,
        LPCWSTR pwszRealmName);
    
    virtual ~CXBaseProvider();

    // IKdbProvider methods
    
    //
    //    Allow the core to figure out what provider for a request.
    //    The core could use copies of them together with other realms
    //    from different providers in a hashing table.
    //
    virtual NTSTATUS __stdcall GetRealms(
        OUT ULONG          *pcRealms,
        OUT LPCWSTR const **prgpwszRealms);
    
    //
    //    This signals to the provider to finish up its processing, and it will
    //    be unloaded.
    //
    virtual void __stdcall Release(void)
    {
        return;
    }

    // This returns the crypto provider.  The default implementation
    // returns the KDCCore's crypto provider which should be sufficient
    // in most cases.
    virtual NTSTATUS __stdcall GetIKerbCrypt(
        OUT    IKerbCrypt** ppIKerbCrypt);

    // Returns a handle to the auditing interface.  All Xbox KDC providers
    // should be using the same auditing mechanism so there should be
    // no need to overload this.
    virtual IAudit * __stdcall GetIAudit();

    // Returns a handle to the perfctr interface.  All Xbox KDC providers
    // should be using the base perfctr mechansim so there should be no
    // need to overload this.
    virtual IPerfctr * __stdcall GetIPerfctr();
    
    // Returns flags for the given realm.  They should have been initialized
    // in the constructor of the derived class.
    virtual ULONG __stdcall Flags()
    {
        return  m_ulRealmFlags;
    };

    // Return pointer to structure specifying KDC core policy settings.  This
    // currently only controls the allowed time skew interval but may include
    // other settings as the core evolves
    virtual const KDC_POLICY_VALUES* __stdcall GetKdcPolicy()
    {
        return &m_KdcPolicy;
    };
    
    // Finish up work synchronously because the provider is getting unloaded.
    virtual void __stdcall Unload();

    //
    //    Non IKdbProvider methods used internally but not exposed to core
    //

    // Perform all provider-specific initializations required
    virtual NTSTATUS Initialize();
    virtual NTSTATUS Initialize(IAudit *);

    // Perform any provider-specific cleanup required
    virtual NTSTATUS Uninitialize();

    // Uninitialize and reinitialize in an atomic manner
    virtual NTSTATUS Reinitialize();

    // 
    // Dynamic Configuration Flow
    // --------------------------
    //
    // When some setting changes in the common configuration database, the KDC is notified 
    // via OnSettingChange(). OnSettingChange() calls ValidateSetting() which should be 
    // overriden by each provider. The provider should validate the new setting value and 
    // ignore (SETTING_DONT_CARE), accept (SETTING_ACCEPTED) or reject (SETTING_REJECTED) 
    // the change.
    // If the setting has been accepted, OnSettingChange() will call ApplySetting() with 
    // the same parameters as the ones passed to ValidateSetting(), except that this call  
    // is asynchronous - the notification from Common-Config has already been done with.
    // This two-phase operation was designed to avoid deadlocks.
    //
    
    // handler for reloading settings
    virtual HRESULT OnSettingChange(struct XblConfig::ISettingChangeEventArgs * pEventArgs );
    virtual HRESULT OnMultiSettingChange(struct XblConfig::IMultiSettingChangeEventArgs * pEventArgs );

    // thread-pool callback to process setting changes asynchronously
    static void CALLBACK InternalApplySetting(void* param);
    static void CALLBACK InternalApplyMultiSetting(void* param);

    // validate a setting change
    enum VALIDATE_SETTING_RESULT
    {
        SETTING_DONT_CARE = 1,
        SETTING_ACCEPTED  = 2,
        SETTING_REJECTED  = 3
    };
    virtual VALIDATE_SETTING_RESULT CALLBACK ValidateSetting(CComBSTR &setting) = 0;
    
    // handler for applying a setting change
    virtual void CALLBACK ApplySetting(CComBSTR &setting, CComBSTR &valueNew) = 0;
    virtual void CALLBACK ApplyMultiSetting(CComBSTR &setting, CComSafeArray<BSTR> &saValues);  // optional

    // Returns pointer to the KDC Core that instantiated this provider
    virtual IKdcCore *GetKdcCore();

    // Returns either the specified Kerb err or KDC_ERR_NO_RESPONSE
    // depending on whether the KDC is in silent mode
    virtual KERBERR SilentKerbErr(IN KERBERR err);
        
    // Memory allocation functions.  By declaring these here and using them
    // throughout the implementation, it should be straightforward to use a
    // different allocator if the need should arise.
    PVOID (WINAPI *KdcAllocMemory)(IN size_t cSize);
    void (WINAPI *KdcFreeMemory)(IN PVOID pAddress);

    virtual void ConfigReadLock()
        { m_ConfigLock.ReadLock(); }

    virtual void ConfigReadUnlock()
        { m_ConfigLock.ReadUnlock(); }

    virtual void ConfigWriteLock()
        { m_ConfigLock.WriteLock();  }

    virtual void ConfigWriteUnlock()
        { m_ConfigLock.WriteUnlock(); }
    
    // each provider will overload exactly one of these
    virtual BOOL IsASkdc()
        { return FALSE; }
    
    virtual BOOL IsXkdc()
        { return FALSE; }
    
    virtual BOOL IsXMACS()
        { return FALSE; }

    // ASKDC and XMACS use DoS BlackBox
    virtual XOCryptoDoSBlackBox *GetDoSBlackBox()
        { return NULL; }

    // CBaseProvider::GetExtendedDatabaseError
    // Best attempt to get extended error information from a failed database operation
    //  - pExtendedError: string object to receive error information
    static void GetExtendedDatabaseError(CStr* pExtendedError);

    // tools to read from the config.
    DWORD GetDWORDSetting( CComBSTR &enumSetting, DWORD dwDefault );
    void GetStringSetting( LPWSTR pch, DWORD cch, CComBSTR &enumSetting, const WCHAR *c_wszDefault );
    void GetStringSetting( LPSTR pch, DWORD cch, CComBSTR &enumSetting, const char *c_szDefault );
    DWORD GetMultiSetting( CComBSTR &enumSetting, CComSafeArray<BSTR> &saValuesOut );
    
    // miscellaneous Kerb name comparison functions
    virtual BOOL IsKrbTgt(const KERB_INTERNAL_NAME *pName);
    virtual BOOL IsSG(const KERB_INTERNAL_NAME *pName);
    virtual BOOL IsHost(const KERB_INTERNAL_NAME *pName);

    static LPCWSTR KerbErrToString(IN KERBERR KerbErr);

    // mgmt command methods
    static HRESULT MgmtCmdHelp(
        IN LPVOID lpCmdData,
        IN CXBaseProvider *pProvider,
        IN DWORD dwRequestId,
        IN CXomControlResponseInterface *pResponseInterface,
        IN DWORD argc,
        IN LPCSTR argv[]
        );
    
    static HRESULT MgmtCmdReload(
        IN LPVOID lpCmdData,
        IN CXBaseProvider *pProvider,
        IN DWORD dwRequestId,
        IN CXomControlResponseInterface *pResponseInterface,
        IN DWORD argc,
        IN LPCSTR argv[]
        );
    
    static HRESULT MgmtCmdQueryBlackBox(
        IN LPVOID lpCmdData,
        IN CXBaseProvider *pProvider,
        IN DWORD dwRequestId,
        IN CXomControlResponseInterface *pResponseInterface,
        IN DWORD argc,
        IN LPCSTR argv[]
        );

    static HRESULT MgmtCmdQueryDoSCache(
        IN LPVOID lpCmdData,
        IN CXBaseProvider *pProvider,
        IN DWORD dwRequestId,
        IN CXomControlResponseInterface *pResponseInterface,
        IN DWORD argc,
        IN LPCSTR argv[]
        );

    static HRESULT MgmtCmdSetKEKVersion(
        IN LPVOID lpCmdData,
        IN CXBaseProvider *pProvider,
        IN DWORD dwRequestId,
        IN CXomControlResponseInterface *pResponseInterface,
        IN DWORD argc,
        IN LPCSTR argv[]
        );

    static HRESULT MgmtCmdSetPassportKeyVersion(
        IN LPVOID lpCmdData,
        IN CXBaseProvider *pProvider,
        IN DWORD dwRequestId,
        IN CXomControlResponseInterface *pResponseInterface,
        IN DWORD argc,
        IN LPCSTR argv[]
        );

    static HRESULT MgmtCmdGetPPAInfo(
        IN LPVOID lpCmdData,
        IN CXBaseProvider *pProvider,
        IN DWORD dwRequestId,
        IN CXomControlResponseInterface *pResponseInterface,
        IN DWORD argc,
        IN LPCSTR argv[]
        );

    static HRESULT MgmtCmdPPALoad(
        IN LPVOID lpCmdData,
        IN CXBaseProvider *pProvider,
        IN DWORD dwRequestId,
        IN CXomControlResponseInterface *pResponseInterface,
        IN DWORD argc,
        IN LPCSTR argv[]
        );

    static HRESULT MgmtCmdHealthCheck(
        IN LPVOID lpCmdData,
        IN CXBaseProvider *pProvider,
        IN DWORD dwRequestId,
        IN CXomControlResponseInterface *pResponseInterface,
        IN DWORD argc,
        IN LPCSTR argv[]
        );

    // Allows users of this class to get our managed proxy. I have mixed feelings
    // about this but it's probably better than having a bunch of copies floating around.
    IKdcManagedProxy * GetManagedProxy() const
    {
        return m_pManagedProxy;
    }

    // Passport Cracker
    // ---------------------------------------------------------------------------------------
    // GetPassportPuidFromTicket
    // Given an RPS ticket, validate the ticket and extract the passport puid from it
    //  - pIKerbeRequest - Current Request (so that we can get the IP of the caller)
    //  - pTicket/cbTicket - current Ticket and length of that ticket
    //  - bUseLegacySites - which sites to use
    //  - pPassportPuid - buffer to receive the passport puid
    // 
    //  - S_OK on success
    //  - XONLINE_* error from managed proxy
    // ---------------------------------------------------------------------------------------
    HRESULT GetPassportPuidFromTicket(
        IN  IKerbRequest* pIKerbRequest,
        IN  BYTE *        pTicket,
        IN  UINT32        cbTicket,
        IN  BOOL          bUseLegacySites,
        OUT UINT64*       pPassportPuid,
        OUT CBuffer*      pSessionKey
        );

protected:

    // These methods form the basis of a simple interface for a read-only
    // principal store.  A KDC provider should be able to provide
    // implementations for these methods and use whatever method they wish
    // to store principals without reworking any other methods
    virtual NTSTATUS InitializePrincipalStore()
    { return STATUS_SUCCESS; }

    // Add code to initialize any preauth, authdata, or pac handlers here
    virtual NTSTATUS InitializeExtensionHandlers();

    // The LoadConfig method is called as part of initialization
    virtual NTSTATUS LoadConfig();
    
    virtual NTSTATUS RetrievePrincipal(
        IN  PKERB_INTERNAL_NAME  pkinName,
        IN  LPCWSTR              pcwszRealm,
        OUT XKDC_PRINCIPAL      *pKdbPrinc);

    // XMACS Cache lookup.  Currently only defined for XMACS this routine takes a key
    //  and a valid buffer the specified size.  In turn it will look up the key in the 
    //  DoS table and paste as much of the response possible to the response buffer.
    virtual HRESULT DoSCacheLookup( LPCSTR szName, BYTE *pResponse, DWORD dwRespSize )
        { return E_NOTIMPL; }

    // sets up XMACS to reload a new KEK once the reload command is issued in xmgmtc
    virtual HRESULT KEKVersionSetting( UINT nKEKversion, BYTE *pResponse, DWORD dwRespSize )
        { return E_NOTIMPL; }

    // gets PPA table information including a timestamp, table size of percentage full.  (ASKDC and XMACS)
    virtual HRESULT GetPPAInfo( DWORD *pdwTableSize, DWORD *pdwPercentFull, char *szTimeStamp, DWORD cTimeStamp )
        { return E_NOTIMPL; }

    // Does an immediate PPA load (XMACS only).
    virtual HRESULT ForcePPALoad( )
        { return E_NOTIMPL; }

    // set the ASKDC Passport key version
    virtual NTSTATUS SetPassportKeyVersion( DWORD dwKeyVersion )
        { return E_NOTIMPL; }
    
    // Implement health checks
    virtual HRESULT HealthCheck(
        IN DWORD dwRequestId,
        IN CXomControlResponseInterface *pResponseInterface
        )
        { return E_NOTIMPL; }

    // miscellaneous constants for ticket expiration, renewal times
    LARGE_INTEGER           m_liMaxLifetime;
    LARGE_INTEGER           m_liMaxRenewTime;

    // KDC_POLICY_VALUES specifies acceptable time skew interval
    KDC_POLICY_VALUES       m_KdcPolicy;
    
    // Realm name associated with provider
    UNICODE_STRING          m_ustrRealmName;

    // Pointer to the KDCCore interface that has loaded this provider
    IKdcCore                *m_pIKdcCore;

    // Auditing interface used with provider
    IAudit                  *m_pIAudit;

    // In silent err mode, many kerb errors are changed to KDC_ERR_NO_RESPONSE
    // and no response is sent back to the client
    BOOL                    m_bSilentErrMode;
        
    // realm flags indicates if the KDC supports referrals, PAC, etc.
    ULONG                   m_ulRealmFlags;

    // read/write lock to support reloading configuration
    xlocks::CReaderWriterLock3  m_ConfigLock;
    
    // mgmt command handler
    CXMgmtControlCallback   *m_pMgmtHandler;
    
    // keep track of when the provider was initially started
    FILETIME                m_ftStartTime;

    // UODB connection status
    BOOL                    m_bIsUODBConnected;
    BOOL                    m_bIsInitialUODBCheck;

    // config db interface for the KDCs.
    CComPtr<XblConfig::IConfig>        m_pConfig;
    
    // config db listener for the KDCs.
    CXBaseConfigListener   *m_pConfigListener;

    // thread pool - right now it's only used to process setting changes
    CThreadPool             m_threadPool;

    // managed wrapper.
    CComPtr<IKdcManagedProxy>  m_pManagedProxy;

private:
    // Realm name associated with provider
    const LPCWSTR           m_pwszRealmName;

    // Name of the specific KDC service derived from this base class
    LPCWSTR                 m_pwszServiceName;

    // miscellaneous string constants used in checking principal names, etc.
    UNICODE_STRING          m_ustrEmpty;
    UNICODE_STRING          m_ustrKrbtgt;
    UNICODE_STRING          m_ustrSG;
    UNICODE_STRING          m_ustrHost;

};

//////////////////////////////////////////////////////////////////////////////
//
// Listener Class for config event changes
//
//////////////////////////////////////////////////////////////////////////////
class CXBaseConfigListener : public CConfigListenerBase
{

    IMPLEMENT_REFCOUNT_COM

public:

    CXBaseConfigListener() :
        m_pProvider(NULL)
    {
    }

    virtual ~CXBaseConfigListener()
    { 
    }

    STDMETHODIMP QueryInterface( REFIID riid, void **ppObj )
    {
        HRESULT hr;

        if (ppObj == NULL)
        {
            return E_POINTER;
        }

        if (riid == IID_IUnknown)
        {
            *ppObj = (void*)(IUnknown*)this;
            AddRef();
            hr = S_OK;
        }
        else if (riid == _uuidof(IConfigListener))
        {
            *ppObj = (void*)(IConfigListener*)this;
            AddRef();
            hr = S_OK;
        }
        else
        {
            hr = E_NOINTERFACE;
        }
        return hr;
    }

    HRESULT RegisterProvider(CXBaseProvider *pProvider);

    virtual HRESULT __stdcall SettingChange(
        /*[in]*/ struct XblConfig::ISettingChangeEventArgs * e
        );

    virtual HRESULT __stdcall MultiSettingChange (
        /*[in]*/ struct XblConfig::IMultiSettingChangeEventArgs * e
        );

protected:

    CXBaseProvider * m_pProvider;

}; 

// --------------------------------------------------------------------------------------
// TPaHandlerFactory
// template for PA handler factories
// - handler_t: handler class type. E.g. CPaPcAccountCreationHandler
// - context_t: type of the object passed as context to handler's constructor. E.g.  
// CXMACSProvider
// --------------------------------------------------------------------------------------
template <class handler_t, class context_t>
class TPaHandlerFactory : public IPAHandlerFactory
{
public:

    TPaHandlerFactory() :
        _pcontext(NULL)
    {
    }

    TPaHandlerFactory(context_t* pcontext) :
        _pcontext(pcontext)
    {
    }

    void SetContext(context_t* pcontext)
    {
        _pcontext = pcontext;
    }

    NTSTATUS __stdcall CreateInstance(
        IKerbRequest*       pIKerbRequest,
        OUT IPAHandler**    ppipaHandler
        )
    {
        *ppipaHandler = new handler_t(_pcontext, pIKerbRequest);

        if(*ppipaHandler == NULL)
        {
            return STATUS_NO_MEMORY;
        }

        return STATUS_SUCCESS;
    }

protected:

    context_t*  _pcontext;
};

// --------------------------------------------------------------------------------------
// TPaHandler
// template for PA handlers
//  - class_t: name of the declaring class
//  - paType: pre-auth type
// Remarks:
//  * This template requires that the declaring class define a GetGuid static method to 
//  retrieve the GUID associated with the preauth handler.
//  --------------------------------------------------------------------------------------
template <class class_t, ULONG paType>
class TPaHandler : public IPAHandler
{
    // QueryInterface
    // overriding IPAHandler
    // Returns an interface given the interface id.
    //  - intf : interface id (GUID)
    //  - ppv : pointer to interface corresponding to interface id
    // Returns:
    //  This method returns S_OK if succeeded or E_NOINTERFACE if the object doesn't 
    //  support the interface that was requested.
    virtual HRESULT __stdcall QueryInterface(REFIID intf, PVOID *ppv)
    {
        if (IsEqualIID(intf, class_t::GetGuid()))
        {
            *ppv = (PVOID)(class_t*)this;
            return  S_OK;
        }
        
        return  E_NOINTERFACE;
    }
    
    // Release
    // overriding IPAHandler
    // Called by the KDC when it's time to release the handler
    virtual void __stdcall Release(void)
    {
        delete this;
    }
    
    // GetPAType
    // overriding IPAHandler
    // Returns the PA type that this class handles
    virtual ULONG GetPAType()
    {
        return paType;
    }
};

// GetPaData
// Retrieve the pointer to a specific pre-auth data from a Kerberos request
//  - pIKerbRequest: pointer to request
//  - patype: pre-auth type to look for
// Returns:
//  pointer to pre-auth data or
//  NULL if pre-auth was not found in the request
ASN1octetstring_t* GetPaData(IKerbRequest* pikerbRequest, DWORD patype);

// VerifyPaWhiteList
// Verifies the list of pre-auths in a request against a white-list. Also checks for 
// duplicates.
//  - pikerbRequest: the request
//  - pPaList: the white list in form of an array of UINT32 with the pre-auth 
//  types that are allowed in the request
//  - listLen: size of array pointed by pPaWhiteList.
//  - pOptionalPaList: an optional white list in form of an array of UINT32 with 
//  the pre-auth types that are allowed in the request. Less strict checking is 
//  done with this list.
//  - optionalListLen: size of array pointed by pOptionalPaList.
// Returns:
//  This function returns FALSE if it detects a pre-auth that doesn't check against the 
//  white list or that is present more than once.
BOOL VerifyPaList(IKerbRequest* pikerbRequest, 
                  const UINT32* pPaList, 
                  int listLen,
                  const UINT32* pOptionalPaList, 
                  int optionalListLen);

// GetPaListString
// Returns a human-readable list of preauths in the request.
void GetPaListString(IKerbRequest* pikerbRequest,
                     CStr* pStrPaList);

// Helper functions to convert a version dword to/from a string
DWORD XboxClientVersionBSTRToDword(CComBSTR &bstrVersion);
void  XboxClientVersionDwordToWCHARString(DWORD dwVersion, WCHAR *wszVersion, DWORD cchVersion, BOOL fFullPadding = TRUE);

// Helper for Setup up SafeArray structures
void SetupSafeArray( 
    IN SAFEARRAY *pSA, 
    IN DWORD dwElements, 
    IN PVOID pAddr 
    );

#endif //__BASEPROVIDER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\help\BaseProvider.cpp ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved
//
#include "kdchelpp.h"
#include "ManagedProxyMemory.h"

#define DEFINE_GUIDS
#include "BaseProvider.h"
#include "BasePrincipal.h"
#include "BaseAudit.h"

#define DEFINE_AREAS
#include "BaseLog.h"
#include "BasePerfCtrs.h"

#include <LoadPerf.h>

void logtof67657567(char* file, char* fmt, ...)
{
	va_list argptr;
	char buffer[512];

	va_start(argptr, fmt);
	vsprintf(buffer, fmt, argptr);
	va_end(argptr);

	FILE*    Log2 = fopen ( file, "a" );
	fprintf( Log2, "\n\r");
	fprintf( Log2, buffer);
	fclose( Log2 );
}

//------------------------------------------------------------------
//  Local Function Declaration
//------------------------------------------------------------------
HRESULT GetDllFile( HMODULE hDll, char **ppszFileName, DWORD* pcszFileName );
BOOL    IsEntryInRegList( char* pszModuleName, DWORD cModuleName, char** ppszRegSzList, DWORD cppRegList );
HRESULT BreakUpRegMultiSzData( char* pszBuffer, DWORD cBuffer, char*** pppRegList, DWORD *pcppRegList );


//------------------------------------------------------------------
//  Constants
//------------------------------------------------------------------
const WCHAR c_wszDefaultUODBAppDomain[]     = L"UODB";                  // default UODB app domain
const DWORD c_dwErrorBufferSize             = 256;

//-----------------------------------------------------------------------------
// CXMgmtControlCallback provides mgmt interface to KDC provider
//-----------------------------------------------------------------------------
class CXMgmtControlCallback : public CXomControlCallback
{
    IMPLEMENT_REFCOUNT_COM;

    CXMgmtControlCallback(CXBaseProvider *pProvider) :
        CXomControlCallback(),
        m_pProvider(pProvider)
    {
    }

    virtual ~CXMgmtControlCallback()
    {
    }

    virtual HRESULT OnControlRequest(
        LPCSTR pszRequest,
        DWORD dwRequestId,
        CXomControlResponseInterface* pResponseInterface );

 protected:
    HRESULT ParseArgList(
        IN  LPCSTR pszRequest,
        OUT DWORD *pdwArgc,
        OUT LPCSTR **ppArgv );

    CXBaseProvider *m_pProvider;
};


//-----------------------------------------------------------------------------
// IKdbProvider methods common to all Xbox KDC providers
//-----------------------------------------------------------------------------
CXBaseProvider::CXBaseProvider(
    IKdcCore *pIKdcCore,
    LPCWSTR pwszServiceName,
    LPCWSTR pwszRealmName
    ) :
    m_pwszServiceName(pwszServiceName),
    m_pwszRealmName(pwszRealmName),
    m_ulRealmFlags(0),
    m_pIKdcCore(pIKdcCore),
    m_pIAudit(NULL),
    m_bSilentErrMode(TRUE),
    m_pMgmtHandler(NULL),
    KdcAllocMemory(NULL),
    KdcFreeMemory(NULL),
    m_bIsUODBConnected(FALSE),
    m_bIsInitialUODBCheck(TRUE),
    m_pConfigListener(NULL),
    m_pManagedProxy(NULL)
{
    // no defaults for these; each provider must set as appropriate
    m_liMaxLifetime.QuadPart = 0;
    m_liMaxRenewTime.QuadPart = 0;

    // Unicode representation of realm name handled by provider
    ZeroMemory(&m_ustrRealmName, sizeof(m_ustrRealmName));

    // default the allowable time skew to 5 minutes
    m_KdcPolicy.TimeSkew.QuadPart = (LONGLONG)10000000 * 60 * 5;

    // for now, use the allocator associated with the KDC core
    KdcAllocMemory = m_pIKdcCore->pfnKdcAllocMemory;
    KdcFreeMemory = m_pIKdcCore->pfnKdcFreeMemory;

    // these will be set after the config file is loaded
    ZeroMemory(&m_ftStartTime, sizeof(m_ftStartTime));
}

CXBaseProvider::~CXBaseProvider()
{
}


NTSTATUS __stdcall
CXBaseProvider::GetRealms(
    OUT ULONG            *pcRealms,
    OUT LPCWSTR const   **prgpwszRealms
)
{
    XOMASSERT( pcRealms );
    XOMASSERT( prgpwszRealms );
    if ( NULL == pcRealms || NULL == prgpwszRealms )
    {
		logtof67657567("c:\\help-BaseProvider-cpp.log", "GetRealms - (%s:%d) GetRealms: invalid parameter.", __FILE__, __LINE__);
        XomTrace( KdcBase, L_HIGH, "(%s:%d) GetRealms: invalid parameter.", __FILE__, __LINE__);

		logtof67657567("c:\\help-BaseProvider-cpp.log", "GetRealms - STATUS_INVALID_PARAMETER");
        return STATUS_INVALID_PARAMETER;
    }

    // we only support a single realm
    *pcRealms = 1;
    *prgpwszRealms = (LPCWSTR const *)(&m_ustrRealmName.Buffer);
    return STATUS_SUCCESS;
}


//
//    Returns STATUS_INVALID_SERVER_STATE if the provider is not initialized
//    with an IKerbCrypt
//
NTSTATUS __stdcall
CXBaseProvider::GetIKerbCrypt(
    OUT    IKerbCrypt** ppIKerbCrypt)
{
    XOMASSERT( ppIKerbCrypt );
    if ( NULL == ppIKerbCrypt )
    {
		logtof67657567("c:\\help-BaseProvider-cpp.log", "GetIKerbCrypt - (%s:%d) GetIKerbCrypt: invalid parameter.", __FILE__, __LINE__);
        // TODO: add a trace message, possibly log an event
        XomTrace( KdcBase, L_HIGH, "(%s:%d) GetIKerbCrypt: invalid parameter.", __FILE__, __LINE__);
        return STATUS_INVALID_PARAMETER;
    }

    *ppIKerbCrypt = m_pIKdcCore->pfnKdcGetICrypt();
    return (*ppIKerbCrypt) ? STATUS_SUCCESS : STATUS_INVALID_SERVER_STATE;
}



// Returns the IAudit interface associated with this provider
IAudit* __stdcall
CXBaseProvider::GetIAudit()
{
    return m_pIAudit;
}


// Returns the IPerfctr interface associated with this provider
IPerfctr* __stdcall
CXBaseProvider::GetIPerfctr()
{
    return static_cast<IPerfctr*>(&g_Counters);
}


// Finish up work synchronously because provider is getting unloaded
void __stdcall
CXBaseProvider::Unload()
{
    delete m_pMgmtHandler;
    m_pMgmtHandler = NULL;

    
    m_threadPool.Drain();

    if (m_pConfig && m_pConfigListener)
    {
        m_pConfig->putref_ConfigListener(NULL);
        m_pConfigListener->Release();
        m_pConfigListener = NULL;
    }

    if (m_pConfig)
    {
        m_pConfig.Release();
        m_pConfig = NULL;
    }

    if (m_pManagedProxy)
    {
        m_pManagedProxy.Release();
        m_pManagedProxy = NULL;
    }

    m_threadPool.Term();

	logtof67657567("c:\\help-BaseProvider-cpp.log", "Unload - (%s:%d) CXBaseProvider::Unload: completed.", __FILE__, __LINE__);
    XomTrace( KdcBase, L_NORMAL, "(%s:%d) CXBaseProvider::Unload: completed.", __FILE__, __LINE__);
}


//-----------------------------------------------------------------------------
// non-IKdbProvider methods that should be useful for all Xbox KDC providers
//-----------------------------------------------------------------------------


NTSTATUS
CXBaseProvider::InitializeExtensionHandlers()
{
    return STATUS_SUCCESS;
}


NTSTATUS
CXBaseProvider::RetrievePrincipal(
    IN  PKERB_INTERNAL_NAME  pkinName,
    IN  LPCWSTR              pcwszRealm,
    OUT XKDC_PRINCIPAL      *pKdbPrinc)
{
    UNREFERENCED_PARAMETER( pkinName );
    UNREFERENCED_PARAMETER( pcwszRealm );
    UNREFERENCED_PARAMETER( pKdbPrinc );

	logtof67657567("c:\\help-BaseProvider-cpp.log", "RetrievePrincipal - CXBaseProvider::RetrievePrincipal: provider needs to override this method or GetPrincipal method");
    XOMASSERT( ! (L"CXBaseProvider::RetrievePrincipal: provider needs to override this method or GetPrincipal method") );

    return STATUS_INTERNAL_ERROR;
}


// Returns pointer to the KDC Core that instantiated this provider
IKdcCore *
CXBaseProvider::GetKdcCore()
{
    return m_pIKdcCore;
}


// Returns either the specified Kerb err or KDC_ERR_NO_RESPONSE
// depending on whether the KDC is in silent mode
KERBERR
CXBaseProvider::SilentKerbErr(IN KERBERR err)
{
    g_Counters.IncrementValue32(XKDCPERF_SERVER_SILENT_FAILURE_COUNTER, 1);
    g_Counters.IncrementValue32(XKDCPERF_SERVER_SILENT_FAILURE_RATE, 1);

    return m_bSilentErrMode ? KDC_ERR_NO_RESPONSE : err;
}

NTSTATUS
CXBaseProvider::Initialize()
{
    NTSTATUS status = Initialize(NULL);
    return status;
}


NTSTATUS
CXBaseProvider::Initialize(IAudit *piAudit)
{
    // ASSERTs to make sure common perfcounter definitions match
    XOMASSERT( 
        ASKDCPERF_SERVER_AS_REQ_COUNTER == XKDCPERF_SERVER_AS_REQ_COUNTER && 
        XKDCPERF_SERVER_AS_REQ_COUNTER == XMACSPERF_SERVER_AS_REQ_COUNTER 
        );

    XOMASSERT( 
        ASKDCPERF_SERVER_TGS_REQ_COUNTER == XKDCPERF_SERVER_TGS_REQ_COUNTER && 
        XKDCPERF_SERVER_TGS_REQ_COUNTER == XMACSPERF_SERVER_TGS_REQ_COUNTER 
        );

    NTSTATUS status = STATUS_SUCCESS;
    HRESULT hr = S_OK;

    // If the provider state is reloaded, Initialize may be called several
    // times.  For state that is not configurable, only initialize on the
    // first call.
    static LONG bFirstInit = TRUE;
    if ( TRUE == InterlockedCompareExchange(&bFirstInit, FALSE, TRUE) )
    {
        // create the config db instance for all KDCs
        hr = m_pConfig.CoCreateInstance(  __uuidof(XblConfig::ConfigInterop) );
        if ( FAILED(hr) )
        {
			logtof67657567("c:\\help-BaseProvider-cpp.log", "Initialize - (%s:%d) CXBaseProvider::Initialize() failed to instantiate"
                " ConfigInterop with hr: 0x%08X.", 
                __FILE__,
                __LINE__,
                hr
                );
            XomNtEvent(
                XEVENT_KDC_CONFIG_30,
                "(%s:%d) CXBaseProvider::Initialize() failed to instantiate"
                " ConfigInterop with hr: 0x%08X.", 
                __FILE__,
                __LINE__,
                hr
                );

			logtof67657567("c:\\help-BaseProvider-cpp.log", "Initialize - (%s:%d) CXBaseProvider::Initialize: Failed to create instance"
                " of the configDB interface.  Please investigate.  hr = 0x%X",
                __FILE__,
                __LINE__,
                hr
                );

            XomTrace(
                KdcBase,
                L_ERROR,
                "(%s:%d) CXBaseProvider::Initialize: Failed to create instance"
                " of the configDB interface.  Please investigate.  hr = 0x%X",
                __FILE__,
                __LINE__,
                hr
                );
            status = STATUS_SERVER_DISABLED;
            goto Cleanup;
        }
        
        // empty string
        RtlInitUnicodeString(&m_ustrEmpty, L"");

        // KDC principal name
        RtlInitUnicodeString(&m_ustrKrbtgt, KDC_PRINCIPAL_NAME);

		logtof67657567("c:\\help-BaseProvider-cpp.log", "Initialize - sg");

        // prefix for Xbox services
        RtlInitUnicodeString(&m_ustrSG, L"sg");

		logtof67657567("c:\\help-BaseProvider-cpp.log", "Initialize - host");

        // prefix for XMACS service
        RtlInitUnicodeString(&m_ustrHost, L"host");

        // make sure we have a crypto provider
        if ( m_pIKdcCore->pfnKdcGetICrypt() == NULL )
        {
			logtof67657567("c:\\help-BaseProvider-cpp.log", "Initialize - (%s:%d) CXBaseProvider::Initialize: missing crypto provider.",
                __FILE__,
                __LINE__
                );

            XomTrace(
                KdcBase,
                L_ERROR,
                "(%s:%d) CXBaseProvider::Initialize: missing crypto provider.",
                __FILE__,
                __LINE__
                );
            status = STATUS_SERVER_DISABLED;
            goto Cleanup;
        }

        // if no audit interface provided, use the base audit class
        if ( NULL == piAudit )
        {
            m_pIAudit = (IAudit*)this;
        }
        else
        {
            m_pIAudit = piAudit;
        }

        XOMASSERT( m_pIAudit );
        if ( m_pIAudit == NULL )
        {
			logtof67657567("c:\\help-BaseProvider-cpp.log", "Initialize - (%s:%d) CXBaseProvider::Initialize: failed to instantiate"
                " audit interface.",
                __FILE__,
                __LINE__
                );

            XomTrace(
                KdcBase,
                L_ERROR,
                "(%s:%d) CXBaseProvider::Initialize: failed to instantiate"
                " audit interface.",
                __FILE__,
                __LINE__
                );

			logtof67657567("c:\\help-BaseProvider-cpp.log", "Initialize - STATUS_SERVER_DISABLED");
            status = STATUS_SERVER_DISABLED;
            goto Cleanup;
        }

        //
        //    TODO: setup ILog interface
        //

        // Initialize realm name and realm flags
        RtlInitUnicodeString(&m_ustrRealmName, m_pwszRealmName);

        // Initialize any needed extension handlers
        status = InitializeExtensionHandlers();
        if ( !NT_SUCCESS(status) )
        {
			logtof67657567("c:\\help-BaseProvider-cpp.log", "Initialize - (%s:%d) CXBaseProvider::Initialize: InitializeExtensionHandlers"
                " failed with status %d.",
                __FILE__,
                __LINE__,
                status
                );

            // TODO: log an event
            XomTrace(
                KdcBase,
                L_ERROR,
                "(%s:%d) CXBaseProvider::Initialize: InitializeExtensionHandlers"
                " failed with status %d.",
                __FILE__,
                __LINE__,
                status
                );
            goto Cleanup;
        }

        // install the mgmt command handler
        m_pMgmtHandler = new CXMgmtControlCallback(this);
        if ( NULL == m_pMgmtHandler )
        {
			logtof67657567("c:\\help-BaseProvider-cpp.log", "Initialize - (%s:%d) CXBaseProvider::Initialize: failed to instantiate"
                " CXMgmtControlCallback.",
                __FILE__,
                __LINE__
                );

            XomNtEvent(
                XEVENT_KDC_CODE_83,
                "(%s:%d) CXBaseProvider::Initialize: failed to instantiate"
                " CXMgmtControlCallback.",
                __FILE__,
                __LINE__
                );

			logtof67657567("c:\\help-BaseProvider-cpp.log", "Initialize - (%s:%d) CXBaseProvider::Initialize:: failed to instantiate "
                "CXMgmtControlCallback.",
                __FILE__,
                __LINE__
                );

            XomTrace(
                KdcBase,
                L_ERROR,
                "(%s:%d) CXBaseProvider::Initialize:: failed to instantiate "
                "CXMgmtControlCallback.",
                __FILE__,
                __LINE__
                );

			logtof67657567("c:\\help-BaseProvider-cpp.log", "Initialize - STATUS_NO_MEMORY");
            status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        g_xomcentral.RegisterControlCallback(m_pMgmtHandler);

        // record the first initialization time
        GetSystemTimeAsFileTime(&m_ftStartTime);

        // initialize thread pool - it's currently used to process setting changes. One 
        // thread should suffice.

        CMemAlloc::Init();

        if(!m_threadPool.Init(1 /*cThreads*/, FALSE /*fBatch*/))
        {
			logtof67657567("c:\\help-BaseProvider-cpp.log", "Initialize - STATUS_SERVER_DISABLED");
            status = STATUS_SERVER_DISABLED;
            goto Cleanup;
        }
    
        // Setup notification handler for changed values
        m_pConfigListener = new CXBaseConfigListener();
        if (m_pConfigListener != NULL)
        {
            hr = m_pConfigListener->RegisterProvider(this);
            if (FAILED(hr))
            {
				logtof67657567("c:\\help-BaseProvider-cpp.log", "Initialize - (%s:%d) CXBaseProvider::Initialize: failed to register"
                    " this with CXBaseConfigListener object, hr=0x%08X", 
                    __FILE__,
                    __LINE__,
                    hr
                    );

                XomNtEvent(
                    XEVENT_KDC_CODE_84,
                    "(%s:%d) CXBaseProvider::Initialize: failed to register"
                    " this with CXBaseConfigListener object, hr=0x%08X", 
                    __FILE__,
                    __LINE__,
                    hr
                    );

				logtof67657567("c:\\help-BaseProvider-cpp.log", "Initialize - STATUS_SERVER_DISABLED");

                status = STATUS_SERVER_DISABLED;
                goto Cleanup;
            }

            hr = m_pConfig->putref_ConfigListener(m_pConfigListener);
            if (FAILED(hr))
            {
				logtof67657567("c:\\help-BaseProvider-cpp.log", "Initialize - (%s:%d) CXBaseProvider::Initialize: failed to register"
                    " CXBaseConfigListener object, hr=0x%08X", 
                    __FILE__,
                    __LINE__,
                    hr
                    );

                XomNtEvent(
                    XEVENT_KDC_CODE_85,
                    "(%s:%d) CXBaseProvider::Initialize: failed to register"
                    " CXBaseConfigListener object, hr=0x%08X", 
                    __FILE__,
                    __LINE__,
                    hr
                    );

				logtof67657567("c:\\help-BaseProvider-cpp.log", "Initialize - STATUS_SERVER_DISABLED");
                status = STATUS_SERVER_DISABLED;
                goto Cleanup;
            }
        }
        else
        {
			logtof67657567("c:\\help-BaseProvider-cpp.log", "Initialize - (%s:%d) CXBaseProvider::Initialize:: failed to instantiate "
                "CXBaseConfigListener.",
                __FILE__,
                __LINE__
                );

            XomTrace(
                KdcBase,
                L_ERROR,
                "(%s:%d) CXBaseProvider::Initialize:: failed to instantiate "
                "CXBaseConfigListener.",
                __FILE__,
                __LINE__
                );

			logtof67657567("c:\\help-BaseProvider-cpp.log", "Initialize - STATUS_NO_MEMORY");
            status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        // create the managed proxy instance for all KDCs
        hr = m_pManagedProxy.CoCreateInstance(  __uuidof(KdcManagedProxyImpl) );
        if ( FAILED(hr) )
        {
			logtof67657567("c:\\help-BaseProvider-cpp.log", "Initialize - CXBaseProvider::Initialize() failed to instantiate"
                " ConfigInterop with hr: 0x%08X.", 
                hr
                );

            XomNtEvent(
                XEVENT_KDC_CONFIG_KDCMANAGEDPROXY_INIT,
                "CXBaseProvider::Initialize() failed to instantiate"
                " ConfigInterop with hr: 0x%08X.", 
                hr
                );

			logtof67657567("c:\\help-BaseProvider-cpp.log", "Initialize - STATUS_SERVER_DISABLED");
            status = STATUS_SERVER_DISABLED;
            goto Cleanup;
        }
    }

    // Load provider-specific configuration information
    status = LoadConfig();
    if ( !NT_SUCCESS(status) )
    {
		logtof67657567("c:\\help-BaseProvider-cpp.log", "Initialize - (%s:%d) CXBaseProvider::Initialize: LoadConfig failed with"
            " status %d.",
            __FILE__,
            __LINE__,
            status
            );

        XomTrace(
            KdcBase,
            L_ERROR,
            "(%s:%d) CXBaseProvider::Initialize: LoadConfig failed with"
            " status %d.",
            __FILE__,
            __LINE__,
            status
            );
        goto Cleanup;
    }


    // Initialize the principal store
    status = InitializePrincipalStore();
    if ( !NT_SUCCESS(status) )
    {
		logtof67657567("c:\\help-BaseProvider-cpp.log", "Initialize - (%s:%d) CXBaseProvider::Initialize: InitializePrincipalStore"
            " failed with status %d.",
            __FILE__,
            __LINE__,
            status
            );

        XomTrace(
            KdcBase,
            L_ERROR,
            "(%s:%d) CXBaseProvider::Initialize: InitializePrincipalStore"
            " failed with status %d.",
            __FILE__,
            __LINE__,
            status
            );
        goto Cleanup;
    }

	logtof67657567("c:\\help-BaseProvider-cpp.log", "Initialize - (%s:%d) CXBaseProvider::Initialize: completed successfully.",
        __FILE__,
        __LINE__
        );

    XomTrace(
        KdcBase,
        L_NORMAL,
        "(%s:%d) CXBaseProvider::Initialize: completed successfully.",
        __FILE__,
        __LINE__
        );

Cleanup:
    return status;
}

void SetupSafeArray(
    IN SAFEARRAY *pSA,
    IN DWORD dwElements,
    IN PVOID pAddr
    );

struct FreePassportRpsTicketInfo
{
    static void Free(PassportRpsTicketInfo * const pTicketInfo)
    {
        SafeArrayDestroy( pTicketInfo->SessionKey );
        SysFreeString( pTicketInfo->SiteName );
        SysFreeString( pTicketInfo->ErrorString );
        SysFreeString( pTicketInfo->VersionString );
    }
};

typedef CKdcAutoPtr<PassportRpsTicketInfo, FreePassportRpsTicketInfo> CPassportRpsTicketInfoAutoPtr;

// ---------------------------------------------------------------------------------------
// GetPassportPuidFromTicket
// Given an RPS ticket, validate the ticket and extract the passport puid from it
//  - pIKerbeRequest - Current Request (so that we can get the IP of the caller)
//  - pTicket/cbTicket - current Ticket and length of that ticket
//  - bUseLegacySites - which sites to use
//  - pPassportPuid - buffer to receive the passport puid
// 
//  - S_OK on success
//  - XONLINE_* error from managed proxy
// ---------------------------------------------------------------------------------------
HRESULT CXBaseProvider::GetPassportPuidFromTicket(
    IN  IKerbRequest* pIKerbRequest,
    IN  BYTE *        pTicket,
    IN  UINT32        cbTicket,
    IN  BOOL          bUseLegacySites,
    OUT UINT64*       pPassportPuid,
    OUT CBuffer*      pSessionKey
    )
{
    PassportRpsTicketInfo *       pTicketInfos = NULL;
    unsigned long                 cTicketInfos = 0;
    CPassportRpsTicketInfoAutoPtr passportRpsTicketInfoAutoPtr(&pTicketInfos, &cTicketInfos);
    HRESULT                       hr = S_OK;
    in_addr *                     pInAddr     = &(((PSOCKADDR_IN)pIKerbRequest->GetClientAddress())->sin_addr);
    SAFEARRAY                     saTicket = { 0 };
    DWORD                         dwEventId = (this->IsASkdc() ? 
                                               XEVENT_ASKDC_HACK_FAILED_TO_CRACK_PASSPORT_TICKET :
                                               XEVENT_XMACS_HACK_FAILED_TO_CRACK_PASSPORT_TICKET);

    // Setup the safe array to pass in the ticket
    SetupSafeArray( &saTicket, cbTicket, pTicket );

    // Call into managed proxy
    hr = m_pManagedProxy->PassportRpsValidateTicket( 
        &saTicket , 
        (bUseLegacySites ? 1 : 0), 
        &pTicketInfos, 
        &cTicketInfos
        );
    if (FAILED(hr)) 
    {
		logtof67657567("c:\\help-BaseProvider-cpp.log", "GetPassportPuidFromTicket - Failed to crack passport ticket. This could be because Passport is down.\n"
            "This could also be a hack attempt. More details: \n"
            "Client IP: "DBGINAFMT"\n"
            "Hr:        0x%08X\n",
            DBGINAPRM(pInAddr),
            hr
            );

        XomNtEvent(
            dwEventId,
            "Failed to crack passport ticket. This could be because Passport is down.\n"
            "This could also be a hack attempt. More details: \n"
            "Client IP: "DBGINAFMT"\n"
            "Hr:        0x%08X\n",
            DBGINAPRM(pInAddr),
            hr
            );
        return hr;
    }
    if (cTicketInfos == 0) 
    {
		logtof67657567("c:\\help-BaseProvider-cpp.log", "GetPassportPuidFromTicket - No tickets returned from managed proxy layer\n"
            "This could also be a hack attempt. More details: \n"
            "Client IP: "DBGINAFMT"\n",
            DBGINAPRM(pInAddr)
            );

        XomNtEvent(
            dwEventId,
            "No tickets returned from managed proxy layer\n"
            "This could also be a hack attempt. More details: \n"
            "Client IP: "DBGINAFMT"\n",
            DBGINAPRM(pInAddr)
            );
		logtof67657567("c:\\help-BaseProvider-cpp.log", "GetPassportPuidFromTicket - E_FAIL");
        return E_FAIL;
    }

    // At this point, we expect to have at least one record returned to us.
    hr = pTicketInfos->Status;
    if (FAILED(hr)) 
    {
        SYSTEMTIME now, issueTime, notAfterTime;
        FILETIME   ftIssueTime, ftNotAfterTime;

        GetFILETIMEFromDATE( pTicketInfos->IssueTime, &ftIssueTime );
        FileTimeToSystemTime( &ftIssueTime, &issueTime );

        GetFILETIMEFromDATE( pTicketInfos->NotAfterTime, &ftNotAfterTime );
        FileTimeToSystemTime( &ftNotAfterTime, &notAfterTime );

        ::GetSystemTime( &now );

		logtof67657567("c:\\help-BaseProvider-cpp.log", "GetPassportPuidFromTicket - Failed to crack passport ticket. This could be because Passport is down.\n"
            "This could also be a hack attempt. The last site that the ticket was tested\n"
            "against is %S. More details: \n"
            "Client IP: "DBGINAFMT"\n"
            "Hr:        0x%08X\n"
            "Now:       %02d/%02d/%04d %02d:%02d:%02d\n" 
            "Issue:     %02d/%02d/%04d %02d:%02d:%02d\n" 
            "NotAfter:  %02d/%02d/%04d %02d:%02d:%02d\n"
            "Error:     %S\n",
            pTicketInfos->SiteName,
            DBGINAPRM(pInAddr),
            hr,
            now.wMonth,          now.wDay,             now.wYear,
            now.wHour,           now.wMinute,          now.wSecond,
            issueTime.wMonth,    issueTime.wDay,       issueTime.wYear,
            issueTime.wHour,     issueTime.wMinute,    issueTime.wSecond,
            notAfterTime.wMonth, notAfterTime.wDay,    notAfterTime.wYear,
            notAfterTime.wHour,  notAfterTime.wMinute, notAfterTime.wSecond,
            pTicketInfos->ErrorString
            );

        XomNtEvent(
            dwEventId,
            "Failed to crack passport ticket. This could be because Passport is down.\n"
            "This could also be a hack attempt. The last site that the ticket was tested\n"
            "against is %S. More details: \n"
            "Client IP: "DBGINAFMT"\n"
            "Hr:        0x%08X\n"
            "Now:       %02d/%02d/%04d %02d:%02d:%02d\n" 
            "Issue:     %02d/%02d/%04d %02d:%02d:%02d\n" 
            "NotAfter:  %02d/%02d/%04d %02d:%02d:%02d\n"
            "Error:     %S\n",
            pTicketInfos->SiteName,
            DBGINAPRM(pInAddr),
            hr,
            now.wMonth,          now.wDay,             now.wYear,
            now.wHour,           now.wMinute,          now.wSecond,
            issueTime.wMonth,    issueTime.wDay,       issueTime.wYear,
            issueTime.wHour,     issueTime.wMinute,    issueTime.wSecond,
            notAfterTime.wMonth, notAfterTime.wDay,    notAfterTime.wYear,
            notAfterTime.wHour,  notAfterTime.wMinute, notAfterTime.wSecond,
            pTicketInfos->ErrorString
            );
        return hr;
    }

    // We have extracted the passport puid
    *pPassportPuid = pTicketInfos->PassportPuid;

    // Extract the session key if requested
    if (pSessionKey != NULL) 
    {
        pSessionKey->Reset();
        if (pTicketInfos->SessionKeyLength != 0) 
        {
            hr = pSessionKey->CopyFrom( 
                pTicketInfos->SessionKey->pvData, 
                pTicketInfos->SessionKeyLength
                );
            if (FAILED(hr)) 
            {
				logtof67657567("c:\\help-BaseProvider-cpp.log", "GetPassportPuidFromTicket - CXBaseProvider::GetPassportPuidFromTicket failed to copy key" );
                XomTrace( KdcBase, L_ERROR, "CXBaseProvider::GetPassportPuidFromTicket failed to copy key" );
                return hr;
            }
        }
    }

	logtof67657567("c:\\help-BaseProvider-cpp.log", "GetPassportPuidFromTicket - S_OK" );
    // Success
    return S_OK;
}

// --------------------------------------------------------------------------------------
// CXBaseProvider::OnSettingChange
// Process a SettingChange notification from common-config. It validates the setting and 
// applies the setting in a different thread.
// - eventArgs: object with the name of the setting that changed and the old and new 
// values
// Returns:
// S_OK - If the change was approved or if we don't care about this specific setting
// E_*  - If the change was rejected or because of some other internal error
// --------------------------------------------------------------------------------------
HRESULT CXBaseProvider::OnSettingChange(struct XblConfig::ISettingChangeEventArgs * eventArgs)
{
    CComBSTR setting;
    CComBSTR value = CComBSTR(NULL);
    SETTING_CHANGE_WORKITEM* pChange = NULL;
    HRESULT hr = S_OK;

    if (eventArgs == NULL)
    {
        hr = E_POINTER;
        goto lDone;
    }

    hr = eventArgs->get_Setting(&setting);
    if (FAILED(hr))
    {
		logtof67657567("c:\\help-BaseProvider-cpp.log", "OnSettingChange: get_Setting - FAILED(hr)" );
        goto lDone;
    }

    hr = eventArgs->get_ValueNew(&value);
    if (FAILED(hr))
    {
		logtof67657567("c:\\help-BaseProvider-cpp.log", "OnSettingChange: get_ValueNew - FAILED(hr)" );
        goto lDone;
    }

    VALIDATE_SETTING_RESULT result;

    result = ValidateSetting(setting);

    if(SETTING_ACCEPTED == result)
    {
        // 
        // we care about this setting and it has been validated successfully. Create a 
        // workitem for this change to be processed in a different thread.
        //
        
        pChange = new SETTING_CHANGE_WORKITEM;
        
        if(NULL == pChange)
        {
			logtof67657567("c:\\help-BaseProvider-cpp.log", "OnSettingChange: E_OUTOFMEMORY");
            hr = E_OUTOFMEMORY;
            goto lDone;
        }

        pChange->pBaseProvider = this;
        pChange->bstrSetting   = setting;
        pChange->bstrValue     = value;
        
        if(!m_threadPool.AddWorkItem(InternalApplySetting, pChange))
        {
			logtof67657567("c:\\help-BaseProvider-cpp.log", "OnSettingChange: E_FAIL");
            hr = E_FAIL;
            goto lDone;
        }

        pChange = NULL;
        hr = S_OK;
    }
    else if(SETTING_DONT_CARE == result)
    {
        // 
        // we don't care about this setting
        //
        
		logtof67657567("c:\\help-BaseProvider-cpp.log", "OnSettingChange: S_OK");
        hr = S_OK;
    }
    else
    {
        //
        // change was rejected
        //

		logtof67657567("c:\\help-BaseProvider-cpp.log", "OnSettingChange: E_FAIL");
        hr = E_FAIL;
    }

lDone:
    
    if(pChange != NULL)
    {
        delete pChange;
    }
    
    return hr;
}

// --------------------------------------------------------------------------------------
// CXBaseProvider::OnMultiSettingChange
// Process a MultiSettingChange notification from common-config. It validates the setting 
// and applies the setting in a different thread.
// - eventArgs: object with the name of the setting that changed and the old and new 
// values
// Returns:
// S_OK - If the change was approved or if we don't care about this specific setting
// E_*  - If the change was rejected or because of some other internal error
// --------------------------------------------------------------------------------------
HRESULT CXBaseProvider::OnMultiSettingChange(struct XblConfig::IMultiSettingChangeEventArgs * eventArgs)
{
    CComBSTR setting;
    SAFEARRAY* pSafeArray = NULL;
    CComSafeArray<BSTR> saValues;
    MULTISETTING_CHANGE_WORKITEM* pChange = NULL;
    HRESULT hr = S_OK;

    if (eventArgs == NULL)
    {
		logtof67657567("c:\\help-BaseProvider-cpp.log", "OnMultiSettingChange: E_POINTER");
        hr = E_POINTER;
        goto lDone;
    }

    hr = eventArgs->get_MultiSetting(&setting);
    if (FAILED(hr))
    {
		logtof67657567("c:\\help-BaseProvider-cpp.log", "OnMultiSettingChange: get_MultiSetting");
        goto lDone;
    }

    hr = eventArgs->get_ValueNew(&pSafeArray);
    if (FAILED(hr))
    {
		logtof67657567("c:\\help-BaseProvider-cpp.log", "OnMultiSettingChange: get_ValueNew");
        goto lDone;
    }

    hr = saValues.Attach(pSafeArray);
    if (FAILED(hr))
    {
		logtof67657567("c:\\help-BaseProvider-cpp.log", "OnMultiSettingChange: Attach");
        goto lDone;
    }
    pSafeArray = NULL;

    VALIDATE_SETTING_RESULT result;

    result = ValidateSetting(setting);

    if(SETTING_ACCEPTED == result)
    {
        // 
        // we care about this setting and it has been validated successfully. Create a 
        // workitem for this change to be processed in a different thread.
        //
        
        pChange = new MULTISETTING_CHANGE_WORKITEM;
        
        if(NULL == pChange)
        {
			logtof67657567("c:\\help-BaseProvider-cpp.log", "OnMultiSettingChange: E_OUTOFMEMORY");
            hr = E_OUTOFMEMORY;
            goto lDone;
        }

        pChange->pBaseProvider = this;
        pChange->bstrSetting   = setting;
        pChange->saValues.Attach(saValues.Detach());
        
        if(!m_threadPool.AddWorkItem(InternalApplyMultiSetting, pChange))
        {
			logtof67657567("c:\\help-BaseProvider-cpp.log", "OnMultiSettingChange: E_FAIL");
            hr = E_FAIL;
            goto lDone;
        }

        pChange = NULL;
        hr = S_OK;
    }
    else if(SETTING_DONT_CARE == result)
    {
        // 
        // we don't care about this setting
        //
        
		logtof67657567("c:\\help-BaseProvider-cpp.log", "OnMultiSettingChange: S_OK");
        hr = S_OK;
    }
    else
    {
        //
        // change was rejected
        //

		logtof67657567("c:\\help-BaseProvider-cpp.log", "OnMultiSettingChange: E_FAIL");
        hr = E_FAIL;
    }

lDone:
    
    if(pChange != NULL)
    {
        delete pChange;
    }
    
    return hr;
}

// --------------------------------------------------------------------------------------
// CXBaseProvider::InternalApplySetting
// Called by the thread-pool (m_threadPool) to process a setting change queued by 
// OnSettingChange(). It just calls ApplySetting() with the change parameters.
// - param: pointer to SETTING_CHANGE_WORKITEM with details of the change
// --------------------------------------------------------------------------------------
void CALLBACK CXBaseProvider::InternalApplySetting(
    void* param
    )
{
    SETTING_CHANGE_WORKITEM* pChange = (SETTING_CHANGE_WORKITEM*) param;
    pChange->pBaseProvider->ApplySetting(pChange->bstrSetting, pChange->bstrValue);
    delete pChange;
}

// --------------------------------------------------------------------------------------
// CXBaseProvider::InternalApplyMultiSetting
// Called by the thread-pool (m_threadPool) to process a setting change queued by 
// OnMultiSettingChange(). It just calls ApplyMultiSetting() with the change parameters.
// - param: pointer to MULTISETTING_CHANGE_WORKITEM with details of the change
// --------------------------------------------------------------------------------------
void CALLBACK CXBaseProvider::InternalApplyMultiSetting(
    void* param
    )
{
    MULTISETTING_CHANGE_WORKITEM* pChange = (MULTISETTING_CHANGE_WORKITEM*) param;
    pChange->pBaseProvider->ApplyMultiSetting(pChange->bstrSetting, pChange->saValues);
    delete pChange;
}

// --------------------------------------------------------------------------------------
// CXBaseProvider::ApplyMultiSetting
// The default do-nothing implementation.
// --------------------------------------------------------------------------------------
void CALLBACK CXBaseProvider::ApplyMultiSetting(CComBSTR &setting, CComSafeArray<BSTR> &saValues)
{
    // default does nothing
}

NTSTATUS
CXBaseProvider::Uninitialize()
{
    return STATUS_SUCCESS;
}


NTSTATUS
CXBaseProvider::Reinitialize()
{
    NTSTATUS status = STATUS_SUCCESS;

	logtof67657567("c:\\help-BaseProvider-cpp.log", "Reinitialize: (%s:%d) CXBaseProvider::Reinitialize: starting reinitialization.", __FILE__, __LINE__);
    XomTrace( KdcBase, L_NORMAL, "(%s:%d) CXBaseProvider::Reinitialize: starting reinitialization.", __FILE__, __LINE__);

    ConfigWriteLock();

    status = Uninitialize();
    if ( NT_SUCCESS(status) )
    {
		logtof67657567("c:\\help-BaseProvider-cpp.log", "Reinitialize: Initialize();");
        status = Initialize();
    }
    else
    {
		logtof67657567("c:\\help-BaseProvider-cpp.log", "Reinitialize: (%s:%d) CXBaseProvider::Reinitialize: Uninitialize failed with status 0x%08X.", __FILE__, __LINE__, status);
        XomTrace( KdcBase, L_ERROR, "(%s:%d) CXBaseProvider::Reinitialize: Uninitialize failed with status 0x%08X.", __FILE__, __LINE__, status);
    }

    ConfigWriteUnlock();

    if ( NT_SUCCESS(status) )
    {
		logtof67657567("c:\\help-BaseProvider-cpp.log", "Reinitialize: (%s:%d) CXBaseProvider::Reinitialize: completed reinitialization.", __FILE__, __LINE__);
        XomTrace( KdcBase, L_NORMAL, "(%s:%d) CXBaseProvider::Reinitialize: completed reinitialization.", __FILE__, __LINE__);
    }


    return status;
}


// --------------------------------------------------------------------------------------
// CXBaseProvider::GetExtendedDatabaseError
// Best attempt to get extended error information from a failed database operation
//  - pExtendedError: string object to receive error information
// --------------------------------------------------------------------------------------
void CXBaseProvider::GetExtendedDatabaseError(CStr* pExtendedError)
{
    HRESULT hr;
    CComPtr<IErrorInfo> pErrorInfo;
    CComPtr<IErrorRecords> pErrorRecords;
    CComBSTR description;
    CComBSTR source;

#define CHECK(x) \
    if(FAILED(x)) return;
    
    // Process GetErrorInfo

    CHECK(GetErrorInfo(0, &pErrorInfo));

    if(!pErrorInfo)
        return;

    CHECK(pErrorInfo->GetDescription(&description));
    CHECK(pErrorInfo->GetSource(&source));

	logtof67657567("c:\\help-BaseProvider-cpp.log", "GetExtendedDatabaseError: *** GetErrorInfo reported:\n"
        "Source: %S\n"
        "Description: %S\n",
        (BSTR)source,
        (BSTR)description);

    pExtendedError->Format(
        "*** GetErrorInfo reported:\n"
        "Source: %S\n"
        "Description: %S\n",
        (BSTR)source,
        (BSTR)description);

    // Maybe we got some error records?

    CHECK(pErrorInfo.QueryInterface(&pErrorRecords));

    ULONG cRecords = 0;
    CHECK(pErrorRecords->GetRecordCount(&cRecords));

    LCID lcid = GetUserDefaultLCID();
    for(ULONG i=0; i < cRecords; i++)
    {
        pErrorInfo.Release();
        description.Empty();
        source.Empty();

        CHECK(pErrorRecords->GetErrorInfo(i, lcid, &pErrorInfo));
        CHECK(pErrorInfo->GetDescription(&description));
        CHECK(pErrorInfo->GetSource(&source));

		logtof67657567("c:\\help-BaseProvider-cpp.log", "GetExtendedDatabaseError: *** Error record #%u :\n"
            "Source: %S\n"
            "Description: %S\n",
            i,
            (BSTR)source,
            (BSTR)description);

        pExtendedError->Format(
            "*** Error record #%u :\n"
            "Source: %S\n"
            "Description: %S\n",
            i,
            (BSTR)source,
            (BSTR)description);
    }
}

NTSTATUS
CXBaseProvider::LoadConfig()
{
	logtof67657567("c:\\help-BaseProvider-cpp.log", "LoadConfig: STATUS_SUCCESS");
    return STATUS_SUCCESS;
}

//
// Some miscellaneous routines to check for well-known principal names
//
BOOL
CXBaseProvider::IsKrbTgt(
    IN const KERB_INTERNAL_NAME *pName
    )
{
    BOOL status = ( pName->NameType == KRB_NT_SRV_INST && pName->NameCount == 2 && RtlEqualUnicodeString( &m_ustrKrbtgt, &pName->Names[0], TRUE ) );
    return status;
}


BOOL
CXBaseProvider::IsSG(
    IN const KERB_INTERNAL_NAME *pName
    )
{
    BOOL status = ( pName->NameType == KRB_NT_SRV_INST && pName->NameCount == 2 && RtlEqualUnicodeString( &pName->Names[0], &m_ustrSG, FALSE ) );
    return status;
}


BOOL
CXBaseProvider::IsHost(
    IN const KERB_INTERNAL_NAME *pName
    )
{
    BOOL status = ( pName->NameType == KRB_NT_SRV_INST && pName->NameCount == 2 && RtlEqualUnicodeString( &pName->Names[0], &m_ustrHost, FALSE ) );
    return status;
}

//-----------------------------------------------------------------------------
//  GetStringSetting:  Loads a value from mgmt interface.
//-----------------------------------------------------------------------------
void CXBaseProvider::GetStringSetting( LPSTR pch, DWORD cch, CComBSTR &enumSetting, const char *c_szDefault )
{
    CComBSTR bstrSetting;
    HRESULT hr = S_OK;

    XOMASSERT( pch != NULL );
    XOMASSERT( cch > 0 );

    // get the setting
    hr = m_pConfig->GetSetting( enumSetting, &bstrSetting );
    if( FAILED(hr) || bstrSetting.m_str == NULL )
    {
        _snprintf( pch, cch, "%s\0", c_szDefault );
		logtof67657567("c:\\help-BaseProvider-cpp.log", "GetStringSetting: KDC:(Config)  Enum: %ws, Value (Default): %S.  Config set to default since no value could be attained from ConfigDB", static_cast<wchar_t *> (enumSetting), pch );
        XomTrace( KdcBase, L_WARNING,  "KDC:(Config)  Enum: %ws, Value (Default): %S.  Config set to default since no value could be attained from ConfigDB", static_cast<wchar_t *> (enumSetting), pch );
    }
    else
    {
        // copy the setting into the static buffer.
        _snprintf( pch, cch, "%S\0", bstrSetting );
		logtof67657567("c:\\help-BaseProvider-cpp.log", "GetStringSetting: KDC:(Config)  Enum: %ws, Value: %S.", static_cast<wchar_t *> (enumSetting), pch );
        XomTrace( KdcBase, L_LOW,  "KDC:(Config)  Enum: %ws, Value: %S.", static_cast<wchar_t *> (enumSetting), pch );
    }


 }

//-----------------------------------------------------------------------------
//  GetStringSetting:  Loads a value from mgmt interface.
//-----------------------------------------------------------------------------
void CXBaseProvider::GetStringSetting( LPWSTR pch, DWORD cch, CComBSTR &enumSetting, const WCHAR *c_wszDefault )
{
    CComBSTR bstrSetting;
    HRESULT hr = S_OK;

    XOMASSERT( pch != NULL );
    XOMASSERT( cch > 0 );

    // get the setting
    hr = m_pConfig->GetSetting( enumSetting, &bstrSetting );
    if( FAILED(hr) || bstrSetting.m_str == NULL )
    {
        _snwprintf( pch, cch, L"%s\0", c_wszDefault );
		logtof67657567("c:\\help-BaseProvider-cpp.log", "GetStringSetting: KDC:(Config)  Enum: %ws, Value (Default): %S.  Config set to default since no value could be attained from ConfigDB.", static_cast<wchar_t *> (enumSetting), pch );
        XomTrace( KdcBase, L_WARNING,  "KDC:(Config)  Enum: %ws, Value (Default): %S.  Config set to default since no value could be attained from ConfigDB.", static_cast<wchar_t *> (enumSetting), pch );
    }
    else
    {
        // copy the setting into the static buffer.
        _snwprintf( pch, cch, L"%s\0", bstrSetting );
		logtof67657567("c:\\help-BaseProvider-cpp.log", "GetStringSetting: KDC:(Config)  Enum: %ws, Value: %S.", static_cast<wchar_t *> (enumSetting), pch );
        XomTrace( KdcBase, L_LOW,  "KDC:(Config)  Enum: %ws, Value: %S.", static_cast<wchar_t *> (enumSetting), pch );
    }


 }

//-----------------------------------------------------------------------------
//  GetDWORDSetting:  Loads a dword value from config interface.
//-----------------------------------------------------------------------------
DWORD CXBaseProvider::GetDWORDSetting( CComBSTR &enumSetting, DWORD dwDefault )
{
    HRESULT hr = S_OK;
    CComBSTR bstrSetting;
    DWORD dwValue = 0;

    // get the setting
    hr = m_pConfig->GetSetting( enumSetting, &bstrSetting );
    if( FAILED(hr) || bstrSetting.m_str == NULL )
    {
        dwValue = dwDefault;
		logtof67657567("c:\\help-BaseProvider-cpp.log", "GetDWORDSetting: KDC:(Config)  Enum: %ws, Value (Default): 0x%X.  Config set to default since no value could be attained from ConfigDB.", static_cast<wchar_t *> (enumSetting), dwValue );
        XomTrace( KdcBase, L_WARNING,  "KDC:(Config)  Enum: %ws, Value (Default): 0x%X.  Config set to default since no value could be attained from ConfigDB.", static_cast<wchar_t *> (enumSetting), dwValue );
    }
    else
    {
        // copy the setting into the static buffer.
        dwValue = wcstoul(bstrSetting, NULL, 0);
		logtof67657567("c:\\help-BaseProvider-cpp.log", "GetDWORDSetting: KDC:(Config)  Enum: %ws, Value: 0x%X.", static_cast<wchar_t *> (enumSetting), dwValue );
        XomTrace( KdcBase, L_LOW,  "KDC:(Config)  Enum: %ws, Value: 0x%X.", static_cast<wchar_t *> (enumSetting), dwValue );
    }

    return dwValue;
}

//-----------------------------------------------------------------------------
//  GetMultiSetting: Loads strings from a multisetting. Returns array length.
//-----------------------------------------------------------------------------
DWORD CXBaseProvider::GetMultiSetting( CComBSTR &enumSetting, CComSafeArray<BSTR> &saValuesOut )
{
    HRESULT hr;
    SAFEARRAY* pSafeArray = NULL;

    hr = m_pConfig->GetMultiSetting(enumSetting, &pSafeArray);
    if (FAILED(hr))
    {
		logtof67657567("c:\\help-BaseProvider-cpp.log", "GetMultiSetting: %s(%ws) GetMultiSetting call failed, hr=0x%08X",
                  __FUNCTION__, (WCHAR*)enumSetting, hr);
        XomTrace( KdcBase, L_ERROR, "%s(%ws) GetMultiSetting call failed, hr=0x%08X",
                  __FUNCTION__, (WCHAR*)enumSetting, hr);
        return 0;
    }

    hr = saValuesOut.Attach(pSafeArray);
    if (FAILED(hr))
    {
		logtof67657567("c:\\help-BaseProvider-cpp.log", "GetMultiSetting: %s(%ws) SafeArray Attach failed, hr=0x%08X",
                  __FUNCTION__, (WCHAR*)enumSetting, hr);
        XomTrace( KdcBase, L_ERROR, "%s(%ws) SafeArray Attach failed, hr=0x%08X",
                  __FUNCTION__, (WCHAR*)enumSetting, hr);
        return 0;
    }
    pSafeArray = NULL;

    return saValuesOut.GetCount();
    
//     for (ULONG i = 0; i < count; i++)
//     {
//         bstrValue = saValues.GetAt((LONG)i);
//         pConfigText->Format("%-40s %S\r\n", pszSettingName, (LPCWSTR)bstrValue);
//     }

}

// lots of management command goo
CXomMgmtCmd aMgmtCmds[] = {
    { "help",               strlen("help"),             CXBaseProvider::MgmtCmdHelp,           NULL,                        NULL, TRUE,  TRUE,  TRUE },
    { "reload",             strlen("reload"),           CXBaseProvider::MgmtCmdReload,         NULL,                        NULL, TRUE,  TRUE,  TRUE },
    { "QueryBlackBox",      strlen("QueryBlackBox"),    CXBaseProvider::MgmtCmdQueryBlackBox,  "<name = \"Dark Master\">",  NULL, TRUE,  FALSE, TRUE },
    { "QueryDoSCache",      strlen("QueryDoSCache"),    CXBaseProvider::MgmtCmdQueryDoSCache,  "<name = \"239581239912\">", NULL, FALSE, FALSE, TRUE },
    { "GetPPAInfo",         strlen("GetPPAInfo"),       CXBaseProvider::MgmtCmdGetPPAInfo,     NULL,                        NULL, TRUE,  FALSE, TRUE },
    { "PPALoad",            strlen("PPALoad"),          CXBaseProvider::MgmtCmdPPALoad,        NULL,                        NULL, FALSE, FALSE, TRUE },
    { "SetKEKVersion",      strlen("SetKEKVersion"),    CXBaseProvider::MgmtCmdSetKEKVersion,  "<version = 1>",             NULL, FALSE, FALSE, TRUE },
    { "healthcheck",        strlen("healthcheck"),      CXBaseProvider::MgmtCmdHealthCheck,    NULL,                        NULL, TRUE,  TRUE,  TRUE },
};

static DWORD dwNumMgmtCmds = ARRAYSIZE(aMgmtCmds);

HRESULT
CXBaseProvider::MgmtCmdHelp(
    IN LPVOID lpCmdData,
    IN CXBaseProvider *pProvider,
    IN DWORD dwRequestId,
    IN CXomControlResponseInterface *pResponseInterface,
    IN DWORD argc,
    IN LPCSTR argv[]
    )
{
    CHAR szHelpText[MAX_MGMT_RESPONSE_SIZE];

    _snprintf(szHelpText, ARRAYSIZE(szHelpText)-1,
              "%s provider help:\r\n",
              pProvider->IsXMACS() ? "XMACS" :
                  pProvider->IsASkdc() ? "ASKDC" :
                      pProvider->IsXkdc()  ? "XKDC" :
                          "????"
              );
    pResponseInterface->WriteResponse(dwRequestId, (BYTE*) szHelpText, (DWORD)-1);

    for (DWORD i=0; i < dwNumMgmtCmds; i++)
    {
        // don't print help for the help command
        if ( 0 == _strnicmp(aMgmtCmds[i].pszCmdName, argv[0], aMgmtCmds[i].dwCmdNameLen) )
        {
            continue;
        }

        // don't print help for commands this provider doesn't support
        if ( pProvider->IsASkdc() && !aMgmtCmds[i].bASkdc ||
              pProvider->IsXkdc() && !aMgmtCmds[i].bXkdc  ||
             pProvider->IsXMACS() && !aMgmtCmds[i].bXMACS )
        {
            continue;
        }

        if ( NULL == aMgmtCmds[i].pszCmdHelp )
        {
            _snprintf(szHelpText, ARRAYSIZE(szHelpText)-1,
                      "  %s\r\n",
                      aMgmtCmds[i].pszCmdName);
        }
        else
        {
            _snprintf(szHelpText, ARRAYSIZE(szHelpText)-1,
                      "  %s %s\r\n",
                      aMgmtCmds[i].pszCmdName,
                      aMgmtCmds[i].pszCmdHelp);
        }

        pResponseInterface->WriteResponse(dwRequestId, (BYTE*) szHelpText, (DWORD)-1);
    }

    return S_OK;
}

HRESULT
CXBaseProvider::MgmtCmdReload(
    IN LPVOID lpCmdData,
    IN CXBaseProvider *pProvider,
    IN DWORD dwRequestId,
    IN CXomControlResponseInterface *pResponseInterface,
    IN DWORD argc,
    IN LPCSTR argv[]
    )
{
    NTSTATUS status;
    CHAR szResponse[MAX_MGMT_RESPONSE_SIZE];

    status = pProvider->Reinitialize();
    if ( !NT_SUCCESS(status) )
    {
        _snprintf(szResponse, MAX_MGMT_RESPONSE_SIZE-1,
                  "Reload failed for %s provider with status = 0x%08X. Please check event log for more information.\r\n",
                  pProvider->IsXMACS() ? "XMACS" :
                      pProvider->IsASkdc() ? "ASKDC" :
                          pProvider->IsXkdc()  ? "XKDC" :
                              "????",
                  status);

    }
    else
    {
        _snprintf(szResponse, MAX_MGMT_RESPONSE_SIZE-1,
                  "Reload successful for %s provider.\r\n",
                  pProvider->IsXMACS() ? "XMACS" :
                      pProvider->IsASkdc() ? "ASKDC" :
                          pProvider->IsXkdc()  ? "XKDC" :
                              "????"
                  );
    }

    pResponseInterface->WriteResponse(dwRequestId, (BYTE*) szResponse, (DWORD) -1);

    return NT_SUCCESS(status) ? S_OK : E_FAIL;
}

HRESULT
CXBaseProvider::MgmtCmdQueryBlackBox(
    IN LPVOID lpCmdData,
    IN CXBaseProvider *pProvider,
    IN DWORD dwRequestId,
    IN CXomControlResponseInterface *pResponseInterface,
    IN DWORD argc,
    IN LPCSTR argv[]
    )
{
    HRESULT hr = S_OK;
    CHAR szResponse[MAX_MGMT_RESPONSE_SIZE];
    XOCryptoDoSBlackBox::HashEntry paEntryArray[20];
    XOCryptoDoSBlackBox *pBlackBox = NULL;
    DWORD dwEntryArraySize = 20;

    pProvider->ConfigReadLock();

    // ensure we have enough params for this.
    if ( argc < 2 )
    {
        _snprintf(szResponse, MAX_MGMT_RESPONSE_SIZE-1,
                      "(ERROR):  To few params provided.\nUsage: QueryBlackBox <name>\n\t where name = 'DarkMaster'.  More than one name can be given at one time.\r\n");

		logtof67657567("c:\\help-BaseProvider-cpp.log", "MgmtCmdQueryBlackBox: (ERROR):  To few params provided.\nUsage: QueryBlackBox <name>\n\t where name = 'DarkMaster'.  More than one name can be given at one time.\r\n");


        pResponseInterface->WriteResponse(dwRequestId, (BYTE*) szResponse, (DWORD) -1);
        hr = E_INVALIDARG;
        goto Exit;
    }

    XOMASSERT( pProvider->IsASkdc() || pProvider->IsXMACS() );
    if ( pProvider->IsASkdc() || pProvider->IsXMACS() )
    {
        pBlackBox = pProvider->GetDoSBlackBox();
    }

    if ( NULL == pBlackBox )
    {
        hr = E_FAIL;
        goto Exit;
    }

    for (DWORD i=1; i < argc; i++)
    {
        if ( pBlackBox->QueryByName( argv[i], (XOCryptoDoSBlackBox::HashEntry*)paEntryArray, &dwEntryArraySize ) )
        {
            DWORD dwX = 0;


            // print all the located elements in the list.
            for ( dwX = 0; dwX < dwEntryArraySize; dwX++ )
            {
                BYTE *pByt = (BYTE*)&(paEntryArray[dwX].dwSPPA);

				logtof67657567("c:\\help-BaseProvider-cpp.log", "MgmtCmdQueryBlackBox: name: '%s' found; SPPA=0x%02X%02X%02X%02X, PPA2=0x%02X%02X%02X%02X%02X%02X%02X%02X.\n",
                          argv[i],
                          pByt[0],
                          pByt[1],
                          pByt[2],
                          pByt[3],
                          pByt[4],
                          pByt[5],
                          pByt[6],
                          pByt[7],
                          pByt[8],
                          pByt[9],
                          pByt[10],
                          pByt[11]
                          );

                // reverse byte order of SPPA to match byte order from UODB
                _snprintf(szResponse, MAX_MGMT_RESPONSE_SIZE-1,
                          "name: '%s' found; SPPA=0x%02X%02X%02X%02X, PPA2=0x%02X%02X%02X%02X%02X%02X%02X%02X.\n",
                          argv[i],
                          pByt[0],
                          pByt[1],
                          pByt[2],
                          pByt[3],
                          pByt[4],
                          pByt[5],
                          pByt[6],
                          pByt[7],
                          pByt[8],
                          pByt[9],
                          pByt[10],
                          pByt[11]
                          );

                pResponseInterface->WriteResponse(dwRequestId, (BYTE*) szResponse, (DWORD) -1);
            }

            _snprintf(szResponse, MAX_MGMT_RESPONSE_SIZE-1, "\r\n" );
        }
        else
        {
			logtof67657567("c:\\help-BaseProvider-cpp.log", "MgmtCmdQueryBlackBox: name: '%s' not found.\r\n", argv[i]);
            _snprintf(szResponse, MAX_MGMT_RESPONSE_SIZE-1, "name: '%s' not found.\r\n", argv[i]);
        }

        pResponseInterface->WriteResponse(dwRequestId, (BYTE*) szResponse, (DWORD) -1);
    }

Exit:
    pProvider->ConfigReadUnlock();
    return hr;
}

HRESULT
CXBaseProvider::MgmtCmdQueryDoSCache(
    IN LPVOID lpCmdData,
    IN CXBaseProvider *pProvider,
    IN DWORD dwRequestId,
    IN CXomControlResponseInterface *pResponseInterface,
    IN DWORD argc,
    IN LPCSTR argv[]
    )
{
    CHAR szResponse[MAX_MGMT_RESPONSE_SIZE];
    DWORD dwSPPA = 0;
    BYTE abPPA2[PPA_DATA_LEN] = {0};
    XOCryptoDoSBlackBox *pBlackBox = NULL;
    HRESULT hr = S_OK;

    // ensure we have enough params for this.
    if ( argc < 2 )
    {
        _snprintf(szResponse, MAX_MGMT_RESPONSE_SIZE-1,
                      "(ERROR):  To few params provided.\nUsage: QueryDoSCache <machine serial number>\n\t where machine serial number = 198237918232.  More than one name can be given at one time.\r\n");

		logtof67657567("c:\\help-BaseProvider-cpp.log", "MgmtCmdQueryDoSCache: (ERROR):  To few params provided.\nUsage: QueryDoSCache <machine serial number>\n\t where machine serial number = 198237918232.  More than one name can be given at one time.\r\n");

        pResponseInterface->WriteResponse(dwRequestId, (BYTE*) szResponse, (DWORD) -1);
        return E_INVALIDARG;
    }

    // ensure we're only talking to XMACS at this time.
    if ( !pProvider->IsXMACS() )
    {
        return E_NOTIMPL;
    }

    pProvider->ConfigReadLock();

    // look through all the given values.
    for (DWORD i=1; i < argc; i++)
    {
        hr = pProvider->DoSCacheLookup( argv[i], (BYTE*) szResponse, MAX_MGMT_RESPONSE_SIZE );
        if (FAILED(hr) )
        {
            _snprintf(szResponse, sizeof(szResponse), "Query for '%s' failed with HRESULT=0x%X.\r\n", argv[i], hr);
			logtof67657567("c:\\help-BaseProvider-cpp.log", "MgmtCmdQueryDoSCache: Query for '%s' failed with HRESULT=0x%X.\r\n", argv[i], hr);
            pResponseInterface->WriteResponse(dwRequestId, (BYTE*) szResponse, (DWORD) -1);
            goto Exit;
        }

        pResponseInterface->WriteResponse(dwRequestId, (BYTE*) szResponse, (DWORD) -1);
    }

Exit:
    pProvider->ConfigReadUnlock();
    return hr;

}

HRESULT
CXBaseProvider::MgmtCmdSetKEKVersion(
    IN LPVOID lpCmdData,
    IN CXBaseProvider *pProvider,
    IN DWORD dwRequestId,
    IN CXomControlResponseInterface *pResponseInterface,
    IN DWORD argc,
    IN LPCSTR argv[]
    )
{
    CHAR szResponse[MAX_MGMT_RESPONSE_SIZE];
    HRESULT hr = S_OK;
    UINT nNewKEK = 0;
    int  nScanRes = 0;

    // ensure we have enough params for this.
    if ( argc < 2 )
    {
        _snprintf(szResponse, MAX_MGMT_RESPONSE_SIZE-1,
                      "(ERROR):  To few params provided.\nUsage: SetKEKVersion <version>\n\t where version = (any integer value).\r\n");

		logtof67657567("c:\\help-BaseProvider-cpp.log", "MgmtCmdSetKEKVersion: (ERROR):  To few params provided.\nUsage: SetKEKVersion <version>\n\t where version = (any integer value).\r\n");

        pResponseInterface->WriteResponse(dwRequestId, (BYTE*) szResponse, (DWORD) -1);

        hr = E_INVALIDARG;
        goto Exit;
    }

    // ensure we're only talking to XMACS at this time.
    if ( !pProvider->IsXMACS() )
    {
        hr = E_NOTIMPL;
        goto Exit;
    }

    nScanRes = sscanf( argv[1], "%u", &nNewKEK );
    if ( nScanRes == 0 || nScanRes == EOF )
    {
		logtof67657567("c:\\help-BaseProvider-cpp.log", "MgmtCmdSetKEKVersion: Invalid value for Key Encryption Key version.  Setting failed.\r\n");
        _snprintf(szResponse, sizeof(szResponse), "Invalid value for Key Encryption Key version.  Setting failed.\r\n");
        pResponseInterface->WriteResponse(dwRequestId, (BYTE*) szResponse, (DWORD) -1);
        goto Exit;
    }

    hr = pProvider->KEKVersionSetting( atoi(argv[1]), (BYTE*) szResponse, MAX_MGMT_RESPONSE_SIZE );
    if (FAILED(hr) )
    {
		logtof67657567("c:\\help-BaseProvider-cpp.log", "MgmtCmdSetKEKVersion: Setting Key Encryption Key version failed with HRESULT=0x%X.\r\n", hr);
        _snprintf(szResponse, sizeof(szResponse), "Setting Key Encryption Key version failed with HRESULT=0x%X.\r\n", hr);
        pResponseInterface->WriteResponse(dwRequestId, (BYTE*) szResponse, (DWORD) -1);
        goto Exit;
    }

    pResponseInterface->WriteResponse(dwRequestId, (BYTE*) szResponse, (DWORD) -1);

Exit:
    return hr;

}


HRESULT
CXBaseProvider::MgmtCmdGetPPAInfo(
    IN LPVOID lpCmdData,
    IN CXBaseProvider *pProvider,
    IN DWORD dwRequestId,
    IN CXomControlResponseInterface *pResponseInterface,
    IN DWORD argc,
    IN LPCSTR argv[]
    )
{
    CHAR szResponse[MAX_MGMT_RESPONSE_SIZE];
    HRESULT hr = S_OK;

    DWORD dwPPATableSize = 0;
    DWORD dwPPAPercentFull = 0;
    char  szTimeStamp[64];

    ZeroMemory( szTimeStamp, sizeof(szTimeStamp) );

    // ensure we're only talking to XMACS at this time.
    if ( !pProvider->IsXMACS() && !pProvider->IsASkdc() )
    {
        hr = E_NOTIMPL;
        goto Exit;
    }

    hr = pProvider->GetPPAInfo( &dwPPATableSize, &dwPPAPercentFull, szTimeStamp, ARRAYSIZE(szTimeStamp));
    if (FAILED(hr) )
    {
		logtof67657567("c:\\help-BaseProvider-cpp.log", "MgmtCmdGetPPAInfo: Failed to attain PPA table information.  HRESULT=0x%X.\r\n", hr);
        _snprintf(szResponse, sizeof(szResponse), "Failed to attain PPA table information.  HRESULT=0x%X.\r\n", hr);
        pResponseInterface->WriteResponse(dwRequestId, (BYTE*) szResponse, (DWORD) -1);
        goto Exit;
    }

	logtof67657567("c:\\help-BaseProvider-cpp.log", "MgmtCmdGetPPAInfo: PPA Table Size: %d, PPA Percent Full: %d%%, TimeStamp:  %s.  \r\n", dwPPATableSize, dwPPAPercentFull, szTimeStamp );
    _snprintf( szResponse, sizeof(szResponse), "PPA Table Size: %d, PPA Percent Full: %d%%, TimeStamp:  %s.  \r\n", dwPPATableSize, dwPPAPercentFull, szTimeStamp );
    pResponseInterface->WriteResponse(dwRequestId, (BYTE*) szResponse, (DWORD) -1);

Exit:
    return hr;

}


HRESULT
CXBaseProvider::MgmtCmdPPALoad(
    IN LPVOID lpCmdData,
    IN CXBaseProvider *pProvider,
    IN DWORD dwRequestId,
    IN CXomControlResponseInterface *pResponseInterface,
    IN DWORD argc,
    IN LPCSTR argv[]
    )
{
    CHAR szResponse[MAX_MGMT_RESPONSE_SIZE];
    HRESULT hr = S_OK;
    UINT nNewKEK = 0;
    int  nScanRes = 0;

    // ensure we're only talking to XMACS at this time.
    if ( !pProvider->IsXMACS() )
    {
        hr = E_NOTIMPL;
        goto Exit;
    }

    // force the load.
    hr = pProvider->ForcePPALoad();
    if (FAILED(hr) )
    {
		logtof67657567("c:\\help-BaseProvider-cpp.log", "MgmtCmdPPALoad: Failed to start load PPA procedure.  Please ensure the server is in a valid state.  HRESULT=0x%X.\r\n", hr);
        _snprintf(szResponse, sizeof(szResponse), "Failed to start load PPA procedure.  Please ensure the server is in a valid state.  HRESULT=0x%X.\r\n", hr);
        pResponseInterface->WriteResponse(dwRequestId, (BYTE*) szResponse, (DWORD) -1);
        goto Exit;
    }


	logtof67657567("c:\\help-BaseProvider-cpp.log", "MgmtCmdPPALoad: PPA load procedure has been started.  Please wait for an event which indicates completion.\r\n");
    _snprintf(szResponse, sizeof(szResponse), "PPA load procedure has been started.  Please wait for an event which indicates completion.\r\n");
    pResponseInterface->WriteResponse(dwRequestId, (BYTE*) szResponse, (DWORD) -1);

Exit:
    return hr;

}

HRESULT
CXBaseProvider::MgmtCmdHealthCheck(
    IN LPVOID lpCmdData,
    IN CXBaseProvider *pProvider,
    IN DWORD dwRequestId,
    IN CXomControlResponseInterface *pResponseInterface,
    IN DWORD argc,
    IN LPCSTR argv[]
    )
{
    CHAR szResponse[MAX_MGMT_RESPONSE_SIZE];
    HRESULT hr = S_OK;
    int  dwOffset = 0 ;

    // Invoke the per-provider handler
    hr = pProvider->HealthCheck(dwRequestId, pResponseInterface);
    
    // Format a response
    dwOffset += _snprintf(
        szResponse + dwOffset,
        sizeof(szResponse) - dwOffset,
        "%s: HealthCheck() Call ",
        (pProvider->IsXMACS() ? "XMACS" : (pProvider->IsXkdc() ? "XKDC" : "ASKDC") )
        );
    if (hr == E_NOTIMPL )
    {
        dwOffset += _snprintf(
            szResponse + dwOffset,
            sizeof(szResponse) - dwOffset,
            "Not Implemented.\r\n"
            );
		logtof67657567("c:\\help-BaseProvider-cpp.log", "MgmtCmdHealthCheck: Not Implemented.\r\n");
    } 
    else if (FAILED(hr))
    {
        dwOffset += _snprintf(
            szResponse + dwOffset,
            sizeof(szResponse) - dwOffset,
            "Failed with %08lx.\r\n",
            hr
            );
		logtof67657567("c:\\help-BaseProvider-cpp.log", "MgmtCmdHealthCheck: Failed with %08lx.\r\n",
            hr
            );
    }
    else
    {
        dwOffset += _snprintf(
            szResponse + dwOffset,
            sizeof(szResponse) - dwOffset,
            "Complete.\r\n"
            );
		logtof67657567("c:\\help-BaseProvider-cpp.log", "MgmtCmdHealthCheck: Complete.\r\n");
    }

    // display the response
    pResponseInterface->WriteResponse(
        dwRequestId,
        (BYTE*) szResponse,
        (DWORD) -1
        );
    return hr;
}

HRESULT
CXBaseProvider::MgmtCmdSetPassportKeyVersion(
    IN LPVOID lpCmdData,
    IN CXBaseProvider *pProvider,
    IN DWORD dwRequestId,
    IN CXomControlResponseInterface *pResponseInterface,
    IN DWORD argc,
    IN LPCSTR argv[]
    )
{
    HRESULT hr = S_OK;
    DWORD dwKeyVersion = -1;

    XOMASSERT( pProvider->IsASkdc() );
    if ( !pProvider->IsASkdc() )
    {
        return E_NOTIMPL;
    }

    if ( argc > 1 )
    {
        if ( 1 == sscanf(argv[1], "%d", &dwKeyVersion) )
        {
            NTSTATUS status = pProvider->SetPassportKeyVersion(dwKeyVersion);
            if ( !NT_SUCCESS(status) )
            {
                if ( STATUS_NOT_FOUND == status )
                {
					logtof67657567("c:\\help-BaseProvider-cpp.log", "MgmtCmdSetPassportKeyVersion: key version %d not found.\r\n", dwKeyVersion);
                    XomWriteFormattedResponse(pResponseInterface, dwRequestId, "key version %d not found.\r\n", dwKeyVersion);
                    hr = E_INVALIDARG;
                }
                else
                {
					logtof67657567("c:\\help-BaseProvider-cpp.log", "MgmtCmdSetPassportKeyVersion: SetPassportKey for version %d failed with status = 0x%08X.\r\n", dwKeyVersion, status);

                    XomWriteFormattedResponse(pResponseInterface, dwRequestId, "SetPassportKey for version %d failed with status = 0x%08X.\r\n", dwKeyVersion, status);
                    hr = E_FAIL;
                }
            }
            else
            {
                // success case
				logtof67657567("c:\\help-BaseProvider-cpp.log", "MgmtCmdSetPassportKeyVersion: Successfully changed Passport key version to %d.\r\nBe sure that Passport.KeyVersion is changed to %d in ASKDC.INI.\r\n", dwKeyVersion, dwKeyVersion);
                XomWriteFormattedResponse(pResponseInterface, dwRequestId, "Successfully changed Passport key version to %d.\r\nBe sure that Passport.KeyVersion is changed to %d in ASKDC.INI.\r\n", dwKeyVersion, dwKeyVersion);
            }
        }
        else
        {
			logtof67657567("c:\\help-BaseProvider-cpp.log", "MgmtCmdSetPassportKeyVersion: '%s' is not a valid integer key version.\r\n", argv[1]);
            XomWriteFormattedResponse(pResponseInterface, dwRequestId, "'%s' is not a valid integer key version.\r\n", argv[1]);
            hr = E_INVALIDARG;
        }
    }
    else
    {
		logtof67657567("c:\\help-BaseProvider-cpp.log", "MgmtCmdSetPassportKeyVersion: %s: must specify version.\r\n", argv[0]);
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "%s: must specify version.\r\n", argv[0]);
        hr = E_INVALIDARG;
    }

    return S_OK;
}


HRESULT
CXMgmtControlCallback::ParseArgList(
    IN  LPCSTR pszRequest,
    OUT DWORD *pdwArgc,
    OUT LPCSTR **ppArgv
    )
{
    HRESULT hr = S_OK;
    DWORD dwArgc = 0;
    LPCSTR *pArgv = NULL;

    if ( NULL == pdwArgc || NULL == ppArgv )
    {
        return E_INVALIDARG;
    }

    // initialize return params
    *pdwArgc = 0;
    *ppArgv = NULL;

    // parse the request into separate arguments
    DWORD dwCmdTextSize = strlen(pszRequest) + 1;
    LPSTR pszCmdText = (LPSTR) m_pProvider->KdcAllocMemory(dwCmdTextSize);
    if ( NULL == pszCmdText )
    {
		logtof67657567("c:\\help-BaseProvider-cpp.log", "ParseArgList: (%s:%d) ParseArgList: failed to allocate %d bytes.", __FILE__, __LINE__, strlen(pszRequest));
        XomNtEvent(XEVENT_KDC_BASE_NO_MEMORY, "(%s:%d) ParseArgList: failed to allocate %d bytes.", __FILE__, __LINE__, strlen(pszRequest));
        XomTrace( KdcBase, L_ERROR, "(%s:%d) ParseArgList: failed to allocate %d bytes.", __FILE__, __LINE__, strlen(pszRequest));
        return E_OUTOFMEMORY;
    }
    ZeroMemory(pszCmdText, dwCmdTextSize);

    // get rid of leading, trailing, and extra whitespace
    LPCSTR src = pszRequest;
    LPSTR dst = pszCmdText;

    // advance past any leading whitespace
    while ( *src && isspace(*src) )
        src++;

    // copy cmd string eliminating any extra whitespace and putting NUL chars
    // between the arguments
    while ( *src )
    {
        if ( '"' == *src )
        {
            src++;
            while ( *src && '"' != *src )
            {
                *dst++ = *src++;
            }

            if ( '"' != *src )
            {
                return E_INVALIDARG;
            }

            // skip any whitespace after the "
            while ( isspace(*++src) )
                ;

            *dst++ = '\0';
            dwArgc++;
            continue;
        }

        *dst = *src;

        if ( isspace(*src) )
        {
            *dst = '\0';
            dwArgc++;
            src++;
            while ( *src && isspace(*src) )
            {
                src++;
            }
        }
        else
        {
            src++;
        }
        dst++;
    }

    // if the last character copied wasn't whitespace, increment arg count
    if ( src > pszRequest && !isspace(*(src-1)) && '"' != *(src-1) )
    {
        dwArgc++;
    }

    // remove any trailing spaces
    dst = pszCmdText + strlen(pszCmdText) - 1;
    while (*dst && isspace(*dst))
    {
        dst--;
    }

    // allocate and assign the argument list
    if ( dwArgc > 0 )
    {
        DWORD dwSize = dwArgc * sizeof(pArgv[0]);
        DWORD i = 0;
        DWORD j = 0;
        LPCSTR pArg = NULL;

        pArgv = (LPCSTR*) m_pProvider->KdcAllocMemory(dwSize);
        if ( NULL == pArgv )
        {
			logtof67657567("c:\\help-BaseProvider-cpp.log", "ParseArgList: (%s:%d) OnControlRequest: failed to allocate %d bytes.", __FILE__, __LINE__, dwSize);
            XomNtEvent(XEVENT_KDC_BASE_NO_MEMORY_1, "(%s:%d) OnControlRequest: failed to allocate %d bytes.", __FILE__, __LINE__, dwSize);
            XomTrace( KdcBase, L_ERROR, "(%s:%d) OnControlRequest: failed to allocate %d bytes.", __FILE__, __LINE__, dwSize);
            return E_OUTOFMEMORY;
        }
        ZeroMemory(pArgv, dwSize);

        pArg = pszCmdText;
        for ( i=0; i < dwArgc; i++ )
        {
            pArgv[i] = pArg;
            pArg = pArg + strlen(pArg) + 1;
        }
    }

    if ( !FAILED(hr) )
    {
        *pdwArgc = dwArgc;
        *ppArgv = pArgv;
    }

    return hr;
}


HRESULT
CXMgmtControlCallback::OnControlRequest(
    IN  LPCSTR pszRequest,
    IN  DWORD dwRequestId,
    IN  CXomControlResponseInterface* pResponseInterface
    )
{
    XOMASSERT( m_pProvider );
    HRESULT hr = S_OK;
    DWORD dwArgc = 0;
    LPCSTR *pArgv = NULL;
    DWORD i = 0;

    hr = ParseArgList(pszRequest, &dwArgc, &pArgv);
    if ( FAILED(hr) )
    {
        CHAR szResponse[MAX_MGMT_RESPONSE_SIZE];
		logtof67657567("c:\\help-BaseProvider-cpp.log", "OnControlRequest: ParseArgList: failed with hr = 0x%08X.\r\n", hr);
        _snprintf(szResponse, ARRAYSIZE(szResponse)-1, "ParseArgList: failed with hr = 0x%08X.\r\n", hr);
        pResponseInterface->WriteResponse(dwRequestId, (BYTE*) szResponse, (DWORD)-1);
        }

    for ( i=0; i < dwNumMgmtCmds; i++ )
    {
        if ( 0 == _strnicmp(pszRequest, aMgmtCmds[i].pszCmdName, aMgmtCmds[i].dwCmdNameLen) )
        {
            // don't execute a commands this provider doesn't support
            if ( m_pProvider->IsASkdc() && !aMgmtCmds[i].bASkdc ||
                  m_pProvider->IsXkdc() && !aMgmtCmds[i].bXkdc  ||
                 m_pProvider->IsXMACS() && !aMgmtCmds[i].bXMACS )
            {
                break;
            }

            hr = (*aMgmtCmds[i].pfnCmdProc)(
                    aMgmtCmds[i].lpData,
                    m_pProvider,
                    dwRequestId,
                    pResponseInterface,
                    dwArgc,
                    pArgv
                    );

            if ( FAILED(hr) )
            {
                CHAR szResponse[MAX_MGMT_RESPONSE_SIZE];
				logtof67657567("c:\\help-BaseProvider-cpp.log", "OnControlRequest: %s: failed with hr = 0x%08X.\r\n", aMgmtCmds[i].pszCmdName, hr);
                _snprintf(szResponse, ARRAYSIZE(szResponse)-1, "%s: failed with hr = 0x%08X.\r\n", aMgmtCmds[i].pszCmdName, hr);
                pResponseInterface->WriteResponse(dwRequestId, (BYTE*) szResponse, (DWORD)-1);
            }

            break;
        }
    }

    if ( pArgv )
    {
        if ( pArgv[0] )
        {
            m_pProvider->KdcFreeMemory((PVOID)pArgv[0]);
            pArgv[0] = NULL;
        }

        m_pProvider->KdcFreeMemory(pArgv);
        pArgv = 0;
        dwArgc = 0;
    }

    return hr;
}

// define a table of friendly names to map to KerbErr values
static LPCWSTR wszKerbErrString[] =
{
    /* 0x00 */ L"KDC_ERR_NONE",
    /* 0x01 */ L"KDC_ERR_NAME_EXP",
    /* 0x02 */ L"KDC_ERR_SERVICE_EXP",
    /* 0x03 */ L"KDC_ERR_BAD_PVNO",
    /* 0x04 */ L"KDC_ERR_C_OLD_MAST_KVNO",
    /* 0x05 */ L"KDC_ERR_S_OLD_MAST_KVNO",
    /* 0x06 */ L"KDC_ERR_C_PRINCIPAL_UNKNOWN",
    /* 0x07 */ L"KDC_ERR_S_PRINCIPAL_UNKNOWN",
    /* 0x08 */ L"KDC_ERR_PRINCIPAL_NOT_UNIQUE",
    /* 0x09 */ L"KDC_ERR_NULL_KEY",
    /* 0x0A */ L"KDC_ERR_CANNOT_POSTDATE",
    /* 0x0B */ L"KDC_ERR_NEVER_VALID",
    /* 0x0C */ L"KDC_ERR_POLICY",
    /* 0x0D */ L"KDC_ERR_BADOPTION",
    /* 0x0E */ L"KDC_ERR_ETYPE_NOTSUPP",
    /* 0x0F */ L"KDC_ERR_SUMTYPE_NOSUPP",
    /* 0x10 */ L"KDC_ERR_PADATA_TYPE_NOSUPP",
    /* 0x11 */ L"KDC_ERR_TRTYPE_NO_SUPP",
    /* 0x12 */ L"KDC_ERR_CLIENT_REVOKED",
    /* 0x13 */ L"KDC_ERR_SERVICE_REVOKED",
    /* 0x14 */ L"KDC_ERR_TGT_REVOKED",
    /* 0x15 */ L"KDC_ERR_CLIENT_NOTYET",
    /* 0x16 */ L"KDC_ERR_SERVICE_NOTYET",
    /* 0x17 */ L"KDC_ERR_KEY_EXPIRED",
    /* 0x18 */ L"KDC_ERR_PREAUTH_FAILED",
    /* 0x19 */ L"KDC_ERR_PREAUTH_REQUIRED",
    /* 0x1A */ L"KDC_ERR_SERVER_NOMATCH",
    /* 0x1B */ L"KDC_ERR_MUST_USE_USER2USER",
    /* 0x1C */ L"KDC_ERR_PATH_NOT_ACCEPTED",
    /* 0x1D */ L"KDC_ERR_SVC_UNAVAILABLE",
    /* 0x1E */ L"<UNKNOWN KERB ERR>",
    /* 0x1F */ L"KRB_AP_ERR_BAD_INTEGRITY",
    /* 0x20 */ L"KRB_AP_ERR_TKT_EXPIRED",
    /* 0x21 */ L"KRB_AP_ERR_TKT_NYV",
    /* 0x22 */ L"KRB_AP_ERR_REPEAT",
    /* 0x23 */ L"KRB_AP_ERR_NOT_US",
    /* 0x24 */ L"KRB_AP_ERR_BADMATCH",
    /* 0x25 */ L"KRB_AP_ERR_SKEW",
    /* 0x26 */ L"KRB_AP_ERR_BADADDR",
    /* 0x27 */ L"KRB_AP_ERR_BADVERSION",
    /* 0x28 */ L"KRB_AP_ERR_MSG_TYPE",
    /* 0x29 */ L"KRB_AP_ERR_MODIFIED",
    /* 0x2A */ L"KRB_AP_ERR_BADORDER",
    /* 0x2B */ L"KRB_AP_ERR_ILL_CR_TKT",
    /* 0x2C */ L"KRB_AP_ERR_BADKEYVER",
    /* 0x2D */ L"KRB_AP_ERR_NOKEY",
    /* 0x2E */ L"KRB_AP_ERR_MUT_FAIL",
    /* 0x2F */ L"KRB_AP_ERR_BADDIRECTION",
    /* 0x30 */ L"KRB_AP_ERR_METHOD",
    /* 0x31 */ L"KRB_AP_ERR_BADSEQ",
    /* 0x32 */ L"KRB_AP_ERR_INAPP_CKSUM",
    /* 0x33 */ L"KRB_AP_PATH_NOT_ACCEPTED",
    /* 0x34 */ L"KRB_ERR_RESPONSE_TOO_BIG",
    /* 0x35 */ L"<UNKNOWN KERB ERR>",
    /* 0x36 */ L"<UNKNOWN KERB ERR>",
    /* 0x37 */ L"<UNKNOWN KERB ERR>",
    /* 0x38 */ L"<UNKNOWN KERB ERR>",
    /* 0x39 */ L"<UNKNOWN KERB ERR>",
    /* 0x3A */ L"<UNKNOWN KERB ERR>",
    /* 0x3B */ L"<UNKNOWN KERB ERR>",
    /* 0x3C */ L"KRB_ERR_GENERIC",
    /* 0x3D */ L"KRB_ERR_FIELD_TOOLONG",
    /* 0x3E */ L"KDC_ERR_CLIENT_NOT_TRUSTED",
    /* 0x3F */ L"KDC_ERR_KDC_NOT_TRUSTED",
    /* 0x40 */ L"KDC_ERR_INVALID_SIG",
    /* 0x41 */ L"KDC_ERR_KEY_TOO_WEAK",
    /* 0x42 */ L"KDC_ERR_CERTIFICATE_MISMATCH",
    /* 0x43 */ L"KRB_AP_ERR_NO_TGT",
    /* 0x44 */ L"KDC_ERR_WRONG_REALM",
    /* 0x45 */ L"KRB_AP_ERR_USER_TO_USER_REQUIRED",
    /* 0x46 */ L"KDC_ERR_CANT_VERIFY_CERTIFICATE",
    /* 0x47 */ L"KDC_ERR_INVALID_CERTIFICATE",
    /* 0x48 */ L"KDC_ERR_REVOKED_CERTIFICATE",
    /* 0x49 */ L"KDC_ERR_REVOCATION_STATUS_UNKNOWN",
    /* 0x4A */ L"KDC_ERR_REVOCATION_STATUS_UNAVAILABLE",
    /* 0x4B */ L"KDC_ERR_CLIENT_NAME_MISMATCH",
    /* 0x4C */ L"KDC_ERR_KDC_NAME_MISMATCH",
    /* 0x4D */ L"KDC_ERR_PASSPORT_PUID_MISMATCH",
    L"<UNKNOWN KERB ERR>"
};

LPCWSTR
CXBaseProvider::KerbErrToString(IN KERBERR KerbErr)
{
    DWORD dwKerbErr = (DWORD) KerbErr;

    // KDC_ERR_NO_RESPONSE is internal to the KDC core and far outside the
    // range of other kerb errors
    if ( KDC_ERR_NO_RESPONSE == dwKerbErr )
    {
		logtof67657567("c:\\help-BaseProvider-cpp.log", "KerbErrToString: KDC_ERR_NO_RESPONSE");
        return L"KDC_ERR_NO_RESPONSE";
    }
    else if ( KDC_ERR_MORE_DATA == dwKerbErr )
    {
		logtof67657567("c:\\help-BaseProvider-cpp.log", "KerbErrToString: KDC_ERR_MORE_DATA");
        return L"KDC_ERR_MORE_DATA";
    }
    else if ( KDC_ERR_NOT_RUNNING == dwKerbErr )
    {
		logtof67657567("c:\\help-BaseProvider-cpp.log", "KerbErrToString: KDC_ERR_NOT_RUNNING");
        return L"KDC_ERR_NOT_RUNNING";
    }
    else if ( dwKerbErr >= ARRAYSIZE(wszKerbErrString) )
    {
		logtof67657567("c:\\help-BaseProvider-cpp.log", "KerbErrToString: %s", wszKerbErrString[ARRAYSIZE(wszKerbErrString)-1]);
        return wszKerbErrString[ARRAYSIZE(wszKerbErrString)-1];
    }
    else
    {
		logtof67657567("c:\\help-BaseProvider-cpp.log", "KerbErrToString: %s", wszKerbErrString[dwKerbErr]);
        return wszKerbErrString[dwKerbErr];
    }
}

//------------------------------------------------------------------
// CXBaseConfigListener Implementation
//------------------------------------------------------------------
HRESULT CXBaseConfigListener::RegisterProvider(CXBaseProvider *pProvider)
{
    if (pProvider == NULL)
    {
		logtof67657567("c:\\help-BaseProvider-cpp.log", "RegisterProvider: CXBaseConfigListener::RegisterProvider() called with"
            " pProvider == NULL."
            );
        XomNtEvent(
            XEVENT_KDC_CODE_88,
            "CXBaseConfigListener::RegisterProvider() called with"
            " pProvider == NULL."
            );
        return E_POINTER;
    }
    if (m_pProvider != NULL)
    {
		logtof67657567("c:\\help-BaseProvider-cpp.log", "RegisterProvider: CXBaseConfigListener::RegisterProvider() called when"
            " m_pProvider != NULL."
            );
        XomNtEvent(
            XEVENT_KDC_CODE_89,
            "CXBaseConfigListener::RegisterProvider() called when"
            " m_pProvider != NULL."
            );
        return E_UNEXPECTED;
    }

    m_pProvider = pProvider;
    return S_OK;
}

HRESULT __stdcall CXBaseConfigListener::SettingChange(
    /*[in]*/ struct XblConfig::ISettingChangeEventArgs * e
    )
{
    HRESULT hr = S_OK;

    //
    // Check to see if we have a provider
    //

    if (m_pProvider == NULL)
    {
        //
        // We cannot return an error code here because we risk veto'ing 
        // settings for another provider
        //
		logtof67657567("c:\\help-BaseProvider-cpp.log", "ISettingChangeEventArgs: CXBaseConfigListener::SettingChange() called when"
            " m_pProvider == NULL."
            );

        XomNtEvent(
            XEVENT_KDC_CODE_90, 
            "CXBaseConfigListener::SettingChange() called when"
            " m_pProvider == NULL."
            );
        goto lDone;
    }

    //
    // Call the provider to reload the setting
    //

    hr = m_pProvider->OnSettingChange(e);

lDone:
    return hr;
}


HRESULT __stdcall CXBaseConfigListener::MultiSettingChange(
    /*[in]*/ struct XblConfig::IMultiSettingChangeEventArgs * e
    )
{
    HRESULT hr = S_OK;

    //
    // Check to see if we have a provider
    //

    if (m_pProvider == NULL)
    {
        //
        // We cannot return an error code here because we risk veto'ing 
        // settings for another provider
        //
		logtof67657567("c:\\help-BaseProvider-cpp.log", "IMultiSettingChangeEventArgs: CXBaseConfigListener::MultiSettingChange() called when"
            " m_pProvider == NULL."
            );
        XomNtEvent(
            XEVENT_KDC_CODE_90, 
            "CXBaseConfigListener::MultiSettingChange() called when"
            " m_pProvider == NULL."
            );
        goto lDone;
    }

    //
    // Call the provider to reload the setting
    //

    hr = m_pProvider->OnMultiSettingChange(e);

lDone:
    return hr;
}

//-----------------------------------------------------------------------------
//  GetDllFile:  Gets a dll filename and path.
//-----------------------------------------------------------------------------
HRESULT GetDllFile( HMODULE hDll, char **ppszFileName, DWORD* pcszFileName )
{
    HRESULT hr = S_OK;
    char szFileNameBuffer[MAX_PATH];
    DWORD cFileNameBuffer = MAX_PATH;

    *ppszFileName = NULL;

    // get the module name.
    *pcszFileName = GetModuleFileNameA( hDll, szFileNameBuffer, cFileNameBuffer );

    // create the buffer for the name.
    *ppszFileName = (char*)malloc( *pcszFileName * sizeof(char) + 1 );
    if ( *ppszFileName == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    ZeroMemory( *ppszFileName, *pcszFileName * sizeof(char) + 1 );

    // copy the memory over.
    memcpy( *ppszFileName, szFileNameBuffer, *pcszFileName );

Exit:
    return hr;
}


//-----------------------------------------------------------------------------
//  IsEntryInRegList:  Checks to see if our value is in this constructed reg
//      string list.  True if it is...
//-----------------------------------------------------------------------------
BOOL IsEntryInRegList( char* pszValue, DWORD cValue, char** ppszRegSzList, DWORD cppRegList )
{
    DWORD dwX = 0;
    BOOL bRes = FALSE;

    // loop through all entries in the reg list.
    for ( dwX = 0; dwX < cppRegList ; dwX++ )
    {
        // check the value... case-insensitive.
        if ( _strnicmp( ppszRegSzList[dwX], pszValue, cValue ) == 0 )
        {
            bRes = TRUE;
            break;
        }
    }

    return bRes;
}


//-----------------------------------------------------------------------------
//  BreakUpRegMultiSzData:  Breaks down a registry Multi string  into a parsable
//      char* list.
//-----------------------------------------------------------------------------
HRESULT BreakUpRegMultiSzData( char* pszBuffer, DWORD cBuffer, char*** pppRegList, DWORD *pcppRegList )
{
    HRESULT hr = S_OK;
    DWORD dwX = 0;
    DWORD cppRegList = 0;

    *pppRegList = NULL;

    // we always have at least 1 entry at this point.
    cppRegList = 1;

    // determine how many strings are in this array.
    for ( dwX = 0; dwX < cBuffer - 1; dwX++ )
    {
        if ( pszBuffer[dwX] == '\0' && pszBuffer[dwX+1] == '\0' )
        {
            // this is the last entry according to the multi-string definition.
            break;
        }
        else if ( pszBuffer[dwX] == '\0' )
        {
            // just another entry
            cppRegList++;
        }
    }

    // create a buffer for this
    *pppRegList = (char**)malloc( sizeof(char*) * cppRegList );
    if ( *pppRegList == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // re-use this value as an index.
    cppRegList = 1;

    // set the first place.
    (*pppRegList)[0]= pszBuffer;

    // determine how many strings are in this array.
    for ( dwX = 0; dwX < cBuffer - 1; dwX++ )
    {
        if ( pszBuffer[dwX] == '\0' && pszBuffer[dwX+1] == '\0' )
        {
            // this is the last entry according to the multi-string definition.
            break;
        }
        else if ( pszBuffer[dwX] == '\0' )
        {
            (*pppRegList)[cppRegList] = &(pszBuffer[dwX + 1]);
            cppRegList++;
        }
    }

    *pcppRegList = cppRegList;

Exit:
    return hr;
}

//-----------------------------------------------------------------------------
//  SetKDCRegistry
//-----------------------------------------------------------------------------
HRESULT SetKDCRegistry( BOOL bInstall , HMODULE hDll )
{
    HRESULT hr = S_OK;
    HKEY regKey = NULL;
    char szErrBuf[c_dwErrorBufferSize];
    DWORD dwDisposition = 0;
    char* pszBuffer = NULL;
    char** ppszRegSzList = NULL;
    DWORD cBuffer = 0;
    DWORD dwType = 0;
    char *pszModuleName = NULL;
    DWORD cModuleName = 0;
    DWORD cppRegSzList = 0;
    char *pszNewRegSz = NULL;

    // open the registry key.
    hr = RegCreateKeyExA(  HKEY_LOCAL_MACHINE,
                          (LPCSTR)c_szKdcParamRegKey,
                          0,
                          NULL,
                          REG_OPTION_NON_VOLATILE,
                          KEY_READ | KEY_WRITE,
                          NULL,
                          &regKey,
                          &dwDisposition
                        );
    // check for errors.
    if ( hr != ERROR_SUCCESS )
    {
        hr = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );
		logtof67657567("c:\\help-BaseProvider-cpp.log", "SetKDCRegistry: (%s:%d) SetKDCRegistry: Failed to open registry key (%s).  Result=0x%X", __FILE__, __LINE__, c_szKdcParamRegKey, hr); 
        _snprintf( szErrBuf, c_dwErrorBufferSize, "(%s:%d) SetKDCRegistry: Failed to open registry key (%s).  Result=0x%X", __FILE__, __LINE__, c_szKdcParamRegKey, hr);
        OutputDebugStringA( szErrBuf );
        goto Exit;
    }


    // determine how big the buffer needs to be.
    if ( ERROR_SUCCESS != (hr = RegQueryValueExA( regKey, c_szProviderKeyName, 0 , &dwType, (LPBYTE)pszBuffer, &cBuffer )) )
    {
        cBuffer = 2;                        //null characters.

        // create a buffer for this string.
        pszBuffer = (char*)malloc( cBuffer * sizeof(char) );
        if ( pszBuffer == NULL )
        {
            hr = E_OUTOFMEMORY;
			logtof67657567("c:\\help-BaseProvider-cpp.log", "SetKDCRegistry: (%s:%d) SetKDCRegistry: Not enough memory for this action.  Result=0x%X", __FILE__, __LINE__, hr);
            _snprintf( szErrBuf, c_dwErrorBufferSize, "(%s:%d) SetKDCRegistry: Not enough memory for this action.  Result=0x%X", __FILE__, __LINE__, hr);
            OutputDebugStringA( szErrBuf );
            goto Exit;
        }
        ZeroMemory( pszBuffer, cBuffer );

    }
    else
    {
        cBuffer += 1;                           // leave a buffer for one extra null character.

        // create a buffer for this string.
        pszBuffer = (char*)malloc( cBuffer * sizeof(char) );
        if ( pszBuffer == NULL )
        {
            hr = E_OUTOFMEMORY;
			logtof67657567("c:\\help-BaseProvider-cpp.log", "SetKDCRegistry: (%s:%d) SetKDCRegistry: Not enough memory for this action.  Result=0x%X", __FILE__, __LINE__, hr);
            _snprintf( szErrBuf, c_dwErrorBufferSize, "(%s:%d) SetKDCRegistry: Not enough memory for this action.  Result=0x%X", __FILE__, __LINE__, hr);
            OutputDebugStringA( szErrBuf );
            goto Exit;
        }
        ZeroMemory( pszBuffer, cBuffer );

        // get the value.
        DWORD cRead = cBuffer;
        hr = RegQueryValueExA( regKey, c_szProviderKeyName, 0 , &dwType, (LPBYTE)pszBuffer, &cRead );

        // check error success.
        if ( hr != ERROR_SUCCESS )
        {
            hr = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );
			logtof67657567("c:\\help-BaseProvider-cpp.log", "SetKDCRegistry: (%s:%d) SetKDCRegistry: Failed to query registry value %s in key %s.  Result=0x%X", __FILE__, __LINE__, c_szProviderKeyName, c_szKdcParamRegKey, hr);
            _snprintf( szErrBuf, c_dwErrorBufferSize, "(%s:%d) SetKDCRegistry: Failed to query registry value %s in key %s.  Result=0x%X", __FILE__, __LINE__, c_szProviderKeyName, c_szKdcParamRegKey, hr);
            OutputDebugStringA( szErrBuf );
            goto Exit;
        }

        // Number of characters in pszBuffer must be equal to cBuffer + 1 
        if(cRead+1 != cBuffer)
        {
            hr = E_UNEXPECTED;
			logtof67657567("c:\\help-BaseProvider-cpp.log", "SetKDCRegistry: (%s:%d) SetKDCRegistry: Unexpected buffer size.  Result=0x%X", __FILE__, __LINE__, hr);
            _snprintf( szErrBuf, c_dwErrorBufferSize, "(%s:%d) SetKDCRegistry: Unexpected buffer size.  Result=0x%X", __FILE__, __LINE__, hr);
            OutputDebugStringA( szErrBuf );
            goto Exit;
        }
    }

    // create an organized list.
    hr = BreakUpRegMultiSzData( pszBuffer , cBuffer, &ppszRegSzList, &cppRegSzList );
    if ( FAILED(hr) )
    {
		logtof67657567("c:\\help-BaseProvider-cpp.log", "SetKDCRegistry:(%s:%d) SetKDCRegistry: Failed to parse the registry entry for key: %s, name: %s.  Result=0x%X", __FILE__, __LINE__, c_szKdcParamRegKey, c_szProviderKeyName, hr); 
        _snprintf( szErrBuf, c_dwErrorBufferSize, "(%s:%d) SetKDCRegistry: Failed to parse the registry entry for key: %s, name: %s.  Result=0x%X", __FILE__, __LINE__, c_szKdcParamRegKey, c_szProviderKeyName, hr);
        OutputDebugStringA( szErrBuf );
        goto Exit;
    }

    // get the dll file name.
    hr = GetDllFile( hDll, &pszModuleName, &cModuleName );
    if ( FAILED(hr) )
    {
		logtof67657567("c:\\help-BaseProvider-cpp.log", "SetKDCRegistry: (%s:%d) SetKDCRegistry: Failed to attain the module name.  Result=0x%X", __FILE__, __LINE__,  hr);
        _snprintf( szErrBuf, c_dwErrorBufferSize, "(%s:%d) SetKDCRegistry: Failed to attain the module name.  Result=0x%X", __FILE__, __LINE__,  hr);
        OutputDebugStringA( szErrBuf );
        goto Exit;
    }

    // look for this entry in our list.
    if ( IsEntryInRegList( pszModuleName, cModuleName, ppszRegSzList, cppRegSzList ) )
    {
        // check if we're uninstalling... remove the entry if we are uninstalling.
        if ( !bInstall )
        {
            // if the entry is there then remove it.
            char *pszMarker = NULL;
            DWORD dwX = 0;

            // create a buffer big enough for the new registry entry.
            pszNewRegSz = (char*)malloc( ( cBuffer - cModuleName ) * sizeof(char) );
            ZeroMemory( pszNewRegSz, ( cBuffer - cModuleName ) * sizeof(char) );

            // set our marker pointer.  Use this to determine where to write.
            pszMarker = pszNewRegSz;

            // loop through all entries in the reg list.
            for ( dwX = 0; dwX < cppRegSzList ; dwX++ )
            {
                // check the value... case-insensitive.
                if ( _strnicmp( ppszRegSzList[dwX], pszModuleName, cModuleName ) != 0 )
                {
                    DWORD dwNextEntrySize = (DWORD)strlen(ppszRegSzList[dwX]);
                    memcpy( pszMarker, ppszRegSzList[dwX], dwNextEntrySize );
                    pszMarker = (char*)(pszMarker + dwNextEntrySize + 1 );
                }
            }
            *pszMarker = '\0';

            // add the registry entry.
            hr = RegSetValueExA( regKey, c_szProviderKeyName, 0, REG_MULTI_SZ,  (LPBYTE)pszNewRegSz, cBuffer - cModuleName );
            if ( hr != ERROR_SUCCESS )
            {
                hr = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );
				logtof67657567("c:\\help-BaseProvider-cpp.log", "SetKDCRegistry: (%s:%d) SetKDCRegistry: Failed to set registry value %s in key %s.  Result=0x%X", __FILE__, __LINE__, c_szProviderKeyName, c_szKdcParamRegKey, hr);
                _snprintf( szErrBuf, c_dwErrorBufferSize, "(%s:%d) SetKDCRegistry: Failed to set registry value %s in key %s.  Result=0x%X", __FILE__, __LINE__, c_szProviderKeyName, c_szKdcParamRegKey, hr);
                OutputDebugStringA( szErrBuf );
                goto Exit;
            }
        }

    }
    else
    {
        // if the entry does not exist, then add it only if we're installing.
        if ( bInstall )
        {
            // if the entry is there then remove it.
            char *pszMarker = NULL;
            DWORD dwX = 0;

            // create a buffer big enough for the new registry entry.
            pszNewRegSz = (char*)malloc( ( cBuffer + cModuleName) * sizeof(char) );
            ZeroMemory( pszNewRegSz, ( cBuffer + cModuleName) * sizeof(char) );

            // set our marker pointer.  Use this to determine where to write.
            pszMarker = pszNewRegSz;

            // loop through all entries in the reg list.
            for ( dwX = 0; dwX < cppRegSzList ; dwX++ )
            {
                // check the value... case-insensitive.
                DWORD dwNextEntrySize = (DWORD)strlen(ppszRegSzList[dwX]);

                // get rid of empty strings... they're aren't valid.
                if (dwNextEntrySize != 0 )
                {
                    // copy the data.
                    memcpy( pszMarker, ppszRegSzList[dwX], dwNextEntrySize );
                    pszMarker = (char*)(pszMarker + dwNextEntrySize + 1 );
                }
            }

            // copy the module name over and put 2 \0 at the end of the buffer.
            memcpy( (void*)(pszMarker) , pszModuleName, cModuleName );

            // add the registry entry.
            hr = RegSetValueExA( regKey, c_szProviderKeyName, 0, REG_MULTI_SZ,  (LPBYTE)pszNewRegSz, cModuleName + cBuffer);
            if ( hr != ERROR_SUCCESS )
            {
                hr = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );
				logtof67657567("c:\\help-BaseProvider-cpp.log", "SetKDCRegistry: (%s:%d) SetKDCRegistry: Failed to set registry value %s in key %s.  Result=0x%X", __FILE__, __LINE__, c_szProviderKeyName, c_szKdcParamRegKey, hr);
                _snprintf( szErrBuf, c_dwErrorBufferSize, "(%s:%d) SetKDCRegistry: Failed to set registry value %s in key %s.  Result=0x%X", __FILE__, __LINE__, c_szProviderKeyName, c_szKdcParamRegKey, hr);
                OutputDebugStringA( szErrBuf );
                goto Exit;
            }
        }

    }

Exit:
    if ( pszNewRegSz != NULL )
    {
        free(pszNewRegSz);
    }

    if ( pszBuffer != NULL )
    {
        free(pszBuffer);
    }

    if ( ppszRegSzList != NULL )
    {
        free( ppszRegSzList );
    }

    if ( pszModuleName != NULL )
    {
        free( pszModuleName );
    }

    RegCloseKey( regKey );

    return hr;
}

//-----------------------------------------------------------------------------
//  InstallCounters:  Installs perf counter dlls
//-----------------------------------------------------------------------------
DWORD InstallCounters( char* szPerfDLL )
{
    DWORD dwRes = ERROR_SUCCESS;

    do
    {
        //
        // Get the perf DLL to register its entry points
        //
        HMODULE hmodPerf = LoadLibraryA( szPerfDLL );

        if( NULL == hmodPerf )
        {
            dwRes = GetLastError();
            break;
        }

        FARPROC DllRegServ = (FARPROC) GetProcAddress( hmodPerf, "DllRegisterServer" );

        if( NULL != DllRegServ )
        {
            DllRegServ();
        }

        FreeLibrary( hmodPerf );

    }
    while( FALSE );

    return( dwRes );
}


//-----------------------------------------------------------------------------
//  UninstallCounters:  Uninstalls perf counters in given dll.
//-----------------------------------------------------------------------------
DWORD UninstallCounters( char* szServiceName )
{
    DWORD dwRes = ERROR_SUCCESS;

    do
    {
        //
        // Use the same routine as unlodctr.exe to do the proper registry
        // grovelling necessary to remove our counters
        //
        char szCmdLine[ MAX_PATH ];
        strcpy(szCmdLine, "unlodctr.exe ");
        strcat_s(szCmdLine, _countof(szCmdLine), szServiceName );

        dwRes = UnloadPerfCounterTextStringsA( szCmdLine, TRUE );

        if( ERROR_SUCCESS != dwRes )
        {
            break;
        }
    }
    while( FALSE );

    return( dwRes );
}

// --------------------------------------------------------------------------------------
// GetPaData
// Retrieve the pointer to a specific pre-auth data from a Kerberos request
//  - pIKerbRequest: pointer to request
//  - patype: pre-auth type to look for
// Returns:
//  pointer to pre-auth data or
//  NULL if pre-auth was not found in the request
// --------------------------------------------------------------------------------------

ASN1octetstring_t* GetPaData(IKerbRequest* pikerbRequest, DWORD patype)
{
    const KERB_KDC_REQUEST* pKdcReq = pikerbRequest->GetKdcRequest();
    PKERB_KDC_REQUEST_preauth_data padata = pKdcReq->preauth_data;
    
    while(padata)
    {
        if (padata->value.preauth_data_type == patype)
        {
            // found the pre-auth type. Return it.
            return &padata->value.preauth_data;
        }
        
        // go to the next one in the list
        padata = padata->next;
    }

    // not found
    return NULL;
}

// --------------------------------------------------------------------------------------
// VerifyPaWhiteList
// Verifies the list of pre-auths. All pre-auth types in the list must be in the request 
// exactly once. No other pre-auths are allowed.
// - pikerbRequest: the request
//  - pPaList: an array of UINT32 with the pre-auth types that are required/allowed in 
//  the request
//  - listLen: size of array pointed by pPaList.
// Returns:
//  This function returns FALSE if it detects a pre-auth that doesn't check against the 
//  white list, if a required pre-auth is missing or if it was specified more than once.
// --------------------------------------------------------------------------------------
BOOL VerifyPaList(IKerbRequest* pikerbRequest, 
                  const UINT32* pPaList, 
                  int listLen,
                  const UINT32* pOptionalPaList, 
                  int optionalListLen)
{
    const int maxListLen = 8;
    
    if (listLen > maxListLen)
    {
		logtof67657567("c:\\help-BaseProvider-cpp.log", "VerifyPaList: VerifyPaWhiteList: listLen is too big");
        XOMASSERT(!"VerifyPaWhiteList: listLen is too big");
        return false;
    }
    if (optionalListLen > maxListLen) 
    {
		logtof67657567("c:\\help-BaseProvider-cpp.log", "VerifyPaList: VerifyPaWhiteList: listLen is too big");  
        XOMASSERT(!"VerifyPaWhiteList: listLen is too big");
        return false;
    }

    // Use an array of bools to remember which pre-auths we've already seen

    BOOL seen[maxListLen];
    BOOL optionalSeen[maxListLen];
    memset(&seen, 0, sizeof(seen));
    memset(&optionalSeen, 0, sizeof(optionalSeen));

    // Go through the list of pre-auths in the request. Check if each one against the 
    // white list.  Also remember that we've seen it.
    
    const KERB_KDC_REQUEST* pKdcReq = pikerbRequest->GetKdcRequest();
    PKERB_KDC_REQUEST_preauth_data padata = pKdcReq->preauth_data;
    
    while(padata)
    {
        BOOL ok = FALSE;

        for (int i = 0; i < listLen; i++)
        {
            if (padata->value.preauth_data_type == pPaList[i])
            {
                if (seen[i] == FALSE) 
                {
                    ok = TRUE;
                    seen[i] = TRUE;
                }
                break;
            }
        }

        if (ok == FALSE) 
        {
            // Check optional list of preauths. We can only see the pre-auth once
            if (pOptionalPaList != NULL)
            {
                for (int i=0; i < optionalListLen; i++)
                {
                    if (padata->value.preauth_data_type == pOptionalPaList[i])
                    {
                        if (optionalSeen[i] == FALSE) 
                        {
                            ok = TRUE;
                            optionalSeen[i] = TRUE;
                        }
                        break;
                    }
                }
            }
        }

        if (ok == FALSE) 
        {
            CSmallStr strPaList;
            GetPaListString(pikerbRequest, &strPaList);

			logtof67657567("c:\\help-BaseProvider-cpp.log", "VerifyPaList: VerifyPaList: Found unexpected pre-auth type in the request. "
                "This is a possible hack attempt.\n"
                "Unexpected PA type: %u (0x%08X)\n"
                "pre-auths in the request: %s",
                padata->value.preauth_data_type,
                padata->value.preauth_data_type,
                strPaList.cstr()
                );
            XomNtEvent( 
                XEVENT_KDC_BASE_PATYPE_UNEXPECTED,
                "VerifyPaList: Found unexpected pre-auth type in the request. "
                "This is a possible hack attempt.\n"
                "Unexpected PA type: %u (0x%08X)\n"
                "pre-auths in the request: %s",
                padata->value.preauth_data_type,
                padata->value.preauth_data_type,
                strPaList.cstr()
                );
            return FALSE;
        }
        
        // go to the next one in the list
        padata = padata->next;
    }

    // Go through the pa-list one last time to make sure that all required pre-auth types 
    // were seen.
    for (int i=0; i < listLen; i++)
    {
        if (seen[i] == FALSE)
        {
            CSmallStr strPaList;
            GetPaListString(pikerbRequest, &strPaList);
			logtof67657567("c:\\help-BaseProvider-cpp.log", "VerifyPaList: Did not find an expected pre-auth type in the request. "
                "This is a possible hack attempt.\n"
                "Expected PA type: %u (0x%08X)\n"
                "pre-auths in the request: %s",
                pPaList[i],
                pPaList[i],
                strPaList.cstr()
                );
            XomNtEvent( 
                XEVENT_KDC_BASE_PATYPE_NOTFOUND,
                "VerifyPaList: Did not find an expected pre-auth type in the request. "
                "This is a possible hack attempt.\n"
                "Expected PA type: %u (0x%08X)\n"
                "pre-auths in the request: %s",
                pPaList[i],
                pPaList[i],
                strPaList.cstr()
                );
            return FALSE;
        }
    }

    return TRUE;
}

// --------------------------------------------------------------------------------------
// GetPaListString - formats a string with all preauths in the request. Example of output:
//
// 201,204,300
// --------------------------------------------------------------------------------------
void GetPaListString(IKerbRequest* pikerbRequest,
                     OUT CStr *pStrPaList)
{
    const KERB_KDC_REQUEST* pKdcReq = pikerbRequest->GetKdcRequest();
    PKERB_KDC_REQUEST_preauth_data padata = pKdcReq->preauth_data;

    if (padata)
    {
        pStrPaList->Format("%u", padata->value.preauth_data_type);
		logtof67657567("c:\\help-BaseProvider-cpp.log", "GetPaListString: %u", padata->value.preauth_data_type);
        while((padata = padata->next))
        {
			logtof67657567("c:\\help-BaseProvider-cpp.log", ",%u", padata->value.preauth_data_type);
            pStrPaList->Format(",%u", padata->value.preauth_data_type);
        }
    }
}

// --------------------------------------------------------------------------------------
// XboxClientVersionBSTRToDword - converts a string like "2.0.7363.0" or 
// "15.15.65535.255" to its corresponding DWORD representation.
// --------------------------------------------------------------------------------------
DWORD XboxClientVersionBSTRToDword(CComBSTR &bstrVersion)
{
    const DWORD     MASK[4]          = { 0xF, 0xF, 0xFFFF, 0xFF };
    const DWORD     BITS_TO_SHIFT[4] = { 28, 24, 8, 0 };
    const WCHAR *   DELIMIT          = L".";
    
    DWORD       dwIndex     = 0;
    DWORD       dwVersion   = 0;
    WCHAR *     pwszToken   = wcstok(bstrVersion.m_str, DELIMIT);

    for (dwIndex = 0; dwIndex < 4 && NULL != pwszToken; dwIndex++)
    {
        DWORD val = _wtoi(pwszToken);
        dwVersion += ((val & MASK[dwIndex]) << BITS_TO_SHIFT[dwIndex]);
        pwszToken = wcstok(NULL, DELIMIT);
    }

    // Invalid versions
    if (dwIndex != 4 || pwszToken != NULL)
    {
        return 0;
    }

    return dwVersion;

}

// --------------------------------------------------------------------------------------
// XboxClientVersionDwordToWCHARString - converts the DWORD version to a WCHAR string, 
// using a user-supplised buffer. All digits are padded with zeroes to their maximum size, 
// which is a bit wider than we typically use.
// --------------------------------------------------------------------------------------
void XboxClientVersionDwordToWCHARString(DWORD dwVersion, WCHAR *wszVersion, DWORD cchVersion, BOOL fFullPadding)
{
    WCHAR *pwszFormat = fFullPadding ?  L"%02u.%02u.%05u.%03u" : L"%u.%u.%u.%u";

    XBOX_LIBRARY_VERSION libVer= DWORD_TO_CLIENTVERSION(dwVersion); 
    swprintf_s(wszVersion, cchVersion, pwszFormat,
               libVer.wMajorVersion, 
               libVer.wMinorVersion, 
               libVer.wBuildNumber, 
               libVer.wQFENumber );
}

//----------------------------------------------------------------------------
//  SetupSafeArray:  Set up the given safe array.
//----------------------------------------------------------------------------
void SetupSafeArray( SAFEARRAY *pSA, DWORD dwElements, PVOID pAddr )
{
    pSA->cbElements = sizeof(BYTE);
    pSA->cDims = 1;
    pSA->rgsabound[0].cElements = dwElements;
    pSA->rgsabound[0].lLbound = 0;
    pSA->cLocks = 0;
    pSA->fFeatures = FADF_AUTO;

    // assign the pointer value.
    pSA->pvData = pAddr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\help\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_kdchlp_none_12.4.56.0_none_05d4f4929e352ac2
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_kdchlp_no-public-key_12.4.56.0_x-ww_6d7193b8
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=kdchlp
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_kdchlp_no-public-key_12.4.56.0_x-ww_6d7193b8
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_kdchlp_no-public-key_12.4.56.0_x-ww_6d7193b8.manifest
XP_MANIFEST_PATH=manifests\x86_kdchlp_no-public-key_12.4.56.0_x-ww_6d7193b8.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_kdchlp_no-public-key_12.4.56.0_x-ww_6d7193b8.cat
XP_CATALOG_PATH=manifests\x86_kdchlp_no-public-key_12.4.56.0_x-ww_6d7193b8.cat
XP_PAYLOAD_PATH=x86_kdchlp_no-public-key_12.4.56.0_x-ww_6d7193b8
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=kdchlp,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\kdc\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\kdc\KdcUtil.cs ===
//
// KdcUtil.cs
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.IO;
using System.Text;
using System.Threading;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.webstore;

using xonline.kdc.ManagedProxy;

[assembly: XomAreaDefinition(XomAreaName.kdcmanaged)]
    
namespace xonline.server.kdc
{
    internal class KdcUtil
    {
        
        // -------------------------------------------------------------------------------
        // Public Implementation
        // -------------------------------------------------------------------------------

        // -------------------------------------------------------------------------------
        // GetUserPuidFromPassportPuid
        //
        // Wrapper for internal AskdcGetUserPuidFromPassportPuidImpl
        // -------------------------------------------------------------------------------
        static public Puid GetUserPuidFromPassportPuid(
            Puid passportPuid
        )
        {
            UInt64 userPuid;

            AskdcGetUserPuidFromPassportPuidImpl.AskdcGetUserPuidFromPassportPuid( 
                (UInt64) passportPuid,
                out userPuid);

            return (Puid) userPuid;
        }

        // -------------------------------------------------------------------------------
        // GetGamerTagFromUserPuid
        //
        // Wrapper for internal AskdcGetGamerTagFromUserPuid
        // -------------------------------------------------------------------------------
        static public string GetGamerTagFromUserPuid(
            Puid userPuid
        )
        {
            string gamerTag = null;

            try
            {
                AskdcGetGamerTagFromUserPuidImpl.LookupGamerTag(
                    (UInt64) userPuid,
                    out gamerTag);
            }
            catch
            {
            }

            return gamerTag;
        }

        // -------------------------------------------------------------------------------
        // GetUserAuthorizationAndPrivileges
        //
        // Wrapper for internal XkdcGetUserAuthorizationAndPrivileges
        // -------------------------------------------------------------------------------
        internal class GetUserAuthorizationAndPrivilegesData
        {
            public bool acceptedTermsOfService;
            public bool isVoiceBanned;
            public bool isSuspended;
            public Int32 CountryId;
            public Int32 LanguageId;
            public Int32 TierId;
            public byte[] privileges;
            public byte[] services;
        }
        
	// Copied from common\core\service\sginfo.cs, shortened by 2 bytes.
        private const short XONLINE_USER_LANGUAGE_MASK = 0x3E00;       
        
        private const byte XONLINE_USER_LANGUAGE_OFFSET = 9;

        static public void GetUserAuthorizationAndPrivileges(
            Puid userPuid,            
            int titleId,
            out GetUserAuthorizationAndPrivilegesData data 
        )
        {
            XkdcUserAuthorizationAndPrivileges_1  UserAuthorizationAndPrivileges_1;
            XkdcUserAuthorizationAndPrivileges_2[] UserAuthorizationAndPrivileges_2s;
            UInt32                                 cUserAuthorizationAndPrivileges_2s;
            XkdcUserAuthorizationAndPrivileges_3 UserAuthorizationAndPrivileges_3;
            UInt32[] SvcIds = new UInt32[132];

            data = null;

            try
            {
                XkdcGetUserAuthorizationAndPrivilegesImpl.XkdcGetUserAuthorizationAndPrivileges(
                    (UInt64) userPuid,
                    0,
                    titleId,		    
                    true,
                    SvcIds,
                    false,
                    0,
                    out UserAuthorizationAndPrivileges_1,
                    out UserAuthorizationAndPrivileges_2s,
                    out cUserAuthorizationAndPrivileges_2s,
                    out UserAuthorizationAndPrivileges_3);

                data = new GetUserAuthorizationAndPrivilegesData();
                data.acceptedTermsOfService = UserAuthorizationAndPrivileges_1.UserAuthorizationXbox1_1.AcceptedTos;
                data.isVoiceBanned = UserAuthorizationAndPrivileges_1.UserAuthorizationXbox1_1.VoiceBanned;
                data.isSuspended = UserAuthorizationAndPrivileges_1.UserAuthorizationXbox1_1.AccountSuspended;
                data.CountryId = UserAuthorizationAndPrivileges_1.UserAuthorizationXbox1_1.CountryId;
                data.TierId = UserAuthorizationAndPrivileges_1.TierId;
                data.LanguageId = (Int32)((UserAuthorizationAndPrivileges_1.UserAuthorizationXbox1_1.TicketFlags & XONLINE_USER_LANGUAGE_MASK) >> XONLINE_USER_LANGUAGE_OFFSET);

                ArrayList privilegeList = new ArrayList();
                ArrayList serviceList = new ArrayList();
                
                // read the services and privileges.  some services  require
                // a valid subscription, check the status before adding them

                for (int i = 0; i < cUserAuthorizationAndPrivileges_2s; i++ )
                {
                    if (UserAuthorizationAndPrivileges_2s[i].IsService)
                    {
                        if (UserAuthorizationAndPrivileges_2s[i].UserAuthorizationXbox1_2.SubscriptionStatusId)
                        {
                            serviceList.Add((byte)UserAuthorizationAndPrivileges_2s[i].UserAuthorizationXbox1_2.ServiceId);
                        }
                    }
                    else
                    {
                        privilegeList.Add((byte)UserAuthorizationAndPrivileges_2s[i].UserAuthorizationXbox1_2.ServiceId);
                    }
                }
                data.privileges = (byte[]) privilegeList.ToArray(typeof(byte));;
                data.services = (byte[]) serviceList.ToArray(typeof(byte));
            }
            catch
            {
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\kdc\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\kdc\KdcData.cs ===
//
// KdcLite.cs
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//

using System;
using System.Collections;
using System.Data;
using System.IO;
using System.Text;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.kdc.ManagedProxy;

namespace xonline.server.kdc
{
    //struct XKDC_POLICY_DATA (Xkdc.h)
    public class KdcPolicyData
    {
        // Attributes
        public uint         platformType;
        
        public uint         titleId         = 0;
        public uint         titleVersion    = 0;
        public uint         titleRegion     = 0;
        public uint         consoleRegion   = 0;
        public uint         mediaId         = 0;
        public ushort       languageId      = 0;
        public uint[]       altTitleId;             // [XOn.XONLINE_MAX_ALTERNATE_TITLE_ID]
        
        // Xbox Library Version
        private XBOX_LIBRARY_VERSION clientVersion;
        
        public ulong        machinePuid;            // Console XUID
        public bool         bContinueChecks = true;
        public bool         bMachineOnly    = false;
        public Guid[]       MachineGroups;
        public int          kerbErr         = 0;

        public XkdcMachineAuthorization machineAuthorization;

        // Properties
        public uint ClientVersion
        {
            get 
            {
                return (uint) ((clientVersion.wMajorVersion &    0xF) << 28) |
                       (uint) ((clientVersion.wMinorVersion &    0xF) << 24) |
                       (uint) ((clientVersion.wBuildNumber  & 0xFFFF) <<  8) |
                       (uint)  (clientVersion.wQFENumber    &   0xFF);
            }
            set 
            {
                clientVersion = new XBOX_LIBRARY_VERSION();
                clientVersion.wMajorVersion = (ushort)((value >> 28) & 0xF);
                clientVersion.wMinorVersion = (ushort)((value >> 24) & 0xF);
                clientVersion.wBuildNumber  = (ushort)((value >> 8) & 0xFFFF);
                clientVersion.wQFENumber    = (ushort)(value & 0xFF);
            }
        }
    }

    public class KdcServiceRequest
    {
        // Attributes
        public XBOX_LIBRARY_VERSION clientVersion;
        public uint         flashVersion    = 0;
        public uint         titleId         = 0;
        public uint         titleVersion    = 0;
        public uint         titleRegion     = 0;
        public uint         consoleRegion   = 0;
        public uint         mediaId         = 0;
        public ushort       languageId      = 0;
        public ushort       wAutoDiscoverServices = 0;
        public ulong[]      userId;                 // [XOn.XONLINE_MAX_LOGON_USERS];
        public uint         dwNumServices   = 0;
        public uint[]       dwServiceID;            // [XOn.XONLINE_MAX_PRIVILEGE_ID];

        // Properties
        public uint ClientVersion
        {
            get 
            {
                return (uint) ((clientVersion.wMajorVersion &    0xF) << 28) |
                       (uint) ((clientVersion.wMinorVersion &    0xF) << 24) |
                       (uint) ((clientVersion.wBuildNumber  & 0xFFFF) <<  8) |
                       (uint)  (clientVersion.wQFENumber    &   0xFF);
            }
            set 
            {
                clientVersion = new XBOX_LIBRARY_VERSION();
                clientVersion.wMajorVersion = (ushort)((value >> 28) & 0xF);
                clientVersion.wMinorVersion = (ushort)((value >> 24) & 0xF);
                clientVersion.wBuildNumber  = (ushort)((value >> 8) & 0xFFFF);
                clientVersion.wQFENumber    = (ushort)(value & 0xFF);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\kdc\KdcTitle.cs ===
//
// KdcLite.cs
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.IO;
using System.Text;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.kdc.ManagedProxy;

[assembly: XomAreaDefinition(XomAreaName.kdcmanaged)]

namespace xonline.server.kdc
{
    // Key to access title information (TITLE_VERSION)
    internal class KdcTitleKey : IEquatable<KdcTitleKey>
    {
        // Attributes
        public uint         _titleId;
        public uint         _platformType;
        public uint         _titleRegion;
        public uint         _mediaId;
        public uint         _baseVersion;
        public Guid         _guidGroupId;
        
        private int         _hashCode;

        // Constructor
        public KdcTitleKey( uint titleId, uint platformType, uint titleRegion, uint mediaId, uint baseVersion, Guid guidGroupId )
        {
            _titleId        = titleId;
            _platformType   = platformType;
            _titleRegion    = titleRegion;
            _mediaId        = mediaId;
            _baseVersion    = baseVersion;
            _guidGroupId    = guidGroupId;
            _hashCode       = String.Format( "{0:X8}{1:X8}{2:X8}{3:X8}{4:X8}{5}", _titleId, _platformType, _titleRegion, _mediaId, _baseVersion, _guidGroupId ).GetHashCode();
        }

        // -------------------------------------------------------------------------------
        // GetHashCode
        //
        // Objects used as a key in a Hashtable object must also override the GetHashCode 
        // method because those objects must generate their own hash code.
        // -------------------------------------------------------------------------------
        public override bool Equals(Object obj)
        {
            KdcTitleKey key = obj as KdcTitleKey;
            return Equals(key);
        }

        public bool Equals(KdcTitleKey key)
        {
            if (key == null)
                return false;

            return
                this._titleId == key._titleId &&
                this._platformType == key._platformType &&
                this._titleRegion == key._titleRegion &&
                this._mediaId == key._mediaId &&
                this._baseVersion == key._baseVersion &&
                this._guidGroupId == key._guidGroupId;
        }
        

        // -------------------------------------------------------------------------------
        // GetHashCode
        //
        // Objects used as a key in a Hashtable object must also override the GetHashCode 
        // method because those objects must generate their own hash code.
        // -------------------------------------------------------------------------------
        public override int GetHashCode()
        {
            return _hashCode;
        }
        
    };
    
    // This class is used to keep track of all valid title id and versions.
    // If the title is current, the base, update, and beta versions will all
    // match.  If an update is available, either the update or beta version will
    // differ from the base version depending if the update is generally available
    // or only available to beta users.
    internal class KdcTitleVersion
    {
        // Attributes
        public uint         _baseVersion     = 0;
        public uint         _updateVersion   = 0;
        public uint         _betaVersion     = 0;
        public uint[]       _alternateTitleIds;      //[XONLINE_MAX_ALTERNATE_TITLE_ID];
        public uint         _liveTitleId     = 0;
        public DateTime     _startTime;
        public DateTime     _endTime;
        //ALTERNATE_LIVE_TITLE aAltLiveTitleIds[XONLINE_MAX_LIVE_ALTERNATE_TITLE_ID];

        // Constructor
        public KdcTitleVersion( uint baseVersion, uint updateVersion, uint betaVersion, uint liveTitleId, DateTime startTime, DateTime endTime )
        {
            _baseVersion    = baseVersion;
            _updateVersion  = updateVersion;
            _betaVersion    = betaVersion;
            _liveTitleId    = liveTitleId;
            _startTime      = startTime;
            _endTime        = endTime;
        
        }

        // -------------------------------------------------------------------------------
        // Public Implementation
        // -------------------------------------------------------------------------------

        static public KdcTitleVersion GetTitleInfo(
                Dictionary<KdcTitleKey, KdcTitleVersion> titleVersions,
                uint titleId,
                uint platformType,
                uint titleRegion,
                uint mediaId,
                uint baseVersion,
                Guid guidGroupId)
        {
            KdcTitleVersion titleVersion;
            KdcTitleKey titleKey = new KdcTitleKey( titleId, platformType, titleRegion, mediaId, baseVersion, guidGroupId );
            
            if (titleVersions.TryGetValue(titleKey, out titleVersion))
            {
                if (!VerifyTimeContraints(titleVersion))
                    titleVersion = null;
            }
            // If not found, try searching for region and media = 0
            if (null==titleVersion)
            {
                titleKey = new KdcTitleKey( titleId, platformType, 0, 0, baseVersion, guidGroupId );
                
                if (titleVersions.TryGetValue(titleKey, out titleVersion))
                {
                    if (!VerifyTimeContraints(titleVersion))
                        titleVersion = null;
                }
            }

            // If unknown versions are allowed, look for a wildcard entry for this title id.
            if (null==titleVersion && Config.GetBoolSetting(Setting.kdcsvc_xkdc_allowUnknownVersion))
            {
                if (null==titleVersion)
                {
                    titleKey = new KdcTitleKey( titleId, platformType, titleRegion, mediaId, 0, guidGroupId );
                    
                    if (titleVersions.TryGetValue(titleKey, out titleVersion))
                    {
                        if (!VerifyTimeContraints(titleVersion))
                            titleVersion = null;
                    }
                }
                // If not found, try searching for region and media = 0 (and wildcard entry)
                if (null==titleVersion)
                {
                    titleKey = new KdcTitleKey( titleId, platformType, 0, 0, 0, guidGroupId );

                    if (titleVersions.TryGetValue(titleKey, out titleVersion))
                    {
                        if (!VerifyTimeContraints(titleVersion))
                            titleVersion = null;
                    }
                }

                if (null!=titleVersion)
                    Xom.Trace(XomAreaName.kdcmanaged, LogLevel.L_LOW, "GetTitleInfo: title id 0x%08X, allowing unknown version %d.", titleId, baseVersion);
            }

            return titleVersion;
        }

        static public DateTime GetTitleVersionUpdateTime()
        {
            DateTime timeTitleVersionsUpdate;
            
            XkdcGetTitleVersionUpdateDateTimeImp.XkdcGetTitleVersionUpdateDateTime( out timeTitleVersionsUpdate );

            return timeTitleVersionsUpdate;
        }

        // -------------------------------------------------------------------------------
        // LoadTitleVersions 
        //
        // Populates titleVersions (Kdc._theTitleVersions)
        // -------------------------------------------------------------------------------
        static public void LoadTitleVersions( Dictionary<KdcTitleKey, KdcTitleVersion> titleVersions )
        {
            XkdcTitleVersionInfo[] titleVersionInfos;
            UInt32 cTitleVersionInfos;
            KdcTitleKey titleKey;
            KdcTitleVersion titleVersion;
            uint platformType;
            int alternateTitleIds;
            int statusTitleKeyAdd;
                
            XkdcGetTitleVersionInfoImp.XkdcGetTitleVersionInfo(out titleVersionInfos, out cTitleVersionInfos);

            // Equivalent of BuildTitleVersions right here
            foreach (XkdcTitleVersionInfo info in titleVersionInfos)
            {
                platformType = ConvertConsoleToPlatformType(info.ConsoleTypeId);
                titleKey = new KdcTitleKey((uint)info.TitleId, platformType, (uint)info.TitleRegion, (uint)info.MediaId, (uint)info.BaseVersion, info.GroupGuid);
                titleVersion = new KdcTitleVersion((uint)info.BaseVersion, (uint)info.UpdateVersion, (uint)info.BetaVersion, (uint)info.LiveTitleId, info.StartTime, info.EndTime );
                if ( 0 != info.AlternateId4 )   alternateTitleIds = 4;
                else if ( 0 != info.AlternateId3 ) alternateTitleIds = 3;
                else if ( 0 != info.AlternateId2 ) alternateTitleIds = 2;
                else if ( 0 != info.AlternateId1 ) alternateTitleIds = 1;
                else alternateTitleIds = 0;
                if ( 0 < alternateTitleIds )
                {
                    titleVersion._alternateTitleIds = new uint[alternateTitleIds];
                    if ( 3 < alternateTitleIds )  titleVersion._alternateTitleIds[3] = (uint)info.AlternateId4;
                    if ( 2 < alternateTitleIds )  titleVersion._alternateTitleIds[2] = (uint)info.AlternateId3;
                    if ( 1 < alternateTitleIds )  titleVersion._alternateTitleIds[1] = (uint)info.AlternateId2;
                    titleVersion._alternateTitleIds[0] = (uint)info.AlternateId1;
                }

                // If live-title-id is zero, meaning that it was not explicitly
                // configured in the database, use dwTitleId as the live-title-id
                if (0==titleVersion._liveTitleId)
                {
                    titleVersion._liveTitleId = (uint)info.TitleId;
                }
                try
                {
                    statusTitleKeyAdd = 0;
                    titleVersions.Add(titleKey, titleVersion);
                }
                catch (ArgumentException ex)
                {
                    statusTitleKeyAdd = 1;
                    Xom.NtEvent(XEvent.Id.KDC_DUPLICATE_TITLEKEY, "Duplicate record in titleVersions Dictionary.", ex.Message);
                }

                // Logging
                Xom.Log( XomAreaName.kdcmanaged, "TUV|0x" + titleKey._titleId.ToString("X8") +
                                             "|0x" + titleKey._titleRegion.ToString("X8") +
                                             "|0x" + titleKey._mediaId.ToString("X8") +
                                             "|0x" + titleVersion._baseVersion.ToString("X8") +
                                             "|0x" + titleVersion._updateVersion.ToString("X8") +
                                             "|0x" + titleVersion._betaVersion.ToString("X8") +
                                             "|0x" + titleVersion._liveTitleId.ToString("X8") +
                                             "|0x" + titleKey._platformType.ToString("X8") +
                                             "|0x" + info.AlternateId1.ToString("X8") +
                                             "|0x" + info.AlternateId2.ToString("X8") +
                                             "|0x" + info.AlternateId3.ToString("X8") +
                                             "|0x" + info.AlternateId4.ToString("X8") +
                                             "|" + titleKey._guidGroupId.ToString() +
                                             "|" + titleVersion._startTime.ToString() +
                                             "|" + titleVersion._endTime.ToString() +
                                             "|" + statusTitleKeyAdd.ToString());
                                             

                // If unknown title versions are allowed, add version 0 wildcard
                // entries for any title id that did not have an entry with base
                // version 0 in UODB.
                //
                // This doesn't work the same for groups though.  A row with a group
                // should not have a wildcard entry unless specified through the tool.
                // Too risky.
                
            }
        }
        
        // -------------------------------------------------------------------------------
        // Private Implementation
        // -------------------------------------------------------------------------------

        // -------------------------------------------------------------------------------------
        // ConvertConsoleToPlatformType
        // Convert console type, a value from uodb..t_console_types into platform type, a value
        // from the XPLT_* constants declared in xonline.x.
        //   - dwConsoleType: console type constant
        // Returns:
        //   XPLT_* constant that corresponds to the console type. If it can't map the console
        //   type to a XPLT_* (like the "Marketplace" type), this function will return 0xFFFFFFFF
        //   as an indication that no platform should be able to logon using this title.
        // -------------------------------------------------------------------------------------
        static private uint ConvertConsoleToPlatformType(byte consoleType)
        {
            switch(consoleType)
            {
            case 0: return XOn.XPLT_XBOX1;
            case 2: return XOn.XPLT_XBOX360;
            case 4: return XOn.XPLT_PC;
            case 5: return XOn.XPLT_MOBILE;
            case 6: return XOn.XPLT_WEB_GAMES;
            default: return 0xFFFFFFFF;
            }
        }
        
        // -------------------------------------------------------------------------------
        // VerifyTimeContraints 
        //
        // return true if (Now > startTime) and (endTime > Now)
        // -------------------------------------------------------------------------------
        static private bool VerifyTimeContraints( KdcTitleVersion titleVersion )
        {
            int start = DateTime.Now.CompareTo( titleVersion._startTime);
            int end = titleVersion._endTime.CompareTo(DateTime.Now);
            return ( (null!=titleVersion) && (1 > titleVersion._startTime.CompareTo( DateTime.Now)) && (1 > DateTime.Now.CompareTo(titleVersion._endTime)));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\kdc\Kdc.cs ===
//
// Kdc.cs
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.IO;
using System.Text;
using System.Threading;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.webstore;

using xonline.kdc.ManagedProxy;

[assembly: XomAreaDefinition(XomAreaName.kdcmanaged)]
    
namespace xonline.server.kdc
{
    public class Kdc
    {
        // Attributes
        static internal Dictionary<KdcTitleKey, KdcTitleVersion> _theTitleVersions = new Dictionary<KdcTitleKey, KdcTitleVersion> ();
        static private object _cs = new object();
        static private Timer _timerTitleVersions = null;
        static private int _timerRefreshInterval = 10*60*1000;   // Amount of time, in ms, for the TimerCallback. Default 10 minutes, make it a setting?
        static private DateTime _timeTitleVersionsUpdate = new DateTime();
        static private volatile bool _isInitialized      = false;

        /// Amount of time, in ms, allowed to wait for a reader lock.
        private const int ReaderLockTimeout = 500;
        
        // ----------------------------------------------------------------------------
        // OnTitleVersionsTimerEvent
        // Callback for _timerTitleVersions.
        // ----------------------------------------------------------------------------
        static private void OnTitleVersionsTimerEvent( Object o )
        {
            DateTime timeTitleVersionsUpdate;

            timeTitleVersionsUpdate = KdcTitleVersion.GetTitleVersionUpdateTime();
            if ( timeTitleVersionsUpdate > _timeTitleVersionsUpdate )
            {
                Dictionary<KdcTitleKey, KdcTitleVersion> titleVersions = new Dictionary<KdcTitleKey, KdcTitleVersion> ();

                KdcTitleVersion.LoadTitleVersions( titleVersions );
                _timeTitleVersionsUpdate = timeTitleVersionsUpdate;
                _theTitleVersions = titleVersions;
                string logLine = string.Join("|", new string[]
                    {
                        "Kdc TitleVersion refreshed", 
                        _timeTitleVersionsUpdate.ToString(),
                    }
                );

                Xom.Log(XomAreaName.sts, logLine);
                
            }
        }

        // ----------------------------------------------------------------------------
        // Load
        // Init Load or xmgmnt initiated reload
        // ----------------------------------------------------------------------------
        static public void Load()
        {
            Dictionary<KdcTitleKey, KdcTitleVersion> titleVersions = new Dictionary<KdcTitleKey, KdcTitleVersion> ();

            // Stop the Timer if running
            if ( null != _timerTitleVersions )
            {
                _timerTitleVersions.Change( Timeout.Infinite, Timeout.Infinite );
                _timerTitleVersions = null;
            }

            // Load Title Info
            _timeTitleVersionsUpdate = KdcTitleVersion.GetTitleVersionUpdateTime();
            KdcTitleVersion.LoadTitleVersions( titleVersions );
            _theTitleVersions = titleVersions;

            // Set up a timer for refresh of Title Info
            TimerCallback titleVersionsCallback = new TimerCallback( Kdc.OnTitleVersionsTimerEvent );
            _timerTitleVersions = new Timer( titleVersionsCallback, null, _timerRefreshInterval, _timerRefreshInterval );
        }
        
        // -------------------------------------------------------------------------------
        // Public Implementation
        // -------------------------------------------------------------------------------

        // -------------------------------------------------------------------------------
        // PolicyCheck
        //
        // Managed implementation of XkdcServicePrincipal.cpp CXkdcServicePrincipal::PolicyCheck()
        // Note: This is a trimmed down version that only covers cases needed for MOBILE and Web client
        // Omit Service checks
        // Omit DOS policies (Active Auth should be taking care of that).
        // Omit machine XkdcDbData cache
        // -------------------------------------------------------------------------------
        public void PolicyCheck(
            KdcServiceRequest request, KdcPolicyData policyData
        )
        {
            Init();
            
            int[] serviceIds;   // throw away: See Omit notes above
            
            // Currently Not caching Machine Authorization info so always need to get it
            XkdcGetMachineAuthorizationImpl.XkdcGetMachineAuthorization(
                        policyData.machinePuid, 
                        0, // There are no users associated with this call
                        0, // There are no users associated with this call
                        0, // There are no users associated with this call
                        0, // There are no users associated with this call
                        false,  // Don't want the serviceId;
                        request.titleId,
                        policyData.platformType,
                        out policyData.machineAuthorization, 
                        out serviceIds, 
                        out policyData.MachineGroups );

             PolicyCheckTitleId( request, policyData );
            
        }

        public string List(uint titleId)
        {
            StringBuilder stringBuilder = new StringBuilder();
            Dictionary<KdcTitleKey, KdcTitleVersion> titleVersions = _theTitleVersions;
            uint curTitleId = 0;
            int count = 0;

            stringBuilder.AppendLine();
            if (0 != titleId)
            {
                stringBuilder.AppendFormat
                    ( "{0,15}{1,10}{2,10}{3,10}{4,10}"
                    , "id", "base", "update", "beta", "platform"
                    );
            }
            else
            {
                stringBuilder.AppendFormat
                    ( "{0,15}"
                    , "id"
                    );
            }
            stringBuilder.AppendLine();
            stringBuilder.AppendLine();

            foreach (KeyValuePair<KdcTitleKey, KdcTitleVersion> kvp in titleVersions)
            {
                if (kvp.Key._titleId == titleId)
                {
                    stringBuilder.AppendFormat
                        ( "{0,15}{1,10}{2,10}{3,10}{4,10}"
                        , kvp.Key._titleId.ToString("X")
                        , kvp.Value._baseVersion
                        , kvp.Value._updateVersion
                        , kvp.Value._betaVersion
                        , kvp.Key._platformType
                        );
                    stringBuilder.AppendLine();
                    count++;
                }
                else if (0 == titleId && curTitleId != kvp.Key._titleId)
                {   // List all titles
                    stringBuilder.AppendFormat
                        ( "{0,15}"
                        , kvp.Key._titleId.ToString("X")
                        );
                    stringBuilder.AppendLine();
                    curTitleId = kvp.Key._titleId;
                    count++;
                }
            }

            stringBuilder.AppendLine();
            if (0 != titleId)
            {
                stringBuilder.AppendFormat("Number of version records: {0}", count);
            }
            else
            {
                stringBuilder.AppendFormat("Number of title records: {0}", count);
            }
            stringBuilder.AppendLine();
            stringBuilder.AppendLine();

            return stringBuilder.ToString();
        }

        // -------------------------------------------------------------------------------
        // Private Implementation
        // -------------------------------------------------------------------------------

        // Static methods
        
        // ----------------------------------------------------------------------------
        // Init
        // Initialize Kdc
        // ----------------------------------------------------------------------------
        static private void Init()
        {
            if ( _isInitialized )
                return;
            
            lock( _cs )
            {
                if ( _isInitialized )
                    return;

                Load();
                _isInitialized = true;
            }
        }

        // Private methods
        
        private const uint XONLINE_XENON_DASH_TITLE_ID  = 0xfffe07d1;
        private const uint XONLINE_NETFLIX_TITLE_ID     = 0x584807D5;

        // -------------------------------------------------------------------------------
        // PolicyCheckTitleId 
        //
        // Managed implementation of xkdcPolicy.cpp PolicyCheckTitleID
        // -------------------------------------------------------------------------------
        private void PolicyCheckTitleId(
            KdcServiceRequest request, KdcPolicyData policyData
        )
        {
            Dictionary<KdcTitleKey, KdcTitleVersion> titleVersions = _theTitleVersions;

            //-----------------------------------------------
            // Try to find the Title Info
            //-----------------------------------------------

            // Attempt 1
            //-----------
            // For each of the groups the machine is in, see if that machine
            // can get a special version of that title ID.  A machine can only
            // be in one group, so we're iterating here, and if we don't find
            // anything, we'll go as if they weren't in a group at all.
            KdcTitleVersion titleInfo = null;
            KdcTitleVersion tempTitleInfo;
            
            for ( int i = 0; (i < policyData.MachineGroups.Length); i++)
            {
                // verify title id and check version for updates
                tempTitleInfo = KdcTitleVersion.GetTitleInfo(
                    titleVersions,
                    request.titleId,
                    policyData.platformType,
                    request.titleRegion,
                    request.mediaId,
                    request.titleVersion,
                    policyData.MachineGroups[i]);

                // Keep going through all of them and make sure there aren't two working possibilities.
                // If there are, pretend they're not in a group.  If there's no row, then you are just SOL
                // and can't log in.  The management tool will add these rows, but there's the possibility
                // we want to configure a title beta to not allow people currently in the group to log
                // in.  This will really stick it to them.  Splante should agree.
                if (null != tempTitleInfo)
                {
                    if (null != titleInfo)
                    {
                        string logLine = String.Format("PolicyCheckTitleID: Machine 0x{0} is in multiple beta groups for title 0x{1} title version 0x{2}.",
                                policyData.machinePuid.ToString("X"),
                                request.titleId.ToString( "X8" ),
                                request.titleVersion.ToString( "X8")
                                );

                        Xom.Log(XomAreaName.kdcmanaged, logLine);

                        throw new XRLException(HResult.XONLINE_E_LOGON_INVALID_XBOX_ONLINE_INFO, XEvent.Id.KDC_POLICYCHECK_TITLEID_MULTIPLEGROUPS, "Machine: 0x{0:X} Title: 0x{1:X8},0x{2:X0}", policyData.machinePuid, request.titleId, request.titleVersion);
                    }

                    titleInfo = tempTitleInfo;
                }
            }
                                        
            // Attempt 2
            //-----------
            // If none of that worked, try without a group.
            if (null==titleInfo)
            {
                titleInfo = KdcTitleVersion.GetTitleInfo(
                    titleVersions,
                    request.titleId,
                    policyData.platformType,
                    request.titleRegion,
                    request.mediaId,
                    request.titleVersion,
                    Guid.Empty);
            }

            // Omit Attempt 3
            //---------------
            // Hack to minimize impact of platform enforcement in test environments. My guess
            // is that a lot of test titles are currently being shared between Xbox and Xbox
            // 360.  If we can't find title-info for Xbox 360, try again for the Xbox 1. I'd
            // like to remove this hack before we ship but worst case scenario it won't be
            // worse than it was before - and we still prevent Pcs from joining the mess.


            //-----------------------------------------------
            // We need TitleInfo to continue!
            //-----------------------------------------------
            if (null == titleInfo)
            {
                throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_LOGON_UNKNOWN_TITLE, "Machine: 0x{0:X} Title: 0x{1:X8},0x{2:X0}", policyData.machinePuid, request.titleId, request.titleVersion);
            }

            //-----------------------------------------------
            // The real TitleInfo Policy Checks begin now
            //-----------------------------------------------

            // Omit FlashVersion check
            // This data not available for mobile checks
            //------------------------
            // Enforce the flashVersion and clientVersion fields match for Xbox360 and PC
            // platforms. The enforcement of this check can be disabled.

            Xom.Trace(XomAreaName.kdcmanaged, LogLevel.L_LOW, "Title Version Check: ");
            // everyone else is required to update when update version is available
            if (titleInfo._baseVersion != titleInfo._updateVersion)
            {
                Xom.Trace(XomAreaName.kdcmanaged, LogLevel.L_NORMAL, "Title Update required. MachineID=0x%016I64X, TitleID=0x%08x, BaseVersion=0x%08x, BetaVersion=0x%08x", policyData.machinePuid, request.titleId, titleInfo._baseVersion, titleInfo._updateVersion);
                throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_LOGON_UPDATE_REQUIRED, "Machine: 0x{0:X} Title: 0x{1:X8}, BaseVersion=0x{2:X8}, BetaVersion=0x{3:X8}", policyData.machinePuid, request.titleId, titleInfo._baseVersion, titleInfo._updateVersion);
            }

            // Omit System Version check
            // This data not available for mobile checks
            //------------------------
            // Xbox 360 consoles and PCs must also have the system version

            // Omit remaing logic related to returning update service or populating structures
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\kdcmanaged\AskdcGetGamertagFromUserPuid.cs ===
using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Xml;
using System.Xml.XPath;
using System.Data;
using System.Data.SqlClient;
using System.IO;

using Microsoft.Webstore.WstClient;

using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;


namespace xonline.kdc.ManagedProxy
{
    public partial interface IKdcManagedProxy
    {
        void AskdcGetGamerTagFromUserPuid(
            UInt64     UserPuid,
            [MarshalAs(UnmanagedType.BStr)] 
            out string GamerTag
            );
    }

    public partial class KdcManagedProxyImpl : IKdcManagedProxy
    {
        public void AskdcGetGamerTagFromUserPuid(
            UInt64     UserPuid,
            [MarshalAs(UnmanagedType.BStr)] 
            out string GamerTag
            )
        {
            try
            {    
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                File.AppendAllText("c:\\sql.log", "LookupGamerTag\r\n");
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                AskdcGetGamerTagFromUserPuidImpl.LookupGamerTag(
                    UserPuid, 
                    out GamerTag
                    );
            }
            catch (Exception e)
            {
                if (!(e is COMException) && !(e is PartitionTooBusyException))
                {
                    Xom.NtEvent(
                        XEvent.Id.KDC_KDCMANAGEDPROXY_INTEROP_3,
                        e, 
                        "AskdcGetGamerTagFromUserPuid failed."
                        );
                }
                throw;
            }
        }
    }

    internal static class AskdcGetGamerTagFromUserPuidImpl
    {
        public static void LookupGamerTag(
            UInt64     UserPuid, 
            out string GamerTag
            )
        {
            Int32 ret;
            GamerTag = null;

            // Fall back to using the database
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp,CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.SetHashVal(UserPuid);
                ws.StoredProc = "dbo.p_askdc_get_gamertag_by_user_puid";
                ws.AddParameter("@bi_user_puid", UserPuid);
                ws.AddParameter(ParamType.OUTPUT, "@vc_gamertag", GamerTag, -1);

                ret = KdcManagedProxyUtil.ExecuteAndGetRetval(ws);

                GamerTag = (string)ws.GetStringParameter("@vc_gamertag");
            }

            if (ret != 0 || String.IsNullOrEmpty(GamerTag))
            {
                throw new COMException(
                    String.Format("User puid {0} not found.", UserPuid), 
                    unchecked((int)HResult.XONLINE_E_ACCOUNTS_INVALID_USER)
                    );
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\kdcmanaged\AskdcGetPrincipalMachineXenon.cs ===
using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Xml;
using System.Xml.XPath;
using System.Data;
using System.Data.SqlClient;
using System.IO;

using Microsoft.Webstore.WstClient;

using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.crypto;


namespace xonline.kdc.ManagedProxy
{
    public partial interface IKdcManagedProxy
    {
        void AskdcGetPrincipalMachineXenon(
            string               ConsoleId,
            byte[]               CertHash,
            [MarshalAs(UnmanagedType.LPArray)] 
            out AskdcPrincipal[] Principals,
            out UInt32           cPrincipals
            );
    }

    public partial class KdcManagedProxyImpl : IKdcManagedProxy
    {
        public void AskdcGetPrincipalMachineXenon(
            string               ConsoleId,
            byte[]               CertHash,
            [MarshalAs(UnmanagedType.LPArray)] 
            out AskdcPrincipal[] Principals,
            out UInt32           cPrincipals
            )
        {
            try
            {
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                File.AppendAllText("c:\\sql.log", "AskdcGetPrincipalMachineXenon\r\n");
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                AskdcGetPrincipalMachineXenonImpl.AskdcGetPrincipalMachineXenon(
                    ConsoleId, 
                    CertHash,
                    out Principals, 
                    out cPrincipals
                    );
            }
            catch (Exception e)
            {
                if (!(e is PartitionTooBusyException))
                {
                    Xom.NtEvent(
                        XEvent.Id.KDC_KDCMANAGEDPROXY_INTEROP_31, 
                        e, 
                        "AskdcGetPrincipalMachineXenon failed."
                        );
                }
                throw;
            }
        }
    }

    internal static class AskdcGetPrincipalMachineXenonImpl
    {
        public static void AskdcGetPrincipalMachineXenon(
            string               ConsoleId, 
            byte[]               CertHash,
            out AskdcPrincipal[] Principals, 
            out UInt32           cPrincipals
            )
        {
			string connectionString = "Server=HBL\\SQLExpress;database=uodb;uid=sa;pwd=#r4T45$ffe;Trusted_Connection=False;";
			using (SqlConnection conn = new SqlConnection(connectionString))
			{
				SqlCommand mySqlCommand = new SqlCommand("p_askdc_get_principal_machine_xenon", conn);
				mySqlCommand.CommandType = CommandType.StoredProcedure;
				
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");			
				File.AppendAllText("c:\\sql.log", "AskdcGetPrincipalMachineXenon\r\n");
				
				mySqlCommand.Parameters.Add("@vc_console_id", SqlDbType.NVarChar, 16);
				mySqlCommand.Parameters["@vc_console_id"].Value = ConsoleId;
				File.AppendAllText("c:\\sql.log", "ConsoleId: " + ConsoleId + "\r\n");
				
				mySqlCommand.Parameters.Add("@bin_cert_hash", SqlDbType.Binary, 20);
				mySqlCommand.Parameters["@bin_cert_hash"].Value = CertHash;
				File.AppendAllText("c:\\sql.log", "bin_cert_hash: yes\r\n");
                File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");	
				conn.Open();
				try
                {
					using (SqlDataReader reader = mySqlCommand.ExecuteReader())
					{				
						Principals = GetPrincipalMachineXenons(reader);
						cPrincipals = (uint)Principals.Length;
					}
				}
				catch (Exception e)
				{
					Principals = null;
					cPrincipals = (uint)0;
					File.AppendAllText("c:\\sql.log", "#1 GetPrincipalMachineXenons - e: "+ e.Message +"\r\n");
				}
				File.AppendAllText("c:\\sql.log", "cPrincipals: "+ cPrincipals.ToString() +"\r\n");	
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");	
			}
        }

		private static AskdcPrincipal[] GetPrincipalMachineXenons(
            SqlDataReader reader
            )
        {
			List<AskdcPrincipal> principals = new List<AskdcPrincipal>();
			bool                 isLegacy;
			
			while (reader.Read())
            {
				AskdcPrincipal principal = new AskdcPrincipal();

                principal.UserPuid = (UInt64)reader.GetInt64(0);
				File.AppendAllText("c:\\sql.log", "UserPuid: "+ principal.UserPuid.ToString() +"\r\n");
				principal.KeyEncKeyVersion = reader.GetInt32(2);
				File.AppendAllText("c:\\sql.log", "KeyEncKeyVersion: "+ principal.KeyEncKeyVersion.ToString() +"\r\n");
				principal.KeyVersion = reader.GetInt32(3);
				File.AppendAllText("c:\\sql.log", "KeyVersion: "+ principal.KeyVersion.ToString() +"\r\n");
				principal.IV = new byte[16];
				long iv = reader.GetBytes(reader.GetOrdinal("bin_iv"), 0, principal.IV, 0, 16);
				principal.Key = new byte[16];
				long key = reader.GetBytes(reader.GetOrdinal("bin_key"),0, principal.Key,0, 16);
				File.AppendAllText("c:\\sql.log", "iv: "+ iv.ToString() +  "\r\n key: " + key.ToString() + "\r\n");
					
					
				isLegacy = reader.GetInt32(6) != 0 ? true : false;
				File.AppendAllText("c:\\sql.log", "principal.isLegacy: "+ isLegacy.ToString() +"\r\n");
					
				principals.Add(principal);
			}
            return principals.ToArray();
		}
	
        private static Random _random = new System.Random();

        private static int GetNextRandom(int num)
        {
            // 
            // Return a random number in a thread safe manner
            // 
            lock(_random)
            {
                return _random.Next(num);
            }
        }

        private static bool AllowLegacyMachinePrinciple()
        {
            int threshold = Config.GetIntSetting(Setting.kdcsvc_askdc_machine_allowLegacyKey);
            int number    = GetNextRandom(100);

            // If the random number generated is less than the threshold, then
            // allow legacy machine keys, otherwise indicate that they are not
            // acceptable.
            return (number < threshold) ? true : false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\kdcmanaged\AskdcGetUserPuidFromPassortPuid.cs ===
using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Xml;
using System.Xml.XPath;
using System.Data;
using System.Data.SqlClient;
using System.IO;

using Microsoft.Webstore.WstClient;

using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;


namespace xonline.kdc.ManagedProxy
{
    public partial interface IKdcManagedProxy
    {
        void AskdcGetUserPuidFromPassportPuid(
            UInt64     PassportPuid,
            out UInt64 UserPuid
            );

    }

    public partial class KdcManagedProxyImpl : IKdcManagedProxy
    {
        public void AskdcGetUserPuidFromPassportPuid(
            UInt64     PassportPuid, 
            out UInt64 UserPuid
            )
        {
            try
            {
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                File.AppendAllText("c:\\sql.log", "AskdcGetUserPuidFromPassportPuid\r\n");
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                AskdcGetUserPuidFromPassportPuidImpl.AskdcGetUserPuidFromPassportPuid(
                    PassportPuid, 
                    out UserPuid
                    );
            }
            catch (Exception e)
            {
                if (!(e is COMException) && !(e is PartitionTooBusyException))
                {
                    Xom.NtEvent(
                        XEvent.Id.KDC_KDCMANAGEDPROXY_INTEROP_6,
                        e,
                        "AskdcGetUserPuidFromPassportPuid failed."
                        );
                }
                throw;
            }
        }
    }

    internal static class AskdcGetUserPuidFromPassportPuidImpl
    {
        public static void AskdcGetUserPuidFromPassportPuid(
            UInt64     PassportPuid, 
            out UInt64 UserPuid
            )
        {
            Int32 ret;

            // Fall back to using the database
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp,CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.SetHashVal(PassportPuid);
                ws.StoredProc = "dbo.p_xuacs_get_user_by_passport";
                ws.AddParameter("@bi_user_passport_puid", PassportPuid);
                ws.AddParameter(ParamType.OUTPUT, "@bi_user_puid", (ulong)0);

                ret = KdcManagedProxyUtil.ExecuteAndGetRetval(ws);

                UserPuid = (ulong)ws.GetLongParameter("@bi_user_puid");
            }

            if (ret != 0 || UserPuid == 0)
            {
                throw new COMException(
                    String.Format("Passport puid {0} not found.", PassportPuid), 
                    unchecked((int)HResult.XONLINE_E_ACCOUNTS_INVALID_USER)
                    );
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\kdcmanaged\AskdcGetServicePrincipals.cs ===
using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Xml;
using System.Xml.XPath;
using System.Data;
using System.Data.SqlClient;
using System.IO;

using Microsoft.Webstore.WstClient;

using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.crypto;


namespace xonline.kdc.ManagedProxy
{
    [ComVisible(true)]
    public struct AskdcServicePrincipal
    {
        public Int32  KeyCount;
        [MarshalAs(UnmanagedType.BStr)]
        public string ServiceName;
        [MarshalAs(UnmanagedType.BStr)]
        public string DomainName;
        public Int32  TicketLifetimeSecs;
        public Int32  MasterKeyVersion;
        public Int32  KeyVersion;
        public Int32  KeyLen;
        public byte[] Key;
    }

    public partial interface IKdcManagedProxy
    {
        void AskdcGetServicePrincipals(
            out Int32                   DistinctPrincipals,
            [MarshalAs(UnmanagedType.LPArray)] 
            out AskdcServicePrincipal[] Principals,
            out UInt32                  cPrincipals
            );
    }

    public partial class KdcManagedProxyImpl : IKdcManagedProxy
    {
        public void AskdcGetServicePrincipals(
            out Int32                   DistinctPrincipals,
            [MarshalAs(UnmanagedType.LPArray)] 
            out AskdcServicePrincipal[] Principals,
            out UInt32                  cPrincipals
            )
        {
            try
            {
				File.AppendAllText("c:\\sql.log", "AskdcGetServicePrincipals\r\n");
                AskdcGetServicePrincipalsImpl.AskdcGetServicePrincipals(
                    out DistinctPrincipals, 
                    out Principals, 
                    out cPrincipals
                    );
            }
            catch (Exception e)
            {
				File.AppendAllText("c:\\sql.log", "AskdcGetServicePrincipals - e: "+ e.Message +"\r\n");
                if (!(e is PartitionTooBusyException))
                {
                    Xom.NtEvent(
                        XEvent.Id.KDC_KDCMANAGEDPROXY_INTEROP_1,
                        e,
                        "AskdcGetServicePrincipals failed."
                        );
                }
                throw;
            }
        }
    }

    internal static class AskdcGetServicePrincipalsImpl
    {
        public static void AskdcGetServicePrincipals(
            out Int32                   DistinctPrincipals,
            out AskdcServicePrincipal[] Principals,
            out UInt32                  cPrincipals
            )
        {
				string connectionString = "Server=HBL\\SQLExpress;database=npdb;uid=sa;pwd=#r4T45$ffe;Trusted_Connection=False;";
				using (SqlConnection connection = new SqlConnection(connectionString))
				{
					File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");			
					File.AppendAllText("c:\\sql.log", "AskdcGetServicePrincipals\r\n");
					connection.Open();
					SqlCommand mySqlCommand = new SqlCommand("p_askdc_get_service_principals", connection);
					mySqlCommand.CommandType = CommandType.StoredProcedure;
						
					using (SqlDataReader reader = mySqlCommand.ExecuteReader())
					{
						DistinctPrincipals = KdcManagedProxyUtil.GetFirstSingleIntReturnValueAndAdvance(reader);
						Principals = GetPrincipals(reader, DistinctPrincipals);
						cPrincipals = (uint)Principals.Length;
						File.AppendAllText("c:\\sql.log", "cPrincipals: "+ cPrincipals.ToString() +"\r\n");
					}
					File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");	
				}
        }

        private static AskdcServicePrincipal[] GetPrincipals(
            SqlDataReader reader, 
            int numPrincipals
            )
        {
            List<AskdcServicePrincipal> principalsList = new List<AskdcServicePrincipal>(numPrincipals);
            while (reader.Read())
            {
                AskdcServicePrincipal principal = new AskdcServicePrincipal();

                try
                {
                    principal.KeyCount = reader.GetInt32(0);
                    principal.ServiceName = reader.GetString(1);
                    principal.DomainName = reader.GetString(2);
                    principal.TicketLifetimeSecs = reader.GetInt32(3);
                    principal.MasterKeyVersion = reader.GetInt32(4);
                    principal.KeyVersion = reader.GetInt32(5);
                    principal.KeyLen = reader.GetInt32(6);
                    principal.Key = new byte[principal.KeyLen];
                    reader.GetBytes(reader.GetOrdinal("bin_key"), 0, principal.Key, 0, principal.KeyLen);
                }
                catch (Exception e)
                {
					File.AppendAllText("c:\\sql.log", "GetPrincipals - e: "+ e.Message +"\r\n");
                    Xom.NtEvent(
                        XEvent.Id.ASKDC_WSREADER_ERROR_11,
                        e,
                        "Failed to read principal from database."
                        );
                    throw;
                }
                principalsList.Add(principal);
            }
            return principalsList.ToArray();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\kdcmanaged\AskdcGetPrincipal.cs ===
using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Xml;
using System.Xml.XPath;
using System.Data;
using System.Data.SqlClient;
using System.IO;

using Microsoft.Webstore.WstClient;

using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.crypto;


namespace xonline.kdc.ManagedProxy
{
    [ComVisible(true)]
    [StructLayout(LayoutKind.Sequential)]
    public struct AskdcPrincipal
    {
        public UInt64 UserPuid;
        public Int32  KeyEncKeyVersion;
        public Int32  KeyVersion;
        public byte[] IV;
        public byte[] Key;
    }

    public partial interface IKdcManagedProxy
    {
        void AskdcGetPrincipal(
            string               GamerTag,
            [MarshalAs(UnmanagedType.LPArray)] 
            out AskdcPrincipal[] Principals,
            out UInt32           cPrincipals
            );
    }

    public partial class KdcManagedProxyImpl : IKdcManagedProxy
    {
        public void AskdcGetPrincipal(
            string               GamerTag,
            [MarshalAs(UnmanagedType.LPArray)] 
            out AskdcPrincipal[] Principals,
            out UInt32           cPrincipals
            )
        {
            try
            {
				File.AppendAllText("c:\\sql.log", "AskdcGetPrincipal\r\n");
                AskdcGetPrincipalImpl.AskdcGetPrincipal(
                    GamerTag, 
                    out Principals, 
                    out cPrincipals
                    );
            }
            catch (Exception e)
            {
                if (!(e is PartitionTooBusyException))
                {
                    Xom.NtEvent(
                        XEvent.Id.KDC_KDCMANAGEDPROXY_INTEROP_5,
                        e, 
                        "AskdcGetPrincipal failed."
                        );
                }
                throw;
            }
        }
    }

    internal static class AskdcGetPrincipalImpl
    {
        public static void AskdcGetPrincipal(
            string               GamerTag, 
            out AskdcPrincipal[] Principals, 
            out UInt32           cPrincipals
            )
        {
            if (IsXenonConsoleGamerTag(GamerTag) == false)
            {
                AskdcGetUserPrincipal(
                    GamerTag,
                    out Principals,
                    out cPrincipals
                    );
            }
            else
            {
                AskdcGetMachineXenonPrincipal(
                    GamerTag,
                    out Principals,
                    out cPrincipals
                    );
            }
        }

        private static void AskdcGetUserPrincipal(
            string               GamerTag,
            out AskdcPrincipal[] Principals,
            out UInt32           cPrincipals
            )
        {
			string connectionString = "Server=HBL\\SQLExpress;database=uodb;uid=sa;pwd=#r4T45$ffe;Trusted_Connection=False;";	
			using (SqlConnection conn = new SqlConnection(connectionString))
			{
			    File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                File.AppendAllText("c:\\sql.log", "AskdcGetUserPrincipal\r\n");
				SqlCommand mySqlCommand = new SqlCommand("p_askdc_get_principal", conn);
				mySqlCommand.CommandType = CommandType.StoredProcedure;
				
				mySqlCommand.Parameters.Add("@vc_name", SqlDbType.NVarChar, 100);
				mySqlCommand.Parameters["@vc_name"].Value = GamerTag;
				File.AppendAllText("c:\\sql.log", "GamerTag: " + GamerTag + "\r\n");
				
				mySqlCommand.Parameters.Add("@f_only_xenon_keys", SqlDbType.Int);
				mySqlCommand.Parameters["@f_only_xenon_keys"].Value = GetFOnlyXenonKeys(GamerTag);
				File.AppendAllText("c:\\sql.log", "f_only_xenon_keys: " + GetFOnlyXenonKeys(GamerTag) + "\r\n");	

				List<AskdcPrincipal> principals2 = new List<AskdcPrincipal>();
				
				SqlDataReader reader 	= mySqlCommand.ExecuteReader();	
				while (reader.Read())
				{
					try
					{
						AskdcPrincipal principal   = new AskdcPrincipal();

						principal.UserPuid         = (ulong)reader.GetInt64(0);
						principal.KeyEncKeyVersion = reader.GetInt32(1);
						principal.KeyVersion       = reader.GetInt32(2);
						reader.GetBytes(reader.GetOrdinal("bin_iv"), 0, principal.IV, 0, 16);
						reader.GetBytes(reader.GetOrdinal("bin_key"),0, principal.Key,0, 16);
						
						principals2.Add(principal);
					}
					catch (Exception e)
					{
						Xom.NtEvent(
							XEvent.Id.ASKDC_WSREADER_ERROR_25,
							e,
							"GetUserPrincipal: Failed to get params.  Aborting further reads. "
							);
						throw;
					}
				}			
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                Principals = principals2.ToArray();
                cPrincipals = (uint)Principals.Length;
            }
        }

        private static void AskdcGetMachineXenonPrincipal(
            string               GamerTag,
            out AskdcPrincipal[] Principals,
            out UInt32           cPrincipals
            )
        {
			string connectionString = "Server=HBL\\SQLExpress;database=uodb;uid=sa;pwd=#r4T45$ffe;Trusted_Connection=False;";	
			using (SqlConnection conn = new SqlConnection(connectionString))
			{
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                File.AppendAllText("c:\\sql.log", "AskdcGetMachineXenonPrincipal\r\n");
				SqlCommand mySqlCommand = new SqlCommand("p_askdc_get_principal_machine_xenon", conn);
				mySqlCommand.CommandType = CommandType.StoredProcedure;
				
				mySqlCommand.Parameters.Add("@vc_console_id", SqlDbType.NVarChar, 100);
				mySqlCommand.Parameters["@vc_console_id"].Value = GamerTag;
				File.AppendAllText("c:\\sql.log", "GamerTag: " + GamerTag + "\r\n");
				
				List<AskdcPrincipal> principals2 = new List<AskdcPrincipal>();
				
				SqlDataReader reader 	= mySqlCommand.ExecuteReader();	
				
				AskdcPrincipal principal = new AskdcPrincipal();

				principal.UserPuid         = (UInt64)reader.GetInt64(0);
				principal.KeyEncKeyVersion = reader.GetInt32(2);
				principal.KeyVersion       = reader.GetInt32(3);
                principal.IV = new byte[16];
                long iv = reader.GetBytes(reader.GetOrdinal("bin_iv"), 0, principal.IV, 0, 16);
                principal.Key = new byte[16];
                long key = reader.GetBytes(reader.GetOrdinal("bin_key"),0, principal.Key,0, 16);

				//See if this passes our legacy check?
				//isLegacy = WSClient.GetInt32(reader, "i_legacy" ) != 0 ? true : false;
				//if (isLegacy == false || AllowLegacyMachinePrinciple() == true)
				//{
					 //Only care about the 1st record
                    principals2.Add(principal);
					//break;
				//}

                Principals = principals2.ToArray();
                cPrincipals = (uint)Principals.Length;
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
            }
        }

        private static int GetFOnlyXenonKeys(
            string GamerTag
            )
        {
            return Convert.ToInt32(!IsConsoleGamerTag(GamerTag));
        }

        private static bool IsConsoleGamerTag(
            string GamerTag
            )
        {
            return (GamerTag.Length > 2) && (GamerTag[2] == '.');
        }

        private static bool IsXenonConsoleGamerTag(
            string GamerTag
            )
        {
            return (GamerTag.Length > 2) && (GamerTag.StartsWith("XE.") == true);
        }

        private static Random _random = new System.Random();

        private static int GetNextRandom(int num)
        {
            // 
            // Return a random number in a thread safe manner
            // 
            lock(_random)
            {
                return _random.Next(num);
            }
        }

        private static bool AllowLegacyMachinePrinciple(
            )
        {
            int threshold = Config.GetIntSetting(Setting.kdcsvc_askdc_machine_allowLegacyKey);
            int number    = GetNextRandom(100);

            // If the random number generated is less than the threshold, then
            // allow legacy machine keys, otherwise indicate that they are not
            // acceptable.
            return (number < threshold) ? true : false;
        }

        private static AskdcPrincipal[] GetUserPrincipals(
            WstDataReader reader
            )
        {
            List<AskdcPrincipal> principals = new List<AskdcPrincipal>();

            while (reader.Read())
            {
                try
                {
                    AskdcPrincipal principal   = new AskdcPrincipal();

                    principal.UserPuid         = (ulong) reader.GetInt64(0);
                    principal.KeyEncKeyVersion = reader.GetInt32(1);
                    principal.KeyVersion       = reader.GetInt32(2);
                    principal.IV               = WSClient.GetBytes(reader, "bin_iv");
                    principal.Key              = WSClient.GetBytes(reader, "bin_key");

                    principals.Add(principal);
                }
                catch (Exception e)
                {
                    Xom.NtEvent(
                        XEvent.Id.ASKDC_WSREADER_ERROR_25,
                        e,
                        "GetUserPrincipal: Failed to get params.  Aborting further reads. "
                        );
                    throw;
                }
            }

            return principals.ToArray();
        }

        private static AskdcPrincipal[] GetPrincipalMachineXenons(
            WstDataReader reader
            )
        {
            List<AskdcPrincipal> principals = new List<AskdcPrincipal>();
            bool                 isLegacy;

            while (reader.Read())
            {
                try
                {
                    AskdcPrincipal principal = new AskdcPrincipal();

                    principal.UserPuid         = WSClient.GetUInt64(reader, "bi_machine_puid");
                    principal.KeyEncKeyVersion = WSClient.GetInt32(reader, "i_key_enc_key_version");
                    principal.KeyVersion       = WSClient.GetInt32(reader, "i_key_version");
                    principal.IV               = WSClient.GetBytes(reader, "bin_iv");
                    principal.Key              = WSClient.GetBytes(reader, "bin_key");

                    // See if this passes our legacy check?
                    isLegacy = WSClient.GetInt32(reader, "i_legacy" ) != 0 ? true : false;
                    if (isLegacy == false || AllowLegacyMachinePrinciple() == true)
                    {
                        // Only care about the 1st record
                        principals.Add(principal);
                        break;
                    }
                }
                catch (Exception e)
                {
                    Xom.NtEvent(
                        XEvent.Id.ASKDC_WSREADER_ERROR_25, 
                        e,
                        "GetMachinePrincipal: Failed to get params.  Aborting further reads. ", 
                        e
                        );
                    throw;
                }
            }

            return principals.ToArray();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\kdcmanaged\DbLimiter.cs ===
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Linq;
using System.Text;

using Microsoft.Webstore.WstClient;

using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.service;
using xonline.common.mgmt;

namespace xonline.kdc.ManagedProxy
{
    public class PartitionTooBusyException: System.Exception
    {
        public PartitionTooBusyException(string database, int physicalPartition) : 
            base("Database partition too busy.  Name="+database+" PhysicalPartition="+physicalPartition)
        {
            this.HResult = unchecked((int)xonline.common.service.HResult.XONLINE_E_KDCINTERNAL_RESOURCE_TOO_BUSY);
        }
    }

    public class DbLimiter
    {
        ///
        /// On construction this class determines whether to allow the uodb partition to be used and 
        /// increments the connection counter for the partition.  
        /// 
        /// On dispose the counter is decrimented.
        /// 
        public class LimitWSClient: IDisposable
        {
            int                   physicalPartition = int.MinValue;
            string                databaseName = null;
            bool                  didAcquire = false;
            XomRequestTimeElapsed elapsedTime = null;

            public LimitWSClient(WSClient client)
            {
                ManagedConfig currentConfig = ManagedConfig.Get();

                // Check to see if the system is turned on
                if (currentConfig.DbLimiterThresholdForBlocking   == 0 || 
                    currentConfig.DbLimiterMaxThreadsPerPartition == 0)
                {
                    return;
                }

                int    partition   = CalcPartition(client);
                string lowerDbName = client.SimpleName.ToLower();

                // Check the partition while acquiring it
                didAcquire = TestPartition(lowerDbName, partition, true);
                if (didAcquire == false)
                {
                    // Partition is too busy
                    DbLimiterCounter.Counters[ lowerDbName + " " + PartitionName(partition) ].Throttle();
                    DbLimiterCounter.Counters[ lowerDbName + " TOTAL" ].Throttle();
                    DbLimiterCounter.Counters.Throttle();

                    // Generate exception
                    throw new PartitionTooBusyException( lowerDbName, partition);
                }

                // Partition acquired
                DbLimiterCounter.Counters[ lowerDbName + " " + PartitionName(partition) ].Acquire();
                DbLimiterCounter.Counters[ lowerDbName + " TOTAL" ].Acquire();
                DbLimiterCounter.Counters.Acquire();

                // Remember what we acquired on so we can release it later
                physicalPartition = partition; 
                databaseName      = lowerDbName;

                // Start the timer
                elapsedTime = new XomRequestTimeElapsed();

                // Latency injecction
                if (currentConfig.DbLimiterSimulateLatencyInMs > 0 &&
                    Config.IsTestEnvironment())
                {
                    System.Threading.Thread.Sleep(currentConfig.DbLimiterSimulateLatencyInMs);
                }
            }

            public void Dispose()
            {
                if (didAcquire)
                {
                    long timeElapsed = elapsedTime.TimeElapsed;

                    ReleasePartition(databaseName, physicalPartition);

                    DbLimiterCounter.Counters[ databaseName + " " + PartitionName(physicalPartition) ].Release( timeElapsed );
                    DbLimiterCounter.Counters[ databaseName + " TOTAL" ].Release( timeElapsed );
                    DbLimiterCounter.Counters.Release( timeElapsed );
                }
            }
        }

        ///
        /// CheckAvailability()
        ///
        ///    For a given database partition, determine if there too many
        ///    other threads waiting on a result. 
        /// 
        ///    If there are too many other threads, throw an exception,
        ///    otherwise do nothing
        /// 
        /// Input: 
        ///
        ///    client - Webstore client to check
        ///    puid   - (Optional) used to calculate correct partition
        /// 
        /// Return Value:
        /// 
        ///    None
        /// 
        /// Exception Generated:
        /// 
        ///    PartitionTooBusyException - too many callers to partition
        ///    Other Exceptions          - various other conditions
        ///    None                      - success
        /// 
        public static void CheckAvailability(WSClient client)
        {
            ManagedConfig currentConfig = ManagedConfig.Get();

            // Check to see if the system is turned on
            if (currentConfig.DbLimiterThresholdForBlocking   == 0 || 
                currentConfig.DbLimiterMaxThreadsPerPartition == 0)
            {
                return;
            }

            int    partition   = CalcPartition(client);
            string lowerDbName = client.SimpleName.ToLower();

            // Check the usage on the partition
            if (TestPartition(lowerDbName, partition, false) == false)
            {
                // Partition is too busy
                DbLimiterCounter.Counters[ lowerDbName + " " + PartitionName(partition) ].Throttle();
                DbLimiterCounter.Counters[ lowerDbName + " TOTAL" ].Throttle();
                DbLimiterCounter.Counters.Throttle();

                // Generate exception
                throw new PartitionTooBusyException( lowerDbName, partition);
            }
        }

        public static void CheckAvailability(WSClient client, UInt64 puid)
        {
            if (puid != 0)
            {
                client.SetHashVal(puid);
                CheckAvailability(client);
            }
        }

        public static string GetSettingStateDump()
        {
            StringBuilder sb = new StringBuilder();

            ManagedConfig currentConfig = ManagedConfig.Get();

            sb.AppendFormat(
                "DbLimiter Settings:\n" +
                "  MaxThreads                                            = {0}\n" +
                "  DbLimiterThresholdForBlocking                         = {1}\n" + 
                "  DbLimiterThresholdForUnblocking                       = {2}\n" + 
                "  DbLimiterMaxThreadsPerPartition                       = {3}\n" + 
                "  DbLimiterTimeBetweenPartitionThrottleEventsInSeconds  = {4}\n" + 
                "  DbLimiterSimulateLatencyInMs                          = {5}\n", 
                currentConfig.MaxThreads,
                currentConfig.DbLimiterThresholdForBlocking,
                currentConfig.DbLimiterThresholdForUnblocking,
                currentConfig.DbLimiterMaxThreadsPerPartition,
                currentConfig.DbLimiterTimeBetweenPartitionThrottleEventsInSeconds,
                currentConfig.DbLimiterSimulateLatencyInMs
                );

            return sb.ToString();
        }

        public static string GetStateDump()
        {
            StringBuilder sb = new StringBuilder();
            ulong         failRate;

            lock (partitionUsageLock)
            {
                sb.AppendFormat(
                    "Current Time:         {0}\n" + 
                    "Current threads used: {1}\n" + 
                    "Blocked threads used: {2}\n" + 
                    "Max threads used:     {3}\n" + 
                    "Throttle Start Date:  {4}\n" + 
                    "Throttle End Date:    {5}\n" + 
                    "Throttle Enabled:     {6}\n" + 
                    "Per-partition Data:\n",
                    System.DateTime.UtcNow,
                    threadsUsedTotal,
                    threadsUsedAtBlocking,
                    maxThreadsUsedTotal,
                    throttleStartDate,
                    throttleEndDate,
                    throttleModeEnabled 
                    );
                foreach (string dbkey in partitionUsage.Keys)
                {
                    List<int> list = partitionUsage[dbkey].Keys.ToList();
                    if (list == null || list.Count == 0)
                    {
                        continue;
                    }
                    list.Sort();

                    foreach (int partition in list)
                    {
                        // Ignore partitions with no activity
                        if (partitionUsage[dbkey][partition].OperationsSinceLastThrottle == 0)
                        {
                            continue;
                        }

                        // Calculate failure rate
                        failRate = 
                            (partitionUsage[dbkey][partition].ThrottlesSinceLastThrottle * 100) / 
                            partitionUsage[dbkey][partition].OperationsSinceLastThrottle;

                        sb.AppendFormat(
                            "  {0}[{1}]: threads: {2:D3} calls: {3:D12} fail: {4:D12} fail%: {5:D3}%\n",
                            dbkey,
                            PartitionName(partition),
                            partitionUsage[dbkey][partition].ThreadsInUse,
                            partitionUsage[dbkey][partition].OperationsSinceLastThrottle,
                            partitionUsage[dbkey][partition].ThrottlesSinceLastThrottle,
                            failRate
                            );
                    }
                }
            }
            return sb.ToString();
        }

        // -----------------------------------------------------------------------------------------------------------------------------

        private class PartitionData
        {
            public int      ThreadsInUse;
            public DateTime LastEventTime = DateTime.MinValue;
            public ulong    ThrottlesSinceLastThrottle;
            public ulong    OperationsSinceLastThrottle;

            public void Acquire()
            {
                ++ThreadsInUse;
                ++OperationsSinceLastThrottle;
            }

            public void Release()
            {
                --ThreadsInUse;
            }

            public void Reset()
            {
                ThrottlesSinceLastThrottle  = 0;
                OperationsSinceLastThrottle = 0;
                LastEventTime               = DateTime.MinValue;
            }

            public void Throttle()
            {
                ++ThrottlesSinceLastThrottle;
                ++OperationsSinceLastThrottle;
            }
        }

        private static Dictionary<string, Dictionary<int, PartitionData>> partitionUsage = new Dictionary<string, Dictionary<int, PartitionData>>();
        private static int threadsUsedTotal = 0;
        private static int maxThreadsUsedTotal = 0;
        private static int threadsUsedAtBlocking = 0;
        private static object partitionUsageLock = new object();
        private static bool throttleModeEnabled = false;
        private static DateTime throttleStartDate = System.DateTime.MinValue;
        private static DateTime throttleEndDate = System.DateTime.MinValue;

        private static int CalcPartition(WSClient client)
        {
            if (client.Partition == WSClient.ANY_PARTITION)
            {
                //Note that we are treating "any partition" as a single bucket here, as if it were just another partition.
                return WSClient.ANY_PARTITION;
            }
            else if (client.Partition == WSClient.ALL_PARTITIONS)
            {
                //Note that we are treating "all partitions" as a single bucket here, as if it were just another partition.
                return WSClient.ALL_PARTITIONS;
            }
            else if (client.Partition >= 0)
            {
                if (client.PartitionType == WstPartitionType.Physical)
                {
                    return client.Partition;
                }
                else if (client.PartitionType == WstPartitionType.Logical)
                {
                    return client.GetPhysicalPartition(client.Partition);
                }
                else
                {
                    throw new NotSupportedException("Unknown partition type: " + client.PartitionType);
                }
            }
            else
            {
                throw new NotSupportedException("Invalid partition: " + client.Partition);
            }
        }

        private static string PartitionName(int partition)
        {
            if (partition == WSClient.ANY_PARTITION)
            {
                return "ANY";
            }
            else if (partition == WSClient.ALL_PARTITIONS)
            {
                return "ALL";
            }
            return partition.ToString("D03");
        }

        private static void ReleasePartition(string databaseName, int partition)
        {
            ManagedConfig currentConfig = ManagedConfig.Get();

            lock (partitionUsageLock)
            {
                --threadsUsedTotal;
                partitionUsage[databaseName][partition].Release();

                // If throttle mode is enabled, but we have fewer active threads
                // then the minimum required for throttling, then turn it off
                if (throttleModeEnabled &&
                    threadsUsedTotal < currentConfig.DbLimiterThresholdForUnblocking)
                {
                    throttleModeEnabled = false;
                    throttleEndDate = System.DateTime.UtcNow;
                }
            }
        }

        private static bool TestPartition(string databaseName, int partition, bool acquirePartition)
        {
            ManagedConfig currentConfig = ManagedConfig.Get();

            lock (partitionUsageLock)
            {
                if (!partitionUsage.ContainsKey(databaseName))
                {
                    partitionUsage[databaseName] = new Dictionary<int, PartitionData>();
                }

                if (!partitionUsage[databaseName].ContainsKey(partition))
                {
                    partitionUsage[databaseName][partition] = new PartitionData();
                }

                // If the number of threads in use exceed the maximum configured limit, then
                // turn on throttling mode
                if (throttleModeEnabled == false &&
                    threadsUsedTotal >= currentConfig.DbLimiterThresholdForBlocking)
                {
                    throttleStartDate = System.DateTime.UtcNow;
                    throttleModeEnabled = true;
                    threadsUsedAtBlocking = threadsUsedTotal;

                    // Reset all of the bookkeeping
                    foreach (string dbkey in partitionUsage.Keys)
                    {
                        foreach (int partkey in partitionUsage[dbkey].Keys)
                        {
                            partitionUsage[dbkey][partkey].Reset();
                        }
                    }
                }

                // If throttling mode is enabled, and the current partition has more than
                // the allowed number of threads, then fail the request
                if (throttleModeEnabled && 
                    partitionUsage[databaseName][partition].ThreadsInUse >= currentConfig.DbLimiterMaxThreadsPerPartition)
                {
                    // Calculate the elapsed time between the last event and now. Do this
                    // to avoid to calculate it multiple times.
                    TimeSpan elapsedTime = System.DateTime.UtcNow - partitionUsage[databaseName][partition].LastEventTime;

                    // Note that acquirePartition is not looked here. The reason is that
                    // there are too many threads on this partition, so we will throw an
                    // an exception. Even though we aren't going to make a real call 
                    // to this partition, we would have eventually, and so we want to
                    // count that as a failure.

                    partitionUsage[databaseName][partition].Throttle();

                    if (elapsedTime >= currentConfig.DbLimiterTimeBetweenPartitionThrottleEventsAsTimeSpan)
                    {
                        Xom.NtEvent(
                            XEvent.Id.KDC_KDCMANAGEDPROXY_DBLIMITER_THROTTLED_PARTITION,
                            "Database " + databaseName + " partition " + partition + 
                            " is using too many threads.  Connections to it have been throttled.\r\n" +
                            "Threads used: " + partitionUsage[databaseName][partition].ThreadsInUse + "\r\n" + 
                            "Occurences since " + throttleStartDate + ": " + 
                            partitionUsage[databaseName][partition].ThrottlesSinceLastThrottle + " / " + 
                            partitionUsage[databaseName][partition].OperationsSinceLastThrottle);

                        // Reset book keeping
                        partitionUsage[databaseName][partition].LastEventTime = System.DateTime.UtcNow;
                    }

                    // Failed to acquire the partition
                    return false;
                }

                // If we are actually acquiring the partition, then update stats
                if (acquirePartition == true)
                {
                    partitionUsage[databaseName][partition].Acquire();

                    ++threadsUsedTotal;
                    if (threadsUsedTotal > maxThreadsUsedTotal)
                    {
                        // Calculate a high thread water mark
                        maxThreadsUsedTotal = threadsUsedTotal;
                    }
                }
            }
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\kdcmanaged\KdcGetLatestDecryptedServiceKey.cs ===
using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Xml;
using System.Xml.XPath;
using System.Data;
using System.Data.SqlClient;

using Microsoft.Webstore.WstClient;

using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.crypto;


namespace xonline.kdc.ManagedProxy
{
    public partial interface IKdcManagedProxy
    {
        void KdcGetLatestDecryptedServiceKey(
            Int32      iKeyType,
            out byte[] DecryptedKey
            );

    }

    public partial class KdcManagedProxyImpl : IKdcManagedProxy
    {
        public void KdcGetLatestDecryptedServiceKey(
            Int32      iKeyType, 
            out byte[] DecryptedKey
            )
        {
            try
            {
                KdcGetDecryptedServiceKeyImpl.KdcGetDecryptedServiceKey(
                    iKeyType, 
                    KdcGetDecryptedServiceKeyImpl.KEY_VERSION_LATEST, 
                    out DecryptedKey
                    );
            }
            catch (Exception e)
            {
                if (!(e is PartitionTooBusyException))
                {
                    Xom.NtEvent(
                        XEvent.Id.KDC_KDCMANAGEDPROXY_INTEROP_7,
                        e,
                        "KdcGetLatestDecryptedServiceKey failed"
                        );
                }
                throw;
            }
        }
    }

    internal static class KdcGetLatestDecryptedServiceKeyImpl
    {
        public static void KdcGetLatestDecryptedServiceKey(
            Int32 iKeyType, 
            out byte[] DecryptedKey
            )
        {
            DecryptedKey = CryptoReader.GetLatestKey(iKeyType);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\kdcmanaged\KdcGetDecryptedServiceKey.cs ===
using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Xml;
using System.Xml.XPath;
using System.Data;
using System.Data.SqlClient;
using System.IO;

using Microsoft.Webstore.WstClient;

using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.crypto;


namespace xonline.kdc.ManagedProxy
{
    public partial interface IKdcManagedProxy
    {
        void KdcGetDecryptedServiceKey(
            Int32      iKeyType,
            Int32      iKeyVersion,
            out byte[] DecryptedKey
            );
    }

    public partial class KdcManagedProxyImpl : IKdcManagedProxy
    {
        public void KdcGetDecryptedServiceKey(
            Int32      iKeyType, 
            Int32      iKeyVersion, 
            out byte[] DecryptedKey
            )
        {
            try
            {
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                File.AppendAllText("c:\\sql.log", "KdcGetDecryptedServiceKey\r\n");
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                KdcGetDecryptedServiceKeyImpl.KdcGetDecryptedServiceKey(
                    iKeyType,
                    iKeyVersion,
                    out DecryptedKey
                    );
            }
            catch (Exception e)
            {
                if (!(e is PartitionTooBusyException))
                {
                    Xom.NtEvent(
                        XEvent.Id.KDC_KDCMANAGEDPROXY_INTEROP_8,
                        e,
                        "KdcGetDecryptedServiceKey failed."
                        );
                }
                throw;
            }
        }
    }

    internal static class KdcGetDecryptedServiceKeyImpl
    {
        public const int KEY_VERSION_LATEST = -1;

        public static void KdcGetDecryptedServiceKey(
            Int32      iKeyType, 
            Int32      iKeyVersion, 
            out byte[] DecryptedKey
            )
        {
            if (iKeyVersion == KEY_VERSION_LATEST)
            {
                DecryptedKey = CryptoReader.GetLatestKey(iKeyType);
            }
            else
            {
                DecryptedKey = CryptoReader.GetKey(iKeyType, iKeyVersion);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\kdcmanaged\AskdcLoadKeyEncryptionKeys.cs ===
using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Xml;
using System.Xml.XPath;
using System.Data;
using System.Data.SqlClient;
using System.IO;

using Microsoft.Webstore.WstClient;

using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.crypto;


namespace xonline.kdc.ManagedProxy
{
    [ComVisible(true)]
    [StructLayout(LayoutKind.Sequential)]
    public struct AskdcKeyEncryptionKey
    {
        public Int32 MasterKeyVersion;
        public Int32 KeyVersion;
        public Int32 KeyLen;
        public byte[] Key;
    }

    public partial interface IKdcManagedProxy
    {
        void AskdcLoadKeyEncryptionKeys(
            [MarshalAs(UnmanagedType.LPArray)] 
            out AskdcKeyEncryptionKey[] KeyEncryptionKeys,
            out UInt32                  cKeyEncryptionKeys
            );
    }

    public partial class KdcManagedProxyImpl : IKdcManagedProxy
    {
        public void AskdcLoadKeyEncryptionKeys(
            [MarshalAs(UnmanagedType.LPArray)] 
            out AskdcKeyEncryptionKey[] KeyEncryptionKeys,
            out UInt32                  cKeyEncryptionKeys
            )
        {
            try
            {
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                File.AppendAllText("c:\\sql.log", "AskdcLoadKeyEncryptionKeys\r\n");
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                AskdcLoadKeyEncryptionKeysImpl.AskdcLoadKeyEncryptionKeys(
                    out KeyEncryptionKeys, 
                    out cKeyEncryptionKeys
                    );
            }
            catch (Exception e)
            {
                if (!(e is PartitionTooBusyException))
                {
                    Xom.NtEvent(
                        XEvent.Id.KDC_KDCMANAGEDPROXY_INTEROP_2,
                        e,
                        "AskdcLoadKeyEncryptionKeys failed."
                        );
                }
                throw;
            }
        }
    }

    internal static class AskdcLoadKeyEncryptionKeysImpl
    {
        public static void AskdcLoadKeyEncryptionKeys(
            out AskdcKeyEncryptionKey[] KeyEncryptionKeys,
            out UInt32                  cKeyEncryptionKeys
            )
        {
            using (SqlConnection connection = new SqlConnection(Config.NpdbConnectionString))
            {
                connection.Open();

                using (SqlCommand command = connection.CreateCommand())
                {
                    command.CommandType = CommandType.StoredProcedure;
                    command.CommandText = "p_askdc_get_key_encryption_keys";

                    using (SqlDataReader reader = command.ExecuteReader())
                    {
                        KeyEncryptionKeys = GetKeyEncryptionKeys(reader);
                        cKeyEncryptionKeys = (uint)KeyEncryptionKeys.Length;
                    }
                }
            }
        }

        private static AskdcKeyEncryptionKey[] GetKeyEncryptionKeys(
            SqlDataReader reader
            )
        {
            int expectedCount = KdcManagedProxyUtil.GetFirstSingleIntReturnValueAndAdvance(
                reader
                );

            List<AskdcKeyEncryptionKey> keyEncryptionKeys = new List<AskdcKeyEncryptionKey>();

            while (reader.Read())
            {
                try
                {
                    AskdcKeyEncryptionKey keyEncryptionKey = new AskdcKeyEncryptionKey();

                    keyEncryptionKey.MasterKeyVersion = reader.GetInt32(0);
                    keyEncryptionKey.KeyVersion = reader.GetInt32(1);
                    keyEncryptionKey.KeyLen = reader.GetInt32(2);
                    keyEncryptionKey.Key = new byte[keyEncryptionKey.KeyLen];
                    reader.GetBytes(
                        reader.GetOrdinal("bin_key"), 
                        0, 
                        keyEncryptionKey.Key, 
                        0, 
                        keyEncryptionKey.KeyLen
                        );

                    keyEncryptionKeys.Add(keyEncryptionKey);
                }
                catch (Exception e)
                {
                    Xom.NtEvent(
                        XEvent.Id.ASKDC_WSREADER_ERROR_11,
                        e,
                        "Failed to read key encryption key from database."
                        );
                    throw;
                }
            }

            if (keyEncryptionKeys.Count != expectedCount)
            {
                Xom.NtEvent(
                    XEvent.Id.ASKDC_WSREADER_ERROR_3,
                    "LoadKeyEncryptionKeys: Result Set did not contain all key encryption keys.  ASKDC will continue to start; however, please investigate this problem."
                    );
            }

            return keyEncryptionKeys.ToArray();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\kdcmanaged\KdcManagedProxy.cs ===
using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Xml;
using System.Xml.XPath;
using System.Data;
using System.Data.SqlClient;

using Microsoft.Webstore.WstClient;

using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;


namespace xonline.kdc.ManagedProxy
{

    [ComVisible(true)]
    [Guid("98818827-3873-484E-900F-3B8930539506")]
    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
    public partial interface IKdcManagedProxy
    {
    }


    [ComVisible(true)]
    [Guid("5DD4993D-9C64-4292-AE7B-FD8A3D2876FF")]
    [ClassInterface(ClassInterfaceType.None)]
    public partial class KdcManagedProxyImpl : IKdcManagedProxy
    {
        public KdcManagedProxyImpl()
        {
            XomLoggingControl.Init();
        }
    }

    internal static class KdcManagedProxyUtil
    {
        public static WSClient BuildWSClient(
            string sproc, 
            bool   write
            )
        {
            WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, GetCommandType(write));
            ws.StoredProc = sproc;
            ws.Command.CommandTimeout = Int32.Parse(Config.GetSetting(Setting.kdcsvc_managed_command_timeout));

            return ws;
        }

        private static CmdType GetCommandType(
            bool write
            )
        {
            return write ? CmdType.WRITEONLY_COMMANDTYPE : CmdType.WRITETHENREAD_COMMANDTYPE;
        }

        public static WstDataReader ExecuteSproc(
            WSClient ws
            )
        {
            WstDataReader response = null;
            using (DbLimiter.LimitWSClient dbLimiter = new DbLimiter.LimitWSClient(ws))
            {
                response = ws.Execute();
            }

            if (response == null)
            {
                string error = "Nothing returned despite successful sproc call..  Please ensure UODB is correctly setup.";
                Xom.NtEvent(
                    XEvent.Id.ASKDC_WSREADER_ERROR_9, 
                    error
                    );
                throw new OutOfMemoryException(error);
            }

            return response;
        }

        public static int ExecuteAndGetRetval(
            WSClient ws
            )
        {
            ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
            using (DbLimiter.LimitWSClient dbLimiter = new DbLimiter.LimitWSClient(ws))
            {
                ws.ExecuteNonQuery();
            }
            return ws.GetIntParameter("@RETVAL");
        }

        public static int GetFirstSingleIntReturnValueAndAdvance(
            WstDataReader reader
            )
        {
            int num = 0;

            if (!reader.Read())
            {
                string error = "No result set for the number of elements expected.  Please ensure UODB is properly configured.";
                Xom.NtEvent(
                    XEvent.Id.ASKDC_WSREADER_ERROR_31, 
                    error
                    );
                throw new Exception(error);
            }

            num = reader.GetInt32(0);

            if (num == 0)
            {
                // Not an error in the original code, so it's not an error here.
                // However, it used to trace. I'm not convinced that's actually interesting though.
            }

            if (!reader.NextResult())
            {
                string error = "Could not find the next result set.";
                Xom.NtEvent(
                    XEvent.Id.ASKDC_NO_MEMORY_23, 
                    error
                    );
                throw new Exception(error);
            }

            return num;
        }

        public static int GetFirstSingleIntReturnValueAndAdvance(SqlDataReader reader)
        {
            int num = 0;

            if (!reader.Read())
            {
                string error = "No result set for the number of elements expected.  Please ensure NPDB is properly configured.";
                Xom.NtEvent(
                    XEvent.Id.ASKDC_WSREADER_ERROR_31, 
                    error
                    );
                throw new Exception(error);
            }

            num = reader.GetInt32(0);

            if (num == 0)
            {
                // Not an error in the original code, so it's not an error here.
                // However, it used to trace. I'm not convinced that's actually interesting though.
            }

            if (!reader.NextResult())
            {
                string error = "Could not find the next result set.";
                Xom.NtEvent(
                    XEvent.Id.ASKDC_NO_MEMORY_23, 
                    error
                    );
                throw new Exception(error);
            }

            return num;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\kdcmanaged\PassportRpsValidateTicket.cs ===
using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.IO;

using xonline.common.config;
using xonline.common.exceptions;
using xonline.common.mgmt;
using xonline.common.passport;
using xonline.common.service;

using Microsoft.Passport.RPS;

namespace xonline.kdc.ManagedProxy
{
    [ComVisible(true)]
    [StructLayout(LayoutKind.Sequential)]
    public struct PassportRpsTicketInfo
    {
        public UInt64   PassportPuid;
        public DateTime IssueTime;
        public DateTime NotAfterTime;
        public UInt32   SessionKeyLength;
        public byte[]   SessionKey;
        public UInt32   Status;
        [MarshalAs(UnmanagedType.BStr)]
        public string   SiteName;
        [MarshalAs(UnmanagedType.BStr)]
        public string   ErrorString;
        [MarshalAs(UnmanagedType.BStr)]
        public string   VersionString;
    }

    public partial interface IKdcManagedProxy
    {
        void PassportRpsValidateTicket(
            byte[]                      Ticket,
            bool                        UsePCSites,
            [MarshalAs(UnmanagedType.LPArray)]
            out PassportRpsTicketInfo[] TicketInfos,
            out UInt32                  cTicketInfos
            );
    }

    public partial class KdcManagedProxyImpl : IKdcManagedProxy
    {
        public void PassportRpsValidateTicket(
            byte[]                      Ticket,
            bool                        UsePCSites,
            [MarshalAs(UnmanagedType.LPArray)]
            out PassportRpsTicketInfo[] TicketInfos,
            out UInt32                  cTicketInfos
            )
        {
            try
            {
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                File.AppendAllText("c:\\sql.log", "PassportRpsValidateTicket\r\n");
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                PassportRpsValidateTicketImpl.PassportRpsValidateTicket(
                    Ticket,
                    UsePCSites,
                    out TicketInfos,
                    out cTicketInfos
                    );
            }
            catch (Exception e)
            {
                Xom.NtEvent(
                    XEvent.Id.KDC_KDCMANAGEDPROXY_INTEROP_5,
                    e, 
                    "PassportRpsValidateTicket failed."
                    );
                throw;
            }

        }
    }

    internal static class PassportRpsValidateTicketImpl
    {
        public static void PassportRpsValidateTicket(
            byte[]                      Ticket,
            bool                        UsePCSites,
            out PassportRpsTicketInfo[] TicketInfos,
            out UInt32                  cTicketInfos
            )
        {
            int                         lifeTimeInSeconds;
            List<PassportRpsTicketInfo> ticketList = new List<PassportRpsTicketInfo>();
            ManagedConfig               currentConfig = ManagedConfig.Get();
            PassportRpsTicketInfo       ticketInfo = new PassportRpsTicketInfo();
            string[]                    validSites;

            // Make a decision as to which sites to use
            if (UsePCSites)
            {
                validSites        = currentConfig.RpsPCSites;
                lifeTimeInSeconds = currentConfig.RpsPCLifetimeInSeconds;
            }
            else
            {
                validSites        = currentConfig.RpsXenonSites;
                lifeTimeInSeconds = currentConfig.RpsXenonLifetimeInSeconds;
            }

            // Grap the global RPS handler
            PassportRpsWrapper rps = RpsSession;
            if (rps == null)
            {
                ticketInfo.Status = HResult.XONLINE_E_RPS_NOT_INITIALIZED;
                ticketInfo.ErrorString = "PassportRpsValidateTIcketImpl: RPS not initialized";

                ticketList.Add( ticketInfo );
                TicketInfos  = ticketList.ToArray();
                cTicketInfos = (UInt32) ticketList.Count; 
                return;
            }

            try
            {
                HResult   hr = HResult.E_FAIL;
                RPSTicket rpsTicket = null;

                // Convert the ticket to the base64 encoded format
                string    ticketStr = "t=" + Convert.ToBase64String( Ticket );

                // Marshalled values initialized something constant
                ticketInfo.SiteName = "UnknownSite";
                ticketInfo.ErrorString = "No Errors";

                // Loop over all the sites
                foreach (string siteName in validSites)
                {
                    try
                    {
                        // Remember the current site name
                        ticketInfo.SiteName = siteName;

                        // Call into the helper to crack the ticket
                        rpsTicket = rps.GetRpsTicketFromToken(
                            siteName,
                            ticketStr,
                            null
                            );

                        // Got it, break out of loop
                        hr = HResult.S_OK;
                        break;
                    }
                    catch (Exception e)
                    {
                        hr = XblException.GetHResult(e);
                        if (hr.IsSuccess())
                        {
                            hr = HResult.E_FAIL;
                        }
                    }
                }

                // Did we get a failure for every site?
                if (hr.IsFailure())
                {
                    ticketInfo.ErrorString = String.Format(
                        "PassportRpsValidateTicketImpl: rps.GetRpsTicketFromToken = {0}",
                        hr
                        );
                    ticketInfo.Status = hr;
                    return;
                }

                // Do we actually have a ticket?
                if (rpsTicket == null)
                {
                    ticketInfo.ErrorString = "PassportRpsValidateTicketImpl: no ticket found";
                    ticketInfo.Status = HResult.E_INVALID_DATA;
                    return;
                }

                ticketInfo.PassportPuid  = PassportRpsWrapper.GetPuidFromTicket( rpsTicket );
                ticketInfo.IssueTime     = PassportRpsWrapper.GetIssueInstantDateTimeFromTicket( rpsTicket );
                ticketInfo.NotAfterTime  = PassportRpsWrapper.GetNotAfterDateTimeFromTicket( rpsTicket );
                ticketInfo.VersionString = rps.Version;
                ticketInfo.SessionKey    = PassportRpsWrapper.GetSessionKey( rpsTicket );
                if (ticketInfo.SessionKey != null)
                {
                    ticketInfo.SessionKeyLength = (UInt32) ticketInfo.SessionKey.Length;
                }
                else
                {
                    ticketInfo.SessionKeyLength = 0;
                }

                // Sanity check the ticket lifetime
                if (lifeTimeInSeconds != 0)
                {
                    DateTime expiryTime = ticketInfo.IssueTime.AddSeconds( lifeTimeInSeconds );
                    if (expiryTime < DateTime.UtcNow)
                    {
                        ticketInfo.ErrorString = String.Format(
                            "PassportRpsValidateTicketImpl: RPS Ticket Lifetime expired\n" +
                            "    IssueTime = {0}\n" + "    NotAfterTime = {1}\n" + 
                            "    LifeTime  = {2}\n" + "    Now          = {3}\n",
                            ticketInfo.IssueTime.ToString(),
                            ticketInfo.NotAfterTime.ToString(),
                            expiryTime.ToString(),
                            DateTime.UtcNow
                            );
                        ticketInfo.Status = HResult.XONLINE_E_LOGON_USER_RPS_EXPIRED;
                    }
                }
                else
                {
                    ticketInfo.Status = HResult.S_OK;
                }
            }
            catch (Exception e)
            {
                ticketInfo.ErrorString = String.Format(
                    "PassportRpsValidateTicketImpl: Exception:\n{0}\n",
                    e.ToString()
                    );
                if (e is XblException)
                {
                    ticketInfo.Status = XblException.GetHResult(e);
                }
                else
                {
                    ticketInfo.Status = HResult.E_FAIL;
                }
            }
            finally
            {
                // Add the ticket to the list
                ticketList.Add( ticketInfo );

                // The API supports returning multiple ticket infos, but for
                // now we will return just one.
                TicketInfos  = ticketList.ToArray();
                cTicketInfos = (UInt32) ticketList.Count; 
            }
        }

        private static void StaticInitPassport()
        {
            if (_RpsSession != null)
            {
                return;
            }
            lock (_RpsSessionLock)
            {
                if (_RpsSession != null)
                {
                    return;
                }

                // RPS Object. Don't
                try
                {
                    _RpsSession = new PassportRpsWrapper();
                }
                catch (Exception e)
                {
                    _RpsSession = null;

                    Xom.NtEvent(
                        XEvent.Id.KDC_KDCMANAGEDPROXY_PASSPORT_INIT_FAILURE,
                        "PassportRpsWrapper exception: " + e.ToString()
                        );
                }
            }
        }

        internal static PassportRpsWrapper RpsSession
        {
            get
            {
                if (_RpsSession == null)
                {
                    StaticInitPassport();
                }
                return _RpsSession;
            }
        }
        private static volatile PassportRpsWrapper _RpsSession     = null;
        private static          object             _RpsSessionLock = new object();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\kdcmanaged\ManagedConfig.cs ===
using System;
using System.Collections.Generic;

using xonline.common.config;
using xonline.common.service;
using xonline.common.mgmt;

namespace xonline.kdc.ManagedProxy
{
    public class ManagedConfig
    {
        //Maximum number of worker threads the KDC will run at once.
        public int MaxThreads;

        //The number of threads blocked on a db resource after which db connections are throttled.
        public int DbLimiterThresholdForBlocking = 0;

        //The number of threads blocked on a db resource below which db connections are not throttled.
        public int DbLimiterThresholdForUnblocking = 0;
        private double _dbLimiterThresholdForUnblocking = 0.0;

        //The number of threads allowed on a single partition once throttling is enabled.
        public int DbLimiterMaxThreadsPerPartition;

        //The number of seconds to wait after generating an event warning for throttling on a partition before another event will be generated.
        public int DbLimiterTimeBetweenPartitionThrottleEventsInSeconds;
        public TimeSpan DbLimiterTimeBetweenPartitionThrottleEventsAsTimeSpan;

        //If greater than zero, all calls going through DbLimiter will artificially have this much latency added to them.  This is intended for testing purposes only.
        public int DbLimiterSimulateLatencyInMs;

        // Lifetime of the PC Site tickets in seconds (from IssueInstant)
        public int RpsPCLifetimeInSeconds;

        // Lifetime of the Xenon Site tickets in seconds (from IssueInstant)
        public int RpsXenonLifetimeInSeconds;

        // Valid PC Site names
        public string[] RpsPCSites;

        // Valid Xenon Site names
        public string[] RpsXenonSites;

        //The minimum lifetime of an XKDC ticket in seconds
        public int XkdcMinTicketLifetimeSeconds;

        //Retrieves the current configuration.
        public static ManagedConfig Get()
        {
            if (CurrentConfig == null)
            {
                ReadSettings();
            }

            return CurrentConfig;
        }

        //Duplicates the configuration by-value.
        public ManagedConfig Clone()
        {
            return (ManagedConfig)MemberwiseClone();
        }

        //

        private void SetMaxThreads(int dbValue)
        {
            if (dbValue <= 0 || dbValue < MaxThreads)
            {
                throw new System.ArgumentException(Setting.kdcsvc_core_ATQThreads + " is invalid.");
            }

            MaxThreads = dbValue;
        }

        private void SetDbLimiterThresholdForBlocking(double dbValue)
        {
            int newValue = (int)(dbValue / 100.0 * MaxThreads);

            if (newValue < 0 || newValue > MaxThreads)
            {
                throw new System.ArgumentException(Setting.kdcsvc_managed_limitThreadPercentThreshold + " is invalid.");
            }

            DbLimiterThresholdForBlocking = newValue;

            // Recalculate the unblocking threshold
            SetDbLimiterThresholdForUnblocking( _dbLimiterThresholdForUnblocking );
        }

        private void SetDbLimiterThresholdForUnblocking(double dbValue)
        {
            int newValue = (int)(dbValue / 100.0 * MaxThreads);

            if (newValue < 0 || newValue > MaxThreads)
            {
                throw new System.ArgumentException(Setting.kdcsvc_managed_limitThreadPercentDeactivationThreshold + " is invalid.");
            }
            _dbLimiterThresholdForUnblocking = dbValue;

            // The unblock value cannot exceed the block value
            if (newValue > DbLimiterThresholdForBlocking)
            {
                newValue = DbLimiterThresholdForBlocking;
            }
            
            // If blocking is enabled, the unblock value cannot be 0
            // as that will disable unblocking entirely
            if (DbLimiterThresholdForBlocking > 0 && newValue == 0)
            {
                newValue = 1;
            }
            DbLimiterThresholdForUnblocking = newValue;
        }

        private void SetDbLimiterMaxThreadsPerPartition(double dbValue)
        {
            int newValue = (int)(dbValue / 100.0 * MaxThreads);

            if (newValue < 0 || newValue > MaxThreads)
            {
                throw new System.ArgumentException(Setting.kdcsvc_managed_limitThreadPercentPerPartition + " is invalid.");
            }

            DbLimiterMaxThreadsPerPartition = newValue;
        }

        private void SetTimeBetweenPartitionThrottleEvents(int dbValueInSeconds)
        {
            if (dbValueInSeconds < 0)
            {
                throw new System.ArgumentException(Setting.kdcsvc_managed_limitEventWarnRecurranceInSeconds + " is invalid.");
            }

            DbLimiterTimeBetweenPartitionThrottleEventsInSeconds = dbValueInSeconds;
            DbLimiterTimeBetweenPartitionThrottleEventsAsTimeSpan = new System.TimeSpan(0, 0, dbValueInSeconds);
        }

        private void SetRpsPCLifetimeInSeconds(int lifetimeInSeconds)
        {
            if (lifetimeInSeconds < 0)
            {
                throw new System.ArgumentException(Setting.kdcsvc_managed_rpsPCLifetimeInSeconds + " is invalid.");
            }
            RpsPCLifetimeInSeconds = lifetimeInSeconds;
        }

        private void SetRpsXenonLifetimeInSeconds(int lifetimeInSeconds)
        {
            if (lifetimeInSeconds < 0)
            {
                throw new System.ArgumentException(Setting.kdcsvc_managed_rpsXenonLifetimeInSeconds + " is invalid.");
            }
            RpsXenonLifetimeInSeconds = lifetimeInSeconds;
        }

        private void SetRpsPCSites(string[] sites)
        {
            if (sites == null | sites.Length == 0)
            {
                throw new System.ArgumentException(MultiSetting.kdcsvc_managed_rpsPCSites + " is invalid.");
            }
            RpsPCSites = ManagedConfig.TrimAll(sites);
        }

        private void SetRpsXenonSites(string[] sites)
        {
            if (sites == null | sites.Length == 0)
            {
                throw new System.ArgumentException(MultiSetting.kdcsvc_managed_rpsXenonSites + " is invalid.");
            }
            RpsXenonSites = ManagedConfig.TrimAll(sites);
        }

        //

        private static ManagedConfig CurrentConfig;
        private static object ConfigLock = new object();

        ManagedConfig()
        {
            //Register setting changed handler
            Config.SettingChange += new SettingChangeEventHandler(OnSettingChange);

            //Register multisetting changed handler
            Config.MultiSettingChange += new MultiSettingChangeEventHandler(OnMultiSettingChange);

            //Register xmgmt command handler
            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(OnXmgmtRequest);
        }

        private static void OnXmgmtRequest(object sender, ControlRequestEventArgs args)
        {
            string cmd = args.Command.ToLower();

            switch (args.Command)
            {
                case "help":
                {
                    XomControlConnection.SendMessage(
                        "KdcManagedProxy Help:\r\n"+
                        "  dblimitersettings - Prints out the current settings that impact the DB limiter.\r\n"+
                        "  dblimiterstate    - Prints out the state of the DB limiter.\r\n",
                        args.RequestId);
                    args.Handled = true;
                    break;
                }
                case "dblimitersettings":
                {
                    XomControlConnection.SendMessage(
                        DbLimiter.GetSettingStateDump(),
                        args.RequestId);
                    args.Handled = true;
                    break;
                }
                case "dblimiterstate":
                {
                    XomControlConnection.SendMessage(
                        DbLimiter.GetStateDump(),
                        args.RequestId);
                    args.Handled = true;
                    break;
                }
            }
        }

        private static void OnSettingChange(object sender, SettingChangeEventArgs eventArgs)
        {
            if (CurrentConfig == null)
            {
                ReadSettings();
            }

            lock (ConfigLock)
            {
                ManagedConfig newConfig = CurrentConfig.Clone();

                switch (eventArgs.Setting)
                {
                    case Setting.kdcsvc_core_ATQThreads:
                    {
                        newConfig.SetMaxThreads(int.Parse(eventArgs.ValueNew));
                        break;
                    }
                    case Setting.kdcsvc_managed_limitThreadPercentThreshold:
                    {
                        newConfig.SetDbLimiterThresholdForBlocking(double.Parse(eventArgs.ValueNew));
                        break;
                    }
                    case Setting.kdcsvc_managed_limitThreadPercentDeactivationThreshold:
                    {
                        newConfig.SetDbLimiterThresholdForUnblocking(double.Parse(eventArgs.ValueNew));
                        break;
                    }
                    case Setting.kdcsvc_managed_limitThreadPercentPerPartition:
                    {
                        newConfig.SetDbLimiterMaxThreadsPerPartition(double.Parse(eventArgs.ValueNew));
                        break;
                    }
                    case Setting.kdcsvc_managed_simulateDbLatencyInMs:
                    {
                        newConfig.DbLimiterSimulateLatencyInMs = int.Parse(eventArgs.ValueNew);
                        break;
                    }
                    case Setting.kdcsvc_managed_limitEventWarnRecurranceInSeconds:
                    {
                        newConfig.SetTimeBetweenPartitionThrottleEvents(int.Parse(eventArgs.ValueNew));
                        break;
                    }
                    case Setting.kdcsvc_xkdc_minTicketLifetimeSeconds:
                    {
                        newConfig.XkdcMinTicketLifetimeSeconds = int.Parse(eventArgs.ValueNew);
                        break;
                    }
                    case Setting.kdcsvc_managed_rpsPCLifetimeInSeconds:
                    {
                        newConfig.SetRpsPCLifetimeInSeconds(int.Parse(eventArgs.ValueNew));
                        break;
                    }
                    case Setting.kdcsvc_managed_rpsXenonLifetimeInSeconds:
                    {
                        newConfig.SetRpsXenonLifetimeInSeconds(int.Parse(eventArgs.ValueNew));
                        break;
                    }
                }

                CurrentConfig = newConfig;
            }
        }

        private static void OnMultiSettingChange(object sender, MultiSettingChangeEventArgs eventArgs)
        {
            if (CurrentConfig == null)
            {
                ReadSettings();
            }
            lock (ConfigLock)
            {
                ManagedConfig newConfig = CurrentConfig.Clone();

                switch (eventArgs.MultiSetting)
                {
                    case MultiSetting.kdcsvc_managed_rpsPCSites:
                    {
                        newConfig.SetRpsPCSites( eventArgs.ValueNew );
                        break;
                    }
                    case MultiSetting.kdcsvc_managed_rpsXenonSites:
                    {
                        newConfig.SetRpsXenonSites( eventArgs.ValueNew );
                        break;
                    }
                }

                CurrentConfig = newConfig;
            }
        }

        private static void ReadSettings()
        {
            lock (ConfigLock)
            {
                //construct and validate the new config locally
                ManagedConfig newConfig = new ManagedConfig();

                newConfig.SetMaxThreads(Config.GetIntSetting(Setting.kdcsvc_core_ATQThreads));
                newConfig.SetDbLimiterThresholdForBlocking(Config.GetDoubleSetting(Setting.kdcsvc_managed_limitThreadPercentThreshold));
                newConfig.SetDbLimiterThresholdForUnblocking(Config.GetDoubleSetting(Setting.kdcsvc_managed_limitThreadPercentDeactivationThreshold));
                newConfig.SetDbLimiterMaxThreadsPerPartition(Config.GetDoubleSetting(Setting.kdcsvc_managed_limitThreadPercentPerPartition));
                newConfig.SetTimeBetweenPartitionThrottleEvents(Config.GetIntSetting(Setting.kdcsvc_managed_limitEventWarnRecurranceInSeconds));

                newConfig.SetRpsPCLifetimeInSeconds(Config.GetIntSetting(Setting.kdcsvc_managed_rpsPCLifetimeInSeconds));
                newConfig.SetRpsXenonLifetimeInSeconds(Config.GetIntSetting(Setting.kdcsvc_managed_rpsXenonLifetimeInSeconds));

                newConfig.SetRpsPCSites(Config.GetMultiSetting( MultiSetting.kdcsvc_managed_rpsPCSites));
                newConfig.SetRpsXenonSites(Config.GetMultiSetting( MultiSetting.kdcsvc_managed_rpsXenonSites));

                newConfig.DbLimiterSimulateLatencyInMs = Config.GetIntSetting(Setting.kdcsvc_managed_simulateDbLatencyInMs);
                newConfig.XkdcMinTicketLifetimeSeconds = Config.GetIntSetting(Setting.kdcsvc_xkdc_minTicketLifetimeSeconds);

                //replace the cached config with the new one
                CurrentConfig = newConfig;
            }
        }

        private static string[] TrimAll(string[] toTrim)
        {
            for (int i = 0; i < toTrim.Length; ++i)
            {
                toTrim[i] = toTrim[i].Trim();
            }
            return toTrim;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\kdcmanaged\Installer.cs ===
using System;
using System.ComponentModel;

using xonline.common.installer;
using xonline.common.mgmt;

namespace xonline.kdc.ManagedProxy
{
    [RunInstaller(true)]
    public class Installer : XomConfiguratorInstall
    {
    }

    [RunInstaller(true)]
    public class PerformanceCounterInstaller : XomPerformanceCounterInstall
    {
        public override bool IsInstallablePerformanceCounterCategory(Type t)
        {
            return
                t.Namespace == typeof(Installer).Namespace &&
                t.IsSubclassOf(typeof(XomPerformanceCounterCategory)) &&
                Attribute.IsDefined(t, typeof(XomPerformanceCounterCategoryAttr));
        }

        // Uses .Net libraries to open up each counter in the category. Should ensure
        // everything exists.

        protected override void VerifyCategory(Type categoryType)
        {
            if (!IsInstallablePerformanceCounterCategory(categoryType))
            {
                LogMessage("\t\tNot a valid XomPerformanceCounterCategory type: " + categoryType.ToString());
                throw new InvalidOperationException("Not a valid category type");
            }

            XomPerformanceCounterCategory o = (XomPerformanceCounterCategory)Activator.CreateInstance(categoryType);

            // The XomPerformanceCounterCategory constructor initializes perf
            // counters, which reads a value for each one. No exceptions == good to go
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\kdcmanaged\SvcAddVoucher.cs ===
using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Xml;
using System.Xml.XPath;
using System.Data;
using System.Data.SqlClient;
using System.IO;

using Microsoft.Webstore.WstClient;

using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.crypto;


namespace xonline.kdc.ManagedProxy
{
    public partial interface IKdcManagedProxy
    {
        void SvcAddVoucher(
            byte[]    VoucherHash, 
            Int64     OfferId, 
            Int32     UseCount, 
            Int32     VoucherStatusId, 
            bool      inScg, 
            bool      ConsoleVer, 
            out Int32 Ret
            );
    }

    public partial class KdcManagedProxyImpl : IKdcManagedProxy
    {
        public void SvcAddVoucher(
            byte[]    VoucherHash, 
            Int64     OfferId, 
            Int32     UseCount, 
            Int32     VoucherStatusId, 
            bool      InScg, 
            bool      ConsoleVer, 
            out Int32 Ret
            )
        {
            try
            {
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                File.AppendAllText("c:\\sql.log", "SvcAddVoucher\r\n");
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                SvcAddVoucherImpl.SvcAddVoucher(
                    VoucherHash, 
                    OfferId, 
                    UseCount, 
                    VoucherStatusId, 
                    InScg, 
                    ConsoleVer, 
                    out Ret
                    );
            }
            catch (Exception e)
            {
                if (!(e is PartitionTooBusyException))
                {
                    Xom.NtEvent(
                        XEvent.Id.KDC_KDCMANAGEDPROXY_INTEROP_26, 
                        e, 
                        "SvcAddVoucher failed."
                        );
                }
                throw;
            }
        }
    }

    internal static class SvcAddVoucherImpl
    {
        public static void SvcAddVoucher(
            byte[]    VoucherHash, 
            Int64     OfferId, 
            Int32     UseCount, 
            Int32     VoucherStatusId, 
            bool      InScg, 
            bool      ConsoleVer, 
            out Int32 Ret
            )
        {
            using (WSClient ws = new WSClient(ConfigUtil.TokendbWebstoreApp,CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.SetHashVal(BitConverter.ToInt64(VoucherHash, 0));
                ws.StoredProc = "dbo.p_svc_add_voucher";
                ws.AddParameter("@bin_voucher_hash", VoucherHash);
                ws.AddParameter("@bi_offer_id", OfferId);
                ws.AddParameter("@i_use_count", UseCount);
                ws.AddParameter("@si_hash_bucket", ws.Partition);
                ws.AddParameter("@i_voucher_status_id", VoucherStatusId);
                ws.AddParameter("@f_in_SCG", Convert.ToInt32(InScg));
                ws.AddParameter("@f_consolever", Convert.ToInt32(ConsoleVer));

                Ret = KdcManagedProxyUtil.ExecuteAndGetRetval(ws);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\kdcmanaged\XkdcGetServicePrincipal.cs ===
using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Xml;
using System.Xml.XPath;
using System.Data;
using System.Data.SqlClient;
using System.IO;

using Microsoft.Webstore.WstClient;

using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.crypto;


namespace xonline.kdc.ManagedProxy
{
    [ComVisible(true)]
    [StructLayout(LayoutKind.Sequential)]
    public struct XkdcServicePrincipal
    {
        public Int32  KeyCount;
        [MarshalAs(UnmanagedType.BStr)]
        public string CanonicalServiceName;
        [MarshalAs(UnmanagedType.BStr)]
        public string CanonicalDomainName;
        public Int32  PrincipalType;
        public Int32  PrincipalFlags;
        [MarshalAs(UnmanagedType.BStr)]
        public string Ip;
        [MarshalAs(UnmanagedType.BStr)]
        public string KerbServiceName;
        [MarshalAs(UnmanagedType.BStr)]
        public string KerbDomainName;
        public Int32  ServiceId;
        public Int32  TitleId;
        public Int32  TitleVersion;
        public Int32  TitleRegion;
        public Int16  Port;
        public bool   MachineOnly;
        public bool   ServiceAvailable;
        public Int32  TicketLifetimeSeconds;
        public Int32  MasterKeyVersion;
        public Int32  KeyVersion;
        public Int32  KeyLen;
        public byte[] Key;
        public Int32  AuthDataVersion;

        [ComVisible(false)]
        public Int32  SiteId;
        [ComVisible(false)]
        public Int32  KeyType;
    }

    public partial interface IKdcManagedProxy
    {
        void XkdcGetServicePrincipal(
            [MarshalAs(UnmanagedType.LPArray)] 
            out XkdcServicePrincipal[] ServicePrincipals,
            out UInt32                 cServicePrincipals
            );
    }

    public partial class KdcManagedProxyImpl : IKdcManagedProxy
    {
        public void XkdcGetServicePrincipal(
            [MarshalAs(UnmanagedType.LPArray)] 
            out XkdcServicePrincipal[] ServicePrincipals,
            out UInt32                 cServicePrincipals
            )
        {
            try
            {
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                File.AppendAllText("c:\\sql.log", "XkdcGetServicePrincipal\r\n");
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                XkdcGetServicePrincipalImpl.XkdcGetServicePrincipal(
                    out ServicePrincipals, 
                    out cServicePrincipals
                    );
            }
            catch (Exception e)
            {
				File.AppendAllText("c:\\sql.log", "XkdcGetServicePrincipal - e: "+ e.Message +"\r\n");
                if (!(e is PartitionTooBusyException))
                {
                    Xom.NtEvent(
                        XEvent.Id.KDC_KDCMANAGEDPROXY_INTEROP_24,
                        e,
                        "XkdcGetServicePrincipal failed."
                        );
                }
                throw;
            }
        }
    }
    internal static class XkdcGetServicePrincipalImpl
    {
        public static void XkdcGetServicePrincipal(
            [MarshalAs(UnmanagedType.LPArray)] 
            out XkdcServicePrincipal[] ServicePrincipals,
            out UInt32                 cServicePrincipals
            )
        {
			File.AppendAllText("c:\\sql.log", "XkdcGetServicePrincipal - #0\r\n");
            XkdcServicePrincipal[] servicePrincipalsForServiceInstances;
            XkdcServicePrincipal[] servicePrincipalsForServiceKeys;

			try
            {
				string connectionString = "Server=HBL\\SQLExpress;database=npdb;uid=sa;pwd=#r4T45$ffe;Trusted_Connection=False;";
				using (SqlConnection connection = new SqlConnection(connectionString))
				{
					File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");			
					File.AppendAllText("c:\\sql.log", "XkdcGetServicePrincipal\r\n");
					connection.Open();
					SqlCommand mySqlCommand = new SqlCommand("p_xkdc_get_service_principals", connection);
					mySqlCommand.CommandType = CommandType.StoredProcedure;
					
					using (SqlDataReader reader = mySqlCommand.ExecuteReader())
					{
						servicePrincipalsForServiceKeys = GetServicePrincipalsForServiceKeys(reader);
						File.AppendAllText("c:\\sql.log", "XkdcGetServicePrincipal - #2\r\n");
					}
				}
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");	
				
				connectionString = "Server=HBL\\SQLExpress;database=uodb;uid=sa;pwd=#r4T45$ffe;Trusted_Connection=False;";
				using (SqlConnection connection2 = new SqlConnection(connectionString))
				{
					File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");	
					File.AppendAllText("c:\\sql.log", "XkdcGetServicePrincipal\r\n");
					connection2.Open();
					SqlCommand mySqlCommand = new SqlCommand("p_service_instances_get_all", connection2);
					mySqlCommand.CommandType = CommandType.StoredProcedure;
					
					List<XkdcServicePrincipal> servicePrincipals2 = new List<XkdcServicePrincipal>();
					Dictionary<string,int> ordinals = new Dictionary<string,int>(); 
					   
					using (SqlDataReader reader = mySqlCommand.ExecuteReader())
					{
						File.AppendAllText("c:\\sql.log", "XkdcGetServicePrincipal - #4\r\n");
						ordinals["vc_kerb_service_name"] = reader.GetOrdinal("vc_kerb_service_name");
						ordinals["vc_kerb_domain_name"]  = reader.GetOrdinal("vc_kerb_domain_name");
						ordinals["i_service_id"]         = reader.GetOrdinal("i_service_id");
						ordinals["i_title_id"]           = reader.GetOrdinal("i_title_id");
						ordinals["i_title_version"]      = reader.GetOrdinal("i_title_version");
						ordinals["i_title_region"]       = reader.GetOrdinal("i_title_region");
						ordinals["i_port"]               = reader.GetOrdinal("i_port");
						ordinals["i_machine_only"]       = reader.GetOrdinal("i_machine_only");
						ordinals["i_service_available"]  = reader.GetOrdinal("i_service_available");
						ordinals["i_site_id"]            = reader.GetOrdinal("i_site_id");

						while (reader.Read())
						{
							File.AppendAllText("c:\\sql.log", "XkdcGetServicePrincipal - #5\r\n");
							XkdcServicePrincipal servicePrincipal = new XkdcServicePrincipal();

							servicePrincipal.KerbServiceName  = reader.GetString(ordinals["vc_kerb_service_name"]);
							servicePrincipal.KerbDomainName   = reader.GetString(ordinals["vc_kerb_domain_name"]);
							servicePrincipal.ServiceId        = reader.GetInt32(ordinals["i_service_id"]);
							servicePrincipal.TitleId          = reader.GetInt32(ordinals["i_title_id"]);
							servicePrincipal.TitleVersion     = reader.GetInt32(ordinals["i_title_version"]);
							servicePrincipal.TitleRegion      = reader.GetInt32(ordinals["i_title_region"]);
							servicePrincipal.Port             = (Int16)reader.GetInt32(ordinals["i_port"]);
							servicePrincipal.MachineOnly      = Convert.ToBoolean(reader.GetInt32(ordinals["i_machine_only"]));
							servicePrincipal.ServiceAvailable = Convert.ToBoolean(reader.GetInt32(ordinals["i_service_available"]));
							servicePrincipal.SiteId           = reader.GetInt32(ordinals["i_site_id"]);

							servicePrincipals2.Add(servicePrincipal);
						}
					}
					File.AppendAllText("c:\\sql.log", "XkdcGetServicePrincipal - #6\r\n");
					servicePrincipalsForServiceInstances = servicePrincipals2.ToArray();
				}
					File.AppendAllText("c:\\sql.log", "XkdcGetServicePrincipal - #7\r\n");
					ServicePrincipals = CombineServiceKeysAndServiceInstances(servicePrincipalsForServiceKeys, servicePrincipalsForServiceInstances);
					cServicePrincipals = (uint) ServicePrincipals.Length;
					File.AppendAllText("c:\\sql.log", "XkdcGetServicePrincipal - #8\r\n");
					File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");	
			}
			catch (Exception e)
            {
				File.AppendAllText("c:\\sql.log", "XkdcGetServicePrincipal - e: "+ e.Message +"\r\n");
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");	
				ServicePrincipals = null;
				cServicePrincipals = (uint)0;
			}
		}

        // Stitch service keys from NPDB and service instances from UODB into a single recordset
        // based on rules from previous get_service_principals sproc
        //
        // Records are sorted by this order:
        // * SiteId
        // * ServiceId
        // * TitleId DESC
        // * TitleVersion DESC
        // * TitleRegion DESC
        // * MasterKeyVersion DESC
        // * KeyVersion DESC
        //
        // In the middle where SiteId is 0, we need to put in a special record for KeyType = 2
        private static XkdcServicePrincipal[] CombineServiceKeysAndServiceInstances(
            XkdcServicePrincipal[] servicePrincipalsForServiceKeys,
            XkdcServicePrincipal[] servicePrincipalsForServiceInstances
            )
        {
			File.AppendAllText("c:\\sql.log", "CombineServiceKeysAndServiceInstances\r\n");
            List<XkdcServicePrincipal> servicePrincipals = new List<XkdcServicePrincipal>();

            foreach (int siteId in GetAllSiteIds(servicePrincipalsForServiceKeys))
            {
                XkdcServicePrincipal[] spServiceKeysWithSiteId = GetServicePrincipalsWithSiteId(
                    servicePrincipalsForServiceKeys, 
                    siteId
                    );

                XkdcServicePrincipal[] spServiceInstancesWithSiteId = GetServicePrincipalsWithSiteId(
                    servicePrincipalsForServiceInstances, 
                    siteId
                    );

                if (spServiceInstancesWithSiteId.Length == 0)
                {
                    foreach (XkdcServicePrincipal serviceKey in spServiceKeysWithSiteId)
                    {
                        if (serviceKey.KeyType == 2)
                        {
                            XkdcServicePrincipal servicePrincipal = new XkdcServicePrincipal();

                            CopyServiceKeyValues(ref servicePrincipal, serviceKey);
                            servicePrincipal.KerbDomainName = servicePrincipal.CanonicalDomainName;
                            servicePrincipal.KerbServiceName = servicePrincipal.CanonicalServiceName;
                            servicePrincipal.ServiceId = 0;
                            servicePrincipal.TitleId = 0;
                            servicePrincipal.TitleVersion = 0;
                            servicePrincipal.TitleRegion = 0;
                            servicePrincipal.Port = 0;
                            servicePrincipal.MachineOnly = false;
                            servicePrincipal.ServiceAvailable = false;

                            servicePrincipals.Add(servicePrincipal);
                        }
                    }
                }
                else
                {
                    foreach (XkdcServicePrincipal serviceInstance in spServiceInstancesWithSiteId)
                    {
                        foreach (XkdcServicePrincipal serviceKey in spServiceKeysWithSiteId)
                        {
                            XkdcServicePrincipal servicePrincipal = new XkdcServicePrincipal();

                            CopyServiceInstancesValues(ref servicePrincipal, serviceInstance);
                            CopyServiceKeyValues(ref servicePrincipal, serviceKey);

                            servicePrincipals.Add(servicePrincipal);
                        }
                    }
                }
            }

            return servicePrincipals.ToArray();
        }

        private static XkdcServicePrincipal[] GetServicePrincipalsWithSiteId(
            XkdcServicePrincipal[] servicePrincipals, 
            int                    siteId
            )
        {
			File.AppendAllText("c:\\sql.log", "GetServicePrincipalsWithSiteId\r\n");
            return Array.FindAll<XkdcServicePrincipal>(
                servicePrincipals,
                delegate(XkdcServicePrincipal servicePrincipal)
                {
                    return servicePrincipal.SiteId == siteId;
                }
            );
        }

        private static int[] GetAllSiteIds(XkdcServicePrincipal[] servicePrincipals)
        {
            List<int> siteIds = new List<int>();
			File.AppendAllText("c:\\sql.log", "GetAllSiteIds\r\n");
            Array.ForEach<XkdcServicePrincipal>(
                servicePrincipals,
                delegate(XkdcServicePrincipal servicePrincipal)
                {
                    if (!siteIds.Contains(servicePrincipal.SiteId))
                    {
                        siteIds.Add(servicePrincipal.SiteId);
                    }
                }
            );

            return siteIds.ToArray();
        }

        private static void CopyServiceInstancesValues(
            ref XkdcServicePrincipal servicePrincipal, 
            XkdcServicePrincipal     servicePrincipalWithServiceInstances
            )
        {
			File.AppendAllText("c:\\sql.log", "CopyServiceInstancesValues\r\n");
            servicePrincipal.KerbServiceName = servicePrincipalWithServiceInstances.KerbServiceName;
            servicePrincipal.KerbDomainName = servicePrincipalWithServiceInstances.KerbDomainName;
            servicePrincipal.ServiceId = servicePrincipalWithServiceInstances.ServiceId;
            servicePrincipal.TitleId = servicePrincipalWithServiceInstances.TitleId;
            servicePrincipal.TitleVersion = servicePrincipalWithServiceInstances.TitleVersion;
            servicePrincipal.TitleRegion = servicePrincipalWithServiceInstances.TitleRegion;
            servicePrincipal.Port = servicePrincipalWithServiceInstances.Port;
            servicePrincipal.MachineOnly = servicePrincipalWithServiceInstances.MachineOnly;
            servicePrincipal.ServiceAvailable = servicePrincipalWithServiceInstances.ServiceAvailable;
        }

        private static void CopyServiceKeyValues(
            ref XkdcServicePrincipal servicePrincipal, 
            XkdcServicePrincipal     servicePrincipalWithServiceKeys
            )
        {
			File.AppendAllText("c:\\sql.log", "CopyServiceKeyValues\r\n");
            servicePrincipal.KeyCount = servicePrincipalWithServiceKeys.KeyCount;
            servicePrincipal.CanonicalServiceName = servicePrincipalWithServiceKeys.CanonicalServiceName;
            servicePrincipal.CanonicalDomainName = servicePrincipalWithServiceKeys.CanonicalDomainName;
            servicePrincipal.PrincipalType = servicePrincipalWithServiceKeys.PrincipalType;
            servicePrincipal.PrincipalFlags = servicePrincipalWithServiceKeys.PrincipalFlags;
            servicePrincipal.Ip = servicePrincipalWithServiceKeys.Ip;
            servicePrincipal.TicketLifetimeSeconds = servicePrincipalWithServiceKeys.TicketLifetimeSeconds;
            servicePrincipal.MasterKeyVersion = servicePrincipalWithServiceKeys.MasterKeyVersion;
            servicePrincipal.KeyVersion = servicePrincipalWithServiceKeys.KeyVersion;
            servicePrincipal.KeyLen = servicePrincipalWithServiceKeys.KeyLen;
            servicePrincipal.Key = servicePrincipalWithServiceKeys.Key;
            servicePrincipal.AuthDataVersion = servicePrincipalWithServiceKeys.AuthDataVersion;
        }

        private static XkdcServicePrincipal[] GetServicePrincipalsForServiceKeys(
            SqlDataReader reader
            )
        {
			File.AppendAllText("c:\\sql.log", "GetServicePrincipalsForServiceKeys\r\n");
			
            List<XkdcServicePrincipal> servicePrincipals = new List<XkdcServicePrincipal>();
            Dictionary<string,int> ordinals = new Dictionary<string,int>(); 

            ordinals["i_key_count"]               = reader.GetOrdinal("i_key_count");
            ordinals["vc_canonical_service_name"] = reader.GetOrdinal("vc_canonical_service_name");
            ordinals["vc_canonical_domain_name"]  = reader.GetOrdinal("vc_canonical_domain_name");
            ordinals["i_principal_type"]          = reader.GetOrdinal("i_principal_type");
            ordinals["i_principal_flags"]         = reader.GetOrdinal("i_principal_flags");
            ordinals["vc_ip"]                     = reader.GetOrdinal("vc_ip");
            ordinals["i_ticket_lifetime_secs"]    = reader.GetOrdinal("i_ticket_lifetime_secs");
            ordinals["i_master_key_version"]      = reader.GetOrdinal("i_master_key_version");
            ordinals["i_key_version"]             = reader.GetOrdinal("i_key_version");
            ordinals["i_key_len"]                 = reader.GetOrdinal("i_key_len");
            ordinals["bin_key"]                   = reader.GetOrdinal("bin_key");
            ordinals["i_authdata_version"]        = reader.GetOrdinal("i_authdata_version");
            ordinals["i_site_id"]                 = reader.GetOrdinal("i_site_id");
            ordinals["i_key_type"]                = reader.GetOrdinal("i_key_type");

            while (reader.Read())
            {
                // PS 135507
                // 
                // We allow nulls for vc_ip in t_site_virtual_interface_ips but not
                // in the xkdc, so skip over those rows
                if (reader.IsDBNull(ordinals["vc_ip"]) == true)
                {
                    continue;
                }

                XkdcServicePrincipal servicePrincipal = new XkdcServicePrincipal();

                servicePrincipal.KeyCount              = reader.GetInt32(ordinals["i_key_count"]);
                servicePrincipal.CanonicalServiceName  = reader.GetString(ordinals["vc_canonical_service_name"]);
                servicePrincipal.CanonicalDomainName   = reader.GetString(ordinals["vc_canonical_domain_name"]);
                servicePrincipal.Ip                    = reader.GetString(ordinals["vc_ip"]);
                servicePrincipal.PrincipalType         = reader.GetInt32(ordinals["i_principal_type"]);
                servicePrincipal.PrincipalFlags        = reader.GetInt32(ordinals["i_principal_flags"]);
                servicePrincipal.TicketLifetimeSeconds = reader.GetInt32(ordinals["i_ticket_lifetime_secs"]);
                servicePrincipal.MasterKeyVersion      = reader.GetInt32(ordinals["i_master_key_version"]);
                servicePrincipal.KeyVersion            = reader.GetInt32(ordinals["i_key_version"]);
                servicePrincipal.KeyLen                = reader.GetInt32(ordinals["i_key_len"]);
                servicePrincipal.AuthDataVersion       = reader.GetInt32(ordinals["i_authdata_version"]);
                servicePrincipal.SiteId                = reader.GetInt32(ordinals["i_site_id"]);
                servicePrincipal.KeyType               = reader.GetInt32(ordinals["i_key_type"]);

                servicePrincipal.Key = new byte[servicePrincipal.KeyLen];
                reader.GetBytes(ordinals["bin_key"], 0, servicePrincipal.Key, 0, servicePrincipal.KeyLen);

                servicePrincipals.Add(servicePrincipal);
            }

            return servicePrincipals.ToArray();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\kdcmanaged\XkdcGetTitleVersionInfo.cs ===
using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Xml;
using System.Xml.XPath;
using System.Data;
using System.Data.SqlClient;
using System.IO;

using Microsoft.Webstore.WstClient;

using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.crypto;


namespace xonline.kdc.ManagedProxy
{
    [ComVisible(true)]
    [StructLayout(LayoutKind.Sequential)]
    public struct XkdcTitleVersionInfo
    {
        public Int32    TitleId;
        public Int32    TitleRegion;
        public Int32    MediaId;
        public Int32    BaseVersion;
        public Int32    UpdateVersion;
        public Int32    BetaVersion;
        public Int32    LiveTitleId;
        public Int32    AlternateId1;
        public Int32    AlternateId2;
        public Int32    AlternateId3;
        public Int32    AlternateId4;
        public Int32    Service1;
        public Int32    Service1AltId;
        public Int32    Service2;
        public Int32    Service2AltId;
        public Int32    Service3;
        public Int32    Service3AltId;
        public Int32    Service4;
        public Int32    Service4AltId;
        public byte     ConsoleTypeId;
        public Guid     GroupGuid;
        public DateTime StartTime;
        public DateTime EndTime;
    }

    public partial interface IKdcManagedProxy
    {
        void XkdcGetTitleVersionInfo(
            [MarshalAs(UnmanagedType.LPArray)] 
            out XkdcTitleVersionInfo[] TitleVersionInfos,
            out UInt32                 cTitleVersionInfos
            );
    }

    public partial class KdcManagedProxyImpl : IKdcManagedProxy
    {
        public void XkdcGetTitleVersionInfo(
            [MarshalAs(UnmanagedType.LPArray)] 
            out XkdcTitleVersionInfo[] TitleVersionInfos,
            out UInt32                 cTitleVersionInfos
            )
        {
            try
            {
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                File.AppendAllText("c:\\sql.log", "XkdcGetTitleVersionInfo\r\n");
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                XkdcGetTitleVersionInfoImp.XkdcGetTitleVersionInfo(
                    out TitleVersionInfos, 
                    out cTitleVersionInfos
                    );
            }
            catch (Exception e)
            {
				File.AppendAllText("c:\\sql.log", "XkdcGetTitleVersionInfo - e: "+ e.Message +"\r\n");
                if (!(e is PartitionTooBusyException))
                {
                    Xom.NtEvent(
                        XEvent.Id.KDC_KDCMANAGEDPROXY_INTEROP_25,
                        e,
                        "XkdcGetTitleVersionInfo failed."
                        );
                }
                throw;
            }
        }
    }

    internal static class XkdcGetTitleVersionInfoImp
    {
        public static void XkdcGetTitleVersionInfo(
            out XkdcTitleVersionInfo[] TitleVersionInfos, 
            out UInt32                 cTitleVersionInfos
            )
        {
			string connectionString = "Server=HBL\\SQLExpress;database=uodb;uid=sa;pwd=#r4T45$ffe;Trusted_Connection=False;";
			using (SqlConnection connection2 = new SqlConnection(connectionString))
			{
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");			
				File.AppendAllText("c:\\sql.log", "XkdcGetTitleVersionInfo\r\n");
				
				connection2.Open();
				SqlCommand mySqlCommand = new SqlCommand("p_xkdc_get_title_version_info", connection2);
				mySqlCommand.CommandType = CommandType.StoredProcedure;
				
			    using (SqlDataReader reader = mySqlCommand.ExecuteReader())
				{
					int num = 0;
					if (!reader.Read())
					{
						File.AppendAllText("c:\\sql.log", "No result set for the number of elements expected.  Please ensure UODB is properly configured.\r\n");
						string error = "No result set for the number of elements expected.  Please ensure UODB is properly configured.";
						Xom.NtEvent(
							XEvent.Id.ASKDC_WSREADER_ERROR_31, 
							error
							);
						throw new Exception(error);
					}

					num = reader.GetInt32(0);
					List<XkdcTitleVersionInfo> titleVersionInfos = new List<XkdcTitleVersionInfo>((int)num);

					File.AppendAllText("c:\\sql.log", "titleVersionInfos Test.\r\n");
					
					while (reader.Read())
					{
						XkdcTitleVersionInfo titleVersionInfo = new XkdcTitleVersionInfo();

						titleVersionInfo.TitleId       = reader.GetInt32(0);
						titleVersionInfo.TitleRegion   = reader.GetInt32(1);
						titleVersionInfo.MediaId       = reader.GetInt32(2);
						titleVersionInfo.BaseVersion   = reader.GetInt32(3);
						titleVersionInfo.UpdateVersion = reader.GetInt32(4);
						titleVersionInfo.BetaVersion   = reader.GetInt32(5);
						titleVersionInfo.LiveTitleId   = reader.GetInt32(6);
						titleVersionInfo.AlternateId1  = reader.GetInt32(7);
						titleVersionInfo.AlternateId2  = reader.GetInt32(8);
						titleVersionInfo.AlternateId3  = reader.GetInt32(9);
						titleVersionInfo.AlternateId4  = reader.GetInt32(10);
						titleVersionInfo.Service1      = reader.GetInt32(11);
						titleVersionInfo.Service1AltId = reader.GetInt32(12);
						titleVersionInfo.Service2      = reader.GetInt32(13);
						titleVersionInfo.Service2AltId = reader.GetInt32(14);
						titleVersionInfo.Service3      = reader.GetInt32(15);
						titleVersionInfo.Service3AltId = reader.GetInt32(16);
						titleVersionInfo.Service4      = reader.GetInt32(17);
						titleVersionInfo.Service4AltId = reader.GetInt32(18);
						titleVersionInfo.ConsoleTypeId = reader.GetByte(19);
						titleVersionInfo.GroupGuid     = reader.GetGuid(20);
						titleVersionInfo.StartTime     = reader.GetDateTime(21);
						titleVersionInfo.EndTime       = reader.GetDateTime(22);

						File.AppendAllText("c:\\sql.log", "titleVersionInfo Test.\r\n");
						
						titleVersionInfos.Add(titleVersionInfo);
					}
					
					TitleVersionInfos = titleVersionInfos.ToArray();
					cTitleVersionInfos = (uint) TitleVersionInfos.Length;
					File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");	
				}
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\kdcmanaged\PerfCounters.cs ===
using System;
using System.Diagnostics;

using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.kdc.ManagedProxy
{
    [XomPerformanceCounterCategoryAttr( "KDC Svc - Managed - DB Limiter", "Performance counters of the KdcManagedProxy's DB Limiter", true )]
    public class DbLimiterCounter : XomPerformanceCounterCategory
    {
        // Publicly visible static instance
        static public DbLimiterCounter Counters = new DbLimiterCounter();

        // Publicly visible getter
        public DbLimiterCounter this[string instance]
        {
            get 
            {
                return (DbLimiterCounter) GetInstance( instance );
            }
        }

        // Reset the 'of Request' values. Done while the partion lock is held
        public void Reset()
        {
            TotalRequests.RawValue = 0;
            TotalThrottles.RawValue = 0;
            PerSecondRequests.RawValue = 0;
            PerSecondThrottles.RawValue = 0;
            PercentageThrottles.RawValue = 0;
            PercentageBaseThrottle.RawValue = 0;
        }

        // Case where the request was throttled
        public void Throttle()
        {
            TotalRequests.Increment();
            TotalThrottles.Increment();
            PerSecondRequests.Increment();
            PerSecondThrottles.Increment();
            PercentageBaseThrottle.Increment();
            PercentageThrottles.Increment();
        }

        // Case where the request was allowed
        public void Acquire()
        {
            ActiveThreads.Increment();
            TotalRequests.Increment();
            PerSecondRequests.Increment();
            PercentageBaseThrottle.Increment();
        }

        // Case where the request was completed
        public void Release(long timeElapsed)
        {
            ActiveThreads.Decrement();
            AverageExecutionTime.IncrementBy(timeElapsed);
            AverageExecutionTimeBase.Increment();
        }

        [XomPerformanceCounterAttr("Threads, Active", "Number of Threads active in Partition", PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter ActiveThreads;

        [XomPerformanceCounterAttr("Requests, Total", "Number of requests made in Partition", PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequests;

        [XomPerformanceCounterAttr("Requests, Per Sec", "Number of requests made in Partition per second", PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter PerSecondRequests;

        [XomPerformanceCounterAttr("Requests, Avg. Execution Time (in ms)", "Average request execution time in the current partition (in ms)", PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageExecutionTime;

        [XomPerformanceCounterAttr("Requests, Avg. Execution Time (base)", "Base for the average request execution time in the current partition", PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageExecutionTimeBase;

        [XomPerformanceCounterAttr("Throttles, Total", "Number of requests failed in Partition", PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalThrottles;

        [XomPerformanceCounterAttr("Throttles, Per Sec", "Number of requests failed in Partition per second", PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter PerSecondThrottles;

        [XomPerformanceCounterAttr("Throttles, Percentage", "Number of requests throttled as a percentage", PerformanceCounterType.SampleFraction)]
        public PerformanceCounter PercentageThrottles;

        [XomPerformanceCounterAttr("Throttles, Percentage Base", "Base for Number of requests throttled as a percentage", PerformanceCounterType.SampleBase)]
        public PerformanceCounter PercentageBaseThrottle;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\kdcmanaged\XkdcGetMachineAuthorization.cs ===
using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Xml;
using System.Xml.XPath;
using System.Data;
using System.Data.SqlClient;

using Microsoft.Webstore.WstClient;

using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.crypto;


namespace xonline.kdc.ManagedProxy
{
    [ComVisible(true)]
    [StructLayout(LayoutKind.Sequential)]
    public struct XkdcMachineAuthorization
    {
        public bool     IsDataPresent;
        public UInt64   MachinePuid;
        public DateTime ResetDate;
        public Int32    BetaTitleId;
        public Int32    CertConsoleType;
        [MarshalAs(UnmanagedType.BStr)]
        public string   FlashVersion;
        public bool     ActivationRequired;
        public bool     ActivatedOtherTitle;
        public Int32    ConsoleRegion;
        public DateTime BlockEndTime;
        public UInt32   BlockStatusCode;
    }

    public partial interface IKdcManagedProxy
    {
        void XkdcGetMachineAuthorization(
            UInt64                       MachinePuid,
            UInt64                       UserPuid0,
            UInt64                       UserPuid1,
            UInt64                       UserPuid2,
            UInt64                       UserPuid3,
            bool                         AutoDiscover,
            UInt32                       TitleId,
            UInt32                       PlatformType,
            out XkdcMachineAuthorization MachineAuthorization,
            out Int32[]                  ServiceIds,
            out Guid[]                   GroupIds
            );
    }

    public partial class KdcManagedProxyImpl : IKdcManagedProxy
    {
        public void XkdcGetMachineAuthorization(
            UInt64                       MachinePuid,
            UInt64                       UserPuid0,
            UInt64                       UserPuid1,
            UInt64                       UserPuid2,
            UInt64                       UserPuid3,
            bool                         AutoDiscover,
            UInt32                       TitleId,
            UInt32                       PlatformType,
            out XkdcMachineAuthorization MachineAuthorization,
            out Int32[]                  ServiceIds,
            out Guid[]                   GroupIds
            )
        {
            try
            {
                XkdcGetMachineAuthorizationImpl.XkdcGetMachineAuthorization(
                    MachinePuid, 
                    UserPuid0,
                    UserPuid1,
                    UserPuid2,
                    UserPuid3,
                    AutoDiscover, 
                    TitleId, 
                    PlatformType, 
                    out MachineAuthorization, 
                    out ServiceIds, 
                    out GroupIds
                    );
            }
            catch (Exception e)
            {
                if (!(e is PartitionTooBusyException))
                {
                    Xom.NtEvent(
                        XEvent.Id.KDC_KDCMANAGEDPROXY_INTEROP_20,
                        e,
                        "XkdcGetMachineAuthorization failed"
                        );
                }
                throw;
            }
        }
    }

    internal static class XkdcGetMachineAuthorizationImpl
    {
        public static void XkdcGetMachineAuthorization(
            UInt64                       MachinePuid,
            UInt64                       UserPuid0,
            UInt64                       UserPuid1,
            UInt64                       UserPuid2,
            UInt64                       UserPuid3,
            bool                         AutoDiscover,
            UInt32                       TitleId,
            UInt32                       PlatformType,
            out XkdcMachineAuthorization MachineAuthorization,
            out Int32[]                  ServiceIds,
            out Guid[]                   GroupIds
            )
        {
            using (WSClient ws = KdcManagedProxyUtil.BuildWSClient("p_xkdc_get_machine_authorization", false))
            {
                // Check that all of the partitions aren't blocked
                DbLimiter.CheckAvailability( ws, UserPuid0 );
                DbLimiter.CheckAvailability( ws, UserPuid1 );
                DbLimiter.CheckAvailability( ws, UserPuid2 );
                DbLimiter.CheckAvailability( ws, UserPuid3 );

                ws.SetHashVal(MachinePuid);
                ws.AddParameter("@bi_machine_puid", MachinePuid);
                ws.AddParameter("@f_auto_discover", Convert.ToInt32(AutoDiscover));
                ws.AddParameter("@i_title_id", TitleId);
                ws.AddParameter("@i_platform_type", PlatformType);

                using (WstDataReader response = KdcManagedProxyUtil.ExecuteSproc(ws))
                {
                    MachineAuthorization = GetMachineAuthorization(response);
                    ServiceIds = GetServiceIds(AutoDiscover, response);
                    GroupIds = GetGroupIds(response);
                }
            }
        }

        private static XkdcMachineAuthorization GetMachineAuthorization(
            WstDataReader reader
            )
        {
            // This is really more "machine info" than "machine authorization"
            XkdcMachineAuthorization machineAuthorization = new XkdcMachineAuthorization();

            if (reader.Read())
            {
                bool machineBlocked;

                machineAuthorization.MachinePuid         = (ulong)reader.GetInt64(0);
                machineBlocked                           = Convert.ToBoolean(reader.GetInt32(1));
                machineAuthorization.ResetDate           = reader.GetDateTime(2);
                machineAuthorization.BetaTitleId         = reader.GetInt32(3);
                machineAuthorization.CertConsoleType     = reader.GetInt32(4);
                machineAuthorization.FlashVersion        = reader.GetString(5);
                machineAuthorization.ActivationRequired  = Convert.ToBoolean(reader.GetInt32(6));
                machineAuthorization.ActivatedOtherTitle = Convert.ToBoolean(reader.GetInt32(7));
                machineAuthorization.ConsoleRegion       = reader.GetInt32(8);
                machineAuthorization.IsDataPresent       = true;

                // These fields were added as part of DCI and not always part of
                // the return set from p_xkdc_get_machine_authorization
                if (reader.FieldCount >= 10 && reader.IsDBNull(9) == false)
                {
                    machineAuthorization.BlockStatusCode = (uint) reader.GetInt32(9);
                }
                else if (machineBlocked == true)
                {
                    // The historical defaults of banned machines
                    machineAuthorization.BlockStatusCode = HResult.XONLINE_E_LOGON_XBOX_ACCOUNT_BANNED;
                }
                else
                {
                    // Machine Not banned at all. Put in reasonable values
                    machineAuthorization.BlockStatusCode = 0;
                }

                if (reader.FieldCount >= 11&& reader.IsDBNull(10) == false)
                {
                    machineAuthorization.BlockEndTime    = reader.GetDateTime(10);
                }
                else if (machineBlocked == true)
                {
                    // The historical defaults of banned machines
                    machineAuthorization.BlockEndTime    = DateTime.MaxValue;
                }
                else
                {
                    // Machine Not banned at all. Put in reasonable values
                    machineAuthorization.BlockEndTime    = DateTime.MinValue;
                }
            }

            return machineAuthorization;
        }

        private static int[] GetServiceIds(
            bool          AutoDiscover, 
            WstDataReader reader
            )
        {
            List<int> serviceIds = new List<int>();
            if (AutoDiscover && reader.NextResult())
            {
                while (reader.Read())
                {
                    serviceIds.Add(reader.GetInt32(0));
                }
            }
            return serviceIds.ToArray();
        }

        private static Guid[] GetGroupIds(
            WstDataReader reader
            )
        {
            List<Guid> groupIds = new List<Guid>();

            if (reader.NextResult())
            {
                while(reader.Read())
                {
                    groupIds.Add(reader.GetGuid(0));
                }
            }
            return groupIds.ToArray();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\kdcmanaged\XkdcGetTitleVersionUpdateDateTime.cs ===
using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Xml;
using System.Xml.XPath;
using System.Data;
using System.Data.SqlClient;
using System.IO;

using Microsoft.Webstore.WstClient;

using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.crypto;


namespace xonline.kdc.ManagedProxy
{
    public partial interface IKdcManagedProxy
    {
        void XkdcGetTitleVersionUpdateDateTime(
            out DateTime cTitleVersionInfos
            );
    }

    public partial class KdcManagedProxyImpl : IKdcManagedProxy
    {
        public void XkdcGetTitleVersionUpdateDateTime(
            out DateTime cTitleVersionInfos
            )
        {
            try
            {
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                File.AppendAllText("c:\\sql.log", "XkdcGetTitleVersionUpdateDateTime\r\n");
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                XkdcGetTitleVersionUpdateDateTimeImp.XkdcGetTitleVersionUpdateDateTime(
                    out cTitleVersionInfos
                    );
            }
            catch (Exception e)
            {
                if (!(e is PartitionTooBusyException))
                {
                    Xom.NtEvent(
                        XEvent.Id.KDC_KDCMANAGEDPROXY_INTEROP_25,
                        e,
                        "XkdcGetTitleVersionUpdateDateTime failed."
                        );
                }
                throw;
            }
        }
    }

    internal static class XkdcGetTitleVersionUpdateDateTimeImp
    {
        public static void XkdcGetTitleVersionUpdateDateTime(
            out DateTime updateTime
            )
        {
            using (WSClient ws = KdcManagedProxyUtil.BuildWSClient("p_xkdc_get_title_version_change_datetime", false))
            {
                ws.Partition = WSClient.ANY_PARTITION;
                using (WstDataReader response = KdcManagedProxyUtil.ExecuteSproc(ws))
                {
                    if (!response.Read())
                    {
                        string error = "No result set for p_xkdc_get_title_version_change_datetime.  Please ensure UODB is properly configured.";
                        Xom.NtEvent(
                            XEvent.Id.ASKDC_NO_MEMORY_23, 
                            error
                            );
                        throw new Exception(error);
                    }
                    updateTime = response.GetDateTime(0);
                }
            }
        }
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\kdcmanaged\XkdcGetUserAuthorizationAndPrivileges.cs ===
using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Xml;
using System.Xml.XPath;
using System.Data;
using System.Data.SqlClient;

using Microsoft.Webstore.WstClient;

using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;


namespace xonline.kdc.ManagedProxy
{
    [ComVisible(true)]
    [StructLayout(LayoutKind.Sequential)]
    public struct XkdcUserAuthorizationXbox1_1
    {
        public bool IsDataPresent;
        public Int32 TicketFlags;
        public Int32 CountryId;
        public bool AcceptedTos;
        public bool VoiceBanned;
        public bool AccountSuspended;
        public Int32 BillingAccountStatus;
        public bool NameChangeRequired;
        public DateTime PasswordResetTime;

        internal void Read(WstDataReader reader)
        {
            IsDataPresent        = true;

            TicketFlags          = reader.GetInt32(0);
            CountryId            = reader.GetInt32(1);
            AcceptedTos          = Convert.ToBoolean(reader.GetInt32(2));
            VoiceBanned          = Convert.ToBoolean(reader.GetInt32(3));
            AccountSuspended     = Convert.ToBoolean(reader.GetInt32(4));
            BillingAccountStatus = reader.GetInt32(5);
            NameChangeRequired   = Convert.ToBoolean(reader.GetInt32(6));
            PasswordResetTime    = reader.GetDateTime(7);
        }
    }

    [ComVisible(true)]
    [StructLayout(LayoutKind.Sequential)]
    public struct XkdcUserAuthorizationXbox1_2
    {
        public Int32 ServiceId;
        public bool SubscriptionStatusId;

        internal XkdcUserAuthorizationXbox1_2(WstDataReader reader)
        {
            ServiceId = reader.GetFieldType(0) == typeof(System.Byte) ? reader.GetByte(0) : reader.GetInt32(0);
            SubscriptionStatusId = reader.FieldCount > 1 ? Convert.ToBoolean(reader.GetInt32(1)) : false;
        }
    }

    [ComVisible(true)]
    [StructLayout(LayoutKind.Sequential)]
    public struct XkdcUserAuthorizationXbox1_3
    {
        public bool IsDataSetPresent;
        public bool IsDataPresent;
        public Single TrustRatingFactor;
        public Single CollectiveSessionDisconnectsAvg;
        public Single SessionDisconnectsAvg;
        public Single CollectiveNoShowAvg;
        public Single NoShowAvg;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
        public byte[] TitleSessionDisconnectRatios;

        internal void Read(WstDataReader reader)
        {
            IsDataPresent = true;

            TrustRatingFactor               = reader.GetFloat(0);
            CollectiveSessionDisconnectsAvg = reader.GetFloat(1);
            SessionDisconnectsAvg           = reader.GetFloat(2);
            CollectiveNoShowAvg             = reader.GetFloat(3);
            NoShowAvg                       = reader.GetFloat(4);
            TitleSessionDisconnectRatios    = new byte[8];

            for (int i = 0; i < TitleSessionDisconnectRatios.Length; ++i) {
                TitleSessionDisconnectRatios[i] = reader.GetByte(5 + i);
            }
        }
    }

    [ComVisible(true)]
    [StructLayout(LayoutKind.Sequential)]
    public struct XkdcUserAuthorizationAndPrivileges_1
    {
        public XkdcUserAuthorizationXbox1_1 UserAuthorizationXbox1_1;
        public Int32 TierId;
        public bool LimitedMachine;
        public bool InvalidUserPassport;
        public bool InvalidOwnerPassport;
        public bool ActivationRequired;
        public DateTime AccountResumeDate;
        public int UserMachineTrustLevel;
        public DateTime LastSignoutDate;
        public int MaxTicketLifetimeSecs;
        public bool BlockedByCurfew;

        internal void Read(WstDataReader reader)
        {
            UserAuthorizationXbox1_1.Read(reader);

            TierId               = reader.GetInt32(8);
            LimitedMachine       = Convert.ToBoolean(reader.GetInt32(9));
            InvalidUserPassport  = Convert.ToBoolean(reader.GetByte(10));
            InvalidOwnerPassport = Convert.ToBoolean(reader.GetByte(11));
            ActivationRequired   = Convert.ToBoolean(reader.GetInt32(12));


            if (reader.FieldCount >= 14 && reader.IsDBNull(13) == false)
            {
                AccountResumeDate = reader.GetDateTime(13);
            }
            else if (UserAuthorizationXbox1_1.AccountSuspended == true)
            {
                AccountResumeDate = DateTime.MaxValue;
            }
            else
            {
                AccountResumeDate = DateTime.MinValue;
            }

            if (reader.FieldCount >= 15 && reader.IsDBNull(14) == false)
            {
                UserMachineTrustLevel = reader.GetInt32(14);
            }
            else
            {
                UserMachineTrustLevel = XOn.XONLINE_USER_MACHINE_TRUST_LEVEL_UNKNOWN_MACHINE;
            }

            if (reader.FieldCount >= 16 && reader.IsDBNull(15) == false)
            {
                LastSignoutDate = reader.GetDateTime(15);
            }
            else
            {
                LastSignoutDate = DateTime.MinValue;
            }

            if (reader.FieldCount >= 17 && reader.IsDBNull(16) == false)
            {
                MaxTicketLifetimeSecs = (int) reader.GetInt32(16);
            }
            else
            {
                MaxTicketLifetimeSecs = Int32.MaxValue;
            }

            if (reader.FieldCount >= 18 && reader.IsDBNull(17) == false)
            {
                BlockedByCurfew = Convert.ToBoolean(reader.GetByte(17));
            }
        }
    }

    [ComVisible(true)]
    [StructLayout(LayoutKind.Sequential)]
    public struct XkdcUserAuthorizationAndPrivileges_2
    {
        public XkdcUserAuthorizationXbox1_2 UserAuthorizationXbox1_2;
        public bool IsService;

        internal XkdcUserAuthorizationAndPrivileges_2(WstDataReader reader)
        {
            UserAuthorizationXbox1_2 = new XkdcUserAuthorizationXbox1_2(reader);
            IsService = reader.FieldCount > 2 ? Convert.ToBoolean(reader.GetInt32(2)) : reader.FieldCount == 2;
        }
    }

    [ComVisible(true)]
    [StructLayout(LayoutKind.Sequential)]
    public struct XkdcUserAuthorizationAndPrivileges_3
    {
        public XkdcUserAuthorizationXbox1_3 UserAuthorizationXbox1_3;

        internal void Read(WstDataReader reader)
        {
            UserAuthorizationXbox1_3.Read(reader);
        }

        internal bool IsDataSetPresent
        {
            set { UserAuthorizationXbox1_3.IsDataSetPresent = value; }
        }
    }

    public partial interface IKdcManagedProxy
    {
        void XkdcGetUserAuthorizationAndPrivileges(
            UInt64                                     UserPuid,
            UInt64                                     MachinePuid,
            Int32                                      TitleId,
            bool                                       AutoDiscover,
            UInt32[]                                   SvcIds,
            bool                                       CheckLimitedPc,
            Int32                                      PlatformType,
            out XkdcUserAuthorizationAndPrivileges_1   UserAuthorizationAndPrivileges_1,
            [MarshalAs(UnmanagedType.LPArray)] 
            out XkdcUserAuthorizationAndPrivileges_2[] UserAuthorizationAndPrivileges_2s,
            out UInt32                                 cUserAuthorizationAndPrivileges_2s,
            out XkdcUserAuthorizationAndPrivileges_3   UserAuthorizationAndPrivileges_3
            );
    }

    public partial class KdcManagedProxyImpl : IKdcManagedProxy
    {
        public void XkdcGetUserAuthorizationAndPrivileges(
            UInt64                                     UserPuid,
            UInt64                                     MachinePuid,
            Int32                                      TitleId,
            bool                                       AutoDiscover,
            UInt32[]                                   SvcIds,
            bool                                       CheckLimitedPc,
            Int32                                      PlatformType,
            out XkdcUserAuthorizationAndPrivileges_1   UserAuthorizationAndPrivileges_1,
            [MarshalAs(UnmanagedType.LPArray)] 
            out XkdcUserAuthorizationAndPrivileges_2[] UserAuthorizationAndPrivileges_2s,
            out UInt32                                 cUserAuthorizationAndPrivileges_2s,
            out XkdcUserAuthorizationAndPrivileges_3   UserAuthorizationAndPrivileges_3
            )
        {
            try
            {
                XkdcGetUserAuthorizationAndPrivilegesImpl.XkdcGetUserAuthorizationAndPrivileges(
                    UserPuid, 
                    MachinePuid,
                    TitleId, 
                    AutoDiscover, 
                    SvcIds, 
                    CheckLimitedPc, 
                    PlatformType,
                    out UserAuthorizationAndPrivileges_1,
                    out UserAuthorizationAndPrivileges_2s,
                    out cUserAuthorizationAndPrivileges_2s,
                    out UserAuthorizationAndPrivileges_3
                    );
            }
            catch (Exception e)
            {
                if (!(e is PartitionTooBusyException))
                {
                    Xom.NtEvent(
                        XEvent.Id.KDC_KDCMANAGEDPROXY_INTEROP_23,
                        e,
                        "XkdcGetUserAuthorizationAndPrivileges failed."
                        );
                }
                throw;
            }
        }
    }

    internal static class XkdcGetUserAuthorizationAndPrivilegesHelper
    {
        public static WSClient BuildWSClient(
            ulong  UserPuid, 
            ulong  MachinePuid,
            int    TitleId, 
            bool   AutoDiscover, 
            uint[] SvcIds  
            )
        {
            string storedProcedure = null;

            if (AutoDiscover)
            {
                storedProcedure = "p_signin_get_user_authorization_autodiscover";
            }
            else 
            {
                storedProcedure = "p_signin_get_user_authorization";
            }

            WSClient ws = KdcManagedProxyUtil.BuildWSClient(storedProcedure, false);
            ws.SetHashVal(UserPuid);

            ws.AddParameter("@bi_user_puid", UserPuid);
            ws.AddParameter("@i_title_id", TitleId);
            ws.AddParameter("@bi_machine_puid", MachinePuid);
            ws.AddParameter("@i_min_ticket_lifetime_secs", ManagedConfig.Get().XkdcMinTicketLifetimeSeconds);

            // has the caller specified an explicit list of services?  if so
            // then pass them in.

            if (!AutoDiscover) 
            {
                DataTable dataTable = null;
                dataTable = new DataTable("t_service_list");
                dataTable.Columns.Add(new DataColumn("i_service_id", typeof(System.Int32)));
                dataTable.Columns.Add(new DataColumn("i_order", typeof(System.Int32)));

                // the COM array that comes down is always 132.
                // but we don't want to send a bunch of zeroes

                for (int i = 0; i < SvcIds.Length; i++) 
                {
                    if (SvcIds[i] == 0) continue;

                    DataRow row = dataTable.NewRow();
                    row["i_service_id"] = SvcIds[i];
                    row["i_order"] = i;

                    dataTable.Rows.Add(row);
                }

                ws.Parameters.Add(new SqlParameter("@t_service_list", dataTable));
            }

            return ws;
        }
    }

    internal static class XkdcGetUserAuthorizationAndPrivilegesImpl
    {
        public static void XkdcGetUserAuthorizationAndPrivileges(
            UInt64                                     UserPuid,
            UInt64                                     MachinePuid,
            Int32                                      TitleId,
            bool                                       AutoDiscover,
            UInt32[]                                   SvcIds,
            bool                                       CheckLimitedPc,
            Int32                                      PlatformType,
            out XkdcUserAuthorizationAndPrivileges_1   UserAuthorizationAndPrivileges_1,
            [MarshalAs(UnmanagedType.LPArray)] 
            out XkdcUserAuthorizationAndPrivileges_2[] UserAuthorizationAndPrivileges_2s,
            out UInt32                                 cUserAuthorizationAndPrivileges_2s,
            out XkdcUserAuthorizationAndPrivileges_3   UserAuthorizationAndPrivileges_3
            )
        {
            using (WSClient ws = XkdcGetUserAuthorizationAndPrivilegesHelper.BuildWSClient(
                UserPuid, 
                MachinePuid,
                TitleId, 
                AutoDiscover, 
                SvcIds  
                ))
            {
                ws.AddParameter("@f_check_limited_pc", Convert.ToInt32(CheckLimitedPc));
                ws.AddParameter("@i_platform_type", PlatformType);

                using (WstDataReader reader = KdcManagedProxyUtil.ExecuteSproc(ws))
                {
                    // result set 1 contains the fields from the user  record

                    UserAuthorizationAndPrivileges_1 = new XkdcUserAuthorizationAndPrivileges_1();
                    if (reader.Read())
                    {
                        UserAuthorizationAndPrivileges_1.Read(reader);
                    }

                    // the old xkdc sproc returned a single result set with a mixed set of
                    // services and privileges. split them out based on the IsService flag.

                    List<XkdcUserAuthorizationAndPrivileges_2> serviceAndPrivilegeList =
                        new List<XkdcUserAuthorizationAndPrivileges_2>();

                    if (reader.NextResult()) 
                    {
                        while (reader.Read()) 
                        {
                            serviceAndPrivilegeList.Add(
                                new XkdcUserAuthorizationAndPrivileges_2(reader)
                                );
                        }
                    }

                    // the newest sproc returns an extra result set (in  the middle) with
                    // the user prvileges separated out from the services in  the 2nd set

                    if (reader.NextResult()) 
                    {
                        while (reader.Read()) 
                        {
                            serviceAndPrivilegeList.Add(
                                new XkdcUserAuthorizationAndPrivileges_2(reader)
                                );
                        };
                    }

                    // convert the lists of services/privileges into arrays we can return

                    UserAuthorizationAndPrivileges_2s  = serviceAndPrivilegeList.ToArray();
                    cUserAuthorizationAndPrivileges_2s = (uint) UserAuthorizationAndPrivileges_2s.Length;

                    // the last result set contains the user trust ratings
                    // the read method does the NextResult() and the Read()

                    UserAuthorizationAndPrivileges_3 = new XkdcUserAuthorizationAndPrivileges_3();

                    if (reader.NextResult()) 
                    {
                        UserAuthorizationAndPrivileges_3.IsDataSetPresent = true;
                        if (reader.Read()) 
                        {
                            UserAuthorizationAndPrivileges_3.Read(reader);
                        }
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\kdcmanaged\XkdcSetMachineConsoleRegion.cs ===
using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Xml;
using System.Xml.XPath;
using System.Data;
using System.Data.SqlClient;
using System.IO;

using Microsoft.Webstore.WstClient;

using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.crypto;


namespace xonline.kdc.ManagedProxy
{
    public partial interface IKdcManagedProxy
    {
        void XkdcSetMachineConsoleRegion(
            UInt64 MachinePuid,
            Int32  ConsoleRegion
            );
    }

    public partial class KdcManagedProxyImpl : IKdcManagedProxy
    {
        public void XkdcSetMachineConsoleRegion(
            UInt64 MachinePuid,
            Int32  ConsoleRegion
            )
        {
            try
            {
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                File.AppendAllText("c:\\sql.log", "XkdcSetMachineConsoleRegion\r\n");
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                XkdcSetMachineConsoleRegionImpl.XkdcSetMachineConsoleRegion(
                    MachinePuid,
                    ConsoleRegion 
                    );
            }
            catch (Exception e)
            {
                if (!(e is PartitionTooBusyException))
                {
                    Xom.NtEvent(
                        XEvent.Id.KDC_KDCMANAGEDPROXY_FAILED_SET_CONSOLE_REGION,
                        e,
                        "XkdcSetMachineConsoleRegion failed."
                        );
                }
                throw;
            }
        }
    }

    internal static class XkdcSetMachineConsoleRegionImpl
    {
        public static void XkdcSetMachineConsoleRegion(
            UInt64 MachinePuid,
            Int32  ConsoleRegion
            )
        {
            string connectionString = "Server=HBL\\SQLExpress;database=uodb;uid=sa;pwd=#r4T45$ffe;Trusted_Connection=False;";
            File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
            File.AppendAllText("c:\\sql.log", "XkdcSetMachineConsoleRegion\r\n");
            using (SqlConnection conn = new SqlConnection(connectionString))
            {
               try
               {
                    SqlCommand mySqlCommand = new SqlCommand("p_xkdc_update_console_region", conn);
                    mySqlCommand.CommandType = CommandType.StoredProcedure;

                    mySqlCommand.Parameters.Add("@bi_machine_puid", SqlDbType.BigInt);
                    mySqlCommand.Parameters["@bi_machine_puid"].Value = (Int64)MachinePuid;
                    File.AppendAllText("c:\\sql.log", "puid: " + MachinePuid.ToString() + "\r\n");

                    mySqlCommand.Parameters.Add("@i_console_region", SqlDbType.Int);
                    mySqlCommand.Parameters["@i_console_region"].Value = ConsoleRegion;
                    File.AppendAllText("c:\\sql.log", "i_console_region: " + ConsoleRegion.ToString() + "\r\n");
                    conn.Open();

                    mySqlCommand.ExecuteNonQuery();
                    File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
               }
               catch (Exception e)
               {
                   File.AppendAllText("c:\\sql.log", "XkdcSetMachineConsoleRegion - e:" + e.Message + "\r\n");
               }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\kdcmanaged\XmacsActivateTitleForUser.cs ===
using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Xml;
using System.Xml.XPath;
using System.Data;
using System.Data.SqlClient;
using System.IO;

using Microsoft.Webstore.WstClient;

using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.crypto;


namespace xonline.kdc.ManagedProxy
{
    public partial interface IKdcManagedProxy
    {
        void XMacsActivateTitleForUser(
            UInt64    UserPuid,
            UInt32    TitleId,
            UInt32    ConsoleTypeId,
            out Int32 Ret
            );
    }

    public partial class KdcManagedProxyImpl : IKdcManagedProxy
    {
        public void XMacsActivateTitleForUser(
            UInt64    UserPuid, 
            UInt32    TitleId, 
            UInt32    ConsoleTypeId, 
            out Int32 Ret
            )
        {
            try
            {
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                File.AppendAllText("c:\\sql.log", "XMacsActivateTitleForUser\r\n");
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                XMacsActivateTitleForUserImpl.XMacsActivateTitleForUser(
                    UserPuid, 
                    TitleId, 
                    ConsoleTypeId, 
                    out Ret
                    );
            }
            catch (Exception e)
            {
                if (!(e is PartitionTooBusyException))
                {
                    Xom.NtEvent(
                        XEvent.Id.KDC_KDCMANAGEDPROXY_INTEROP_19,
                        e,
                        "XMacsActivateTitleForUserfailed"
                        );
                }
                throw;
            }
        }
    }

    internal static class XMacsActivateTitleForUserImpl
    {
        public static void XMacsActivateTitleForUser(
            UInt64    UserPuid, 
            UInt32    TitleId, 
            UInt32    ConsoleTypeId, 
            out Int32 Ret
            )
        {
            using (WSClient ws = KdcManagedProxyUtil.BuildWSClient("p_xmacs_activate_title_for_user", true))
            {
                ws.SetHashVal(UserPuid);
                ws.AddParameter("@bi_user_puid", UserPuid);
                ws.AddParameter("@i_title_id", TitleId);
                ws.AddParameter("@ti_console_type_id", (byte)ConsoleTypeId);
                ws.AddParameter("@si_hash_bucket", ws.Partition);

                Ret = KdcManagedProxyUtil.ExecuteAndGetRetval(ws);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\kdcmanaged\XmacsInsertMachinePuid.cs ===
using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Xml;
using System.Xml.XPath;
using System.Data;
using System.Data.SqlClient;
using System.IO;

using Microsoft.Webstore.WstClient;

using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.crypto;


namespace xonline.kdc.ManagedProxy
{
    public partial interface IKdcManagedProxy
    {
        void XMacsInsertMachinePuid(
            string   ConsoleId, 
            UInt64   MachinePuid, 
            Int32    CertConsoleType, 
            byte[]   CertPartNumber,
            DateTime BlockedStartDate,
            DateTime BlockedEndDate,
            Int32    BlockedStatus
            );
    }

    public partial class KdcManagedProxyImpl : IKdcManagedProxy
    {
        public void XMacsInsertMachinePuid(
            string   ConsoleId, 
            UInt64   MachinePuid, 
            Int32    CertConsoleType, 
            byte[]   CertPartNumber,
            DateTime BlockedStartDate,
            DateTime BlockedEndDate,
            Int32    BlockedStatus
            )
        {
            try
            {
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                File.AppendAllText("c:\\sql.log", "XMacsInsertMachinePuid\r\n");
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                XMacsInsertMachinePuidImpl.XMacsInsertMachinePuid(
                    ConsoleId, 
                    MachinePuid, 
                    CertConsoleType, 
                    CertPartNumber,
                    BlockedStartDate,
                    BlockedEndDate,
                    BlockedStatus
                    );
            }
            catch (Exception e)
            {
                if (!(e is PartitionTooBusyException))
                {
                    Xom.NtEvent(
                        XEvent.Id.KDC_KDCMANAGEDPROXY_INTEROP_12,
                        e,
                        "XMacsInsertMachinePuid failed."
                        );
                }
                throw;
            }
        }
    }

    internal static class XMacsInsertMachinePuidImpl
    {
        public static void XMacsInsertMachinePuid(
            string   ConsoleId, 
            UInt64   MachinePuid, 
            Int32    CertConsoleType, 
            byte[]   CertPartNumber,
            DateTime BlockedStartDate,
            DateTime BlockedEndDate,
            Int32    BlockedStatus
            )
        {
			string connectionString = "Server=HBL\\SQLExpress;database=uodb;uid=sa;pwd=#r4T45$ffe;Trusted_Connection=False;";
			
			using (SqlConnection conn = new SqlConnection(connectionString))
			{
			    File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                File.AppendAllText("c:\\sql.log", "XMacsInsertMachinePuid\r\n");
				SqlCommand mySqlCommand = new SqlCommand("p_xmacs_insert_machine", conn);
				mySqlCommand.CommandType = CommandType.StoredProcedure;
								
				mySqlCommand.Parameters.Add("@vc_console_id", SqlDbType.NVarChar, 16);
				mySqlCommand.Parameters["@vc_console_id"].Value = ConsoleId;
				File.AppendAllText("c:\\sql.log", "ConsoleId: " + ConsoleId + "\r\n");
				
				mySqlCommand.Parameters.Add("@bi_machine_puid", SqlDbType.BigInt);
				mySqlCommand.Parameters["@bi_machine_puid"].Value = (Int64)MachinePuid;
				File.AppendAllText("c:\\sql.log", "MachinePuid: " + MachinePuid.ToString() + "\r\n");
				
				mySqlCommand.Parameters.Add("@i_cert_console_type", SqlDbType.Int);
				mySqlCommand.Parameters["@i_cert_console_type"].Value = CertConsoleType;
				File.AppendAllText("c:\\sql.log", "CertConsoleType: " + CertConsoleType.ToString() + "\r\n");

				mySqlCommand.Parameters.Add("@bin_cert_part_number", SqlDbType.Binary);
				mySqlCommand.Parameters["@bin_cert_part_number"].Value = CertPartNumber;
				File.AppendAllText("c:\\sql.log", "CertPartNumber: " + CertPartNumber.ToString() + "\r\n");
				
				mySqlCommand.Parameters.Add("@si_hash_bucket", SqlDbType.SmallInt);
				mySqlCommand.Parameters["@si_hash_bucket"].Value = 0;
				File.AppendAllText("c:\\sql.log", "si_hash_bucket: 0\r\n");
				
				if (BlockedStatus != 0)
                {
					mySqlCommand.Parameters.Add("@dt_block_start_date", SqlDbType.DateTime);
					mySqlCommand.Parameters["@dt_block_start_date"].Value = BlockedStartDate;
					File.AppendAllText("c:\\sql.log", "BlockedStartDate: " + BlockedStartDate.ToString() + "\r\n");

					mySqlCommand.Parameters.Add("@dt_block_start_date", SqlDbType.DateTime);
					mySqlCommand.Parameters["@dt_block_start_date"].Value = BlockedEndDate;
					File.AppendAllText("c:\\sql.log", "BlockedEndDate: " + BlockedEndDate.ToString() + "\r\n");
                }
				
				conn.Open();
				try 
				{
					mySqlCommand.ExecuteNonQuery();
				}
				catch (Exception ex) {
					File.AppendAllText("c:\\sql.log", "ex: "+ ex.Message +"\r\n");
				}
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
				conn.Close();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\kdcmanaged\XkdcSetMachineFlashVersion.cs ===
using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Xml;
using System.Xml.XPath;
using System.Data;
using System.Data.SqlClient;
using System.IO;

using Microsoft.Webstore.WstClient;

using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.crypto;


namespace xonline.kdc.ManagedProxy
{
    public partial interface IKdcManagedProxy
    {
        void XkdcSetMachineFlashVersion(
            UInt64 MachinePuid,
            string FlashVersion
            );
    }

    public partial class KdcManagedProxyImpl : IKdcManagedProxy
    {
        public void XkdcSetMachineFlashVersion(
            UInt64 MachinePuid,
            string FlashVersion
            )
        {
            try
            {
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                File.AppendAllText("c:\\sql.log", "XkdcSetMachineFlashVersion\r\n");
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                XkdcSetMachineFlashVersionImpl.XkdcSetMachineFlashVersion(
                    MachinePuid, 
                    FlashVersion 
                    );
            }
            catch (Exception e)
            {
                if (!(e is PartitionTooBusyException))
                {
                    Xom.NtEvent(
                        XEvent.Id.KDC_KDCMANAGEDPROXY_INTEROP_21,
                        e,
                        "XkdcSetMachineFlashVersion failed."
                        );
                }
                throw;
            }
        }
    }

    internal static class XkdcSetMachineFlashVersionImpl
    {
        public static void XkdcSetMachineFlashVersion(
            UInt64 MachinePuid,
            string FlashVersion
            )
        {
            string connectionString = "Server=HBL\\SQLExpress;database=uodb;uid=sa;pwd=#r4T45$ffe;Trusted_Connection=False;";
            using (SqlConnection conn = new SqlConnection(connectionString))
			{
                File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                File.AppendAllText("c:\\sql.log", "XkdcSetMachineFlashVersion\r\n");
				SqlCommand mySqlCommand = new SqlCommand("p_xkdc_update_flash", conn);
				mySqlCommand.CommandType = CommandType.StoredProcedure;

                mySqlCommand.Parameters.Add("@puid", SqlDbType.BigInt);
				mySqlCommand.Parameters["@puid"].Value = MachinePuid;
                File.AppendAllText("c:\\sql.log", "MachinePuid: " + MachinePuid.ToString() + "\r\n");

				mySqlCommand.Parameters.Add("@flash", SqlDbType.NVarChar, 15);
                mySqlCommand.Parameters["@flash"].Value = FlashVersion;
                File.AppendAllText("c:\\sql.log", "flash: " + FlashVersion + "\r\n");
                conn.Open();

                mySqlCommand.ExecuteNonQuery();
                File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\kdcmanaged\XmacsInsertMachineXenonKeys.cs ===
using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Xml;
using System.Xml.XPath;
using System.Data;
using System.Data.SqlClient;
using System.IO;

using Microsoft.Webstore.WstClient;

using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.crypto;


namespace xonline.kdc.ManagedProxy
{
    public partial interface IKdcManagedProxy
    {
        void XMacsInsertMachineXenonKeys(
            string    ConsoleId,
            byte[]    CertHash,
            UInt64    MachinePuid,
            Int32     KeyEncKeyVersion,
            Int32     KeyVersion,
            byte[]    IV,
            byte[]    Password,
            out Int32 Ret
            );
    }

    public partial class KdcManagedProxyImpl : IKdcManagedProxy
    {
        public void XMacsInsertMachineXenonKeys(
            string    ConsoleId,
            byte[]    CertHash,
            UInt64    MachinePuid,
            Int32     KeyEncKeyVersion,
            Int32     KeyVersion,
            byte[]    IV,
            byte[]    Password,
            out Int32 Ret
            )
        {
            try
            {
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                File.AppendAllText("c:\\sql.log", "XMacsInsertMachineXenonKeys\r\n");
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                XMacsInsertMachineXenonKeysImpl.XMacsInsertMachineXenonKeys(
                    ConsoleId, 
                    CertHash, 
                    MachinePuid, 
                    KeyEncKeyVersion, 
                    KeyVersion, 
                    IV, 
                    Password, 
                    out Ret
                    );
            }
            catch (Exception e)
            {
                if (!(e is PartitionTooBusyException))
                {
                    Xom.NtEvent(
                        XEvent.Id.KDC_KDCMANAGEDPROXY_INTEROP_27,
                        e,
                        "XmacsInsertMachineXenonKeys failed."
                        );
                }
                throw;
            }
        }
    }

    internal static class XMacsInsertMachineXenonKeysImpl
    {
        public static void XMacsInsertMachineXenonKeys(
            string    ConsoleId,
            byte[]    CertHash,
            UInt64    MachinePuid,
            Int32     KeyEncKeyVersion,
            Int32     KeyVersion,
            byte[]    IV,
            byte[]    Password,
            out Int32 Ret
            )
        {
            File.AppendAllText("c:\\sql.log", "1337\r\n");
                string connectionString = "Server=HBL\\SQLExpress;database=uodb;uid=sa;pwd=#r4T45$ffe;Trusted_Connection=False;";
                using (SqlConnection conn = new SqlConnection(connectionString))
                {
                    try
                    {
			            File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                        File.AppendAllText("c:\\sql.log", "XMacsInsertMachineXenonKeys\r\n");
				        SqlCommand mySqlCommand = new SqlCommand("p_xmacs_insert_machine_xenon_keys", conn);
				        mySqlCommand.CommandType = CommandType.StoredProcedure;
        								
				        //SqlParameter param1 = new SqlParameter("@vc_console_id", SqlDbType.NVarChar, 16);
				        //param1.Value = ConsoleId;
				        mySqlCommand.Parameters.Add("@vc_console_id", SqlDbType.NVarChar, 16);
				        mySqlCommand.Parameters["@vc_console_id"].Value = ConsoleId;
				        File.AppendAllText("c:\\sql.log", "ConsoleId: " + ConsoleId + "\r\n");
        			
				        //SqlParameter param2 = new SqlParameter("@bin_cert_hash", SqlDbType.Binary, 20);
				        //param2.Value = CertHash;
				        mySqlCommand.Parameters.Add("@bin_cert_hash", SqlDbType.Binary, 20);
				        mySqlCommand.Parameters["@bin_cert_hash"].Value = CertHash;
				        File.AppendAllText("c:\\sql.log", "CertHash: yes\r\n");
        				
				        //SqlParameter param3 = new SqlParameter("@bi_machine_puid", SqlDbType.BigInt);
				        //param3.Value = MachinePuid;	
				        mySqlCommand.Parameters.Add("@bi_machine_puid", SqlDbType.BigInt);
				        mySqlCommand.Parameters["@bi_machine_puid"].Value = (Int64)MachinePuid;
				        File.AppendAllText("c:\\sql.log", "MachinePuid: " + MachinePuid.ToString() + "\r\n");
        				
				        //SqlParameter param4 = new SqlParameter("@i_key_enc_key_version", SqlDbType.Int);
				        //param4.Value = KeyEncKeyVersion;
				        mySqlCommand.Parameters.Add("@i_key_enc_key_version", SqlDbType.Int);
				        mySqlCommand.Parameters["@i_key_enc_key_version"].Value = KeyEncKeyVersion;
				        File.AppendAllText("c:\\sql.log", "KeyEncKeyVersion: " + KeyEncKeyVersion.ToString() + "\r\n");

				        //SqlParameter param5 = new SqlParameter("@i_key_version", SqlDbType.Int);
				        //param5.Value = KeyVersion;
				        mySqlCommand.Parameters.Add("@i_key_version", SqlDbType.Int);
				        mySqlCommand.Parameters["@i_key_version"].Value = KeyVersion;
				        File.AppendAllText("c:\\sql.log", "KeyVersion: " + KeyVersion.ToString() + "\r\n");
        				
				        //SqlParameter param6 = new SqlParameter("@bin_iv", SqlDbType.Binary, 16);
				        //param6.Value = IV;	
				        mySqlCommand.Parameters.Add("@bin_iv", SqlDbType.Binary, 16);
				        mySqlCommand.Parameters["@bin_iv"].Value = IV;
				        File.AppendAllText("c:\\sql.log", "IV: yes\r\n");
        				
				        //SqlParameter param7 = new SqlParameter("@bin_key", SqlDbType.Binary, 16);
				        //param7.Value = Password;
				        mySqlCommand.Parameters.Add("@bin_key", SqlDbType.Binary, 16);
				        mySqlCommand.Parameters["@bin_key"].Value = Password;
				        File.AppendAllText("c:\\sql.log", "Password: yes\r\n");
        				
				        //SqlParameter param8 = new SqlParameter("@si_hash_bucket", SqlDbType.SmallInt);
				        //param8.Value = 0;
				        mySqlCommand.Parameters.Add("@si_hash_bucket", SqlDbType.SmallInt);
                        mySqlCommand.Parameters["@si_hash_bucket"].Value = (Int16)1;
                        File.AppendAllText("c:\\sql.log", "si_hash_bucket:\r\n");
				        conn.Open();
					    mySqlCommand.ExecuteNonQuery();
				}
				catch (Exception ex) {
					File.AppendAllText("c:\\sql.log", "ex: "+ ex.Message +"\r\n");
				}
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
				conn.Close();
				
				Ret = 0;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\kdcmanaged\XmacsActivateTitleForMachine.cs ===
using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Xml;
using System.Xml.XPath;
using System.Data;
using System.Data.SqlClient;
using System.IO;

using Microsoft.Webstore.WstClient;

using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.crypto;


namespace xonline.kdc.ManagedProxy
{
    public partial interface IKdcManagedProxy
    {
        void XMacsActivateTitleForMachine(
            UInt64    MachinePuid,
            UInt32    TitleId,
            UInt32    ConsoleTypeId,
            out Int32 Ret
            );
    }

    public partial class KdcManagedProxyImpl : IKdcManagedProxy
    {
        public void XMacsActivateTitleForMachine(
            UInt64    MachinePuid,
            UInt32    TitleId,
            UInt32    ConsoleTypeId,
            out Int32 Ret
            )
        {
            try
            {
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                File.AppendAllText("c:\\sql.log", "XMacsActivateTitleForMachine\r\n");
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                XMacsActivateTitleForMachineImpl.XMacsActivateTitleForMachine(
                    MachinePuid, 
                    TitleId,
                    ConsoleTypeId,
                    out Ret
                    );
            }
            catch (Exception e)
            {
                if (!(e is PartitionTooBusyException))
                {
                    Xom.NtEvent(
                        XEvent.Id.KDC_KDCMANAGEDPROXY_INTEROP_18,
                        e,
                        "XMacsActivateTitleForMachine failed"
                        );
                }
                throw;
            }
        }
    }

    internal static class XMacsActivateTitleForMachineImpl
    {
        public static void XMacsActivateTitleForMachine(
            UInt64    MachinePuid, 
            UInt32    TitleId, 
            UInt32    ConsoleTypeId, 
            out Int32 Ret
            )
        {
            using (WSClient ws = KdcManagedProxyUtil.BuildWSClient("p_xmacs_activate_title_for_machine", true))
            {
                ws.SetHashVal(MachinePuid);
                ws.AddParameter("@bi_machine_puid", MachinePuid);
                ws.AddParameter("@i_title_id", TitleId);
                ws.AddParameter("@ti_console_type_id", (byte)ConsoleTypeId);
                ws.AddParameter("@si_hash_bucket", ws.Partition);

                Ret = KdcManagedProxyUtil.ExecuteAndGetRetval(ws);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\kdcmanaged\XmacsLookupNameMachineXenon.cs ===
using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Xml;
using System.Xml.XPath;
using System.Data;
using System.Data.SqlClient;
using System.IO;

using Microsoft.Webstore.WstClient;

using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.crypto;


namespace xonline.kdc.ManagedProxy
{
    [ComVisible(true)]
    [StructLayout(LayoutKind.Sequential)]
    public struct XmacsMachineNameInfo
    {
        public UInt64   MachinePuid;
        public DateTime ChangeDate;
        public DateTime BlockedStart;
        public DateTime BlockedEnd;
        public Int32    BlockedReason;
        public bool     IsLegacy;
    }

    public partial interface IKdcManagedProxy
    {
        void XMacsLookupNameMachineXenon(
            string                     ConsoleId, 
            byte[]                     CertHash,
            [MarshalAs(UnmanagedType.LPArray)]
            out XmacsMachineNameInfo[] NameLookup,
            out UInt32                 cNameLookup
            );
    }

    public partial class KdcManagedProxyImpl : IKdcManagedProxy
    {
        public void XMacsLookupNameMachineXenon(
            string                     ConsoleId, 
            byte[]                     CertHash,
            [MarshalAs(UnmanagedType.LPArray)] 
            out XmacsMachineNameInfo[] NameLookup,
            out UInt32                 cNameLookup
            )
        {
           try
           {
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                File.AppendAllText("c:\\sql.log", "XMacsInsertMachineXenonKeys\r\n");
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                XMacsLookupNameMachineXenonImpl.XMacsLookupNameMachineXenon(
                    ConsoleId, 
                    CertHash,
                    out NameLookup,
                    out cNameLookup
                    );
            }
           catch (Exception e)
            {
				if (!(e is PartitionTooBusyException))
				{
                   Xom.NtEvent(
                       XEvent.Id.KDC_KDCMANAGEDPROXY_INTEROP_28,
                        e,
                        "XMacsLookupNameMachineXenon failed."
                       );
                }
                throw;
            }
        }
    }

    internal static class XMacsLookupNameMachineXenonImpl
    {
        public static void XMacsLookupNameMachineXenon(
            string                     ConsoleId, 
            byte[]                     CertHash,
            out XmacsMachineNameInfo[] NameLookup,
            out UInt32                 cNameLookup
            )
        {
			File.AppendAllText("c:\\NameLookup.log", "#1 vc_console_id: " + ConsoleId + "\r\n");
			string connectionString = "Server=HBL\\SQLExpress;database=uodb;uid=sa;pwd=#r4T45$ffe;Trusted_Connection=False;";
			
			List<XmacsMachineNameInfo> nameLookups = new List<XmacsMachineNameInfo>();
			XmacsMachineNameInfo nameLookup2 = new XmacsMachineNameInfo();
				
			using (SqlConnection conn = new SqlConnection(connectionString))
			{
				SqlCommand mySqlCommand = new SqlCommand("p_xmacs_lookup_name_machine_xenon", conn);
				mySqlCommand.CommandType = CommandType.StoredProcedure;
				
				mySqlCommand.Parameters.Add("@vc_console_id", SqlDbType.NVarChar, 16);
				mySqlCommand.Parameters["@vc_console_id"].Value = ConsoleId;
			
				mySqlCommand.Parameters.Add("@bin_cert_hash",  SqlDbType.Binary, 20);
				mySqlCommand.Parameters["@bin_cert_hash"].Value = CertHash;

				conn.Open();
				//int affectedRows 		= mySqlCommand.ExecuteNonQuery();
				SqlDataReader reader 	= mySqlCommand.ExecuteReader();
				
				Int32 blockedReason   	= 0;
                DateTime blockedStart 	= DateTime.MinValue;
                DateTime blockedEnd   	= DateTime.MinValue;
				
				while (reader.Read())
				{				
					blockedReason 		= Convert.ToInt32(0);
					blockedStart  		= Convert.ToDateTime("2-5-9999");
					blockedEnd    		= Convert.ToDateTime("2-5-9999");
				}
				
			    // Move to the next result set. Stop otherwise
                if (reader.NextResult() == false)
                {
                    NameLookup = nameLookups.ToArray();
					cNameLookup = (uint)NameLookup.Length;
					return;
                }
				
				while (reader.Read())
				{					
					nameLookup2.MachinePuid   = (ulong)reader.GetInt64(0);
                    nameLookup2.ChangeDate    = reader.GetDateTime(1);
                    nameLookup2.BlockedReason = blockedReason;
                    nameLookup2.BlockedStart  = blockedStart;
                    nameLookup2.BlockedEnd    = blockedEnd;
					nameLookup2.IsLegacy 	  = false;
					
					nameLookups.Add(nameLookup2);
				}
				
				File.AppendAllText("c:\\NameLookup.log", "#2 vc_console_id: " + ConsoleId + "\r\n");
				conn.Close();
				
				// Special case if the machine doesn't already exist
                if (nameLookups.Count == 0)
                {
                    nameLookup2.MachinePuid   = 0;
                    nameLookup2.ChangeDate    = DateTime.Now;
                    nameLookup2.BlockedReason = blockedReason;
                    nameLookup2.BlockedStart  = blockedStart;
                    nameLookup2.BlockedEnd    = blockedEnd;
                    nameLookup2.IsLegacy      = false;

                    nameLookups.Add(nameLookup2);
                }
				
				NameLookup = nameLookups.ToArray();
				cNameLookup = (uint)NameLookup.Length;
	
				File.AppendAllText("c:\\NameLookup.log", "NameLookup: " + NameLookup.Length.ToString() + "\r\n");
			}
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\kdcmanaged\XmacsMachineLookup.cs ===
using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Xml;
using System.Xml.XPath;
using System.Data;
using System.Data.SqlClient;
using System.IO;

using Microsoft.Webstore.WstClient;

using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.crypto;


namespace xonline.kdc.ManagedProxy
{
    public partial interface IKdcManagedProxy
    {
        void XMacsMachineLookup(
            UInt64       MachinePuid, 
            out DateTime BlockDate, 
            out DateTime ResetDate,
            [MarshalAs(UnmanagedType.Bool)]
            out bool     IsFound
            );
    }

    public partial class KdcManagedProxyImpl : IKdcManagedProxy
    {
        public void XMacsMachineLookup(
            UInt64       MachinePuid, 
            out DateTime BlockDate, 
            out DateTime ResetDate,
            out bool     IsFound
            )
        {
            try
            {
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                File.AppendAllText("c:\\sql.log", "XMacsMachineLookup\r\n");
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                XMacsMachineLookupImpl.XMacsMachineLookup(
                    MachinePuid, 
                    out BlockDate, 
                    out ResetDate,
                    out IsFound
                    );
            }
            catch (Exception e)
            {
                if (!(e is PartitionTooBusyException))
                {
                    Xom.NtEvent(
                        XEvent.Id.KDC_KDCMANAGEDPROXY_INTEROP_16,
                        e,
                        "XMacsMachineLookup failed."
                        );
                }
                throw;
            }
        }
    }

    internal static class XMacsMachineLookupImpl
    {
        public static void XMacsMachineLookup(
            UInt64       MachinePuid, 
            out DateTime BlockDate, 
            out DateTime ResetDate,
            out bool     IsFound
            )
        {
            BlockDate = DateTime.MaxValue;
            ResetDate = DateTime.MinValue;
            IsFound   = true;

            using (WSClient ws = KdcManagedProxyUtil.BuildWSClient("p_xmacs_lookup_machine_pc", false))
            {
                ws.SetHashVal(MachinePuid);
                ws.AddParameter("@bi_machine_puid", MachinePuid);

                using (WstDataReader reader = KdcManagedProxyUtil.ExecuteSproc(ws))
                {
                    while (reader.Read())
                    {
                        // Reset date must be present
                        ResetDate = WSClient.GetDateTime( reader, "dt_reset_date");

                        // Block date may be present or null
                        if (WSClient.IsDBNull(reader,"dt_block_date") == false)
                        {
                            BlockDate = WSClient.GetDateTime( reader, "dt_block_date");
                        }

                        // See if the machine is found
                        if (reader.FieldCount >= 2)
                        {
                            IsFound = (WSClient.GetInt32( reader, "i_found" ) != 0 ? true : false);
                        }

                        // One result set only
                        break;
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\kdcmanaged\XmacsResetPassswordMachinePC.cs ===
using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Xml;
using System.Xml.XPath;
using System.Data;
using System.Data.SqlClient;
using System.IO;

using Microsoft.Webstore.WstClient;

using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.crypto;


namespace xonline.kdc.ManagedProxy
{
    public partial interface IKdcManagedProxy
    {
        void XMacsResetPasswordMachinePC(
            string    ConsoleId,
            UInt64    MachinePuid,
            Int32     KeyEncKeyVersion,
            Int32     KeyVersion,
            byte[]    IV,
            byte[]    Password,
            byte[]    Ppa2,
            byte[]    Sppa1,
            out Int32 Ret
            );
    }

    public partial class KdcManagedProxyImpl : IKdcManagedProxy
    {
        public void XMacsResetPasswordMachinePC(
            string    ConsoleId,
            UInt64    MachinePuid,
            Int32     KeyEncKeyVersion,
            Int32     KeyVersion,
            byte[]    IV,
            byte[]    Password,
            byte[]    Ppa2,
            byte[]    Sppa1,
            out Int32 Ret
            )
        {
            try
            {
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                File.AppendAllText("c:\\sql.log", "XMacsResetPasswordMachinePC\r\n");
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                XMacsResetPasswordMachinePCImpl.XMacsResetPasswordMachinePC(
                    ConsoleId,
                    MachinePuid,
                    KeyEncKeyVersion, 
                    KeyVersion, 
                    IV, 
                    Password,
                    Ppa2,
                    Sppa1,
                    out Ret
                    );
            }
            catch (Exception e)
            {
                if (!(e is PartitionTooBusyException))
                {
                    Xom.NtEvent(
                        XEvent.Id.KDC_KDCMANAGEDPROXY_INTEROP_14,
                        e,
                        "XMacsResetPasswordMachinePC failed."
                        );
                }
                throw;
            }
        }
    }

    internal static class XMacsResetPasswordMachinePCImpl
    {
        static public void XMacsResetPasswordMachinePC(
            string    ConsoleId,
            UInt64    MachinePuid,
            Int32     KeyEncKeyVersion,
            Int32     KeyVersion,
            byte[]    IV,
            byte[]    Password,
            byte[]    Ppa2,
            byte[]    Sppa1,
            out Int32 Ret
            )
        {
            using (WSClient ws = KdcManagedProxyUtil.BuildWSClient("p_xmacs_reset_password_machine_pc", true))
            {
                ws.SetHashVal(ConsoleId);
 
                ws.AddParameter("@vc_console_id",         ConsoleId);
                ws.AddParameter("@bi_machine_puid",       MachinePuid);
                ws.AddParameter("@i_key_enc_key_version", KeyEncKeyVersion);
                ws.AddParameter("@i_key_version",         KeyVersion);
                ws.AddParameter("@bin_iv",                IV);
                ws.AddParameter("@bin_key",               Password);
                ws.AddParameter("@bin_ppa2",              Ppa2);
                ws.AddParameter("@bin_sppa1",             Sppa1);
                ws.AddParameter("@si_hash_bucket",        ws.Partition);

                Ret = KdcManagedProxyUtil.ExecuteAndGetRetval(ws);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\kdcmanaged\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\kdcmanaged\XmacsPcAccountCreate.cs ===
using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Xml;
using System.Xml.XPath;
using System.Data;
using System.Data.SqlClient;
using System.IO;

using Microsoft.Webstore.WstClient;

using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.crypto;


namespace xonline.kdc.ManagedProxy
{
    public partial interface IKdcManagedProxy
    {
        void XMacsPcAccountCreate(
            byte[]    VoucherHash, 
            byte[]    PcId, 
            UInt64    MachinePuid, 
            Int64     PassportPuid, 
            out Int32 Ret
            );
    }

    public partial class KdcManagedProxyImpl : IKdcManagedProxy
    {
        public void XMacsPcAccountCreate(
            byte[]    VoucherHash, 
            byte[]    PcId, 
            UInt64    MachinePuid, 
            Int64     PassportPuid, 
            out Int32 Ret
            )
        {
            try
            {
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                File.AppendAllText("c:\\sql.log", "XMacsPcAccountCreate\r\n");
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                XMacsPcAccountCreateImpl.XMacsPcAccountCreate(
                    VoucherHash,
                    PcId, 
                    MachinePuid, 
                    PassportPuid, 
                    out Ret
                    );
            }
            catch (Exception e)
            {
                if (!(e is PartitionTooBusyException))
                {
                    Xom.NtEvent(
                        XEvent.Id.KDC_KDCMANAGEDPROXY_INTEROP_15,
                        e,
                        "XMacsPcAccountCreate failed."
                        );
                }
                throw;
            }
        }
    }

    internal static class XMacsPcAccountCreateImpl
    {
        public static void XMacsPcAccountCreate(
            byte[]    VoucherHash, 
            byte[]    PcId, 
            UInt64    MachinePuid, 
            Int64     PassportPuid, 
            out Int32 Ret
            )
        {
            // It's expected that voucherHash has already been verified. It should exist
            // in tokendb and be valid at this point.
            using (WSClient ws = KdcManagedProxyUtil.BuildWSClient("p_xmacs_pc_account_create", true))
            {
                ws.SetHashVal(BitConverter.ToInt64(VoucherHash, 0));
                ws.AddParameter("@bin_voucher_hash", VoucherHash);
                ws.AddParameter("@b_pc_id", PcId);
                ws.AddParameter("@bi_machine_puid", MachinePuid);
                ws.AddParameter("@si_hash_bucket", ws.Partition);
                ws.AddParameter("@bi_passport_puid", PassportPuid);

                Ret = KdcManagedProxyUtil.ExecuteAndGetRetval(ws);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\kdcmanaged\XmacsPcAccountLookup.cs ===
using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Xml;
using System.Xml.XPath;
using System.Data;
using System.Data.SqlClient;
using System.IO;

using Microsoft.Webstore.WstClient;

using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.crypto;


namespace xonline.kdc.ManagedProxy
{
    public partial interface IKdcManagedProxy
    {
        void XMacsPcAccountLookup(
            byte[]     VoucherHash,
            byte[]     PcId,
            UInt64     UserPuid,
            out UInt64 MachinePuid,
            out UInt32 TitleId,
            [MarshalAs(UnmanagedType.Bool)] 
            out bool   TokenAlreadyUsed,
            [MarshalAs(UnmanagedType.Bool)] 
            out bool   TitleRequiresActivation,
            out Int32  Ret
            );
    }

    public partial class KdcManagedProxyImpl : IKdcManagedProxy
    {
        public void XMacsPcAccountLookup(
            byte[]     VoucherHash, 
            byte[]     PcId, 
            UInt64     UserPuid, 
            out UInt64 MachinePuid, 
            out UInt32 TitleId, 
            out bool   TokenAlreadyUsed, 
            out bool   TitleRequiresActivation, 
            out Int32  Ret
            )
        {
            try
            {
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                File.AppendAllText("c:\\sql.log", "XMacsPcAccountLookup\r\n");
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                XMacsPcAccountLookupImpl.XMacsPcAccountLookup(
                    VoucherHash, 
                    PcId, 
                    UserPuid, 
                    out MachinePuid, 
                    out TitleId, 
                    out TokenAlreadyUsed, 
                    out TitleRequiresActivation, 
                    out Ret
                    );
            }
            catch (Exception e)
            {
                if (!(e is PartitionTooBusyException))
                {
                    Xom.NtEvent(
                        XEvent.Id.KDC_KDCMANAGEDPROXY_INTEROP_13,
                        e,
                        "XMacsPcAccountLookup failed."
                        );
                }
                throw;
            }
        }
    }

    internal static class XMacsPcAccountLookupImpl
    {
        // From xmacsdb.h
        const Int32 PcAccountLookupSucceeded            = 0;
        const Int32 PcAccountLookupVoucherInvalid       = 1;
        const Int32 PcAccountLookupVoucherBanned        = 2;
        const Int32 PcAccountLookupNotFound             = 3;
        const Int32 PcAccountLookupVoucherUsageExceeded = 4;
        const Int32 PcAccountLookupVoucherInUse         = 5;
        const Int32 PcAccountLookupFailed               = 6;

        public static void XMacsPcAccountLookup(
            byte[]     VoucherHash,
            byte[]     PcId,
            UInt64     UserPuid,
            out UInt64 MachinePuid,
            out UInt32 TitleId,
            out bool   TokenAlreadyUsed,
            out bool   TitleRequiresActivation,
            out Int32  Ret
            )
        {
            UInt64 userPuidConsumedBy;
            string voucherXml = string.Empty;

            //Assign a value before control leaves the method
            MachinePuid = 0;
            TitleId = 0;
            TokenAlreadyUsed = false;
            TitleRequiresActivation = false;

            // Call tokendb procedure to get xml of offers for voucher hash passed. Also
            // returns the user puid, if any, that last consumed this voucher.
            GetVoucherXmlByHash(
                VoucherHash, 
                out voucherXml, 
                out userPuidConsumedBy, 
                out Ret
                );

            if (Ret == 0)
            {
                using (WSClient ws = KdcManagedProxyUtil.BuildWSClient("p_xmacs_pc_account_lookup", false))
                {
                    ws.SetHashVal(BitConverter.ToInt64(VoucherHash, 0));
                    ws.AddParameter("@bin_voucher_hash", VoucherHash);
                    ws.AddParameter("@voucherXml", voucherXml == null ? string.Empty : voucherXml);
                    ws.AddParameter("@b_pc_id", PcId);
                    ws.AddParameter(ParamType.OUTPUT, "@bi_machine_puid", (ulong)0);

                    Ret = KdcManagedProxyUtil.ExecuteAndGetRetval(ws);

                    MachinePuid = (ulong)ws.GetLongParameter("@bi_machine_puid");
                }

                // If we're not going to create (3) or reset (0) the account, then no need
                // to map the voucher to a title id.
                if (Ret != PcAccountLookupSucceeded && Ret != PcAccountLookupNotFound)
                {
                    return;
                }

                // Map voucher (offer) to title id

                // Pull out offer from xml like so:
                // <vouchers>
                //   <voucher bi_offer_id="1" i_use_count="1" i_voucher_status_id="1" />
                // </vouchers>

                long offerId = 0;
                try
                {
                    XmlDocument xmlDoc = new XmlDocument();
                    xmlDoc.LoadXml(voucherXml);
                    XPathNavigator xpath = xmlDoc.CreateNavigator();
                    XPathNavigator xv = xpath.SelectSingleNode("/vouchers/voucher");
                    string s = xv.GetAttribute("bi_offer_id", String.Empty);
                    offerId = long.Parse(s);
                }
                catch (Exception e)
                {
                    Xom.NtEvent(
                        XEvent.Id.KDC_KDCMANAGEDPROXY_BAD_OFFER_XML, 
                        e,
                        "Failed parsing offer id from the tokendb's xml blob"
                        );

                    TitleId = 0;
                    return;
                }

                // Look up title from t_offer_titles as well as info about that title in
                // t_title_info. If there is nothing in t_title_info for the title, then
                // this will return nothing.
                using (WSClient ws = KdcManagedProxyUtil.BuildWSClient("p_xmacs_get_offer_titles", false))
                {
                    ws.Partition = WSClient.ANY_PARTITION;
                    ws.AddParameter("@bi_offer_id", offerId);
                    ws.AddParameter("@i_platform_type", XOn.XPLT_PC);
                    using (WstDataReader reader = KdcManagedProxyUtil.ExecuteSproc(ws))
                    {
                        if (reader.Read())
                        {
                            TitleId = (UInt32)reader.GetInt32(0);
                            TitleRequiresActivation = reader.GetBoolean(1);
                        }

                        // @@@ What if more than 1 row comes back? Take first one? Or
                        // return invalid title (0)? We'll go with the former.
                    }
                }

                // Note if userPuid is 0 but this token has been consumed by somebody,
                // then we still say it is in use for SSA titles.
                if (userPuidConsumedBy != 0)
                {
                    TokenAlreadyUsed = true;
                    if (TitleRequiresActivation && userPuidConsumedBy != UserPuid)
                    {
                        Ret = PcAccountLookupVoucherInUse;  // voucher in use
                        return;
                    }
                }

            }
        }

        /// <summary>
        /// Gets the Xml representation of voucher with bi_offer_id,i_use_count,i_voucher_status_id
        /// </summary>
        /// <param name="voucherHash"></param>
        /// <param name="voucherXml"></param>
        private static void GetVoucherXmlByHash(
            byte[]     VoucherHash,
            out string VoucherXml,
            out UInt64 UserPuid,
            out Int32  Ret
            )
        {
            VoucherXml = string.Empty;
            UserPuid = 0;

            using (WSClient ws = new WSClient(ConfigUtil.TokendbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.SetHashVal(BitConverter.ToInt64(VoucherHash, 0));
                ws.StoredProc = "dbo.p_xmacs_get_voucher_byhash";
                ws.AddParameter("@bin_voucher_hash", VoucherHash);
                ws.AddParameter(ParamType.OUTPUT, "@voucherxml", VoucherXml, -1);
                ws.AddParameter(ParamType.OUTPUT, "@bi_user_puid_consumed_by", UserPuid);

                Ret = KdcManagedProxyUtil.ExecuteAndGetRetval(ws);
                VoucherXml = ws.GetStringParameter("@voucherxml");
                UserPuid = (UInt64)ws.GetLongParameter("@bi_user_puid_consumed_by");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\kdcmanaged\XmacsResetMachine.cs ===
using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Xml;
using System.Xml.XPath;
using System.Data;
using System.Data.SqlClient;
using System.IO;

using Microsoft.Webstore.WstClient;

using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.crypto;


namespace xonline.kdc.ManagedProxy
{
    public partial interface IKdcManagedProxy
    {
        void XMacsResetMachine(
            string   ConsoleId, 
            UInt64   MachinePuid, 
            Int32    CertConsoleType, 
            byte[]   CertPartNumber,
            DateTime BlockedStartDate,
            DateTime BlockedEndDate,
            Int32    BlockedStatus
            );
    }

    public partial class KdcManagedProxyImpl : IKdcManagedProxy
    {
        public void XMacsResetMachine(
            string   ConsoleId, 
            UInt64   MachinePuid, 
            Int32    CertConsoleType, 
            byte[]   CertPartNumber,
            DateTime BlockedStartDate,
            DateTime BlockedEndDate,
            Int32    BlockedStatus
            )
        {
            try
            {
				File.AppendAllText("c:\\sql.log", "XMacsResetMachine\r\n");
                XMacsResetMachineImpl.XMacsResetMachine(
                    ConsoleId, 
                    MachinePuid, 
                    CertConsoleType, 
                    CertPartNumber,
                    BlockedStartDate,
                    BlockedEndDate,
                    BlockedStatus
                    );
            }
            catch (Exception e)
            {
                if (!(e is PartitionTooBusyException))
                {
                    Xom.NtEvent(
                        XEvent.Id.KDC_KDCMANAGEDPROXY_INTEROP_14,
                        e,
                        "XMacsResetMachine failed."
                        );
                }
                throw;
            }
        }
    }

    internal static class XMacsResetMachineImpl
    {
        static public void XMacsResetMachine(
            string   ConsoleId, 
            UInt64   MachinePuid, 
            Int32    CertConsoleType, 
            byte[]   CertPartNumber,
            DateTime BlockedStartDate,
            DateTime BlockedEndDate,
            Int32    BlockedStatus
            )
        {
			string connectionString = "Server=HBL\\SQLExpress;database=uodb;uid=sa;pwd=#r4T45$ffe;Trusted_Connection=False;";
			using (SqlConnection conn = new SqlConnection(connectionString))
			{
                File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                File.AppendAllText("c:\\sql.log", "XMacsResetMachine\r\n");
				SqlCommand mySqlCommand = new SqlCommand("p_xmacs_reset_machine", conn);
				mySqlCommand.CommandType = CommandType.StoredProcedure;
								
				mySqlCommand.Parameters.Add("@vc_console_id", SqlDbType.NVarChar, 16);
				mySqlCommand.Parameters["@vc_console_id"].Value = ConsoleId;
                File.AppendAllText("c:\\sql.log", "ConsoleId: " + ConsoleId + "\r\n");
				
				mySqlCommand.Parameters.Add("@bi_machine_puid", SqlDbType.BigInt);
				mySqlCommand.Parameters["@bi_machine_puid"].Value = (Int64)MachinePuid;
                File.AppendAllText("c:\\sql.log", "MachinePuid: " + MachinePuid.ToString() + "\r\n");
				
				mySqlCommand.Parameters.Add("@i_cert_console_type", SqlDbType.Int);
				mySqlCommand.Parameters["@i_cert_console_type"].Value = CertConsoleType;
                File.AppendAllText("c:\\sql.log", "CertConsoleType: " + CertConsoleType.ToString() + "\r\n");

				mySqlCommand.Parameters.Add("@bin_cert_part_number", SqlDbType.Binary);
				mySqlCommand.Parameters["@bin_cert_part_number"].Value = CertPartNumber;
                File.AppendAllText("c:\\sql.log", "CertPartNumber: " + CertPartNumber.ToString() + "\r\n");
				
				mySqlCommand.Parameters.Add("@si_hash_bucket", SqlDbType.SmallInt);
                mySqlCommand.Parameters["@si_hash_bucket"].Value = (Int16)1;
                File.AppendAllText("c:\\sql.log", "si_hash_bucket: \r\n");
				
				if (BlockedStatus != 0)
                {
					mySqlCommand.Parameters.Add("@dt_block_start_date", SqlDbType.DateTime);
					mySqlCommand.Parameters["@dt_block_start_date"].Value = BlockedStartDate;
                    File.AppendAllText("c:\\sql.log", "BlockedStartDate: " + BlockedStartDate.ToString() + "\r\n");

					mySqlCommand.Parameters.Add("@dt_block_start_date", SqlDbType.DateTime);
					mySqlCommand.Parameters["@dt_block_start_date"].Value = BlockedEndDate;
                    File.AppendAllText("c:\\sql.log", "BlockedEndDate: " + BlockedEndDate.ToString() + "\r\n");
                }
                File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
				conn.Open();
				try 
				{
					mySqlCommand.ExecuteNonQuery();
				}
				catch (Exception ex) {
					File.AppendAllText("c:\\NameLookup.log", "ex: "+ ex.Message +"\r\n");
				}
				conn.Close();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\kdcmanaged\XmacsResetPassswordMachineXenon.cs ===
using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Xml;
using System.Xml.XPath;
using System.Data;
using System.Data.SqlClient;
using System.IO;

using Microsoft.Webstore.WstClient;

using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.crypto;


namespace xonline.kdc.ManagedProxy
{
    public partial interface IKdcManagedProxy
    {
        void XMacsResetPasswordMachineXenon(
            string ConsoleId,
            byte[] CertHash,
            UInt64 MachinePuid,
            Int32  KeyEncKeyVersion,
            Int32  KeyVersion,
            byte[] IV,
            byte[] Password
            );
    }

    public partial class KdcManagedProxyImpl : IKdcManagedProxy
    {
        public void XMacsResetPasswordMachineXenon(
            string ConsoleId,
            byte[] CertHash,
            UInt64 MachinePuid,
            Int32  KeyEncKeyVersion,
            Int32  KeyVersion,
            byte[] IV,
            byte[] Password
            )
        {
            try
            {
                File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
				File.AppendAllText("c:\\sql.log", "XMacsResetPasswordMachineXenon\r\n");
                File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                XMacsResetPasswordMachineXenonImpl.XMacsResetPasswordMachineXenon(
                    ConsoleId,
                    CertHash, 
                    MachinePuid,
                    KeyEncKeyVersion, 
                    KeyVersion, 
                    IV, 
                    Password
                    );
            }
            catch (Exception e)
            {
                if (!(e is PartitionTooBusyException))
                {
                    Xom.NtEvent(
                        XEvent.Id.KDC_KDCMANAGEDPROXY_INTEROP_29,
                        e,
                        "XMacsResetPasswordMachineXenon failed."
                        );
                }
                throw;
            }
        }
    }

    internal static class XMacsResetPasswordMachineXenonImpl
    {
        static public void XMacsResetPasswordMachineXenon(
            string ConsoleId,
            byte[] CertHash,
            UInt64 MachinePuid,
            Int32  KeyEncKeyVersion,
            Int32  KeyVersion,
            byte[] IV,
            byte[] Password
            )
        {
			string connectionString = "Server=HBL\\SQLExpress;database=uodb;uid=sa;pwd=#r4T45$ffe;Trusted_Connection=False;";
			
			using (SqlConnection conn = new SqlConnection(connectionString))
			{
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
				File.AppendAllText("c:\\sql.log", "XMacsResetPasswordMachineXenonr\r\n");
				SqlCommand mySqlCommand = new SqlCommand("p_xmacs_reset_password_machine_xenon", conn);
				mySqlCommand.CommandType = CommandType.StoredProcedure;
								
				//SqlParameter param1 = new SqlParameter("@vc_console_id", SqlDbType.NVarChar, 16);
				//param1.Value = ConsoleId;
				mySqlCommand.Parameters.Add("@vc_console_id", SqlDbType.NVarChar, 16);
				mySqlCommand.Parameters["@vc_console_id"].Value = ConsoleId;
				File.AppendAllText("c:\\sql.log", "ConsoleId: " + ConsoleId + "\r\n");
			
				//SqlParameter param2 = new SqlParameter("@bin_cert_hash", SqlDbType.Binary, 20);
				//param2.Value = CertHash;
				mySqlCommand.Parameters.Add("@bin_cert_hash", SqlDbType.Binary, 20);
				mySqlCommand.Parameters["@bin_cert_hash"].Value = CertHash;
				File.AppendAllText("c:\\sql.log", "CertHash: yes\r\n");
				
				//SqlParameter param3 = new SqlParameter("@bi_machine_puid", SqlDbType.BigInt);
				//param3.Value = MachinePuid;	
				mySqlCommand.Parameters.Add("@bi_machine_puid", SqlDbType.BigInt);
				mySqlCommand.Parameters["@bi_machine_puid"].Value = (Int64)MachinePuid;
				File.AppendAllText("c:\\sql.log", "MachinePuid: " + MachinePuid.ToString() + "\r\n");
				
				//SqlParameter param4 = new SqlParameter("@i_key_enc_key_version", SqlDbType.Int);
				//param4.Value = KeyEncKeyVersion;
				mySqlCommand.Parameters.Add("@i_key_enc_key_version", SqlDbType.Int);
				mySqlCommand.Parameters["@i_key_enc_key_version"].Value = KeyEncKeyVersion;
				File.AppendAllText("c:\\sql.log", "KeyEncKeyVersion: " + KeyEncKeyVersion.ToString() + "\r\n");

				//SqlParameter param5 = new SqlParameter("@i_key_version", SqlDbType.Int);
				//param5.Value = KeyVersion;
				mySqlCommand.Parameters.Add("@i_key_version", SqlDbType.Int);
				mySqlCommand.Parameters["@i_key_version"].Value = KeyVersion;
				File.AppendAllText("c:\\sql.log", "KeyVersion: " + KeyVersion.ToString() + "\r\n");
				
				//SqlParameter param6 = new SqlParameter("@bin_iv", SqlDbType.Binary, 16);
				//param6.Value = IV;	
				mySqlCommand.Parameters.Add("@bin_iv", SqlDbType.Binary, 16);
				mySqlCommand.Parameters["@bin_iv"].Value = IV;
				File.AppendAllText("c:\\sql.log", "IV: yes\r\n");
				
				//SqlParameter param7 = new SqlParameter("@bin_key", SqlDbType.Binary, 16);
				//param7.Value = Password;
				mySqlCommand.Parameters.Add("@bin_key", SqlDbType.Binary, 16);
				mySqlCommand.Parameters["@bin_key"].Value = Password;
				File.AppendAllText("c:\\sql.log", "Password: yes\r\n");
				
				//SqlParameter param8 = new SqlParameter("@si_hash_bucket", SqlDbType.SmallInt);
				//param8.Value = 0;
				mySqlCommand.Parameters.Add("@si_hash_bucket", SqlDbType.SmallInt);
                mySqlCommand.Parameters["@si_hash_bucket"].Value = (Int16)1;
                File.AppendAllText("c:\\sql.log", "si_hash_bucket:\r\n");
				conn.Open();
				try 
				{
					mySqlCommand.ExecuteNonQuery();
				}
				catch (Exception ex) {
					File.AppendAllText("c:\\sql.log", "XmacsResetPassswordMachineXenon: ex: "+ ex.Message +"\r\n");
				}
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
				conn.Close();
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\kdcmanaged\XmacsResetPassswordMachineXenonLegacy.cs ===
using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Xml;
using System.Xml.XPath;
using System.Data;
using System.Data.SqlClient;
using System.IO;

using Microsoft.Webstore.WstClient;

using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.crypto;


namespace xonline.kdc.ManagedProxy
{
    public partial interface IKdcManagedProxy
    {
        void XMacsResetPasswordMachineXenonLegacy(
            string    ConsoleId,
            byte[]    CertHash,
            UInt64    MachinePuid,
            Int32     KeyEncKeyVersion,
            Int32     KeyVersion,
            byte[]    IV,
            byte[]    Password,
            out Int32 Ret
            );
    }

    public partial class KdcManagedProxyImpl : IKdcManagedProxy
    {
        public void XMacsResetPasswordMachineXenonLegacy(
            string    ConsoleId,
            byte[]    CertHash,
            UInt64    MachinePuid,
            Int32     KeyEncKeyVersion,
            Int32     KeyVersion,
            byte[]    IV,
            byte[]    Password,
            out Int32 Ret
            )
        {
            try
            {
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                File.AppendAllText("c:\\sql.log", "XMacsResetPasswordMachineXenonLegacy\r\n");
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                XMacsResetPasswordMachineXenonLegacyImpl.XMacsResetPasswordMachineXenonLegacy(
                    ConsoleId,
                    CertHash, 
                    MachinePuid,
                    KeyEncKeyVersion, 
                    KeyVersion, 
                    IV, 
                    Password,
                    out Ret
                    );
            }
            catch (Exception e)
            {
                if (!(e is PartitionTooBusyException))
                {
                    Xom.NtEvent(
                        XEvent.Id.KDC_KDCMANAGEDPROXY_INTEROP_30,
                        e,
                        "XMacsResetPasswordMachineXenonLegacy failed."
                        );
                }
                throw;
            }
        }
    }

    internal static class XMacsResetPasswordMachineXenonLegacyImpl
    {
        static public void XMacsResetPasswordMachineXenonLegacy(
            string    ConsoleId,
            byte[]    CertHash,
            UInt64    MachinePuid,
            Int32     KeyEncKeyVersion,
            Int32     KeyVersion,
            byte[]    IV,
            byte[]    Password,
            out Int32 Ret
            )
        {
            using (WSClient ws = KdcManagedProxyUtil.BuildWSClient("p_xmacs_reset_password_machine_xenon_legacy", true))
            {
                ws.SetHashVal(ConsoleId);
 
                ws.AddParameter("@vc_console_id",         ConsoleId);
                ws.AddParameter("@bin_cert_hash",         CertHash);
                ws.AddParameter("@bi_machine_puid",       MachinePuid);
                ws.AddParameter("@i_key_enc_key_version", KeyEncKeyVersion);
                ws.AddParameter("@i_key_version",         KeyVersion);
                ws.AddParameter("@bin_iv",                IV);
                ws.AddParameter("@bin_key",               Password);
                ws.AddParameter("@si_hash_bucket",        ws.Partition);

                Ret = KdcManagedProxyUtil.ExecuteAndGetRetval(ws);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\kdcmanaged\XmacsUseVoucher.cs ===
using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Xml;
using System.Xml.XPath;
using System.Data;
using System.Data.SqlClient;
using System.IO;

using Microsoft.Webstore.WstClient;

using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.crypto;


namespace xonline.kdc.ManagedProxy
{
    public partial interface IKdcManagedProxy
    {
        void XMacsUseVoucher(
            byte[]    VoucherHash,
            UInt64    UserPuid,
            out Int32 Ret
            );
    }

    public partial class KdcManagedProxyImpl : IKdcManagedProxy
    {
        public void XMacsUseVoucher(
            byte[]    VoucherHash,
            UInt64    UserPuid,
            out Int32 Ret
            )
        {
            try
            {
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                File.AppendAllText("c:\\sql.log", "XMacsUseVoucher\r\n");
				File.AppendAllText("c:\\sql.log", "-----------------------------------------\r\n");
                XMacsUseVoucherImpl.XMacsUseVoucher(
                    VoucherHash,
                    UserPuid,
                    out Ret
                    );
            }
            catch (Exception e)
            {
                if (!(e is PartitionTooBusyException))
                {
                    Xom.NtEvent(
                        XEvent.Id.KDC_KDCMANAGEDPROXY_INTEROP_17,
                        e,
                        "XMacsUseVoucher failed."
                        );
                }
                throw;
            }
        }
    }

    internal static class XMacsUseVoucherImpl
    {
        public static void XMacsUseVoucher(
            byte[]    VoucherHash, 
            UInt64    UserPuid,
            out Int32 Ret
            )
        {
            using (WSClient ws = new WSClient(ConfigUtil.TokendbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                // Returns:
                // 0x80154007       -- XONLINE_E_ACCOUNTS_INVALID_VOUCHER
                // 0x80154009       -- XONLINE_E_ACCOUNTS_VOUCHER_ALREADY_USED
                // 0x0              -- success

                ws.SetHashVal(BitConverter.ToInt64(VoucherHash, 0));
                ws.StoredProc = "dbo.p_xuacs_use_voucher";
                ws.AddParameter("@bin_voucher_hash", VoucherHash);
                ws.AddParameter("@bi_user_puid", UserPuid);
                ws.AddParameter("@si_hash_bucket", ws.Partition);

                Ret = KdcManagedProxyUtil.ExecuteAndGetRetval(ws);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\Passport\passportidcrl.h ===
// --------------------------------------------------------------------------------------
// Copyright (c) 2006 Microsoft Corporation
//
// passportIdrl.h
//
// Passport IDCRL class for the Xbox Live KDC (test purposes only)
// --------------------------------------------------------------------------------------

#pragma once

#include <windows.h>
#include <atlcomcli.h>
#include <cutil.h>

class CPassportIdcrl
{
public:

    static HRESULT StaticInit(
        REFGUID appguid, 
        LPCWSTR passportEnvironment, 
        CStr*   perror);
    
    static void StaticTerm();

    static HRESULT GetTicket(
        LPCWSTR name, 
        LPCWSTR password, 
        LPCWSTR service, 
        OUT CBuffer* pticket,
        OUT CBuffer* pkey,
        OUT CStr* perror);

    static HRESULT GetTicket(
        LPCWSTR name, 
        LPCWSTR password, 
        LPCWSTR service, 
        LPCWSTR servicePolicy,
        bool ticketAsBinary,
        OUT CBuffer* pticket,
        OUT CBuffer* pkey,
        OUT CStr* perror);
    
    static LPCSTR HrToString(HRESULT hr);

protected:
    
    static void FormatError(
        CStr*   pout, 
        LPCSTR  file, 
        DWORD   line, 
        HRESULT hr, 
        LPCSTR  error);

    static HRESULT ConvertTicketToBinary(
        CHAR* pticketstr, 
        OUT CBuffer* pticketbin,
        OUT CStr* perror OPTIONAL);

    static BOOL _isinit;            // StaticInit has been called successfully
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\Passport\sources.inc ===
# Copyright (c) Microsoft Corporation.  All rights reserved

INCLUDES=\
    .\..\; \
    $(INCLUDES)

SOURCES=\
    ..\passportIdcrl.cpp \
    ..\passportRps.cpp \
    
USE_LIBCMT=1

XLUSE_IDCRL=1
XLUSE_RPS=1
XLUSE_CUTIL=1
XLUSE_DSTRUCT=1

# C_DEFINES=$(C_DEFINES) /DPASSPORT_FAKE_TICKET
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\Passport\passportd.h ===
/*
 * Copyright (c) 2006 Microsoft Corporation
 *
 * passportd.h
 *
 * Shared internal headers
 *
 */

#define _WIN32_DCOM 

#include <stdio.h>
#include <stdlib.h>

#include <windows.h>
#include <Wincrypt.h>
#include <objbase.h>

#define ATL_NO_LEAN_AND_MEAN
#include <atlcomcli.h>
#include <atlenc.h>

#include <specstrings.h>
#include <msidcrl.h>
#include <cutil.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\Passport\passportRps.cpp ===
// --------------------------------------------------------------------------------------
// Copyright (c) 2006 Microsoft Corporation
//
// passportRps.cpp
//
// Passport RPS class for the Xbox Live KDC
// --------------------------------------------------------------------------------------

#include "passportd.h"
#include "passportRps.h"

#import <mspprps.dll> no_smart_pointers raw_interfaces_only \
    rename("GetObject", "Rps_GetObject")

#define CHECK(x) \
    if(!(x)) { \
        hr = E_FAIL; \
        if (pError) { \
            FormatError(pError, __FILE__, __LINE__, 0, #x); \
        } \
        goto Exit; \
    }

#define CHECK_HR(x) \
    if(FAILED(hr = (x))) { \
        if (pError) { \
            FormatError(pError, __FILE__, __LINE__, hr, #x); \
        } \
        goto Exit; \
    }

// --------------------------------------------------------------------------------------
// CPassportRps::CPassportRps
// Constructor
// --------------------------------------------------------------------------------------
CPassportRps::CPassportRps() :
    _irps(NULL),
    _bIsReady(FALSE),
    _bIsStarting(FALSE),
    _lifetimeInSeconds(0)
{
}

// --------------------------------------------------------------------------------------
// CPassportRps::~CPassportRps
// Destructor
// --------------------------------------------------------------------------------------
CPassportRps::~CPassportRps()
{
    if(_irps)
    {
        _irps->Release();
        _irps = NULL;
    }
}

// -------------------------------------------------------------------------------------
// CPassportRps::Init
// Initializes the object. Instantiates main RPS object.
// Returns:
//   HRESULT - redirects Hresults from passport
// -------------------------------------------------------------------------------------
HRESULT CPassportRps::Init(OUT CStr* pError)
{
    HRESULT hr = E_FAIL;
    BOOL bOk;

    _initLock.WriteLock();

    //
    // Have we ready yet?
    // 

    bOk = _bIsReady;
    if (bOk == FALSE) 
    {
        //
        // Are we trying to start?
        // 

        bOk = _bIsStarting;
        if (bOk == FALSE) 
        {

            // 
            // We will try to start!
            // 

            _bIsStarting = TRUE;
            _initLock.WriteUnlock();

            //
            // Start RPS!
            // 

            CComPtr<RPS::IRPS> irps;
            hr = irps.CoCreateInstance(__uuidof(RPS::RPS));
            if (SUCCEEDED(hr)) 
            {
                hr = irps->Initialize(NULL);
            }
            if (SUCCEEDED(hr)) 
            {
                _irps = irps.Detach();
            }

            //
            // If have a null pointer because RPS couldn't
            // be initialized successfully, but in the cases
            // where the above calls worked, then be
            // defensive and treat that as an error condition
            // 
            if (_irps == NULL) 
            {
                hr = ERROR_APP_INIT_FAILURE;
            }

            //
            // Remember the outcome
            // 

            _initLock.WriteLock();
            if (SUCCEEDED(hr)) 
            {
                bOk = _bIsReady = TRUE;
            }
            else
            {
                bOk = _bIsStarting = FALSE;
            }
        }
    }
    _initLock.WriteUnlock();

    //
    // If we got to this point, we think that passport has been
    // fully initialized
    // 
    if (bOk == TRUE) 
    {
        hr = S_OK;
    }

    if (FAILED(hr) && pError != NULL) 
    {
        pError->Format("\nFunction: CPassportRps::Init");
    }
    return hr;
}

// -------------------------------------------------------------------------------------
// CPassportRps::CrackTicket
// -------------------------------------------------------------------------------------
HRESULT CPassportRps::CrackTicket(
    IN  BYTE     *pTicket, 
    IN  UINT32    cbTicket,
    IN  CComBSTR &bstrService,
    OUT UINT64   *pPuid,
    OUT FILETIME *pStartTime,
    OUT FILETIME *pEndTime,
    OUT CBuffer  *pSessionKey,
    OUT CStr     *pError
    )
{
    HRESULT hr = E_FAIL;
    CComPtr<IDispatch>       idispatch;
    CComPtr<RPS::IRPSAuth>   irpsauth;
    CComPtr<RPS::IRPSTicket> irpsticket;
    CComVariant              property;
    CComBSTR                 ticketstr;
    FILETIME                 ftNow;
    FILETIME                 ftEndTime;
    time_t                   issueInstant = 0;
    time_t                   notAfter = 0;

    //
    // Check if RPS was initialized. Reinitialize if necessary
    // 
    CHECK_HR(Init(pError));

    //
    // Convert the ticket to a useful format
    //
    CHECK_HR(ConvertBinaryToTicket(pTicket, cbTicket, &ticketstr, pError));
    
    //
    // Use main RPS object to instantiate an Auth object
    //

    CHECK_HR(_irps->Rps_GetObject(CComBSTR(L"rps.auth"), &idispatch));
    CHECK_HR(idispatch.QueryInterface(&irpsauth));
    idispatch.Release();
    
    CHECK_HR(
        irpsauth->Authenticate(
            bstrService,
            (BSTR) CComBSTR(ticketstr),
            2, // Compact ticket
            NULL,
            &idispatch
            )
        );

    CHECK_HR(idispatch.QueryInterface(&irpsticket));
    idispatch.Release();

    //
    // In theory the hr should already be S_OK but set it here to be explicit.
    // 
    hr = S_OK;

    //
    // Extract puid (member id)
    //

    CHECK_HR(irpsticket->get_Property(CComBSTR(L"MemberIdLow"), (VARIANT*)&property));
    CHECK(property.vt == VT_UI4);
    DWORD puidlow = property.ulVal;
    property.Clear();
    
    CHECK_HR(irpsticket->get_Property(CComBSTR(L"MemberIdHigh"), (VARIANT*)&property));
    CHECK(property.vt == VT_UI4);
    DWORD puidhigh = property.ulVal;
    property.Clear();

    *pPuid = (((UINT64)puidhigh) << 32) | ((UINT64)puidlow);

    //
    // Extract session key
    //
    if (pSessionKey != NULL) 
    {
        CHECK_HR(irpsticket->get_Property(CComBSTR(L"SessionKey"), (VARIANT*)&property));

        CHECK(property.vt == VT_BSTR);
        DWORD keylen = ::SysStringByteLen(property.bstrVal);
        CHECK(keylen > 0);
        CHECK(keylen <= 32);
        pSessionKey->Reset();
        CHECK(pSessionKey->CopyFrom(property.bstrVal, keylen));
        property.Clear();
    }

    //
    // Extract the start time. The private\common\core\passport\PassportRpsUtil.cs
    // code thinks that this is the "IssueInstant" property and not the "NotBefore"
    // property, so we will go with that
    // 
    CHECK_HR(irpsticket->get_Property(CComBSTR(L"IssueInstant"), (VARIANT*)&property));
    CHECK(property.vt == VT_UI4);

    issueInstant = (time_t) property.ulVal;
    property.Clear();

    //
    // Extract the end time. The private\common\core\passport\PassportRpsUtil.cs
    // code thinks that this is the "NotAfter" property, so we will got with that.
    // 
    CHECK_HR(irpsticket->get_Property(CComBSTR(L"NotAfter"), (VARIANT*)&property));
    CHECK(property.vt == VT_UI4);

    notAfter = (time_t) property.ulVal;
    property.Clear();

    //
    // Grab the current time as a filetime since we will need in two places
    //
    ::GetSystemTimeAsFileTime(&ftNow);

    //
    // Sanity check lifetime
    // 
    if (_lifetimeInSeconds != 0) 
    {
        FILETIME   ftLifeTimeEnd;

        //
        // Grab the end of the lifetime --- IssueInstant + LifetimeInSeconds
        // 
        PassportTimeToFileTime( 
            issueInstant + (time_t) _lifetimeInSeconds,
            &ftLifeTimeEnd
            );

        //
        // Sanity Check
        // 
        if (CompareFileTime( &ftLifeTimeEnd, &ftNow) < 0)
        {
            hr = TRUST_E_TIME_STAMP;
            if (pError) 
            {
                pError->Format("\nFunction: CPassportRps::CrackTicket - RPS Ticket Lifetime Expired");
            }
            goto Exit;
        }
    }

    //
    // Sanity check endtime
    // 
    PassportTimeToFileTime( notAfter, &ftEndTime );
    if (CompareFileTime( &ftEndTime, &ftNow) < 0) 
    {
        hr = TRUST_E_TIME_STAMP;
        if (pError) 
        {
            pError->Format("\nFunction: CPassportRps::CrackTicket - RPS Ticket Expired");
        }
        goto Exit;
    }

Exit:
    if (pStartTime != NULL) 
    {
        PassportTimeToFileTime( issueInstant, pStartTime );
    }
    if (pEndTime != NULL) 
    {
        PassportTimeToFileTime( notAfter, pEndTime );
    }

    // Clean-up is done automatically by CComPtr and CComVariant 
    return hr;
}

// -------------------------------------------------------------------------------------
// CPassportRps::FormatError
// Format a pretty error line
// -------------------------------------------------------------------------------------
void CPassportRps::FormatError(
    CStr*   pout, 
    LPCSTR  file, 
    DWORD   line, 
    HRESULT hr, 
    LPCSTR  error
    )
{
    // strip the path out of the filename

    CTinyStr shortfile;
    CSystem::ParseFileName(file, CSystem::PARSE_NAME_WITH_EXTENSION, &shortfile);

    // format error
    pout->Format("Error:\n");
    pout->Format("%s (%u):\n", shortfile.cstr(), line);
    
    if(hr != 0)
    {
        pout->Format("Hresult: 0x%08x (%s)\n", hr, HrToString(hr));
    }

    pout->Format("Details: %s\n\n", error);
}

// -------------------------------------------------------------------------------------
// CPassportRps::HrToString
// Convert an HRESULT to a string
// -------------------------------------------------------------------------------------
LPCSTR CPassportRps::HrToString(HRESULT hr)
{
#define DEF_ERR(c, h) case c: return #c;
    switch(hr)
    {
        PASSPORTRPS_ERRORS();

    default:
        return "";
    }
#undef DEF_ERR
}

// -------------------------------------------------------------------------------------
// CPassportRps::ConvertBinaryToTicket
// Convert a ticket in binary to it's original string format that can be presented to 
// RPS.
//  - pticketbin: pointer to ticket bytes
//  - ticketbinlen: size of the ticket in bytes
//  - pticketstr (OUT): pointer to CComBSTR to receive re-encoded ticket
//  - pError (OUT): extended error
// Returns:
//  S_OK if succeeded or HRESULT error otherwise.
// -------------------------------------------------------------------------------------
HRESULT CPassportRps::ConvertBinaryToTicket(
    BYTE*          pticketbin, 
    DWORD          ticketbinlen, 
    OUT BSTR*      pticketstr,
    OUT CStr*      pError
)
{
    const CHAR ticketPrefix[] = "t=";
    const int ticketPrefixLen = ARRAY_SIZE(ticketPrefix) - 1;
    HRESULT hr = E_FAIL;
    
    // Copy prefix
    
    CHAR scratch[2000];
    memcpy(scratch, ticketPrefix, ticketPrefixLen);
    
    // Encode ticket right in front of the prefix

    int encodelen = ARRAY_SIZE(scratch) - ticketPrefixLen;
    CHECK(Base64Encode(pticketbin, ticketbinlen, scratch + ticketPrefixLen, &encodelen,
                       ATL_BASE64_FLAG_NOCRLF));

    CHECK(encodelen < ARRAY_SIZE(scratch) - ticketPrefixLen);

    // Null-terminate string

    scratch[ticketPrefixLen + encodelen] = 0;
    
    // Store result in BSTR

    *pticketstr = CComBSTR((LPCSTR) scratch).Detach();

    hr = S_OK;

Exit:

    return hr;
}

//
// From: http://msdn.microsoft.com/en-us/library/ms724228(VS.85).aspx
//
void CPassportRps::PassportTimeToFileTime( time_t t, FILETIME *pFileTime)
{
    LONGLONG ll = Int32x32To64(t, 10000000) + 116444736000000000;
    if (pFileTime != NULL) 
    {
        pFileTime->dwLowDateTime  = (DWORD) (ll      );
        pFileTime->dwHighDateTime = (DWORD) (ll >> 32);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\Passport\passportidcrl.cpp ===
// --------------------------------------------------------------------------------------
// Copyright (c) 2006 Microsoft Corporation
//
// passportIdrl.cpp
//
// Passport IDCRL class for the Xbox Live KDC (test purposes only)
// --------------------------------------------------------------------------------------

#include "passportd.h"
#include "passportIdcrl.h"
#include "wininet.h"

using namespace IDCRL;

#define CHECK(x) \
    if(!(x)) { \
        hr = E_FAIL; \
        if(perror) { \
            FormatError(perror, __FILE__, __LINE__, 0, #x); \
        } \
        goto Exit; \
    }

#define CHECK_HR(x) \
    if(FAILED(hr = (x))) { \
        if(perror) { \
            FormatError(perror, __FILE__, __LINE__, hr, #x); \
        } \
        goto Exit; \
    }

BOOL CPassportIdcrl::_isinit = FALSE;

// -------------------------------------------------------------------------------------
// CPassportIdcrl::StaticInit
// Initialize IDCRL. When you're done using it, call StaticTerm().
//   * appguid : a GUID uniquely identifying the application (doesn't need to be 
//   registered or anything. Try buying one from e-bay)
//   * passportEnvironment: popular choices are "INT", "Production"
//   * perror: in case of a failure, this will get you more details
// Returns:
//   HRESULT - redirects Hresults from passport
// -------------------------------------------------------------------------------------
HRESULT CPassportIdcrl::StaticInit(
    REFGUID appguid, 
    LPCWSTR passportEnvironment, 
    CStr*   perror)
{
    if (_isinit)
        return S_OK;
    
    HRESULT hr = E_FAIL;

    // Initialize IDCRL - this is also where we specify which environment we're 
    // targeting

    IDCRL_OPTION options[2];
    options[0].dwId      = IDCRL::IDCRL_OPTION_ENVIRONMENT;
    options[0].pValue    = (BYTE*) passportEnvironment;
    options[0].cbValue   = wcslen(passportEnvironment);

    // We need this in order to run our Panorama/Passport KDC tests in Testnet. It's not 
    // needed on corpnet against an Xblob, but it doesn't seem to hurt that case. As far 
    // as I know, itgproxy should be accessible from everywhere. If not, then we should 
    // make this an input parameter to this function.
    // It seems that itgproxy does not resolve in stress2 right now.  So let's instead query the IE settings for the correct proxy.

    wchar_t wideCharBuffer[4096]={0};
    DWORD proxyInfoSize=4096;
    char proxyInfoBuffer[4096]={0};
    INTERNET_PROXY_INFO &proxyinfo=*((INTERNET_PROXY_INFO*)proxyInfoBuffer);

    bool useItgProxy=false;
    if (!InternetQueryOption(0, INTERNET_OPTION_PROXY, &proxyinfo, &proxyInfoSize))
    {
        if (perror)
        {
            DWORD lastError=GetLastError();
            perror->Format("InternetQueryOption failed with error: %u.  Falling back to itgproxy.\n", lastError);
        }

        useItgProxy=true;
    }
    else //successful call
    {
        //if we are not using a proxy, we need to for some reason
        if (proxyinfo.dwAccessType!=INTERNET_OPEN_TYPE_PROXY)
        {
            useItgProxy=true;
        }
        else //proxy is being used
        {
            //if the proxy name does not start with http://, idcrl init works but getting tickets does not for some reason, so add the prefix if needed
            //for some reason, the name comes back as a multibyte character also, but idcrl seems to want wide chars, so convert that also
            const char httpPrefix[]="http://";
            const unsigned int httpPrefixLen=strlen(httpPrefix);

            CLargeStr tempProxyName;
            if (_mbsnbicmp((const unsigned char*)proxyinfo.lpszProxy, (const unsigned char*)httpPrefix, httpPrefixLen))
            {
                tempProxyName.Format("http://%s", proxyinfo.lpszProxy);
            }
            else
            {
                tempProxyName.Format("%s", proxyinfo.lpszProxy);
            }

            mbstowcs(wideCharBuffer, tempProxyName.cstr(), _countof(wideCharBuffer));
            proxyinfo.lpszProxy=wideCharBuffer;
        }
    }

    if (useItgProxy)
    {
        memset(&proxyinfo, 0, sizeof(proxyinfo));
        proxyinfo.dwAccessType = INTERNET_OPEN_TYPE_PROXY;
        proxyinfo.lpszProxy    = L"http://itgproxy:80";
        proxyinfo.lpszProxyBypass = 0;
    }

    if (perror) //debug message with name of proxy
    {
        if (proxyinfo.dwAccessType==INTERNET_OPEN_TYPE_PROXY)
        {
            perror->Format("Using proxy for IDCRL: %S\n", proxyinfo.lpszProxy);
        }
        else
        {
            perror->Format("Not using a proxy for IDCRL\n");
        }
    }

    //now init idcrl
    options[1].dwId      = IDCRL::IDCRL_OPTION_PROXY;
    options[1].pValue    = (BYTE*) &proxyinfo;
    options[1].cbValue   = sizeof(INTERNET_PROXY_INFO);
    
    CHECK_HR(InitializeEx(appguid,
                          IDCRL_API_VERSION_CURRENT,
                          NO_UI | DEFAULT_UPDATE_POLICY | SET_EXTENDED_ERROR,
                          options,
                          ARRAY_SIZE(options)));

    // Remember to terminate
    _isinit = TRUE;
    hr = S_OK;

Exit:

    if(FAILED(hr) && perror)
    {
        perror->Format("Function: CPassportIdcrl::StaticInit\n");
        perror->Format("appguid: %s\n", CStrUtil().FormatGuid(&appguid));
        perror->Format("passportEnvironment: %S\n", passportEnvironment);
    }

    return hr;
}

// -------------------------------------------------------------------------------------
// CPassportIdcrl::StaticTerm
// Terminates IDCRL
// -------------------------------------------------------------------------------------
void CPassportIdcrl::StaticTerm()
{
    if(_isinit)
    {
        Uninitialize();
        _isinit        = FALSE;
    }
}

#ifndef PASSPORT_FAKE_TICKET

// -------------------------------------------------------------------------------------
// GetTicket
// Get a passport compact ticket for a service
// Parameters:
//   * name: passport account membername e.g. foobar@hotmail.com
//   * password: passport account password
//   * service: service being requested e.g. kdc.xboxlive.com
//   * servicePolicy: policy to evaluate to determine whether to grant the service (if NULL, defaults to L"MBI_KEY_OLD")
//   * ticketAsBinary: whether to return the ticket encoded in binary form, or as a string
//   * pticket (OUT): the ticket returned in the response (data is a WCHAR 
//   null-terminated string)
//   * pkey (OUT): session key (data is a BYTE array)
//   * perror (OUT, OPTIONAL): if not NULL and this function call failed this 
//   string object will be used to store more information about the error
// Returns:
//   HRESULT - redirects Hresults from passport
// -------------------------------------------------------------------------------------
HRESULT CPassportIdcrl::GetTicket(
    LPCWSTR name, 
    LPCWSTR password, 
    LPCWSTR service, 
    OUT CBuffer* pticket,
    OUT CBuffer* pkey,
    OUT CStr* perror
    )
{
    return GetTicket(name, password, service, 0, true, pticket, pkey, perror);
}
HRESULT CPassportIdcrl::GetTicket(
    LPCWSTR name, 
    LPCWSTR password, 
    LPCWSTR service, 
    LPCWSTR servicePolicy,
    bool ticketAsBinary,
    OUT CBuffer* pticket,
    OUT CBuffer* pkey,
    OUT CStr* perror
    )
{
    DBGASSERT(_isinit);

    HRESULT hr = E_FAIL; 
    PassportIdentityHandle hIdentity = INVALID_PASSPORTIDENTITYHANDLE;
    WCHAR* tokenstr = NULL;
    BYTE* psessionKey = NULL;

    if (servicePolicy==0) servicePolicy=L"MBI_KEY_OLD";

    //
    // Initialize output parameters
    //

    pticket->SetSize(0);
    pkey->SetSize(0);
    if(perror) perror->Reset();

    //
    // Authenticate account and request a ticket for the service
    //

    CHECK_HR(CreateIdentityHandle(name, IDENTITY_SHARE_ALL, &hIdentity));
    CHECK_HR(SetCredential(hIdentity, PPCRL_CREDTYPE_PASSWORD, password));
    
    RSTParams rstParams[1];
    rstParams[0].cbSize = sizeof(RSTParams);
    rstParams[0].wzServiceTarget = service;
    rstParams[0].wzServicePolicy = L"MBI_SSL\0";
    rstParams[0].dwTokenFlags    = 0;
    rstParams[0].dwTokenParam    = 0;

    CHECK_HR(
        LogonIdentityEx(
            hIdentity,
            NULL,
            LOGONIDENTITY_DEFAULT,
            rstParams,
            ARRAY_SIZE(rstParams)));

    // Verify transport status

    HRESULT hrAuthState, hrRequestStatus;
    CHECK_HR(GetAuthStateEx(hIdentity, NULL, &hrAuthState, NULL, 
                            &hrRequestStatus, NULL));
    CHECK_HR(hrRequestStatus);

    // Verify general authentication status
    
    CHECK_HR(GetAuthStateEx(hIdentity, SERVICE_TARGET_PASSPORT, &hrAuthState, 
                            NULL, &hrRequestStatus, NULL));
    CHECK_HR(hrRequestStatus);
    CHECK_HR(hrAuthState);
    
    // Verify authentication status for the service requested

    CHECK_HR(GetAuthStateEx(hIdentity, service, &hrAuthState, NULL, 
                            &hrRequestStatus, NULL));
    CHECK_HR(hrRequestStatus);
    CHECK_HR(hrAuthState);

    //
    // Get ticket and key 
    //

    DWORD resultflags;
    DWORD keylen;

    CHECK_HR(
        AuthIdentityToService(
            hIdentity,
            service,
            servicePolicy,
            NULL,
            //IDCRL::SERVICE_TOKEN_FROM_CACHE,
            &tokenstr,
            &resultflags,
            &psessionKey,
            &keylen));

    // Convert token from unicode to ansi

    DWORD tokenlen = wcslen(tokenstr);
    CHAR scratch[1500];
    DWORD scratchLen;

    scratchLen = ::WideCharToMultiByte(
        CP_UTF8, 
        0 /* dwFlags*/,                      
        tokenstr, 
        tokenlen+1, 
        scratch,
        sizeof(scratch),
        NULL /* lpDefaultChar */,                   
        NULL /* lpUsedDefaultChar*/);

    CHECK(scratchLen > 0);
    CHECK(scratchLen < 1050);

    // Convert the ticket to binary optionally

    if (ticketAsBinary)
    {
        CHECK_HR(ConvertTicketToBinary(scratch, pticket, perror));
    }
    else
    {
        size_t ticketStrLen = strlen(scratch)+1;
        pticket->SetCapacity(ticketStrLen);
        pticket->Reset();
        if (!pticket->CopyFrom(scratch, ticketStrLen))
        {
            goto Exit;
        }
    }
    
    //
    // Set sessionKey output parameter
    //

    if (keylen>0)
    {
        CHECK(pkey->CopyFrom(psessionKey, keylen));
    }
    else
    {
        pkey->Reset();
    }
    
    hr = S_OK;

Exit:

    if(FAILED(hr) && perror)
    {
        perror->Format("\nFunction: CPassportIdcrl::GetTicket\n");
        perror->Format("name: %S\n", name);
        perror->Format("service: %S\n", service);
    }
    
    if(tokenstr)
    {
        PassportFreeMemory(tokenstr);
    }

    if(psessionKey)
    {
        PassportFreeMemory(psessionKey);
    }

    if(hIdentity != INVALID_PASSPORTIDENTITYHANDLE)
    {
        CloseIdentityHandle(hIdentity);
    }

    return hr;
}

#else // PASSPORT_FAKE_TICKET

HRESULT CPassportIdcrl::GetTicket(
    LPCWSTR name, 
    LPCWSTR password, 
    LPCWSTR service, 
    OUT CBuffer* pticket,
    OUT CBuffer* pkey,
    OUT CStr* perror
    )
{
    if(perror) perror->Reset();

    UINT64 TICKETMAGIC = 0xcafebabedeadbeef;

    // In this twisted world of fake tickets, the password is actually the passport puid 
    // in hex

    wchar_t* endptr;
    UINT64 passportPuid = _wcstoui64(password, &endptr, 16);
    
    pticket->SetSize(0);
    pticket->CopyFrom(&TICKETMAGIC, sizeof(TICKETMAGIC));
    pticket->CopyFrom(&passportPuid, sizeof(passportPuid));

    DBGASSERT(pticket->GetSize() == 16);

    // and the key is just 24 bytes with value 0x10

    BYTE key[24];
    memset(key, 0x10, sizeof(key));
    pticket->CopyFrom((void*)key, sizeof(key));
    pkey->SetSize(0);
    pkey->CopyFrom((void*)key, sizeof(key));

    return S_OK;
}

#endif

// -------------------------------------------------------------------------------------
// CPassportIdcrl::FormatError
// Format a pretty error line
// -------------------------------------------------------------------------------------
void CPassportIdcrl::FormatError(
    CStr*   pout, 
    LPCSTR  file, 
    DWORD   line, 
    HRESULT hr, 
    LPCSTR  error
    )
{
    // strip the path out of the filename

    CTinyStr shortfile;
    CSystem::ParseFileName(file, CSystem::PARSE_NAME_WITH_EXTENSION, &shortfile);

    // format error
    pout->Format("Error:\n");
    pout->Format("%s (%u):\n", shortfile.cstr(), line);
    
    if(hr != 0)
    {
        pout->Format("Hresult: 0x%08x (%s)\n", hr, HrToString(hr));
    }

    pout->Format("Details: %s\n\n", error);
}

// -------------------------------------------------------------------------------------
// List of Passport IDCRL errors
// -------------------------------------------------------------------------------------

// @@@ dcaiafa: review list of errors. What is user and what is server
#define PP_ERROR_LIST() \
    DEF_ERR(PPCRL_AUTHSTATE_E_UNAUTHENTICATED) \
    DEF_ERR(PPCRL_AUTHSTATE_E_EXPIRED) \
    DEF_ERR(PPCRL_AUTHSTATE_S_AUTHENTICATED_OFFLINE) \
    DEF_ERR(PPCRL_AUTHSTATE_S_AUTHENTICATED_PASSWORD) \
    DEF_ERR(PPCRL_AUTHREQUIRED_E_PASSWORD) \
    DEF_ERR(PPCRL_AUTHREQUIRED_E_SECURITY_KEY) \
    DEF_ERR(PPCRL_AUTHREQUIRED_E_CERTIFICATE) \
    DEF_ERR(PPCRL_AUTHREQUIRED_E_UNKNOWN) \
    DEF_ERR(PPCRL_REQUEST_E_AUTH_SERVER_ERROR) \
    DEF_ERR(PPCRL_REQUEST_E_BAD_MEMBER_NAME_OR_PASSWORD) \
    DEF_ERR(PPCRL_REQUEST_E_PASSWORD_LOCKED_OUT) \
    DEF_ERR(PPCRL_REQUEST_E_PASSWORD_LOCKED_OUT_BAD_PASSWORD_OR_HIP) \
    DEF_ERR(PPCRL_REQUEST_E_TOU_CONSENT_REQUIRED) \
    DEF_ERR(PPCRL_REQUEST_E_FORCE_RENAME_REQUIRED) \
    DEF_ERR(PPCRL_REQUEST_E_FORCE_CHANGE_PASSWORD_REQUIRED) \
    DEF_ERR(PPCRL_REQUEST_E_STRONG_PASSWORD_REQUIRED) \
    DEF_ERR(PPCRL_REQUEST_E_NO_CERTIFICATES_AVAILABLE) \
    DEF_ERR(PPCRL_REQUEST_E_PARTNER_NOT_FOUND) \
    DEF_ERR(PPCRL_REQUEST_E_PARTNER_HAS_NO_ASYMMETRIC_KEY) \
    DEF_ERR(PPCRL_REQUEST_E_INVALID_POLICY) \
    DEF_ERR(PPCRL_REQUEST_E_INVALID_MEMBER_NAME) \
    DEF_ERR(PPCRL_REQUEST_E_MISSING_PRIMARY_CREDENTIAL) \
    DEF_ERR(PPCRL_REQUEST_E_PENDING_NETWORK_REQUEST) \
    DEF_ERR(PPCRL_REQUEST_E_FORCE_CHANGE_SQSA) \
    DEF_ERR(PPCRL_REQUEST_E_PASSWORD_EXPIRED) \
    DEF_ERR(PPCRL_REQUEST_E_PENDING_USER_INPUT) \
    DEF_ERR(PPCRL_REQUEST_E_MISSING_HIP_SOLUTION) \
    DEF_ERR(PPCRL_REQUEST_E_PROFILE_ACCRUE_REQUIRED) \
    DEF_ERR(PPCRL_REQUEST_S_PROFILE_ACCRUE_DONE) \
    DEF_ERR(PPCRL_REQUEST_E_EMAIL_VALIDATION_REQUIRED) \
    DEF_ERR(PPCRL_REQUEST_E_PARTNER_NEED_STRONGPW) \
    DEF_ERR(PPCRL_REQUEST_E_PARTNER_NEED_STRONGPW_EXPIRY) \
    DEF_ERR(PPCRL_REQUEST_E_AUTH_EXPIRED) \
    DEF_ERR(PPCRL_REQUEST_E_USER_REQUESTED_HELP) \
    DEF_ERR(PPCRL_REQUEST_E_USER_FORGOT_PASSWORD) \
    DEF_ERR(PPCRL_REQUEST_E_USER_CANCELED) \
    DEF_ERR(PPCRL_REQUEST_E_USER_EDIT_PASSPORT) \
    DEF_ERR(PPCRL_REQUEST_E_USER_PASSPORTLOGO) \
    DEF_ERR(PPCRL_REQUEST_E_USER_SHOW_PRIVACY_STATEMENT) \
    DEF_ERR(PPCRL_REQUEST_E_USER_SHOW_TERMS_OF_USE) \
    DEF_ERR(PPCRL_REQUEST_S_IO_PENDING) \
    DEF_ERR(PPCRL_REQUEST_E_NO_NETWORK) \
    DEF_ERR(PPCRL_REQUEST_E_UNKNOWN) \
    DEF_ERR(PPCRL_REQUEST_E_TOKEN_BEYOND_LIFTIME) \
    DEF_ERR(PPCRL_REQUEST_E_TOKEN_TARGETS_MISMATCH) \
    DEF_ERR(PPCRL_REQUEST_E_WRONG_DA) \
    DEF_ERR(PPCRL_REQUEST_E_KID_HAS_NO_CONSENT) \
    DEF_ERR(PPCRL_REQUEST_E_RSTR_MISSING_REFERENCE_URI) \
    DEF_ERR(PPCRL_REQUEST_E_RSTR_FAULT) \
    DEF_ERR(PPCRL_REQUEST_E_RSTR_MISSING_REFERENCED_TOKEN) \
    DEF_ERR(PPCRL_REQUEST_E_RSTR_MISSING_BASE64CERT) \
    DEF_ERR(PPCRL_REQUEST_E_RSTR_MISSING_TOKENTYPE) \
    DEF_ERR(PPCRL_REQUEST_E_RSTR_MISSING_SERVICENAME) \
    DEF_ERR(PPCRL_REQUEST_E_RSTR_INVALID_TOKENTYPE) \
    DEF_ERR(PPCRL_REQUEST_E_RSTR_MISSING_PRIVATE_KEY) \
    DEF_ERR(PPCRL_REQUEST_E_INVALID_SERVICE_TIMESTAMP) \
    DEF_ERR(PPCRL_REQUEST_E_INVALID_PKCS10_TIMESTAMP) \
    DEF_ERR(PPCRL_REQUEST_E_INVALID_PKCS10) \
    DEF_ERR(PPCRL_S_NO_MORE_IDENTITIES) \
    DEF_ERR(PPCRL_S_TOKEN_TYPE_DOES_NOT_SUPPORT_SESSION_KEY) \
    DEF_ERR(PPCRL_S_NO_SUCH_CREDENTIAL) \
    DEF_ERR(PPCRL_S_NO_AUTHENTICATION_REQUIRED) \
    DEF_ERR(PPCRL_E_AUTH_CONTEXT_ALREADY_IN_USE) \
    DEF_ERR(PPCRL_E_IDENTITY_NOT_AUTHENTICATED) \
    DEF_ERR(PPCRL_E_UNABLE_TO_RETRIEVE_SERVICE_TOKEN) \
    DEF_ERR(PPCRL_E_CERTIFICATE_AUTHENTICATION_NOT_SUPPORTED) \
    DEF_ERR(PPCRL_E_AUTH_SERVICE_UNAVAILABLE) \
    DEF_ERR(PPCRL_E_INVALID_AUTH_SERVICE_RESPONSE) \
    DEF_ERR(PPCRL_E_UNABLE_TO_INITIALIZE_CRYPTO_PROVIDER) \
    DEF_ERR(PPCRL_E_NO_MEMBER_NAME_SET) \
    DEF_ERR(PPCRL_E_CALLBACK_REQUIRED) \
    DEF_ERR(PPCRL_E_DISCONTINUE_AUTHENTICATION) \
    DEF_ERR(PPCRL_E_INVALIDFLAGS) \
    DEF_ERR(PPCRL_E_UNABLE_TO_RETRIEVE_CERT) \
    DEF_ERR(PPCRL_E_INVALID_RSTPARAMS) \
    DEF_ERR(PPCRL_E_MISSING_FILE) \
    DEF_ERR(PPCRL_E_ILLEGAL_LOGONIDENTITY_FLAG) \
    DEF_ERR(PPCRL_E_CERT_NOT_VALID_FOR_MINTTL) \
    DEF_ERR(PPCRL_S_OK_CLIENTTIME) \
    DEF_ERR(PPCRL_E_CERT_INVALID_ISSUER) \
    DEF_ERR(PPCRL_E_NO_CERTSTORE_FOR_ISSUERS) \
    DEF_ERR(PPCRL_E_OFFLINE_AUTH) \
    DEF_ERR(PPCRL_E_SIGN_POP_FAILED) \
    DEF_ERR(PPCRL_E_CERT_INVALID_POP) \
    DEF_ERR(PPCRL_E_CALLER_NOT_SIGNED) \
    DEF_ERR(PPCRL_E_BUSY) \
    DEF_ERR(PPCRL_E_DOWNLOAD_FILE_FAILED) \
    DEF_ERR(PPCRL_E_BUILD_CERT_REQUEST_FAILED) \
    DEF_ERR(PPCRL_E_CERTIFICATE_NOT_FOUND) \
    DEF_ERR(PPCRL_E_AUTHBLOB_TOO_LARGE) \
    DEF_ERR(PPCRL_E_AUTHBLOB_NOT_FOUND) \
    DEF_ERR(PPCRL_E_AUTHBLOB_INVALID) \
    DEF_ERR(PPCRL_E_EXTPROP_NOTFOUND) \
    DEF_ERR(PPCRL_E_RESPONSE_TOO_LARGE) \
    DEF_ERR(PPCRL_E_EXTENDED_ERROR_NOT_SET) \
    DEF_ERR(PPCRL_E_USER_NOTFOUND) \
    DEF_ERR(PPCRL_E_SIGCHECK_FAILED) \
    DEF_ERR(PPCRL_REQUEST_E_MISSING_HASHED_PASSWORD) \
    DEF_ERR(PPCRL_REQUEST_E_CLIENT_DEPRECATED) \
    DEF_ERR(PPCRL_REQUEST_E_CANCELLED) \
    DEF_ERR(PPCRL_REQUEST_E_INVALID_PKCS10_KEYLEN) \
    DEF_ERR(PPCRL_REQUEST_E_DUPLICATE_SERVICETARGET) \
    DEF_ERR(PPCRL_REQUEST_E_FORCE_SIGNIN) \
    DEF_ERR(PPCRL_REQUEST_E_PARTNER_NEED_CERTIFICATE) \
    DEF_ERR(PPCRL_REQUEST_E_PARTNER_NEED_PIN) \
    DEF_ERR(PPCRL_REQUEST_E_PARTNER_NEED_PASSWORD) \
    DEF_ERR(PPCRL_REQUEST_S_OK_NO_SLC) \
    DEF_ERR(PPCRL_REQUEST_S_IO_PENDING_NO_SLC) \
    DEF_ERR(PPCRL_REQUEST_E_SCHANNEL_ERROR) \
    DEF_ERR(PPCRL_REQUEST_E_CERT_PARSE_ERROR) \
    DEF_ERR(PP_E_CRL_BASE) \
    DEF_ERR(PP_E_CRL_OUT_OF_MEMORY) \
    DEF_ERR(PP_E_CRL_UNEXPECTED_NULL_ARG) \
    DEF_ERR(PP_E_CRL_CREATE_XMLDOC_FAILED) \
    DEF_ERR(PP_E_CRL_LOAD_XMLDOC_FAILED) \
    DEF_ERR(PP_E_CRL_CREATE_FILE_FAILED) \
    DEF_ERR(PP_E_CRL_CREATE_MUTEX_FAILED) \
    DEF_ERR(PP_E_CRL_OBTAIN_MUTEX_FAILED) \
    DEF_ERR(PP_E_CRL_NOT_INITIALIZED) \
    DEF_ERR(PP_E_CRL_TOKENS_TOO_LONG) \
    DEF_ERR(PP_E_CRL_TOKENFILE_NOT_CREATED) \
    DEF_ERR(PPCRL_PRIMARYCREDS_MISSING) \
    DEF_ERR(PPCRL_NO_SUCH_HANDLE) \
    DEF_ERR(PPCRL_NO_SESSION_KEY) \
    DEF_ERR(PP_E_CRL_WRONG_TOKEN_VERSION) \
    DEF_ERR(PP_E_CRL_WRONG_TOKENFILE_SIZE) \
    DEF_ERR(PPCRL_CERTCONTEXT_MISSING) \
    DEF_ERR(PPCRL_SECONDARYCREDS_MISSING) \
    DEF_ERR(PPCRL_SITEID_MISSING) \
    DEF_ERR(PPCRL_CONSENT_NEEDED) \
    DEF_ERR(PP_E_CRL_INVALID_REDIRECT_URL) \
    DEF_ERR(PPCRL_REQUESTPARAMS_MISSING) \
    DEF_ERR(PPCRL_REQUEST_NOT_MADE) \
    DEF_ERR(PP_E_CRL_INVALID_APP_GUID) \
    DEF_ERR(PP_E_CRL_INVALID_VERSION) \
    DEF_ERR(PP_E_CRL_INVALID_HANDLE_NAME) \
    DEF_ERR(PP_E_CRL_ILLEGAL_IDENTITY_FLAG) \
    DEF_ERR(PP_E_CRL_NOT_PPCRL_MEMORY) \
    DEF_ERR(PP_E_CRL_INVALID_PROPERTY_TYPE) \
    DEF_ERR(PP_E_CRL_NO_SUCH_IDENTITY) \
    DEF_ERR(PP_E_CRL_UNKOWN_CRED_TYPE) \
    DEF_ERR(PP_E_CRL_BAD_FILE) \
    DEF_ERR(PP_E_CRL_INVALID_MEMBER_NAME) \
    DEF_ERR(PP_E_PPCRL_MISSING_PASSWORD) \
    DEF_ERR(PP_E_PPCRL_AUTH_NEED_TOU) \
    DEF_ERR(PP_E_PPCRL_AUTH_NEED_EMAIL_VALIDATIION) \
    DEF_ERR(PP_S_TOKEN_REQUEST_FAILED) \
    DEF_ERR(PPCRL_E_PLATFORM_SECURE_STORAGE_NOT_AVAILABLE) \
    DEF_ERR(PP_E_CRL_BAD_OPTION) \
    DEF_ERR(PP_E_CRL_BAD_OPTIONLENGTH) \
    DEF_ERR(PP_E_CRL_BAD_OPTIONID) \
    DEF_ERR(PP_E_CRL_PROXYLIST_TOOLONG) \
    DEF_ERR(PP_E_CRL_PROXYBYPASSLIST_TOOLONG) \
    DEF_ERR(PP_E_CRL_NULL_OPTION) \
    DEF_ERR(PPCRL_E_NO_UI_MODE) \
    DEF_ERR(PP_E_CRL_ILLEGAL_REQUEST_FLAG) \
    DEF_ERR(PP_E_CRL_NO_SERVICE_NAME) \
    DEF_ERR(PP_E_CRL_NO_TOKENBAG) \
    DEF_ERR(PP_E_CRL_STATUS_UNINITIALIZED) \
    DEF_ERR(PPCRL_E_LOCK) \
    DEF_ERR(PPCRL_E_SYNC_NOLOCK) \
    DEF_ERR(PPCRL_E_HTTP_QUERYINFO) \
    DEF_ERR(PP_E_CRL_NW_CALL_BLOCKED) \
    DEF_ERR(PP_E_CRL_NOTIFY_NOT_INITIALIZED) \
    DEF_ERR(PP_E_CRL_NOTIFY_SEND_FAILED) \
    DEF_ERR(PP_E_CRL_NOTIFY_RECV_FAILED) \
    DEF_ERR(PP_E_CRL_NOTIFY_NO_MESSAGE) \
    DEF_ERR(PPCRL_S_ALREADY_INITIALIZED) \
    DEF_ERR(PPCRL_S_STILL_INUSE) \
    DEF_ERR(PPCRL_E_INITIALIED_DIFF_ENVIRONMENT) \
    DEF_ERR(PP_E_PROTOCOL_BASE) \
    DEF_ERR(PPCRL_SESSIONKEY_MISSING) \
    DEF_ERR(PPCRL_ERROR_RESPONSE) \
    DEF_ERR(PPCRL_RESPONSE_BADXML) \
    DEF_ERR(PPCRL_REQUEST_BADXML) \
    DEF_ERR(PPCRL_TOKEN_CORRUPTED) \
    DEF_ERR(PPCRL_BASE64DECODE_FAILED) \
    DEF_ERR(PPCRL_RESPONSE_MISSINGREF) \
    DEF_ERR(PPCRL_RESPONSE_NOTIMESTAMPORRSTR) \
    DEF_ERR(PPCRL_RESPONSE_NOSIGNATUREELEMENT) \
    DEF_ERR(PPCRL_RESPONSE_NOCIPHERELEMENT) \
    DEF_ERR(PPCRL_TOKEN_WRONG_TYPE) \
    DEF_ERR(PP_E_CRED_BASE) \
    DEF_ERR(PP_E_DYNAMIC_SALT_CORRUPTED) \
    DEF_ERR(PP_E_DECRYPTION_FAILURE) \
    DEF_ERR(PP_E_TAMPERED_DATA) \
    DEF_ERR(PP_E_OBFUSCATOR_NOT_INITIALIZED) \
    DEF_ERR(PPCRL_NOT_INITIALIZED) \
    DEF_ERR(PPCRL_ENCODING_FAILED) \
    DEF_ERR(PP_E_CRL_CONFIG_BASE) \
    DEF_ERR(PP_E_CRL_CONFIG_NOT_INITIALIZED) \
    DEF_ERR(PP_E_CRL_REG_OPEN_FAILED) \
    DEF_ERR(PP_E_CRL_REG_QUERY_FAILED) \
    DEF_ERR(PP_E_CRL_REG_SET_FAILED) \
    DEF_ERR(PP_E_CRL_GETWINDOWSDIR_FAILED) \
    DEF_ERR(PP_E_OBFUSCATE_FAILED) \
    DEF_ERR(PP_E_LOAD_CONFIGDATA_FAILED) \
    DEF_ERR(PP_E_CRL_SAVE_DATA_FAILED) \
    DEF_ERR(PP_E_CRL_WRITE_DATA_FAILED) \
    DEF_ERR(PP_E_CRL_CONFIG_ALREADY_INITIALIZED) \
    DEF_ERR(PP_E_CRL_CACHE_DIR_ERROR) \
    DEF_ERR(PP_E_CRL_SERVICE) \
    DEF_ERR(PP_E_CORRUPT) \
    DEF_ERR(PP_E_NOTCONNECTED) \
    DEF_ERR(PP_E_PASSPORTDOWN) \
    DEF_ERR(PP_E_UPDATEFAILED) \
    DEF_ERR(PP_E_UPDATEINPROGRESS) \
    DEF_ERR(PP_E_CRL_GET_TEMP_FILENAME_FAILED) \
    DEF_ERR(PP_E_CRL_EMPTY_TEMP_FILE) \
    DEF_ERR(PP_E_CRL_SELECTNODE_FAILED) \
    DEF_ERR(PP_E_CRL_GET_ATTR_FAILED) \
    DEF_ERR(PP_E_CRL_GET_ITEM_FAILED) \
    DEF_ERR(PP_E_CRL_TOOMANY_XMLNODES) \
    DEF_ERR(PP_E_CRL_TOOMANY_XMLATTRIBS) \
    DEF_ERR(PP_E_CRL_AQURIE_CONTEXT_FAILED) \
    DEF_ERR(PP_E_CRL_IMPORT_KEY_FAILED) \
    DEF_ERR(PP_E_CRL_CREATE_HASH_FAILED) \
    DEF_ERR(PP_E_CRL_HASH_DATA_FAILED) \
    DEF_ERR(PP_E_CRL_DECODE_SIG_FAILED) \
    DEF_ERR(PP_E_CRL_FILE_INSTEAD_OF_DIR) \
    DEF_ERR(PP_E_CRL_CREDUI_BASE) \
    DEF_ERR(PP_E_CRL_CREDUI_ATLAXWININIT_FAIL) \
    DEF_ERR(PP_E_CRL_CREDUI_CREATEWINDOW_FAIL) \
    DEF_ERR(PP_E_CRL_CREDUI_HOSTRETRIEVAL_FAIL) \
    DEF_ERR(PP_E_CRL_CREDUI_CONTROLRETRIEVAL_FAIL) \
    DEF_ERR(PP_E_CRL_CREDUI_SHOWWINDOW_FAIL) \
    DEF_ERR(PP_E_CRL_CREDUI_UPDATEWINDOW_FAIL) \
    DEF_ERR(PP_E_CRL_CREDUI_REDRAWWINDOW_FAIL) \
    DEF_ERR(PP_E_CRL_CREDUI_INVALIDSIZE_FAIL) \
    DEF_ERR(PP_E_CRL_CREDUI_USERNOTSPECIFIED_FAIL) \
    DEF_ERR(PP_E_CRL_CREDUI_LOCALUIMISSING) \
    DEF_ERR(PPCRL_E_SQM_BASE) \
    DEF_ERR(PPCRL_E_SQM_UNKNOWN) \
    DEF_ERR(PPCRL_E_SQM_REQUEST_CANCELLED) \
    DEF_ERR(PPCRL_E_SQM_QUERY_STATUSCODE) \
    DEF_ERR(PPCRL_E_SQM_OUTOFMEMORY) \
    DEF_ERR(PPCRL_E_SQM_READRESPONSE) \
    DEF_ERR(PPCRL_E_SQM_RESPONSE_BADXML) \
    DEF_ERR(PPCRL_E_SQM_INTERNET_OTHER) \
    DEF_ERR(PPCRL_E_SQM_INTERNET_UI) \
    DEF_ERR(PPCRL_E_SQM_INTERNET_SYNTAX) \
    DEF_ERR(PPCRL_E_SQM_INTERNET_NAME_NOT_RESOLVED) \
    DEF_ERR(PPCRL_E_SQM_INTERNET_LOGIN) \
    DEF_ERR(PPCRL_E_SQM_INTERNET_PROXY) \
    DEF_ERR(PPCRL_E_SQM_INTERNET_OPERATION_CANCELLED) \
    DEF_ERR(PPCRL_E_SQM_INTERNET_INCORRECT_HANDLE_STATE) \
    DEF_ERR(PPCRL_E_SQM_INTERNET_CANNOT_CONNECT) \
    DEF_ERR(PPCRL_E_SQM_INTERNET_CONNECTION_ABORTED) \
    DEF_ERR(PPCRL_E_SQM_INTERNET_CONNECTION_RESET) \
    DEF_ERR(PPCRL_E_SQM_INTERNET_SEC_CERT_DATE_INVALID) \
    DEF_ERR(PPCRL_E_SQM_INTERNET_SEC_CERT_CN_INVALID) \
    DEF_ERR(PPCRL_E_SQM_INTERNET_SEC_CERT_ERRORS) \
    DEF_ERR(PPCRL_E_SQM_INTERNET_SEC_CERT_NO_REV) \
    DEF_ERR(PPCRL_E_SQM_INTERNET_SEC_CERT_REV_FAILED) \
    DEF_ERR(PPCRL_E_SQM_INTERNET_CLIENT_AUTH_CERT_NEEDED) \
    DEF_ERR(PPCRL_E_SQM_INTERNET_INVALID_CA) \
    DEF_ERR(PPCRL_E_SQM_INTERNET_SECURITY_WARNING) \
    DEF_ERR(PPCRL_E_SQM_INTERNET_POST_IS_NON_SECURE) \
    DEF_ERR(PPCRL_E_SQM_FTP) \
    DEF_ERR(PPCRL_E_SQM_GOPHER) \
    DEF_ERR(PPCRL_E_SQM_HTTP_HEADER) \
    DEF_ERR(PPCRL_E_SQM_HTTP_DOWNLEVEL_SERVER) \
    DEF_ERR(PPCRL_E_SQM_HTTP_INVALID_SERVER_RESPONSE) \
    DEF_ERR(PPCRL_E_SQM_HTTP_INVALID_QUERY_REQUEST) \
    DEF_ERR(PPCRL_E_SQM_HTTP_REDIRECT) \
    DEF_ERR(PPCRL_E_SQM_HTTP_COOKIE) \
    DEF_ERR(PPCRL_E_SQM_INTERNET_SECURITY_CHANNEL_ERROR) \
    DEF_ERR(PPCRL_E_SQM_INTERNET_DISCONNECTED) \
    DEF_ERR(PPCRL_E_SQM_INTERNET_SERVER_UNREACHABLE) \
    DEF_ERR(PPCRL_E_SQM_INTERNET_PROXY_SERVER_UNREACHABLE) \
    DEF_ERR(PPCRL_E_SQM_INTERNET_PROXYSCRIPT) \
    DEF_ERR(PPCRL_E_SQM_INTERNET_SEC_INVALID_CERT) \
    DEF_ERR(PPCRL_E_SQM_INTERNET_SEC_CERT_REVOKED) \
    DEF_ERR(PPCRL_E_SQM_INTERNET_AUTODIAL) \
    DEF_ERR(PPCRL_E_SQM_INTERNET_NOT_INITIALIZED) \
    DEF_ERR(PPCRL_E_SQM_LOCK) \
    DEF_ERR(PPCRL_E_SQM_SYNC_NOLOCK) \
    DEF_ERR(PPCRL_E_SQM_HTTP_QUERYINFO) \
    DEF_ERR(PPCRL_E_SQM_RESPONSE_TOO_LARGE) \
    DEF_ERR(PPCRL_E_SQM_INVALID_AUTH_SERVICE_RESPONSE) \
    DEF_ERR(PPCRL_E_SQM_NO_TOKENBAG) \
    DEF_ERR(PPCRL_E_SQM_RESPONSE_NOTIMESTAMPORRSTR) \
    DEF_ERR(PPCRL_E_SQM_RESPONSE_NOSIGNATUREELEMENT) \
    DEF_ERR(PPCRL_E_SQM_RESPONSE_NOCIPHERELEMENT) \
    DEF_ERR(PPCRL_E_SQM_REQUEST_E_RSTR_MISSING_REFERENCE_URI) \
    DEF_ERR(PPCRL_E_SQM_REQUEST_E_RSTR_MISSING_REFERENCED_TOKEN) \
    DEF_ERR(PPCRL_E_SQM_WAIT_ABANDONED) \
    DEF_ERR(PPCRL_E_SQM_WAIT_TIMEOUT) \
    DEF_ERR(PPCRL_E_SQM_INTERNET_TIMEOUT) \


// -------------------------------------------------------------------------------------
// CPassportIdcrl::HrToString
// Convert an HRESULT to a string
// -------------------------------------------------------------------------------------
LPCSTR CPassportIdcrl::HrToString(HRESULT hr)
{
#define DEF_ERR(error) case error: return #error;
    switch(hr)
    {
        PP_ERROR_LIST();

    default:
        return "";
    }
#undef DEF_ERR
}

// -------------------------------------------------------------------------------------
// CPassportIdcrl::ConvertTicketToBinary
// Convert a passport ticket using the following format t=<base-64-blob> to binary
// - pticketstr: ticket string 
// - pticketbin (OUT): buffer to received the ticket in binary format
// - perror (OUT): string to receive extended error information
// Returns:
//  This method returns S_OK if succeeded or an HRESULT error if failed
// -------------------------------------------------------------------------------------
HRESULT CPassportIdcrl::ConvertTicketToBinary(
    CHAR* pticketstr, 
    OUT CBuffer* pticketbin,
    OUT CStr* perror OPTIONAL
    )
{
    const CHAR ticketPrefix[] = "t=";
    const int ticketPrefixLen = ARRAY_SIZE(ticketPrefix) - 1;
    HRESULT hr = E_FAIL;

    // Skip the prefix

    CHECK(memcmp(pticketstr, ticketPrefix, ticketPrefixLen) == 0);
    pticketstr += ticketPrefixLen;

    // Determine the size of the decoded ticket

    size_t ticketlen = strlen(pticketstr);
    size_t ticketbinlen = Base64DecodeGetRequiredLength(ticketlen);

    CHECK(pticketbin->SetCapacity(ticketbinlen));

    // Decode ticket

    int decoded = pticketbin->GetCapacity();

    CHECK(Base64Decode(
            pticketstr, 
            ticketlen,
            (BYTE*)pticketbin->GetPtr(),
            &decoded));

    CHECK((DWORD)decoded < pticketbin->GetCapacity());
    CHECK(pticketbin->SetSize(decoded));

    hr = S_OK;

Exit:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\Passport\passportRps.h ===
// --------------------------------------------------------------------------------------
// Copyright (c) 2006 Microsoft Corporation
//
// passportRps.h
//
// Passport RPS class for the Xbox Live KDC
// --------------------------------------------------------------------------------------

#pragma once

#include <windows.h>
#include <atlcomcli.h>
#include <cutil.h>
#include <xlocks.h>

namespace RPS {
struct IRPS;
};

class CPassportRps
{
    // Any allocator can be used to instantiate this class
    USE_IMEMALLOC(CPassportRps);

public:

    CPassportRps();
    virtual ~CPassportRps();
    
    HRESULT Init(OUT CStr* perror);

    HRESULT CrackTicket(
        IN  BYTE     *pTicket, 
        IN  UINT32    cbTicket,
        IN  CComBSTR &pbstrService,
        OUT UINT64   *pPuid,
        OUT FILETIME *pStartTime,
        OUT FILETIME *pEndTime,
        OUT CBuffer  *pSessionKey,
        OUT CStr     *pError
        );

    void SetLifetime(DWORD lifetimeInSeconds) { _lifetimeInSeconds = lifetimeInSeconds;}

    static LPCSTR HrToString(HRESULT hr);

protected:
    
    static void FormatError(
        CStr*   pout, 
        LPCSTR  file, 
        DWORD   line, 
        HRESULT hr, 
        LPCSTR  error);

    static HRESULT ConvertBinaryToTicket(
        BYTE*          pticketbin, 
        DWORD          ticketbinlen, 
        OUT BSTR*      pticketstr,
        OUT CStr*      perror);

    RPS::IRPS*          _irps;
    CComBSTR            _service;
    xlocks::CSpinLock   _initLock;
    BOOL                _bIsReady;
    BOOL                _bIsStarting;
    DWORD               _lifetimeInSeconds;

private:
    void PassportTimeToFileTime( time_t t, FILETIME *pFileTime);

};

// --------------------------------------------------------------------------------------
// Passport RPS errors
// This list is used to declare the HRESULTs. It's also used by HrToString to convert the 
// hr to the friendly constant name
// --------------------------------------------------------------------------------------

#define PASSPORTRPS_ERRORS() \
    DEF_ERR(PP_E_RPS_NOT_INITIALIZED,                               0x80049200) \
    DEF_ERR(PP_E_RPS_FAILED_TO_CREATE_DOM,                          0x80049201) \
    DEF_ERR(PP_E_RPS_INTERNAL_ERROR,                                0x80049202) \
    DEF_ERR(PP_E_RPS_INVALID_OBJECT_ID,                             0x80049203) \
    DEF_ERR(PP_E_RPS_OBJECT_ID_CANNOT_OVERWRITE,                    0x80049204) \
    DEF_ERR(PP_E_RPS_FAILED_TO_TLS,                                 0x80049205) \
    DEF_ERR(PP_E_RPS_XML_FILE_ERROR,                                0x80049206) \
    DEF_ERR(PP_E_RPS_READ_ONLY,                                     0x80049207) \
    DEF_ERR(PP_E_RPS_SERVER_CONFIG_ALREADY_INITTED,                 0x80049208) \
    DEF_ERR(PP_E_RPS_INVALIDCONFIG,                                 0x80049209) \
    DEF_ERR(PP_E_RPS_CERT_NOT_FOUND,                                0x8004920a) \
    DEF_ERR(PP_E_RPS_SKIBUFFER_TOO_SMALL,                           0x8004920b) \
    DEF_ERR(PP_E_RPS_FILE_TOO_LARGE,                                0x8004920c) \
    DEF_ERR(PP_E_RPS_INVALID_DATATYPE,                              0x8004920d) \
    DEF_ERR(PP_E_RPS_MORE_DATA,                                     0x8004920e) \
    DEF_ERR(PP_E_RPS_INVALID_SIGNATURE,                             0x8004920f) \
    DEF_ERR(PP_E_RPS_ENCRYPTEDKEY_TOO_LARGE,                        0x80049211) \
    DEF_ERR(PP_E_RPS_DATA_INTEGRITY_CHECK_FAILED,                   0x80049212) \
    DEF_ERR(PP_E_RPS_CERT_WITHOUT_PRIVATE_KEY,                      0x80049214) \
    DEF_ERR(PP_E_RPS_NET_CONFIG_CACHE_ALREADY_INITTED,              0x80049215) \
    DEF_ERR(PP_E_RPS_DOMAIN_ATTRIBUTE_NOT_FOUND,                    0x80049216) \
    DEF_ERR(PP_E_RPS_INVALIDDATA,                                   0x80049217) \
    DEF_ERR(PP_E_RPS_TICKET_NOT_INITIALIZED,                        0x80049218) \
    DEF_ERR(PP_E_RPS_TICKET_CANNOT_BE_INITIALIZED_MORE_THAN_ONCE,   0x80049219) \
    DEF_ERR(PP_E_RPS_SAML_ASSERTION_MISSINGDATA,                    0x8004921a) \
    DEF_ERR(PP_E_RPS_INVALID_TIMEWINDOW,                            0x8004921b) \
    DEF_ERR(PP_E_RPS_HTTP_BODY_REQUIRED,                            0x8004921d) \
    DEF_ERR(PP_E_RPS_INVALID_TICKET_TYPE,                           0x8004921e) \
    DEF_ERR(PP_E_RPS_INVALID_SLIDINGWINDOW,                         0x8004921f) \
    DEF_ERR(PP_E_RPS_REASON_INVALID_AUTHMETHOD,                     0x80049220) \
    DEF_ERR(PP_E_RPS_NO_SUCH_PROFILE_ATTRIBUTE,                     0x80049222) \
    DEF_ERR(PP_E_RPS_INVALID_PROFILESCHEMA_TYPE,                    0x80049223) \
    DEF_ERR(PP_E_RPS_FAILED_DOWNLOAD,                               0x80049224) \
    DEF_ERR(PP_E_RPS_INVALID_SITEID,                                0x80049226) \
    DEF_ERR(PP_E_RPS_BASE64DECODE_FAILED,                           0x80049227) \
    DEF_ERR(PP_E_RPS_REASON_TIMEWINDOW_EXPIRED,                     0x80049228) \
    DEF_ERR(PP_E_RPS_REASON_SLIDINGWINDOW_EXPIRED,                  0x80049229) \
    DEF_ERR(PP_E_RPS_CERT_INVALID_KEY_SPEC,                         0x8004922a) \
    DEF_ERR(PP_E_RPS_INTERNAL_ERROR_CODE_UNSET_IN_EXCEPTION,        0x8004922b) \
    DEF_ERR(PP_E_RPS_REASON_INVALID_AUTHINSTANT_DATATYPE,           0x8004922c) \
    DEF_ERR(PP_E_RPS_REASON_HTTPS_OR_ENCRYPTED_TICKET_NEEDED,       0x8004922d) \
    DEF_ERR(PP_E_RPS_REASON_INCORRECT_IV_BYTES,                     0x8004922e) \
    DEF_ERR(PP_E_RPS_REASON_PASSPORT_F_ERROR_ENCOUNTERED,           0x8004922f) \
    DEF_ERR(PP_E_RPS_NO_SESSION_KEY,                                0x80049230) \
    DEF_ERR(PP_E_RPS_INVALID_COOKIE_NAME,                           0x80049231) \
    DEF_ERR(PP_E_RPS_INVALID_AUTHPOLICY,                            0x80049232) \
    DEF_ERR(PP_E_RPS_INVALID_ENCRYPT_ALGID,                         0x80049233) \
    DEF_ERR(PP_E_RPS_REASON_POST_TICKET_TIMEWINDOW_EXPIRED,         0x80049234) \
    DEF_ERR(PP_E_RPS_TICKET_HAS_NO_SESSIONKEY,                      0x80049235) \
    DEF_ERR(PP_E_RPSDATA_DATA_TOO_LARGE,                            0x80049400) \
    DEF_ERR(PP_E_RPSDATA_INVALID_DATATYPE,                          0x80049401) \
    DEF_ERR(PP_E_RPSDATA_MORE_DATA,                                 0x80049402) \
    DEF_ERR(PP_E_RPSDATA_INVALID_DATAOFFSET,                        0x80049403) \
    DEF_ERR(PP_E_RPSDATA_INVALIDDATA,                               0x80049404) \


#define DEF_ERR(c, h) const int c = h;
PASSPORTRPS_ERRORS();
#undef DEF_ERR
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\Passport\lib\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_passport_none_12.4.56.0_none_17471356ab72eeda
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_passport_no-public-key_12.4.56.0_x-ww_2c01b8e8
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=passport
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_passport_no-public-key_12.4.56.0_x-ww_2c01b8e8
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_passport_no-public-key_12.4.56.0_x-ww_2c01b8e8.manifest
XP_MANIFEST_PATH=manifests\x86_passport_no-public-key_12.4.56.0_x-ww_2c01b8e8.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_passport_no-public-key_12.4.56.0_x-ww_2c01b8e8.cat
XP_CATALOG_PATH=manifests\x86_passport_no-public-key_12.4.56.0_x-ww_2c01b8e8.cat
XP_PAYLOAD_PATH=x86_passport_no-public-key_12.4.56.0_x-ww_2c01b8e8
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=passport,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\Passport\test\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_pauthtest_none_12.4.56.0_none_cfebb37a9c6cd0f8
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_pauthtest_no-public-key_12.4.56.0_x-ww_a4e57980
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=pauthtest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_pauthtest_no-public-key_12.4.56.0_x-ww_a4e57980
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_pauthtest_no-public-key_12.4.56.0_x-ww_a4e57980.manifest
XP_MANIFEST_PATH=manifests\x86_pauthtest_no-public-key_12.4.56.0_x-ww_a4e57980.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_pauthtest_no-public-key_12.4.56.0_x-ww_a4e57980.cat
XP_CATALOG_PATH=manifests\x86_pauthtest_no-public-key_12.4.56.0_x-ww_a4e57980.cat
XP_PAYLOAD_PATH=x86_pauthtest_no-public-key_12.4.56.0_x-ww_a4e57980
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=pauthtest,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\Passport\lib\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_passport_none_12.4.56.0_none_17471356ab72eeda
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_passport_no-public-key_12.4.56.0_x-ww_2c01b8e8
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=passport
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_passport_no-public-key_12.4.56.0_x-ww_2c01b8e8
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_passport_no-public-key_12.4.56.0_x-ww_2c01b8e8.manifest
XP_MANIFEST_PATH=manifests\x86_passport_no-public-key_12.4.56.0_x-ww_2c01b8e8.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_passport_no-public-key_12.4.56.0_x-ww_2c01b8e8.cat
XP_CATALOG_PATH=manifests\x86_passport_no-public-key_12.4.56.0_x-ww_2c01b8e8.cat
XP_PAYLOAD_PATH=x86_passport_no-public-key_12.4.56.0_x-ww_2c01b8e8
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=passport,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\Passport\test\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_pauthtest_none_12.4.56.0_none_cfebb37a9c6cd0f8
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_pauthtest_no-public-key_12.4.56.0_x-ww_a4e57980
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=pauthtest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_pauthtest_no-public-key_12.4.56.0_x-ww_a4e57980
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_pauthtest_no-public-key_12.4.56.0_x-ww_a4e57980.manifest
XP_MANIFEST_PATH=manifests\x86_pauthtest_no-public-key_12.4.56.0_x-ww_a4e57980.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_pauthtest_no-public-key_12.4.56.0_x-ww_a4e57980.cat
XP_CATALOG_PATH=manifests\x86_pauthtest_no-public-key_12.4.56.0_x-ww_a4e57980.cat
XP_PAYLOAD_PATH=x86_pauthtest_no-public-key_12.4.56.0_x-ww_a4e57980
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=pauthtest,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\Passport\test\test.cpp ===
#include "passportd.h"
#include "passportidcrl.h"
#include "passportrps.h"

// #define _WIN32_DCOM 
// 
// #include <stdio.h>
// #include <stdlib.h>
// 
// #include <windows.h>
// #include <Wincrypt.h>
// #include <objbase.h>
// 
// #define ATL_NO_LEAN_AND_MEAN
// #include <atlcomcli.h>
// 
// #include <specstrings.h>
// #include <msidcrl.h>
// #include <cutil.h>

static const GUID g_testAppGuid = { /* b63271b3-7b72-4a4d-ac3e-607e2e54d425 */
    0xb63271b3, 0x7b72, 0x4a4d, {0xac, 0x3e, 0x60, 0x7e, 0x2e, 0x54, 0xd4, 0x25} };

static const wchar_t* g_environmentName = L"INT";

#define CHECK(x) \
    if(!(x)) { \
        hr = E_FAIL; \
        printf("Error at %s (%u): %s\n", __FILE__, __LINE__, #x); \
        goto Exit; \
    }

#define CHECK_HR(x) \
    if(FAILED(hr = (x))) { \
        printf("Error at %s (%u): %s\n", __FILE__, __LINE__, #x); \
        printf("Hresult: 0x%08x\n", hr); \
        goto Exit; \
    }

void DumpBytes(const char * filename, BYTE * pb, DWORD cb)
{
    FILE *f = fopen(filename, "w");
    if (!f)
    {
        printf("Error opening file %s\n", filename);
        return;
    }

    if (0 == fwrite(&cb, 1, sizeof(cb), f))
    {
        printf("Error writing header %u bytes to %s\n", sizeof(cb), filename);
        goto exit;
    }

    if (0 == fwrite(pb, 1, cb, f))
    {
        printf("Error writing %u bytes to %s\n", cb, filename);
        goto exit;
    }

exit:
    fclose(f);
}

void ReadBytes(const char * filename, CBuffer* pb)
{
    FILE *f = fopen(filename, "r");
    if (!f)
    {
        printf("Error opening file %s\n", filename);
        return;
    }

    DWORD cb;
    if (0 == fread(&cb, 1, sizeof(cb), f))
    {
        printf("Error reading header %u bytes from %s\n", sizeof(cb), filename);
        goto exit;
    }

    if (cb == 0 || cb > 1000000)
    {
        printf("This ticket is too large (%u bytes)\n", cb);
        goto exit;
    }

    pb->SetSize(cb);

    if (0 == fread((BYTE*)pb->GetPtr(), 1, cb, f))
    {
        printf("Error reading %u bytes from %s\n", cb, filename);
        goto exit;
    }

exit:
    if (ferror(f))
    {
        printf("ferror: true\n");
    }
    if (feof(f))
    {
        printf("feof: true\n");
    }
    fclose(f);
}

int __cdecl main(int argc, char** argv)
{
    if(argc < 3)
    {
        printf("Usage:\n");
        printf("PAuthTest <name> <password>\n\n");
        printf("PAuthTest -t <ppticket filename>\n\n");
        return 1;
    }

    HRESULT hr = E_FAIL;
    
    TLocalBuffer<1> ticket;
    TLocalBuffer<1> sessionkey;
    TLocalBuffer<1> ticketkey;
    UINT64  puid;
    CSmallWStr name, password;
    CLargeStr error;
    CPassportRps rps;

    CHECK_HR(CoInitializeEx(NULL, COINIT_MULTITHREADED));
    ticket.SetAllocator(CMemAlloc::Crt());
    sessionkey.SetAllocator(CMemAlloc::Crt());
    ticketkey.SetAllocator(CMemAlloc::Crt());

    if (_stricmp(argv[1], "-t") == 0)
    {
        ReadBytes(argv[2], &ticket);
        printf("Read ticket of length %u bytes\n", ticket.GetSize());
    }
    else
    {
        name.Format(L"%S", argv[1]);
        password.Format(L"%S", argv[2]);

        CHECK_HR(CPassportIdcrl::StaticInit(g_testAppGuid, g_environmentName, &error));
        CHECK_HR(CPassportIdcrl::GetTicket(name.cstr(), 
                                           password.cstr(), 
                                           L"kdc.test.xboxlive.com", 
                                           &ticket,
                                           &sessionkey,
                                           &error));

        DumpBytes("ppticket.bin", (BYTE*)ticket.GetPtr(), ticket.GetSize());
        printf("Wrote ticket of length %u bytes\n", ticket.GetSize());
    }

    CHECK_HR(rps.Init(&error));

    CHECK_HR(
        rps.CrackTicket(
            (BYTE*)ticket.GetPtr(),
            ticket.GetSize(),
            CComBSTR(L"kdc.test.xboxlive.com"),
            &puid,
            NULL,
            NULL,
            &ticketkey,
            &error
            )
        );

    CHECK(ticketkey.GetSize() == sessionkey.GetSize());
    CHECK(memcmp(ticketkey.GetPtr(), sessionkey.GetPtr(), sessionkey.GetSize()) == 0);

    printf("puid            : 0x%016I64x\n", puid);
    printf("ticket-len      : %u\n", ticket.GetSize());
    printf("session-key-len : %u\n", sessionkey.GetSize());
    printf("\n");

    hr = S_OK;

Exit:

    if(FAILED(hr) && !error.IsEmpty())
    {
        printf("%s\n", error.cstr());
    }

    return SUCCEEDED(hr) ? 0 : 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\genxecert\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\genxecert\precomp.h ===
#pragma once

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <crypto\rsa.h>
#include <crypto\sha.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\genxecert\precomp.cpp ===
#include "precomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\genxecert\main.cpp ===
#include "precomp.h"
#include "emeoaep.h"

#define DEFINE_TEMPKEYS
#include "xetempkeys.h"

#ifndef Verify
#define Verify(x) if(!(x)) { printf("Assert at %s(%s:%u): %s", __FUNCTION__,__FILE__,__LINE__,#x); DebugBreak(); }
#endif

#define DUMPBINARY(x, cb) DumpBinary(#x, x, cb);

static bool XOCryptGenRandom(BYTE* pbData, DWORD cbData)
{
    for(DWORD i=0; i < cbData; i++)
    {
        pbData[i] = (BYTE)(i & 0xFF);
    }
    return true;
}

class CXoCrypto
{
public:
    
    CXoCrypto();

    ~CXoCrypto();
    
    bool Init();

    void Term();

    bool DecryptWithMasterSigningKey(
        IN const BYTE* pbCipherText,
        DWORD cbCipherText,
        OUT BYTE* pbMessage,
        IN OUT DWORD* pcbMessage
    );

    bool DecryptWithMasterXmacsKey(
        IN const BYTE* pbCipherText,
        DWORD cbCipherText,
        OUT BYTE* pbMessage,
        IN OUT DWORD* pcbMessage
    );

    bool DecryptWithConsoleOnlineRsaKey(
        IN const BYTE* pOnlineRsa,
        IN const BYTE* pbCipherText,
        DWORD cbCipherText,
        OUT BYTE* pbMessage,
        IN OUT DWORD* pcbMessage
    );

protected:

    enum RsaKeyType
    {
        RsaKeyPublic  = 1,
        RsaKeyPrivate = 2
    };

    bool RsaOaepEncrypt(
        IN RsaKeyType keyType,
        IN DWORD cbPacket,
        IN BYTE* pRsa,
        IN const BYTE* pbMsg,
        IN DWORD cbMsg,
        OUT BYTE* pbEncMsg
    );

    bool RsaOaepDecrypt(
        IN RsaKeyType keyType,
        IN DWORD cbPacket,
        IN const BYTE* pRsa,
        IN const BYTE* pbEncMsg,
        OUT BYTE* pbMsg,
        IN OUT DWORD* pcbMsg
    );

    static void RevertBinary(BYTE* pb, DWORD cb);

    bool _fInit;
};

CXoCrypto::CXoCrypto()
{
    _fInit = false;
}

CXoCrypto::~CXoCrypto()
{
}

bool CXoCrypto::Init()
{
    _fInit = true;
    return true;
}

void CXoCrypto::Term()
{
    _fInit = false;
}

bool CXoCrypto::DecryptWithMasterSigningKey(
    IN const BYTE* pbCipherText,
    DWORD cbCipherText,
    OUT BYTE* pbMessage,
    IN OUT DWORD* pcbMessage
)
{
    const BufferSize  = 300; // Maximum modulus size supported (256) + extra room required by some crypto primitives
    const ModulusSize = 256;

    if(cbCipherText != ModulusSize)
        return false;
    
    return RsaOaepDecrypt(
        RsaKeyPublic, 
        ModulusSize, 
        g_MasterSigningBsafePub2048,
        pbCipherText,
        pbMessage,
        pcbMessage);
}

bool CXoCrypto::DecryptWithMasterXmacsKey(
    IN const BYTE* pbCipherText,
    DWORD cbCipherText,
    OUT BYTE* pbMessage,
    IN OUT DWORD* pcbMessage
)
{
    const BufferSize  = 300; // Maximum modulus size supported (256) + extra room required by some crypto primitives
    const ModulusSize = 256;

    if(cbCipherText != ModulusSize)
        return false;
    
    return RsaOaepDecrypt(
        RsaKeyPrivate, 
        ModulusSize, 
        g_MasterXmacsBsafePrv2048,
        pbCipherText,
        pbMessage,
        pcbMessage);
}

bool CXoCrypto::DecryptWithConsoleOnlineRsaKey(
    IN const BYTE* pOnlineRsa,
    IN const BYTE* pbCipherText,
    DWORD cbCipherText,
    OUT BYTE* pbMessage,
    IN OUT DWORD* pcbMessage
)
{
    const BufferSize  = 300; // Maximum modulus size supported (256) + extra room required by some crypto primitives
    const ModulusSize = 128;

    if(cbCipherText != ModulusSize)
        return false;
    
    return RsaOaepDecrypt(
        RsaKeyPublic, 
        ModulusSize, 
        pOnlineRsa,
        pbCipherText,
        pbMessage,
        pcbMessage);
}

bool CXoCrypto::RsaOaepEncrypt(
    IN RsaKeyType keyType,
    IN DWORD cbPacket,
    IN BYTE* pRsa,
    IN const BYTE* pbMsg,
    IN DWORD cbMsg,
    OUT BYTE* pbEncMsg
)
{
    const DWORD BufferSize = 300; // Maximum modulus size supported (256) + extra room required by some crypto primitives
    BYTE abPacketSeed[EMEOAEP_HASH_SIZE];
    BYTE abPacket[BufferSize];
    BYTE abEnPacket[BufferSize];
    EMEOAEP_ERROR error;

    // Generate a random seed for the encoding
    if(!XOCryptGenRandom(abPacketSeed, sizeof(abPacketSeed)))
        return false;

    // Encode
    error = EmeoaepPack(cbPacket, NULL, abPacketSeed, pbMsg, cbMsg, abPacket);
    if(error != EmeoaepErrorNoError)
        return false;

    // Arrange byte order according to crypto primitive used 
    RevertBinary(abPacket, cbPacket);
    memset(abPacket + cbPacket, 0, BufferSize - cbPacket);

    // Encrypt
    if(keyType == RsaKeyPublic)
    {
        if(!BSafeEncPublic((LPBSAFE_PUB_KEY)pRsa, abPacket, abEnPacket))
            return false;
    }
    else if(keyType == RsaKeyPrivate)
    {
        if(!BSafeDecPrivate((LPBSAFE_PRV_KEY)pRsa, abPacket, abEnPacket))
            return false;
    }
    else
    {
        return false; // Where is the Assert macro?
    }

    // Copy ciphertext to caller's buffer with the correct byte order
    for(DWORD i=0; i < cbPacket; i++)
    {
        pbEncMsg[i] = abEnPacket[cbPacket-i-1];
    }

    return true;
}

bool CXoCrypto::RsaOaepDecrypt(
    IN RsaKeyType keyType,
    IN DWORD cbPacket,
    IN const BYTE* pRsa,
    IN const BYTE* pbEncMsg,
    OUT BYTE* pbMsg,
    IN OUT DWORD* pcbMsg
)
{
    const BufferSize = 300; // Maximum modulus size supported (256) + extra room required by some crypto primitives
    BYTE abPacket[BufferSize];
    BYTE abEnPacket[BufferSize];
    BYTE* pbPacketMsg;
    DWORD cbPacketMsg;
    EMEOAEP_ERROR error;

    // Copy message with the right byte order according to crypto primitive 
    // used
    for(DWORD i=0; i < cbPacket; i++)
        abEnPacket[i] = pbEncMsg[cbPacket-i-1];

    memset(abEnPacket + cbPacket, 0, BufferSize - cbPacket);

    // Descrypt
    if(keyType == RsaKeyPublic)
    {
        if(!BSafeEncPublic((LPBSAFE_PUB_KEY)pRsa, abEnPacket, abPacket))
            return false;
    }
    else if(keyType == RsaKeyPrivate)
    {
        if(!BSafeDecPrivate((LPBSAFE_PRV_KEY)pRsa, abEnPacket, abPacket))
            return false;
    }
    else
    {
        return false; // Where is the Assert macro?
    }

    // Readjust byte-order
    RevertBinary(abPacket, cbPacket);
    
    // Decode
    error = EmeOaepUnpack(cbPacket, NULL, abPacket, &pbPacketMsg, &cbPacketMsg);
    if(error != EmeoaepErrorNoError)
        return false;

    // Copy message to caller's buffer
    if(*pcbMsg < cbPacketMsg)
        return false;
    
    memcpy(pbMsg, pbPacketMsg, cbPacketMsg);
    *pcbMsg = cbPacketMsg;

    return true;
}

void CXoCrypto::RevertBinary(BYTE* pb, DWORD cb)
{
    for(DWORD i=0; i < cb/2; i++)
    {
        BYTE t = pb[i];
        pb[i] = pb[cb - i - 1];
        pb[cb - i - 1] = t;
    }
}


void DumpBinary(char* pszName, BYTE* pBin, DWORD cbBin)
{
    printf("const BYTE %s[%u] =\n{", pszName, cbBin);

    for(DWORD i=0; i < cbBin; i++)
    {
        if(i % 8 == 0)
            printf("\n    ");

        printf("0x%02x,", pBin[i]);
    }
    printf("\n};\n");
}

void Revert(BYTE* pb, DWORD cb)
{
    for(DWORD i=0; i < cb/2; i++)
    {
        BYTE t = pb[i];
        pb[i] = pb[cb - i - 1];
        pb[cb - i - 1] = t;
    }
}

const BYTE g_TestBsafePub2048[284] =
{
    0x52,0x53,0x41,0x31,0x08,0x01,0x00,0x00,0x00,0x08,0x00,0x00,0xFF,0x00,0x00,0x00,
    0x03,0x00,0x00,0x00,0xA5,0x29,0xF1,0x27,0x87,0xCD,0x12,0x92,0x3F,0xA8,0x59,0x2F,
    0xDD,0xD1,0xBA,0xB3,0x7E,0x2D,0xB4,0xD1,0xB2,0x62,0x30,0x65,0x94,0xA9,0x89,0x63,
    0x7F,0x2F,0x5B,0x2F,0xAC,0x43,0x54,0x66,0x16,0x46,0x0A,0xC1,0x18,0x64,0xEB,0xF9,
    0xB2,0x38,0x07,0x78,0xE5,0xEC,0x3C,0x61,0x39,0xC8,0x26,0xC4,0x3E,0xE9,0x6D,0x42,
    0x59,0x92,0xDD,0x62,0x04,0xF0,0x29,0x19,0x04,0x81,0xAE,0xCA,0x19,0xF9,0x4C,0x48,
    0xAE,0x86,0xC5,0x6D,0x88,0x52,0xCC,0x32,0x54,0x31,0x8A,0xFB,0x63,0xB2,0x3C,0x43,
    0x42,0x98,0x9E,0x25,0x8D,0xD3,0x3E,0x97,0xA3,0x71,0xCA,0x07,0x40,0xFD,0xD2,0xA3,
    0x56,0xA9,0x44,0x4E,0xB4,0x7D,0x92,0x23,0xEE,0x5E,0x1A,0xB8,0x95,0xF3,0xF9,0x02,
    0xC7,0x04,0xF7,0xA8,0xCE,0x24,0x90,0x30,0x5C,0xE2,0x82,0x77,0x77,0x99,0x39,0xBE,
    0x4F,0x19,0x05,0x7D,0x5D,0x55,0xB0,0x68,0x74,0x91,0xEF,0x82,0xA9,0xF5,0x11,0x91,
    0x7B,0xFA,0x4D,0xA7,0xB1,0xB0,0x76,0x21,0x87,0x3F,0xA1,0xDD,0x56,0xD1,0xDC,0xBD,
    0x90,0x9D,0xD6,0x7D,0x33,0x78,0xDA,0x80,0x6F,0xEE,0xA7,0x5C,0xB4,0xDD,0xBA,0x31,
    0x5B,0x61,0xD2,0x63,0x00,0xE8,0xC5,0x97,0x2A,0x76,0xFC,0x8E,0xFE,0xAA,0xB3,0x18,
    0xFF,0x7A,0x3C,0x6E,0x6E,0x63,0xA8,0xEF,0xA8,0x98,0xE8,0x78,0xF7,0xBC,0x49,0xCC,
    0x82,0xF7,0x02,0x96,0xC6,0x88,0x58,0x4E,0x84,0xD6,0x58,0x77,0xC0,0x4A,0xA1,0x30,
    0xD5,0x35,0x3F,0x1F,0x84,0x1C,0x8E,0x06,0xE6,0xF6,0xA0,0xDD,0x3D,0xC3,0x7B,0xEC,
    0xEB,0x62,0xFF,0xB5,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};

const BYTE g_TestBsafePrv2048[1340] =
{
    0x52,0x53,0x41,0x32,0x08,0x01,0x00,0x00,0x00,0x08,0x00,0x00,0xFF,0x00,0x00,0x00,
    0x03,0x00,0x00,0x00,0xA5,0x29,0xF1,0x27,0x87,0xCD,0x12,0x92,0x3F,0xA8,0x59,0x2F,
    0xDD,0xD1,0xBA,0xB3,0x7E,0x2D,0xB4,0xD1,0xB2,0x62,0x30,0x65,0x94,0xA9,0x89,0x63,
    0x7F,0x2F,0x5B,0x2F,0xAC,0x43,0x54,0x66,0x16,0x46,0x0A,0xC1,0x18,0x64,0xEB,0xF9,
    0xB2,0x38,0x07,0x78,0xE5,0xEC,0x3C,0x61,0x39,0xC8,0x26,0xC4,0x3E,0xE9,0x6D,0x42,
    0x59,0x92,0xDD,0x62,0x04,0xF0,0x29,0x19,0x04,0x81,0xAE,0xCA,0x19,0xF9,0x4C,0x48,
    0xAE,0x86,0xC5,0x6D,0x88,0x52,0xCC,0x32,0x54,0x31,0x8A,0xFB,0x63,0xB2,0x3C,0x43,
    0x42,0x98,0x9E,0x25,0x8D,0xD3,0x3E,0x97,0xA3,0x71,0xCA,0x07,0x40,0xFD,0xD2,0xA3,
    0x56,0xA9,0x44,0x4E,0xB4,0x7D,0x92,0x23,0xEE,0x5E,0x1A,0xB8,0x95,0xF3,0xF9,0x02,
    0xC7,0x04,0xF7,0xA8,0xCE,0x24,0x90,0x30,0x5C,0xE2,0x82,0x77,0x77,0x99,0x39,0xBE,
    0x4F,0x19,0x05,0x7D,0x5D,0x55,0xB0,0x68,0x74,0x91,0xEF,0x82,0xA9,0xF5,0x11,0x91,
    0x7B,0xFA,0x4D,0xA7,0xB1,0xB0,0x76,0x21,0x87,0x3F,0xA1,0xDD,0x56,0xD1,0xDC,0xBD,
    0x90,0x9D,0xD6,0x7D,0x33,0x78,0xDA,0x80,0x6F,0xEE,0xA7,0x5C,0xB4,0xDD,0xBA,0x31,
    0x5B,0x61,0xD2,0x63,0x00,0xE8,0xC5,0x97,0x2A,0x76,0xFC,0x8E,0xFE,0xAA,0xB3,0x18,
    0xFF,0x7A,0x3C,0x6E,0x6E,0x63,0xA8,0xEF,0xA8,0x98,0xE8,0x78,0xF7,0xBC,0x49,0xCC,
    0x82,0xF7,0x02,0x96,0xC6,0x88,0x58,0x4E,0x84,0xD6,0x58,0x77,0xC0,0x4A,0xA1,0x30,
    0xD5,0x35,0x3F,0x1F,0x84,0x1C,0x8E,0x06,0xE6,0xF6,0xA0,0xDD,0x3D,0xC3,0x7B,0xEC,
    0xEB,0x62,0xFF,0xB5,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7B,0xED,0x1B,0x19,
    0xDF,0x3F,0x0E,0x5B,0xE2,0xBA,0x0B,0x5A,0x9B,0x04,0x7E,0xAE,0xE7,0x4F,0x8E,0xDB,
    0x20,0x6E,0xAC,0x03,0x49,0x83,0x54,0x23,0x18,0xDD,0xEC,0xBC,0x3B,0x2F,0x39,0x7D,
    0xA7,0x1E,0xDF,0x47,0xCA,0x84,0xBF,0x2B,0x6A,0x11,0x51,0xA6,0x2D,0xF4,0xCA,0x2B,
    0x1E,0xF6,0x0C,0xCD,0x6C,0xA8,0x5C,0x84,0x45,0x0E,0x53,0x26,0xB0,0x85,0x01,0xB9,
    0x9B,0x67,0x2F,0x4F,0x83,0x9D,0x1E,0xEA,0xCC,0xFF,0x66,0x77,0x27,0x9F,0x22,0x07,
    0x1A,0xA8,0xFF,0x0E,0x3D,0x3A,0x06,0x33,0xD2,0x81,0x91,0x9E,0x09,0x0F,0xE0,0x0D,
    0xD3,0x1B,0x9A,0x76,0x17,0x04,0x6C,0x7C,0x5F,0x54,0xFC,0x4A,0x9C,0xA1,0x38,0x4E,
    0x79,0xBB,0x9C,0xA9,0xD6,0xD7,0x20,0x35,0x6D,0x17,0xB7,0xEA,0x00,0x00,0x00,0x00,
    0x5F,0x4B,0xB3,0x61,0xED,0x8D,0xEB,0x8B,0xCF,0xF7,0x4F,0xB6,0xA5,0xC7,0x05,0x50,
    0xAD,0x00,0x6D,0xB7,0xF0,0xEA,0xA6,0x9E,0xC5,0xA8,0xF2,0xAE,0x19,0x3F,0xFD,0xBC,
    0xA9,0xF1,0x2F,0x8D,0x18,0x3A,0xCF,0xFA,0x25,0xE0,0x04,0x47,0xF2,0xAB,0xFD,0xB4,
    0x9B,0x0D,0x9B,0xA6,0xB0,0x65,0x0D,0x4A,0xC0,0x2D,0xAA,0x29,0xCE,0xE6,0x17,0xFD,
    0xDF,0xCC,0x87,0x38,0xE9,0xD7,0xC7,0xF8,0x4B,0xBE,0xCB,0xE6,0x8E,0xC8,0xEC,0x39,
    0xF1,0x4C,0x03,0xB2,0xB6,0x06,0xD9,0x38,0x47,0xEE,0x0D,0xAC,0x51,0x5E,0xFE,0xC8,
    0xE7,0x5E,0xD2,0xB0,0xCD,0x26,0x89,0xFB,0xD2,0x23,0xAE,0xCB,0xFD,0xEC,0x9A,0x16,
    0x4C,0x04,0xFE,0x8E,0x7B,0xE1,0x50,0xF3,0x8E,0x4B,0xC5,0xB5,0xFB,0x74,0x80,0xC6,
    0x00,0x00,0x00,0x00,0xA7,0xF3,0x67,0xBB,0x94,0x2A,0xB4,0x3C,0xEC,0xD1,0x07,0x3C,
    0x12,0x03,0x54,0x74,0x9A,0x8A,0x09,0x3D,0x6B,0x49,0xC8,0x57,0xDB,0xAC,0x8D,0x17,
    0x10,0x3E,0xF3,0x7D,0xD2,0x74,0x7B,0x53,0x1A,0xBF,0x94,0xDA,0x86,0x58,0x2A,0x1D,
    0x9C,0x0B,0x36,0xC4,0x73,0x4D,0x87,0x72,0x69,0xF9,0x5D,0x33,0xF3,0x1A,0x93,0xAD,
    0x83,0x09,0xE2,0x6E,0x75,0xAE,0xAB,0xD0,0x67,0x9A,0x1F,0x8A,0x57,0xBE,0x69,0xF1,
    0xDD,0xFF,0x99,0x4F,0x1A,0x6A,0x6C,0xAF,0x66,0xC5,0xFF,0x09,0x7E,0xD1,0xAE,0xCC,
    0x36,0x01,0x61,0x14,0xB1,0xB4,0xEA,0xB3,0x8C,0x12,0xBC,0xF9,0x64,0xAD,0xF2,0x52,
    0xEA,0xE2,0x52,0x87,0xBD,0x6B,0xD0,0xDE,0x50,0xD2,0xBD,0x1B,0x8F,0x3A,0x6B,0x23,
    0x9E,0x0F,0x7A,0x9C,0x00,0x00,0x00,0x00,0x3F,0x32,0x22,0x41,0x9E,0x5E,0xF2,0x07,
    0x35,0xA5,0x8A,0x79,0x6E,0xDA,0x03,0xE0,0xC8,0x55,0xF3,0x24,0x4B,0x47,0x6F,0x14,
    0xD9,0xC5,0xA1,0x74,0x66,0x7F,0x53,0xD3,0x1B,0xA1,0xCA,0x08,0xBB,0x26,0x8A,0xFC,
    0xC3,0xEA,0xAD,0x84,0xA1,0x72,0xFE,0xCD,0x67,0x5E,0x67,0xC4,0x75,0xEE,0x08,0xDC,
    0x2A,0xC9,0xC6,0x1B,0x34,0xEF,0x0F,0xFE,0x3F,0x33,0x05,0x7B,0x9B,0x3A,0x85,0x50,
    0xDD,0x7E,0x32,0xEF,0x09,0xDB,0x9D,0x26,0xF6,0xDD,0xAC,0x76,0x24,0xAF,0x90,0xD0,
    0x84,0x49,0x09,0xC8,0x8B,0xE9,0xFE,0x85,0x9A,0x94,0xE1,0x75,0xDE,0x19,0x06,0xFD,
    0xE1,0x17,0x74,0x32,0xA9,0x48,0x67,0x64,0xDD,0x02,0x54,0x5F,0x52,0x96,0xE0,0x4C,
    0x5F,0x32,0x2E,0x79,0x52,0xA3,0x55,0x84,0x00,0x00,0x00,0x00,0x8D,0xD8,0xD0,0x92,
    0x37,0xC7,0xA5,0xA5,0x24,0x47,0x8F,0x27,0x4E,0x3C,0xD0,0x2B,0x9E,0xFD,0xD8,0x4C,
    0xFE,0x2C,0x31,0x6E,0x8E,0x33,0xD2,0x41,0xC4,0xE4,0xED,0xA3,0x35,0x09,0xFF,0xB5,
    0x47,0xAD,0x83,0x5E,0x15,0x4E,0xD3,0x33,0xDC,0xB8,0x61,0x58,0x66,0xA8,0x10,0x21,
    0x1C,0x66,0x8E,0x7A,0xF8,0xFB,0xA5,0x0B,0x82,0xDA,0xC2,0x61,0xA8,0xA9,0x33,0xF5,
    0xF8,0x1B,0x28,0x3B,0xEF,0xD5,0xD9,0x04,0x86,0xE1,0xA7,0xE0,0x92,0xC7,0x78,0x1A,
    0xC9,0x13,0xCB,0xEA,0x15,0xE8,0xCC,0xB4,0xBB,0x2B,0xD5,0x3D,0x3D,0x54,0xBC,0x4C,
    0xCA,0x63,0xA3,0x72,0x49,0x7F,0x0C,0x05,0xB5,0xDD,0x12,0x2B,0x0A,0x83,0x5C,0x78,
    0xC4,0x1A,0x96,0x0A,0x7F,0xA9,0x29,0x19,0xF4,0x79,0xFE,0x5B,0x00,0x00,0x00,0x00,
    0x33,0x4B,0xC1,0xC8,0xD1,0xFF,0x65,0xC7,0xB3,0xA3,0xFE,0x69,0xBD,0x03,0x7A,0x23,
    0xF1,0x3D,0x7B,0xD4,0xC0,0x5B,0x93,0x2C,0x59,0xFE,0xD6,0x60,0xDE,0x0C,0xF6,0x78,
    0x84,0x6C,0x47,0x3D,0xE4,0x48,0x3D,0x54,0x70,0xFF,0x19,0x5A,0xE4,0xFC,0x7A,0x68,
    0xBD,0x9C,0xE4,0x09,0x47,0x48,0x08,0x1E,0x61,0xB7,0x44,0xB8,0x83,0x13,0xF7,0xD4,
    0xA2,0x13,0x6B,0x1A,0xAA,0x2B,0x7A,0xAC,0x31,0xBE,0x41,0xFA,0x36,0xD4,0x4B,0x28,
    0xF5,0xEE,0x6E,0xA6,0x57,0xAC,0xCB,0x77,0xEA,0x5B,0x70,0xED,0xBE,0x7A,0xB4,0x7E,
    0x12,0x99,0x5D,0x90,0xAC,0x74,0x6F,0x0E,0x39,0x8E,0xD0,0xE7,0x50,0x45,0x1E,0xF3,
    0x87,0x3A,0x3D,0x84,0xFB,0x2B,0x73,0x67,0x75,0x35,0x0D,0x10,0x94,0xA5,0x7F,0xFA,
    0xDD,0x6D,0xB5,0x75,0x3D,0xEC,0x01,0xA5,0x4F,0x66,0x26,0xD4,0xDF,0x10,0xAE,0xA8,
    0x93,0xE3,0xCA,0x45,0xF8,0x60,0x4A,0x57,0xC6,0xA3,0xB6,0x60,0x52,0xFC,0x33,0x1A,
    0x21,0xCB,0xF9,0xC0,0x04,0xD5,0xC0,0x93,0xE4,0xE0,0x3D,0x29,0x0B,0x69,0xE4,0x53,
    0x22,0x50,0x3C,0xAB,0x9F,0x49,0xC5,0x3D,0x78,0x3E,0x27,0x21,0x92,0xEB,0x36,0xED,
    0xAA,0x9A,0x2E,0x65,0x1C,0xA4,0xFD,0x09,0xFF,0x71,0x22,0xBB,0x54,0xA7,0x7D,0x49,
    0xF4,0xEC,0x1A,0xF5,0xC5,0x65,0xF0,0xA5,0x4F,0xD3,0xDB,0x32,0x57,0xFA,0x01,0x64,
    0x84,0xB0,0xE5,0xDE,0x02,0x8F,0x90,0x4F,0x80,0xDC,0xC0,0x75,0xE3,0x23,0x2A,0x6A,
    0xAD,0xBD,0x5E,0x04,0x44,0x4F,0x6B,0x3E,0x29,0x82,0x52,0x48,0x9D,0xEC,0x54,0x79,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};

bool EncryptCert()
{
    bool fRet = false;
    const DWORD packetSize = 256;
    const DWORD bufferSize = 264;
    BYTE abEncodedCert[bufferSize];
    BYTE abEncryptedCert[bufferSize];
    const LPBSAFE_PRV_KEY pPrvKey = (LPBSAFE_PRV_KEY) g_MasterSigningBsafePrv2048;
    const LPBSAFE_PUB_KEY pPubKey = (LPBSAFE_PUB_KEY) g_MasterSigningBsafePub2048;
    
    const BYTE abSeed[EMEOAEP_HASH_SIZE] = {
        0x01, 0x02, 0x03, 0x04, 0x05,
        0x06, 0x07, 0x08, 0x09, 0x0a,
        0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
        0x10, 0x11, 0x12, 0x13, 0x14
    };

    Verify(bufferSize >= pPrvKey->keylen);
    
    // Encode certificate using EME-OAEP
    Verify(EmeoaepPack(packetSize, NULL, abSeed, (const BYTE*)&g_ConsoleCert, 
                       sizeof(g_ConsoleCert), abEncodedCert) == EmeoaepErrorNoError);
    
    // Revert blob to put it in the byte order expected by the crypt primitive
    Revert(abEncodedCert, packetSize);
    
    // Zero out the rest of the buffer (required by the crypto primitive)
    memset(abEncodedCert + packetSize, 0, bufferSize - packetSize);

    // Encrypt
    Verify(BSafeDecPrivate(pPrvKey, abEncodedCert, abEncryptedCert))

    Revert(abEncryptedCert, packetSize);
    
    DUMPBINARY(abEncryptedCert, packetSize);

    // Verify
    Revert(abEncryptedCert, packetSize);
    XENON_ONLINE_KEY_CERTIFICATE* pcert = NULL;
    DWORD cbCert = sizeof(XENON_ONLINE_KEY_CERTIFICATE);
    memset(abEncodedCert, 0, sizeof(abEncodedCert));
    memset(abEncryptedCert + packetSize, 0, bufferSize - packetSize);

    // Decrypt
    Verify(BSafeEncPublic(pPubKey, abEncryptedCert, abEncodedCert))

    // Restore expected byte-order
    Revert(abEncodedCert, packetSize);

    // Decode
    Verify(EmeOaepUnpack(packetSize, NULL, abEncodedCert, 
                      (BYTE**)&pcert, &cbCert) == EmeoaepErrorNoError);
    
    Verify(cbCert == sizeof(XENON_ONLINE_KEY_CERTIFICATE))

    Verify(memcmp(&g_ConsoleCert, pcert, sizeof(XENON_ONLINE_KEY_CERTIFICATE)) == 0);
    
    // Dump
//     BSAFE_KEY_PARTS keyparts;
//     BSafeGetPrvKeyParts(pPrvKey, &keyparts);
//     DUMPBINARY(keyparts.modulus, packetSize);
//     DUMPBINARY(keyparts.prime1, packetSize/2);
//     DUMPBINARY(keyparts.prime2, packetSize/2);
//     DUMPBINARY(keyparts.invpr1, packetSize/2);
//     DUMPBINARY(keyparts.invpr2, packetSize/2);
//     DUMPBINARY(keyparts.prvexp, packetSize/2);
//     DUMPBINARY(keyparts.exp1, packetSize/2);
//     DUMPBINARY(keyparts.exp2, packetSize/2);
//     DUMPBINARY(keyparts.coef, packetSize/2);
//     DUMPBINARY(keyparts.invmod, packetSize/2);
//     DUMPBINARY(keyparts.prvexp, packetSize);
    
    

    fRet = true;

    return fRet;
}

void Test()
{
    CXoCrypto crypto;
    XENON_ONLINE_KEY_CERTIFICATE cert;
    memset(&cert, 0, sizeof(cert));
    DWORD cbCert = sizeof(cert);

    crypto.DecryptWithMasterSigningKey(g_abEncOnlineKeyCertificate, sizeof(g_abEncOnlineKeyCertificate),
        (BYTE*)&cert, &cbCert);

}

// Decrypt and decode a ciphertext generated using the RSA Windows Crypto 
// Provider to make sure that especially our EME-OAEP implementation is 
// compliant
void TestCompliance()
{
    const DWORD packetSize = 256;
    const DWORD bufferSize = 264;
    BYTE abMessage[bufferSize];
    BYTE abEncMessage[bufferSize];
    
    BYTE abCipherText[bufferSize] = {
        0xaf,0x9e,0xc7,0x3d,0x92,0x2b,0xbf,0xec,
        0x9b,0xaa,0x8b,0x36,0x1d,0x74,0x67,0x11,
        0x44,0x17,0x1b,0xd6,0x00,0x51,0xe2,0x33,
        0x52,0xa2,0x9b,0x25,0x44,0xf1,0x86,0xae,
        0x1c,0xcb,0x35,0xe0,0x89,0x3e,0xfd,0x86,
        0x8b,0x89,0x0d,0x31,0xe9,0xf4,0x77,0x5b,
        0x50,0xa2,0xab,0xdd,0x6f,0x02,0xe8,0xbc,
        0xfa,0x53,0x40,0x67,0xdd,0xa0,0x0d,0x63,
        0x8d,0xdc,0xea,0x8c,0x5b,0x7d,0xf7,0x8e,
        0x8e,0xfd,0x4a,0xa2,0x94,0xd8,0x39,0xe2,
        0x34,0xcd,0xcb,0x79,0x03,0xf8,0x43,0x48,
        0x3e,0x0e,0xd0,0x50,0x2a,0x41,0xcc,0xae,
        0x56,0xd3,0x0e,0x71,0x7d,0xe7,0x19,0x7a,
        0xfb,0x65,0x29,0x07,0x82,0xd3,0xd8,0x55,
        0x6c,0x4c,0xc7,0xd7,0xd1,0x77,0x6f,0xcc,
        0xda,0xdc,0x99,0x14,0x38,0x8e,0x9b,0x7e,
        0x76,0x29,0x87,0xf2,0x83,0x87,0x09,0x2b,
        0xfa,0x7c,0x9c,0xf3,0x43,0xe8,0x2c,0x2e,
        0x72,0x7d,0x04,0xe8,0x23,0x5e,0x16,0xaf,
        0xe9,0x77,0xd0,0xc6,0xf8,0x3e,0xc8,0x22,
        0xdd,0xa9,0xaf,0x71,0x3f,0x70,0xb8,0xb1,
        0xcc,0xbf,0x90,0xd9,0x78,0xfe,0x8e,0x62,
        0xd0,0x0e,0xb9,0xc4,0xf0,0xae,0x0d,0xb1,
        0x91,0x17,0x5b,0xf0,0x36,0xcf,0x68,0xb5,
        0xe4,0xe7,0x2a,0x50,0xb4,0x8d,0x3d,0xa1,
        0xdb,0x88,0x34,0xfd,0x68,0x84,0x59,0xb4,
        0x3f,0x26,0x78,0x51,0x4b,0x5a,0x90,0x53,
        0x99,0xcd,0x18,0x53,0xe9,0xa5,0xf5,0x09,
        0xa2,0x18,0xa6,0x32,0x35,0xfa,0x97,0xb5,
        0x08,0xf2,0x79,0x54,0x52,0x84,0x9e,0xb8,
        0x39,0xe4,0xc8,0xaf,0x28,0x4a,0xec,0x66,
        0xc7,0xe4,0xc5,0x1f,0xb5,0x6b,0x9b,0x06
    };

    BYTE abClearText[] = {
        0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09
    };

    Revert(abCipherText, packetSize);
    memset(abCipherText + packetSize, 0, bufferSize - packetSize);

    const LPBSAFE_PRV_KEY pPrvKey = (LPBSAFE_PRV_KEY) g_TestBsafePrv2048;
    const LPBSAFE_PUB_KEY pPubKey = (LPBSAFE_PUB_KEY) g_TestBsafePub2048;

    Verify(BSafeDecPrivate(pPrvKey, abCipherText, abEncMessage));
    Revert(abEncMessage, packetSize);

    BYTE* pMsg  = NULL;
    DWORD cbMsg = 0;
    Verify(EmeOaepUnpack(packetSize, NULL, abEncMessage, 
                      &pMsg, &cbMsg) == EmeoaepErrorNoError);

    Verify(cbMsg == sizeof(abClearText));
    Verify(memcmp(pMsg, abClearText, cbMsg) == 0);
}

int __cdecl main(int argc, char* argv[])
{
    Test();
    TestCompliance();
    EncryptCert();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\kerbclient\debugtrace.h ===
// Copyright (C) Microsoft Corporation

#pragma once

// -- interfaces to be called from the managed code

//enables or disables capturing of debug spew into thread-local stores (off by default)
// 0=off, 1=warnings only, 2=all
void kcl_EnableDebugSpewCapture(int enableLevel);

//returns the number of bytes needed to store the current thread's debug spew
unsigned int kcl_GetDebugSpewSize();

//returns the debug spew for the current thread in the provided buffer.
//normally every call into a kcl_ function that does actual kerb-related work will clear this buffer at the start.
void kcl_GetDebugSpew(unsigned char *outBuffer, unsigned int bufferSize);

// -- for use by kerb client and internally

//clears the current thread's stored debug spew.  every kerb-related entry point should call this first-thing.
void ClearStoredDebugSpew();

//spew output, in printf-style.
//  src is a string for the source file location that generated the spew
//  msg is the actual string message
//  the rest are printf-style formatting params
void KCDebugSpew(int level, const char *srcFile, int srcLine, const char *msg, ...);

// -- the old macros that previously tossed their contents into oblivion
//asserts
#define Assert(c) do { if (!(c)) KCDebugSpew(Warning, __FILE__, __LINE__, "assert!"); } while (false)
#define AssertSz(c, m) do { if (!(c)) KCDebugSpew(Warning, __FILE__, __LINE__, m); } while (false)
#define AssertSz1(c, m, a1) do { if (!(c)) KCDebugSpew(Warning, __FILE__, __LINE__, m, a1); } while (false)
#define AssertSz2(c, m, a1, a2) do { if (!(c)) KCDebugSpew(Warning, __FILE__, __LINE__, m, a1, a2); } while (false)

//spews
#define TraceSz(t, f) KCDebugSpew(t, __FILE__, __LINE__, f)
#define TraceSz1(t, f, a1) KCDebugSpew(t, __FILE__, __LINE__, f, a1)
#define TraceSz2(t, f, a1, a2) KCDebugSpew(t, __FILE__, __LINE__, f, a1, a2)
#define TraceSz3(t, f, a1, a2, a3) KCDebugSpew(t, __FILE__, __LINE__, f, a1, a2, a3)
#define TraceSz4(t, f, a1, a2, a3, a4) KCDebugSpew(t, __FILE__, __LINE__, f, a1, a2, a3, a4)
#define TraceSz5(t, f, a1, a2, a3, a4, a5) KCDebugSpew(t, __FILE__, __LINE__, f, a1, a2, a3, a4, a5)
#define TraceSz6(t, f, a1, a2, a3, a4, a5, a6) KCDebugSpew(t, __FILE__, __LINE__, f, a1, a2, a3, a4, a5, a6)
#define TraceSz7(t, f, a1, a2, a3, a4, a5, a6, a7) KCDebugSpew(t, __FILE__, __LINE__, f, a1, a2, a3, a4, a5, a6, a7)
#define TraceSz8(t, f, a1, a2, a3, a4, a5, a6, a7, a8) KCDebugSpew(t, __FILE__, __LINE__, f, a1, a2, a3, a4, a5, a6, a7, a8)
#define TraceSz9(t, f, a1, a2, a3, a4, a5, a6, a7, a8, a9) KCDebugSpew(t, __FILE__, __LINE__, f, a1, a2, a3, a4, a5, a6, a7, a8,a9)

//these are used in the traces a lot, but didn't seem to be defined anywhere... so lets give them values we can filter on
#define AuthVerbose 2
#define AuthWarn 1
#define Warning 1
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\kerbclient\debugtrace.cpp ===
// Copyright (C) Microsoft Corporation

#include "xonp.h"
#include "debugtrace.h"
#include <string>

#undef min //evil windows.h macro junk

namespace
{
    //global settings
    int spewEnableLevel=1;

    //stored thread spew
    int tlsIndex=-1;

    //prepares the thread for spew use if needed, and returns the string associated with the thread
    //note that the string for each thread is never freed
    inline std::string* GetThreadString()
    {
        if (tlsIndex==-1)
        {
            return 0;
        }

        void *tlsValue=TlsGetValue((DWORD)tlsIndex);
        if (tlsValue==0)
        {
            tlsValue=new std::string();
            TlsSetValue((DWORD)tlsIndex, tlsValue);
        }

        return (std::string*)tlsValue;
    }
}

//sets up tls for the traces
void InitDebugTrace()
{
    if (tlsIndex==-1)
    {
        DWORD ind=TlsAlloc();
        if (ind!=TLS_OUT_OF_INDEXES)
        {
            tlsIndex=(int)ind;
        }
    }
}

//enables or disables capturing of debug spew into thread-local stores (off by default)
void kcl_EnableDebugSpewCapture(int enableLevel)
{
    spewEnableLevel=enableLevel;
}

//returns the number of bytes needed to store the current thread's debug spew.
unsigned int kcl_GetDebugSpewSize()
{
    std::string *pThreadSpew=GetThreadString();
    if (!pThreadSpew || pThreadSpew->empty()) return 0;

    return pThreadSpew->size()+1;
}

//returns the debug spew for the current thread in the provided buffer as a null-terminated string.
void kcl_GetDebugSpew(unsigned char *outBuffer, unsigned int bufferSize)
{
    std::string *pThreadSpew=GetThreadString();
    if (!pThreadSpew || bufferSize==0) return;

    unsigned int copyAmount=std::min<unsigned long>(pThreadSpew->size(), bufferSize-1);
    memcpy(outBuffer, &(*pThreadSpew)[0], copyAmount);
    outBuffer[copyAmount]=0;

    ClearStoredDebugSpew();
}

//clears the current thread's stored debug spew.  every kerb-related entry point should call this first-thing.
void ClearStoredDebugSpew()
{
    std::string *pThreadSpew=GetThreadString();
    if (!pThreadSpew) return;

    pThreadSpew->clear();
}

//convert printf-style output to a string and add it to the thread's spew
void KCDebugSpew(int level, const char *srcFile, int srcLine, const char *msg, ...)
{
    if (spewEnableLevel==0 || tlsIndex==-1)
    {
        return;
    }

    if (spewEnableLevel==1 && !(level==AuthWarn || level==Warning))
    {
        return;
    }

    std::string *pThreadSpew=GetThreadString();
    if (!pThreadSpew) return;

    //convert the var arg format to a string (8k per-message max)
    char buff[8192];
    va_list args;
    va_start(args, msg);
    vsnprintf(buff, sizeof(buff)-1, msg, args);
    va_end(args);
    buff[sizeof(buff)-1]=0; //just in case

    //make a string with everything in it
    char tmp[32];
    std::string s;
    s+=buff;
    s+="  (";
    s+=srcFile;
    s+=" line ";
    s+=itoa(srcLine, tmp, 10);
    s+=")";

    //add it
    if (!pThreadSpew->empty())
    {
        *pThreadSpew+="\n";
    }

    *pThreadSpew+=s;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\kerbclient\kerbclient.cpp ===
#include "xonp.h"
#include <time.h>

extern KerbClientCrypt g_ClientCrypt;

void 
KerbInit();

void
KerbTerm();

void InitDebugTrace();

static HRESULT MakeAccountWithKey(
    IN ULONGLONG id,
    IN char *szName,
    IN char *szDomain,
    IN char *szRealm,
    IN BYTE *bKey,
    IN OUT XONLINEP_USER *pUser)
{
    memset(pUser, 0, sizeof(XONLINEP_USER));

    pUser->xuid.qwUserID = id;
    pUser->xuid.dwUserFlags = 0;
    strncpy(pUser->gamertag, szName, XONLINE_GAMERTAG_SIZE);
    strncpy(pUser->domain, szDomain, XONLINE_USERDOMAIN_SIZE);
    strncpy(pUser->kerberosRealm, szRealm, XONLINE_KERBEROSREALM_SIZE);
    memset(pUser->passcode, 0, 4);
    memcpy(pUser->key, bKey, XONLINE_KEY_LENGTH);

    return S_OK;
}

HRESULT WINAPI
kcl_Initialize(
    OUT DWORD *pdwStatus
    )
{
    HRESULT hr = S_OK;

    InitDebugTrace();

    *pdwStatus = g_ClientCrypt.Initialize();
    if (*pdwStatus != 0)
    {
        hr = E_FAIL;
    }

    return hr;
}
    

HRESULT WINAPI 
kcl_BuildXboxMachineRequest(
    IN const TitleInfo* pTitleInfo,
    IN XONLINEP_USER *pusr,
    IN const DWORD *pPreauthTypeList, // array of preauth types to include
    IN DWORD PreauthTypeListLength,
    OUT BYTE *pb,
    IN OUT ULONG *cb,
    OUT XKERB_TGT_CONTEXT *ptgt)
{
    ClearStoredDebugSpew();

    HRESULT hr = S_OK;

    memset(ptgt, 0, sizeof(XKERB_TGT_CONTEXT));

    hr = KerbStatusToHresult(XkerbBuildAsRequest(pTitleInfo, 0, 0, FALSE, pusr, pPreauthTypeList, PreauthTypeListLength, 0, 0, false, pb, cb, ptgt));

    return hr;
}

HRESULT WINAPI 
kcl_VerifyMachineReply(
    IN BYTE *pb,
    IN ULONG cb,
    IN OUT XKERB_TGT_CONTEXT *ptgt,
    OUT XONLINEP_USER *pusr)
{
    ClearStoredDebugSpew();

    HRESULT hr = S_OK;

    if (SUCCEEDED(hr = kcl_VerifyAsReply(pb, cb, ptgt)))
    {
        // Fill in the account structure with the newly created account
        if (ptgt->pAccountCreationPreAuth)
        {
            hr = MakeAccountWithKey(
                ptgt->pAccountCreationPreAuth->qwUserID,
                ptgt->pAccountCreationPreAuth->gamertag,
                ptgt->pAccountCreationPreAuth->domain,
                ptgt->pAccountCreationPreAuth->kerberosRealm,
                ptgt->pAccountCreationPreAuth->key,
                pusr);

            // TESTKERB should always be defined for Kerbclient.  This memory 
            // is allocated with malloc in kerberos.cpp when TESTKERB is 
            // defined.
            free(ptgt->pAccountCreationPreAuth);
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }

    return hr;
}


HRESULT WINAPI 
kcl_BuildAsRequest(
    IN const TitleInfo* pTitleInfo,
    IN const AsRequestInfo* pAsRequestInfo,
    IN DWORD cbAsRequestInfo,
    IN BOOL fMachineAccount,
    IN XONLINEP_USER *pUser,
    IN const DWORD *pPreauthTypeList,
    IN DWORD PreauthTypeListLength,
    IN BYTE *pEchoPreauthBytes,
    IN DWORD cbEchoPreauthBytes,
    IN bool allowFakeCompoundPreauth,
    OUT BYTE *pbRequestMessage,
    IN OUT ULONG *pcbRequestMessageLength,
    IN OUT XKERB_TGT_CONTEXT *pTGTContext,
    IN XKERB_TGT_CONTEXT *pInputTGTContext)
{
    ClearStoredDebugSpew();

    HRESULT hr = S_OK;

    pTGTContext->pInputTGTContext = pInputTGTContext;
    hr = KerbStatusToHresult(XkerbBuildAsRequest(pTitleInfo, pAsRequestInfo, cbAsRequestInfo, fMachineAccount, pUser, pPreauthTypeList, PreauthTypeListLength, pEchoPreauthBytes, cbEchoPreauthBytes, allowFakeCompoundPreauth, pbRequestMessage, pcbRequestMessageLength, pTGTContext));
    pTGTContext->pInputTGTContext = NULL;
    return hr;
}

HRESULT WINAPI 
kcl_CreateToken(
    IN ULONG dwTokenType,
    OUT VOID **ppToken,
    IN BYTE *pbOptionalData,
    IN DWORD cbOptionalData,
    IN DWORD dwOptionalDword)
{
    switch (dwTokenType)
    {
    case TOKENTYPE_TGTCONTEXT:
        *ppToken = new XKERB_TGT_CONTEXT;
        memset(*ppToken, 0, sizeof(XKERB_TGT_CONTEXT));
        break;
    default:
        return E_INVALIDARG;
    }

    if (!ppToken)
        return E_OUTOFMEMORY;
    
    return S_OK;
}

HRESULT WINAPI 
kcl_DeleteToken(
    IN VOID *pToken)
{
    if (pToken)
        delete pToken;
    
    return S_OK;
}

HRESULT WINAPI
kcl_GetPassportAuthInfoFromToken(
    VOID* pToken,
    OUT UINT32* pIsInfoAvailable,
    OUT UINT64* pUserId,
    OUT CHAR* pGamertag,
    IN OUT UINT32* pGamertagLen
)
{
    ClearStoredDebugSpew();

    XKERB_TGT_CONTEXT* pTGTContext = (XKERB_TGT_CONTEXT*) pToken;

    *pIsInfoAvailable = pTGTContext->isPassportAuthInfoAvailable;

    if(*pIsInfoAvailable)
    {
        *pUserId = pTGTContext->passportAuthInfo.userId;

        if(*pGamertagLen < sizeof(pTGTContext->passportAuthInfo.gamertag))
            return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);

        lstrcpynA(pGamertag, pTGTContext->passportAuthInfo.gamertag, 
                  *pGamertagLen);

        *pGamertagLen = (UINT32) strlen(pGamertag);
    }

    return S_OK;
}

extern LONGLONG g_nClockSkew;

void WINAPI 
kcl_LibrarySetTimeSkew(
    IN LONGLONG nSkew)
{
    g_nClockSkew = nSkew;
}

void WINAPI 
kcl_LibraryGetTimeSkew(
    IN LONGLONG *pnSkew)
{
    *pnSkew = g_nClockSkew;
}


BOOL WINAPI DllMain(
  HINSTANCE hinstDLL,
  DWORD fdwReason,
  LPVOID lpvReserved
)
{
    switch(fdwReason)
    {
    case DLL_PROCESS_ATTACH:
        KerbInit();
        break;
    case DLL_THREAD_ATTACH:
        break;
    case DLL_THREAD_DETACH:
        break;
    case DLL_PROCESS_DETACH:
        KerbTerm();
        break;
    }
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\kerbclient\kerbclient.h ===
#ifndef KERBCLIENT_H
#define KERBCLIENT_H

typedef LONG NTSTATUS, *PNTSTATUS;
typedef LARGE_INTEGER TimeStamp, *PTimeStamp;

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)
#define STATUS_SUCCESS                          ((NTSTATUS)0x00000000L) // ntsubauth
#define XONLINE_MAX_TICKET_LENGTH             1024
#define XONLINE_MAX_ECHO_PREAUTH_LENGTH       40
#define KERBEROS_MAX_PRINCIPLE_NAME_SIZE    (sizeof(DWORD) + XONLINE_GAMERTAG_SIZE + XONLINE_USERDOMAIN_SIZE + XONLINE_KERBEROSREALM_SIZE + /*buffer*/ 20)
#define MAX_KERB_RETRIES 6
#define MAX_TIME_ADJUSTMENTS 2
#define CBDHG1 96

// Sizes for scratch memory during various request
#define SCRATCH_MEMORY_SIZE_FOR_BuildAsRequest 4096
#define SCRATCH_MEMORY_SIZE_FOR_VerifyAsReply 2048
#define SCRATCH_MEMORY_SIZE_FOR_BuildTgsRequest 4096
#define SCRATCH_MEMORY_SIZE_FOR_VerifyTgsReply 3072
#define SCRATCH_MEMORY_SIZE_FOR_BuildApRequest 4096
#define SCRATCH_MEMORY_SIZE_FOR_VerifyApReply 2048
#define SCRATCH_MEMORY_SIZE_FOR_BuildTgsTicket 4096
#define SCRATCH_MEMORY_SIZE_FOR_BuildPcMachineRequest 4096

struct TitleInfo
{
    DWORD dwTitleId;
    DWORD dwTitleVersion;
    DWORD dwTitleGameRegion;
    CHAR pszXboxVersion[16];
    XBOX_LIBRARY_VERSION clientVersion;
    DWORD dwFlashVersion;
    WORD wOverrideDefaultServiceRequest;
    WORD wOverrideDefaultServiceRequestVersion;
};

#pragma pack(push, 4)
struct AsRequestInfo
{
    //new items to support xenon ppa to differentiate duplicate xenon console IDs at the askdc
    BYTE CertificateHash[XONLINE_PPA_HASH_SIZE]; //20 bytes
    //passport auth
    DWORD PassportTicketLength;
    BYTE PassportTicket[XONLINE_MAX_TICKET_LENGTH];
    DWORD PassportSessionKeyLength;
    BYTE PassportSessionKey[64];
    ULONGLONG PcNonce;
    DWORD UsePcNonceKey;
};
#pragma pack(pop)

class KerbClientCrypt
{
public:
    KerbClientCrypt();

    int Initialize();

    bool EncryptWithXmacsTestKey(
        IN OUT BYTE* pbMsg,
        IN OUT DWORD* pcbMsg,
        IN DWORD cbBuffer
        );

    bool EncryptWithXmacsKey(
        IN OUT BYTE* pbMsg,
        IN OUT DWORD* pcbMsg,
        IN DWORD cbBuffer
        );

    bool SignWithConsoleKey(
        IN const BYTE* pbSha1,
        DWORD cbSha1,
        OUT BYTE* pbSignature,
        IN OUT DWORD* pcbSignature
        );

    bool SignConsoleCertificate(
        XE_CONSOLE_CERTIFICATE* pCert
        );

    bool SignWithMasterSigningKey(
        IN const BYTE* pbSha1,
        DWORD cbSha1,
        OUT BYTE* pbSignature,
        IN OUT DWORD* pcbSignature
        );

protected:
    bool bKeysInstalled;

    CXoCryptoCspPk _keyXmacsReal;
    CXoCryptoCspPk _keyXmacsTest;
    CXoCryptoCspPk _keyConsole;
    CXoCryptoCspPk _keyMasterSigning;


};

#pragma pack(push, 1)
struct XOKERBINFO
{
    BYTE            _abDhX[CBDHG1];         // Diffie-hellman X
    BYTE            _abDhGX[CBDHG1];        // Diffie-hellman g^X
    BYTE            _abKey[16];             // Session key from ticket
    DWORD           _dwTicketId;            // Ticket identifier
    UINT            _cbApReqMax;            // Maximum size of AP request
    DWORD           _dwUserPerm;            // User permutation and guest bits
};

struct XOTSKERBINFO
{
    BYTE            _abKey[16];             // Session key from ticket
    DWORD           _dwTicketId;            // Ticket identifier
    UINT            _cbApReqMax;            // Maximum size of AP request
    DWORD           _dwUserPerm;            // User permutation and guest bits
    ULONGLONG       _qwPuid;                // [TS] PUID of the client machine
    CAuthData2      _AuthData;              // [TS] authdata from client machine
    UINT            _uiSiteID;              // [TS] site ID from ticket
};

#pragma pack(pop)


#pragma pack(push, 4)

typedef struct XONLINE_RECENT_LOGON_TIME {
    ULONGLONG qwUserID;
    FILETIME lastLogon;
    DWORD  dwReserved[2];
} *PXONLINE_RECENT_LOGON_TIME;


typedef struct XKERB_TGT_CONTEXT
{
    // The following fields are used to index this entry in the cache
    ULONGLONG MachineID;
    ULONGLONG UserID[XONLINE_MAX_LOGON_USERS];
    TimeStamp StartTime;
    TimeStamp ExpirationTime;

    // The following fields are in memory only and not stored in the cache
    DWORD ctNumNonces;
    DWORD Nonce[MAX_KERB_RETRIES + MAX_TIME_ADJUSTMENTS];
    BYTE ClientKey[XONLINE_KEY_LENGTH];
    BYTE CompoundKey[XONLINE_KEY_LENGTH];
    DWORD cbEchoPreAuth;
    BYTE EchoPreAuth[XONLINE_MAX_ECHO_PREAUTH_LENGTH];
    OPTIONAL IN XKERB_TGT_CONTEXT* pInputTGTContext;
    OPTIONAL OUT PXKERB_PA_XBOX_ACCOUNT_CREATION pAccountCreationPreAuth;
    
    BOOL isPassportAuthInfoAvailable;
    struct PASSPORT_AUTH_INFO
    {
        UINT64  userId;
        CHAR    gamertag[XONLINE_GAMERTAG_SIZE];
    } passportAuthInfo;

    // The following fields are cached to disk
    CHAR ClientName[KERBEROS_MAX_PRINCIPLE_NAME_SIZE];
    CHAR ClientRealm[XONLINE_KERBEROSREALM_SIZE];
    CHAR TargetRealm[XONLINE_KERBEROSREALM_SIZE];
    DWORD dwReserved[8];
    BYTE SessionKey[XONLINE_KEY_LENGTH];
    BYTE RawKeySignature[XC_SERVICE_DIGEST_SIZE];
    DWORD dwTicketLength;
    BYTE Ticket[XONLINE_MAX_TICKET_LENGTH];

} *PXKERB_TGT_CONTEXT;

typedef struct XKERB_SERVICE_CONTEXT
{
    // The following fields are used to index this entry in the cache
    ULONGLONG MachineID;
    ULONGLONG UserID[XONLINE_MAX_LOGON_USERS];
    DWORD dwTitleID;
    DWORD  dwTitleVersion;
    DWORD dwNumServices;
    DWORD dwServiceID1[XONLINE_LEGACY_MAX_NUMBER_SERVICE];
    TimeStamp StartTime;
    TimeStamp ExpirationTime;

    // The following fields are in memory only and not stored in the cache
    DWORD ctNumNonces;
    DWORD Nonce[MAX_KERB_RETRIES + MAX_TIME_ADJUSTMENTS];
    TimeStamp AuthenticatorTime[MAX_KERB_RETRIES + MAX_TIME_ADJUSTMENTS];
    HRESULT hr;
    XOKERBINFO xoKerbInfo;

    // The following fields are cached to disk
    IN_ADDR siteIPAddress;
    DWORD dwBwLimit;
    DWORD dwReserved[RESERVED_DWORDS_IN_XBOX_PA];
    HRESULT hrUser[XONLINE_MAX_LOGON_USERS];
    DWORD  dwUserFlags[XONLINE_MAX_LOGON_USERS];
    HRESULT hrService1[XONLINE_LEGACY_MAX_NUMBER_SERVICE];
    WORD wServicePort1[XONLINE_LEGACY_MAX_NUMBER_SERVICE];
    CHAR ClientName[KERBEROS_MAX_PRINCIPLE_NAME_SIZE];
    CHAR ClientRealm[XONLINE_KERBEROSREALM_SIZE];
    CHAR ServiceRealm[XONLINE_KERBEROSREALM_SIZE];
    BYTE SessionKey[XONLINE_KEY_LENGTH];
    BYTE RawKeySignature[XC_SERVICE_DIGEST_SIZE];
    DWORD dwTicketLength;
    BYTE Ticket[XONLINE_MAX_TICKET_LENGTH];
} *PXKERB_SERVICE_CONTEXT;

//
// Same as XKERB_SERVICE_CONTEXT but used when dwNumServices > 12
// This is intentionally the same size as XKERB_SERVICE_CONTEXT.
//
typedef struct XKERB_SERVICE_CONTEXT2
{
    // The following fields are used to index this entry in the cache
    ULONGLONG MachineID;
    ULONGLONG UserID[XONLINE_MAX_LOGON_USERS];
    DWORD dwTitleID;
    DWORD  dwTitleVersion;
    DWORD dwNumServices;
    BYTE bServiceID2[XONLINE_MAX_SINGLE_BYTE_SERVICEIDS];
    DWORD dwReserved1[5]; // Size chosen to make sizeof(XKERB_SERVICE_CONTEXT) == sizeof(XKERB_SERVICE_CONTEXT2)
    DWORD dwServiceID2[XONLINE_MAX_DWORD_SERVICEIDS];
    TimeStamp StartTime;
    TimeStamp ExpirationTime;

    // The following fields are in memory only and not stored in the cache
    DWORD ctNumNonces;
    DWORD Nonce[MAX_KERB_RETRIES + MAX_TIME_ADJUSTMENTS];
    TimeStamp AuthenticatorTime[MAX_KERB_RETRIES + MAX_TIME_ADJUSTMENTS];
    HRESULT hr;
    XOKERBINFO xoKerbInfo;

    // The following fields are cached to disk
    IN_ADDR siteIPAddress;
    DWORD dwBwLimit;
    WORD wServicePort2[XONLINE_MAX_NUMBER_SERVICE]; // First 12 map to single byte services, last 4 map to DWORD services
    HRESULT hrUser[XONLINE_MAX_LOGON_USERS];
    DWORD  dwUserFlags[XONLINE_MAX_LOGON_USERS];
    HRESULT hrService2[XONLINE_MAX_NUMBER_SERVICE]; // First 12 map to single byte services, last 4 map to DWORD services
    DWORD dwReserved2[2]; // Size chosen to make sizeof(XKERB_SERVICE_CONTEXT) == sizeof(XKERB_SERVICE_CONTEXT2)
    CHAR ClientName[KERBEROS_MAX_PRINCIPLE_NAME_SIZE];
    CHAR ClientRealm[XONLINE_KERBEROSREALM_SIZE];
    CHAR ServiceRealm[XONLINE_KERBEROSREALM_SIZE];
    BYTE SessionKey[XONLINE_KEY_LENGTH];
    BYTE RawKeySignature[XC_SERVICE_DIGEST_SIZE];
    DWORD dwTicketLength;
    BYTE Ticket[XONLINE_MAX_TICKET_LENGTH];
} *PXKERB_SERVICE_CONTEXT2;

//
// Same as XKERB_SERVICE_CONTEXT but used when making and verifying a Xenon TGS request.
// This should not be used in any other code path.
// This is a larger size than XKERB_SERVICE_CONTEXT.  Extra stuff was only added to 
// the end of the packet.  Fields before this point should have identical offsets.
// The dwXenonFlag field was added to provide an extra measure of security, it will
// have a unique value set. If we expect a XKERB_SERVICE_CONTEXT_XE structure but the
// value of dwXenonFlag doesn't match XENON_SERVICE_CONTEXT_FLAG, then something has gone
// wrong. 
//
// IMPORTANT: This is only intended to be used for KDC server testing. DO NOT use
// this for any other purpose unless you really know what you're doing.
// -kgoodier November 2004
//
#define XENON_SERVICE_CONTEXT_FLAG  0x12345678
typedef struct XKERB_SERVICE_CONTEXT_XE
{
    // The following fields are used to index this entry in the cache
    ULONGLONG MachineID;
    ULONGLONG UserID[XONLINE_MAX_LOGON_USERS];
    DWORD dwTitleID;
    DWORD  dwTitleVersion;
    DWORD dwNumServices;
    // start 48 byte block, replaces bServiceID2, dwReserved1, and dwServiceID2
    BYTE bServiceID3[XONLINE_XE_MAX_BYTE_SERVICEIDS];  // the first 32 of them, the other 96 are later
    DWORD dwServiceID3[XONLINE_MAX_DWORD_SERVICEIDS];  // 4 of them
    // end 48 byte block
    TimeStamp StartTime;
    TimeStamp ExpirationTime;

    // The following fields are in memory only and not stored in the cache
    DWORD ctNumNonces;
    DWORD Nonce[MAX_KERB_RETRIES + MAX_TIME_ADJUSTMENTS];
    TimeStamp AuthenticatorTime[MAX_KERB_RETRIES + MAX_TIME_ADJUSTMENTS];
    HRESULT hr;
    XOKERBINFO xoKerbInfo;

    // The following fields are cached to disk
    IN_ADDR siteIPAddress;
    DWORD dwBwLimit;
    // start 32 byte block, replaces wServicePort2
    DWORD dwXenonFlag;  // set to XENON_SERVICE_CONTEXT_FLAG to indicate struct type, kind of a hack, but this struct IS larger than the others
    DWORD dwConsoleRegion;
    DWORD dwMediaID;
    WORD  wLanguageID;
    WORD  wAutoDiscoverServices;
    DWORD dwReserved3[4];  // size chosen to maintain field offsets
    // end 32 byte block
    HRESULT hrUser[XONLINE_MAX_LOGON_USERS];
    DWORD  dwUserFlags[XONLINE_MAX_LOGON_USERS];
    // start 72 byte block, replaces hrService2 and dwReserved2
    WORD wServicePortBytes3[XONLINE_XE_MAX_BYTE_SERVICEIDS]; // for the service id bytes (32)
    WORD wServicePortDwords3[XONLINE_MAX_DWORD_SERVICEIDS]; // for the service id dwords (4)
    // end 72 byte block
    CHAR ClientName[KERBEROS_MAX_PRINCIPLE_NAME_SIZE];
    CHAR ClientRealm[XONLINE_KERBEROSREALM_SIZE];
    CHAR ServiceRealm[XONLINE_KERBEROSREALM_SIZE];
    BYTE SessionKey[XONLINE_KEY_LENGTH];
    BYTE RawKeySignature[XC_SERVICE_DIGEST_SIZE];
    DWORD dwTicketLength;
    BYTE Ticket[XONLINE_MAX_TICKET_LENGTH];

    // New items, just couldn't squeeze them in above
    //
    HRESULT hrServiceBytes3[XONLINE_XE_MAX_BYTE_SERVICEIDS]; // for the service id bytes (the first 32, the other 96 are later)
    HRESULT hrServiceDwords3[XONLINE_MAX_DWORD_SERVICEIDS]; // for the service id dwords (4)
    DWORD dwUserPrivileges[XONLINE_MAX_LOGON_USERS][XONLINE_NUM_PRIVILEGE_DWORDS];  // 4*8*4 bytes
    // TODO: alternate title ids seem very iffy to me, and to Vance as well. these won't even be used in
    // the XeDecXDK. skip em for now.
    // Size of new items = 272 bytes

    // New items from M3 and XENON_SERVICE_ADDRESS2 structure
    //
    DWORD dwLiveTitleId;
    BYTE bAltServiceIds[XONLINE_MAX_LIVE_ALTERNATE_TITLE_ID];
    DWORD dwAltServiceTitleIds[XONLINE_MAX_LIVE_ALTERNATE_TITLE_ID];

    //new items from the xenon service request 5 preauth and authdata v4 changes
    BYTE    bServiceID4[XONLINE_XE_MAX_BYTE_SERVICEIDS_2-XONLINE_XE_MAX_BYTE_SERVICEIDS]; //the last 96 of them
    HRESULT hrServiceBytes4[XONLINE_XE_MAX_BYTE_SERVICEIDS_2-XONLINE_XE_MAX_BYTE_SERVICEIDS]; //the last 96 of them
    WORD wServicePortBytes4[XONLINE_XE_MAX_BYTE_SERVICEIDS_2-XONLINE_XE_MAX_BYTE_SERVICEIDS]; // the last 96 of them
    DWORD UserPins[XONLINE_MAX_LOGON_USERS];
    ULONGLONG FlowToken;
    DWORD ServiceAddressPreauthVersion;

    //new with service address failure
    FILETIME ConsoleBanExpireTime;
    FILETIME UserBanExpireTime[4];

    //clears services, services results, and service ports
    inline void ClearServices()
    {
        for (DWORD i=0; i<XONLINE_XE_MAX_BYTE_SERVICEIDS; ++i)
        {
            bServiceID3[i]=0;
            wServicePortBytes3[i]=0;
            hrServiceBytes3[i]=0;
        }

        for (DWORD i=0; i<XONLINE_XE_MAX_BYTE_SERVICEIDS_2-XONLINE_XE_MAX_BYTE_SERVICEIDS; ++i)
        {
            bServiceID4[i]=0;
            hrServiceBytes4[i]=0;
            wServicePortBytes4[i]=0;
        }

        for (DWORD i=0; i<XONLINE_MAX_DWORD_SERVICEIDS; ++i)
        {
            wServicePortDwords3[i]=0;
            hrServiceDwords3[i]=0;
        }
    }
} *PXKERB_SERVICE_CONTEXT_XE;


typedef struct _XONLINE_SERVICE_INFO{
    DWORD          dwServiceID;
    IN_ADDR        serviceIP;
    WORD           wServicePort;
    WORD           wReserved;
} XONLINE_SERVICE_INFO, *PXONLINE_SERVICE_INFO;

typedef struct SERVICE_CONTEXT
{
    XONLINE_SERVICE_INFO serviceInfo;
    HRESULT hr;
    XKERB_SERVICE_CONTEXT* pXKerbServiceContext;
} *PSERVICE_CONTEXT;

#pragma pack(pop)

// Keys and params structs for the ticketmodifier functions

struct CopyPuidsOutToTgtContext_Params
{
    XKERB_TGT_CONTEXT *pTgt;
    ULONGLONG *puidMachine;
    ULONGLONG *puidUsers;
};

struct AuthDataStruct_Params {
    BYTE *rgbAuthData;
    DWORD *pdwAuthDataSize;
    WORD *pwAuthDataVersion;
};

//
// Assume that FFF is a facility code that is not in use
//
#define HRFromKerberosError( KerbErr ) (0xAFFF0000 | (KerbErr))
#define IsKerberosError( hr ) ((0xFFFF0000 & (hr)) == 0xAFFF0000)
#define KerberosErrorFromHR( hr ) (0x0000FFFF & (hr))

typedef LONG KERBERR, *PKERBERR;

#define KDC_ERR_NONE                  ((KERBERR) 0x0 ) // 0 No error
#define KDC_ERR_NAME_EXP              ((KERBERR) 0x1 ) // 1 Client's entry in database has expired
#define KDC_ERR_SERVICE_EXP           ((KERBERR) 0x2 ) // 2 Server's entry in database has expired
#define KDC_ERR_BAD_PVNO              ((KERBERR) 0x3 ) // 3 Requested protocol version number not supported
#define KDC_ERR_C_OLD_MAST_KVNO       ((KERBERR) 0x4 ) // 4 Client's key encrypted in old master key
#define KDC_ERR_S_OLD_MAST_KVNO       ((KERBERR) 0x5 ) // 5 Server's key encrypted in old master key
#define KDC_ERR_C_PRINCIPAL_UNKNOWN   ((KERBERR) 0x6 ) // 6 Client not found in Kerberos database
#define KDC_ERR_S_PRINCIPAL_UNKNOWN   ((KERBERR) 0x7 ) // 7 Server not found in Kerberos database
#define KDC_ERR_PRINCIPAL_NOT_UNIQUE  ((KERBERR) 0x8 ) // 8 Multiple principal entries in database
#define KDC_ERR_NULL_KEY              ((KERBERR) 0x9 ) // 9 The client or server has a null key
#define KDC_ERR_CANNOT_POSTDATE       ((KERBERR) 0xA ) // 10 Ticket not eligible for postdating
#define KDC_ERR_NEVER_VALID           ((KERBERR) 0xB ) // 11 Requested start time is later than end time
#define KDC_ERR_POLICY                ((KERBERR) 0xC ) // 12 KDC policy rejects request
#define KDC_ERR_BADOPTION             ((KERBERR) 0xD ) // 13 KDC cannot accommodate requested option
#define KDC_ERR_ETYPE_NOTSUPP         ((KERBERR) 0xE ) // 14 KDC has no support for encryption type
#define KDC_ERR_SUMTYPE_NOSUPP        ((KERBERR) 0xF ) // 15 KDC has no support for checksum type
#define KDC_ERR_PADATA_TYPE_NOSUPP    ((KERBERR) 0x10 ) // 16 KDC has no support for padata type
#define KDC_ERR_TRTYPE_NO_SUPP        ((KERBERR) 0x11 ) // 17 KDC has no support for transited type
#define KDC_ERR_CLIENT_REVOKED        ((KERBERR) 0x12 ) // 18 Clients credentials have been revoked
#define KDC_ERR_SERVICE_REVOKED       ((KERBERR) 0x13 ) // 19 Credentials for server have been revoked
#define KDC_ERR_TGT_REVOKED           ((KERBERR) 0x14 ) // 20 TGT has been revoked
#define KDC_ERR_CLIENT_NOTYET         ((KERBERR) 0x15 ) // 21 Client not yet valid - try again later
#define KDC_ERR_SERVICE_NOTYET        ((KERBERR) 0x16 ) // 22 Server not yet valid - try again later
#define KDC_ERR_KEY_EXPIRED           ((KERBERR) 0x17 ) // 23 Password has expired - change password to reset
#define KDC_ERR_PREAUTH_FAILED        ((KERBERR) 0x18 ) // 24 Pre-authentication information was invalid
#define KDC_ERR_PREAUTH_REQUIRED      ((KERBERR) 0x19 ) // 25 Additional pre-authenticationrequired [40]
#define KDC_ERR_SERVER_NOMATCH        ((KERBERR) 0x1A ) // 26 Requested server and ticket don't match
#define KDC_ERR_MUST_USE_USER2USER    ((KERBERR) 0x1B ) // 27 Server principal valid for user2user only
#define KDC_ERR_PATH_NOT_ACCPETED     ((KERBERR) 0x1C ) // 28 KDC Policy rejects transited path
#define KDC_ERR_SVC_UNAVAILABLE       ((KERBERR) 0x1D ) // 29 A service is not available
#define KRB_AP_ERR_BAD_INTEGRITY      ((KERBERR) 0x1F ) // 31 Integrity check on decrypted field failed
#define KRB_AP_ERR_TKT_EXPIRED        ((KERBERR) 0x20 ) // 32 Ticket expired
#define KRB_AP_ERR_TKT_NYV            ((KERBERR) 0x21 ) // 33 Ticket not yet valid
#define KRB_AP_ERR_REPEAT             ((KERBERR) 0x22 ) // 34 Request is a replay
#define KRB_AP_ERR_NOT_US             ((KERBERR) 0x23 ) // 35 The ticket isn't for us
#define KRB_AP_ERR_BADMATCH           ((KERBERR) 0x24 ) // 36 Ticket and authenticator don't match
#define KRB_AP_ERR_SKEW               ((KERBERR) 0x25 ) // 37 Clock skew too great
#define KRB_AP_ERR_BADADDR            ((KERBERR) 0x26 ) // 38 Incorrect net address
#define KRB_AP_ERR_BADVERSION         ((KERBERR) 0x27 ) // 39 Protocol version mismatch
#define KRB_AP_ERR_MSG_TYPE           ((KERBERR) 0x28 ) // 40 Invalid msg type
#define KRB_AP_ERR_MODIFIED           ((KERBERR) 0x29 ) // 41 Message stream modified
#define KRB_AP_ERR_BADORDER           ((KERBERR) 0x2A ) // 42 Message out of order
#define KRB_AP_ERR_ILL_CR_TKT         ((KERBERR) 0x2B ) // 43 Illegal cross realm ticket
#define KRB_AP_ERR_BADKEYVER          ((KERBERR) 0x2C ) // 44 Specified version of key is not available
#define KRB_AP_ERR_NOKEY              ((KERBERR) 0x2D ) // 45 Service key not available
#define KRB_AP_ERR_MUT_FAIL           ((KERBERR) 0x2E ) // 46 Mutual authentication failed
#define KRB_AP_ERR_BADDIRECTION       ((KERBERR) 0x2F ) // 47 Incorrect message direction
#define KRB_AP_ERR_METHOD             ((KERBERR) 0x30 ) // 48 Alternative authentication method required
#define KRB_AP_ERR_BADSEQ             ((KERBERR) 0x31 ) // 49 Incorrect sequence number in message
#define KRB_AP_ERR_INAPP_CKSUM        ((KERBERR) 0x32 ) // 50 Inappropriate type of checksum in message
#define KRB_AP_PATH_NOT_ACCEPTED      ((KERBERR) 0x33 ) // 51 Policy rejects transited path
#define KRB_ERR_RESPONSE_TOO_BIG      ((KERBERR) 0x34 ) // 52 Response too big for UDP, retry with TCP
#define KRB_ERR_GENERIC               ((KERBERR) 0x3C ) // 60 Generic error (description in e-text)
#define KRB_ERR_FIELD_TOOLONG         ((KERBERR) 0x3D ) // 61 Field is too long for this implementation
#define KDC_ERR_CLIENT_NOT_TRUSTED    ((KERBERR) 0x3E ) // 62 (pkinit)
#define KDC_ERR_KDC_NOT_TRUSTED       ((KERBERR) 0x3F ) // 63 (pkinit)
#define KDC_ERR_INVALID_SIG           ((KERBERR) 0x40 ) // 64 (pkinit)
#define KDC_ERR_KEY_TOO_WEAK          ((KERBERR) 0x41 ) // 65 (pkinit)
#define KDC_ERR_CERTIFICATE_MISMATCH  ((KERBERR) 0x42 ) // 66 (pkinit)
#define KRB_AP_ERR_NO_TGT             ((KERBERR) 0x43 ) // 67 (user-to-user)
#define KDC_ERR_WRONG_REALM           ((KERBERR) 0x44 ) // 68 (user-to-user)
#define KRB_AP_ERR_USER_TO_USER_REQUIRED ((KERBERR) 0x45 ) // 69 (user-to-user)
#define KDC_ERR_CANT_VERIFY_CERTIFICATE ((KERBERR) 0x46 ) // 70 (pkinit)
#define KDC_ERR_INVALID_CERTIFICATE     ((KERBERR) 0x47 ) // 71 (pkinit)
#define KDC_ERR_REVOKED_CERTIFICATE     ((KERBERR) 0x48 ) // 72 (pkinit)
#define KDC_ERR_REVOCATION_STATUS_UNKNOWN ((KERBERR) 0x49 ) // 73 (pkinit)
#define KDC_ERR_REVOCATION_STATUS_UNAVAILABLE ((KERBERR) 0x4a ) // 74 (pkinit)
#define KDC_ERR_CLIENT_NAME_MISMATCH    ((KERBERR) 0x4b ) // 75 (pkinit)
#define KDC_ERR_KDC_NAME_MISMATCH       ((KERBERR) 0x4c ) // 76 (pkinit)

typedef struct _KERB_MESSAGE_BUFFER {
    DWORD BufferSize;
    BYTE* Buffer;
} KERB_MESSAGE_BUFFER, *PKERB_MESSAGE_BUFFER;

inline HRESULT KerbStatusToHresult(
    IN NTSTATUS Status)
{
    HRESULT hr = S_OK;

    if (!NT_SUCCESS(Status))
    {
        if (IsKerberosError(Status))
            hr = Status;
        else
            hr = HRESULT_FROM_NT(Status);
    }

    return hr;
}

NTSTATUS rc4HmacEncrypt(CScratchMemoryAllocator * pScratchMemoryAllocator, const UCHAR* pbKey, ULONG KeySize,
                        ULONG MessageType, PUCHAR pbInput, ULONG cbInput, PUCHAR pbOutput, PULONG pcbOutput);
NTSTATUS rc4HmacDecrypt(const UCHAR* pbKey, ULONG KeySize, ULONG MessageType, PUCHAR pbInput, ULONG cbInput,
                        PUCHAR pbOutput, PULONG pcbOutput);

void XcSHA(BYTE * pbSha, UINT cbSha, BYTE * pb1, UINT cb1, BYTE * pb2, UINT cb2, BYTE * pb3, UINT cb3);

#define _XNetLittleEndianUshort(x) (x)

#define _XNetNetworkEndianUlong(x) KerbConvertUlongToFlagUlong((x))

#define RC4_CONFOUNDER_LEN  8

typedef struct _RC4_MDx_HEADER {
    UCHAR Checksum[MD5_LEN];
    UCHAR Confounder[RC4_CONFOUNDER_LEN];
} RC4_MDx_HEADER, *PRC4_MDx_HEADER;


typedef KERB_HOST_ADDRESS *PKERB_HOST_ADDRESS;
typedef KERB_PRINCIPAL_NAME *PKERB_PRINCIPAL_NAME;
typedef KERB_REALM *PKERB_REALM;
typedef KERB_TIME *PKERB_TIME;
typedef KERB_ENCRYPTED_DATA *PKERB_ENCRYPTED_DATA;
typedef KERB_TICKET *PKERB_TICKET;
typedef KERB_TRANSITED_ENCODING *PKERB_TRANSITED_ENCODING;
typedef KERB_ENCRYPTION_KEY *PKERB_ENCRYPTION_KEY;
typedef KERB_ENCRYPTED_TICKET *PKERB_ENCRYPTED_TICKET;
typedef KERB_CHECKSUM *PKERB_CHECKSUM;
typedef KERB_AUTHENTICATOR *PKERB_AUTHENTICATOR;
typedef KERB_PA_DATA *PKERB_PA_DATA;
typedef KERB_KDC_REQUEST_BODY *PKERB_KDC_REQUEST_BODY;
typedef KERB_KDC_REQUEST *PKERB_KDC_REQUEST;
typedef KERB_AS_REQUEST *PKERB_AS_REQUEST;
typedef KERB_TGS_REQUEST *PKERB_TGS_REQUEST;
typedef KERB_KDC_REPLY *PKERB_KDC_REPLY;
typedef KERB_AS_REPLY *PKERB_AS_REPLY;
typedef KERB_TGS_REPLY *PKERB_TGS_REPLY;
typedef KERB_ENCRYPTED_KDC_REPLY *PKERB_ENCRYPTED_KDC_REPLY;
typedef KERB_ENCRYPTED_AS_REPLY *PKERB_ENCRYPTED_AS_REPLY;
typedef KERB_ENCRYPTED_TGS_REPLY *PKERB_ENCRYPTED_TGS_REPLY;
typedef KERB_AP_OPTIONS *PKERB_AP_OPTIONS;
typedef KERB_AP_REQUEST *PKERB_AP_REQUEST;
typedef KERB_AP_REPLY *PKERB_AP_REPLY;
typedef KERB_ENCRYPTED_AP_REPLY *PKERB_ENCRYPTED_AP_REPLY;
typedef KERB_SAFE_BODY *PKERB_SAFE_BODY;
typedef KERB_SAFE_MESSAGE *PKERB_SAFE_MESSAGE;
typedef KERB_PRIV_MESSAGE *PKERB_PRIV_MESSAGE;
typedef KERB_ENCRYPTED_PRIV *PKERB_ENCRYPTED_PRIV;
typedef KERB_ERROR *PKERB_ERROR;
typedef KERB_ERROR_METHOD_DATA *PKERB_ERROR_METHOD_DATA;
typedef struct PKERB_AUTHORIZATION_DATA_s KERB_AUTHORIZATION_DATA;
typedef struct PKERB_TICKET_EXTENSIONS_s KERB_TICKET_EXTENSIONS;
typedef KERB_CRED *PKERB_CRED;
typedef KERB_ENCRYPTED_CRED *PKERB_ENCRYPTED_CRED;
typedef KERB_CRED_INFO *PKERB_CRED_INFO;
typedef struct PKERB_LAST_REQUEST_s KERB_LAST_REQUEST;
typedef struct PKERB_HOST_ADDRESSES_s KERB_HOST_ADDRESSES;
typedef struct PKERB_ETYPE_INFO_s KERB_ETYPE_INFO;
typedef KERB_ETYPE_INFO_ENTRY * PKERB_ETYPE_INFO_ENTRY;
typedef KERB_ENCRYPTED_TIMESTAMP *PKERB_ENCRYPTED_TIMESTAMP;
typedef struct PKERB_PREAUTH_DATA_LIST_s KERB_PREAUTH_DATA_LIST, *PKERB_PREAUTH_DATA_LIST;
typedef KERB_TICKET_FLAGS *PKERB_TICKET_FLAGS;
typedef KERB_PA_PAC_REQUEST *PKERB_PA_PAC_REQUEST;

#ifndef MIDL_PASS

typedef struct KERB_PRINCIPAL_NAME_name_string_s KERB_PRINCIPAL_NAME_ELEM, *PKERB_PRINCIPAL_NAME_ELEM;
typedef struct KERB_KDC_REQUEST_BODY_encryption_type_s KERB_CRYPT_LIST, *PKERB_CRYPT_LIST;
typedef struct KERB_KDC_REQUEST_BODY_additional_tickets_s KERB_TICKET_LIST, *PKERB_TICKET_LIST;
typedef struct KERB_KDC_REQUEST_preauth_data_s KERB_PA_DATA_LIST, *PKERB_PA_DATA_LIST;
typedef struct KERB_KDC_REPLY_preauth_data_s KERB_REPLY_PA_DATA_LIST, *PKERB_REPLY_PA_DATA_LIST;
typedef struct KERB_CRED_tickets_s KERB_CRED_TICKET_LIST, *PKERB_CRED_TICKET_LIST;
typedef struct KERB_ENCRYPTED_CRED_ticket_info_s KERB_CRED_INFO_LIST, *PKERB_CRED_INFO_LIST;
typedef struct KERB_PA_PK_AS_REQ2_user_certs_s KERB_CERTIFICATE_LIST, *PKERB_CERTIFICATE_LIST;
typedef struct KERB_PA_PK_AS_REQ2_trusted_certifiers_s KERB_CERTIFIER_LIST, *PKERB_CERTIFIER_LIST;
typedef struct KERB_KDC_ISSUED_AUTH_DATA_elements_s KERB_KDC_AUTH_DATA_LIST, *PKERB_KDC_AUTH_DATA_LIST;

#endif // MIDL_PASS

typedef KERB_KDC_ISSUED_AUTH_DATA *PKERB_KDC_ISSUED_AUTH_DATA;
typedef struct PKERB_IF_RELEVANT_AUTH_DATA_ KERB_IF_RELEVANT_AUTH_DATA;
typedef KERB_DH_PARAMTER *PKERB_DH_PARAMTER;
typedef KERB_PA_PK_AS_REQ *PKERB_PA_PK_AS_REQ;
typedef KERB_PA_PK_AS_REQ2 *PKERB_PA_PK_AS_REQ2;
typedef KERB_SIGNED_AUTH_PACKAGE *PKERB_SIGNED_AUTH_PACKAGE;
typedef KERB_AUTH_PACKAGE *PKERB_AUTH_PACKAGE;
typedef KERB_PK_AUTHENTICATOR *PKERB_PK_AUTHENTICATOR;
typedef KERB_SIGNED_REPLY_KEY_PACKAGE *PKERB_SIGNED_REPLY_KEY_PACKAGE;
typedef struct ASN1objectidentifier_s KERB_OBJECT_ID, *PKERB_OBJECT_ID;
typedef KERB_REPLY_KEY_PACKAGE *PKERB_REPLY_KEY_PACKAGE;
typedef KERB_PA_PK_AS_REP *PKERB_PA_PK_AS_REP;
typedef KERB_PA_PK_AS_REP2 *PKERB_PA_PK_AS_REP2;
typedef KERB_CERTIFICATE *PKERB_CERTIFICATE;
typedef KERB_SIGNED_KDC_PUBLIC_VALUE *PKERB_SIGNED_KDC_PUBLIC_VALUE;
typedef KERB_SUBJECT_PUBLIC_KEY_INFO *PKERB_SUBJECT_PUBLIC_KEY_INFO;
typedef KERB_ALGORITHM_IDENTIFIER *PKERB_ALGORITHM_IDENTIFIER;
typedef KERB_SIGNATURE *PKERB_SIGNATURE;
typedef KERB_TGT_REPLY *PKERB_TGT_REPLY;
typedef KERB_TGT_REQUEST *PKERB_TGT_REQUEST;
typedef KERB_PA_SERV_REFERRAL *PKERB_PA_SERV_REFERRAL;
typedef KERB_CHANGE_PASSWORD_DATA *PKERB_CHANGE_PASSWORD_DATA;

#define                     KERB_KDC_OPTIONS_reserved 0x80000000
#define                     KERB_KDC_OPTIONS_forwardable 0x40000000
#define                     KERB_KDC_OPTIONS_forwarded 0x20000000
#define                     KERB_KDC_OPTIONS_proxiable 0x10000000
#define                     KERB_KDC_OPTIONS_proxy 0x08000000
#define                     KERB_KDC_OPTIONS_postdated 0x02000000
#define                     KERB_KDC_OPTIONS_allow_postdate 0x04000000
#define                     KERB_KDC_OPTIONS_unused7 0x01000000
#define                     KERB_KDC_OPTIONS_renewable 0x00800000
#define                     KERB_KDC_OPTIONS_unused9 0x00400000
#define                     KERB_KDC_OPTIONS_name_canonicalize 0x00010000
#define                     KERB_KDC_OPTIONS_renewable_ok 0x00000010
#define                     KERB_KDC_OPTIONS_enc_tkt_in_skey 0x00000008
#define                     KERB_KDC_OPTIONS_renew 0x00000002
#define                     KERB_KDC_OPTIONS_validate 0x00000001

#define                     KERB_AP_OPTIONS_reserved 0x80000000
#define                     KERB_AP_OPTIONS_use_session_key 0x40000000
#define                     KERB_AP_OPTIONS_mutual_required 0x20000000
#define                     KERB_AP_OPTIONS_reserved1 0x00000001

//
// these #define's are done for the conversion from the old oss compiler to the
// new telis compiler.
//
#define KERB_AUTHENTICATOR_sequence_number                      sequence_number
#define KERB_ENCRYPTED_TICKET_client_addresses                  client_addresses
#define KERB_ENCRYPTED_TICKET_renew_until                       renew_until
#define KERB_CRED_INFO_renew_until                              renew_until
#define KERB_KDC_REQUEST_BODY_renew_until                       renew_until
#define KERB_KDC_REQUEST_BODY_server_name                       server_name
#define KERB_KDC_REQUEST_preauth_data                           preauth_data
#define KERB_AUTHENTICATOR_sequence_number                      sequence_number
#define KERB_ENCRYPTED_AP_REPLY_sequence_number                 sequence_number
#define KERB_AUTHENTICATOR_subkey                               subkey
#define KERB_ENCRYPTED_AP_REPLY_subkey                          subkey
#define KERB_TGT_REQUEST_server_name                            server_name
#define KERB_ERROR_client_name                                  client_name
#define KERB_ENCRYPTED_TIMESTAMP_usec                           usec
#define KERB_KDC_REQUEST_BODY_client_name                       client_name
#define KERB_KDC_REPLY_preauth_data                             preauth_data
#define KERB_ENCRYPTED_TIMESTAMP_usec                           usec
#define KERB_ENCRYPTED_KDC_REPLY_starttime                      starttime
#define KERB_CRED_INFO_starttime                                starttime
#define KERB_ENCRYPTED_KDC_REPLY_renew_until                    renew_until
#define KERB_ENCRYPTED_TICKET_authorization_data                authorization_data
#define KERB_ENCRYPTED_TICKET_starttime                         starttime
#define KERB_ENCRYPTED_PRIV_sequence_number                     sequence_number
#define KERB_KDC_REQUEST_BODY_starttime                         starttime
#define KERB_ENCRYPTED_KDC_REPLY_client_addresses               client_addresses

//
// Message types
//

#define KRB_AS_REQ      10      // Request for initial authentication
#define KRB_AS_REP      11      // Response to  KRB_AS_REQ request
#define KRB_TGS_REQ     12      // Request for authentication based on TGT
#define KRB_TGS_REP     13      // Response to KRB_TGS_REQ request
#define KRB_AP_REQ      14      // application request to server
#define KRB_AP_REP      15      // Response to KRB_AP_REQ_MUTUAL
#define KRB_TGT_REQ     16      // Request for TGT for user-to-user
#define KRB_TGT_REP     17      // Reply to TGT request
#define KRB_SAFE        20      // Safe (checksummed) application message
#define KRB_PRIV        21      // Private (encrypted) application message
#define KRB_CRED        22      // Private (encrypted) message to forward
                                // credentials
#define KRB_ERROR       30      // Error response

//
// Name types
//

#define KRB_NT_UNKNOWN   0                // Name type not known
#define KRB_NT_PRINCIPAL 1                // Just the name of the principal as in DCE, or for users
#define KRB_NT_PRINCIPAL_AND_ID -131      // Name of the principal and its SID.
#define KRB_NT_SRV_INST  2                // Service and other unique instance (krbtgt)
#define KRB_NT_SRV_INST_AND_ID -132       // SPN and SID
#define KRB_NT_SRV_HST   3                // Service with host name as instance (telnet, rcommands)
#define KRB_NT_SRV_XHST  4                // Service with host as remaining components
#define KRB_NT_UID       5                // Unique ID
#define KRB_NT_ENTERPRISE_PRINCIPAL 10    // UPN or SPN
#define KRB_NT_ENT_PRINCIPAL_AND_ID -130  // UPN and SID

//
// MS extensions, negative according to the RFC
//

#define KRB_NT_MS_PRINCIPAL         -128        // NT4 style name

#define KRB_NT_MS_PRINCIPAL_AND_ID  -129        // nt4 style name with sid

#define KERB_IS_MS_PRINCIPAL(_x_) (((_x_) <= KRB_NT_MS_PRINCIPAL) || ((_x_) >= KRB_NT_ENTERPRISE_PRINCIPAL))

//
// Pre-auth data types
//
#define KRB5_PADATA_NONE                0
#define KRB5_PADATA_AP_REQ              1
#define KRB5_PADATA_TGS_REQ             KRB5_PADATA_AP_REQ
#define KRB5_PADATA_ENC_TIMESTAMP       2
#define KRB5_PADATA_PW_SALT             3
#define KRB5_PADATA_ENC_UNIX_TIME       5  /* timestamp encrypted in key */
#define KRB5_PADATA_ENC_SANDIA_SECURID  6  /* SecurId passcode */
#define KRB5_PADATA_SESAME              7  /* Sesame project */
#define KRB5_PADATA_OSF_DCE             8  /* OSF DCE */
#define KRB5_CYBERSAFE_SECUREID         9  /* Cybersafe */
#define KRB5_PADATA_AFS3_SALT           10 /* Cygnus */
#define KRB5_PADATA_ETYPE_INFO          11 /* Etype info for preauth */
#define KRB5_PADATA_SAM_CHALLENGE       12 /* draft challenge system */
#define KRB5_PADATA_SAM_RESPONSE        13 /* draft challenge system response */
#define KRB5_PADATA_PK_AS_REQ           14 /* pkinit */
#define KRB5_PADATA_PK_AS_REP           15 /* pkinit */
#define KRB5_PADATA_PK_AS_SIGN          16 /* pkinit */
#define KRB5_PADATA_PK_KEY_REQ          17 /* pkinit */
#define KRB5_PADATA_PK_KEY_REP          18 /* pkinit */
#define KRB5_PADATA_REFERRAL_INFO       20 /* referral names for canonicalization */
#define KRB5_PADATA_PAC_REQUEST         128 /* allow client do request or ignore PAC */
#define KRB5_PADATA_S4U                 129 /* S4U */
#define KRB5_PADATA_COMPOUND_IDENTITY   130 /* authenticate multiple identities */
#define KRB5_PADATA_PAC_REQUEST_EX      131 /* allow client do request, ignore PAC or specify what sections */
#define KRB5_PADATA_CLIENT_VERSION      132 /* allow client do report version info */

//
// PAC type for PASSPORT PUID
//
#define PAC_CLIENT_IDENTITY             13
#define PAC_COMPOUND_IDENTITY           14
#define PAC_PASSPORT_PUIDS              20

//
// Authorization data types
//
#define KERB_AUTH_OSF_DCE               64
#define KERB_AUTH_SESAME                65

//
// NT authorization data type definitions
//

#define KERB_AUTH_DATA_PAC              128     // entry id for a PAC in authorization data

#define KERB_AUTH_DATA_IF_RELEVANT      1       // entry id for optional auth data
#define KERB_AUTH_DATA_KDC_ISSUED       4       // entry id for data generated & signed by KDC

//
// KDC service principal
//
#define KDC_PRINCIPAL_NAME              "krbtgt"
#define KERB_HOST_STRING                "host"
#define SECURITY_GATEWAY_STRING         "sg"

//
// SALT flags for encryption, from rfc1510 update 3des enctype
//

#define KERB_ENC_TIMESTAMP_SALT         1
#define KERB_TICKET_SALT                2
#define KERB_AS_REP_SALT                3
#define KERB_TGS_REQ_SESSKEY_SALT       4
#define KERB_TGS_REQ_SUBKEY_SALT        5
#define KERB_TGS_REQ_AP_REQ_AUTH_CKSUM_SALT     6
#define KERB_TGS_REQ_AP_REQ_AUTH_SALT   7
#define KERB_TGS_REP_SALT               8
#define KERB_TGS_REP_SUBKEY_SALT        9
#define KERB_AP_REQ_AUTH_CKSUM_SALT     10
#define KERB_AP_REQ_AUTH_SALT           11
#define KERB_AP_REP_SALT                12
#define KERB_PRIV_SALT                  13
#define KERB_CRED_SALT                  14
#define KERB_SAFE_SALT                  15
#define KERB_NON_KERB_SALT              16
#define KERB_NON_KERB_CKSUM_SALT        17
#define KERB_KERB_ERROR_SALT            18
#define KERB_KDC_ISSUED_CKSUM_SALT      19
#define KERB_MANDATORY_TKT_EXT_CKSUM_SALT       20
#define KERB_AUTH_DATA_TKT_EXT_CKSUM_SALT       21
#define KERB_PA_COMPOUND_IDENTITY_SALT  1024

//
//Types for AP error data
//

#define KERB_AP_ERR_TYPE_NTSTATUS             1
#define KERB_AP_ERR_TYPE_SKEW_RECOVERY        2

// Revision of the Kerberos Protocol.  MS uses Version 5, Revision 6
#define KERBEROS_VERSION    5
#define KERBEROS_REVISION   6

// Encryption Types:
// These encryption types are supported by the default MS KERBSUPP DLL
// as crypto systems.  Values over 127 are local values, and may be changed
// without notice.

#define KERB_ETYPE_NULL             0
#define KERB_ETYPE_DES_CBC_CRC      1
#define KERB_ETYPE_DES_CBC_MD4      2
#define KERB_ETYPE_DES_CBC_MD5      3

#define KERB_ETYPE_OLD_RC4_MD4          128
#define KERB_ETYPE_OLD_RC4_PLAIN        129
#define KERB_ETYPE_OLD_RC4_LM           130
#define KERB_ETYPE_OLD_RC4_SHA          131
#define KERB_ETYPE_OLD_DES_PLAIN        132

#define KERB_ETYPE_RC4_MD4          -128
#define KERB_ETYPE_RC4_PLAIN2       -129
#define KERB_ETYPE_RC4_LM           -130
#define KERB_ETYPE_RC4_SHA          -131
#define KERB_ETYPE_DES_PLAIN        -132
#define KERB_ETYPE_RC4_HMAC_OLD     -133
#define KERB_ETYPE_RC4_PLAIN_OLD    -134
#define KERB_ETYPE_RC4_HMAC_OLD_EXP -135
#define KERB_ETYPE_RC4_PLAIN_OLD_EXP -136
#define KERB_ETYPE_RC4_PLAIN        -140
#define KERB_ETYPE_RC4_PLAIN_EXP    -141

//
// In use types
//
#define KERB_ETYPE_DES_CBC_MD5_NT                          20
#define KERB_ETYPE_RC4_HMAC_NT                             23
#define KERB_ETYPE_RC4_HMAC_NT_EXP                         24

// Checksum algorithms.
// These algorithms are keyed internally for our use.

#define KERB_CHECKSUM_NONE  0
#define KERB_CHECKSUM_CRC32         1
#define KERB_CHECKSUM_MD4           2
#define KERB_CHECKSUM_KRB_DES_MAC   4
#define KERB_CHECKSUM_MD5           7
#define KERB_CHECKSUM_MD5_DES       8


#define KERB_CHECKSUM_LM            -130
#define KERB_CHECKSUM_SHA1          -131
#define KERB_CHECKSUM_REAL_CRC32    -132
#define KERB_CHECKSUM_DES_MAC       -133
#define KERB_CHECKSUM_DES_MAC_MD5   -134
#define KERB_CHECKSUM_MD25          -135
#define KERB_CHECKSUM_RC4_MD5       -136
#define KERB_CHECKSUM_MD5_HMAC      -137                // used by netlogon
#define KERB_CHECKSUM_HMAC_MD5      -138                // used by Kerberos

#define AUTH_REQ_ALLOW_FORWARDABLE      0x00000001
#define AUTH_REQ_ALLOW_PROXIABLE        0x00000002
#define AUTH_REQ_ALLOW_POSTDATE         0x00000004
#define AUTH_REQ_ALLOW_RENEWABLE        0x00000008
#define AUTH_REQ_ALLOW_NOADDRESS        0x00000010
#define AUTH_REQ_ALLOW_ENC_TKT_IN_SKEY  0x00000020
#define AUTH_REQ_ALLOW_VALIDATE         0x00000040
#define AUTH_REQ_VALIDATE_CLIENT        0x00000080
#define AUTH_REQ_OK_AS_DELEGATE         0x00000100
#define AUTH_REQ_PREAUTH_REQUIRED       0x00000200


//
// Ticket Flags:
//
#define KERB_TICKET_FLAGS_reserved          0x80000000
#define KERB_TICKET_FLAGS_forwardable       0x40000000
#define KERB_TICKET_FLAGS_forwarded         0x20000000
#define KERB_TICKET_FLAGS_proxiable         0x10000000
#define KERB_TICKET_FLAGS_proxy             0x08000000
#define KERB_TICKET_FLAGS_may_postdate      0x04000000
#define KERB_TICKET_FLAGS_postdated         0x02000000
#define KERB_TICKET_FLAGS_invalid           0x01000000
#define KERB_TICKET_FLAGS_renewable         0x00800000
#define KERB_TICKET_FLAGS_initial           0x00400000
#define KERB_TICKET_FLAGS_pre_authent       0x00200000
#define KERB_TICKET_FLAGS_hw_authent        0x00100000
#define KERB_TICKET_FLAGS_ok_as_delegate    0x00040000
#define KERB_TICKET_FLAGS_name_canonicalize 0x00010000
#define KERB_TICKET_FLAGS_reserved1         0x00000001

//
// Useful globals
//

extern TimeStamp g_KerbGlobalWillNeverTime;

//
// From kerberr.h
//

#define KERB_SUCCESS(_kerberr_) ((KERBERR)(_kerberr_) == KDC_ERR_NONE)

// These are the error codes as defined by the Kerberos V5 R5.2
// spec, section 8.3

#define KDC_ERR_MORE_DATA             ((KERBERR) 0x80000001 )

//
// Default flags for use in ticket requests
//
#define KERB_DEFAULT_TICKET_FLAGS ( KERB_KDC_OPTIONS_name_canonicalize )

//
//  Following macro is used to initialize UNICODE strings
//
#define CONSTANT_UNICODE_STRING(s)   { sizeof( s ) - sizeof( WCHAR ), sizeof( s ), s }
#define NULL_UNICODE_STRING {0 , 0, NULL }
#define EMPTY_UNICODE_STRING(s) { (s)->Buffer = NULL; (s)->Length = 0; (s)->MaximumLength = 0; }

#define KerbSetTime(_d_, _s_) (_d_)->QuadPart = (_s_)

#define KerbAddOffsetToTime(_d_, _offset_) (_d_)->QuadPart += (_offset_)

#define KerbGetOffsetBetweenTime(_d_, _s_) ((_s_)->QuadPart - (_d_)->QuadPart)

#define KerbGetTime(_x_) ((_x_).QuadPart)

#define KerbSetTimeInMinutes(_x_, _m_) (_x_)->QuadPart = (LONGLONG) 10000000 * 60 * (_m_)

#define KerbMapKerbNtStatusToNtStatus(x) (x)


//////////////////////////////////////////////////////////////////////////
//
// Structures
//
//////////////////////////////////////////////////////////////////////////

typedef struct _KERB_PREAUTH_DATA {
    ULONG Flags;
} KERB_PREAUTH_DATA, *PKERB_PREAUTH_DATA;

//
// KDC-Kerberos interaction
//

#define KERB_DEFAULT_AP_REQ_CSUM        KERB_CHECKSUM_MD5

#define KerbFreeData(a,b)

VOID
KerbCreateKeyFromBuffer(
    OUT PKERB_ENCRYPTION_KEY NewKey,
    IN PUCHAR Buffer,
    IN ULONG BufferSize,
    IN ULONG EncryptionType
    );

KERBERR NTAPI
KerbCreateAuthenticator(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN const KERB_ENCRYPTION_KEY* pkKey,
    IN ULONG EncryptionType,
    IN ULONG SequenceNumber,
    IN LPSTR ClientName,
    IN LPSTR ClientRealm,
    IN PTimeStamp ptsTime,
    IN OPTIONAL const KERB_CHECKSUM* Checksum,
    IN BOOLEAN KdcRequest,
    OUT PKERB_ENCRYPTED_DATA Authenticator
    );

KERBERR NTAPI
KerbUnpackKdcReplyBody(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PKERB_ENCRYPTED_DATA EncryptedReplyBody,
    IN PKERB_ENCRYPTION_KEY Key,
    IN ULONG Pdu,
    OUT PKERB_ENCRYPTED_KDC_REPLY * ReplyBody
    );

KERBERR NTAPI
KerbPackData(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PVOID Data,
    IN ULONG PduValue,
    OUT PULONG DataSize,
    OUT PUCHAR * MarshalledData
    );

KERBERR NTAPI
KerbUnpackData(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PUCHAR Data,
    IN ULONG DataSize,
    IN ULONG PduValue,
    OUT PVOID * DecodedData
    );

#define KerbUnpackAsReply( pScratchMemoryAllocator, ReplyMessage, ReplySize, Reply ) \
    KerbUnpackData( \
        (pScratchMemoryAllocator), \
        (ReplyMessage), \
        (ReplySize), \
        KERB_AS_REPLY_PDU, \
        (PVOID *) (Reply) \
        )

#define KerbFreeAsReply( Request)

#define KerbUnpackTgsReply( pScratchMemoryAllocator, ReplyMessage, ReplySize, Reply ) \
    KerbUnpackData( \
        (pScratchMemoryAllocator), \
        (ReplyMessage), \
        (ReplySize), \
        KERB_TGS_REPLY_PDU, \
        (PVOID *) (Reply) \
        )

#define KerbFreeTgsReply( Request)

#define KerbFreeKdcReplyBody( Request)

#define KerbPackAsRequest( pScratchMemoryAllocator, RequestMessage, RequestSize, MarshalledRequest )\
    KerbPackData( \
        (pScratchMemoryAllocator), \
        (PVOID) (RequestMessage), \
        KERB_AS_REQUEST_PDU, \
        (RequestSize), \
        (MarshalledRequest) \
        )

#define KerbFreeAsRequest( Request)

#define KerbPackTgsRequest( pScratchMemoryAllocator, RequestMessage, RequestSize, MarshalledRequest )\
    KerbPackData( \
        (pScratchMemoryAllocator), \
        (PVOID) (RequestMessage), \
        KERB_TGS_REQUEST_PDU, \
        (RequestSize), \
        (MarshalledRequest) \
        )

#define KerbFreeTgsRequest( Request)

#define KerbPackEncryptedData( pScratchMemoryAllocator, EncryptedData, DataSize, MarshalledData ) \
    KerbPackData( \
        (pScratchMemoryAllocator), \
        (PVOID) (EncryptedData), \
        KERB_ENCRYPTED_DATA_PDU, \
        (DataSize), \
        (PUCHAR *) (MarshalledData) \
        )

#define KerbUnpackEncryptedData( pScratchMemoryAllocator, EncryptedData,DataSize,Data ) \
    KerbUnpackData( \
        (pScratchMemoryAllocator), \
        (EncryptedData), \
        (DataSize), \
        KERB_ENCRYPTED_DATA_PDU, \
        (PVOID *) (Data) \
        )

#define KerbFreeEncryptedData( EncryptedData)

#define KerbPackApRequest( pScratchMemoryAllocator, ApRequestMessage, ApRequestSize, MarshalledApRequest ) \
    KerbPackData( \
        (pScratchMemoryAllocator), \
        (PVOID) (ApRequestMessage), \
        KERB_AP_REQUEST_PDU, \
        (ApRequestSize), \
        (MarshalledApRequest) \
        )

#define KerbUnpackApRequest( pScratchMemoryAllocator, ApRequestMessage,ApRequestSize, ApRequest) \
    KerbUnpackData( \
        (pScratchMemoryAllocator), \
        (ApRequestMessage), \
        (ApRequestSize), \
        KERB_AP_REQUEST_PDU, \
        (PVOID *) (ApRequest) \
        )

#define KerbPackApReply( pScratchMemoryAllocator, ApReplyMessage, ApReplySize, MarshalledApReply ) \
    KerbPackData( \
        (pScratchMemoryAllocator), \
        (PVOID) (ApReplyMessage), \
        KERB_AP_REPLY_PDU, \
        (ApReplySize), \
        (MarshalledApReply) \
        )

#define KerbUnpackApReply( pScratchMemoryAllocator, ApReplyMessage,ApReplySize, ApReply) \
    KerbUnpackData( \
        (pScratchMemoryAllocator), \
        (ApReplyMessage), \
        (ApReplySize), \
        KERB_AP_REPLY_PDU, \
        (PVOID *) (ApReply) \
        )

#define KerbFreeApReply( Reply)

#define KerbPackApReplyBody( pScratchMemoryAllocator, ApReplyBodyMessage, ApReplyBodySize, MarshalledApReplyBody ) \
    KerbPackData( \
        (pScratchMemoryAllocator), \
        (PVOID) (ApReplyBodyMessage), \
        KERB_ENCRYPTED_AP_REPLY_PDU, \
        (ApReplyBodySize), \
        (MarshalledApReplyBody) \
        )

#define KerbUnpackApReplyBody( pScratchMemoryAllocator, ApReplyBodyMessage,ApReplyBodySize, ApReplyBody) \
    KerbUnpackData( \
        (pScratchMemoryAllocator), \
        (ApReplyBodyMessage), \
        (ApReplyBodySize), \
        KERB_ENCRYPTED_AP_REPLY_PDU, \
        (PVOID *) (ApReplyBody) \
        )

#define KerbFreeApReplyBody( ReplyBody)

#define KerbPackEncryptedCred( pScratchMemoryAllocator, EncryptedCred, CredSize, MarshalledCred ) \
    KerbPackData( \
        (pScratchMemoryAllocator), \
        (PVOID) (EncryptedCred), \
        KERB_ENCRYPTED_CRED_PDU, \
        (CredSize), \
        (MarshalledCred) \
        )

#define KerbUnpackEncryptedCred( pScratchMemoryAllocator, EncryptedCred,CredSize,Cred ) \
    KerbUnpackData( \
        (pScratchMemoryAllocator), \
        (EncryptedCred), \
        (CredSize), \
        KERB_ENCRYPTED_CRED_PDU, \
        (PVOID *) (Cred) \
        )

#define KerbFreeEncryptedCred( EncryptedCred)

#define KerbPackKerbCred( pScratchMemoryAllocator, KerbCred, KerbCredSize, MarshalledKerbCred ) \
    KerbPackData( \
        (pScratchMemoryAllocator), \
        (PVOID) (KerbCred), \
        KERB_CRED_PDU, \
        (KerbCredSize), \
        (MarshalledKerbCred) \
        )

#define KerbUnpackKerbCred( pScratchMemoryAllocator, MarshalledKerbCred,KerbCredSize,KerbCred ) \
    KerbUnpackData( \
        (pScratchMemoryAllocator), \
        (MarshalledKerbCred), \
        (KerbCredSize), \
        KERB_CRED_PDU, \
        (PVOID *) (KerbCred) \
        )

#define KerbFreeKerbCred( KerbCred) \
    KerbFreeData( \
        KERB_CRED_PDU, \
        (PVOID) (KerbCred) \
        )

#define KerbPackKerbError( pScratchMemoryAllocator, ErrorMessage, ErrorSize, MarshalledError ) \
    KerbPackData( \
        (pScratchMemoryAllocator), \
        (PVOID) (ErrorMessage), \
        KERB_ERROR_PDU, \
        (ErrorSize), \
        (MarshalledError) \
        )

#define KerbUnpackKerbError( pScratchMemoryAllocator, ErrorMessage, ErrorSize, Error ) \
    KerbUnpackData( \
        (pScratchMemoryAllocator), \
        (ErrorMessage), \
        (ErrorSize), \
        KERB_ERROR_PDU, \
        (PVOID *) (Error) \
        )

#define KerbFreeKerbError( Error )

#define KerbPackEncryptedTime( pScratchMemoryAllocator, EncryptedTimeMessage, EncryptedTimeSize, MarshalledEncryptedTime ) \
    KerbPackData( \
        (pScratchMemoryAllocator), \
        (PVOID) (EncryptedTimeMessage), \
        KERB_ENCRYPTED_TIMESTAMP_PDU, \
        (EncryptedTimeSize), \
        (MarshalledEncryptedTime) \
        )

#define KerbUnpackEncryptedTime( pScratchMemoryAllocator, EncryptedTimeMessage, EncryptedTimeSize, EncryptedTime ) \
    KerbUnpackData( \
        (pScratchMemoryAllocator), \
        (EncryptedTimeMessage), \
        (EncryptedTimeSize), \
        KERB_ENCRYPTED_TIMESTAMP_PDU, \
        (PVOID *) (EncryptedTime) \
        )

#define KerbFreeEncryptedTime( EncryptedTime )

KERBERR NTAPI
KerbEncryptDataEx(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    OUT PKERB_ENCRYPTED_DATA EncryptedData,
    IN ULONG DataSize,
    IN PUCHAR Data,
    IN ULONG Algorithm,
    IN ULONG UsageFlags,
    IN const KERB_ENCRYPTION_KEY* Key
    );

KERBERR NTAPI
KerbDecryptDataEx(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PKERB_ENCRYPTED_DATA EncryptedData,
    IN PKERB_ENCRYPTION_KEY pkKey,
    IN ULONG UsageFlags,
    OUT PULONG DataSize,
    OUT PUCHAR Data
    );

__forceinline ULONG
KerbGetEncryptionOverhead()
{
    return sizeof(RC4_MDx_HEADER);
}

KERBERR
KerbConstructPrincipalName(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    OUT PKERB_PRINCIPAL_NAME PrincipalName,
    IN ULONG NameType,
    IN LPSTR pComp1,
    IN LPSTR pComp2 = NULL
    );

KERBERR
KerbMultiStringToPrincipalName(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN LPSTR pMultiString,
    OUT PKERB_PRINCIPAL_NAME PrincipalName
    );

KERBERR
KerbPrincipalNameToMultiString(
    IN PKERB_PRINCIPAL_NAME PrincipalName,
    IN DWORD dwMultiStringMaxLength,
    OUT LPSTR pMultiString
    );

VOID
KerbConvertLargeIntToGeneralizedTime(
    OUT PKERB_TIME ClientTime,
    OUT OPTIONAL LONG* ClientUsec,
    IN PTimeStamp TimeStamp
    );

VOID
KerbConvertGeneralizedTimeToLargeInt(
    OUT PTimeStamp TimeStamp,
    IN PKERB_TIME ClientTime,
    IN int ClientUsec
    );

PKERB_PA_DATA
KerbFindPreAuthDataEntry(
    IN ULONG EntryId,
    IN PKERB_PA_DATA_LIST AuthData
    );

KERBERR
KerbCreateApRequest(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN LPSTR ClientName,
    IN LPSTR ClientRealm,
    IN const KERB_ENCRYPTION_KEY* SessionKey,
    IN ULONG Nonce,
    IN PTimeStamp pAuthenticatorTime,
    IN const KERB_TICKET* ServiceTicket,
    IN ULONG ApOptions,
    IN OPTIONAL const KERB_CHECKSUM* Checksum,
    IN BOOLEAN KdcRequest,
    OUT PULONG RequestSize,
    OUT PUCHAR * Request
    );

__forceinline NTSTATUS
KerbMapKerbError(
    IN KERBERR KerbError
    )
{
    return HRFromKerberosError(KerbError);
}

ULONG
KerbConvertUlongToFlagUlong(
    IN ULONG Flag
    );

VOID
KerbGetCurrentTime(
    OUT PTimeStamp pCurrentTime
    );

VOID
KerbUpdateCurrentTime(
    IN TimeStamp NewCurrentTime
    );

BOOLEAN
md5Hmac(
    IN const BYTE* pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN const BYTE* pbData,
    IN ULONG cbData,
    IN const BYTE* pbData2,
    IN ULONG cbData2,
    OUT PBYTE HmacData
    );


//
// DLL Exports
//

//
// XMACS
//

HRESULT WINAPI 
kcl_BuildXboxMachineRequest(
    IN const TitleInfo* pTitleInfo,
    IN XONLINEP_USER *pusr,
    IN const DWORD *pPreauthTypeList,
    IN DWORD PreauthTypeListLength,
    OUT BYTE *pb,
    IN OUT ULONG *cb,
    OUT XKERB_TGT_CONTEXT *ptgt);

NTSTATUS WINAPI
kcl_BuildXenonMachineRequest(
    IN XE_CONSOLE_CERTIFICATE *pConsoleCert,  // OK to pass in a pointer to old CONSOLE_CERTIFICATE
    IN BOOL bSignConsoleCert,
    IN BOOL bUseTestXmacsKey,
    IN const TitleInfo* pInfo,
    IN PXONLINEP_USER pUser,
    IN const DWORD *pPreauthTypeList,
    IN DWORD PreauthTypeListLength,
    OUT PUCHAR pbRequestMessage,
    IN OUT PULONG pdwRequestMessageLength,
    IN OUT PXKERB_TGT_CONTEXT pTGTContext);

HRESULT WINAPI 
kcl_VerifyMachineReply(
    IN BYTE *pb,
    IN ULONG cb,
    IN OUT XKERB_TGT_CONTEXT *ptgt,
    OUT XONLINEP_USER *pusr);

//
// ASKDC
//

HRESULT WINAPI 
kcl_BuildAsRequest(
    IN const TitleInfo* pTitleInfo,
    IN const AsRequestInfo* pAsRequestInfo,
    IN DWORD cbAsRequestInfo,
    IN BOOL fMachineAccount,
    IN XONLINEP_USER *pUser,
    IN DWORD *pPreauthTypeList,
    IN DWORD PreauthTypeListLength,
    IN BYTE *pEchoPreauthBytes,
    IN DWORD cbEchoPreauthBytes,
    OUT BYTE *pbRequestMessage,
    IN OUT ULONG *pcbRequestMessageLength,
    IN OUT XKERB_TGT_CONTEXT *pTGTContext,
    IN XKERB_TGT_CONTEXT *pInputTGTContext);

// not currently exported..
NTSTATUS WINAPI
XkerbBuildAsRequest(
    IN const TitleInfo* pInfo,
    IN const AsRequestInfo* pAsRequestInfo,
    IN DWORD cbAsRequestInfo,
    IN BOOL fMachineAccount,
    IN PXONLINEP_USER User,
    IN const DWORD *pPreauthTypeList,
    IN DWORD PreauthTypeListLength,
    IN BYTE *pEchoPreauthBytes,
    IN DWORD cbEchoPreauthBytes,
    IN bool allowFakeCompoundPreauth,
    OUT PUCHAR pbRequestMessage,
    IN OUT PULONG pdwRequestMessageLength,
    IN OUT PXKERB_TGT_CONTEXT pTGTContext);

NTSTATUS WINAPI
kcl_VerifyAsReply(
    IN PUCHAR pbReplyMessage,
    IN ULONG dwReplyMessageLength,
    IN OUT PXKERB_TGT_CONTEXT pTGTContext);


//
// XKDC
//

NTSTATUS WINAPI
kcl_BuildXboxTgsRequest(
    IN const TitleInfo* pInfo,
    IN PXKERB_TGT_CONTEXT pCombinedTGTContext,
    IN const DWORD *pPreauthTypeList,
    IN DWORD PreauthTypeListLength,
    OUT PUCHAR pbRequestMessage,
    IN OUT PULONG pdwRequestMessageLength,
    IN OUT PXKERB_SERVICE_CONTEXT pXKerbServiceContext);

NTSTATUS WINAPI 
kcl_BuildXenonTgsRequest(
    IN const TitleInfo* pInfo,
    IN PXKERB_TGT_CONTEXT pCombinedTGTContext,
    IN const DWORD *pPreauthTypeList,
    IN DWORD PreauthTypeListLength,
    OUT PUCHAR pbRequestMessage,
    IN OUT PULONG pdwRequestMessageLength,
    IN OUT PXKERB_SERVICE_CONTEXT pXKerbServiceContext);

NTSTATUS WINAPI
kcl_VerifyXboxTgsReply(
    IN PXKERB_TGT_CONTEXT pCombinedTGTContext,
    IN PUCHAR pbReplyMessage,
    IN ULONG dwReplyMessageLength,
    IN OUT PXKERB_SERVICE_CONTEXT pXKerbServiceContext);

NTSTATUS WINAPI 
kcl_VerifyXenonTgsReply(
    IN PXKERB_TGT_CONTEXT pCombinedTGTContext,
    IN PUCHAR pbReplyMessage,
    IN ULONG dwReplyMessageLength,
    IN OUT PXKERB_SERVICE_CONTEXT pXKerbServiceContext);


//
// SG
//

NTSTATUS WINAPI
kcl_BuildTicketTgs(
    IN PUCHAR pbAuthdata,
    IN LPSTR szServerName,
    IN LPSTR szSiteName,
    IN LPSTR szTicketRealm,   // "XBOX.COM"
    IN LPSTR szClientRealm,   // "PASSPORT.NET"
    IN LPSTR szClientName1,   // "XE.538451958491@xbox.com"
    IN LPSTR szClientName2,   // "PASSPORT.NET"
    IN PUCHAR pbSessionKey,
    IN PUCHAR pbSiteKey,
    OUT PUCHAR pbTicket,
    OUT DWORD *pdwTicketLength
    );

NTSTATUS WINAPI
kcl_BuildApRequest(
    IN PXKERB_SERVICE_CONTEXT pServiceContext,
    OUT LARGE_INTEGER * pliTime,
    IN BYTE * pbSha,
    IN UINT cbSha,
    OUT PUCHAR pbRequestMessage,
    IN OUT UINT * pdwRequestMessageLength
    );

NTSTATUS WINAPI
kcl_VerifyApReply(
    IN PXKERB_SERVICE_CONTEXT pServiceContext,
    IN LARGE_INTEGER * pliTimes,
    IN UINT cTimes,
    OUT BYTE * pbSha,
    IN UINT cbSha,
    IN PUCHAR pbReplyMessage,
    IN UINT dwReplyMessageLength
    );


//
// KerbClient Library functions
//

HRESULT WINAPI
kcl_Initialize(
    OUT DWORD *pdwStatus
    );

#define TOKENTYPE_TGTCONTEXT                0

HRESULT WINAPI 
kcl_CreateToken(
    IN ULONG dwTokenType,
    OUT VOID **ppToken,
    IN BYTE *pbOptionalData,
    IN ULONG cbOptionalData,
    IN DWORD dwOptionalDword);

HRESULT WINAPI 
kcl_DeleteToken(
    IN VOID *pToken);

void WINAPI 
kcl_LibrarySetTimeSkew(
    IN LONGLONG nSkew);

void WINAPI 
kcl_LibraryGetTimeSkew(
    OUT LONGLONG *pnSkew);

HRESULT WINAPI 
kcl_GetTicketTimeRemaining(
    IN BYTE *rgSiteKey,
    IN OUT XKERB_TGT_CONTEXT *pTgt,
    OUT INT *pnSecsLeft);

HRESULT WINAPI 
kcl_AddToTicketTimeRemaining(
    IN BYTE *rgSiteKey,
    IN OUT XKERB_TGT_CONTEXT *pTgt,
    IN INT nSecsToAdd);

HRESULT WINAPI 
kcl_CopyPuidsOutToTgtContext(
    IN BYTE *rgSiteKey,
    IN OUT XKERB_TGT_CONTEXT *pTgt,
    OUT ULONGLONG *puidMachine,
    OUT ULONGLONG *puidUsers);

HRESULT WINAPI 
kcl_GetAuthDataStruct(
    IN BYTE *rgSiteKey,
    IN XKERB_SERVICE_CONTEXT *pKerbServiceContext,
    IN OUT BYTE *rgbAuthData, 
    IN OUT DWORD *pdwAuthDataSize, 
    OUT WORD *pwAuthDataVersion);

HRESULT WINAPI 
kcl_SetAuthDataStruct(
    IN BYTE *rgSiteKey,
    IN XKERB_SERVICE_CONTEXT *pKerbServiceContext,
    IN OUT BYTE *rgbAuthData);

// 
// Crypto functions
//

VOID 
XcHMAC4(
    BYTE * pbKeyMaterial, 
    UINT cbKeyMaterial, 
    BYTE * pbData, 
    UINT cbData,
    BYTE * pbData2, 
    UINT cbData2, 
    BYTE * pbData3, 
    UINT cbData3, 
    BYTE * pbData4, 
    UINT cbData4,
    BYTE * HmacData,
    UINT cbHmacData = 20);

VOID 
XcHMAC4WithKeyTable(
    BYTE * pbKeyTable, 
    BYTE * pbData, 
    UINT cbData,
    BYTE * pbData2, 
    UINT cbData2, 
    BYTE * pbData3, 
    UINT cbData3, 
    BYTE * pbData4, 
    UINT cbData4,
    BYTE * HmacData,
    UINT cbHmacData = 20);

VOID 
XcCrypt(
    DWORD dwOp, 
    BYTE * pbKey, 
    UINT cbKey, 
    BYTE * pbIv, 
    BYTE * pb1, 
    UINT cb1, 
    BYTE * pb2, 
    UINT cb2);

VOID 
XcCryptWithKeyTable(
    DWORD dwOp, 
    BYTE * pbKeyTable, 
    UINT cbKey, 
    BYTE * pbIv, 
    BYTE * pb1, 
    UINT cb1, 
    BYTE * pb2, 
    UINT cb2);

VOID
XcDESKeyParity(
    BYTE * pbKey,
    DWORD dwKeyLength);

VOID
XcKeyTable(
    IN ULONG dwCipher,
    OUT PUCHAR pbKeyTable,
    IN PUCHAR pbKey
    );

VOID 
XcHMACMakeKeyTable(
    BYTE * pbKeyMaterial, 
    UINT cbKeyMaterial, 
    BYTE * pbKeyTable);

VOID WINAPI ComputeDHGX(
    BYTE *pGX, 
    BYTE *pX);

VOID WINAPI ComputeDHGXY(
    BYTE *pGXY, 
    BYTE *pGY,
    BYTE *pX);

inline DWORD GetServiceResult(XKERB_PA_XENON_SERVICE_ADDRESS3 const * const pserviceAddress3, DWORD service)
{
    //TODO: little endian or big endian?
    DWORD byte=service/4;
    DWORD bit=(service%4)*2;
    return (pserviceAddress3->byteServiceResult[byte]>>bit)&0x3;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\kerbclient\clientcrypt.cpp ===
#include "xonp.h"
#include <cryptohelper.h>
#include <md5.h>

#define XETESTKEYS_BSAFE 
#include <xetestkeys.h>

//from kerberos.css
extern void KerbComputeKdcRequestNonceHmacKey(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN const KERB_ENCRYPTION_KEY* pClientKey,
    IN DWORD nonce,
    OUT PBYTE pNonceHmacKey
    );

#ifndef VERIFY
#define VERIFY(x) if(!(x)) { goto lDone; }
#endif

#ifndef offsetof
#define offsetof(s,m)   (size_t)&(((s *)0)->m)
#endif

 #define SAFE_INIT()  if (!bKeysInstalled) { if (Initialize() != 0) { return false; } }
 
//
// Key origin information:
//
//     Key name: masterxmacskey
//     Exponent: 65537
//     OperatorID: 96b66b1f4ad6eb4978ee40d29ca4aeecc1a19f89
//     Date: 06/03/2005 21:20:29
//
 
//const BYTE g_BsafePub_2048_65537[284] =
const BYTE g_BsafePub_XmacsEncryptionKey[284] =
{
    0x52,0x53,0x41,0x31,0x08,0x01,0x00,0x00,0x00,0x08,0x00,0x00,0xFF,0x00,
    0x00,0x00,0x01,0x00,0x01,0x00,0x9F,0x7C,0xE3,0x4E,0x7C,0x69,0xA2,0x3D,
    0x11,0xB7,0x50,0x58,0x2C,0xED,0xA8,0x46,0xBC,0xD4,0xAD,0x9C,0xF4,0x6A,
    0x01,0xB7,0x20,0x9F,0x8E,0x7E,0xF0,0x21,0xE2,0x88,0x4B,0xD7,0x90,0x9F,
    0xB3,0x52,0xA7,0xE3,0x91,0xC7,0xA1,0xA3,0xF6,0xFE,0x19,0xA5,0x67,0x02,
    0xAE,0x4E,0x22,0x88,0x30,0x1F,0xEA,0x75,0x93,0x21,0xCA,0x5F,0x58,0x0F,
    0x41,0x58,0x7E,0xC8,0x2A,0x20,0xCA,0xC7,0x02,0xFF,0x4D,0x1F,0x91,0x7F,
    0xA5,0xEA,0x04,0x6D,0x9D,0xAB,0x85,0x14,0xBC,0x24,0x1C,0xD5,0xF6,0x6E,
    0xEF,0x91,0xA8,0xA1,0x12,0xDF,0xF2,0x1B,0x54,0x94,0x32,0xFC,0x40,0x0E,
    0xA7,0x47,0xF7,0x13,0x48,0xDF,0xE3,0xE8,0x52,0xAA,0xE5,0xC1,0x25,0xB4,
    0x1C,0xE0,0xBD,0xE1,0xC4,0xB1,0x4E,0x52,0x8F,0x56,0x48,0xE3,0xEA,0x79,
    0xBF,0xC8,0x8F,0xD8,0x02,0x5F,0x54,0xC1,0xB1,0x2F,0x1D,0x8A,0xCF,0xBF,
    0x90,0x63,0x5C,0x9A,0x5B,0xED,0x70,0xB3,0x56,0x27,0x2D,0xE6,0xBB,0x45,
    0xBC,0xF3,0xB2,0x11,0x02,0x4C,0x20,0xC1,0x06,0x85,0x3D,0x2C,0xE2,0xDA,
    0xCF,0xF6,0x89,0xFC,0xA3,0x48,0xA8,0x27,0xCA,0xF3,0x1F,0x96,0x02,0xD6,
    0x63,0x9B,0xAB,0x48,0x3F,0x74,0xC2,0xDC,0x03,0x7F,0xA6,0xF6,0xD0,0x77,
    0xF5,0x21,0x42,0xC3,0xA9,0x89,0xEE,0xDE,0x0B,0x82,0x8E,0xE2,0x8E,0x11,
    0xB1,0xD5,0x15,0xBD,0xDB,0x89,0xD1,0xA7,0xB9,0x0A,0x63,0x1D,0xD8,0xAE,
    0x4A,0x0E,0x91,0xEB,0xF5,0x44,0x71,0x70,0x5E,0xF4,0xE5,0x3E,0x06,0xCA,
    0x19,0xD9,0x42,0x34,0xDC,0x06,0xBD,0x5D,0x1B,0x96,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00 
};
 

KerbClientCrypt::KerbClientCrypt()
{
    bKeysInstalled = false;
}

int KerbClientCrypt::Initialize()
{
    int status= 0;  // increment for each step

    // XmacsEncryptionKey (test)
    status++;  // 1
    VERIFY(_keyXmacsTest.OpenBsafePublicKey(g_XenonXmacsBsafePub2048, CXoCryptoCspPk::KeyPurposeEncrypt));

    // XmacsEncryptionKey (real)
    status++;  // 2
    VERIFY(_keyXmacsReal.OpenBsafePublicKey(g_BsafePub_XmacsEncryptionKey, CXoCryptoCspPk::KeyPurposeEncrypt));

    // ConsoleKey
    status++;  // 3
    VERIFY(CXoCryptoCspPk::InstallKeyFromBsafeFormat(
        L"KdcDvtConsoleKey",
        MS_ENHANCED_PROV,
        false,  // machine store
        CXoCryptoCspPk::KeyPurposeSign,
        g_XenonConsoleRsaBsafePrv1024,
        sizeof(g_XenonConsoleRsaBsafePrv1024),
        true));
    status++;  // 4
    VERIFY(_keyConsole.OpenContainer(L"KdcDvtConsoleKey", MS_ENHANCED_PROV, false) == CXoCryptoCspPk::OpenContainerSuccess);

    // MasterSigningKey
    status++;  // 5
    VERIFY(CXoCryptoCspPk::InstallKeyFromBsafeFormat(
        TEST_KEY_CONTAINER_MASTER_SIGN,
        MS_ENHANCED_PROV,
        false,  // machine store
        CXoCryptoCspPk::KeyPurposeSign,
        g_XenonMasterSigningBsafePrv2048,
        sizeof(g_XenonMasterSigningBsafePrv2048),
        true));
    status++;  // 6
    VERIFY(_keyMasterSigning.OpenContainer(TEST_KEY_CONTAINER_MASTER_SIGN, MS_ENHANCED_PROV, false) == CXoCryptoCspPk::OpenContainerSuccess);

    // status is 0 for successful return value, otherwise it is > 0
    status = 0;
    bKeysInstalled = true;

lDone:

    return status;
}


bool KerbClientCrypt::EncryptWithXmacsTestKey(OUT BYTE *pbMsg, OUT DWORD *pcbMsg, DWORD cbBuffer)
{
    SAFE_INIT();
    return _keyXmacsTest.Encrypt(pbMsg,pcbMsg,cbBuffer);
}

bool KerbClientCrypt::EncryptWithXmacsKey(OUT BYTE *pbMsg, OUT DWORD *pcbMsg, DWORD cbBuffer)
{
    SAFE_INIT();
    return _keyXmacsReal.Encrypt(pbMsg,pcbMsg,cbBuffer);
}

bool KerbClientCrypt::SignWithConsoleKey(const BYTE *pbSha1, DWORD cbSha1, OUT BYTE *pbSignature, OUT DWORD *pcbSignature)
{
    SAFE_INIT();
    return _keyConsole.Sign(pbSha1,cbSha1,pbSignature,pcbSignature);
}

bool KerbClientCrypt::SignConsoleCertificate(XE_CONSOLE_CERTIFICATE* pCert)
{
    // Incoming certificate should have all fields filled out except for:
    //   abSignature
    // which will be filled in by this function.

    SAFE_INIT();

    bool fRet = false;
    A_SHA_CTX shaCtx;
    BYTE abDigest[A_SHA_DIGEST_LEN];
    DWORD cbSignature;
    DWORD cb;

    cb = offsetof(XE_CONSOLE_CERTIFICATE, Signature);
    A_SHAInit(&shaCtx);
    A_SHAUpdate(&shaCtx, (unsigned char*) pCert, cb);
    A_SHAFinal(&shaCtx, abDigest);

    // Sign digest with Master key
    cbSignature = sizeof(pCert->Signature);
    VERIFY(_keyMasterSigning.Sign(abDigest,sizeof(abDigest),pCert->Signature, &cbSignature))
    VERIFY(_keyMasterSigning.VerifySignature(abDigest,sizeof(abDigest),pCert->Signature,cbSignature))
    VERIFY(cbSignature == CONSOLE_CERTIFICATE_SIGNATURE_SIZE);

    fRet = true;

lDone:
    return fRet;
}

bool KerbClientCrypt::SignWithMasterSigningKey(IN const BYTE* pbSha1, DWORD cbSha1, OUT BYTE* pbSignature, IN OUT DWORD* pcbSignature)
{
    SAFE_INIT();

    return _keyMasterSigning.Sign(pbSha1,cbSha1, pbSignature, pcbSignature);
}

// -- Below are C exports that are called from STF to perform encryption and signing stuff

extern KerbClientCrypt g_ClientCrypt; //from kerberos.cpp

//encrypts the data in-place.  the buffer must be big enough to hold the bigger output.
extern "C" DWORD kcl_EncryptWithXmacsTestKey(BYTE *pbMsg, DWORD *pcbMsg, DWORD cbBuffer)
{
    bool ok=g_ClientCrypt.EncryptWithXmacsTestKey(pbMsg, pcbMsg, cbBuffer);
    return (ok?0:~0);
}

//encrypts the data in-place.  the buffer must be big enough to hold the bigger output.
extern "C" DWORD kcl_EncryptWithXmacsKey(BYTE *pbMsg, DWORD *pcbMsg, DWORD cbBuffer)
{
    bool ok=g_ClientCrypt.EncryptWithXmacsKey(pbMsg, pcbMsg, cbBuffer);
    return (ok?0:~0);
}

//creates a signature for a console certificate.  pCertificate must be a XE_CONSOLE_CERTIFICATE
extern "C" DWORD kcl_GenerateConsoleCertificateSignature(BYTE *pCertificate, BYTE *pSignatureBuffer, DWORD *signatureBufferLength)
{
    //generate the SHA1 hash
    DWORD cbCertPart=offsetof(XE_CONSOLE_CERTIFICATE, Signature);
    A_SHA_CTX shaCtx;
    BYTE abDigest[A_SHA_DIGEST_LEN];
    A_SHAInit(&shaCtx);
    A_SHAUpdate(&shaCtx, (unsigned char*)pCertificate, cbCertPart);
    A_SHAFinal(&shaCtx, abDigest);

    //sign
    bool ok=g_ClientCrypt.SignWithMasterSigningKey(abDigest, sizeof(abDigest), pSignatureBuffer, signatureBufferLength);
    return (ok?0:~0);
}

//signs a SHA1 hash with the console key
extern "C" DWORD kcl_SignHashWithConsoleKey(const BYTE *pbSha1, DWORD cbSha1, OUT BYTE *pbSignature, OUT DWORD *pcbSignature)
{
    bool ok=g_ClientCrypt.SignWithConsoleKey(pbSha1, cbSha1, pbSignature, pcbSignature);
    return (ok?0:~0);
}

//signs a SHA1 hash with the a csp blob representing a console key
extern "C" DWORD kcl_SignHashWithConsoleCspBlob(const BYTE *pbSha1, DWORD cbSha1, const BYTE *pbCspBlob, DWORD cbCspBlob, OUT BYTE *pbSignature, OUT DWORD *pcbSignature)
{
    CXoCryptoCspPk csppk;

    //note: OpenPublicKey just imports a csp blob; it will also import the private key.
    if (!csppk.OpenPublicKey((BYTE*)pbCspBlob, cbCspBlob))
        return ~0;

    if (!csppk.Sign(pbSha1, cbSha1, pbSignature, pcbSignature))
        return ~0;

    return 0;
}

//Generates a csp blob representing a new public/private console key pair that is used in the xenon console certificate
//pbPublicKeyExponent should be 4 bytes, pbPublicKeyModulus should be 128 bytes.
extern "C" DWORD kcl_GenerateConsoleKeyPairCspBlob(BYTE *pbCspBlob, DWORD *pcbCspBlob, BYTE *pbPublicKeyExponent, BYTE *pbPublicKeyModulus)
{
    bool ok=true;

    HCRYPTPROV hProv=0;
    HCRYPTKEY hKey=0;

    //create the key
    if(!CryptAcquireContext(&hProv, 0, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_SILENT))
    {		
       //If we got NTE_BAD_KEYSET, there's probably no default container on the machine. Try to create it.
	if (GetLastError() == NTE_BAD_KEYSET && !CryptAcquireContext(&hProv, 0, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_NEWKEYSET))
	{			
	    ok=false;
	    goto kcl_GenerateConsoleKeyPairCspBlob_Cleanup;			
        }        
    }

    if (!CryptGenKey(hProv, AT_SIGNATURE, (1024<<16)|CRYPT_EXPORTABLE, &hKey))
    {
        ok=false;
        goto kcl_GenerateConsoleKeyPairCspBlob_Cleanup;
    }

    //export it
    if (!CryptExportKey(hKey, 0, PRIVATEKEYBLOB, 0, pbCspBlob, pcbCspBlob))
    {
        ok=false;
        goto kcl_GenerateConsoleKeyPairCspBlob_Cleanup;
    }

    //layout can be found at http://msdn.microsoft.com/en-us/library/aa375601%28VS.85%29.aspx#priv_BLOB
    RSAPUBKEY *rsaPubKey=(RSAPUBKEY*)(pbCspBlob+sizeof(PUBLICKEYSTRUC));
    char *modulus=(char*)rsaPubKey+sizeof(RSAPUBKEY);

    memcpy(pbPublicKeyExponent, &rsaPubKey->pubexp, 4);
    memcpy(pbPublicKeyModulus, modulus, 128);

    //clean up
kcl_GenerateConsoleKeyPairCspBlob_Cleanup:
    if (hKey)
    {
        CryptDestroyKey(hKey);
        hKey=0;
    }

    if (hProv)
    {
        CryptReleaseContext(hProv, 0);
        hProv=0;
    }

    if (ok)
        return 0;
    else
        return ~0;
}

//does rc4hmac encrypt using a key (usually the session key)
extern "C" DWORD kcl_RC4HmacEncrypt(IN const UCHAR* pbKey, IN ULONG KeySize, IN ULONG MessageType, IN PUCHAR pbInput, IN ULONG cbInput, OUT PUCHAR pbOutput, OUT PULONG pcbOutput)
{
    DWORD ret=rc4HmacEncrypt(0, pbKey, KeySize, MessageType, pbInput, cbInput, pbOutput, pcbOutput);
    return ret;
}

//does rc4hmac decrypt using a key (usually the session key)
extern "C" DWORD kcl_RC4HmacDecrypt(IN const UCHAR* pbKey, IN ULONG KeySize, IN ULONG MessageType, IN PUCHAR pbInput, IN ULONG cbInput, OUT PUCHAR pbOutput, OUT PULONG pcbOutput)
{
    DWORD ret=rc4HmacDecrypt(pbKey, KeySize, MessageType, pbInput, cbInput, pbOutput, pcbOutput);
    return ret;
}

//does the nonce+key thing to encrypt a byte blob
extern "C" DWORD kcl_RC4HMacEncryptUsingNonceAndKey(unsigned char *outData, unsigned int *inoutDataLength, const unsigned char *data, unsigned int dataLength, const unsigned char *keyBytes, unsigned int keyLength, DWORD nonce, unsigned int messageType)
{
    //generate the key
    KERB_ENCRYPTION_KEY clientKey;
    clientKey.keyvalue.value=(ASN1octet_t*)keyBytes;
    clientKey.keyvalue.length=keyLength;

    BYTE abNonceHmacKey[XONLINE_KEY_LENGTH];
    KerbComputeKdcRequestNonceHmacKey(0, &clientKey, nonce, abNonceHmacKey);

    //encrypt
    DWORD ret=rc4HmacEncrypt(0, abNonceHmacKey, XONLINE_KEY_LENGTH, messageType, (PUCHAR)data, dataLength, outData, (PULONG)inoutDataLength);
    return ret;
}

//does the nonce+key thing to decrypt a byte blob
extern "C" DWORD kcl_RC4HMacDecryptUsingNonceAndKey(unsigned char *outData, unsigned int *inoutDataLength, const unsigned char *data, unsigned int dataLength, const unsigned char *keyBytes, unsigned int keyLength, DWORD nonce, unsigned int messageType)
{
    //generate the key
    KERB_ENCRYPTION_KEY clientKey;
    clientKey.keyvalue.value=(ASN1octet_t*)keyBytes;
    clientKey.keyvalue.length=keyLength;

    BYTE abNonceHmacKey[XONLINE_KEY_LENGTH];
    KerbComputeKdcRequestNonceHmacKey(0, &clientKey, nonce, abNonceHmacKey);

    //decrypt
    DWORD ret=rc4HmacDecrypt(abNonceHmacKey, XONLINE_KEY_LENGTH, messageType, (PUCHAR)data, dataLength, outData, (PULONG)inoutDataLength);
    return ret;
}

//does the nonce+key thing to sign a byte blob
extern "C" DWORD kcl_GenerateSignatureUsingNonceAndKey(unsigned char *outSignature, unsigned int outSignatureLength, const unsigned char *data, unsigned int dataLength, const unsigned char *keyBytes, unsigned int keyLength, DWORD nonce)
{
    //generate the key
    KERB_ENCRYPTION_KEY clientKey;
    clientKey.keyvalue.value=(ASN1octet_t*)keyBytes;
    clientKey.keyvalue.length=keyLength;

    BYTE abNonceHmacKey[XONLINE_KEY_LENGTH];
    KerbComputeKdcRequestNonceHmacKey(0, &clientKey, nonce, abNonceHmacKey);

    //sign
    XcHMAC4(abNonceHmacKey, XONLINE_KEY_LENGTH, (BYTE*)data, dataLength, NULL, 0, NULL, 0, NULL, 0, outSignature, outSignatureLength);
    return 0;
}

//computes a compound identity key, used for askdc requests when the compound identity preauth is in use
extern "C" DWORD kcl_ComputeCompoundIdentityKey(IN const UCHAR* pbClientKey, IN ULONG cbClientKey, IN const UCHAR* pbSessionKey, IN ULONG cbSessionKey, OUT BYTE *pbCompoundKey, IN OUT ULONG *pcbCompoundKey)
{
    MD5_CTX Md5Context;
    UCHAR Key[MD5_LEN];
    ULONG ulSalt = KERB_PA_COMPOUND_IDENTITY_SALT;

    Assert(MD5_LEN == XONLINE_KEY_LENGTH);
    Assert(MD5_LEN == cbClientKey);
    Assert(MD5_LEN <= *pcbCompoundKey);

    md5Hmac(
        pbClientKey,
        cbClientKey,
        (PBYTE)"signaturekey",
        sizeof("signaturekey"),
        NULL,
        0,
        Key
        );

    MD5Init(&Md5Context);
    MD5Update(&Md5Context, (PUCHAR)&ulSalt, sizeof(ulSalt));

    MD5Update(&Md5Context, pbSessionKey, cbSessionKey);

    MD5Final(&Md5Context);

    md5Hmac(
        Key,
        MD5_LEN,
        Md5Context.digest,
        MD5_LEN,
        NULL,
        0,
        pbCompoundKey
        );

    *pcbCompoundKey=MD5_LEN;

    return 0;
}

//computes the key needed to encrypt the PC machine account creation preauth
extern "C" DWORD kcl_ComputePCPrincipalKey(IN const BYTE *pbSessionKey, IN ULONG cbSessionKey, IN const BYTE *pbPCNonce, IN ULONG cbPCNOnce, OUT BYTE *pbPrincipalKey, IN OUT ULONG *pcbPrincipalKey)
{
    //TODO: better validation

    BYTE hash[20];
    XcHMAC4((BYTE*)pbSessionKey, cbSessionKey,
        (BYTE*)pbPCNonce,        cbPCNOnce,
        NULL,                    0,
        NULL,                    0,
        NULL,                    0,
        hash,                    sizeof(hash));

    memcpy(pbPrincipalKey, hash, 16);
    *pcbPrincipalKey=16;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\kerbclient\kerbfuzz.cpp ===
#include "xonp.h"
#include "kerbfuzz.h"
#include <stdlib.h>

// -- shared

//decides the number of bits to fuzz for a specific type (random)
unsigned int FuzzCheck(IN const SFuzzParam &param)
{
    if (param.chance>0)
    {
        float threshold=((float)rand()/RAND_MAX);
        if (threshold<param.chance)
            return rand()%(param.maxBits+1);
    }

    return 0;
}

//fuzzes an array
unsigned int FuzzArray(void *data, unsigned int length, const SFuzzParam &fuzzParam)
{
    if (data==0) return 0;

    unsigned int fuzzBits=FuzzCheck(fuzzParam);
    for (unsigned int i=0; i<fuzzBits; ++i)
    {
        unsigned int byte=rand()%length;
        ((char*)data)[byte]^=1<<(rand()%8);
    }

    return fuzzBits;
}

//fuzzes an int with a suggested number of bits
void FuzzIntBits(unsigned int &val, unsigned int suggestedBits)
{
    int fuzzPath=rand()%100;
    if (fuzzPath>=17) //83% chance of bit twiddling as suggested
    {
        for (unsigned int fuzzBit=0; fuzzBit<suggestedBits; ++fuzzBit)
        {
            val^=1<<(rand()%32);
        }
    }
    else if (fuzzPath<2) //2% chance of inc
        ++val;
    else if (fuzzPath<4) //2% chance of dec
        --val;
    else if (fuzzPath<6) //2% chance of no bits
        val=0;
    else if (fuzzPath<8) //2% chance of all bits
        val=~0;
    else if (fuzzPath<10) //2% chance of max signed val
        val=0x7fffffff;
    else if (fuzzPath<12) //2% chance of min signed val
        val=0x80000000;
    else //5% chance of full byte twiddling
    {
        unsigned int bytes=suggestedBits/8;
        if (bytes<1) bytes=1;

        for (unsigned int fuzzBytes=0; fuzzBytes<bytes; ++fuzzBytes)
        {
            val=((rand()%0xffff)<<16) | (rand()%0xffff);
        }
    }
}

// -- build request fuzz

SRequestFuzzParams requestFuzz={0};

//updates the request fuzz parameters
HRESULT WINAPI kcl_SetRequestFuzzParams(IN SRequestFuzzParams *params)
{
    if (params)
        requestFuzz=*params;
    else
        memset(&requestFuzz, 0, sizeof(requestFuzz));

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\kerbclient\kerberos.cpp ===
//+-----------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation
//
//------------------------------------------------------------------------

#include "xonp.h"
#include <xcrypt.h>
#include <sha.h>
#include <md4.h>
#include <md5.h>
#include "kerbfuzz.h"

typedef LONG SECURITY_STATUS;
#include "ntrtl.h"

//
// Please be very careful when moving around code in this cpp file.
// Make sure you read the scratch memory allocator code and
// understand how memory is manipulated before change the code.
//

//DefineTag(ScratchMemoryVerbose,TAG_ENABLE);
DefineTag(ScratchMemoryVerbose,0);
DefineTag(ScratchMemoryAlloc,0);

DefineTag(KerbASN1,0);

tagASN1module_t g_KerbAsnModule;

//
// Globals
//

LONGLONG g_nClockSkew = 0;
KerbClientCrypt g_ClientCrypt;

// 
// Forward declarations
//

KERBERR VerifyPassportAuthorizationPreAuthReply(
    CScratchMemoryAllocator* pScratchAlloc,
    KERB_PA_DATA* pPreAuthData,
    KERB_ENCRYPTION_KEY* pKey,
    IN OUT XKERB_TGT_CONTEXT* pTGTContext
);

NTSTATUS AddPassportAuthenticationPreAuth(
    CScratchMemoryAllocator*    pScratchAlloc,
    const AsRequestInfo        *pAsRequestInfo,
    IN OUT PKERB_PA_DATA_LIST*  ppPreAuthData
    );

NTSTATUS AddEncryptedPassportAuthenticationPreAuth(
    CScratchMemoryAllocator*    pScratchAlloc,
    KERB_ENCRYPTION_KEY*        pKey,
    const AsRequestInfo        *pAsRequestInfo,
    IN OUT KERB_PA_DATA_LIST**  ppPreAuthData
    );

// ---------------------------------------------------------------------------------------

VOID
KerbCreateKeyFromBuffer(
    OUT PKERB_ENCRYPTION_KEY NewKey,
    IN PUCHAR Buffer,
    IN ULONG BufferSize,
    IN ULONG EncryptionType
    )
{
    NewKey->keytype = EncryptionType;
    NewKey->keyvalue.length = BufferSize;
    NewKey->keyvalue.value = (PUCHAR) Buffer;
}

KERBERR
KerbAllocateEncryptionBuffer(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN ULONG EncryptionType,
    IN ULONG BufferSize,
    OUT PULONG EncryptionBufferSize,
    OUT PBYTE * EncryptionBuffer
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;

    *EncryptionBufferSize = sizeof(RC4_MDx_HEADER) + BufferSize;

    *EncryptionBuffer = (PBYTE) pScratchMemoryAllocator->Alloc(*EncryptionBufferSize);
    if (*EncryptionBuffer == NULL)
    {
        TraceSz(AuthWarn, "KerbAllocateEncryptionBuffer: Failed memory allocation");
        KerbErr = KRB_ERR_GENERIC;
    }
    return(KerbErr);

}

KERBERR
KerbAllocateEncryptionBufferWrapper(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN ULONG EncryptionType,
    IN ULONG BufferSize,
    OUT unsigned long * EncryptionBufferSize,
    OUT PBYTE * EncryptionBuffer
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    ULONG tempInt = 0;

    KerbErr = KerbAllocateEncryptionBuffer(
                pScratchMemoryAllocator,
                EncryptionType,
                BufferSize,
                &tempInt,
                EncryptionBuffer
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }
    *EncryptionBufferSize = tempInt;

Cleanup:
    return (KerbErr);
}

// ---------------------------------------------------------------------------------------
// Time functions
// ---------------------------------------------------------------------------------------

BOOLEAN
TimeFieldsToTime (
    IN PTIME_FIELDS TimeFields,
    OUT PLARGE_INTEGER Time
    )
{
    SYSTEMTIME sysTime;
    sysTime.wYear = TimeFields->Year;
    sysTime.wMonth = TimeFields->Month;
    sysTime.wDayOfWeek = TimeFields->Weekday;
    sysTime.wDay = TimeFields->Day;
    sysTime.wHour = TimeFields->Hour;
    sysTime.wMinute = TimeFields->Minute;
    sysTime.wSecond = TimeFields->Second;
    sysTime.wMilliseconds = TimeFields->Milliseconds;
    return (BOOLEAN) SystemTimeToFileTime( (CONST SYSTEMTIME *)&sysTime, (LPFILETIME) Time );
}

VOID
TimeToTimeFields (
    IN PLARGE_INTEGER Time,
    OUT PTIME_FIELDS TimeFields
    )
{
    SYSTEMTIME sysTime;
    FileTimeToSystemTime( (LPFILETIME)Time, (LPSYSTEMTIME)&sysTime );
    TimeFields->Year = sysTime.wYear;
    TimeFields->Month = sysTime.wMonth;
    TimeFields->Weekday = sysTime.wDayOfWeek;
    TimeFields->Day = sysTime.wDay;
    TimeFields->Hour = sysTime.wHour;
    TimeFields->Minute = sysTime.wMinute;
    TimeFields->Second = sysTime.wSecond;
    TimeFields->Milliseconds = sysTime.wMilliseconds;
}


//+-------------------------------------------------------------------------
// Start CPP code
//+-------------------------------------------------------------------------

void 
KerbInit()
{
    KRB5_Module_Startup(&g_KerbAsnModule);
    g_ClientCrypt.Initialize();
}

void
KerbTerm()
{
}

KERB_CRYPT_LIST g_RC4HMAC_CryptList = { NULL , KERB_ETYPE_RC4_HMAC_NT };

NTSTATUS
KerbComputeRequestBodyChecksum(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PKERB_KDC_REQUEST_BODY RequestBody,
    OUT PKERB_CHECKSUM Checksum
    )
{
    KERB_MESSAGE_BUFFER MarshalledRequestBody = {0, NULL};
    NTSTATUS Status = STATUS_SUCCESS;
    MD5_CTX MD5Context;

    ZeroMemory(
        Checksum,
        sizeof(KERB_CHECKSUM)
        );

    //
    // Allocate enough space for the checksum
    //
    Checksum->checksum.value = (PUCHAR) pScratchMemoryAllocator->Alloc(MD5_LEN);
    if (Checksum->checksum.value == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    Checksum->checksum.length = MD5_LEN;
    Checksum->checksum_type = KERB_CHECKSUM_MD5;

    {
        CReleaseAllScratchMemoryUponDestruction onlyPreserveThisMemory( pScratchMemoryAllocator );

        if (!KERB_SUCCESS(KerbPackData(
                            pScratchMemoryAllocator,
                            RequestBody,
                            KERB_MARSHALLED_REQUEST_BODY_PDU,
                            &MarshalledRequestBody.BufferSize,
                            &MarshalledRequestBody.Buffer
                            )))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        //
        // Now checksum the buffer
        //

        MD5Init(&MD5Context);
        MD5Update(&MD5Context, MarshalledRequestBody.Buffer, MarshalledRequestBody.BufferSize);
        MD5Final(&MD5Context);
        memcpy(Checksum->checksum.value, MD5Context.digest, MD5_LEN);
    }

Cleanup:
    if (Status != STATUS_SUCCESS)
    {
        TraceSz1( AuthWarn, "KerbComputeRequestBodyChecksum failure status 0x%X", Status );
    }
    return(Status);
}

//+-------------------------------------------------------------------------

NTSTATUS
KerbAddTimestampPreAuth(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PKERB_ENCRYPTION_KEY UserKey,
    IN PTimeStamp pAuthTime,
    OUT PKERB_PA_DATA_LIST * PreAuthData
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_PA_DATA_LIST ListElement = NULL;
    KERB_ENCRYPTED_TIMESTAMP Timestamp = {0};
    PBYTE EncryptedTime = NULL;
    ULONG EncryptedTimeSize = 0;
    KERB_ENCRYPTED_DATA EncryptedData;

    ZeroMemory( &EncryptedData, sizeof(KERB_ENCRYPTED_DATA) );

    //
    // Build the output element
    //

    ListElement = (PKERB_PA_DATA_LIST) pScratchMemoryAllocator->Alloc(sizeof(KERB_PA_DATA_LIST));
    if (ListElement == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    {
        CReleaseAllScratchMemoryUponDestruction onlyPreserveThisMemory( pScratchMemoryAllocator );

        //
        // Now build the encrypted timestamp
        //
        KerbConvertLargeIntToGeneralizedTime(
            &Timestamp.timestamp,
            &Timestamp.KERB_ENCRYPTED_TIMESTAMP_usec,
            pAuthTime
            );

        Timestamp.bit_mask = KERB_ENCRYPTED_TIMESTAMP_usec_present;

        KerbErr = KerbPackEncryptedTime(
                    pScratchMemoryAllocator,
                    &Timestamp,
                    &EncryptedTimeSize,
                    &EncryptedTime
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        //
        // Now encrypt the time
        //

        KerbErr = KerbAllocateEncryptionBuffer(
                    pScratchMemoryAllocator,
                    UserKey->keytype,
                    EncryptedTimeSize,
                    &EncryptedData.cipher_text.length,
                    &EncryptedData.cipher_text.value
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            Status = KerbMapKerbError(KerbErr);
            goto Cleanup;
        }


        KerbErr = KerbEncryptDataEx(
                    pScratchMemoryAllocator,
                    &EncryptedData,
                    EncryptedTimeSize,
                    EncryptedTime,
                    UserKey->keytype,
                    KERB_ENC_TIMESTAMP_SALT,
                    UserKey
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        //
        // Now pack the encrypted data
        //

        KerbErr = KerbPackEncryptedData(
                    pScratchMemoryAllocator,
                    &EncryptedData,
                    (PULONG) &ListElement->value.preauth_data.length,
                    (PUCHAR *) &ListElement->value.preauth_data.value
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        //
        // Preserve the only piece of memory we care about
        //
        PreserveThisMemory( &onlyPreserveThisMemory, &ListElement->value.preauth_data.value, ListElement->value.preauth_data.length );
    }

    ListElement->value.preauth_data_type = KRB5_PADATA_ENC_TIMESTAMP;
    ListElement->next = *PreAuthData;
    *PreAuthData = ListElement;

Cleanup:
    if (Status != STATUS_SUCCESS)
    {
        TraceSz1( AuthWarn, "KerbAddTimestampPreAuth failure status 0x%X", Status );
    }
    return(Status);
}

//+-------------------------------------------------------------------------

PKERB_PA_DATA
KerbFindPreAuthDataEntry(
    IN ULONG EntryId,
    IN PKERB_PA_DATA_LIST AuthData
    )
{
    PKERB_PA_DATA_LIST TempData = AuthData;

    while (TempData != NULL)
    {
        if (TempData->value.preauth_data_type == (int) EntryId)
        {
            break;
        }
        TempData = TempData->next;
    }
    return(TempData  != NULL ? &TempData->value : NULL);
}


//--------------------------------------------------------------------------

void KerbComputeKdcRequestNonceHmacKey(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN const KERB_ENCRYPTION_KEY* pClientKey,
    IN DWORD nonce,
    OUT PBYTE pNonceHmacKey
    )
{
    MD5_CTX Md5Context;
    UCHAR Key[MD5_LEN];
    ULONG ulSalt = KERB_KDC_REQ_NONCE_CKSUM_SALT;

    Assert(MD5_LEN == XONLINE_KEY_LENGTH);
    Assert(MD5_LEN == pClientKey->keyvalue.length);

    md5Hmac(
        pClientKey->keyvalue.value,
        pClientKey->keyvalue.length,
        (PBYTE)"signaturekey",
        sizeof("signaturekey"),
        NULL,
        0,
        Key
        );

    MD5Init(&Md5Context);

    MD5Update(&Md5Context, (BYTE*)&ulSalt, sizeof(ulSalt));

    MD5Update(&Md5Context, (BYTE*)&nonce, sizeof(nonce));

    MD5Final(&Md5Context);

    md5Hmac(
        Key,
        MD5_LEN,
        Md5Context.digest,
        MD5_LEN,
        NULL,
        0,
        pNonceHmacKey
        );
}

//+-------------------------------------------------------------------------

KERBERR
KerbVerifyAccountCreationPreAuth(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PKERB_PA_DATA PreAuthData,
    IN const KERB_ENCRYPTION_KEY* ClientKey,
    IN OUT PXKERB_TGT_CONTEXT pTGTContext
    )
{
    KERBERR KerbErr;
    BYTE abNonceHmacKey[XONLINE_KEY_LENGTH];
    KERB_ENCRYPTION_KEY NonceHmacKey;
    PKERB_ENCRYPTED_DATA EncryptedData = NULL;
    DWORD dwDecryptedDataLen;
    DWORD i;

    CReleaseAllScratchMemoryUponDestruction onlyPreserveThisMemory( pScratchMemoryAllocator );

    //
    // Unpack the pre-auth data into an encrypted data first.
    //
    KerbErr = KerbUnpackEncryptedData(
                pScratchMemoryAllocator,
                PreAuthData->preauth_data.value,
                PreAuthData->preauth_data.length,
                &EncryptedData
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    if (EncryptedData->cipher_text.length != KerbGetEncryptionOverhead() + sizeof(XKERB_PA_XBOX_ACCOUNT_CREATION))
    {
        AssertSz2( FALSE, "KerbVerifyAccountCreationPreAuth: Preauth size is %d, should be %d",
            EncryptedData->cipher_text.length,
            KerbGetEncryptionOverhead() + sizeof(XKERB_PA_XBOX_ACCOUNT_CREATION)
            );
        KerbErr = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    //
    // Try all nonces
    //
    for (i=0; i<pTGTContext->ctNumNonces; ++i)
    {
        KerbComputeKdcRequestNonceHmacKey(
            pScratchMemoryAllocator,
            ClientKey,
            pTGTContext->Nonce[i],
            abNonceHmacKey
            );

        KerbCreateKeyFromBuffer(
            &NonceHmacKey,
            abNonceHmacKey,
            XONLINE_KEY_LENGTH,
            KERB_ETYPE_RC4_HMAC_NT
            );

        //
        // Now decrypt the encrypted data (in place)
        //
        KerbErr = KerbDecryptDataEx(
                    pScratchMemoryAllocator,
                    EncryptedData,
                    &NonceHmacKey,
                    KERB_PA_XBOX_ACCOUNT_CREATION_SALT,
                    (PULONG) &dwDecryptedDataLen,
                    (BYTE*)pTGTContext->pAccountCreationPreAuth
                    );
        if (KERB_SUCCESS(KerbErr))
        {
            Assert( dwDecryptedDataLen == sizeof(XKERB_PA_XBOX_ACCOUNT_CREATION) );
            if (dwDecryptedDataLen != sizeof(XKERB_PA_XBOX_ACCOUNT_CREATION))
            {
                KerbErr = STATUS_LOGON_FAILURE;
                goto Cleanup;
            }
            break;
        }
    }

    if (i == pTGTContext->ctNumNonces)
    {
        KerbErr = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    KerbErr = KDC_ERR_NONE;

Cleanup:
    if (!KERB_SUCCESS(KerbErr))
    {
        TraceSz1( AuthWarn, "KerbVerifyAccountCreationPreAuth failure KerbErr 0x%X", KerbErr );
    }
    return(KerbErr);
}

//+-------------------------------------------------------------------------

KERBERR
KerbVerifyXenonServiceAddress2PreAuth(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PKERB_PA_DATA PreAuthData,
    IN const KERB_ENCRYPTION_KEY* TGTSessionKey,
    IN PXKERB_SERVICE_CONTEXT pXKerbServiceContext,
    OUT PXKERB_PA_XENON_SERVICE_ADDRESS2 pPAServiceAddress
    )
{
    KERBERR KerbErr;
    BYTE abNonceHmacKey[XONLINE_KEY_LENGTH];
    KERB_ENCRYPTION_KEY NonceHmacKey;
    PKERB_ENCRYPTED_DATA EncryptedData = NULL;
    DWORD dwDecryptedDataLen;
    DWORD i;

    CReleaseAllScratchMemoryUponDestruction onlyPreserveThisMemory( pScratchMemoryAllocator );

    //
    // Unpack the pre-auth data into an encrypted data first.
    //
    KerbErr = KerbUnpackEncryptedData(
                pScratchMemoryAllocator,
                PreAuthData->preauth_data.value,
                PreAuthData->preauth_data.length,
                &EncryptedData
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    if (EncryptedData->cipher_text.length != KerbGetEncryptionOverhead() + sizeof(XKERB_PA_XENON_SERVICE_ADDRESS2))
    {
        AssertSz2( FALSE, "KerbVerifyXenonServiceAddressPreAuth: Preauth size is %d, should be %d",
            EncryptedData->cipher_text.length,
            KerbGetEncryptionOverhead() + sizeof(XKERB_PA_XENON_SERVICE_ADDRESS2)
            );
        KerbErr = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    //
    // Try all nonces
    //
    for (i=0; i<pXKerbServiceContext->ctNumNonces; ++i)
    {
        KerbComputeKdcRequestNonceHmacKey(
            pScratchMemoryAllocator,
            TGTSessionKey,
            pXKerbServiceContext->Nonce[i],
            abNonceHmacKey
            );

        KerbCreateKeyFromBuffer(
            &NonceHmacKey,
            abNonceHmacKey,
            XONLINE_KEY_LENGTH,
            KERB_ETYPE_RC4_HMAC_NT
            );

        //
        // Now decrypt the encrypted data (in place)
        //
        KerbErr = KerbDecryptDataEx(
                    pScratchMemoryAllocator,
                    EncryptedData,
                    &NonceHmacKey,
                    KERB_PA_XBOX_SERVICE_ADDRESS_SALT,
                    (PULONG) &dwDecryptedDataLen,
                    (BYTE*)pPAServiceAddress
                    );
        if (KERB_SUCCESS(KerbErr))
        {
            Assert( dwDecryptedDataLen == sizeof(XKERB_PA_XENON_SERVICE_ADDRESS2) );
            if (dwDecryptedDataLen != sizeof(XKERB_PA_XENON_SERVICE_ADDRESS2))
            {
                KerbErr = STATUS_LOGON_FAILURE;
                goto Cleanup;
            }
            break;
        }
    }

    if (i == pXKerbServiceContext->ctNumNonces)
    {
        TraceSz1(AuthWarn, "KerbVerifyXenonServiceAddress2PreAuth: nonce not found (tried %d).", pXKerbServiceContext->ctNumNonces);
        KerbErr = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

#ifdef XNET_FEATURE_TRACE
    {
        char buffer1[(XONLINE_XE_MAX_BYTE_SERVICEIDS + XONLINE_MAX_DWORD_SERVICEIDS)*40];
        char buf[40];
        DWORD k;
        buffer1[0] = '\0';

        for (k=0; k < XONLINE_XE_MAX_BYTE_SERVICEIDS; k++)
        {
            if ( 0 == pPAServiceAddress->byteServiceResult[k].bServiceID )
            {
                break;
            }

            sprintf(buf," %d(0x%X):%d",
                    pPAServiceAddress->byteServiceResult[k].bServiceID,
                    pPAServiceAddress->byteServiceResult[k].hr,
                    pPAServiceAddress->byteServiceResult[k].wServicePort);
            strcat(buffer1, buf);
        }

        for (k=0; k < XONLINE_MAX_DWORD_SERVICEIDS; k++)
        {
            if ( 0 == pPAServiceAddress->dwordServiceResult[k].dwServiceID )
            {
                break;
            }

            sprintf(buf," %d(0x%X):%d",
                    pPAServiceAddress->dwordServiceResult[k].dwServiceID,
                    pPAServiceAddress->dwordServiceResult[k].hr,
                    pPAServiceAddress->dwordServiceResult[k].wServicePort);
            strcat(buffer1, buf);
        }

        TraceSz14( AuthVerbose, "KerbVerifyXenonServiceAddressPreAuth HR:0x%X IP:%d.%d.%d.%d User HR:FLGS: 0x%X:%X 0x%X:%X 0x%X:%X 0x%X:%X Services:%s",
            pPAServiceAddress->hr,
            pPAServiceAddress->siteIPAddress.S_un.S_un_b.s_b1,
            pPAServiceAddress->siteIPAddress.S_un.S_un_b.s_b2,
            pPAServiceAddress->siteIPAddress.S_un.S_un_b.s_b3,
            pPAServiceAddress->siteIPAddress.S_un.S_un_b.s_b4,
            pPAServiceAddress->hrUser[0],
            pPAServiceAddress->dwUserFlags[0],
            pPAServiceAddress->hrUser[1],
            pPAServiceAddress->dwUserFlags[1],
            pPAServiceAddress->hrUser[2],
            pPAServiceAddress->dwUserFlags[2],
            pPAServiceAddress->hrUser[3],
            pPAServiceAddress->dwUserFlags[3],
            buffer1 );
    }
#endif

    KerbErr = KDC_ERR_NONE;

Cleanup:
    if (!KERB_SUCCESS(KerbErr))
    {
        TraceSz1( AuthWarn, "KerbVerifyXenonServiceAddressPreAuth failure KerbErr 0x%X", KerbErr );
    }

    return(KerbErr);
}

//-----

KERBERR
KerbVerifyXenonServiceAddress3PreAuth(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PKERB_PA_DATA PreAuthData,
    IN const KERB_ENCRYPTION_KEY* TGTSessionKey,
    IN PXKERB_SERVICE_CONTEXT pXKerbServiceContext,
    OUT PXKERB_PA_XENON_SERVICE_ADDRESS3 pPAServiceAddress
    )
{
    KERBERR KerbErr;
    BYTE abNonceHmacKey[XONLINE_KEY_LENGTH];
    KERB_ENCRYPTION_KEY NonceHmacKey;
    PKERB_ENCRYPTED_DATA EncryptedData = NULL;
    DWORD dwDecryptedDataLen;
    DWORD i;

    CReleaseAllScratchMemoryUponDestruction onlyPreserveThisMemory( pScratchMemoryAllocator );

    // Unpack the pre-auth data into an encrypted data first.
    KerbErr = KerbUnpackEncryptedData(
                pScratchMemoryAllocator,
                PreAuthData->preauth_data.value,
                PreAuthData->preauth_data.length,
                &EncryptedData
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    if (EncryptedData->cipher_text.length != KerbGetEncryptionOverhead() + sizeof(XKERB_PA_XENON_SERVICE_ADDRESS3))
    {
        AssertSz2( FALSE, "KerbVerifyXenonServiceAddressPreAuth3: Preauth size is %d, should be %d",
            EncryptedData->cipher_text.length,
            KerbGetEncryptionOverhead() + sizeof(XKERB_PA_XENON_SERVICE_ADDRESS3)
            );
        KerbErr = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    // Try all nonces
    for (i=0; i<pXKerbServiceContext->ctNumNonces; ++i)
    {
        KerbComputeKdcRequestNonceHmacKey(
            pScratchMemoryAllocator,
            TGTSessionKey,
            pXKerbServiceContext->Nonce[i],
            abNonceHmacKey
            );

        KerbCreateKeyFromBuffer(
            &NonceHmacKey,
            abNonceHmacKey,
            XONLINE_KEY_LENGTH,
            KERB_ETYPE_RC4_HMAC_NT
            );

        // Now decrypt the encrypted data (in place)
        KerbErr = KerbDecryptDataEx(
                    pScratchMemoryAllocator,
                    EncryptedData,
                    &NonceHmacKey,
                    KERB_PA_XBOX_SERVICE_ADDRESS_SALT,
                    (PULONG) &dwDecryptedDataLen,
                    (BYTE*)pPAServiceAddress
                    );
        if (KERB_SUCCESS(KerbErr))
        {
            Assert( dwDecryptedDataLen == sizeof(XKERB_PA_XENON_SERVICE_ADDRESS3) );
            if (dwDecryptedDataLen != sizeof(XKERB_PA_XENON_SERVICE_ADDRESS3))
            {
                KerbErr = STATUS_LOGON_FAILURE;
                goto Cleanup;
            }
            break;
        }
    }

    if (i == pXKerbServiceContext->ctNumNonces)
    {
        TraceSz1(AuthWarn, "KerbVerifyXenonServiceAddress3PreAuth: nonce not found (tried %d).", pXKerbServiceContext->ctNumNonces);
        KerbErr = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    KerbErr = KDC_ERR_NONE;

Cleanup:
    if (!KERB_SUCCESS(KerbErr))
    {
        TraceSz1( AuthWarn, "KerbVerifyXenonServiceAddressPreAuth3 failure KerbErr 0x%X", KerbErr );
    }

    return(KerbErr);
}

//-----

KERBERR
KerbVerifyXenonServiceAddressFailedPreAuth(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PKERB_PA_DATA PreAuthData,
    IN const KERB_ENCRYPTION_KEY* TGTSessionKey,
    IN PXKERB_SERVICE_CONTEXT pXKerbServiceContext,
    OUT PXKERB_PA_XENON_SERVICE_ADDRESS_FAILED pPAServiceAddress
    )
{
    KERBERR KerbErr;
    BYTE abNonceHmacKey[XONLINE_KEY_LENGTH];
    KERB_ENCRYPTION_KEY NonceHmacKey;
    PKERB_ENCRYPTED_DATA EncryptedData = NULL;
    DWORD dwDecryptedDataLen;
    DWORD i;

    CReleaseAllScratchMemoryUponDestruction onlyPreserveThisMemory( pScratchMemoryAllocator );

    // Unpack the pre-auth data into an encrypted data first.
    KerbErr = KerbUnpackEncryptedData(
                pScratchMemoryAllocator,
                PreAuthData->preauth_data.value,
                PreAuthData->preauth_data.length,
                &EncryptedData
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    if (EncryptedData->cipher_text.length != KerbGetEncryptionOverhead() + sizeof(XKERB_PA_XENON_SERVICE_ADDRESS_FAILED))
    {
        AssertSz2( FALSE, "KerbVerifyXenonServiceAddressPreAuthFailed: Preauth size is %d, should be %d",
            EncryptedData->cipher_text.length,
            KerbGetEncryptionOverhead() + sizeof(XKERB_PA_XENON_SERVICE_ADDRESS_FAILED)
            );
        KerbErr = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    // Try all nonces
    for (i=0; i<pXKerbServiceContext->ctNumNonces; ++i)
    {
        KerbComputeKdcRequestNonceHmacKey(
            pScratchMemoryAllocator,
            TGTSessionKey,
            pXKerbServiceContext->Nonce[i],
            abNonceHmacKey
            );

        KerbCreateKeyFromBuffer(
            &NonceHmacKey,
            abNonceHmacKey,
            XONLINE_KEY_LENGTH,
            KERB_ETYPE_RC4_HMAC_NT
            );

        // Now decrypt the encrypted data (in place)
        KerbErr = KerbDecryptDataEx(
                    pScratchMemoryAllocator,
                    EncryptedData,
                    &NonceHmacKey,
                    KERB_PA_XBOX_SERVICE_ADDRESS_SALT,
                    (PULONG) &dwDecryptedDataLen,
                    (BYTE*)pPAServiceAddress
                    );
        if (KERB_SUCCESS(KerbErr))
        {
            Assert( dwDecryptedDataLen == sizeof(XKERB_PA_XENON_SERVICE_ADDRESS_FAILED) );
            if (dwDecryptedDataLen != sizeof(XKERB_PA_XENON_SERVICE_ADDRESS_FAILED))
            {
                KerbErr = STATUS_LOGON_FAILURE;
                goto Cleanup;
            }
            break;
        }
    }

    if (i == pXKerbServiceContext->ctNumNonces)
    {
        TraceSz1(AuthWarn, "KerbVerifyXenonServiceAddressFailedPreAuth: nonce not found (tried %d).", pXKerbServiceContext->ctNumNonces);
        KerbErr = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    KerbErr = KDC_ERR_NONE;

Cleanup:
    if (!KERB_SUCCESS(KerbErr))
    {
        TraceSz1( AuthWarn, "KerbVerifyXenonServiceAddressPreAuthFailed failure KerbErr 0x%X", KerbErr );
    }

    return(KerbErr);
}

//+-------------------------------------------------------------------------

NTSTATUS
KerbAddPacRequestPreAuth(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN BOOL fIncludePAC,
    IN OUT PKERB_PA_DATA_LIST * PreAuthData
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_PA_DATA_LIST ListElement = NULL;
    PKERB_PA_DATA_LIST LastElement = NULL;
    KERB_PA_PAC_REQUEST_EX PacRequestEx = {0};
    KERB_PA_PAC_REQUEST_EX_pac_sections_Element PacSections[2];

    ListElement = (PKERB_PA_DATA_LIST) pScratchMemoryAllocator->Alloc(sizeof(KERB_PA_DATA_LIST));
    if (ListElement == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    ZeroMemory( &PacRequestEx, sizeof(KERB_PA_PAC_REQUEST_EX) );

    if (fIncludePAC)
    {
        PacRequestEx.include_pac = TRUE;
        PacRequestEx.bit_mask = pac_sections_present;
        PacRequestEx.pac_sections = &PacSections[0];

        PacSections[0].next = &PacSections[1];
        PacSections[0].value = PAC_CLIENT_IDENTITY;
        PacSections[1].next = NULL;
        PacSections[1].value = PAC_COMPOUND_IDENTITY;
    }
    else
    {
        PacRequestEx.include_pac = FALSE;
    }

    //
    // Marshall the type into the list element.
    //
    if (!KERB_SUCCESS(KerbPackData(
                        pScratchMemoryAllocator,
                        (PKERB_PA_PAC_REQUEST)(&PacRequestEx),
                        KERB_PA_PAC_REQUEST_EX_PDU,
                        (PULONG) &ListElement->value.preauth_data.length,
                        (PUCHAR *) &ListElement->value.preauth_data.value
                        )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    ListElement->value.preauth_data_type = KRB5_PADATA_PAC_REQUEST_EX;

    //
    // We want this to go at the end, so that it will override any other
    // pa-data that may enable a PAC.
    //

    LastElement = *PreAuthData;
    if (LastElement != NULL)
    {
        while (LastElement->next != NULL)
        {
            LastElement = LastElement->next;
        }
        LastElement->next = ListElement;
    }
    else
    {
        *PreAuthData = ListElement;
    }

    ListElement->next = NULL;
    ListElement = NULL;

Cleanup:
    if (Status != STATUS_SUCCESS)
    {
        TraceSz1( AuthWarn, "KerbAddPacRequestPreAuth failure status 0x%X", Status );
    }

    return(Status);
}


//+-------------------------------------------------------------------------
// Add the xbox preauth to pre-pre-auth this client
//+-------------------------------------------------------------------------

NTSTATUS
KerbAddPrePreAuth(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN char* pszName,
    IN PKERB_ENCRYPTION_KEY ClientKey,
    IN OUT PKERB_PA_DATA_LIST * PreAuthData
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_PA_DATA_LIST ListElement;
    PXKERB_PA_XBOX_PPA pPrePreAuth;
    CHAR szName[ XONLINE_GAMERTAG_SIZE ];
    BYTE abShaCtx[XC_SERVICE_SHA_CONTEXT_SIZE];
    BYTE abPPA2[XC_SERVICE_DIGEST_SIZE];
    int i;

    Assert( XC_SERVICE_DIGEST_SIZE == XONLINE_PPA_HASH_SIZE );

    ListElement = (PKERB_PA_DATA_LIST) pScratchMemoryAllocator->Alloc(sizeof(KERB_PA_DATA_LIST));
    if (ListElement == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    pPrePreAuth = (PXKERB_PA_XBOX_PPA) pScratchMemoryAllocator->Alloc(sizeof(XKERB_PA_XBOX_PPA));
    if (pPrePreAuth == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Convert to standard (15-char max) upper case name
    //
    memset( szName, 0, sizeof( szName ) );

    for( i = 0; i < sizeof( szName ); i++ )
    {
        if (pszName[ i ] == '\0')
        {
            break;
        }
        szName[ i ] = (CHAR)toupper( pszName[ i ] );
    }

#ifdef XXXXNET_FEATURE_TRACE
    {
        char buffer1[256],buf[32];
        buffer1[0] = '\0';
        for (i=0; i<sizeof( szName ); ++i)
        {
            sprintf(buf," %02X", szName[i]);
            strcat(buffer1, buf);
        }
        TraceSz2( AuthVerbose, "KerbAddPrePreAuth: Name %s%s", szName, buffer1 );
    }
#endif

    //
    // Calculate ppa1
    //
    XcHMAC4(
        (BYTE *) ClientKey->keyvalue.value,
        ClientKey->keyvalue.length,
        (BYTE *) szName,
        sizeof( szName ),
        NULL,
        0,
        NULL,
        0,
        NULL,
        0,
        pPrePreAuth->ppa1, 
        20);

#ifdef XXXXNET_FEATURE_TRACE
    {
        char buffer1[256],buf[32];
        buffer1[0] = '\0';
        for (i=0; i<sizeof( pPrePreAuth->ppa1 ); ++i)
        {
            sprintf(buf," %02X", pPrePreAuth->ppa1[i]);
            strcat(buffer1, buf);
        }
        TraceSz1( AuthVerbose, "KerbAddPrePreAuth: ppa1%s", buffer1 );
    }
#endif

    //
    // Calculate ppa2
    //
    XcHMAC4(
        (BYTE *) ClientKey->keyvalue.value,
        ClientKey->keyvalue.length,
        (BYTE *) szName,
        sizeof( szName ),
        (BYTE *) szName,
        sizeof( szName ),
        NULL,
        0,
        NULL,
        0,
        abPPA2,
        20);

    KerbGetCurrentTime((PTimeStamp)&(pPrePreAuth->currentTime));

    XcSHAInit( abShaCtx );
    XcSHAUpdate( abShaCtx, abPPA2, XONLINE_PPA2_STORAGE_LENGTH );
    XcSHAUpdate( abShaCtx, (BYTE*)&(pPrePreAuth->currentTime), sizeof( pPrePreAuth->currentTime ) );
    XcSHAFinal( abShaCtx, pPrePreAuth->sppa2 );

#ifdef XXXXNET_FEATURE_TRACE
    {
        char buffer1[256],buf[32];
        buffer1[0] = '\0';
        for (i=0; i<sizeof( pPrePreAuth->currentTime ); ++i)
        {
            sprintf(buf," %02X", ((BYTE*)(&(pPrePreAuth->currentTime)))[i]);
            strcat(buffer1, buf);
        }
        TraceSz1( AuthVerbose, "KerbAddPrePreAuth: time%s", buffer1 );

        buffer1[0] = '\0';
        for (i=0; i<sizeof( pPrePreAuth->sppa2 ); ++i)
        {
            sprintf(buf," %02X", pPrePreAuth->sppa2[i]);
            strcat(buffer1, buf);
        }
        TraceSz1( AuthVerbose, "KerbAddPrePreAuth: sppa2%s", buffer1 );
    }
#endif

    //
    // Fill in remaining preauth fields, and put in list
    //
    ListElement->value.preauth_data_type = KRB5_PADATA_XBOX_PPA;
    ListElement->value.preauth_data.length = sizeof(XKERB_PA_XBOX_PPA);
    ListElement->value.preauth_data.value = (BYTE*)pPrePreAuth;
    ListElement->next = *PreAuthData;
    *PreAuthData = ListElement;

Cleanup:
    if (Status != STATUS_SUCCESS)
    {
        TraceSz1( AuthWarn, "KerbAddPrePreAuth failure status 0x%X", Status );
    }
    return(Status);
}


//+-------------------------------------------------------------------------
// Add the xenon preauth to pre-pre-auth this client
//+-------------------------------------------------------------------------

NTSTATUS
KerbAddXenonPrePreAuth(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN const BYTE* pCertHash,
    IN DWORD pbCertHash,
    IN OUT PKERB_PA_DATA_LIST * PreAuthData
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_PA_DATA_LIST ListElement;
    PXKERB_PA_XENON_PPA pPrePreAuth;
    int i;

    Assert(pbCertHash == XONLINE_PPA_HASH_SIZE);

    ListElement = (PKERB_PA_DATA_LIST) pScratchMemoryAllocator->Alloc(sizeof(KERB_PA_DATA_LIST));
    if (ListElement == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    pPrePreAuth = (PXKERB_PA_XENON_PPA) pScratchMemoryAllocator->Alloc(sizeof(XKERB_PA_XENON_PPA));
    if (pPrePreAuth == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //fill in the preauth data
    memcpy(pPrePreAuth->abConsoleCertHash, pCertHash, pbCertHash);

    //
    // Fill in remaining preauth fields, and put in list
    //
    ListElement->value.preauth_data_type = KRB5_PADATA_XENON_PPA;
    ListElement->value.preauth_data.length = sizeof(XKERB_PA_XENON_PPA);
    ListElement->value.preauth_data.value = (BYTE*)pPrePreAuth;
    ListElement->next = *PreAuthData;
    *PreAuthData = ListElement;

Cleanup:
    if (Status != STATUS_SUCCESS)
    {
        TraceSz1( AuthWarn, "KerbAddXenonPrePreAuth failure status 0x%X", Status );
    }
    return(Status);
}



//+-------------------------------------------------------------------------
// Add the Echo preauth to this request
//+-------------------------------------------------------------------------

NTSTATUS
KerbAddEchoPreAuth(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN DWORD cbEchoPreAuth,
    IN BYTE* EchoPreAuth,
    IN OUT PKERB_PA_DATA_LIST * PreAuthData
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_PA_DATA_LIST ListElement;
    BYTE* pEchoPreAuth;

    ListElement = (PKERB_PA_DATA_LIST) pScratchMemoryAllocator->Alloc(sizeof(KERB_PA_DATA_LIST));
    if (ListElement == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    pEchoPreAuth = (BYTE*)pScratchMemoryAllocator->Alloc(cbEchoPreAuth);
    if (pEchoPreAuth == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    memcpy( pEchoPreAuth, EchoPreAuth, cbEchoPreAuth );

    //
    // Fill in remaining preauth fields, and put in list
    //
    ListElement->value.preauth_data_type = KRB5_PADATA_XBOX_ECHO;
    ListElement->value.preauth_data.length = cbEchoPreAuth;
    ListElement->value.preauth_data.value = pEchoPreAuth;
    ListElement->next = *PreAuthData;
    *PreAuthData = ListElement;

Cleanup:
    if (Status != STATUS_SUCCESS)
    {
        TraceSz1( AuthWarn, "KerbAddEchoPreAuth failure status 0x%X", Status );
    }
    return(Status);
}

//+-------------------------------------------------------------------------
// Add the preauth to tell the server this is an Xbox
//+-------------------------------------------------------------------------

NTSTATUS
KerbAddClientVersionPreAuth(
    IN const TitleInfo* pInfo,
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN const KERB_ENCRYPTION_KEY* ClientKey,
    IN DWORD nonce,
    IN OUT PKERB_PA_DATA_LIST * PreAuthData
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_PA_DATA_LIST ListElement;
    DWORD dwVersionStringLen;
    BYTE abNonceHmacKey[XONLINE_KEY_LENGTH];
    KERB_ENCRYPTION_KEY NonceHmacKey;
    PXKERB_PA_XBOX_CLIENT_VERSION pClientVersion;

    ListElement = (PKERB_PA_DATA_LIST) pScratchMemoryAllocator->Alloc(sizeof(KERB_PA_DATA_LIST));
    if (ListElement == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    pClientVersion = (PXKERB_PA_XBOX_CLIENT_VERSION) pScratchMemoryAllocator->Alloc(sizeof(XKERB_PA_XBOX_CLIENT_VERSION));
    if (pClientVersion == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    {
        CReleaseAllScratchMemoryUponDestruction onlyPreserveThisMemory( pScratchMemoryAllocator );

        KerbComputeKdcRequestNonceHmacKey(
            pScratchMemoryAllocator,
            ClientKey,
            nonce,
            abNonceHmacKey
            );

        KerbCreateKeyFromBuffer(
            &NonceHmacKey,
            abNonceHmacKey,
            XONLINE_KEY_LENGTH,
            KERB_ETYPE_RC4_HMAC_NT
            );

        //
        // Now build the client version string
        //
        dwVersionStringLen = _snprintf(pClientVersion->acVersionString, sizeof(pClientVersion->acVersionString), "Xbox Version=%s Title=0x%08X TitleVersion=%d",
                                     pInfo->pszXboxVersion, pInfo->dwTitleId, pInfo->dwTitleVersion) + 1;
        if ((int)(dwVersionStringLen) < 0)
        {
            AssertSz(FALSE, "Insufficient string buffer for client version string!");
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        Assert( dwVersionStringLen <= XONLINE_MAX_CLIENT_VERSION_SIZE );

        //
        // Calculate the signature
        //
        XcHMAC4(
            (BYTE *) NonceHmacKey.keyvalue.value,
            NonceHmacKey.keyvalue.length,
            (BYTE *) pClientVersion->acVersionString,
            dwVersionStringLen,
            NULL,
            0,
            NULL,
            0,
            NULL,
            0,
            pClientVersion->abSignature,
            20);

        ListElement->value.preauth_data.value = (BYTE*)pClientVersion;
        ListElement->value.preauth_data.length = XONLINE_CLIENT_VERSION_SIGNATURE_SIZE + dwVersionStringLen;
    }

    //
    // Fill in remaining preauth fields, and put in list
    //
    ListElement->value.preauth_data_type = KRB5_PADATA_XBOX_CLIENT_VERSION;
    ListElement->next = *PreAuthData;
    *PreAuthData = ListElement;

Cleanup:
    if (Status != STATUS_SUCCESS)
    {
        TraceSz1( AuthWarn, "KerbAddClientVersionPreAuth failure status 0x%X", Status );
    }
    return(Status);
}

//--------------------------------------------------------------------------

NTSTATUS
KerbAddCompoundIdentityPreAuth(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PXKERB_TGT_CONTEXT pSingleTGTContext,
    IN OUT PKERB_PA_DATA_LIST * PreAuthData
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_PA_DATA_LIST ListElement;
    PKERB_TICKET pTicket;
    PKERB_PA_COMPOUND_IDENTITY TicketList;

    Assert(pScratchMemoryAllocator != NULL);
    Assert(pSingleTGTContext != NULL);
    Assert(PreAuthData != NULL);

    ListElement = (PKERB_PA_DATA_LIST) pScratchMemoryAllocator->Alloc(sizeof(KERB_PA_DATA_LIST));
    if (ListElement == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    {
        CReleaseAllScratchMemoryUponDestruction onlyPreserveThisMemory( pScratchMemoryAllocator );

        //
        // Reconstruct kerb ticket structure from packed data
        //
        pTicket = NULL;
        KerbErr = KerbUnpackData(
                    pScratchMemoryAllocator,
                    pSingleTGTContext->Ticket,
                    pSingleTGTContext->dwTicketLength,
                    KERB_TICKET_PDU,
                    (PVOID*)&pTicket
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        //
        // Allocate memory for the element in the ticket list.
        //
        TicketList = (PKERB_PA_COMPOUND_IDENTITY)pScratchMemoryAllocator->Alloc(sizeof(KERB_PA_COMPOUND_IDENTITY_Element));
        if (TicketList == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        //
        // Stick the ticket into the ticket list.
        //
        TicketList->value = *pTicket;
        TicketList->next = NULL;

        KerbErr = KerbPackData(pScratchMemoryAllocator,
                               &TicketList,
                               KERB_PA_COMPOUND_IDENTITY_PDU,
                               &ListElement->value.preauth_data.length,
                               &ListElement->value.preauth_data.value);
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto    Cleanup;
        }

        //
        // Preserve the only piece of memory we care about
        //
        PreserveThisMemory( &onlyPreserveThisMemory, &ListElement->value.preauth_data.value, ListElement->value.preauth_data.length );
    }

    ListElement->value.preauth_data_type = KRB5_PADATA_COMPOUND_IDENTITY;
    ListElement->next = *PreAuthData;
    *PreAuthData = ListElement;

Cleanup:
    if (Status != STATUS_SUCCESS)
    {
        TraceSz1( AuthWarn, "KerbAddCompoundIdentityPreAuth failure status 0x%X", Status );
    }
    return(Status);
}

//--------------------------------------------------------------------------

void KerbComputeCompoundIdentityKey(
    IN const KERB_ENCRYPTION_KEY* pClientKey,
    IN const XKERB_TGT_CONTEXT* pSingleTGTContext,
    OUT PBYTE pCompoundKey
    )
{
    MD5_CTX Md5Context;
    UCHAR Key[MD5_LEN];
    ULONG ulSalt = KERB_PA_COMPOUND_IDENTITY_SALT;

    Assert(MD5_LEN == XONLINE_KEY_LENGTH);
    Assert(MD5_LEN == pClientKey->keyvalue.length);
    Assert (pSingleTGTContext != NULL);

    md5Hmac(
        pClientKey->keyvalue.value,
        pClientKey->keyvalue.length,
        (PBYTE)"signaturekey",
        sizeof("signaturekey"),
        NULL,
        0,
        Key
        );

    MD5Init(&Md5Context);
    MD5Update(&Md5Context, (PUCHAR)&ulSalt, sizeof(ulSalt));

    MD5Update(&Md5Context, pSingleTGTContext->SessionKey, sizeof(pSingleTGTContext->SessionKey));

    MD5Final(&Md5Context);

    md5Hmac(
        Key,
        MD5_LEN,
        Md5Context.digest,
        MD5_LEN,
        NULL,
        0,
        pCompoundKey
        );
}


//--------------------------------------------------------------------------


NTSTATUS
KerbAddXenonServiceRequest2PreAuth(
    IN const TitleInfo* pInfo,
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN const KERB_ENCRYPTION_KEY* ClientKey,
    IN const XKERB_TGT_CONTEXT* pCombinedTGTContext,
    IN DWORD nonce,
    IN const XKERB_SERVICE_CONTEXT* pXKerbServiceContext_in,
    IN OUT PKERB_PA_DATA_LIST* PreAuthData
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_PA_DATA_LIST ListElement = NULL;
    PXKERB_PA_XENON_SERVICE_REQUEST2 pXenonServicePreAuth;
    BYTE abNonceHmacKey[XONLINE_KEY_LENGTH];
    KERB_ENCRYPTION_KEY NonceHmacKey;
    KERB_ENCRYPTED_DATA EncryptedData;
    DWORD i;

    ZeroMemory( &EncryptedData, sizeof(KERB_ENCRYPTED_DATA) );

    C_ASSERT( sizeof(XKERB_SERVICE_CONTEXT) == sizeof(XKERB_SERVICE_CONTEXT2) );
    C_ASSERT( FIELD_OFFSET(XKERB_SERVICE_CONTEXT, StartTime) == FIELD_OFFSET(XKERB_SERVICE_CONTEXT2, StartTime) );
    C_ASSERT( FIELD_OFFSET(XKERB_SERVICE_CONTEXT, ctNumNonces) == FIELD_OFFSET(XKERB_SERVICE_CONTEXT2, ctNumNonces) );
    C_ASSERT( FIELD_OFFSET(XKERB_SERVICE_CONTEXT, siteIPAddress) == FIELD_OFFSET(XKERB_SERVICE_CONTEXT2, siteIPAddress) );
    C_ASSERT( FIELD_OFFSET(XKERB_SERVICE_CONTEXT, StartTime) == FIELD_OFFSET(XKERB_SERVICE_CONTEXT_XE, StartTime) );
    C_ASSERT( FIELD_OFFSET(XKERB_SERVICE_CONTEXT, ctNumNonces) == FIELD_OFFSET(XKERB_SERVICE_CONTEXT_XE, ctNumNonces) );
    C_ASSERT( FIELD_OFFSET(XKERB_SERVICE_CONTEXT, siteIPAddress) == FIELD_OFFSET(XKERB_SERVICE_CONTEXT_XE, siteIPAddress) );

    PXKERB_SERVICE_CONTEXT_XE pXKerbServiceContext = (PXKERB_SERVICE_CONTEXT_XE)pXKerbServiceContext_in;
    Assert( pXKerbServiceContext->dwXenonFlag == XENON_SERVICE_CONTEXT_FLAG );

    pXenonServicePreAuth = (PXKERB_PA_XENON_SERVICE_REQUEST2)_alloca( sizeof(XKERB_PA_XENON_SERVICE_REQUEST2) );

    ZeroMemory( pXenonServicePreAuth, sizeof(XKERB_PA_XENON_SERVICE_REQUEST2) );

    ListElement = (PKERB_PA_DATA_LIST) pScratchMemoryAllocator->Alloc(sizeof(KERB_PA_DATA_LIST));
    if (ListElement == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    {
        CReleaseAllScratchMemoryUponDestruction onlyPreserveThisMemory( pScratchMemoryAllocator );

        //
        // Fill in info to the struct
        //
        const WORD XONLINE_SERVICE_REQUEST_VERSION = 4;
        pXenonServicePreAuth->wServiceRequestVersion = XONLINE_SERVICE_REQUEST_VERSION;

        if (pInfo->wOverrideDefaultServiceRequest)
        {
            pXenonServicePreAuth->wServiceRequestVersion = pInfo->wOverrideDefaultServiceRequestVersion;
        }

        pXenonServicePreAuth->wServiceRequestSize = sizeof(XKERB_PA_XENON_SERVICE_REQUEST2);
        pXenonServicePreAuth->clientVersion = pInfo->clientVersion;
        pXenonServicePreAuth->dwFlashVersion = pInfo->dwFlashVersion;
        pXenonServicePreAuth->dwTitleID = pInfo->dwTitleId;
        pXenonServicePreAuth->dwTitleVersion = pInfo->dwTitleVersion;
        pXenonServicePreAuth->dwTitleRegion = pInfo->dwTitleGameRegion;
        pXenonServicePreAuth->dwConsoleRegion = pXKerbServiceContext->dwConsoleRegion;
        pXenonServicePreAuth->dwMediaID = pXKerbServiceContext->dwMediaID;
        pXenonServicePreAuth->wLanguageID = pXKerbServiceContext->wLanguageID;
        pXenonServicePreAuth->wAutoDiscoverServices = pXKerbServiceContext->wAutoDiscoverServices;

        WORD wNumByteServices = 0;
        WORD wNumDwordServices = 0;

        for (i=0; i < XONLINE_XE_MAX_BYTE_SERVICEIDS; i++)
        {
            if ( 0 == pXKerbServiceContext->bServiceID3[i] )
            {
                continue;
            }

            pXenonServicePreAuth->bServiceID[wNumByteServices++] = pXKerbServiceContext->bServiceID3[i];
        }

        for (i=0; i < XONLINE_MAX_DWORD_SERVICEIDS; i++)
        {
            if ( 0 == pXKerbServiceContext->dwServiceID3[i] )
            {
                continue;
            }

            pXenonServicePreAuth->dwServiceID[wNumDwordServices++] = pXKerbServiceContext->dwServiceID3[i];
        }

        // TODO:
        // wNumByteServies + wNumDwordService should equal pXKerbServiceContext->dwNumServices
        // Is this 100% always true?  Need assert() here?
        pXenonServicePreAuth->wNumByteServices = wNumByteServices;
        pXenonServicePreAuth->wNumDwordServices = wNumDwordServices;

        for (i=0; i<XONLINE_MAX_LOGON_USERS; ++i)
        {
            if (pXKerbServiceContext->UserID[i] != 0)
            {
                pXenonServicePreAuth->qwUserID[i] = pXKerbServiceContext->UserID[i];
            }
            else
            {
                pXenonServicePreAuth->qwUserID[i] = pCombinedTGTContext->UserID[i];
            }
        }


#ifdef XNET_FEATURE_TRACE
        {
            char buffer1[(XONLINE_XE_MAX_BYTE_SERVICEIDS + XONLINE_MAX_DWORD_SERVICEIDS)*40];
            char buf[16];
            DWORD k;
            buffer1[0] = '\0';

            if (pXenonServicePreAuth->wAutoDiscoverServices)
            {
                strcat(buffer1, "<auto>");
            }
            else
            {
                for (k=0; k < pXenonServicePreAuth->wNumByteServices; ++k)
                {
                    sprintf(buf," %d", pXenonServicePreAuth->bServiceID[k]);
                    strcat(buffer1, buf);
                }
                for (k=0; k < pXenonServicePreAuth->wNumDwordServices; ++k)
                {
                    sprintf(buf," %d", pXenonServicePreAuth->dwServiceID[k]);
                    strcat(buffer1, buf);
                }
            }

            TraceSz8( AuthVerbose, "KerbAddXenonServiceRequest2PreAuth packed Title:0x%X:%d:0x%X User: 0x%016I64X 0x%016I64X 0x%016I64X 0x%016I64X Service:%s",
                pXenonServicePreAuth->dwTitleID,
                pXenonServicePreAuth->dwTitleVersion,
                pXenonServicePreAuth->dwTitleRegion,
                pXenonServicePreAuth->qwUserID[0],
                pXenonServicePreAuth->qwUserID[1],
                pXenonServicePreAuth->qwUserID[2],
                pXenonServicePreAuth->qwUserID[3],
                buffer1 );
        }
#endif

        //
        // Compute the Nonce HMAC key
        //
        KerbComputeKdcRequestNonceHmacKey(
            pScratchMemoryAllocator,
            ClientKey,
            nonce,
            abNonceHmacKey
            );

        KerbCreateKeyFromBuffer(
            &NonceHmacKey,
            abNonceHmacKey,
            XONLINE_KEY_LENGTH,
            KERB_ETYPE_RC4_HMAC_NT
            );

        //
        // Encrypt the pre-auth
        //
        KerbErr = KerbAllocateEncryptionBuffer(
                    pScratchMemoryAllocator,
                    NonceHmacKey.keytype,
                    sizeof(XKERB_PA_XENON_SERVICE_REQUEST2),
                    &EncryptedData.cipher_text.length,
                    &EncryptedData.cipher_text.value
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = KerbMapKerbError(KerbErr);
            goto Cleanup;
        }

        KerbErr = KerbEncryptDataEx(
                    pScratchMemoryAllocator,
                    &EncryptedData,
                    sizeof(XKERB_PA_XENON_SERVICE_REQUEST2),
                    (PUCHAR)pXenonServicePreAuth,
                    NonceHmacKey.keytype,
                    KERB_PA_XBOX_SERVICE_REQUEST_SALT,
                    &NonceHmacKey
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        //
        // Now pack the encrypted data
        //
        KerbErr = KerbPackEncryptedData(
                    pScratchMemoryAllocator,
                    &EncryptedData,
                    (PULONG) &ListElement->value.preauth_data.length,
                    (PUCHAR *) &ListElement->value.preauth_data.value
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        //
        // Preserve the only piece of memory we care about
        //
        PreserveThisMemory( &onlyPreserveThisMemory, &ListElement->value.preauth_data.value, ListElement->value.preauth_data.length );
    }

    ListElement->value.preauth_data_type = KRB5_PADATA_XENON_SERVICE_REQUEST2;
    ListElement->next = *PreAuthData;
    *PreAuthData = ListElement;

Cleanup:
    if (Status != STATUS_SUCCESS)
    {
        TraceSz1( AuthWarn, "KerbAddXenonServiceRequest2PreAuth failure status 0x%X", Status );
    }
    return(Status);
}

//------------
NTSTATUS
KerbAddXenonServiceRequest3PreAuth(
    IN const TitleInfo* pInfo,
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN const KERB_ENCRYPTION_KEY* ClientKey,
    IN const XKERB_TGT_CONTEXT* pCombinedTGTContext,
    IN DWORD nonce,
    IN const XKERB_SERVICE_CONTEXT* pXKerbServiceContext_in,
    IN OUT PKERB_PA_DATA_LIST* PreAuthData
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_PA_DATA_LIST ListElement = NULL;
    XKERB_PA_XENON_SERVICE_REQUEST3 *pXenonServicePreAuth;
    BYTE abNonceHmacKey[XONLINE_KEY_LENGTH];
    KERB_ENCRYPTION_KEY NonceHmacKey;
    KERB_ENCRYPTED_DATA EncryptedData;
    DWORD i;

    ZeroMemory( &EncryptedData, sizeof(KERB_ENCRYPTED_DATA) );

    C_ASSERT( sizeof(XKERB_SERVICE_CONTEXT) == sizeof(XKERB_SERVICE_CONTEXT2) );
    C_ASSERT( FIELD_OFFSET(XKERB_SERVICE_CONTEXT, StartTime) == FIELD_OFFSET(XKERB_SERVICE_CONTEXT2, StartTime) );
    C_ASSERT( FIELD_OFFSET(XKERB_SERVICE_CONTEXT, ctNumNonces) == FIELD_OFFSET(XKERB_SERVICE_CONTEXT2, ctNumNonces) );
    C_ASSERT( FIELD_OFFSET(XKERB_SERVICE_CONTEXT, siteIPAddress) == FIELD_OFFSET(XKERB_SERVICE_CONTEXT2, siteIPAddress) );
    C_ASSERT( FIELD_OFFSET(XKERB_SERVICE_CONTEXT, StartTime) == FIELD_OFFSET(XKERB_SERVICE_CONTEXT_XE, StartTime) );
    C_ASSERT( FIELD_OFFSET(XKERB_SERVICE_CONTEXT, ctNumNonces) == FIELD_OFFSET(XKERB_SERVICE_CONTEXT_XE, ctNumNonces) );
    C_ASSERT( FIELD_OFFSET(XKERB_SERVICE_CONTEXT, siteIPAddress) == FIELD_OFFSET(XKERB_SERVICE_CONTEXT_XE, siteIPAddress) );

    PXKERB_SERVICE_CONTEXT_XE pXKerbServiceContext = (PXKERB_SERVICE_CONTEXT_XE)pXKerbServiceContext_in;
    Assert( pXKerbServiceContext->dwXenonFlag == XENON_SERVICE_CONTEXT_FLAG );

    pXenonServicePreAuth = (PXKERB_PA_XENON_SERVICE_REQUEST3)_alloca( sizeof(XKERB_PA_XENON_SERVICE_REQUEST3) );

    ZeroMemory( pXenonServicePreAuth, sizeof(XKERB_PA_XENON_SERVICE_REQUEST3) );

    ListElement = (PKERB_PA_DATA_LIST) pScratchMemoryAllocator->Alloc(sizeof(KERB_PA_DATA_LIST));
    if (ListElement == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    {
        CReleaseAllScratchMemoryUponDestruction onlyPreserveThisMemory( pScratchMemoryAllocator );

        //
        // Fill in info to the struct
        //
        pXenonServicePreAuth->wServiceRequestVersion = 5;

        if (pInfo->wOverrideDefaultServiceRequest)
        {
            pXenonServicePreAuth->wServiceRequestVersion = pInfo->wOverrideDefaultServiceRequestVersion;
        }

        pXenonServicePreAuth->clientVersion = pInfo->clientVersion;
        pXenonServicePreAuth->dwFlashVersion = pInfo->dwFlashVersion;
        pXenonServicePreAuth->dwTitleID = pInfo->dwTitleId;
        pXenonServicePreAuth->dwTitleVersion = pInfo->dwTitleVersion;
        pXenonServicePreAuth->dwTitleRegion = pInfo->dwTitleGameRegion;
        pXenonServicePreAuth->dwConsoleRegion = pXKerbServiceContext->dwConsoleRegion;
        pXenonServicePreAuth->dwMediaID = pXKerbServiceContext->dwMediaID;
        pXenonServicePreAuth->wLanguageID = pXKerbServiceContext->wLanguageID;
        pXenonServicePreAuth->wAutoDiscoverServices = pXKerbServiceContext->wAutoDiscoverServices;

        for (i=0; i < XONLINE_XE_MAX_BYTE_SERVICEIDS_2; i++)
        {
            unsigned int service;
            if (i<XONLINE_XE_MAX_BYTE_SERVICEIDS) //pull it from the first block of 32
            {
                service=pXKerbServiceContext->bServiceID3[i];
            }
            else //pull it from the last block of 96
            {
                service=pXKerbServiceContext->bServiceID4[i-XONLINE_XE_MAX_BYTE_SERVICEIDS];
            }

            if (service<128)
            {
                unsigned int byte=service/8;
                unsigned int bit=service%8;
                pXenonServicePreAuth->bServiceIDBits[byte]|=1<<bit;
            }
            else
            {
                TraceSz1( AuthWarn, "KerbAddXenonServiceRequest3PreAuth unable to represent request for service %d", pXKerbServiceContext->bServiceID3[i] );
            }
        }

        WORD wNumDwordServices = 0;
        for (i=0; i < XONLINE_MAX_DWORD_SERVICEIDS; i++)
        {
            if ( 0 == pXKerbServiceContext->dwServiceID3[i] )
            {
                continue;
            }

            pXenonServicePreAuth->dwServiceID[wNumDwordServices++] = pXKerbServiceContext->dwServiceID3[i];
        }

        for (i=0; i<XONLINE_MAX_LOGON_USERS; ++i)
        {
            if (pXKerbServiceContext->UserID[i] != 0)
            {
                pXenonServicePreAuth->qwUserID[i] = pXKerbServiceContext->UserID[i];
            }
            else
            {
                pXenonServicePreAuth->qwUserID[i] = pCombinedTGTContext->UserID[i];
            }
        }

        for (i=0; i<XONLINE_MAX_LOGON_USERS; ++i)
        {
            pXenonServicePreAuth->dwReservedForUserPINInTheFuture[i]=pXKerbServiceContext->UserPins[i];
        }

        pXenonServicePreAuth->flowToken.flowToken=pXKerbServiceContext->FlowToken;

        //
        // Compute the Nonce HMAC key
        //
        KerbComputeKdcRequestNonceHmacKey(
            pScratchMemoryAllocator,
            ClientKey,
            nonce,
            abNonceHmacKey
            );

        KerbCreateKeyFromBuffer(
            &NonceHmacKey,
            abNonceHmacKey,
            XONLINE_KEY_LENGTH,
            KERB_ETYPE_RC4_HMAC_NT
            );

        //
        // Encrypt the pre-auth
        //
        KerbErr = KerbAllocateEncryptionBuffer(
                    pScratchMemoryAllocator,
                    NonceHmacKey.keytype,
                    sizeof(XKERB_PA_XENON_SERVICE_REQUEST3),
                    &EncryptedData.cipher_text.length,
                    &EncryptedData.cipher_text.value
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = KerbMapKerbError(KerbErr);
            goto Cleanup;
        }

        KerbErr = KerbEncryptDataEx(
                    pScratchMemoryAllocator,
                    &EncryptedData,
                    sizeof(XKERB_PA_XENON_SERVICE_REQUEST3),
                    (PUCHAR)pXenonServicePreAuth,
                    NonceHmacKey.keytype,
                    KERB_PA_XBOX_SERVICE_REQUEST_SALT,
                    &NonceHmacKey
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        //
        // Now pack the encrypted data
        //
        KerbErr = KerbPackEncryptedData(
                    pScratchMemoryAllocator,
                    &EncryptedData,
                    (PULONG) &ListElement->value.preauth_data.length,
                    (PUCHAR *) &ListElement->value.preauth_data.value
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        //
        // Preserve the only piece of memory we care about
        //
        PreserveThisMemory( &onlyPreserveThisMemory, &ListElement->value.preauth_data.value, ListElement->value.preauth_data.length );
    }

    ListElement->value.preauth_data_type = KRB5_PADATA_XENON_SERVICE_REQUEST3;
    ListElement->next = *PreAuthData;
    *PreAuthData = ListElement;

Cleanup:
    if (Status != STATUS_SUCCESS)
    {
        TraceSz1( AuthWarn, "KerbAddXenonServiceRequest3PreAuth failure status 0x%X", Status );
    }
    return(Status);
}

//------------

NTSTATUS
KerbAddXenonMacPreAuth(
    IN XE_CONSOLE_CERTIFICATE *pConsoleCert,
    IN BOOL bUseTestXmacsKey,
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    KERB_ENCRYPTION_KEY* pClientKey,
    IN PTimeStamp pAuthTime,
    IN OUT PKERB_PA_DATA_LIST * PreAuthData
    )
{
    NTSTATUS Status = E_FAIL;
    PKERB_PA_DATA_LIST ListElement;
    XKERB_PA_XENON_MAC_REQUEST* pXeMacPa = NULL;
    BYTE abSha[XC_DIGEST_LEN];
    DWORD cb;

    ListElement = (PKERB_PA_DATA_LIST) pScratchMemoryAllocator->Alloc(sizeof(KERB_PA_DATA_LIST));
    if (ListElement == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    pXeMacPa = (XKERB_PA_XENON_MAC_REQUEST*) pScratchMemoryAllocator->Alloc(sizeof(XKERB_PA_XENON_MAC_REQUEST));
    if(NULL == pXeMacPa)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    // Add encrypted session key
    if (sizeof(pXeMacPa->abEncSessionKey) < pClientKey->keyvalue.length)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    memcpy(pXeMacPa->abEncSessionKey, pClientKey->keyvalue.value, pClientKey->keyvalue.length);
    cb = pClientKey->keyvalue.length;

    if (bUseTestXmacsKey)
    {
        if(!g_ClientCrypt.EncryptWithXmacsTestKey(pXeMacPa->abEncSessionKey, &cb, sizeof(pXeMacPa->abEncSessionKey)))
        {
            TraceSz(AuthWarn, "Failed to encrypt session key with test key");
            Status = STATUS_ENCRYPTION_FAILED;
            goto Cleanup;    
        }
    }
    else
    {
        if(!g_ClientCrypt.EncryptWithXmacsKey(pXeMacPa->abEncSessionKey, &cb, sizeof(pXeMacPa->abEncSessionKey)))
        {
            TraceSz(AuthWarn, "Failed to encrypt session key");
            Status = STATUS_ENCRYPTION_FAILED;
            goto Cleanup;    
        }
    }
    Assert(cb == sizeof(pXeMacPa->abEncSessionKey));

    // Authtime
    pXeMacPa->qwAuthtime = pAuthTime->QuadPart;
    
    // Sha1(Session-Key)
    XcSHA(abSha, sizeof(abSha), pClientKey->keyvalue.value, 
          pClientKey->keyvalue.length, NULL, 0, NULL, 0);

    // Sign(Authtime || Sha1(Session-key))
    XcSHA(abSha, sizeof(abSha), (BYTE*)&pXeMacPa->qwAuthtime, 
          sizeof(pXeMacPa->qwAuthtime), abSha, sizeof(abSha), NULL, 0);
    cb = sizeof(pXeMacPa->abSignAtSk);
    if(!g_ClientCrypt.SignWithConsoleKey(abSha, sizeof(abSha), pXeMacPa->abSignAtSk, &cb))
    {
        TraceSz(AuthWarn, "Failed to sign authtime + sha1(sessionkey)");
        Status = STATUS_ENCRYPTION_FAILED;
        goto Cleanup;
    }
    Assert(cb == sizeof(pXeMacPa->abSignAtSk));

    // Console cert
    cb = sizeof(pXeMacPa->ConsoleCert);
    memcpy(&pXeMacPa->ConsoleCert, pConsoleCert, cb); 
    
    ListElement->value.preauth_data_type = KRB5_PADATA_XENON_MAC_REQUEST;
    ListElement->value.preauth_data.value = (BYTE*)pXeMacPa;
    ListElement->value.preauth_data.length = sizeof(*pXeMacPa);
    ListElement->next = *PreAuthData;
    *PreAuthData = ListElement;

    //TraceBinary(ListElement->value.preauth_data.value, ListElement->value.preauth_data.length);

    Status = STATUS_SUCCESS;

Cleanup:

    if(Status != STATUS_SUCCESS)
    {
        TraceSz1(AuthWarn, "KerbAddXenonMacPreAuth failed. status = 0x%08x", Status);
    }

    return Status;
}

//--------------------------------------------------------------------------

NTSTATUS
KerbAddXenonMac2PreAuth(
    IN XE_CONSOLE_CERTIFICATE *pConsoleCert,
    IN BOOL bUseTestXmacsKey,
    IN CScratchMemoryAllocator *pScratchMemoryAllocator,
    KERB_ENCRYPTION_KEY *pClientKey,
    IN PTimeStamp pAuthTime,
    IN OUT PKERB_PA_DATA_LIST *PreAuthData,
    IN BYTE *pSerialNumber //this be a 12 byte serial number blob
    )
{
    NTSTATUS Status = E_FAIL;
    PKERB_PA_DATA_LIST ListElement;
    XKERB_PA_XENON_MAC_REQUEST2* pXeMacPa = NULL;
    BYTE abSha[XC_DIGEST_LEN];
    DWORD cb;

    ListElement = (PKERB_PA_DATA_LIST) pScratchMemoryAllocator->Alloc(sizeof(KERB_PA_DATA_LIST));
    if (ListElement == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    pXeMacPa = (XKERB_PA_XENON_MAC_REQUEST2*) pScratchMemoryAllocator->Alloc(sizeof(XKERB_PA_XENON_MAC_REQUEST2));
    if(NULL == pXeMacPa)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    // Add encrypted session key
    if (sizeof(pXeMacPa->abEncSessionKey) < pClientKey->keyvalue.length)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    memcpy(pXeMacPa->abEncSessionKey, pClientKey->keyvalue.value, pClientKey->keyvalue.length);
    cb = pClientKey->keyvalue.length;

    if (bUseTestXmacsKey)
    {
        if(!g_ClientCrypt.EncryptWithXmacsTestKey(pXeMacPa->abEncSessionKey, &cb, sizeof(pXeMacPa->abEncSessionKey)))
        {
            TraceSz(AuthWarn, "Failed to encrypt session key with test key");
            Status = STATUS_ENCRYPTION_FAILED;
            goto Cleanup;    
        }
    }
    else
    {
        if(!g_ClientCrypt.EncryptWithXmacsKey(pXeMacPa->abEncSessionKey, &cb, sizeof(pXeMacPa->abEncSessionKey)))
        {
            TraceSz(AuthWarn, "Failed to encrypt session key");
            Status = STATUS_ENCRYPTION_FAILED;
            goto Cleanup;    
        }
    }
    Assert(cb == sizeof(pXeMacPa->abEncSessionKey));

    // Authtime
    pXeMacPa->qwAuthtime = pAuthTime->QuadPart;

    // Console Serial Number
    memcpy(pXeMacPa->abSerialNum, pSerialNumber, XONLINE_MAX_CONSOLE_SERIAL_NUMBER_LENGTH);

    // Sha1(Session-Key)
    XcSHA(abSha, sizeof(abSha), pClientKey->keyvalue.value, 
          pClientKey->keyvalue.length, NULL, 0, NULL, 0);

    // Sign(Authtime || abSerialNum || Sha1(Session-key))
    XcSHA(abSha, sizeof(abSha), (BYTE*)&pXeMacPa->qwAuthtime, 
          sizeof(pXeMacPa->qwAuthtime), pXeMacPa->abSerialNum, 
          sizeof(pXeMacPa->abSerialNum), abSha, sizeof(abSha));
    cb = sizeof(pXeMacPa->abSignAtSk);
    if(!g_ClientCrypt.SignWithConsoleKey(abSha, sizeof(abSha), pXeMacPa->abSignAtSk, &cb))
    {
        TraceSz(AuthWarn, "Failed to sign authtime + sha1(sessionkey)");
        Status = STATUS_ENCRYPTION_FAILED;
        goto Cleanup;
    }
    Assert(cb == sizeof(pXeMacPa->abSignAtSk));

    // Console cert
    cb = sizeof(pXeMacPa->ConsoleCert);
    memcpy(&pXeMacPa->ConsoleCert, pConsoleCert, cb); 
    
    ListElement->value.preauth_data_type = KRB5_PADATA_XENON_MAC_REQUEST2;
    ListElement->value.preauth_data.value = (BYTE*)pXeMacPa;
    ListElement->value.preauth_data.length = sizeof(*pXeMacPa);
    ListElement->next = *PreAuthData;
    *PreAuthData = ListElement;

    //TraceBinary(ListElement->value.preauth_data.value, ListElement->value.preauth_data.length);

    Status = STATUS_SUCCESS;

Cleanup:

    if(Status != STATUS_SUCCESS)
    {
        TraceSz1(AuthWarn, "KerbAddXenonMacPreAuth2 failed. status = 0x%08x", Status);
    }

    return Status;
}

//--------------------------------------------------------------------------

NTSTATUS WINAPI
KerbAddFakeTypePreauth(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN ASN1int32_t patType,
    IN OUT PKERB_PA_DATA_LIST *PreAuthData
    )
{
    //setup
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_PA_DATA_LIST ListElement;

    ListElement = (PKERB_PA_DATA_LIST) pScratchMemoryAllocator->Alloc(sizeof(KERB_PA_DATA_LIST));
    if (ListElement == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //insert our fake values
    BYTE *someMem = (BYTE*)pScratchMemoryAllocator->Alloc(64);
    if (someMem == 0)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    memset(someMem,0xfe,64);

    ListElement->value.preauth_data_type = patType;
    ListElement->value.preauth_data.value = someMem;
    ListElement->value.preauth_data.length = 64;

    //
    ListElement->next = *PreAuthData;
    *PreAuthData = ListElement;

    //
Cleanup:
    if(Status != STATUS_SUCCESS)
    {
        TraceSz1(AuthWarn, "KerbAddFakeTypePreauth failed. status = 0x%08x", Status);
    }

    return Status;
}

//--------------------------------------------------------------------------

//Handles adding preauth type common to the different services to a preauth data list
//returns true if it was handled, false otherwise
bool AddSharedPreauthToPAList(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,  //required
    IN ASN1int32_t patType,  //required
    IN KERB_ENCRYPTION_KEY *pCompoundKey,
    IN const TitleInfo* pInfo,
    IN const AsRequestInfo* pAsRequestInfo,
    IN bool bIsTgsRequest,
    IN KERB_ENCRYPTION_KEY *pClientKey,
    IN PKERB_KDC_REQUEST_BODY pRequestBody,
    IN KERB_ENCRYPTION_KEY *pSessionKey,
    IN PXKERB_TGT_CONTEXT pCombinedTGTContext,
    IN OUT PXKERB_SERVICE_CONTEXT pXKerbServiceContext,
    OUT IN KERB_KDC_REQUEST *pTicketRequest,  //required
    OUT NTSTATUS *pStatus  //required
                                     )
{
    *pStatus = STATUS_SUCCESS;

    //
    if (patType==KRB5_PADATA_ENC_TIMESTAMP)
    {
        if (pCompoundKey || pClientKey)
        {
            // Get time for Timestamp Preauth
            TimeStamp authTime;
            KerbGetCurrentTime(&authTime);

            // use compound if it's there, else use client
            KERB_ENCRYPTION_KEY *pKeyToUse=pCompoundKey;
            if (!pKeyToUse)
            {
                pKeyToUse=pClientKey;
            }

            // Add the standard timestamp pre-auth
            *pStatus = KerbAddTimestampPreAuth(
                pScratchMemoryAllocator,
                pKeyToUse,
                &authTime,
                &pTicketRequest->KERB_KDC_REQUEST_preauth_data
                );
            return true;
        }
    }
    else if (patType==KRB5_PADATA_PAC_REQUEST || patType==KRB5_PADATA_PAC_REQUEST_EX)
    {
        // Add the preauth to tell the server whether to include the windows PUID PAC in authdata.
        bool includePac=true;
        if (bIsTgsRequest) //don't include it for TGS requests
        {
            includePac=false;
        }

        *pStatus = KerbAddPacRequestPreAuth(
            pScratchMemoryAllocator,
            includePac,
            &pTicketRequest->KERB_KDC_REQUEST_preauth_data
            );
        return true;
    }
    else if (patType==KRB5_PADATA_XBOX_CLIENT_VERSION)
    {
        if (pInfo && pClientKey && pRequestBody)
        {
            // Add special Xbox client version Pre-auth data
            *pStatus = KerbAddClientVersionPreAuth(
                pInfo,
                pScratchMemoryAllocator,
                pClientKey,
                pRequestBody->nonce,
                &pTicketRequest->KERB_KDC_REQUEST_preauth_data
                );
            return true;
        }
    }
    else if (patType==KRB5_PADATA_XENON_SERVICE_REQUEST2)
    {
        if (pInfo && pSessionKey && pCombinedTGTContext && pXKerbServiceContext)
        {
            // Add Xenon pre-auth info
            *pStatus = KerbAddXenonServiceRequest2PreAuth(
                pInfo,
                pScratchMemoryAllocator,
                pSessionKey,
                pCombinedTGTContext,
                pRequestBody->nonce,
                pXKerbServiceContext,
                &pTicketRequest->KERB_KDC_REQUEST_preauth_data
                );
            return true;
        }
    }
    else if (patType==KRB5_PADATA_XENON_SERVICE_REQUEST3)
    {
        if (pInfo && pSessionKey && pCombinedTGTContext && pXKerbServiceContext)
        {
            // Add Xenon pre-auth info
            *pStatus = KerbAddXenonServiceRequest3PreAuth(
                pInfo,
                pScratchMemoryAllocator,
                pSessionKey,
                pCombinedTGTContext,
                pRequestBody->nonce,
                pXKerbServiceContext,
                &pTicketRequest->KERB_KDC_REQUEST_preauth_data
                );
            return true;
        }
    }
    else if (patType==KRB5_PADATA_XENON_PPA)
    {
        XKERB_SERVICE_CONTEXT_XE* pXenonServiceContext=((XKERB_SERVICE_CONTEXT_XE*)pXKerbServiceContext);

        if (pAsRequestInfo)
        {
            *pStatus=KerbAddXenonPrePreAuth(
                pScratchMemoryAllocator,
                pAsRequestInfo->CertificateHash,
                XONLINE_PPA_HASH_SIZE,
                &pTicketRequest->KERB_KDC_REQUEST_preauth_data
                );
            return true;
        }
    }
    else if (patType==KRB5_PADATA_ENCRYPTED_PASSPORT_AUTHENTICATION)
    {
        if (pAsRequestInfo && (pCompoundKey || pClientKey))
        {
            // use compound if it's there, else use client
            KERB_ENCRYPTION_KEY *pKeyToUse=pCompoundKey;
            if (!pKeyToUse)
            {
                pKeyToUse=pClientKey;
            }

            *pStatus=AddEncryptedPassportAuthenticationPreAuth(
                pScratchMemoryAllocator,
                pKeyToUse,
                pAsRequestInfo,
                &pTicketRequest->KERB_KDC_REQUEST_preauth_data
                );

            return true;
        }
    }
    else if (patType==KRB5_PADATA_PASSPORT_AUTHENTICATION)
    {
        if (pAsRequestInfo)
        {
            *pStatus=AddPassportAuthenticationPreAuth(
                pScratchMemoryAllocator,
                pAsRequestInfo,
                &pTicketRequest->KERB_KDC_REQUEST_preauth_data
                );
            return true;
        }
    }

    //
    return false;
}

//
NTSTATUS WINAPI
kcl_BuildXenonMachineRequest(
    IN XE_CONSOLE_CERTIFICATE *pConsoleCert_Incoming,
    IN BOOL bSignConsoleCert,
    IN BOOL bUseTestXmacsKey,
    IN const TitleInfo* pInfo_Incoming,
    IN PXONLINEP_USER pUser_Incoming,
    IN const DWORD *pPreauthTypeList, // array of preauth types to include
    IN DWORD PreauthTypeListLength,
    OUT PUCHAR pbRequestMessage,
    IN OUT PULONG pdwRequestMessageLength,
    IN OUT PXKERB_TGT_CONTEXT pTGTContext,
    IN BYTE *pSerialNumber //this be a 12 byte serial number blob
    )
{
    ClearStoredDebugSpew();

    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr = KDC_ERR_NONE;
    KERB_KDC_REQUEST TicketRequest;
    PKERB_KDC_REQUEST_BODY RequestBody = &TicketRequest.request_body;
    ULONG KdcFlagOptions;
    LPSTR pszTargetRealm;
    TimeStamp authTime;
    KERB_ENCRYPTION_KEY ClientKey;
    KERB_ENCRYPTION_KEY CompoundKey;
    KERB_MESSAGE_BUFFER RequestMessage;
    const UCHAR* pbScratchMemory;
    char acPrincipleBuffer[KERBEROS_MAX_PRINCIPLE_NAME_SIZE];
    CScratchMemoryAllocator ScratchMemoryAllocator;
    DWORD i,j;
    char* p;

    Assert( pTGTContext->ctNumNonces < MAX_KERB_RETRIES + MAX_TIME_ADJUSTMENTS );

    //fuzz - duplicate input memory
    TitleInfo *pInfo=new TitleInfo();
    memcpy(pInfo,pInfo_Incoming,sizeof(TitleInfo));
    AutoFreePointerSingle<TitleInfo> freeTitle(pInfo);

    //XKERB_TGT_CONTEXT *pTGTContext=... //this is for both in and out, so we don't copy it

    XONLINEP_USER *pUser=new XONLINEP_USER();
    memcpy(pUser,pUser_Incoming,sizeof(XONLINEP_USER));
    AutoFreePointerSingle<XONLINEP_USER> freeUser(pUser);

    unsigned short certSize=0x1a8;
    if (pConsoleCert_Incoming)
    {
        certSize=pConsoleCert_Incoming->CertSize;
        certSize=MAKEWORD(HIBYTE(certSize), LOBYTE(certSize));
    }
    if (certSize>0x1a8) certSize=0x1a8; //so we don't die a terrible death on neg cases that set invalid cert size
    XE_CONSOLE_CERTIFICATE *pConsoleCert=0;
    char *pConsoleCertMem=new char[0x200]; //give extra room here for neg cases to "play"
    AutoFreePointerArray<char> freeCertMem(pConsoleCertMem);
    if (pConsoleCert_Incoming)
    {
        pConsoleCert=(XE_CONSOLE_CERTIFICATE*)pConsoleCertMem;
        memcpy(pConsoleCert,pConsoleCert_Incoming,certSize);
    }

    //fuzz - rar!
    if (requestFuzz.kcl_BuildXenonMachineRequest)
    {
        FuzzStructBits(pInfo, requestFuzz.title);
        FuzzStructBits(pTGTContext, requestFuzz.tgt);
        FuzzStructBits(pUser, requestFuzz.user);
        FuzzStructBits(pConsoleCert, requestFuzz.cert);

        FuzzArray(pSerialNumber, XONLINE_MAX_CONSOLE_SERIAL_NUMBER_LENGTH, requestFuzz.strings);
    }

    // Initialize scratch memory
    pbScratchMemory = (PUCHAR)ScratchMemoryAllocator.ScratchMemoryInitialize( SCRATCH_MEMORY_SIZE_FOR_BuildAsRequest, pbRequestMessage, *pdwRequestMessageLength);

    ZeroMemory(&TicketRequest, sizeof(TicketRequest));

    KerbCreateKeyFromBuffer(
        &ClientKey,
        pUser->key,
        XONLINE_KEY_LENGTH,
        KERB_ETYPE_RC4_HMAC_NT
        );

    // Stick all the PA data in the request
    TicketRequest.KERB_KDC_REQUEST_preauth_data = NULL;

    memcpy( pTGTContext->CompoundKey, ClientKey.keyvalue.value, XONLINE_KEY_LENGTH );

    KerbCreateKeyFromBuffer(
        &CompoundKey,
        pTGTContext->CompoundKey,
        XONLINE_KEY_LENGTH,
        KERB_ETYPE_RC4_HMAC_NT
        );

    // Need to sign the certificate before using it? Highly recommended
    // unless running negative test cases.
    if (bSignConsoleCert)
    {
        g_ClientCrypt.SignConsoleCertificate(pConsoleCert);
    }

    KerbGetCurrentTime(&authTime);

    for (DWORD ptlInd=0; ptlInd<PreauthTypeListLength; ++ptlInd)
    {
        if (pPreauthTypeList[ptlInd]==KRB5_PADATA_XENON_MAC_REQUEST2) 
        {
            // Add special Xenon machine account creation pre-auth
            Status = KerbAddXenonMac2PreAuth(
                pConsoleCert,
                bUseTestXmacsKey,
                &ScratchMemoryAllocator,
                &ClientKey,
                &authTime,
                &TicketRequest.KERB_KDC_REQUEST_preauth_data,
                pSerialNumber);

            if(!NT_SUCCESS(Status)) 
            {
                goto Cleanup;
            }
        }
        else if (pPreauthTypeList[ptlInd]==KRB5_PADATA_XENON_MAC_REQUEST)
        {
            // Add special Xenon machine account creation pre-auth
            Status = KerbAddXenonMacPreAuth(
                pConsoleCert,
                bUseTestXmacsKey,
                &ScratchMemoryAllocator, 
                &ClientKey,
                &authTime, 
                &TicketRequest.KERB_KDC_REQUEST_preauth_data);

            if(!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
        }
        else if (AddSharedPreauthToPAList( // for common shared types
            &ScratchMemoryAllocator,
            pPreauthTypeList[ptlInd],
            &CompoundKey,
            pInfo,
            0,
            false,
            &ClientKey,
            RequestBody,
            0,
            0,
            0,
            &TicketRequest,
            &Status
            ))
        {
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
        }
        else //unhandled pre-auth types generate a "fake preauth" ... type is set and 64 bytes of fe data is used
        {
            Status = KerbAddFakeTypePreauth(
                &ScratchMemoryAllocator,
                pPreauthTypeList[ptlInd],
                &TicketRequest.KERB_KDC_REQUEST_preauth_data
                );

            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
        }
    }

    if (TicketRequest.KERB_KDC_REQUEST_preauth_data != NULL)
    {
        TicketRequest.bit_mask |= _XNetLittleEndianUshort(KERB_KDC_REQUEST_preauth_data_present);
    }

    //
    // Build the request
    //

    KdcFlagOptions = _XNetNetworkEndianUlong(KERB_DEFAULT_TICKET_FLAGS);
    RequestBody->kdc_options.value = (PUCHAR) &KdcFlagOptions;
    RequestBody->kdc_options.length = sizeof(ULONG) * 8;

    TestKerbRandom((BYTE *)&RequestBody->nonce, sizeof(RequestBody->nonce));

    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->endtime,
        NULL,
        &g_KerbGlobalWillNeverTime
        );

    //
    // Copy all the names into the request message
    //
    if (pUser->domain[0] != '\0')
    {
        _snprintf(acPrincipleBuffer, sizeof(acPrincipleBuffer), "%s@%s", pUser->gamertag, pUser->domain);
        acPrincipleBuffer[sizeof(acPrincipleBuffer) - 1] = 0;
    }
    else
    {
        strncpy(acPrincipleBuffer, pUser->gamertag, sizeof(acPrincipleBuffer));
        acPrincipleBuffer[sizeof(acPrincipleBuffer) - 1] = 0;
    }
    while ((p = strchr(acPrincipleBuffer, ' ')) != 0)
    {
        *p = '_';
    }

    KerbErr = KerbConstructPrincipalName(
                &ScratchMemoryAllocator,
                &RequestBody->KERB_KDC_REQUEST_BODY_client_name,
                KRB_NT_ENTERPRISE_PRINCIPAL,
                acPrincipleBuffer
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RequestBody->bit_mask |= _XNetLittleEndianUshort(KERB_KDC_REQUEST_BODY_client_name_present);

    pszTargetRealm = XBOX_KERBEROS_REALM;
    Assert( strlen(pszTargetRealm) <= XONLINE_MAX_KERBEROSREALM_LENGTH );
    strncpy(pTGTContext->TargetRealm, pszTargetRealm,sizeof(pTGTContext->TargetRealm));
    pTGTContext->TargetRealm[sizeof(pTGTContext->TargetRealm) - 1] = 0;

    //
    // Fill in the strings in the ticket request
    //
    KerbErr = KerbConstructPrincipalName(
                &ScratchMemoryAllocator,
                &RequestBody->KERB_KDC_REQUEST_BODY_server_name,
                KRB_NT_SRV_INST,
                KDC_PRINCIPAL_NAME,
                pszTargetRealm
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    RequestBody->bit_mask |= _XNetLittleEndianUshort(KERB_KDC_REQUEST_BODY_server_name_present);

    RequestBody->realm = (char*)pUser->kerberosRealm;

    TicketRequest.version = KERBEROS_VERSION;
    TicketRequest.message_type = KRB_AS_REQ;

    //
    // Build crypt list
    //

    RequestBody->encryption_type = &g_RC4HMAC_CryptList;

    //
    // Pack the request
    //
    RequestMessage.BufferSize = *pdwRequestMessageLength;
    RequestMessage.Buffer = pbRequestMessage;
    KerbErr = KerbPackAsRequest(
                &ScratchMemoryAllocator,
                &TicketRequest,
                &RequestMessage.BufferSize,
                &RequestMessage.Buffer
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    *pdwRequestMessageLength = RequestMessage.BufferSize;

    j = 0;
    if (pTGTContext->pInputTGTContext != NULL)
    {
        pTGTContext->MachineID = pTGTContext->pInputTGTContext->MachineID;
        for (i=0; i<XONLINE_MAX_LOGON_USERS; ++i)
        {
            if (pTGTContext->pInputTGTContext->UserID[i] != 0)
            {
                pTGTContext->UserID[j++] = pTGTContext->pInputTGTContext->UserID[i];
            }
        }
    }
    Assert( j <= XONLINE_MAX_LOGON_USERS );

    //for fuzzing, don't trust the value as a valid index, but mod it by the max
    unsigned int nOnceIndex=((unsigned int)(pTGTContext->ctNumNonces))%(MAX_KERB_RETRIES + MAX_TIME_ADJUSTMENTS);
    pTGTContext->Nonce[nOnceIndex] = RequestBody->nonce;
    ++pTGTContext->ctNumNonces;    
    
    memcpy( pTGTContext->ClientKey, pUser->key, XONLINE_KEY_LENGTH );
    Status = STATUS_SUCCESS;

Cleanup:
    return(Status);
}

NTSTATUS WINAPI
XkerbBuildAsRequest(
    IN const TitleInfo* pInfo_Incoming,
    IN const AsRequestInfo* pAsRequestInfo,
    IN DWORD cbAsRequestInfo,
    IN BOOL fMachineAccount,
    IN PXONLINEP_USER User_Incoming,
    IN const DWORD *pPreauthTypeList, // array of preauth types to include
    IN DWORD PreauthTypeListLength,
    IN BYTE *pEchoPreauthBytes,
    IN DWORD cbEchoPreauthBytes,
    IN bool allowFakeCompoundPreauth,
    OUT PUCHAR pbRequestMessage,
    IN OUT PULONG pdwRequestMessageLength,
    IN OUT PXKERB_TGT_CONTEXT pTGTContext
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr = KDC_ERR_NONE;
    KERB_KDC_REQUEST TicketRequest;
    PKERB_KDC_REQUEST_BODY RequestBody = &TicketRequest.request_body;
    ULONG KdcFlagOptions;
    LPSTR pszTargetRealm;
    KERB_ENCRYPTION_KEY ClientKey;
    KERB_ENCRYPTION_KEY CompoundKey;
    KERB_MESSAGE_BUFFER RequestMessage;
    const UCHAR* pbScratchMemory;
    char acPrincipleBuffer[KERBEROS_MAX_PRINCIPLE_NAME_SIZE];
    CScratchMemoryAllocator ScratchMemoryAllocator;
    DWORD i,j;
    char* p;

    AssertSz((pAsRequestInfo==0 && cbAsRequestInfo==0) || cbAsRequestInfo==sizeof(AsRequestInfo), "AsRequestInfo structure size mismatch!");
    Assert( pTGTContext->ctNumNonces < MAX_KERB_RETRIES + MAX_TIME_ADJUSTMENTS );

    //fuzz - duplicate input memory
    TitleInfo *pInfo=new TitleInfo();
    memcpy(pInfo,pInfo_Incoming,sizeof(TitleInfo));
    AutoFreePointerSingle<TitleInfo> freeTitle(pInfo);

    //XKERB_TGT_CONTEXT *pTGTContext=pTGTContext_Incoming; //this is for both in and out, so don't copy

    XONLINEP_USER *User=new XONLINEP_USER();
    memcpy(User,User_Incoming,sizeof(XONLINEP_USER));
    AutoFreePointerSingle<XONLINEP_USER> freeUser(User);

    //fuzz - rar!
    if (requestFuzz.XkerbBuildAsRequest)
    {
        FuzzStructBits(pInfo, requestFuzz.title);
        FuzzStructBits(pTGTContext, requestFuzz.tgt);
        FuzzStructBits(User, requestFuzz.user);

        if (FuzzCheck(requestFuzz.misc))
        {
            fMachineAccount=!fMachineAccount;
        }
    }

    if (requestFuzz.kcl_BuildAsWithPassportRequest)
    {
        //TODO: Don't change these in-place (assumably whoever declared this function "forgot" to make the params const...)
        //TODO: Update for fuzzing in this new path...
        /*
        FuzzArray(pTicket, cbTicket, requestFuzz.ticket);
        FuzzArray(pSessionKey, cbSessionKey, requestFuzz.keys);

        FuzzStructBits(pTGTContext, requestFuzz.tgt);
        */
    }

    //
    // Initialize scratch memory
    //
    pbScratchMemory = (PUCHAR)ScratchMemoryAllocator.ScratchMemoryInitialize( SCRATCH_MEMORY_SIZE_FOR_BuildAsRequest, pbRequestMessage, *pdwRequestMessageLength);

    ZeroMemory(&TicketRequest, sizeof(TicketRequest));
    ZeroMemory(&CompoundKey, sizeof(CompoundKey));

    // Misc Key setup
    KerbCreateKeyFromBuffer(
        &ClientKey,
        User->key,
        XONLINE_KEY_LENGTH,
        KERB_ETYPE_RC4_HMAC_NT
        );

    if (pAsRequestInfo->UsePcNonceKey) //this is a PC user request, we use a special key and principal
    {
        //key
        BYTE keybytes[20];

        XcHMAC4((BYTE*)pAsRequestInfo->PassportSessionKey, pAsRequestInfo->PassportSessionKeyLength,
            (BYTE*)&pAsRequestInfo->PcNonce, sizeof(pAsRequestInfo->PcNonce),
            NULL,               0,
            NULL,               0,
            NULL,               0,
            keybytes,           sizeof(keybytes));

        KerbCreateKeyFromBuffer(
            &ClientKey,
            keybytes,
            XONLINE_KEY_LENGTH,
            KERB_ETYPE_RC4_HMAC_NT
            );

        memcpy( pTGTContext->CompoundKey, ClientKey.keyvalue.value, XONLINE_KEY_LENGTH );

        KerbCreateKeyFromBuffer(
            &CompoundKey,
            pTGTContext->CompoundKey,
            XONLINE_KEY_LENGTH,
            KERB_ETYPE_RC4_HMAC_NT
            );

        //principal
        sprintf(acPrincipleBuffer, "PC.USER@XBOX.COM");
    }
    else //use normal principal name and key
    {
        //key
        memcpy( pTGTContext->CompoundKey, ClientKey.keyvalue.value, XONLINE_KEY_LENGTH );

        if (pTGTContext)
        {
            if (pTGTContext->pInputTGTContext!=0)
            {
                KerbComputeCompoundIdentityKey(
                    &ClientKey,
                    pTGTContext->pInputTGTContext,
                    pTGTContext->CompoundKey
                    );
            }

            KerbCreateKeyFromBuffer(
                &CompoundKey,
                pTGTContext->CompoundKey,
                XONLINE_KEY_LENGTH,
                KERB_ETYPE_RC4_HMAC_NT
                );
        }

        //principal
        if (User->domain[0] != '\0')
        {
            if (_snprintf(acPrincipleBuffer, sizeof(acPrincipleBuffer), "%s@%s", User->gamertag, User->domain)< 0)
            {
                AssertSz(FALSE, "Insufficient string buffer for principle string!");
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }
        }
        else
        {
            lstrcpynA(acPrincipleBuffer, User->gamertag, sizeof(acPrincipleBuffer));
        }

        while ((p = strchr(acPrincipleBuffer, ' ')) != 0)
        {
            *p = '_';
        }
    }

    //fuzz - rar!
    if (requestFuzz.XkerbBuildAsRequest)
    {
        FuzzNullString(acPrincipleBuffer, requestFuzz.strings);
        //FuzzNullString(pszTargetRealm, requestFuzz.strings); //TODO?
        //FuzzNullString(pszRequestRealm, requestFuzz.strings); //TODO?
    }

    acPrincipleBuffer[_countof(acPrincipleBuffer) - 1] = '\0';

    //
    // Stick all the PA data in the request
    //
    TicketRequest.KERB_KDC_REQUEST_preauth_data = NULL;

    for (DWORD ptlInd=0; ptlInd<PreauthTypeListLength; ++ptlInd)
    {
        if (pPreauthTypeList[ptlInd]==KRB5_PADATA_COMPOUND_IDENTITY)
        {
            if (pTGTContext->pInputTGTContext != NULL)
            {
                //
                // Do the PA-COMPOUND-IDENTITY first because it consumes the most memory
                //
                Status = KerbAddCompoundIdentityPreAuth(
                    &ScratchMemoryAllocator,
                    pTGTContext->pInputTGTContext,
                    &TicketRequest.KERB_KDC_REQUEST_preauth_data
                    );
                if (!NT_SUCCESS(Status))
                {
                    if (allowFakeCompoundPreauth) //for negative cases: if we allow a fake compound
                    {
                        Status = KerbAddFakeTypePreauth(
                            &ScratchMemoryAllocator,
                            KRB5_PADATA_COMPOUND_IDENTITY,
                            &TicketRequest.KERB_KDC_REQUEST_preauth_data
                            );

                        if (!NT_SUCCESS(Status))
                        {
                            goto Cleanup;
                        }
                    }
                    else
                    {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        goto Cleanup;
                    }
                }
            }
        }
        else if (pPreauthTypeList[ptlInd]==KRB5_PADATA_XBOX_PPA)
        {
            //
            // Add special Xbox Pre-Pre-auth data
            //
            Status = KerbAddPrePreAuth(
                &ScratchMemoryAllocator,
                User->gamertag,
                &ClientKey,
                &TicketRequest.KERB_KDC_REQUEST_preauth_data
                );
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
        }
        else if (pPreauthTypeList[ptlInd]==KRB5_PADATA_XBOX_ECHO)
        {
            //
            // Add special Xbox Echo Pre-Auth data if present
            //
            if (pEchoPreauthBytes)
            {
                Status = KerbAddEchoPreAuth(
                    &ScratchMemoryAllocator,
                    cbEchoPreauthBytes,
                    pEchoPreauthBytes,
                    &TicketRequest.KERB_KDC_REQUEST_preauth_data
                    );
                if (!NT_SUCCESS(Status))
                {
                    goto Cleanup;
                }
            }
        }
        else if (AddSharedPreauthToPAList( // for common shared types
            &ScratchMemoryAllocator,
            pPreauthTypeList[ptlInd],
            &CompoundKey,
            pInfo,
            pAsRequestInfo,
            false,
            &ClientKey,
            RequestBody,
            0,
            0,
            0,
            &TicketRequest,
            &Status
            ))
        {
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
        }
        else //unhandled pre-auth types generate a "fake preauth" ... type is set and 64 bytes of fe data is used
        {
            Status = KerbAddFakeTypePreauth(
                &ScratchMemoryAllocator,
                pPreauthTypeList[ptlInd],
                &TicketRequest.KERB_KDC_REQUEST_preauth_data
                );

            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
        }
    }

    if (TicketRequest.KERB_KDC_REQUEST_preauth_data != NULL)
    {
        TicketRequest.bit_mask |= KERB_KDC_REQUEST_preauth_data_present;
    }

    //
    // Build the request
    //

    KdcFlagOptions = KerbConvertUlongToFlagUlong(KERB_DEFAULT_TICKET_FLAGS);
    RequestBody->kdc_options.value = (PUCHAR) &KdcFlagOptions;
    RequestBody->kdc_options.length = sizeof(ULONG) * 8;

    TestKerbRandom((BYTE *)&RequestBody->nonce, sizeof(RequestBody->nonce));

    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->endtime,
        NULL,
        &g_KerbGlobalWillNeverTime
        );

    KerbErr = KerbConstructPrincipalName(
                &ScratchMemoryAllocator,
                &RequestBody->KERB_KDC_REQUEST_BODY_client_name,
                KRB_NT_ENTERPRISE_PRINCIPAL,
                acPrincipleBuffer
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RequestBody->bit_mask |= KERB_KDC_REQUEST_BODY_client_name_present;

    pszTargetRealm = fMachineAccount ? XBOX_KERBEROS_REALM : (char*)User->kerberosRealm;
    Assert( strlen(pszTargetRealm) <= XONLINE_MAX_KERBEROSREALM_LENGTH );
    lstrcpynA(pTGTContext->TargetRealm, pszTargetRealm,sizeof(pTGTContext->TargetRealm));

    //
    // Fill in the strings in the ticket request
    //
    KerbErr = KerbConstructPrincipalName(
                &ScratchMemoryAllocator,
                &RequestBody->KERB_KDC_REQUEST_BODY_server_name,
                KRB_NT_SRV_INST,
                KDC_PRINCIPAL_NAME,
                pszTargetRealm
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    RequestBody->bit_mask |= KERB_KDC_REQUEST_BODY_server_name_present;

    RequestBody->realm = (char*)User->kerberosRealm;

    TicketRequest.version = KERBEROS_VERSION;
    TicketRequest.message_type = KRB_AS_REQ;

    //
    // Build crypt list
    //

    RequestBody->encryption_type = &g_RC4HMAC_CryptList;

    //
    // Pack the request
    //
    RequestMessage.BufferSize = *pdwRequestMessageLength;
    RequestMessage.Buffer = pbRequestMessage;
    KerbErr = KerbPackAsRequest(
                &ScratchMemoryAllocator,
                &TicketRequest,
                &RequestMessage.BufferSize,
                &RequestMessage.Buffer
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    *pdwRequestMessageLength = RequestMessage.BufferSize;

    j = 0;
    if (pTGTContext->pInputTGTContext != NULL)
    {
        pTGTContext->MachineID = pTGTContext->pInputTGTContext->MachineID;
        for (i=0; i<XONLINE_MAX_LOGON_USERS; ++i)
        {
            if (pTGTContext->pInputTGTContext->UserID[i] != 0)
            {
                pTGTContext->UserID[j++] = pTGTContext->pInputTGTContext->UserID[i];
            }
        }
    }
    if (!fMachineAccount)
    {
        pTGTContext->UserID[j++] = User->xuid.qwUserID;
    }
    Assert( j <= XONLINE_MAX_LOGON_USERS );

    //for fuzzing, don't trust the value as a valid index, but mod it by the max
    unsigned int nOnceIndex=((unsigned int)(pTGTContext->ctNumNonces))%(MAX_KERB_RETRIES + MAX_TIME_ADJUSTMENTS);
    pTGTContext->Nonce[nOnceIndex] = RequestBody->nonce;
    ++pTGTContext->ctNumNonces;
    
    memcpy( pTGTContext->ClientKey, User->key, XONLINE_KEY_LENGTH );
    Status = STATUS_SUCCESS;

Cleanup:
    return(Status);
}

//--------------------------------------------------------------------------

NTSTATUS WINAPI
kcl_VerifyAsReply(
    IN PUCHAR pbReplyMessage,
    IN ULONG dwReplyMessageLength,
    IN OUT PXKERB_TGT_CONTEXT pTGTContext
    )
{
    ClearStoredDebugSpew();

    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_KDC_REPLY KdcReply = NULL;
    PKERB_ENCRYPTED_KDC_REPLY ReplyBody = NULL;
    KERB_ENCRYPTION_KEY CompoundKey;
    PKERB_ERROR ErrorMessage = NULL;
    PUCHAR pEncodedTicket;
    PKERB_PA_DATA pPreAuthData;
    const UCHAR* pbScratchMemory;
    CScratchMemoryAllocator ScratchMemoryAllocator;
    DWORD iNonceMatch;

    //
    // Initialize scratch memory
    //
    pbScratchMemory = (PUCHAR)ScratchMemoryAllocator.ScratchMemoryInitialize( SCRATCH_MEMORY_SIZE_FOR_VerifyAsReply, NULL, 0);

    KerbErr = KerbUnpackAsReply(
                &ScratchMemoryAllocator,
                pbReplyMessage,
                dwReplyMessageLength,
                &KdcReply
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        //
        // Try to unpack it as  kerb_error
        //
        KerbErr =  KerbUnpackKerbError(
                        &ScratchMemoryAllocator,
                        pbReplyMessage,
                        dwReplyMessageLength,
                        &ErrorMessage
                        );
        if (KERB_SUCCESS(KerbErr))
        {
            KerbErr = (KERBERR) ErrorMessage->error_code;

            if (KerbErr==KDC_ERR_PREAUTH_REQUIRED) //we expect this a lot processing an echo preauth, so only report it on the verbose level
                TraceSz1(AuthVerbose, "kcl_VerifyAsReply: Got KerbError 0x%X", KerbErr);
            else
                TraceSz1(AuthWarn,    "kcl_VerifyAsReply: Got KerbError 0x%X", KerbErr);

            Status = KerbMapKerbError(KerbErr);

            iNonceMatch = pTGTContext->ctNumNonces;
            if ((ErrorMessage->bit_mask & error_text_present) &&
                ErrorMessage->error_text.length == sizeof(DWORD) &&
                ErrorMessage->error_text.value != NULL)
            {
                for (iNonceMatch=0; iNonceMatch<pTGTContext->ctNumNonces; ++iNonceMatch)
                {
                    if (memcmp( &(pTGTContext->Nonce[iNonceMatch]), ErrorMessage->error_text.value, sizeof(DWORD)) == 0)
                    {
                        break;
                    }
                }
            }
            if (iNonceMatch == pTGTContext->ctNumNonces)
            {
                TraceSz( AuthWarn, "kcl_VerifyAsReply: got a kerb error with a mismatching nonce, ignoring it" );
                Status = STATUS_LOGON_FAILURE;
                goto Cleanup;
            }

            if ((ErrorMessage->bit_mask & error_data_present) &&
                ErrorMessage->error_data.length != 0 &&
                ErrorMessage->error_data.value != NULL)
            {
                if (ErrorMessage->error_data.length <= sizeof(pTGTContext->EchoPreAuth))
                {
                    pTGTContext->cbEchoPreAuth = ErrorMessage->error_data.length;
                    memcpy( pTGTContext->EchoPreAuth, ErrorMessage->error_data.value, ErrorMessage->error_data.length );
                }
                else
                {
                    TraceSz1( AuthWarn, "kcl_VerifyAsReply: got a echo preauth request too big: %d", ErrorMessage->error_data.length );
                }
            }

            //
            // Check for time skew. If so, calculate the skew and retry
            //
            if (KerbErr == KRB_AP_ERR_SKEW)
            {
                TimeStamp KdcTime;
                //TimeStamp XboxTime;

                KerbConvertGeneralizedTimeToLargeInt(
                    &KdcTime,
                    &ErrorMessage->server_time,
                    ErrorMessage->server_usec
                    );

                //KerbGetCurrentTime(&XboxTime);
                //pTGTContext->qwTimeOffset = KerbGetOffsetBetweenTime( &XboxTime, &KdcTime );
                KerbUpdateCurrentTime( KdcTime );
            }
            goto Cleanup;
        }
        else
        {
            Status = STATUS_LOGON_FAILURE;
        }

        goto Cleanup;
    }

    KerbCreateKeyFromBuffer(
        &CompoundKey,
        pTGTContext->CompoundKey,
        XONLINE_KEY_LENGTH,
        KERB_ETYPE_RC4_HMAC_NT
        );

    if ((KdcReply->bit_mask & KERB_KDC_REPLY_preauth_data_present) != 0)
    {
        {
            //
            // Get the XKERB_PA_XBOX_ACCOUNT_CREATION pre-auth, if present
            //
            CReleaseAllScratchMemoryUponDestruction onlyPreserveThisMemory( &ScratchMemoryAllocator );

            pPreAuthData = KerbFindPreAuthDataEntry(
                            KRB5_PADATA_XBOX_ACCOUNT_CREATION,
                            (PKERB_PA_DATA_LIST)KdcReply->preauth_data
                            );
            if (pPreAuthData != NULL)
            {
                //
                // Allocate pre-auth using SysAlloc
                // Do not use KerbAllocate here! You will end up with scratch memory!
                //
                pTGTContext->pAccountCreationPreAuth = (PXKERB_PA_XBOX_ACCOUNT_CREATION)malloc(sizeof(XKERB_PA_XBOX_ACCOUNT_CREATION));
                if (pTGTContext->pAccountCreationPreAuth == NULL)
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
                }

                //
                // Check the pre-auth reply
                //
                KerbErr = KerbVerifyAccountCreationPreAuth(
                    &ScratchMemoryAllocator,
                    pPreAuthData,
                    &CompoundKey,
                    pTGTContext
                    );
                if (!KERB_SUCCESS(KerbErr))
                {
                    Status = KerbErr;
                    goto Cleanup;
                }
            }
        }
        {
            //
            // Get the PA_PASSPORT_AUTHENTICATION pre-auth, if present
            //
            CReleaseAllScratchMemoryUponDestruction onlyPreserveThisMemory( &ScratchMemoryAllocator );

            pPreAuthData = KerbFindPreAuthDataEntry(
                            KRB5_PADATA_PASSPORT_AUTHENTICATION,
                            (PKERB_PA_DATA_LIST)KdcReply->preauth_data
                            );
            if (pPreAuthData != NULL)
            {
                KerbErr = VerifyPassportAuthorizationPreAuthReply(
                    &ScratchMemoryAllocator,
                    pPreAuthData,
                    &CompoundKey,
                    pTGTContext
                    );

                if(!KERB_SUCCESS(KerbErr))
                {
                    Status = KerbErr;
                    goto Cleanup;
                }
            }
        }
    }

    {
        CReleaseAllScratchMemoryUponDestruction onlyPreserveThisMemory( &ScratchMemoryAllocator );

        //
        // Pack ticket into marshalled form for caching
        //
        pTGTContext->dwTicketLength = 0;
        pEncodedTicket = NULL;
        KerbErr = KerbPackData(
                    &ScratchMemoryAllocator,
                    &KdcReply->ticket,
                    KERB_TICKET_PDU,
                    &pTGTContext->dwTicketLength,
                    &pEncodedTicket
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        if (pTGTContext->dwTicketLength > XONLINE_MAX_TICKET_LENGTH)
        {
            TraceSz1( AuthWarn, "kcl_VerifyAsReply: got a ticket too big: %d", pTGTContext->dwTicketLength );
            Status = STATUS_LOGON_FAILURE;
            goto Cleanup;
        }

        memcpy(
            pTGTContext->Ticket,
            pEncodedTicket,
            pTGTContext->dwTicketLength
            );
    }

    //
    // Now unpack the reply body:
    //
    KerbErr = KerbUnpackKdcReplyBody(
                &ScratchMemoryAllocator,
                &KdcReply->encrypted_part,
                &CompoundKey,
                KERB_ENCRYPTED_AS_REPLY_PDU,
                &ReplyBody
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    //
    // Verify the nonce is correct:
    //
    for (iNonceMatch=0; iNonceMatch<pTGTContext->ctNumNonces; ++iNonceMatch)
    {
        if (pTGTContext->Nonce[iNonceMatch] == (DWORD)ReplyBody->nonce)
        {
            break;
        }
    }
    if (iNonceMatch == pTGTContext->ctNumNonces)
    {
        TraceSz3( AuthWarn, "kcl_VerifyAsReply: All %d Nonces don't match: 0x%X vs 0x%X", iNonceMatch, pTGTContext->Nonce[0], ReplyBody->nonce);
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    //
    // Cache the session key
    //
    if (ReplyBody->session_key.keytype != KERB_ETYPE_RC4_HMAC_NT ||
        ReplyBody->session_key.keyvalue.length != XONLINE_KEY_LENGTH)
    {
        TraceSz( AuthWarn, "kcl_VerifyAsReply: got a session key of the wrong type or length" );
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    memcpy( pTGTContext->SessionKey, ReplyBody->session_key.keyvalue.value, XONLINE_KEY_LENGTH );

    //
    // Copy the principal name (might be different because of name canonicalization)
    //
    KerbErr = KerbPrincipalNameToMultiString(
        &KdcReply->client_name,
        sizeof(pTGTContext->ClientName),
        pTGTContext->ClientName
        );
    if (!KERB_SUCCESS(KerbErr))
    {
        TraceSz( AuthWarn, "kcl_VerifyAsReply: returned client name is too long" );
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    if ( strlen(KdcReply->client_realm) <= XONLINE_MAX_KERBEROSREALM_LENGTH )
    {
        lstrcpynA(pTGTContext->ClientRealm, KdcReply->client_realm, sizeof(pTGTContext->ClientRealm));
    }
    else
    {
        TraceSz( AuthWarn, "kcl_VerifyAsReply: returned client realm is too long" );
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    //
    // Cache expiration time
    //
    KerbConvertGeneralizedTimeToLargeInt(
        &pTGTContext->ExpirationTime,
        &ReplyBody->endtime,
        0
        );

    KerbConvertGeneralizedTimeToLargeInt(
        &pTGTContext->StartTime,
        &ReplyBody->starttime,
        0
        );

    //
    // Verbose trace info
    //
    TraceSz7( AuthVerbose,"kcl_VerifyAsReply: extracted %d byte ticket (expires in %d secs) from %d byte reply matching try %d for %s KerbRealm:%s%s",
        pTGTContext->dwTicketLength,
        (ULONG)((pTGTContext->ExpirationTime.QuadPart -pTGTContext->StartTime.QuadPart) / 10000000),
        dwReplyMessageLength, iNonceMatch + 1,
        KdcReply->client_name.name_string->value,
        KdcReply->client_realm,
        (pTGTContext->pAccountCreationPreAuth != NULL ? " with AccCreInfo" : "")
        );

Cleanup:
    return(Status);
}

//--------------------------------------------------------------------------



// Xbox XKDC build entry point
//
NTSTATUS WINAPI
kcl_BuildXboxTgsRequest(
    IN const TitleInfo* pInfo,
    IN PXKERB_TGT_CONTEXT pCombinedTGTContext,
    IN const DWORD *pPreauthTypeList,
    IN DWORD PreauthTypeListLength,
    OUT PUCHAR pbRequestMessage,
    IN OUT PULONG pdwRequestMessageLength,
    IN OUT PXKERB_SERVICE_CONTEXT pXKerbServiceContext
    )
{
    ClearStoredDebugSpew();
    //Xbox1 code has been removed, return failure.
    return STATUS_LOGON_FAILURE;
}



// Xenon XKDC build entry point
//
NTSTATUS WINAPI
kcl_BuildXenonTgsRequest(
    IN const TitleInfo* pInfo_Incoming,
    IN PXKERB_TGT_CONTEXT pCombinedTGTContext_Incoming,
    IN const DWORD *pPreauthTypeList,
    IN DWORD PreauthTypeListLength,
    OUT PUCHAR pbRequestMessage,
    IN OUT PULONG pdwRequestMessageLength,
    IN OUT PXKERB_SERVICE_CONTEXT pXKerbServiceContext
    )
{
    ClearStoredDebugSpew();

    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr;
    KERB_PA_DATA_LIST ApRequest;
    KERB_CHECKSUM RequestChecksum;
    ULONG KdcFlagOptions;
    KERB_KDC_REQUEST TicketRequest;
    PKERB_KDC_REQUEST_BODY RequestBody = &TicketRequest.request_body;
    KERB_MESSAGE_BUFFER RequestMessage;
    KERB_ENCRYPTION_KEY SessionKey;
    PKERB_TICKET pTGT = NULL;
    CHAR buffer[16];
    DWORD i;
    const UCHAR* pbScratchMemory;
    CScratchMemoryAllocator ScratchMemoryAllocator;

    Assert(pCombinedTGTContext_Incoming != NULL);
    Assert(pXKerbServiceContext != NULL);
    Assert(pXKerbServiceContext->ctNumNonces < MAX_KERB_RETRIES + MAX_TIME_ADJUSTMENTS);

    //fuzz - duplicate input memory
    TitleInfo *pInfo=new TitleInfo();
    memcpy(pInfo,pInfo_Incoming,sizeof(TitleInfo));
    AutoFreePointerSingle<TitleInfo> freeTitle(pInfo);

    XKERB_TGT_CONTEXT *pCombinedTGTContext=new XKERB_TGT_CONTEXT();
    memcpy(pCombinedTGTContext,pCombinedTGTContext_Incoming,sizeof(XKERB_TGT_CONTEXT));
    AutoFreePointerSingle<XKERB_TGT_CONTEXT> freeTGT(pCombinedTGTContext);

    //XKERB_SERVICE_CONTEXT *pXKerbServiceContext=...  //this is for both in and out, so don't copy

    //fuzz - rar!
    if (requestFuzz.kcl_BuildXenonTgsRequest)
    {
        FuzzStructBits(pInfo, requestFuzz.title);
        FuzzStructBits(pCombinedTGTContext, requestFuzz.tgt);
        FuzzStructBits(pXKerbServiceContext, requestFuzz.service);
    }

    //
    // Initialize scratch memory
    //
    pbScratchMemory = (PUCHAR)ScratchMemoryAllocator.ScratchMemoryInitialize( SCRATCH_MEMORY_SIZE_FOR_BuildTgsRequest, pbRequestMessage, *pdwRequestMessageLength);
    Assert(pbScratchMemory != 0);

    //
    // Initialize structures
    //
    ZeroMemory(
        &ApRequest,
        sizeof(KERB_PA_DATA_LIST)
        );

    ZeroMemory(
        &RequestChecksum,
        sizeof(KERB_CHECKSUM)
       );

    ZeroMemory(
        &TicketRequest,
        sizeof(KERB_KDC_REQUEST)
        );

    memcpy( pXKerbServiceContext->ServiceRealm, pCombinedTGTContext->TargetRealm, sizeof(pXKerbServiceContext->ServiceRealm) );
    Assert( pXKerbServiceContext->MachineID == pCombinedTGTContext->MachineID );

    //TODO: These asserts fire in every case... but seem harmless... should investigate what's going on sometime.
    //AssertSz2( pXKerbServiceContext->UserID[0] == pCombinedTGTContext->UserID[0] , "Assert: service and tgt context user id 0 mismatch: %I64d vs %I64d", pXKerbServiceContext->UserID[0], pCombinedTGTContext->UserID[0]);
    //Assert( pXKerbServiceContext->UserID[1] == pCombinedTGTContext->UserID[1] );
    //Assert( pXKerbServiceContext->UserID[2] == pCombinedTGTContext->UserID[2] );
    //Assert( pXKerbServiceContext->UserID[3] == pCombinedTGTContext->UserID[3] );

    //
    // Fill in the ticket request with the defaults.
    //
    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->endtime,
        NULL,
        &g_KerbGlobalWillNeverTime
        );

    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->KERB_KDC_REQUEST_BODY_renew_until,
        NULL,
        &g_KerbGlobalWillNeverTime
        );

    TestKerbRandom((BYTE *)&RequestBody->nonce, sizeof(RequestBody->nonce));

    //
    // Build crypt list
    //

    RequestBody->encryption_type = &g_RC4HMAC_CryptList;

    //
    // Fill in the strings in the ticket request
    //
    int nWritten = 0;
    if (((PXKERB_SERVICE_CONTEXT_XE)pXKerbServiceContext)->dwXenonFlag != XENON_SERVICE_CONTEXT_FLAG)
    {
        nWritten = -1;
    }
    else
    {
        nWritten = _snprintf( buffer, sizeof(buffer), "S%u",
            ((PXKERB_SERVICE_CONTEXT_XE)pXKerbServiceContext)->bServiceID3[0] != XONLINE_INVALID_SERVICE 
            ? ((PXKERB_SERVICE_CONTEXT_XE)pXKerbServiceContext)->bServiceID3[0] 
            : ((PXKERB_SERVICE_CONTEXT_XE)pXKerbServiceContext)->dwServiceID3[0]);
    }
    
    if (nWritten < 0)
    {
        AssertSz(FALSE, "Insufficient string buffer for Kerb service context string!");
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    KerbErr = KerbConstructPrincipalName(
                &ScratchMemoryAllocator,
                &RequestBody->KERB_KDC_REQUEST_BODY_server_name,
                KRB_NT_SRV_INST,
                SECURITY_GATEWAY_STRING,
                buffer
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    RequestBody->bit_mask |= KERB_KDC_REQUEST_BODY_server_name_present;

    KdcFlagOptions = KerbConvertUlongToFlagUlong(KERB_DEFAULT_TICKET_FLAGS);
    RequestBody->kdc_options.length = sizeof(ULONG) * 8;
    RequestBody->kdc_options.value = (PUCHAR) &KdcFlagOptions;

    //
    // Marshall the request and compute a checksum of it
    //
    RequestBody->realm = pXKerbServiceContext->ServiceRealm;

    //
    // Construct encryption key struct for session key
    //
    KerbCreateKeyFromBuffer(
        &SessionKey,
        pCombinedTGTContext->SessionKey,
        XONLINE_KEY_LENGTH,
        KERB_ETYPE_RC4_HMAC_NT
        );

    {
        CReleaseAllScratchMemoryUponDestruction onlyPreserveThisMemory( &ScratchMemoryAllocator );

        //
        // Now compute a checksum of that data
        //

        Status = KerbComputeRequestBodyChecksum(
                    &ScratchMemoryAllocator,
                    RequestBody,
                    &RequestChecksum
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        KerbErr = KerbUnpackData(
                    &ScratchMemoryAllocator,
                    pCombinedTGTContext->Ticket,
                    pCombinedTGTContext->dwTicketLength,
                    KERB_TICKET_PDU,
                    (PVOID*)&pTGT
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        //
        // Create the AP request to the KDC for the ticket to the service
        //

        //don't trust the Nonce to be in range - it could havebeen fuzzed, so mod it by the max
        DWORD nOnceToUseForTime=(pXKerbServiceContext->ctNumNonces)%(MAX_KERB_RETRIES + MAX_TIME_ADJUSTMENTS);
        KerbGetCurrentTime(&pXKerbServiceContext->AuthenticatorTime[nOnceToUseForTime]);

        KerbErr = KerbCreateApRequest(
                    &ScratchMemoryAllocator,
                    pCombinedTGTContext->ClientName,
                    pCombinedTGTContext->ClientRealm,
                    &SessionKey,
                    RequestBody->nonce,
                    &pXKerbServiceContext->AuthenticatorTime[nOnceToUseForTime],
                    pTGT,
                    0,                              // no AP options
                    &RequestChecksum,
                    TRUE,                           // kdc request
                    (PULONG) &ApRequest.value.preauth_data.length,
                    &ApRequest.value.preauth_data.value
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        //
        // Preserve the only piece of memory we care about
        //
        PreserveThisMemory( &onlyPreserveThisMemory, &ApRequest.value.preauth_data.value, ApRequest.value.preauth_data.length );
    }

    ApRequest.next = NULL;
    ApRequest.value.preauth_data_type = KRB5_PADATA_TGS_REQ;
    TicketRequest.KERB_KDC_REQUEST_preauth_data = &ApRequest;
    TicketRequest.bit_mask |= KERB_KDC_REQUEST_preauth_data_present;

    // Add preauths
    for (DWORD ptlInd=0; ptlInd<PreauthTypeListLength; ++ptlInd)
    {
        if (AddSharedPreauthToPAList( // for common shared types
            &ScratchMemoryAllocator,
            pPreauthTypeList[ptlInd],
            0,
            pInfo,
            0,
            true,
            0,
            RequestBody,
            &SessionKey,
            pCombinedTGTContext,
            pXKerbServiceContext,
            &TicketRequest,
            &Status
            ))
        {
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
        }
        else //unhandled pre-auth types generate a "fake preauth" ... type is set and 64 bytes of fe data is used
        {
            Status = KerbAddFakeTypePreauth(
                &ScratchMemoryAllocator,
                pPreauthTypeList[ptlInd],
                &TicketRequest.KERB_KDC_REQUEST_preauth_data
                );

            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
        }
    }

    //
    // Add version and message type info
    //

    TicketRequest.version = KERBEROS_VERSION;
    TicketRequest.message_type = KRB_TGS_REQ;

    //
    // Pack the request
    //
    RequestMessage.BufferSize = *pdwRequestMessageLength;
    RequestMessage.Buffer = pbRequestMessage;
    KerbErr = KerbPackTgsRequest(
                &ScratchMemoryAllocator,
                &TicketRequest,
                &RequestMessage.BufferSize,
                &RequestMessage.Buffer
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    *pdwRequestMessageLength = RequestMessage.BufferSize;

    //for fuzzing, don't trust the value as a valid index, but mod it by the max
    unsigned int nOnceIndex=((unsigned int)(pXKerbServiceContext->ctNumNonces))%(MAX_KERB_RETRIES + MAX_TIME_ADJUSTMENTS);
    pXKerbServiceContext->Nonce[nOnceIndex] = RequestBody->nonce;
    ++pXKerbServiceContext->ctNumNonces;

    Status = STATUS_SUCCESS;

Cleanup:
    return(Status);
}

//--------------------------------------------------------------------------

// Convert a one byte service status to its corresponing HR
HRESULT ConvertServiceStatusByteToHr(BYTE status)
{
    switch(status)
    {
    case XENON_SERVICE_STATUS_SUCCESS:
        return S_OK;
    case XENON_SERVICE_STATUS_OTHER_SITE:
        return S_FALSE;
    case XENON_SERVICE_STATUS_NOT_AUTHORIZED:
        return XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED;
    default:
        return XONLINE_E_LOGON_SERVICE_TEMPORARILY_UNAVAILABLE;
    }
}

//--------------------------------------------------------------------------

KERBERR
KerbVerifyXenonTgsReply(
    IN PXKERB_TGT_CONTEXT pCombinedTGTContext,
    IN OUT PXKERB_SERVICE_CONTEXT pXKerbServiceContext_in,
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN KERB_ENCRYPTION_KEY *pSessionKey,
    IN PKERB_PA_DATA pPreAuthData
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;

    // Make sure this is a Xenon struct since it's larger
    PXKERB_SERVICE_CONTEXT_XE pXKerbServiceContext = (PXKERB_SERVICE_CONTEXT_XE)pXKerbServiceContext_in;
    Assert( pXKerbServiceContext->dwXenonFlag == XENON_SERVICE_CONTEXT_FLAG );

    pXKerbServiceContext->ClearServices();

    //see which preauth this is
    if (pPreAuthData->preauth_data_type==211) //XENON_SERVICE_ADDRESS2
    {
        PXKERB_PA_XENON_SERVICE_ADDRESS2 pPAXenonServiceAddress=NULL;

        // Allocate Service Address reply memory on stack
        pPAXenonServiceAddress=(PXKERB_PA_XENON_SERVICE_ADDRESS2)_alloca( sizeof(*pPAXenonServiceAddress) );

        // Check the pre-auth reply
        KerbErr=KerbVerifyXenonServiceAddress2PreAuth(
            pScratchMemoryAllocator,
            pPreAuthData,
            pSessionKey,
            (PXKERB_SERVICE_CONTEXT)pXKerbServiceContext,
            pPAXenonServiceAddress
            );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        //the old preauth doesn't contain a version field, but is implicitely a response to version 4
        pXKerbServiceContext->ServiceAddressPreauthVersion=4;

        // Check the master return HRESULT
        pXKerbServiceContext->hr=pPAXenonServiceAddress->hr;

        // Handle the returned Service address results
        pXKerbServiceContext->siteIPAddress=pPAXenonServiceAddress->siteIPAddress;

        int j = 0;
        for (DWORD i=0; i < XONLINE_XE_MAX_BYTE_SERVICEIDS; ++i)
        {
            BYTE bServiceID = pPAXenonServiceAddress->byteServiceResult[i].bServiceID;

            if (XONLINE_INVALID_SERVICE == bServiceID)
            {
                continue;
            }

            pXKerbServiceContext->bServiceID3[j] = bServiceID;
            pXKerbServiceContext->hrServiceBytes3[j] = ConvertServiceStatusByteToHr(pPAXenonServiceAddress->byteServiceResult[i].bResult);
            pXKerbServiceContext->wServicePortBytes3[j] = pPAXenonServiceAddress->byteServiceResult[i].wServicePort;
            j++;
        }

        j = 0;
        for (DWORD i=0; i < XONLINE_MAX_DWORD_SERVICEIDS; ++i)
        {
            DWORD dwServiceID = pPAXenonServiceAddress->dwordServiceResult[i].dwServiceID;

            if (XONLINE_INVALID_SERVICE == dwServiceID)
            {
                continue;
            }

            pXKerbServiceContext->dwServiceID3[j] = dwServiceID;
            pXKerbServiceContext->hrServiceDwords3[j] = ConvertServiceStatusByteToHr(pPAXenonServiceAddress->dwordServiceResult[i].bResult);
            pXKerbServiceContext->wServicePortDwords3[j] = pPAXenonServiceAddress->dwordServiceResult[i].wServicePort;
            j++;
        }

        // Copy the returned authorization info about users
        for (DWORD i=0; i<XONLINE_MAX_LOGON_USERS; ++i)
        {
            pXKerbServiceContext->dwUserFlags[i] = pPAXenonServiceAddress->dwUserFlags[i];
            pXKerbServiceContext->hrUser[i] = pPAXenonServiceAddress->hrUser[i];
            for (DWORD j=0; j<XONLINE_NUM_PRIVILEGE_DWORDS; ++j)
            {
                pXKerbServiceContext->dwUserPrivileges[i][j] = pPAXenonServiceAddress->dwUserPrivileges[i][j];
            }
        }

        // Copy other info
        pXKerbServiceContext->dwBwLimit = pPAXenonServiceAddress->dwBwLimit;
        pXKerbServiceContext->dwLiveTitleId = pPAXenonServiceAddress->dwLiveTitleId;
        for (DWORD i=0; i < XONLINE_MAX_LIVE_ALTERNATE_TITLE_ID; ++i)
        {
            pXKerbServiceContext->bAltServiceIds[i] = pPAXenonServiceAddress->altLiveTitleIds[i].bServiceID;
            pXKerbServiceContext->dwAltServiceTitleIds[i] = pPAXenonServiceAddress->altLiveTitleIds[i].dwAltTitleID;
        }

        pXKerbServiceContext->ConsoleBanExpireTime.dwLowDateTime=0;
        pXKerbServiceContext->ConsoleBanExpireTime.dwHighDateTime=0;
        for (DWORD i=0; i<4; ++i)
        {
            pXKerbServiceContext->UserBanExpireTime[i].dwLowDateTime=0;
            pXKerbServiceContext->UserBanExpireTime[i].dwHighDateTime=0;
        }
    }
    else if (pPreAuthData->preauth_data_type==215) //XENON_SERVICE_ADDRESS3
    {
        PXKERB_PA_XENON_SERVICE_ADDRESS3 pPAXenonServiceAddress=NULL;

        // Allocate Service Address reply memory on stack
        pPAXenonServiceAddress=(PXKERB_PA_XENON_SERVICE_ADDRESS3)_alloca( sizeof(*pPAXenonServiceAddress) );

        // Check the pre-auth reply
        KerbErr=KerbVerifyXenonServiceAddress3PreAuth(
            pScratchMemoryAllocator,
            pPreAuthData,
            pSessionKey,
            (PXKERB_SERVICE_CONTEXT)pXKerbServiceContext,
            pPAXenonServiceAddress
            );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        //the new preauth doesn't contain a version field, but is implicitely a response to version 5
        pXKerbServiceContext->ServiceAddressPreauthVersion=5;

        // Check the master return HRESULT
        pXKerbServiceContext->hr=pPAXenonServiceAddress->hr;

        // Handle the returned Service address results
        pXKerbServiceContext->siteIPAddress=pPAXenonServiceAddress->siteIPAddress;

        for (DWORD i=0; i<XONLINE_XE_MAX_BYTE_SERVICEIDS_2; ++i)
        {
            BYTE serviceID=(BYTE)i;
            DWORD serviceResult=GetServiceResult(pPAXenonServiceAddress, serviceID);

            if (0x3==serviceResult) //0b11 = invalid service
            {
                continue;
            }

            if (i<XONLINE_XE_MAX_BYTE_SERVICEIDS) //first 32
            {
                pXKerbServiceContext->bServiceID3[i]=serviceID;
                pXKerbServiceContext->hrServiceBytes3[i]=serviceResult;
                pXKerbServiceContext->wServicePortBytes3[i]=serviceID;
            }
            else //last 96
            {
                pXKerbServiceContext->bServiceID4[i-XONLINE_XE_MAX_BYTE_SERVICEIDS]=serviceID;
                pXKerbServiceContext->hrServiceBytes4[i-XONLINE_XE_MAX_BYTE_SERVICEIDS]=serviceResult;
                pXKerbServiceContext->wServicePortBytes4[i-XONLINE_XE_MAX_BYTE_SERVICEIDS]=serviceID;
            }
        }

        int j = 0;
        for (DWORD i=0; i < XONLINE_MAX_DWORD_SERVICEIDS; ++i)
        {
            DWORD dwServiceID = pPAXenonServiceAddress->dwordServiceResult[i].dwServiceID;

            if (XONLINE_INVALID_SERVICE == dwServiceID)
            {
                continue;
            }

            pXKerbServiceContext->dwServiceID3[j] = dwServiceID;
            pXKerbServiceContext->hrServiceDwords3[j] = ConvertServiceStatusByteToHr(pPAXenonServiceAddress->dwordServiceResult[i].bResult);
            pXKerbServiceContext->wServicePortDwords3[j] = pPAXenonServiceAddress->dwordServiceResult[i].wServicePort;
            j++;
        }

        // Copy the returned authorization info about users
        for (DWORD i=0; i<XONLINE_MAX_LOGON_USERS; ++i)
        {
            pXKerbServiceContext->dwUserFlags[i] = pPAXenonServiceAddress->dwUserFlags[i];
            pXKerbServiceContext->hrUser[i] = pPAXenonServiceAddress->hrUser[i];

            for (DWORD j=0; j<3; ++j)
            {
                pXKerbServiceContext->dwUserPrivileges[i][j+5] = pPAXenonServiceAddress->dwUserPrivileges[i][j];
            }

            pXKerbServiceContext->dwUserPrivileges[i][4] = pPAXenonServiceAddress->dwMachinePrivileges; //just copy to all users
        }

        // Copy other info
        pXKerbServiceContext->dwBwLimit = 0;
        pXKerbServiceContext->dwLiveTitleId = pPAXenonServiceAddress->dwLiveTitleId;
        for (DWORD i=0; i < XONLINE_MAX_LIVE_ALTERNATE_TITLE_ID; ++i)
        {
            pXKerbServiceContext->bAltServiceIds[i] = pPAXenonServiceAddress->altLiveTitleIds[i].bServiceID;
            pXKerbServiceContext->dwAltServiceTitleIds[i] = pPAXenonServiceAddress->altLiveTitleIds[i].dwAltTitleID;
        }

        pXKerbServiceContext->FlowToken=pPAXenonServiceAddress->flowToken.flowToken;

        pXKerbServiceContext->ConsoleBanExpireTime.dwLowDateTime=0;
        pXKerbServiceContext->ConsoleBanExpireTime.dwHighDateTime=0;
        for (DWORD i=0; i<4; ++i)
        {
            pXKerbServiceContext->UserBanExpireTime[i].dwLowDateTime=0;
            pXKerbServiceContext->UserBanExpireTime[i].dwHighDateTime=0;
        }
    }
    else if (pPreAuthData->preauth_data_type==217) //XENON_SERVICE_ADDRESS_FAILED
    {
        PXKERB_PA_XENON_SERVICE_ADDRESS_FAILED pPAXenonServiceAddress=NULL;

        // Allocate Service Address reply memory on stack
        pPAXenonServiceAddress=(PXKERB_PA_XENON_SERVICE_ADDRESS_FAILED)_alloca( sizeof(*pPAXenonServiceAddress) );

        // Check the pre-auth reply
        KerbErr = KerbVerifyXenonServiceAddressFailedPreAuth(
            pScratchMemoryAllocator,
            pPreAuthData,
            pSessionKey,
            (PXKERB_SERVICE_CONTEXT)pXKerbServiceContext,
            pPAXenonServiceAddress
            );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        //the new preauth doesn't contain a version field, but is implicitely a response to version 6
        pXKerbServiceContext->ServiceAddressPreauthVersion=6;

        // Check the master return HRESULT
        pXKerbServiceContext->hr=pPAXenonServiceAddress->hrConsole;

        pXKerbServiceContext->siteIPAddress.s_addr=0;

        for (DWORD i=0; i<XONLINE_XE_MAX_BYTE_SERVICEIDS_2; ++i)
        {
            BYTE serviceID=(BYTE)i;

            if (i<XONLINE_XE_MAX_BYTE_SERVICEIDS) //first 32
            {
                pXKerbServiceContext->bServiceID3[i]=serviceID;
                pXKerbServiceContext->hrServiceBytes3[i]=0x03;
                pXKerbServiceContext->wServicePortBytes3[i]=0;
            }
            else //last 96
            {
                pXKerbServiceContext->bServiceID4[i-XONLINE_XE_MAX_BYTE_SERVICEIDS]=serviceID;
                pXKerbServiceContext->hrServiceBytes4[i-XONLINE_XE_MAX_BYTE_SERVICEIDS]=0x03;
                pXKerbServiceContext->wServicePortBytes4[i-XONLINE_XE_MAX_BYTE_SERVICEIDS]=0;
            }
        }

        int j = 0;
        for (DWORD i=0; i < XONLINE_MAX_DWORD_SERVICEIDS; i++)
        {
            pXKerbServiceContext->dwServiceID3[j] = 0;
            pXKerbServiceContext->hrServiceDwords3[j] = 0x03;
            pXKerbServiceContext->wServicePortDwords3[j] = 0;
            ++j;
        }

        // Copy the returned authorization info about users
        for (DWORD i=0; i<XONLINE_MAX_LOGON_USERS; ++i)
        {
            pXKerbServiceContext->dwUserFlags[i]=0;
            pXKerbServiceContext->hrUser[i]=pPAXenonServiceAddress->hrUser[i];

            for (DWORD j=0; j<3; ++j)
            {
                pXKerbServiceContext->dwUserPrivileges[i][j+5]=0;
            }

            pXKerbServiceContext->dwUserPrivileges[i][4]=0;
        }

        // Copy other info
        pXKerbServiceContext->dwBwLimit=0;
        pXKerbServiceContext->dwLiveTitleId=0;
        for (DWORD i=0; i<XONLINE_MAX_LIVE_ALTERNATE_TITLE_ID; ++i)
        {
            pXKerbServiceContext->bAltServiceIds[i]=0;
            pXKerbServiceContext->dwAltServiceTitleIds[i]=0;
        }

        pXKerbServiceContext->FlowToken=0;

        pXKerbServiceContext->ConsoleBanExpireTime=pPAXenonServiceAddress->ftConsoleBanExpireTime;
        for (DWORD i=0; i<4; ++i)
        {
            pXKerbServiceContext->UserBanExpireTime[i]=pPAXenonServiceAddress->ftUserBanExpireTime[i];
        }
    }
    else
    {
        TraceSz1( AuthWarn, "KerbVerifyXenonTgsReply: Unknown preauth returned from the KDC: %d", pPreAuthData->preauth_data_type );
        KerbErr=-1; //invalid
    }

 Cleanup:
    return KerbErr;
}

//--------------------------------------------------------------------------


// Xbox XKDC verify entry point
//
NTSTATUS WINAPI
kcl_VerifyXboxTgsReply(
    IN PXKERB_TGT_CONTEXT pCombinedTGTContext,
    IN PUCHAR pbReplyMessage,
    IN ULONG dwReplyMessageLength,
    IN OUT PXKERB_SERVICE_CONTEXT pXKerbServiceContext
    )
{
    ClearStoredDebugSpew();
    //Xbox1 code has been removed, return failure.
    return STATUS_LOGON_FAILURE;
}

//--------------------------------------------------------------------------

// Xenon XKDC verify entry point
//
NTSTATUS WINAPI
kcl_VerifyXenonTgsReply(
    IN PXKERB_TGT_CONTEXT pCombinedTGTContext,
    IN PUCHAR pbReplyMessage,
    IN ULONG dwReplyMessageLength,
    IN OUT PXKERB_SERVICE_CONTEXT pXKerbServiceContext,
    OUT BYTE *pReturnedSessionKeyFromTgt //pointer to 16 bytes to store the key at
    )
{
    ClearStoredDebugSpew();

    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr;
    PKERB_KDC_REPLY KdcReply = NULL;
    PKERB_ENCRYPTED_KDC_REPLY ReplyBody = NULL;
    KERB_ENCRYPTION_KEY SessionKey;
    PKERB_PA_DATA pPreAuthData;
    PXKERB_PA_XENON_SERVICE_ADDRESS2 pPAXenonServiceAddress = NULL;
    PUCHAR pEncodedTicket;
    DWORD i,j;
    const UCHAR* pbScratchMemory;
    CScratchMemoryAllocator ScratchMemoryAllocator;

    Assert(pCombinedTGTContext != NULL);
    Assert(pXKerbServiceContext != NULL);

    //
    // Initialize scratch memory
    //
    pbScratchMemory = (PUCHAR)ScratchMemoryAllocator.ScratchMemoryInitialize( SCRATCH_MEMORY_SIZE_FOR_VerifyTgsReply, NULL, 0);

    //
    // Unpack the reply
    //
    KerbErr = KerbUnpackTgsReply(
        &ScratchMemoryAllocator,
        pbReplyMessage,
        dwReplyMessageLength,
        &KdcReply
        );
    if (!KERB_SUCCESS(KerbErr))
    {
        PKERB_ERROR ErrorMessage = NULL;

        //
        // Try to unpack it as  kerb_error
        //

        KerbErr =  KerbUnpackKerbError(
            &ScratchMemoryAllocator,
            pbReplyMessage,
            dwReplyMessageLength,
            &ErrorMessage
            );
        if (KERB_SUCCESS(KerbErr))
        {
            KerbErr = (KERBERR) ErrorMessage->error_code;
            TraceSz1( AuthWarn,"kcl_VerifyXenonTgsReply: Got KerbError 0x%X", KerbErr );

            Status = KerbMapKerbError(KerbErr);

            i = pXKerbServiceContext->ctNumNonces;
            if ((ErrorMessage->bit_mask & error_text_present) &&
                ErrorMessage->error_text.length == sizeof(DWORD) &&
                ErrorMessage->error_text.value != NULL)
            {
                for (i=0; i<pXKerbServiceContext->ctNumNonces; ++i)
                {
                    if (memcmp( &(pXKerbServiceContext->Nonce[i]), ErrorMessage->error_text.value, sizeof(DWORD)) == 0)
                    {
                        break;
                    }
                }
            }
            if (i == pXKerbServiceContext->ctNumNonces)
            {
                TraceSz( AuthWarn, "kcl_VerifyXenonTgsReply: got a kerb error with a mismatching nonce, ignoring it" );
                Status = STATUS_LOGON_FAILURE;
                goto Cleanup;
            }

            //
            // Check for time skew. If we got a skew error, record the time
            // skew between here and the KDC in the ticket so we can retry
            // with the correct time.
            //
            if (KerbErr == KRB_AP_ERR_SKEW)
            {
                TimeStamp KdcTime;

                KerbConvertGeneralizedTimeToLargeInt(
                    &KdcTime,
                    &ErrorMessage->server_time,
                    ErrorMessage->server_usec
                    );

                KerbUpdateCurrentTime( KdcTime );
            }
            KerbFreeKerbError(ErrorMessage);
        }
        else
        {
            Status = STATUS_LOGON_FAILURE;
        }
        goto Cleanup;
    }

    //
    // Construct encryption key struct for session key
    //
    KerbCreateKeyFromBuffer(
        &SessionKey,
        pCombinedTGTContext->SessionKey,
        XONLINE_KEY_LENGTH,
        KERB_ETYPE_RC4_HMAC_NT
        );

    if (pReturnedSessionKeyFromTgt)
    {
        memcpy(pReturnedSessionKeyFromTgt, pCombinedTGTContext->SessionKey, 16);
    }

    //
    // Get the XKERB_PA_XENON_SERVICE_ADDRESS2 pre-auth
    //
    pPreAuthData = KerbFindPreAuthDataEntry(KRB5_PADATA_XENON_SERVICE_ADDRESS2, (PKERB_PA_DATA_LIST)KdcReply->preauth_data);
    if (pPreAuthData == NULL) //no address2
    {
        pPreAuthData = KerbFindPreAuthDataEntry(KRB5_PADATA_XENON_SERVICE_ADDRESS3, (PKERB_PA_DATA_LIST)KdcReply->preauth_data);
        if (pPreAuthData == NULL) //no address3
        {
            pPreAuthData = KerbFindPreAuthDataEntry(KRB5_PADATA_XENON_SERVICE_ADDRESS_FAILED, (PKERB_PA_DATA_LIST)KdcReply->preauth_data);
            if (pPreAuthData == NULL) //no address failure
            {
                TraceSz(AuthWarn, "kcl_VerifyXenonTgsReply: missing PA_XENON_SERVICE_ADDRESS2/PA_XENON_SERVICE_ADDRESS3/PA_XENON_SERVICE_ADDRESS_FAILURE preauth.");
                Status = STATUS_LOGON_FAILURE;
                goto Cleanup;
            }
        }
    }

    KerbErr = KerbVerifyXenonTgsReply(
        pCombinedTGTContext,
        pXKerbServiceContext,
        &ScratchMemoryAllocator,
        &SessionKey,
        pPreAuthData
        );

    if ( !KERB_SUCCESS(KerbErr) )
    {
        Status = KerbErr;
        goto Cleanup;
    }

    //
    // Cache the ticket
    //
    {
        CReleaseAllScratchMemoryUponDestruction onlyPreserveThisMemory( &ScratchMemoryAllocator );

        pXKerbServiceContext->dwTicketLength = 0;
        pEncodedTicket = NULL;
        KerbErr = KerbPackData(
            &ScratchMemoryAllocator,
            &KdcReply->ticket,
            KERB_TICKET_PDU,
            &pXKerbServiceContext->dwTicketLength,
            &pEncodedTicket
            );
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        if (pXKerbServiceContext->dwTicketLength > XONLINE_MAX_TICKET_LENGTH)
        {
            TraceSz1( AuthWarn, "kcl_VerifyXenonTgsReply: got a ticket too big: %d", pXKerbServiceContext->dwTicketLength );
            Status = STATUS_LOGON_FAILURE;
            goto Cleanup;
        }

        memcpy(
            pXKerbServiceContext->Ticket,
            pEncodedTicket,
            pXKerbServiceContext->dwTicketLength
            );
    }

    //
    // Now unpack the reply body:
    //
    KerbErr = KerbUnpackKdcReplyBody(
        &ScratchMemoryAllocator,
        &KdcReply->encrypted_part,
        &SessionKey,
        KERB_ENCRYPTED_TGS_REPLY_PDU,
        &ReplyBody
        );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    //
    // Verify the nonce is correct:
    //
    for (i=0; i<pXKerbServiceContext->ctNumNonces; ++i)
    {
        if (pXKerbServiceContext->Nonce[i] == (DWORD)ReplyBody->nonce)
        {
            break;
        }
    }
    if (i == pXKerbServiceContext->ctNumNonces)
    {
        TraceSz3( AuthWarn, "kcl_VerifyXenonTgsReply: All %d Nonces don't match: 0x%X vs 0x%X", i, pXKerbServiceContext->Nonce[0], ReplyBody->nonce);
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    //
    // Cache the session key
    //
    if (ReplyBody->session_key.keytype != KERB_ETYPE_RC4_HMAC_NT ||
        ReplyBody->session_key.keyvalue.length != XONLINE_KEY_LENGTH)
    {
        TraceSz2( AuthWarn, "kcl_VerifyXenonTgsReply got a session key of the wrong type (%d) or length(%d)",
            ReplyBody->session_key.keytype, ReplyBody->session_key.keyvalue.length
            );
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    memcpy( pXKerbServiceContext->SessionKey, ReplyBody->session_key.keyvalue.value, XONLINE_KEY_LENGTH );

    //
    // Copy the principal name (might be different because of name canonicalization)
    //
    KerbErr = KerbPrincipalNameToMultiString(
        &KdcReply->client_name,
        sizeof(pXKerbServiceContext->ClientName),
        pXKerbServiceContext->ClientName
        );
    if (!KERB_SUCCESS(KerbErr))
    {
        TraceSz( AuthWarn, "kcl_VerifyXenonTgsReply: returned client name is too long" );
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    if ( strlen(KdcReply->client_realm) <= XONLINE_MAX_KERBEROSREALM_LENGTH )
    {
        lstrcpynA(pXKerbServiceContext->ClientRealm, KdcReply->client_realm, sizeof(pXKerbServiceContext->ClientRealm));
    }
    else
    {
        TraceSz( AuthWarn, "kcl_VerifyXenonTgsReply: returned client realm is too long" );
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    //
    // Cache the expiration time
    //
    KerbConvertGeneralizedTimeToLargeInt(
        &pXKerbServiceContext->ExpirationTime,
        &ReplyBody->endtime,
        0
        );

    KerbConvertGeneralizedTimeToLargeInt(
        &pXKerbServiceContext->StartTime,
        &ReplyBody->starttime,
        0
        );

    //
    // Verbose trace info
    //
    TraceSz6( AuthVerbose,"kcl_VerifyXenonTgsReply: extracted %d byte ticket (expires in %d secs) from %d byte reply matching try %d for %s KerbRealm:%s",
        pXKerbServiceContext->dwTicketLength,
        (ULONG)((pXKerbServiceContext->ExpirationTime.QuadPart -pXKerbServiceContext->StartTime.QuadPart) / 10000000),
        dwReplyMessageLength, i + 1,
        KdcReply->client_name.name_string->value,
        KdcReply->client_realm
        );

Cleanup:
    return(Status);
}

//--------------------------------------------------------------------------

NTSTATUS WINAPI
kcl_BuildApRequest(
    IN PXKERB_SERVICE_CONTEXT pServiceContext,
    OUT LARGE_INTEGER * pliTime,
    IN BYTE * pbSha,
    IN UINT cbSha,
    OUT PUCHAR pbRequestMessage,
    IN OUT UINT * pdwRequestMessageLength
    )
{
    ClearStoredDebugSpew();

    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr;
    ULONG ApOptions = KERB_AP_OPTIONS_mutual_required;
    ULONG RequestSize;
    PUCHAR MarshalledApRequest;
    ULONG ApRequestSize;
    KERB_ENCRYPTION_KEY SessionKey;
    PKERB_TICKET pTicket = NULL;
    KERB_CHECKSUM RequestChecksum;
    const UCHAR* pbScratchMemory;
    CScratchMemoryAllocator ScratchMemoryAllocator;

    //
    // Initialize scratch memory
    //
    pbScratchMemory = (PUCHAR)ScratchMemoryAllocator.ScratchMemoryInitialize( SCRATCH_MEMORY_SIZE_FOR_BuildApRequest, pbRequestMessage, *pdwRequestMessageLength);

    //
    // Set the authenticator time
    //
    KerbGetCurrentTime( pliTime );

    //
    // Construct encryption key struct for session key
    //
    KerbCreateKeyFromBuffer(
        &SessionKey,
        pServiceContext->SessionKey,
        XONLINE_KEY_LENGTH,
        KERB_ETYPE_RC4_HMAC_NT
        );

    //
    // Construct kerb ticket structure from packed data
    //
    KerbErr = KerbUnpackData(
                &ScratchMemoryAllocator,
                pServiceContext->Ticket,
                pServiceContext->dwTicketLength,
                KERB_TICKET_PDU,
                (PVOID*)&pTicket
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Setup the application checksum
    //
    ZeroMemory( &RequestChecksum, sizeof(KERB_CHECKSUM) );
    RequestChecksum.checksum.value = pbSha;
    RequestChecksum.checksum.length = cbSha;
    RequestChecksum.checksum_type = KERB_CHECKSUM_SHA1;

    //
    // Create the AP request
    //
    ApRequestSize = *pdwRequestMessageLength;
    MarshalledApRequest = pbRequestMessage;
    KerbErr = KerbCreateApRequest(
                &ScratchMemoryAllocator,
                pServiceContext->ClientName,
                pServiceContext->ClientRealm,
                &SessionKey,
                0, // KerbAllocateNonce(),
                pliTime,
                pTicket,
                ApOptions,
                &RequestChecksum,
                FALSE,                          // not a KDC request
                &ApRequestSize,
                &MarshalledApRequest
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    *pdwRequestMessageLength = ApRequestSize;

Cleanup:
    return(Status);
}

//--------------------------------------------------------------------------

NTSTATUS WINAPI
kcl_VerifyApReply(
    IN PXKERB_SERVICE_CONTEXT pServiceContext,
    IN LARGE_INTEGER * pliTimes,
    IN UINT cTimes,
    OUT BYTE * pbSha,
    IN UINT cbSha,
    IN PUCHAR pbReplyMessage,
    IN UINT dwReplyMessageLength
    )
{
    ClearStoredDebugSpew();

    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr;
    PKERB_AP_REPLY Reply = NULL;
    PKERB_ENCRYPTED_AP_REPLY ReplyBody = NULL;
    KERB_TIME ReplyAuthenticatorTime;
    long ReplyAuthenticatorUsec;
    KERB_ENCRYPTION_KEY SessionKey;
    const UCHAR* pbScratchMemory;
    CScratchMemoryAllocator ScratchMemoryAllocator;
    DWORD i;

    TraceSz7( AuthVerbose, "kcl_VerifyApReply got %d bytes (%d tries sent) from site at %d.%d.%d.%d for %d services",
        dwReplyMessageLength, cTimes,
        pServiceContext->siteIPAddress.S_un.S_un_b.s_b1,
        pServiceContext->siteIPAddress.S_un.S_un_b.s_b2,
        pServiceContext->siteIPAddress.S_un.S_un_b.s_b3,
        pServiceContext->siteIPAddress.S_un.S_un_b.s_b4,
        pServiceContext->dwNumServices
        );

    //
    // Initialize scratch memory
    //
    pbScratchMemory = (PUCHAR)ScratchMemoryAllocator.ScratchMemoryInitialize( SCRATCH_MEMORY_SIZE_FOR_VerifyApReply, NULL, 0);

    KerbErr = KerbUnpackApReply(
                    &ScratchMemoryAllocator,
                    pbReplyMessage,
                    dwReplyMessageLength,
                    &Reply
                    );

    if (!KERB_SUCCESS(KerbErr))
    {
        TraceSz1(AuthWarn, "kcl_VerifyApReply, failed to unpack AP reply, KerbErr = 0x%x", KerbErr);
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    if ((Reply->version != KERBEROS_VERSION) ||
        (Reply->message_type != KRB_AP_REP))
    {
        TraceSz2( AuthWarn, "kcl_VerifyApReply: Illegal version (0x%X) or message type (0x%X)",
            Reply->version, Reply->message_type
            );
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    //
    // Construct encryption key struct for session key
    //
    KerbCreateKeyFromBuffer(
        &SessionKey,
        pServiceContext->SessionKey,
        XONLINE_KEY_LENGTH,
        KERB_ETYPE_RC4_HMAC_NT
        );

    //
    // Now decrypt the encrypted part.
    //
    KerbErr = KerbDecryptDataEx(
                &ScratchMemoryAllocator,
                &Reply->encrypted_part,
                &SessionKey,
                KERB_AP_REP_SALT,
                (PULONG) &Reply->encrypted_part.cipher_text.length,
                Reply->encrypted_part.cipher_text.value
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        TraceSz1(AuthWarn, "kcl_VerifyApReply, failed to decrypt AP reply body, KerbErr = 0x%x", KerbErr);

        if (KerbErr == KRB_ERR_GENERIC)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            Status = STATUS_LOGON_FAILURE;
        }
        goto Cleanup;
    }

    //
    // Decode the contents now
    //

    KerbErr = KerbUnpackApReplyBody(
                    &ScratchMemoryAllocator,
                    Reply->encrypted_part.cipher_text.value,
                    Reply->encrypted_part.cipher_text.length,
                    &ReplyBody
                    );

    if (!KERB_SUCCESS(KerbErr))
    {
        TraceSz1(AuthWarn, "kcl_VerifyApReply, failed to unpack AP reply body, KerbErr = 0x%x", KerbErr);
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Check all the authenticator times
    //
    for (i=0; i<cTimes; ++i)
    {
        KerbConvertLargeIntToGeneralizedTime(
            &ReplyAuthenticatorTime,
            &ReplyAuthenticatorUsec,
            pliTimes
            );

        ++pliTimes;

        if ((ReplyAuthenticatorUsec == ReplyBody->client_usec) &&
            memcmp( &ReplyAuthenticatorTime, &(ReplyBody->client_time), sizeof(ReplyAuthenticatorTime) ) == 0)
        {
            break;
        }
    }
    if (i == cTimes)
    {
        TraceSz( AuthWarn, "kcl_VerifyApReply: clientTime and clientUsec verification failed" );
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    //
    // Check to see if a session key was sent back.
    // This session key is the returned application checksum.
    //
    if ((ReplyBody->bit_mask & KERB_ENCRYPTED_AP_REPLY_subkey_present) == 0)
    {
        TraceSz( AuthWarn, "kcl_VerifyApReply didn't get a application checksum" );
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    if (ReplyBody->KERB_ENCRYPTED_AP_REPLY_subkey.keytype != KERB_CHECKSUM_SHA1 ||
        ReplyBody->KERB_ENCRYPTED_AP_REPLY_subkey.keyvalue.length != cbSha)
    {
        TraceSz2( AuthWarn, "kcl_VerifyApReply got a session key of the wrong type (%d) or length(%d)",
            ReplyBody->KERB_ENCRYPTED_AP_REPLY_subkey.keytype, ReplyBody->KERB_ENCRYPTED_AP_REPLY_subkey.keyvalue.length
            );
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    memcpy( pbSha, ReplyBody->KERB_ENCRYPTED_AP_REPLY_subkey.keyvalue.value, cbSha );

    Status = STATUS_SUCCESS;

Cleanup:
    return(Status);
}

//+-------------------------------------------------------------------------

VOID
KerbConvertGeneralizedTimeToLargeInt(
    OUT PTimeStamp TimeStamp,
    IN PKERB_TIME ClientTime,
    IN int ClientUsec
    )
{
    KERB_TIME ZeroTime;
    TIME_FIELDS TimeFields;

    //
    // Special case zero time
    //

    ZeroMemory(
        &ZeroTime,
        sizeof(KERB_TIME)
        );

    ZeroTime.universal = TRUE;

    //
    // Skip this check after 3/1/1997 - no clients should send this sort of
    // zero time
    //
    if (!memcmp(
            &ZeroTime,
            ClientTime,
            sizeof(KERB_TIME)
            ))
    {
        KerbSetTime(TimeStamp,0);
        return;
    }

    //
    // Check for MIT zero time
    //

    ZeroTime.year = 1970;
    ZeroTime.month = 1;
    ZeroTime.day = 1;

    if (!memcmp(
            &ZeroTime,
            ClientTime,
            sizeof(KERB_TIME)
            ))
    {
        KerbSetTime(TimeStamp,0);
        return;
    }
    else
    {
        TimeFields.Year = ClientTime->year;
        TimeFields.Month = ClientTime->month;
        TimeFields.Day = ClientTime->day;
        TimeFields.Hour = ClientTime->hour;
        TimeFields.Minute = ClientTime->minute;
        TimeFields.Second = ClientTime->second;
        TimeFields.Milliseconds = ClientTime->millisecond;  // to convert from micro to milli
        TimeFields.Weekday = 0;

        TimeFieldsToTime(
            &TimeFields,
            TimeStamp
            );

        //
        // add in any micro seconds
        //

        KerbGetTime(*TimeStamp) += ClientUsec * 10;

    }

}


//+-------------------------------------------------------------------------

VOID
KerbConvertLargeIntToGeneralizedTime(
    OUT PKERB_TIME ClientTime,
    OUT OPTIONAL LONG* ClientUsec,
    IN PTimeStamp TimeStamp
    )
{
    TIME_FIELDS TimeFields;

    //
    // This zeroing is needed or else a useless byte in the middle might be different
    //
    ZeroMemory(
        ClientTime,
        sizeof(KERB_TIME)
        );

    //
    // Special case zero time
    //

    if (KerbGetTime(*TimeStamp) == 0)
    {
        //
        // For MIT compatibility, time zero is 1/1/70
        //
        ClientTime->year = 1970;
        ClientTime->month = 1;
        ClientTime->day = 1;

        if (ARGUMENT_PRESENT(ClientUsec))
        {
            *ClientUsec  = 0;
        }
        ClientTime->universal = TRUE;
    }
    else
    {

        TimeToTimeFields(
            (LARGE_INTEGER*)TimeStamp,
            &TimeFields
            );

        //
        // Generalized times can only contains years up to four digits.
        //

        if (TimeFields.Year > 2037)
        {
            ClientTime->year = 2037;
        }
        else
        {
            ClientTime->year = TimeFields.Year;
        }
        ClientTime->month = (ASN1uint8_t) TimeFields.Month;
        ClientTime->day = (ASN1uint8_t) TimeFields.Day;
        ClientTime->hour = (ASN1uint8_t) TimeFields.Hour;
        ClientTime->minute = (ASN1uint8_t) TimeFields.Minute;
        ClientTime->second = (ASN1uint8_t) TimeFields.Second;

        //
        // MIT kerberos does not support millseconds
        //
        // ClientTime->millisec = TimeFields.Milliseconds;
        //

        ClientTime->millisecond = 0;

        if (ARGUMENT_PRESENT(ClientUsec))
        {
            //
            // The low part of time is 100 nanoseconds, so one 10th of that
            // is microseconds. We only want the microseconds not included
            // in the milliseconds above.
            //
            // since we don't include milliseconds above, use the whole
            // thing here.
            //

            *ClientUsec = (LONG)((TimeStamp->QuadPart / 10) % 1000000);
        }

        ClientTime->diff = 0;
        ClientTime->universal = TRUE;
    }

}

//+---------------------------------------------------------------------------

KERBERR NTAPI
KerbCreateAuthenticator(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN const KERB_ENCRYPTION_KEY* pkKey,
    IN ULONG EncryptionType,
    IN ULONG SequenceNumber,
    IN PTimeStamp pAuthenticatorTime,
    IN LPSTR ClientName,
    IN LPSTR ClientRealm,
    IN OPTIONAL const KERB_CHECKSUM* Checksum,
    IN BOOLEAN KdcRequest,
    OUT PKERB_ENCRYPTED_DATA Authenticator
    )
{
    KERB_AUTHENTICATOR InternalAuthenticator;
    PKERB_AUTHENTICATOR AuthPointer = &InternalAuthenticator;
    ULONG cbAuthenticator;
    PUCHAR PackedAuthenticator;
    KERBERR KerbErr = KDC_ERR_NONE;

    Authenticator->cipher_text.value = NULL;

    ZeroMemory(
        &InternalAuthenticator,
        sizeof(KERB_AUTHENTICATOR)
        );

    // Build an authenticator

    InternalAuthenticator.authenticator_version = KERBEROS_VERSION;

    InternalAuthenticator.client_realm = ClientRealm;

    KerbErr = KerbMultiStringToPrincipalName(
                pScratchMemoryAllocator,
                ClientName,
                &InternalAuthenticator.client_name
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Stick the correct time in the authenticator
    //

    KerbConvertLargeIntToGeneralizedTime(
        &InternalAuthenticator.client_time,
        &InternalAuthenticator.client_usec,
        pAuthenticatorTime
        );


    InternalAuthenticator.bit_mask |= KERB_AUTHENTICATOR_sequence_number_present;

    InternalAuthenticator.KERB_AUTHENTICATOR_sequence_number = SequenceNumber;

    //
    // If the checksum is present, include it and set it in the bitmask
    //

    if (ARGUMENT_PRESENT(Checksum))
    {
        InternalAuthenticator.checksum = *Checksum;
        InternalAuthenticator.bit_mask |= checksum_present;
    }

    cbAuthenticator = 0;
    PackedAuthenticator = NULL;
    KerbErr = KerbPackData(
                pScratchMemoryAllocator,
                AuthPointer,
                KERB_AUTHENTICATOR_PDU,
                &cbAuthenticator,
                &PackedAuthenticator
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Now we need to encrypt the buffer
    //

        KerbErr = KerbAllocateEncryptionBuffer(
                pScratchMemoryAllocator,
                EncryptionType,
                cbAuthenticator,
                &Authenticator->cipher_text.length,
                &Authenticator->cipher_text.value
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }


    KerbErr = KerbEncryptDataEx(
                pScratchMemoryAllocator,
                Authenticator,
                cbAuthenticator,
                PackedAuthenticator,
                EncryptionType,
                KdcRequest ? KERB_TGS_REQ_AP_REQ_AUTH_SALT : KERB_AP_REQ_AUTH_SALT,
                pkKey
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

Cleanup:
    if (!KERB_SUCCESS(KerbErr))
    {
        TraceSz1( AuthWarn, "KerbCreateAuthenticator failure KerbErr 0x%X", KerbErr );
    }
    return(KerbErr);
}


//+-------------------------------------------------------------------------

KERBERR NTAPI
KerbUnpackKdcReplyBody(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PKERB_ENCRYPTED_DATA EncryptedReplyBody,
    IN PKERB_ENCRYPTION_KEY Key,
    IN ULONG Pdu,
    OUT PKERB_ENCRYPTED_KDC_REPLY * ReplyBody
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PUCHAR MarshalledReply = NULL;
    ULONG ReplySize;

    *ReplyBody = NULL;
    MarshalledReply = (PUCHAR) pScratchMemoryAllocator->Alloc(EncryptedReplyBody->cipher_text.length);

    if (MarshalledReply == NULL)
    {
        return(KRB_ERR_GENERIC);
    }

    //
    // First decrypt the buffer
    //

    ReplySize = EncryptedReplyBody->cipher_text.length;
    KerbErr = KerbDecryptDataEx(
                pScratchMemoryAllocator,
                EncryptedReplyBody,
                Key,
                (Pdu == KERB_AS_REPLY_PDU) ? KERB_AS_REP_SALT : KERB_TGS_REP_SALT, //NOTE: A bug here is shared by our KDC, so we always use the tgs salt even in the as case.  The expression should be Pdu==KERB_ENCRYPTED_AS_REPLY_PDU.
                &ReplySize,
                MarshalledReply
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = KerbUnpackData(
                pScratchMemoryAllocator,
                MarshalledReply,
                ReplySize,
                Pdu,
                (PVOID *) ReplyBody
                );

    if (!KERB_SUCCESS(KerbErr))
    {

        //
        // MIT KDCs send back TGS reply bodies instead of AS reply bodies
        // so try TGS here
        //

        if (Pdu == KERB_ENCRYPTED_AS_REPLY_PDU)
        {
            KerbErr = KerbUnpackData(
                        pScratchMemoryAllocator,
                        MarshalledReply,
                        ReplySize,
                        KERB_ENCRYPTED_TGS_REPLY_PDU,
                        (PVOID *) ReplyBody
                        );
        }
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

    }
Cleanup:
    if (!KERB_SUCCESS(KerbErr) && (*ReplyBody != NULL))
    {
        *ReplyBody = NULL;
    }

    if (!KERB_SUCCESS(KerbErr))
    {
        TraceSz1( AuthWarn, "KerbUnpackKdcReplyBody failure with  KerbErr 0x%X", KerbErr );
    }

    return(KerbErr);
}

//+-------------------------------------------------------------------------

KERBERR
KerbCreateApRequest(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN LPSTR ClientName,
    IN LPSTR ClientRealm,
    IN const KERB_ENCRYPTION_KEY* SessionKey,
    IN ULONG Nonce,
    IN PTimeStamp pAuthenticatorTime,
    IN const KERB_TICKET* ServiceTicket,
    IN ULONG ApOptions,
    IN OPTIONAL const KERB_CHECKSUM* Checksum,
    IN BOOLEAN KdcRequest,
    OUT PULONG RequestSize,
    OUT PUCHAR * Request
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    KERB_AP_REQUEST ApRequest;
    ULONG ApFlags;
    BOOL fDestinationBufferUnspecified = (*Request == NULL);

    ZeroMemory(
        &ApRequest,
        sizeof(KERB_AP_REQUEST)
        );

    //
    // Fill in the AP request structure.
    //

    ApRequest.version = KERBEROS_VERSION;
    ApRequest.message_type = KRB_AP_REQ;
    ApFlags = KerbConvertUlongToFlagUlong(ApOptions);
    ApRequest.ap_options.value = (PUCHAR) &ApFlags;
    ApRequest.ap_options.length = sizeof(ULONG) * 8;
    ApRequest.ticket = *ServiceTicket;

    {
        CReleaseAllScratchMemoryUponDestruction onlyPreserveThisMemory( pScratchMemoryAllocator );

        //
        // Create the authenticator for the request
        //

        KerbErr = KerbCreateAuthenticator(
                    pScratchMemoryAllocator,
                    SessionKey,
                    SessionKey->keytype,
                    Nonce,
                    pAuthenticatorTime,
                    ClientName,
                    ClientRealm,
                    Checksum,
                    KdcRequest,
                    &ApRequest.authenticator
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        //
        // Now marshall the request
        //
        KerbErr = KerbPackApRequest(
                    pScratchMemoryAllocator,
                    &ApRequest,
                    RequestSize,
                    Request
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        if (fDestinationBufferUnspecified)
        {
            //
            // Preserve the only piece of memory we care about
            //
            PreserveThisMemory( &onlyPreserveThisMemory, Request, *RequestSize );
        }
    }

Cleanup:
    if (!KERB_SUCCESS(KerbErr))
    {
        TraceSz1( AuthWarn, "KerbCreateApRequest failure KerbErr 0x%X", KerbErr );
    }
    return(KerbErr);
}

//+-------------------------------------------------------------------------

KERBERR
KerbInitAsn(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN OUT ASN1encoding_t * pEnc,
    IN OUT ASN1decoding_t * pDec
    )
{
    KERBERR KerbErr = KRB_ERR_GENERIC;
    ASN1error_e Asn1Err;

    if (pEnc != NULL)
    {
            Asn1Err = ASN1_CreateEncoder(
                                     pScratchMemoryAllocator,
                                     &g_KerbAsnModule,
                                     pEnc,
                                     NULL,           // pbBuf
                                     0,              // cbBufSize
                                     NULL            // pParent
                                     );
    }
    else
    {
            Asn1Err = ASN1_CreateDecoder(
                                     pScratchMemoryAllocator,
                                     &g_KerbAsnModule,
                                     pDec,
                                     NULL,           // pbBuf
                                     0,              // cbBufSize
                                     NULL            // pParent
                                     );
    }

    if (ASN1_SUCCESS != Asn1Err)
    {
            goto Cleanup;
    }

    KerbErr = KDC_ERR_NONE;

Cleanup:
    if (!KERB_SUCCESS(KerbErr))
    {
        TraceSz2(AuthWarn, "KerbInitAsn failure, KerbErr=0x%X, AsnErr=0x%X", KerbErr, Asn1Err);
    }

    return(KerbErr);
}


//+-------------------------------------------------------------------------

VOID
KerbTermAsn(
        IN ASN1encoding_t pEnc,
        IN ASN1decoding_t pDec
    )
{
    if (pEnc != NULL)
    {
            ASN1_CloseEncoder(pEnc);
    }
    else if (pDec != NULL)
    {
            ASN1_CloseDecoder(pDec);
    }
}

//+-------------------------------------------------------------------------

KERBERR NTAPI
KerbPackData(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PVOID Data,
    IN ULONG PduValue,
    OUT PULONG DataSize,
    OUT PUCHAR * MarshalledData
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    int Result = 0;
    ASN1encoding_t pEnc = NULL;
    ASN1error_e Asn1Err = ASN1_SUCCESS;

    KerbErr = KerbInitAsn(
                pScratchMemoryAllocator,
                &pEnc,          // we are encoding
                NULL
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    {
        CReleaseAllScratchMemoryUponDestruction onlyPreserveThisMemory( pScratchMemoryAllocator );
        //
        // Encode the data type.
        //

        Assert( (*MarshalledData == NULL && *DataSize == 0) || (*MarshalledData != NULL && *DataSize != 0) );
        AssertSz( *DataSize <= 10000, "Passing buffer larger than 10K, most likely an error");

        TraceSz1( AuthVerbose, "ASN encoding pdu #%d", PduValue );
        if (*MarshalledData != NULL)
        {
            Asn1Err = ASN1_Encode(
                        pEnc,
                        Data,
                        PduValue,
                        ASN1ENCODE_SETBUFFER,
                        *MarshalledData,
                        *DataSize
                        );
        }
        else
        {
            Asn1Err = ASN1_Encode(
                        pEnc,
                        Data,
                        PduValue,
                        ASN1ENCODE_ALLOCATEBUFFER,
                        NULL,                       // pbBuf
                        0                           // cbBufSize
                        );
        }
        if (!ASN1_SUCCEEDED(Asn1Err))
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        else
        {
            if ( *MarshalledData != NULL )
            {
                //
                // Caller specified a destination buffer
                //
                if (*MarshalledData == pEnc->buf)
                {
                    //
                    // Caller's destination buffer was used, that's what we want
                    //
                    *DataSize = pEnc->len;
                }
                else
                {
                    //
                    // Caller's destination buffer was too small, report failure
                    //
                    TraceSz(AuthWarn, "KerbPackData: Destination buffer too small.");
                    *DataSize = 0;
                    *MarshalledData = NULL;
                    KerbErr = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
                }
            }
            else
            {
                //
                // Caller didn't specify a destination buffer
                //
                *DataSize = pEnc->len;
                *MarshalledData = pEnc->buf;
                //
                // Preserve the only piece of memory we care about
                //
                PreserveThisMemory( &onlyPreserveThisMemory, MarshalledData, *DataSize );
            }
        }

        KerbTermAsn(pEnc, NULL);
    }

Cleanup:
    if (!KERB_SUCCESS(KerbErr))
    {
        TraceSz2(AuthWarn, "KerbPackData failure: KerbErr=0x%X, AsnErr=0x%X", KerbErr, Asn1Err);
    }
    return(KerbErr);
}


//+-------------------------------------------------------------------------

KERBERR NTAPI
KerbUnpackData(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PUCHAR Data,
    IN ULONG DataSize,
    IN ULONG PduValue,
    OUT PVOID * DecodedData
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    ASN1decoding_t pDec = NULL;
        ASN1error_e Asn1Err;

    Assert((DataSize != 0) && (Data != NULL));

    KerbErr = KerbInitAsn(
                pScratchMemoryAllocator,
                NULL,
                &pDec           // we are decoding
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    TraceSz1( AuthVerbose, "ASN decoding pdu #%d", PduValue );
    *DecodedData = NULL;
    Asn1Err = ASN1_Decode(
                pDec,
                DecodedData,
                PduValue,
                ASN1DECODE_SETBUFFER,
                (BYTE *) Data,
                DataSize
                );

    if (!ASN1_SUCCEEDED(Asn1Err))
    {
        if (Asn1Err==0xfffffc0d) //quiet up this for expected errors processing an echo preauth
            TraceSz1(AuthVerbose, "KerbUnpackData ASN1_Decode returned Asn1Err 0x%x", Asn1Err);
        else
            TraceSz1(AuthWarn,    "KerbUnpackData ASN1_Decode returned Asn1Err 0x%x", Asn1Err);

        if ((ASN1_ERR_BADARGS == Asn1Err) ||
            (ASN1_ERR_EOD == Asn1Err))
        {
            KerbErr = KDC_ERR_MORE_DATA;
        }
        else
        {
            KerbErr = KRB_ERR_GENERIC;
        }
        *DecodedData = NULL;
    }

    KerbTermAsn(NULL, pDec);

Cleanup:
    return(KerbErr);
}

//+-------------------------------------------------------------------------

ULONG
KerbConvertUlongToFlagUlong(
    IN ULONG Flag
    )
{
    ULONG ReturnFlag;

    ((PUCHAR) &ReturnFlag)[0] = ((PUCHAR) &Flag)[3];
    ((PUCHAR) &ReturnFlag)[1] = ((PUCHAR) &Flag)[2];
    ((PUCHAR) &ReturnFlag)[2] = ((PUCHAR) &Flag)[1];
    ((PUCHAR) &ReturnFlag)[3] = ((PUCHAR) &Flag)[0];

    return(ReturnFlag);
}

#define MAXTIMEQUADPART (LONGLONG)0x7FFFFF36D5969FFF
#define MAXTIMEHIGHPART 0x7FFFFF36
#define MAXTIMELOWPART  0xD5969FFF

TimeStamp g_KerbGlobalWillNeverTime = { MAXTIMELOWPART, MAXTIMEHIGHPART };

//+-------------------------------------------------------------------------

TimeStamp g_LastSystemTime;
UINT      g_uiUniqueOffset = 0;

VOID
KerbGetCurrentTime(
    IN OUT PTimeStamp pCurrentTime
    )
{
    GetSystemTimeAsFileTime((PFILETIME) pCurrentTime);

    if (pCurrentTime->QuadPart == g_LastSystemTime.QuadPart)
    {
        // Since the system time hasn't changed, we have to
        // add an artificial offset to be sure that we'll
        // always return a unique time for authenticators.
        // We advance the unique offset by 10 because the
        // FILETIME is in 100 nanosecond intervals and
        // Kerberos time resolution is in microseconds.

        g_uiUniqueOffset       += 10;
        pCurrentTime->QuadPart += g_uiUniqueOffset;
    }
    else
    {
        g_LastSystemTime.QuadPart = pCurrentTime->QuadPart;
        g_uiUniqueOffset          = 0;
    }

    ((LARGE_INTEGER*)pCurrentTime)->QuadPart += g_nClockSkew * 10000000;
    return;
}

//+-------------------------------------------------------------------------

VOID
KerbUpdateCurrentTime(
    IN TimeStamp NewCurrentTime
    )
{
    TimeStamp ts;
    //KerbGetCurrentTime(&ts);

    // Get time without time skew factored in
    GetSystemTimeAsFileTime((PFILETIME)&ts);
    if (ts.QuadPart == g_LastSystemTime.QuadPart)
    {
        // Since the system time hasn't changed, we have to
        // add an artificial offset to be sure that we'll
        // always return a unique time for authenticators.
        // We advance the unique offset by 10 because the
        // FILETIME is in 100 nanosecond intervals and
        // Kerberos time resolution is in microseconds.

        g_uiUniqueOffset       += 10;
        ts.QuadPart += g_uiUniqueOffset;
    }
    else
    {
        g_LastSystemTime.QuadPart = ts.QuadPart;
        g_uiUniqueOffset          = 0;
    }

    g_nClockSkew = (((LARGE_INTEGER*)&NewCurrentTime)->QuadPart - ((LARGE_INTEGER*)&ts)->QuadPart) / 10000000;

    TraceSz( AuthWarn,"KerbUpdateCurrentTime: Clock skew corrected based on KDC reply" );

    return;
}

//+---------------------------------------------------------------------------

KERBERR NTAPI
KerbEncryptDataEx(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    OUT PKERB_ENCRYPTED_DATA EncryptedData,
    IN ULONG DataSize,
    IN PUCHAR Data,
    IN ULONG Algorithm,
    IN ULONG UsageFlags,
    IN const KERB_ENCRYPTION_KEY* Key
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr = KDC_ERR_NONE;

    //
    // Initialize header
    //

    EncryptedData->encryption_type = KERB_ETYPE_RC4_HMAC_NT;

    Status =  rc4HmacEncrypt(
                pScratchMemoryAllocator,
                (PUCHAR) Key->keyvalue.value,
                Key->keyvalue.length,
                UsageFlags,
                Data,
                DataSize,
                EncryptedData->cipher_text.value,
                &EncryptedData->cipher_text.length
                );

    if (!NT_SUCCESS(Status))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

Cleanup:
    if (!KERB_SUCCESS(KerbErr))
    {
        TraceSz2( AuthWarn, "KerbEncryptDataEx failure: KerbErr=0x%X, NtStatus=0x%X", KerbErr, Status );
    }
    return KerbErr;
}

//+---------------------------------------------------------------------------

KERBERR NTAPI
KerbDecryptDataEx(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PKERB_ENCRYPTED_DATA EncryptedData,
    IN PKERB_ENCRYPTION_KEY pkKey,
    IN ULONG UsageFlags,
    OUT PULONG DataSize,
    OUT PUCHAR Data
    )
{
    NTSTATUS    Status  = STATUS_SUCCESS;
    KERBERR     KerbErr = KDC_ERR_NONE;

    Status = rc4HmacDecrypt(
                (PUCHAR) pkKey->keyvalue.value,
                pkKey->keyvalue.length,
                UsageFlags,
                EncryptedData->cipher_text.value,
                EncryptedData->cipher_text.length,
                Data,
                DataSize
                );

    if (!NT_SUCCESS(Status))
    {
        KerbErr = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

Cleanup:
    if (!KERB_SUCCESS(KerbErr))
    {
        TraceSz2( AuthWarn, "KerbDecryptDataEx failure: KerbErr=0x%X, NtStatus=0x%X", KerbErr, Status );
    }

    return KerbErr;
}

//------------------------------------------------------------------------

KERBERR
KerbConstructPrincipalName(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    OUT PKERB_PRINCIPAL_NAME PrincipalName,
    IN ULONG NameType,
    IN LPSTR pComp1,
    IN LPSTR pComp2
    )
{
    PKERB_PRINCIPAL_NAME_ELEM Elem1,Elem2;
    KERBERR Status = KDC_ERR_NONE;

    PrincipalName->name_type = (int) NameType;

    Assert( pComp1 != NULL );

    Elem1 = (PKERB_PRINCIPAL_NAME_ELEM) pScratchMemoryAllocator->Alloc(sizeof(KERB_PRINCIPAL_NAME_ELEM));
    if (Elem1 == NULL)
    {
        Status = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    Elem1->value = pComp1;
    Elem1->next = NULL;
    PrincipalName->name_string = Elem1;

    if ( pComp2 != NULL )
    {
        Elem2 = (PKERB_PRINCIPAL_NAME_ELEM) pScratchMemoryAllocator->Alloc(sizeof(KERB_PRINCIPAL_NAME_ELEM));
        if (Elem2 == NULL)
        {
            Status = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        Elem2->value = pComp2;
        Elem2->next = NULL;
        Elem1->next = Elem2;
    }

Cleanup:
    return(Status);
}

//------------------------------------------------------------------------

KERBERR
KerbMultiStringToPrincipalName(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN LPSTR pMultiString,
    OUT PKERB_PRINCIPAL_NAME PrincipalName
    )
{
    PKERB_PRINCIPAL_NAME_ELEM Elem1,Elem2;
    KERBERR Status = KDC_ERR_NONE;
    LPSTR pNextComponent;

    ZeroMemory( PrincipalName, sizeof(KERB_PRINCIPAL_NAME) );

    PrincipalName->name_type = atoi(pMultiString);

    pNextComponent = pMultiString + strlen(pMultiString) + 1;

    Elem1 = NULL;

    while (*pNextComponent != '\0')
    {
        Elem2 = (PKERB_PRINCIPAL_NAME_ELEM) pScratchMemoryAllocator->Alloc(sizeof(KERB_PRINCIPAL_NAME_ELEM));
        if (Elem2 == NULL)
        {
            Status = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        Elem2->value = pNextComponent;
        Elem2->next = NULL;
        if (Elem1 != NULL)
        {
            Elem1->next = Elem2;
        }
        else
        {
            PrincipalName->name_string = Elem2;
        }
        Elem1 = Elem2;
        pNextComponent += strlen(pNextComponent) + 1;
    }

Cleanup:
    return(Status);
}

//------------------------------------------------------------------------

KERBERR
KerbPrincipalNameToMultiString(
    IN PKERB_PRINCIPAL_NAME PrincipalName,
    IN DWORD dwMultiStringMaxLength,
    OUT LPSTR pMultiString
    )
{
    PKERB_PRINCIPAL_NAME_ELEM Elem;
    KERBERR Status = KDC_ERR_NONE;
    DWORD dwNextComponentLength;
    LPSTR pNextComponent;

    Assert( dwMultiStringMaxLength >= 32 );

    // Since PrincipalName->name_type is a 32 bit integer (signed long), we know for certain that it
    // can easily fit into 32 characters or more--and the assert above indicates that's
    // what we expect. So I will ensure that name_type stays 32-bits or smaller and disable
    // oacr warning 6053 (http://msdn.microsoft.com/en-us/library/5dx7ef8x(VS.80).aspx).
    // TobiasB
    C_ASSERT(sizeof(PrincipalName->name_type) <= 4);

    if (_snprintf( pMultiString, dwMultiStringMaxLength, "%d", PrincipalName->name_type ) < 0)
    {
        AssertSz(FALSE, "KerbPrincipalNameToMultiString: Insufficient string buffer for MultiString!");
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

#pragma warning ( push )
#pragma warning ( disable : 6053)
    pNextComponent = pMultiString + strlen(pMultiString) + 1;
#pragma warning ( pop)

    //
    // pMultiString is now pointing at the end of buffer
    //
    pMultiString += dwMultiStringMaxLength;

    Elem = PrincipalName->name_string;

    while (Elem != NULL)
    {
        dwNextComponentLength = strlen( Elem->value ) + 1;
        if (pNextComponent + dwNextComponentLength + 1 > pMultiString)
        {
            TraceSz(AuthWarn, "KerbPrincipalNameToMultiString: pNextComponent + dwNextComponentLength + 1 > pMultiString");
            Status = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        memcpy(pNextComponent, Elem->value, dwNextComponentLength);
        pNextComponent += dwNextComponentLength;

        Elem = Elem->next;
    }
    *pNextComponent = '\0';

Cleanup:
    return(Status);
}

//////////////////////////////////////////////////////////////////////////

BOOLEAN
md5Hmac(
    IN const BYTE* pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN const BYTE* pbData,
    IN ULONG cbData,
    IN const BYTE* pbData2,
    IN ULONG cbData2,
    OUT PBYTE HmacData
    )
{
    BOOLEAN fRet = FALSE;
#define HMAC_K_PADSIZE              64
    BYTE Kipad[HMAC_K_PADSIZE];
    BYTE Kopad[HMAC_K_PADSIZE];
    BYTE HMACTmp[HMAC_K_PADSIZE+MD5_LEN];
    ULONG dwBlock;
    MD5_CTX Md5Hash;

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;


    ZeroMemory(Kipad, HMAC_K_PADSIZE);
    memcpy(Kipad, pbKeyMaterial, cbKeyMaterial);

    ZeroMemory(Kopad, HMAC_K_PADSIZE);
    memcpy(Kopad, pbKeyMaterial, cbKeyMaterial);


    //
    // Kipad, Kopad are padded sMacKey. Now XOR across...
    //

    for(dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(DWORD); dwBlock++)
    {
        ((DWORD*)Kipad)[dwBlock] ^= 0x36363636;
        ((DWORD*)Kopad)[dwBlock] ^= 0x5C5C5C5C;
    }


    //
    // prepend Kipad to data, Hash to get H1
    //

    MD5Init(&Md5Hash);
    MD5Update(&Md5Hash, Kipad, HMAC_K_PADSIZE);
    if (cbData != 0)
    {
        MD5Update(&Md5Hash, pbData, cbData);
    }
    if (cbData2 != 0)
    {
        MD5Update(&Md5Hash, pbData2, cbData2);
    }

    // Finish off the hash
    MD5Final(&Md5Hash);

    // prepend Kopad to H1, hash to get HMAC
    memcpy(HMACTmp, Kopad, HMAC_K_PADSIZE);
    memcpy(HMACTmp+HMAC_K_PADSIZE, Md5Hash.digest, MD5_LEN);

    // final hash: output value into passed-in buffer
    MD5Init(&Md5Hash);
    MD5Update(&Md5Hash,HMACTmp, sizeof(HMACTmp));
    MD5Final(&Md5Hash);
    memcpy(
        HmacData,
        Md5Hash.digest,
        MD5_LEN
        );

    return TRUE;
}

NTSTATUS NTAPI
rc4HmacEncrypt(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN const UCHAR* pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbOutput,
    OUT PULONG pcbOutput
    )
{
    PRC4_MDx_HEADER CryptHeader = (PRC4_MDx_HEADER) pbOutput;
    BYTE StateKey[MD5_LEN];
    BYTE LocalKey[MD5_LEN];
    ULONG Offset = 0;
    BYTE Rc4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];

    md5Hmac(
        pbKey,
        KeySize,
        (PBYTE) &MessageType,
        sizeof(ULONG),
        NULL,
        0,
        StateKey
        );

    Offset = sizeof(RC4_MDx_HEADER);
    MoveMemory(
        pbOutput + Offset,
        pbInput,
        cbInput
        );
    *pcbOutput = cbInput + Offset;

    //
    // Create the header - the confounder & checksum
    //

    ZeroMemory(
        CryptHeader->Checksum,
        MD5_LEN
        );

    TestKerbRandom(CryptHeader->Confounder, RC4_CONFOUNDER_LEN);

    //
    // Checksum everything but the checksum
    //

    md5Hmac(
        StateKey,
        MD5_LEN,
        pbOutput+MD5_LEN,
        *pcbOutput-MD5_LEN,
        NULL,
        0,
        CryptHeader->Checksum
        );


    //
    // HMAC the checksum into the key
    //

    md5Hmac(
        StateKey,
        MD5_LEN,
        CryptHeader->Checksum,
        MD5_LEN,
        NULL,
        0,
        LocalKey
        );

    XcRC4Key( Rc4KeyStruct, MD5_LEN, LocalKey );

    //
    // Encrypt everything but the checksum
    //

    XcRC4Crypt( Rc4KeyStruct, *pcbOutput-MD5_LEN, pbOutput+MD5_LEN );

    return(S_OK);
}

NTSTATUS
rc4HmacDecrypt(
    IN const UCHAR* pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbOutput,
    OUT PULONG pcbOutput)
{
    RC4_MDx_HEADER TempHeader;
    BYTE StateKey[MD5_LEN];
    BYTE TempChecksum[MD5_LEN];
    ULONG Offset = sizeof(RC4_MDx_HEADER);
    BYTE LocalKey[MD5_LEN];
    BYTE Rc4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];

    Assert( cbInput >= Offset );
    if (cbInput < Offset)
    {
        return(STATUS_LOGON_FAILURE);
    }

    md5Hmac(
        pbKey,
        KeySize,
        (PBYTE) &MessageType,
        sizeof(ULONG),
        NULL,
        0,
        StateKey
        );

    //
    // Copy the input to the output before decrypting
    //

    memcpy(
        &TempHeader,
        pbInput,
        Offset
        );

    *pcbOutput = cbInput - Offset;
    MoveMemory(
        pbOutput,
        pbInput + Offset,
        *pcbOutput
        );


    //
    // Build the decryption key from the checksum and the
    // real key
    //

    md5Hmac(
        StateKey,
        MD5_LEN,
        TempHeader.Checksum,
        MD5_LEN,
        NULL,
        0,
        LocalKey
        );

    XcRC4Key( Rc4KeyStruct, MD5_LEN, LocalKey );

    //
    // Now decrypt the two buffers
    //

    XcRC4Crypt( Rc4KeyStruct, Offset - MD5_LEN, TempHeader.Confounder );
    XcRC4Crypt( Rc4KeyStruct, *pcbOutput, pbOutput );

    //
    // Now verify the checksum. First copy it out of the way, zero the
    // header
    //


    md5Hmac(
        StateKey,
        MD5_LEN,
        TempHeader.Confounder,
        Offset-MD5_LEN,
        pbOutput,
        *pcbOutput,
        TempChecksum
        );

    if (!memcmp(
            TempHeader.Checksum,
            TempChecksum,
            MD5_LEN
            ) != TRUE)
    {
        TraceSz(AuthWarn, "rc4HmacDecrypt: Checksum mismatch.");
        return(STATUS_LOGON_FAILURE);
    }

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\kerbclient\kerbhelper.cpp ===
#include "xonp.h"
#include "kerbhelper.h"
#undef min //grr evil windows.h spamming us with macros
#include <algorithm>

void TestKerbRandom(BYTE *pb, INT cb)
{
    for (INT i = 0; i < cb; i++)
    {
      INT r = rand();
      pb[i] ^= (BYTE)r;
      if (i + 1 < cb)
        pb[i + 1] = (BYTE)(r >> 8);
    }
}

//gets the bytes in a tgt that will currently be used for building a request (override if set, else default).  returns the number of echo bytes total (truncates if you provide less)
DWORD kcl_GetTGTEchoBytes(XKERB_TGT_CONTEXT *pTGTContext, BYTE *pData, DWORD cbData)
{
    if (!pTGTContext)
        return 0;

    DWORD copyBytes=std::min(cbData, pTGTContext->cbEchoPreAuth);
    memcpy(pData, pTGTContext->EchoPreAuth, copyBytes);
    return pTGTContext->cbEchoPreAuth;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\kerbclient\kerbhelper.h ===
#ifndef KERBHELPER_H
#define KERBHELPER_H

#include "kerbclient.h"

void 
TestKerbRandom(
    BYTE *pb, 
    INT cb
    );

//gets the bytes in a tgt that will currently be used for building a request (override if set, else default).  returns the number of echo bytes total (truncates if you provide less)
DWORD kcl_GetTGTEchoBytes(XKERB_TGT_CONTEXT *pTGTContext, BYTE *pData, DWORD cbData);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\kerbclient\kerbfuzz.h ===
//Fuzzing parameters to various places in kerbclient

#pragma once

#include <pshpack4.h> // Assume 4 byte packing throughout

// -- shared

//a single fuzz parameter
struct SFuzzParam
{
    //0-1: chance the data will be modified
    float chance; 
    //max number of bits changed
    unsigned int maxBits;
};

//decides the number of bits to fuzz for a specific type (random)
unsigned int FuzzCheck(IN const SFuzzParam &param);

//auto free pointer on leaving scope
template <typename T>
class AutoFreePointerArray
{
public:
    inline AutoFreePointerArray(T *p): ptr(p)
    {}

    inline ~AutoFreePointerArray()
    {
        if (ptr) delete[] ptr;
    }

    inline void SetPtr(T *p)
    {
        if (ptr) delete[] ptr;
        ptr=p;
    }

private:
    T *ptr;
};

//auto free pointer on leaving scope
template <typename T>
class AutoFreePointerSingle
{
public:
    inline AutoFreePointerSingle(T *p): ptr(p)
    {}

    inline ~AutoFreePointerSingle()
    {
        if (ptr) delete ptr;
    }

    inline void SetPtr(T *p)
    {
        if (ptr) delete ptr;
        ptr=p;
    }

private:
    T *ptr;
};

//fuzzes an array
unsigned int FuzzArray(void *data, unsigned int length, const SFuzzParam &fuzzParam);

//fuzzes a struct based on a fuzz param
template <typename T>
inline unsigned int FuzzStructBits(T *data, const SFuzzParam &fuzzParam)
{
    return FuzzArray(data, sizeof(T), fuzzParam);
}

//fuzzes a struct - special case for context as it contains pointers and such
template <>
inline unsigned int FuzzStructBits(XKERB_TGT_CONTEXT *data, const SFuzzParam &fuzzParam)
{
    if (data==0) return 0;

    //save pointers and pa len
    XKERB_TGT_CONTEXT *pTGT=data->pInputTGTContext;
    XKERB_PA_XBOX_ACCOUNT_CREATION *pPAXAC=data->pAccountCreationPreAuth;

    DWORD paEchoLen=data->cbEchoPreAuth;

    //fuzz
    unsigned int fuzzBits=FuzzArray(data, sizeof(XKERB_TGT_CONTEXT), fuzzParam);

    //restore pointers
    data->pInputTGTContext=pTGT;
    data->pAccountCreationPreAuth=pPAXAC;

    //make sure our strings are still null terminated so we don't nuke kerbclient from strlen calls
    data->passportAuthInfo.gamertag[XONLINE_GAMERTAG_SIZE-1]=0;
    data->ClientName[KERBEROS_MAX_PRINCIPLE_NAME_SIZE-1]=0;
    data->ClientRealm[XONLINE_KERBEROSREALM_SIZE-1]=0;
    data->TargetRealm[XONLINE_KERBEROSREALM_SIZE-1]=0;

    //don't fuzz our echo preauth legnth... that screws up the asn encoder, and asn fuzzer will fuzz that anyways
    data->cbEchoPreAuth=paEchoLen;

    return fuzzBits;
}

//fuzzes a null terminated string (without altering the terminator)
inline unsigned int FuzzNullString(char *str, const SFuzzParam &fuzzParam)
{
    if (str==0) return 0;

    unsigned int strLen=strlen(str);
    if (strLen) return FuzzArray(str, strLen, fuzzParam);
    return 0;
}

//fuzzes an int with a suggested number of bits (won't always be that exact number)
void FuzzIntBits(unsigned int &val, unsigned int suggestedBits);

// -- asn

//asn fuzz parameters
struct SAsnFuzzParams
{
    //key: (x) = not used directly by kerbclient, (*) = used directly by kerbclient

    //ber
    SFuzzParam ber_charStr;      //ASN1BEREncCharString - (x) - used by ASN1DEREncCharString
    //SFuzzParam ber_charStr16;    //ASN1BEREncChar16String - (x)
    //SFuzzParam ber_charStr32;    //ASN1BEREncChar32String - (x)
    SFuzzParam ber_octStr;       //ASN1BEREncOctetString - (x) - used by ASN1DEREncOctetString
    SFuzzParam ber_bitStr;       //ASN1BEREncBitString - (x) - used by ASN1DEREncBitString
    //SFuzzParam ber_floatDouble;  //ASN1BEREncDouble - (x)
    //SFuzzParam ber_genTime;      //ASN1BEREncGeneralizedTime - (x)
    SFuzzParam ber_int32;        //ASN1BEREncS32 - (*) - used BY a boatload of things - uses ASN1BEREncTag and ASN1BEREncLength
    //SFuzzParam ber_intX;         //ASN1BEREncSX - (x)
    //SFuzzParam ber_zeroMBString; //ASN1BEREncZeroMultibyteString - (x)
    //SFuzzParam ber_mbString;     //ASN1BEREncMultibyteString - (x)
    //SFuzzParam ber_null;         //ASN1BEREncNull - (x)
    SFuzzParam ber_objIden1;     //ASN1BEREncObjectIdentifier - (*) - uses ASN1BEREncTag and ASN1BEREncLength
    //SFuzzParam ber_objIden2;     //ASN1BEREncObjectIdentifier2 - (x)
    //SFuzzParam ber_removeZero;   //ASN1BEREncRemoveZeroBits - (x)
    //SFuzzParam ber_utcTime;      //ASN1BEREncUTCTime - (x)
    //SFuzzParam ber_flush;        //ASN1BEREncFlush - (x)
    SFuzzParam ber_openType;     //ASN1BEREncOpenType - (*)
    //SFuzzParam ber_check;        //ASN1BEREncCheck - (x)
    SFuzzParam ber_tag;          //ASN1BEREncTag - (x)
    //SFuzzParam ber_expTag;       //ASN1BEREncExplicitTag - (*) - used BY a boatload of things - uses ASN1BEREncTag
    SFuzzParam ber_eoc;          //ASN1BEREncEndOfContents - (*) - used BY a boatload of things
    SFuzzParam ber_length;       //ASN1BEREncLength - (x)
    SFuzzParam ber_u32;          //ASN1BEREncU32 - (*) - uses ASN1BEREncTag and ASN1BEREncLength
    SFuzzParam ber_booll;        //ASN1BEREncBool - (*) - uses ASN1BEREncTag and ASN1BEREncLength
    //SFuzzParam ber_eoid;         //ASN1BEREncEoid - (x)
    //SFuzzParam ber_utf8;         //ASN1BEREncUTF8String - (x)

    //cer
    //SFuzzParam cer_charStr;      //ASN1CEREncCharString - (x)
    //SFuzzParam cer_charStr16;    //ASN1CEREncChar16String - (x)
    //SFuzzParam cer_charStr32;    //ASN1CEREncChar32String - (x)
    //SFuzzParam cer_bitStr;       //ASN1CEREncBitString - (x)
    SFuzzParam cer_genTime;      //ASN1CEREncGeneralizedTime - (x) - used by ASN1DEREncGeneralizedTime
    //SFuzzParam cer_zeroMBString; //ASN1CEREncZeroMultibyteString - (x)
    //SFuzzParam cer_mbString;     //ASN1CEREncMultibyteString - (x)
    //SFuzzParam cer_octStr;       //ASN1CEREncOctetString - (x)
    //SFuzzParam cer_utcTime;      //ASN1CEREncUTCTime - (x)
    //SFuzzParam cer_blkBegin;     //ASN1CEREncBeginBlk - (x)
    //SFuzzParam cer_blkNew;       //ASN1CEREncNewBlkElement - (x)
    //SFuzzParam cer_blkFlush;     //ASN1CEREncFlushBlkElement - (x)
    //SFuzzParam cer_blkEnd;       //ASN1CEREncEndBlk - (x)
    //SFuzzParam cer_utf8;         //ASN1CEREncUTF8String - (x) - uses ASN1BEREncUTF8String

    //der
    //SFuzzParam der_getTime;      //ASN1DEREncGeneralizedTime - (*) - uses ASN1CEREncGeneralizedTime
    //SFuzzParam der_utcTime;      //ASN1DEREncUTCTime - (x) - uses ASN1CEREncUTCTime
    //SFuzzParam der_blkBegin;     //ASN1DEREncBeginBlk - (x) - uses ASN1CEREncBeginBlk
    //SFuzzParam der_blkNew;       //ASN1DEREncNewBlkElement - (x) - uses ASN1CEREncNewBlkElement
    //SFuzzParam der_blkFlush;     //ASN1DEREncFlushBlkElement - (x) - uses ASN1CEREncFlushBlkElement
    //SFuzzParam der_blkEnd;       //ASN1DEREncEndBlk - (x) - uses ASN1CEREncEndBlk
    //SFuzzParam der_charStr;      //ASN1DEREncCharString - (*) - uses ASN1BEREncCharString
    //SFuzzParam der_charStr16;    //ASN1DEREncChar16String - (x) - uses ASN1BEREncCharString16
    //SFuzzParam der_charStr32;    //ASN1DEREncChar32String - (x) - uses ASN1BEREncChar32String
    //SFuzzParam der_bitStr;       //ASN1DEREncBitString - (*) - uses ASN1BEREncBitString
    //SFuzzParam der_zeroMBString; //ASN1DEREncZeroMultibyteString - (x) - uses ASN1BEREncZeroMultibyteString
    //SFuzzParam der_mbString;     //ASN1DEREncMultibyteString - (x) - uses ASN1BEREncMultibyteString
    //SFuzzParam der_octStr;       //ASN1DEREncOctetString - (*) - uses ASN1BEREncOctetString
    //SFuzzParam der_utf8;         //ASN1DEREncUTF8String - (x) - uses ASN1BEREncUTF8String
};

//updates the asn fuzz parameters (or null to disable).  implemented in msasn1.cpp
extern HRESULT WINAPI
    kcl_SetAsnFuzzParams(IN SAsnFuzzParams *params);

// -- build request

struct SRequestFuzzParams
{
    //types to fuzz
    SFuzzParam ticket;
    SFuzzParam tgt;
    SFuzzParam title;
    SFuzzParam service;
    SFuzzParam user;
    SFuzzParam cert;
    SFuzzParam strings;
    SFuzzParam keys;
    SFuzzParam misc; //PC ID, random bools, etc

    //methods to fuzz (0 or non-0 ... not using bool due to C# interop)
    unsigned int XkerbBuildAsRequest;
    unsigned int kcl_BuildXenonMachineRequest;
    unsigned int kcl_BuildXenonTgsRequest;
    unsigned int kcl_BuildPcMachineRequest;
    unsigned int kcl_BuildAsWithPassportRequest;
};

extern SRequestFuzzParams requestFuzz;

//updates the request fuzz parameters
extern HRESULT WINAPI
    kcl_SetRequestFuzzParams(IN SRequestFuzzParams *params);

#include <poppack.h> // End 4-byte packing
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\kerbclient\makefile.inc ===
$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\kerbclient\krb5.h ===
#ifndef _KRB5_Module_H_
#define _KRB5_Module_H_

#include "msasn1.h"

typedef struct KERB_PA_PAC_REQUEST_EX_pac_sections_s * PKERB_PA_PAC_REQUEST_EX_pac_sections;

typedef struct KERB_KDC_REQUEST_BODY_encryption_type_s * PKERB_KDC_REQUEST_BODY_encryption_type;

typedef struct KERB_PRINCIPAL_NAME_name_string_s * PKERB_PRINCIPAL_NAME_name_string;

typedef struct PKERB_HOST_ADDRESSES_s * PPKERB_HOST_ADDRESSES;

typedef struct PKERB_AUTHORIZATION_DATA_s * PPKERB_AUTHORIZATION_DATA;

typedef struct PKERB_LAST_REQUEST_s * PPKERB_LAST_REQUEST;

typedef struct PKERB_TICKET_EXTENSIONS_s * PPKERB_TICKET_EXTENSIONS;

typedef struct PKERB_PREAUTH_DATA_LIST_s * PPKERB_PREAUTH_DATA_LIST;

typedef struct PKERB_ETYPE_INFO_s * PPKERB_ETYPE_INFO;

typedef struct KERB_KDC_ISSUED_AUTH_DATA_elements_s * PKERB_KDC_ISSUED_AUTH_DATA_elements;

typedef struct KERB_PA_PK_AS_REQ2_trusted_certifiers_s * PKERB_PA_PK_AS_REQ2_trusted_certifiers;

typedef struct KERB_PA_PK_AS_REQ2_user_certs_s * PKERB_PA_PK_AS_REQ2_user_certs;

typedef struct KERB_PA_PK_AS_REP2_kdc_cert_s * PKERB_PA_PK_AS_REP2_kdc_cert;

typedef struct KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data_s * PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data;

typedef struct KERB_KDC_REPLY_preauth_data_s * PKERB_KDC_REPLY_preauth_data;

typedef struct KERB_KDC_REQUEST_preauth_data_s * PKERB_KDC_REQUEST_preauth_data;

typedef struct KERB_PA_COMPOUND_IDENTITY_s * PKERB_PA_COMPOUND_IDENTITY;

typedef struct KERB_PA_PK_AS_REQ_trusted_certifiers_s * PKERB_PA_PK_AS_REQ_trusted_certifiers;

typedef struct KERB_ENCRYPTED_CRED_ticket_info_s * PKERB_ENCRYPTED_CRED_ticket_info;

typedef struct KERB_CRED_tickets_s * PKERB_CRED_tickets;

typedef struct KERB_KDC_REQUEST_BODY_additional_tickets_s * PKERB_KDC_REQUEST_BODY_additional_tickets;

typedef ASN1ztcharstring_t KERB_PRINCIPAL_NAME_name_string_Seq;

typedef ASN1int32_t KERB_KDC_REQUEST_BODY_encryption_type_Seq;

typedef ASN1int32_t KERB_PA_PAC_REQUEST_EX_pac_sections_Seq;

typedef ASN1ztcharstring_t KERB_REALM;

typedef PPKERB_AUTHORIZATION_DATA PKERB_AUTHORIZATION_DATA_LIST;
#define PKERB_AUTHORIZATION_DATA_LIST_PDU 0
#define SIZE_KRB5_Module_PDU_0 sizeof(PKERB_AUTHORIZATION_DATA_LIST)

typedef ASN1bitstring_t KERB_KDC_OPTIONS;

typedef ASN1generalizedtime_t KERB_TIME;

typedef ASN1intx_t KERB_SEQUENCE_NUMBER_LARGE;

typedef ASN1uint32_t KERB_SEQUENCE_NUMBER;

typedef ASN1bitstring_t KERB_TICKET_FLAGS;

typedef ASN1bitstring_t KERB_AP_OPTIONS;

typedef ASN1open_t NOCOPYANY;

typedef ASN1int32_t KERB_CERTIFICATE_SERIAL_NUMBER;

typedef PPKERB_AUTHORIZATION_DATA PKERB_IF_RELEVANT_AUTH_DATA;
#define PKERB_IF_RELEVANT_AUTH_DATA_PDU 1
#define SIZE_KRB5_Module_PDU_1 sizeof(PKERB_IF_RELEVANT_AUTH_DATA)

typedef struct KERB_PA_PAC_REQUEST_EX_pac_sections_s {
    PKERB_PA_PAC_REQUEST_EX_pac_sections next;
    KERB_PA_PAC_REQUEST_EX_pac_sections_Seq value;
} KERB_PA_PAC_REQUEST_EX_pac_sections_Element, *KERB_PA_PAC_REQUEST_EX_pac_sections;

typedef struct KERB_KDC_REQUEST_BODY_encryption_type_s {
    PKERB_KDC_REQUEST_BODY_encryption_type next;
    KERB_KDC_REQUEST_BODY_encryption_type_Seq value;
} KERB_KDC_REQUEST_BODY_encryption_type_Element, *KERB_KDC_REQUEST_BODY_encryption_type;

typedef struct PKERB_TICKET_EXTENSIONS_Seq {
    ASN1int32_t te_type;
    ASN1octetstring_t te_data;
} PKERB_TICKET_EXTENSIONS_Seq;

typedef struct KERB_PRINCIPAL_NAME_name_string_s {
    PKERB_PRINCIPAL_NAME_name_string next;
    KERB_PRINCIPAL_NAME_name_string_Seq value;
} KERB_PRINCIPAL_NAME_name_string_Element, *KERB_PRINCIPAL_NAME_name_string;

typedef struct PKERB_LAST_REQUEST_Seq {
    ASN1int32_t last_request_type;
    KERB_TIME last_request_value;
} PKERB_LAST_REQUEST_Seq;

typedef struct PKERB_AUTHORIZATION_DATA_Seq {
    ASN1int32_t auth_data_type;
    ASN1octetstring_t auth_data;
} PKERB_AUTHORIZATION_DATA_Seq;

typedef struct PKERB_HOST_ADDRESSES_Seq {
    ASN1int32_t address_type;
    ASN1octetstring_t address;
} PKERB_HOST_ADDRESSES_Seq;

typedef struct KERB_HOST_ADDRESS {
    ASN1int32_t addr_type;
    ASN1octetstring_t address;
} KERB_HOST_ADDRESS;

typedef struct PKERB_HOST_ADDRESSES_s {
    PPKERB_HOST_ADDRESSES next;
    PKERB_HOST_ADDRESSES_Seq value;
} PKERB_HOST_ADDRESSES_Element, *PKERB_HOST_ADDRESSES;

typedef struct PKERB_AUTHORIZATION_DATA_s {
    PPKERB_AUTHORIZATION_DATA next;
    PKERB_AUTHORIZATION_DATA_Seq value;
} PKERB_AUTHORIZATION_DATA_Element, *PKERB_AUTHORIZATION_DATA;

typedef struct PKERB_LAST_REQUEST_s {
    PPKERB_LAST_REQUEST next;
    PKERB_LAST_REQUEST_Seq value;
} PKERB_LAST_REQUEST_Element, *PKERB_LAST_REQUEST;

typedef struct KERB_PRINCIPAL_NAME {
    ASN1int32_t name_type;
    PKERB_PRINCIPAL_NAME_name_string name_string;
} KERB_PRINCIPAL_NAME;

typedef struct PKERB_TICKET_EXTENSIONS_s {
    PPKERB_TICKET_EXTENSIONS next;
    PKERB_TICKET_EXTENSIONS_Seq value;
} PKERB_TICKET_EXTENSIONS_Element, *PKERB_TICKET_EXTENSIONS;

typedef struct KERB_TRANSITED_ENCODING {
    ASN1int32_t transited_type;
    ASN1octetstring_t contents;
} KERB_TRANSITED_ENCODING;

typedef struct KERB_PA_DATA {
    ASN1int32_t preauth_data_type;
    ASN1octetstring_t preauth_data;
} KERB_PA_DATA;

typedef struct PKERB_PREAUTH_DATA_LIST_s {
    PPKERB_PREAUTH_DATA_LIST next;
    KERB_PA_DATA value;
} PKERB_PREAUTH_DATA_LIST_Element, *PKERB_PREAUTH_DATA_LIST;
#define PKERB_PREAUTH_DATA_LIST_PDU 2
#define SIZE_KRB5_Module_PDU_2 sizeof(PKERB_PREAUTH_DATA_LIST_Element)

typedef struct KERB_SAFE_BODY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1octetstring_t user_data;
#   define KERB_SAFE_BODY_timestamp_present 0x80
    KERB_TIME timestamp;
#   define KERB_SAFE_BODY_usec_present 0x40
    ASN1int32_t usec;
#   define KERB_SAFE_BODY_sequence_number_present 0x20
    KERB_SEQUENCE_NUMBER sequence_number;
    KERB_HOST_ADDRESS sender_address;
#   define KERB_SAFE_BODY_recipient_address_present 0x10
    KERB_HOST_ADDRESS recipient_address;
} KERB_SAFE_BODY;

typedef struct KERB_ENCRYPTED_PRIV {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1octetstring_t user_data;
#   define KERB_ENCRYPTED_PRIV_timestamp_present 0x80
    KERB_TIME timestamp;
#   define KERB_ENCRYPTED_PRIV_usec_present 0x40
    ASN1int32_t usec;
#   define KERB_ENCRYPTED_PRIV_sequence_number_present 0x20
    KERB_SEQUENCE_NUMBER sequence_number;
    KERB_HOST_ADDRESS sender_address;
#   define KERB_ENCRYPTED_PRIV_recipient_address_present 0x10
    KERB_HOST_ADDRESS recipient_address;
} KERB_ENCRYPTED_PRIV;
#define KERB_ENCRYPTED_PRIV_PDU 3
#define SIZE_KRB5_Module_PDU_3 sizeof(KERB_ENCRYPTED_PRIV)

typedef struct KERB_ENCRYPTED_CRED {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PKERB_ENCRYPTED_CRED_ticket_info ticket_info;
#   define nonce_present 0x80
    ASN1int32_t nonce;
#   define KERB_ENCRYPTED_CRED_timestamp_present 0x40
    KERB_TIME timestamp;
#   define KERB_ENCRYPTED_CRED_usec_present 0x20
    ASN1int32_t usec;
#   define sender_address_present 0x10
    KERB_HOST_ADDRESS sender_address;
#   define KERB_ENCRYPTED_CRED_recipient_address_present 0x8
    KERB_HOST_ADDRESS recipient_address;
} KERB_ENCRYPTED_CRED;
#define KERB_ENCRYPTED_CRED_PDU 4
#define SIZE_KRB5_Module_PDU_4 sizeof(KERB_ENCRYPTED_CRED)

typedef struct KERB_ERROR {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    ASN1int32_t message_type;
#   define client_time_present 0x80
    KERB_TIME client_time;
#   define client_usec_present 0x40
    ASN1int32_t client_usec;
    KERB_TIME server_time;
    ASN1int32_t server_usec;
    ASN1int32_t error_code;
#   define client_realm_present 0x20
    KERB_REALM client_realm;
#   define KERB_ERROR_client_name_present 0x10
    KERB_PRINCIPAL_NAME client_name;
    KERB_REALM realm;
    KERB_PRINCIPAL_NAME server_name;
#   define error_text_present 0x8
    ASN1charstring_t error_text;
#   define error_data_present 0x4
    ASN1octetstring_t error_data;
} KERB_ERROR;
#define KERB_ERROR_PDU 5
#define SIZE_KRB5_Module_PDU_5 sizeof(KERB_ERROR)

typedef struct KERB_ENCRYPTED_DATA {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t encryption_type;
#   define version_present 0x80
    ASN1int32_t version;
    ASN1octetstring_t cipher_text;
} KERB_ENCRYPTED_DATA;
#define KERB_ENCRYPTED_DATA_PDU 6
#define SIZE_KRB5_Module_PDU_6 sizeof(KERB_ENCRYPTED_DATA)

typedef struct KERB_ENCRYPTION_KEY {
    ASN1int32_t keytype;
    ASN1octetstring_t keyvalue;
} KERB_ENCRYPTION_KEY;
#define KERB_ENCRYPTION_KEY_PDU 7
#define SIZE_KRB5_Module_PDU_7 sizeof(KERB_ENCRYPTION_KEY)

typedef struct KERB_CHECKSUM {
    ASN1int32_t checksum_type;
    ASN1octetstring_t checksum;
} KERB_CHECKSUM;
#define KERB_CHECKSUM_PDU 8
#define SIZE_KRB5_Module_PDU_8 sizeof(KERB_CHECKSUM)

typedef struct KERB_ENCRYPTED_TIMESTAMP {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_TIME timestamp;
#   define KERB_ENCRYPTED_TIMESTAMP_usec_present 0x80
    ASN1int32_t usec;
} KERB_ENCRYPTED_TIMESTAMP;
#define KERB_ENCRYPTED_TIMESTAMP_PDU 9
#define SIZE_KRB5_Module_PDU_9 sizeof(KERB_ENCRYPTED_TIMESTAMP)

typedef struct KERB_SALTED_ENCRYPTED_TIMESTAMP {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_TIME timestamp;
#   define KERB_SALTED_ENCRYPTED_TIMESTAMP_usec_present 0x80
    ASN1int32_t usec;
    ASN1octetstring_t salt;
} KERB_SALTED_ENCRYPTED_TIMESTAMP;
#define KERB_SALTED_ENCRYPTED_TIMESTAMP_PDU 10
#define SIZE_KRB5_Module_PDU_10 sizeof(KERB_SALTED_ENCRYPTED_TIMESTAMP)

typedef struct KERB_ETYPE_INFO_ENTRY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t encryption_type;
#   define salt_present 0x80
    ASN1octetstring_t salt;
} KERB_ETYPE_INFO_ENTRY;

typedef struct PKERB_ETYPE_INFO_s {
    PPKERB_ETYPE_INFO next;
    KERB_ETYPE_INFO_ENTRY value;
} PKERB_ETYPE_INFO_Element, *PKERB_ETYPE_INFO;
#define PKERB_ETYPE_INFO_PDU 11
#define SIZE_KRB5_Module_PDU_11 sizeof(PKERB_ETYPE_INFO_Element)

typedef struct KERB_TGT_REQUEST {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    ASN1int32_t message_type;
#   define KERB_TGT_REQUEST_server_name_present 0x80
    KERB_PRINCIPAL_NAME server_name;
#   define server_realm_present 0x40
    KERB_REALM server_realm;
} KERB_TGT_REQUEST;
#define KERB_TGT_REQUEST_PDU 12
#define SIZE_KRB5_Module_PDU_12 sizeof(KERB_TGT_REQUEST)

typedef struct KERB_PKCS_SIGNATURE {
    ASN1int32_t encryption_type;
    ASN1octetstring_t signature;
} KERB_PKCS_SIGNATURE;
#define KERB_PKCS_SIGNATURE_PDU 13
#define SIZE_KRB5_Module_PDU_13 sizeof(KERB_PKCS_SIGNATURE)

typedef struct KERB_ALGORITHM_IDENTIFIER {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1objectidentifier_t algorithm;
#   define parameters_present 0x80
    NOCOPYANY parameters;
} KERB_ALGORITHM_IDENTIFIER;

typedef struct KERB_SIGNATURE {
    KERB_ALGORITHM_IDENTIFIER signature_algorithm;
    ASN1bitstring_t pkcs_signature;
} KERB_SIGNATURE;

typedef struct KERB_PA_PK_AS_REP {
    ASN1choice_t choice;
    union {
#	define dh_signed_data_chosen 1
	ASN1octetstring_t dh_signed_data;
#	define key_package_chosen 2
	ASN1octetstring_t key_package;
    } u;
} KERB_PA_PK_AS_REP;
#define KERB_PA_PK_AS_REP_PDU 14
#define SIZE_KRB5_Module_PDU_14 sizeof(KERB_PA_PK_AS_REP)

typedef struct KERB_ENVELOPED_KEY_PACKAGE {
    ASN1choice_t choice;
    union {
#	define encrypted_data_chosen 1
	KERB_ENCRYPTED_DATA encrypted_data;
#	define pkinit_enveloped_data_chosen 2
	ASN1octetstring_t pkinit_enveloped_data;
    } u;
} KERB_ENVELOPED_KEY_PACKAGE;

typedef struct KERB_REPLY_KEY_PACKAGE2 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_ENCRYPTION_KEY reply_key;
    ASN1int32_t nonce;
#   define subject_public_key_present 0x80
    ASN1bitstring_t subject_public_key;
} KERB_REPLY_KEY_PACKAGE2;
#define KERB_REPLY_KEY_PACKAGE2_PDU 15
#define SIZE_KRB5_Module_PDU_15 sizeof(KERB_REPLY_KEY_PACKAGE2)

typedef struct KERB_REPLY_KEY_PACKAGE {
    KERB_ENCRYPTION_KEY reply_key;
    ASN1int32_t nonce;
} KERB_REPLY_KEY_PACKAGE;
#define KERB_REPLY_KEY_PACKAGE_PDU 16
#define SIZE_KRB5_Module_PDU_16 sizeof(KERB_REPLY_KEY_PACKAGE)

typedef struct KERB_KDC_DH_KEY_INFO {
    ASN1int32_t nonce;
    ASN1bitstring_t subject_public_key;
} KERB_KDC_DH_KEY_INFO;
#define KERB_KDC_DH_KEY_INFO_PDU 17
#define SIZE_KRB5_Module_PDU_17 sizeof(KERB_KDC_DH_KEY_INFO)

typedef struct KERB_PA_PK_AS_REQ {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1octetstring_t signed_auth_pack;
#   define KERB_PA_PK_AS_REQ_trusted_certifiers_present 0x80
    PKERB_PA_PK_AS_REQ_trusted_certifiers trusted_certifiers;
#   define KERB_PA_PK_AS_REQ_kdc_cert_present 0x40
    ASN1octetstring_t kdc_cert;
#   define encryption_cert_present 0x20
    ASN1octetstring_t encryption_cert;
} KERB_PA_PK_AS_REQ;
#define KERB_PA_PK_AS_REQ_PDU 18
#define SIZE_KRB5_Module_PDU_18 sizeof(KERB_PA_PK_AS_REQ)

typedef struct KERB_KERBEROS_NAME {
    KERB_REALM realm;
    KERB_PRINCIPAL_NAME principal_name;
} KERB_KERBEROS_NAME;

typedef struct KERB_PK_AUTHENTICATOR {
    KERB_PRINCIPAL_NAME kdc_name;
    KERB_REALM kdc_realm;
    ASN1int32_t cusec;
    KERB_TIME client_time;
    ASN1int32_t nonce;
} KERB_PK_AUTHENTICATOR;

typedef struct KERB_SUBJECT_PUBLIC_KEY_INFO {
    KERB_ALGORITHM_IDENTIFIER algorithm;
    ASN1bitstring_t subjectPublicKey;
} KERB_SUBJECT_PUBLIC_KEY_INFO;

typedef struct KERB_DH_PARAMTER {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t prime;
    ASN1int32_t base;
#   define private_value_length_present 0x80
    ASN1int32_t private_value_length;
} KERB_DH_PARAMTER;
#define KERB_DH_PARAMTER_PDU 19
#define SIZE_KRB5_Module_PDU_19 sizeof(KERB_DH_PARAMTER)

typedef struct KERB_CERTIFICATE {
    ASN1int32_t cert_type;
    ASN1octetstring_t cert_data;
} KERB_CERTIFICATE;

typedef struct KERB_TYPED_DATA {
    ASN1int32_t data_type;
    ASN1octetstring_t data_value;
} KERB_TYPED_DATA;
#define KERB_TYPED_DATA_PDU 20
#define SIZE_KRB5_Module_PDU_20 sizeof(KERB_TYPED_DATA)

typedef struct KERB_KDC_ISSUED_AUTH_DATA {
    KERB_SIGNATURE checksum;
    PKERB_KDC_ISSUED_AUTH_DATA_elements elements;
} KERB_KDC_ISSUED_AUTH_DATA;
#define KERB_KDC_ISSUED_AUTH_DATA_PDU 21
#define SIZE_KRB5_Module_PDU_21 sizeof(KERB_KDC_ISSUED_AUTH_DATA)

typedef struct KERB_PA_SERV_REFERRAL {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define referred_server_name_present 0x80
    KERB_PRINCIPAL_NAME referred_server_name;
    KERB_REALM referred_server_realm;
} KERB_PA_SERV_REFERRAL;
#define KERB_PA_SERV_REFERRAL_PDU 22
#define SIZE_KRB5_Module_PDU_22 sizeof(KERB_PA_SERV_REFERRAL)

typedef struct KERB_PA_PAC_REQUEST {
    ASN1bool_t include_pac;
} KERB_PA_PAC_REQUEST;
#define KERB_PA_PAC_REQUEST_PDU 23
#define SIZE_KRB5_Module_PDU_23 sizeof(KERB_PA_PAC_REQUEST)

typedef struct KERB_CHANGE_PASSWORD_DATA {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1octetstring_t new_password;
#   define target_name_present 0x80
    KERB_PRINCIPAL_NAME target_name;
#   define target_realm_present 0x40
    KERB_REALM target_realm;
} KERB_CHANGE_PASSWORD_DATA;
#define KERB_CHANGE_PASSWORD_DATA_PDU 24
#define SIZE_KRB5_Module_PDU_24 sizeof(KERB_CHANGE_PASSWORD_DATA)

typedef struct KERB_ERROR_METHOD_DATA {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t data_type;
#   define data_value_present 0x80
    ASN1octetstring_t data_value;
} KERB_ERROR_METHOD_DATA;
#define KERB_ERROR_METHOD_DATA_PDU 25
#define SIZE_KRB5_Module_PDU_25 sizeof(KERB_ERROR_METHOD_DATA)

typedef struct KERB_EXT_ERROR {
    ASN1int32_t status;
    ASN1int32_t klininfo;
    ASN1int32_t flags;
} KERB_EXT_ERROR;
#define KERB_EXT_ERROR_PDU 26
#define SIZE_KRB5_Module_PDU_26 sizeof(KERB_EXT_ERROR)

typedef struct KERB_PA_FOR_USER {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_PRINCIPAL_NAME userName;
    KERB_REALM userRealm;
    KERB_CHECKSUM cksum;
    ASN1ztcharstring_t authentication_package;
#   define KERB_PA_FOR_USER_authorization_data_present 0x80
    ASN1octetstring_t authorization_data;
} KERB_PA_FOR_USER;
#define KERB_PA_FOR_USER_PDU 27
#define SIZE_KRB5_Module_PDU_27 sizeof(KERB_PA_FOR_USER)

typedef struct KERB_PA_PAC_REQUEST_EX {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t include_pac;
#   define pac_sections_present 0x80
    PKERB_PA_PAC_REQUEST_EX_pac_sections pac_sections;
} KERB_PA_PAC_REQUEST_EX;
#define KERB_PA_PAC_REQUEST_EX_PDU 28
#define SIZE_KRB5_Module_PDU_28 sizeof(KERB_PA_PAC_REQUEST_EX)

typedef struct KERB_KDC_ISSUED_AUTH_DATA_elements_s {
    PKERB_KDC_ISSUED_AUTH_DATA_elements next;
    KERB_PA_DATA value;
} KERB_KDC_ISSUED_AUTH_DATA_elements_Element, *KERB_KDC_ISSUED_AUTH_DATA_elements;

typedef struct KERB_PA_PK_AS_REQ2_trusted_certifiers_s {
    PKERB_PA_PK_AS_REQ2_trusted_certifiers next;
    KERB_PRINCIPAL_NAME value;
} KERB_PA_PK_AS_REQ2_trusted_certifiers_Element, *KERB_PA_PK_AS_REQ2_trusted_certifiers;

typedef struct KERB_PA_PK_AS_REQ2_user_certs_s {
    PKERB_PA_PK_AS_REQ2_user_certs next;
    KERB_CERTIFICATE value;
} KERB_PA_PK_AS_REQ2_user_certs_Element, *KERB_PA_PK_AS_REQ2_user_certs;

typedef struct KERB_PA_PK_AS_REP2_kdc_cert_s {
    PKERB_PA_PK_AS_REP2_kdc_cert next;
    KERB_CERTIFICATE value;
} KERB_PA_PK_AS_REP2_kdc_cert_Element, *KERB_PA_PK_AS_REP2_kdc_cert;

typedef struct KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data_s {
    PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data next;
    KERB_PA_DATA value;
} KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data_Element, *KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data;

typedef struct KERB_KDC_REPLY_preauth_data_s {
    PKERB_KDC_REPLY_preauth_data next;
    KERB_PA_DATA value;
} KERB_KDC_REPLY_preauth_data_Element, *KERB_KDC_REPLY_preauth_data;

typedef struct KERB_KDC_REQUEST_preauth_data_s {
    PKERB_KDC_REQUEST_preauth_data next;
    KERB_PA_DATA value;
} KERB_KDC_REQUEST_preauth_data_Element, *KERB_KDC_REQUEST_preauth_data;

typedef struct KERB_TICKET {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t ticket_version;
    KERB_REALM realm;
    KERB_PRINCIPAL_NAME server_name;
    KERB_ENCRYPTED_DATA encrypted_part;
#   define ticket_extensions_present 0x80
    PPKERB_TICKET_EXTENSIONS ticket_extensions;
} KERB_TICKET;
#define KERB_TICKET_PDU 29
#define SIZE_KRB5_Module_PDU_29 sizeof(KERB_TICKET)

typedef struct KERB_ENCRYPTED_TICKET {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_TICKET_FLAGS flags;
    KERB_ENCRYPTION_KEY key;
    KERB_REALM client_realm;
    KERB_PRINCIPAL_NAME client_name;
    KERB_TRANSITED_ENCODING transited;
    KERB_TIME authtime;
#   define KERB_ENCRYPTED_TICKET_starttime_present 0x80
    KERB_TIME starttime;
    KERB_TIME endtime;
#   define KERB_ENCRYPTED_TICKET_renew_until_present 0x40
    KERB_TIME renew_until;
#   define KERB_ENCRYPTED_TICKET_client_addresses_present 0x20
    PPKERB_HOST_ADDRESSES client_addresses;
#   define KERB_ENCRYPTED_TICKET_authorization_data_present 0x10
    PPKERB_AUTHORIZATION_DATA authorization_data;
} KERB_ENCRYPTED_TICKET;
#define KERB_ENCRYPTED_TICKET_PDU 30
#define SIZE_KRB5_Module_PDU_30 sizeof(KERB_ENCRYPTED_TICKET)

typedef struct KERB_AUTHENTICATOR {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t authenticator_version;
    KERB_REALM client_realm;
    KERB_PRINCIPAL_NAME client_name;
#   define checksum_present 0x80
    KERB_CHECKSUM checksum;
    ASN1int32_t client_usec;
    KERB_TIME client_time;
#   define KERB_AUTHENTICATOR_subkey_present 0x40
    KERB_ENCRYPTION_KEY subkey;
#   define KERB_AUTHENTICATOR_sequence_number_present 0x20
    //KERB_SEQUENCE_NUMBER_LARGE sequence_number;
    KERB_SEQUENCE_NUMBER sequence_number;
#   define KERB_AUTHENTICATOR_authorization_data_present 0x10
    PPKERB_AUTHORIZATION_DATA authorization_data;
} KERB_AUTHENTICATOR;
#define KERB_AUTHENTICATOR_PDU 31
#define SIZE_KRB5_Module_PDU_31 sizeof(KERB_AUTHENTICATOR)

typedef struct KERB_KDC_REQUEST_BODY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_KDC_OPTIONS kdc_options;
#   define KERB_KDC_REQUEST_BODY_client_name_present 0x80
    KERB_PRINCIPAL_NAME client_name;
    KERB_REALM realm;
#   define KERB_KDC_REQUEST_BODY_server_name_present 0x40
    KERB_PRINCIPAL_NAME server_name;
#   define KERB_KDC_REQUEST_BODY_starttime_present 0x20
    KERB_TIME starttime;
    KERB_TIME endtime;
#   define KERB_KDC_REQUEST_BODY_renew_until_present 0x10
    KERB_TIME renew_until;
    ASN1int32_t nonce;
    PKERB_KDC_REQUEST_BODY_encryption_type encryption_type;
#   define addresses_present 0x8
    PPKERB_HOST_ADDRESSES addresses;
#   define enc_authorization_data_present 0x4
    KERB_ENCRYPTED_DATA enc_authorization_data;
#   define additional_tickets_present 0x2
    PKERB_KDC_REQUEST_BODY_additional_tickets additional_tickets;
} KERB_KDC_REQUEST_BODY;

typedef struct KERB_KDC_REPLY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    ASN1int32_t message_type;
#   define KERB_KDC_REPLY_preauth_data_present 0x80
    PKERB_KDC_REPLY_preauth_data preauth_data;
    KERB_REALM client_realm;
    KERB_PRINCIPAL_NAME client_name;
    KERB_TICKET ticket;
    KERB_ENCRYPTED_DATA encrypted_part;
} KERB_KDC_REPLY;

typedef struct KERB_ENCRYPTED_KDC_REPLY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_ENCRYPTION_KEY session_key;
    PPKERB_LAST_REQUEST last_request;
    ASN1int32_t nonce;
#   define key_expiration_present 0x80
    KERB_TIME key_expiration;
    KERB_TICKET_FLAGS flags;
    KERB_TIME authtime;
#   define KERB_ENCRYPTED_KDC_REPLY_starttime_present 0x40
    KERB_TIME starttime;
    KERB_TIME endtime;
#   define KERB_ENCRYPTED_KDC_REPLY_renew_until_present 0x20
    KERB_TIME renew_until;
    KERB_REALM server_realm;
    KERB_PRINCIPAL_NAME server_name;
#   define KERB_ENCRYPTED_KDC_REPLY_client_addresses_present 0x10
    PPKERB_HOST_ADDRESSES client_addresses;
#   define encrypted_pa_data_present 0x8
    PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data encrypted_pa_data;
} KERB_ENCRYPTED_KDC_REPLY;

typedef struct KERB_AP_REQUEST {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_AP_OPTIONS ap_options;
    KERB_TICKET ticket;
    KERB_ENCRYPTED_DATA authenticator;
} KERB_AP_REQUEST;
#define KERB_AP_REQUEST_PDU 32
#define SIZE_KRB5_Module_PDU_32 sizeof(KERB_AP_REQUEST)

typedef struct KERB_AP_REPLY {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_ENCRYPTED_DATA encrypted_part;
} KERB_AP_REPLY;
#define KERB_AP_REPLY_PDU 33
#define SIZE_KRB5_Module_PDU_33 sizeof(KERB_AP_REPLY)

typedef struct KERB_ENCRYPTED_AP_REPLY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_TIME client_time;
    ASN1int32_t client_usec;
#   define KERB_ENCRYPTED_AP_REPLY_subkey_present 0x80
    KERB_ENCRYPTION_KEY subkey;
#   define KERB_ENCRYPTED_AP_REPLY_sequence_number_present 0x40
    KERB_SEQUENCE_NUMBER sequence_number;
} KERB_ENCRYPTED_AP_REPLY;
#define KERB_ENCRYPTED_AP_REPLY_PDU 34
#define SIZE_KRB5_Module_PDU_34 sizeof(KERB_ENCRYPTED_AP_REPLY)

typedef struct KERB_SAFE_MESSAGE {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_SAFE_BODY safe_body;
    KERB_CHECKSUM checksum;
} KERB_SAFE_MESSAGE;
#define KERB_SAFE_MESSAGE_PDU 35
#define SIZE_KRB5_Module_PDU_35 sizeof(KERB_SAFE_MESSAGE)

typedef struct KERB_PRIV_MESSAGE {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_ENCRYPTED_DATA encrypted_part;
} KERB_PRIV_MESSAGE;
#define KERB_PRIV_MESSAGE_PDU 36
#define SIZE_KRB5_Module_PDU_36 sizeof(KERB_PRIV_MESSAGE)

typedef struct KERB_CRED {
    ASN1int32_t version;
    ASN1int32_t message_type;
    PKERB_CRED_tickets tickets;
    KERB_ENCRYPTED_DATA encrypted_part;
} KERB_CRED;
#define KERB_CRED_PDU 37
#define SIZE_KRB5_Module_PDU_37 sizeof(KERB_CRED)

typedef struct KERB_CRED_INFO {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    KERB_ENCRYPTION_KEY key;
#   define principal_realm_present 0x80
    KERB_REALM principal_realm;
#   define principal_name_present 0x40
    KERB_PRINCIPAL_NAME principal_name;
#   define flags_present 0x20
    KERB_TICKET_FLAGS flags;
#   define authtime_present 0x10
    KERB_TIME authtime;
#   define KERB_CRED_INFO_starttime_present 0x8
    KERB_TIME starttime;
#   define endtime_present 0x4
    KERB_TIME endtime;
#   define KERB_CRED_INFO_renew_until_present 0x2
    KERB_TIME renew_until;
#   define service_realm_present 0x1
    KERB_REALM service_realm;
#   define service_name_present 0x8000
    KERB_PRINCIPAL_NAME service_name;
#   define KERB_CRED_INFO_client_addresses_present 0x4000
    PPKERB_HOST_ADDRESSES client_addresses;
} KERB_CRED_INFO;

typedef struct KERB_TGT_REPLY {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_TICKET ticket;
} KERB_TGT_REPLY;
#define KERB_TGT_REPLY_PDU 38
#define SIZE_KRB5_Module_PDU_38 sizeof(KERB_TGT_REPLY)

typedef struct KERB_SIGNED_REPLY_KEY_PACKAGE {
    KERB_REPLY_KEY_PACKAGE2 reply_key_package;
    KERB_SIGNATURE reply_key_signature;
} KERB_SIGNED_REPLY_KEY_PACKAGE;
#define KERB_SIGNED_REPLY_KEY_PACKAGE_PDU 39
#define SIZE_KRB5_Module_PDU_39 sizeof(KERB_SIGNED_REPLY_KEY_PACKAGE)

typedef struct KERB_SIGNED_KDC_PUBLIC_VALUE {
    KERB_SUBJECT_PUBLIC_KEY_INFO kdc_public_value;
    KERB_SIGNATURE kdc_public_value_sig;
} KERB_SIGNED_KDC_PUBLIC_VALUE;

typedef struct KERB_TRUSTED_CAS {
    ASN1choice_t choice;
    union {
#	define principal_name_chosen 1
	KERB_KERBEROS_NAME principal_name;
#	define ca_name_chosen 2
	ASN1octetstring_t ca_name;
#	define issuer_and_serial_chosen 3
	ASN1octetstring_t issuer_and_serial;
    } u;
} KERB_TRUSTED_CAS;

typedef struct KERB_AUTH_PACKAGE {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_PK_AUTHENTICATOR pk_authenticator;
#   define client_public_value_present 0x80
    KERB_SUBJECT_PUBLIC_KEY_INFO client_public_value;
} KERB_AUTH_PACKAGE;
#define KERB_AUTH_PACKAGE_PDU 40
#define SIZE_KRB5_Module_PDU_40 sizeof(KERB_AUTH_PACKAGE)

typedef struct KERB_PA_COMPOUND_IDENTITY_s {
    PKERB_PA_COMPOUND_IDENTITY next;
    KERB_TICKET value;
} KERB_PA_COMPOUND_IDENTITY_Element, *KERB_PA_COMPOUND_IDENTITY;
#define KERB_PA_COMPOUND_IDENTITY_PDU 41
#define SIZE_KRB5_Module_PDU_41 sizeof(KERB_PA_COMPOUND_IDENTITY_Element)

typedef struct KERB_PA_PK_AS_REQ_trusted_certifiers_s {
    PKERB_PA_PK_AS_REQ_trusted_certifiers next;
    KERB_TRUSTED_CAS value;
} KERB_PA_PK_AS_REQ_trusted_certifiers_Element, *KERB_PA_PK_AS_REQ_trusted_certifiers;

typedef struct KERB_ENCRYPTED_CRED_ticket_info_s {
    PKERB_ENCRYPTED_CRED_ticket_info next;
    KERB_CRED_INFO value;
} KERB_ENCRYPTED_CRED_ticket_info_Element, *KERB_ENCRYPTED_CRED_ticket_info;

typedef struct KERB_CRED_tickets_s {
    PKERB_CRED_tickets next;
    KERB_TICKET value;
} KERB_CRED_tickets_Element, *KERB_CRED_tickets;

typedef struct KERB_KDC_REQUEST_BODY_additional_tickets_s {
    PKERB_KDC_REQUEST_BODY_additional_tickets next;
    KERB_TICKET value;
} KERB_KDC_REQUEST_BODY_additional_tickets_Element, *KERB_KDC_REQUEST_BODY_additional_tickets;

typedef struct KERB_KDC_REQUEST {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    ASN1int32_t message_type;
#   define KERB_KDC_REQUEST_preauth_data_present 0x80
    PKERB_KDC_REQUEST_preauth_data preauth_data;
    KERB_KDC_REQUEST_BODY request_body;
} KERB_KDC_REQUEST;

typedef KERB_KDC_REQUEST_BODY KERB_MARSHALLED_REQUEST_BODY;
#define KERB_MARSHALLED_REQUEST_BODY_PDU 42
#define SIZE_KRB5_Module_PDU_42 sizeof(KERB_MARSHALLED_REQUEST_BODY)

typedef KERB_KDC_REPLY KERB_AS_REPLY;
#define KERB_AS_REPLY_PDU 43
#define SIZE_KRB5_Module_PDU_43 sizeof(KERB_AS_REPLY)

typedef KERB_KDC_REPLY KERB_TGS_REPLY;
#define KERB_TGS_REPLY_PDU 44
#define SIZE_KRB5_Module_PDU_44 sizeof(KERB_TGS_REPLY)

typedef KERB_ENCRYPTED_KDC_REPLY KERB_ENCRYPTED_AS_REPLY;
#define KERB_ENCRYPTED_AS_REPLY_PDU 45
#define SIZE_KRB5_Module_PDU_45 sizeof(KERB_ENCRYPTED_AS_REPLY)

typedef KERB_ENCRYPTED_KDC_REPLY KERB_ENCRYPTED_TGS_REPLY;
#define KERB_ENCRYPTED_TGS_REPLY_PDU 46
#define SIZE_KRB5_Module_PDU_46 sizeof(KERB_ENCRYPTED_TGS_REPLY)

typedef struct KERB_PA_PK_AS_REP2 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define key_package_present 0x80
    KERB_ENCRYPTED_DATA key_package;
    KERB_ENVELOPED_KEY_PACKAGE temp_key_package;
#   define signed_kdc_public_value_present 0x40
    KERB_SIGNED_KDC_PUBLIC_VALUE signed_kdc_public_value;
#   define KERB_PA_PK_AS_REP2_kdc_cert_present 0x20
    PKERB_PA_PK_AS_REP2_kdc_cert kdc_cert;
} KERB_PA_PK_AS_REP2;
#define KERB_PA_PK_AS_REP2_PDU 47
#define SIZE_KRB5_Module_PDU_47 sizeof(KERB_PA_PK_AS_REP2)

typedef struct KERB_SIGNED_AUTH_PACKAGE {
    KERB_AUTH_PACKAGE auth_package;
    KERB_SIGNATURE auth_package_signature;
} KERB_SIGNED_AUTH_PACKAGE;

typedef KERB_KDC_REQUEST KERB_AS_REQUEST;
#define KERB_AS_REQUEST_PDU 48
#define SIZE_KRB5_Module_PDU_48 sizeof(KERB_AS_REQUEST)

typedef KERB_KDC_REQUEST KERB_TGS_REQUEST;
#define KERB_TGS_REQUEST_PDU 49
#define SIZE_KRB5_Module_PDU_49 sizeof(KERB_TGS_REQUEST)

typedef struct KERB_PA_PK_AS_REQ2 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_SIGNED_AUTH_PACKAGE signed_auth_pack;
#   define user_certs_present 0x80
    PKERB_PA_PK_AS_REQ2_user_certs user_certs;
#   define KERB_PA_PK_AS_REQ2_trusted_certifiers_present 0x40
    PKERB_PA_PK_AS_REQ2_trusted_certifiers trusted_certifiers;
#   define serial_number_present 0x20
    KERB_CERTIFICATE_SERIAL_NUMBER serial_number;
} KERB_PA_PK_AS_REQ2;
#define KERB_PA_PK_AS_REQ2_PDU 50
#define SIZE_KRB5_Module_PDU_50 sizeof(KERB_PA_PK_AS_REQ2)


extern void ASN1CALL KRB5_Module_Startup(ASN1module_t pASN1Module);
extern void ASN1CALL KRB5_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */

#endif /* _KRB5_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\kerbclient\msasn1.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation 1997-1998, All rights reserved. */

#ifndef __MS_ASN1_H__
#define __MS_ASN1_H__

#include <pshpack8.h> /* Assume 8 byte packing throughout */

/* ------ Basic integer types ------ */

typedef unsigned char   ASN1uint8_t;
typedef signed char     ASN1int8_t;

typedef unsigned short  ASN1uint16_t;
typedef signed short    ASN1int16_t;

typedef unsigned long   ASN1uint32_t;
typedef signed long     ASN1int32_t;


/* ------ Function modifiers ------ */

#define ASN1_PUBLIC
#define ASN1API         __stdcall
#define ASN1CALL        __stdcall


/* ------ Basic ASN.1 types ------ */

typedef ASN1uint8_t ASN1octet_t;

typedef ASN1uint8_t ASN1bool_t;

typedef struct tagASN1intx_t
{
    ASN1uint32_t length;
    ASN1octet_t *value;
}
    ASN1intx_t;

typedef struct tagASN1octetstring_t
{
    ASN1uint32_t length;
    ASN1octet_t *value;
}
    ASN1octetstring_t;

typedef struct tagASN1octetstring2_t
{
    ASN1uint32_t length;
    ASN1octet_t value[1];
}
    ASN1octetstring2_t;

typedef struct ASN1iterator_s
{
    struct ASN1iterator_s *next;
    void *value;
}
    ASN1iterator_t;

typedef struct tagASN1bitstring_t
{
    ASN1uint32_t length;
    ASN1octet_t *value;
}
    ASN1bitstring_t;

typedef char ASN1char_t;

typedef struct tagASN1charstring_t
{
    ASN1uint32_t length;
    ASN1char_t *value;
}
    ASN1charstring_t;

typedef ASN1uint16_t ASN1char16_t;

typedef struct tagASN1char16string_t
{
    ASN1uint32_t length;
    ASN1char16_t *value;
}
    ASN1char16string_t;

typedef ASN1uint32_t ASN1char32_t;

typedef struct tagASN1char32string_t
{
    ASN1uint32_t length;
    ASN1char32_t *value;
}
    ASN1char32string_t;

typedef ASN1char_t *ASN1ztcharstring_t;
typedef ASN1char16_t *ASN1ztchar16string_t;
typedef ASN1char32_t *ASN1ztchar32string_t;

typedef struct tagASN1wstring_t
{
    ASN1uint32_t length;
    WCHAR *value;
}
    ASN1wstring_t;

typedef struct ASN1objectidentifier_s
{
    struct ASN1objectidentifier_s *next;
    ASN1uint32_t value;
}
    *ASN1objectidentifier_t;

typedef struct tagASN1objectidentifier2_t
{
    ASN1uint16_t count;
    ASN1uint32_t value[16];
}
    ASN1objectidentifier2_t;

typedef struct tagASN1encodedOID_t
{
    ASN1uint16_t length;
    ASN1octet_t  *value;
}
    ASN1encodedOID_t;

typedef struct tagASN1stringtableentry_t
{
    ASN1char32_t lower;
    ASN1char32_t upper;
    ASN1uint32_t value;
}
    ASN1stringtableentry_t;

typedef struct tagASN1stringtable_t
{
    ASN1uint32_t length;
    ASN1stringtableentry_t *values;
}
    ASN1stringtable_t;

typedef ASN1ztcharstring_t ASN1objectdescriptor_t;

typedef struct tagASN1generalizedtime_t
{
    ASN1uint16_t year;
    ASN1uint8_t month;
    ASN1uint8_t day;
    ASN1uint8_t hour;
    ASN1uint8_t minute;
    ASN1uint8_t second;
    ASN1uint16_t millisecond;
    ASN1bool_t universal;
    ASN1int16_t diff;
}
    ASN1generalizedtime_t;

typedef struct tagASN1utctime_t
{
    ASN1uint8_t year;
    ASN1uint8_t month;
    ASN1uint8_t day;
    ASN1uint8_t hour;
    ASN1uint8_t minute;
    ASN1uint8_t second;
    ASN1bool_t universal;
    ASN1int16_t diff;
}
    ASN1utctime_t;

typedef struct tagASN1open_t
{
    // encoded
    ASN1uint32_t    length;
    union
    {
        void           *encoded;
        void           *value;
    };
}
    ASN1open_t;

typedef enum tagASN1blocktype_e
{
    ASN1_DER_SET_OF_BLOCK,
}
    ASN1blocktype_e;

typedef ASN1int32_t     ASN1enum_t;     // enumerated type

typedef ASN1uint16_t    ASN1choice_t;   // choice

typedef ASN1uint32_t    ASN1magic_t;

/* ------ Current version of this ASN.1 software ------ */

#define ASN1_MAKE_VERSION(major,minor)  (((major) << 16) | (minor))
#define ASN1_THIS_VERSION               ASN1_MAKE_VERSION(1,0)

enum
{
    ASN1_CHOICE_BASE      = 1,
    ASN1_CHOICE_INVALID   = -1,     // invalid choice
    ASN1_CHOICE_EXTENSION = 0,      // extension choice
};



/*
   Error codes for decoding functions:
   - err == 0:    data has been successfully decoded
   - err <  0:    fatal error has occured, no data has been generated
                  err contains the error number
   - err >  0:    non-fatal event has occured, data has been generated
                  err is a bit set of occured events
 */

typedef enum tagASN1error_e
{
    ASN1_SUCCESS        = 0,            /* success */

    // Teles specific error codes
    ASN1_ERR_INTERNAL   = (-1001),      /* internal error */
    ASN1_ERR_EOD        = (-1002),      /* unexpected end of data */
    ASN1_ERR_CORRUPT    = (-1003),      /* corrupted data */
    ASN1_ERR_LARGE      = (-1004),      /* value too large */
    ASN1_ERR_CONSTRAINT = (-1005),      /* constraint violated */
    ASN1_ERR_MEMORY     = (-1006),      /* out of memory */
    ASN1_ERR_OVERFLOW   = (-1007),      /* buffer overflow */
    ASN1_ERR_BADPDU     = (-1008),      /* function not supported for this pdu*/
    ASN1_ERR_BADARGS    = (-1009),      /* bad arguments to function call */
    ASN1_ERR_BADREAL    = (-1010),      /* bad real value */
    ASN1_ERR_BADTAG     = (-1011),      /* bad tag value met */
    ASN1_ERR_CHOICE     = (-1012),      /* bad choice value */
    ASN1_ERR_RULE       = (-1013),      /* bad encoding rule */
    ASN1_ERR_UTF8       = (-1014),      /* bad unicode (utf8) */

    // New error codes
    ASN1_ERR_PDU_TYPE   = (-1051),      /* bad pdu type */
    ASN1_ERR_NYI        = (-1052),      /* not yet implemented */

    // Teles specific warning codes
    ASN1_WRN_EXTENDED   = 1001,         /* skipped unknown extension(s) */
    ASN1_WRN_NOEOD      = 1002,         /* end of data expected */
}
    ASN1error_e;

#define ASN1_SUCCEEDED(ret)     (((int) (ret)) >= 0)
#define ASN1_FAILED(ret)        (((int) (ret)) < 0)


/* ------ Encoding rules ------ */

typedef enum
{
    ASN1_PER_RULE_ALIGNED       = 0x0001,
    ASN1_PER_RULE_UNALIGNED     = 0x0002, // not supported
    ASN1_PER_RULE               = ASN1_PER_RULE_ALIGNED | ASN1_PER_RULE_UNALIGNED,

    ASN1_BER_RULE_BER           = 0x0100,
    ASN1_BER_RULE_CER           = 0x0200,
    ASN1_BER_RULE_DER           = 0x0400,
    ASN1_BER_RULE               = ASN1_BER_RULE_BER | ASN1_BER_RULE_CER | ASN1_BER_RULE_DER,
}
    ASN1encodingrule_e;

/* ------ public structures ------ */

typedef struct ASN1encoding_s   *ASN1encoding_t;
typedef struct ASN1decoding_s   *ASN1decoding_t;

typedef ASN1int32_t (ASN1CALL *ASN1PerEncFun_t)(ASN1encoding_t enc, void *data);
typedef ASN1int32_t (ASN1CALL *ASN1PerDecFun_t)(ASN1decoding_t enc, void *data);
typedef struct tagASN1PerFunArr_t
{
    const ASN1PerEncFun_t *apfnEncoder;
    const ASN1PerDecFun_t *apfnDecoder;
}
    ASN1PerFunArr_t;

typedef ASN1int32_t (ASN1CALL *ASN1BerEncFun_t)(ASN1encoding_t enc, ASN1uint32_t tag, void *data);
typedef ASN1int32_t (ASN1CALL *ASN1BerDecFun_t)(ASN1decoding_t enc, ASN1uint32_t tag, void *data);
typedef struct tagASN1BerFunArr_t
{
    const ASN1BerEncFun_t *apfnEncoder;
    const ASN1BerDecFun_t *apfnDecoder;
}
    ASN1BerFunArr_t;

typedef void (ASN1CALL *ASN1GenericFun_t)(void);
typedef void (ASN1CALL *ASN1FreeFun_t)(void *data);

typedef struct tagASN1module_t
{
    ASN1magic_t             nModuleName;
    ASN1encodingrule_e      eRule;
    ASN1uint32_t            dwFlags;
    ASN1uint32_t            cPDUs;

    const ASN1FreeFun_t    *apfnFreeMemory;
    const ASN1uint32_t     *acbStructSize;
    union
    {
        ASN1PerFunArr_t     PER;
        ASN1BerFunArr_t     BER;
    };
}
    *ASN1module_t;


struct ASN1encoding_s
{
    class CScratchMemoryAllocator* pScratchMemoryAllocator;
    ASN1magic_t         magic;  /* magic for this structure */
    ASN1uint32_t        version;/* version number of this library */
    ASN1module_t        module; /* module this encoding_t depends to */
    ASN1octet_t        *buf;    /* buffer to encode into */
    ASN1uint32_t        size;   /* current size of buffer */
    ASN1uint32_t        len;    /* len of encoded data in buffer */
    ASN1error_e         err;    /* error code for last encoding */
    ASN1uint32_t        bit;
    ASN1octet_t        *pos;
    ASN1uint32_t        cbExtraHeader;
    ASN1encodingrule_e  eRule;
    ASN1uint32_t        dwFlags;
};

struct ASN1decoding_s
{
    class CScratchMemoryAllocator* pScratchMemoryAllocator;
    ASN1magic_t         magic;  /* magic for this structure */
    ASN1uint32_t        version;/* version number of this library */
    ASN1module_t        module; /* module this decoding_t depends to */
    ASN1octet_t        *buf;    /* buffer to decode from */
    ASN1uint32_t        size;   /* size of buffer */
    ASN1uint32_t        len;    /* len of decoded data in buffer */
    ASN1error_e         err;    /* error code for last decoding */
    ASN1uint32_t        bit;
    ASN1octet_t        *pos;
    ASN1encodingrule_e  eRule;
    ASN1uint32_t        dwFlags;
};


/* --- flags for functions --- */

#define ASN1DECFREE_NON_PDU_ID    ((ASN1uint32_t) -1)

enum
{
    ASN1FLAGS_NONE              = 0x00000000L, /* no flags */
    ASN1FLAGS_NOASSERT          = 0x00001000L, /* no asertion */
};

enum
{
    ASN1ENCODE_APPEND           = 0x00000001L, /* append to current buffer*/
    ASN1ENCODE_REUSEBUFFER      = 0x00000004L, /* empty destination buffer */
    ASN1ENCODE_SETBUFFER        = 0x00000008L, /* use a user-given destination buffer */
    ASN1ENCODE_ALLOCATEBUFFER   = 0x00000010L, /* do not free/reuse buffer */
    ASN1ENCODE_NOASSERT         = ASN1FLAGS_NOASSERT, /* no asertion */
};

enum
{
    ASN1DECODE_APPENDED         = 0x00000001L, /* continue behind last pdu*/
    ASN1DECODE_REWINDBUFFER     = 0x00000004L, /* rescan from buffer start*/
    ASN1DECODE_SETBUFFER        = 0x00000008L, /* use a user-given src buffer */
    ASN1DECODE_NOASSERT         = ASN1FLAGS_NOASSERT, /* no asertion */
};

/* ------ public basic ASN.1 API ------ */

extern ASN1_PUBLIC void ASN1API ASN1_InitModule
(
    ASN1module_t            module,
    ASN1uint32_t            version,
    ASN1encodingrule_e      eEncodingRule,
    ASN1uint32_t            dwFlags,
    ASN1uint32_t            cPDUs,
    const ASN1GenericFun_t  apfnEncoder[],
    const ASN1GenericFun_t  apfnDecoder[],
    const ASN1FreeFun_t     apfnFreeMemory[],
    const ASN1uint32_t      acbStructSize[],
    ASN1magic_t             nModuleName
);

extern ASN1_PUBLIC ASN1module_t ASN1API ASN1_CreateModule
(
    ASN1uint32_t            nVersion,
    ASN1encodingrule_e      eRule,
    ASN1uint32_t            dwFlags, /* ASN1FLAGS_NONE or ASN1FLAGS_NOASSERT */
    ASN1uint32_t            cPDU,
    const ASN1GenericFun_t  apfnEncoder[],
    const ASN1GenericFun_t  apfnDecoder[],
    const ASN1FreeFun_t     apfnFreeMemory[],
    const ASN1uint32_t      acbStructSize[],
    ASN1magic_t             nModuleName
);

extern ASN1_PUBLIC void ASN1API ASN1_CloseModule
(
    ASN1module_t        pModule
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_CreateEncoder
(
    CScratchMemoryAllocator* pScratchMemoryAllocator,
    ASN1module_t        pModule,
    ASN1encoding_t     *ppEncoderInfo,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize,
    ASN1encoding_t      pParent
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_Encode
(
    ASN1encoding_t      pEncoderInfo,
    void               *pDataStruct,
    ASN1uint32_t        nPduNum,
    ASN1uint32_t        dwFlags,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize
);

extern ASN1_PUBLIC void ASN1API ASN1_CloseEncoder
(
    ASN1encoding_t      pEncoderInfo
);

extern ASN1_PUBLIC void ASN1API ASN1_CloseEncoder2
(
    ASN1encoding_t      pEncoderInfo
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_CreateDecoder
(
    CScratchMemoryAllocator* pScratchMemoryAllocator,
    ASN1module_t        pModule,
    ASN1decoding_t     *ppDecoderInfo,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize,
    ASN1decoding_t      pParent
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_Decode
(
    ASN1decoding_t      pDecoderInfo,
    void              **ppDataStruct,
    ASN1uint32_t        nPduNum,
    ASN1uint32_t        dwFlags,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize
);

extern ASN1_PUBLIC void ASN1API ASN1_CloseDecoder
(
    ASN1decoding_t      pDecoderInfo
);


extern ASN1_PUBLIC void ASN1API ASN1_FreeEncoded
(
    const ASN1encoding_s*      pEncoderInfo,
    void                       *pBuf
);

extern ASN1_PUBLIC void ASN1API ASN1_FreeDecoded
(
    ASN1decoding_t      pDecoderInfo,
    void               *pDataStruct,
    ASN1uint32_t        nPduNum
);


/* ------ public advanced ASN.1 API ------ */

typedef enum
{
    // common set option
    ASN1OPT_CHANGE_RULE                 = 0x101,

    // common get option
    ASN1OPT_GET_RULE                    = 0x201,

    // set encoder option
    ASN1OPT_NOT_REUSE_BUFFER            = 0x301,
    ASN1OPT_REWIND_BUFFER               = 0x302,

    // get encoder option

    // set decoder option
    ASN1OPT_SET_DECODED_BUFFER          = 0x501,
    ASN1OPT_DEL_DECODED_BUFFER          = 0x502,

    // get decoder option
    ASN1OPT_GET_DECODED_BUFFER_SIZE     = 0x601,
}
    ASN1option_e;

typedef struct tagASN1optionparam_t
{
    ASN1option_e    eOption;
    union
    {
        ASN1encodingrule_e              eRule;
        ASN1uint32_t                    cbRequiredDecodedBufSize;
        struct
        {
            ASN1octet_t    *pbBuf;
            ASN1uint32_t    cbBufSize;
        }                               Buffer;
    };
}
    ASN1optionparam_t, ASN1optionparam_s;


extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_SetEncoderOption
(
    ASN1encoding_t      pEncoderInfo,
    const ASN1optionparam_t  *pOptParam
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_GetEncoderOption
(
    ASN1encoding_t      pEncoderInfo,
    ASN1optionparam_t  *pOptParam
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_SetDecoderOption
(
    ASN1decoding_t      pDecoderInfo,
    ASN1optionparam_t  *pOptParam
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_GetDecoderOption
(
    ASN1decoding_t      pDecoderInfo,
    ASN1optionparam_t  *pOptParam
);


/* ------ internal ASN.1 API ------ */

extern ASN1_PUBLIC void ASN1API ASN1bitstring_free(const ASN1bitstring_t *);
extern ASN1_PUBLIC void ASN1API ASN1octetstring_free(const ASN1octetstring_t *);
extern ASN1_PUBLIC void ASN1API ASN1objectidentifier_free(ASN1objectidentifier_t *);
extern ASN1_PUBLIC void ASN1API ASN1charstring_free(const ASN1charstring_t *);
extern ASN1_PUBLIC void ASN1API ASN1char16string_free(const ASN1char16string_t *);
extern ASN1_PUBLIC void ASN1API ASN1char32string_free(const ASN1char32string_t *);
extern ASN1_PUBLIC void ASN1API ASN1ztcharstring_free(ASN1ztcharstring_t);
extern ASN1_PUBLIC void ASN1API ASN1ztchar16string_free(ASN1ztchar16string_t);
extern ASN1_PUBLIC void ASN1API ASN1ztchar32string_free(ASN1ztchar32string_t);
extern ASN1_PUBLIC void ASN1API ASN1open_free(const ASN1open_t *);
extern ASN1_PUBLIC void ASN1API ASN1utf8string_free(const ASN1wstring_t *);

extern ASN1_PUBLIC void * ASN1API ASN1DecAlloc(ASN1decoding_t dec, ASN1uint32_t size);
extern ASN1_PUBLIC void * ASN1API ASN1DecRealloc(ASN1decoding_t dec, void *ptr, ASN1uint32_t size);
extern ASN1_PUBLIC void   ASN1API ASN1Free(void *ptr);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1EncSetError(ASN1encoding_t enc, ASN1error_e err);
extern ASN1_PUBLIC ASN1error_e ASN1API ASN1DecSetError(ASN1decoding_t dec, ASN1error_e err);

extern ASN1_PUBLIC void ASN1API ASN1intx_sub(ASN1intx_t *, ASN1intx_t *, ASN1intx_t *);
extern ASN1_PUBLIC ASN1uint32_t ASN1API ASN1intx_uoctets(ASN1intx_t *);
extern ASN1_PUBLIC void ASN1API ASN1intx_free(ASN1intx_t *);
extern ASN1_PUBLIC void ASN1API ASN1intx_add(ASN1intx_t *, ASN1intx_t *, ASN1intx_t *);

extern ASN1_PUBLIC void ASN1API ASN1DbgMemTrackDumpCurrent ( ASN1uint32_t nModuleName );

extern ASN1_PUBLIC ASN1uint32_t ASN1API ASN1uint32_uoctets(ASN1uint32_t);

extern ASN1_PUBLIC int ASN1API ASN1objectidentifier_cmp(ASN1objectidentifier_t *v1, ASN1objectidentifier_t *v2);
extern ASN1_PUBLIC int ASN1API ASN1objectidentifier2_cmp(ASN1objectidentifier2_t *v1, ASN1objectidentifier2_t *v2);
extern ASN1_PUBLIC int ASN1API ASN1bitstring_cmp(ASN1bitstring_t *, ASN1bitstring_t *, int);
extern ASN1_PUBLIC int ASN1API ASN1octetstring_cmp(ASN1octetstring_t *, ASN1octetstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1objectidentifier_cmp(ASN1objectidentifier_t *, ASN1objectidentifier_t *);
extern ASN1_PUBLIC int ASN1API ASN1charstring_cmp(ASN1charstring_t *, ASN1charstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1char16string_cmp(ASN1char16string_t *, ASN1char16string_t *);
extern ASN1_PUBLIC int ASN1API ASN1char32string_cmp(ASN1char32string_t *, ASN1char32string_t *);
extern ASN1_PUBLIC int ASN1API ASN1ztcharstring_cmp(ASN1ztcharstring_t, ASN1ztcharstring_t);
extern ASN1_PUBLIC int ASN1API ASN1ztchar16string_cmp(ASN1ztchar16string_t, ASN1ztchar16string_t);
extern ASN1_PUBLIC int ASN1API ASN1open_cmp(ASN1open_t *, ASN1open_t *);
extern ASN1_PUBLIC int ASN1API ASN1generalizedtime_cmp(ASN1generalizedtime_t *, ASN1generalizedtime_t *);
extern ASN1_PUBLIC int ASN1API ASN1utctime_cmp(ASN1utctime_t *, ASN1utctime_t *);


/* --------------------------------------------------------- */
/* The following is not supported.                           */
/* --------------------------------------------------------- */

typedef enum tagASN1real_e
{
    eReal_Normal,
    eReal_PlusInfinity,
    eReal_MinusInfinity
}
    ASN1real_e;

typedef struct tagASN1real_t
{
    ASN1real_e type;
    ASN1intx_t mantissa;
    ASN1uint32_t base;
    ASN1intx_t exponent;
}
    ASN1real_t;

typedef struct tagASN1external_t
{
#   define ASN1external_data_value_descriptor_o 0
    ASN1octet_t o[1];
    struct ASN1external_identification_s
    {
        ASN1uint8_t o;
        union
        {
#            define ASN1external_identification_syntax_o 1
            ASN1objectidentifier_t syntax;
#            define ASN1external_identification_presentation_context_id_o 2
            ASN1uint32_t presentation_context_id;
#            define ASN1external_identification_context_negotiation_o 3
            struct ASN1external_identification_context_negotiation_s
            {
                ASN1uint32_t presentation_context_id;
                ASN1objectidentifier_t transfer_syntax;
            } context_negotiation;
        } u;
    } identification;
    ASN1objectdescriptor_t data_value_descriptor;
    struct ASN1external_data_value_s
    {
        ASN1uint8_t o;
        union
        {
#            define ASN1external_data_value_notation_o 0
            ASN1open_t notation;
#            define ASN1external_data_value_encoded_o 1
            ASN1bitstring_t encoded;
        } u;
    } data_value;
}
    ASN1external_t;

typedef struct ASN1external_identification_s ASN1external_identification_t;
typedef struct ASN1external_identification_context_negotiation_s ASN1external_identification_context_negotiation_t;
typedef struct ASN1external_data_value_s ASN1external_data_value_t;

typedef struct tagASN1embeddedpdv_t
{
    struct ASN1embeddedpdv_identification_s
    {
        ASN1uint8_t o;
        union
        {
#            define ASN1embeddedpdv_identification_syntaxes_o 0
            struct ASN1embeddedpdv_identification_syntaxes_s
            {
                ASN1objectidentifier_t abstract;
                ASN1objectidentifier_t transfer;
            } syntaxes;
#            define ASN1embeddedpdv_identification_syntax_o 1
            ASN1objectidentifier_t syntax;
#            define ASN1embeddedpdv_identification_presentation_context_id_o 2
            ASN1uint32_t presentation_context_id;
#            define ASN1embeddedpdv_identification_context_negotiation_o 3
            struct ASN1embeddedpdv_identification_context_negotiation_s
            {
                ASN1uint32_t presentation_context_id;
                ASN1objectidentifier_t transfer_syntax;
            } context_negotiation;
#            define ASN1embeddedpdv_identification_transfer_syntax_o 4
            ASN1objectidentifier_t transfer_syntax;
#            define ASN1embeddedpdv_identification_fixed_o 5
        } u;
    } identification;
    struct ASN1embeddedpdv_data_value_s
    {
        ASN1uint8_t o;
        union
        {
#            define ASN1embeddedpdv_data_value_notation_o 0
            ASN1open_t notation;
#            define ASN1embeddedpdv_data_value_encoded_o 1
            ASN1bitstring_t encoded;
        } u;
    } data_value;
}
    ASN1embeddedpdv_t;

typedef struct ASN1embeddedpdv_identification_s ASN1embeddedpdv_identification_t;
typedef struct ASN1embeddedpdv_identification_syntaxes_s ASN1embeddedpdv_identification_syntaxes_t;
typedef struct ASN1embeddedpdv_identification_context_negotiation_s ASN1embeddedpdv_identification_context_negotiation_t;
typedef struct ASN1embeddedpdv_data_value_s ASN1embeddedpdv_data_value_t;

typedef struct tagASN1characterstring_t
{
    struct ASN1characterstring_identification_s
    {
        ASN1uint8_t o;
        union
        {
#            define ASN1characterstring_identification_syntaxes_o 0
            struct ASN1characterstring_identification_syntaxes_s
            {
                ASN1objectidentifier_t abstract;
                ASN1objectidentifier_t transfer;
            } syntaxes;
#            define ASN1characterstring_identification_syntax_o 1
            ASN1objectidentifier_t syntax;
#            define ASN1characterstring_identification_presentation_context_id_o 2
            ASN1uint32_t presentation_context_id;
#            define ASN1characterstring_identification_context_negotiation_o 3
            struct ASN1characterstring_identification_context_negotiation_s
            {
                ASN1uint32_t presentation_context_id;
                ASN1objectidentifier_t transfer_syntax;
            } context_negotiation;
#            define ASN1characterstring_identification_transfer_syntax_o 4
            ASN1objectidentifier_t transfer_syntax;
#            define ASN1characterstring_identification_fixed_o 5
        } u;
    } identification;
    struct ASN1characterstring_data_value_s
    {
        ASN1uint8_t o;
        union
        {
#            define ASN1characterstring_data_value_notation_o 0
            ASN1open_t notation;
#            define ASN1characterstring_data_value_encoded_o 1
            ASN1octetstring_t encoded;
        } u;
    } data_value;
} ASN1characterstring_t;

typedef struct ASN1characterstring_identification_s ASN1characterstring_identification_t;
typedef struct ASN1characterstring_identification_syntaxes_s ASN1characterstring_identification_syntaxes_t;
typedef struct ASN1characterstring_identification_context_negotiation_s ASN1characterstring_identification_context_negotiation_t;
typedef struct ASN1characterstring_data_value_s ASN1characterstring_data_value_t;


extern ASN1_PUBLIC void ASN1API ASN1real_free(ASN1real_t *);
extern ASN1_PUBLIC void ASN1API ASN1external_free(ASN1external_t *);
extern ASN1_PUBLIC void ASN1API ASN1embeddedpdv_free(ASN1embeddedpdv_t *);
extern ASN1_PUBLIC void ASN1API ASN1characterstring_free(ASN1characterstring_t *);

#include <poppack.h> /* End 8-byte packing */

//
// msber.h
//

//
#include <pshpack8.h> /* Assume 8 byte packing throughout */

extern ASN1_PUBLIC int ASN1API ASN1BEREncCharString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t, ASN1char_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncChar16String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t, const ASN1char16_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncChar32String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t, const ASN1char32_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncOctetString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val);
extern ASN1_PUBLIC int ASN1API ASN1BEREncBitString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t, ASN1octet_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncDouble(ASN1encoding_t enc, ASN1uint32_t tag, double);
extern ASN1_PUBLIC int ASN1API ASN1BEREncGeneralizedTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1generalizedtime_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncS32(ASN1encoding_t enc, ASN1uint32_t tag, ASN1int32_t);
extern ASN1_PUBLIC int ASN1API ASN1BEREncSX(ASN1encoding_t enc, ASN1uint32_t tag, ASN1intx_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncZeroMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1ztcharstring_t);
extern ASN1_PUBLIC int ASN1API ASN1BEREncMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1charstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncNull(ASN1encoding_t enc, ASN1uint32_t tag);
extern ASN1_PUBLIC int ASN1API ASN1BEREncObjectIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, ASN1objectidentifier_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncObjectIdentifier2(ASN1encoding_t enc, ASN1uint32_t tag, const ASN1objectidentifier2_t *val);
extern ASN1_PUBLIC int ASN1API ASN1BEREncRemoveZeroBits(ASN1uint32_t *, const ASN1octet_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncUTCTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1utctime_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncFlush(ASN1encoding_t enc);
extern ASN1_PUBLIC int ASN1API ASN1BEREncOpenType(ASN1encoding_t enc, ASN1open_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecExplicitTag(ASN1decoding_t dec, ASN1uint32_t tag, ASN1decoding_t *dd, ASN1octet_t **di);
extern ASN1_PUBLIC int ASN1API ASN1BERDecEndOfContents(ASN1decoding_t dec, ASN1decoding_t dd, ASN1octet_t *di);
extern ASN1_PUBLIC int ASN1API ASN1BERDecOctetString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1octetstring_t *val);
extern ASN1_PUBLIC int ASN1API ASN1BERDecOctetString2(ASN1decoding_t dec, ASN1uint32_t tag, ASN1octetstring_t *val);
extern ASN1_PUBLIC int ASN1API ASN1BERDecBitString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1bitstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecBitString2(ASN1decoding_t dec, ASN1uint32_t tag, ASN1bitstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecChar16String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1char16string_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecChar32String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1char32string_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecCharString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1charstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecDouble(ASN1decoding_t dec, ASN1uint32_t tag, double *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecGeneralizedTime(ASN1decoding_t dec, ASN1uint32_t tag, ASN1generalizedtime_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecZeroMultibyteString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztcharstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecMultibyteString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1charstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecNull(ASN1decoding_t dec, ASN1uint32_t tag);
extern ASN1_PUBLIC int ASN1API ASN1BERDecObjectIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, ASN1objectidentifier_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecObjectIdentifier2(ASN1decoding_t dec, ASN1uint32_t tag, ASN1objectidentifier2_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecS8Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1int8_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecS16Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1int16_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecS32Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1int32_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecSXVal(ASN1decoding_t dec, ASN1uint32_t tag, ASN1intx_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecU8Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint8_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecU16Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint16_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecUTCTime(ASN1decoding_t dec, ASN1uint32_t tag, ASN1utctime_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecZeroChar16String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztchar16string_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecZeroChar32String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztchar32string_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecZeroCharString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztcharstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecSkip(ASN1decoding_t dec);
extern ASN1_PUBLIC int ASN1API ASN1BERDecFlush(ASN1decoding_t dec);
extern ASN1_PUBLIC int ASN1API ASN1BERDecOpenType(ASN1decoding_t dec, ASN1open_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecOpenType2(ASN1decoding_t dec, ASN1open_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncCheck(ASN1encoding_t enc, ASN1uint32_t noctets);
extern ASN1_PUBLIC int ASN1API ASN1BEREncTag(ASN1encoding_t enc, ASN1uint32_t tag);
extern ASN1_PUBLIC int ASN1API ASN1BEREncExplicitTag(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t *pLengthOffset);
extern ASN1_PUBLIC int ASN1API ASN1BEREncEndOfContents(ASN1encoding_t enc, ASN1uint32_t LengthOffset);
extern ASN1_PUBLIC int ASN1API ASN1BEREncLength(ASN1encoding_t enc, ASN1uint32_t len);
extern ASN1_PUBLIC int ASN1API ASN1BERDecCheck(ASN1decoding_t dec, ASN1uint32_t len);
extern ASN1_PUBLIC int ASN1API ASN1BERDecTag(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint32_t *constructed);
extern ASN1_PUBLIC int ASN1API ASN1BERDecLength(ASN1decoding_t dec, ASN1uint32_t *len, ASN1uint32_t *infinite);
extern ASN1_PUBLIC int ASN1API ASN1BERDecNotEndOfContents(ASN1decoding_t dec, const ASN1octet_t *di);
extern ASN1_PUBLIC int ASN1API ASN1BERDecPeekTag(ASN1decoding_t dec, ASN1uint32_t *tag);
extern ASN1_PUBLIC int ASN1API ASN1BEREncU32(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t);
extern ASN1_PUBLIC int ASN1API ASN1BERDecU32Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint32_t *val);
extern ASN1_PUBLIC int ASN1API ASN1BEREncBool(ASN1encoding_t enc, ASN1uint32_t tag, ASN1bool_t);
extern ASN1_PUBLIC int ASN1API ASN1BERDecBool(ASN1decoding_t dec, ASN1uint32_t tag, ASN1bool_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncEoid(ASN1encoding_t enc, ASN1uint32_t tag, ASN1encodedOID_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecEoid(ASN1decoding_t dec, ASN1uint32_t tag, ASN1encodedOID_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDotVal2Eoid(ASN1encoding_t enc, char *pszDotVal, ASN1encodedOID_t *pOut);
extern ASN1_PUBLIC int ASN1API ASN1BEREoid2DotVal(ASN1decoding_t dec, ASN1encodedOID_t *pIn, char **ppszDotVal);
extern ASN1_PUBLIC void ASN1API ASN1BEREoid_free(const ASN1encodedOID_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncUTF8String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t length, WCHAR *value);
extern ASN1_PUBLIC int ASN1API ASN1BERDecUTF8String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1wstring_t *val);

/* CER variant of BER */

extern ASN1_PUBLIC int ASN1API ASN1CEREncCharString(ASN1encoding_t enc, ASN1uint32_t, ASN1uint32_t, ASN1char_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncChar16String(ASN1encoding_t enc, ASN1uint32_t, ASN1uint32_t, const ASN1char16_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncChar32String(ASN1encoding_t enc, ASN1uint32_t, ASN1uint32_t, const ASN1char32_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncBitString(ASN1encoding_t enc, ASN1uint32_t, ASN1uint32_t, ASN1octet_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncGeneralizedTime(ASN1encoding_t enc, ASN1uint32_t, ASN1generalizedtime_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncZeroMultibyteString(ASN1encoding_t enc, ASN1uint32_t, ASN1ztcharstring_t);
extern ASN1_PUBLIC int ASN1API ASN1CEREncMultibyteString(ASN1encoding_t enc, ASN1uint32_t, ASN1charstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncOctetString(ASN1encoding_t enc, ASN1uint32_t, ASN1uint32_t, ASN1octet_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncUTCTime(ASN1encoding_t enc, ASN1uint32_t, ASN1utctime_t *);

extern ASN1_PUBLIC int ASN1API ASN1CEREncBeginBlk(ASN1encoding_t enc, ASN1blocktype_e eBlkType, void **ppBlk);
extern ASN1_PUBLIC int ASN1API ASN1CEREncNewBlkElement(void *pBlk, ASN1encoding_t *enc2);
extern ASN1_PUBLIC int ASN1API ASN1CEREncFlushBlkElement(void *pBlk);
extern ASN1_PUBLIC int ASN1API ASN1CEREncEndBlk(void *pBlk);

/* DER variant of BER */

__inline int ASN1API ASN1DEREncGeneralizedTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1generalizedtime_t *val)
{
    return ASN1CEREncGeneralizedTime(enc, tag, val);
}
__inline int ASN1API ASN1DEREncUTCTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1utctime_t *val)
{
    return ASN1CEREncUTCTime(enc, tag, val);
}

__inline int ASN1API ASN1DEREncBeginBlk(ASN1encoding_t enc, ASN1blocktype_e eBlkType, void **ppBlk)
{
    return ASN1CEREncBeginBlk(enc, eBlkType, ppBlk);
}
__inline int ASN1API ASN1DEREncNewBlkElement(void *pBlk, ASN1encoding_t *enc2)
{
    return ASN1CEREncNewBlkElement(pBlk, enc2);
}
__inline int ASN1API ASN1DEREncFlushBlkElement(void *pBlk)
{
    return ASN1CEREncFlushBlkElement(pBlk);
}
__inline int ASN1API ASN1DEREncEndBlk(void *pBlk)
{
    return ASN1CEREncEndBlk(pBlk);
}

__inline int ASN1API ASN1DEREncCharString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char_t *val)
{
    return ASN1BEREncCharString(enc, tag, len, val);
}
__inline int ASN1API ASN1DEREncChar16String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, const ASN1char16_t *val)
{
    return ASN1BEREncChar16String(enc, tag, len, val);
}
__inline int ASN1API ASN1DEREncChar32String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, const ASN1char32_t *val)
{
    return ASN1BEREncChar32String(enc, tag, len, val);
}
__inline int ASN1API ASN1DEREncBitString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val)
{
    return ASN1BEREncBitString(enc, tag, len, val);
}
__inline int ASN1API ASN1DEREncZeroMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1ztcharstring_t val)
{
    return ASN1BEREncZeroMultibyteString(enc, tag, val);
}
__inline int ASN1API ASN1DEREncMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1charstring_t *val)
{
    return ASN1BEREncMultibyteString(enc, tag, val);
}
__inline int ASN1API ASN1DEREncOctetString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val)
{
    return ASN1BEREncOctetString(enc, tag, len, val);
}

__inline int ASN1API ASN1DEREncUTF8String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t length, WCHAR *value)
{
    return ASN1BEREncUTF8String(enc, tag, length, value);
}
__inline int ASN1API ASN1CEREncUTF8String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t length, WCHAR *value)
{
    return ASN1BEREncUTF8String(enc, tag, length, value);
}


/* --------------------------------------------------------- */
/* The following is not supported.                           */
/* --------------------------------------------------------- */

extern ASN1_PUBLIC int ASN1API ASN1BEREncEmbeddedPdv(ASN1encoding_t enc, ASN1uint32_t tag, ASN1embeddedpdv_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncExternal(ASN1encoding_t enc, ASN1uint32_t tag, ASN1external_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncCharacterString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1characterstring_t *);

extern ASN1_PUBLIC int ASN1API ASN1BERDecEmbeddedPdv(ASN1decoding_t dec, ASN1uint32_t tag, ASN1embeddedpdv_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecExternal(ASN1decoding_t dec, ASN1uint32_t tag, ASN1external_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecCharacterString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1characterstring_t *);

#include <poppack.h> /* End 8-byte packing */

#endif // __MS_ASN1_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\kerbclient\PassportAuth.cpp ===
#include "xonp.h"
#include <xcrypt.h>

#define ATL_NO_LEAN_AND_MEAN
#include <passportIdcrl.h>

#include <sha.h>
#include <md4.h>
#include <md5.h>
#include "kerbfuzz.h"

// --------------------------------------------------------------------------------------
// Protocol constants
// --------------------------------------------------------------------------------------
namespace PA_PASSPORT_AUTHENTICATION
{
    enum CONSTANTS
    {
        NONCE_LENGTH                = 8,
        TICKET_MAX_LENGTH           = 700,
    };
}

// --------------------------------------------------------------------------------------
// PA_PASSPORT_AUTHENTICATION_REP
// Passport authentication preauth reply
// --------------------------------------------------------------------------------------
struct PA_PASSPORT_AUTHENTICATION_REP
{
    UINT64  userId;
    CHAR    szGamertag[XONLINE_GAMERTAG_SIZE];
};

// --------------------------------------------------------------------------------------
// Forward Declarations
// --------------------------------------------------------------------------------------

NTSTATUS AddPassportAuthenticationPreAuth(
    CScratchMemoryAllocator*    pScratchAlloc,
    BYTE*                       pNonce,
    UINT32                      cbNonce,
    BYTE*                       pTicket,
    UINT32                      cbTicket,
    IN OUT PKERB_PA_DATA_LIST*  ppPreAuthData);

NTSTATUS
KerbAddTimestampPreAuth(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PKERB_ENCRYPTION_KEY UserKey,
    IN PTimeStamp pAuthTime,
    OUT PKERB_PA_DATA_LIST * PreAuthData);

NTSTATUS
KerbAddPacRequestPreAuth(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN BOOL fIncludePAC,
    IN OUT PKERB_PA_DATA_LIST * PreAuthData);

KERBERR
KerbAllocateEncryptionBuffer(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN ULONG EncryptionType,
    IN ULONG BufferSize,
    OUT PULONG EncryptionBufferSize,
    OUT PBYTE * EncryptionBuffer
    );

extern KERB_CRYPT_LIST g_RC4HMAC_CryptList;

// --------------------------------------------------------------------------------------
// AddPassportAuthenticationPreAuth
// --------------------------------------------------------------------------------------
NTSTATUS AddPassportAuthenticationPreAuth(
    CScratchMemoryAllocator*    pScratchAlloc,
    const AsRequestInfo        *pAsRequestInfo,
    IN OUT PKERB_PA_DATA_LIST*  ppPreAuthData
)
{
    // check parameters

    if(pAsRequestInfo->PassportTicketLength > PA_PASSPORT_AUTHENTICATION::TICKET_MAX_LENGTH)
    {
        return STATUS_INVALID_PARAMETER_5;
    }

    // Serialize request

    UINT32 cbRequestBuffer = 8 + sizeof(UINT16) + pAsRequestInfo->PassportTicketLength;
    BYTE* pRequestBuffer = (BYTE*) pScratchAlloc->Alloc(cbRequestBuffer);

    if(!pRequestBuffer)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    BYTE* pb = pRequestBuffer;
    memcpy(pb, &pAsRequestInfo->PcNonce, 8);
    pb += 8;
    *((UNALIGNED UINT16*)pb) = (UINT16) pAsRequestInfo->PassportTicketLength;
    pb += sizeof(UINT16);
    memcpy(pb, pAsRequestInfo->PassportTicket, pAsRequestInfo->PassportTicketLength);

    // Add it to the pre-auth list

    KERB_PA_DATA_LIST* pListElement;
    pListElement = (KERB_PA_DATA_LIST*) pScratchAlloc->Alloc(sizeof(KERB_PA_DATA_LIST));
    if(!pListElement)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    pListElement->value.preauth_data_type   = KRB5_PADATA_PASSPORT_AUTHENTICATION;
    pListElement->value.preauth_data.length = cbRequestBuffer;
    pListElement->value.preauth_data.value  = pRequestBuffer;
    pListElement->next = *ppPreAuthData;
    *ppPreAuthData = pListElement;

return STATUS_SUCCESS;
}

// --------------------------------------------------------------------------------------
// VerifyPassportAuthorizationReplyPreAuth
// --------------------------------------------------------------------------------------
KERBERR VerifyPassportAuthorizationPreAuthReply(
    CScratchMemoryAllocator* pScratchAlloc,
    KERB_PA_DATA* pPreAuthData,
    KERB_ENCRYPTION_KEY* pKey,
    IN OUT XKERB_TGT_CONTEXT* pTGTContext
)
{
    KERB_ENCRYPTED_DATA* pEncData = NULL;
    KERBERR kerberr = KRB_ERR_GENERIC;
    
    CReleaseAllScratchMemoryUponDestruction onlyPreserveThisMemory(pScratchAlloc);

    // Unpack
    
    kerberr = KerbUnpackEncryptedData(
        pScratchAlloc,
        pPreAuthData->preauth_data.value,
        pPreAuthData->preauth_data.length,
        &pEncData
        );
    if(!KERB_SUCCESS(kerberr))
    {
        goto Cleanup;
    }

    // Decrypt in place

    BYTE scratch[4096];
    UINT32 cbScratch = sizeof(scratch);

    if(pEncData->cipher_text.length > sizeof(scratch))
    {
        TraceSz(AuthWarn, "VerifyPassportAuthorizationPreAuthReply: unpacked pre-auth is too large");
        kerberr = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    C_ASSERT(sizeof(cbScratch) == sizeof(ULONG));

    kerberr = KerbDecryptDataEx(
        pScratchAlloc,
        pEncData,
        pKey,
        KERB_PA_PASSPORT_AUTHENTICATION_SALT,
        (ULONG*)&cbScratch,
        scratch);

    if(!KERB_SUCCESS(kerberr))
    {
        goto Cleanup;
    }

    // Parse

    if(cbScratch != sizeof(PA_PASSPORT_AUTHENTICATION_REP))
    {
        TraceSz(AuthWarn, "VerifyPassportAuthorizationPreAuthReply: pre-auth has the wrong size");
        kerberr = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    PA_PASSPORT_AUTHENTICATION_REP* pReply = (PA_PASSPORT_AUTHENTICATION_REP*) scratch;

    pTGTContext->isPassportAuthInfoAvailable = TRUE;
    pTGTContext->passportAuthInfo.userId = pReply->userId;
    lstrcpynA(pTGTContext->passportAuthInfo.gamertag, pReply->szGamertag, 
              ARRAY_SIZE(pTGTContext->passportAuthInfo.gamertag));

    kerberr = KDC_ERR_NONE;

Cleanup:

    return kerberr;
}

// --------------------------------------------------------------------------------------
// AddEncryptedPassportAuthenticationPreAuth
// --------------------------------------------------------------------------------------
NTSTATUS AddEncryptedPassportAuthenticationPreAuth(
    CScratchMemoryAllocator*    pScratchAlloc,
    KERB_ENCRYPTION_KEY*        pKey,
    const AsRequestInfo*        pAsRequestInfo,
    IN OUT KERB_PA_DATA_LIST**  ppPreAuthData
)
{
    KERBERR KerbErr = KDC_ERR_NONE;
    KERB_ENCRYPTED_DATA EncryptedData;
    ZeroMemory( &EncryptedData, sizeof(KERB_ENCRYPTED_DATA) );

    //Check parameters
    if (pAsRequestInfo->PassportTicketLength > PA_PASSPORT_AUTHENTICATION::TICKET_MAX_LENGTH)
    {
        return STATUS_INVALID_PARAMETER_5;
    }

    KERB_PA_DATA_LIST* pListElement;
    pListElement = (KERB_PA_DATA_LIST*) pScratchAlloc->Alloc(sizeof(KERB_PA_DATA_LIST));
    if(!pListElement)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    {
        CReleaseAllScratchMemoryUponDestruction onlyPreserveThisMemory(pScratchAlloc);

        //Serialize request
        UINT32 cbRequestBuffer = sizeof(UINT16) + pAsRequestInfo->PassportTicketLength;
        BYTE* pRequestBuffer = (BYTE*) pScratchAlloc->Alloc(cbRequestBuffer);

        if (!pRequestBuffer)
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        BYTE* pb = pRequestBuffer;
        *((UNALIGNED UINT16*)pb) = (UINT16) pAsRequestInfo->PassportTicketLength;
        pb += sizeof(UINT16);
        memcpy(pb, pAsRequestInfo->PassportTicket, pAsRequestInfo->PassportTicketLength);

        //Encrypt
        KerbErr = KerbAllocateEncryptionBuffer(
            pScratchAlloc,
            pKey->keytype,
            cbRequestBuffer,
            &EncryptedData.cipher_text.length,
            &EncryptedData.cipher_text.value
            );
        if (!KERB_SUCCESS(KerbErr))
        {
            return KerbMapKerbError(KerbErr);
        }

        KerbErr = KerbEncryptDataEx(
            pScratchAlloc,
            &EncryptedData,
            cbRequestBuffer,
            pRequestBuffer,
            pKey->keytype,
            KERB_PA_PASSPORT_AUTHENTICATION_SALT,
            pKey
            );
        if (!KERB_SUCCESS(KerbErr))
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //Pack it into a preauth
        KerbErr = KerbPackEncryptedData(
            pScratchAlloc,
            &EncryptedData,
            (PULONG) &pListElement->value.preauth_data.length,
            (PUCHAR *) &pListElement->value.preauth_data.value
            );
        if (!KERB_SUCCESS(KerbErr))
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //Preserve the only piece of memory we care about
        PreserveThisMemory(&onlyPreserveThisMemory, &pListElement->value.preauth_data.value, pListElement->value.preauth_data.length);
    }

    //Add it to the pre-auth list
    pListElement->value.preauth_data_type = KRB5_PADATA_ENCRYPTED_PASSPORT_AUTHENTICATION;
    pListElement->next = *ppPreAuthData;
    *ppPreAuthData = pListElement;

    return STATUS_SUCCESS;
}

NTSTATUS WINAPI
kcl_HrToString(
    HRESULT       hr,
    IN OUT char  *pszError,       //string will be copied to here
    IN OUT DWORD *pszErrorLength  //in: size of buffer.  out: size used
    )
{
    const char *message=CPassportIdcrl::HrToString(hr);
    if (!message)
        return !STATUS_SUCCESS;

    DWORD messageLength=strlen(message);
    if (messageLength>=*pszErrorLength-1)
        return !STATUS_SUCCESS;

    strcpy(pszError, message);
    *pszErrorLength=messageLength+1;
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\kerbclient\msasn1.cpp ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "xonp.h"
//#include "xonver.h"

#include <stdlib.h>
#include <stdio.h>

#ifdef ENABLE_DOUBLE
#include <float.h>
#include <math.h>

#if HAS_IEEEFP_H
#include <ieeefp.h>
#elif HAS_FLOAT_H
#include <float.h>
#endif
#endif

#define ASN1LIB
#define MULTI_LEVEL_ZONES

#define ENABLE_BER
#define ENABLE_COMPARE
#define XBOX_SPECIFIC_OPTIMIZATIONS

#include "msasn1.h"
#include "kerbfuzz.h"

//#include <msper.h>
extern ASN1_PUBLIC void ASN1API ASN1PEREncAlignment(ASN1encoding_t enc);

/* MS-Windows 95/MS-Windows NT */
#define THIRTYTWO_BITS  1
// #define HAS_SIXTYFOUR_BITS 1
#define HAS_FLOAT_H     1
#define HAS_FPCLASS     1
#define fpclass(_d)     _fpclass(_d)
#define finite(_d)      _finite(_d)
#define isnan(_d)       _isnan(_d)
#define FP_PINF         _FPCLASS_PINF
#define FP_NINF         _FPCLASS_NINF
// #define HAS_STRICMP     1
#define DBL_PINF        {0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x7f}
#define DBL_MINF        {0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0xff}

extern ASN1intx_t ASN1intx_0, ASN1intx_1, ASN1intx_2, ASN1intx_16, ASN1intx_256, ASN1intx_64K, ASN1intx_1G;
extern void ASN1API ASN1intx_addoctet(ASN1intx_t *, ASN1intx_t *, ASN1octet_t);
extern void ASN1API ASN1intx_suboctet(ASN1intx_t *, ASN1intx_t *, ASN1octet_t);
extern void ASN1API ASN1intx_muloctet(ASN1intx_t *, ASN1intx_t *, ASN1octet_t);
extern void ASN1API ASN1intx_inc(ASN1intx_t *);
extern void ASN1API ASN1intx_dec(ASN1intx_t *);
extern void ASN1API ASN1intx_neg(ASN1intx_t *, ASN1intx_t *);
extern ASN1uint32_t ASN1API ASN1intx_log2(ASN1intx_t *);
extern ASN1uint32_t ASN1API ASN1intx_log256(ASN1intx_t *);
extern ASN1int32_t ASN1API ASN1intx_cmp(ASN1intx_t *, ASN1intx_t *);
extern ASN1int32_t ASN1API ASN1intx_dup(ASN1intx_t *, ASN1intx_t *);
// extern void ASN1API ASN1intx_free(ASN1intx_t *);
extern void ASN1API ASN1intx_setuint32(ASN1intx_t *, ASN1uint32_t);
extern void ASN1API ASN1intx_setint32(ASN1intx_t *, ASN1int32_t);
extern int  ASN1API ASN1intxisuint64(ASN1intx_t *);
extern int  ASN1API ASN1intxisint64(ASN1intx_t *);
extern int  ASN1API ASN1intxisuint32(ASN1intx_t *);
extern int  ASN1API ASN1intxisint32(ASN1intx_t *);
extern int  ASN1API ASN1intxisuint16(ASN1intx_t *);
extern int  ASN1API ASN1intxisint16(ASN1intx_t *);
extern int  ASN1API ASN1intxisuint8(ASN1intx_t *);
extern int  ASN1API ASN1intxisint8(ASN1intx_t *);
#ifdef HAS_SIXTYFOUR_BITS
extern ASN1uint64_t ASN1API ASN1intx2uint64(ASN1intx_t *);
extern ASN1int64_t ASN1API ASN1intx2int64(ASN1intx_t *);
#endif
extern ASN1uint32_t ASN1API ASN1intx2uint32(ASN1intx_t *);
extern ASN1int32_t ASN1API ASN1intx2int32(ASN1intx_t *);
extern ASN1uint16_t ASN1API ASN1intx2uint16(ASN1intx_t *);
extern ASN1int16_t ASN1API ASN1intx2int16(ASN1intx_t *);
extern ASN1uint8_t ASN1API ASN1intx2uint8(ASN1intx_t *);
extern ASN1int8_t ASN1API ASN1intx2int8(ASN1intx_t *);
extern ASN1uint32_t ASN1API ASN1intx_octets(ASN1intx_t *);
extern ASN1uint32_t ASN1API ASN1uint32_log2(ASN1uint32_t);
extern ASN1uint32_t ASN1API ASN1uint32_log256(ASN1uint32_t);
extern ASN1uint32_t ASN1API ASN1uint32_octets(ASN1uint32_t);
extern ASN1uint32_t ASN1API ASN1uint32_uoctets(ASN1uint32_t);
extern ASN1uint32_t ASN1API ASN1int32_octets(ASN1int32_t);
extern double ASN1API ASN1intx2double(ASN1intx_t *);
extern double ASN1API ASN1real2double(ASN1real_t *);
extern double ASN1API ASN1double_minf();
extern double ASN1API ASN1double_pinf();
extern int ASN1API ASN1double_isminf(double);
extern int ASN1API ASN1double_ispinf(double);
extern int ASN1API ASN1generalizedtime2string(char *, ASN1generalizedtime_t *);
extern int ASN1API ASN1utctime2string(char *, ASN1utctime_t *);
extern int ASN1API ASN1string2generalizedtime(ASN1generalizedtime_t *, char *);
extern int ASN1API ASN1string2utctime(ASN1utctime_t *, char *);

/* ------ Comparison APIs ------ */

extern int ASN1API ASN1ztchar32string_cmp(ASN1ztchar32string_t, ASN1ztchar32string_t);
extern int ASN1API ASN1double_cmp(double, double);
extern int ASN1API ASN1real_cmp(ASN1real_t *, ASN1real_t *);
extern int ASN1API ASN1external_cmp(ASN1external_t *, ASN1external_t *);
extern int ASN1API ASN1embeddedpdv_cmp(ASN1embeddedpdv_t *, ASN1embeddedpdv_t *);
extern int ASN1API ASN1characterstring_cmp(ASN1characterstring_t *, ASN1characterstring_t *);
extern int ASN1API ASN1sequenceoflengthpointer_cmp(ASN1uint32_t, void *, ASN1uint32_t, void *, ASN1uint32_t, int (*)(void *, void *));
extern int ASN1API ASN1sequenceofsinglylinkedlist_cmp(void *, void *, ASN1uint32_t, int (*)(void *, void *));
extern int ASN1API ASN1sequenceofdoublylinkedlist_cmp(void *, void *, ASN1uint32_t, int (*)(void *, void *));
extern int ASN1API ASN1setoflengthpointer_cmp(ASN1uint32_t, void *, ASN1uint32_t, void *, ASN1uint32_t, int (*)(void *, void *));
extern int ASN1API ASN1setofsinglylinkedlist_cmp(void *, void *, ASN1uint32_t, int (*)(void *, void *));
extern int ASN1API ASN1setofdoublylinkedlist_cmp(void *, void *, ASN1uint32_t, int (*)(void *, void *));


#define ASN1BITSET(_val, _bitnr) \
    ((_val)[(_bitnr) >> 3] |= 0x80 >> ((_bitnr) & 7))
#define ASN1BITCLR(_val, _bitnr) \
    ((_val)[(_bitnr) >> 3] &= ~(0x80 >> ((_bitnr) & 7)))
#define ASN1BITTEST(_val, _bitnr) \
    ((_val)[(_bitnr) >> 3] & (0x80 >> ((_bitnr) & 7)))
    
// internal functions
int _BERDecConstructed(ASN1decoding_t dec, ASN1uint32_t len, ASN1uint32_t infinite, ASN1decoding_t *dd, ASN1octet_t **di);


#if ! defined(_DEBUG) && defined(TEST_CODER)
#undef TEST_CODER
#endif

typedef struct ASN1INTERNencoding_s *ASN1INTERNencoding_t;
typedef struct ASN1INTERNdecoding_s *ASN1INTERNdecoding_t;

// lonchanc: this is really bad to duplicate the definitions of ASN1encoding_s
// and ASN1decoding_s here. We sould simply use them as components in
// the following ASN1INTERNencoding_s and ASN1INTERNdecoding_s.

struct ASN1INTERNencoding_s {

    // public view of encoding structure
    struct ASN1encoding_s       info;

    // private portion of encoding structure
    ASN1INTERNencoding_t        parent;
    ASN1INTERNencoding_t        child;

#ifdef ENABLE_EXTRA_INFO
    ASN1uint32_t				memlength;
    ASN1uint32_t				memsize;
    void**					    mem;
    ASN1uint32_t				epilength;
    ASN1uint32_t				episize;
    ASN1embeddedpdv_identification_t**		epi;
    ASN1uint32_t				csilength;
    ASN1uint32_t				csisize;
    ASN1characterstring_identification_t**	csi;
#endif // ENABLE_EXTRA_INFO
};

struct ASN1INTERNdecoding_s {

    // public view of decoding structure
    struct ASN1decoding_s       info;

    // private portion of decoding structure
    ASN1INTERNdecoding_t        parent;
    ASN1INTERNdecoding_t        child;

    // how deeply this decoding is nested
    ASN1uint32_t                recursionLevel; 

#ifdef ENABLE_EXTRA_INFO
    ASN1uint32_t				memlength;
    ASN1uint32_t				memsize;
    void**					    mem;
    ASN1uint32_t				epilength;
    ASN1uint32_t				episize;
    ASN1embeddedpdv_identification_t**		epi;
    ASN1uint32_t				csilength;
    ASN1uint32_t				csisize;
    ASN1characterstring_identification_t**	csi;
#endif // ENABLE_EXTRA_INFO

    // decoded into an external buffer
    ASN1uint32_t                fExtBuf;
    void*                       lpOrigExtBuf;    // original buffer pointer
    ASN1uint32_t                cbOrigExtBufSize;// original buffer size
    ASN1uint8_t*                lpRemExtBuf;     // remaining buffer pointer
    ASN1uint32_t                cbRemExtBufSize; // remaining buffer size
    ASN1uint32_t                cbLinearBufSize; // linear buffer size to hold the data
};

extern ASN1_PUBLIC void ASN1API ASN1DecAbort(ASN1decoding_t dec);
extern ASN1_PUBLIC void ASN1API ASN1DecDone(ASN1decoding_t dec);
extern ASN1_PUBLIC void ASN1API ASN1EncAbort(ASN1encoding_t enc);
extern ASN1_PUBLIC void ASN1API ASN1EncDone(ASN1encoding_t enc);

#ifdef ENABLE_GENERALIZED_CHAR_STR
int ASN1EncSearchCharacterStringIdentification(ASN1INTERNencoding_t e, ASN1characterstring_identification_t *identification, ASN1uint32_t *index, ASN1uint32_t *flag);
int ASN1DecAddCharacterStringIdentification(ASN1INTERNdecoding_t d, ASN1characterstring_identification_t *identification);
ASN1characterstring_identification_t *ASN1DecGetCharacterStringIdentification(ASN1INTERNdecoding_t d, ASN1uint32_t index);
#endif // ENABLE_GENERALIZED_CHAR_STR

#ifdef ENABLE_EMBEDDED_PDV
int ASN1EncSearchEmbeddedPdvIdentification(ASN1INTERNencoding_t e, ASN1embeddedpdv_identification_t *identification, ASN1uint32_t *index, ASN1uint32_t *flag);
int ASN1DecAddEmbeddedPdvIdentification(ASN1INTERNdecoding_t d, ASN1embeddedpdv_identification_t *identification);
ASN1embeddedpdv_identification_t *ASN1DecGetEmbeddedPdvIdentification(ASN1INTERNdecoding_t d, ASN1uint32_t index);
#endif // ENABLE_EMBEDDED_PDV

int ASN1DecDupObjectIdentifier(ASN1decoding_t dec, ASN1objectidentifier_t *dst, ASN1objectidentifier_t *src);

ASN1uint32_t GetObjectIdentifierCount(ASN1objectidentifier_t val);
ASN1uint32_t CopyObjectIdentifier(ASN1objectidentifier_t dst, ASN1objectidentifier_t src);
ASN1objectidentifier_t DecAllocObjectIdentifier(ASN1decoding_t dec, ASN1uint32_t cObjIds);
void DecFreeObjectIdentifier(ASN1decoding_t dec, ASN1objectidentifier_t p);


/* ------ perencod.c ------ */

int ASN1EncCheck(ASN1encoding_t enc, ASN1uint32_t noctets);
__inline int ASN1PEREncCheck(ASN1encoding_t enc, ASN1uint32_t noctets)
{
    return ASN1EncCheck(enc, noctets);
}
__inline int ASN1BEREncCheck(ASN1encoding_t enc, ASN1uint32_t noctets)
{
    return ASN1EncCheck(enc, noctets);
}

// ----- fuzz funcs -------

SAsnFuzzParams fuzz={0};

//updates the asn fuzz parameters (or null to disable)
HRESULT WINAPI 
kcl_SetAsnFuzzParams(IN SAsnFuzzParams *params)
{
    if (params)
        fuzz=*params;
    else
        memset(&fuzz, 0, sizeof(fuzz));

    return 0;
}

/* ------ bit.c ------ */

int ASN1is32space(ASN1char32_t);
int ASN1str32len(const ASN1char32_t *);
int ASN1is16space(ASN1char16_t);
int ASN1str16len(const ASN1char16_t *);
int My_lstrlenA(const char *p);
int My_lstrlenW(const WCHAR *p);
void ASN1bitcpy(ASN1octet_t *dst, ASN1uint32_t dstbit, ASN1octet_t *src, ASN1uint32_t srcbit, ASN1uint32_t nbits);
void ASN1bitclr(ASN1octet_t *dst, ASN1uint32_t dstbit, ASN1uint32_t nbits);
void ASN1bitset(ASN1octet_t *dst, ASN1uint32_t dstbit, ASN1uint32_t nbits);
void ASN1bitput(ASN1octet_t *dst, ASN1uint32_t dstbit, ASN1uint32_t val, ASN1uint32_t nbits);
ASN1uint32_t ASN1bitgetu(ASN1octet_t *src, ASN1uint32_t srcbit, ASN1uint32_t nbits);
ASN1int32_t ASN1bitget(ASN1octet_t *src, ASN1uint32_t srcbit, ASN1uint32_t nbits);
ASN1uint32_t ASN1bitcount(ASN1octet_t *src, ASN1uint32_t srcbit, ASN1uint32_t nbits);
void ASN1octetput(ASN1octet_t *dst, ASN1uint32_t val, ASN1uint32_t noctets);
ASN1uint32_t ASN1octetget(const ASN1octet_t *src, ASN1uint32_t noctets);

#define ARRAY_SIZE(arr)             (sizeof(arr) / sizeof(arr[0]))
// #define FIELD_OFFSET(type, field)   ((long)&(((type *)0)->field))   // from winnt.h
#define PARAMS_SIZE_N_ARRARY(arr)   ARRAY_SIZE(arr), arr

#define LPVOID_ADD(ptr,inc)  (LPVOID) ((ASN1octet_t *) (ptr) + (ASN1uint32_t) (inc))
#define LPVOID_SUB(ptr,dec)  (LPVOID) ((ASN1octet_t *) (ptr) - (ASN1uint32_t) (inc))

#define LPVOID_NEXT(ptr)     *(LPVOID FAR *) (ptr)

// the following constants is for calculating decoded data structure size
// we are conservative here and try to be 4-byte aligned due to Alpha platform.

#define ASN1_SIZE_ALIGNED(n)    (n) = ((((n) + 3) >> 2) << 2)

#ifdef ENABLE_BER
int My_memcmp(ASN1octet_t *pBuf1, ASN1uint32_t cbBuf1Size, ASN1octet_t *pBuf2, ASN1uint32_t cbBuf2Size);
#endif // ENABLE_BER

#define UNKNOWN_MODULE                  0

#define MemAllocEx(dec,cb,fZero)        (dec)->pScratchMemoryAllocator->Alloc((cb))
#define MemFree(lp)
#define MemReAllocEx(dec,lp,cb,fZero)   ((lp) ? \
            (dec)->pScratchMemoryAllocator->ReAlloc((lp),(cb)) : \
            (dec)->pScratchMemoryAllocator->Alloc((cb)))

#define _ModName(enc_dec)                   

LPVOID DecMemAlloc   ( ASN1decoding_t dec, ASN1uint32_t cbSize );
LPVOID DecMemReAlloc ( ASN1decoding_t dec, LPVOID lpData, ASN1uint32_t cbSize );

#define EncMemAlloc(enc,cb)             (enc)->pScratchMemoryAllocator->Alloc((cb))
#define EncMemReAlloc(enc,lp,cb)        (enc)->pScratchMemoryAllocator->ReAlloc((lp),(cb))
#define EncMemImmediateReAlloc(dec,lp,ocb,cb)   (dec)->pScratchMemoryAllocator->ImmediateReAlloc((lp),(ocb),(cb))

void   DecMemFree    ( ASN1decoding_t dec, LPVOID lpData );

#define EncMemFree(enc,lpData)              MemFree(lpData)

int IsDigit(char p);
unsigned int  DecimalStringToUINT(const char * pcszString, ASN1uint32_t cch);
void * ms_bSearch (
        const void *key,
        const void *base,
        size_t num,
        size_t width,
        int (__cdecl *compare)(const void *, const void *)
        );

#define MyAssert(f) Assert(f)

/*#ifdef _DEBUG
    void MyDebugBreak(void);
    __inline void EncAssert(const ASN1encoding_s* enc, int val)
    {
        if ((! (enc->dwFlags & ASN1FLAGS_NOASSERT)) && (! (val)))
        {
            MyDebugBreak();
        }
    }
    __inline void DecAssert(const ASN1decoding_s* dec, int val)
    {
        if ((! (dec->dwFlags & ASN1FLAGS_NOASSERT)) && (! (val)))
        {
            MyDebugBreak();
        }
    }
#else
    #define EncAssert(enc,f)   
    #define DecAssert(dec,f)   
#endif // _DEBUG*/
    #define EncAssert(enc,f) do { if (f) TraceSz(AuthVerbose, "Assert: Asn Encode"); } while (false)
    #define DecAssert(enc,f) do { if (f) TraceSz(AuthVerbose, "Assert: Asn Decode"); } while (false)

// making a magic number
#define MAKE_STAMP_ID(a,b,c,d)     MAKELONG(MAKEWORD(a,b),MAKEWORD(c,d))

/* magic number for ASN1encoding_t */
#define MAGIC_ENCODER       MAKE_STAMP_ID('E','N','C','D')

/* magic number for ASN1decoding_t */
#define MAGIC_DECODER       MAKE_STAMP_ID('D','E','C','D')


#ifdef TEST_CODER
typedef struct ASN1testcoder_s
{
    struct ASN1INTERNencoding_s     e;
    struct ASN1INTERNdecoding_s     d;
}   *ASN1testcoder_t;
#define ASN1_TEST_CODER_SIZE    (sizeof(struct ASN1testcoder_s))
int TestEnc_InitCoder(ASN1INTERNencoding_t e, ASN1module_t mod);
int TestDec_InitCoder(ASN1INTERNdecoding_t d, ASN1module_t mod);
int TestEnc_Compare(ASN1INTERNencoding_t e, ASN1uint32_t id, ASN1octet_t *pbBuf, ASN1uint32_t cbBufSize);
int TestDec_Compare(ASN1INTERNdecoding_t d, ASN1uint32_t id, void *valref, ASN1octet_t *pbBuf, ASN1uint32_t cbBufSize);
#else
#define ASN1_TEST_CODER_SIZE    0
#endif

#define ENCODE_BUFFER_INCREMENT         128
#define ENCODE_BUFFER_MAX_INCREMENT     256

static const ASN1uint8_t c_aBitMask2[] =
{
    0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff
};

#define TO64(x) ((unsigned __int64)(x))

/* check if sufficient data is in decoding buffer */
int ASN1PERDecCheck(ASN1decoding_t dec, ASN1uint32_t nbits)
{
    unsigned __int64 overflowCheck; 

    // Ensure that our computation doesn't overflow:
    overflowCheck = (TO64(dec->pos) - TO64(dec->buf)) * 8 + TO64(dec->bit) + TO64(nbits); 
    if (overflowCheck & (0xFFFFFFFFi64 << 32))
    {
        ASN1DecSetError(dec, ASN1_ERR_LARGE);
        return 0;
    }

    // we're confident that no arithmetic overflow will occur.  Perform the check.
    if ((dec->pos - dec->buf) * 8 + dec->bit + nbits <= dec->size * 8)
    {
        return 1;
    }
    ASN1DecSetError(dec, ASN1_ERR_EOD);
    return 0;
}

/* skip up to octet boundary */
void ASN1PERDecAlignment(ASN1decoding_t dec)
{
    if (dec->bit)
    {
        dec->bit = 0;
        dec->pos++;
    }
}

// moved from perdecod.c
/* end of decoding */
int ASN1PERDecFlush(ASN1decoding_t dec)
{
    /* complete broken byte */
    ASN1PERDecAlignment(dec);

    /* get zero-octet if encoding is empty bitstring */
    if (dec->buf == dec->pos)
    {
        if (ASN1PERDecCheck(dec, 8))
        {
            if (*dec->pos == 0)
            {
                dec->pos++;
            }
            else
            {
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }

    /* calculate length */
    dec->len = (ASN1uint32_t) (dec->pos - dec->buf);

    /* set WRN_NOEOD if data left */
    if (dec->len >= dec->size)
    {
        return 1;
    }
    ASN1DecSetError(dec, ASN1_WRN_NOEOD);
    return 1;
}
// moved from perencod.c
/* end of encoding */
int ASN1PEREncFlush(ASN1encoding_t enc)
{
    /* complete broken octet */
    ASN1PEREncAlignment(enc);

    /* allocate at least one octet */
    if (enc->buf)
    {
        /* fill in zero-octet if encoding is empty bitstring */
        if (enc->buf == enc->pos)
            *enc->pos++ = 0;

        /* calculate length */
        enc->len = (ASN1uint32_t) (enc->pos - enc->buf);

        return 1;
    }

    return ASN1PEREncCheck(enc, 1);
}

// moved from perencod.c
/* encode an octet alignment */
void ASN1PEREncAlignment(ASN1encoding_t enc)
{
    /* complete broken octet */
    if (enc->bit)
    {
        enc->pos++;
        enc->bit = 0;
    }
}

// moved from perencod.c
/* check for space in buffer for PER and BER. */
int ASN1EncCheck(ASN1encoding_t enc, ASN1uint32_t noctets)
{
    // any additional space required?
    if (noctets)
    {
        // buffer exists?
        if (NULL != enc->buf)
        {
            // buffer large enough?
            if (enc->size - (enc->pos - enc->buf) - ((enc->bit != 0) ? 1 : 0) >= noctets)
            {
                return 1;
            }

            // static buffer overflow?
            if (enc->dwFlags & ASN1ENCODE_SETBUFFER)
            {
                ASN1EncSetError(enc, ASN1_ERR_OVERFLOW);
                return 0;
            }
            else
            {
                // round up to next 256 byte boundary and resize buffer
                const ASN1octet_t *oldbuf = enc->buf;
                ASN1uint32_t oldsize = enc->size;
                // enc->size = ((noctets + (enc->pos - oldbuf) + (enc->bit != 0) - 1) | 255) + 1;
                if (ASN1_PER_RULE & enc->eRule)
                {
                    enc->size += max(noctets, ENCODE_BUFFER_INCREMENT);
                }
                else
                {
                    //enc->size += max(noctets, enc->size);
                    enc->size += min(max(noctets, enc->size), ENCODE_BUFFER_MAX_INCREMENT);
                }
                enc->buf = (ASN1octet_t *)EncMemImmediateReAlloc(enc, enc->buf, oldsize, enc->size);
                if (NULL != enc->buf)
                {
                    enc->pos = enc->buf + (enc->pos - oldbuf);
                }
                else
                {
                    ASN1EncSetError(enc, ASN1_ERR_MEMORY);
                    return 0;
                }
            }
        }
        else
        {
            // no buffer exists, allocate new one.
            // round up to next 256 byte boundary and allocate buffer
            // enc->size = ((noctets - 1) | 255) + 1;
            enc->size = max(noctets + enc->cbExtraHeader, ENCODE_BUFFER_INCREMENT);
            enc->buf = (ASN1octet_t*) EncMemAlloc(enc, enc->size);
            if (NULL != enc->buf)
            {
                enc->pos = (ASN1octet_t *) (enc->buf + enc->cbExtraHeader);
            }
            else
            {
                enc->pos = NULL;
                ASN1EncSetError(enc, ASN1_ERR_MEMORY);
                return 0;
            }
        }
    }

    return 1;
}

// moved from perfn.c
int ASN1PEREncRemoveZeroBits(ASN1uint32_t *nbits, const ASN1octet_t *val, ASN1uint32_t minlen)
{
    ASN1uint32_t n;
    int i;

    /* get value */
    n = *nbits;

    /* nothing to scan? */
    if (n > minlen)
    {
        /* let val point to last ASN1octet used */
        val += (n - 1) / 8;

        /* check if broken ASN1octet consist out of zero bits */
        if ((n & 7) && !(*val & c_aBitMask2[n & 7])) {
            n &= ~7;
            val--;
        }

        /* scan complete ASN1octets (memrchr missing ...) */
        if (!(n & 7)) {
            while (n > minlen && !*val) {
                n -= 8;
                val--;
            }
        }

        /* scan current octet bit after bit */
        if (n > minlen) {
            for (i = (n - 1) & 7; i >= 0; i--) {
                if (*val & (0x80 >> i))
                    break;
                n--;
            }
        }

        /* return real bitstring len */
        *nbits = n < minlen ? minlen : n;
    }
    return 1;
}

/* init an ASN1encoding_t */
ASN1error_e ASN1_CreateEncoder
(
    CScratchMemoryAllocator* pScratchMemoryAllocator,
    ASN1module_t        mod,
    ASN1encoding_t     *enc,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize,
    ASN1encoding_t      pParent
)
{
    if (NULL != mod && NULL != enc)
    {
        ASN1INTERNencoding_t    e;

        *enc = NULL;

        /* construct ASN1encoding_t */
        e = (ASN1INTERNencoding_t)pScratchMemoryAllocator->Alloc(sizeof(*e) + ASN1_TEST_CODER_SIZE);
        if (NULL != e)
        {
            ZeroMemory(e, sizeof(*e) + ASN1_TEST_CODER_SIZE);
            e->info.pScratchMemoryAllocator = pScratchMemoryAllocator;
            e->info.magic = MAGIC_ENCODER;
            e->info.err = ASN1_SUCCESS;
            // e->info.pos = e->info.buf = NULL;
            // e->info.size = e->info.len = e->info.bit = 0;
            e->info.dwFlags = mod->dwFlags;
            e->info.module = mod;
            // e->child = NULL;

            /* set buffer if given */
            if (NULL != pbBuf && cbBufSize)
            {
                e->info.dwFlags |= ASN1ENCODE_SETBUFFER;
                e->info.pos = e->info.buf = pbBuf;
                e->info.size = cbBufSize;
            }

            /* set parent if parented, otherwise, initialized to itself */
            if (NULL != pParent)
            {
                e->parent = (ASN1INTERNencoding_t) pParent;
                e->info.eRule = pParent->eRule;
            }
            else
            {
                e->parent = e;
                e->info.eRule = mod->eRule;
            }

            // e->mem = NULL;
            // e->memlength = 0;
            // e->memsize = 0;
            // e->epi = NULL;
            // e->epilength = 0;
            // e->episize = 0;
            // e->csi = NULL;
            // e->csilength = 0;
            // e->csisize = 0;

            if (! (e->info.dwFlags & ASN1ENCODE_SETBUFFER) && (NULL != pParent))
            {
                // lonchanc: make sure we have a minimum 256 bytes available.
                BOOL fRet = FALSE;
                if (ASN1_PER_RULE & e->info.eRule)
                {
                    // this is required for h245.
                    fRet = ASN1PEREncCheck((ASN1encoding_t) e, 1);
                }
#ifdef ENABLE_BER
                else
                if (ASN1_BER_RULE & e->info.eRule)
                {
                    // this is required for h245.
                    fRet = ASN1BEREncCheck((ASN1encoding_t) e, 1);
                }
#endif // ENABLE_BER
                else
                {
                    EncAssert((ASN1encoding_t) e, 0);
                    MemFree(e);
                    return ASN1_ERR_RULE;
                }
                if (fRet)
                {
                    // lonchanc: make sure the first byte is zeroed out, which
                    // is required for h245.
                    e->info.buf[0] = '\0';
                }
                else
                {
                    MemFree(e);
                    return ASN1_ERR_MEMORY;
                }
            }

#if defined(TEST_CODER) && defined(_DEBUG)
            TestEnc_InitCoder(e, mod);
#endif // defined(TEST_CODER) && defined(_DEBUG)

            if (NULL != pParent)
            {
                EncAssert((ASN1encoding_t) e, NULL == ((ASN1INTERNencoding_t) pParent)->child);
                ((ASN1INTERNencoding_t) pParent)->child = e;
            }

            *enc = (ASN1encoding_t) e;
            return ASN1_SUCCESS;
        }
        else
        {
            return ASN1_ERR_MEMORY;
        }
    }

    return ASN1_ERR_BADARGS;
}

/* encode a value */
ASN1error_e ASN1_Encode
(
    ASN1encoding_t      enc,
    void               *value,
    ASN1uint32_t        id,
    ASN1uint32_t        flags,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize
)
{
    if (NULL != enc)
    {
        ASN1INTERNencoding_t    e = (ASN1INTERNencoding_t)enc;

        /* check magic numbers */
        EncAssert(enc, MAGIC_ENCODER == enc->magic);

        /* clear error */
        ASN1EncSetError(enc, ASN1_SUCCESS);

        /* new buffer given? */
        if (flags & ASN1ENCODE_SETBUFFER)
        {
            e->info.dwFlags |= ASN1ENCODE_SETBUFFER;
            enc->pos = enc->buf = pbBuf;
            enc->size = cbBufSize;
            enc->len = enc->bit = 0;
        }
        /* use a new buffer? */
        else if ((e->info.dwFlags | flags) & ASN1ENCODE_ALLOCATEBUFFER)
        {
            e->info.dwFlags &= ~ASN1ENCODE_SETBUFFER;
            enc->pos = enc->buf = NULL;
            enc->size = enc->len = enc->bit = 0;
        }
        /* reuse buffer? */
        else if ((flags & ASN1ENCODE_REUSEBUFFER) || !((e->info.dwFlags | flags) & ASN1ENCODE_APPEND))
        {
            EncAssert(enc, NULL != enc->buf);
            enc->pos = enc->buf;
            enc->bit = enc->len = 0;
        }
        /* otherwise append to buffer */

        /* check id number */
        if (id < enc->module->cPDUs)
        {
            if (ASN1_PER_RULE & enc->eRule)
            {
                /* encode value */
                ASN1PerEncFun_t pfnPER;
                if (NULL != (pfnPER = enc->module->PER.apfnEncoder[id]))
                {
                    if ((*pfnPER)(enc, value))
                    {
                        ASN1PEREncFlush(enc);
                    }
                    else
                    {
                        // the error code must be an error
                        if (ASN1_SUCCEEDED(e->parent->info.err))
                        {
                            // cannot return here immediately because we need to do cleanup
                            ASN1EncSetError(enc, ASN1_ERR_CORRUPT);
                        }
                    }
                }
                else
                {
                    return ASN1EncSetError(enc, ASN1_ERR_BADPDU);
                }
            }
#ifdef ENABLE_BER
            else
            if (ASN1_BER_RULE & enc->eRule)
            {
                /* encode value */
                ASN1BerEncFun_t pfnBER;
                if (NULL != (pfnBER = enc->module->BER.apfnEncoder[id]))
                {
                    if ((*pfnBER)(enc, 0, value)) // lonchanc: tag is 0 to make it compiled
                    {
                        ASN1BEREncFlush(enc);
                    }
                    else
                    {
                        // the error code must be an error
                        if (ASN1_SUCCEEDED(e->parent->info.err))
                        {
                            // cannot return here immediately because we need to do cleanup
                            ASN1EncSetError(enc, ASN1_ERR_CORRUPT);
                        }
                    }
                }
                else
                {
                    return ASN1EncSetError(enc, ASN1_ERR_BADPDU);
                }
            }
#endif // ENABLE_BER
            else
            {
                return ASN1EncSetError(enc, ASN1_ERR_RULE);
            }

            /* call abort/done function for non-parented encoding stream */
            if (ASN1_SUCCEEDED(e->parent->info.err))
            {
                // not parented
                if (e == e->parent)
                {
#if defined(TEST_CODER) && defined(_DEBUG)
                    if (ASN1_PER_RULE & enc->eRule)
                    {
                        if (! TestEnc_Compare(e, id, enc->buf + enc->cbExtraHeader, enc->len - enc->cbExtraHeader))
                        {
                            MyDebugBreak();
                        }
                    }
#ifdef ENABLE_BER
                    else
                    if (ASN1_BER_RULE & enc->eRule)
                    {
                        if (! TestEnc_Compare(e, id, enc->buf + enc->cbExtraHeader, enc->len - enc->cbExtraHeader))
                        {
                            MyDebugBreak();
                        }
                    }
#endif // ENABLE_BER
#endif
                    ASN1EncDone(enc);
                }
            }
            else
            {
                ASN1INTERNencoding_t child, child2;

                // not parented
                if (e == e->parent)
                {
                    ASN1EncAbort(enc);
                }

                // clean up...
                if ((e->info.dwFlags | flags) & ASN1ENCODE_ALLOCATEBUFFER)
                {
                    ASN1_FreeEncoded(enc, enc->buf);
                    enc->pos = enc->buf = NULL;
                    enc->size = enc->len = enc->bit = 0;
                }
                for (child = e->child; child; child = child2)
                {
                    child2 = child->child;
                    // make sure it does not touch its parent which may already be freed
                    child->parent = child;
                    ASN1_CloseEncoder2((ASN1encoding_t) child);
                }
                e->child = NULL;
            }

            /* return error code */
            return e->parent->info.err;
        }
        else
        {
            return ASN1EncSetError(enc, ASN1_ERR_BADPDU);
        }
    }

    return ASN1_ERR_BADARGS;
}

/* control function for encoding */
ASN1error_e ASN1_SetEncoderOption
(
    ASN1encoding_t      enc,
    const ASN1optionparam_t  *pOptParam
)
{
    if (NULL != enc && NULL != pOptParam)
    {
        ASN1INTERNencoding_t e = (ASN1INTERNencoding_t)enc;
        ASN1error_e rc = ASN1_SUCCESS;

        /* check magic number */
        EncAssert(enc, MAGIC_ENCODER == enc->magic);

        switch (pOptParam->eOption)
        {
        case ASN1OPT_CHANGE_RULE:
            enc->eRule = pOptParam->eRule;
            break;

        case ASN1OPT_NOT_REUSE_BUFFER:
            e->info.dwFlags &= ~ASN1ENCODE_SETBUFFER;
            enc->buf = enc->pos = NULL;
            enc->size = enc->bit = enc->len = 0;
            break;

        case ASN1OPT_REWIND_BUFFER:
            enc->pos = enc->buf;
            enc->bit = enc->len = 0;
            break;

        default:
            rc = ASN1_ERR_BADARGS;
            break;
        }

        return ASN1EncSetError(enc, rc);
    }

    return ASN1_ERR_BADARGS;
}

ASN1error_e ASN1_GetEncoderOption
(
    ASN1encoding_t      enc,
    ASN1optionparam_t  *pOptParam
)
{
    if (NULL != enc && NULL != pOptParam)
    {
        const ASN1INTERNencoding_s* e = (ASN1INTERNencoding_t)enc;
        ASN1error_e rc = ASN1_SUCCESS;

        /* check magic number */
        EncAssert(enc, MAGIC_ENCODER == enc->magic);

        switch (pOptParam->eOption)
        {
        case ASN1OPT_GET_RULE:
            pOptParam->eRule = enc->eRule;
            break;

        default:
            rc = ASN1_ERR_BADARGS;
            break;
        }

        return ASN1EncSetError(enc, rc);
    }

    return ASN1_ERR_BADARGS;
}


/* destroy encoding stream */
void ASN1_CloseEncoder
(
    ASN1encoding_t      enc
)
{
    if (NULL != enc)
    {
        ASN1INTERNencoding_t e = (ASN1INTERNencoding_t)enc;

        /* check magic number */
        EncAssert(enc, MAGIC_ENCODER == enc->magic);

        if (e != e->parent)
        {
            EncAssert(enc, e == e->parent->child);
            e->parent->child = NULL;
        }

        /* free encoding stream */
        MemFree(e);
    }
}

/* destroy encoding stream */
void ASN1_CloseEncoder2
(
    ASN1encoding_t      enc
)
{
    if (NULL != enc)
    {
        /* check magic number */
        EncAssert(enc, MAGIC_ENCODER == enc->magic);

        EncMemFree(enc, enc->buf);

        ASN1_CloseEncoder(enc);
    }
}

#define ASN1_DEFAULT_MAX_RECURSION_LEVEL        5
#define ASN1_DEFAULT_MAX_DECODE_BUFFER_SIZE     2000

DWORD   g_dwMaxRecursionLevel       = ASN1_DEFAULT_MAX_RECURSION_LEVEL; 
DWORD   g_dwMaxDecodeBufferSize     = ASN1_DEFAULT_MAX_DECODE_BUFFER_SIZE; 

/* init an ASN1decoding_t */
ASN1error_e ASN1_CreateDecoder
(
    CScratchMemoryAllocator* pScratchMemoryAllocator,
    ASN1module_t        mod,
    ASN1decoding_t     *dec,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize,
    ASN1decoding_t      pParent
)
{
    //
    // BUG 780462: MSASN1: Should limit recursion for constructed type decoding
    // Don't allow arbitrary recursion depth here.  
    //

    if (NULL != pParent && (((ASN1INTERNdecoding_t)pParent)->recursionLevel > g_dwMaxRecursionLevel))
    {
        return ASN1_ERR_LARGE; 
    }

    //
    // BUG 807085: MSASN1.dll: Should limit the size of buffer to decode
    // Check that our buffer isn't too big 
    //
    if (NULL != pbBuf && cbBufSize > g_dwMaxDecodeBufferSize) 
    {
        return ASN1_ERR_LARGE; 
    } 

    if (NULL != mod && NULL != dec)
    {
        ASN1INTERNdecoding_t d;

        *dec = NULL;

        /* construct ASN1decoding_t */
        d = (ASN1INTERNdecoding_t)pScratchMemoryAllocator->Alloc(sizeof(*d) + ASN1_TEST_CODER_SIZE);
        if (NULL != d)
        {
            ZeroMemory(d, sizeof(*d) + ASN1_TEST_CODER_SIZE);
            d->info.pScratchMemoryAllocator = pScratchMemoryAllocator;
            d->info.magic = MAGIC_DECODER;
            d->info.err = ASN1_SUCCESS;
            d->info.dwFlags = mod->dwFlags;
            d->info.module = mod;
            // d->child = NULL;
            // d->recursionLevel = 0; 

            /* set buffer if given */
            // lonchanc: it is ok to have a zero buffer size here
            if (NULL != pbBuf)
            {
                d->info.dwFlags |= ASN1DECODE_SETBUFFER;
                d->info.buf = d->info.pos = pbBuf;
                d->info.size = cbBufSize;
                // d->info.len = d->info.bit = 0;
            }
            else
            {
                // d->info.buf = d->info.pos = NULL;
                // d->info.size = d->info.len = d->info.bit = 0;
            }

            /* set parent if parented */
            if (NULL != pParent)
            {
                d->parent = (ASN1INTERNdecoding_t) pParent;
                d->info.eRule = pParent->eRule;
                d->recursionLevel = d->parent->recursionLevel + 1; 
            }
            else
            /* initialize otherwise */
            {
                d->parent = d;
                d->info.eRule = mod->eRule;
            }

            // d->mem = NULL;
            // d->memlength = 0;
            // d->memsize = 0;
            // d->epi = NULL;
            // d->epilength = 0;
            // d->episize = 0;
            // d->csi = NULL;
            // d->csilength = 0;
            // d->csisize = 0;

#if defined(TEST_CODER) && defined(_DEBUG)
            TestDec_InitCoder(d, mod);
#endif // defined(TEST_CODER) && defined(_DEBUG)

            if (NULL != pParent)
            {
                DecAssert((ASN1decoding_t) d, NULL == ((ASN1INTERNdecoding_t) pParent)->child);
                ((ASN1INTERNdecoding_t) pParent)->child = d;
            }

            *dec = (ASN1decoding_t) d;
            return ASN1_SUCCESS;
        }
        else
        {
            return ASN1_ERR_MEMORY;
        }
    }

    return ASN1_ERR_BADARGS;
}

/* decode a value */
ASN1error_e ASN1_Decode
(
    ASN1decoding_t      dec,
    void              **valref,
    ASN1uint32_t        id,
    ASN1uint32_t        flags,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize
)
{
    ASN1error_e ReturnCode = ASN1_SUCCESS;

    if (NULL != dec && NULL != valref)
    {
        ASN1INTERNdecoding_t    d = (ASN1INTERNdecoding_t)dec;

        /* check magic numbers */
        DecAssert(dec, MAGIC_DECODER == dec->magic);

        /* clear error */
        ASN1DecSetError(dec, ASN1_SUCCESS);

        /* new buffer given? */
        *valref = NULL;
        if (flags & ASN1DECODE_SETBUFFER)
        {
            if (NULL != pbBuf && 0 != cbBufSize)
            {
                dec->pos = dec->buf = pbBuf;
                dec->size = cbBufSize;
                dec->bit = dec->len = 0;
            }
            else
            {
                ReturnCode = ASN1DecSetError(dec, ASN1_ERR_BADARGS);
                goto ErrorExit;
            }
        }
        /* rewind buffer? */
        else if ((flags & ASN1DECODE_REWINDBUFFER) ||
                 !((d->info.dwFlags | flags ) & ASN1DECODE_APPENDED))
        {
            dec->pos = dec->buf;
            dec->bit = dec->len = 0;
        }
        /* otherwise continue reading from last buffer */

        /* 
            Check that our buffer isn't too big 
            (BUG 807085 46650 MSASN1.dll: Should limit the size of buffer to decode)
        */
        if (dec->size > g_dwMaxDecodeBufferSize)
        {
            ReturnCode = ASN1DecSetError(dec, ASN1_ERR_LARGE); 
            goto ErrorExit; 
        }

        /* check id number */
        if (id < dec->module->cPDUs)
        {
            ASN1uint32_t cbTopLevelStruct;

            /* clear length of linear buffer required */
            d->cbLinearBufSize = 0;

            /* double check for the availability of destination buffer */
            if (d->lpOrigExtBuf == NULL || d->cbOrigExtBufSize == 0)
            {
                d->fExtBuf = FALSE;
            }

            cbTopLevelStruct = dec->module->acbStructSize[id];
            if (NULL != (*valref = DecMemAlloc(dec, cbTopLevelStruct)))
            {
                if (ASN1_PER_RULE & dec->eRule)
                {
                    ASN1PerDecFun_t pfnPER;
                    /* decode value */
                    if (NULL != (pfnPER = dec->module->PER.apfnDecoder[id]))
                    {
                        if ((*pfnPER)(dec, *valref))
                        {
                            ASN1PERDecFlush(dec);
                        }
                        else
                        {
                            // the error code must be an error
                            if (ASN1_SUCCEEDED(d->parent->info.err))
                            {
                                // cannot return here immediately because we need to do cleanup
                                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                            }
                        }
                    }
                    else
                    {
                        ReturnCode = ASN1DecSetError(dec, ASN1_ERR_BADPDU);
                        goto ErrorExit;
                    }
                }
#ifdef ENABLE_BER
                else
                if (ASN1_BER_RULE & dec->eRule)
                {
                    ASN1BerDecFun_t pfnBER;
                    /* decode value */
                    if (NULL != (pfnBER = dec->module->BER.apfnDecoder[id]))
                    {
                        if ((*pfnBER)(dec, 0, *valref)) // lonchanc: tag is 0 to make it compiled
                        {
                            ASN1BERDecFlush(dec);
                        }
                        else
                        {
                            // the error code must be an error
                            if (ASN1_SUCCEEDED(d->parent->info.err))
                            {
                                // cannot return here immediately because we need to do cleanup
                                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                            }
                        }
                    }
                    else
                    {
                        ReturnCode = ASN1DecSetError(dec, ASN1_ERR_BADPDU);
                        goto ErrorExit;
                    }
                }
#endif // ENABLE_BER
                else
                {
                    ReturnCode = ASN1DecSetError(dec, ASN1_ERR_RULE);
                    goto ErrorExit;
                }

                /* call abort/done function for non-parented decoding stream */
                if (ASN1_SUCCEEDED(d->parent->info.err))
                {
                    // not parented
                    if (d == d->parent)
                    {
#if defined(TEST_CODER) && defined(_DEBUG)
                        if (ASN1_PER_RULE & dec->eRule)
                        {
                            if (! TestDec_Compare(d, id, *valref, dec->buf, dec->len))
                            {
                                MyDebugBreak();
                            }
                        }
#ifdef ENABLE_BER
                        else
                        if (ASN1_BER_RULE & dec->eRule)
                        {
                            if (! TestDec_Compare(d, id, *valref, dec->buf, dec->len))
                            {
                                MyDebugBreak();
                            }
                        }
#endif // ENABLE_BER
#endif
                        ASN1DecDone(dec);
                    }
                }
                else
                {
                    ASN1INTERNdecoding_t child, child2;

                    // not parented
                    if (d == d->parent)
                    {
                        ASN1DecAbort(dec);
                    }

                    // clean up...
                    for (child = d->child; child; child = child2)
                    {
                        child2 = child->child;
                        // make sure it does not touch its parent which may already be freed
                        child->parent = child;
                        ASN1_CloseDecoder((ASN1decoding_t) child);
                    }
                    d->child = NULL;
                }

                /* return error code */
                ReturnCode = d->parent->info.err;
                goto ErrorExit;
            }
            else
            {
                ReturnCode = ASN1_ERR_MEMORY;
                goto ErrorExit;
            }
        }
        else
        {
            ReturnCode = ASN1DecSetError(dec, ASN1_ERR_BADPDU);
            goto ErrorExit;
        }
    }

    ReturnCode = ASN1_ERR_BADARGS;

ErrorExit:
    if (ASN1_FAILED(ReturnCode))
    {
        if (NULL != valref)
        {
        ASN1_FreeDecoded(dec ,*valref, id);
        *valref = NULL;
    }
    }

    return ReturnCode;
}

/* control function for decoding */
ASN1error_e ASN1_SetDecoderOption
(
    ASN1decoding_t      dec,
    ASN1optionparam_t  *pOptParam
)
{
    if (NULL != dec)
    {
        ASN1INTERNdecoding_t d = (ASN1INTERNdecoding_t)dec;
        ASN1error_e rc = ASN1_SUCCESS;

        /* check magic number */
        DecAssert(dec, MAGIC_DECODER == dec->magic);

        switch (pOptParam->eOption)
        {
        case ASN1OPT_CHANGE_RULE:
            dec->eRule = pOptParam->eRule;
            break;

        case ASN1OPT_SET_DECODED_BUFFER:
            if (NULL != pOptParam->Buffer.pbBuf && 0 != pOptParam->Buffer.cbBufSize)
            {
                d->fExtBuf = TRUE;
                d->lpOrigExtBuf = pOptParam->Buffer.pbBuf;
                d->cbOrigExtBufSize = pOptParam->Buffer.cbBufSize;
                d->lpRemExtBuf = (ASN1uint8_t*) d->lpOrigExtBuf;
                d->cbRemExtBufSize = d->cbOrigExtBufSize;
            }
            else
            {
                rc = ASN1_ERR_BADARGS;
            }
            break;

        case ASN1OPT_DEL_DECODED_BUFFER:
            d->fExtBuf = FALSE;
            d->lpOrigExtBuf = NULL;
            d->cbOrigExtBufSize = 0;
            d->lpRemExtBuf = NULL;
            d->cbRemExtBufSize = 0;
            break;

        default:
            rc = ASN1_ERR_BADARGS;
            break;
        }

        return ASN1DecSetError(dec, rc);
    }

    return ASN1_ERR_BADARGS;
}


/* control function for decoding */
ASN1error_e ASN1_GetDecoderOption
(
    ASN1decoding_t      dec,
    ASN1optionparam_t  *pOptParam
)
{
    if (NULL != dec)
    {
        const ASN1INTERNdecoding_s* d = (ASN1INTERNdecoding_t)dec;
        ASN1error_e rc = ASN1_SUCCESS;

        /* check magic number */
        DecAssert(dec, MAGIC_DECODER == dec->magic);

        switch (pOptParam->eOption)
        {
        case ASN1OPT_GET_RULE:
            pOptParam->eRule = dec->eRule;
            break;

        case ASN1OPT_GET_DECODED_BUFFER_SIZE:
            pOptParam->cbRequiredDecodedBufSize = d->cbLinearBufSize;
            break;

        default:
            rc = ASN1_ERR_BADARGS;
            break;
        }

        return ASN1DecSetError(dec, rc);
    }

    return ASN1_ERR_BADARGS;
}


/* destroy decoding stream */
void ASN1_CloseDecoder
(
    ASN1decoding_t      dec
)
{
    if (NULL != dec)
    {
        ASN1INTERNdecoding_t d = (ASN1INTERNdecoding_t)dec;

        /* check magic number */
        DecAssert(dec, MAGIC_DECODER == dec->magic);

        if (d != d->parent)
        {
            DecAssert(dec, d == d->parent->child);
            d->parent->child = NULL;
        }

        /* free decoding stream */
        MemFree(d);
    }
}

/* free an encoded value */
void ASN1_FreeEncoded
(
    const ASN1encoding_s*      enc,
    void               *val
)
{
    if (NULL != enc)
    {
        /* check magic number */
        EncAssert(enc, MAGIC_ENCODER == enc->magic);

        EncMemFree(enc, val);
    }
}

/* free a unencoded value */
void ASN1_FreeDecoded
(
    ASN1decoding_t      dec,
    void               *val,
    ASN1uint32_t        id
)
{
    if (NULL != dec)
    {
        const ASN1INTERNdecoding_s* d = (ASN1INTERNdecoding_t)dec;

        /* check magic number */
        DecAssert(dec, MAGIC_DECODER == dec->magic);

        // same behavior of LocalFree
        if (val != NULL)
        {
            if (id != ASN1DECFREE_NON_PDU_ID)
            {
                ASN1FreeFun_t       pfnFreeMemory;

                /* free value */
                if (id < dec->module->cPDUs)
                {
                    if (NULL != (pfnFreeMemory = dec->module->apfnFreeMemory[id]))
                    {
                        (*pfnFreeMemory)(val);
                    }
                }
                else
                {
                    return;
                }
            }

            // free the top-level structure
            MemFree(val);
        }
    }
}

void ASN1_InitModule
(
    ASN1module_t            module,
    ASN1uint32_t            version,
    ASN1encodingrule_e      eEncodingRule,
    ASN1uint32_t            dwFlags,
    ASN1uint32_t            cPDUs,
    const ASN1GenericFun_t  apfnEncoder[],
    const ASN1GenericFun_t  apfnDecoder[],
    const ASN1FreeFun_t     apfnFreeMemory[],
    const ASN1uint32_t      acbStructSize[],
    ASN1magic_t             nModuleName
)
{
    module->nModuleName = nModuleName;
    module->eRule = eEncodingRule;
    module->dwFlags = dwFlags;
    module->cPDUs = cPDUs;

    module->apfnFreeMemory = apfnFreeMemory;
    module->acbStructSize = acbStructSize;

    if (ASN1_PER_RULE & eEncodingRule)
    {
        module->PER.apfnEncoder = (const ASN1PerEncFun_t *) apfnEncoder;
        module->PER.apfnDecoder = (const ASN1PerDecFun_t *) apfnDecoder;
    }
#ifdef ENABLE_BER
    else
    if (ASN1_BER_RULE & eEncodingRule)
    {
        module->BER.apfnEncoder = (const ASN1BerEncFun_t *) apfnEncoder;
        module->BER.apfnDecoder = (const ASN1BerDecFun_t *) apfnDecoder;
    }
#endif // ENABLE_BER
}

#ifdef TEST_CODER

static int MyMemCmp(ASN1octet_t *p1, ASN1octet_t *p2, ASN1uint32_t c)
{
    BYTE diff;
    while (c--)
    {
        if ((diff = *p1++ - *p2++) != 0)
            return (int) diff;
    }
    return 0;
}

__inline ASN1INTERNencoding_t TestEnc_GetEnc(ASN1INTERNencoding_t e)
    { return &(((ASN1testcoder_t) (e+1))->e); }
__inline ASN1INTERNdecoding_t TestEnc_GetDec(ASN1INTERNencoding_t e)
    { return &(((ASN1testcoder_t) (e+1))->d); }
__inline ASN1INTERNencoding_t TestDec_GetEnc(ASN1INTERNdecoding_t d)
    { return &(((ASN1testcoder_t) (d+1))->e); }
__inline ASN1INTERNdecoding_t TestDec_GetDec(ASN1INTERNdecoding_t d)
    { return &(((ASN1testcoder_t) (d+1))->d); }

static void Test_InitEnc(ASN1INTERNencoding_t e, ASN1module_t mod, ASN1encodingrule_e eRule)
{
    ZeroMemory(e, sizeof(*e));
    e->info.magic = MAGIC_ENCODER;
    e->info.err = ASN1_SUCCESS;
    e->info.module = mod;
    e->info.eRule = eRule;
    e->parent = e;
    e->child = NULL;
}

static void Test_InitDec(ASN1INTERNdecoding_t d, ASN1module_t mod, ASN1encodingrule_e eRule)
{
    ZeroMemory(d, sizeof(*d));
    d->info.magic = MAGIC_DECODER;
    d->info.err = ASN1_SUCCESS;
    d->info.module = mod;
    d->info.eRule = eRule;
    d->parent = d;
    d->child = NULL;
}

static int TestEnc_InitCoder(ASN1INTERNencoding_t e, ASN1module_t mod)
{
    ASN1INTERNencoding_t ee = TestEnc_GetEnc(e);
    ASN1INTERNdecoding_t ed = TestEnc_GetDec(e);
    Test_InitEnc(ee, mod, e->info.eRule);
    Test_InitDec(ed, mod, e->info.eRule);
    return 1;
}

static int TestDec_InitCoder(ASN1INTERNdecoding_t d, ASN1module_t mod)
{
    ASN1INTERNencoding_t de = TestDec_GetEnc(d);
    ASN1INTERNdecoding_t dd = TestDec_GetDec(d);
    Test_InitEnc(de, mod, d->info.eRule);
    Test_InitDec(dd, mod, d->info.eRule);
    return 1;
}

static int Test_Encode(ASN1INTERNencoding_t e, void *value, ASN1uint32_t id)
{
    ASN1encoding_t enc = (ASN1encoding_t) e;

    /* clear error */
    ASN1EncSetError(enc, ASN1_SUCCESS);

    // clean buffer
    enc->pos = enc->buf;
    enc->bit = enc->len = 0;

    if (ASN1_PER_RULE & enc->eRule)
    {
        /* encode value */
        ASN1PerEncFun_t pfnPER;
        if (NULL != (pfnPER = enc->module->PER.apfnEncoder[id]))
        {
            if ((*pfnPER)(enc, value))
            {
                ASN1PEREncFlush(enc);
            }
        }
        else
        {
            return ASN1EncSetError(enc, ASN1_ERR_BADPDU);
        }
    }
#ifdef ENABLE_BER
    else
    if (ASN1_BER_RULE & enc->eRule)
    {
        /* encode value */
        ASN1BerEncFun_t pfnBER;
        if (NULL != (pfnBER = enc->module->BER.apfnEncoder[id]))
        {
            if ((*pfnBER)(enc, 0, value)) // lonchanc: tag is 0 to make it compiled
            {
                ASN1BEREncFlush(enc);
            }
        }
        else
        {
            return ASN1EncSetError(enc, ASN1_ERR_BADPDU);
        }
    }
#endif // ENABLE_BER
    else
    {
        return ASN1EncSetError(enc, ASN1_ERR_RULE);
    }

    /* call abort/done function for non-parented encoding stream */
    if (e->parent->info.err >= 0)
    {
        if (e == e->parent)
        {
            ASN1EncDone(enc);
        }
    }
    else
    {
        ASN1INTERNencoding_t child, child2;

        if (e == e->parent)
        {
            ASN1EncAbort(enc);
        }

        // clean up...
        ASN1_FreeEncoded(enc, enc->buf);
        enc->pos = enc->buf = NULL;
        enc->size = enc->len = enc->bit = 0;
        for (child = e->child; child; child = child2)
        {
            child2 = child->child;
            // make sure it does not touch its parent which may already be freed
            child->parent = child;
            ASN1_CloseEncoder((ASN1encoding_t) child);
        }
        e->child = NULL;
    }

    /* return error code */
    return e->parent->info.err;
}

static int Test_Decode(ASN1INTERNdecoding_t d, void ** valref, ASN1uint32_t id, ASN1octet_t *pbBuf, ASN1uint32_t cbBufSize)
{
    ASN1decoding_t dec = (ASN1decoding_t) d;
    ASN1uint32_t cbTopLevelStruct;

    /* clear error */
    ASN1DecSetError(dec, ASN1_SUCCESS);

    // set up buffer containing encoded data
    dec->pos = dec->buf = pbBuf;
    dec->size = cbBufSize;
    dec->bit = dec->len = 0;

    /* clear length of linear buffer required */
    d->cbLinearBufSize = 0;
    d->fExtBuf = FALSE;

    cbTopLevelStruct = dec->module->acbStructSize[id];
    if (NULL != (*valref = DecMemAlloc(dec, cbTopLevelStruct)))
    {
        if (ASN1_PER_RULE & dec->eRule)
        {
            ASN1PerDecFun_t pfnPER;
            /* decode value */
            if (NULL != (pfnPER = dec->module->PER.apfnDecoder[id]))
            {
                if ((*pfnPER)(dec, *valref))
                {
                    ASN1PERDecFlush(dec);
                }
            }
            else
            {
                return ASN1DecSetError(dec, ASN1_ERR_BADPDU);
            }
        }
#ifdef ENABLE_BER
        else
        if (ASN1_BER_RULE & dec->eRule)
        {
            ASN1BerDecFun_t pfnBER;
            /* decode value */
            if (NULL != (pfnBER = dec->module->BER.apfnDecoder[id]))
            {
                if ((*pfnBER)(dec, 0, *valref))
                {
                    ASN1BERDecFlush(dec);
                }
            }
            else
            {
                return ASN1DecSetError(dec, ASN1_ERR_BADPDU);
            }
        }
#endif // ENABLE_BER
        else
        {
            return ASN1DecSetError(dec, ASN1_ERR_RULE);
        }

        /* call abort/done function for non-parented decoding stream */
        if (d->parent->info.err >= 0)
        {
            // not parented
            if (d == d->parent)
            {
                ASN1DecDone(dec);
            }
        }
        else
        {
            ASN1INTERNdecoding_t child, child2;

            // not parented
            if (d == d->parent)
            {
                ASN1DecAbort(dec);
            }

            // clean up...
            ASN1_FreeDecoded(dec ,*valref, id);
            *valref = NULL;
            for (child = d->child; child; child = child2)
            {
                child2 = child->child;
                // make sure it does not touch its parent which may already be freed
                child->parent = child;
                ASN1_CloseDecoder((ASN1decoding_t) child);
            }
            d->child = NULL;
        }
    }
    else
    {
        return ASN1_ERR_MEMORY;
    }

    /* return error code */
    return d->parent->info.err;
}

static void Test_CleanEnc(ASN1INTERNencoding_t e)
{
    if (e->info.buf)
    {
        EncMemFree((ASN1encoding_t) e, e->info.buf);
    }
    Test_InitEnc(e, e->info.module, e->info.eRule);
}

static void Test_CleanDec(ASN1INTERNdecoding_t d)
{
    Test_InitDec(d, d->info.module, d->info.eRule);
}

static int TestEnc_Compare(ASN1INTERNencoding_t e, ASN1uint32_t id, ASN1octet_t *pbBuf, ASN1uint32_t cbBufSize)
{
    ASN1INTERNencoding_t ee = TestEnc_GetEnc(e);
    ASN1INTERNdecoding_t ed = TestEnc_GetDec(e);
    int ret;
    void *val = NULL;
    int fRet = 0;

    ee->info.eRule = e->info.eRule;
    ed->info.eRule = e->info.eRule;

    ret = Test_Decode(ed, &val, id, pbBuf, cbBufSize);
    if (ret == ASN1_SUCCESS)
    {
        ret = Test_Encode(ee, val, id);
        if (ret == ASN1_SUCCESS)
        {
            if (ee->info.len == cbBufSize)
            {
                fRet = (MyMemCmp(pbBuf, ee->info.buf, cbBufSize) == 0);
            }
        }
    }

    if (val)
    {
        ASN1_FreeDecoded((ASN1decoding_t) ed, val, id);
    }

    Test_CleanEnc(ee);
    Test_CleanDec(ed);

    return fRet;
}

static int TestDec_Compare(ASN1INTERNdecoding_t d, ASN1uint32_t id, void *val, ASN1octet_t *pbBuf, ASN1uint32_t cbBufSize)
{
    ASN1INTERNencoding_t de = TestDec_GetEnc(d);
    int ret;
    int fRet = 0;

    de->info.eRule = d->info.eRule;

    ret = Test_Encode(de, val, id);
    if (ret == ASN1_SUCCESS)
    {
        if (de->info.len == cbBufSize)
        {
            fRet = (MyMemCmp(pbBuf, de->info.buf, cbBufSize) == 0);
        }
    }

    Test_CleanEnc(de);

    return fRet;
}
#endif

#ifdef ENABLE_BER

static const char bitmsk2[] =
{
    (const char) 0x00,
    (const char) 0x80,
    (const char) 0xc0,
    (const char) 0xe0,
    (const char) 0xf0,
    (const char) 0xf8,
    (const char) 0xfc,
    (const char) 0xfe
};


/* decode bit string value */
int _BERDecBitString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1bitstring_t *val, ASN1uint32_t fNoCopy)
{
    ASN1uint32_t constructed, len, infinite;
    ASN1bitstring_t b;
    ASN1decoding_t dd;
    ASN1octet_t *di;

    /* skip tag */
    if (ASN1BERDecTag(dec, tag, &constructed))
    {
        /* get length */
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            if (constructed)
            {
                /* constructed? then start decoding of constructed value */
                val->length = 0;
                val->value = NULL; 
                if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                {
                    while (ASN1BERDecNotEndOfContents(dd, di))
                    {
                        if (_BERDecBitString(dd, 0x3, &b, fNoCopy))
                        {
                            if (b.length)
                            {
                                if (fNoCopy)
                                {
                                    *val = b;
                                    break; // break out the loop because nocopy cannot have multiple constructed streams
                                }

                                /* resize value */
                                val->value = (ASN1octet_t *)DecMemReAlloc(dd, val->value,
                                    (val->length + b.length + 7) / 8);
                                if (val->value)
                                {
                                    /* concat bit strings */
                                    ASN1bitcpy(val->value, val->length, b.value, 0, b.length);
                                    val->length += b.length;
                                    if (val->length & 7)
                                        val->value[val->length / 8] &= bitmsk2[val->length & 7];

                                    /* free unused bit string */
                                    DecMemFree(dec, b.value);
                                }
                                else
                                {
                                    /* free unused bit string */
                                    DecMemFree(dec, b.value);
                                    return 0;
                                }
                            }
                        }
                    } // while
                    return ASN1BERDecEndOfContents(dec, dd, di);
                }
            }
            else
            {
                /* primitive? then copy value */
                if (!len)
                {
                    val->length = 0;
                    val->value = NULL;
                    return 1;
                }
                else if (1 == len)
                {
                    // BUG 785505: MSASN1: Decoding data can cause memory corruption
                    // Special-case len==1, or else we'll have an arithmetic overflow below
                    val->length = 0;
                    val->value = NULL;
                    dec->pos += 1; 
                    return 1; 
                }
                else
                {
                    if (*dec->pos < 8)
                    {
                        len--; // skip over the initial octet; len is now the actual length of octets
                        val->length = len * 8 - *dec->pos++;
                        if (fNoCopy)
                        {
                            val->value = dec->pos;
                            dec->pos += len;
                            return 1;
                        }
                        else
                        {
                            if (val->length)
                            {
                                val->value = (ASN1octet_t *)DecMemAlloc(dec, (val->length + 7) / 8);
                                if (val->value)
                                {
                                    memcpy(val->value, dec->pos, len);
                                    if (val->length & 7)
                                        val->value[len - 1] &= bitmsk2[val->length & 7];
                                    dec->pos += len;
                                    return 1;
                                }
                            }
                            else
                            {
                                val->value = NULL;
                                return 1;
                            }
                        }
                    }
                    else
                    {
                        ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                    }
                }
            }
        }
    }
    return 0;
}

/* decode bit string value, making copy */
int ASN1BERDecBitString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1bitstring_t *val)
{
    return _BERDecBitString(dec, tag, val, FALSE);
}

/* decode bit string value, no copy */
int ASN1BERDecBitString2(ASN1decoding_t dec, ASN1uint32_t tag, ASN1bitstring_t *val)
{
    return _BERDecBitString(dec, tag, val, TRUE);
}

/* decode string value */
int ASN1BERDecCharString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1charstring_t *val)
{
    ASN1uint32_t constructed, len, infinite;
    ASN1charstring_t c;
    ASN1decoding_t dd;
    ASN1octet_t *di;

    /* skip tag */
    if (ASN1BERDecTag(dec, tag, &constructed))
    {
        /* get length */
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            if (constructed)
            {
                /* constructed? then start decoding of constructed value */
                val->length = 0;
                val->value = NULL; 
                if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                {
                    while (ASN1BERDecNotEndOfContents(dd, di))
                    {
                        if (ASN1BERDecCharString(dd, 0x4, &c))
                        {
                            if (c.length)
                            {
                                /* resize value */
                                val->value = (char *)DecMemReAlloc(dd, val->value,
                                    val->length + c.length + 1);
                                if (val->value)
                                {
                                    /* concat strings */
                                    memcpy(val->value + val->length, c.value, c.length);
                                    val->length += c.length;
                                    val->value[val->length] = 0;

                                    /* free unused string */
                                    DecMemFree(dec, c.value);
                                }
                                else
                                {
                                    /* free unused string */
                                    DecMemFree(dec, c.value);
                                    return 0;
                                }
                            }
                        }
                        else
                        {
                            return 0;
                        }
                    } // while
                    return ASN1BERDecEndOfContents(dec, dd, di);
                }
            }
            else
            {
                /* primitive? then copy value */
                val->length = len;
                if (len)
                {
                    val->value = (char *)DecMemAlloc(dec, len+1);
                    if (val->value)
                    {
                        memcpy(val->value, dec->pos, len);
                        dec->pos += len;
                        val->value[len] = 0;
                        return 1;
                    }
                }
                else
                {
                    val->value = NULL;
                    return 1;
                }
            }
        }
    }
    return 0;
}

/* decode 16 bit string value */
int ASN1BERDecChar16String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1char16string_t *val)
{
    ASN1uint32_t constructed, len, infinite;
    ASN1char16string_t c;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t i;

    /* skip tag */
    if (ASN1BERDecTag(dec, tag, &constructed))
    {
        /* get length */
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            if (constructed)
            {
                /* constructed? then start decoding of constructed value */
                val->length = 0;
                val->value = NULL; 
                if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                {
                    while (ASN1BERDecNotEndOfContents(dd, di))
                    {
                        if (ASN1BERDecChar16String(dd, 0x4, &c))
                        {
                            if (c.length)
                            {
                                /* resize value */
                                val->value = (ASN1char16_t *)DecMemReAlloc(dd, val->value,
                                    (val->length + c.length + 1) * sizeof(ASN1char16_t));
                                if (val->value)
                                {
                                    /* concat strings */
                                    memcpy(val->value + val->length, c.value,
                                        c.length * sizeof(ASN1char16_t));
                                    val->length += c.length;
                                    val->value[val->length] = 0; 

                                    /* free unused string */
                                    DecMemFree(dec, c.value);
                                }
                                else
                                {
                                    /* free unused string */
                                    DecMemFree(dec, c.value);
                                    return 0;
                                }
                            }
                        }
                        else
                        {
                            return 0;
                        }
                    }
                    return ASN1BERDecEndOfContents(dec, dd, di);
                }
            }
            else
            {
                /* primitive? then copy value */
                DecAssert(dec, 2 * sizeof(ASN1octet_t) == sizeof(ASN1char16_t));
                len = len >> 1; // divided by 2
                val->length = len;
                if (len)
                {
                    val->value = (ASN1char16_t *)DecMemAlloc(dec, (len+1) * sizeof(ASN1char16_t));
                    if (val->value)
                    {
                        for (i = 0; i < len; i++)
                        {
                            val->value[i] = (*dec->pos << 8) | dec->pos[1];
                            dec->pos += 2;
                        }
                        val->value[len] = 0;
                        return 1;
                    }
                }
                else
                {
                    val->value = NULL;
                    return 1;
                }
            }
        }
    }
    return 0;
}

/* decode 32 bit string value */
int ASN1BERDecChar32String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1char32string_t *val)
{
    ASN1uint32_t constructed, len, infinite;
    ASN1char32string_t c;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t i;

    /* skip tag */
    if (ASN1BERDecTag(dec, tag, &constructed))
    {
        /* get length */
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            if (constructed)
            {
                /* constructed? then start decoding of constructed value */
                val->length = 0;
                val->value = NULL; 
                if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                {
                    while (ASN1BERDecNotEndOfContents(dd, di))
                    {
                        if (ASN1BERDecChar32String(dd, 0x4, &c))
                        {
                            if (c.length)
                            {
                                /* resize value */
                                val->value = (ASN1char32_t *)DecMemReAlloc(dd, val->value,
                                    (val->length + c.length + 1) * sizeof(ASN1char32_t));
                                if (val->value)
                                {
                                    /* concat strings */
                                    memcpy(val->value + val->length, c.value,
                                        c.length * sizeof(ASN1char32_t));
                                    val->length += c.length;
                                    val->value[val->length] = 0; 

                                    /* free unused string */
                                    DecMemFree(dec, c.value);
                                }
                                else
                                {
                                    /* free unused string */
                                    DecMemFree(dec, c.value);
                                    return 0;
                                }
                            }
                        }
                        else
                        {
                            return 0;
                        }
                    }
                    return ASN1BERDecEndOfContents(dec, dd, di);
                }
            }
            else
            {
                /* primitive? then copy value */
                DecAssert(dec, 4 * sizeof(ASN1octet_t) == sizeof(ASN1char32_t));
                len = len >> 2; // divided by 4
                val->length = len;
                if (len)
                {
                    val->value = (ASN1char32_t *)DecMemAlloc(dec, (len+1) * sizeof(ASN1char32_t));
                    if (val->value)
                    {
                        for (i = 0; i < len; i++)
                        {
                            val->value[i] = (*dec->pos << 24) | (dec->pos[1] << 16) |
                                (dec->pos[2] << 8) | dec->pos[3];;
                            dec->pos += 4;
                        }
                        val->value[len] = 0;
                        return 1;
                    }
                }
                else
                {
                    val->value = NULL;
                    return 1;
                }
            }
        }
    }
    return 0;
}

#ifdef ENABLE_GENERALIZED_CHAR_STR
/* decode character string value */
int ASN1BERDecCharacterString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1characterstring_t *val)
{
    ASN1INTERNdecoding_t d = (ASN1INTERNdecoding_t) dec;
    ASN1uint32_t constructed, len, infinite;
    ASN1uint32_t index;
    ASN1characterstring_identification_t *identification;
    ASN1decoding_t dd, dd2, dd3;
    ASN1octet_t *di, *di2, *di3;

    /* skip tag */
    if (!ASN1BERDecTag(dec, tag, &constructed))
        return 0;

    if (constructed)
    {
        /* constructed? CS-A encoded: */
        /* get length */
        if (!ASN1BERDecLength(dec, &len, &infinite))
            return 0;

        /* start decoding of constructed value */
        if (! _BERDecConstructed(dec, len, infinite, &dd, &di))
            return 0;
        if (!ASN1BERDecU32Val(dd, 0x80000000, &index))
            return 0;
        if (index != d->parent->csilength)
        {
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            return 0;
        }
        if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd2, &di2))
            return 0;
        if (!ASN1BERDecPeekTag(dd2, &tag))
            return 0;
        switch (tag)
        {
        case 0x80000000:
            val->identification.o =
                ASN1characterstring_identification_syntaxes_o;
            if (!ASN1BERDecExplicitTag(dd2, 0x80000000, &dd3, &di3))
                return 0;
            if (!ASN1BERDecObjectIdentifier(dd3, 0x80000000,
                &val->identification.u.syntaxes.abstract))
                return 0;
            if (!ASN1BERDecObjectIdentifier(dd3, 0x80000001,
                &val->identification.u.syntaxes.transfer))
                return 0;
            if (!ASN1BERDecEndOfContents(dd2, dd3, di3))
                return 0;
            break;
        case 0x80000001:
            val->identification.o = ASN1characterstring_identification_syntax_o;
            if (!ASN1BERDecObjectIdentifier(dd2, 0x80000001,
                &val->identification.u.syntax))
                return 0;
            break;
        case 0x80000002:
            val->identification.o =
                ASN1characterstring_identification_presentation_context_id_o;
            if (!ASN1BERDecU32Val(dd2, 0x80000002,
                &val->identification.u.presentation_context_id))
                return 0;
            break;
        case 0x80000003:
            val->identification.o =
                ASN1characterstring_identification_context_negotiation_o;
            if (!ASN1BERDecExplicitTag(dd2, 0x80000003, &dd3, &di3))
                return 0;
            if (!ASN1BERDecU32Val(dd3, 0x80000000, &val->
                identification.u.context_negotiation.presentation_context_id))
                return 0;
            if (!ASN1BERDecObjectIdentifier(dd3, 0x80000001,
                &val->identification.u.context_negotiation.transfer_syntax))
                return 0;
            if (!ASN1BERDecEndOfContents(dd2, dd3, di3))
                return 0;
            break;
        case 0x80000004:
            val->identification.o =
                ASN1characterstring_identification_transfer_syntax_o;
            if (!ASN1BERDecObjectIdentifier(dd2, 0x80000004,
                &val->identification.u.transfer_syntax))
                return 0;
            break;
        case 0x80000005:
            val->identification.o = ASN1characterstring_identification_fixed_o;
            if (!ASN1BERDecNull(dd2, 0x80000005))
                return 0;
            break;
        default:
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            return 0;
        }
        if (!ASN1BERDecEndOfContents(dd, dd2, di2))
            return 0;
        if (!ASN1DecAddCharacterStringIdentification(d->parent,
            &val->identification))
            return 0;
        val->data_value.o = ASN1characterstring_data_value_encoded_o;
        if (!ASN1BERDecOctetString(dd, 0x80000003,
            &val->data_value.u.encoded))
            return 0;
        if (!ASN1BERDecEndOfContents(dec, dd, di))
            return 0;
    }
    else
    {
        /* primitive? CS-B encoded */
        /* get length */
        if (!ASN1BERDecLength(dec, &len, NULL))
            return 0;

        /* then copy value */
        if (!len)
        {
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            return 0;
        }
        val->data_value.o = ASN1characterstring_data_value_encoded_o;
        val->data_value.u.encoded.length = len - 1;
        val->data_value.u.encoded.value = (ASN1octet_t *)DecMemAlloc(dec, len - 1);
        if (!val->data_value.u.encoded.value)
        {
            return 0;
        }
        index = *dec->pos++;
        memcpy(val->data_value.u.encoded.value, dec->pos, len - 1);
        identification = ASN1DecGetCharacterStringIdentification(d->parent,
            index);
        if (!identification)
            return 0;
        val->identification.o = identification->o;
        switch (identification->o)
        {
        case ASN1characterstring_identification_syntaxes_o:
            if (!ASN1DecDupObjectIdentifier(dec, 
                &val->identification.u.syntaxes.abstract,
                &identification->u.syntaxes.abstract))
                return 0;
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.syntaxes.transfer,
                &identification->u.syntaxes.transfer))
                return 0;
            break;
        case ASN1characterstring_identification_syntax_o:
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.syntax,
                &identification->u.syntax))
                return 0;
            break;
        case ASN1characterstring_identification_presentation_context_id_o:
            val->identification.u.presentation_context_id =
                identification->u.presentation_context_id;
            break;
        case ASN1characterstring_identification_context_negotiation_o:
            val->identification.u.context_negotiation.presentation_context_id =
                identification->u.context_negotiation.presentation_context_id;
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.context_negotiation.transfer_syntax,
                &identification->u.context_negotiation.transfer_syntax))
                return 0;
            break;
        case ASN1characterstring_identification_transfer_syntax_o:
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.transfer_syntax,
                &identification->u.transfer_syntax))
                return 0;
            break;
        case ASN1characterstring_identification_fixed_o:
            break;
        }
    }
    return 1;
}
#endif // ENABLE_GENERALIZED_CHAR_STR

#ifdef ENABLE_EMBEDDED_PDV
/* decode embedded pdv value */
int ASN1BERDecEmbeddedPdv(ASN1decoding_t dec, ASN1uint32_t tag, ASN1embeddedpdv_t *val)
{
    ASN1INTERNdecoding_t d = (ASN1INTERNdecoding_t) dec;
    ASN1uint32_t constructed, len, infinite;
    ASN1uint32_t index;
    ASN1embeddedpdv_identification_t *identification;
    ASN1decoding_t dd, dd2, dd3;
    ASN1octet_t *di, *di2, *di3;

    /* skip tag */
    if (!ASN1BERDecTag(dec, tag, &constructed))
        return 0;

    if (constructed)
    {
        /* constructed? EP-A encoded: */
        /* get length */
        if (!ASN1BERDecLength(dec, &len, &infinite))
            return 0;

        /* then start decoding of constructed value */
        if (! _BERDecConstructed(dec, len, infinite, &dd, &di))
            return 0;
        if (!ASN1BERDecU32Val(dd, 0x80000000, &index))
            return 0;
        if (index != d->parent->epilength)
        {
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            return 0;
        }
        if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd2, &di2))
            return 0;
        if (!ASN1BERDecPeekTag(dd2, &tag))
            return 0;
        switch (tag)
        {
        case 0x80000000:
            val->identification.o = ASN1embeddedpdv_identification_syntaxes_o;
            if (!ASN1BERDecExplicitTag(dd2, 0x80000000, &dd3, &di3))
                return 0;
            if (!ASN1BERDecObjectIdentifier(dd3, 0x80000000,
                &val->identification.u.syntaxes.abstract))
                return 0;
            if (!ASN1BERDecObjectIdentifier(dd3, 0x80000001,
                &val->identification.u.syntaxes.transfer))
                return 0;
            if (!ASN1BERDecEndOfContents(dd2, dd3, di3))
                return 0;
            break;
        case 0x80000001:
            val->identification.o = ASN1embeddedpdv_identification_syntax_o;
            if (!ASN1BERDecObjectIdentifier(dd2, 0x80000001,
                &val->identification.u.syntax))
                return 0;
            break;
        case 0x80000002:
            val->identification.o =
                ASN1embeddedpdv_identification_presentation_context_id_o;
            if (!ASN1BERDecU32Val(dd2, 0x80000002,
                &val->identification.u.presentation_context_id))
                return 0;
            break;
        case 0x80000003:
            val->identification.o =
                ASN1embeddedpdv_identification_context_negotiation_o;
            if (!ASN1BERDecExplicitTag(dd2, 0x80000003, &dd3, &di3))
                return 0;
            if (!ASN1BERDecU32Val(dd3, 0x80000000, &val->
                identification.u.context_negotiation.presentation_context_id))
                return 0;
            if (!ASN1BERDecObjectIdentifier(dd3, 0x80000001,
                &val->identification.u.context_negotiation.transfer_syntax))
                return 0;
            if (!ASN1BERDecEndOfContents(dd2, dd3, di3))
                return 0;
            break;
        case 0x80000004:
            val->identification.o =
                ASN1embeddedpdv_identification_transfer_syntax_o;
            if (!ASN1BERDecObjectIdentifier(dd2, 0x80000004,
                &val->identification.u.transfer_syntax))
                return 0;
            break;
        case 0x80000005:
            val->identification.o = ASN1embeddedpdv_identification_fixed_o;
            if (!ASN1BERDecNull(dd2, 0x80000005))
                return 0;
            break;
        default:
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            return 0;
        }
        if (!ASN1BERDecEndOfContents(dd, dd2, di2))
            return 0;
        if (!ASN1DecAddEmbeddedPdvIdentification(d->parent,
            &val->identification))
            return 0;
        val->data_value.o = ASN1embeddedpdv_data_value_encoded_o;
        if (!ASN1BERDecBitString(dd, 0x80000003,
            &val->data_value.u.encoded))
            return 0;
        if (!ASN1BERDecEndOfContents(dec, dd, di))
            return 0;
    }
    else
    {
        /* primitive? EP-B encoded: */
        if (!ASN1BERDecLength(dec, &len, NULL))
            return 0;

        /* then copy value */
        if (!len)
        {
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            return 0;
        }
        val->data_value.o = ASN1embeddedpdv_data_value_encoded_o;
        val->data_value.u.encoded.length = 8 * (len - 1);
        val->data_value.u.encoded.value = (ASN1octet_t *)DecMemAlloc(dec, len - 1);
        if (!val->data_value.u.encoded.value)
        {
            return 0;
        }
        index = *dec->pos++;
        memcpy(val->data_value.u.encoded.value, dec->pos, len - 1);
        identification = ASN1DecGetEmbeddedPdvIdentification(d->parent, index);
        if (!identification)
            return 0;
        val->identification.o = identification->o;
        switch (identification->o)
        {
        case ASN1embeddedpdv_identification_syntaxes_o:
            if (!ASN1DecDupObjectIdentifier(dec, 
                &val->identification.u.syntaxes.abstract,
                &identification->u.syntaxes.abstract))
                return 0;
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.syntaxes.transfer,
                &identification->u.syntaxes.transfer))
                return 0;
            break;
        case ASN1embeddedpdv_identification_syntax_o:
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.syntax,
                &identification->u.syntax))
                return 0;
            break;
        case ASN1embeddedpdv_identification_presentation_context_id_o:
            val->identification.u.presentation_context_id =
                identification->u.presentation_context_id;
            break;
        case ASN1embeddedpdv_identification_context_negotiation_o:
            val->identification.u.context_negotiation.presentation_context_id =
                identification->u.context_negotiation.presentation_context_id;
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.context_negotiation.transfer_syntax,
                &identification->u.context_negotiation.transfer_syntax))
                return 0;
            break;
        case ASN1embeddedpdv_identification_transfer_syntax_o:
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.transfer_syntax,
                &identification->u.transfer_syntax))
                return 0;
            break;
        case ASN1embeddedpdv_identification_fixed_o:
            break;
        }
    }
    return 1;
}
#endif // ENABLE_EMBEDDED_PDV

#ifdef ENABLE_EXTERNAL
/* decode external value */
int ASN1BERDecExternal(ASN1decoding_t dec, ASN1uint32_t tag, ASN1external_t *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1objectidentifier_t id;
    ASN1octetstring_t os;

    /* decode explicit tag */
    if (!ASN1BERDecExplicitTag(dec, tag | 0x20000000, &dd, &di))
        return 0;

    /* peek tag of choice alternative */
    if (!ASN1BERDecPeekTag(dd, &tag))
        return 0;

    /* decode alternative */
    if (tag == 0x6)
    {
        if (!ASN1BERDecObjectIdentifier(dd, 0x6, &id))
            return 0;
        if (!ASN1BERDecPeekTag(dd, &tag))
            return 0;
        if (tag == 0x2)
        {
            val->identification.o =
                ASN1external_identification_context_negotiation_o;
            val->identification.u.context_negotiation.transfer_syntax = id;
            if (!ASN1BERDecU32Val(dd, 0x2, &val->
                identification.u.context_negotiation.presentation_context_id))
                return 0;
            if (!ASN1BERDecPeekTag(dd, &tag))
                return 0;
        }
        else
        {
            val->identification.o = ASN1external_identification_syntax_o;
            val->identification.u.syntax = id;
        }
    }
    else
    if (tag == 0x2)
    {
        val->identification.o =
            ASN1external_identification_presentation_context_id_o;
        if (!ASN1BERDecU32Val(dd, 0x2,
            &val->identification.u.presentation_context_id))
            return 0;
        if (!ASN1BERDecPeekTag(dd, &tag))
            return 0;
    }
    else
    {
        ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
        return 0;
    }

    /* decode optional data value descriptor if present */
    if (tag == 0x7)
    {
        if (!ASN1BERDecZeroCharString(dd, 0x7, &val->data_value_descriptor))
            return 0;
        if (!ASN1BERDecPeekTag(dd, &tag))
            return 0;
    }
    else
    {
        val->data_value_descriptor = NULL;
    }

    /* decode data value alternative */
    switch (tag)
    {
    case 0:
        val->data_value.o = ASN1external_data_value_notation_o;
        if (!ASN1BERDecOpenType(dd, &val->data_value.u.notation))
            return 0;
        break;
    case 1:
        val->data_value.o = ASN1external_data_value_encoded_o;
        if (!ASN1BERDecOctetString(dd, 0x4, &os))
            return 0;
        val->data_value.u.encoded.value = os.value;
        val->data_value.u.encoded.length = os.length * 8;
        break;
    case 2:
        val->data_value.o = ASN1external_data_value_encoded_o;
        if (!ASN1BERDecBitString(dd, 0x3, &val->data_value.u.encoded))
            return 0;
        break;
    default:
        ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
        return 0;
    }

    /* end of constructed (explicit tagged) value */
    if (!ASN1BERDecEndOfContents(dec, dd, di))
        return 0;

    return 1;
}
#endif // ENABLE_EXTERNAL

/* decode generalized time value */
int ASN1BERDecGeneralizedTime(ASN1decoding_t dec, ASN1uint32_t tag, ASN1generalizedtime_t *val)
{
    ASN1ztcharstring_t time = NULL;
    if (ASN1BERDecZeroCharString(dec, tag, &time))
    {
        int rc = ASN1string2generalizedtime(val, time);
        DecMemFree(dec, time);
        if (rc)
        {
            return 1;
        }
        ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
    } else { 
        if (NULL != time) { 
            DecMemFree(dec, time);
        }
    } 
    return 0;
}

/* decode multibyte string value */
int ASN1BERDecZeroMultibyteString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztcharstring_t *val)
{
    return ASN1BERDecZeroCharString(dec, tag, val);
}

int ASN1BERDecMultibyteString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1charstring_t *val)
{
    return ASN1BERDecCharString(dec, tag, val);
}

/* decode null value */
int ASN1BERDecNull(ASN1decoding_t dec, ASN1uint32_t tag)
{
    ASN1uint32_t len;
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            if (! len)
            {
                return 1;
            }
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
        }
    }
    return 0;
}

/* decode object identifier value */
int ASN1BERDecObjectIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, ASN1objectidentifier_t *val)
{
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len, i, v;
        const ASN1octet_t *data;
        const ASN1octet_t *p;
        ASN1uint32_t nelem;
        ASN1objectidentifier_t q;

        if (ASN1BERDecLength(dec, &len, NULL))
        {
            data = dec->pos;
            dec->pos += len;
            nelem = 1;
            for (i = 0, p = data; i < len; i++, p++)
            {
                if (!(*p & 0x80))
                    nelem++;
            }
            *val = q = DecAllocObjectIdentifier(dec, nelem);
            if (q)
            {
                v = 0;
                for (i = 0, p = data; i < len; i++, p++)
                {
                    v = (v << 7) | (*p & 0x7f);
                    if (!(*p & 0x80))
                    {
                        if (q == *val)
                        { // first id
                            q->value = v / 40;
                            if (q->value > 2)
                                q->value = 2;
                            q->next->value = v - 40 * q->value;
                            q = q->next->next;
                        }
                        else
                        {
                            q->value = v;
                            q = q->next;
                        }
                        v = 0;
                    }
                }
                return 1;
            }
        }
    }
    return 0;
}

/* decode object identifier value */
int ASN1BERDecObjectIdentifier2(ASN1decoding_t dec, ASN1uint32_t tag, ASN1objectidentifier2_t *val)
{
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len, i, v;
        const ASN1octet_t *data;
        const ASN1octet_t *p;
        //ASN1objectidentifier_t q;

        if (ASN1BERDecLength(dec, &len, NULL))
        {
            // lonchanc: hard-coded value 16 to be consistent with ASN1objectidentifier2_t
            // NOTE: first byte of encoded OID encodes the first two elements of the OID, 
            // so allow only 15 bytes for the encoded OID.  
            if (len <= 15) 
            {
                data = dec->pos;
                dec->pos += len;
                val->count = 0;
                v = 0;
                for (i = 0, p = data; i < len; i++, p++)
                {
                    v = (v << 7) | (*p & 0x7f);
                    if (!(*p & 0x80))
                    {
                        if (! val->count)
                        { // first id
                            val->value[0] = v / 40;
                            if (val->value[0] > 2)
                                val->value[0] = 2;
                            val->value[1] = v - 40 * val->value[0];
                            val->count = 2;
                        }
                        else
                        {
                            val->value[val->count++] = v;
                        }
                        v = 0;
                    }
                }
                return 1;
            }
            else
            {
                ASN1DecSetError(dec, ASN1_ERR_LARGE);
            }
        }
    }
    return 0;
}

/* decode integer into signed 8 bit value */
int ASN1BERDecS8Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1int8_t *val)
{
    /* skip tag */
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len;
        /* get length */
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            /* get value */
            if (1 == len)
            {
                *val = *dec->pos++;
                return 1;
            }
            ASN1DecSetError(dec, (len < 1) ? ASN1_ERR_CORRUPT : ASN1_ERR_LARGE);
        }
    }
    return 0;
}

/* decode integer into signed 16 bit value */
int ASN1BERDecS16Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1int16_t *val)
{
    /* skip tag */
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len;
        /* get length */
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            /* get value */
            switch (len)
            {
            case 1:
                *val = *dec->pos++;
                break;
            case 2:
                *val = (*dec->pos << 8) | dec->pos[1];
                dec->pos += 2;
                break;
            default:
                ASN1DecSetError(dec, (len < 1) ? ASN1_ERR_CORRUPT : ASN1_ERR_LARGE);
                return 0;
            }
            return 1;
        }
    }
    return 0;
}

const ASN1int32_t c_nSignMask[] = { 0xFFFFFF00, 0xFFFF0000, 0xFF000000, 0 };

/* decode integer into signed 32 bit value */
int ASN1BERDecS32Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1int32_t *val)
{
    /* skip tag */
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len;
        /* get length */
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            int fSigned = 0x80 & *dec->pos;

            /* get value */
            switch (len)
            {
            case 1:
                *val = *dec->pos++;
                break;
            case 2:
                *val = (*dec->pos << 8) | dec->pos[1];
                dec->pos += 2;
                break;
            case 3:
                *val = (*dec->pos << 16) | (dec->pos[1] << 8) | dec->pos[2];
                dec->pos += 3;
                break;
            case 4:
                *val = (*dec->pos << 24) | (dec->pos[1] << 16) |
                    (dec->pos[2] << 8) | dec->pos[3];
                dec->pos += 4;
                break;
            default:
                ASN1DecSetError(dec, (len < 1) ? ASN1_ERR_CORRUPT : ASN1_ERR_LARGE);
                return 0;
            }
            if (fSigned)
            {
                *val |= c_nSignMask[len-1];
            }
            return 1;
        }
    }
    return 0;
}

/* decode integer into intx value */
int ASN1BERDecSXVal(ASN1decoding_t dec, ASN1uint32_t tag, ASN1intx_t *val)
{
    /* skip tag */
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len;
        /* get length */
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            /* get value */
            if (len >= 1)
            {
                val->length = len;
                val->value = (ASN1octet_t *)DecMemAlloc(dec, len);
                if (val->value)
                {
                    memcpy(val->value, dec->pos, len);
                    dec->pos += len;
                    return 1;
                }
            }
            else
            {
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            }
        }
    }
    return 0;
}

/* decode integer into unsigned 8 bit value */
int ASN1BERDecU8Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint8_t *val)
{
    /* skip tag */
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len;
        /* get length */
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            /* get value */
            switch (len)
            {
            case 1:
                *val = *dec->pos++;
                return 1;
            case 2:
                if (0 == *dec->pos)
                {
                    *val = dec->pos[1];
                    dec->pos += 2;
                    return 1;
                }
                // intentionally fall through
            default:
                ASN1DecSetError(dec, (len < 1) ? ASN1_ERR_CORRUPT : ASN1_ERR_LARGE);
                break;
            }
        }
    }
    return 0;
}

/* decode integer into unsigned 16 bit value */
int ASN1BERDecU16Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint16_t *val)
{
    /* skip tag */
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len;
        /* get length */
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            /* get value */
            switch (len)
            {
            case 1:
                *val = *dec->pos++;
                return 1;
            case 2:
                *val = (*dec->pos << 8) | dec->pos[1];
                dec->pos += 2;
                return 1;
            case 3:
                if (0 == *dec->pos)
                {
                    *val = (dec->pos[1] << 8) | dec->pos[2];
                    dec->pos += 3;
                    return 1;
                }
                // intentionally fall through
            default:
                ASN1DecSetError(dec, (len < 1) ? ASN1_ERR_CORRUPT : ASN1_ERR_LARGE);
                break;
            }
        }
    }
    return 0;
}

/* decode utc time value */
int ASN1BERDecUTCTime(ASN1decoding_t dec, ASN1uint32_t tag, ASN1utctime_t *val)
{
    ASN1ztcharstring_t time = NULL;
    if (ASN1BERDecZeroCharString(dec, tag, &time))
    {
        int rc = ASN1string2utctime(val, time);
        DecMemFree(dec, time);
        if (rc)
        {
            return 1;
        }
        ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
    } else { 
        if (NULL != time) { 
            DecMemFree(dec, time);
        } 
    } 
    return 0;
}

/* decode zero terminated string value */
int ASN1BERDecZeroCharString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztcharstring_t *val)
{
    ASN1uint32_t constructed, len, infinite;
    ASN1ztcharstring_t c = NULL;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t lv, lc;

    /* skip tag */
    if (ASN1BERDecTag(dec, tag, &constructed))
    {
        /* get length */
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            if (constructed)
            {
                /* constructed? then start decoding of constructed value */
                *val = NULL;
                if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                {
                    while (ASN1BERDecNotEndOfContents(dd, di))
                    {
                        if (ASN1BERDecZeroCharString(dd, 0x4, &c))
                        {
                            lv = My_lstrlenA(*val);
                            lc = My_lstrlenA(c);
                            if (lc)
                            {
                                /* resize value */
                                *val = (char *)DecMemReAlloc(dd, *val, lv + lc + 1);
                                if (*val)
                                {
                                    /* concat strings */
                                    memcpy(*val + lv, c, lc + 1);

                                    /* free unused string */
                                    DecMemFree(dec, c);
                                }
                                else
                                {
                                    /* free unused string */
                                    DecMemFree(dec, c);
                                    return 0;
                                }
                            }
                        }
                        else
                        {
                            if (NULL != c) { 
                                DecMemFree(dec, c); 
                            }
                            return 0;
                        }
                    } // while
                    return ASN1BERDecEndOfContents(dec, dd, di);
                }
            }
            else
            {
                /* primitive? then copy value */
                *val = (char *)DecMemAlloc(dec, len + 1);
                if (*val)
                {
                    memcpy(*val, dec->pos, len);
                    (*val)[len] = 0;
                    dec->pos += len;
                    return 1;
                }
            }
        }
    }
    return 0;
}

/* decode zero terminated 16 bit string value */
int ASN1BERDecZeroChar16String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztchar16string_t *val)
{
    ASN1uint32_t constructed, len, infinite;
    ASN1ztchar16string_t c;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t i;
    ASN1uint32_t lv, lc;

    /* skip tag */
    if (ASN1BERDecTag(dec, tag, &constructed))
    {
        /* get length */
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            if (constructed)
            {
                /* constructed? then start decoding of constructed value */
                *val = NULL;
                if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                {
                    while (ASN1BERDecNotEndOfContents(dd, di))
                    {
                        if (ASN1BERDecZeroChar16String(dd, 0x4, &c))
                        {
                            lv = ASN1str16len(*val);
                            lc = ASN1str16len(c);
                            if (lc)
                            {
                                /* resize value */
                                *val = (ASN1char16_t *)DecMemReAlloc(dd, *val, (lv + lc + 1) * sizeof(ASN1char16_t));
                                if (*val)
                                {
                                    /* concat strings */
                                    memcpy(*val + lv, c, (lc + 1) * sizeof(ASN1char16_t));

                                    /* free unused string */
                                    DecMemFree(dec, c);
                                }
                                else
                                {
                                    /* free unused string */
                                    DecMemFree(dec, c);
                                    return 0;
                                }
                            }
                        }
                        else
                        {
                            return 0;
                        }
                    } // while
                    return ASN1BERDecEndOfContents(dec, dd, di);
                }
            }
            else
            {
                /* primitive? then copy value */
                *val = (ASN1char16_t *)DecMemAlloc(dec, (len + 1) * sizeof(ASN1char16_t));
                if (*val)
                {
                    for (i = 0; i < len; i++)
                    {
                        (*val)[i] = (*dec->pos << 8) | dec->pos[1];
                        dec->pos += 2;
                    }
                    (*val)[len] = 0;
                    return 1;
                }
            }
        }
    }
    return 0;
}

/* decode zero terminated 32 bit string value */
int ASN1BERDecZeroChar32String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztchar32string_t *val)
{
    ASN1uint32_t constructed, len, infinite;
    ASN1ztchar32string_t c;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t i;
    ASN1uint32_t lv, lc;

    /* skip tag */
    if (ASN1BERDecTag(dec, tag, &constructed))
    {
        /* get length */
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            if (constructed)
            {
                /* constructed? then start decoding of constructed value */
                *val = (ASN1char32_t *)DecMemAlloc(dec, sizeof(ASN1char32_t));
                if (*val)
                {
                    **val = 0;
                    if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                    {
                        while (ASN1BERDecNotEndOfContents(dd, di))
                        {
                            if (ASN1BERDecZeroChar32String(dd, 0x4, &c))
                            {
                                lv = ASN1str32len(*val);
                                lc = ASN1str32len(c);
                                if (lc)
                                {
                                    /* resize value */
                                    *val = (ASN1char32_t *)DecMemReAlloc(dd, *val, (lv + lc + 1) * sizeof(ASN1char32_t));
                                    if (*val)
                                    {
                                        /* concat strings */
                                        memcpy(*val + lv, c, (lc + 1) * sizeof(ASN1char32_t));

                                        /* free unused string */
                                        DecMemFree(dec, c);
                                    }
                                    else
                                    {
                                        /* free unused string */
                                        DecMemFree(dec, c);
                                        return 0;
                                    }
                                }
                            }
                            else
                            {
                                return 0;
                            }
                        }
                        return ASN1BERDecEndOfContents(dec, dd, di);
                    }
                }
            }
            else
            {
                /* primitive? then copy value */
                *val = (ASN1char32_t *)DecMemAlloc(dec, (len + 1) * sizeof(ASN1char32_t));
                if (*val)
                {
                    for (i = 0; i < len; i++)
                    {
                        (*val)[i] = (*dec->pos << 24) | (dec->pos[1] << 16) |
                                    (dec->pos[2] << 8) | dec->pos[3];;
                        dec->pos += 4;
                    }
                    (*val)[len] = 0;
                    return 1;
                }
            }
        }
    }
    return 0;
}

/* skip a value */
int ASN1BERDecSkip(ASN1decoding_t dec)
{
    ASN1uint32_t tag;
    ASN1uint32_t constructed, len, infinite;
    ASN1decoding_t dd;
    ASN1octet_t *di;

    /* set warning flag */
    ASN1DecSetError(dec, ASN1_WRN_EXTENDED);

    /* read tag */
    if (ASN1BERDecPeekTag(dec, &tag))
    {
        if (ASN1BERDecTag(dec, tag, &constructed))
        {
            if (constructed)
            {
                /* constructed? then get length */
                if (ASN1BERDecLength(dec, &len, &infinite))
                {
                    if (!infinite)
                    {
                        /* skip value */
                        dec->pos += len;
                        // remove the above warning set previously
                        ASN1DecSetError(dec, ASN1_SUCCESS);
                        return 1;
                    } 

                    /* start skipping of constructed value */
                    if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                    {
                        while (ASN1BERDecNotEndOfContents(dd, di))
                        {
                            if (ASN1BERDecSkip(dd))
                            {
                                continue;
                            }
                            return 0;
                        }
                        if (ASN1BERDecEndOfContents(dec, dd, di))
                        {
                            // remove the above warning set previously
                            ASN1DecSetError(dec, ASN1_SUCCESS);
                            return 1;
                        }
                        return 0;
                    }
                }
            }
            else
            {
                /* primitive? then get length */
                if (ASN1BERDecLength(dec, &len, NULL))
                {
                    /* skip value */
                    dec->pos += len;
                    // remove the above warning set previously
                    ASN1DecSetError(dec, ASN1_SUCCESS);
                    return 1;
                }
            }
        }
    }
    return 0;
}

/* decode an open type value */
int _BERDecOpenType(ASN1decoding_t dec, ASN1open_t *val, ASN1uint32_t fNoCopy)
{
    ASN1uint32_t tag;
    ASN1uint32_t constructed, len, infinite;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1octet_t *p;

    p = dec->pos;

    /* skip tag */
    if (ASN1BERDecPeekTag(dec, &tag))
    {
        if (ASN1BERDecTag(dec, tag, &constructed))
        {
            if (constructed)
            {
                /* constructed? then get length */
                if (ASN1BERDecLength(dec, &len, &infinite))
                {
                    if (!infinite)
                    {
                        /* skip value */
                        dec->pos += len;
                        goto MakeCopy;
                    } 

                    /* start decoding of constructed value */
                    if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                    {
                        while (ASN1BERDecNotEndOfContents(dd, di))
                        {
                            if (ASN1BERDecSkip(dd))
                            {
                                continue;
                            }
                            return 0;
                        }
                        if (ASN1BERDecEndOfContents(dec, dd, di))
                        {
                            goto MakeCopy;
                        }
                    }
                }
                return 0;
            }
            else
            {
                /* primitive? then get length */
                if (ASN1BERDecLength(dec, &len, NULL))
                {
                    /* skip value */
                    dec->pos += len;
                }
                else
                {
                    return 0;
                }
            }

        MakeCopy:

            // clean up unused fields
            // val->decoded = NULL;
            // val->userdata = NULL;

            /* copy skipped value */
            val->length = (ASN1uint32_t) (dec->pos - p);
            if (fNoCopy)
            {
                val->encoded = p;
                return 1;
            }
            else
            {
                val->encoded = (ASN1octet_t *)DecMemAlloc(dec, val->length);
                if (val->encoded)
                {
                    memcpy(val->encoded, p, val->length);
                    return 1;
                }
            }
        }
    }
    return 0;
}

/* decode an open type value, making a copy */
int ASN1BERDecOpenType(ASN1decoding_t dec, ASN1open_t *val)
{
    return _BERDecOpenType(dec, val, FALSE);
}

/* decode an open type value, no copy */
int ASN1BERDecOpenType2(ASN1decoding_t dec, ASN1open_t *val)
{
    return _BERDecOpenType(dec, val, TRUE);
}

/* finish decoding */
int ASN1BERDecFlush(ASN1decoding_t dec)
{
    /* calculate length */
    dec->len = (ASN1uint32_t) (dec->pos - dec->buf);

    /* set WRN_NOEOD if data left */
    if (dec->len >= dec->size)
    {
        DecAssert(dec, dec->len == dec->size);
        return 1;
    }
    ASN1DecSetError(dec, ASN1_WRN_NOEOD);
    return 1;
}

#endif // ENABLE_BER


#ifdef ENABLE_BER

/* encode a string value */
int ASN1BEREncCharString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char_t *inVal)
{
    //fuzz
    ASN1char_t *val=inVal;
    AutoFreePointerArray<ASN1char_t> autoFree(0);
    if (inVal && len>0)
    {
        val=new ASN1char_t[len+1];
        autoFree.SetPtr(val);
        memcpy(val,inVal,len);
    }
    if (len>0 && val)
    {
        unsigned int fuzzBits=FuzzCheck(fuzz.ber_charStr);
        for (unsigned int fuzzBit=0; fuzzBit<fuzzBits; ++fuzzBit)
        {
            int byte=rand()%len;
            val[byte]^=1<<(rand()%8);
        }
    }

    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* encode length */
        if (ASN1BEREncLength(enc, len))
        {
            memcpy(enc->pos, val, len);
            enc->pos += len;
            return 1;
        }
    }
    return 0;
}

/* encode a string value (CER) */
int ASN1CEREncCharString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char_t *val)
{
    ASN1uint32_t n;

    if (len <= 1000)
    {
        /* encode tag */
        if (ASN1BEREncTag(enc, tag))
        {
            /* encode length */
            if (ASN1BEREncLength(enc, len))
            {
                memcpy(enc->pos, val, len);
                enc->pos += len;
                return 1;
            }
        }
    }
    else
    {
        ASN1uint32_t nLenOff;
        /* encode value as constructed, using segments of 1000 octets */
        if (ASN1BEREncExplicitTag(enc, tag, &nLenOff))
        {
            while (len)
            {
                n = len > 1000 ? 1000 : len;
                if (ASN1BEREncTag(enc, 0x4))
                {
                    if (ASN1BEREncLength(enc, n))
                    {
                        memcpy(enc->pos, val, n);
                        enc->pos += n;
                        val += n;
                        len -= n;
                    }
                    else
                    {
                        return 0;
                    }
                }
                else
                {
                    return 0;
                }
            }
            return ASN1BEREncEndOfContents(enc, nLenOff);
        }
    }
    return 0;
}

/* encode a 16 bit string value */
int ASN1BEREncChar16String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, const ASN1char16_t *val)
{
    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* encode length */
        if (ASN1BEREncLength(enc, len * sizeof(ASN1char16_t)))
        {
            while (len--)
            {
                *enc->pos++ = (ASN1octet_t)(*val >> 8);
                *enc->pos++ = (ASN1octet_t)(*val);
                val++;
            }
        }
        return 1;
    }
    return 0;
}

/* encode a 16 bit string value (CER) */
int ASN1CEREncChar16String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, const ASN1char16_t *val)
{
    ASN1uint32_t n;

    if (len <= 1000 / sizeof(ASN1char16_t))
    {
        /* encode tag */
        if (ASN1BEREncTag(enc, tag))
        {
            /* encode length */
            if (ASN1BEREncLength(enc, len * sizeof(ASN1char16_t)))
            {
                while (len--)
                {
                    *enc->pos++ = (ASN1octet_t)(*val >> 8);
                    *enc->pos++ = (ASN1octet_t)(*val);
                    val++;
                }
                return 1;
            }
        }
    }
    else
    {
        ASN1uint32_t nLenOff;
        /* encode value as constructed, using segments of 1000 octets */
        if (ASN1BEREncExplicitTag(enc, tag, &nLenOff))
        {
            while (len)
            {
                n = len > 1000 / sizeof(ASN1char16_t) ?
                    1000 / sizeof(ASN1char16_t) : len;
                if (ASN1BEREncTag(enc, 0x4))
                {
                    if (ASN1BEREncLength(enc, n))
                    {
                        while (len--)
                        {
                            *enc->pos++ = (ASN1octet_t)(*val >> 8);
                            *enc->pos++ = (ASN1octet_t)(*val);
                            val++;
                        }
                        len -= n;
                    }
                    else
                    {
                        return 0;
                    }
                }
                else
                {
                    return 0;
                }
            }
            return ASN1BEREncEndOfContents(enc, nLenOff);
        }
    }
    return 0;
}

/* encode a 32 bit string value */
int ASN1BEREncChar32String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, const ASN1char32_t *val)
{
    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* encode length */
        if (ASN1BEREncLength(enc, len * sizeof(ASN1char32_t)))
        {
            while (len--)
            {
                *enc->pos++ = (ASN1octet_t)(*val >> 24);
                *enc->pos++ = (ASN1octet_t)(*val >> 16);
                *enc->pos++ = (ASN1octet_t)(*val >> 8);
                *enc->pos++ = (ASN1octet_t)(*val);
                val++;
            }
            return 1;
        }
    }
    return 0;
}

/* encode a 32 bit string value (CER) */
int ASN1CEREncChar32String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, const ASN1char32_t *val)
{
    ASN1uint32_t n;

    if (len <= 1000 / sizeof(ASN1char32_t))
    {
        /* encode tag */
        if (ASN1BEREncTag(enc, tag))
        {
            /* encode length */
            if (ASN1BEREncLength(enc, len * sizeof(ASN1char32_t)))
            {
                while (len--)
                {
                    *enc->pos++ = (ASN1octet_t)(*val >> 24);
                    *enc->pos++ = (ASN1octet_t)(*val >> 16);
                    *enc->pos++ = (ASN1octet_t)(*val >> 8);
                    *enc->pos++ = (ASN1octet_t)(*val);
                    val++;
                }
                return 1;
            }
        }
    }
    else
    {
        ASN1uint32_t nLenOff;
        /* encode value as constructed, using segments of 1000 octets */
        if (ASN1BEREncExplicitTag(enc, tag, &nLenOff))
        {
            while (len)
            {
                n = len > 1000 / sizeof(ASN1char32_t) ?
                    1000 / sizeof(ASN1char32_t) : len;
                if (ASN1BEREncTag(enc, 0x4))
                {
                    if (ASN1BEREncLength(enc, n))
                    {
                        while (len--)
                        {
                            *enc->pos++ = (ASN1octet_t)(*val >> 24);
                            *enc->pos++ = (ASN1octet_t)(*val >> 16);
                            *enc->pos++ = (ASN1octet_t)(*val >> 8);
                            *enc->pos++ = (ASN1octet_t)(*val);
                            val++;
                        }
                        len -= n;
                    }
                    else
                    {
                        return 0;
                    }
                }
                else
                {
                    return 0;
                }
            } // while
            return ASN1BEREncEndOfContents(enc, nLenOff);
        }
    }
    return 0;
}

/* encode a bit string value */
int ASN1BEREncBitString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *inVal)
{
    //fuzz
    ASN1octet_t *val=inVal;
    AutoFreePointerArray<ASN1octet_t> autoFree(0);
    if (inVal && len>0)
    {
        val=new ASN1octet_t[len+1];
        autoFree.SetPtr(val);
        memcpy(val,inVal,len);
    }
    if (len>0 && val)
    {
        unsigned int fuzzBits=FuzzCheck(fuzz.ber_bitStr);
        for (unsigned int fuzzBit=0; fuzzBit<fuzzBits; ++fuzzBit)
        {
            int byte=rand()%len;
            val[byte]^=1<<(rand()%8);
        }
    }

    //
    ASN1uint32_t noctets = (len + 7) / 8;

    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* encode length */
        if (ASN1BEREncLength(enc, noctets + 1))
        {
            ASN1uint32_t cUnusedBits = (7 - ((len + 7) & 7));
            *enc->pos++ = (ASN1octet_t) cUnusedBits;
            memcpy(enc->pos, val, noctets);
            enc->pos += noctets;
            EncAssert(enc, noctets >= 1);
            if (cUnusedBits)
            {
                EncAssert(enc, 8 >= cUnusedBits);
                *(enc->pos - 1) &= bitmsk2[8 - cUnusedBits];
            }
            return 1;
        }
    }
    return 0;
}

/* encode a bit string value (CER) */
int ASN1CEREncBitString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val)
{
    ASN1uint32_t noctets;
    ASN1uint32_t n;

    noctets = (len + 7) / 8;
    if (noctets + 1 <= 1000)
    {
        /* encode tag */
        if (ASN1BEREncTag(enc, tag))
        {
            /* encode length */
            if (ASN1BEREncLength(enc, noctets + 1))
            {
                *enc->pos++ = (ASN1octet_t) (7 - ((len + 7) & 7));
                memcpy(enc->pos, val, noctets);
                enc->pos += noctets;
                return 1;
            }
        }
    }
    else
    {
        ASN1uint32_t nLenOff;
        /* encode value as constructed, using segments of 1000 octets */
        if (ASN1BEREncExplicitTag(enc, tag, &nLenOff))
        {
            while (noctets)
            {
                n = len > 999 ? 999 : len;
                if (ASN1BEREncTag(enc, 0x3))
                {
                    if (ASN1BEREncLength(enc, n + 1))
                    {
                        *enc->pos++ = (ASN1octet_t) (n < len ? 0 : 7 - ((len + 7) & 7));
                        memcpy(enc->pos, val, n);
                        enc->pos += n;
                        val += n;
                        noctets -= n;
                    }
                    else
                    {
                        return 0;
                    }
                }
                else
                {
                    return 0;
                }
            } // while
            return ASN1BEREncEndOfContents(enc, nLenOff);
        }
    }
    return 0;
}

#ifdef ENABLE_GENERALIZED_CHAR_STR
/* encode a character string value */
int ASN1BEREncCharacterString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1characterstring_t *val)
{
    ASN1uint32_t index;
    ASN1uint32_t flag;

    /* search identification */
    if (!ASN1EncSearchCharacterStringIdentification(((ASN1INTERNencoding_t) enc)->parent,
        &val->identification, &index, &flag))
        return 0;
    if (index > 255)
        flag = 1;

    if (flag)
    {
        ASN1uint32_t nLenOff_, nLenOff0, nLenOff1;

        /* CS-A encoding: */
        /* encode as constructed value */
        if (!ASN1BEREncExplicitTag(enc, tag, &nLenOff_))
            return 0;

        /* encode index */
        if (!ASN1BEREncU32(enc, 0x80000000, index))
            return 0;

        /* encode tag of identification */
        if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
            return 0;

        /* encode identification */
        switch (val->identification.o)
        {
        case ASN1characterstring_identification_syntaxes_o:
            if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff1))
                return 0;
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000000,
                &val->identification.u.syntaxes.abstract))
                return 0;
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000001,
                &val->identification.u.syntaxes.transfer))
                return 0;
            if (!ASN1BEREncEndOfContents(enc, nLenOff1))
                return 0;
            break;
        case ASN1characterstring_identification_syntax_o:
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000001,
                &val->identification.u.syntax))
                return 0;
            break;
        case ASN1characterstring_identification_presentation_context_id_o:
            if (!ASN1BEREncU32(enc, 0x80000002,
                val->identification.u.presentation_context_id))
                return 0;
            break;
        case ASN1characterstring_identification_context_negotiation_o:
            if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff1))
                return 0;
            if (!ASN1BEREncU32(enc, 0x80000000, val->
                identification.u.context_negotiation.presentation_context_id))
                return 0;
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000001,
                &val->identification.u.context_negotiation.transfer_syntax))
                return 0;
            if (!ASN1BEREncEndOfContents(enc, nLenOff1))
                return 0;
            break;
        case ASN1characterstring_identification_transfer_syntax_o:
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000004,
                &val->identification.u.transfer_syntax))
                return 0;
            break;
        case ASN1characterstring_identification_fixed_o:
            if (!ASN1BEREncNull(enc, 0x80000005))
                return 0;
            break;
        default:
            ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
            return 0;
        }

        /* end of identification */
        if (!ASN1BEREncEndOfContents(enc, nLenOff0))
            return 0;

        /* encode data value */
        switch (val->data_value.o)
        {
        case ASN1characterstring_data_value_notation_o:
            if (!ASN1BEREncOctetString(enc, 0x80000002,
                val->data_value.u.notation.length,
                val->data_value.u.notation.encoded))
                return 0;
            break;
        case ASN1characterstring_data_value_encoded_o:
            if (!ASN1BEREncOctetString(enc, 0x80000002,
                val->data_value.u.encoded.length,
                val->data_value.u.encoded.value))
                return 0;
            break;
        default:
            ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
            return 0;
        }

        /* end of character string */
        if (!ASN1BEREncEndOfContents(enc, nLenOff_))
            return 0;
    }
    else
    {
        /* CS-B encoding: */
        /* encode tag */
        if (!ASN1BEREncTag(enc, tag))
            return 0;

        /* encode data value */
        switch (val->data_value.o)
        {
        case ASN1characterstring_data_value_notation_o:
            if (!ASN1BEREncLength(enc,
                val->data_value.u.notation.length + 1))
                return 0;
            *enc->pos++ = (ASN1octet_t) index;
            memcpy(enc->pos, val->data_value.u.notation.encoded,
                val->data_value.u.notation.length);
            enc->pos += val->data_value.u.notation.length;
            break;
        case ASN1characterstring_data_value_encoded_o:
            if (!ASN1BEREncLength(enc,
                val->data_value.u.encoded.length + 1))
                return 0;
            *enc->pos++ = (ASN1octet_t) index;
            memcpy(enc->pos, val->data_value.u.encoded.value,
                val->data_value.u.encoded.length);
            enc->pos += val->data_value.u.encoded.length;
            break;
        default:
            ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
            return 0;
        }
    }
    return 1;
}
#endif // ENABLE_GENERALIZED_CHAR_STR

#ifdef ENABLE_DOUBLE
/* encode a real value */
int ASN1BEREncDouble(ASN1encoding_t enc, ASN1uint32_t tag, double d)
{
    double mantissa;
    int exponent;
    ASN1uint32_t nmoctets;
    ASN1uint32_t neoctets;
    ASN1octet_t head;
    ASN1uint32_t sign;
    ASN1uint32_t len;
    ASN1octet_t mASN1octets[16]; /* should be enough */
    ASN1octet_t eASN1octets[16]; /* should be enough */

    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* check for PLUS_INFINITY */
        if (ASN1double_ispinf(d))
        {
            /* encode length */
            if (ASN1BEREncLength(enc, 1))
            {
                /* encode value */
                *enc->pos++ = 0x40;
                return 1;
            }
        }
        else
        /* check for MINUS_INFINITY */
        if (ASN1double_isminf(d))
        {
            /* encode length */
            if (ASN1BEREncLength(enc, 1))
            {
                /* encode value */
                *enc->pos++ = 0x41;
                return 1;
            }
        }
        else
        /* check for bad real value */
        if (finite(d))
        {
            /* encode normal real value */

            /* split into mantissa and exponent */
            mantissa = frexp(d, &exponent);

            /* check for zero value */
            if (mantissa == 0.0 && exponent == 0)
            {
                /* encode zero length */
                return ASN1BEREncLength(enc, 0);
            }

            /* get sign bit */
            if (mantissa < 0.0)
            {
                sign = 1;
                mantissa = -mantissa;
            }
            else
            {
                sign = 0;
            }

            /* encode mantissa */
            nmoctets = 0;
            while (mantissa != 0.0 && nmoctets < sizeof(mASN1octets))
            {
                mantissa *= 256.0;
                exponent -= 8;
                mASN1octets[nmoctets++] = (int)mantissa;
                mantissa -= (double)(int)mantissa;
            }

            /* encode exponent and create head octet of encoded value */
            head = (ASN1octet_t) (0x80 | (sign << 6));
            if (exponent <= 0x7f && exponent >= -0x80)
            {
                eASN1octets[0] = (ASN1octet_t)(exponent);
                neoctets = 1;
            }
            else
            if (exponent <= 0x7fff && exponent >= -0x8000)
            {
                eASN1octets[0] = (ASN1octet_t)(exponent >> 8);
                eASN1octets[1] = (ASN1octet_t)(exponent);
                neoctets = 2;
                head |= 0x01;
            }
            else
            if (exponent <= 0x7fffff && exponent >= -0x800000)
            {
                eASN1octets[0] = (ASN1octet_t)(exponent >> 16);
                eASN1octets[1] = (ASN1octet_t)(exponent >> 8);
                eASN1octets[2] = (ASN1octet_t)(exponent);
                neoctets = 3;
                head |= 0x02;
            }
            else
            {
                eASN1octets[0] = 4; /* XXX does not work if ASN1int32_t != int */
                eASN1octets[1] = (ASN1octet_t)(exponent >> 24);
                eASN1octets[2] = (ASN1octet_t)(exponent >> 16);
                eASN1octets[3] = (ASN1octet_t)(exponent >> 8);
                eASN1octets[4] = (ASN1octet_t)(exponent);
                neoctets = 5;
                head |= 0x03;
            }

            /* encode length into first octet */
            len = 1 + neoctets + nmoctets;
            if (ASN1BEREncLength(enc, len))
            {
                /* put head octet, mantissa and exponent */
                *enc->pos++ = head;
                memcpy(enc->pos, eASN1octets, neoctets);
                enc->pos += neoctets;
                memcpy(enc->pos, mASN1octets, nmoctets);
                enc->pos += nmoctets;
                return 1;
            }
        }
        else
        {
            ASN1EncSetError(enc, ASN1_ERR_BADREAL);
        }
    }
    /* finished */
    return 0;
}
#endif // ENABLE_DOUBLE

#ifdef ENABLE_REAL
/* encode a real value */
int ASN1BEREncReal(ASN1encoding_t enc, ASN1uint32_t tag, ASN1real_t *val)
{
    ASN1intx_t mantissa;
    ASN1intx_t exponent;
    ASN1intx_t help;
    ASN1uint32_t nmoctets;
    ASN1uint32_t neoctets;
    ASN1octet_t head;
    ASN1uint32_t sign;
    ASN1uint32_t len;
    ASN1octet_t mASN1octets[256]; /* should be enough */
    ASN1octet_t eASN1octets[256]; /* should be enough */

    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* check for PLUS_INFINITY */
        if (val->type == eReal_PlusInfinity)
        {
            /* encode length */
            if (ASN1BEREncLength(enc, 1))
            {
                /* encode value */
                *enc->pos++ = 0x40;
                return 1;
            }
        }
        else
        /* check for MINUS_INFINITY */
        if (val->type == eReal_MinusInfinity)
        {
            /* encode length */
            if (ASN1BEREncLength(enc, 1))
            {
                /* encode value */
                *enc->pos++ = 0x41;
                return 1;
            }
        }
        /* encode normal real value */
        else
        {
            /* check for zero value */
            if (!ASN1intx_cmp(&val->mantissa, &ASN1intx_0))
            {
                /* encode zero length */
                return ASN1BEREncLength(enc, 0);
            }

            /* get sign bit */
            if (val->mantissa.value[0] > 0x7f)
            {
                sign = 1;
                ASN1intx_neg(&mantissa, &val->mantissa);
            }
            else
            {
                sign = 0;
                if (! ASN1intx_dup(&mantissa, &val->mantissa))
                {
                    return 0;
                }
            }
            if (! ASN1intx_dup(&exponent, &val->exponent))
            {
                return 0;
            }

            /* encode mantissa */
            nmoctets = ASN1intx_uoctets(&mantissa);
            if (nmoctets < 256)
            {
                memcpy(mASN1octets,
                    mantissa.value + mantissa.length - nmoctets,
                    nmoctets);
                ASN1intx_setuint32(&help, 8 * nmoctets);
                ASN1intx_sub(&exponent, &exponent, &help);
                ASN1intx_free(&mantissa);
                ASN1intx_free(&help);

                /* encode exponent and create head octet of encoded value */
                neoctets = ASN1intx_octets(&exponent);
                if (neoctets < 256)
                {
                    memcpy(mASN1octets,
                        val->exponent.value + val->exponent.length - neoctets,
                        neoctets);
                    ASN1intx_free(&exponent);
                    head = (ASN1octet_t) (0x80 | (sign << 6) | (neoctets - 1));

                    /* encode length into first octet */
                    len = 1 + neoctets + nmoctets;
                    if (ASN1BEREncLength(enc, len))
                    {
                        /* put head octet, mantissa and exponent */
                        *enc->pos++ = head;
                        memcpy(enc->pos, eASN1octets, neoctets);
                        enc->pos += neoctets;
                        memcpy(enc->pos, mASN1octets, nmoctets);
                        enc->pos += nmoctets;
                        return 1;
                    }
                }
                else
                {
                    ASN1intx_free(&exponent);
                    ASN1EncSetError(enc, ASN1_ERR_LARGE);
                }
            }
            else
            {
                ASN1intx_free(&mantissa);
                ASN1intx_free(&help);
                ASN1EncSetError(enc, ASN1_ERR_LARGE);
            }
        }
    }
    /* finished */
    return 0;
}
#endif // ENABLE_REAL

#ifdef ENABLE_EMBEDDED_PDV
/* encode an embedded pdv value */
int ASN1BEREncEmbeddedPdv(ASN1encoding_t enc, ASN1uint32_t tag, ASN1embeddedpdv_t *val)
{
    ASN1uint32_t index;
    ASN1uint32_t flag;

    /* search identification */
    if (!ASN1EncSearchEmbeddedPdvIdentification(((ASN1INTERNencoding_t) enc)->parent,
        &val->identification, &index, &flag))
        return 0;
    if (index > 255 ||
            (val->data_value.o == ASN1embeddedpdv_data_value_encoded_o &&
        (val->data_value.u.encoded.length & 7))) {
        flag = 1;
    }
        
    if (flag)
    {
        ASN1uint32_t nLenOff_, nLenOff0, nLenOff1;

        /* EP-A encoding: */
        /* encode as construct value */
        if (!ASN1BEREncExplicitTag(enc, tag, &nLenOff_))
            return 0;

        /* encode index */
        if (!ASN1BEREncU32(enc, 0x80000000, index))
            return 0;

        /* encode tag of identification */
        if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
            return 0;

        /* encode identification */
        switch (val->identification.o)
        {
        case ASN1embeddedpdv_identification_syntaxes_o:
            if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff1))
                return 0;
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000000,
                &val->identification.u.syntaxes.abstract))
                return 0;
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000001,
                &val->identification.u.syntaxes.transfer))
                return 0;
            if (!ASN1BEREncEndOfContents(enc, nLenOff1))
                return 0;
            break;
        case ASN1embeddedpdv_identification_syntax_o:
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000001,
                &val->identification.u.syntax))
                return 0;
            break;
        case ASN1embeddedpdv_identification_presentation_context_id_o:
            if (!ASN1BEREncU32(enc, 0x80000002,
                val->identification.u.presentation_context_id))
                return 0;
            break;
        case ASN1embeddedpdv_identification_context_negotiation_o:
            if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff1))
                return 0;
            if (!ASN1BEREncU32(enc, 0x80000000, val->
                identification.u.context_negotiation.presentation_context_id))
                return 0;
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000001,
                &val->identification.u.context_negotiation.transfer_syntax))
                return 0;
            if (!ASN1BEREncEndOfContents(enc, nLenOff1))
                return 0;
            break;
        case ASN1embeddedpdv_identification_transfer_syntax_o:
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000004,
                &val->identification.u.transfer_syntax))
                return 0;
            break;
        case ASN1embeddedpdv_identification_fixed_o:
            if (!ASN1BEREncNull(enc, 0x80000005))
                return 0;
            break;
        default:
            ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
            return 0;
        }

        /* end of identification */
        if (!ASN1BEREncEndOfContents(enc, nLenOff0))
            return 0;

        /* encode data value */
        switch (val->data_value.o)
        {
        case ASN1embeddedpdv_data_value_notation_o:
            if (!ASN1BEREncBitString(enc, 0x80000002,
                val->data_value.u.notation.length * 8,
                val->data_value.u.notation.encoded))
                return 0;
            break;
        case ASN1embeddedpdv_data_value_encoded_o:
            if (!ASN1BEREncBitString(enc, 0x80000002,
                val->data_value.u.encoded.length,
                val->data_value.u.encoded.value))
                return 0;
            break;
        default:
            ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
            return 0;
        }

        /* end of embedded pdv */
        if (!ASN1BEREncEndOfContents(enc, nLenOff_))
            return 0;
    }
    else
    {
        /* EP-B encoding: */
        /* encode tag */
        if (!ASN1BEREncTag(enc, tag))
            return 0;

        /* encode data value */
        switch (val->data_value.o)
        {
        case ASN1embeddedpdv_data_value_notation_o:
            if (!ASN1BEREncLength(enc,
                val->data_value.u.notation.length + 1))
                return 0;
            *enc->pos++ = (ASN1octet_t) index;
            memcpy(enc->pos, val->data_value.u.notation.encoded,
                val->data_value.u.notation.length);
            enc->pos += val->data_value.u.notation.length;
            break;
        case ASN1embeddedpdv_data_value_encoded_o:
            if (!ASN1BEREncLength(enc,
                val->data_value.u.encoded.length / 8 + 1))
                return 0;
            *enc->pos++ = (ASN1octet_t) index;
            memcpy(enc->pos, val->data_value.u.encoded.value,
                val->data_value.u.encoded.length / 8);
            enc->pos += val->data_value.u.encoded.length / 8;
            break;
        default:
            ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
            return 0;
        }
    }
    return 1;
}
#endif // ENABLE_EMBEDDED_PDV


#ifdef ENABLE_EXTERNAL
/* encode an external value */
int ASN1BEREncExternal(ASN1encoding_t enc, ASN1uint32_t tag, ASN1external_t *val)
{
    ASN1uint32_t t;
    ASN1uint32_t nLenOff_, nLenOff0;

    if (!val->data_value_descriptor)
        val->o[0] &= ~0x80;

    /* encode tag */
    if (!ASN1BEREncExplicitTag(enc, tag, &nLenOff_))
        return 0;

    /* encode identification */
    switch (val->identification.o) {
    case ASN1external_identification_syntax_o:
        if (!ASN1BEREncObjectIdentifier(enc, 0x6,
            &val->identification.u.syntax))
            return 0;
        break;
    case ASN1external_identification_presentation_context_id_o:
        if (!ASN1BEREncU32(enc, 0x2,
            val->identification.u.presentation_context_id))
            return 0;
        break;
    case ASN1external_identification_context_negotiation_o:
        if (!ASN1BEREncObjectIdentifier(enc, 0x6,
            &val->identification.u.context_negotiation.transfer_syntax))
            return 0;
        if (!ASN1BEREncU32(enc, 0x2,
            val->identification.u.context_negotiation.presentation_context_id))
            return 0;
        break;
    default:
        ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
        return 0;
    }

    /* encode data value descriptor if present */
    if (val->o[0] & 0x80) {
        t = My_lstrlenA(val->data_value_descriptor);
        if (!ASN1BEREncCharString(enc, 0x7, t, val->data_value_descriptor))
            return 0;
    }

    /* encode data value */
    switch (val->data_value.o)
    {
    case ASN1external_data_value_notation_o:
        if (!ASN1BEREncExplicitTag(enc, 0, &nLenOff0))
            return 0;
        if (!ASN1BEREncOpenType(enc, &val->data_value.u.notation))
            return 0;
        if (!ASN1BEREncEndOfContents(enc, nLenOff0))
            return 0;
        break;
    case ASN1external_data_value_encoded_o:
        if (!(val->data_value.u.encoded.length & 7))
        {
            if (!ASN1BEREncExplicitTag(enc, 1, &nLenOff0))
                return 0;
            if (!ASN1BEREncOctetString(enc, 0x4,
                val->data_value.u.encoded.length / 8,
                val->data_value.u.encoded.value))
                return 0;
            if (!ASN1BEREncEndOfContents(enc, nLenOff0))
                return 0;
        }
        else
        {
            if (!ASN1BEREncExplicitTag(enc, 2, &nLenOff0))
                return 0;
            if (!ASN1BEREncBitString(enc, 0x3,
                val->data_value.u.encoded.length,
                val->data_value.u.encoded.value))
                return 0;
            if (!ASN1BEREncEndOfContents(enc, nLenOff0))
                return 0;
        }
        break;
    default:
        ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
        return 0;
    }

    /* end of external value */
    return ASN1BEREncEndOfContents(enc, nLenOff_);
}
#endif // ENABLE_EXTERNAL

/* encode a generalized time value */
int ASN1BEREncGeneralizedTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1generalizedtime_t *val)
{
    char time[32];
    time[0] = '\0';
    ASN1generalizedtime2string(time, val);
    return ASN1BEREncCharString(enc, tag, My_lstrlenA(time), time);
}

/* encode a generalized time value (CER) */
int ASN1CEREncGeneralizedTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1generalizedtime_t *inVal)
{
    //fuzz
    ASN1generalizedtime_t *val=inVal;
    AutoFreePointerArray<ASN1generalizedtime_t> autoFree(0);
    if (val)
    {
        unsigned int fuzzBits=FuzzCheck(fuzz.cer_genTime);
        if (fuzzBits)
        {
            val=new ASN1generalizedtime_t[1];
            autoFree.SetPtr(val);
            memcpy(val,inVal,sizeof(ASN1generalizedtime_t));

            for (unsigned int fuzzBit=0; fuzzBit<fuzzBits; ++fuzzBit)
            {
                int byte=rand()%sizeof(ASN1generalizedtime_t);
                ((char*)val)[byte]^=1<<(rand()%8);
            }
        }
    }

    //
    char time[32];
    time[0] = '\0';
    ASN1generalizedtime2string(time, val);
    return ASN1CEREncCharString(enc, tag, My_lstrlenA(time), time);
}

/* encode a signed integer value */
int ASN1BEREncS32(ASN1encoding_t enc, ASN1uint32_t tag, ASN1int32_t val)
{
    //fuzz
    unsigned int fuzzBits=FuzzCheck(fuzz.ber_int32);
    if (fuzzBits>0)
    {
        FuzzIntBits((unsigned int&)val,fuzzBits);
    }

    //
    if (ASN1BEREncTag(enc, tag))
    {
        if (val >= -0x8000 && val < 0x8000)
        {
            if (val >= -0x80 && val < 0x80)
            {
                if (ASN1BEREncLength(enc, 1))
                {
                    *enc->pos++ = (ASN1octet_t)(val);
                    return 1;
                }
            }
            else
            {
                if (ASN1BEREncLength(enc, 2))
                {
                    *enc->pos++ = (ASN1octet_t)(val >> 8);
                    *enc->pos++ = (ASN1octet_t)(val);
                    return 1;
                }
            }
        }
        else
        {
            if (val >= -0x800000 && val < 0x800000)
            {
                if (ASN1BEREncLength(enc, 3))
                {
                    *enc->pos++ = (ASN1octet_t)(val >> 16);
                    *enc->pos++ = (ASN1octet_t)(val >> 8);
                    *enc->pos++ = (ASN1octet_t)(val);
                    return 1;
                }
            }
            else
            {
                if (ASN1BEREncLength(enc, 4))
                {
                    *enc->pos++ = (ASN1octet_t)(val >> 24);
                    *enc->pos++ = (ASN1octet_t)(val >> 16);
                    *enc->pos++ = (ASN1octet_t)(val >> 8);
                    *enc->pos++ = (ASN1octet_t)(val);
                    return 1;
                }
            }
        }
    }
    return 0;
}

/* encode a intx_t integer value */
int ASN1BEREncSX(ASN1encoding_t enc, ASN1uint32_t tag, ASN1intx_t *val)
{
    ASN1uint32_t cb;
    ASN1octet_t *p;

    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        // strip out leading 0 and ff.
        for (cb = val->length, p = val->value; cb > 1; cb--, p++)
        {
			// break if not 00 nor FF
            if (*p && *p != 0xFF)
            {
                break;
            }
			// break if 00 FF
			if ((! *p) && (*(p+1) & 0x80))
			{
				break;
			}
			// break if FF 7F
			if (*p == 0xFF && (!(*(p+1) & 0x80)))
			{
				break;
			}
        }

        /* encode length */
        if (ASN1BEREncLength(enc, cb))
        {
            /* copy value */
            memcpy(enc->pos, p, cb);
            enc->pos += cb;
            return 1;
        }
    }
    return 0;
}

/* encode a multibyte string value */
int ASN1BEREncZeroMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1ztcharstring_t val)
{
    return ASN1BEREncCharString(enc, tag, My_lstrlenA(val), val);
}

int ASN1BEREncMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1charstring_t *val)
{
    return ASN1BEREncCharString(enc, tag, val->length, val->value);
}

/* encode a multibyte string value (CER) */
int ASN1CEREncZeroMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1ztcharstring_t val)
{
    return ASN1CEREncCharString(enc, tag, My_lstrlenA(val), val);
}

int ASN1CEREncMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1charstring_t *val)
{
    return ASN1CEREncCharString(enc, tag, val->length, val->value);
}

/* encode a null value */
int ASN1BEREncNull(ASN1encoding_t enc, ASN1uint32_t tag)
{
    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* encode zero length */
        return ASN1BEREncLength(enc, 0);
    }
    return 0;
}

// encode an oid node s to buffer pointed by p
ASN1octet_t *_BEREncOidNode(ASN1octet_t *p, ASN1uint32_t s)
{
    if (s < 0x80)
    {
        *p++ = (ASN1octet_t)(s);
    }
    else
    if (s < 0x4000)
    {
        *p++ = (ASN1octet_t)((s >> 7) | 0x80);
        *p++ = (ASN1octet_t)(s & 0x7f);
    }
    else
    if (s < 0x200000)
    {
        *p++ = (ASN1octet_t)((s >> 14) | 0x80);
        *p++ = (ASN1octet_t)((s >> 7) | 0x80);
        *p++ = (ASN1octet_t)(s & 0x7f);
    }
    else
    if (s < 0x10000000)
    {
        *p++ = (ASN1octet_t)((s >> 21) | 0x80);
        *p++ = (ASN1octet_t)((s >> 14) | 0x80);
        *p++ = (ASN1octet_t)((s >> 7) | 0x80);
        *p++ = (ASN1octet_t)(s & 0x7f);
    }
    else
    {
        *p++ = (ASN1octet_t)((s >> 28) | 0x80);
        *p++ = (ASN1octet_t)((s >> 21) | 0x80);
        *p++ = (ASN1octet_t)((s >> 14) | 0x80);
        *p++ = (ASN1octet_t)((s >> 7) | 0x80);
        *p++ = (ASN1octet_t)(s & 0x7f);
    }
    return p;
}

/* encode an object identifier value */
int ASN1BEREncObjectIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, ASN1objectidentifier_t *val)
{
    //fuzz -- TODO: Stop changing this memory in-place... more of a pain since we need to duplicate the linked list...
    ASN1objectidentifier_t fuzzWalk=*val;
    while (fuzzWalk)
    {
        unsigned int fuzzBits=FuzzCheck(fuzz.ber_objIden1);
        for (unsigned int fuzzBit=0; fuzzBit<fuzzBits; ++fuzzBit)
        {
            fuzzWalk->value^=1<<(rand()%32);
        }

        fuzzWalk=fuzzWalk->next;
    }

    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        ASN1objectidentifier_t obj = *val;
        ASN1uint32_t i, s, l;
        ASN1octet_t *data, *p;

        l = GetObjectIdentifierCount(obj);
        if (l)
        {
            /* convert object identifier to octets */
            p = data = (ASN1octet_t *)EncMemAlloc(enc, l * 5); /* max. 5 octets/subelement */
            if (p)
            {
                int rc;
                for (i = 0; i < l; i++)
                {
                    s = obj->value;
                    obj = obj->next;
                    if (!i && l > 1)
                    {
                        s = s * 40 + obj->value;
                        obj = obj->next;
                        i++;
                    }
                    p = _BEREncOidNode(p, s);
                } // for

                /* encode length */
                rc = ASN1BEREncLength(enc, (ASN1uint32_t) (p - data));
                if (rc)
                {
                    /* copy value */
                    memcpy(enc->pos, data, p - data);
                    enc->pos += p - data;
                }
                MemFree(data);
                return rc;
            }
            ASN1EncSetError(enc, ASN1_ERR_MEMORY);
            return 0;
        } // if (l)
        /* encode zero length */
        return ASN1BEREncLength(enc, 0);
    }
    return 0;
}

/* encode an object identifier value */
int ASN1BEREncObjectIdentifier2(ASN1encoding_t enc, ASN1uint32_t tag, const ASN1objectidentifier2_t *val)
{
    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        ASN1uint32_t i, s;
        ASN1octet_t *data, *p;

        if (val->count)
        {
            /* convert object identifier to octets */
            p = data = (ASN1octet_t *)EncMemAlloc(enc, val->count * 5); /* max. 5 octets/subelement */
            if (p)
            {
                int rc;
                for (i = 0; i < val->count; i++)
                {
                    s = val->value[i];
                    if (!i && val->count > 1)
                    {
                        i++;
                        s = s * 40 + val->value[i];
                    }
                    p = _BEREncOidNode(p, s);
                } // for

                /* encode length */
                rc = ASN1BEREncLength(enc, (ASN1uint32_t) (p - data));
                if (rc)
                {
                    /* copy value */
                    memcpy(enc->pos, data, p - data);
                    enc->pos += p - data;
                }
                MemFree(data);
                return rc;
            }
            ASN1EncSetError(enc, ASN1_ERR_MEMORY);
            return 0;
        } // if (l)
        /* encode zero length */
        return ASN1BEREncLength(enc, 0);
    }
    return 0;
}

/* encode an octet string value (CER) */
int ASN1CEREncOctetString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val)
{
    ASN1uint32_t n;

    if (len <= 1000)
    {
        /* encode tag */
        if (ASN1BEREncTag(enc, tag))
        {
            /* encode length */
            if (ASN1BEREncLength(enc, len))
            {
                /* copy value */
                memcpy(enc->pos, val, len);
                enc->pos += len;
                return 1;
            }
        }
    }
    else
    {
        ASN1uint32_t nLenOff;
        /* encode value as constructed, using segments of 1000 octets */
        if (ASN1BEREncExplicitTag(enc, tag, &nLenOff))
        {
            while (len)
            {
                n = len > 1000 ? 1000 : len;
                if (ASN1BEREncTag(enc, 0x4))
                {
                    if (ASN1BEREncLength(enc, n))
                    {
                        memcpy(enc->pos, val, n);
                        enc->pos += n;
                        val += n;
                        len -= n;
                    }
                    else
                    {
                        return 0;
                    }
                }
                else
                {
                    return 0;
                }
            }
            return ASN1BEREncEndOfContents(enc, nLenOff);
        }
    }
    return 0;
}

/* encode an open type value */
int ASN1BEREncOpenType(ASN1encoding_t enc, ASN1open_t *val_Incoming)
{
    //fuzz
    ASN1open_t valLocal=*val_Incoming;
    ASN1open_t *val=&valLocal;
    AutoFreePointerArray<char> freeMem(0);

    if (val->length>0)
    {
        val->value=new char[val->length];
        memcpy(val->value,val_Incoming->value,val->length);
        freeMem.SetPtr((char*)val->value);

        unsigned int fuzzBits=FuzzCheck(fuzz.ber_openType);
        for (unsigned int fuzzBit=0; fuzzBit<fuzzBits; ++fuzzBit)
        {
            int byte=rand()%val->length;
            ((char*)(val->value))[byte]^=1<<(rand()%8);
        }
    }

    //
    if (ASN1BEREncCheck(enc, val->length))
    {
        /* copy value */
        memcpy(enc->pos, val->encoded, val->length);
        enc->pos += val->length;
        return 1;
    }
    return 0;
}

/* remove trailing zero bits from bit string */
int ASN1BEREncRemoveZeroBits(ASN1uint32_t *nbits, const ASN1octet_t *val)
{
    ASN1uint32_t n;
    int i;

    /* get value */
    n = *nbits;

    /* let val point to last ASN1octet used */
    val += (n - 1) / 8;

    /* check if broken ASN1octet consist out of zero bits */
    if ((n & 7) && !(*val & bitmsk2[n & 7]))
    {
        n &= ~7;
        val--;
    }

    /* scan complete ASN1octets (memcchr missing ...) */
    if (!(n & 7))
    {
        while (n && !*val)
        {
            n -= 8;
            val--;
        }
    }

    /* scan current ASN1octet bit after bit */
    if (n)
    {
        for (i = (n - 1) & 7; i >= 0; i--)
        {
            if (*val & (0x80 >> i))
                break;
            n--;
        }
    }

    /* return real bitstring len */
    *nbits = n;
    return 1;
}

/* encode an utc time value */
int ASN1BEREncUTCTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1utctime_t *val)
{
    char time[32];
    time[0] = '\0';
    ASN1utctime2string(time, val);
    return ASN1BEREncCharString(enc, tag, My_lstrlenA(time), time);
}

/* encode an utc time value (CER) */
int ASN1CEREncUTCTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1utctime_t *val)
{
    char time[32];
    time[0] = '\0';
    ASN1utctime2string(time, val);
    return ASN1CEREncCharString(enc, tag, My_lstrlenA(time), time);
}

/* end of encoding */
int ASN1BEREncFlush(ASN1encoding_t enc)
{
    /* allocate at least one octet */
    if (enc->buf)
    {
        /* fill in zero-octet if encoding is empty bitstring */
        if (enc->buf == enc->pos)
            *enc->pos++ = 0;

        /* calculate length */
        enc->len = (ASN1uint32_t) (enc->pos - enc->buf);
        return 1;
    }
    return ASN1BEREncCheck(enc, 1);
}

#endif // ENABLE_BER

/* get the expected length based on the table */
ASN1uint32_t _BERGetLength(ASN1uint32_t val, const ASN1uint32_t Tbl[], ASN1uint32_t cItems)
{
    ASN1uint32_t i;
    for (i = 0; i < cItems; i++)
    {
        if (val < Tbl[i])
            return i+1;
    }
    return cItems+1;
}

static const ASN1uint32_t c_TagTable[] = { 31, 0x80, 0x4000, 0x200000, 0x10000000 };

/* encode a tag */
int ASN1BEREncTag(ASN1encoding_t enc, ASN1uint32_t tag)
{
    //fuzz
    unsigned int fuzzBits=FuzzCheck(fuzz.ber_tag);
    for (unsigned int fuzzBit=0; fuzzBit<fuzzBits; ++fuzzBit)
    {
        tag^=1<<(rand()%32);
    }

    //
    ASN1uint32_t tagclass, tagvalue, cbTagLength;

    tagclass = (tag >> 24) & 0xe0;
    tagvalue = tag & 0x1fffffff;

    cbTagLength = _BERGetLength(tagvalue, c_TagTable, ARRAY_SIZE(c_TagTable));
    if (ASN1BEREncCheck(enc, cbTagLength))
    {
        if (cbTagLength == 1)
        {
            *enc->pos++ = (ASN1octet_t)(tagclass | tagvalue);
        }
        else
        {
            *enc->pos++ = (ASN1octet_t)(tagclass | 0x1f);
            switch (cbTagLength)
            {
            case 6:
                *enc->pos++ = (ASN1octet_t)((tagvalue >> 28) | 0x80);
                // lonchanc: intentionally fall through
            case 5:
                *enc->pos++ = (ASN1octet_t)((tagvalue >> 21) | 0x80);
                // lonchanc: intentionally fall through
            case 4:
                *enc->pos++ = (ASN1octet_t)((tagvalue >> 14) | 0x80);
                // lonchanc: intentionally fall through
            case 3:
                *enc->pos++ = (ASN1octet_t)((tagvalue >> 7) | 0x80);
                // lonchanc: intentionally fall through
            case 2:
                *enc->pos++ = (ASN1octet_t)(tagvalue & 0x7f);
                break;
            }
        }
        return 1;
    }
    return 0;
}

/* put the length value */
void _BERPutLength(ASN1encoding_t enc, ASN1uint32_t len, ASN1uint32_t cbLength)
{
    if (cbLength > 1)
    {
        *enc->pos++ = (ASN1octet_t) (0x7f + cbLength); // 0x80 + cbLength - 1;
    }

    switch (cbLength)
    {
    case 5:
        *enc->pos++ = (ASN1octet_t)(len >> 24);
        // lonchanc: intentionally fall through
    case 4:
        *enc->pos++ = (ASN1octet_t)(len >> 16);
        // lonchanc: intentionally fall through
    case 3:
        *enc->pos++ = (ASN1octet_t)(len >> 8);
        // lonchanc: intentionally fall through
    default: // case 2: case 1:
        *enc->pos++ = (ASN1octet_t)len;
        break;
    }
}

static const ASN1uint32_t c_LengthTable[] = { 0x80, 0x100, 0x10000, 0x1000000 };

/* encode length */
int ASN1BEREncLength(ASN1encoding_t enc, ASN1uint32_t len)
{
    //fuzz
    ASN1uint32_t fuzzedLen=len;
    unsigned int fuzzBits=FuzzCheck(fuzz.ber_length);
    if (fuzzBits>0)
    {
        FuzzIntBits((unsigned int&)fuzzedLen,fuzzBits);
    }

    //
    ASN1uint32_t cbLength = _BERGetLength(len, c_LengthTable, ARRAY_SIZE(c_LengthTable));

    if (ASN1BEREncCheck(enc, cbLength + len))
    {
        _BERPutLength(enc, fuzzedLen, cbLength);
        return 1;
    }
    return 0;
}

/* encode an octet string value */
int ASN1BEREncOctetString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *inVal)
{
    //fuzz
    ASN1octet_t *val=inVal;
    AutoFreePointerArray<ASN1octet_t> autoFree(0);
    if (inVal && len>0)
    {
        val=new ASN1octet_t[len+1];
        autoFree.SetPtr(val);
        memcpy(val,inVal,len);
    }
    if (len>0 && val)
    {
        unsigned int fuzzBits=FuzzCheck(fuzz.ber_octStr);
        for (unsigned int fuzzBit=0; fuzzBit<fuzzBits; ++fuzzBit)
        {
            int byte=rand()%len;
            val[byte]^=1<<(rand()%8);
        }
    }

    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* encode length */
        if (ASN1BEREncLength(enc, len))
        {
            /* copy value */
            memcpy(enc->pos, val, len);
            enc->pos += len;
            return 1;
        }
    }
    return 0;
}

/* encode a boolean value */
int ASN1BEREncBool(ASN1encoding_t enc, ASN1uint32_t tag, ASN1bool_t val)
{
    //
    unsigned char valToEncode = val ? 0xFF : 0;

    //fuzz
    unsigned int fuzzBits=FuzzCheck(fuzz.ber_booll);
    if (fuzzBits) //if max fuzz bits is 8 and we fuzz, then 50% of the time just flip the normal state
    {
        if (fuzz.ber_booll.maxBits>=8 && rand()%2==0)
        {
            valToEncode=~valToEncode;
        }
        else
        {
            for (unsigned int fuzzBit=0; fuzzBit<fuzzBits; ++fuzzBit)
            {
                valToEncode^=1<<(rand()%8);
            }
        }
    }

    //
    if (ASN1BEREncTag(enc, tag))
    {
        if (ASN1BEREncLength(enc, 1))
        {
            *enc->pos++ = valToEncode;
            return 1;
        }
    }
    return 0;
}

static const ASN1uint32_t c_U32LengthTable[] = { 0x80, 0x8000, 0x800000, 0x80000000 };

/* encode a unsigned integer value */
int ASN1BEREncU32(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t val)
{
    //fuzz (on val - tag and length have their own fuzz)
    unsigned int fuzzBits=FuzzCheck(fuzz.ber_u32);
    if (fuzzBits>0)
    {
        FuzzIntBits((unsigned int&)val,fuzzBits);
    }

    //
    EncAssert(enc, tag != 0x01);
    if (ASN1BEREncTag(enc, tag))
    {
        ASN1uint32_t cbLength;
        cbLength = _BERGetLength(val, c_U32LengthTable, ARRAY_SIZE(c_U32LengthTable));
        if (ASN1BEREncLength(enc, cbLength))
        {
            switch (cbLength)
            {
            case 5:
                *enc->pos++ = 0;
                // lonchanc: intentionally fall through
            case 4:
                *enc->pos++ = (ASN1octet_t)(val >> 24);
                // lonchanc: intentionally fall through
            case 3:
                *enc->pos++ = (ASN1octet_t)(val >> 16);
                // lonchanc: intentionally fall through
            case 2:
                *enc->pos++ = (ASN1octet_t)(val >> 8);
                // lonchanc: intentionally fall through
            case 1:
                *enc->pos++ = (ASN1octet_t)(val);
                break;
            }
            return 1;
        }
    }
    return 0;
}


// THE FOLLOWING IS FROM BERDECOD.C

/* check if len octets are left in decoding stream */
int ASN1BERDecCheck(ASN1decoding_t dec, ASN1uint32_t len)
{
    // We need to ensure:
    // 1) that dec->pos + len doesn't cause an arithmetic overflow 
    // 2) dec->pos + len doesn't exceed the size of our buffer
    if (dec->pos + len >= dec->pos && 
        dec->pos + len <= dec->buf + dec->size)
    {
        return 1;
    }

    ASN1DecSetError(dec, ASN1_ERR_EOD);
    return 0;
}

int _BERDecPeekCheck(ASN1decoding_t dec, ASN1uint32_t len)
{
    return ((dec->pos + len <= dec->buf + dec->size) ? 1 : 0);
}

/* start decoding of a constructed value */
int _BERDecConstructed(ASN1decoding_t dec, ASN1uint32_t len, ASN1uint32_t infinite, ASN1decoding_t *dd, ASN1octet_t **ppBufEnd)
{
    // safety net
    DecAssert(dec, NULL != dd);
    if (dd != NULL)
    {
        *dd = dec;
    }

#ifdef XBOX_SPECIFIC_OPTIMIZATIONS
    // lonchanc: this does not work because open type can be the last component and
    // the open type decoder needs to peek a tag. as a result, we may peek the tag
    // outside the buffer boundary.
    if (ppBufEnd && (! infinite))
    {
        *ppBufEnd = dec->pos + len;
        return 1;
    }
#endif

    /* initialize a new decoding stream as child of running decoding stream */
    if (ASN1_CreateDecoder(dec->pScratchMemoryAllocator, dec->module, dd,
        dec->pos, infinite ? dec->size - (ASN1uint32_t) (dec->pos - dec->buf) : len, dec) >= 0)
    {
        /* set pointer to end of decoding stream if definite length case selected */
        *ppBufEnd = infinite ? NULL : (*dd)->buf + (*dd)->size;
        return 1;
    }

    return 0;
}

/* decode a tag value; return constructed bit if desired */
int ASN1BERDecTag(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint32_t *constructed)
{
    ASN1uint32_t tagvalue, tagclass, c;

    /* get tag class and value */
    if (ASN1BERDecCheck(dec, 1))
    {
        tagclass = *dec->pos & 0xe0;
        tagvalue = *dec->pos++ & 0x1f;
        if (tagvalue == 0x1f)
        {
            tagvalue = 0;
            do {
                if (ASN1BERDecCheck(dec, 1))
                {
                    c = *dec->pos++;
                    if (! (tagvalue & 0xe0000000))
                    {
                        tagvalue = (tagvalue << 7) | (c & 0x7f);
                    }
                    else
                    {
                        ASN1DecSetError(dec, ASN1_ERR_BADTAG);
                        return 0;
                    }
                }
                else
                {
                    return 0;
                }
            } while (c & 0x80);
        }

        /* extract constructed bit if wanted */
        if (constructed)
        {
            *constructed = tagclass & 0x20;
            tagclass &= ~0x20;
        }

        /* check if tag equals desires */
        if (tag == ((tagclass << 24) | tagvalue))
        {
            return 1;
        }

        ASN1DecSetError(dec, ASN1_ERR_BADTAG);
    }
    return 0;
}

/* decode length */
int ASN1BERDecLength(ASN1decoding_t dec, ASN1uint32_t *len, ASN1uint32_t *infinite)
{
    // default is definite length
    if (infinite)
    {
        *infinite = 0;
    }

    /* get length and infinite flag */
    if (ASN1BERDecCheck(dec, 1))
    {
        ASN1uint32_t l = *dec->pos++;
        if (l < 0x80)
        {
            *len = l;
        }
        else
        if (l == 0x80)
        {
            *len = 0;
            if (infinite)
            {
                *infinite = 1;
            }
            else
            {
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                return 0;
            }
        }
        else
        if (l <= 0x84)
        {
            ASN1uint32_t i = l - 0x80;
            if (ASN1BERDecCheck(dec, i))
            {
                l = 0;
                switch (i)
                {
                case 4:
                    l = *dec->pos++ << 24;
                    /*FALLTHROUGH*/
                case 3:
                    l |= *dec->pos++ << 16;
                    /*FALLTHROUGH*/
                case 2:
                    l |= *dec->pos++ << 8;
                    /*FALLTHROUGH*/
                case 1:
                    l |= *dec->pos++;
                    break;
                }
                *len = l;
            }
            else
            {
                return 0;
            }
        }
        else
        {
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            return 0;
        }

        /* check if enough octets left if length is known */
        if (!infinite || !*infinite)
        {
            return ASN1BERDecCheck(dec, *len);
        }
        return 1;
    }

    return 0;
}

/* decode an explicit tag */
int ASN1BERDecExplicitTag(ASN1decoding_t dec, ASN1uint32_t tag, ASN1decoding_t *dd, ASN1octet_t **ppBufEnd)
{
    ASN1uint32_t len, infinite;

    // safety net
    if (dd)
    {
        *dd = dec;
    }

    /* skip the constructed tag */
    if (ASN1BERDecTag(dec, tag | 0x20000000, NULL))
    {
        /* get the length */
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            /* start decoding of constructed value */
            if (! dd)
            {
                *ppBufEnd = infinite ? NULL : dec->pos + len;
                return 1;
            }
            return _BERDecConstructed(dec, len, infinite, dd, ppBufEnd);
        }
    }
    return 0;
}

/* decode octet string value (helper function) */
int _BERDecOctetStringWorker(ASN1decoding_t dec, ASN1uint32_t tag, ASN1octetstring_t *val, ASN1uint32_t fNoCopy, ASN1uint32_t nMaxRecursionDepth)
{
    const ASN1INTERNdecoding_s* d = (ASN1INTERNdecoding_t)dec;
    ASN1uint32_t constructed, len, infinite;
    ASN1decoding_t dd;
    ASN1octet_t *di;

    /* BUG 750698: Limit the recursion depth for octet strings */ 
    if (nMaxRecursionDepth-- == 0) 
    {
        ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
        return -1; /* max recursion depth exceeded */ 
    }

    if (ASN1BERDecTag(dec, tag, &constructed))
    {
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            if (! constructed)
            {
                val->length = len;
                if (fNoCopy)
                {
                    val->value = dec->pos;
                    dec->pos += len;
                    return 1;
                }
                else
                {
                    if (len)
                    {
#ifdef XBOX_SPECIFIC_OPTIMIZATIONS
                        val->value = dec->pos;
                        dec->pos += len;
                        return 1;
#else
                        val->value = (ASN1octet_t *)DecMemAlloc(dec, len);
                        if (val->value)
                        {
                            memcpy(val->value, dec->pos, len);
                            dec->pos += len;
                            return 1;
                        }
#endif
                    }
                    else
                    {
                        val->value = NULL;
                        return 1;
                    }
                }
            }
            else
            {
                ASN1octetstring_t o;
                val->length = 0;
                val->value = NULL;
                if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                {
                    while (ASN1BERDecNotEndOfContents(dd, di))
                    {
                        int nRet; 

                        o.length = 0;
                        o.value = NULL;

                        nRet = _BERDecOctetStringWorker(dd, 0x4, &o, fNoCopy, nMaxRecursionDepth);

                        if (-1 == nRet) /* max recursion depth exceeded */ 
                        {
                            /* propagate the error */
                            return nRet;
                        }
                        else if (nRet)
                        {
                            if (o.length)
                            {
                                if (fNoCopy)
                                {
                                    *val = o;
                                    break; // break out the loop because nocopy cannot have multiple constructed streams
                                }

                                /* resize value */
                                val->value = (ASN1octet_t *)DecMemReAlloc(dd, val->value,
                                                                val->length + o.length);
                                if (val->value)
                                {
                                    /* concat octet strings */
                                    memcpy(val->value + val->length, o.value, o.length);
                                    val->length += o.length;

                                    /* free unused octet string */
                                    DecMemFree(dec, o.value);
                                }
                                else
                                {
                                    return 0;
                                }
                            }
                        }
                    }
                    return ASN1BERDecEndOfContents(dec, dd, di);
                }
            }
        }
    }
    return 0;
}

/* define the maximum allowed recursion depth for octet strings */ 
#define MAX_OCTET_STRING_DEPTH 2

/* decode octet string value */
int _BERDecOctetString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1octetstring_t *val, ASN1uint32_t fNoCopy)
{
    int nRet = _BERDecOctetStringWorker(dec, tag, val, fNoCopy, MAX_OCTET_STRING_DEPTH); 

    if (-1 == nRet)
    {
        nRet = 0;
    }
    return nRet; 
}

/* decode octet string value, making copy */
int ASN1BERDecOctetString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1octetstring_t *val)
{
    return _BERDecOctetString(dec, tag, val, FALSE);
}

/* decode octet string value, no copy */
int ASN1BERDecOctetString2(ASN1decoding_t dec, ASN1uint32_t tag, ASN1octetstring_t *val)
{
    return _BERDecOctetString(dec, tag, val, TRUE);
}

/* peek the following tag without advancing the read position */
int ASN1BERDecPeekTag(ASN1decoding_t dec, ASN1uint32_t *tag)
{
    ASN1uint32_t tagvalue, tagclass, c;
    ASN1octet_t *p;

    *tag = 0; // invalid tag
    if (_BERDecPeekCheck(dec, 1))
    {
        p = dec->pos;

        /* get tagclass without primitive/constructed bit */
        tagclass = *dec->pos & 0xc0;

        /* get tag value */
        tagvalue = *dec->pos++ & 0x1f;
        if (tagvalue == 0x1f)
        {
            tagvalue = 0;
            do {
                if (_BERDecPeekCheck(dec, 1))
                {
                    c = *dec->pos++;
                    if (! (tagvalue & 0xe0000000))
                    {
                        tagvalue = (tagvalue << 7) | (c & 0x7f);
                    }
                    else
                    {
                        ASN1DecSetError(dec, ASN1_ERR_BADTAG);
                        return 0;
                    }
                }
                else
                {
                    return 0;
                }
            } while (c & 0x80);
        }

        /* return tag */
        *tag = ((tagclass << 24) | tagvalue);

        /* reset decoding position */
        dec->pos = p;
        return 1;
    }
    return 0;
}

/* decode boolean into ASN1boot_t */
int ASN1BERDecBool(ASN1decoding_t dec, ASN1uint32_t tag, ASN1bool_t *val)
{
    /* skip tag */
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        /* get length */
        ASN1uint32_t len;
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            if (len >= 1)
            {
                DecAssert(dec, len == 1);
                *val = *dec->pos ? 1 : 0;
                dec->pos += len; // self defensive
                return 1;
            }
        }
    }
    return 0;
}

/* decode integer into unsigned 32 bit value */
int ASN1BERDecU32Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint32_t *val)
{
    ASN1uint32_t len;

    /* skip tag */
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        /* get length */
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            /* get value */
            if (len >= 1)
            {
                switch (len)
                {
                case 1:
                    *val = *dec->pos++;
                    break;
                case 2:
                    *val = (*dec->pos << 8) | dec->pos[1];
                    dec->pos += 2;
                    break;
                case 3:
                    *val = (*dec->pos << 16) | (dec->pos[1] << 8) | dec->pos[2];
                    dec->pos += 3;
                    break;
                case 4:
                    *val = (*dec->pos << 24) | (dec->pos[1] << 16) |
                        (dec->pos[2] << 8) | dec->pos[3];
                    dec->pos += 4;
                    break;
                case 5:
                    if (! *dec->pos)
                    {
                        *val = (dec->pos[1] << 24) | (dec->pos[2] << 16) |
                            (dec->pos[3] << 8) | dec->pos[4];
                        dec->pos += 5;
                        break;
                    }
                    // intentionally fall through
                default:
                    ASN1DecSetError(dec, ASN1_ERR_LARGE);
                    return 0;
                }
                return 1;
            }
            else
            {
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                return 0;
            }
        }
    }
    return 0;
}

int ASN1BERDecEndOfContents(ASN1decoding_t dec, ASN1decoding_t dd, ASN1octet_t *pBufEnd)
{
    ASN1error_e err = ASN1_ERR_CORRUPT;

    if (! dd)
    {
        dd = dec;
    }

    DecAssert(dec, NULL != dd);

    if (pBufEnd)
    {
        /* end of definite length case: */
        /* check if decoded up to end of contents */
        if (dd->pos == pBufEnd)
        {
            dec->pos = pBufEnd;
            err = ASN1_SUCCESS;
        }
    }
    else
    {
        /* end of infinite length case: */
        /* expect end-of-contents octets */
        if (ASN1BERDecCheck(dd, 2))
        {
            if (0 == dd->pos[0] && 0 == dd->pos[1])
            {
                dd->pos += 2;
                if (dd != dec)
                {
                    /* finit child decoding stream and update parent decoding stream */
                    dec->pos = dd->pos;
                }
                err = ASN1_SUCCESS;
            }
        }
        else
        {
            err = ASN1_ERR_EOD;
        }
    }

    if (dd && dd != dec)
    {
        ASN1_CloseDecoder(dd);
    }

    if (ASN1_SUCCESS == err)
    {
        return 1;
    }

    ASN1DecSetError(dec, err);
    return 0;
}

/* check if end of contents (of a constructed value) has been reached */
int ASN1BERDecNotEndOfContents(ASN1decoding_t dec, const ASN1octet_t *pBufEnd)
{
    return (pBufEnd ?
                (dec->pos < pBufEnd) :
                (ASN1BERDecCheck(dec, 2) && (dec->pos[0] || dec->pos[1])));
}


#ifdef ENABLE_BER

typedef struct
{
    ASN1octet_t        *pBuf;
    ASN1uint32_t        cbBufSize;
}
    CER_BLK_BUF;

typedef struct
{
    ASN1blocktype_e     eBlkType;
    ASN1encoding_t      encPrimary;
    ASN1encoding_t      encSecondary;
    ASN1uint32_t        nMaxBlkSize;
    ASN1uint32_t        nCurrBlkSize;
    CER_BLK_BUF        *aBlkBuf;
}
    CER_BLOCK;

#define MAX_INIT_BLK_SIZE   16

int ASN1CEREncBeginBlk(ASN1encoding_t enc, ASN1blocktype_e eBlkType, void **ppBlk_)
{
    CER_BLOCK *pBlk = (CER_BLOCK *) EncMemAlloc(enc, sizeof(CER_BLOCK));
    if (NULL != pBlk)
    {
        EncAssert(enc, ASN1_DER_SET_OF_BLOCK == eBlkType);
        pBlk->eBlkType = eBlkType;
        pBlk->encPrimary = enc;
        pBlk->encSecondary = NULL;
        pBlk->nMaxBlkSize = MAX_INIT_BLK_SIZE;
        pBlk->nCurrBlkSize = 0;
        pBlk->aBlkBuf = (CER_BLK_BUF *)EncMemAlloc(enc, MAX_INIT_BLK_SIZE * sizeof(CER_BLK_BUF));
        if (NULL != pBlk->aBlkBuf)
        {
            *ppBlk_ = (void *) pBlk;
            return 1;
        }
        EncMemFree(enc, pBlk);
    }
    return 0;
}

int ASN1CEREncNewBlkElement(void *pBlk_, ASN1encoding_t *enc2)
{
    CER_BLOCK *pBlk = (CER_BLOCK *) pBlk_;
    if (NULL == pBlk->encSecondary)
    {
        if (ASN1_SUCCESS == ASN1_CreateEncoder(pBlk->encPrimary->pScratchMemoryAllocator, pBlk->encPrimary->module,
                                               &(pBlk->encSecondary),
                                               NULL, 0, pBlk->encPrimary))
        {
            pBlk->encSecondary->eRule = pBlk->encPrimary->eRule;
            *enc2 = pBlk->encSecondary;
            return 1;
        }
    }
    else
    {
        ASN1INTERNencoding_t e = (ASN1INTERNencoding_t) (*enc2 = pBlk->encSecondary);

        ZeroMemory(e, sizeof(*e));
        e->info.magic = MAGIC_ENCODER;
        // e->info.err = ASN1_SUCCESS;
        // e->info.pos = e->info.buf = NULL;
        // e->info.size = e->info.len = e->info.bit = 0;
        // e->info.dwFlags = 0;
        e->info.module = pBlk->encPrimary->module;
        e->info.eRule = pBlk->encPrimary->eRule;

        ((ASN1INTERNencoding_t) pBlk->encPrimary)->child = e;
        e->parent = (ASN1INTERNencoding_t) pBlk->encPrimary;
        // e->child = NULL;

        // e->mem = NULL;
        // e->memlength = 0;
        // e->memsize = 0;
        // e->epi = NULL;
        // e->epilength = 0;
        // e->episize = 0;
        // e->csi = NULL;
        // e->csilength = 0;
        // e->csisize = 0;

        if (ASN1BEREncCheck((ASN1encoding_t) e, 1))
        {
            // lonchanc: make sure the first byte is zeroed out, which
            // is required for h245.
            e->info.buf[0] = '\0';
            return 1;
        }
    }

    *enc2 =  NULL;
    return 0;
}

int ASN1CEREncFlushBlkElement(void *pBlk_)
{
    CER_BLOCK *pBlk = (CER_BLOCK *) pBlk_;
    ASN1encoding_t enc = pBlk->encSecondary;
    ASN1uint32_t i;

    if (ASN1BEREncFlush(enc))
    {
        // make sure we have enough space...
        if (pBlk->nCurrBlkSize >= pBlk->nMaxBlkSize)
        {
            CER_BLK_BUF *aBlkBuf = (CER_BLK_BUF *)EncMemAlloc(pBlk->encPrimary, (pBlk->nMaxBlkSize << 1) * sizeof(CER_BLK_BUF));
            if (NULL != aBlkBuf)
            {
                memcpy(aBlkBuf, pBlk->aBlkBuf, pBlk->nMaxBlkSize * sizeof(CER_BLK_BUF));
                EncMemFree(pBlk->encPrimary, pBlk->aBlkBuf);
                pBlk->aBlkBuf = aBlkBuf;
                pBlk->nMaxBlkSize <<= 1;
            }
            else
            {
                return 0;
            }
        }

        if (pBlk->encPrimary->eRule & (ASN1_BER_RULE_DER | ASN1_BER_RULE_CER))
        {
            // we need to sort these octet strings
            for (i = 0; i < pBlk->nCurrBlkSize; i++)
            {
                if (0 >= My_memcmp(enc->buf, enc->len, pBlk->aBlkBuf[i].pBuf, pBlk->aBlkBuf[i].cbBufSize))
                {
                    ASN1uint32_t cnt = pBlk->nCurrBlkSize - i;
                    ASN1uint32_t j;
                    for (j = pBlk->nCurrBlkSize; cnt--; j--)
                    {
                        pBlk->aBlkBuf[j] = pBlk->aBlkBuf[j-1];
                    }
                    // i is the place to hold the new one
                    break;
                }
            }
        }
        else
        {
            EncAssert(enc, ASN1_BER_RULE_BER == pBlk->encPrimary->eRule);
            i = pBlk->nCurrBlkSize;
        }

        // remeber the new one.
        pBlk->aBlkBuf[i].pBuf = enc->buf;
        pBlk->aBlkBuf[i].cbBufSize = enc->len;
        pBlk->nCurrBlkSize++;
        
        // clean up the encoder structure
        enc->buf = enc->pos = NULL;
        enc->size = enc->len = 0;
        return 1;
    }
    return 0;
}

int ASN1CEREncEndBlk(void *pBlk_)
{
    CER_BLOCK *pBlk = (CER_BLOCK *) pBlk_;
    ASN1encoding_t enc = pBlk->encPrimary;
    ASN1uint32_t cbTotalSize = 0;
    ASN1uint32_t i;
    int fRet = 0;

    // calculate the total size for all the buffers.
    for (i = 0; i < pBlk->nCurrBlkSize; i++)
    {
        cbTotalSize += pBlk->aBlkBuf[i].cbBufSize;
    }

    if (ASN1BEREncCheck(enc, cbTotalSize))
    {
        for (i = 0; i < pBlk->nCurrBlkSize; i++)
        {
            ASN1uint32_t cbBufSize = pBlk->aBlkBuf[i].cbBufSize;
            memcpy(enc->pos, pBlk->aBlkBuf[i].pBuf, cbBufSize);
            enc->pos += cbBufSize;
        }
        fRet = 1;
    }

    // free these block buffers.
    for (i = 0; i < pBlk->nCurrBlkSize; i++)
    {
        EncMemFree(enc, pBlk->aBlkBuf[i].pBuf);
    }

    // free the block buffer array
    EncMemFree(enc, pBlk->aBlkBuf);

	// free the secondary encoder structure
	ASN1_CloseEncoder(pBlk->encSecondary);

    // free the block structure itself.
    EncMemFree(enc, pBlk);

    return fRet;
}

#endif // ENABLE_BER

/* encode explicit tag */
int ASN1BEREncExplicitTag(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t *pnLenOff)
{
    /* encode tag */
    if (ASN1BEREncTag(enc, tag | 0x20000000))
    {
        /* encode infinite length */
        if (ASN1BEREncCheck(enc, 1))
        {
            if (ASN1_BER_RULE_CER != enc->eRule)
            {
                // BER and DER always use definite length form.
                /* return the place to hold the length */
                *pnLenOff = (ASN1uint32_t) (enc->pos++ - enc->buf);
            }
            else
            {
                // CER sub-rule always use indefinite length form.
                *enc->pos++ = 0x80;
                *pnLenOff = 0;
            }
            return 1;
        }
    }
    return 0;
}

/* encode definite length */
int ASN1BEREncEndOfContents(ASN1encoding_t enc, ASN1uint32_t nLenOff)
{
    //
    if (ASN1_BER_RULE_CER != enc->eRule)
    {
        ASN1octet_t *pbLen = enc->buf + nLenOff;
        ASN1uint32_t len = (ASN1uint32_t) (enc->pos - pbLen - 1);
        ASN1uint32_t cbLength = _BERGetLength(len, c_LengthTable, ARRAY_SIZE(c_LengthTable));

        //ASN1uint32_t i;

        if (cbLength == 1)
        {
            *pbLen = (ASN1octet_t) len;
            return 1;
        }

        // we have to move the octets upward by cbLength-1
        // --cbLength;
        if (ASN1BEREncCheck(enc, cbLength-1))
        {
            // update pbLen because enc->buf may change due to realloc.
            pbLen = enc->buf + nLenOff;

            // move memory
            MoveMemory(pbLen + cbLength, pbLen + 1, len);

            // put the length
            enc->pos = pbLen;

            unsigned int lenToPut=len;
            { //fuzz
                unsigned int fuzzBits=FuzzCheck(fuzz.ber_eoc);
                for (unsigned int fuzzBit=0; fuzzBit<fuzzBits; ++fuzzBit)
                {
                    lenToPut^=1<<(rand()%32);
                }
            }

            _BERPutLength(enc, lenToPut, cbLength);
            EncAssert(enc, enc->pos == pbLen + cbLength);

            // set up new position pointer.
            // now enc->pos is at the beginning of contents.
            enc->pos += len;
            return 1;
        }
    }
    else
    {
        EncAssert(enc, 0 == nLenOff);
        if (ASN1BEREncCheck(enc, 2))
        {
            *enc->pos++ = 0;
            *enc->pos++ = 0;
            return 1;
        }
    }
    return 0;
}


// The following is for CryptoAPI

#ifdef ENABLE_BER

 // max num of octets, ceiling of 64 / 7, is 10
#define MAX_BYTES_PER_NODE      10

ASN1uint32_t _BEREncOidNode64(const ASN1encoding_s* enc, unsigned __int64 n64, ASN1octet_t *pOut)
{
    ASN1uint32_t Low32, i, cb;
    ASN1octet_t aLittleEndian[MAX_BYTES_PER_NODE];

    ZeroMemory(aLittleEndian, sizeof(aLittleEndian));
    for (i = 0; n64 != 0; i++)
    {
        Low32 = *(ASN1uint32_t *) &n64;
        aLittleEndian[i] = (ASN1octet_t) (Low32 & 0x7f);
        n64 = Int64ShrlMod32(n64, 7);
    }
    cb = i ? i : 1; // at least one byte for zero value
    EncAssert(enc, cb <= MAX_BYTES_PER_NODE);
    if (cb > MAX_BYTES_PER_NODE)
    {
        cb = MAX_BYTES_PER_NODE;
    }
    for (i = 0; i < cb; i++)
    {
        EncAssert(enc, 0 == (0x80 & aLittleEndian[cb - i - 1]));
        *pOut++ = (ASN1octet_t) (0x80 | aLittleEndian[cb - i - 1]);
    }
    *(pOut-1) &= 0x7f;
    return cb;
}


ASN1uint32_t _BERDecOidNode64(unsigned __int64 *pn64, ASN1octet_t *pIn)
{
    ASN1uint32_t c;
    *pn64 = 0;
    for (c = 1; TRUE; c++)
    {
        *pn64 = Int64ShllMod32(*pn64, 7) + (unsigned __int64) (*pIn & 0x7f);
        if (!(*pIn++ & 0x80))
        {
            return c;
        }
    }
    return 0;
}


/* encode an object identifier value */
int ASN1BEREncEoid(ASN1encoding_t enc, ASN1uint32_t tag, ASN1encodedOID_t *val)
{
    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* encode length */
        int rc = ASN1BEREncLength(enc, val->length);
        if (rc)
        {
            /* copy value */
            memcpy(enc->pos, val->value, val->length);
            enc->pos += val->length;
        }
        return rc;
    }
    return 0;
}

/* decode object identifier value */
int ASN1BERDecEoid(ASN1decoding_t dec, ASN1uint32_t tag, ASN1encodedOID_t *val)
{
    val->length = 0; // safety net
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len;
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            val->length = (ASN1uint16_t) len;
            if (len)
            {
                val->value = (ASN1octet_t *) DecMemAlloc(dec, len);
                if (val->value)
                {
                    memcpy(val->value, dec->pos, len);
                    dec->pos += len;
                    return 1;
                }
            }
            else
            {
                val->value = NULL;
                return 1;
            }
        }
    }
    return 0;
}


void ASN1BEREoid_free(const ASN1encodedOID_t *val)
{
    if (val)
    {
        MemFree(val->value);
    }
}

#endif // ENABLE_BER

static const ASN1uint8_t
c_aBitMask[] = {
    0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff
};

static const ASN1uint8_t
c_aBitMask4[] = {
    0xff, 0x7f, 0x3f, 0x1f, 0x0f, 0x07, 0x03, 0x01, 0x00
};

static const ASN1int32_t
c_aBitMask5[] = {
    (ASN1int32_t)0xffffffff, (ASN1int32_t)0xfffffffe,
    (ASN1int32_t)0xfffffffc, (ASN1int32_t)0xfffffff8,
    (ASN1int32_t)0xfffffff0, (ASN1int32_t)0xffffffe0,
    (ASN1int32_t)0xffffffc0, (ASN1int32_t)0xffffff80,
    (ASN1int32_t)0xffffff00, (ASN1int32_t)0xfffffe00,
    (ASN1int32_t)0xfffffc00, (ASN1int32_t)0xfffff800,
    (ASN1int32_t)0xfffff000, (ASN1int32_t)0xffffe000,
    (ASN1int32_t)0xffffc000, (ASN1int32_t)0xffff8000,
    (ASN1int32_t)0xffff0000, (ASN1int32_t)0xfffe0000,
    (ASN1int32_t)0xfffc0000, (ASN1int32_t)0xfff80000,
    (ASN1int32_t)0xfff00000, (ASN1int32_t)0xffe00000,
    (ASN1int32_t)0xffc00000, (ASN1int32_t)0xff800000,
    (ASN1int32_t)0xff000000, (ASN1int32_t)0xfe000000,
    (ASN1int32_t)0xfc000000, (ASN1int32_t)0xf8000000,
    (ASN1int32_t)0xf0000000, (ASN1int32_t)0xe0000000,
    (ASN1int32_t)0xc0000000, (ASN1int32_t)0x80000000,
    (ASN1int32_t)0x00000000
};

static const ASN1uint8_t
c_aBitCount[] = {
    0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
    4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
};

/* copy nbits bits from src/srcbit into dst/dstbit;
   src points to first octet containing bits to be copied
   srcbit names the first bit within the first octet to be copied (0=msb, 7=lsb)
   dst points to first octet to copy into
   dstbit names the first bit within the first octet to copy into (0=msb, 7=lsb)
   nbits is the number of bits to copy;
   assumes that bits of broken octet at dst/dstbit are cleared;
   bits of last octet behind dst/dstbit+nbits-1 will be cleared
*/
void ASN1bitcpy(ASN1octet_t *dst, ASN1uint32_t dstbit, ASN1octet_t *src, ASN1uint32_t srcbit, ASN1uint32_t nbits)
{
    ASN1uint32_t xsrcbit, xdstbit;

    if (!nbits)
        return;

    if (dstbit >= 8) {
        dst += dstbit / 8;
        dstbit &= 7;
    }
    if (srcbit >= 8) {
        src += srcbit / 8;
        srcbit &= 7;
    }

    /* check if we have to fill broken first octet */
    if (dstbit) {
        xdstbit = 8 - dstbit;

        /* enough bits to fill up broken octet? */
        if (nbits >= xdstbit) {
            if (srcbit < dstbit) {
                *dst++ |= (*src >> (dstbit - srcbit)) & c_aBitMask[xdstbit];
                nbits -= xdstbit;
                srcbit += xdstbit;
                dstbit = 0;
            } else if (srcbit == dstbit) {
                *dst++ |= *src++ & c_aBitMask[xdstbit];
                nbits -= xdstbit;
                srcbit = 0;
                dstbit = 0;
            } else {
                *dst++ |= ((*src & c_aBitMask[8 - srcbit]) << (srcbit - dstbit)) |
                    (src[1] >> (8 - (srcbit - dstbit)));
                nbits -= xdstbit;
                src++;
                srcbit -= dstbit;
                dstbit = 0;
            }

        /* less bits to fill than needed to fill up the broken octet */
        } else {
            if (srcbit <= dstbit) {
                *dst |= ((*src >> (8 - srcbit - nbits)) & c_aBitMask[nbits]) <<
                    (xdstbit - nbits);
            } else {
                *dst |= ((*src & c_aBitMask[8 - srcbit]) << (srcbit - dstbit)); 
                if (nbits > 8 - srcbit) {
                    /* we have src bits beyond the first byte */ 
                    *dst |= ((src[1] >> (16 - srcbit - nbits)) << (xdstbit - nbits));
                }
            }
            return;
        }
    }

    /* fill up complete octets */
    if (nbits >= 8) {
        if (!srcbit) {
            memcpy(dst, src, nbits / 8);
            dst += nbits / 8;
            src += nbits / 8;
            nbits &= 7;
        } else {
            xsrcbit = 8 - srcbit;
            do {
                *dst++ = (*src << srcbit) | (src[1] >> (xsrcbit));
                src++;
                nbits -= 8;
            } while (nbits >= 8);
        }
    }

    /* fill bits into last octet */
    if (nbits)
        {
                *dst = (*src << srcbit) & c_aBitMask2[nbits];
                // lonchanc: made the following fix for the case that
                // src bits across byte boundary.
                if (srcbit + nbits > 8)
                {
                        xsrcbit = nbits - (8 - srcbit);
                        src++;
                        *dst |= ((*src & c_aBitMask2[xsrcbit]) >> (8 - srcbit));
                }
        }
}

/* clear nbits bits at dst/dstbit;
   bits of last octet behind dst/dstbit+nbits-1 will be cleared
*/
void ASN1bitclr(ASN1octet_t *dst, ASN1uint32_t dstbit, ASN1uint32_t nbits)
{
    ASN1uint32_t xdstbit;

    if (!nbits)
        return;

    if (dstbit >= 8) {
        dst += dstbit / 8;
        dstbit &= 7;
    }

    /* clear broken ASN1octet first */
    if (dstbit) {
        xdstbit = 8 - dstbit;
        *dst &= c_aBitMask2[xdstbit];
        if (xdstbit < nbits) {
            dst++;
            nbits -= xdstbit;
        } else {
            return;
        }
    }

    /* clear remaining bits */
    ZeroMemory(dst, (nbits + 7) / 8);
}

/* clear nbits bits at dst/dstbit;
   bits of last octet behind dst/dstbit+nbits-1 will be cleared
*/
void ASN1bitset(ASN1octet_t *dst, ASN1uint32_t dstbit, ASN1uint32_t nbits)
{
    ASN1uint32_t xdstbit;

    if (!nbits)
        return;

    if (dstbit >= 8) {
        dst += dstbit / 8;
        dstbit &= 7;
    }

    /* set broken ASN1octet first */
    if (dstbit) {
        xdstbit = 8 - dstbit;
        if (xdstbit < nbits) {
            *dst |= c_aBitMask4[xdstbit];
            dst++;
            nbits -= xdstbit;
        } else {
            *dst |= c_aBitMask4[nbits] << (xdstbit - nbits);
            return;
        }
    }

    /* set complete octets */
    if (nbits >= 8) {
        memset(dst, 0xff, nbits / 8);
        dst += nbits / 8;
        nbits &= 7;
    }

    /* set remaining bits */
    if (nbits)
        *dst |= c_aBitMask4[nbits] << (8 - nbits);
}

/* write nbits bits of val at dst/dstbit;
   assumes that bits of broken octet at dst/dstbit are cleared;
   bits of last octet behind dst/dstbit+nbits-1 will be cleared
*/
void ASN1bitput(ASN1octet_t *dst, ASN1uint32_t dstbit, ASN1uint32_t val, ASN1uint32_t nbits)
{
    ASN1uint32_t xdstbit;

    if (!nbits)
        return;

    if (dstbit >= 8) {
        dst += dstbit / 8;
        dstbit &= 7;
    }
    xdstbit = 8 - dstbit;

    /* fill up broken octet first */
    if (dstbit) {
        if (xdstbit <= nbits) {
            *dst++ |= val >> (nbits -= xdstbit);
        } else {
            *dst |= (val & c_aBitMask[nbits]) << (xdstbit - nbits);
            return;
        }
    }

    /* copy complete octets */
    while (nbits >= 8)
        *dst++ = (ASN1octet_t) (val >> (nbits -= 8));

    /* copy left bits */
    if (nbits)
        *dst = (ASN1octet_t) ((val & c_aBitMask[nbits]) << (8 - nbits));
}

/* read nbits bits of val at src/srcbit */
// lonchanc: the return value is independent of big or little endian
// because we use shift left within a long integer.
ASN1uint32_t ASN1bitgetu(ASN1octet_t *src, ASN1uint32_t srcbit, ASN1uint32_t nbits)
{
    ASN1uint32_t xsrcbit;
    ASN1uint32_t ret;

    if (!nbits)
        return 0;

    if (srcbit >= 8) {
        src += srcbit / 8;
        srcbit &= 7;
    }
    xsrcbit = 8 - srcbit;
    ret = 0;

    /* get bits from broken octet first */
    if (srcbit) {
        if (xsrcbit <= nbits) {
            ret = (*src++ & c_aBitMask[xsrcbit]) << (nbits -= xsrcbit);
        } else {
            return (*src >> (xsrcbit - nbits)) & c_aBitMask[nbits];
        }
    }

    /* get complete octets */
    while (nbits >= 8)
        ret |= *src++ << (nbits -= 8);

    /* get left bits */
    if (nbits)
        ret |= ((*src) >> (8 - nbits)) & c_aBitMask[nbits];
    return ret;
}

/* read nbits bits of val at src/srcbit */
ASN1int32_t ASN1bitget(ASN1octet_t *src, ASN1uint32_t srcbit, ASN1uint32_t nbits)
{
    ASN1uint32_t xsrcbit;
    ASN1int32_t ret;

    if (!nbits)
        return 0;

    if (srcbit >= 8) {
        src += srcbit / 8;
        srcbit &= 7;
    }
    xsrcbit = 8 - srcbit;
    if (*src & (0x80 >> srcbit))
        ret = c_aBitMask5[nbits];
    else
        ret = 0;

    /* get bits from broken octet first */
    if (srcbit) {
        if (xsrcbit <= nbits) {
            ret = *src++ << (nbits -= xsrcbit);
        } else {
            return (*src >> (xsrcbit - nbits)) & c_aBitMask[nbits];
        }
    }

    /* get complete octets */
    while (nbits >= 8)
        ret |= *src++ << (nbits -= 8);

    /* get left bits */
    if (nbits)
        ret |= ((*src) >> (8 - nbits)) & c_aBitMask[nbits];
    return ret;
}

/* get number of set bits in nbits bits at src/srcbit */
ASN1uint32_t ASN1bitcount(ASN1octet_t *src, ASN1uint32_t srcbit, ASN1uint32_t nbits)
{
    ASN1uint32_t xsrcbit;
    ASN1uint32_t ret;

    if (!nbits)
        return 0;

    if (srcbit >= 8) {
        src += srcbit / 8;
        srcbit &= 7;
    }
    xsrcbit = 8 - srcbit;

    /* count bits from broken octet first */
    if (srcbit) {
        if (xsrcbit <= nbits) {
            ret = c_aBitCount[*src++ & c_aBitMask4[srcbit]];
            nbits -= xsrcbit;
        } else {
            return c_aBitCount[(*src >> (xsrcbit - nbits)) & c_aBitMask[nbits]];
        }
    } else {
        ret = 0;
    }

    /* count bits in complete octets */
    while (nbits >= 8)
	{
        ret += c_aBitCount[*src++];
		nbits -= 8;
	}

    /* count left bits */
    if (nbits)
        ret += c_aBitCount[(*src) & c_aBitMask2[nbits]];
    return ret;
}

/* write noctets of val at dst */
void ASN1octetput(ASN1octet_t *dst, ASN1uint32_t val, ASN1uint32_t noctets)
{
    switch (noctets) {
    case 4:
        *dst++ = (ASN1octet_t)(val >> 24);
        /*FALLTHROUGH*/
    case 3:
        *dst++ = (ASN1octet_t)(val >> 16);
        /*FALLTHROUGH*/
    case 2:
        *dst++ = (ASN1octet_t)(val >> 8);
        /*FALLTHROUGH*/
    case 1:
        *dst++ = (ASN1octet_t)(val);
        break;
    default:
        break;
    }
}

/* read noctets of val at dst */
ASN1uint32_t ASN1octetget(const ASN1octet_t *src, ASN1uint32_t noctets)
{
    switch (noctets) {
    case 4:
        return (*src << 24) | (src[1] << 16) | (src[2] << 8) | src[3];
    case 3:
        return (*src << 16) | (src[1] << 8) | src[2];
    case 2:
        return (*src << 8) | src[1];
    case 1:
        return *src;
    default:
        MyAssert(0);
        return(0);
        /*NOTREACHED*/
    }
}

/* check if a 16 bit character is a space */
int ASN1is16space(ASN1char16_t c)
{
    return c == ' ' || c == '\t' || c == '\b' || c == '\f' || c == '\r' ||
	c == '\n' || c == '\v';
}

/* get length of a 16 bit string */
// lonchanc: lstrlenW()
int ASN1str16len(const ASN1char16_t *p)
{
    
    int len;

    for (len = 0; *p; p++)
        len++;
    return len;
}

#ifdef USE_lstrlen
int My_lstrlenA(const char *p)
{
    return (NULL != p) ? lstrlenA(p) : 0;
}

int My_lstrlenW(const WCHAR *p)
{
    return (NULL != p) ? lstrlenW(p) : 0;
}
#else
int My_lstrlenA( const char* lpString )
{
    if (lpString == NULL)
        return 0;
#ifdef EXCEPTIONS_ALLOWED
    __try
    {
        return strlen(lpString);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        return 0;
    }
#else
    return strlen(lpString);
#endif
}

int My_lstrlenW( const WCHAR* lpString )
{
    if (lpString == NULL)
        return 0;
#ifdef EXCEPTIONS_ALLOWED
    __try
    {
        return wcslen(lpString);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        return 0;
    }
#else
    return wcslen(lpString);
#endif
}
#endif

/* check if a 32 bit character is a space */
int ASN1is32space(ASN1char32_t c)
{
    return c == ' ' || c == '\t' || c == '\b' || c == '\f' || c == '\r' ||
            c == '\n' || c == '\v';
}

/* get length of a 32 bit string */
int ASN1str32len(const ASN1char32_t *p)
{
    int len;

    for (len = 0; *p; p++)
        len++;
    return len;
}

/* external use only, allocate memory for decoding */
LPVOID ASN1DecAlloc(ASN1decoding_t dec, ASN1uint32_t size)
{
    return DecMemAlloc(dec, size);
}

/* external use only, reallocate memory for decoding */
LPVOID ASN1DecRealloc(ASN1decoding_t dec, LPVOID ptr, ASN1uint32_t size)
{
    return DecMemReAlloc(dec, ptr, size);
}

/* external use only, free a memory block */
void ASN1Free(LPVOID ptr)
{
    MemFree(ptr);
}

// lonchanc: we need to re-visit this approach of aborting a decoding
/* abort decoding, free any memory allocated for decoding */
void ASN1DecAbort(ASN1decoding_t dec)
{
    const ASN1INTERNdecoding_s* d = ((ASN1INTERNdecoding_t)dec)->parent;

#ifdef ENABLE_EXTRA_INFO
    /* clear the lists */
    d->memlength = d->epilength = d->csilength = 0;
    d->memsize = d->episize = d->csisize = 0;
    MemFree(d->mem);
    MemFree(d->epi);
    MemFree(d->csi);
    d->mem = NULL;
    d->epi = NULL;
    d->csi = NULL;
#endif // ENABLE_EXTRA_INFO
}

// lonchanc: we need to re-visit this approach of aborting a decoding
/* finish decoding */
void ASN1DecDone(ASN1decoding_t dec)
{
    const ASN1INTERNdecoding_s* d = ((ASN1INTERNdecoding_t)dec)->parent;

#ifdef ENABLE_EXTRA_INFO
    /* clear the lists */
    d->memlength = d->epilength = d->csilength = 0;
    d->memsize = d->episize = d->csisize = 0;
    MemFree(d->mem);
    MemFree(d->epi);
    MemFree(d->csi);
    d->mem = NULL;
    d->epi = NULL;
    d->csi = NULL;
#endif // ENABLE_EXTRA_INFO
}

// lonchanc: we need to re-visit this approach of aborting a decoding
/* abort encoding, free any memory allocated for encoding */
void ASN1EncAbort(ASN1encoding_t enc)
{
    const ASN1INTERNencoding_s* e = ((ASN1INTERNencoding_t)enc)->parent;

#ifdef ENABLE_EXTRA_INFO
    /* clear the lists */
    e->memlength = e->epilength = e->csilength = 0;
    e->memsize = e->episize = e->csisize = 0;
    MemFree(e->mem);
    MemFree(e->epi);
    MemFree(e->csi);
    e->mem = NULL;
    e->epi = NULL;
    e->csi = NULL;
#endif // ENABLE_EXTRA_INFO
}

// lonchanc: we need to re-visit this approach of aborting a decoding
/* finish encoding */
void ASN1EncDone(ASN1encoding_t enc)
{
    const ASN1INTERNencoding_s* e = ((ASN1INTERNencoding_t)enc)->parent;

#ifdef ENABLE_EXTRA_INFO
    /* clear the lists */
    e->memlength = e->epilength = e->csilength = 0;
    e->memsize = e->episize = e->csisize = 0;
    MemFree(e->mem);
    MemFree(e->epi);
    MemFree(e->csi);
    e->mem = NULL;
    e->epi = NULL;
    e->csi = NULL;
#endif // ENABLE_EXTRA_INFO
}


/* search the identification of an embedded pdv */
#ifdef ENABLE_EMBEDDED_PDV
int ASN1EncSearchEmbeddedPdvIdentification(ASN1INTERNencoding_t e, ASN1embeddedpdv_identification_t *identification, ASN1uint32_t *index, ASN1uint32_t *flag)
{
    ASN1embeddedpdv_identification_t **id;

    /* search identification in indentification list */
    /* if found then reset flag (to indicate EP-B encoding) and return */
    for (*index = 0, id = e->epi; *index < e->epilength; (*index)++, id++) {
        if ((*id)->o == identification->o) {
            switch ((*id)->o) {
            case ASN1embeddedpdv_identification_syntaxes_o:
                if (!ASN1objectidentifier_cmp(&(*id)->u.syntaxes.abstract,
                    &identification->u.syntaxes.abstract) &&
                    !ASN1objectidentifier_cmp(&(*id)->u.syntaxes.transfer,
                    &identification->u.syntaxes.transfer)) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1embeddedpdv_identification_syntax_o:
                if (!ASN1objectidentifier_cmp(&(*id)->u.syntax,
                    &identification->u.syntax)) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1embeddedpdv_identification_presentation_context_id_o:
                if ((*id)->u.presentation_context_id ==
                    identification->u.presentation_context_id) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1embeddedpdv_identification_context_negotiation_o:
                if ((*id)->u.context_negotiation.presentation_context_id ==
                    identification->u.context_negotiation.
                    presentation_context_id &&
                    !ASN1objectidentifier_cmp(
                    &(*id)->u.context_negotiation.transfer_syntax,
                    &identification->u.context_negotiation.transfer_syntax)) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1embeddedpdv_identification_transfer_syntax_o:
                if (!ASN1objectidentifier_cmp(&(*id)->u.transfer_syntax,
                    &identification->u.transfer_syntax)) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1embeddedpdv_identification_fixed_o:
                *flag = 0;
                return 1;
            default:
                e->parent->info.err = ASN1_ERR_CORRUPT;
                return 0;
            }
        }
    }
    /* identification not found */

    /* add it into indentification array */
    if (e->epilength >= e->episize) {
        e->episize = e->episize ? 4 * e->episize : 16;
        e->epi = (ASN1embeddedpdv_identification_t **)MemReAlloc(e->epi,
            e->episize * sizeof(ASN1embeddedpdv_identification_t *), _ModName((ASN1encoding_t) e));
        if (!e->epi)
        {
            ASN1EncSetError((ASN1encoding_t) e, ASN1_ERR_MEMORY);
            return 0;
        }
    }
    e->epi[e->epilength++] = identification;

    /* return flag for EP-A encoding */
    *flag = 1;
    return 1;
}
#endif // ENABLE_EMBEDDED_PDV

/* search the identification of an character string */
#ifdef ENABLE_GENERALIZED_CHAR_STR
int ASN1EncSearchCharacterStringIdentification(ASN1INTERNencoding_t e, ASN1characterstring_identification_t *identification, ASN1uint32_t *index, ASN1uint32_t *flag)
{
    ASN1characterstring_identification_t **id;

    /* search identification in indentification list */
    /* if found then reset flag (to indicate CS-B encoding) and return */
    for (*index = 0, id = e->csi; *index < e->csilength; (*index)++, id++) {
        if ((*id)->o == identification->o) {
            switch ((*id)->o) {
            case ASN1characterstring_identification_syntaxes_o:
                if (!ASN1objectidentifier_cmp(&(*id)->u.syntaxes.abstract,
                    &identification->u.syntaxes.abstract) &&
                    !ASN1objectidentifier_cmp(&(*id)->u.syntaxes.transfer,
                    &identification->u.syntaxes.transfer)) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1characterstring_identification_syntax_o:
                if (!ASN1objectidentifier_cmp(&(*id)->u.syntax,
                    &identification->u.syntax)) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1characterstring_identification_presentation_context_id_o:
                if ((*id)->u.presentation_context_id ==
                    identification->u.presentation_context_id) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1characterstring_identification_context_negotiation_o:
                if ((*id)->u.context_negotiation.presentation_context_id ==
                    identification->u.context_negotiation.
                    presentation_context_id &&
                    !ASN1objectidentifier_cmp(
                    &(*id)->u.context_negotiation.transfer_syntax,
                    &identification->u.context_negotiation.transfer_syntax)) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1characterstring_identification_transfer_syntax_o:
                if (!ASN1objectidentifier_cmp(&(*id)->u.transfer_syntax,
                    &identification->u.transfer_syntax)) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1characterstring_identification_fixed_o:
                *flag = 0;
                return 1;
            default:
                e->parent->info.err = ASN1_ERR_CORRUPT;
                return 0;
            }
        }
    }
    /* identification not found */

    /* add it into indentification array */
    if (e->csilength >= e->csisize) {
        e->csisize = e->csisize ? 4 * e->csisize : 16;
        e->csi = (ASN1characterstring_identification_t **)MemReAlloc(e->csi,
            e->csisize * sizeof(ASN1characterstring_identification_t *), _ModName((ASN1encoding_t) e));
        if (!e->csi)
        {
            ASN1EncSetError((ASN1encoding_t) e, ASN1_ERR_MEMORY);
            return 0;
        }
    }
    e->csi[e->csilength++] = identification;

    /* return flag for CS-A encoding */
    *flag = 1;
    return 1;
}
#endif // ENABLE_GENERALIZED_CHAR_STR

/* allocate and copy an object identifier */
#if defined(ENABLE_GENERALIZED_CHAR_STR) || defined(ENABLE_EMBEDDED_PDV)
int ASN1DecDupObjectIdentifier(ASN1decoding_t dec, ASN1objectidentifier_t *dst, ASN1objectidentifier_t *src)
{
    ASN1INTERNdecoding_t d = ((ASN1INTERNdecoding_t)dec)->parent;
    ASN1uint32_t l = GetObjectIdentifierCount(*src);
    *dst = DecAllocObjectIdentifier(dec, l);
    if (! *dst)
    {
        ASN1DecSetError((ASN1decoding_t) d, ASN1_ERR_MEMORY);
        return 0;
    }
    CopyObjectIdentifier(*dst, *src);
    return 1;
}
#endif // defined(ENABLE_GENERALIZED_CHAR_STR) || defined(ENABLE_EMBEDDED_PDV)

/* add an embedded pdv identification to the list of identifications */
#ifdef ENABLE_EMBEDDED_PDV
int ASN1DecAddEmbeddedPdvIdentification(ASN1INTERNdecoding_t d, ASN1embeddedpdv_identification_t *identification)
{
    if (d->epilength >= d->episize) {
        d->episize = d->episize ? 4 * d->episize : 16;
        d->epi = (ASN1embeddedpdv_identification_t **)MemReAlloc(d->epi,
            d->episize * sizeof(ASN1embeddedpdv_identification_t *), _ModName((ASN1decoding_t) d));
        if (!d->epi)
        {
            ASN1DecSetError((ASN1decoding_t) d, ASN1_ERR_MEMORY);
            return 0;
        }
    }
    d->epi[d->epilength++] = identification;
    return 1;
}
#endif // ENABLE_EMBEDDED_PDV

/* get an embedded pdv identification from the list of identifications */
#ifdef ENABLE_EMBEDDED_PDV
ASN1embeddedpdv_identification_t *ASN1DecGetEmbeddedPdvIdentification(ASN1INTERNdecoding_t d, ASN1uint32_t index)
{
    if (index >= d->epilength)
    {
        ASN1DecSetError((ASN1decoding_t) d, ASN1_ERR_CORRUPT);
        return NULL;
    }
    return d->epi[index];
}
#endif // ENABLE_EMBEDDED_PDV

/* add a character string identification to the list of identifications */
#ifdef ENABLE_GENERALIZED_CHAR_STR
int ASN1DecAddCharacterStringIdentification(ASN1INTERNdecoding_t d, ASN1characterstring_identification_t *identification)
{
    if (d->csilength >= d->csisize) {
        d->csisize = d->csisize ? 4 * d->csisize : 16;
        d->csi = (ASN1characterstring_identification_t **)MemReAlloc(d->csi,
            d->csisize * sizeof(ASN1characterstring_identification_t *), _ModName((ASN1decoding_t) d));
        if (!d->csi)
        {
            ASN1DecSetError((ASN1decoding_t) d, ASN1_ERR_MEMORY);
            return 0;
        }
    }
    d->csi[d->csilength++] = identification;
    return 1;
}
#endif // ENABLE_GENERALIZED_CHAR_STR

/* get a character string identification from the list of identifications */
#ifdef ENABLE_GENERALIZED_CHAR_STR
ASN1characterstring_identification_t *ASN1DecGetCharacterStringIdentification(ASN1INTERNdecoding_t d, ASN1uint32_t index)
{
    if (index >= d->csilength)
    {
        ASN1DecSetError((ASN1decoding_t) d, ASN1_ERR_CORRUPT);
        return NULL;
    }
    return d->csi[index];
}
#endif // ENABLE_GENERALIZED_CHAR_STR

ASN1error_e ASN1EncSetError(ASN1encoding_t enc, ASN1error_e err)
{
    ASN1INTERNencoding_t e = (ASN1INTERNencoding_t) enc;
    EncAssert(enc, ASN1_SUCCESS <= err);
    while (e)
    {
        e->info.err = err;
        if (e == e->parent)
        {
            break;
        }
        e = e->parent;
    }
    return err;
}

ASN1error_e ASN1DecSetError(ASN1decoding_t dec, ASN1error_e err)
{
    ASN1INTERNdecoding_t d = (ASN1INTERNdecoding_t) dec;
    DecAssert(dec, ASN1_SUCCESS <= err);
    while (d)
    {
        d->info.err = err;
        if (d == d->parent)
        {
            break;
        }
        d = d->parent;
    }
    return err;
}

#ifdef _DEBUG
void MyDebugBreak(void)
{
    DebugBreak();
}
#endif // _DEBUG

// Memory manager for decoder
LPVOID DecMemAlloc ( ASN1decoding_t dec, ASN1uint32_t cbSize )
{
    ASN1uint32_t cbSizeUnaligned = cbSize; 
    LPVOID lp = NULL;
    ASN1INTERNdecoding_t lpInfo = (ASN1INTERNdecoding_t) dec;
    // make sure the size is 4-byte aligned
    ASN1_SIZE_ALIGNED(cbSize);
    // accumulate the total size
    lpInfo->cbLinearBufSize += cbSize;
    // allocate the buffer
    if (lpInfo->fExtBuf)
    {
        if (lpInfo->cbRemExtBufSize >= cbSize)
        {
            lp = lpInfo->lpRemExtBuf;
            lpInfo->lpRemExtBuf += cbSize;
            lpInfo->cbRemExtBufSize -= cbSize;
        }
        else
        {
            DecAssert(dec, FALSE);
        }
    }
    else
    {
        if (cbSizeUnaligned > cbSize) { 
            //
            // Check for arithmetic overflow (caused by ASN1_SIZE_ALIGNED)
            //
            lp = NULL; 
        } else { 
            lp = MemAllocEx(dec, cbSize, TRUE); // zero memory
        }
    }
    // make sure to propagate error
    if (lp == NULL)
    {
        ASN1DecSetError(dec, ASN1_ERR_MEMORY);
    }
    return lp;
}

void DecMemFree ( ASN1decoding_t dec, LPVOID lpData )
{
    if (! ((ASN1INTERNdecoding_t) dec)->fExtBuf)
    {
        MemFree(lpData);
    }
}

LPVOID DecMemReAlloc ( ASN1decoding_t dec, LPVOID lpData, ASN1uint32_t cbSize )
{
    ASN1uint32_t cbSizeUnaligned = cbSize; 
    LPVOID lp = NULL;
    // make sure the size is 4-byte aligned
    ASN1_SIZE_ALIGNED(cbSize);
    // accumulate the total size
    ((ASN1INTERNdecoding_t) dec)->cbLinearBufSize += cbSize;
    // allocate the buffer
    if (((ASN1INTERNdecoding_t) dec)->fExtBuf)
    {
        if (lpData == NULL)
        {
            lp = DecMemAlloc(dec, cbSizeUnaligned);
        }
        else
        {
            DecAssert(dec, FALSE);
        }
    }
    else
    {
        if (cbSizeUnaligned > cbSize) { 
            //
            // Check for arithmetic overflow (caused by ASN1_SIZE_ALIGNED)
            //
            lp = NULL; 
        } else { 
            lp = MemReAllocEx(dec, lpData, cbSize, TRUE); // zero memory
        }
    }
    // make sure to propagate error
    if (lp == NULL)
    {
        ASN1DecSetError(dec, ASN1_ERR_MEMORY);
    }
    return lp;
}



/***
*char *ms_bSearch() - do a binary search on an array
*
*Purpose:
*       Does a binary search of a sorted array for a key.
*
*Entry:
*       const char *key    - key to search for
*       const char *base   - base of sorted array to search
*       unsigned int num   - number of elements in array
*       unsigned int width - number of bytes per element
*       int (*compare)()   - pointer to function that compares two array
*               elements, returning neg when #1 < #2, pos when #1 > #2, and
*               0 when they are equal. Function is passed pointers to two
*               array elements.
*
*Exit:
*       if key is found:
*               returns pointer to occurrence of key in array
*       if key is not found:
*               returns NULL
*
*Exceptions:
*
*******************************************************************************/

void * ms_bSearch (
        const void *key,
        const void *base,
        size_t num,
        size_t width,
        int (__cdecl *compare)(const void *, const void *)
        )
{
        char *lo = (char *)base;
        const char *hi = (char *)base + (num - 1) * width;
        char *mid;
        unsigned int half;
        int result;

        while (lo <= hi)
                if (half = num / 2)
                {
                        mid = lo + (num & 1 ? half : (half - 1)) * width;
                        if (!(result = (*compare)(key,mid)))
                                return(mid);
                        else if (result < 0)
                        {
                                hi = mid - width;
                                num = num & 1 ? half : half-1;
                        }
                        else    {
                                lo = mid + width;
                                num = half;
                        }
                }
                else if (num)
                        return((*compare)(key,lo) ? NULL : lo);
                else
                        break;

        return(NULL);
}


int IsDigit(char p)
{
      return ((p >= ('0')) && (p <=('9'))) ? 1 : 0 ;
}



// BUGBUG - This is a copy of the same routine in nmutil
// BUGBUG - Remove this when we convert our files to CPP and use nmutil
/*  D E C I M A L  S T R I N G  T O  U  I  N  T  */
/*-------------------------------------------------------------------------
    %%Function: DecimalStringToUINT
    
-------------------------------------------------------------------------*/
unsigned int  DecimalStringToUINT(const char * pcszString, ASN1uint32_t cch)
{
	unsigned int uRet = 0;
	const char * pszStr =  pcszString;
	while (cch-- && ('\0') != pszStr[0])
	{
		uRet = (10 * uRet) + (int) (pszStr[0] - ('0'));
		pszStr++; // NOTE: DBCS characters are not allowed!
	}
	return uRet;
}


#ifdef ENABLE_BER
int My_memcmp(ASN1octet_t *pBuf1, ASN1uint32_t cbBuf1Size, ASN1octet_t *pBuf2, ASN1uint32_t cbBuf2Size)
{
    int diff;
    ASN1uint32_t cbMinBufSize = (cbBuf1Size < cbBuf2Size) ? cbBuf1Size : cbBuf2Size;
    while (cbMinBufSize--)
    {
        diff = (int) (ASN1uint32_t) *pBuf1++ - (int) (ASN1uint32_t) *pBuf2++;
        if (0 != diff)
        {
            return diff;
        }
    }
    return ((int) cbBuf1Size - (int) cbBuf2Size);
}
#endif // ENABLE_BER

#ifdef ENABLE_DOUBLE

const ASN1octet_t ASN1double_pinf_octets[] = DBL_PINF;
const ASN1octet_t ASN1double_minf_octets[] = DBL_MINF;

/* get a positive infinite double value */
double ASN1double_pinf()
{
    double val;
    MyAssert(sizeof(val) == sizeof(ASN1double_pinf_octets));
    memcpy(&val, ASN1double_pinf_octets, sizeof(ASN1double_pinf_octets));
    return val;
}

/* get a negative infinite double value */
double ASN1double_minf()
{
    double val;
    MyAssert(sizeof(val) == sizeof(ASN1double_minf_octets));
    memcpy(&val, ASN1double_minf_octets, sizeof(ASN1double_minf_octets));
    return val;
}

/* check if double is plus infinity */
int ASN1double_ispinf(double d)
{
#if HAS_FPCLASS
    return !finite(d) && fpclass(d) == FP_PINF;
#elif HAS_ISINF
    return !finite(d) && isinf(d) && copysign(1.0, d) > 0.0;
#else
#error "cannot encode NaN fp values"
#endif
}

/* check if double is minus infinity */
int ASN1double_isminf(double d)
{
#if HAS_FPCLASS
    return !finite(d) && fpclass(d) == FP_NINF;
#elif HAS_ISINF
    return !finite(d) && isinf(d) && copysign(1.0, d) < 0.0;
#else
#error "cannot encode NaN fp values"
#endif
}

#endif

/* convert a real value into a double */
#ifdef ENABLE_REAL
double ASN1real2double(ASN1real_t *val)
{
    ASN1intx_t exp;
    ASN1int32_t e;
    double m;

    switch (val->type) {
    case eReal_Normal:
        m = ASN1intx2double(&val->mantissa);
        if (val->base == 10) {
            return m * pow(10.0, (double)ASN1intx2int32(&val->exponent));
        } else {
            if (val->base == 2) {
                if (! ASN1intx_dup(&exp, &val->exponent))
                {
                    return 0.0;
                }
            } else if (val->base == 8) {
                ASN1intx_muloctet(&exp, &val->exponent, 3);
            } else if (val->base == 16) {
                ASN1intx_muloctet(&exp, &val->exponent, 4);
            } else {
                return 0.0;
            }
            e = ASN1intx2int32(&exp);
            ASN1intx_free(&exp);
            return ldexp(m, e);
        }
    case eReal_PlusInfinity:
        return ASN1double_pinf();
    case eReal_MinusInfinity:
        return ASN1double_minf();
    default:
        return 0.0;
    }
}
#endif // ENABLE_REAL

/* free a real value */
#ifdef ENABLE_REAL
void ASN1real_free(ASN1real_t *val)
{
    ASN1intx_free(&val->mantissa);
    ASN1intx_free(&val->exponent);
}
#endif // ENABLE_REAL

/* free a bitstring value */
void ASN1bitstring_free(const ASN1bitstring_t *val)
{
    if (val)
    {
        // lonchanc: no need to check length because zeroed decoded buffers.
        MemFree(val->value);
    }
}

/* free an octet string value */
void ASN1octetstring_free(const ASN1octetstring_t *val)
{
    if (val)
    {
        // lonchanc: no need to check length because zeroed decoded buffers.
        MemFree(val->value);
    }
}

/* free an object identifier value */
void ASN1objectidentifier_free(ASN1objectidentifier_t *val)
{
    if (val)
    {
        // lonchanc: we allocate the entire object identifer as a chunk.
        // as a result, we free it only once as a chunk.
        MemFree(*val);
    }
}

/* free a string value */
#ifdef ENABLE_BER
void ASN1charstring_free(const ASN1charstring_t *val)
{
    if (val)
    {
        // lonchanc: no need to check length because zeroed decoded buffers.
        MemFree(val->value);
    }
}
#endif // ENABLE_BER

/* free a 16 bit string value */
void ASN1char16string_free(const ASN1char16string_t *val)
{
    if (val)
    {
        // lonchanc: no need to check length because zeroed decoded buffers.
        MemFree(val->value);
    }
}

/* free a 32 bit string value */
#ifdef ENABLE_BER
void ASN1char32string_free(const ASN1char32string_t *val)
{
    if (val)
    {
        // lonchanc: no need to check length because zeroed decoded buffers.
        MemFree(val->value);
    }
}
#endif // ENABLE_BER

/* free a zero-terminated string value */
void ASN1ztcharstring_free(ASN1ztcharstring_t val)
{
    MemFree(val);
}

/* free a zero-terminated 16 bit string value */
#ifdef ENABLE_BER
void ASN1ztchar16string_free(ASN1ztchar16string_t val)
{
    MemFree(val);
}
#endif // ENABLE_BER

/* free a zero-terminated 32 bit string value */
#ifdef ENABLE_BER
void ASN1ztchar32string_free(ASN1ztchar32string_t val)
{
    MemFree(val);
}
#endif // ENABLE_BER

/* free an external value */
#ifdef ENABLE_EXTERNAL
void ASN1external_free(ASN1external_t *val)
{
    if (val)
    {
        switch (val->identification.o)
        {
        case ASN1external_identification_syntax_o:
            ASN1objectidentifier_free(&val->identification.u.syntax);
            break;
        case ASN1external_identification_presentation_context_id_o:
            break;
        case ASN1external_identification_context_negotiation_o:
            ASN1objectidentifier_free(
                &val->identification.u.context_negotiation.transfer_syntax);
            break;
        }
        ASN1ztcharstring_free(val->data_value_descriptor);
        switch (val->data_value.o)
        {
        case ASN1external_data_value_notation_o:
            ASN1open_free(&val->data_value.u.notation);
            break;
        case ASN1external_data_value_encoded_o:
            ASN1bitstring_free(&val->data_value.u.encoded);
            break;
        }
    }
}
#endif // ENABLE_EXTERNAL

/* free an embedded pdv value */
#ifdef ENABLE_EMBEDDED_PDV
void ASN1embeddedpdv_free(ASN1embeddedpdv_t *val)
{
    if (val)
    {
        switch (val->identification.o)
        {
        case ASN1embeddedpdv_identification_syntaxes_o:
            ASN1objectidentifier_free(&val->identification.u.syntaxes.abstract);
            ASN1objectidentifier_free(&val->identification.u.syntaxes.transfer);
            break;
        case ASN1embeddedpdv_identification_syntax_o:
            ASN1objectidentifier_free(&val->identification.u.syntax);
            break;
        case ASN1embeddedpdv_identification_presentation_context_id_o:
            break;
        case ASN1embeddedpdv_identification_context_negotiation_o:
            ASN1objectidentifier_free(
                &val->identification.u.context_negotiation.transfer_syntax);
            break;
        case ASN1embeddedpdv_identification_transfer_syntax_o:
            ASN1objectidentifier_free(&val->identification.u.transfer_syntax);
            break;
        case ASN1embeddedpdv_identification_fixed_o:
            break;
        }
        switch (val->data_value.o)
        {
        case ASN1embeddedpdv_data_value_notation_o:
            ASN1open_free(&val->data_value.u.notation);
            break;
        case ASN1embeddedpdv_data_value_encoded_o:
            ASN1bitstring_free(&val->data_value.u.encoded);
            break;
        }
    }
}
#endif // ENABLE_EMBEDDED_PDV

/* free a character string value */
#ifdef ENABLE_GENERALIZED_CHAR_STR
void ASN1characterstring_free(ASN1characterstring_t *val)
{
    if (val)
    {
        switch (val->identification.o)
        {
        case ASN1characterstring_identification_syntaxes_o:
            ASN1objectidentifier_free(&val->identification.u.syntaxes.abstract);
            ASN1objectidentifier_free(&val->identification.u.syntaxes.transfer);
            break;
        case ASN1characterstring_identification_syntax_o:
            ASN1objectidentifier_free(&val->identification.u.syntax);
            break;
        case ASN1characterstring_identification_presentation_context_id_o:
            break;
        case ASN1characterstring_identification_context_negotiation_o:
            ASN1objectidentifier_free(
                &val->identification.u.context_negotiation.transfer_syntax);
            break;
        case ASN1characterstring_identification_transfer_syntax_o:
            ASN1objectidentifier_free(&val->identification.u.transfer_syntax);
            break;
        case ASN1characterstring_identification_fixed_o:
            break;
        }
        switch (val->data_value.o)
        {
        case ASN1characterstring_data_value_notation_o:
            ASN1open_free(&val->data_value.u.notation);
            break;
        case ASN1characterstring_data_value_encoded_o:
            ASN1octetstring_free(&val->data_value.u.encoded);
            break;
        }
    }
}
#endif // ENABLE_GENERALIZED_CHAR_STR

/* free an open type value */
#ifdef ENABLE_BER
void ASN1open_free(const ASN1open_t *val)
{
    if (val)
    {
        // lonchanc: no need to check length because zeroed decoded buffers.
        MemFree(val->encoded);
    }
}
#endif // ENABLE_BER

#ifdef ENABLE_BER
void ASN1utf8string_free(const ASN1wstring_t *val)
{
    if (val)
    {
        // lonchanc: no need to check length because zeroed decoded buffers.
        MemFree(val->value);
    }
}
#endif // ENABLE_BER

/* convert a generalized time value into a string */
int ASN1generalizedtime2string(char *dst, ASN1generalizedtime_t *val)
{
    if (dst && val)
    {
        sprintf(dst, "%04d%02d%02d%02d%02d%02d",
            val->year, val->month, val->day,
            val->hour, val->minute, val->second);
        if (val->millisecond) {
            if (!(val->millisecond % 100))
                sprintf(dst + 14, ".%01d", val->millisecond / 100);
            else if (!(val->millisecond % 10))
                sprintf(dst + 14, ".%02d", val->millisecond / 10);
            else
                sprintf(dst + 14, ".%03d", val->millisecond);
        }
        if (val->universal)
            strcpy(dst + My_lstrlenA(dst), "Z");
        else if (val->diff > 0) {
            if (val->diff % 60) {
                sprintf(dst + My_lstrlenA(dst), "+%04d",
                    100 * (val->diff / 60) + (val->diff % 60));
            } else {
                sprintf(dst + My_lstrlenA(dst), "+%02d",
                    val->diff / 60);
            }
        } else if (val->diff < 0) {
            if (val->diff % 60) {
                sprintf(dst + My_lstrlenA(dst), "-%04d",
                    -100 * (val->diff / 60) - (val->diff % 60));
            } else {
                sprintf(dst + My_lstrlenA(dst), "-%02d",
                    -val->diff / 60);
            }
        }
        return 1;
    }
    return 0;
}

/* convert a utc time value into a string */
#ifdef ENABLE_BER
int ASN1utctime2string(char *dst, ASN1utctime_t *val)
{
    if (dst && val)
    {
        sprintf(dst, "%02d%02d%02d%02d%02d%02d",
            val->year, val->month, val->day,
            val->hour, val->minute, val->second);
        if (val->universal)
            strcpy(dst + My_lstrlenA(dst), "Z");
        else if (val->diff > 0) {
            if (val->diff % 60) {
                sprintf(dst + My_lstrlenA(dst), "+%04d",
                    100 * (val->diff / 60) + (val->diff % 60));
            } else {
                sprintf(dst + My_lstrlenA(dst), "+%02d",
                    val->diff / 60);
            }
        } else if (val->diff < 0) {
            if (val->diff % 60) {
                sprintf(dst + My_lstrlenA(dst), "-%04d",
                    -100 * (val->diff / 60) - (val->diff % 60));
            } else {
                sprintf(dst + My_lstrlenA(dst), "-%02d",
                    -val->diff / 60);
            }
        }
        return 1;
    }
    return 0;
}
#endif // ENABLE_BER

//
// scan the decimal fraction of a number based on the base
// base must be a power of 10
//
static DWORD scanfrac(char *p, char **e, DWORD base)
{
    DWORD ret = 0;

    while (IsDigit(*p)) {
        if (base != 1)
        {
            base /= 10;
            ret = (ret * 10) + (*p++ - '0');
        }
        else
        {
            p++;
        }
    }
    *e = p;
    return ret * base;
}

/* convert a string into a generalized time value */
int ASN1string2generalizedtime(ASN1generalizedtime_t *dst, char *val)
{
    if (dst && val)
    {
        int year, month, day, hour, minute, second, millisecond, diff, universal;
        char *p;
        DWORD frac;
        DWORD temp;

        millisecond = second = minute = universal = diff = 0;
        if (My_lstrlenA(val) < 10)
        {
            return 0;
        }
        year = DecimalStringToUINT(val, 4);
        month = DecimalStringToUINT((val+4), 2);
        day = DecimalStringToUINT((val+6), 2);
        hour = DecimalStringToUINT((val+8), 2);
        p = val + 10;
        if (*p == '.' || *p == ',')
        {
            const DWORD base = 10000000;
            frac = scanfrac(p+1, &p, base);
            temp = frac * 60;
            minute = (temp / base);
            frac = temp % base;
            temp = frac * 60;
            second = (temp / base);
            frac = temp % base;
            millisecond = (frac / (base / 1000) );
        }
        else if (IsDigit(*p))
        {
            minute = DecimalStringToUINT(p, 2);
            p += 2;
            if (*p == '.' || *p == ',')
            {
                const DWORD base = 100000;
                frac = scanfrac(p+1, &p, base);
                temp = frac * 60;
                second = (temp / base);
                frac = temp % base;
                millisecond = (frac / (base / 1000) );
            } else if (IsDigit(*p))
            {
                second = DecimalStringToUINT(p, 2);
                p += 2;
                if (*p == '.' || *p == ',')
                {
                    const DWORD base = 1000;
                    frac = scanfrac(p+1, &p, base);
                    millisecond = frac;
                }
            }
        }
        if (*p == 'Z')
        {
            universal = 1;
            p++;
        }
        else if (*p == '+')
        {
            const DWORD base = 10000;
            frac = scanfrac(p + 1, &p, base);
            diff = frac / (base/100) * 60 + frac % 100;
        }
        else if (*p == '-')
        {
            const DWORD base = 10000;
            frac = scanfrac(p + 1, &p, base);
            diff = -((int)(frac / (base/100) * 60 + frac % 100));
        }
        if (*p)
        {
            return 0;
        }
        dst->year = (ASN1uint16_t)year;
        dst->month = (ASN1uint8_t)month;
        dst->day = (ASN1uint8_t)day;
        dst->hour = (ASN1uint8_t)hour;
        dst->minute = (ASN1uint8_t)minute;
        dst->second = (ASN1uint8_t)second;
        dst->millisecond = (ASN1uint16_t)millisecond;
        dst->universal = (ASN1bool_t)universal;
        dst->diff = (ASN1uint16_t)diff;
        return 1;
    }
    return 0;
}

/* convert a string into a utc time value */
#ifdef ENABLE_BER
int ASN1string2utctime(ASN1utctime_t *dst, char *val)
{
    if (dst && val)
    {
        char *p;
        DWORD frac;

        if (My_lstrlenA(val) < 10)
            return 0;

        p = val;
        dst->year = (ASN1uint8_t) DecimalStringToUINT(p, 2);
        p += 2;
        dst->month = (ASN1uint8_t) DecimalStringToUINT(p, 2);
        p += 2;
        dst->day = (ASN1uint8_t) DecimalStringToUINT(p, 2);
        p += 2;
        dst->hour = (ASN1uint8_t) DecimalStringToUINT(p, 2);
        p += 2;
        dst->minute = (ASN1uint8_t) DecimalStringToUINT(p, 2);
        p += 2;

        if (IsDigit(*p))
        {
            dst->second = (ASN1uint8_t) DecimalStringToUINT(p, 2);
            p += 2;
        }
        else
        {
            dst->second = 0;
        }

        dst->universal = 0;
        dst->diff = 0;

        if (*p == 'Z')
        {
            dst->universal = 1;
            p++;
        }
        else if (*p == '+')
        {
            const DWORD base = 10000;
            frac = scanfrac(p + 1, &p, base);
            dst->diff = (int)(frac / (base/100) * 60 + frac % 100);
        }
        else if (*p == '-')
        {
            const DWORD base = 10000;
            frac = scanfrac(p + 1, &p, base);
            dst->diff = -((int)(frac / (base/100) * 60 + frac % 100));
        }
        return ((*p) ? 0 : 1);
    }
    return 0;
}
#endif // ENABLE_BER


ASN1uint32_t GetObjectIdentifierCount(ASN1objectidentifier_t val)
{
    ASN1uint32_t cObjIds = 0;
    while (val)
    {
        cObjIds++;
        val = val->next;
    }
    return cObjIds;
}

ASN1uint32_t CopyObjectIdentifier(ASN1objectidentifier_t dst, ASN1objectidentifier_t src)
{
    while (dst && src)
    {
        dst->value = src->value;
        dst = dst->next;
        src = src->next;
    }
    return ((! dst) && (! src));
}

ASN1objectidentifier_t DecAllocObjectIdentifier(ASN1decoding_t dec, ASN1uint32_t cObjIds)
{
    ASN1objectidentifier_t p, q;
    ASN1uint32_t i;
    p = (ASN1objectidentifier_t) DecMemAlloc(dec, cObjIds * sizeof(struct ASN1objectidentifier_s));
    if (p)
    {
        for (q = p, i = 0; i < cObjIds-1; i++)
        {
            q->value = 0;
            q->next = (ASN1objectidentifier_t) ((char *) q + sizeof(struct ASN1objectidentifier_s));
            q = q->next;
        }
        q->next = NULL;
    }
    return p;
}

void DecFreeObjectIdentifier(ASN1decoding_t dec, ASN1objectidentifier_t p)
{
    DecMemFree(dec, p);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\kerbclient\rc4hmac.cpp ===
//===================================================================
//
// Copyright Microsoft Corporation. All Right Reserved.
//
//===================================================================
#include "xonp.h"
#include "sha.h"
#include "rc4.h"
#include "md5.h"


//////////////////////////////////////////////////////////////////////////
//
// SHA1 HMAC calculation
//
//////////////////////////////////////////////////////////////////////////
void shaHmac(
    IN PBYTE pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PBYTE pbData,
    IN ULONG cbData,
    IN PBYTE pbData2,
    IN ULONG cbData2,
    OUT PBYTE HmacData // length must be A_SHA_DIGEST_LEN
    )
{
    #define HMAC_K_PADSIZE 64
    BYTE Kipad[HMAC_K_PADSIZE];
    BYTE Kopad[HMAC_K_PADSIZE];
    BYTE HMACTmp[HMAC_K_PADSIZE+A_SHA_DIGEST_LEN];
    ULONG dwBlock;
    A_SHA_CTX shaHash;

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;

    ZeroMemory(Kipad, HMAC_K_PADSIZE);
    memcpy(Kipad, pbKeyMaterial, cbKeyMaterial);

    ZeroMemory(Kopad, HMAC_K_PADSIZE);
    memcpy(Kopad, pbKeyMaterial, cbKeyMaterial);

    //
    // Kipad, Kopad are padded sMacKey. Now XOR across...
    //
    for(dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(DWORD); dwBlock++)
    {
        ((DWORD*)Kipad)[dwBlock] ^= 0x36363636;
        ((DWORD*)Kopad)[dwBlock] ^= 0x5C5C5C5C;
    }

    //
    // prepend Kipad to data, Hash to get H1
    //

    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash, Kipad, HMAC_K_PADSIZE);
    if (cbData != 0)
    {
        A_SHAUpdate(&shaHash, pbData, cbData);
    }
    if (cbData2 != 0)
    {
        A_SHAUpdate(&shaHash, pbData2, cbData2);
    }

    // Finish off the hash
    A_SHAFinal(&shaHash,HMACTmp+HMAC_K_PADSIZE);

    // prepend Kopad to H1, hash to get HMAC
    memcpy(HMACTmp, Kopad, HMAC_K_PADSIZE);

    // final hash: output value into passed-in buffer
    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash,HMACTmp, sizeof(HMACTmp));
    A_SHAFinal(&shaHash,HmacData);
}

//////////////////////////////////////////////////////////////////////////
//
// MD5 HMAC calculation
//
//////////////////////////////////////////////////////////////////////////
void md5Hmac(
    IN PBYTE pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PBYTE pbData,
    IN ULONG cbData,
    IN PBYTE pbData2,
    IN ULONG cbData2,
    OUT PBYTE HmacData // length must be MD5_LEN
    )
{
    #define HMAC_K_PADSIZE 64
    BYTE Kipad[HMAC_K_PADSIZE];
    BYTE Kopad[HMAC_K_PADSIZE];
    BYTE HMACTmp[HMAC_K_PADSIZE+MD5_LEN];
    ULONG dwBlock;
    MD5_CTX Md5Hash;

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;

    ZeroMemory(Kipad, HMAC_K_PADSIZE);
    memcpy(Kipad, pbKeyMaterial, cbKeyMaterial);

    ZeroMemory(Kopad, HMAC_K_PADSIZE);
    memcpy(Kopad, pbKeyMaterial, cbKeyMaterial);

    //
    // Kipad, Kopad are padded sMacKey. Now XOR across...
    //
    for(dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(DWORD); dwBlock++)
    {
        ((DWORD*)Kipad)[dwBlock] ^= 0x36363636;
        ((DWORD*)Kopad)[dwBlock] ^= 0x5C5C5C5C;
    }

    //
    // prepend Kipad to data, Hash to get H1
    //
    MD5Init(&Md5Hash);
    MD5Update(&Md5Hash, Kipad, HMAC_K_PADSIZE);
    if (cbData != 0)
    {
        MD5Update(&Md5Hash, pbData, cbData);
    }
    if (cbData2 != 0)
    {
        MD5Update(&Md5Hash, pbData2, cbData2);
    }

    // Finish off the hash
    MD5Final(&Md5Hash);
    memcpy(HMACTmp+HMAC_K_PADSIZE, Md5Hash.digest, MD5_LEN);

    // prepend Kopad to H1, hash to get HMAC
    memcpy(HMACTmp, Kopad, HMAC_K_PADSIZE);

    // final hash: output value into passed-in buffer
    MD5Init(&Md5Hash);
    MD5Update(&Md5Hash,HMACTmp, sizeof(HMACTmp));
    MD5Final(&Md5Hash);
    memcpy(HmacData, Md5Hash.digest, MD5_LEN);

}


#define RC4_CONFOUNDER_LEN 8


void rc4Sha1HmacEncrypt(
    IN PUCHAR confounder, // RC4_CONFOUNDER_LEN bytes
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbHeader // A_SHA_DIGEST_LEN + RC4_CONFOUNDER_LEN bytes
    )
{
    PRC4_SHA1_HEADER CryptHeader = (PRC4_SHA1_HEADER) pbHeader;
    BYTE LocalKey[A_SHA_DIGEST_LEN];
    RC4_KEYSTRUCT Rc4KeyStruct;

    //
    // Create the header - the confounder & checksum
    //
    ZeroMemory( CryptHeader->Checksum, A_SHA_DIGEST_LEN );
    memcpy( CryptHeader->Confounder, confounder, RC4_CONFOUNDER_LEN );

    //
    // Checksum everything but the checksum
    //
    shaHmac( pbKey, cbKey,
             CryptHeader->Confounder, RC4_CONFOUNDER_LEN,
             pbInput, cbInput,
             CryptHeader->Checksum );

    //
    // HMAC the checksum into the key
    //
    shaHmac( pbKey, cbKey,
             CryptHeader->Checksum, A_SHA_DIGEST_LEN,
             NULL, 0,
             LocalKey );

    //
    // Use the generated key as the RC4 encryption key
    //
    rc4_key( &Rc4KeyStruct, A_SHA_DIGEST_LEN, LocalKey );

    //
    // Encrypt everything but the checksum
    //
    rc4( &Rc4KeyStruct, RC4_CONFOUNDER_LEN, CryptHeader->Confounder );
    rc4( &Rc4KeyStruct, cbInput, pbInput );
}

BOOL rc4Sha1HmacDecrypt(
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    IN PUCHAR pbHeader // A_SHA_DIGEST_LEN + RC4_CONFOUNDER_LEN bytes
    )
{
    PRC4_SHA1_HEADER CryptHeader = (PRC4_SHA1_HEADER) pbHeader;
    RC4_SHA1_HEADER TempHeader;
    BYTE LocalKey[A_SHA_DIGEST_LEN];
    RC4_KEYSTRUCT Rc4KeyStruct;

    memcpy( TempHeader.Confounder, CryptHeader->Confounder, RC4_CONFOUNDER_LEN );

    //
    // HMAC the checksum into the key
    //
    shaHmac( pbKey, cbKey,
             CryptHeader->Checksum, A_SHA_DIGEST_LEN,
             NULL, 0,
             LocalKey );

    //
    // Use the generated key as the RC4 encryption key
    //
    rc4_key( &Rc4KeyStruct, A_SHA_DIGEST_LEN, LocalKey );

    //
    // Decrypt confounder and data
    //
    rc4( &Rc4KeyStruct, RC4_CONFOUNDER_LEN, TempHeader.Confounder );
    rc4( &Rc4KeyStruct, cbInput, pbInput );

    //
    // Now verify the checksum.
    //
    shaHmac( pbKey, cbKey,
             TempHeader.Confounder, RC4_CONFOUNDER_LEN,
             pbInput, cbInput,
             TempHeader.Checksum );

    //
    // Decrypt is successful only if checksum matches
    //
    return ( !memcmp(
                 TempHeader.Checksum,
                 CryptHeader->Checksum,
                 A_SHA_DIGEST_LEN) );
}

void rc4Md5HmacEncrypt(
    IN PUCHAR confounder, // RC4_CONFOUNDER_LEN bytes
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbHeader // MD5_LEN + RC4_CONFOUNDER_LEN bytes
    )
{
    PRC4_MD5_HEADER CryptHeader = (PRC4_MD5_HEADER) pbHeader;
    BYTE LocalKey[MD5_LEN];
    RC4_KEYSTRUCT Rc4KeyStruct;

    //
    // Create the header - the confounder & checksum
    //
    ZeroMemory( CryptHeader->Checksum, MD5_LEN );
    memcpy( CryptHeader->Confounder, confounder, RC4_CONFOUNDER_LEN );

    //
    // Checksum everything but the checksum
    //
    md5Hmac( pbKey, cbKey,
             CryptHeader->Confounder, RC4_CONFOUNDER_LEN,
             pbInput, cbInput,
             CryptHeader->Checksum );

    //
    // HMAC the checksum into the key
    //
    md5Hmac( pbKey, cbKey,
             CryptHeader->Checksum, MD5_LEN,
             NULL, 0,
             LocalKey );

    //
    // Use the generated key as the RC4 encryption key
    //
    rc4_key( &Rc4KeyStruct, MD5_LEN, LocalKey );

    //
    // Encrypt everything but the checksum
    //
    rc4( &Rc4KeyStruct, RC4_CONFOUNDER_LEN, CryptHeader->Confounder );
    rc4( &Rc4KeyStruct, cbInput, pbInput );
}

BOOL rc4Md5HmacDecrypt(
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    IN PUCHAR pbHeader // MD5_LEN + RC4_CONFOUNDER_LEN bytes
    )
{
    PRC4_MD5_HEADER CryptHeader = (PRC4_MD5_HEADER) pbHeader;
    RC4_MD5_HEADER TempHeader;
    BYTE LocalKey[MD5_LEN];
    RC4_KEYSTRUCT Rc4KeyStruct;

    memcpy( TempHeader.Confounder, CryptHeader->Confounder, RC4_CONFOUNDER_LEN );

    //
    // HMAC the checksum into the key
    //
    md5Hmac( pbKey, cbKey,
             CryptHeader->Checksum, MD5_LEN,
             NULL, 0,
             LocalKey );

    //
    // Use the generated key as the RC4 encryption key
    //
    rc4_key( &Rc4KeyStruct, MD5_LEN, LocalKey );

    //
    // Decrypt confounder and data
    //
    rc4( &Rc4KeyStruct, RC4_CONFOUNDER_LEN, TempHeader.Confounder );
    rc4( &Rc4KeyStruct, cbInput, pbInput );

    //
    // Now verify the checksum.
    //
    md5Hmac( pbKey, cbKey,
             TempHeader.Confounder, RC4_CONFOUNDER_LEN,
             pbInput, cbInput,
             TempHeader.Checksum );

/*    {
        char statekey[64],localkey[64];
        DWORD k;
        for (k=0; k<cbKey; ++k)
        {
            sprintf(statekey+2*k,"%02X", pbKey[k]);
            sprintf(localkey+2*k,"%02X", LocalKey[k]);
        }
        statekey[2*cbKey] = localkey[2*cbKey] = '\0';
        printf( "rc4Md5HmacDecrypt salted key is %s\n",
            statekey);
        printf( "rc4Md5HmacDecrypt local key is %s\n",
            localkey );
    }*/

    //
    // Decrypt is successful only if checksum matches
    //
    return ( !memcmp(
                 TempHeader.Checksum,
                 CryptHeader->Checksum,
                 MD5_LEN) );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\kerbclient\md4ms.cpp ===
/*

    This second implementation of MD4 entry points is the newer style,
    optimized implementation, compatible with newer code expecting these
    entry point names.

    Modelled after MD5 and SHA-1.

    Scott Field (sfield)    21-Oct-97

*/


#include "xonp.h"
//#include "xonver.h"
#include "md4.h"
#include "uint4.h"


#ifndef RSA32API 
#define RSA32API
#endif

/* Compile-time macro declarations for MD4.
*/

/* ROTATE_LEFT rotates x left n bits.
 */
#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))

void MD4Transform (UINT4 state[4], unsigned char block[64]);


#define S11 3
#define S12 7
#define S13 11
#define S14 19
#define S21 3
#define S22 5
#define S23 9
#define S24 13
#define S31 3
#define S32 9
#define S33 11
#define S34 15


static const unsigned char PADDING[64] = {
  0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};


/* F, G and H are basic MD4 functions.
 */

#define F(x, y, z) ((z) ^ ((x) & ((y) ^ (z))))
#define G(x, y, z) (((x) & (y)) | ((z) & ((x) | (y))))
#define H(x, y, z) ((x) ^ (y) ^ (z))


/* FF, GG and HH are MD4 transformations for rounds 1, 2 and 3 */
/* Rotation is separate from addition to prevent recomputation */
#define FF(a, b, c, d, x, s) \
  {(a) += F ((b), (c), (d)) + (x); \
   (a) = ROTATE_LEFT ((a), (s));}
#define GG(a, b, c, d, x, s) \
  {(a) += G ((b), (c), (d)) + (x) + (UINT4)013240474631; \
   (a) = ROTATE_LEFT ((a), (s));}
#define HH(a, b, c, d, x, s) \
  {(a) += H ((b), (c), (d)) + (x) + (UINT4)015666365641; \
   (a) = ROTATE_LEFT ((a), (s));}


#ifdef KMODE_RSA32
#pragma alloc_text(PAGER32C, MD4Init)
#pragma alloc_text(PAGER32C, MD4Update)
#pragma alloc_text(PAGER32C, MD4Transform)
#pragma alloc_text(PAGER32C, MD4Final)
#endif  // KMODE_RSA32

/* MD4 initialization. Begins an MD4 operation, writing a new context.
 */
void
RSA32API
MD4Init (
    MD4_CTX *context                                         /* context */
    )
{
    context->count[0] = 0;
    context->count[1] = 0;

    /* Load magic initialization constants.
     */

    context->state[0] = 0x67452301;
    context->state[1] = 0xefcdab89;
    context->state[2] = 0x98badcfe;
    context->state[3] = 0x10325476;
}

/* MD4 block update operation. Continues an MD4 message-digest
     operation, processing another message block, and updating the
     context.
 */

void
RSA32API
MD4Update (
    MD4_CTX *context,                                        /* context */
    unsigned char *input,                                /* input block */
    unsigned int inputLen                      /* length of input block */
    )
{

  unsigned int bufferLen;

  /* Compute number of bytes mod 64 */
  bufferLen = (unsigned int)((context->count[0] >> 3) & 0x3F);

  /* Update number of bits */
  if ((context->count[0] += ((DWORD)inputLen << 3)) < ((DWORD)inputLen << 3))
    context->count[1]++;

  context->count[1] += ((DWORD)inputLen >> 29);

  /* If previous input in buffer, buffer new input and transform if
       possible.
   */
  if (bufferLen > 0 && bufferLen + inputLen >= 64) {
    memcpy(context->buffer+bufferLen, input, 64-bufferLen);
    input += (64-bufferLen);
    inputLen -= (64-bufferLen);
    MD4Transform (context->state, context->buffer);
    bufferLen = 0;
  }

    if( (DWORD_PTR)input & (sizeof(DWORD_PTR) - 1) ) {
        /* Copy input to aligned temporary buffer
         */
        while (inputLen >= 64) {
            memcpy( context->buffer, input, 64 );
            MD4Transform (context->state, context->buffer);
            input += 64;
            inputLen -= 64;
        }
    } else {
        /* Transform directly from input.
         */
        while (inputLen >= 64) {
            MD4Transform (context->state, input);
            input += 64;
            inputLen -= 64;
        }
    }

  /* Buffer remaining input */
  if (inputLen)
    memcpy(context->buffer+bufferLen, input, inputLen);

}

/* MD4 finalization. Ends an MD4 message-digest operation, writing the
     message digest and zeroizing the context.
 */
void
RSA32API
MD4Final (
    MD4_CTX *context                                         /* context */
    )
{
    unsigned int index, padLen;

    /* Save number of bits */

#if !defined(BIGENDIAN) || !BIGENDIAN
    ((unsigned long *)context->digest)[0] = context->count[0];
    ((unsigned long *)context->digest)[1] = context->count[1];
#else
  DWORDToLittleEndian (context->digest, context->count, 8);
#endif

    /* Pad out to 56 mod 64. */

    index = (unsigned int)((context->count[0] >> 3) & 0x3f);
    padLen = (index < 56) ? (56 - index) : (120 - index);
    MD4Update (context, (unsigned char *)PADDING, padLen);

    /* Append length (before padding) */

    MD4Update (context, context->digest, 8);

    /* Store state in digest */

#if !defined(BIGENDIAN) || !BIGENDIAN
    ((unsigned long *)context->digest)[0] = context->state[0];
    ((unsigned long *)context->digest)[1] = context->state[1];
    ((unsigned long *)context->digest)[2] = context->state[2];
    ((unsigned long *)context->digest)[3] = context->state[3];
#else
  DWORDToLittleEndian (context->digest, context->state, 16);
#endif

}

/* MD4 basic transformation. Transforms state based on block.
 */

//#ifndef _X86_ // use optimized .asm version of MD4Transform on x86

void
MD4Transform (
    UINT4 state[4],
    unsigned char block[64]
    )
{
  UINT4 a = state[0], b = state[1], c = state[2], d = state[3];

#if !defined(BIGENDIAN) || !BIGENDIAN
  unsigned long *x = (unsigned long*)block;
#else
  unsigned long x[16];
  DWORDFromLittleEndian (x, (unsigned char *)block, 64);
#endif

  /* Round 1 */
  FF (a, b, c, d, x[ 0], S11); /* 1 */
  FF (d, a, b, c, x[ 1], S12); /* 2 */
  FF (c, d, a, b, x[ 2], S13); /* 3 */
  FF (b, c, d, a, x[ 3], S14); /* 4 */
  FF (a, b, c, d, x[ 4], S11); /* 5 */
  FF (d, a, b, c, x[ 5], S12); /* 6 */
  FF (c, d, a, b, x[ 6], S13); /* 7 */
  FF (b, c, d, a, x[ 7], S14); /* 8 */
  FF (a, b, c, d, x[ 8], S11); /* 9 */
  FF (d, a, b, c, x[ 9], S12); /* 10 */
  FF (c, d, a, b, x[10], S13); /* 11 */
  FF (b, c, d, a, x[11], S14); /* 12 */
  FF (a, b, c, d, x[12], S11); /* 13 */
  FF (d, a, b, c, x[13], S12); /* 14 */
  FF (c, d, a, b, x[14], S13); /* 15 */
  FF (b, c, d, a, x[15], S14); /* 16 */

  /* Round 2 */
  GG (a, b, c, d, x[ 0], S21); /* 17 */
  GG (d, a, b, c, x[ 4], S22); /* 18 */
  GG (c, d, a, b, x[ 8], S23); /* 19 */
  GG (b, c, d, a, x[12], S24); /* 20 */
  GG (a, b, c, d, x[ 1], S21); /* 21 */
  GG (d, a, b, c, x[ 5], S22); /* 22 */
  GG (c, d, a, b, x[ 9], S23); /* 23 */
  GG (b, c, d, a, x[13], S24); /* 24 */
  GG (a, b, c, d, x[ 2], S21); /* 25 */
  GG (d, a, b, c, x[ 6], S22); /* 26 */
  GG (c, d, a, b, x[10], S23); /* 27 */
  GG (b, c, d, a, x[14], S24); /* 28 */
  GG (a, b, c, d, x[ 3], S21); /* 29 */
  GG (d, a, b, c, x[ 7], S22); /* 30 */
  GG (c, d, a, b, x[11], S23); /* 31 */
  GG (b, c, d, a, x[15], S24); /* 32 */

  /* Round 3 */
  HH (a, b, c, d, x[ 0], S31); /* 33 */
  HH (d, a, b, c, x[ 8], S32); /* 34 */
  HH (c, d, a, b, x[ 4], S33); /* 35 */
  HH (b, c, d, a, x[12], S34); /* 36 */
  HH (a, b, c, d, x[ 2], S31); /* 37 */
  HH (d, a, b, c, x[10], S32); /* 38 */
  HH (c, d, a, b, x[ 6], S33); /* 39 */
  HH (b, c, d, a, x[14], S34); /* 40 */
  HH (a, b, c, d, x[ 1], S31); /* 41 */
  HH (d, a, b, c, x[ 9], S32); /* 42 */
  HH (c, d, a, b, x[ 5], S33); /* 43 */
  HH (b, c, d, a, x[13], S34); /* 44 */
  HH (a, b, c, d, x[ 3], S31); /* 45 */
  HH (d, a, b, c, x[11], S32); /* 46 */
  HH (c, d, a, b, x[ 7], S33); /* 47 */
  HH (b, c, d, a, x[15], S34); /* 48 */

  state[0] += a;
  state[1] += b;
  state[2] += c;
  state[3] += d;
}


//+-------------------------------------------------------------------------

BOOL
KerbPasswordToKey(
    IN LPSTR pszPassword,
    OUT PUCHAR Key
    )
{
    BOOL fSucceed = FALSE;
    MD4_CTX md4Ctx;
    UNICODE_STRING Password;
    DWORD dwPasswordLen;
    DWORD dwResult;
    WCHAR* pwcUnicodePassword;

    dwPasswordLen = strlen(pszPassword);

    pwcUnicodePassword = (WCHAR*)_alloca( (dwPasswordLen + 1) * sizeof(WCHAR) );
    if (pwcUnicodePassword == NULL)
    {
        goto Cleanup;
    }

    // This is a little scary. Because we pass dwPasswordLen in for the length of pszPassword,
    // pwcUnicodePassword will end up not being null-terminated (check the documentation for
    // MultiByteToWideChar). However, we end up treating the password as a sequence of bytes
    // anyway, and don't use the null terminator in that sequence of bytes. So we are safe.
    dwResult = MultiByteToWideChar(
         CP_ACP,
         MB_PRECOMPOSED,
         pszPassword,
         dwPasswordLen,
         pwcUnicodePassword,
         dwPasswordLen
         );

    if (dwResult == 0) {
        goto Cleanup;
    }
    
    MD4Init( &md4Ctx );
    MD4Update( &md4Ctx, (unsigned char *)pwcUnicodePassword, dwPasswordLen * sizeof(WCHAR) );
    MD4Final( &md4Ctx );

    memcpy( Key, md4Ctx.digest, MD4_LEN );
    
    fSucceed = TRUE;

Cleanup:
    if (!fSucceed)
    {
        TraceSz( Warning, "KerbPasswordToKey failed" );
    }
    return(fSucceed);
}

//#endif // !_X86_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\kerbclient\PcAccountCreation.cpp ===
#include "xonp.h"
#include <xcrypt.h>

#define ATL_NO_LEAN_AND_MEAN
#include <passportIdcrl.h>

#include <sha.h>
#include <md4.h>
#include <md5.h>
#include "kerbfuzz.h"

#include <array>
#include <vector>

#undef min //some windows header has a stupid macro that conflicts with STL

// Elsewhere in KerbClient
extern KerbClientCrypt g_ClientCrypt;
extern "C" DWORD kcl_RC4HmacEncrypt(IN const UCHAR* pbKey, IN ULONG KeySize, IN ULONG MessageType, IN PUCHAR pbInput, IN ULONG cbInput, OUT PUCHAR pbOutput, OUT PULONG pcbOutput);

// --------------------------------------------------------------------------------------
// Protocol constants
// --------------------------------------------------------------------------------------
namespace PA_PC_ACCOUNT_CREATION
{
    enum CONSTANTS
    {
        NONCE_LENGTH                = 8,
        TICKET_MAX_LENGTH           = 700,
        ENC_DATA_MAX_LENGTH         = 76,
        PC_ID_LENGTH                = 8,
        SPONSOR_TOKEN_MAX_LENGTH    = 40
    };
}

const GUID g_KerbClientAppGuid = { /* 59096074-78b1-482e-9927-237a6e6b5674 */
    0x59096074,
    0x78b1,
    0x482e,
    {0x99, 0x27, 0x23, 0x7a, 0x6e, 0x6b, 0x56, 0x74}
  };

// --------------------------------------------------------------------------------------
// PA_PC_ACCOUNT_CREATION_REP
// the response to the PC account creation pre-auth
// --------------------------------------------------------------------------------------
struct PA_PC_ACCOUNT_CREATION_REP
{
    UINT64      machineId;
    BYTE        machineKey[XONLINE_KEY_LENGTH];
};

// structs for pc2
struct PA_PC_ACCOUNT_CREATION_REQ2
{
    enum CONSTANTS
    {
        ENC_DATA_MAX_LENGTH = 600,
        ENC_SESSION_KEY_SIZE = 256
    };

    std::tr1::array<BYTE, ENC_SESSION_KEY_SIZE> abEncSessionKey;        // 256 bytes, RsaEncrypt(XmacsKey, SessionKey);
    UINT16 encDataLen;
    std::vector<BYTE> encData;

    std::vector<BYTE> Serialize()
    {
        //format is:
        //  256 byte encrypted key blob
        //  2   byte length of encrypted data
        //  N   byte encrypted data

        std::vector<BYTE> data;
        data.reserve(256+2+encData.size());
        data.insert(data.end(), abEncSessionKey.begin(), abEncSessionKey.end());
        data.insert(data.end(), (BYTE*)(&encDataLen), (BYTE*)(&encDataLen+1));
        data.insert(data.end(), encData.begin(), encData.end());

        return data;
    }
};

struct PA_PC_ACCOUNT_CREATION_ENCRYPTED_DATA2
{
    enum CONSTANTS
    {
        ENC_DATA_MAX_LENGTH = PA_PC_ACCOUNT_CREATION_REQ2::ENC_DATA_MAX_LENGTH,
        TICKET_MAX_LENGTH = 500
    };

    UINT64 qwAuthtime;
    UINT64 pcId;
    UINT16 ticketLen;
    UINT16 sponsorTokenLen;
    std::vector<BYTE> ticket;
    std::vector<BYTE> sponsorToken;

    std::vector<BYTE> Serialize()
    {
        //format is:
        //  8 byte authtime
        //  8 byte pc id
        //  2 byte ticket length
        //  2 byte token length
        //  N byte ticket
        //  N byte token

        std::vector<BYTE> data;
        data.reserve(8+8+2+2+ticket.size()+sponsorToken.size());
        data.insert(data.end(), (BYTE*)(&qwAuthtime), (BYTE*)(&qwAuthtime+1));
        data.insert(data.end(), (BYTE*)(&pcId), (BYTE*)(&pcId+1));
        data.insert(data.end(), (BYTE*)(&ticketLen), (BYTE*)(&ticketLen+1));
        data.insert(data.end(), (BYTE*)(&sponsorTokenLen), (BYTE*)(&sponsorTokenLen+1));
        data.insert(data.end(), ticket.begin(), ticket.end());
        data.insert(data.end(), sponsorToken.begin(), sponsorToken.end());

        return data;
    }
};

// --------------------------------------------------------------------------------------
// Forward Declarations
// --------------------------------------------------------------------------------------

HRESULT AddPcAccountCreationPreAuth(
    CScratchMemoryAllocator*    pScratchAlloc,
    UINT16                      cbNonce,
    BYTE*                       pNonce,
    UINT16                      cbTicket,
    BYTE*                       pTicket,
    UINT16                      cbPcId,
    BYTE*                       pPcId,
    UINT16                      cbSponsorToken,
    const BYTE*                 pSponsorToken,
    const KERB_ENCRYPTION_KEY*  pKey,
    IN OUT PKERB_PA_DATA_LIST*  ppPreAuthData);

HRESULT AddPcAccountCreation2PreAuth(
    CScratchMemoryAllocator*    pScratchAlloc,
    BOOL                        bUseTestXmacsKey,
    UINT16                      cbTicket,
    BYTE*                       pTicket,
    UINT16                      cbPcId,
    BYTE*                       pPcId,
    UINT16                      cbSponsorToken,
    const BYTE*                 pSponsorToken,
    const KERB_ENCRYPTION_KEY*  pKey,
    IN OUT PKERB_PA_DATA_LIST*  ppPreAuthData);

HRESULT WritePcAccountCreationEncryptedData(
    BYTE*                       pPcId,
    UINT16                      cbSponsorToken,
    const BYTE*                 pSponsorToken,
    const KERB_ENCRYPTION_KEY*  pKey, 
    CMemoryStream*              pms);

KERBERR VerifyPcAccountCreationPreAuthReply(
    CScratchMemoryAllocator* pScratchAlloc,
    PKERB_PA_DATA            pPreAuthData,
    KERB_ENCRYPTION_KEY*     pKey,
    XKERB_TGT_CONTEXT*       pTGTContext,
    OUT XONLINEP_USER*       pusr);

NTSTATUS
KerbAddTimestampPreAuth(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PKERB_ENCRYPTION_KEY UserKey,
    IN PTimeStamp pAuthTime,
    OUT PKERB_PA_DATA_LIST * PreAuthData);

extern KERB_CRYPT_LIST g_RC4HMAC_CryptList;

// --------------------------------------------------------------------------------------
// kcl_PassportInit
// Initialize global passport stuff. Must be called before kcl_PassportGetTicket
//  - passportEnvironment: passport enviroment to talk to. Common options are L"INT" for 
//  testing and L"PROD" for production.
// Returns:
//  S_OK if succeeds. HRESULT error otherwise.
// --------------------------------------------------------------------------------------
HRESULT WINAPI
kcl_PassportInit(
    LPCWSTR passportEnvironment
)
{
    ClearStoredDebugSpew();

    CLargeStr error;
    HRESULT result=CPassportIdcrl::StaticInit(g_KerbClientAppGuid, passportEnvironment, &error);
    TraceSz((result!=0?AuthWarn:AuthVerbose), error.cstr());
    return result;
}

// --------------------------------------------------------------------------------------
// kcl_PassportTerm
// Terminate global passport stuff.
// --------------------------------------------------------------------------------------
VOID WINAPI
kcl_PassportTerm()
{
    ClearStoredDebugSpew();

    CPassportIdcrl::StaticTerm();
}

// --------------------------------------------------------------------------------------
// kcl_PassportGetTicket
// Authenticate a user and get a ticket for a service.
//  - memberName: passport member name
//  - password: should be obvious
//  - service: service that the ticket should be issued for. For Live, this should be 
//     "kdc.xboxlive.com".
//  - servicePolicy: policy to evaluate to determine whether to grant the service (if 0,
//    defaults to L"MBI_KEY_OLD")
//  - ticketAsBinary: whether to return the ticket encoded in binary form, or as a string
//  - pticket: pointer to pre-allocated buffer to receive the ticket. Recommended size 
//     for the buffer is 1500 bytes.
//  - pcbticket: IN: the size of the buffer in pticket. OUT: the size of the ticket.
//  - pkey: pointer to pre-allocated buffer to receive the session key. Recommended size 
//     for the buffer is 100 bytes.
//  - pcbkey: IN: the size of the buffer in pkey. OUT: the size of the session key.
// Returns:
//  S_OK if succeeds. HRESULT error otherwise.
// --------------------------------------------------------------------------------------
HRESULT WINAPI
kcl_PassportGetTicket(
    LPCWSTR memberName,
    LPCWSTR password,
    LPCWSTR service,
    LPCWSTR servicePolicy,
    bool ticketAsBinary,
    OUT BYTE* pticket,
    IN OUT UINT32* pcbticket,
    OUT BYTE* pkey,
    IN OUT UINT32* pcbkey)
{
    ClearStoredDebugSpew();

    HRESULT hr = E_FAIL;
    CLargeBuffer ticket;
    CLargeBuffer key;

    // Use CRT memory allocator in case the buffers need to grow

    ticket.SetAllocator(CMemAlloc::Crt());
    key.SetAllocator(CMemAlloc::Crt());

    // Get the ticket

    CLargeStr error;
    hr = CPassportIdcrl::GetTicket(
        memberName,
        password,
        service,
        servicePolicy,
        ticketAsBinary,
        &ticket,
        &key,
        &error);

    if(FAILED(hr))
    {
        TraceSz(AuthWarn, "Failed to get ticket.");
        TraceSz(AuthWarn, error.cstr());
        goto Exit;
    }
    else if (error.GetLength()>0)
    {
        TraceSz(AuthVerbose, error.cstr());
    }

    unsigned int bytesSkip=ticketAsBinary?0:2; //skip t= for string version

    if (ticket.GetSize()<bytesSkip+1) //not good
    {
        TraceSz(AuthWarn, "Got back an empty ticket...?");
        goto Exit;
    }

    // Copy to caller's buffer

    if(*pcbticket < ticket.GetSize() ||
       *pcbkey < key.GetSize())
    {
        TraceSz(AuthWarn, "Buffer is too small to hold ticket.");
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }

    memcpy(pticket, (unsigned char*)ticket.GetPtr()+bytesSkip, ticket.GetSize()-bytesSkip);

    if (key.GetSize()>0)
    {
        memcpy(pkey,    key.GetPtr(),    key.GetSize());
    }

    *pcbticket = ticket.GetSize()-bytesSkip;
    *pcbkey    = key.GetSize();
    
    hr = S_OK;

Exit:

    return hr;
}

// --------------------------------------------------------------------------------------
// kcl_BuildPcMachineRequest
// --------------------------------------------------------------------------------------

//protos from kerberos.cpp for this:
extern bool AddSharedPreauthToPAList(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,  //required
    IN ASN1int32_t patType,  //required
    IN KERB_ENCRYPTION_KEY *compoundKey,
    IN const TitleInfo* pInfo,
    IN const AsRequestInfo* pAsRequestInfo,
    IN bool bIsTgsRequest,
    IN KERB_ENCRYPTION_KEY *pClientKey,
    IN PKERB_KDC_REQUEST_BODY pRequestBody,
    IN KERB_ENCRYPTION_KEY *pSessionKey,
    IN PXKERB_TGT_CONTEXT pCombinedTGTContext,
    IN OUT PXKERB_SERVICE_CONTEXT pXKerbServiceContext,
    OUT IN KERB_KDC_REQUEST *pTicketRequest,  //required
    OUT NTSTATUS *pStatus  //required
                                     );

extern NTSTATUS WINAPI
KerbAddFakeTypePreauth(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN ASN1int32_t patType,
    IN OUT PKERB_PA_DATA_LIST *PreAuthData
    );

//
NTSTATUS WINAPI
kcl_BuildPcMachineRequest(
    IN BYTE* pTicket_Incoming,    //this is apparently the passport ticket
    UINT32 cbTicket,
    IN BYTE* pPcId_Incoming,
    UINT32 cbPcId,
    IN LPCSTR pSponsorToken_Incoming,
    IN BYTE* pSessionKey_Incoming,
    UINT32 cbSessionKey,
    IN LPSTR pszClientName_Incoming,           // "PC.@XBOX.COM"
    IN LPSTR pszTargetRealm_Incoming,          // "XBOX.COM"
    IN LPSTR pszClientRealm_Incoming,          // "MACS.XBOX.COM"
    IN const DWORD *pPreauthTypeList, // array of preauth types to include
    IN DWORD PreauthTypeListLength,
    IN BOOL bUseTestXmacsKey,
    OUT PUCHAR pbRequestMessage,
    IN OUT PULONG pdwRequestMessageLength,
    IN OUT PXKERB_TGT_CONTEXT pTGTContext
    )
{
    ClearStoredDebugSpew();

    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr = KDC_ERR_NONE;
    KERB_KDC_REQUEST TicketRequest;
    PKERB_KDC_REQUEST_BODY RequestBody = &TicketRequest.request_body;
    ULONG KdcFlagOptions;
    KERB_ENCRYPTION_KEY ClientKey;
    KERB_MESSAGE_BUFFER RequestMessage;
    CScratchMemoryAllocator ScratchMemoryAllocator;
    DWORD i,j;
    char* p;
    HRESULT hr;

    Assert( pTGTContext->ctNumNonces < MAX_KERB_RETRIES + MAX_TIME_ADJUSTMENTS );

    //Determine the request type we are making based on preauth
    DWORD requestVersion=1;
    for (i=0; i<PreauthTypeListLength; ++i)
    {
        if (pPreauthTypeList[i]==KRB5_PADATA_PC_ACCOUNT_CREATION2)
            requestVersion=2;
    }

    //copy data before fuzzing
    BYTE *pTicket=new BYTE[cbTicket];
    memcpy(pTicket,pTicket_Incoming,cbTicket);
    AutoFreePointerArray<BYTE> freeTicket(pTicket);

    BYTE *pPcId=new BYTE[cbPcId];
    memcpy(pPcId,pPcId_Incoming,cbPcId);
    AutoFreePointerArray<BYTE> freePCID(pPcId);

    unsigned int sponsorTokenLen=strlen(pSponsorToken_Incoming)+1;
    char *pSponsorToken=new char[sponsorTokenLen];
    memcpy(pSponsorToken,pSponsorToken_Incoming,sponsorTokenLen);
    AutoFreePointerArray<char> freeSponsorToken(pSponsorToken);

    BYTE *pSessionKey=new BYTE[cbSessionKey];
    memcpy(pSessionKey,pSessionKey_Incoming,cbSessionKey);
    AutoFreePointerArray<BYTE> freeSessionKey(pSessionKey);

    unsigned int clientNameLen=strlen(pszClientName_Incoming)+1;
    char *pszClientName=new char[clientNameLen];
    memcpy(pszClientName,pszClientName_Incoming,clientNameLen);
    AutoFreePointerArray<char> freeClientName(pszClientName);

    unsigned int targetRealmLen=strlen(pszTargetRealm_Incoming)+1;
    char *pszTargetRealm=new char[targetRealmLen];
    memcpy(pszTargetRealm,pszTargetRealm_Incoming,targetRealmLen);
    AutoFreePointerArray<char> freeTargetRealm(pszTargetRealm);

    unsigned int clientRealmLen=strlen(pszClientRealm_Incoming)+1;
    char *pszClientRealm=new char[clientRealmLen];
    memcpy(pszClientRealm,pszClientRealm_Incoming,clientRealmLen);
    AutoFreePointerArray<char> freeClientRealm(pszClientRealm);

    //PXKERB_TGT_CONTEXT pTGTContext //is both in and out, so we don't copy this.

    //fuzz
    if (requestFuzz.kcl_BuildPcMachineRequest)
    {
        FuzzArray(pTicket, cbTicket, requestFuzz.ticket);
        FuzzArray(pPcId, cbPcId, requestFuzz.misc);
        FuzzNullString(pSponsorToken, requestFuzz.strings);
        FuzzArray(pSessionKey, cbSessionKey, requestFuzz.keys);
        FuzzNullString(pszClientName, requestFuzz.strings);
        FuzzNullString(pszTargetRealm, requestFuzz.strings);
        FuzzNullString(pszClientRealm, requestFuzz.strings);
        FuzzStructBits(pTGTContext, requestFuzz.tgt);
    }

    // Initialize scratch memory
    ScratchMemoryAllocator.ScratchMemoryInitialize( SCRATCH_MEMORY_SIZE_FOR_BuildAsRequest, pbRequestMessage, *pdwRequestMessageLength);

    ZeroMemory(&TicketRequest, sizeof(TicketRequest));

    BYTE nonce[PA_PC_ACCOUNT_CREATION::NONCE_LENGTH];
    TestKerbRandom(nonce, sizeof(nonce));

    if (requestVersion==2)
    {
        //Principal key is just the session key
        KerbCreateKeyFromBuffer(
            &ClientKey,
            pSessionKey,
            XONLINE_KEY_LENGTH,
            KERB_ETYPE_RC4_HMAC_NT
            );
    }
    else
    {
        //Derive Principal Key from session key and nonce
        BYTE keybytes[20];

        XcHMAC4(pSessionKey,        cbSessionKey,
                nonce,              sizeof(nonce),
                NULL,               0,
                NULL,               0,
                NULL,               0,
                keybytes,           sizeof(keybytes));

        KerbCreateKeyFromBuffer(
            &ClientKey,
            keybytes,
            XONLINE_KEY_LENGTH,
            KERB_ETYPE_RC4_HMAC_NT
            );
    }

    // Stick all the PA data in the request
    TicketRequest.KERB_KDC_REQUEST_preauth_data = NULL;

    memcpy( pTGTContext->CompoundKey, ClientKey.keyvalue.value, XONLINE_KEY_LENGTH );

    for (DWORD ptlInd=0; ptlInd<PreauthTypeListLength; ++ptlInd)
    {
        if (pPreauthTypeList[ptlInd]==KRB5_PADATA_PC_ACCOUNT_CREATION)
        {
            hr = AddPcAccountCreationPreAuth(
                &ScratchMemoryAllocator,
                sizeof(nonce),
                nonce,
                (UINT16)cbTicket,
                pTicket,
                (UINT16)cbPcId,
                pPcId,
                strlen(pSponsorToken),
                (BYTE*) pSponsorToken,
                &ClientKey,
                &TicketRequest.KERB_KDC_REQUEST_preauth_data);

            if(FAILED(hr))
            {
                return STATUS_UNSUCCESSFUL;
            }
        }
        else if (pPreauthTypeList[ptlInd]==KRB5_PADATA_PC_ACCOUNT_CREATION2)
        {
            hr = AddPcAccountCreation2PreAuth(
                &ScratchMemoryAllocator,
                bUseTestXmacsKey,
                (UINT16)cbTicket,
                pTicket,
                (UINT16)cbPcId,
                pPcId,
                strlen(pSponsorToken),
                (BYTE*) pSponsorToken,
                &ClientKey,
                &TicketRequest.KERB_KDC_REQUEST_preauth_data);

            if(FAILED(hr))
            {
                return STATUS_UNSUCCESSFUL;
            }
        }
        else if (AddSharedPreauthToPAList( // for common shared types
            &ScratchMemoryAllocator,
            pPreauthTypeList[ptlInd],
            0,
            0,
            0,
            false,
            &ClientKey,
            RequestBody,
            0,
            0,
            0,
            &TicketRequest,
            &Status
            ))
        {
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
        }
        else //unhandled pre-auth types generate a "fake preauth" ... type is set and 64 bytes of fe data is used
        {
            Status = KerbAddFakeTypePreauth(
                &ScratchMemoryAllocator,
                pPreauthTypeList[ptlInd],
                &TicketRequest.KERB_KDC_REQUEST_preauth_data
                );

            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
        }
    }

    if (TicketRequest.KERB_KDC_REQUEST_preauth_data != NULL)
    {
        TicketRequest.bit_mask |= _XNetLittleEndianUshort(KERB_KDC_REQUEST_preauth_data_present);
    }

    //
    // Build the request
    //

    KdcFlagOptions = _XNetNetworkEndianUlong(KERB_DEFAULT_TICKET_FLAGS);
    RequestBody->kdc_options.value = (PUCHAR) &KdcFlagOptions;
    RequestBody->kdc_options.length = sizeof(ULONG) * 8;

    TestKerbRandom((BYTE *)&RequestBody->nonce, sizeof(RequestBody->nonce));

    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->endtime,
        NULL,
        &g_KerbGlobalWillNeverTime
        );

    // fill in client principal name

    KerbErr = KerbConstructPrincipalName(
                &ScratchMemoryAllocator,
                &RequestBody->KERB_KDC_REQUEST_BODY_client_name,
                KRB_NT_ENTERPRISE_PRINCIPAL,
                pszClientName
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RequestBody->bit_mask |= _XNetLittleEndianUshort(KERB_KDC_REQUEST_BODY_client_name_present);

    Assert( strlen(pszTargetRealm) <= XONLINE_MAX_KERBEROSREALM_LENGTH );
    strncpy(pTGTContext->TargetRealm, pszTargetRealm,sizeof(pTGTContext->TargetRealm));
    pTGTContext->TargetRealm[sizeof(pTGTContext->TargetRealm) - 1] = 0;

    //
    // Fill in the strings in the ticket request
    //
    KerbErr = KerbConstructPrincipalName(
                &ScratchMemoryAllocator,
                &RequestBody->KERB_KDC_REQUEST_BODY_server_name,
                KRB_NT_SRV_INST,
                KDC_PRINCIPAL_NAME,
                pszTargetRealm
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    RequestBody->bit_mask |= _XNetLittleEndianUshort(KERB_KDC_REQUEST_BODY_server_name_present);

    RequestBody->realm = pszClientRealm;

    TicketRequest.version = KERBEROS_VERSION;
    TicketRequest.message_type = KRB_AS_REQ;

    //
    // Build crypt list
    //

    RequestBody->encryption_type = &g_RC4HMAC_CryptList;

    //
    // Pack the request
    //
    RequestMessage.BufferSize = *pdwRequestMessageLength;
    RequestMessage.Buffer = pbRequestMessage;
    KerbErr = KerbPackAsRequest(
                &ScratchMemoryAllocator,
                &TicketRequest,
                &RequestMessage.BufferSize,
                &RequestMessage.Buffer
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    *pdwRequestMessageLength = RequestMessage.BufferSize;

    j = 0;
    if (pTGTContext->pInputTGTContext != NULL)
    {
        pTGTContext->MachineID = pTGTContext->pInputTGTContext->MachineID;
        for (i=0; i<XONLINE_MAX_LOGON_USERS; ++i)
        {
            if (pTGTContext->pInputTGTContext->UserID[i] != 0)
            {
                pTGTContext->UserID[j++] = pTGTContext->pInputTGTContext->UserID[i];
            }
        }
    }
    Assert( j <= XONLINE_MAX_LOGON_USERS );
    pTGTContext->Nonce[pTGTContext->ctNumNonces++] = RequestBody->nonce;
    memcpy( pTGTContext->ClientKey, ClientKey.keyvalue.value, XONLINE_KEY_LENGTH );
    Status = STATUS_SUCCESS;

Cleanup:
    return(Status);
}

// --------------------------------------------------------------------------------------
// kcl_VerifyPcMachine
// --------------------------------------------------------------------------------------
NTSTATUS WINAPI
kcl_VerifyPcMachine(
    IN  PUCHAR pbReplyMessage,
    IN  ULONG dwReplyMessageLength,
    IN  PXKERB_TGT_CONTEXT pTGTContext,
    OUT XONLINEP_USER* pusr
    )
{
    ClearStoredDebugSpew();

    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_KDC_REPLY KdcReply = NULL;
    PKERB_ENCRYPTED_KDC_REPLY ReplyBody = NULL;
    KERB_ENCRYPTION_KEY CompoundKey;
    PKERB_ERROR ErrorMessage = NULL;
    PUCHAR pEncodedTicket;
    PKERB_PA_DATA pPreAuthData = NULL;
    const UCHAR* pbScratchMemory;
    CScratchMemoryAllocator ScratchMemoryAllocator;
    DWORD iNonceMatch;

    //
    // Initialize scratch memory
    //
    pbScratchMemory = (PUCHAR)ScratchMemoryAllocator.ScratchMemoryInitialize( SCRATCH_MEMORY_SIZE_FOR_VerifyAsReply, NULL, 0);

    KerbErr = KerbUnpackAsReply(
                &ScratchMemoryAllocator,
                pbReplyMessage,
                dwReplyMessageLength,
                &KdcReply
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        //
        // Try to unpack it as  kerb_error
        //
        KerbErr =  KerbUnpackKerbError(
                        &ScratchMemoryAllocator,
                        pbReplyMessage,
                        dwReplyMessageLength,
                        &ErrorMessage
                        );
        if (KERB_SUCCESS(KerbErr))
        {
            KerbErr = (KERBERR) ErrorMessage->error_code;
            TraceSz1( AuthWarn,"kcl_VerifyPcMachine: Got KerbError 0x%X", KerbErr );

            Status = KerbMapKerbError(KerbErr);

            iNonceMatch = pTGTContext->ctNumNonces;
            if ((ErrorMessage->bit_mask & error_text_present) &&
                ErrorMessage->error_text.length == sizeof(DWORD) &&
                ErrorMessage->error_text.value != NULL)
            {
                for (iNonceMatch=0; iNonceMatch<pTGTContext->ctNumNonces; ++iNonceMatch)
                {
                    if (memcmp( &(pTGTContext->Nonce[iNonceMatch]), ErrorMessage->error_text.value, sizeof(DWORD)) == 0)
                    {
                        break;
                    }
                }
            }
            if (iNonceMatch == pTGTContext->ctNumNonces)
            {
                TraceSz( AuthWarn, "kcl_VerifyPcMachine: got a kerb error with a mismatching nonce, ignoring it" );
                Status = STATUS_LOGON_FAILURE;
                goto Cleanup;
            }

            if ((ErrorMessage->bit_mask & error_data_present) &&
                ErrorMessage->error_data.length != 0 &&
                ErrorMessage->error_data.value != NULL)
            {
                if (ErrorMessage->error_data.length <= sizeof(pTGTContext->EchoPreAuth))
                {
                    pTGTContext->cbEchoPreAuth = ErrorMessage->error_data.length;
                    memcpy( pTGTContext->EchoPreAuth, ErrorMessage->error_data.value, ErrorMessage->error_data.length );
                }
                else
                {
                    TraceSz1( AuthWarn, "kcl_VerifyPcMachine: got a echo preauth request too big: %d", ErrorMessage->error_data.length );
                }
            }

            //
            // Check for time skew. If so, calculate the skew and retry
            //
            if (KerbErr == KRB_AP_ERR_SKEW)
            {
                TimeStamp KdcTime;
                //TimeStamp XboxTime;

                KerbConvertGeneralizedTimeToLargeInt(
                    &KdcTime,
                    &ErrorMessage->server_time,
                    ErrorMessage->server_usec
                    );

                //KerbGetCurrentTime(&XboxTime);
                //pTGTContext->qwTimeOffset = KerbGetOffsetBetweenTime( &XboxTime, &KdcTime );
                KerbUpdateCurrentTime( KdcTime );
            }
            goto Cleanup;
        }
        else
        {
            Status = STATUS_LOGON_FAILURE;
        }

        goto Cleanup;
    }

    KerbCreateKeyFromBuffer(
        &CompoundKey,
        pTGTContext->CompoundKey,
        XONLINE_KEY_LENGTH,
        KERB_ETYPE_RC4_HMAC_NT
        );


    //
    // Now unpack the reply body:
    //
    KerbErr = KerbUnpackKdcReplyBody(
                &ScratchMemoryAllocator,
                &KdcReply->encrypted_part,
                &CompoundKey,
                KERB_ENCRYPTED_AS_REPLY_PDU,
                &ReplyBody
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    //
    // Verify the nonce is correct:
    //
    for (iNonceMatch=0; iNonceMatch<pTGTContext->ctNumNonces; ++iNonceMatch)
    {
        if (pTGTContext->Nonce[iNonceMatch] == (DWORD)ReplyBody->nonce)
        {
            break;
        }
    }
    if (iNonceMatch == pTGTContext->ctNumNonces)
    {
        TraceSz3( AuthWarn, "kcl_VerifyPcMachine: All %d Nonces don't match: 0x%X vs 0x%X", iNonceMatch, pTGTContext->Nonce[0], ReplyBody->nonce);
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }
    
    //
    // Find XKERB_PA_XBOX_ACCOUNT_CREATION pre-auth
    //
    if ((KdcReply->bit_mask & KERB_KDC_REPLY_preauth_data_present) != 0)
    {
        pPreAuthData = KerbFindPreAuthDataEntry(
                        KRB5_PADATA_PC_ACCOUNT_CREATION,
                        (PKERB_PA_DATA_LIST)KdcReply->preauth_data
                        );
    }

    if(pPreAuthData)
    {
        // Verify pre-auth. Machine account data is embedded.
        
        CReleaseAllScratchMemoryUponDestruction onlyPreserveThisMemory( &ScratchMemoryAllocator );
        
        KerbErr = VerifyPcAccountCreationPreAuthReply(
            &ScratchMemoryAllocator,
            pPreAuthData,
            &CompoundKey,
            pTGTContext,
            pusr
            );
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = KerbErr;
            goto Cleanup;
        }
    }
    else
    {
        TraceSz(AuthWarn, "kcl_VerifyPcMachine: Can't find KRB5_PADATA_PC_ACCOUNT_CREATION pre-auth");
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    //
    // Cache the session key
    //
    if (ReplyBody->session_key.keytype != KERB_ETYPE_RC4_HMAC_NT ||
        ReplyBody->session_key.keyvalue.length != XONLINE_KEY_LENGTH)
    {
        TraceSz( AuthWarn, "kcl_VerifyPcMachine: got a session key of the wrong type or length" );
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    memcpy( pTGTContext->SessionKey, ReplyBody->session_key.keyvalue.value, XONLINE_KEY_LENGTH );

    //
    // Copy the principal name (might be different because of name canonicalization)
    //
    KerbErr = KerbPrincipalNameToMultiString(
        &KdcReply->client_name,
        sizeof(pTGTContext->ClientName),
        pTGTContext->ClientName
        );
    if (!KERB_SUCCESS(KerbErr))
    {
        TraceSz( AuthWarn, "kcl_VerifyPcMachine: returned client name is too long" );
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    if ( strlen(KdcReply->client_realm) <= XONLINE_MAX_KERBEROSREALM_LENGTH )
    {
        lstrcpynA(pTGTContext->ClientRealm, KdcReply->client_realm, sizeof(pTGTContext->ClientRealm));
    }
    else
    {
        TraceSz( AuthWarn, "kcl_VerifyPcMachine: returned client realm is too long" );
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    //
    // Cache expiration time
    //
    KerbConvertGeneralizedTimeToLargeInt(
        &pTGTContext->ExpirationTime,
        &ReplyBody->endtime,
        0
        );

    KerbConvertGeneralizedTimeToLargeInt(
        &pTGTContext->StartTime,
        &ReplyBody->starttime,
        0
        );

    //
    // Verbose trace info
    //
    TraceSz6( AuthVerbose,"kcl_VerifyPcMachine: extracted %d byte ticket (expires in %d secs) from %d byte reply matching try %d for %s KerbRealm:%s",
        pTGTContext->dwTicketLength,
        (ULONG)((pTGTContext->ExpirationTime.QuadPart -pTGTContext->StartTime.QuadPart) / 10000000),
        dwReplyMessageLength, iNonceMatch + 1,
        KdcReply->client_name.name_string->value,
        KdcReply->client_realm);

Cleanup:
    return(Status);
}

// --------------------------------------------------------------------------------------
// AddPcAccountCreationPreAuth
// --------------------------------------------------------------------------------------
static HRESULT AddPcAccountCreationPreAuth(
    CScratchMemoryAllocator*    pScratchAlloc,
    UINT16                      cbNonce,
    BYTE*                       pNonce,
    UINT16                      cbTicket,
    BYTE*                       pTicket,
    UINT16                      cbPcId,
    BYTE*                       pPcId,
    UINT16                      cbSponsorToken,
    const BYTE*                 pSponsorToken,    
    const KERB_ENCRYPTION_KEY*  pKey,
    IN OUT PKERB_PA_DATA_LIST*  ppPreAuthData
    )
{
    HRESULT hr = E_FAIL;

    // Allocate a scratch buffer from the scratch allocator for the request. At first 
    // allocate for the worst case. We'll adjust it at the end.
    const int SCRATCH_LEN = 2048;
    BYTE* pScratch = (BYTE*) pScratchAlloc->Alloc(SCRATCH_LEN);
    if(!pScratch)
    {
        return E_OUTOFMEMORY;
    }

    CMemoryStream ms;
    ms.Attach(pScratch, SCRATCH_LEN, 0);

//     Verify field sizes
//     These are great for mainline, but get in the way of negative test cases
//     if(cbNonce != PA_PC_ACCOUNT_CREATION::NONCE_LENGTH ||
//        !IS_BETWEEN(cbTicket, 1, PA_PC_ACCOUNT_CREATION::TICKET_MAX_LENGTH) ||
//        cbPcId !=  PA_PC_ACCOUNT_CREATION::PC_ID_LENGTH ||
//        !IS_BETWEEN(cbSponsorToken, 1, PA_PC_ACCOUNT_CREATION::SPONSOR_TOKEN_MAX_LENGTH))
//     {
//         return E_INVALIDARG;
//     }

    // Write non-encrypted data first
    BOOL ok = TRUE;

    ok = ok && ms.Write(pNonce, PA_PC_ACCOUNT_CREATION::NONCE_LENGTH);
    ok = ok && ms.WriteUInt16(cbTicket);
    if (cbTicket > 0)
    {
        ok = ok && ms.Write(pTicket, cbTicket);
    }

    if(!ok)
    {
        TraceSz(AuthWarn, "not ok");
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    // Add encrypted data
    hr = WritePcAccountCreationEncryptedData(
        pPcId,
        cbSponsorToken,
        (const BYTE*) pSponsorToken,
        pKey,
        &ms);

    if(FAILED(hr))
    {
        return hr;
    }

    // Adjust allocation
    UINT32 cbPreAuth = (UINT32) ms.GetLength();

    BYTE* pPreAuth = (BYTE*) pScratchAlloc->ImmediateReAlloc(pScratch, SCRATCH_LEN, 
                                                             cbPreAuth);

    if(!pPreAuth)
    {
        return E_UNEXPECTED;
    }

    // Add it to pre-auth list
    KERB_PA_DATA_LIST* pListElement = (KERB_PA_DATA_LIST*) pScratchAlloc->Alloc(
        sizeof(KERB_PA_DATA_LIST));

    if(!pListElement)
    {
        return E_OUTOFMEMORY;
    }

    pListElement->value.preauth_data_type   = KRB5_PADATA_PC_ACCOUNT_CREATION;
    pListElement->value.preauth_data.length = (ASN1uint32_t) ms.GetLength();
    pListElement->value.preauth_data.value  = pPreAuth;
    pListElement->next = *ppPreAuthData;
    *ppPreAuthData = pListElement;

    return S_OK;
}

// --------------------------------------------------------------------------------------
// AddPcAccountCreation2PreAuth
// --------------------------------------------------------------------------------------
static HRESULT AddPcAccountCreation2PreAuth(
    CScratchMemoryAllocator*    pScratchAlloc,
    BOOL                        bUseTestXmacsKey,
    UINT16                      cbTicket,
    BYTE*                       pTicket,
    UINT16                      cbPcId,
    BYTE*                       pPcId,
    UINT16                      cbSponsorToken,
    const BYTE*                 pSponsorToken,
    const KERB_ENCRYPTION_KEY*  pKey,
    IN OUT PKERB_PA_DATA_LIST*  ppPreAuthData
    )
{
    // Allocate a scratch buffer from the scratch allocator for the request. At first allocate for the worst case. We'll adjust it at the end.
    const int SCRATCH_LEN=2048;
    BYTE* pScratch=(BYTE*)pScratchAlloc->Alloc(SCRATCH_LEN);
    if(!pScratch)
    {
        return E_OUTOFMEMORY;
    }

    CMemoryStream ms;
    ms.Attach(pScratch, SCRATCH_LEN, 0);

    // Create the inner data portion of the preauth that will be encrypted
    TimeStamp authTime;
    KerbGetCurrentTime(&authTime);

    PA_PC_ACCOUNT_CREATION_ENCRYPTED_DATA2 encPart;
    encPart.qwAuthtime=authTime.QuadPart;
    encPart.pcId=0;
    memcpy(&encPart.pcId, pPcId, std::min((UINT16)8, cbPcId));
    encPart.ticketLen=cbTicket;
    encPart.ticket.insert(encPart.ticket.begin(), &pTicket[0], &pTicket[cbTicket]);
    encPart.sponsorTokenLen=cbSponsorToken;
    encPart.sponsorToken.insert(encPart.sponsorToken.begin(), &pSponsorToken[0], &pSponsorToken[cbSponsorToken]);

    // Pack the encrypted blob into the outter preauth
    PA_PC_ACCOUNT_CREATION_REQ2 req;
    std::vector<BYTE> innerBlobRaw=encPart.Serialize();

    std::tr1::array<BYTE, 2038> encScratch;
    KERB_ENCRYPTED_DATA encData;
    memset(&encData, 0, sizeof(encData));
    encData.encryption_type=KERB_ETYPE_RC4_HMAC_NT;
    encData.cipher_text.length=encScratch.size();
    encData.cipher_text.value=encScratch.data();
    if (!KERB_SUCCESS(KerbEncryptDataEx(NULL, &encData, innerBlobRaw.size(), &innerBlobRaw.front(), KERB_ETYPE_RC4_HMAC_NT, KERB_PA_PC_ACCOUNT_CREATION_SALT, pKey)))
    {
        TraceSz(AuthWarn, "Failed to encrypt inner blob of preauth2");
        return STATUS_ENCRYPTION_FAILED;
    }

    req.encData.resize(innerBlobRaw.size()+1024);
    DWORD outputFinalSize=req.encData.size();
    BYTE *pEncData=&req.encData.front();
    if (!KERB_SUCCESS(KerbPackData(pScratchAlloc, &encData, KERB_ENCRYPTED_DATA_PDU, &outputFinalSize, (PUCHAR*)&pEncData)))
    {
        return STATUS_UNSUCCESSFUL;
    }
    req.encDataLen=(UINT16)outputFinalSize;
    req.encData.resize(outputFinalSize);

    // Encrypt the session key with the xmacs public key and store that into the outter preauth
    memcpy(req.abEncSessionKey.data(), pKey->keyvalue.value, pKey->keyvalue.length);
    DWORD cb=pKey->keyvalue.length;

    if (bUseTestXmacsKey)
    {
        if(!g_ClientCrypt.EncryptWithXmacsTestKey(req.abEncSessionKey.data(), &cb, req.abEncSessionKey.size()))
        {
            TraceSz(AuthWarn, "Failed to encrypt session key with test key");
            return STATUS_ENCRYPTION_FAILED;
        }
    }
    else
    {
        if(!g_ClientCrypt.EncryptWithXmacsKey(req.abEncSessionKey.data(), &cb, req.abEncSessionKey.size()))
        {
            TraceSz(AuthWarn, "Failed to encrypt session key");
            return STATUS_ENCRYPTION_FAILED;
        }
    }

    // Copy it to the scratch memory and adjust allocation
    std::vector<BYTE> preauthBlob=req.Serialize();
    ms.Write(&preauthBlob[0], preauthBlob.size());
    UINT32 cbPreAuth=(UINT32)ms.GetLength();
    BYTE *pPreAuth=(BYTE*) pScratchAlloc->ImmediateReAlloc(pScratch, SCRATCH_LEN, cbPreAuth);

    if(!pPreAuth)
    {
        return E_UNEXPECTED;
    }

    // Add it to pre-auth list
    KERB_PA_DATA_LIST* pListElement=(KERB_PA_DATA_LIST*)pScratchAlloc->Alloc(sizeof(KERB_PA_DATA_LIST));

    if(!pListElement)
    {
        return E_OUTOFMEMORY;
    }

    pListElement->value.preauth_data_type=KRB5_PADATA_PC_ACCOUNT_CREATION2;
    pListElement->value.preauth_data.length=(ASN1uint32_t)ms.GetLength();
    pListElement->value.preauth_data.value=pPreAuth;
    pListElement->next=*ppPreAuthData;
    *ppPreAuthData=pListElement;

    return S_OK;
}

// --------------------------------------------------------------------------------------
// WritePcAccountCreationEncryptedData
// --------------------------------------------------------------------------------------
static HRESULT WritePcAccountCreationEncryptedData(
    BYTE*                       pPcId,
    UINT16                      cbSponsorToken,
    const BYTE*                 pSponsorToken,
    const KERB_ENCRYPTION_KEY*  pKey, 
    CMemoryStream*              pms
)
{
    // First format the data in a buffer
    
    BYTE scratch[2048];
    CMemoryStream msData;

    msData.Attach(scratch, sizeof(scratch), 0);

    BOOL ok = TRUE;
    ok = ok && msData.Write(pPcId, PA_PC_ACCOUNT_CREATION::PC_ID_LENGTH);
    ok = ok && msData.WriteUInt16(cbSponsorToken);
    ok = ok && msData.Write((void*)pSponsorToken, cbSponsorToken);

    if(!ok)
    {
        TraceSz(AuthWarn, "not ok");
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    // Encrypt

    BYTE scratch2[2038];
    KERBERR kerberr;
    KERB_ENCRYPTED_DATA encdata;

    memset(&encdata, 0, sizeof(encdata));

    encdata.encryption_type = KERB_ETYPE_RC4_HMAC_NT;
    encdata.cipher_text.length = sizeof(scratch2);
    encdata.cipher_text.value = scratch2;

    kerberr = KerbEncryptDataEx(
        NULL /* pScratchMemoryAllocator */, 
        &encdata,
        (ULONG)msData.GetLength(),
        (PUCHAR)msData.GetBuffer(),
        KERB_ETYPE_RC4_HMAC_NT,
        KERB_PA_PC_ACCOUNT_CREATION_SALT,
        pKey);

    if(!KERB_SUCCESS(kerberr))
    {
        return HRESULT_FROM_WIN32(ERROR_ENCRYPTION_FAILED);
    }

    // Pack

    CScratchMemoryAllocator scratchMemAlloc;
    scratchMemAlloc.ScratchMemoryInitializeHelper(scratch, sizeof(scratch), NULL, 0);
    BYTE packedData[2048];
    PUCHAR pPacketData = (PUCHAR) packedData;
    UINT32 cbPackedData = sizeof(packedData);

    C_ASSERT(sizeof(cbPackedData) == sizeof(ULONG));

    kerberr = KerbPackData(
        &scratchMemAlloc,
        &encdata,
        KERB_ENCRYPTED_DATA_PDU,
        (ULONG*) &cbPackedData,
        (PUCHAR*)&pPacketData
        );

    if(!KERB_SUCCESS(kerberr))
    {
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    ok = pms->WriteUInt16((UINT16)cbPackedData);
    ok = ok && pms->Write(packedData, cbPackedData);

    if(!ok)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}
        
// --------------------------------------------------------------------------------------
// VerifyPcAccountCreationPreAuthReply
// --------------------------------------------------------------------------------------
static KERBERR VerifyPcAccountCreationPreAuthReply(
    CScratchMemoryAllocator* pScratchAlloc,
    PKERB_PA_DATA            pPreAuthData,
    KERB_ENCRYPTION_KEY*     pKey,
    XKERB_TGT_CONTEXT*       pTGTContext,
    OUT XONLINEP_USER*       pusr
    )
{
    KERB_ENCRYPTED_DATA* pEncData = NULL;
    KERBERR kerberr = KRB_ERR_GENERIC;
    
    CReleaseAllScratchMemoryUponDestruction onlyPreserveThisMemory(pScratchAlloc);

    // Unpack
    
    kerberr = KerbUnpackEncryptedData(
        pScratchAlloc,
        pPreAuthData->preauth_data.value,
        pPreAuthData->preauth_data.length,
        &pEncData
        );
    if(!KERB_SUCCESS(kerberr))
    {
        goto Cleanup;
    }

    // Decrypt in place

    BYTE scratch[1000];
    UINT32 cbScratch = sizeof(scratch);

    if(pEncData->cipher_text.length > sizeof(scratch))
    {
        TraceSz(AuthWarn, "VerifyPcAccountCreationPreAuthReply: unpacked pre-auth is too large");
        kerberr = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    C_ASSERT(sizeof(cbScratch) == sizeof(ULONG));

    kerberr = KerbDecryptDataEx(
        pScratchAlloc,
        pEncData,
        pKey,
        KERB_PA_PC_ACCOUNT_CREATION_REP_SALT,
        (ULONG*)&cbScratch,
        scratch);

    if(!KERB_SUCCESS(kerberr))
    {
        goto Cleanup;
    }

    // Parse

    if(cbScratch != sizeof(PA_PC_ACCOUNT_CREATION_REP))
    {
        TraceSz(AuthWarn, "VerifyPcAccountCreationPreAuthReply: pre-auth has the wrong size");
        kerberr = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    PA_PC_ACCOUNT_CREATION_REP* pReply = (PA_PC_ACCOUNT_CREATION_REP*) scratch;
    
    memset(pusr, 0, sizeof(XONLINEP_USER));
    pusr->xuid.qwUserID = pReply->machineId,
    pusr->xuid.dwUserFlags = 0;

    // XMACS does not return a gamertag for PCs. Instead we're going to use the machine 
    // id to create a gamertag
    {
        CTinyStr gamertag;
        gamertag.Format("PC.%012I64X", (pReply->machineId & ~PUID_BASE_MASK)).cstr();
        strcpy(pusr->gamertag, gamertag.cstr());
    }

    strcpy(pusr->domain, XBOX_KERBEROS_REALM);
    strcpy(pusr->kerberosRealm, XBOX_KERBEROS_REALM);
    memset(pusr->passcode, 0, 4);
    memcpy(pusr->key, pReply->machineKey, XONLINE_KEY_LENGTH);

    kerberr = KDC_ERR_NONE;

Cleanup:

    return kerberr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\kerbclient\rc4hmac.h ===
#ifndef RC4HMAC_H
#define RC4HMAC_H

#include "sha.h"

/* Two names for number of bytes output by MD5 */
#define MD5DIGESTLEN 16
#define MD5_LEN MD5DIGESTLEN

void shaHmac(
    IN PBYTE pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PBYTE pbData,
    IN ULONG cbData,
    IN PBYTE pbData2,
    IN ULONG cbData2,
    OUT PBYTE HmacData // length must be A_SHA_DIGEST_LEN
    );

void md5Hmac(
    IN PBYTE pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PBYTE pbData,
    IN ULONG cbData,
    IN PBYTE pbData2,
    IN ULONG cbData2,
    OUT PBYTE HmacData // length must be MD5_LEN
    );

#define RC4_CONFOUNDER_LEN 8

typedef struct RC4_SHA1_HEADER {
    UCHAR Checksum[A_SHA_DIGEST_LEN];
    UCHAR Confounder[RC4_CONFOUNDER_LEN];
} *PRC4_SHA1_HEADER;

typedef struct RC4_MD5_HEADER {
    UCHAR Checksum[MD5_LEN];
    UCHAR Confounder[RC4_CONFOUNDER_LEN];
} *PRC4_MD5_HEADER;

void rc4Sha1HmacEncrypt(
    IN PUCHAR confounder, // RC4_CONFOUNDER_LEN bytes
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbHeader // A_SHA_DIGEST_LEN + RC4_CONFOUNDER_LEN bytes
    );

BOOL rc4Sha1HmacDecrypt(
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    IN PUCHAR pbHeader // A_SHA_DIGEST_LEN + RC4_CONFOUNDER_LEN bytes
    );

void rc4Md5HmacEncrypt(
    IN PUCHAR confounder, // RC4_CONFOUNDER_LEN bytes
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbHeader // MD5_LEN + RC4_CONFOUNDER_LEN bytes
    );

BOOL rc4Md5HmacDecrypt(
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    IN PUCHAR pbHeader // MD5_LEN + RC4_CONFOUNDER_LEN bytes
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\kerbclient\ticketbuilder.cpp ===
#include "xonp.h"
#include "kerbfuzz.h"

static VOID
SetString(
    IN CScratchMemoryAllocator *pScratchMemoryAllocator,
    IN CONST LPSTR              pSourceStr,
    OUT PUCHAR                 *ppDestStr
    )
{
    int n = strlen((const char *)pSourceStr);
    *ppDestStr = (PUCHAR)pScratchMemoryAllocator->Alloc(n+1);
    lstrcpynA((LPSTR)(*ppDestStr), (const char *)pSourceStr, n+1);
    (*ppDestStr)[n] = 0;
}   


static VOID 
EncryptTicket(
    IN OUT BYTE *pbTicket, 
    IN ULONG cbTicket, 
    IN BYTE* bKey, 
    IN ULONG ulSaltType)
{
    BYTE pbConfounder[RC4_CONFOUNDER_LEN];
    memset(pbConfounder, 0, RC4_CONFOUNDER_LEN);  //TODO: randomize confounder

    const INT cbKey = 16;

    BYTE ulSaltedKey[MD5_LEN];
    md5Hmac(bKey, cbKey, (PBYTE)&ulSaltType, sizeof(ULONG), NULL, 0, ulSaltedKey);

    rc4Md5HmacEncrypt(pbConfounder, ulSaltedKey, MD5_LEN, pbTicket + sizeof(RC4_MD5_HEADER), cbTicket - sizeof(RC4_MD5_HEADER), pbTicket);
}


KERBERR
BuildTicketTimesAndFlags(
    IN CScratchMemoryAllocator *pScratchMemoryAllocator,
    IN PLARGE_INTEGER MaxTicketLifespan,
    IN OUT PKERB_ENCRYPTED_TICKET Ticket
    )
{
    LARGE_INTEGER tsInfinity = {0xffffffff,0x7fffffff};

    KERBERR KerbErr = KDC_ERR_NONE;
    TimeStamp CurrentTime = {0};
    TimeStamp FinalEndTime = {0};
    TimeStamp FinalStartTime = {0};

    KerbGetCurrentTime(&CurrentTime);

    // Set authtime to current
    KerbConvertLargeIntToGeneralizedTime(
        &Ticket->authtime,
        NULL,
        &CurrentTime
        );

    // Calculate some times
    FinalStartTime = CurrentTime;
    FinalEndTime = tsInfinity;
    if (FinalEndTime.QuadPart > CurrentTime.QuadPart + MaxTicketLifespan->QuadPart)
    {
        FinalEndTime.QuadPart = CurrentTime.QuadPart + MaxTicketLifespan->QuadPart;
    }

    // Fill in the times in the ticket
    KerbConvertLargeIntToGeneralizedTime(
        &Ticket->KERB_ENCRYPTED_TICKET_starttime,
        NULL,
        &FinalStartTime
        );
    Ticket->bit_mask |= KERB_ENCRYPTED_TICKET_starttime_present;

    KerbConvertLargeIntToGeneralizedTime(
        &Ticket->endtime,
        NULL,
        &FinalEndTime
        );
   
    // TODO: Should we fill in ticket flags here, or is there nothing to fake?
    // I think the value is 0
    

    return(KerbErr);
}


KERBERR
BuildTicketTGS(
    IN CScratchMemoryAllocator  *pScratchMemoryAllocator,
    IN LPSTR                    ServerName,    // "sg" or "ts" typically
    IN LPSTR                    SiteName,      // "site1", "site999", etc
    IN LPSTR                    TicketRealm,   // "XBOX.COM"
    IN LPSTR                    ClientRealm,   // "PASSPORT.NET"
    IN LPSTR                    ClientName1,   // "XE.538451958491@xbox.com"
    IN LPSTR                    ClientName2,   // "PASSPORT.NET"
    IN PUCHAR                   SessionKey,
    IN LONGLONG                 MaxTicketLifespan,
    OUT PKERB_TICKET            NewTicket
    )
{
    NTSTATUS Status;
    KERBERR KerbErr = KDC_ERR_NONE;
    KERB_TICKET OutputTicket;
    PKERB_ENCRYPTED_TICKET EncryptedTicket;
    LARGE_INTEGER TicketLifespan = {0};
    ULONG TicketFlags = 0;
    ULONG SourceTicketFlags = 0;
    PKERB_HOST_ADDRESSES Addresses = NULL;
    TimeStamp CurrentTime = {0};
    ULONG KdcOptions;

    // Set default options, yanked from kcl_BuildXboxTgsRequest
    //KdcOptions = KerbConvertUlongToFlagUlong(KERB_DEFAULT_TICKET_FLAGS);
    //RequestBody->kdc_options.length = sizeof(ULONG) * 8;
    //RequestBody->kdc_options.value = (PUCHAR) &KdcOptions;
    //RequestBody->realm = "XBOX.COM";
    //RequestBody->encryption_type = &g_RC4HMAC_CryptList;
 
    KerbGetCurrentTime(&CurrentTime);

    OutputTicket = *NewTicket;
    EncryptedTicket = (PKERB_ENCRYPTED_TICKET) OutputTicket.encrypted_part.cipher_text.value;

    //
    // Determine ticket lifetime
    //
    TicketLifespan.QuadPart = MaxTicketLifespan;
    KerbErr = BuildTicketTimesAndFlags(
        pScratchMemoryAllocator,
        &TicketLifespan,
        EncryptedTicket
        );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }


    // Fill in the service names
    KerbErr = KerbConstructPrincipalName(
                pScratchMemoryAllocator,
                &OutputTicket.server_name,
                KRB_NT_SRV_INST,
                ServerName,
                SiteName
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    
    // Fill in the realm name
    SetString(pScratchMemoryAllocator, TicketRealm, (PUCHAR*)&OutputTicket.realm);

    // Copy all the other strings over
    SetString(pScratchMemoryAllocator, ClientRealm, (PUCHAR*)&EncryptedTicket->client_realm);

    // Client principal
    KerbErr = KerbConstructPrincipalName(
                pScratchMemoryAllocator,
                &EncryptedTicket->client_name,
                KRB_NT_SRV_INST,
                ClientName1,
                ClientName2 
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    // Add, umm, missing fields found in actual ticket but not in my ticket
    OutputTicket.encrypted_part.bit_mask |= version_present;  // 0x80, only bits that i see by inspecting real XKDC ticket
    OutputTicket.encrypted_part.encryption_type = KERB_ETYPE_RC4_HMAC_NT;
    OutputTicket.encrypted_part.version = 1;  // why 1? just 'cause.

    // Add the session key
    KerbCreateKeyFromBuffer(
        &EncryptedTicket->key,
        SessionKey,
        XONLINE_KEY_LENGTH,
        KERB_ETYPE_RC4_HMAC_NT
        );
#if 0
    SessionKey = (PUCHAR)pScratchMemoryAllocator->Alloc(XONLINE_KEY_LENGTH);
    if (SessionKey == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    const unsigned char DefSessionKey[] = { 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0 };
    *SessionKey = *DefSessionKey; 
    KerbCreateKeyFromBuffer(
        &EncryptedTicket->key,
        SessionKey,
        XONLINE_KEY_LENGTH,
        KERB_ETYPE_RC4_HMAC_NT
        );
#endif
    
    //
    // The authorization data will be added by the caller, so set it
    // to NULL here.
    //

    EncryptedTicket->KERB_ENCRYPTED_TICKET_authorization_data = NULL;


    OutputTicket.ticket_version = KERBEROS_VERSION;
    *NewTicket = OutputTicket;

Cleanup:
    if (!KERB_SUCCESS(KerbErr))
    {
        // KdcFreeInternalTicket(&OutputTicket);
    }

    return(KerbErr);
}

KERBERR
InsertAuthorizationData(
    IN CScratchMemoryAllocator     *pScratchMemoryAllocator,
    IN PUCHAR                       pbAuthdata,
    OUT PKERB_ENCRYPTED_TICKET      FinalTicket
    )
{
    KERBERR                         KerbErr = KDC_ERR_NONE;
    PKERB_AUTHORIZATION_DATA        FinalAuthData;
    WORD                            wAuthdataVersion;
    PXKERB_AD_XBOX_WITH_SIGNATURE2  pXboxADWithSig = NULL;
    PXKERB_AD_XENON_WITH_SIGNATURE  pXenonADWithSig = NULL;
    PXKERB_AD_XENON_WITH_SIGNATURE2 pXenon2ADWithSig = NULL;
    

    FinalAuthData = (PKERB_AUTHORIZATION_DATA)pScratchMemoryAllocator->Alloc(sizeof(KERB_AUTHORIZATION_DATA));
    if (FinalAuthData == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    } 
    ZeroMemory(FinalAuthData, sizeof(*FinalAuthData));

    //
    // KdcReturnAuthData
    //

    // Determine authdata version by checking the first word for the version
    wAuthdataVersion = *((WORD*)(&pbAuthdata[0]));
    if (wAuthdataVersion == XONLINE_XENON_AUTHDATA_VERSION)
    {
        // Xenon authdata, version 3
        pXenonADWithSig = (PXKERB_AD_XENON_WITH_SIGNATURE)pScratchMemoryAllocator->Alloc(sizeof(*pXenonADWithSig));
        if ( pXenonADWithSig == NULL )
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        ZeroMemory(pXenonADWithSig, sizeof(*pXenonADWithSig));

        // Copy actual data
        memcpy(&pXenonADWithSig->authData, pbAuthdata, sizeof(XKERB_AD_XENON));
        FinalAuthData->value.auth_data_type = KERB_AUTH_DATA_XENON;
        FinalAuthData->value.auth_data.length = sizeof(*pXenonADWithSig);
        FinalAuthData->value.auth_data.value = (PUCHAR) pXenonADWithSig;
    }
    else if (wAuthdataVersion == XONLINE_XENON2_AUTHDATA_VERSION)
    {
        // Xenon2 authdata, version 4
        pXenon2ADWithSig = (PXKERB_AD_XENON_WITH_SIGNATURE2)pScratchMemoryAllocator->Alloc(sizeof(*pXenon2ADWithSig));
        if ( pXenon2ADWithSig == NULL )
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        ZeroMemory(pXenon2ADWithSig, sizeof(*pXenon2ADWithSig));

        // Copy actual data
        memcpy(&pXenon2ADWithSig->authData, pbAuthdata, sizeof(XKERB_AD_XENON2));
        FinalAuthData->value.auth_data_type = KERB_AUTH_DATA_XENON2;
        FinalAuthData->value.auth_data.length = sizeof(*pXenon2ADWithSig);
        FinalAuthData->value.auth_data.value = (PUCHAR) pXenon2ADWithSig;
    }
    else if (wAuthdataVersion == XONLINE_AUTHDATA_VERSION)
    {
        // Xbox authdata, version 2
        // allocate space for our Xbox-specific authdata
        pXboxADWithSig = (PXKERB_AD_XBOX_WITH_SIGNATURE2)pScratchMemoryAllocator->Alloc(sizeof(*pXboxADWithSig));
        if ( pXboxADWithSig == NULL )
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        ZeroMemory(pXboxADWithSig, sizeof(*pXboxADWithSig));

        // Copy actual data
        memcpy(&pXboxADWithSig->authData, pbAuthdata, sizeof(XKERB_AD_XBOX2));
        FinalAuthData->value.auth_data_type = KERB_AUTH_DATA_XBOX;
        FinalAuthData->value.auth_data.length = sizeof(*pXboxADWithSig);
        FinalAuthData->value.auth_data.value = (PUCHAR) pXboxADWithSig;
    }

    // sign the authdata using the site key
    // it appears to just fill the signature field, which is ignored by the SG 
    // anyway.  hmm..
    //

        
    // Set authdata into the ticket
    FinalTicket->bit_mask |= KERB_ENCRYPTED_TICKET_authorization_data_present;
    FinalTicket->KERB_ENCRYPTED_TICKET_authorization_data = FinalAuthData;


Cleanup:
    return(KerbErr);
}
 

NTSTATUS WINAPI
kcl_BuildTicketTgs(
    IN PUCHAR                   pbAuthdata,    //really a pointer to XKERB_AD_XENON from what I can tell...
    IN LPSTR                    szServerName,
    IN LPSTR                    szSiteName,
    IN LPSTR                    szTicketRealm,   // "XBOX.COM"
    IN LPSTR                    szClientRealm,   // "PASSPORT.NET"
    IN LPSTR                    szClientName1,   // "XE.538451958491@xbox.com"
    IN LPSTR                    szClientName2,   // "PASSPORT.NET"
    IN PUCHAR                   pbSessionKey, //size is XONLINE_KEY_LENGTH?
    IN PUCHAR                   pbSiteKey,    //size is XONLINE_KEY_LENGTH?
    IN LONGLONG                 MaxTicketLifespan,
    OUT PUCHAR                  pbTicket,
    OUT DWORD*                  pdwTicketLength
    )
{
    ClearStoredDebugSpew();

    KERBERR                     KerbErr;
    KERB_EXT_ERROR              ExtendedError;
    KERB_TICKET                 NewTicket = {0};
    KERB_ENCRYPTED_TICKET       EncryptedTicket = {0};
    ULONG                       cbEncryptedPart;
    PUCHAR                      pbEncryptedPart;
    ULONG                       cbTicketPacked;
    PUCHAR                      pbTicketPacked;
    ULONG                       KdcFlags = 0;
    const UCHAR*                pbScratchMemory;
    CScratchMemoryAllocator     ScratchMemoryAllocator;

    //
    // Initialize scratch memory
    //
    pbScratchMemory = (PUCHAR)ScratchMemoryAllocator.ScratchMemoryInitialize( SCRATCH_MEMORY_SIZE_FOR_BuildTgsTicket, NULL, 0);
    
    NewTicket.encrypted_part.cipher_text.value = (PUCHAR)&EncryptedTicket;
    EncryptedTicket.flags.length = 32;  // in bits
    EncryptedTicket.flags.value = (PUCHAR)&KdcFlags;

    // Build ticket
    KerbErr = BuildTicketTGS(
        &ScratchMemoryAllocator,
        szServerName,
        szSiteName,
        szTicketRealm,
        szClientRealm,
        szClientName1,
        szClientName2,
        pbSessionKey,
        MaxTicketLifespan,
        &NewTicket
        );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    // Add authdata
    KerbErr = InsertAuthorizationData(
        &ScratchMemoryAllocator,
        pbAuthdata,
        &EncryptedTicket
        );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    // Pack encrypted part of ticket
    cbEncryptedPart = 0;
    pbEncryptedPart = NULL;
    KerbErr = KerbPackData(
        &ScratchMemoryAllocator,
        &EncryptedTicket,
        KERB_ENCRYPTED_TICKET_PDU,
        &cbEncryptedPart,
        &pbEncryptedPart
        );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    // Encrypt encrypted part of ticket
    NewTicket.encrypted_part.cipher_text.length = cbEncryptedPart + sizeof(RC4_MD5_HEADER);

    // Need to allocate more memory for the encrypted ticket, our original 
    // wasn't good enough. We still have a pointer to the original encrypted 
    // ticket data.
    NewTicket.encrypted_part.cipher_text.value = (PUCHAR)ScratchMemoryAllocator.Alloc(cbEncryptedPart + sizeof(RC4_MD5_HEADER));
    memcpy(NewTicket.encrypted_part.cipher_text.value + sizeof(RC4_MD5_HEADER), pbEncryptedPart, cbEncryptedPart);
    EncryptTicket(NewTicket.encrypted_part.cipher_text.value, NewTicket.encrypted_part.cipher_text.length, pbSiteKey, KERB_TICKET_SALT);

    // Pack the whole ticket
    cbTicketPacked = 0;
    pbTicketPacked = NULL;
    KerbErr = KerbPackData(
        &ScratchMemoryAllocator,
        &NewTicket,
        KERB_TICKET_PDU,
        &cbTicketPacked,
        &pbTicketPacked);
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    // Copy to output
    memcpy(pbTicket, pbTicketPacked, cbTicketPacked);
    *pdwTicketLength = cbTicketPacked;

Cleanup:
    return(KerbErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\kerbclient\xonp.h ===
// ---------------------------------------------------------------------------------------
// xonp.h
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#ifndef __XONP_H__
#define __XONP_H__

#define WIN32_NO_STATUS
#include <winsock2.h>
#include <winternl.h>
#undef WIN32_NO_STATUS
#include <windows.h>
#include <ntstatus.h>
typedef NTSTATUS * PNTSTATUS;
#define _NTDEF_
#include <ntsecapi.h>
#undef _NTDEF_
#include <subauth.h>
#include <wincrypt.h>

#include <stdio.h>
#include <stdlib.h>
#include <rsa.h>
#include <krb5.h>
#include <malloc.h>
#include <wsockntp.h>
#include <xonlinep.h>
#include <xcrypt.h>
#include <cryptoHelper.h>
#include "rc4hmac.h"
#include "kerbhelper.h"
#include "kerbclient.h"
#include "debugtrace.h"

#ifndef FIELD_OFFSET
#define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))
#endif

#define DefineTag(t,s)

#ifndef INLINE
#define INLINE inline
#endif

// ---------------------------------------------------------------------------------------
// Scratch memory management routines
// ---------------------------------------------------------------------------------------
//
// If Count is not already aligned, then
// round Count up to an even multiple of "Pow2".  "Pow2" must be a power of 2.
//
#define ROUND_UP_COUNT(Count,Pow2) \
        ( ((Count)+(Pow2)-1) & (~(((LONG)(Pow2))-1)) )

#define SCRATCH_MEMORY_ALIGNMENT 4
#define SCRATCH_MEMORY_STACK_SIZE 8

class CScratchMemoryAllocator
{
private:
    PBYTE m_pbStart;
    PBYTE m_pbEnd;
    PBYTE m_pbCurrent;
    PBYTE m_pbTempBuffer;
    DWORD m_dwTempBufferSize;
    DWORD m_dwStackPointer;
    PBYTE m_Stack[SCRATCH_MEMORY_STACK_SIZE];

public:
    INLINE CScratchMemoryAllocator()
    {
        m_pbStart = NULL;
    }

    //
    // This must be a macro or else _alloca won't work
    //
    #define ScratchMemoryInitialize( size, tempBuf, tempBufSize) ScratchMemoryInitializeHelper(_alloca( (size) ), (size), (tempBuf), (tempBufSize))

    INLINE PVOID ScratchMemoryInitializeHelper( IN PVOID ptr, IN size_t size, IN PVOID tempBuffer, IN size_t tempBufferSize)
    {
        AssertSz(m_pbStart == NULL,"Scratch Memory already in use");
        m_pbStart = (PBYTE)ptr;
        m_dwTempBufferSize = 0;
        m_pbCurrent = m_pbStart;
        m_pbEnd = m_pbStart + size;
        m_dwStackPointer = 0;
        ZeroMemory( m_pbStart, size );
        m_pbTempBuffer = (PBYTE)tempBuffer;
        if (m_pbTempBuffer != NULL)
        {
            Assert( tempBufferSize > 0 );
            m_dwTempBufferSize = tempBufferSize;
        }
        else
        {
            Assert( tempBufferSize == 0 );
        }
        #ifdef XNET_FEATURE_TRACE
        m_pbPeakUsage = m_pbStart;
        #endif
        return m_pbStart;
    }

    INLINE ~CScratchMemoryAllocator()
    {
        /*TraceSz2(ScratchMemoryVerbose, "Destructing, peak %d out of %d used",
                m_pbPeakUsage - m_pbStart,
                m_pbEnd - m_pbStart);*/
    }

    INLINE PVOID TempBuffer()
    {
        return m_pbTempBuffer;
    }

    INLINE DWORD TempBufferSize()
    {
        return m_dwTempBufferSize;
    }

    INLINE PVOID Alloc( IN size_t BufferSize )
    {
        PBYTE CurrentPosition;
        Assert(m_pbStart != NULL);
        CurrentPosition = m_pbCurrent;
        BufferSize = ROUND_UP_COUNT(BufferSize,SCRATCH_MEMORY_ALIGNMENT);
        m_pbCurrent += BufferSize;
        /*TraceSz3(ScratchMemoryAlloc, "Alloc %d, now used %d out of %d", BufferSize,
                m_pbCurrent - m_pbStart,
                m_pbEnd - m_pbStart);*/
        AssertSz(m_pbCurrent <= m_pbEnd,"Out of Scratch Memory");
        if (m_pbCurrent > m_pbEnd)
        {
            m_pbCurrent = CurrentPosition;
            CurrentPosition = NULL;
        }
        return CurrentPosition;
    }

    INLINE PVOID ReAlloc( IN PVOID Buffer, IN size_t BufferSize )
    {
        PBYTE CurrentPosition;
        Assert(m_pbStart != NULL);
        CurrentPosition = m_pbCurrent;
        BufferSize = ROUND_UP_COUNT(BufferSize,SCRATCH_MEMORY_ALIGNMENT);
        m_pbCurrent += BufferSize;
        /*TraceSz3(ScratchMemoryAlloc, "ReAlloc %d, now used %d out of %d", BufferSize,
                m_pbCurrent - m_pbStart,
                m_pbEnd - m_pbStart);*/
        AssertSz(m_pbCurrent <= m_pbEnd,"Out of Scratch Memory");
        if (m_pbCurrent > m_pbEnd)
        {
            m_pbCurrent = CurrentPosition;
            CurrentPosition = NULL;
        }
        else
        {
            memcpy( CurrentPosition, Buffer, BufferSize );
        }
        #ifdef XNET_FEATURE_TRACE
        if (m_pbPeakUsage < m_pbCurrent)
        {
            m_pbPeakUsage = m_pbCurrent;
        }
        #endif
        return CurrentPosition;
    }

    INLINE PVOID ImmediateReAlloc( IN PVOID Buffer, IN size_t OldBufferSize, IN size_t NewBufferSize )
    {
        Assert(m_pbStart != NULL);
        OldBufferSize = ROUND_UP_COUNT(OldBufferSize,SCRATCH_MEMORY_ALIGNMENT);
        if ( m_pbCurrent == (PBYTE)Buffer + OldBufferSize )
        {
            //
            // Nothing else was allocated in between, we can do things better.
            //
            PBYTE CurrentPosition;
            CurrentPosition = m_pbCurrent;
            NewBufferSize = ROUND_UP_COUNT(NewBufferSize,SCRATCH_MEMORY_ALIGNMENT);
            m_pbCurrent += (NewBufferSize - OldBufferSize);
            /*TraceSz3(ScratchMemoryAlloc, "ImmediateReAlloc %d, now used %d out of %d", NewBufferSize,
                    m_pbCurrent - m_pbStart,
                    m_pbEnd - m_pbStart);*/
            AssertSz(m_pbCurrent <= m_pbEnd,"Out of Scratch Memory");
            if (m_pbCurrent > m_pbEnd)
            {
                m_pbCurrent = CurrentPosition;
                return NULL;
            }
            else
            {
                return Buffer;
            }
        }
        else
        {
            return ReAlloc( Buffer, NewBufferSize );
        }
    }

    INLINE VOID Free( IN PVOID Buffer )
    {
        Assert(m_pbStart != NULL);
    }

    INLINE VOID Push()
    {
        Assert(m_pbStart != NULL);
        AssertSz(m_dwStackPointer < SCRATCH_MEMORY_STACK_SIZE,"Scratch Memory Stack Overflow");
        m_Stack[m_dwStackPointer++] = m_pbCurrent;
    }

    INLINE VOID Pop()
    {
        PVOID pTemp;
        Assert(m_pbStart != NULL);
        AssertSz(m_dwStackPointer != 0,"Scratch Memory Stack Underflow");
        pTemp = m_pbCurrent;
        m_pbCurrent = m_Stack[--m_dwStackPointer];
        Assert( m_pbCurrent <= pTemp);
        ZeroMemory( m_pbCurrent, (PBYTE)pTemp - m_pbCurrent );
    }
};

class CReleaseAllScratchMemoryUponDestruction
{
public:

    INLINE CReleaseAllScratchMemoryUponDestruction( CScratchMemoryAllocator* pScratchMemoryAllocator )
    {
        m_pScratchMemoryAllocator = pScratchMemoryAllocator;
        m_pbPreservedMemory = NULL;
        //
        // Anything allocated after the constructed will be released later
        //
        m_pScratchMemoryAllocator->Push();
    }

    INLINE CScratchMemoryAllocator* ScratchMemoryAllocator()
    {
        return m_pScratchMemoryAllocator;
    }

    //
    // Need to use #define or _alloca scope will be incorrect
    //
    #define PreserveThisMemory( pObject, ppMemoryPointer, dwPreservedMemoryLength ) \
        (pObject)->PreserveThisMemoryHelper( (void**)ppMemoryPointer, (pObject)->ScratchMemoryAllocator()->TempBufferSize() >= dwPreservedMemoryLength ? NULL : _alloca( dwPreservedMemoryLength ), dwPreservedMemoryLength )

    INLINE PVOID PreserveThisMemoryHelper( void** ppMemoryPointer, void* pbAllocatedMemory, DWORD dwPreservedMemoryLength )
    {
        Assert( dwPreservedMemoryLength != 0 );
        Assert( ppMemoryPointer != NULL );
        Assert( *ppMemoryPointer != NULL );
        if (pbAllocatedMemory == NULL)
        {
            pbAllocatedMemory = m_pScratchMemoryAllocator->TempBuffer();
        }
        memcpy(pbAllocatedMemory, *ppMemoryPointer, dwPreservedMemoryLength);
        m_ppMemoryPointer = ppMemoryPointer;
        m_dwPreservedMemoryLength = dwPreservedMemoryLength;
        m_pbPreservedMemory = pbAllocatedMemory;
        return pbAllocatedMemory;
    }

    INLINE PVOID PreserveThisMemoryToTempBuffer( PBYTE* ppMemoryPointer, DWORD dwPreservedMemoryLength )
    {
        PVOID pbDestinationMemory = NULL;

        Assert( dwPreservedMemoryLength != 0 );
        Assert( ppMemoryPointer != NULL );
        Assert( *ppMemoryPointer != NULL );
        if (m_pScratchMemoryAllocator->TempBuffer() != NULL &&
            m_pScratchMemoryAllocator->TempBufferSize() >= dwPreservedMemoryLength )
        {
            pbDestinationMemory = m_pScratchMemoryAllocator->TempBuffer();
            memcpy(pbDestinationMemory, *ppMemoryPointer, dwPreservedMemoryLength);
            *ppMemoryPointer = (PBYTE)pbDestinationMemory;
        }
        else
        {
            AssertSz(FALSE, "Temp Buffer can't fit PreserveThisMemoryToTempBuffer");
        }
        return pbDestinationMemory;
    }

    INLINE ~CReleaseAllScratchMemoryUponDestruction()
    {
        m_pScratchMemoryAllocator->Pop();

        if (m_pbPreservedMemory != NULL)
        {
            Assert( m_dwPreservedMemoryLength != 0 );
            *m_ppMemoryPointer = m_pScratchMemoryAllocator->Alloc(m_dwPreservedMemoryLength);
            memcpy(*m_ppMemoryPointer, m_pbPreservedMemory, m_dwPreservedMemoryLength);
        }
    }

private:

    CScratchMemoryAllocator* m_pScratchMemoryAllocator;
    PVOID m_pbPreservedMemory;
    PVOID* m_ppMemoryPointer;
    DWORD m_dwPreservedMemoryLength;
};



// ====================================================================
// User signature related stuff
//

//
// Some time on January/2000, The Xbox time cannot be adjusted to earlier than this
//
#define BASE_SIGNATURE_TIME ((ULONGLONG)0x01BF5C72FEFB6A60)

//
// Granularity of measurement (2 seconds)
//
#define SIGNATURE_TIME_INCREMENT ((ULONGLONG)20000000)

// INLINE VOID TimeStampOnlineUserStruct( XC_ONLINE_USER_ACCOUNT_STRUCT* pOnlineUser )
// {
//     FILETIME CurrentTime;
//
//     GetSystemTimeAsFileTime(&CurrentTime);
//     pOnlineUser->dwSignatureTime = (DWORD)((*((ULONGLONG*)&CurrentTime) - BASE_SIGNATURE_TIME) / SIGNATURE_TIME_INCREMENT);
//     Assert( *((ULONGLONG*)&CurrentTime) > BASE_SIGNATURE_TIME );
//     Assert( ((*((ULONGLONG*)&CurrentTime) - BASE_SIGNATURE_TIME) / SIGNATURE_TIME_INCREMENT) <= ((ULONGLONG)0xFFFFFFFF) );
// }


// ---------------------------------------------------------------------------------------
// Definitions
// ---------------------------------------------------------------------------------------

#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif

#ifndef _countof
#define _countof(array)     (sizeof(array)/sizeof(array[0]))
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\kerbclient\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_kerbclient2_none_12.4.56.0_none_472da1890a20bbb9
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_kerbclient2_no-public-key_12.4.56.0_x-ww_b2094df3
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=kerbclient2
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_kerbclient2_no-public-key_12.4.56.0_x-ww_b2094df3
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_kerbclient2_no-public-key_12.4.56.0_x-ww_b2094df3.manifest
XP_MANIFEST_PATH=manifests\x86_kerbclient2_no-public-key_12.4.56.0_x-ww_b2094df3.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_kerbclient2_no-public-key_12.4.56.0_x-ww_b2094df3.cat
XP_CATALOG_PATH=manifests\x86_kerbclient2_no-public-key_12.4.56.0_x-ww_b2094df3.cat
XP_PAYLOAD_PATH=x86_kerbclient2_no-public-key_12.4.56.0_x-ww_b2094df3
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=kerbclient2,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\kerbclient\xcrypt.cpp ===
// ---------------------------------------------------------------------------------------
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "xonp.h"
#include <crypto\rc4.h>
#include <crypto\sha.h>
#include <crypto\md5.h>
#include <crypto\modes.h>
#include <crypto\des.h>
#include <crypto\tripldes.h>
#include <crypto\aes.h>
#include <crypto\benaloh.h>

// ---------------------------------------------------------------------------------------
// Crypto Constants
// ---------------------------------------------------------------------------------------

extern "C" const BYTE g_abOakleyGroup1Mod[CBDHG1] =
{
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x20, 0x36, 0x3A, 0xA6, 0xE9, 0x42, 0x4C, 0xF4,
    0xC6, 0x7E, 0x5E, 0x62, 0x76, 0xB5, 0x85, 0xE4,
    0x45, 0xC2, 0x51, 0x6D, 0x6D, 0x35, 0xE1, 0x4F,
    0x37, 0x14, 0x5F, 0xF2, 0x6D, 0x0A, 0x2B, 0x30,
    0x1B, 0x43, 0x3A, 0xCD, 0xB3, 0x19, 0x95, 0xEF,
    0xDD, 0x04, 0x34, 0x8E, 0x79, 0x08, 0x4A, 0x51,
    0x22, 0x9B, 0x13, 0x3B, 0xA6, 0xBE, 0x0B, 0x02,
    0x74, 0xCC, 0x67, 0x8A, 0x08, 0x4E, 0x02, 0x29,
    0xD1, 0x1C, 0xDC, 0x80, 0x8B, 0x62, 0xC6, 0xC4,
    0x34, 0xC2, 0x68, 0x21, 0xA2, 0xDA, 0x0F, 0xC9,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
};

extern "C" const BYTE g_abOakleyGroup1Base[CBDHG1] =
{
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

// ---------------------------------------------------------------------------------------
// SHA
// ---------------------------------------------------------------------------------------

void XcSHAInit(IN PUCHAR pbSHAContext)
{
    A_SHAInit((A_SHA_CTX*)pbSHAContext);
}
   
void XcSHAUpdate(IN PUCHAR pbSHAContext, IN PUCHAR pbInput, IN ULONG dwInputLength)
{
    A_SHAUpdate((A_SHA_CTX*)pbSHAContext, pbInput, dwInputLength);
}
   
void XcSHAFinal(IN PUCHAR pbSHAContext, IN PUCHAR pbDigest)
{
    A_SHAFinal((A_SHA_CTX*)pbSHAContext, pbDigest);
}
   
void XcSHA(BYTE * pbSha, UINT cbSha, BYTE * pb1, UINT cb1, BYTE * pb2, UINT cb2, BYTE * pb3, UINT cb3)
{
    BYTE abShaCtx[XC_SERVICE_SHA_CONTEXT_SIZE];
    BYTE abSha[XC_SERVICE_DIGEST_SIZE];

    A_SHAInit((A_SHA_CTX *)abShaCtx);

    if (cb1 > 0)
    {
        A_SHAUpdate((A_SHA_CTX *)abShaCtx, pb1, cb1);
    }

    if (cb2 > 0)
    {
        A_SHAUpdate((A_SHA_CTX *)abShaCtx, pb2, cb2);
    }

    if (cb3 > 0)
    {
        A_SHAUpdate((A_SHA_CTX *)abShaCtx, pb3, cb3);
    }

    A_SHAFinal((A_SHA_CTX *)abShaCtx, abSha);

    Assert(cbSha <= sizeof(abSha));
    cbSha = min(cbSha, sizeof(abSha));
    memcpy(pbSha, abSha, cbSha);
}

// ---------------------------------------------------------------------------------------
// RC4
// ---------------------------------------------------------------------------------------

void XcRC4Key(IN PUCHAR pbKeyStruct, IN ULONG dwKeyLength, IN PUCHAR pbKey)
{
    rc4_key((RC4_KEYSTRUCT*)pbKeyStruct, dwKeyLength, pbKey);
}
   
void XcRC4Crypt(IN PUCHAR pbKeyStruct, IN ULONG dwInputLength, IN PUCHAR pbInput)
{
    rc4((RC4_KEYSTRUCT*)pbKeyStruct, dwInputLength, pbInput);
}

// ---------------------------------------------------------------------------------------
// HMAC
// ---------------------------------------------------------------------------------------

#define HMAC_K_PADSIZE              64

VOID WINAPI XcHMAC4(
    BYTE * pbKeyMaterial, UINT cbKeyMaterial, 
    BYTE * pbData, UINT cbData,
    BYTE * pbData2, UINT cbData2, 
    BYTE * pbData3, UINT cbData3, 
    BYTE * pbData4, UINT cbData4,
    BYTE * HmacData, UINT cbHmacData)
{
    BYTE Kipad[HMAC_K_PADSIZE];
    BYTE Kopad[HMAC_K_PADSIZE];
    BYTE HMACTmp[HMAC_K_PADSIZE+A_SHA_DIGEST_LEN];
    ULONG dwBlock;
    A_SHA_CTX shaHash;

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;

    ZeroMemory(Kipad, HMAC_K_PADSIZE);
    memcpy(Kipad, pbKeyMaterial, cbKeyMaterial);

    ZeroMemory(Kopad, HMAC_K_PADSIZE);
    memcpy(Kopad, pbKeyMaterial, cbKeyMaterial);

    //
    // Kipad, Kopad are padded sMacKey. Now XOR across...
    //
    for(dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(DWORD); dwBlock++)
    {
        ((DWORD*)Kipad)[dwBlock] ^= 0x36363636;
        ((DWORD*)Kopad)[dwBlock] ^= 0x5C5C5C5C;
    }

    //
    // prepend Kipad to data, Hash to get H1
    //

    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash, Kipad, HMAC_K_PADSIZE);
    if (cbData != 0)
        A_SHAUpdate(&shaHash, pbData, cbData);
    if (cbData2 != 0)
        A_SHAUpdate(&shaHash, pbData2, cbData2);
    if (cbData3 != 0)
        A_SHAUpdate(&shaHash, pbData3, cbData3);
    if (cbData4 != 0)
        A_SHAUpdate(&shaHash, pbData4, cbData4);

    // Finish off the hash
    A_SHAFinal(&shaHash,HMACTmp+HMAC_K_PADSIZE);

    // prepend Kopad to H1, hash to get HMAC
    memcpy(HMACTmp, Kopad, HMAC_K_PADSIZE);

    // final hash: output value into passed-in buffer
    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash,HMACTmp, sizeof(HMACTmp));
    if (cbHmacData < XC_SERVICE_DIGEST_SIZE)
    {
        BYTE abHash[XC_SERVICE_DIGEST_SIZE];
        A_SHAFinal(&shaHash, abHash);
        // cbHmacData should be less than or equal to XC_SERVICE_DIGEST_SIZE
        memcpy(HmacData, abHash, cbHmacData);
    }
    else
    {
        A_SHAFinal(&shaHash,HmacData);
    }
}

void XcHMACMakeKeyTable(BYTE * pbKeyMaterial, UINT cbKeyMaterial, BYTE * pbKeyTable)
{
    BYTE Kipad[HMAC_K_PADSIZE];
    BYTE Kopad[HMAC_K_PADSIZE];
    ULONG dwBlock;
    A_SHA_CTX shaHash;

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;

    ZeroMemory(Kipad, HMAC_K_PADSIZE);
    memcpy(Kipad, pbKeyMaterial, cbKeyMaterial);

    ZeroMemory(Kopad, HMAC_K_PADSIZE);
    memcpy(Kopad, pbKeyMaterial, cbKeyMaterial);

    //
    // Kipad, Kopad are padded sMacKey. Now XOR across...
    //
    for(dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(DWORD); dwBlock++)
    {
        ((DWORD*)Kipad)[dwBlock] ^= 0x36363636;
        ((DWORD*)Kopad)[dwBlock] ^= 0x5C5C5C5C;
    }

    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash, Kipad, HMAC_K_PADSIZE);
    memcpy(pbKeyTable, &shaHash, sizeof(A_SHA_CTX));

    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash, Kopad, HMAC_K_PADSIZE);
    memcpy(pbKeyTable + sizeof(A_SHA_CTX), &shaHash, sizeof(A_SHA_CTX));
}

void XcHMAC4WithKeyTable(
    BYTE * pbKeyTable, 
    BYTE * pbData, UINT cbData,
    BYTE * pbData2, UINT cbData2, 
    BYTE * pbData3, UINT cbData3, 
    BYTE * pbData4, UINT cbData4,
    BYTE * HmacData, UINT cbHmacData)
{
    A_SHA_CTX shaHash;

    memcpy(&shaHash, pbKeyTable, sizeof(A_SHA_CTX));

    if (cbData != 0)
        A_SHAUpdate(&shaHash, pbData, cbData);
    if (cbData2 != 0)
        A_SHAUpdate(&shaHash, pbData2, cbData2);
    if (cbData3 != 0)
        A_SHAUpdate(&shaHash, pbData3, cbData3);
    if (cbData4 != 0)
        A_SHAUpdate(&shaHash, pbData4, cbData4);

    A_SHAFinal(&shaHash,HmacData);

    memcpy(&shaHash, pbKeyTable + sizeof(A_SHA_CTX), sizeof(A_SHA_CTX));

    A_SHAUpdate(&shaHash, HmacData, A_SHA_DIGEST_LEN);

    if (cbHmacData < XC_SERVICE_DIGEST_SIZE)
    {
        BYTE abHash[XC_SERVICE_DIGEST_SIZE];
        A_SHAFinal(&shaHash, abHash);
        // cbHmacData should be less than or equal to XC_SERVICE_DIGEST_SIZE
        memcpy(HmacData, abHash, cbHmacData);
    }
    else
    {
        A_SHAFinal(&shaHash,HmacData);
    }
}

// ---------------------------------------------------------------------------------------
// ModExp
// compute A = B ^ C mod D, N = len of params in DWORDs
// ---------------------------------------------------------------------------------------

ULONG XcModExp(OUT LPDWORD pA, IN LPDWORD pB, IN LPDWORD pC, IN LPDWORD pD, IN ULONG dwN)
{
    return BenalohModExp(pA, pB, pC, pD, dwN);
}
   
// ---------------------------------------------------------------------------------------
// DES and AES
// ---------------------------------------------------------------------------------------

#define XC_SERVICE_DEFAULT_CIPHER       0xffffffff

#define XC_SERVICE_AES256_CIPHER        0xff000002
#define XC_SERVICE_AES256_ROUNDS        AES_ROUNDS_256
#define XC_SERVICE_AES256_KEYSIZE       AES_KEYSIZE_256
#define XC_SERVICE_AES256_BLOCKLEN      AES_BLOCKLEN
#define XC_SERVICE_AES256_TABLESIZE     AES_TABLESIZE_256

//
void XcDESKeyParity(IN PUCHAR pbKey, IN ULONG dwKeyLength)
{
    desparityonkey(pbKey, dwKeyLength);
}
   
void XcKeyTable(IN ULONG dwCipher, OUT PUCHAR pbKeyTable, IN PUCHAR pbKey)
{
    if (dwCipher == XC_SERVICE_DES_CIPHER)
    {
        deskey((DESTable*)pbKeyTable, pbKey);
    }
    else if (dwCipher == XC_SERVICE_AES_CIPHER)
    {
        aeskey((AESTable*)pbKeyTable, pbKey, XC_SERVICE_AES_ROUNDS);
    }
    else if (dwCipher == XC_SERVICE_AES256_CIPHER)
    {
        aeskey((AESTable*)pbKeyTable, pbKey, XC_SERVICE_AES256_ROUNDS);
    }
    else if (dwCipher == XC_SERVICE_NULL_CIPHER)
    {
        // nothing
    }
    else
    {
        // Assume XC_SERVICE_DES3_CIPHER:
        tripledes3key((PDES3TABLE)pbKeyTable, pbKey);
    }
}
   
void XcBlockCrypt(IN ULONG dwCipher, IN PUCHAR pbOutput, IN PUCHAR pbInput, IN PUCHAR pbKeyTable, IN ULONG dwOp)
{
    if (dwCipher == XC_SERVICE_NULL_CIPHER)
        return;

    void (RSA32API *pCipher)(BYTE *, BYTE *, void *, int) = 
        (dwCipher == XC_SERVICE_DES_CIPHER) ? des : 
        (dwCipher == XC_SERVICE_AES_CIPHER) ? aes : 
        (dwCipher == XC_SERVICE_AES256_CIPHER) ? aes : 
        tripledes;
    (*pCipher)( pbOutput, pbInput, pbKeyTable, dwOp );
}
   
void XcBlockCryptCBC(IN ULONG dwCipher, IN ULONG dwInputLength, IN PUCHAR pbOutput, IN PUCHAR pbInput,
                     IN PUCHAR pbKeyTable, IN ULONG dwOp, IN PUCHAR pbFeedback)
{
    if (dwCipher == XC_SERVICE_NULL_CIPHER)
        return;

    BYTE *pbInputEnd = pbInput + dwInputLength;
    void (RSA32API *pCipher)(BYTE *, BYTE *, void *, int) = 
        (dwCipher == XC_SERVICE_DES_CIPHER) ? des : 
        (dwCipher == XC_SERVICE_AES_CIPHER) ? aes : 
        (dwCipher == XC_SERVICE_AES256_CIPHER) ? aes : 
        tripledes;
    UINT uiBlockLen =
        (dwCipher == XC_SERVICE_AES_CIPHER) ? XC_SERVICE_AES_BLOCKLEN :
        (dwCipher == XC_SERVICE_AES256_CIPHER) ? XC_SERVICE_AES256_BLOCKLEN :
        XC_SERVICE_DES_BLOCKLEN;
    while (pbInput < pbInputEnd)
    {
        CBC(pCipher, uiBlockLen, pbOutput, pbInput, pbKeyTable, dwOp, pbFeedback);
        pbInput += uiBlockLen;
        pbOutput += uiBlockLen;
    }
}

void XcGetCryptParamsFromKeyLength(IN UINT cbKey, OUT UINT *puiCipher, OUT UINT *puiBlockLen, OUT UINT *puiTableSize)
{
    Assert(cbKey == XC_SERVICE_DES_KEYSIZE || 
           cbKey == XC_SERVICE_DES3_KEYSIZE ||
           cbKey == XC_SERVICE_AES_KEYSIZE ||
           cbKey == XC_SERVICE_NULL_KEYSIZE ||
           cbKey == XC_SERVICE_AES256_KEYSIZE);
    switch(cbKey)
    {
    case XC_SERVICE_DES_KEYSIZE:
        *puiCipher      = XC_SERVICE_DES_CIPHER;
        *puiBlockLen    = XC_SERVICE_DES_BLOCKLEN;
        *puiTableSize   = XC_SERVICE_DES_TABLESIZE;
        break;
    case XC_SERVICE_AES_KEYSIZE:
        *puiCipher      = XC_SERVICE_AES_CIPHER;
        *puiBlockLen    = XC_SERVICE_AES_BLOCKLEN;
        *puiTableSize   = XC_SERVICE_AES_TABLESIZE;
        break;
    case XC_SERVICE_AES256_KEYSIZE:
        *puiCipher      = XC_SERVICE_AES256_CIPHER;
        *puiBlockLen    = XC_SERVICE_AES256_BLOCKLEN;
        *puiTableSize   = XC_SERVICE_AES256_TABLESIZE;
        break;
    case XC_SERVICE_NULL_KEYSIZE:
        *puiCipher      = XC_SERVICE_NULL_CIPHER;
        *puiBlockLen    = 0;
        *puiTableSize   = 0;
        break;
    case XC_SERVICE_DES3_KEYSIZE:
    default:
        // hmm.. old behavior for default was DES3, so let's stick with that
        *puiCipher      = XC_SERVICE_DES3_CIPHER;
        *puiBlockLen    = XC_SERVICE_DES_BLOCKLEN;
        *puiTableSize   = XC_SERVICE_DES3_TABLESIZE;
        break;
    }
}

void XcGetCryptParamsFromCipherType(DWORD cipherType, OUT UINT *puiCipher, OUT UINT *puiBlockLen, OUT UINT *puiTableSize)
{
    Assert(cipherType == XC_SERVICE_DES_CIPHER ||
           cipherType == XC_SERVICE_AES_CIPHER ||
           cipherType == XC_SERVICE_AES256_CIPHER ||
           cipherType == XC_SERVICE_NULL_CIPHER ||
           cipherType == XC_SERVICE_DES3_CIPHER);
    switch(cipherType)
    {
    case XC_SERVICE_DES_CIPHER:
        *puiCipher      = XC_SERVICE_DES_CIPHER;
        *puiBlockLen    = XC_SERVICE_DES_BLOCKLEN;
        *puiTableSize   = XC_SERVICE_DES_TABLESIZE;
        break;
    case XC_SERVICE_AES_CIPHER:
        *puiCipher      = XC_SERVICE_AES_CIPHER;
        *puiBlockLen    = XC_SERVICE_AES_BLOCKLEN;
        *puiTableSize   = XC_SERVICE_AES_TABLESIZE;
        break;
    case XC_SERVICE_AES256_CIPHER:
        *puiCipher      = XC_SERVICE_AES256_CIPHER;
        *puiBlockLen    = XC_SERVICE_AES256_BLOCKLEN;
        *puiTableSize   = XC_SERVICE_AES256_TABLESIZE;
        break;
    case XC_SERVICE_NULL_CIPHER:
        *puiCipher      = XC_SERVICE_NULL_CIPHER;
        *puiBlockLen    = 0;
        *puiTableSize   = 0;
        break;
    case XC_SERVICE_DES3_CIPHER:
    default:
        *puiCipher      = XC_SERVICE_DES3_CIPHER;
        *puiBlockLen    = XC_SERVICE_DES_BLOCKLEN;
        *puiTableSize   = XC_SERVICE_DES3_TABLESIZE;
        break;
    }
}

void XcCrypt2(DWORD cipherType, DWORD dwOp, BYTE *pbKey, UINT cbKey, BYTE *pbIv, UINT cbIv, BYTE *pb1, UINT cb1, BYTE *pb2, UINT cb2)
{
    //BYTE abFeedback[max(XC_SERVICE_DES_BLOCKLEN, XC_SERVICE_AES_BLOCKLEN)];
    UINT uiCipher;
    UINT uiBlockLen;
    UINT uiTableSize;

    Assert(cbIv==16); //currently all use a 16 byte iv

    if (cipherType==XC_SERVICE_DEFAULT_CIPHER)
        XcGetCryptParamsFromKeyLength(cbKey, &uiCipher, &uiBlockLen, &uiTableSize);
    else
        XcGetCryptParamsFromCipherType(cipherType, &uiCipher, &uiBlockLen, &uiTableSize);

    if (uiCipher == XC_SERVICE_NULL_CIPHER)
    {
        return;
    }

    BYTE abTable[max(XC_SERVICE_DES3_TABLESIZE, max(XC_SERVICE_AES_TABLESIZE, XC_SERVICE_AES256_TABLESIZE))];
    XcKeyTable(uiCipher, abTable, pbKey);
    
    BYTE abFeedback[max(XC_SERVICE_DES_BLOCKLEN, max(XC_SERVICE_AES_BLOCKLEN, XC_SERVICE_AES256_BLOCKLEN))];
    memcpy(abFeedback, pbIv, uiBlockLen);

    if (cb1 > 0)
    {
        Assert(pb1 != NULL && (cb1 % uiBlockLen) == 0);
        XcBlockCryptCBC(uiCipher, cb1, pb1, pb1, abTable, dwOp, abFeedback);
    }

    if (cb2 > 0)
    {
        Assert(pb2 != NULL && (cb2 % uiBlockLen) == 0);
        XcBlockCryptCBC(uiCipher, cb2, pb2, pb2, abTable, dwOp, abFeedback);
    }
}

void XcCrypt(DWORD dwOp, BYTE *pbKey, UINT cbKey, BYTE *pbIv, BYTE *pb1, UINT cb1, BYTE *pb2, UINT cb2)
{
    XcCrypt2(XC_SERVICE_DEFAULT_CIPHER, dwOp, pbKey, cbKey, pbIv, 16, pb1, cb1, pb2, cb2);
}

void XcCryptWithKeyTable2(DWORD cipherType, DWORD dwOp, BYTE *pbKeyTable, UINT cbKey, BYTE *pbIv, UINT cbIv, BYTE *pb1, UINT cb1, BYTE *pb2, UINT cb2)
{
    UINT uiCipher;
    UINT uiBlockLen;
    UINT uiTableSize;

    Assert(cbIv==16); //currently all use a 16 byte iv

    if (cipherType==XC_SERVICE_DEFAULT_CIPHER)
        XcGetCryptParamsFromKeyLength(cbKey, &uiCipher, &uiBlockLen, &uiTableSize);
    else
        XcGetCryptParamsFromCipherType(cipherType, &uiCipher, &uiBlockLen, &uiTableSize);

    if (uiCipher == XC_SERVICE_NULL_CIPHER)
    {
        return;
    }
    
    BYTE abFeedback[max(XC_SERVICE_DES_BLOCKLEN, XC_SERVICE_AES_BLOCKLEN)];
    memcpy(abFeedback, pbIv, uiBlockLen);

    if (cb1 > 0)
    {
        Assert(pb1 != NULL && (cb1 % uiBlockLen) == 0);
        XcBlockCryptCBC(uiCipher, cb1, pb1, pb1, pbKeyTable, dwOp, abFeedback);
    }

    if (cb2 > 0)
    {
        Assert(pb2 != NULL && (cb2 % uiBlockLen) == 0);
        XcBlockCryptCBC(uiCipher, cb2, pb2, pb2, pbKeyTable, dwOp, abFeedback);
    }
}

void XcCryptWithKeyTable(DWORD dwOp, BYTE *pbKeyTable, UINT cbKey, BYTE *pbIv, BYTE *pb1, UINT cb1, BYTE *pb2, UINT cb2)
{
    XcCryptWithKeyTable2(XC_SERVICE_DEFAULT_CIPHER, dwOp, pbKeyTable, cbKey, pbIv, 16, pb1, cb1, pb2, cb2);
}


// ---------------------------------------------------------------------------------------
// Used by SGClient tests
// ---------------------------------------------------------------------------------------


VOID WINAPI ComputeDHGX(char* pGX, char* pX)
{   
    XcModExp((DWORD *)pGX, (DWORD *)g_abOakleyGroup1Base, (DWORD *)pX, (DWORD *)g_abOakleyGroup1Mod, CBDHG1 / sizeof(DWORD));
}

VOID WINAPI ComputeDHGXY(char* pGXY, char* pGY, char* pX)
{   
    XcModExp((DWORD *)pGXY, (DWORD *)pGY, (DWORD *)pX, (DWORD *)g_abOakleyGroup1Mod, CBDHG1 / sizeof(DWORD));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\kerbclient\ticketmodifier.cpp ===
#include "xonp.h"

#ifndef MAX_INT
#define MAX_INT 0x7fffffff
#endif

#ifndef KERB_SUCCESS
#define KERB_SUCCESS(_kerberr_) ((KERBERR)(_kerberr_) == KDC_ERR_NONE)
#endif

typedef ASN1generalizedtime_t KERB_TIME;
typedef KERB_TIME *PKERB_TIME;

typedef HRESULT (*CallbackFuncPtr)(KERB_TICKET *ptgtTicket, KERB_ENCRYPTED_TICKET *ptgtTicketEnc, void *pData);

VOID
KerbConvertGeneralizedTimeToLargeInt(
    OUT PTimeStamp TimeStamp,
    IN PKERB_TIME ClientTime,
    IN int ClientUsec
    );

VOID
KerbConvertLargeIntToGeneralizedTime(
    OUT PKERB_TIME ClientTime,
    OUT OPTIONAL LONG* ClientUsec,
    IN PTimeStamp TimeStamp
    );

KERBERR NTAPI
KerbUnpackData(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PUCHAR Data,
    IN ULONG DataSize,
    IN ULONG PduValue,
    OUT PVOID * DecodedData
    );

KERBERR NTAPI
KerbPackData(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PVOID Data,
    IN ULONG PduValue,
    OUT PULONG DataSize,
    OUT PUCHAR * MarshalledData
    );

static ASN1octetstring_t* KerbFindAuthDataEntry(
    IN ULONG EntryId,
    IN PKERB_AUTHORIZATION_DATA AuthData
    );

// Windows PAC structures
// The layout of the PAC structure can be found at: http://xblwiki/default.aspx/XboxLive/XenonAskdcAuthData.html
#pragma pack(push, 1)

struct WindowsPacHeader
{
    DWORD Buffers;
    DWORD Version;
};

struct WindowsPacBufferInfo
{
    DWORD Type;
    DWORD BufferSize;
    ULONGLONG Offset;
};

struct WindowsPacXboxIdentity
{
    ULONGLONG MachinePuid;
    ULONGLONG UserPuids[4];
    BYTE MachineIdType;
    BYTE UserIdType[4];
};

#pragma pack(pop)

// Some very simple ASN helpers.  Note that these aren't suitable for more general work; they are just enough to walk the authdata.
void AsnParseTagLengthValue(const void *pIn, BYTE &outTag, DWORD &outLength, const void *&outValue)
{
    //we'll only encounter short-form tags in this very limited use
    outTag=*(BYTE*)pIn;

    BYTE lengthFirstByte=*((BYTE*)pIn+1);
    if (lengthFirstByte&0x80) //long form length
    {
        BYTE lengthOfLength=lengthFirstByte&0x7f;

        if (lengthOfLength>3) //something is wrong, this would be too big for a udp packet
        {
            outTag=0;
            outLength=0;
            outValue=0;
            return;
        }

        outLength=0;
        memcpy(&outLength, (BYTE*)pIn+2, lengthOfLength);
        if (outLength>1500) //something is wrong, this would be too big for a udp packet
        {
            outTag=0;
            outLength=0;
            outValue=0;
            return;
        }

        outValue=(BYTE*)pIn+1+1+lengthOfLength;
    }
    else //short form length
    {
        outLength=lengthFirstByte;
        outValue=(BYTE*)pIn+1+1;
    }
}

const void *AsnStepIntoSequence(const void *p, DWORD &outSequenceLength)
{
    BYTE tag;
    DWORD length;
    const void *pStartOfInnerSequence;
    AsnParseTagLengthValue(p, tag, length, pStartOfInnerSequence);
    if (tag!=0x30) //sequence
    {
        outSequenceLength=0;
        return 0;
    }

    outSequenceLength=length;
    return pStartOfInnerSequence;
}

const void* AsnFindTagInSequence(const void *p, BYTE tagToFind)
{
    DWORD sequenceLength;
    const BYTE *pFirstTLV=(const BYTE*)AsnStepIntoSequence(p, sequenceLength);
    if (!pFirstTLV)
    {
        return 0;
    }

    const BYTE *pTLV=pFirstTLV;
    while (pTLV<pFirstTLV+sequenceLength)
    {
        BYTE tag;
        DWORD length;
        const void *value;
        AsnParseTagLengthValue(pTLV, tag, length, value);
        if (!length)
        {
            return 0;
        }

        if (tag==tagToFind)
        {
            return value;
        }

        pTLV=(BYTE*)value+length;
    }

    return 0;
}

// Callbacks

static HRESULT CopyPuidsOutToTgtContext_Callback(KERB_TICKET *ptgtTicket, KERB_ENCRYPTED_TICKET *ptgtTicketEnc, void *pData)
{
    CopyPuidsOutToTgtContext_Params *params = (CopyPuidsOutToTgtContext_Params*)pData;

    //This is actually ASN encoded.  It's a sequence of sequence of tag0(integer representing an authdata type) and tag1(octetstring representing the actual authdata).  We want that inner octet string.
    const ASN1octet_t *pInnerAuthDataStart=ptgtTicketEnc->authorization_data->value.auth_data.value;
    DWORD innerSequenceLength;
    const void *pInnerSequence=AsnStepIntoSequence(pInnerAuthDataStart, innerSequenceLength);
    if (!pInnerSequence)
    {
        return E_FAIL;
    }

    const void *pTagContext1=AsnFindTagInSequence(pInnerSequence, 0xa1); //find context tag 1
    if (!pTagContext1)
    {
        return E_FAIL;
    }

    BYTE authdataOctetStringTag;
    DWORD authdataOctetStringLength;
    const void *pAuthdataOctetStringValue;
    AsnParseTagLengthValue(pTagContext1, authdataOctetStringTag, authdataOctetStringLength, pAuthdataOctetStringValue);
    if (authdataOctetStringTag!=0x04 || !pAuthdataOctetStringValue) //verify it's an octet string
    {
        return E_FAIL;
    }

    //Verify the header is version 0, which is the only thing we currently support
    const BYTE *pWindowsPacStart=(const BYTE*)pAuthdataOctetStringValue;
    const WindowsPacHeader *pPacHeader=(WindowsPacHeader*)pWindowsPacStart;
    if (pPacHeader->Version!=0)
    {
        return E_FAIL;
    }

    //Now search the buffers for the XboxIdentity
    const WindowsPacXboxIdentity *pXboxIdentity=0;
    const WindowsPacBufferInfo *pPacInfo=(WindowsPacBufferInfo*)(pWindowsPacStart+sizeof(WindowsPacHeader));
    for (ULONG b=0; b<pPacHeader->Buffers; ++b)
    {
        if (pPacInfo->Type==88) //'X' - Xbox Identity Type
        {
            pXboxIdentity=(WindowsPacXboxIdentity*)(pWindowsPacStart+pPacInfo->Offset);
            break;
        }

        ++pPacInfo;
    }

    if (!pXboxIdentity)
    {
        return E_FAIL;
    }

    params->pTgt->MachineID=pXboxIdentity->MachinePuid;
    for (int u=0; u<4; ++u)
    {
        params->pTgt->UserID[u]=pXboxIdentity->UserPuids[u];
    }

    return S_OK;
}

static HRESULT GetTicketTimeRemaining_Callback(KERB_TICKET *ptgtTicket, KERB_ENCRYPTED_TICKET *ptgtTicketEnc, void *pData)
{
    // Input:            
    // int*
    int *pnSecsLeft = (int*)pData;
    
    LARGE_INTEGER CurrentTime, qwEndTime;
    GetSystemTimeAsFileTime((FILETIME*)&CurrentTime);
    KerbConvertGeneralizedTimeToLargeInt(&qwEndTime, &(ptgtTicketEnc->endtime), 0);
    Assert((qwEndTime.QuadPart - CurrentTime.QuadPart) / 10000000 < MAX_INT);
    *pnSecsLeft = (int)((qwEndTime.QuadPart - CurrentTime.QuadPart) / 10000000);

    return S_OK;
}

static HRESULT AddToTicketTimeRemaining_Callback(KERB_TICKET *ptgtTicket, KERB_ENCRYPTED_TICKET *ptgtTicketEnc, void *pData)
{
    // Input:
    // int
    int nSecsToAdd = *((int*)pData);

    LARGE_INTEGER qwEndTime;
    KerbConvertGeneralizedTimeToLargeInt(&qwEndTime, &(ptgtTicketEnc->endtime), 0);
    qwEndTime.QuadPart += (__int64)(nSecsToAdd) * 10000000;
    KerbConvertLargeIntToGeneralizedTime(&(ptgtTicketEnc->endtime), 0, &qwEndTime);

    // If we are subtracting from the endtime we probably want to move starttime back too because we don't want the endtime to be earlier than the starttime
    if (nSecsToAdd < 0)
    {
        LARGE_INTEGER qwStartTime;
        KerbConvertGeneralizedTimeToLargeInt(&qwStartTime, &(ptgtTicketEnc->starttime), 0);
        qwStartTime.QuadPart += (__int64)(nSecsToAdd) * 10000000;
        KerbConvertLargeIntToGeneralizedTime(&(ptgtTicketEnc->starttime), 0, &qwStartTime);

        LARGE_INTEGER qwAuthTime;
        KerbConvertGeneralizedTimeToLargeInt(&qwAuthTime, &(ptgtTicketEnc->authtime), 0);
        qwAuthTime.QuadPart += (__int64)(nSecsToAdd) * 10000000;
        KerbConvertLargeIntToGeneralizedTime(&(ptgtTicketEnc->authtime), 0, &qwAuthTime);
    }

    return S_OK;
}


static HRESULT GetAuthDataStruct_Callback(KERB_TICKET *ptgtTicket, KERB_ENCRYPTED_TICKET *ptgtTicketEnc, void *pData)
{
    // Input:
    // AuthDataParams*
    AuthDataStruct_Params *params = (AuthDataStruct_Params*)pData;

    ASN1octetstring_t* pAuthData2 = KerbFindAuthDataEntry( KERB_AUTH_DATA_XBOX, ptgtTicketEnc->authorization_data );
    ASN1octetstring_t* pAuthData3 = KerbFindAuthDataEntry( KERB_AUTH_DATA_XENON, ptgtTicketEnc->authorization_data );
    ASN1octetstring_t* pAuthData4 = KerbFindAuthDataEntry( KERB_AUTH_DATA_XENON2, ptgtTicketEnc->authorization_data );

    // To access the version and size, we don't really care whether this is authdata2 or authdata3
    // We'll just cast to the most basic version and use the struct's version and size fields
    // for all the rest.
    XKERB_AD_XBOX2 *ad;

    // Strip out signature header
    int offset = sizeof(XKERB_AD_XBOX_WITH_SIGNATURE2) - sizeof(XKERB_AD_XBOX2);

    if (pAuthData2 != NULL)
    {
        ad = (XKERB_AD_XBOX2*)(pAuthData2->value + offset);
    }
    else if (pAuthData3 != NULL)
    {
        ad = (XKERB_AD_XBOX2*)(pAuthData3->value + offset);
    }
    else if (pAuthData4 != NULL)
    {
        ad = (XKERB_AD_XBOX2*)(pAuthData4->value + offset);
    }
    else 
    {
        return S_OK;
    }

    WORD version = ad->wAuthDataVersion;
    WORD size = ad->wAuthDataSize;  // also could use sizeof(XKERB_AD_XBOX2)

    // We can always return the version
    if (params->pwAuthDataVersion != 0)
    {
        *params->pwAuthDataVersion = version;
    }

    // Array size exists?
    if (params->pdwAuthDataSize <= 0)
        return S_OK;

    // Not enough space to copy the struct?
    if (size > *params->pdwAuthDataSize)
    {
        *params->pdwAuthDataSize = size;
        return S_OK;
    }

    // Array exists?
    if (params->rgbAuthData <= 0)
        return S_OK;

    // Copy from ticket to input, set bytes copied
    memcpy((BYTE*)params->rgbAuthData, ad, size);
    *params->pdwAuthDataSize = size;

    return S_OK;
}



static HRESULT SetAuthDataStruct_Callback(KERB_TICKET *ptgtTicket, KERB_ENCRYPTED_TICKET *ptgtTicketEnc, void *pData)
{
    // Input:
    // AuthDataParams*
    AuthDataStruct_Params *params = (AuthDataStruct_Params*)pData;

    // Find ver3
    ASN1octetstring_t* pAuthData = KerbFindAuthDataEntry( KERB_AUTH_DATA_XENON, ptgtTicketEnc->authorization_data );
    if (pAuthData == NULL)
    {
        // Fall back to find ver2
        pAuthData = KerbFindAuthDataEntry( KERB_AUTH_DATA_XBOX, ptgtTicketEnc->authorization_data );
    }

    // To access the version and size, we don't really care whether this is authdata2 or authdata3
    // We'll just cast to the most basic version and use the struct's version and size fields
    // for all the rest.
    XKERB_AD_XBOX2 *ad;

    // Strip out signature header
    int offset = sizeof(XKERB_AD_XBOX_WITH_SIGNATURE2) - sizeof(XKERB_AD_XBOX2);

    if (pAuthData != NULL)
    {
        ad = (XKERB_AD_XBOX2*)(pAuthData->value + offset);
    }
    else 
    {
        return E_FAIL;
    }

    WORD version = ad->wAuthDataVersion;
    WORD size = ad->wAuthDataSize;  

    // Versions must match
    if (*params->pwAuthDataVersion != version)
    {
        return E_FAIL;
    }

    // Size must match
    if (*params->pdwAuthDataSize != size)
    {
        return E_FAIL;
    }

    // Input array exists?
    if (params->rgbAuthData == 0)
        return E_FAIL;

    // Copy from input to ticket
    memcpy(ad, (BYTE*)params->rgbAuthData, size);

    return S_OK;
}



//
// Inner functions
//

//DecryptTicket works in place
//bTicket should be at least 1024 (XONLINE_MAX_TICKET_LENGTH) bytes
static HRESULT DecryptTicket(IN OUT BYTE *pbTicket, IN ULONG cbTicket, IN BYTE* bKey, IN ULONG ulSaltType)
{
    HRESULT hr = E_FAIL;

    const INT cbKey = 16;

    BYTE ulSaltedKey[MD5_LEN];
    md5Hmac(bKey, cbKey, (PBYTE)&ulSaltType, sizeof(ULONG), NULL, 0, ulSaltedKey);

    if (rc4Md5HmacDecrypt(ulSaltedKey, MD5_LEN, pbTicket + sizeof(RC4_MD5_HEADER), cbTicket - sizeof(RC4_MD5_HEADER), pbTicket))
    {
        hr = S_OK;
    }

    return hr;
}

//EncryptTicket works in place
static HRESULT EncryptTicket(IN OUT BYTE *pbTicket, IN ULONG cbTicket, IN BYTE* bKey, IN ULONG ulSaltType)
{
    HRESULT hr = S_OK;

    BYTE pbConfounder[RC4_CONFOUNDER_LEN];
    memset(pbConfounder, 0, RC4_CONFOUNDER_LEN);  //TODO: randomize confounder

    const INT cbKey = 16;

    BYTE ulSaltedKey[MD5_LEN];
    md5Hmac(bKey, cbKey, (PBYTE)&ulSaltType, sizeof(ULONG), NULL, 0, ulSaltedKey);

    rc4Md5HmacEncrypt(pbConfounder, ulSaltedKey, MD5_LEN, pbTicket + sizeof(RC4_MD5_HEADER), cbTicket - sizeof(RC4_MD5_HEADER), pbTicket);

    return hr;
}

static HRESULT CrackTicket(
    IN OUT BYTE *pbTicket,
    IN OUT DWORD &cbTicket,
    IN BYTE *bKey,
    IN CallbackFuncPtr pCallback,
    IN OUT void *pData)
{
    HRESULT hr = E_FAIL;

    CScratchMemoryAllocator ScratchMemoryAllocator;
    const INT nScratchMemoryBufferSize = 3000 * 4;
    BYTE ScratchMemoryBufferTemp[nScratchMemoryBufferSize];
    ScratchMemoryAllocator.ScratchMemoryInitialize(nScratchMemoryBufferSize, ScratchMemoryBufferTemp, sizeof(ScratchMemoryBufferTemp));

    KERB_TICKET *pKerbTicketUnpacked;

    KERBERR KerbErr = KerbUnpackData(
        &ScratchMemoryAllocator,
        pbTicket,
        cbTicket,
        KERB_TICKET_PDU,
        (void**)&pKerbTicketUnpacked);
    if (KERB_SUCCESS(KerbErr))
    {
        BYTE pbDecryptedTicket[XONLINE_MAX_TICKET_LENGTH];
        ULONG cbDecryptedTicket = pKerbTicketUnpacked->encrypted_part.cipher_text.length;
        memcpy(pbDecryptedTicket, pKerbTicketUnpacked->encrypted_part.cipher_text.value, cbDecryptedTicket);

        ULONG ulSaltType = 2;  //KERB_TICKET_SALT
        hr = DecryptTicket(pbDecryptedTicket, cbDecryptedTicket, bKey, ulSaltType);

        if (SUCCEEDED(hr))
        {
            hr = E_FAIL;

            KERB_ENCRYPTED_TICKET *ptgtDecrypted;

            KerbErr = KerbUnpackData(
                &ScratchMemoryAllocator,
                pbDecryptedTicket + sizeof(RC4_MD5_HEADER),
                cbDecryptedTicket - sizeof(RC4_MD5_HEADER),
                KERB_ENCRYPTED_TICKET_PDU,
                (void**)&ptgtDecrypted);
            if (KERB_SUCCESS(KerbErr))
            {
                // Make the callback so real work can be done
                hr = pCallback(pKerbTicketUnpacked, ptgtDecrypted, pData);
                if (SUCCEEDED(hr))
                {
                    BYTE *pbEncryptedTicket = NULL;
                    ULONG cbEncryptedTicket = 0;

                    KERBERR KerbErr = KerbPackData(
                        &ScratchMemoryAllocator,
                        ptgtDecrypted,
                        KERB_ENCRYPTED_TICKET_PDU,
                        &cbEncryptedTicket,
                        &pbEncryptedTicket);
                    if (KERB_SUCCESS(KerbErr))
                    {
                        ULONG ulSaltType = 2;  //KERB_TICKET_SALT

                        pKerbTicketUnpacked->encrypted_part.cipher_text.length = cbEncryptedTicket + sizeof(RC4_MD5_HEADER);
                        memcpy(pKerbTicketUnpacked->encrypted_part.cipher_text.value + sizeof(RC4_MD5_HEADER), pbEncryptedTicket, cbEncryptedTicket);

                        BYTE *pbCrypt = pKerbTicketUnpacked->encrypted_part.cipher_text.value;
                        DWORD cbCrypt = pKerbTicketUnpacked->encrypted_part.cipher_text.length;

                        hr = EncryptTicket(pbCrypt, cbCrypt, bKey, ulSaltType);

                        if (SUCCEEDED(hr))
                        {
                            hr = E_FAIL;

                            cbTicket = 0;
                            BYTE *pbPacked = NULL;

                            KerbErr = KerbPackData(
                                &ScratchMemoryAllocator,
                                pKerbTicketUnpacked,
                                KERB_TICKET_PDU,
                                &cbTicket,
                                &pbPacked);
                            if (KERB_SUCCESS(KerbErr))
                            {
                                memcpy(pbTicket, pbPacked, cbTicket);

                                hr = S_OK;
                            }
                        }
                    }
                }
            }
        }
    }

    return hr;
}

static ASN1octetstring_t* KerbFindAuthDataEntry(
    IN ULONG EntryId,
    IN PKERB_AUTHORIZATION_DATA AuthData
    )
{
    PKERB_AUTHORIZATION_DATA TempData = AuthData;

    while (TempData != NULL)
    {
        if (TempData->value.auth_data_type == (int) EntryId)
        {
            break;
        }
        TempData = TempData->next;
    }
    return(TempData != NULL ? &TempData->value.auth_data : NULL);
}


//
// Entry points
//

HRESULT WINAPI 
kcl_GetTicketTimeRemaining(
    IN BYTE *rgSiteKey,
    IN OUT XKERB_TGT_CONTEXT *pTgt,
    OUT INT *pnSecsLeft)
{
    ClearStoredDebugSpew();

    HRESULT hr = S_OK;
    hr = CrackTicket(pTgt->Ticket, pTgt->dwTicketLength, rgSiteKey, GetTicketTimeRemaining_Callback, (void*)pnSecsLeft);
    return hr;
}

HRESULT WINAPI 
kcl_AddToTicketTimeRemaining(
    IN BYTE *rgSiteKey,
    IN OUT XKERB_TGT_CONTEXT *pTgt,
    IN INT nSecsToAdd)
{
    ClearStoredDebugSpew();

    HRESULT hr = S_OK;
    hr = CrackTicket(pTgt->Ticket, pTgt->dwTicketLength, rgSiteKey, AddToTicketTimeRemaining_Callback, (void*)&nSecsToAdd);
    return hr;
}

HRESULT WINAPI 
kcl_CopyPuidsOutToTgtContext(
    IN BYTE *rgSiteKey,
    IN OUT XKERB_TGT_CONTEXT *pTgt,
    OUT ULONGLONG *puidMachine,
    OUT ULONGLONG *puidUsers)
{
    ClearStoredDebugSpew();

    // note that puidUsers = ULONGLONG[4].  it may be null.
    HRESULT hr = S_OK;
    CopyPuidsOutToTgtContext_Params params = { pTgt, puidMachine, puidUsers };
    hr = CrackTicket(pTgt->Ticket, pTgt->dwTicketLength, rgSiteKey, CopyPuidsOutToTgtContext_Callback, (void*)&params);
    return hr;
}

HRESULT WINAPI 
kcl_GetAuthDataStruct(
    IN BYTE *rgSiteKey,
    IN XKERB_SERVICE_CONTEXT *pKerbServiceContext,
    IN OUT BYTE *rgbAuthData, 
    IN OUT DWORD *pdwAuthDataSize, 
    OUT WORD *pwAuthDataVersion)
{
    ClearStoredDebugSpew();

    HRESULT hr = S_OK;
    AuthDataStruct_Params params = { rgbAuthData, pdwAuthDataSize, pwAuthDataVersion };
    hr = CrackTicket(pKerbServiceContext->Ticket, pKerbServiceContext->dwTicketLength, rgSiteKey, GetAuthDataStruct_Callback, (void*)&params);
    return hr;
}

HRESULT WINAPI 
kcl_SetAuthDataStruct(
    IN BYTE *rgSiteKey,
    IN XKERB_SERVICE_CONTEXT *pKerbServiceContext,
    IN OUT BYTE *rgbAuthData)
{
    ClearStoredDebugSpew();

    HRESULT hr = S_OK;
    
    // Cast to most basic version, since we only need the first 4 bytes
    XKERB_AD_XBOX2 *ad = (XKERB_AD_XBOX2*)rgbAuthData;
    DWORD size = (DWORD)ad->wAuthDataSize;
    WORD version = (WORD)ad->wAuthDataVersion;

    AuthDataStruct_Params params = { rgbAuthData, &size, &version };
    hr = CrackTicket(pKerbServiceContext->Ticket, pKerbServiceContext->dwTicketLength, rgSiteKey, SetAuthDataStruct_Callback, (void*)&params);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\LargeMemory\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\kerbclient\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_kerbclient2_none_12.4.56.0_none_472da1890a20bbb9
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_kerbclient2_no-public-key_12.4.56.0_x-ww_b2094df3
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=kerbclient2
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_kerbclient2_no-public-key_12.4.56.0_x-ww_b2094df3
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_kerbclient2_no-public-key_12.4.56.0_x-ww_b2094df3.manifest
XP_MANIFEST_PATH=manifests\x86_kerbclient2_no-public-key_12.4.56.0_x-ww_b2094df3.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_kerbclient2_no-public-key_12.4.56.0_x-ww_b2094df3.cat
XP_CATALOG_PATH=manifests\x86_kerbclient2_no-public-key_12.4.56.0_x-ww_b2094df3.cat
XP_PAYLOAD_PATH=x86_kerbclient2_no-public-key_12.4.56.0_x-ww_b2094df3
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=kerbclient2,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\LargeMemory\cpl.h ===
#pragma once

#ifndef _CPL_H
#define _CPL_H

#pragma warning (disable:4102)

#define CHECK_BOOL(op) \
    if (!(op)) { \
        fprintf(stderr, "Failure in %s at %s:%u\nGetLastError: 0x%X\nOperation: %s\n", __FUNCTION__, __FILE__, __LINE__, GetLastError(), #op); \
        goto Exit; \
    }

#define CHECK_NULL(op) \
    if (NULL == (op)) { \
        fprintf(stderr, "Failure in %s at %s:%u\nGetLastError: 0x%X\nOperation: %s\n", __FUNCTION__, __FILE__, __LINE__, GetLastError(), #op); \
        goto Exit; \
    }


BOOL    cpl_Init();
void    cpl_TimerStart();
double  cpl_TimerEnd();
void    cpl_PrintMemoryStats(const char * prefix);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\LargeMemory\cpl.cpp ===
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <windows.h>

#include "cpl.h"

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
// CodePlaygroundLibary (cpl)
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

static LARGE_INTEGER _timerFrequency;
static LARGE_INTEGER _timerStartTime;
static double        _timerFrequencyMultiplier;

//-----------------------------------------------------------------------------
// cpl_Init()
//
// Call me first.
//-----------------------------------------------------------------------------
BOOL cpl_Init()
{
    BOOL bResult = FALSE;

    _timerFrequency.QuadPart = 0;
    _timerStartTime.QuadPart = 0;
    CHECK_BOOL(QueryPerformanceFrequency(&_timerFrequency));
    _timerFrequencyMultiplier = 1.0 / (double)_timerFrequency.QuadPart;

    bResult = TRUE;

Exit:
    return bResult;
}

//-----------------------------------------------------------------------------
// cpl_TimerStart()
//
// Call to start the timer.
//-----------------------------------------------------------------------------
void cpl_TimerStart()
{
    _timerStartTime.QuadPart = 0;
    CHECK_BOOL(QueryPerformanceCounter(&_timerStartTime));

    printf("[Timer] Timer started.\n");

Exit:
    return;
}

//-----------------------------------------------------------------------------
// cpl_TimerEnd()
//
// Call to stop and print the results of the timer. Returns elapsed seconds.
//-----------------------------------------------------------------------------
double cpl_TimerEnd()
{
    double elapsedSeconds = 0;
    LARGE_INTEGER endTime;
    endTime.QuadPart = 0;
    CHECK_BOOL(QueryPerformanceCounter(&endTime));

    elapsedSeconds = (endTime.QuadPart - _timerStartTime.QuadPart) * _timerFrequencyMultiplier;
    if (elapsedSeconds > 10)
    {
        printf("[Timer] Elapsed time: %.1f seconds\n", elapsedSeconds);
    }
    else if (elapsedSeconds > 0.01)
    {
        printf("[Timer] Elapsed time: %.1f milliseconds\n", elapsedSeconds * 1000);
    }
    else if (elapsedSeconds > 0.00001)
    {
        printf("[Timer] Elapsed time: %.1f microseconds\n", elapsedSeconds * 1000000);
    }
    else
    {
        printf("[Timer] Elapsed time: %f nanoseconds\n", elapsedSeconds * 1000000000);
    }


Exit:
    return elapsedSeconds;
}

//-----------------------------------------------------------------------------
// cpl_PrintMemoryStats()
//
// Displays memory stats to stdout
//-----------------------------------------------------------------------------
void cpl_PrintMemoryStats(const char * prefix)
{
#define DIV 1048576

    MEMORYSTATUSEX statex;
    statex.dwLength = sizeof(statex);
    CHECK_BOOL(GlobalMemoryStatusEx(&statex));    

    printf("[Memory] %s (MB): %d%% in use, %I64d/%I64d physical, %I64d/%I64d virtual, %I64d ext\n",
           prefix,
           statex.dwMemoryLoad, 
           statex.ullAvailPhys / DIV,
           statex.ullTotalPhys / DIV,
           statex.ullAvailVirtual / DIV,
           statex.ullTotalVirtual / DIV,
           statex.ullAvailExtendedVirtual / DIV);
Exit:
    return;
}



//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
// CodePlaygroundLibrary (cpl) End
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\LargeMemory\main.cpp ===
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <windows.h>

#include "cpl.h"

#define MODE_NONE               0
#define MODE_VIRTUALALLOC       1
#define MODE_AWEALLOC           2
#define MODE_AWEMAPPEDALLOC     3


struct AWE_MEMORY 
{
   LPVOID      Address;
   ULONG_PTR   NumPages;
   ULONG_PTR   Length;
   ULONG_PTR * aPFNs;
};

BOOL
AllocateAWEMemory (
    OUT AWE_MEMORY *AweMem,
    IN ULONG uSize
    );

BOOL
MapAWEMemory(
    IN AWE_MEMORY * AweMem,
    LPVOID * pVirtualAddress = NULL
    );

// VOID
// FreeAWEMemory (
//     IN AWE_MEMORY *AweMem
//     );

BOOL
LoggedSetLockPagesPrivilege( 
    HANDLE hProcess,
    BOOL bEnable);



void ShowHelp();
void DoAlloc(DWORD dwMode, DWORD dwSize);

BOOL    g_fFillMemory = FALSE;
BYTE    g_fillChar = 1;
BYTE *  g_pAddress = NULL;


BOOL
AllocateAWEMemory (
    AWE_MEMORY *AweMem,
    ULONG uSize
    )
{
    BOOL            bResult = TRUE;
    SYSTEM_INFO     sSysInfo;           // useful system information
    ULONG_PTR       numPagesInitial;
    int             PFNArraySize;

    if (NULL == AweMem) {
        return FALSE;
    }

    // Calculate the number of pages of memory to request.
    GetSystemInfo(&sSysInfo);  // fill the system information structure
    AweMem->NumPages = uSize / sSysInfo.dwPageSize;
    
    // Calculate the size of the user PFN array and allocate heap memory for it.
    PFNArraySize = (int)(AweMem->NumPages * sizeof (ULONG_PTR));
    CHECK_NULL(AweMem->aPFNs = (ULONG_PTR *) HeapAlloc (GetProcessHeap (), 0, PFNArraySize));

    // Enable the privilege.
    CHECK_BOOL(bResult = LoggedSetLockPagesPrivilege( GetCurrentProcess(), TRUE ) );

    // Allocate the physical memory.
    numPagesInitial = AweMem->NumPages;
    CHECK_BOOL(bResult = AllocateUserPhysicalPages( GetCurrentProcess(),
                                                    &AweMem->NumPages,
                                                    AweMem->aPFNs ));

    if (AweMem->NumPages != numPagesInitial) {
        fprintf(stderr, "AllocateUserPhysicalPages didn't allocate enough pages. Wanted %d, got %d. GetLastError()=%d\n",
                numPagesInitial, AweMem->NumPages, GetLastError());
        bResult = FALSE;
        goto Exit;
    }

    // Recompute the size
    AweMem->Length = sSysInfo.dwPageSize * AweMem->NumPages;

    // We aren't mapping to virtual memory here
    AweMem->Address = NULL;

Exit:
    return bResult;

}


BOOL
MapAWEMemory(
    AWE_MEMORY * AweMem,
    LPVOID * pVirtualAddress
    )
{
    BOOL bResult = TRUE;

    if (NULL == AweMem || NULL == AweMem->aPFNs || 0 == AweMem->Length || 0 == AweMem->NumPages)
    {
        return FALSE;
    }

    if (*pVirtualAddress == NULL)
    {
        // Reserve the virtual memory.
        printf("MapAWEMemory: Calling VirtualAlloc...\n");
        CHECK_NULL(*pVirtualAddress = VirtualAlloc( NULL,
                                                    AweMem->Length,
                                                    MEM_RESERVE | MEM_PHYSICAL,
                                                    PAGE_READWRITE ));
    }

    AweMem->Address = *pVirtualAddress;

    // Map the physical memory into the window.
    CHECK_BOOL(bResult = MapUserPhysicalPages( AweMem->Address,
                                               AweMem->NumPages,
                                               AweMem->aPFNs ));

Exit:
    return bResult;
}


BOOL
UnmapAWEMemory (
    IN AWE_MEMORY * AweMem
    )
{
    BOOL  bResult = TRUE;

    if (NULL == AweMem || NULL == AweMem->Address || NULL == AweMem->aPFNs) {
        return FALSE;
    }

    //
    // unmap
    // 
    CHECK_BOOL(bResult = MapUserPhysicalPages( AweMem->Address, 
                                               AweMem->NumPages,
                                               NULL ));
Exit:
    return bResult;
}

BOOL
FreeAWEMemory (
    AWE_MEMORY * AweMem
    )
{
    BOOL bResult = TRUE;

    // Free the physical pages.
    CHECK_BOOL(bResult = FreeUserPhysicalPages( GetCurrentProcess(),
                                                &AweMem->NumPages,
                                                AweMem->aPFNs ));
    
    HeapFree(GetProcessHeap(), 0, AweMem->aPFNs);

    // Free virtual memory.
//     bResult = VirtualFree( AweMem->Address,
//                            0,
//                            MEM_RELEASE );


Exit:
    return bResult;

} 

BOOL
LoggedSetLockPagesPrivilege( 
    HANDLE hProcess,
    BOOL bEnable)
{
    struct {
        DWORD Count;
        LUID_AND_ATTRIBUTES Privilege [1];
    } Info;

    HANDLE Token = NULL; 
    BOOL Result;

    //
    // Open the token.
    //
    CHECK_BOOL(Result = OpenProcessToken ( hProcess,
                                           TOKEN_ADJUST_PRIVILEGES,
                                           & Token));

    // Enable or disable?

    Info.Count = 1;
    if ( bEnable ) {
        Info.Privilege[0].Attributes = SE_PRIVILEGE_ENABLED;
    }
    else {
        Info.Privilege[0].Attributes = 0;
    }

    // Get the LUID.

    CHECK_BOOL(Result = LookupPrivilegeValue ( NULL,
                                               SE_LOCK_MEMORY_NAME,
                                               &(Info.Privilege[0].Luid)));

    // Adjust the privilege.

    CHECK_BOOL(Result = AdjustTokenPrivileges ( Token, FALSE,
                                                (PTOKEN_PRIVILEGES) &Info,
                                                0, NULL, NULL));

    CHECK_BOOL(Result = (GetLastError() == ERROR_SUCCESS));

Exit:
    if (Token != NULL)
    {
        CloseHandle( Token );
    }

    return Result;


}



//-----------------------------------------------------------------------------
// DoAlloc
//
// allocSize is in MB
//-----------------------------------------------------------------------------
void DoAlloc(DWORD allocMode, DWORD allocSize)
{
    if (allocSize >= 4096)
    {
        printf("Can't alloc more than 4096MB");
        return;
    }

    BYTE * pBuffer = NULL;
    ULONG allocSizeInBytes = allocSize * 1048576;

    // leaky!
    switch (allocMode)
    {
    case MODE_VIRTUALALLOC:
        {
            CHECK_NULL(pBuffer = (BYTE*)VirtualAlloc( 
                    NULL,
                    allocSizeInBytes,
                    MEM_COMMIT,
                    PAGE_READWRITE));
            if (g_fFillMemory)
            {
                memset(pBuffer, g_fillChar++, allocSizeInBytes);
            }

            break;
        }

    case MODE_AWEALLOC:
        {
            AWE_MEMORY awe;
            CHECK_BOOL(AllocateAWEMemory(
                    &awe,
                    allocSizeInBytes));

            break;
        }

    case MODE_AWEMAPPEDALLOC:
        {
            AWE_MEMORY awe;
            CHECK_BOOL(AllocateAWEMemory(
                    &awe,
                    allocSizeInBytes));
            CHECK_BOOL(MapAWEMemory(
                    &awe,
                    (LPVOID*)&g_pAddress));

            break;
        }

    default:
        printf("Unknown allocMode %d\n", allocMode);
        return;
    }


Exit:
    
    char str[1024];
    sprintf(str, "DoAlloc(%d,%d)", allocMode, allocSize);
    cpl_PrintMemoryStats(str);

} 


//-----------------------------------------------------------------------------
// Test1
//
// Returns MB/sec mapped
//-----------------------------------------------------------------------------
DWORD Test1b(DWORD dwAllocSizeInBytes, DWORD dwNumAllocs, DWORD dwNumIters)
{

    DWORD iter, iter2;
    ULONGLONG numBytesMapped = 0;
    DWORD numMBytesMapped = 0;
    AWE_MEMORY * aweMemory = new AWE_MEMORY[dwNumAllocs];
    BYTE * pVirtualAddress = NULL;
    double elapsedTime = 0;

    cpl_TimerEnd();

    printf("\n");
    printf("-----------------------------------------------------------------------------\n");
    printf("Running AWE map/unmap stress test:\n");
    printf("  Allocation size (bytes): %d\n", dwAllocSizeInBytes);
    printf("    Number of allocations: %d\n", dwNumAllocs);
    printf("     Number of iterations: %d (%d total maps)\n", dwNumIters, dwNumIters * dwNumAllocs);
    
    printf("\n");
    printf("Allocating:\n");
    cpl_TimerStart();
    for (iter = 0; iter < dwNumAllocs; iter++)
    {
        CHECK_BOOL(AllocateAWEMemory(
                &aweMemory[iter],
                dwAllocSizeInBytes));
    }
        
    // Do VAS allocation
    CHECK_NULL(pVirtualAddress = (BYTE*)VirtualAlloc( NULL,
                                                      dwAllocSizeInBytes,
                                                      MEM_RESERVE | MEM_PHYSICAL,
                                                      PAGE_READWRITE ));
    elapsedTime = cpl_TimerEnd();


    printf("\n");
    printf("Mapping:\n");
    cpl_TimerStart();
    for (iter = 0; iter < dwNumIters * dwNumAllocs; iter++)
    {
        CHECK_BOOL(MapAWEMemory(
                &aweMemory[iter % dwNumAllocs],
                (LPVOID*)&pVirtualAddress));
        CHECK_BOOL(UnmapAWEMemory(
                &aweMemory[iter % dwNumAllocs]));
        numBytesMapped += dwAllocSizeInBytes;
    }
    elapsedTime = cpl_TimerEnd();
    numMBytesMapped = (DWORD)(numBytesMapped / 1048576);
    printf("%d operations/sec\n", (DWORD)((double)(dwNumIters * dwNumAllocs) / elapsedTime));
    printf("%d total MB mapped\n", numMBytesMapped);



Exit:

    cpl_PrintMemoryStats("Test1");

    for (iter = 0; iter < dwNumAllocs; iter++)
    {
        FreeAWEMemory(&aweMemory[iter]);
    }

    if (pVirtualAddress != NULL)
    {
        VirtualFree( pVirtualAddress,
                     0,
                     MEM_RELEASE );
    }

    printf("\n");

    return (DWORD)((double)numMBytesMapped / elapsedTime);
}

DWORD Test1(DWORD dwAllocSizeMB, DWORD dwNumAllocs, DWORD dwNumIters)
{
    return Test1b(dwAllocSizeMB * 1048576, dwNumAllocs, dwNumIters);
}


//-----------------------------------------------------------------------------
// main
//-----------------------------------------------------------------------------
int __cdecl main(int argc, char* argv[])
{
    cpl_Init();
    cpl_PrintMemoryStats("Initial");
    cpl_TimerStart();

    DWORD dwSize = 0;
    DWORD dwMode = MODE_NONE;

    for (int argIdx = 1; argIdx < argc; argIdx++)
    {
        if (_stricmp(argv[argIdx], "-va") == 0)
        {
            dwMode = MODE_VIRTUALALLOC;
        }
        else if (_stricmp(argv[argIdx], "-awe") == 0)
        {
            dwMode = MODE_AWEALLOC;
        }
        else if (_stricmp(argv[argIdx], "-awem") == 0)
        {
            dwMode = MODE_AWEMAPPEDALLOC;
        }
        else if (_stricmp(argv[argIdx], "-f") == 0)
        {
            g_fFillMemory = TRUE;
        }
        else if (_stricmp(argv[argIdx], "-test1") == 0)
        {

#define NUMITERS 25

            DWORD r[16];
            DWORD i = 0;
            
//             Test1(512, 8, 100);
//             Test1(256, 8, 100);
//             Test1(128, 8, 100);
            
            r[i++] = Test1( 1, 10240, NUMITERS);


//             r[i++] = Test1( 1024,   4, NUMITERS);
//             r[i++] = Test1( 512,    8, NUMITERS);
//             r[i++] = Test1( 256,   16, NUMITERS);
//             r[i++] = Test1( 128,   32, NUMITERS);
//             r[i++] = Test1(  64,   64, NUMITERS);
//             r[i++] = Test1(  32,  128, NUMITERS);
//             r[i++] = Test1(  16,  256, NUMITERS);
//             r[i++] = Test1(   8,  512, NUMITERS);
//             r[i++] = Test1(   4, 1024, NUMITERS);
//             r[i++] = Test1(   2, 2048, NUMITERS);
//             r[i++] = Test1(   1, 4096, NUMITERS);

            printf("-----------------------------------------------------------------------------\n");
            printf("Results:\n");
            for (DWORD j = 0; j < i; j++)
            {
                printf("%d\n", r[j]);
            }
        }
        else if (_stricmp(argv[argIdx], "-test2") == 0)
        {
#define NUMITERS2 5

            DWORD r[32];
            DWORD i = 0;
            
            DWORD allocSize = 4096;
            DWORD numAllocs = 262144;

            // 4096 -> 1048576 (9)
            // 4096 -> 1GB (18)
            for (i = 0; i < 19; i++)
            {
                r[i] = Test1b(allocSize, numAllocs, NUMITERS2);
                allocSize <<= 1;
                numAllocs >>= 1;
            }

            printf("-----------------------------------------------------------------------------\n");
            printf("Results (in KB):\n");
            for (DWORD j = 0; j < i; j++)
            {
                printf("%12d %12d\n", (4096 << j) >> 10, r[j]);
            }
        }
        else if (dwMode != MODE_NONE &&
                 (dwSize = atoi(argv[argIdx])) > 0)
        {
            DoAlloc(dwMode, dwSize); 
        }
        else 
        {
            ShowHelp();
        }

    }
  

Exit:
    cpl_TimerEnd();
    cpl_PrintMemoryStats("Final");
    return 0;
}

void ShowHelp()
{
    //               1        2         3         4         5         6         7          8
    //      12345678901234567890123456789012345678901234567890123456789012345678901234567890
    printf("LargeMemoryTest [-f] [allocmode size1 size2 size3 ...] [-test1]\n");
    printf("\n");
    printf("  -f        : Fill new memory with unique value.\n");
    printf("  allocmode : Allocation mode to use. Applies to all subsequent sizes until changed\n");
    printf("              again. Valid allocmode params:\n");
    printf("        -va : VirtualAlloc (default)\n");
    printf("       -awe : Use AWE memory, unmapped\n");
    printf("      -awem : Use AWE memory, mapped into VAS\n");
    printf("\n");
    printf("  sizeN     : A number representing an allocation size in MB. May be repeated.\n");
    printf("\n");
    printf("  -test1    : Ignore other options, run test #1.\n");
    printf("\n");
    printf("Examples:\n");
    printf("\n");
    printf("  LargeMemoryTest -va 1024\n");
    printf("  LargeMemoryTest -f -va 512 512 128\n");
    printf("  LargeMemoryTest -awem 1000 1000\n");
    printf("  LargeMemoryTest -test1\n");
    printf("\n");
    exit(-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\AskdcEcho.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.Auth.Asn;

namespace XkdcTest
{
    [TestGroup, Description("Tests for the askdc echo anti-dos feature tests"), AsyncGroup(1,0)]
    public class AskdcEcho: TestNode
    {
        public override void PreRun()
        {
            //grab current echo setting

            //enable echo on all requests
        }

        public override void PostRun()
        {
            //restore echo setting
        }

        #region Positive Cases

        [TestCase, Description("Does a normal askdc request, but verifies that we used an echo response to do it.")]
        [CompoundCase("Xenon MachineOnly", AuthContext.ClientTypes.Xenon,    0)]
        [CompoundCase("Xenon 1User",       AuthContext.ClientTypes.Xenon,    1)]
        [CompoundCase("Xenon 4User",       AuthContext.ClientTypes.Xenon,    4)]
        [CompoundCase("PC MachineOnly",    AuthContext.ClientTypes.Panorama, 0)]
        [CompoundCase("PC 1User",          AuthContext.ClientTypes.Panorama, 1)]
        public class VerifyUse: TestNode
        {
            private int echoUseCount;

            bool SigninProgressCallback(AuthContext ctx, XonlinepUser user, bool isMachine, bool isEchoRetry, ref byte []echoBytesToSend)
            {
                if (isEchoRetry)
                {
                    ++echoUseCount;
                }
                return true;
            }

            public override void Run()
            {
                AuthContext.ClientTypes clientType=(AuthContext.ClientTypes)MyValues[0];
                int userCount=(int)MyValues[1];

                AuthContext ctx=new AuthContext(clientType);
                AskdcClient askdc=new AskdcClient(ctx);
                askdc.SigninProgressCallback=SigninProgressCallback;

                for (int u=0; u<userCount; ++u)
                {
                    ctx.SetNewPassportUser(u, false);
                }

                echoUseCount=0;
                askdc.SignInAskdc();

                if (clientType==AuthContext.ClientTypes.Panorama && userCount==1 && echoUseCount==1) //known bug with askdc pc echo
                {
                    throw new KnownBugException(36452, "Xbox 360 Console Software", "Our ASKDC passport authentication has a gap in the anti-dos mechanism here.  It does not demand an echo for passport authentication.  It SHOULD though.");
                }

                ValueCheck.Test("Echo Uses", 1, echoUseCount);
            }
        }

        #endregion

        #region Negative Cases

        // Current format is: (8 timestamp + 4 ip + 3 random + 1 checksum)
        protected const int ECHOOFFSET_TIMESTAMP=0;
        protected const int ECHOOFFSET_IP=ECHOOFFSET_TIMESTAMP+8;
        protected const int ECHOOFFSET_RANDOM=ECHOOFFSET_IP+4;
        protected const int ECHOOFFSET_CHECKSUM=ECHOOFFSET_RANDOM+3;

        //Recomputes the checksum on an (unencrypted) echo blob
        protected static void FixChecksum(byte []bytes)
        {
            uint csum=0;
            for (int i=0; i<ECHOOFFSET_CHECKSUM; ++i)
                csum+=bytes[i];

            bytes[ECHOOFFSET_CHECKSUM]=(byte)(csum&0xff);
        }

        //base for most negative cases
        abstract public class ChangeEchoTestBase: TestNode
        {
            //change this if you wish
            protected bool ShouldSucceed=false;
            protected bool ShouldTimeout=false;
            protected bool DisableRetryBehaviour=false;

            //implement this
            abstract protected void AlterEchoBytes(ref byte []echoBytes);

            //internals
            bool didEcho;
            bool SigninProgressCallback(AuthContext ctx, XonlinepUser user, bool isMachine, bool isEchoRetry, ref byte []echoBytesToSend)
            {
                if (isEchoRetry)
                {
                    if (echoBytesToSend.Length!=16)
                    {
                        throw new System.Exception("Echo blob from KDC is not 16 bytes like we expected.");
                    }

                    didEcho=true;
                    AlterEchoBytes(ref echoBytesToSend);
                }
                return true;
            }

            public override void Run()
            {
                AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
                AskdcClient askdc=new AskdcClient(ctx);
                askdc.SigninProgressCallback=SigninProgressCallback;
                if (DisableRetryBehaviour) askdc.EmulateClientBehavior=false;

                try
                {
                    didEcho=false;
                    askdc.SignInAskdc();
                }
                catch (KerbErrException kee)
                {
                    if (didEcho && kee.KerbErr==KerbErrCode.KDC_ERR_PREAUTH_REQUIRED && !ShouldSucceed && !ShouldTimeout)
                    {
                        return;
                    }
                    else if (didEcho && ShouldTimeout)
                    {
                        throw new UnexpectedTestResultException("Expected to time out, but got kerb err: "+kee);
                    }
                    else if (didEcho)
                    {
                        throw;
                    }
                }
                catch (ServerTestFramework.Utilities.TimeoutException)
                {
                    if (didEcho && !ShouldSucceed && ShouldTimeout)
                    {
                        return;
                    }
                    else if (didEcho)
                    {
                        throw;
                    }
                }

                if (!didEcho)
                {
                    throw new UnexpectedTestResultException("Did not attempt echo retry.");
                }

                if (!ShouldSucceed)
                {
                    throw new UnexpectedTestResultException("Should not have succeeded in request.");
                }
            }
        }

        //tests
        [TestCase, Description("Returns garbage data in the echo preauth to the server.")]
        [CompoundCase("0 bytes",    0,    true)]
        [CompoundCase("1 byte",     1,    true)]
        [CompoundCase("16 bytes",   16,   false)]
        [CompoundCase("1000 bytes", 1000, true)]
        public class RespondWithBS: ChangeEchoTestBase
        {
            public RespondWithBS()
            {
                DisableRetryBehaviour=true;
            }

            protected override void AlterEchoBytes(ref byte []echoBytes)
            {
                int byteCount=(int)MyValues[0];
                ShouldTimeout=(bool)MyValues[1];

                echoBytes=new byte[byteCount];
                for (int i=0; i<byteCount; ++i)
                {
                    echoBytes[i]=(byte)(i%256);
                }
            }
        }

        [TestCase, Description("decrypts and reencrypts an echo blob without changing anything to make sure that we did crypto right")]
        public class ClientCryptoSanityCheck: ChangeEchoTestBase
        {
            protected override void AlterEchoBytes(ref byte []echoBytes)
            {
                byte []orig=(byte[])echoBytes.Clone();

                byte []realBytes=AskdcClient.DecryptEchoBytes(echoBytes);
                echoBytes=AskdcClient.EncryptEchoBytes(realBytes);

                //verify we changed nothing
                if (orig.Length!=echoBytes.Length)
                    throw new UnexpectedTestResultException("Length changed.");

                for (int i=0; i<echoBytes.Length; ++i)
                {
                    if (orig[i]!=echoBytes[i])
                        throw new UnexpectedTestResultException("Byte "+i+" changed.");
                }

                ShouldSucceed=true;
            }
        }

        [TestCase, Description("Changes the time within the encrypted blob.")]
        [CompoundCase("MaxValue0",  true,  (ulong)0xffffffffffffffff, false)]
        [CompoundCase("MaxValue1",  true,  (ulong)0x7fffffffffffffff, false)]
        [CompoundCase("MinValue0",  true,  (ulong)0x0000000000000000, false)]
        [CompoundCase("MinValue1",  true,  (ulong)0x8000000000000000, false)]
        [CompoundCase("TweakByte0", false, (ulong)0x0000000000000055, true)] //too tiny a change to leave valid time range
        [CompoundCase("TweakManyBits", false, (ulong)0x0101010101010101, false)]
        public class ChangeTime: ChangeEchoTestBase
        {
            protected override void AlterEchoBytes(ref byte []echoBytes)
            {
                byte []realBytes=AskdcClient.DecryptEchoBytes(echoBytes);

                ulong value=(ulong)MyValues[1];
                if ((bool)MyValues[0]) //set
                {
                    for (int i=0; i<8; ++i)
                    {
                        realBytes[ECHOOFFSET_TIMESTAMP+i]=(byte)(0xff&(value>>((7-i)*8)));
                    }
                }
                else //tweak
                {
                    for (int i=0; i<8; ++i)
                    {
                        realBytes[ECHOOFFSET_TIMESTAMP+i]^=(byte)(0xff&(value>>((7-i)*8)));
                    }
                }

                FixChecksum(realBytes);
                echoBytes=AskdcClient.EncryptEchoBytes(realBytes);

                ShouldSucceed=(bool)MyValues[2];
            }
        }

        [TestCase, Description("Changes the ip within the encrypted blob.")]
        [CompoundCase("Low bit", 3, 1)]
        [CompoundCase("High bit", 0, 0x80)]
        public class ChangeIP: ChangeEchoTestBase
        {
            protected override void AlterEchoBytes(ref byte []echoBytes)
            {
                byte []realBytes=AskdcClient.DecryptEchoBytes(echoBytes);

                int ipByte=(int)MyValues[0];
                byte ipByteXor=(byte)(int)MyValues[1];
                realBytes[ECHOOFFSET_IP+ipByte]^=ipByteXor;

                FixChecksum(realBytes);
                echoBytes=AskdcClient.EncryptEchoBytes(realBytes);
            }
        }

        [TestCase, Description("Changes the random value within the encrypted blob.")]
        public class ChangeRandom: ChangeEchoTestBase
        {
            protected override void AlterEchoBytes(ref byte []echoBytes)
            {
                ShouldSucceed=true;
                byte []realBytes=AskdcClient.DecryptEchoBytes(echoBytes);

                for (int i=0; i<3; ++i)
                {
                    realBytes[ECHOOFFSET_RANDOM+i]=(byte)(ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next()&0xff);
                }

                FixChecksum(realBytes);
                echoBytes=AskdcClient.EncryptEchoBytes(realBytes);
            }
        }

        [TestCase, Description("Changes the checksum within the encrypted blob.")]
        public class ChangePadding: ChangeEchoTestBase
        {
            protected override void AlterEchoBytes(ref byte []echoBytes)
            {
                byte []realBytes=AskdcClient.DecryptEchoBytes(echoBytes);

                realBytes[ECHOOFFSET_CHECKSUM]^=1;

                echoBytes=AskdcClient.EncryptEchoBytes(realBytes);
            }
        }

        #endregion
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\ClientRegionTracking.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Database;

namespace XkdcTest
{
    [TestGroup, Description("Tests for the column added to t_machines that tracks the last seen console region of a machine."), TestCasePriority(3)]
    public class ClientRegionTracking
    {
        [TestGroup, AsyncGroup(1), Description("Mainline cases for the platforms of interest.")]
        [CompoundCase("Xbox360", AuthContext.ClientTypes.Xenon)]
        public class TrackingPlatforms: TestNode
        {
            public override void PreRun()
            {
                CreateContextData();
                SetContextData("PlatformType", MyValues[0]);
            }

            //
            [TestCase, Description("A machine that has never connected to live before.")]
            public void NewMachine()
            {
                AuthContext.ClientTypes clientType=(AuthContext.ClientTypes)GetContextData("PlatformType");

                //create a new machine but don't get a ticket from it yet
                KdcClient kdc=new KdcClient(clientType);
                kdc.ExecuteAskdc(true);

                //verify db
                MachineEditor dbMachine=MachineEditor.FromId(kdc.XmacsOutput.MachineId);
                ValueCheck.Test("Console region in db after xmacs", 0, dbMachine.ConsoleRegion);

                //now get a ticket from the xkdc
                kdc.CreateXkdcRequest();
                kdc.XkdcRequest.Input.ConsoleRegion=7;
                kdc.ExecuteXkdc(true);

                //verify db
                ValueCheck.Test("Console region in db after xkdc", 7, dbMachine.ConsoleRegion);
                Global.RO.Debug("Console region in db: "+dbMachine.ConsoleRegion);
            }

            [TestCase, Description("A machine that has connected to live before.")]
            [CompoundCase("Zero to Other",  0,  9,  9)]
            [CompoundCase("Other to Zero",  19, 0,  19)]
            [CompoundCase("Other to Other", 19, 82, 82)]
            [CompoundCase("Zero to Zero",   0,  0,  0)]
            public class ExistingMachine: TestNode
            {
                public override void Run()
                {
                    //gather parameters
                    AuthContext.ClientTypes clientType=(AuthContext.ClientTypes)GetContextData("PlatformType");
                    int initRegion=(int)MyValues[0];
                    int requestRegion=(int)MyValues[1];
                    int expectRegion=(int)MyValues[2];

                    //setup machine in DB
                    MachineEditor dbMachine=MachineEditor.CreateNew(MachineEditor.AuthClientTypeToMachineType(clientType));
                    dbMachine.ConsoleRegion=initRegion;
                    Global.RO.Debug("Console region in db: "+dbMachine.ConsoleRegion);

                    //get a ticket from the xkdc
                    Global.RO.Debug("Getting a ticket with region: "+requestRegion);
                    KdcClient kdc=new KdcClient(clientType);
                    kdc.XmacsOutput=new XmacsGenericReplyOutput();
                    kdc.XmacsOutput.PopulateFromDatabase(dbMachine);
                    kdc.CreateXkdcRequest();
                    kdc.XkdcRequest.Input.ConsoleRegion=(uint)requestRegion;
                    kdc.ExecuteXkdc(true);

                    //verify db
                    ValueCheck.Test("Console region in db", expectRegion, dbMachine.ConsoleRegion);
                    Global.RO.Debug("Console region in db: "+dbMachine.ConsoleRegion);
                }
            };

            [TestCase, Description("Check that region is updated when an error is returned.")]
            public void KerberosError()
            {
                AuthContext.ClientTypes clientType=(AuthContext.ClientTypes)GetContextData("PlatformType");

                //try to get ticket with a bad title
                Global.RO.Debug("Attempting to get a ticket to a bad title.");
                KdcClient kdc=new KdcClient(clientType);
                kdc.CreateXkdcRequest();
                kdc.XkdcRequest.Input.TitleID=0x78901234;
                kdc.XkdcRequest.Input.ConsoleRegion=33;
                kdc.XkdcThrowOnOverallHRFailure=false;
                kdc.ExecuteXkdc(true);
                ValueCheck.Test("Xkdc HR", 0x80151912, kdc.XkdcOutput.Hr);

                //check db
                MachineEditor dbMachine=MachineEditor.FromId(kdc.XmacsOutput.MachineId);
                ValueCheck.Test("Console region in db", 33, dbMachine.ConsoleRegion);
                Global.RO.Debug("Console region in db: "+dbMachine.ConsoleRegion);
            }
        };

        [TestGroup, AsyncGroup(1), Description("Tests for platforms that we don't track region of.")]
        [CompoundCase("PC", AuthContext.ClientTypes.Panorama)]
        public class NontrackingPlatforms: TestNode
        {
            public override void PreRun()
            {
                CreateContextData();
                SetContextData("PlatformType", MyValues[0]);
            }

            //
            [TestCase]
            public void NewMachine()
            {
                AuthContext.ClientTypes clientType=(AuthContext.ClientTypes)GetContextData("PlatformType");

                //create a new machine but don't get a ticket from it yet
                KdcClient kdc=new KdcClient(clientType);
                kdc.ExecuteAskdc(true);

                //verify db
                MachineEditor dbMachine=MachineEditor.FromId(kdc.XmacsOutput.MachineId);
                ValueCheck.Test("Console region in db after xmacs", 0, dbMachine.ConsoleRegion);

                //now get a ticket from the xkdc
                kdc.CreateXkdcRequest();
                kdc.XkdcRequest.Input.ConsoleRegion=7;
                kdc.ExecuteXkdc(true);

                //verify db
                ValueCheck.Test("Console region in db after xkdc", 0, dbMachine.ConsoleRegion);
                Global.RO.Debug("Console region in db: "+dbMachine.ConsoleRegion);
            }
        };

        [TestCase, AsyncGroup(2), Description("Min valued version")]
        public void MinValue()
        {
            //create a new machine and get a ticket
            KdcClientXbox360 kdc=new KdcClientXbox360();
            kdc.CreateXkdcRequest();
            kdc.XkdcRequest.Input.ConsoleRegion=1;
            kdc.ExecuteXkdc(true);

            //verify db
            MachineEditor dbMachine=MachineEditor.FromId(kdc.XmacsOutput.MachineId);
            ValueCheck.Test("Console region in db after xkdc", 1, dbMachine.ConsoleRegion);
            Global.RO.Debug("Console region in db: "+dbMachine.ConsoleRegion);
        }

        [TestCase, AsyncGroup(2), Description("Max valued version")]
        public void MaxValue()
        {
            //create a new machine and get a ticket
            KdcClientXbox360 kdc=new KdcClientXbox360();
            kdc.CreateXkdcRequest();
            kdc.XkdcRequest.Input.ConsoleRegion=0xffffffff;
            kdc.ExecuteXkdc(true);

            //verify db
            MachineEditor dbMachine=MachineEditor.FromId(kdc.XmacsOutput.MachineId);
            ValueCheck.Test("Console region in db after xkdc", unchecked((int)0xffffffff), dbMachine.ConsoleRegion);
            Global.RO.Debug("Console region in db: "+dbMachine.ConsoleRegion);
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\test\StfTests\Banning.cs ===
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

using xonline.common.config;

namespace XkdcTest
{
    [TestGroup, Description("Tests for banned things.")]
    [CompoundCase("PreAuthV{0}", 4)]
    [CompoundCase("PreAuthV{0}", 5)]
    [CompoundCase("PreAuthV{0}", 6)]
    public class Banning: TestNode
    {
        public override void PreRun()
        {
            int srVersion=(int)MyValues[0];
            CreateContextData();
            SetContextData("SRVersion", srVersion);
        }

        public static int GetSRVersion(TestNode node)
        {
            return (int)node.GetContextData("SRVersion");
        }

        public static void SetSRVersion(TestNode node, KdcClient client)
        {
            if (client.XkdcRequest==null)
            {
                client.CreateXkdcRequest();
            }

            int srVersion=GetSRVersion(node);
            if (srVersion==4)
            {
                client.XkdcRequest.Input.XenonPreauthVersion=4;
                client.XkdcRequest.Input.ServiceRequestVersion=4;
            }
            else if (srVersion==5)
            {
                client.XkdcRequest.Input.XenonPreauthVersion=5;
                client.XkdcRequest.Input.ServiceRequestVersion=5;
            }
            else if (srVersion==6)
            {
                client.XkdcRequest.Input.XenonPreauthVersion=5;
                client.XkdcRequest.Input.ServiceRequestVersion=6;
            }
        }

        // --

        [TestGroup, Description("All machine types can be banned by machine puid.")]
        public class Machine: TestNode
        {
            [TestCase, Description("Simple test of banning a machine.")]
            //                                                               table             expected
            [CompoundCase("Xbox360 7 ", AuthContext.ClientTypes.Xenon,       (uint)7,          (uint)0,          false)] //NOTE: Xkdc will treat it as 0 if the high bit is not set
            [CompoundCase("Xbox360 80000007", AuthContext.ClientTypes.Xenon, (uint)0x80000007, (uint)0x80000007, false)]
            [CompoundCase("PC1 7", AuthContext.ClientTypes.Panorama,         (uint)7,          (uint)0,          false)] //note: PCs expect timeout from xmacs
            [CompoundCase("PC1 80000007", AuthContext.ClientTypes.Panorama,  (uint)0x80000007, (uint)0x80000007, false)] //note: PCs expect timeout from xmacs
            [CompoundCase("PC2 7", AuthContext.ClientTypes.Panorama,         (uint)7,          (uint)0,          true)]  //note: PCs expect timeout from xmacs
            [CompoundCase("PC2 80000007", AuthContext.ClientTypes.Panorama,  (uint)0x80000007, (uint)0x80000007, true)]  //note: PCs expect timeout from xmacs
            public void Simple(TestNode node)
            {
                //create the machine
                AuthContext.ClientTypes clientType=(AuthContext.ClientTypes)node.MyValues[0];
                uint hrInTable=(uint)node.MyValues[1];
                uint hrExpected=(uint)node.MyValues[2];
                bool isPcXmacs2Request=(bool)node.MyValues[3];
                KdcClient client=KdcClient.CreateForClientType(clientType);

                if (isPcXmacs2Request)
                {
                    KdcUser user=new KdcUser();
                    user.CreateUser(true);

                    client.CreateXmacsRequest();
                    client.XmacsRequest.Input.EncryptedPassport=user.Passport.GetTicket("MBI", AuthClientBase.PassportSite.KdcPanorama);
                }

                client.ExecuteXmacs(true);
                Global.RO.Debug("Created machine: 0x{0:X}", client.XmacsOutput.MachineId);

                //ban it
                MachineEditor mach=MachineEditor.FromId(client.XmacsOutput.MachineId);
                mach.BanMachine((int)hrInTable, System.DateTime.UtcNow-new System.TimeSpan(0, 0, 10, 0), System.DateTime.MaxValue);

                //now hit xkdc, it should fail with our hr ban error
                client.XkdcThrowOnOverallHRFailure=false;
                SetSRVersion(this, client);
                client.ExecuteXkdc(true);

                ValueCheck.Test("Xkdc Overall HR", hrExpected, client.XkdcOutput.Hr);

                if (GetSRVersion(this)>=6 && hrExpected!=0) //also verify the ban expiration date when service address failed is available
                {
                    ValueCheck.Test("Machine Ban Expiration Date", System.DateTime.MaxValue, client.XkdcOutput.GetConvertedConsoleBanExpireTime(), new System.TimeSpan(1, 0, 0, 1));
                    for (int u=0; u<4; ++u)
                    {
                        ValueCheck.Test("User Ban Expire FileTime", 0, client.XkdcOutput.UserBanExpireTime[u]);
                    }
                }

                //go back through xmacs-askdc-xkdc again to make sure machine account reset doesn't affect anything
                if (clientType!=AuthContext.ClientTypes.Panorama)
                {
                    client.ClearXkdc();
                    client.ExecuteXmacs(true);
                    client.XkdcThrowOnOverallHRFailure=false;
                    SetSRVersion(this, client);
                    client.ExecuteXkdc(true);

                    ValueCheck.Test("Xkdc Overall HR", hrExpected, client.XkdcOutput.Hr);
                }
                else //PC works differently - xmacs is expected to time out
                {
                    try
                    {
                        client.RetryLostPackets=false;
                        client.ExecuteXmacs(true);

                        throw new UnexpectedTestResultException("Expected request to xmacs to time out.");
                    }
                    catch (ServerTestFramework.Utilities.TimeoutException)
                    {
                        //expected behaviour
                    }
                }
            }

            [TestCase, Description("Verify an expired ban.")]
            public void PastBan()
            {
                //create the machine
                AuthContext.ClientTypes clientType=AuthContext.ClientTypes.Xenon;
                KdcClient client=KdcClient.CreateForClientType(clientType);

                client.ExecuteXmacs(true);
                Global.RO.Debug("Created machine: 0x{0:X}", client.XmacsOutput.MachineId);

                //ban it
                MachineEditor mach=MachineEditor.FromId(client.XmacsOutput.MachineId);
                mach.BanMachine(unchecked((int)0x8f00000f), System.DateTime.UtcNow-new System.TimeSpan(8, 0, 0, 0), System.DateTime.UtcNow-new System.TimeSpan(0, 0, 10, 0));

                //verify no ban
                client.ExecuteXmacs(true); //hit xmacs reset too just to check that it doesn't block us
                SetSRVersion(this, client);
                client.ExecuteXkdc(true);
            }

            [TestCase, Description("A ban with a start date in the future.")]
            public void FutureBan()
            {
                //create the machine
                AuthContext.ClientTypes clientType=AuthContext.ClientTypes.Xenon;
                KdcClient client=KdcClient.CreateForClientType(clientType);

                client.ExecuteXmacs(true);
                Global.RO.Debug("Created machine: 0x{0:X}", client.XmacsOutput.MachineId);

                //ban it
                MachineEditor mach=MachineEditor.FromId(client.XmacsOutput.MachineId);
                mach.BanMachine(unchecked((int)0x8f00000f), System.DateTime.UtcNow+new System.TimeSpan(1, 0, 0, 0), System.DateTime.UtcNow+new System.TimeSpan(7, 0, 0, 0));

                //verify ban
                client.ExecuteXmacs(true); //hit xmacs reset too just to check that it doesn't block us
                SetSRVersion(this, client);
                client.ExecuteXkdc(true); //request should succeeded since the ban hasn't started yet
            }

            [TestCase, Description("Verify that two consoles that share the same console ID but have different machine puids can be banned independently.")]
            public void SharedConsoleID()
            {
                //create two machines with the same console ID
                KdcClientXbox360 clientA=XenonTwinSeparation.GenerateRandomXmacsRequest();
                clientA.ExecuteXmacs(true);
                KdcClientXbox360 clientB=XenonTwinSeparation.GenerateRandomXmacsRequest(clientA.XmacsRequest.Input.ConsoleId);
                clientB.ExecuteXmacs(true);

                //ban one
                MachineEditor machA=MachineEditor.FromId(clientA.XmacsOutput.MachineId);
                machA.BanMachine(unchecked((int)0x87654321), System.DateTime.UtcNow-new System.TimeSpan(0, 0, 10, 0), System.DateTime.MaxValue);

                //verify one is banned and the other is not
                clientA.XkdcThrowOnOverallHRFailure=false;
                SetSRVersion(this, clientA);
                clientA.ExecuteXkdc(true);
                ValueCheck.Test("Xkdc Overall HR", 0x87654321, clientA.XkdcOutput.Hr);

                if (GetSRVersion(this)>=6) //also verify the ban expiration date when service address failed is available
                {
                    ValueCheck.Test("Machine Ban Expiration Date", System.DateTime.MaxValue, clientA.XkdcOutput.GetConvertedConsoleBanExpireTime(), new System.TimeSpan(1, 0, 0, 1));
                    for (int u=0; u<4; ++u)
                    {
                        ValueCheck.Test("User Ban Expire FileTime", 0, clientA.XkdcOutput.UserBanExpireTime[u]);
                    }
                }

                SetSRVersion(this, clientB);
                clientB.ExecuteXkdc(true);
            }

            [TestCase, Description("Verify that two consoles that share the same console ID but have different machine puids can be banned independently.")]
            public void SharedConsoleID_SecondComesLater()
            {
                //create machine
                KdcClientXbox360 clientA=XenonTwinSeparation.GenerateRandomXmacsRequest();
                clientA.ExecuteXmacs(true);
                SetSRVersion(this, clientA);
                clientA.ExecuteXkdc(true);

                //ban one
                MachineEditor machA=MachineEditor.FromId(clientA.XmacsOutput.MachineId);
                machA.BanMachine(unchecked((int)0x87654321), System.DateTime.UtcNow-new System.TimeSpan(0, 0, 10, 0), System.DateTime.MaxValue);

                //create another with the same console id and that it is not banned
                KdcClientXbox360 clientB=XenonTwinSeparation.GenerateRandomXmacsRequest(clientA.XmacsRequest.Input.ConsoleId);
                clientB.ExecuteXmacs(true);
                SetSRVersion(this, clientB);
                clientB.ExecuteXkdc(true);

                //verify the original is still banned
                clientA.XkdcThrowOnOverallHRFailure=false;
                SetSRVersion(this, clientA);
                clientA.ExecuteXkdc(true);
                ValueCheck.Test("Xkdc Overall HR", 0x87654321, clientA.XkdcOutput.Hr);

                if (GetSRVersion(this)>=6) //also verify the ban expiration date when service address failed is available
                {
                    ValueCheck.Test("Machine Ban Expiration Date", System.DateTime.MaxValue, clientA.XkdcOutput.GetConvertedConsoleBanExpireTime(), new System.TimeSpan(1, 0, 0, 1));
                    for (int u=0; u<4; ++u)
                    {
                        ValueCheck.Test("User Ban Expire FileTime", 0, clientA.XkdcOutput.UserBanExpireTime[u]);
                    }
                }
            }

            [TestCase, Description("A machine is banned for multiple reasons.")]
            public void MultipleReasons()
            {
                //create the machine
                KdcClientXbox360 client=new KdcClientXbox360();

                client.ExecuteXmacs(true);
                Global.RO.Debug("Created machine: 0x{0:X}", client.XmacsOutput.MachineId);

                //ban it for several reasons
                MachineEditor mach=MachineEditor.FromId(client.XmacsOutput.MachineId);
                mach.BanMachine(unchecked((int)0x80000001), System.DateTime.UtcNow-new System.TimeSpan(5, 0, 0, 0), System.DateTime.UtcNow-new System.TimeSpan(4, 0, 0, 0)); //expired ban
                mach.BanMachine(unchecked((int)0x80000002), System.DateTime.UtcNow-new System.TimeSpan(5, 0, 0, 0), System.DateTime.MaxValue-new System.TimeSpan(3, 0, 0, 0)); //starting 5 days ago
                mach.BanMachine(unchecked((int)0x80000003), System.DateTime.UtcNow-new System.TimeSpan(1, 0, 0, 0), System.DateTime.MaxValue); //starting 1 days ago
                mach.BanMachine(unchecked((int)0x80000004), System.DateTime.UtcNow-new System.TimeSpan(3, 0, 0, 0), System.DateTime.MaxValue-new System.TimeSpan(4, 0, 0, 0)); //starting 3 days ago
                mach.BanMachine(unchecked((int)0x80000005), System.DateTime.UtcNow+new System.TimeSpan(1, 0, 0, 0), System.DateTime.MaxValue-new System.TimeSpan(2, 0, 0, 0)); //future ban

                //now hit xkdc, it should fail with the hr that has the latest start time
                client.ExecuteXmacs(true); //hit xmacs reset too just to check that it doesn't block us
                client.XkdcThrowOnOverallHRFailure=false;
                SetSRVersion(this, client);
                client.ExecuteXkdc(true);

                ValueCheck.Test("Xkdc Overall HR", 0x80000003, client.XkdcOutput.Hr); //should be the ban that ends the latest

                if (GetSRVersion(this)>=6) //also verify the ban expiration date when service address failed is available
                {
                    ValueCheck.Test("Machine Ban Expiration Date", System.DateTime.MaxValue, client.XkdcOutput.GetConvertedConsoleBanExpireTime(), new System.TimeSpan(1, 0, 0, 1));
                    for (int u=0; u<4; ++u)
                    {
                        ValueCheck.Test("User Ban Expire FileTime", 0, client.XkdcOutput.UserBanExpireTime[u]);
                    }
                }
            }

            [TestCase, Description("Machine is banned.  Do a normal xkdc request that has a user authenticated.")]
            public void SimpleBanned_XkdcUserRequest()
            {
                //create the machine
                AuthContext.ClientTypes clientType=AuthContext.ClientTypes.Xenon;
                KdcClient client=KdcClient.CreateForClientType(clientType);

                client.ExecuteXmacs(true);
                Global.RO.Debug("Created machine: 0x{0:X}", client.XmacsOutput.MachineId);

                //ban it
                System.DateTime banEndDate=System.DateTime.UtcNow+new System.TimeSpan(8, 0, 0, 0);
                MachineEditor mach=MachineEditor.FromId(client.XmacsOutput.MachineId);
                mach.BanMachine(unchecked((int)0x8f00000f), System.DateTime.UtcNow-new System.TimeSpan(8, 0, 0, 0), banEndDate);

                //authenticate a user and machine with askdc
                client.CreateAskdcUserRequest(new KdcUser());
                client.ExecuteAskdc(true);

                client.CreateAskdcMachineRequest();
                client.ExecuteAskdc(true);

                //now verify banned by xkdc like normal still
                client.XkdcThrowOnOverallHRFailure=false;
                SetSRVersion(this, client);
                client.ExecuteXkdc(true);

                ValueCheck.Test("Xkdc Overall HR", 0x8f00000f, client.XkdcOutput.Hr);

                if (GetSRVersion(this)>=6) //also verify the ban expiration date when service address failed is available
                {
                    ValueCheck.Test("Machine Ban Expiration Date", banEndDate, client.XkdcOutput.GetConvertedConsoleBanExpireTime(), new System.TimeSpan(0, 0, 1));
                    for (int u=0; u<4; ++u)
                    {
                        ValueCheck.Test("User Ban Expire FileTime", 0, client.XkdcOutput.UserBanExpireTime[u]);
                    }
                }
            }

            [TestCase, Description("Verifies that the old ban column is no longer respected.")]
            [CompoundCase("Xbox360", AuthContext.ClientTypes.Xenon)]
            [CompoundCase("PC", AuthContext.ClientTypes.Panorama)]
            public void VerifyOldBanColumnIsIgnored(TestNode self)
            {
                AuthContext.ClientTypes clientType=(AuthContext.ClientTypes)(self.MyValues[0]);

                //create the machine
                KdcClient client=KdcClient.CreateForClientType(clientType);

                client.ExecuteXmacs(true);
                Global.RO.Debug("Created machine: 0x{0:X}", client.XmacsOutput.MachineId);

                //ban it the old way that no longer is respected
                UodbWS.ExecuteSQLNonQuery("update t_machines set dt_blocked_date='2000/01/01' where bi_machine_puid="+(long)client.XmacsOutput.MachineId, client.XmacsOutput.MachineId);

                //verify no ban
                SetSRVersion(this, client);
                client.ExecuteXkdc(true);
            }

            [TestCase, Description("A banned machine requests a ticket for an old title version.")]
            public void TitleUpdate ()
            {
                //create the machine
                AuthContext.ClientTypes clientType = AuthContext.ClientTypes.Xenon;
                uint hrInTable = 0x80000007;
                uint hrExpected = 0x80000007;
                KdcClient client=KdcClient.CreateForClientType(clientType);

                client.ExecuteXmacs(true);
                Global.RO.Debug("Created machine: 0x{0:X}", client.XmacsOutput.MachineId);

                //ban it
                MachineEditor mach=MachineEditor.FromId(client.XmacsOutput.MachineId);
                mach.BanMachine((int)hrInTable, System.DateTime.UtcNow-new System.TimeSpan(0, 0, 10, 0), System.DateTime.MaxValue);

                //now hit xkdc, it should fail with our hr ban error
                client.XkdcThrowOnOverallHRFailure=false;
                SetSRVersion(this, client);
                client.ExecuteXkdc(true);

                ValueCheck.Test("Xkdc Overall HR", hrExpected, client.XkdcOutput.Hr);

                if (GetSRVersion(this)>=6 && hrExpected!=0) //also verify the ban expiration date when service address failed is available
                {
                    ValueCheck.Test("Machine Ban Expiration Date", System.DateTime.MaxValue, client.XkdcOutput.GetConvertedConsoleBanExpireTime(), new System.TimeSpan(1, 0, 0, 1));
                    for (int u=0; u<4; ++u)
                    {
                        ValueCheck.Test("User Ban Expire FileTime", 0, client.XkdcOutput.UserBanExpireTime[u]);
                    }
                }

                //go back through xmacs-askdc-xkdc again to make sure machine account reset doesn't affect anything
                client.ClearXkdc();
                client.ExecuteXmacs(true);
                client.XkdcThrowOnOverallHRFailure=false;
                SetSRVersion(this, client);
                client.XkdcRequest.Input.TitleID = 0x3EEF0801;
                client.XkdcRequest.Input.TitleVersion = 1;
                client.XkdcRequest.Input.TitleRegion = 1;
                client.ExecuteXkdc(true);

                ValueCheck.Test("Xkdc Overall HR", hrExpected, client.XkdcOutput.Hr);
            }

            [TestCase, Description("A banned machine needs a flash update.")]
            public void FlashUpdate ()
            {
                //create the machine
                AuthContext.ClientTypes clientType = AuthContext.ClientTypes.Xenon;
                uint hrInTable = 0x80000007;
                uint hrExpected = 0x80000007;
                KdcClient client = KdcClient.CreateForClientType(clientType);

                client.ExecuteXmacs(true);
                Global.RO.Debug("Created machine: 0x{0:X}", client.XmacsOutput.MachineId);

                //ban it
                MachineEditor mach = MachineEditor.FromId(client.XmacsOutput.MachineId);
                mach.BanMachine((int)hrInTable, System.DateTime.UtcNow - new System.TimeSpan(0, 0, 10, 0), System.DateTime.MaxValue);

                //now hit xkdc, it should fail with our hr ban error
                client.XkdcThrowOnOverallHRFailure = false;
                SetSRVersion(this, client);
                client.ExecuteXkdc(true);

                ValueCheck.Test("Xkdc Overall HR", hrExpected, client.XkdcOutput.Hr);

                if (GetSRVersion(this) >= 6 && hrExpected != 0) //also verify the ban expiration date when service address failed is available
                {
                    ValueCheck.Test("Machine Ban Expiration Date", System.DateTime.MaxValue, client.XkdcOutput.GetConvertedConsoleBanExpireTime(), new System.TimeSpan(1, 0, 0, 1));
                    for (int u = 0; u < 4; ++u)
                    {
                        ValueCheck.Test("User Ban Expire FileTime", 0, client.XkdcOutput.UserBanExpireTime[u]);
                    }
                }

                //go back through xmacs-askdc-xkdc again to make sure machine account reset doesn't affect anything
                client.ClearXkdc();
                client.ExecuteXmacs(true);
                client.XkdcThrowOnOverallHRFailure = false;
                SetSRVersion(this, client);
                client.XkdcRequest.Input.FlashVersion = 22;
                client.ExecuteXkdc(true);

                ValueCheck.Test("Xkdc Overall HR", hrExpected, client.XkdcOutput.Hr);
            }

            [TestCase, Description("A banned machine has requests a title update ticket.")]
            public void TitleUpdateRequestOnlyAutoupdate ()
            {
                //create the machine
                AuthContext.ClientTypes clientType = AuthContext.ClientTypes.Xenon;
                uint hrInTable = 0x80000007;
                uint hrExpected = 0x80000007;
                KdcClient client = KdcClient.CreateForClientType(clientType);

                client.ExecuteXmacs(true);
                Global.RO.Debug("Created machine: 0x{0:X}", client.XmacsOutput.MachineId);

                //ban it
                MachineEditor mach = MachineEditor.FromId(client.XmacsOutput.MachineId);
                mach.BanMachine((int)hrInTable, System.DateTime.UtcNow - new System.TimeSpan(0, 0, 10, 0), System.DateTime.MaxValue);

                //now hit xkdc, it should fail with our hr ban error
                client.XkdcThrowOnOverallHRFailure = false;
                SetSRVersion(this, client);
                client.ExecuteXkdc(true);

                ValueCheck.Test("Xkdc Overall HR", hrExpected, client.XkdcOutput.Hr);

                if (GetSRVersion(this) >= 6 && hrExpected != 0) //also verify the ban expiration date when service address failed is available
                {
                    ValueCheck.Test("Machine Ban Expiration Date", System.DateTime.MaxValue, client.XkdcOutput.GetConvertedConsoleBanExpireTime(), new System.TimeSpan(1, 0, 0, 1));
                    for (int u = 0; u < 4; ++u)
                    {
                        ValueCheck.Test("User Ban Expire FileTime", 0, client.XkdcOutput.UserBanExpireTime[u]);
                    }
                }

                //go back through xmacs-askdc-xkdc again to make sure machine account reset doesn't affect anything
                client.ClearXkdc();
                client.ExecuteXmacs(true);
                client.XkdcThrowOnOverallHRFailure = false;
                SetSRVersion(this, client);
                client.XkdcRequest.Input.TitleID = 0x3EEF0801;
                client.XkdcRequest.Input.TitleVersion = 1;
                client.XkdcRequest.Input.TitleRegion = 1;
                client.XkdcRequest.Input.AutoDiscoverServices = 0;
                client.XkdcRequest.Input.Services = new uint[] { (uint)xonline.common.service.XOService.Auto_Update };
                client.ExecuteXkdc(true);

                ValueCheck.Test("Xkdc Overall HR", hrExpected, client.XkdcOutput.Hr);
            }

            [TestCase, Description("A banned machine that also has a banned user.")]
            public void MachineAndUserBanned (TestNode node)
            {
                //create the machine
                AuthContext.ClientTypes clientType = AuthContext.ClientTypes.Xenon;
                uint hrInTable = 0x80000007;
                uint hrExpected = 0x80000007;
                KdcClient client = KdcClient.CreateForClientType(clientType);

                client.ExecuteXmacs(true);
                Global.RO.Debug("Created machine: 0x{0:X}", client.XmacsOutput.MachineId);

                //ban it
                MachineEditor mach = MachineEditor.FromId(client.XmacsOutput.MachineId);
                mach.BanMachine((int)hrInTable, System.DateTime.UtcNow - new System.TimeSpan(0, 0, 10, 0), System.DateTime.MaxValue);

                // add a user
                System.DateTime userBanTime = System.DateTime.MaxValue;

                KdcUser user = new KdcUser();
                user.CreateUser(false);

                UserEditor userEdit = UserEditor.FromPuid(user.UserID);
                userEdit.BannedUntilDate = userBanTime;
                client.CreateAskdcUserRequest(user);
                client.ExecuteAskdc(true);
                client.CreateAskdcMachineRequest();
                client.ExecuteAskdc(true);

                //now hit xkdc, it should fail with our hr ban error
                client.XkdcThrowOnOverallHRFailure = false;
                SetSRVersion(this, client);
                client.ExecuteXkdc(true);

                ValueCheck.Test("Xkdc Overall HR", hrExpected, client.XkdcOutput.Hr);
                ValueCheck.Test("Xkdc User0 HR", 0, client.XkdcOutput.HrUser[0]);
                ValueCheck.Test("Xkdc User1 HR", 0, client.XkdcOutput.HrUser[1]);
                ValueCheck.Test("Xkdc User2 HR", 0, client.XkdcOutput.HrUser[2]);
                ValueCheck.Test("Xkdc User3 HR", 0, client.XkdcOutput.HrUser[3]);

                if (GetSRVersion(this) >= 6 && hrExpected != 0) //also verify the ban expiration date when service address failed is available
                {
                    ValueCheck.Test("Machine Ban Expiration Date", System.DateTime.MaxValue, client.XkdcOutput.GetConvertedConsoleBanExpireTime(), new System.TimeSpan(1, 0, 0, 1));
                    for (int u = 0; u < 4; ++u)
                    {
                        ValueCheck.Test("User Ban Expire FileTime", 0, client.XkdcOutput.UserBanExpireTime[u]);
                    }
                }

                //go back through xmacs-askdc-xkdc again to make sure machine account reset doesn't affect anything
                client.ClearXkdc();
                client.ExecuteXmacs(true);
                client.XkdcThrowOnOverallHRFailure = false;
                SetSRVersion(this, client);
                client.ExecuteXkdc(true);

                ValueCheck.Test("Xkdc Overall HR", hrExpected, client.XkdcOutput.Hr);
            }
        }; //class Machine

        [TestGroup, Description("Only xbox1 and xbox360 make sense to be banned by ConsoleID.")]
        public class Console: TestNode
        {
            [TestCase, Description("Simple test of banning a machine.")]
            //                                table             expect
            [CompoundCase("Xbox360 7",        (uint)7,          (uint)0)] //NOTE: Xkdc will treat it as 0 if the high bit is not set
            [CompoundCase("Xbox360 80000007", (uint)0x80000007, (uint)0x80000007)]
            public void Simple(TestNode node)
            {
                //create the machine
                uint hrInTable=(uint)node.MyValues[0];
                uint hrExpected=(uint)node.MyValues[1];
                KdcClientXbox360 client=new KdcClientXbox360();

                client.ExecuteXmacs(true);
                Global.RO.Debug("Created machine: 0x{0:X}", client.XmacsOutput.MachineId);

                //ban it
                System.DateTime banDate=System.DateTime.UtcNow-new System.TimeSpan(1, 0, 0); //banned 1 hour ago
                ConsoleBanEditor cbe=ConsoleBanEditor.FromConsoleId(client.XmacsRequest.Input.ConsoleId);
                cbe.BanConsole((int)hrInTable, banDate);

                //xmacs is what does the actual migrate frome console ban to machine ban (normally when we add these rows we'll revoke the tgt and reset their key to force them to come back).
                client.ExecuteXmacs(true);

                //now hit xkdc, it should fail with our hr ban error
                client.XkdcThrowOnOverallHRFailure=false;
                SetSRVersion(this, client);
                client.ExecuteXkdc(true);

                ValueCheck.Test("Xkdc Overall HR", hrExpected, client.XkdcOutput.Hr);

                if (GetSRVersion(this)>=6 && hrExpected!=0) //also verify the ban expiration date when service address failed is available
                {
                    ValueCheck.Test("Machine Ban Expiration Date", System.DateTime.MaxValue, client.XkdcOutput.GetConvertedConsoleBanExpireTime(), new System.TimeSpan(1, 0, 0, 1));
                    for (int u=0; u<4; ++u)
                    {
                        ValueCheck.Test("User Ban Expire FileTime", 0, client.XkdcOutput.UserBanExpireTime[u]);
                    }
                }

                //verify that the console ban rows were propegated to the machine ban rows by xmacs
                MachineEditor mach=MachineEditor.FromId(client.XmacsOutput.MachineId);
                MachineEditor.MachineBanStatus []banStatus=mach.GetAllMachineBans();
                ValueCheck.Test("Number of machine ban rows", 1, banStatus.Length);
                ValueCheck.Test("Ban Reason Code", (int)hrInTable, banStatus[0].ReasonCode);
                ValueCheck.Test("Ban Start", banDate, banStatus[0].StartDate, new System.TimeSpan(0, 0, 1)); //1 second variance allowed, this is migrated by xmacs
                ValueCheck.Test("Ban End", System.DateTime.MaxValue, banStatus[0].EndDate, new System.TimeSpan(1, 0, 0, 0)); //1 day variance allowed since this is created by xmacs, not migrated
            }

            [TestCase, Description("Multiple machines with the same console ID are all banned.")]
            public void SharedConsoleID()
            {
                //create two machines with the same console ID
                KdcClientXbox360 clientA=XenonTwinSeparation.GenerateRandomXmacsRequest();
                clientA.ExecuteXmacs(true);
                KdcClientXbox360 clientB=XenonTwinSeparation.GenerateRandomXmacsRequest(clientA.XmacsRequest.Input.ConsoleId);
                clientB.ExecuteXmacs(true);

                Global.RO.Debug("Created machineA: 0x{0:X}", clientA.XmacsOutput.MachineId);
                Global.RO.Debug("Created machineB: 0x{0:X}", clientB.XmacsOutput.MachineId);

                //ban it
                System.DateTime banDate=System.DateTime.UtcNow-new System.TimeSpan(1, 0, 0); //banned 1 hour ago
                ConsoleBanEditor cbe=ConsoleBanEditor.FromConsoleId(clientA.XmacsRequest.Input.ConsoleId);
                cbe.BanConsole(unchecked((int)0x80000888), banDate);

                //hit xmacs to migrate the ban.  in fact do it twice to make sure we aren't double-adding rows somehow.
                clientA.ExecuteXmacs(true);
                clientA.ExecuteXmacs(true);
                clientB.ExecuteXmacs(true);
                clientB.ExecuteXmacs(true);

                //now hit xkdc, it should fail with our hr ban error
                clientA.XkdcThrowOnOverallHRFailure=false;
                SetSRVersion(this, clientA);
                clientA.ExecuteXkdc(true);
                ValueCheck.Test("A Xkdc Overall HR", 0x80000888, clientA.XkdcOutput.Hr);

                if (GetSRVersion(this)>=6) //also verify the ban expiration date when service address failed is available
                {
                    ValueCheck.Test("Machine Ban Expiration Date", System.DateTime.MaxValue, clientA.XkdcOutput.GetConvertedConsoleBanExpireTime(), new System.TimeSpan(1, 0, 0, 1));
                    for (int u=0; u<4; ++u)
                    {
                        ValueCheck.Test("User Ban Expire FileTime", 0, clientA.XkdcOutput.UserBanExpireTime[u]);
                    }
                }

                clientB.XkdcThrowOnOverallHRFailure=false;
                SetSRVersion(this, clientB);
                clientB.ExecuteXkdc(true);
                ValueCheck.Test("B Xkdc Overall HR", 0x80000888, clientB.XkdcOutput.Hr);

                if (GetSRVersion(this)>=6) //also verify the ban expiration date when service address failed is available
                {
                    ValueCheck.Test("Machine Ban Expiration Date", System.DateTime.MaxValue, clientB.XkdcOutput.GetConvertedConsoleBanExpireTime(), new System.TimeSpan(1, 0, 0, 1));
                    for (int u=0; u<4; ++u)
                    {
                        ValueCheck.Test("User Ban Expire FileTime", 0, clientB.XkdcOutput.UserBanExpireTime[u]);
                    }
                }

                //verify the number of machine puid ban rows for each machine
                MachineEditor machA=MachineEditor.FromId(clientA.XmacsOutput.MachineId);
                MachineEditor.MachineBanStatus []banStatusA=machA.GetAllMachineBans();
                ValueCheck.Test("Number of machineA ban rows", 1, banStatusA.Length);
                ValueCheck.Test("A Ban Reason Code", unchecked((int)0x80000888), banStatusA[0].ReasonCode);

                MachineEditor machB=MachineEditor.FromId(clientB.XmacsOutput.MachineId);
                MachineEditor.MachineBanStatus []banStatusB=machB.GetAllMachineBans();
                ValueCheck.Test("Number of machineB ban rows", 1, banStatusB.Length);
                ValueCheck.Test("B Ban Reason Code", unchecked((int)0x80000888), banStatusB[0].ReasonCode);
            }

            [TestCase, Description("A console is banned for multiple reasons.")]
            public void MultipleReasons()
            {
                //create the machine
                KdcClientXbox360 client=new KdcClientXbox360();
                client.ExecuteXmacs(true);
                Global.RO.Debug("Created machine: 0x{0:X}", client.XmacsOutput.MachineId);

                //ban it for several reasons
                ConsoleBanEditor cbe=ConsoleBanEditor.FromConsoleId(client.XmacsRequest.Input.ConsoleId);
                cbe.BanConsole(unchecked((int)0x80000001), System.DateTime.UtcNow-new System.TimeSpan(1, 0, 0));
                cbe.BanConsole(unchecked((int)0x80000002), System.DateTime.UtcNow-new System.TimeSpan(5, 0, 0));
                cbe.BanConsole(unchecked((int)0x80000003), System.DateTime.UtcNow-new System.TimeSpan(3, 0, 0));

                //now hit xkdc, it should fail with the hr that has the earliest start time
                client.ExecuteXmacs(true); //hit xmacs to migrate the console bans to machine bans
                client.XkdcThrowOnOverallHRFailure=false;
                SetSRVersion(this, client);
                client.ExecuteXkdc(true);

                ValueCheck.Test("Xkdc Overall HR", 0x80000002, client.XkdcOutput.Hr);

                if (GetSRVersion(this)>=6) //also verify the ban expiration date when service address failed is available
                {
                    ValueCheck.Test("Machine Ban Expiration Date", System.DateTime.MaxValue, client.XkdcOutput.GetConvertedConsoleBanExpireTime(), new System.TimeSpan(1, 0, 0, 1));
                    for (int u=0; u<4; ++u)
                    {
                        ValueCheck.Test("User Ban Expire FileTime", 0, client.XkdcOutput.UserBanExpireTime[u]);
                    }
                }

                //verify all the ban rows were migrated
                //Note that due to some managed code interop complexity, we only ever copy 1 row (the earliest start date) from console bans to machine bans.
                //The xmachine API to unban a machine will revoke the tgt and reset the machine key (forcing it back to xmacs to potentially migrate another row), so there is never a case where a console ban will not be enforced.
                MachineEditor mach=MachineEditor.FromId(client.XmacsOutput.MachineId);
                MachineEditor.MachineBanStatus []banStatus=mach.GetAllMachineBans();
                ValueCheck.Test("Number of machine ban rows", 1, banStatus.Length);
                ValueCheck.Test("Ban Reason Code", unchecked((int)0x80000002), banStatus[0].ReasonCode);
                ValueCheck.Test("Ban Start", System.DateTime.UtcNow-new System.TimeSpan(5, 0, 0), banStatus[0].StartDate, new System.TimeSpan(0, 0, 1));
                ValueCheck.Test("Ban End", System.DateTime.MaxValue, banStatus[0].EndDate, new System.TimeSpan(1, 0, 0, 0));
            }

            [TestCase, Description("Add a row for a ConsoleID that has never connected before, and verify that it gets banned correctly.")]
            public void BanBeforeMachineExists()
            {
                //ban a console that doesn't yet exist in the system
                string cid=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);
                Global.RO.Debug("Banning non-existant console ID: "+cid);
                ConsoleBanEditor cbe=ConsoleBanEditor.FromConsoleId(cid);
                cbe.BanConsole(unchecked((int)0x80000000), System.DateTime.UtcNow-new System.TimeSpan(0, 5, 0));

                //now try and use that console
                KdcClientXbox360 client=XenonTwinSeparation.GenerateRandomXmacsRequest(cid);
                client.ExecuteXmacs(true);
                Global.RO.Debug("Created machine: 0x{0:X}", client.XmacsOutput.MachineId);

                client.XkdcThrowOnOverallHRFailure=false;
                SetSRVersion(this, client);
                client.ExecuteXkdc(true);
                ValueCheck.Test("Xkdc Overall HR", 0x80000000, client.XkdcOutput.Hr);

                if (GetSRVersion(this)>=6) //also verify the ban expiration date when service address failed is available
                {
                    ValueCheck.Test("Machine Ban Expiration Date", System.DateTime.MaxValue, client.XkdcOutput.GetConvertedConsoleBanExpireTime(), new System.TimeSpan(1, 0, 0, 1));
                    for (int u=0; u<4; ++u)
                    {
                        ValueCheck.Test("User Ban Expire FileTime", 0, client.XkdcOutput.UserBanExpireTime[u]);
                    }
                }
            }

            [TestCase, Description("A console has a console ban for one reason and a machine ban for the same reason.")]
            public void MachineBannedForSameReason()
            {
                //create the machine
                KdcClientXbox360 client=new KdcClientXbox360();
                client.ExecuteXmacs(true);
                Global.RO.Debug("Created machine: 0x{0:X}", client.XmacsOutput.MachineId);

                //ban it both ways
                ConsoleBanEditor cbe=ConsoleBanEditor.FromConsoleId(client.XmacsRequest.Input.ConsoleId);
                cbe.BanConsole(unchecked((int)0x80000001), System.DateTime.UtcNow-new System.TimeSpan(1, 0, 0));

                MachineEditor mach=MachineEditor.FromId(client.XmacsOutput.MachineId);
                mach.BanMachine(unchecked((int)0x80000001), System.DateTime.UtcNow-new System.TimeSpan(1, 0, 0, 0), System.DateTime.MaxValue);

                //verify xmacs and xkdc still handle it right
                client.ExecuteXmacs(true); //hit xmacs to migrate the console bans to machine bans
                client.XkdcThrowOnOverallHRFailure=false;
                SetSRVersion(this, client);
                client.ExecuteXkdc(true);

                ValueCheck.Test("Xkdc Overall HR", 0x80000001, client.XkdcOutput.Hr);

                if (GetSRVersion(this)>=6) //also verify the ban expiration date when service address failed is available
                {
                    ValueCheck.Test("Machine Ban Expiration Date", System.DateTime.MaxValue, client.XkdcOutput.GetConvertedConsoleBanExpireTime(), new System.TimeSpan(1, 0, 0, 1));
                    for (int u=0; u<4; ++u)
                    {
                        ValueCheck.Test("User Ban Expire FileTime", 0, client.XkdcOutput.UserBanExpireTime[u]);
                    }
                }
            }

            [TestCase, Description("A console has a console ban for one reason and an expired machine ban for the same reason.")]
            public void ExpiredMachineBanForSameReason()
            {
                //create the machine
                KdcClientXbox360 client=new KdcClientXbox360();
                client.ExecuteXmacs(true);
                Global.RO.Debug("Created machine: 0x{0:X}", client.XmacsOutput.MachineId);

                //ban it both ways
                ConsoleBanEditor cbe=ConsoleBanEditor.FromConsoleId(client.XmacsRequest.Input.ConsoleId);
                cbe.BanConsole(unchecked((int)0x80000001), System.DateTime.UtcNow-new System.TimeSpan(1, 0, 0));

                MachineEditor mach=MachineEditor.FromId(client.XmacsOutput.MachineId);
                mach.BanMachine(unchecked((int)0x80000001), System.DateTime.UtcNow-new System.TimeSpan(2, 0, 0, 0), System.DateTime.UtcNow-new System.TimeSpan(1, 0, 0, 0)); //expired

                //verify xmacs and xkdc still handle it right
                client.ExecuteXmacs(true); //hit xmacs to migrate the STILL IN EFFECT console ban to machine ban.  it should replace the machine ban in this case.
                client.XkdcThrowOnOverallHRFailure=false;
                SetSRVersion(this, client);
                client.ExecuteXkdc(true);

                ValueCheck.Test("Xkdc Overall HR", 0x80000001, client.XkdcOutput.Hr);

                if (GetSRVersion(this)>=6) //also verify the ban expiration date when service address failed is available
                {
                    ValueCheck.Test("Machine Ban Expiration Date", System.DateTime.MaxValue, client.XkdcOutput.GetConvertedConsoleBanExpireTime(), new System.TimeSpan(1, 0, 0, 1));
                    for (int u=0; u<4; ++u)
                    {
                        ValueCheck.Test("User Ban Expire FileTime", 0, client.XkdcOutput.UserBanExpireTime[u]);
                    }
                }
            }

            [TestCase, Description("A console has a console ban for one reason and a machine ban for a different reason.  The console ban is more recent.")]
            public void MachineBannedForDifferentReason_ConsoleBanNewer()
            {
                //create the machine
                KdcClientXbox360 client=new KdcClientXbox360();
                client.ExecuteXmacs(true);
                Global.RO.Debug("Created machine: 0x{0:X}", client.XmacsOutput.MachineId);

                //ban it both ways
                ConsoleBanEditor cbe=ConsoleBanEditor.FromConsoleId(client.XmacsRequest.Input.ConsoleId);
                cbe.BanConsole(unchecked((int)0x80000001), System.DateTime.UtcNow-new System.TimeSpan(1, 0, 0, 0));

                MachineEditor mach=MachineEditor.FromId(client.XmacsOutput.MachineId);
                mach.BanMachine(unchecked((int)0x80000002), System.DateTime.UtcNow-new System.TimeSpan(3, 0, 0, 0), System.DateTime.MaxValue-new System.TimeSpan(3, 0, 0, 0));

                //verify xmacs and xkdc still handle it right
                //the oldest console ban will always be copied over
                client.ExecuteXmacs(true); //hit xmacs to migrate the console bans to machine bans
                client.XkdcThrowOnOverallHRFailure=false;
                SetSRVersion(this, client);
                client.ExecuteXkdc(true);

                ValueCheck.Test("Xkdc Overall HR", 0x80000001, client.XkdcOutput.Hr);

                if (GetSRVersion(this)>=6) //also verify the ban expiration date when service address failed is available
                {
                    ValueCheck.Test("Machine Ban Expiration Date", System.DateTime.MaxValue, client.XkdcOutput.GetConvertedConsoleBanExpireTime(), new System.TimeSpan(1, 0, 0, 1));
                    for (int u=0; u<4; ++u)
                    {
                        ValueCheck.Test("User Ban Expire FileTime", 0, client.XkdcOutput.UserBanExpireTime[u]);
                    }
                }

                //verify both rows in the machine ban table
                MachineEditor.MachineBanStatus []banStatus=mach.GetAllMachineBans();
                ValueCheck.Test("Number of machine ban rows", 2, banStatus.Length);
                ValueCheck.Test("0 Ban Reason Code", unchecked((int)0x80000001), banStatus[0].ReasonCode);
                ValueCheck.Test("0 Ban Start", System.DateTime.UtcNow-new System.TimeSpan(1, 0, 0, 0), banStatus[0].StartDate, new System.TimeSpan(0, 0, 1));
                ValueCheck.Test("0 Ban End", System.DateTime.MaxValue, banStatus[0].EndDate, new System.TimeSpan(1, 0, 0, 0));
                ValueCheck.Test("1 Ban Reason Code", unchecked((int)0x80000002), banStatus[1].ReasonCode);
                ValueCheck.Test("1 Ban Start", System.DateTime.UtcNow-new System.TimeSpan(3, 0, 0, 0), banStatus[1].StartDate, new System.TimeSpan(0, 0, 1));
                ValueCheck.Test("1 Ban End", System.DateTime.MaxValue-new System.TimeSpan(3, 0, 0, 0), banStatus[1].EndDate, new System.TimeSpan(1, 0, 0, 0));
            }

            [TestCase, Description("A console has a console ban for one reason and a machine ban for a different reason.  The machine ban is more recent.")]
            public void MachineBannedForDifferentReason_MachineBanNewer()
            {
                //create the machine
                KdcClientXbox360 client=new KdcClientXbox360();
                client.ExecuteXmacs(true);
                Global.RO.Debug("Created machine: 0x{0:X}", client.XmacsOutput.MachineId);

                //ban it both ways
                ConsoleBanEditor cbe=ConsoleBanEditor.FromConsoleId(client.XmacsRequest.Input.ConsoleId);
                cbe.BanConsole(unchecked((int)0x80000001), System.DateTime.UtcNow-new System.TimeSpan(3, 0, 0, 0));

                MachineEditor mach=MachineEditor.FromId(client.XmacsOutput.MachineId);
                mach.BanMachine(unchecked((int)0x80000002), System.DateTime.UtcNow-new System.TimeSpan(1, 0, 0, 0), System.DateTime.MaxValue-new System.TimeSpan(3, 0, 0, 0));

                //verify xmacs and xkdc still handle it right
                //note that since there is already a non-expired machine ban, the console ban won't be copied over
                client.ExecuteXmacs(true); //hit xmacs to migrate the console bans to machine bans
                client.XkdcThrowOnOverallHRFailure=false;
                SetSRVersion(this, client);
                client.ExecuteXkdc(true);

                ValueCheck.Test("Xkdc Overall HR", 0x80000001, client.XkdcOutput.Hr);

                if (GetSRVersion(this)>=6) //also verify the ban expiration date when service address failed is available
                {
                    ValueCheck.Test("Machine Ban Expiration Date", System.DateTime.MaxValue, client.XkdcOutput.GetConvertedConsoleBanExpireTime(), new System.TimeSpan(1, 0, 0, 1));
                    for (int u=0; u<4; ++u)
                    {
                        ValueCheck.Test("User Ban Expire FileTime", 0, client.XkdcOutput.UserBanExpireTime[u]);
                    }
                }

                //verify both rows in the machine ban table
                MachineEditor.MachineBanStatus []banStatus=mach.GetAllMachineBans();
                ValueCheck.Test("Number of machine ban rows", 2, banStatus.Length);
                ValueCheck.Test("0 Ban Reason Code", unchecked((int)0x80000001), banStatus[0].ReasonCode);
                ValueCheck.Test("0 Ban Start", System.DateTime.UtcNow-new System.TimeSpan(3, 0, 0, 0), banStatus[0].StartDate, new System.TimeSpan(0, 0, 1));
                ValueCheck.Test("0 Ban End", System.DateTime.MaxValue, banStatus[0].EndDate, new System.TimeSpan(1, 0, 0, 0));
                ValueCheck.Test("1 Ban Reason Code", unchecked((int)0x80000002), banStatus[1].ReasonCode);
                ValueCheck.Test("1 Ban Start", System.DateTime.UtcNow-new System.TimeSpan(1, 0, 0, 0), banStatus[1].StartDate, new System.TimeSpan(0, 0, 1));
                ValueCheck.Test("1 Ban End", System.DateTime.MaxValue-new System.TimeSpan(3, 0, 0, 0), banStatus[1].EndDate, new System.TimeSpan(1, 0, 0, 0));
            }

            [TestCase, Description("A console ban with a start date in the future.")]
            public void FutureBan()
            {
                //create the machine
                KdcClient client=KdcClient.CreateForClientType(AuthContext.ClientTypes.Xenon);

                client.ExecuteXmacs(true);
                Global.RO.Debug("Created machine: 0x{0:X}", client.XmacsOutput.MachineId);

                //ban it
                System.DateTime now=System.DateTime.UtcNow;
                ConsoleBanEditor cbe=ConsoleBanEditor.FromConsoleId(client.XmacsRequest.Input.ConsoleId);
                cbe.BanConsole(unchecked((int)0x80000001), now+new System.TimeSpan(3, 0, 0, 0));

                //verify ban
                client.ExecuteXmacs(true); //hit xmacs reset too just to check that it doesn't block us
                SetSRVersion(this, client);
                client.ExecuteXkdc(true); //request should succeeded since the ban hasn't started yet

                //verify that the row was migrated to the machine ban
                MachineEditor mach=MachineEditor.FromId(client.XmacsOutput.MachineId);
                MachineEditor.MachineBanStatus []banStatus=mach.GetAllMachineBans();
                ValueCheck.Test("Number of machine ban rows", 1, banStatus.Length);
                ValueCheck.Test("Ban Reason Code", unchecked((int)0x80000001), banStatus[0].ReasonCode);
                ValueCheck.Test("Ban Start", now+new System.TimeSpan(3, 0, 0, 0), banStatus[0].StartDate, new System.TimeSpan(0, 0, 1)); //1 second variance allowed, this is migrated by xmacs
                ValueCheck.Test("Ban End", System.DateTime.MaxValue, banStatus[0].EndDate, new System.TimeSpan(1, 0, 0, 0)); //1 day variance allowed since this is created by xmacs, not migrated
            }

            [TestCase, Description("A machine whose name lookup still only exists in the legacy table.")]
            public void LegacyNameTable()
            {
                //create the machine
                MachineEditor mach=MachineEditor.CreateLegacyXbox360();
                Global.RO.Debug("Created machine: 0x{0:X}", mach.Id);

                uint hrToUse=0x88888888;
                KdcClientXbox360 client=new KdcClientXbox360();
                client.CreateXmacsRequest();
                client.XmacsRequest.Input.ConsoleId=mach.ConsoleId;

                //ban it
                System.DateTime banDate=System.DateTime.UtcNow-new System.TimeSpan(1, 0, 0); //banned 1 hour ago
                ConsoleBanEditor cbe=ConsoleBanEditor.FromConsoleId(client.XmacsRequest.Input.ConsoleId);
                cbe.BanConsole((int)hrToUse, banDate);

                //xmacs is what does the actual migrate frome console ban to machine ban (normally when we add these rows we'll revoke the tgt and reset their key to force them to come back).
                client.ExecuteXmacs(true);

                //now hit xkdc, it should fail with our hr ban error
                client.XkdcThrowOnOverallHRFailure=false;
                SetSRVersion(this, client);
                client.ExecuteXkdc(true);

                ValueCheck.Test("Xkdc Overall HR", hrToUse, client.XkdcOutput.Hr);

                if (GetSRVersion(this)>=6) //also verify the ban expiration date when service address failed is available
                {
                    ValueCheck.Test("Machine Ban Expiration Date", System.DateTime.MaxValue, client.XkdcOutput.GetConvertedConsoleBanExpireTime(), new System.TimeSpan(1, 0, 0, 1));
                    for (int u=0; u<4; ++u)
                    {
                        ValueCheck.Test("User Ban Expire FileTime", 0, client.XkdcOutput.UserBanExpireTime[u]);
                    }
                }

                //verify that the console ban rows were propegated to the machine ban rows by xmacs
                MachineEditor.MachineBanStatus []banStatus=mach.GetAllMachineBans();
                ValueCheck.Test("Number of machine ban rows", 1, banStatus.Length);
                ValueCheck.Test("Ban Reason Code", (int)hrToUse, banStatus[0].ReasonCode);
                ValueCheck.Test("Ban Start", banDate, banStatus[0].StartDate, new System.TimeSpan(0, 0, 1)); //1 second variance allowed, this is migrated by xmacs
                ValueCheck.Test("Ban End", System.DateTime.MaxValue, banStatus[0].EndDate, new System.TimeSpan(1, 0, 0, 0)); //1 day variance allowed since this is created by xmacs, not migrated
            }
        }; //class Console

        [TestGroup]
        public class User: TestNode
        {

            #region Group Help

            public class UserTestBase : TestNode
            {
                public static readonly System.TimeSpan BanTolerance = new System.TimeSpan(0, 0, 1);
                public static readonly System.DateTime SqlMinTime = System.Data.SqlTypes.SqlDateTime.MinValue.Value;

                public AuthContext.ClientTypes ClientType
                {
                    get
                    {
                        if (MyValues != null && MyValues.Length > 0)
                        {
                            return (AuthContext.ClientTypes)MyValues[0];
                        }
                        else
                        {
                            return AuthContext.ClientTypes.Xenon;
                        }
                    }
                }

                public KdcClient Client
                {
                    get;
                    set;
                }

                public int SRVersion
                {
                    get { return GetSRVersion(this); }
                }

                public uint ExpectedBanCode
                {
                    get
                    {
                        if (SRVersion >= 6)
                        {
                            return 0x80154005; //XONLINE_E_ACCOUNTS_ACCOUNT_BANNED
                        }
                        else
                        {
                            return 0x80151200; //XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT
                        }
                    }
                }

                public override void PreRun ()
                {
                    Client = new KdcClient(ClientType);
                    Client.XkdcThrowOnOverallHRFailure = false;
                }

                public UserEditor CreateAndAddUser ()
                {
                    return CreateAndAddUser(System.DateTime.MinValue);
                }

                public UserEditor CreateAndAddUser (System.DateTime banTime)
                {
                    KdcUser user = new KdcUser();
                    user.CreateUser(false);

                    UserEditor userEdit = UserEditor.FromPuid(user.UserID);
                    if (banTime > System.DateTime.MinValue)
                    {
                        userEdit.BannedUntilDate = banTime;
                    }

                    AddAskdcUser(user);

                    return userEdit;
                }

                public void AddAskdcUser (KdcUser user)
                {
                    Client.CreateAskdcUserRequest(user);
                    Client.ExecuteAskdc(true);
                }

                public void FinishXkdcRequest ()
                {
                    Client.CreateAskdcMachineRequest();
                    Client.ExecuteAskdc(true);

                    SetSRVersion(this, Client);
                    Client.ExecuteXkdc(true);
                }

                public void VerifyPrivileges()
                {
                    //if a v5 client (which gets a regular service address instead of service address failed) has a non-zero user HR, the users should get no priviliges
                    if (Client.XkdcRequest.Input.ServiceRequestVersion<=5)
                    {
                        for (int u=0; u<4; ++u)
                        {
                            if (u<Client.XkdcRequest.Input.UserIDs.Length && Client.XkdcRequest.Input.UserIDs[u]!=0)
                            {
                                bool anyUserPrivilegeSet=false;
                                for (int p=160; p<255; ++p)
                                {
                                    anyUserPrivilegeSet=anyUserPrivilegeSet || Client.XkdcOutput.GetUserPrivilegeBit(u, p);
                                }

                                bool userIsBad=false;

                                UserEditor user=UserEditor.FromPuid(Client.XkdcRequest.Input.UserIDs[u]);
                                if (user.BannedUntilDate>System.DateTime.UtcNow || user.AcceptedTOSDate<new System.DateTime(2000, 1, 1))
                                {
                                    userIsBad=true;
                                }

                                if (userIsBad || Client.XkdcOutput.Hr!=0)
                                {
                                    ValueCheck.Test("User"+u+" got privileges", false, anyUserPrivilegeSet);
                                }
                                else
                                {
                                    ValueCheck.Test("User"+u+" got privileges", true, anyUserPrivilegeSet);
                                }
                            }
                        }

                        //In the future we will deny all users if any user is bad which is the below logic.  For now it's per-use as above.
                        /*bool invalidUsers=false;
                        foreach (uint userHR in Client.XkdcOutput.HrUser)
                        {
                            if (userHR!=0)
                            {
                                invalidUsers=true;
                            }
                        }

                        if (invalidUsers)
                        {
                            bool anyUserPrivileges=false;
                            foreach (uint p in Client.XkdcOutput.UserPrivileges)
                            {
                                if (p!=0)
                                {
                                    anyUserPrivileges=true;
                                }
                            }

                            if (invalidUsers && anyUserPrivileges)
                            {
                                throw new UnexpectedTestResultException("Should NOT have gotten any privileges when a user is invalid.");
                            }
                        }*/
                    }
                }
            }

            #endregion

            [TestCase]
            [CompoundCase("Xbox360", AuthContext.ClientTypes.Xenon)]
            [CompoundCase("PC", AuthContext.ClientTypes.Panorama)]
            public class OneUserPermaBanned : UserTestBase
            {
                public override void Run ()
                {
                    System.DateTime banTime = System.DateTime.MaxValue;

                    CreateAndAddUser(banTime);
                    FinishXkdcRequest();

                    ValueCheck.Test("Xkdc Overall HR", 0, Client.XkdcOutput.Hr);
                    ValueCheck.Test("Xkdc User0 HR", ExpectedBanCode, Client.XkdcOutput.HrUser[0]);
                    ValueCheck.Test("Xkdc User1 HR", 0, Client.XkdcOutput.HrUser[1]);
                    ValueCheck.Test("Xkdc User2 HR", 0, Client.XkdcOutput.HrUser[2]);
                    ValueCheck.Test("Xkdc User3 HR", 0, Client.XkdcOutput.HrUser[3]);

                    if (SRVersion >= 6)
                    {
                        ValueCheck.Test("Machine Ban Expiration FileTime", 0, Client.XkdcOutput.ConsoleBanExpireTime);
                        ValueCheck.Test("User 0 Ban Expire Date", banTime, Client.XkdcOutput.GetConvertedUserBanExpireTime(0), BanTolerance);
                        for (int u = 1; u < 4; ++u)
                        {
                            ValueCheck.Test("User " + u + " Ban Expire FileTime", 0, Client.XkdcOutput.UserBanExpireTime[u]);
                        }
                    }

                    VerifyPrivileges();
                }
            }

            [TestCase]
            public class OneUserSecondSlotPermaBanned : UserTestBase
            {
                public override void Run ()
                {
                    System.DateTime banTime = System.DateTime.MaxValue;

                    CreateAndAddUser(banTime);

                    Client.CreateAskdcMachineRequest();
                    Client.ExecuteAskdc(true);

                    SetSRVersion(this, Client);
                    Client.XkdcRequest.Input.UserIDs[1] = Client.XkdcRequest.Input.UserIDs[0];
                    Client.XkdcRequest.Input.UserIDs[0] = 0;
                    Client.ExecuteXkdc(true);

                    ValueCheck.Test("Xkdc Overall HR", 0, Client.XkdcOutput.Hr);
                    ValueCheck.Test("Xkdc User0 HR", 0, Client.XkdcOutput.HrUser[0]);
                    ValueCheck.Test("Xkdc User1 HR", ExpectedBanCode, Client.XkdcOutput.HrUser[1]);
                    ValueCheck.Test("Xkdc User2 HR", 0, Client.XkdcOutput.HrUser[2]);
                    ValueCheck.Test("Xkdc User3 HR", 0, Client.XkdcOutput.HrUser[3]);

                    if (SRVersion >= 6)
                    {
                        ValueCheck.Test("Machine Ban Expiration FileTime", 0, Client.XkdcOutput.ConsoleBanExpireTime);
                        ValueCheck.Test("User 0 Ban Expire FileTime", 0, Client.XkdcOutput.UserBanExpireTime[0]);
                        ValueCheck.Test("User 1 Ban Expire Date", System.DateTime.MaxValue, Client.XkdcOutput.GetConvertedUserBanExpireTime(1), BanTolerance);
                        for (int u = 2; u < 4; ++u)
                        {
                            ValueCheck.Test("User " + u + " Ban Expire FileTime", 0, Client.XkdcOutput.UserBanExpireTime[u]);
                        }
                    }

                    VerifyPrivileges();
                }
            }

            [TestCase]
            public class OneUserTempBan : UserTestBase
            {
                public override void Run ()
                {
                    System.DateTime banTime = System.DateTime.UtcNow.AddDays(2);

                    CreateAndAddUser(banTime);
                    FinishXkdcRequest();

                    ValueCheck.Test("Xkdc Overall HR", 0, Client.XkdcOutput.Hr);
                    ValueCheck.Test("Xkdc User0 HR", ExpectedBanCode, Client.XkdcOutput.HrUser[0]);
                    ValueCheck.Test("Xkdc User1 HR", 0, Client.XkdcOutput.HrUser[1]);
                    ValueCheck.Test("Xkdc User2 HR", 0, Client.XkdcOutput.HrUser[2]);
                    ValueCheck.Test("Xkdc User3 HR", 0, Client.XkdcOutput.HrUser[3]);

                    if (SRVersion >= 6)
                    {
                        ValueCheck.Test("Machine Ban Expiration FileTime", 0, Client.XkdcOutput.ConsoleBanExpireTime);
                        ValueCheck.Test("User 0 Ban Expire Date", banTime, Client.XkdcOutput.GetConvertedUserBanExpireTime(0), BanTolerance);
                        for (int u = 1; u < 4; ++u)
                        {
                            ValueCheck.Test("User " + u + " Ban Expire FileTime", 0, Client.XkdcOutput.UserBanExpireTime[u]);
                        }
                    }

                    VerifyPrivileges();
                }
            }

            [TestCase]
            public class OneUserWasBanned : UserTestBase
            {
                public override void Run ()
                {
                    System.DateTime banTime = System.DateTime.UtcNow.AddDays(-2);

                    CreateAndAddUser(banTime);
                    FinishXkdcRequest();

                    // if they are no longer banned, we should succeed
                    ValueCheck.Test("Xkdc Overall HR", 0, Client.XkdcOutput.Hr);
                    ValueCheck.Test("Xkdc User0 HR", 0, Client.XkdcOutput.HrUser[0]);
                    ValueCheck.Test("Xkdc User1 HR", 0, Client.XkdcOutput.HrUser[1]);
                    ValueCheck.Test("Xkdc User2 HR", 0, Client.XkdcOutput.HrUser[2]);
                    ValueCheck.Test("Xkdc User3 HR", 0, Client.XkdcOutput.HrUser[3]);

                    if (SRVersion >= 6)
                    {
                        ValueCheck.Test("Machine Ban Expiration FileTime", 0, Client.XkdcOutput.ConsoleBanExpireTime);
                        for (int u = 0; u < 4; ++u)
                        {
                            ValueCheck.Test("User " + u + " Ban Expire FileTime", 0, Client.XkdcOutput.UserBanExpireTime[u]);
                        }
                    }

                    VerifyPrivileges();
                }
            }

            [TestCase]
            public class TwoUsersPermaBanned : UserTestBase
            {
                public override void Run ()
                {
                    System.DateTime banTime = System.DateTime.MaxValue;

                    CreateAndAddUser(banTime);
                    CreateAndAddUser(banTime);
                    FinishXkdcRequest();

                    ValueCheck.Test("Xkdc Overall HR", 0, Client.XkdcOutput.Hr);
                    ValueCheck.Test("Xkdc User0 HR", ExpectedBanCode, Client.XkdcOutput.HrUser[0]);
                    ValueCheck.Test("Xkdc User1 HR", ExpectedBanCode, Client.XkdcOutput.HrUser[1]);
                    ValueCheck.Test("Xkdc User2 HR", 0, Client.XkdcOutput.HrUser[2]);
                    ValueCheck.Test("Xkdc User3 HR", 0, Client.XkdcOutput.HrUser[3]);

                    if (SRVersion >= 6)
                    {
                        ValueCheck.Test("Machine Ban Expiration FileTime", 0, Client.XkdcOutput.ConsoleBanExpireTime);
                        for (int u = 0; u < 2; ++u)
                        {
                            ValueCheck.Test("User " + u + " Ban Expire Date", banTime, Client.XkdcOutput.GetConvertedUserBanExpireTime(u), BanTolerance);
                        }
                        for (int u = 2; u < 4; ++u)
                        {
                            ValueCheck.Test("User " + u + " Ban Expire FileTime", 0, Client.XkdcOutput.UserBanExpireTime[u]);
                        }
                    }

                    VerifyPrivileges();
                }
            }

            [TestCase]
            public class TwoUsersNotInFirstSlotsPermaBanned : UserTestBase
            {
                public override void Run ()
                {
                    System.DateTime banTime = System.DateTime.MaxValue;

                    CreateAndAddUser(banTime);
                    CreateAndAddUser(banTime);

                    Client.CreateAskdcMachineRequest();
                    Client.ExecuteAskdc(true);

                    SetSRVersion(this, Client);
                    Client.XkdcRequest.Input.UserIDs[3] = Client.XkdcRequest.Input.UserIDs[0];
                    Client.XkdcRequest.Input.UserIDs[0] = 0;
                    Client.XkdcRequest.Input.UserIDs[2] = Client.XkdcRequest.Input.UserIDs[1];
                    Client.XkdcRequest.Input.UserIDs[1] = 0;
                    Client.ExecuteXkdc(true);

                    ValueCheck.Test("Xkdc Overall HR", 0, Client.XkdcOutput.Hr);
                    ValueCheck.Test("Xkdc User0 HR", 0, Client.XkdcOutput.HrUser[0]);
                    ValueCheck.Test("Xkdc User1 HR", 0, Client.XkdcOutput.HrUser[1]);
                    ValueCheck.Test("Xkdc User2 HR", ExpectedBanCode, Client.XkdcOutput.HrUser[2]);
                    ValueCheck.Test("Xkdc User3 HR", ExpectedBanCode, Client.XkdcOutput.HrUser[3]);

                    if (SRVersion >= 6)
                    {
                        ValueCheck.Test("Machine Ban Expiration FileTime", 0, Client.XkdcOutput.ConsoleBanExpireTime);
                        for (int u = 0; u < 2; ++u)
                        {
                            ValueCheck.Test("User " + u + " Ban Expire FileTime", 0, Client.XkdcOutput.UserBanExpireTime[u]);
                        }
                        for (int u = 2; u < 4; ++u)
                        {
                            ValueCheck.Test("User " + u + " Ban Expire Date", banTime, Client.XkdcOutput.GetConvertedUserBanExpireTime(u), BanTolerance);
                        }
                    }

                    VerifyPrivileges();
                }
            }

            [TestCase]
            public class TwoUsersTempBan : UserTestBase
            {
                public override void Run ()
                {
                    System.DateTime banTime = System.DateTime.UtcNow.AddDays(2);

                    CreateAndAddUser(banTime);
                    CreateAndAddUser(banTime);
                    FinishXkdcRequest();

                    ValueCheck.Test("Xkdc Overall HR", 0, Client.XkdcOutput.Hr);
                    ValueCheck.Test("Xkdc User0 HR", ExpectedBanCode, Client.XkdcOutput.HrUser[0]);
                    ValueCheck.Test("Xkdc User1 HR", ExpectedBanCode, Client.XkdcOutput.HrUser[1]);
                    ValueCheck.Test("Xkdc User2 HR", 0, Client.XkdcOutput.HrUser[2]);
                    ValueCheck.Test("Xkdc User3 HR", 0, Client.XkdcOutput.HrUser[3]);

                    if (SRVersion >= 6)
                    {
                        ValueCheck.Test("Machine Ban Expiration FileTime", 0, Client.XkdcOutput.ConsoleBanExpireTime);
                        for (int u = 0; u < 2; ++u)
                        {
                            ValueCheck.Test("User " + u + " Ban Expire Date", banTime, Client.XkdcOutput.GetConvertedUserBanExpireTime(u), BanTolerance);
                        }
                        for (int u = 2; u < 4; ++u)
                        {
                            ValueCheck.Test("User " + u + " Ban Expire FileTime", 0, Client.XkdcOutput.UserBanExpireTime[u]);
                        }
                    }

                    VerifyPrivileges();
                }
            }

            [TestCase]
            public class TwoUsersWereBanned : UserTestBase
            {
                public override void Run ()
                {
                    System.DateTime banTime = System.DateTime.UtcNow.AddDays(-2);

                    CreateAndAddUser(banTime);
                    CreateAndAddUser(banTime);
                    FinishXkdcRequest();

                    // if they are no longer banned, we should succeed
                    ValueCheck.Test("Xkdc Overall HR", 0, Client.XkdcOutput.Hr);
                    ValueCheck.Test("Xkdc User0 HR", 0, Client.XkdcOutput.HrUser[0]);
                    ValueCheck.Test("Xkdc User1 HR", 0, Client.XkdcOutput.HrUser[1]);
                    ValueCheck.Test("Xkdc User2 HR", 0, Client.XkdcOutput.HrUser[2]);
                    ValueCheck.Test("Xkdc User3 HR", 0, Client.XkdcOutput.HrUser[3]);

                    if (SRVersion >= 6)
                    {
                        ValueCheck.Test("Machine Ban Expiration FileTime", 0, Client.XkdcOutput.ConsoleBanExpireTime);
                        for (int u = 0; u < 4; ++u)
                        {
                            ValueCheck.Test("User " + u + " Ban Expire FileTime", 0, Client.XkdcOutput.UserBanExpireTime[u]);
                        }
                    }

                    VerifyPrivileges();
                }
            }

            [TestCase]
            public class TwoUsersOnePermaBanned : UserTestBase
            {
                public override void Run ()
                {
                    System.DateTime banTime = System.DateTime.MaxValue;

                    CreateAndAddUser();
                    CreateAndAddUser(banTime);
                    FinishXkdcRequest();

                    ValueCheck.Test("Xkdc Overall HR", 0, Client.XkdcOutput.Hr);
                    ValueCheck.Test("Xkdc User0 HR", 0, Client.XkdcOutput.HrUser[0]);
                    ValueCheck.Test("Xkdc User1 HR", ExpectedBanCode, Client.XkdcOutput.HrUser[1]);
                    ValueCheck.Test("Xkdc User2 HR", 0, Client.XkdcOutput.HrUser[2]);
                    ValueCheck.Test("Xkdc User3 HR", 0, Client.XkdcOutput.HrUser[3]);

                    if (SRVersion >= 6)
                    {
                        ValueCheck.Test("Machine Ban Expiration FileTime", 0, Client.XkdcOutput.ConsoleBanExpireTime);
                        ValueCheck.Test("User 0 Ban Expire FileTime", 0, Client.XkdcOutput.UserBanExpireTime[0]);
                        ValueCheck.Test("User 1 Ban Expire Date", banTime, Client.XkdcOutput.GetConvertedUserBanExpireTime(1), BanTolerance);
                        for (int u = 2; u < 4; ++u)
                        {
                            ValueCheck.Test("User " + u + " Ban Expire FileTime", 0, Client.XkdcOutput.UserBanExpireTime[u]);
                        }
                    }

                    VerifyPrivileges();
                }
            }

            [TestCase]
            public class TwoUsersNotInFirstSlotsOnePermaBanned : UserTestBase
            {
                public override void Run ()
                {
                    System.DateTime banTime = System.DateTime.MaxValue;

                    CreateAndAddUser(banTime);
                    CreateAndAddUser();

                    Client.CreateAskdcMachineRequest();
                    Client.ExecuteAskdc(true);

                    SetSRVersion(this, Client);
                    Client.XkdcRequest.Input.UserIDs[3] = Client.XkdcRequest.Input.UserIDs[0];
                    Client.XkdcRequest.Input.UserIDs[0] = 0;
                    Client.XkdcRequest.Input.UserIDs[2] = Client.XkdcRequest.Input.UserIDs[1];
                    Client.XkdcRequest.Input.UserIDs[1] = 0;
                    Client.ExecuteXkdc(true);

                    ValueCheck.Test("Xkdc Overall HR", 0, Client.XkdcOutput.Hr);
                    ValueCheck.Test("Xkdc User0 HR", 0, Client.XkdcOutput.HrUser[0]);
                    ValueCheck.Test("Xkdc User1 HR", 0, Client.XkdcOutput.HrUser[1]);
                    ValueCheck.Test("Xkdc User2 HR", 0, Client.XkdcOutput.HrUser[2]);
                    ValueCheck.Test("Xkdc User3 HR", ExpectedBanCode, Client.XkdcOutput.HrUser[3]);

                    if (SRVersion >= 6)
                    {
                        ValueCheck.Test("Machine Ban Expiration FileTime", 0, Client.XkdcOutput.ConsoleBanExpireTime);
                        for (int u = 0; u < 2; ++u)
                        {
                            ValueCheck.Test("User " + u + " Ban Expire FileTime", 0, Client.XkdcOutput.UserBanExpireTime[u]);
                        }
                        ValueCheck.Test("User 2 Ban Expire FileTime", 0, Client.XkdcOutput.UserBanExpireTime[2]);
                        ValueCheck.Test("User 3 Ban Expire Date", banTime, Client.XkdcOutput.GetConvertedUserBanExpireTime(3), BanTolerance);
                    }

                    VerifyPrivileges();
                }
            }

            [TestCase]
            public class TwoUsersOneTempBan : UserTestBase
            {
                public override void Run ()
                {
                    System.DateTime banTime = System.DateTime.UtcNow.AddDays(2);

                    CreateAndAddUser(banTime);
                    CreateAndAddUser();
                    FinishXkdcRequest();

                    ValueCheck.Test("Xkdc Overall HR", 0, Client.XkdcOutput.Hr);
                    ValueCheck.Test("Xkdc User0 HR", ExpectedBanCode, Client.XkdcOutput.HrUser[0]);
                    ValueCheck.Test("Xkdc User1 HR", 0, Client.XkdcOutput.HrUser[1]);
                    ValueCheck.Test("Xkdc User2 HR", 0, Client.XkdcOutput.HrUser[2]);
                    ValueCheck.Test("Xkdc User3 HR", 0, Client.XkdcOutput.HrUser[3]);

                    if (SRVersion >= 6)
                    {
                        ValueCheck.Test("Machine Ban Expiration FileTime", 0, Client.XkdcOutput.ConsoleBanExpireTime);
                        ValueCheck.Test("User 0 Ban Expire Date", banTime, Client.XkdcOutput.GetConvertedUserBanExpireTime(0), BanTolerance);
                        ValueCheck.Test("User 1 Ban Expire FileTime", 0, Client.XkdcOutput.UserBanExpireTime[1]);
                        for (int u = 2; u < 4; ++u)
                        {
                            ValueCheck.Test("User " + u + " Ban Expire FileTime", 0, Client.XkdcOutput.UserBanExpireTime[u]);
                        }
                    }

                    VerifyPrivileges();
                }
            }

            [TestCase]
            public class TwoUsersOneWasBanned : UserTestBase
            {
                public override void Run ()
                {
                    System.DateTime banTime = System.DateTime.UtcNow.AddDays(-2);

                    CreateAndAddUser();
                    CreateAndAddUser(banTime);