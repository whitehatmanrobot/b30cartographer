                    {
                            dwFlags |= SMINV_PROMOTE;
                        }
                        else if (pdwidl->dwItem1 == SHCNEE_DEMOTEDITEM)
                        {
                            dwFlags |= SMINV_DEMOTE;
                        }


                        // Are we actually doing something?
                        if (SMINV_NOCALLBACK != dwFlags)
                        {
                            v_InvalidateItem(&smd, dwFlags);
                        }
                    }
                }
            }
            break;


        default:
            break;
        }
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: IShellChangeNotify::OnChange

*/
HRESULT CMenuSFToolbar::OnChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    HRESULT hres = E_FAIL;

    // If we're in the middle of being destroyed, don't process this.
    if (!_hwndMB)
        return S_OK;

    _pcmb->_pmbState->PushChangeNotify();

    SMCSHCHANGENOTIFYSTRUCT shns;
    shns.lEvent = lEvent;
    shns.pidl1  = pidl1;
    shns.pidl2  = pidl2;
    CallCB(NULL, SMC_SHCHANGENOTIFY, NULL, (LPARAM)&shns);  // Ignore return value. Notify only.

    // Since we may be removing the selected item, we want the selection to move to the next item
    int iHot = ToolBar_GetHotItem(_hwndMB);

    hres = CSFToolbar::OnChange(lEvent, pidl1, pidl2);

    // BUGBUG(lamadio): Investigate moving this into the OnTranslateChange handler. Saves us
    // from having to wrap them again.... This could be a big perf win....

    // Is this a child of this toolbar is some shape or form?
    // 1) The changing pidl is a child of this pane.
    // 2) What the pidl is changing to is in this pane (For renames)
    // 3) Updatedirs. Recursive change notifies must forward update dirs all the way down the chain.
    // 4) EXTENDED events with a pidl2 == NULL. This means Reorder all your items.
    if (_IsChildID(pidl1, FALSE) || 
        (pidl2 && _IsChildID(pidl2, FALSE)) || 
        lEvent == SHCNE_UPDATEDIR ||
        (lEvent == SHCNE_EXTENDED_EVENT &&
         pidl2 == NULL)) 
    {
        // We need to forward this down then.
        HRESULT hresInner = _pcmb->ForwardChangeNotify(lEvent, pidl1, pidl2);


        // Did either of us handle this change?
        if (SUCCEEDED(hresInner) || SUCCEEDED(hres))
        {
            hres = S_OK;
        }
        else if (lEvent != SHCNE_EXTENDED_EVENT)    // Don't bother with extended events...
        {   
            // Ok so neither of us handled this?
            // Must be the SHChangeNotifyCollapsing code that collapses
            // the Directory Create and item create into a single item create.
            // We need to force an update dir on ourselves so that we get this change.
            hres = CSFToolbar::OnChange(SHCNE_UPDATEDIR, pidl1, pidl2);
        }
    }

    // Set the hot item back, wrapping if necessary.
    if (ToolBar_GetHotItem(_hwndMB) != iHot)
        SetHotItem(1, iHot, -1, 0);

    _pcmb->_pmbState->PopChangeNotify();

    return hres;
}

void CMenuSFToolbar::_OnDragBegin(int iItem, DWORD dwPreferedEffect)
{
    // During drag and drop, allow dialogs to collapse menu.
    MyLockSetForegroundWindow(FALSE);

    CSFToolbar::_OnDragBegin(iItem, DROPEFFECT_MOVE);
    if (_fEditMode)
        SetTimer(_hwndTB, MBTIMER_ENDEDIT, MBTIMER_ENDEDITTIME, 0);
}


void CMenuSFToolbar::v_SendMenuNotification(UINT idCmd, BOOL fClear)
{
    if (fClear)
    {
        // If we're clearing, tell the browser 
        PostMessage(_pcmb->_pmbState->GetSubclassedHWND(), WM_MENUSELECT,
            MAKEWPARAM(0, -1), NULL);

    }
    else
    {
        PIBDATA pibdata = _IDToPibData(idCmd);
        LPCITEMIDLIST pidl;
    
        // Only send notifications for non submenu items
        if (EVAL(pibdata) && (pidl = pibdata->GetPidl()))
        {
            CallCB(pidl, SMC_SFSELECTITEM, 0, 0);
            // Don't free Pidl
        }
    }
}    


LRESULT CMenuSFToolbar::_OnGetObject(NMOBJECTNOTIFY* pnmon)
{
    pnmon->hResult = QueryInterface(*pnmon->piid, &pnmon->pObject);

    return 1;
}


LRESULT CMenuSFToolbar::_OnNotify(LPNMHDR pnm)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    LRESULT lres = 0;

    // These are notifies we handle even when disengaged from the message hook.
    switch (pnm->code)
    {
    case TBN_DELETINGBUTTON:
        if (_fEmptyingToolbar)
            return 0;
        else
            goto DoDefault;
        break;

    case TBN_GETDISPINFOA:
    case TBN_GETDISPINFOW:
    case NM_CUSTOMDRAW:
        goto DoDefault;
    }

    // Pager notifications MUST be forwarded even when the message hook is disengaged.
    if((pnm->code <= PGN_FIRST)  && (pnm->code >= PGN_LAST)) 
    {
        goto DoNotify;
    }
    
    
    // Is the Global Message filter Disengaged? This will happen when the Subclassed window
    // looses activation to a dialog box of some kind.
    if (lres == 0 && !GetMessageFilter()->IsEngaged())
    {
        // Yes; We've lost activation so we don't want to track like a normal menu...
        // For hot item change, return 1 so that the toolbar does not change the hot item.
        if (pnm->code == TBN_HOTITEMCHANGE && _pcmb->_fMenuMode)
            return 1;

        // For all other items, don't do anything....
        return 0;
    }

DoNotify:
    switch (pnm->code)
    {
    case PGN_SCROLL:
        KillTimer(_hwndMB, MBTIMER_DRAGPOPDOWN);
        if (_pcmb->_fInSubMenu)
            _pcmb->_SubMenuOnSelect(MPOS_CANCELLEVEL);

        _fSuppressUserMonitor = TRUE;
        break;

    case TBN_GETOBJECT:
        lres = _OnGetObject((NMOBJECTNOTIFY*)pnm);
        break;

    case TBN_DRAGOUT:
        {
            TBNOTIFY *ptbn = (TBNOTIFY*)pnm;
            if (!_fEmpty && ptbn->iItem != _idCmdChevron &&
                !(_pcmb->_dwFlags & SMINIT_RESTRICT_DRAGDROP) &&
                (S_FALSE == CallCB(NULL, SMC_SFDDRESTRICTED, NULL, NULL)))
            {

                // We're now in edit mode
                _fEditMode = TRUE;
                _idCmdDragging = ptbn->iItem;
                _MarkItem(ptbn->iItem);

                lres = 1;       // Allow the drag to occur
                goto DoDefault;
            }
            else
                lres = 0;   // Do not allow the drag out.
        }
        break;
   
    default:
DoDefault:
        lres = CMenuToolbarBase::_OnNotify(pnm);
        if (lres == 0)
        {
            lres = CSFToolbar::_OnNotify(pnm);
        }
        break;
    }

    return lres;
}


void CMenuSFToolbar::CreateToolbar(HWND hwndParent)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    CSFToolbar::_CreateToolbar(hwndParent);
    if (_hwndPager)
    {
        SHSetWindowBits(_hwndPager, GWL_STYLE, PGS_DRAGNDROP, PGS_DRAGNDROP);
        SHSetWindowBits(_hwndPager, GWL_STYLE, PGS_AUTOSCROLL, PGS_AUTOSCROLL);
        SHSetWindowBits(_hwndPager, GWL_STYLE, PGS_HORZ|PGS_VERT,
           _fVertical ? PGS_VERT : PGS_HORZ);
    }

    _hwndMB = _hwndTB;

    CMenuToolbarBase::CreateToolbar(hwndParent);

    // By "Registering optimized" means that someone else is going to pass the change to us, 
    // we don't need to register for it. This is for the disjoint Fast Items | Programs menu case.
    // We still need top level change notify registration for Favorites, Documents, Printers and Control
    // Panel (Depending on their visibility)
    //

    if (_pcmb->_uId == MNFOLDER_IS_PARENT || 
        (_dwFlags & SMSET_DONTREGISTERCHANGENOTIFY))
        _fRegisterChangeNotify = FALSE;

    // This is a good as spot as any to do this:
    _RegisterToolbar();
}


HKEY CMenuSFToolbar::_GetKey(LPCITEMIDLIST pidl)
{
    HKEY hMenuKey;
    DWORD dwDisp;
    TCHAR szDisplay[MAX_PATH];

    if (!_hKey)
        return NULL;

    _ObtainPIDLName(pidl, szDisplay, ARRAYSIZE(szDisplay));
    RegCreateKeyEx(_hKey, szDisplay, NULL, NULL,
        REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
        NULL, &hMenuKey, &dwDisp);
    TraceMsg(TF_MENUBAND, "%d is setting %s\'s Key to %d", _hKey, szDisplay, hMenuKey);
    return hMenuKey;
}


//***
// NOTES
//  idtCmd is currently always -1.  we'll need other values when we're
// called from CallCB.  however we can't do that until we move idtCmd
// 'down' into CallCB.
HRESULT CMenuSFToolbar::v_GetState(int idtCmd, LPSMDATA psmd)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    HRESULT hres = E_FAIL;
    CMenuData* pdata;
    LPITEMIDLIST pidl = NULL;

    psmd->dwMask = SMDM_SHELLFOLDER;

    if (idtCmd == -1)
        idtCmd = GetButtonCmd(_hwndTB, ToolBar_GetHotItem(_hwndTB));

    pdata = (CMenuData*)_IDToPibData(idtCmd);
    if (EVAL(pdata))
    {
        pidl = pdata->GetPidl();
        ASSERT(IS_VALID_PIDL(pidl));
    }

    if (pidl)
    {
        if( _pasf2 && S_OK == _pasf2->UnWrapIDList(pidl, 1, &psmd->psf, &psmd->pidlFolder, &psmd->pidlItem, NULL))
        {
            /*NOTHING*/
            ;
        }
        else
        {
            // Then it must be a straight ShellFolder.
            psmd->psf = _psf;
            if (EVAL(psmd->psf))
                psmd->psf->AddRef();
            psmd->pidlFolder = ILClone(_pidl);
            psmd->pidlItem = ILClone(ILFindLastID(pidl));
        }

        psmd->uIdParent = _pcmb->_uId;
        psmd->punk = SAFECAST(_pcmb, IShellMenu*);
        psmd->punk->AddRef();

        hres = S_OK;
    }

    return hres;
}

HRESULT CMenuSFToolbar::CallCB(LPCITEMIDLIST pidl, DWORD dwMsg, WPARAM wParam, LPARAM lParam)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    if (!_pcmb->_psmcb)
        return S_FALSE;

    SMDATA smd;
    HRESULT hres = S_FALSE;
    BOOL fDestroy = FALSE;

    // todo: call v_GetState (but need idCmd for pidl)
    smd.dwMask = SMDM_SHELLFOLDER;

    if (pidl)
    {
        // We used to unwrap the pidl here in the case of AUGMISF, but why? In the Callback, we only
        // needed the Full pidl for Executing and for Darwin. The unwrap is an expensive call that in
        // the majority case wasn't even used. Put it on the client to unwrap it. Start Menu is the
        // only user of Augmented shell folders anyway....
        smd.psf = _psf;
        smd.pidlFolder = _pidl;
        smd.pidlItem = (LPITEMIDLIST)pidl;
    }
    else
    {
        // Null pidl means tell the callback about me...
        smd.pidlItem = ILClone(ILFindLastID(_pidl));
        smd.pidlFolder = ILClone(_pidl);
        ILRemoveLastID(smd.pidlFolder);
        smd.psf = NULL; // Incase bind fails.
        IEBindToObject(smd.pidlFolder, &smd.psf);
        fDestroy = TRUE;
    }

    smd.uIdParent = _pcmb->_uId;
    smd.uIdAncestor = _pcmb->_uIdAncestor;

    smd.punk = SAFECAST(_pcmb, IShellMenu*);
    smd.pvUserData = _pcmb->_pvUserData;

    hres = _pcmb->_psmcb->CallbackSM(&smd, dwMsg, wParam, lParam);

    if (fDestroy)
    {
        ATOMICRELEASE(smd.psf);
        ILFree(smd.pidlFolder);
        ILFree(smd.pidlItem);
    }
    
    return hres;
}

HRESULT CMenuSFToolbar::v_CallCBItem(int idtCmd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hres = E_FAIL;
    CMenuData* pdata = (CMenuData*)_IDToPibData(idtCmd);
    ASSERT(pdata);
    ASSERT(pdata->GetPidl() == NULL || IS_VALID_PIDL(pdata->GetPidl()));

    if (pdata)
        hres = CallCB(pdata->GetPidl(), uMsg, wParam, lParam);
    return hres;
}

HRESULT CMenuSFToolbar::v_GetSubMenu(int idCmd, const GUID* pguidService, REFIID riid, void** ppvObj)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    CMenuData* pdata = (CMenuData*)_IDToPibData(idCmd);
    HRESULT hres = E_FAIL;

    ASSERT(IS_VALID_WRITE_PTR(ppvObj, void*));

    *ppvObj = NULL;

    ASSERT(pdata);
    if (pdata && pdata->GetFlags() & SMIF_SUBMENU)
    {
        hres = pdata->GetSubMenu(pguidService, riid, (void**)ppvObj);
        if ( FAILED(hres) && IsEqualGUID(riid, IID_IShellMenu))
        {
            hres = CallCB(pdata->GetPidl(), SMC_GETSFOBJECT, (WPARAM)&riid, (LPARAM)ppvObj);
            if (SUCCEEDED(hres))
            {
                BOOL fCache = TRUE;
                if (S_OK != hres)
                {
                    hres = E_FAIL;
                    IShellMenu* psm = (IShellMenu*) new CMenuBand();
                    if (psm)
                    {
                        IShellFolder* psf = NULL;
                        LPITEMIDLIST pidlItem = pdata->GetPidl();
                        LPITEMIDLIST pidlFolder = _pidl;
                        BOOL fDestroy = FALSE;
                        IShellMenuCallback* psmcb;

                        // Ask the callback if they want to supply a different callback
                        // object for this sub menu. If they do, then use what they 
                        // pass back NOTE: If they pass back S_OK, it's perfectly Ok,
                        // for them to pass back a NULL psmcb. This means, I don't want
                        // my child to have a callback. Use the default.
                        // If they don't handle it, then use their pointer.
                        if (S_FALSE == CallCB(pdata->GetPidl(), SMC_GETSFOBJECT, 
                            (WPARAM)&IID_IShellMenuCallback, (LPARAM)&psmcb))
                        {
                            psmcb = _pcmb->_psmcb;
                            if (psmcb)
                                psmcb->AddRef();
                        }


                        // This has to be before the unwrap because it does name resolution through
                        // the Augmented ISF.
                        HKEY hMenuKey = _GetKey(pidlItem);
                        
                        if (_pasf2)
                        {
                            if (S_OK == _pasf2->UnWrapIDList(pdata->GetPidl(), 1, &psf, &pidlFolder, &pidlItem, NULL))
                            {
                                psf->Release(); // I don't need this
                                psf = NULL;
                                fDestroy = TRUE;
                            }

                            _pasf2->BindToObject(pdata->GetPidl(), NULL, IID_IShellFolder, (LPVOID*)&psf);
                        }

                        // Inherit the flags from the parent...
                        DWORD dwFlags = SMINIT_VERTICAL | 
                            (_pcmb->_dwFlags & (SMINIT_RESTRICT_CONTEXTMENU | 
                                                SMINIT_RESTRICT_DRAGDROP    | 
                                                SMINIT_MULTICOLUMN));

                        LPITEMIDLIST pidlFull = ILCombine(pidlFolder, pidlItem);
                        if (psf == NULL)
                        {
                            hres = _psf->BindToObject(pidlItem, NULL, IID_IShellFolder, (void**)&psf);
                        }

                        DWORD dwAttrib = SFGAO_FILESYSTEM;
                        LPCITEMIDLIST pidlWrappedItem = pdata->GetPidl();
                        // _psf can be an augmented shell folder. Use the wrapped item....
                        _psf->GetAttributesOf(1, (LPCITEMIDLIST*)&pidlWrappedItem, &dwAttrib);

                        // We need to sniff the pidl to see if it's a junction
                        // The format of a Filesytem pidl is 
                        //  WORD cb;
                        //  BYTE bFlags;
                        // if (pidl->bFlags & Namespace Junction)
                        //      ...Or...
                        // It's not in the filesystem.

                        if (SIL_GetType(pidlItem) & 0x80 || !(dwAttrib & SFGAO_FILESYSTEM))
                        {
                            // We're not going to persist anything
                            RegCloseKey(hMenuKey);
                            hMenuKey = NULL;
                            psmcb = NULL;   // We're not going to pass a callback. NOTE: We don't need to release this
                            dwFlags &= ~SMINIT_MULTICOLUMN; // No multi on FShortcut...
                            fCache = FALSE;
                        }
                        UINT uIdAncestor = _pcmb->_uIdAncestor;
                        if (uIdAncestor == ANCESTORDEFAULT)
                            uIdAncestor = idCmd;

                        psm->Initialize(psmcb, MNFOLDER_IS_PARENT, uIdAncestor, dwFlags);
                        
                        if (psf)
                        {
                            psm->SetShellFolder(psf, pidlFull, hMenuKey, 
                                _dwFlags & (SMSET_HASEXPANDABLEFOLDERS | SMSET_USEBKICONEXTRACTION));
                            hres = psm->QueryInterface(riid, ppvObj);
                            psf->Release();
                        }
                        ILFree(pidlFull);

                        psm->Release();
                        if (psmcb)
                            psmcb->Release();

                        if (fDestroy)
                        {
                            ILFree(pidlFolder);
                            ILFree(pidlItem);
                        }
                    }
                }

                if (*ppvObj)
                {
                    if (fCache)
                    {
                        pdata->SetSubMenu((IUnknown*)*ppvObj);
                    }

                    VARIANT Var;
                    Var.vt = VT_UNKNOWN;
                    Var.byref = SAFECAST(_pcmb->_pmbm, IUnknown*);

                    // Set the CMenuBandMetrics into the new menuband
                    IUnknown_Exec((IUnknown*)*ppvObj, &CGID_MenuBand, MBANDCID_SETFONTS, 0, &Var, NULL);

                    // Set the CMenuBandState  into the new menuband
                    Var.vt = VT_INT_PTR;
                    Var.byref = _pcmb->_pmbState;
                    IUnknown_Exec((IUnknown*)*ppvObj, &CGID_MenuBand, MBANDCID_SETSTATEOBJECT, 0, &Var, NULL);


                }
            }
        }
    }

    return hres;
}


DWORD CMenuSFToolbar::v_GetFlags(int idCmd)
{
    CMenuData* pdata = (CMenuData*)_IDToPibData(idCmd);

    // Toolbar is allowed to pass a bad command in the case of background erase
    if (pdata)
        return pdata->GetFlags();
    else
        return 0;

//  BUGBUG (lamadio): Should I query each time? For like Volitile items?
//    SMINFO SMINFO = {SMIM_FLAGS};
//    CallCB(pdata->GetPidl(), SMC_GETFSINFO, (WPARAM)idCmd, (LPARAM)&SMINFO);

}


// This is to tell all other clients that we updated the promotion state of something.
void CMenuSFToolbar::BroadcastIntelliMenuState(LPCITEMIDLIST pidlItem, BOOL fPromoted)
{
    LPITEMIDLIST pidlFolder;
    LPITEMIDLIST pidlItemUnwrapped;
    LPITEMIDLIST pidlFull;

    if( _pasf2 && S_OK == _pasf2->UnWrapIDList(pidlItem, 1, NULL, &pidlFolder, &pidlItemUnwrapped, NULL))
    {

        pidlFull = ILCombine(pidlFolder, pidlItemUnwrapped);
        ILFree(pidlFolder);
        ILFree(pidlItemUnwrapped);
    }
    else
    {

        pidlFull = ILCombine(_pidl, pidlItem);
    }

    SHSendChangeMenuNotify(this,
                           fPromoted ? SHCNEE_PROMOTEDITEM : SHCNEE_DEMOTEDITEM,
                           0, pidlFull);

    ILFree(pidlFull);

}

HRESULT CMenuSFToolbar::v_ExecItem(int idCmd)
{
    CMenuData* pdata = (CMenuData*)_IDToPibData(idCmd);
    HRESULT hres = E_FAIL;
    if (pdata && !_fEmpty && idCmd != _idCmdChevron)
    {
        // STRESS: pdata was becomming 0x8 for some reason after the InvokeDefault.
        // I assume that this call was causing a flush, which frees our list of pidls.
        // So, I'm cloning it. I also changed the order, so that we'll just fire the
        // UEM event.

        LPITEMIDLIST pidl = ILClone(pdata->GetPidl());
        if (pidl)
        {
            ASSERT(IS_VALID_PIDL(pidl));

            SMDATA smd;
            smd.dwMask = SMDM_SHELLFOLDER;
            smd.pidlFolder = _pidl;
            smd.pidlItem = pidl;
            v_InvalidateItem(&smd, SMINV_PROMOTE | SMINV_FORCE);

            hres = CallCB(pidl, SMC_SFEXEC, 0, 0);

            // Did the Callback handle this execute for us?
            if (hres == S_FALSE) 
            {
                // No, Ok, do it ourselves.
                hres = SHInvokeDefaultCommand(_hwndTB, _psf, pidl);
            }

            ILFree(pidl);
        }

    }

    return hres;
}


HRESULT CMenuSFToolbar::v_GetInfoTip(int idCmd, LPTSTR psz, UINT cch)
{
    CMenuData* pdata = (CMenuData*)_IDToPibData(idCmd);
    HRESULT hres = E_FAIL;

    if (_fEmpty || !pdata)
        return hres;

    hres = CallCB(pdata->GetPidl(), SMC_GETSFINFOTIP, (WPARAM)psz, (LPARAM)cch);

    if (S_FALSE == hres)
    {
        hres = E_FAIL;
        if (GetInfoTip(_psf, pdata->GetPidl(), psz, cch))
        {
            hres = NOERROR;
        }
    } 

    return hres;

}


void CMenuSFToolbar::v_ForwardMouseMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    RECT rc;
    POINT pt;
    HWND    hwndFwd;
    
    // These are in screen coords
    pt.x = GET_X_LPARAM(lParam);
    pt.y = GET_Y_LPARAM(lParam);

    hwndFwd = _hwndPager ? _hwndPager : _hwndTB;
    GetWindowRect(hwndFwd, &rc);

    if (PtInRect(&rc, pt))
    {
        MapWindowPoints(NULL, hwndFwd, &pt, 1);
        HWND hwnd = ChildWindowFromPoint(hwndFwd, pt);

        if (hwnd) 
        {
            MapWindowPoints(hwndFwd, hwnd, &pt, 1);
        }
        else
        {
            hwnd = hwndFwd;
        }

        SendMessage(hwnd, uMsg, wParam, MAKELONG(pt.x, pt.y));
    }
}


HRESULT CMenuSFToolbar::OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    switch(uMsg)
    {
    case WM_SYSCOLORCHANGE:
        if (_hwndPager)
            Pager_SetBkColor(_hwndPager, GetSysColor(COLOR_MENU));

        // Change the color, so that we can see it.
        ToolBar_SetInsertMarkColor(_hwndMB, GetSysColor(COLOR_MENUTEXT));
        break;
    }
    HRESULT hres = CMenuToolbarBase::OnWinEvent(hwnd, uMsg, wParam, lParam, plres);
    if (hres != S_OK)
        hres = CSFToolbar::OnWinEvent(hwnd, uMsg, wParam, lParam, plres);

    return hres;
}


BOOL CMenuSFToolbar::v_UpdateIconSize(UINT uIconSize, BOOL fUpdateButtons) 
{ 
    if (uIconSize == -1) 
        uIconSize = _uIconSize; 
    _uIconSizeMB = uIconSize;
    return _UpdateIconSize(uIconSize, fUpdateButtons); 
}

 
HRESULT CMenuSFToolbar::GetShellFolder(LPITEMIDLIST* ppidl, REFIID riid, void** ppvObj)
{
    HRESULT hres = E_FAIL;
    *ppvObj = NULL;
    if (_psf)
    {
        hres = _psf->QueryInterface(riid, ppvObj);
    }

    if(SUCCEEDED(hres) && ppidl)
    {
        *ppidl = ILClone(_pidl);
        if (! *ppidl)
        {
            (*(IUnknown**)ppvObj)->Release();
            
            hres = E_FAIL;
        }
    }

    return hres;
}


LRESULT CMenuSFToolbar::_OnTimer(WPARAM wParam)
{
    switch(wParam)
    {
    case MBTIMER_ENDEDIT:
        KillTimer(_hwndTB, wParam);
        _fEditMode = FALSE;
        break;

    case MBTIMER_CLICKUNHANDLE:
        KillTimer(_hwndTB, wParam);
        _fClickHandled = FALSE;
        break;

    default:
        return CMenuToolbarBase::_OnTimer(wParam);
    }
    return 1;
}


LRESULT CMenuSFToolbar::_OnDropDown(LPNMTOOLBAR pnmtb)
{
    if (GetAsyncKeyState(VK_LBUTTON) < 0 && _fEditMode)
    {
        // Are we in edit mode?
        if (_fEditMode)
        {
            // Yes, mark the item as the item that is subject to moving
            _MarkItem(pnmtb->iItem);
        }
        return TBDDRET_TREATPRESSED;
    }
    
    return CMenuToolbarBase::_OnDropDown(pnmtb);
}


/*----------------------------------------------------------
Purpose: In the context of a menuband, marking means putting
         a black rectangle around the item currently being dragged.

*/
void CMenuSFToolbar::_MarkItem(int idCmd)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    // Un-highlight the previously moved button
    if (0 <= _pcmb->_nItemMove)
    {
        // Should item move be a member of SFToolbar?
        ToolBar_MarkButton(_hwndTB, _pcmb->_nItemMove, FALSE);
        _pcmb->_nItemMove = -1;
    }
    
    if (_fEditMode)    
    {
        _pcmb->_nItemMove = idCmd;
        ToolBar_MarkButton(_hwndTB, _pcmb->_nItemMove, TRUE);
    }
}    


STDMETHODIMP CMenuSFToolbar::IsWindowOwner(HWND hwnd) 
{ 
    if (_hwndTB == hwnd || _hwndPager == hwnd || HWND_BROADCAST == hwnd) 
    {
        return S_OK;
    } 
    else 
    {
        return S_FALSE;
    } 
}


void CMenuSFToolbar::SetWindowPos(LPSIZE psize, LPRECT prc, DWORD dwFlags)
{
    if (!_hwndPager)
    {
        CMenuToolbarBase::SetWindowPos(psize, prc, dwFlags);
        return;
    }
    DWORD rectWidth = RECTWIDTH(*prc);

    TraceMsg(TF_MENUBAND, "CMSFTB::SetWindowPos %d - (%d,%d,%d,%d)", psize?psize->cx:0,
        prc->left, prc->top, prc->right, prc->bottom);

    ShowWindow(_hwndPager, SW_SHOW);
    ::SetWindowPos(_hwndPager, NULL, prc->left, prc->top, 
        rectWidth, RECTHEIGHT(*prc), SWP_NOZORDER | SWP_NOACTIVATE | dwFlags);
    if (psize)
        SendMessage(_hwndTB, TB_SETBUTTONWIDTH, 0, MAKELONG(psize->cx, psize->cx));

    SendMessage(_hwndPager, PGMP_RECALCSIZE, 0L, 0L);
}


void CMenuSFToolbar::SetParent(HWND hwndParent)
{ 
    int nCmdShow = SW_SHOW;
    if (hwndParent)
    {
        if (!_hwndTB)
            CreateToolbar(hwndParent);
        else
        {
            // make sure width is set correctly . . . 
            SendMessage(_hwndTB, TB_SETBUTTONWIDTH, 0, MAKELONG(_cxMin, _cxMax));
        }
    }
    else
    {
        // As an optimization, we implement "disowning" ourselves
        // as just moving ourselves offscreen.  The previous parent
        // still owns us.  The parent is invariably the menusite.
        RECT rc = {-1,-1,-1,-1};
        SetWindowPos(NULL, &rc, 0);
        nCmdShow = SW_HIDE;
    }


    HWND hwnd = _hwndPager ? _hwndPager: _hwndTB;
    
    if (IsWindow(hwnd)) // JANK : Fix for bug #98253
    {
       ::SetParent(hwnd, hwndParent); 
       SendMessage(hwnd, TB_SETPARENT, (WPARAM)hwndParent, NULL);
       ShowWindow(hwnd, nCmdShow);
    }
}

void CMenuSFToolbar::Expand(BOOL fExpand)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    TBBUTTON tbb;

    DAD_ShowDragImage(FALSE);

    // Since we're not sure if the Chevron is going to be visible we should remove it here
    // Later we'll add it back in if it's needed.
    _RemoveChevron();

    // Loop through and apply the fExpand
    int iNumButtons = ToolBar_ButtonCount(_hwndTB);

    // We reset these when iterating.
    _cPromotedItems = 0;
    _fHasDemotedItems = FALSE;

    int iHotItem = ToolBar_GetHotItem(_hwndMB);

//    SendMessage(_hwndMB, WM_SETREDRAW, FALSE, 0);

    for (int i = 0; i < iNumButtons; i++)
    {
        if (!ToolBar_GetButton(_hwndMB, i, &tbb))
            continue;

        CMenuData* pmd = (CMenuData*)tbb.dwData;

        // Get the toolbar state. Toolbar can set things like
        // TBSTATE_WRAP that we would go nuke.
        DWORD dwState = tbb.fsState;
        DWORD dwFlags = pmd ? pmd->GetFlags() : 0;

        if (dwFlags & SMIF_DEMOTED)
        {
            // Are we expanding?
            if (fExpand)
            {
                //Yes; Enable the button and remove the hidden state
                dwState |= TBSTATE_ENABLED;
                dwState &= ~TBSTATE_HIDDEN;
            }
            else
            {
                //No; Remove the Enabled state and hide the button
                dwState |= TBSTATE_HIDDEN;
                dwState &= ~TBSTATE_ENABLED;
            }

            _fHasDemotedItems = TRUE;
        }
        else if (dwFlags & SMIF_HIDDEN)
        {
            dwState |= TBSTATE_HIDDEN;
            dwState &= ~TBSTATE_ENABLED;
        }
        else if (tbb.idCommand != _idCmdChevron)
        {
            dwState |= TBSTATE_ENABLED;
            dwState &= ~TBSTATE_HIDDEN;
            _cPromotedItems++;
        }

        // If the state has changed, then set it into the toolbar.
        if (dwState != tbb.fsState)
            ToolBar_SetState(_hwndTB, tbb.idCommand, dwState);
    }

    // _fExpand means "Draw as Expanded". We do not want to 
    // draw expanded when we have no demoted items.

    _pcmb->_fExpanded = _fHasDemotedItems? fExpand : FALSE;

    if (fExpand)
    {
        if (_pcmb->_pmbState)
        {
            _pcmb->_pmbState->SetExpand(TRUE);
            _pcmb->_pmbState->HideTooltip(TRUE);
        }
    }
    else
    {
        _AddChevron();
    }

    // Have the menubar think about changing its height
    IUnknown_QueryServiceExec(_pcmb->_punkSite, SID_SMenuPopup, &CGID_MENUDESKBAR, 
        MBCID_SETEXPAND, _fHasDemotedItems?(int)_pcmb->_pmbState->GetExpand():FALSE, NULL, NULL);

//    SendMessage(_hwndMB, WM_SETREDRAW, TRUE, 0);
    _ToolbarChanged();
    ToolBar_SetHotItem(_hwndMB, iHotItem);
    if (_hwndPager)
        UpdateWindow(_hwndPager);
    UpdateWindow(_hwndTB);
//    DAD_ShowDragImage(TRUE);
}


void CMenuSFToolbar::GetSize(SIZE* psize)
{
    CMenuToolbarBase::GetSize(psize);

    if (_fEmpty && _fDontShowEmpty)
    {
        psize->cy = 0;
        TraceMsg(TF_MENUBAND, "CMSFT::GetSize (%d, %d)", psize->cx, psize->cy);
    }
}

void CMenuSFToolbar::_RefreshInfo()
{
    int cButton = ToolBar_ButtonCount(_hwndMB);
    for (int iButton = 0; iButton < cButton; iButton++)
    {
        int idCmd = GetButtonCmd(_hwndTB, iButton);

        if (idCmd != _idCmdChevron)
        {
            // Get the information from that button.
            CMenuData* pmd = (CMenuData*)_IDToPibData(idCmd);

            if (pmd)
            {
                SMINFO sminfo;
                sminfo.dwMask = SMIM_FLAGS;
                if (SUCCEEDED(_GetInfo(pmd->GetPidl(), &sminfo)))
                {
                    pmd->SetFlags(sminfo.dwFlags);
                }
            }
        }
    }
}

void CMenuSFToolbar::_FindMinPromotedItems(BOOL fSetOrderStream)
{
    // We need to iterate through the buttons and set the Promoted flag.
    int cButton = ToolBar_ButtonCount(_hwndMB);
    for (int iButton = 0; iButton < cButton; iButton++)
    {
        int idCmd = GetButtonCmd(_hwndTB, iButton);

        if (idCmd != _idCmdChevron)
        {
            // Get the information from that button.
            CMenuData* pmd = (CMenuData*)_IDToPibData(idCmd);

            if (pmd)
            {
                PORDERITEM poi = pmd->GetOrderItem();

                if (fSetOrderStream)
                {
                    DWORD dwFlags = pmd->GetFlags();
                    OrderItem_SetFlags(poi, dwFlags);
                }
                else    // Query the order stream
                {
                    DWORD dwFlags = OrderItem_GetFlags(poi);
                    DWORD dwOldFlags = pmd->GetFlags();

                    // When reading the flags from the registry, we only care about the demote flag.
                    if (dwFlags & SMIF_DEMOTED)
                    {
                        dwOldFlags |= SMIF_DEMOTED;
                    }
                    else if (!(dwOldFlags & SMIF_SUBMENU)) // Don't promote sub menus.
                    {
                        // Force a promote
                        CallCB(pmd->GetPidl(), SMC_PROMOTE, 0, 0);
                        dwOldFlags &= ~SMIF_DEMOTED;
                    }

                    pmd->SetFlags(dwOldFlags);

                }
            }
        }
    }

}

void CMenuSFToolbar::v_Show(BOOL fShow, BOOL fForceUpdate)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    CMenuToolbarBase::v_Show(fShow, fForceUpdate);

    if (fShow)
    {
        BOOL fDirty = _fDirty;
        _fClickHandled = FALSE;
        _RegisterToolbar();
        _FillToolbar();
        _pcmb->SetTracked(NULL);  // Since hot item is NULL
        ToolBar_SetHotItem(_hwndTB, -1);

        if (_fEmpty && (_dwFlags & SMSET_NOEMPTY))
        {
            _fDontShowEmpty = TRUE;
        }
        else if (_fRefreshInfo && !fDirty)         // Do we need to refresh our information?
        {
            // Yes;
            _RefreshInfo();
        }

        // HACKHACK (lamadio) : There is a sizing issue, where the sizing between the
        // toolbars gets preemted by a resize of the menubar before the size calculation completes.
        // So:
        //  ShowDW  -   Asks each toolbar to calc it's width
        //  CMenuSFToolbar::v_Show - Does a _FillToolbar. Since (in this senario) an item
        //              Has been added, it calls _ToolbarChanged
        //  _ToolbarChanged -   This says to the menubar, I've changed sizes, recalc.
        //  ResizeMenuBar   - In the depths, it eventually calls OnPosRectChanged, which asks each
        //              Toolbar what it's size is. Since the menu portion has not calculated it yet,
        //              It has the old size which is has the old size of the sftoolbar. So everything
        //              Gets reset to that size.
        //

        // We only want to Call expand if we are dirty or the expand state has changed. We
        // call for the Dirty case, because Expand does some neat stuff in calculating the
        // number of promoted items. If the state has changed, we want to reflect that.
        BOOL fExpand = _pcmb->_pmbState ? _pcmb->_pmbState->GetExpand() : FALSE;
        if ((BOOL)_pcmb->_fExpanded != fExpand || fDirty || _fRefreshInfo)
        {
            fForceUpdate = TRUE;
            Expand(fExpand);
        }

        // Only do this in the beginning.
        if (_fFirstTime)
        {
            CallCB(NULL, SMC_GETMINPROMOTED, 0, (LPARAM)&_cMinPromotedItems);

            if (_cPromotedItems < _cMinPromotedItems)
            {
                _FindMinPromotedItems(FALSE);
                Expand(fExpand);
            }
        }

        // Have the menubar think about changing its height
        // we need to do this here because the menubar may have changed it's
        // expand state independant of the pane.
        IUnknown_QueryServiceExec(_pcmb->_punkSite, SID_SMenuPopup, &CGID_MENUDESKBAR, 
            MBCID_SETEXPAND, (int)_pcmb->_fExpanded, NULL, NULL);
    
        // If we're dirty, have our parent consider promoting itself if there
        // are promoted items in the menu, or demoting itself if there arn't.
        // Don't worry, the parent won't do anything if it's already in that state.
        if ( fDirty )
        {
            IUnknown_RefreshParent(_pcmb->_punkSite, _pidl,
            ((_cPromotedItems == 0)? SMINV_DEMOTE : SMINV_PROMOTE) | SMINV_NEXTSHOW);
        }


        // If it is empty, we want to auto expand.
        // We have to do this before the update buttons, so that the size is calculate correctly.
        if (_cPromotedItems == 0 && !_pcmb->_fExpanded)
            Expand(TRUE);

        if (fForceUpdate)
            _UpdateButtons();

        if (_fHasDemotedItems)
        {
            if (S_OK == CallCB(NULL, SMC_DISPLAYCHEVRONTIP, 0, 0))
            {
                _FlashChevron();
            }
        }

        _fFirstTime = FALSE;
        _fRefreshInfo = FALSE;
    }
    else
    {
        KillTimer(_hwndMB, MBTIMER_UEMTIMEOUT);
    }
    _fShowMB = _fShow = fShow;


    // Reset these so we don't have stale information for the next drag drop cycle. NT #287914 (lamadio) 3.22.99
    _tbim.iButton = -1;
    _tbim.dwFlags = 0;

    _idCmdDragging = -1;

    // n.b. for !fShow, we don't kill the tracked site chain.  we
    // count on this in startmnu.cpp!CStartMenuCallback::_OnExecItem,
    // where we walk up the chain to find all hit 'nodes'.  if we need
    // to change this we could fire a 'pre-exec' event.
}


void CMenuSFToolbar::v_UpdateButtons(BOOL fNegotiateSize) 
{
    CSFToolbar::_UpdateButtons();
    if (_hwndTB && fNegotiateSize && _fVerticalMB)
        NegotiateSize();
}


// this method invalidates a single item in the toolbar
HRESULT CMenuSFToolbar::v_InvalidateItem(LPSMDATA psmd, DWORD dwFlags)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    // Default to not not handling this event.
    HRESULT hres = S_FALSE;

    if (NULL == psmd)
    {
        if (dwFlags & SMINV_REFRESH)
        {
            // bugbug: Needs to be optimized
            _Refresh();
            hres = S_OK;
        }
    }

    // CMenuSFToolbar only handles ShellFolder items.
    // Is this a shell folder?
    else if (psmd->dwMask & SMDM_SHELLFOLDER)
    {
        // Yes;
        int i;
        LPITEMIDLIST pidlButton = NULL;
        SMINFO sminfo;
        sminfo.dwMask = SMIM_FLAGS;

        // Since this pidl is comming from an outside source, 
        // we may need to translate it to a wrapped pidl.

        // Do we have a pidl Translator?
        if (_ptscn)
        {
            // Yes; 
            LPITEMIDLIST pidlTranslated;
            LPITEMIDLIST pidlDummy = NULL;
            LPITEMIDLIST pidlToTranslate = ILCombine(psmd->pidlFolder, psmd->pidlItem);
            if (pidlToTranslate)
            {
                LONG lEvent = 0, lEvent2;
                LPITEMIDLIST pidlDummy1, pidlDummy2;
                if (SUCCEEDED(_ptscn->TranslateIDs(&lEvent, pidlToTranslate, NULL, &pidlTranslated, &pidlDummy,
                                                   &lEvent2, &pidlDummy1, &pidlDummy2)))
                {
                    // Get the button in the toolbar that corresponds to this pidl.
                    pidlButton = _GetButtonFromPidl(ILFindLastID(pidlTranslated), NULL, &i);

                    // if pidl does not get translated TranslateIDs returns the same pidl passed
                    // to the function
                    if (pidlTranslated != pidlToTranslate)
                        ILFree(pidlTranslated);
                    // Don't need to delete pidlDummy because it's not set.
                    ASSERT(pidlDummy == NULL);
                    ASSERT(pidlDummy1 == NULL);
                    ASSERT(pidlDummy2 == NULL);
                }

                ILFree(pidlToTranslate);
            }
        }

        // Did we come from a non-augmented shell folder, or
        // did the caller pass a wrapped pidl? 
        if (!pidlButton)
        {
            // Seems like it, we'll try to find the pidl they passed in

            // Get the button in the toolbar that corresponds to this pidl.
            pidlButton = _GetButtonFromPidl(psmd->pidlItem, NULL, &i);
        }

        // Did we find this pidl in the toolbar?
        if (pidlButton)
        {

            int idCmd = GetButtonCmd(_hwndTB, i);

            // Yes, Get the information from that button.
            CMenuData* pmd = (CMenuData*)_IDToPibData(idCmd);

            if (pmd)
            {
                BOOL fRefresh = FALSE;
                DWORD dwFlagsUp = dwFlags;
                DWORD dwOldItemFlags = pmd->GetFlags();
                DWORD dwNewItemFlags = dwOldItemFlags;
                if ((dwFlags & SMINV_DEMOTE) && 
                    (!(dwOldItemFlags & SMIF_DEMOTED) || dwFlags & SMINV_FORCE))
                {
                    if (!(dwFlags & SMINV_NOCALLBACK))
                    {
                        CallCB(pidlButton, SMC_DEMOTE, 0, 0);
                        BroadcastIntelliMenuState(pidlButton, FALSE);
                    }
                    dwNewItemFlags |= SMIF_DEMOTED;
                    dwFlagsUp |= SMINV_DEMOTE;
                }
                else if ((dwFlags & SMINV_PROMOTE) && 
                         ((dwOldItemFlags & SMIF_DEMOTED) || dwFlags & SMINV_FORCE))
                {
                    if (!(dwFlags & SMINV_NOCALLBACK))
                    {
                        CallCB(pidlButton, SMC_PROMOTE, 0, 0);
                        BroadcastIntelliMenuState(pidlButton, TRUE);
                    }

                    dwNewItemFlags &= ~SMIF_DEMOTED;
                    dwFlagsUp |= SMINV_PROMOTE;
                }

                // Was it promoted and now Demoted or
                // Was it demoted and now promoted
                if ((dwNewItemFlags & SMIF_DEMOTED) ^
                     (dwOldItemFlags & SMIF_DEMOTED))
                {
                    fRefresh = TRUE;
                    if (dwNewItemFlags & SMIF_DEMOTED)
                    {
                        // Yes; Then decrement the Promoted count
                        _cPromotedItems--;

                        // If we're decementing, then we not have a demoted item.
                        _fHasDemotedItems = TRUE;

                        // Have we dropped off the face of the earth?
                        if (_cPromotedItems == 0)
                        {
                            dwFlagsUp |= SMINV_DEMOTE;
                            Expand(TRUE);
                        }
                        else
                        {
                            fRefresh = FALSE;
                        }
                    }
                    else
                    {
                        int cButtons = ToolBar_ButtonCount(_hwndMB);
                        _cPromotedItems++;
                        if (cButtons == _cPromotedItems)
                        {

                            // if the button count is the number of promoted items,
                            // then we can't have any demoted items
                            // then we need to reset the _fHasDemotedItems flag so that
                            // we don't get a chevron and stuff...

                            _fHasDemotedItems = FALSE;
                        }

                        dwFlagsUp |= SMINV_PROMOTE;
                        fRefresh = TRUE;
                    }

                }

                if (fRefresh || dwFlags & SMINV_FORCE)
                    IUnknown_RefreshParent(_pcmb->_punkSite, _pidl, dwFlagsUp);

                if (dwOldItemFlags != dwNewItemFlags || dwFlags & SMINV_FORCE)
                {
                    if (dwFlags & SMINV_NEXTSHOW || !_fShow)
                    {
                        _fRefreshInfo = TRUE;
                    }
                    else
                    {
                        // Since we updated the flags, set them into the cache
                        pmd->SetFlags(dwNewItemFlags);

                        // Based on the new flags, do we enable?
                        DWORD dwState = ToolBar_GetState(_hwndTB, idCmd);
                        dwState |= TBSTATE_ENABLED;
                        if (dwNewItemFlags & SMIF_DEMOTED &&
                            !_pcmb->_fExpanded)
                        {
                            // No; We're not expanded and this is a demoted item
                            dwState |= TBSTATE_HIDDEN;
                            dwState &= ~TBSTATE_ENABLED;
                            _fHasDemotedItems = TRUE;

                            // Just in case the chevron is not there, we should
                            // try and add it. This call will never add more than 1
                            _AddChevron();
                        }
                        else if (!_fHasDemotedItems)
                        {
                            _RemoveChevron();
                        }

                        // Adjust the state of the button in the toolbar.
                        ToolBar_SetState(_hwndTB, idCmd, dwState);

                        _ToolbarChanged();
                    }
                }
            }
        }

        // We handled this one.
        hres = S_OK;
    }

    return hres;
}


LRESULT CMenuSFToolbar::_DefWindowProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    switch (uMessage)
    {
    case WM_GETOBJECT:
        // Yet another poor design choice on the part of the accessibility team.
        // Typically, if you do not answer a WM_* you return 0. They choose 0 as their success
        // code.
        return _DefWindowProcMB(hwnd, uMessage, wParam, lParam);
        break;
    }

    return CSFToolbar::_DefWindowProc(hwnd, uMessage, wParam, lParam);
}

void CMenuSFToolbar::_SetFontMetrics()
{
    CMenuToolbarBase::_SetFontMetrics();

    if (_hwndPager && _pcmb->_pmbm)
        Pager_SetBkColor(_hwndPager, _pcmb->_pmbm->_clrBackground);
}

int CMenuSFToolbar::_GetBitmap(int iCommandID, PIBDATA pibdata, BOOL fUseCache)
{
    int iIcon = -1;


    // If we don't have a pibdata, or we can't get an icon return.
    if (!pibdata || pibdata->GetNoIcon())
        return -1;

    if (_dwFlags & SMSET_USEBKICONEXTRACTION)
    {
        LPITEMIDLIST pidlItem = pibdata->GetPidl();
        // If the caller is using background icon extraction, we need them to provide a
        // default icon that we are going to display until we get the real one. This is 
        // specifically to make favorites fast.
        if (_iDefaultIconIndex == -1)
        {
            TCHAR szIconPath [MAX_PATH];

            if (S_OK == CallCB(NULL, SMC_DEFAULTICON, (WPARAM)szIconPath, (LPARAM)&iIcon))
            {
                _iDefaultIconIndex = Shell_GetCachedImageIndex(szIconPath, iIcon, 0);
            }
        }

        iIcon = _iDefaultIconIndex;

        DWORD dwAttrib = 0;

        if (pidlItem && SUCCEEDED(_psf->GetAttributesOf(1, (LPCITEMIDLIST*)&pidlItem, &dwAttrib)))
        {
            if (dwAttrib & SFGAO_FOLDER)
                iIcon = II_FOLDER;
        }

        IShellTaskScheduler* pScheduler = _pcmb->_pmbState->GetScheduler();

        if (pScheduler)
        {
            IShellFolder* psf = NULL;
            LPITEMIDLIST pidlFolder = _pidl;
            LPITEMIDLIST pidlItemUnwrapped;

            // Since this can be an augmented shell folder, we should do the correct thing so that
            // the icon extraction with the full pidl takes place correctly. 
            if( _pasf2 && 
                S_OK == _pasf2->UnWrapIDList(pidlItem, 1, NULL, &pidlFolder, &pidlItemUnwrapped, NULL))
            {

                pidlItem = ILCombine(pidlFolder, pidlItemUnwrapped);
                ILFree(pidlFolder);
                ILFree(pidlItemUnwrapped);
            }
            else
            {
                psf = _psf;
            }

            // AddIconTask takes ownership of the pidl when psf is NULL and will free it.
            HRESULT hres = AddIconTask(pScheduler, psf, pidlFolder, pidlItem, 
                s_IconCallback, (LPVOID)_hwndTB, iCommandID, NULL);

            pScheduler->Release();

            if (FAILED(hres))
            {
                // If that call failed for some reason, default to the shell32 impl.
                goto DoSyncMap;
            }
        }
        else
            goto DoSyncMap;

    }
    else
    {
    DoSyncMap:
        iIcon = CSFToolbar::_GetBitmap(iCommandID, pibdata, fUseCache);
    }

    return iIcon;
} 

void CMenuSFToolbar::s_IconCallback(LPVOID pvData, UINT uId, UINT iIconIndex)
{
    HWND hwnd = (HWND)pvData;
    if (hwnd && IsWindow(hwnd))
    {
        DAD_ShowDragImage(FALSE);
        SendMessage(hwnd, TB_CHANGEBITMAP, uId, iIconIndex);
        DAD_ShowDragImage(TRUE);
    }

}

HWND CMenuSFToolbar::GetHWNDForUIObject()   
{ 
    HWND hwnd = _pcmb->_pmbState->GetWorkerWindow(_hwndMB);
    if (hwnd)
        ::SetWindowPos(hwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE);
    return hwnd;
}

HWND CMenuSFToolbar::CreateWorkerWindow()
{ 
    return GetHWNDForUIObject();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\legacy\qlink.cpp ===
#include "priv.h"
#include "sccls.h"
#include "itbar.h"
#include "itbdrop.h"
#include "qlink.h"
#include "resource.h"
#include "dpastuff.h"

#include "bands.h"
#include "isfband.h"
#include "bandprxy.h"
#include "uemapp.h"

#include "mluisupp.h"

#define SUPERCLASS CISFBand

#define DM_PERSIST      DM_TRACE        // trace IPS::Load, ::Save, etc.


class CQuickLinks : public CISFBand
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void) { return CISFBand::AddRef(); };
    virtual STDMETHODIMP_(ULONG) Release(void){ return CISFBand::Release(); };
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    
    // *** IPersistStream methods ***
    virtual STDMETHODIMP GetClassID(CLSID *pClassID);
    virtual STDMETHODIMP Load(IStream *pStm);
    virtual STDMETHODIMP Save(IStream *pstm, BOOL fClearDirty);
    
    // *** IDockingWindow methods (override) ***
    virtual STDMETHODIMP ShowDW(BOOL fShow);
    virtual STDMETHODIMP CloseDW(DWORD dw) { return CISFBand::CloseDW(dw); };
    
    // *** IObjectWithSite methods ***
    virtual STDMETHODIMP SetSite(IUnknown* punkSite) { return CISFBand::SetSite(punkSite); };

    // *** IOleCommandTarget ***
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
                              DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn,
                              VARIANTARG *pvarargOut);
    
    // *** IDeskBand methods ***
    virtual STDMETHODIMP GetBandInfo(DWORD dwBandID, DWORD fViewMode, 
                                   DESKBANDINFO* pdbi);

    // *** IDelegateDropTarget ***
    virtual HRESULT OnDropDDT(IDropTarget *pdt, IDataObject *pdtobj, DWORD * pgrfKeyState, POINTL pt, DWORD *pdwEffect);
protected:    
    CQuickLinks();
    virtual ~CQuickLinks();

    HRESULT _GetTitleW(LPWSTR pwzTitle, DWORD cchSize);
    HRESULT _InternalInit(void);

    virtual HRESULT _LoadOrderStream();
    virtual HRESULT _SaveOrderStream();
    virtual BOOL    _AllowDropOnTitle() { return TRUE; };
    virtual HRESULT _GetIEnumIDList(DWORD dwEnumFlags, IEnumIDList **ppenum);

private:    
    BITBOOL    _fIsInited :1;
    BITBOOL    _fSingleLine :1;

    friend HRESULT CQuickLinks_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);    // for ctor
};

#define MAX_QL_SITES            5   // Number of Sites on the quick link bar

#define SZ_REGKEY_SPECIALFOLDERS  TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders")

HRESULT SHGetSpecialFolderPathEx(LPTSTR pszPath, DWORD cchSize, DWORD dwCSIDL, LPCTSTR pszFolderName)
{
    HRESULT hr = S_OK;
    
    if (SHGetSpecialFolderPath(NULL, pszPath, CSIDL_FAVORITES, TRUE))
        return hr;

    cchSize *= sizeof(TCHAR);   // Count of chars to count of bytes.
    if (ERROR_SUCCESS != SHGetValue(HKEY_CURRENT_USER, SZ_REGKEY_SPECIALFOLDERS, pszFolderName, NULL, pszPath, &cchSize))
        hr = E_FAIL;

    TraceMsg(TF_BAND|TF_GENERAL, "CQuickLinks SHGetSpecialFolderPath(CSIDL_FAVORITES), Failed so getting Fav dir from registry. Path=%s; hr=%#8lx", pszPath, hr);
    
    return hr;
}

#define LINKS_FOLDERNAME_KEY   TEXT("Software\\Microsoft\\Internet Explorer\\Toolbar")
#define LINKS_FOLDERNAME_VALUE TEXT("LinksFolderName")

// _GetTitleW and QuickLinks_GetFolder call this. 
// if we ever go back to ANSI days we'll get a build break
// right now we are saving some space by not having A version that's not used
void QuickLinks_GetName(LPTSTR pszName, DWORD cchSize, BOOL bSetup)
{
    DWORD cb = cchSize * SIZEOF(TCHAR);
    // try to get the name of the folder from the registry (in case of upgrade to a different
    // language we cannot use the resource)
    if (SHGetValue(HKEY_CURRENT_USER, LINKS_FOLDERNAME_KEY, LINKS_FOLDERNAME_VALUE, NULL, (void *)pszName, &cb) != ERROR_SUCCESS)
    {
        // no luck, try the HKLM if we are doing per user registration, maybe setup stored the old links folder name there
        cb = cchSize * SIZEOF(TCHAR);
        if (!bSetup || SHGetValue(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion"), TEXT("LinkFolderName"), NULL, (void *)pszName, &cb) != ERROR_SUCCESS)
        {
            // if everything else fails load it from the resource
            MLLoadString(IDS_QLINKS, pszName, cchSize);
        }
    }
}

HRESULT QuickLinks_GetFolder(LPTSTR pszPath, DWORD cchSize, BOOL bSetup = FALSE)
{
    TCHAR szQuickLinks[MAX_PATH];

    if (SUCCEEDED(SHGetSpecialFolderPathEx(pszPath, cchSize, CSIDL_FAVORITES, TEXT("Favorites"))))
    {
        QuickLinks_GetName(szQuickLinks, ARRAYSIZE(szQuickLinks), bSetup);
        PathCombine(pszPath, pszPath, szQuickLinks);
        return S_OK;
    }    
    
    return E_FAIL;
}

#define QL_BUFFER (MAX_QL_TEXT_LENGTH + MAX_URL_STRING + MAX_TOOLTIP_STRING + 3)

//
// Load strings needed for quick links
//
// returns TRUE/FALSE if it was user specified (false used to load the default
// urls, but now we leave that to branding dll
BOOL QLLoadLinkName(HUSKEY hUSKey, int i, LPTSTR pszTitle, UINT cchTitle, LPTSTR pszURL, UINT cchURL)
{
    CHAR szScratch[QL_BUFFER];
    DWORD dwcbData = SIZEOF(szScratch);
    CHAR * pszTemp;
    TCHAR szRegValues[5];

    // In IE3, links did not have its own folder.  Instead, links were stored in the registry as a
    // set of binary streams of ANSI strings.
    wnsprintf(szRegValues, ARRAYSIZE(szRegValues), TEXT("%d"), i+1);
    if (hUSKey && 
        (ERROR_SUCCESS == SHRegQueryUSValue(hUSKey, szRegValues, NULL, (LPBYTE)szScratch, &dwcbData, FALSE, NULL, 0)))
    {
        int nNULLs = 0;
        pszTemp = szScratch;
        DWORD j;
        for (j = 0; j < dwcbData; j++)
        {
#ifdef MAINWIN
            // Because of the limitations of the MainWin registry, we'll put '*' instead of '\0'.
            if (*pszTemp == TEXT('*'))
                *pszTemp = '\0';
#endif
            nNULLs += (UINT)(*pszTemp++ == TEXT('\0'));
        }

        // make sure we have 3 strings with a double NULL at the end
        if (nNULLs > 3)
        {
            pszTemp = szScratch;
            SHAnsiToTChar(pszTemp, pszTitle, cchTitle);
            pszTemp += lstrlenA(pszTemp) + 1;
            SHAnsiToTChar(pszTemp, pszURL, cchURL);
            return TRUE;
        }
    }
    return FALSE;
}

void ImportQuickLinks()
{
    TCHAR szQuickLinksDir[MAX_PATH];

    if (FAILED(QuickLinks_GetFolder(szQuickLinksDir, ARRAYSIZE(szQuickLinksDir), TRUE)))
        return;
        
    // need to write the folder name to the registry so we can use it w/ different plug ui languages
    LPTSTR pszQLinks;
    DWORD cb;

    PathRemoveBackslash(szQuickLinksDir);
    pszQLinks = PathFindFileName(szQuickLinksDir);
    if (pszQLinks)
    {
        cb = (lstrlen(pszQLinks)+1) * sizeof(TCHAR);
        SHSetValue(HKEY_CURRENT_USER, LINKS_FOLDERNAME_KEY, LINKS_FOLDERNAME_VALUE, REG_SZ, (void *)pszQLinks, cb);
    }

    if (!PathFileExists(szQuickLinksDir) &&
        CreateDirectory(szQuickLinksDir, NULL))
    {
        HUSKEY hUSKey = NULL;

        SHRegOpenUSKey(TEXT("Software\\Microsoft\\Internet Explorer\\Toolbar\\Links"), KEY_READ, NULL, &hUSKey, FALSE);

        for (int i = 0; i < MAX_QL_SITES; i++)
        {
            // this was user specified...  convert it
            LPITEMIDLIST pidl;
            TCHAR szURLTemp[MAX_URL_STRING];
            TCHAR szTitle[MAX_QL_TEXT_LENGTH];

            if (QLLoadLinkName(hUSKey, i, szTitle, ARRAYSIZE(szTitle), szURLTemp, ARRAYSIZE(szURLTemp)))
            {
                WCHAR szURL[MAX_URL_STRING];
                if (SUCCEEDED(URLSubstitution(szURLTemp, szURL, ARRAYSIZE(szURL), URLSUB_ALL)) &&
                    SUCCEEDED(IECreateFromPath(szURL, &pidl)))
                {
                    CreateShortcutInDir(pidl, szTitle, szQuickLinksDir, NULL, FALSE);
                    ILFree(pidl);
                }
            }
        }
        // we found the key, there's something to migrate
        if (hUSKey)
            SHRegCloseUSKey(hUSKey);

        // all converted, delete the key
        SHDeleteKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Internet Explorer\\Toolbar\\Links"));
    }
    else
    {
        // ie4 -> ieX upgrade
        // create a value in hkcu\sw\ms\ie\toolbar to indicate that we should preserve the order from the links stream
        // not the one from the favorites\links that we are using for links starting w/ ie5
        BOOL bVal = TRUE;
        // we don't care if this fails. if it does we'll just just favorites\links order stream
        SHSetValue(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Internet Explorer\\Toolbar"), 
                   TEXT("SaveLinksOrder"), REG_BINARY, (DWORD *)&bVal, SIZEOF(bVal));
    }
}

HRESULT CQuickLinks::_InternalInit(void)
{
    if (!_fIsInited && !_psf)
    {
        LPITEMIDLIST pidlQLinks;
        TCHAR szPath[MAX_PATH];

        QuickLinks_GetFolder(szPath, ARRAYSIZE(szPath));
        if (!PathFileExists(szPath))
            CreateDirectory(szPath, NULL);
        if (SUCCEEDED(IECreateFromPath(szPath, &pidlQLinks)))
        {
            InitializeSFB(NULL, pidlQLinks);
            ILFree(pidlQLinks);
        }
    }
    _fIsInited = TRUE;

    return S_OK;
}

CQuickLinks::CQuickLinks() :
    SUPERCLASS()
{
    
#ifdef DEBUG
    if (IsFlagSet(g_dwBreakFlags, BF_ONAPIENTER))
    {
        TraceMsg(TF_ALWAYS, "Stopping in CQuickLinks ctor");
        DEBUG_BREAK;
    }
#endif
    
    ASSERT(!_fIsInited);
    _fCascadeFolder = TRUE;
    _fVariableWidth = TRUE;

    _pguidUEMGroup = &UEMIID_BROWSER;
    
}

CQuickLinks::~CQuickLinks()
{
}

STDAPI CQuickLinks_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory
    CQuickLinks * p = new CQuickLinks();
    if (p) 
    {
        *ppunk = SAFECAST(p, IDeskBand *);
        return NOERROR;
    }
    *ppunk = NULL;
    return E_OUTOFMEMORY;
}

HRESULT CQuickLinks::_LoadOrderStream()
{
    HRESULT hr = E_FAIL;

    if (_pidl && _psf) {
        IStream* pstm = OpenPidlOrderStream((LPCITEMIDLIST)CSIDL_FAVORITES, _pidl, REG_SUBKEY_FAVORITESA, STGM_READ);

        if (pstm) {
            OrderList_Destroy(&_hdpaOrder);

            hr = OrderList_LoadFromStream(pstm, &_hdpaOrder, _psf);

            pstm->Release();
        }
    }

    return hr;
}

HRESULT CQuickLinks::_SaveOrderStream()
{
    HRESULT hr = E_FAIL;

    if (_pidl && (_hdpa || _hdpaOrder)) {
        IStream* pstm = OpenPidlOrderStream((LPCITEMIDLIST)CSIDL_FAVORITES, _pidl, REG_SUBKEY_FAVORITESA, STGM_CREATE | STGM_WRITE);

        if (pstm) {
            hr = OrderList_SaveToStream(pstm, (_hdpa ? _hdpa : _hdpaOrder), _psf);

            pstm->Release();
        }
    }

    if (SUCCEEDED(hr))
        hr = SUPERCLASS::_SaveOrderStream();

    return hr;
}

HRESULT CQuickLinks::_GetIEnumIDList(DWORD dwEnumFlags, IEnumIDList **ppenum)
{
    HRESULT hres;
    
    ASSERT(_psf);
    // Pass in a NULL hwnd so the enumerator does not show any UI while
    // we're filling a band.    
    hres = IShellFolder_EnumObjects(_psf, NULL, dwEnumFlags, ppenum);
    // we could have failed because our folder does not exist
    // that can happen if someone delted/renamed links while there is 
    // stream in the registry that saves the pidl - we get the pidl and
    // bind to it (bind does not hit the disk so it succeeds even though
    // the file does not exist
    if (FAILED(hres) && hres != E_OUTOFMEMORY)
    {
        TCHAR szPath[MAX_PATH];

        ASSERT(_pidl);
        if (SHGetPathFromIDList(_pidl, szPath) && !PathFileExists(szPath))
        {
            LPITEMIDLIST pidlQLinks;
            
            QuickLinks_GetFolder(szPath, ARRAYSIZE(szPath));
            if (!PathFileExists(szPath))
                CreateDirectory(szPath, NULL);
            if (SUCCEEDED(IECreateFromPath(szPath, &pidlQLinks)))
            {
                if (SUCCEEDED(InitializeSFB(NULL, pidlQLinks)))
                {
                    hres = _psf->EnumObjects(NULL, dwEnumFlags, ppenum);
                }
                ILFree(pidlQLinks);
            }
        }
    }
    return hres;
}

//*** CQuickLinks::IPersistStream
HRESULT CQuickLinks::Load(IStream *pstm)
{
    HRESULT hr = S_OK;

    hr = SUPERCLASS::Load(pstm);

    // This forces a refresh
    _fIsInited = FALSE;
    ATOMICRELEASE(_psf);
    _InternalInit();



    // if we are on our first run through (i.e. this reg key exists)
    // we load the order stream from our old location (used in ie4) and avoid overwriting it w/ favorites stream
    // so user can have their custom order preserved on upgrade (they are more likely to customize links bar 
    // order then favorites/links so we picked that one)
    if (SHGetValue(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Internet Explorer\\Toolbar"), 
                   TEXT("SaveLinksOrder"), NULL, NULL, NULL) == ERROR_SUCCESS)
    {
        SHDeleteValue(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Internet Explorer\\Toolbar"), TEXT("SaveLinksOrder"));
        // must persist old order stream in the new location (fav/links)
        _SaveOrderStream();
    }
    else
    {
        _LoadOrderStream();
    }

    return hr;
}

HRESULT CQuickLinks::Save(IStream *pstm, BOOL fClearDirty)
{
    HRESULT hr = SUPERCLASS::Save(pstm, fClearDirty);

    _SaveOrderStream();

    return hr;
}

HRESULT CQuickLinks::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_QuickLinks;
    return S_OK;
}

// *** IUnknown Interface ***
HRESULT CQuickLinks::QueryInterface(REFIID riid, void **ppvObj)
{
    return SUPERCLASS::QueryInterface(riid, ppvObj);
}

// command target
STDMETHODIMP CQuickLinks::Exec(const GUID *pguidCmdGroup, DWORD nCmdID,
    DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    HRESULT hres = S_FALSE;
    if (pguidCmdGroup)
    {
        if (IsEqualGUID(*pguidCmdGroup, CLSID_QuickLinks)) 
        {
            switch (nCmdID) 
            {
            case QLCMD_SINGLELINE:
                _fSingleLine = (nCmdexecopt == 1);
                return S_OK;
            }
        }
        else if (IsEqualGUID(*pguidCmdGroup, CGID_ISFBand))
        {
            switch(nCmdID)
            {
            case ISFBID_SETORDERSTREAM:
                hres = SUPERCLASS::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
                _SaveOrderStream();
                break;
            }
        }
    }

    if (hres ==  S_FALSE)
        hres = SUPERCLASS::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);

    return hres;
}

// *** IDockingWindow Interface ***
HRESULT CQuickLinks::ShowDW(BOOL fShow)
{
    if (fShow)
        _InternalInit();

    return SUPERCLASS::ShowDW(fShow);
}

    
HRESULT CQuickLinks::_GetTitleW(LPWSTR pwzTitle, DWORD cchSize)
{
    QuickLinks_GetName(pwzTitle, cchSize, FALSE);
    return S_OK;
}


HRESULT CQuickLinks::GetBandInfo(DWORD dwBandID, DWORD fViewMode, DESKBANDINFO* pdbi) 
{
   HRESULT hres = SUPERCLASS::GetBandInfo(dwBandID, fViewMode, pdbi);
   
   if (_hwndTB && _fSingleLine) {
       LRESULT lButtonSize = SendMessage(_hwndTB, TB_GETBUTTONSIZE, 0, 0L);
       pdbi->ptMinSize.y = HIWORD(lButtonSize);
       
       pdbi->dwModeFlags &= ~DBIMF_VARIABLEHEIGHT;
   }
   return hres;
    
}

HRESULT CQuickLinks::OnDropDDT(IDropTarget *pdt, IDataObject *pdtobj, DWORD * pgrfKeyState, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hr;
    BOOL    fIsSafe = TRUE;

    // if we are not the source of the drop and the Links folder does not exist we need to create it
    if (_iDragSource == -1)
    {
        TCHAR szPath[MAX_PATH];

        QuickLinks_GetFolder(szPath, ARRAYSIZE(szPath));
        if (!PathFileExists(szPath))
            CreateDirectory(szPath, NULL);

        LPITEMIDLIST pidl;

        if (SUCCEEDED(SHPidlFromDataObject(pdtobj, &pidl, NULL, 0)))
        {
            fIsSafe = IEIsLinkSafe(_hwnd, pidl, ILS_LINK);
            ILFree(pidl);
        }

    }

    if (fIsSafe)
    {
        hr = SUPERCLASS::OnDropDDT(pdt, pdtobj, pgrfKeyState, pt, pdwEffect);
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\legacy\mnstatic.h ===
#ifndef MENUST
#define MENUST

#include "mnbase.h"
#include "cwndproc.h"
#include "droptgt.h"

class CMenuBand;

class CMenuStaticToolbar : public CMenuToolbarBase,
                           public CDelegateDropTarget,
                           public CNotifySubclassWndProc
{
public:

    // *** IUnknown (override) ***
    virtual STDMETHODIMP_(ULONG) AddRef(void) { return CMenuToolbarBase::AddRef(); };
    virtual STDMETHODIMP_(ULONG) Release(void) { return CMenuToolbarBase::Release(); };
    virtual STDMETHODIMP QueryInterface(REFIID riid, void** ppvObj);

    // *** CDelegateDropTarget Methods ***
    virtual HRESULT GetWindowsDDT (HWND * phwndLock, HWND * phwndScroll);
    virtual HRESULT HitTestDDT (UINT nEvent, LPPOINT ppt, DWORD_PTR * pdwId, DWORD *pdwEffect);
    virtual HRESULT GetObjectDDT (DWORD_PTR dwId, REFIID riid, LPVOID * ppvObj);
    virtual HRESULT OnDropDDT (IDropTarget *pdt, IDataObject *pdtobj, 
                            DWORD * pgrfKeyState, POINTL pt, DWORD *pdwEffect);

    //*** IWinEventHandler (override) ***
    virtual STDMETHODIMP IsWindowOwner(HWND hwnd);
    virtual STDMETHODIMP OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres);

    // Other public methods
    virtual void GetSize(SIZE* psize);

    virtual void v_SendMenuNotification(UINT idCmd, BOOL fClear);
    virtual BOOL v_TrackingSubContextMenu();
    virtual BOOL v_UpdateIconSize(UINT uIconSize, BOOL fUpdateButtons);
    virtual void v_Show(BOOL fShow, BOOL fForceUpdate);
    virtual void v_UpdateButtons(BOOL fNegotiateSize);

    virtual STDMETHODIMP OnChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    virtual void CreateToolbar(HWND hwndParent);

    virtual void v_Close(); // override
    virtual void    v_OnEmptyToolbar();        // override
    virtual void v_OnDeleteButton(LPVOID pData);
    virtual HRESULT v_InvalidateItem(LPSMDATA psmd, DWORD dwFlags);

    virtual HRESULT GetMenu(HMENU* phmenu, HWND* phwnd, DWORD* pdwFlags);
    virtual HRESULT SetMenu(HMENU hmenu, HWND hwnd, DWORD dwFlags);
    inline virtual BOOL ShowAmpersand()   { return FALSE; }

    CMenuStaticToolbar(CMenuBand* pmb, HMENU hmenu, HWND hwnd, UINT idCmd, DWORD dwFlags);

protected:
    class CMenuStaticData
    {
    public:
        ~CMenuStaticData();
        void SetSubMenu(IUnknown* punk);
        HRESULT GetSubMenu(const GUID* pguidService, REFIID riid, void** ppvObj);
        IUnknown*   _punkSubMenu;
        DWORD       _dwFlags;
    };

    HWND    _hwndMenuOwner;
    HWND    _hwndDD;
    HMENU   _hmenu;
    UINT    _idCmd;
    int     _iDragOverButton;
    IContextMenu* _pcm;

    BITBOOL _fHasTopSep: 1;
    BITBOOL _fHasBottomSep: 1;
    BITBOOL _fTopSepRemoved: 1;
    BITBOOL _fBottomSepRemoved: 1;
    BITBOOL _fDirty: 1;


    LRESULT _OnAccelerator(NMCHAR* pnmChar);
    LRESULT (*_lpfnWndProc)(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    CMenuStaticData* _IDToData(int idCmd);
    HRESULT CallCB(UINT idCmd, DWORD dwMsg, WPARAM wParam, LPARAM lParam);

protected:
    virtual ~CMenuStaticToolbar();

    // Window Proc and message handlers
    virtual LRESULT _DefWindowProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
    virtual LRESULT _OnNotify(LPNMHDR pnm);

    virtual int  v_GetDragOverButton()
        { return _iDragOverButton; };

    virtual HRESULT v_GetInfoTip(int iCmd, LPTSTR psz, UINT cch);
    virtual HRESULT v_CallCBItem(int idtCmd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual HRESULT v_GetState(int idtCmd, LPSMDATA psmd);
    virtual HRESULT v_ExecItem(int iCmd);
    virtual DWORD v_GetFlags(int iCmd);
    virtual void v_Refresh();
    virtual HRESULT v_GetSubMenu(int iCmd, const GUID* pguidService, REFIID riid, void** ppvObj);
    virtual HRESULT v_CreateTrackPopup(int idCmd, REFIID riid, void** ppvObj);

    LRESULT _OnGetObject(NMOBJECTNOTIFY*);
    LRESULT _OnContextMenu(WPARAM wParam, LPARAM lParam);
    void _FillToolbar();
    void _OnGetDispInfo(LPNMHDR pnm, BOOL fUnicode);
    void _Insert(int iIndex, MENUITEMINFO* pmii);
    void _CheckSeparators();
};


#endif // MENUST
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\legacy\mnbase.h ===
#ifndef MNBASE
#define MNBASE


// Characters for _DrawMenuGlyph
#define CH_MENUARROWA    '8'
#define CH_MENUARROW     TEXT(CH_MENUARROWA)
#define CH_MENUCHECKA    'a'
#define CH_MENUCHEVRONA  187

class CMenuBand;    // Forward Declare
class CMenuBandMetrics;

#define LIST_GAP 8      // from Observation

class CMenuToolbarBase: public IWinEventHandler, public IObjectWithSite
{
public:

    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, void** ppvObj);

    // *** IObjectWithSite methods ***
    virtual STDMETHODIMP SetSite(IUnknown* punkSite);
    virtual STDMETHODIMP GetSite(REFIID riid, void ** ppvSite);

    // *** IWinEventHandler methods ***
    virtual STDMETHODIMP IsWindowOwner(HWND hwnd) PURE;
    virtual STDMETHODIMP OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres);

    // Other public methods

    CMenuToolbarBase(CMenuBand* pmb, DWORD dwFlags);

    // Returns the HWND and Converts the pt to child.
    virtual void v_ForwardMouseMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual void v_SendMenuNotification(UINT idCmd, BOOL fClear) PURE;
    virtual BOOL v_TrackingSubContextMenu() PURE;
    virtual void v_Show(BOOL fShow, BOOL fForceUpdate);
    virtual BOOL v_UpdateIconSize(UINT uIconSize, BOOL fUpdateButtons) PURE;
    virtual void v_UpdateButtons(BOOL fNegotiateSize) PURE;
    virtual HRESULT v_GetSubMenu(int iCmd, const GUID* pguidService, REFIID riid, void** pObj) PURE;
    virtual HRESULT v_CallCBItem(int idtCmd, UINT uMsg, WPARAM wParam, LPARAM lParam) PURE;
    virtual HRESULT v_GetState(int idtCmd, LPSMDATA psmd) PURE;
    virtual HRESULT v_ExecItem(int iCmd) PURE;
    virtual DWORD v_GetFlags(int iCmd) PURE;
    virtual void v_Refresh() PURE;
    virtual void v_Close();
    virtual void v_OnEmptyToolbar();
    virtual void v_OnDeleteButton(LPVOID pData) {};
    virtual HRESULT v_InvalidateItem(LPSMDATA psmd, DWORD dwFlags) 
        { return E_NOTIMPL; };

    virtual void NegotiateSize();
    virtual void SetWindowPos(LPSIZE psize, LPRECT prc, DWORD dwFlags);
    virtual void GetSize(SIZE*);
    virtual void CreateToolbar(HWND hwndParent);
    virtual void SetParent(HWND hwndParent);
    virtual HRESULT GetShellFolder(LPITEMIDLIST* ppidl, REFIID riid, void** ppvObj) {return E_FAIL;};
    virtual HRESULT GetMenu(HMENU* phmenu, HWND* phwnd, DWORD* pdwFlags) { return E_FAIL; };
    virtual HRESULT SetMenu(HMENU hmenu, HWND hwnd, DWORD dwFlags) { return E_FAIL;};
    virtual void Expand(BOOL fExpand) {};

    HRESULT GetSubMenu(int idCmd, GUID* pguidService, REFIID riid, void** ppvObj);

    HRESULT PositionSubmenu(int idCmd);
    void Activate(BOOL fActivate);
    void SetMenuBandMetrics(CMenuBandMetrics* pmbm);
    void PostPopup(int idCmd, BOOL bSetItem, BOOL bInitialSelect);
    void PopupClose(void);
    HRESULT PopupOpen(int nCmd);
    void PopupHelper(int idCmd, BOOL bInitialSelect);
    void KillPopupTimer();
    void SetToTop(BOOL bToTop);
    void EmptyToolbar();        // override
    DWORD GetFlags(void)          { return _dwFlags; };
    BOOL DontShowEmpty()           { return _fDontShowEmpty; };
    void DontShowEmpty(BOOL fDontShowEmpty) { _fDontShowEmpty = BOOLIFY(fDontShowEmpty); };
    BOOL GetChevronID()               { return _idCmdChevron;  };
    int GetValidHotItem(int iDir, int iIndex, int iCount, DWORD dwFlags);
    BOOL SetHotItem(int iDir, int iIndex, int iCount, DWORD dwFlags);
    void SetKeyboardCue();
    inline virtual BOOL ShowAmpersand() { return FALSE; }

    virtual ~CMenuToolbarBase() {};

    BOOL IsEmpty()      { return _fEmpty; };

    HWND        _hwndMB;
   
protected:
    static void s_FadeCallback(DWORD dwStep, LPVOID pvParam);

    virtual void v_CalcWidth(int* pcxMin, int* pcxMax);
    virtual int  v_GetDragOverButton() PURE;
    virtual HRESULT v_GetInfoTip(int iCmd, LPTSTR psz, UINT cch) PURE;
    virtual HRESULT v_CreateTrackPopup(int idCmd, REFIID riid, void** ppvObj) PURE;
    
    // Window Proc Overrides
    LRESULT _DropDownOrExec(UINT idCmd, BOOL bKeyboard);
    LRESULT _OnCustomDraw(NMCUSTOMDRAW * pnmcd);
    void    _PaintButton(HDC hdc, int idCmd, LPRECT prc, DWORD dwMBIF);
    LRESULT _OnWrapHotItem(NMTBWRAPHOTITEM* pnmwh);
    LRESULT _OnWrapAccelerator(NMTBWRAPACCELERATOR* pnmwa);
    LRESULT _OnDupAccelerator(NMTBDUPACCELERATOR* pnmda);
    virtual LRESULT _OnHotItemChange(NMTBHOTITEM * pnmhot);
    virtual LRESULT _OnNotify(LPNMHDR pnm);
    virtual LRESULT _OnDropDown(LPNMTOOLBAR pnmtb);
    virtual LRESULT _OnTimer( WPARAM wParam );
    virtual void _FlashChevron();
    virtual LRESULT _DefWindowProcMB(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL    _OnKey(BOOL bDown, UINT vk, UINT uFlags);
    void    _OnSelectArrow(int iDir);
    void    _FireEvent(BYTE bEvent);

    // Utility Functions
    void    _DoPopup(int idCmd, BOOL bInitialSelect);
    virtual void    _SetFontMetrics();
    virtual void    _SetToolbarState();
    void    _PressBtn(int idBtn, BOOL bDown);
    HRESULT _SetMenuBand(IShellMenu* psm);
    BOOL    _SetTimer(int nTimer);

    void    _DrawMenuArrowGlyph( HDC hdc, RECT * prc, COLORREF rgbText );
    void    _DrawMenuGlyph( HDC hdc, HFONT hFont, RECT * prc, 
                               CHAR ch, COLORREF rgbText,
                               LPSIZE psize);

    int     _CalcChevronSize();
    void    _DrawChevron(HDC hdc, LPRECT prect, BOOL fFocus, BOOL fSelected);

    BOOL    _HandleObscuredItem(int idCmd);

    CMenuBand*  _pcmb;
    DEBUG_CODE (int _cRef);     // To debug references to the sub objects.
    DWORD       _dwFlags;           // SMSET_* flags
    UINT        _uIconSizeMB;
    UINT        _nItemTimer;
    int         _idCmdChevron;     // -1 if no chevron exists
    int         _cPromotedItems;    // Number of promoted items.
    BYTE        _cFlashCount;
    int         _idCmdLastClicked;
    int         _iLastClickedTime;
    int         _idCmdDragging;        

    BITBOOL     _fHasDemotedItems: 1;
    BITBOOL     _fVerticalMB: 1;
    BITBOOL     _fTopLevel: 1;
    BITBOOL     _fEmpty : 1;
    BITBOOL     _fHasSubMenu: 1;
    BITBOOL     _fEditMode : 1;
    BITBOOL     _fClickHandled: 1;
    BITBOOL     _fProcessingWrapHotItem: 1;
    BITBOOL     _fEmptyingToolbar : 1;
    BITBOOL     _fMulticolumnMB : 1;
    BITBOOL     _fExpandTimer: 1;   // There is an expand timer.
    BITBOOL     _fIgnoreHotItemChange: 1;
    BITBOOL     _fShowMB: 1;
    BITBOOL     _fFirstTime: 1;
    BITBOOL     _fHasDrop: 1;
    BITBOOL     _fRefreshInfo: 1;
    BITBOOL     _fDontShowEmpty: 1;
    BITBOOL     _fSuppressUserMonitor: 1;
    BITBOOL     _fHorizInVerticalMB: 1;     // TRUE: Don't set EX_Vertical on the Toolbar
};


int     GetButtonCmd(HWND hwndTB, int iPos);
void*   ItemDataFromPos(HWND hwndTB, int iPos);
BOOL    SetHotItem(HWND hwnd, int iDir, int iIndex, int iCount, DWORD dwFlags);
long    GetIndexFromChild(BOOL fTop, int iIndex);

// UEM Parameters
#define UEM_TIMEOUT         0
#define UEM_HOT_ITEM        1
#define UEM_HOT_FOLDER      2

#define UEM_RESET           -1

#endif  // MNBASE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\legacy\qlink.h ===
#ifndef QLINK_H_
#define QLINK_H_

// Length of the text under each quick links
#define MAX_QL_TEXT_LENGTH      256
#define MAX_QL_WIDTH            92


HRESULT CQuickLinks_CreateInstance(IDeskBand **ppunk);
#define QLCMD_SINGLELINE 1

#endif // QLINK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\legacy\mnfolder.h ===
#ifndef MENUSF
#define MENUSF

#include "mnbase.h"
#include "sftbar.h"

class CMenuData : public IBDATA
{
protected:
    IUnknown* _punkSubmenu;

public:
    CMenuData(PORDERITEM poi) : IBDATA(poi) {};
    virtual ~CMenuData();

    void SetSubMenu(IUnknown* pmb2);
    HRESULT GetSubMenu(const GUID* pguidService, REFIID riid, void**);
};

class CMenuBand;

class CMenuSFToolbar :  public CSFToolbar,
                        public CMenuToolbarBase
{
public:

    // *** IUnknown (override) ***
    //   This deliberately forwards AddRef and Release to CMenuToolbarBase, and
    //   forwards QI separately to CSFToolbar.
    virtual STDMETHODIMP_(ULONG) AddRef(void) { return CMenuToolbarBase::AddRef(); };
    virtual STDMETHODIMP_(ULONG) Release(void) { return CMenuToolbarBase::Release(); };
    virtual STDMETHODIMP QueryInterface(REFIID riid, void** ppvObj);

    // *** IObjectWithSite methods ***
    virtual STDMETHODIMP SetSite(IUnknown* punkSite);

    // *** IShellChangeNotify methods ***
    virtual STDMETHODIMP OnChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);

    // *** IWinEventHandler methods (override) ***
    virtual STDMETHODIMP IsWindowOwner(HWND hwnd);
    virtual STDMETHODIMP OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres);

    // *** CDelegateDropTarget methods ***
    virtual STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    virtual STDMETHODIMP DragLeave(void);
    virtual HRESULT HitTestDDT (UINT nEvent, LPPOINT ppt, DWORD_PTR * pdwId, DWORD *pdwEffect);
    virtual HRESULT GetObjectDDT (DWORD_PTR dwId, REFIID riid, LPVOID * ppvObj);
    virtual HRESULT OnDropDDT (IDropTarget *pdt, IDataObject *pdtobj, DWORD * pgrfKeyState, POINTL pt, DWORD *pdwEffect);

    // Other public methods
    virtual HWND v_GetHWND() 
        { return _hwndTB; };

    virtual void v_ForwardMouseMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual void v_SendMenuNotification(UINT idCmd, BOOL fClear);
    virtual BOOL v_TrackingSubContextMenu()  { return (BOOL) ( _pcm2 ? 1 : 0 );}; // Win64: should be ok since _pcm2 used as boolean in all contexts
    virtual BOOL v_UpdateIconSize(UINT uIconSize, BOOL fUpdateButtons);
    virtual void v_Close();
    virtual void v_Show(BOOL fShow, BOOL fForceUpdate);
    virtual void v_UpdateButtons(BOOL fNegotiateSize);
    virtual void NegotiateSize();
    virtual void Expand(BOOL fExpand);

    virtual void GetSize(SIZE* size);
    virtual void SetWindowPos(LPSIZE psize, LPRECT prc, DWORD dwFlags);
    virtual void CreateToolbar(HWND hwndParent);

    virtual void    SetParent(HWND hwndParent);
    virtual HRESULT GetShellFolder(LPITEMIDLIST* ppidl, REFIID riid, void** ppvObj);
    virtual void    v_OnEmptyToolbar();        // override
    virtual void v_OnDeleteButton(LPVOID pData);
    virtual HRESULT v_InvalidateItem(LPSMDATA psmd, DWORD dwFlags);
    virtual HRESULT SetShellFolder(IShellFolder* psf, LPCITEMIDLIST pidl);
    inline virtual BOOL ShowAmpersand()   { return TRUE; }

    // Change HKEY to IStream*
    CMenuSFToolbar(CMenuBand* pmb, IShellFolder* psf, LPCITEMIDLIST pidl, HKEY hKey, DWORD dwFlags);

protected:
    ~CMenuSFToolbar();

    // Window Proc Overrides
    virtual LRESULT _DefWindowProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
    virtual LRESULT _OnContextMenu(WPARAM wParam, LPARAM lParam);
    virtual void _OnDragBegin(int iItem, DWORD dwPreferedEffect);
    virtual void _OnFSNotifyAdd(LPCITEMIDLIST pidl);
    virtual void _OnFSNotifyRemove(LPCITEMIDLIST pidl);
    virtual HRESULT OnTranslatedChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);

    virtual void _FillToolbar();
    virtual LRESULT _OnNotify(LPNMHDR pnm);
    virtual LRESULT _OnTimer(WPARAM wParam);
    virtual LRESULT _OnCustomDraw(NMCUSTOMDRAW * pnmcd) 
        { return CMenuToolbarBase::_OnCustomDraw(pnmcd); };
    virtual void    _SetToolbarState()
        { CMenuToolbarBase::_SetToolbarState(); };

    virtual void EmptyToolbar()
        { CMenuToolbarBase::EmptyToolbar(); };

    virtual int  v_GetDragOverButton()
        { return _tbim.iButton; };

    virtual HRESULT v_GetSubMenu(int iCmd, const GUID* pguidService, REFIID riid, void** pObj);
    virtual HRESULT v_GetInfoTip(int iCmd, LPTSTR psz, UINT cch);
    virtual HRESULT v_CallCBItem(int idtCmd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual HRESULT v_GetState(int idtCmd, LPSMDATA psmd);

    virtual HRESULT v_ExecItem(int iCmd);
    virtual DWORD v_GetFlags(int iCmd);
    virtual void v_Refresh() 
        { _Refresh(); };
    virtual void v_CalcWidth(int* pcxMin, int* pcxMax) 
        { CMenuToolbarBase::v_CalcWidth(pcxMin, pcxMax); };

    // Utility Functions
    virtual BOOL _AddPidl(LPITEMIDLIST pidl, int index);
    virtual PIBDATA _AddOrderItemTB(PORDERITEM poi, int index, TBBUTTON* ptbb);
    virtual void _Dropped(int nIndex, BOOL fDroppedOnSource);
    virtual HRESULT _TBStyleForPidl(LPCITEMIDLIST pidl, DWORD * pdwStyle, 
        DWORD* pdwState, DWORD * pdwFlags,int* piIcon);

    virtual void _ToolbarChanged();
    virtual void _FillDPA(HDPA hdpa, HDPA hdpaSort, DWORD dwEnumFlags);
    virtual BOOL _FilterPidl(LPCITEMIDLIST pidl);
    virtual void _ObtainPIDLName(LPCITEMIDLIST pidl, LPTSTR psz, int cchMax);
    virtual HMENU _GetContextMenu(IContextMenu* pcm, int* pid);
    virtual void _OnDefaultContextCommand(int idCmd);
    virtual void v_NewItem(LPCITEMIDLIST pidl);
    virtual void _SetDirty(BOOL fDirty);
    virtual void _SetFontMetrics();
    virtual int  _GetBitmap(int iCommandID, PIBDATA pibdata, BOOL fUseCache);
    virtual HWND GetHWNDForUIObject();
    virtual HWND CreateWorkerWindow();

    static  void s_IconCallback(LPVOID pvData, UINT uId, UINT iIconIndex);

    void _AddChevron();
    void _RemoveChevron();
    void _RefreshInfo();

    void BroadcastIntelliMenuState(LPCITEMIDLIST pidlItem, BOOL fPromoted);

    BOOL _ReBindToFolder(LPCITEMIDLIST pidl);
    
    virtual HRESULT _LoadOrderStream();
    virtual HRESULT _SaveOrderStream();

    virtual HRESULT _AfterLoad();
    HRESULT _GetInfo(LPCITEMIDLIST pidl, SMINFO* pmbiinfo);
    HRESULT CallCB(LPCITEMIDLIST pidl, DWORD dwMsg, WPARAM wParam, LPARAM lParam);
    HKEY _GetKey(LPCITEMIDLIST pidl);
    void _MarkItem(int idCmd);
    LRESULT _OnGetObject(NMOBJECTNOTIFY*);
    void _FindMinPromotedItems(BOOL fSetOrderStream);


    virtual LRESULT _OnDropDown(LPNMTOOLBAR pnmtb);

    virtual HRESULT v_CreateTrackPopup(int, REFIID, void**) 
        { AssertMsg(0, TEXT("MenuSF trying to get a TrackPopup")); return E_FAIL; };

    virtual PIBDATA _CreateItemData(PORDERITEM poi);

    // Member Variables
    HKEY    _hKey;
    BITBOOL _fPreventToolbarChange: 1;

    IAugmentedShellFolder2* _pasf2;

    int     _iDefaultIconIndex;

    int     _cMinPromotedItems;

};

#define MNFOLDER_NORODER   -5       // Some random negative number to denote there is no order
#define MNFOLDER_IS_PARENT -1       // -1 is passed to the child as uIdParent so that 
                                    // it knows it's not rooted at a static menu
#endif  // MENUSF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\legacy\sftbar.cpp ===
#include "priv.h"
#include "sccls.h"

#include "iface.h"
#include "itbdrop.h"
#include "sftbar.h"
#include "resource.h"
#include "dpastuff.h"
#include "shlwapi.h"
#include "cobjsafe.h"
#include <iimgctx.h>
#include "uemapp.h"

#include "mluisupp.h"

extern UINT g_idFSNotify;

#define TF_SFTBAR   0x10000000      // Same ID as the AugMISF stuff

#define PGMP_RECALCSIZE  200

// do not set CMD_ID_FIRST to 0.  we use this to see if anything is selected
#define CMD_ID_FIRST    1
#define CMD_ID_LAST     0x7fff

CSFToolbar::CSFToolbar()
{
#ifdef CASCADE_DEBUG
    _fCascadeFolder = TRUE;
#endif
    _dwStyle = TBSTYLE_TOOLTIPS;
    _fDirty = TRUE; // we havn't enumerated, so our state is dirty
    _fRegisterChangeNotify = TRUE;
    _fAllowReorder = TRUE;

    _tbim.iButton = -1;
    _iDragSource = -1;
    _lEvents = SHCNE_DRIVEADD|SHCNE_CREATE|SHCNE_MKDIR|SHCNE_DRIVEREMOVED|
               SHCNE_DELETE|SHCNE_RMDIR|SHCNE_RENAMEITEM|SHCNE_RENAMEFOLDER|
               SHCNE_MEDIAINSERTED|SHCNE_MEDIAREMOVED|SHCNE_NETUNSHARE|SHCNE_NETSHARE|
               SHCNE_UPDATEITEM|SHCNE_UPDATEIMAGE|SHCNE_ASSOCCHANGED|
               SHCNE_UPDATEDIR|SHCNE_EXTENDED_EVENT;
}

CSFToolbar::~CSFToolbar()
{
    ATOMICRELEASE(_pcmSF);

    _ReleaseShellFolder();

    ILFree(_pidl);

    ASSERT(NULL == _hdpa);

    if (_hwndWorkerWindow)
        DestroyWindow(_hwndWorkerWindow);

    OrderList_Destroy(&_hdpaOrder);
}

HRESULT CSFToolbar::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CSFToolbar, IWinEventHandler),
        QITABENT(CSFToolbar, IShellChangeNotify),
        QITABENT(CSFToolbar, IDropTarget),
        QITABENT(CSFToolbar, IContextMenu),
        QITABENT(CSFToolbar, IShellFolderBand),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

HRESULT CSFToolbar::SetShellFolder(IShellFolder* psf, LPCITEMIDLIST pidl)
{
    HRESULT hres = E_INVALIDARG;
    // Save the old values
    LPITEMIDLIST pidlSave = _pidl;
    IShellFolder *psfSave = _psf;
    ITranslateShellChangeNotify *ptscnSave = _ptscn;

    _psf = NULL;
    _pidl = NULL;
    _ptscn = NULL;
    
    ASSERT(NULL == psf || IS_VALID_CODE_PTR(psf, IShellFolder));
    ASSERT(NULL == pidl || IS_VALID_PIDL(pidl));

    if (psf || pidl)
    {
        if (psf)
        {
            _psf = psf;
            _psf->AddRef();

            _psf->QueryInterface(IID_ITranslateShellChangeNotify, (LPVOID *)&_ptscn);
        }
            
        if (pidl)
            _pidl = ILClone(pidl);
        hres = S_OK;
    }

    if (SUCCEEDED(hres))
    {
        ILFree(pidlSave);
        if (psfSave)
            psfSave->Release();
        if (ptscnSave)
            ptscnSave->Release();
    }
    else
    {
        ASSERT(_psf == NULL);
        ASSERT(_pidl == NULL);
        ASSERT(_ptscn == NULL);
        // we failed -- restore the old values
        _psf = psfSave;
        _pidl = pidlSave;
        _ptscn = ptscnSave;
    }

    // This code is here for ShellFolderToolbar reuse. When setting a new shell folder
    // into an existing band, we will refresh. Note that this is a noop on a new band.

    _RememberOrder();
    _SetDirty(TRUE);
    if (_fShow)
        _FillToolbar();
    return hres;
}

HWND CSFToolbar::_CreatePager(HWND hwndParent)
{
    if (!_fMulticolumn)
    {
        _hwndPager = CreateWindowEx(0, WC_PAGESCROLLER, NULL,
                                 WS_CHILD | WS_TABSTOP |
                                 WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
                                 0, 0, 0, 0, hwndParent, (HMENU) 0, HINST_THISDLL, NULL);
        if (_hwndPager)
        {
            hwndParent = _hwndPager;
        }
    }

    return hwndParent;
}

void CSFToolbar::_CreateToolbar(HWND hwndParent)
{
    if (!_hwndTB)
    {

        hwndParent = _CreatePager(hwndParent);

        _hwndTB = CreateWindowEx(WS_EX_TOOLWINDOW, TOOLBARCLASSNAME, NULL,
                                 WS_VISIBLE | WS_CHILD | TBSTYLE_FLAT |
                                 WS_CLIPCHILDREN | WS_CLIPSIBLINGS |
                                 CCS_NODIVIDER | CCS_NOPARENTALIGN |
                                 CCS_NORESIZE | _dwStyle,
                                 0, 0, 0, 0, hwndParent, (HMENU) 0, HINST_THISDLL, NULL);
        if (_hwndPager)
            SendMessage(_hwndPager, PGM_SETCHILD, 0, (LPARAM)_hwndTB);

        if (!_hwndTB)
        {
            TraceMsg(TF_ERROR, "_hwndTB failed");
            return;
        }
        
        SendMessage(_hwndTB, TB_BUTTONSTRUCTSIZE,    SIZEOF(TBBUTTON), 0);

        // Set the format to ANSI or UNICODE as appropriate.
        ToolBar_SetUnicodeFormat(_hwndTB, DLL_IS_UNICODE);
        if (_hwndPager)
        {
            // Set the format to ANSI or UNICODE as appropriate.
            ToolBar_SetUnicodeFormat(_hwndPager, DLL_IS_UNICODE);
        }

        
#if 0 // Not going to do this for IE5.
        ToolBar_SetExtendedStyle(_hwndTB, 
            TBSTYLE_EX_HIDECLIPPEDBUTTONS, 
            TBSTYLE_EX_HIDECLIPPEDBUTTONS);
#endif

        // Make sure we're on the same wavelength.
        SendMessage(_hwndTB, CCM_SETVERSION, COMCTL32_VERSION, 0);

        RECT rc;
        SIZE size;

        SystemParametersInfoA(SPI_GETWORKAREA, SIZEOF(RECT), &rc, FALSE);
        if (!_hwndPager)
        {
            size.cx = RECTWIDTH(rc);
            size.cy = GetSystemMetrics(SM_CYSCREEN) - (2 * GetSystemMetrics(SM_CYEDGE));    // Need to subrtact off the borders
        }
        else
        {
            //HACKHACK:  THIS WILL FORCE NO WRAP TO HAPPEN FOR PROPER WIDTH CALC WHEN PAGER IS PRESENT.
            size.cx = RECTWIDTH(rc);
            size.cy = 32000;
        }
        ToolBar_SetBoundingSize(_hwndTB, &size);
    }
    else
    {
        if (_hwndPager && GetParent(_hwndPager) != hwndParent)
            SetParent(_hwndPager, hwndParent);
    }

    if (FAILED(_GetTopBrowserWindow(&_hwndDD)))
        _hwndDD = GetParent(_hwndTB);
}


#define MAX_COMMANDID 0xFFFF // We're allowed one word of command ids (tested at 5)
int  CSFToolbar::_GetCommandID()
{
    int id = -1;

    if (!_fCheckIds)
    {
        id = _nNextCommandID++;
    }
    else
    {
        // We are reusing command ids and must verify that
        // the current one is not in use. This is slow, but
        // I assume the number of buttons on one of these
        // bands is relatively few.
        //
        for (int i = 0 ; i <= MAX_COMMANDID ; i++)
        {
            TBBUTTONINFO tbbiDummy = {0};

            tbbiDummy.cbSize = SIZEOF(tbbiDummy);
            tbbiDummy.dwMask = 0; // we don't care about data, just existence

            if (-1 != ToolBar_GetButtonInfo(_hwndTB, _nNextCommandID, &tbbiDummy))
            {
                // A button by this id wasn't found, so the id must be free
                //
                id = _nNextCommandID++;
                break;
            }

            _nNextCommandID++;
            _nNextCommandID %= MAX_COMMANDID;
        }
    }

    if (_nNextCommandID > MAX_COMMANDID)
    {
        _nNextCommandID = 0;
        _fCheckIds = TRUE;
    }

    return(id);
}


/*----------------------------------------------------------
Purpose: This function determines the toolbar button style for the
         given pidl.  

         Returns S_OK if pdwMIFFlags is also set (i.e., the object
         supported IMenuBandItem to provide more info).  S_FALSE if only
         *pdwTBStyle is set.

*/
HRESULT CSFToolbar::_TBStyleForPidl(LPCITEMIDLIST pidl, 
                                   DWORD * pdwTBStyle, DWORD* pdwTBState, DWORD * pdwMIFFlags,int* piIcon)
{
    HRESULT hres = S_FALSE;
    DWORD dwStyle = TBSTYLE_BUTTON;
    if (!_fAccelerators)
        dwStyle |= TBSTYLE_NOPREFIX;

    *pdwMIFFlags = 0;
    *pdwTBStyle = dwStyle;
    *piIcon = -1;
    *pdwTBState = TBSTATE_ENABLED;

    return hres;
}


PIBDATA CSFToolbar::_CreateItemData(PORDERITEM poi)
{
    return new IBDATA(poi);
}


PIBDATA CSFToolbar::_AddOrderItemTB(PORDERITEM poi, int index, TBBUTTON* ptbb)
{
    TCHAR szName[MAX_PATH];

    // We need to do this even for NULL because _ObtainPIDLName cooks
    // up the word "(Empty)" as necessary.
    _ObtainPIDLName(poi ? poi->pidl : NULL, szName, SIZECHARS(szName));

    TBBUTTON tbb = {0};
    DWORD dwMIFFlags;
    DWORD dwStyle;
    DWORD dwState;
    int iIcon;
    int iCommandID = _GetCommandID();
    BOOL bNoIcon = FALSE;
    
    if (!ptbb)
        ptbb = &tbb;

    if (S_OK == _TBStyleForPidl(poi ? poi->pidl : NULL, &dwStyle, &dwState, &dwMIFFlags,&iIcon) &&
        !(dwMIFFlags & SMIF_ICON))
    {
        bNoIcon = TRUE;
    }

    PIBDATA pibdata = _CreateItemData(poi);
    if (pibdata)
    {
        pibdata->SetFlags(dwMIFFlags);
        pibdata->SetNoIcon(bNoIcon);

        if(!bNoIcon && iIcon != -1)
            ptbb->iBitmap = iIcon;
        else
            ptbb->iBitmap = I_IMAGECALLBACK;

        ptbb->idCommand = iCommandID;
        ptbb->fsState = (BYTE)dwState;
        ptbb->fsStyle = (BYTE)dwStyle;
        ptbb->dwData = (DWORD_PTR)pibdata;
        ptbb->iString = (INT_PTR)szName;

        // Disregard variablewidth if we are vertical
        if (_fVariableWidth && !_fVertical)
            ptbb->fsStyle |= TBSTYLE_AUTOSIZE;

        if (ptbb->idCommand != -1)
        {
            if (SendMessage(_hwndTB, TB_INSERTBUTTON, index, (LPARAM)ptbb))
            {
                TraceMsg(TF_BAND, "SFToolbar::_AddPidl %d 0x%x [%s]", ptbb->idCommand, ptbb->dwData, ptbb->iString);                                    
            } 
            else 
            {
                delete pibdata;
                pibdata = NULL;
            }
        }

    }

    return pibdata;
}

void CSFToolbar::_ObtainPIDLName(LPCITEMIDLIST pidl, LPTSTR psz, int cchMax)
{
    STRRET strret;
    
    if SUCCEEDED(_psf->GetDisplayNameOf(pidl, SHGDN_NORMAL, &strret))
    {
        StrRetToBuf(&strret, pidl, psz, cchMax);
    }
}

int CSFToolbar::_GetBitmap(int iCommandID, PIBDATA pibdata, BOOL fUseCache)
{
    int iBitmap;

    if(_fNoIcons || pibdata->GetNoIcon())
        iBitmap = -1;
    else
    {
        iBitmap = OrderItem_GetSystemImageListIndex(pibdata->GetOrderItem(), _psf, fUseCache);
    }

    return iBitmap;
}

void CSFToolbar::_OnGetDispInfo(LPNMHDR pnm, BOOL fUnicode) 
{
    LPNMTBDISPINFO pdi = (LPNMTBDISPINFO)pnm;
    PIBDATA pibdata = (PIBDATA)pdi->lParam;
    LPITEMIDLIST pidl = pibdata->GetPidl();
    
    if(pdi->dwMask & TBNF_IMAGE) 
    {
        pdi->iImage = _GetBitmap(pdi->idCommand, pibdata, TRUE);
    }
    
    if(pdi->dwMask & TBNF_TEXT) {
        if(pdi->pszText) {
            if(fUnicode) {
                pdi->pszText[0] = TEXT('\0');
            }else {
                pdi->pszText[0] = 0;
            }
        }
    }
    pdi->dwMask |= TBNF_DI_SETITEM;

    return;
   

}


// Adds pidl as a new button, handles ILFree(pidl) for the caller
//
BOOL CSFToolbar::_AddPidl(LPITEMIDLIST pidl, int index)
{
    if (_hdpa)
    {
        PORDERITEM poi = OrderItem_Create(pidl, index);
        if (poi)
        {
            int iPos = DPA_InsertPtr(_hdpa, index, poi);
            if (-1 != iPos)
            {
                // If we did not load an order, then new items should
                // show up alphabetically in the list, not at the bottom.
                if (!_fHasOrder)
                {
                    // Sort by name
                    _SortDPA(_hdpa);

                    // Find the index of the order item. We use this index as
                    // the toolbar insert index.
                    index = DPA_GetPtrIndex(_hdpa, poi);
                }

                if (_AddOrderItemTB(poi, index, NULL))
                {
                    return TRUE;
                }
                
                DPA_DeletePtr(_hdpa, iPos);
            }

            OrderItem_Free(poi);

            return FALSE;
        }
    }

    ILFree(pidl);

    return FALSE;
}

BOOL CSFToolbar::_FilterPidl(LPCITEMIDLIST pidl)
{
    return FALSE;
}

void CSFToolbar::s_NewItem(LPVOID pvParam, LPCITEMIDLIST pidl)
{
    CSFToolbar* psft = (CSFToolbar*)pvParam;
    psft->v_NewItem(pidl);
}

HRESULT CSFToolbar::_GetIEnumIDList(DWORD dwEnumFlags, IEnumIDList **ppenum)
{
    ASSERT(_psf);
    // Pass in a NULL hwnd so the enumerator does not show any UI while
    // we're filling a band.    
    return IShellFolder_EnumObjects(_psf, NULL, dwEnumFlags, ppenum);
}

void CSFToolbar::_FillDPA(HDPA hdpa, HDPA hdpaSort, DWORD dwEnumFlags)
{
    IEnumIDList* penum;
    int cItems = 0;
    BOOL f9x = IsOS(OS_WINDOWS);

    if (!_psf)
        return;

    if (SUCCEEDED(_GetIEnumIDList(dwEnumFlags, &penum)))
    {
        LPITEMIDLIST pidl;
        ULONG ul;

        while (S_OK == penum->Next(1, &pidl, &ul))
        {
            cItems++;
            if (_FilterPidl(pidl) || !OrderList_Append(hdpa, pidl, -1))
            {
                TraceMsg(TF_MENUBAND, "SFToolbar (0x%x)::_FillDPA : Did not Add Pidl (0x%x).", this, pidl);
                ILFree(pidl);
            }

            // Windows 9x issue
            if (cItems > 1000 && f9x)
            {
                // Here's the deal:
                // When enumerating NTdev, we have 10,000 items. If each item is 20 pixels
                // long, we end up with 200,000 pixels. Windows can only display 32,000 pixels,
                // or 1,600 items in the default case. I'm limiting to 1,000 items = 20,000 so that
                // we have some room for reasonable font sizes.
                break;
            }
        }

        penum->Release();
    }

    ORDERINFO   oinfo;
    int iInsertIndex = _tbim.iButton + 1;               // This is the button where the cursor sat. 
                                                        // So, We want to insert after that
    if (iInsertIndex >= ToolBar_ButtonCount(_hwndTB))   // But, if it's at the end,
        iInsertIndex = -1;                              // Convert the insert to an append.
                                                        //      - Comments in rhyme by lamadio

    oinfo.psf = _psf;
    (oinfo.psf)->AddRef();
    oinfo.dwSortBy = (_fHasOrder || _fDropping)? ((_fNoNameSort ? OI_SORTBYORDINAL : OI_SORTBYNAME)): OI_MERGEBYNAME;
    OrderList_Merge(hdpa, hdpaSort, _fDropping ? iInsertIndex : _DefaultInsertIndex(), (LPARAM) &oinfo,
        s_NewItem, (LPVOID)this);
    ATOMICRELEASE(oinfo.psf);
}

// This function re-enumerates the IShellFolder, keeping things ordered correctly.
// At some point it may reduce flicker by not removing buttons that don't change.
//
void CSFToolbar::_FillToolbar()
{
    HDPA hdpaSort;
    HDPA hdpa;

    if (!_fDirty || !_psf)
        return;

    
    // If we have an order array, use that, otherwise
    // use the currently viewed items
    if (_hdpaOrder)
        hdpaSort = _hdpaOrder; // already sorted by name
    else
    {
        hdpaSort = _hdpa;
        _SortDPA(hdpaSort);
    }

    hdpa = DPA_Create(hdpaSort ? DPA_GetPtrCount(hdpaSort) : 12);
    if (hdpa)
    {
        _FillDPA(hdpa, hdpaSort, SHCONTF_FOLDERS|SHCONTF_NONFOLDERS);

        // NOTE: if many buttons were moved at the same time
        // the notifications may be spread out as the files
        // are copied and we'd only insert the first time.
        // This is probably okay.
        //
        _fDropping = FALSE;

        // For the case of dragging a new item into the band (or one
        // just showing up) we could re-sort _hdpa by ordinal (which
        // would match the current button order), and iterate through hdpa
        // to see where a button needs to be inserted or removed.
        // This would be way less flicker and toolbar painting
        // than always blowing away the current buttons and reinserting them...
        //
        // For now be lazy and do extra work.
        //
        // remove buttons and replace _hdpa with hdpa
        if (_hdpa)
        {
            EmptyToolbar();
            ASSERT(!_hdpa);
        }
        _hdpa = hdpa;

        SendMessage(_hwndTB, WM_SETREDRAW, FALSE, 0);

        // add buttons back in
        DEBUG_CODE( BOOL bFailed = FALSE; )
        int i = 0;
        while (i < DPA_GetPtrCount(_hdpa))
        {
            PORDERITEM poi = (PORDERITEM)DPA_FastGetPtr(_hdpa, i);

//            ASSERT(bFailed || poi->nOrder == i);

            if (_AddOrderItemTB(poi, -1, NULL))
            {
                i++;
            }
            else
            {
                DPA_DeletePtr(_hdpa, i);
                DEBUG_CODE( bFailed = TRUE; )
            }
        }
                
    }
    SendMessage(_hwndTB, WM_SETREDRAW, TRUE, 0);

    // if we used an _hdpaOrder then we don't need it any more
    OrderList_Destroy(&_hdpaOrder);
    
    _UpdateButtons();
    _SetDirty(FALSE);

    _ToolbarChanged();
    TraceMsg(TF_BAND, "SFToolbar::_FillToolbar found %d items", DPA_GetPtrCount(_hdpa));
}

void CSFToolbar::EmptyToolbar()
{
    if (_hwndTB)
    {
        TraceMsg(TF_BAND, "SFToolbar::EmptyToolbar %d items", _hdpa ? DPA_GetPtrCount(_hdpa) : 0);

        while (InlineDeleteButton(0))
        {
            // delete the buttons
        }
    }

    OrderList_Destroy(&_hdpa);

    _fDirty = TRUE;
    
    _nNextCommandID = 0;
}

void CSFToolbar::_SetDirty(BOOL fDirty)
{
    _fDirty = fDirty;
}

UINT CSFToolbar::_IndexToID(int iIndex)
{
    TBBUTTON tbb;

    if (SendMessage(_hwndTB, TB_GETBUTTON, iIndex, (LPARAM)&tbb))
    {
        return tbb.idCommand;
    }
    return (UINT)-1;
}

// if ptbbi is specified, dwMask must be filled in
//
LPITEMIDLIST CSFToolbar::_GetButtonFromPidl(LPCITEMIDLIST pidl, TBBUTTONINFO * ptbbi, int * pIndex)
{
    int i;

    if (!_hdpa)
        return NULL;

    for (i = DPA_GetPtrCount(_hdpa)-1 ; i >= 0 ; i--)
    {
        HRESULT hres;
        PORDERITEM poi = (PORDERITEM)DPA_FastGetPtr(_hdpa, i);

        ASSERT(poi);
        if (poi->pidl) {
            hres = _psf->CompareIDs(0, pidl, poi->pidl);
            if (ResultFromShort(0) == hres)
            {
                if (pIndex)
                    *pIndex = i;

                if (ptbbi)
                {
                    int id = _IndexToID(i);

                    if (id != -1) {
                        ptbbi->cbSize = SIZEOF(*ptbbi);
                        if (-1 == ToolBar_GetButtonInfo(_hwndTB, id, ptbbi))
                        {
                            ZeroMemory(ptbbi, SIZEOF(*ptbbi));
                        }
                    }
                    else
                    {
                        ZeroMemory(ptbbi, SIZEOF(*ptbbi));
                    }
                }

                return poi->pidl;
            }
        }
    }

    return NULL;
}

// On an add, tack the new button on the end
void CSFToolbar::_OnFSNotifyAdd(LPCITEMIDLIST pidl)
{
    // be paranoid and make sure we don't duplicate an item
    //
    if (!_GetButtonFromPidl(pidl, NULL, NULL))
    {
        LPITEMIDLIST pidlNew;

        if (_fFSNotify && !_ptscn)
        {
            if (FAILED(SHGetRealIDL(_psf, pidl, &pidlNew)))
                pidlNew = NULL;
        }
        else
        {
            pidlNew = ILClone(pidl);
        }

        if (pidlNew)
        {
            if (!_FilterPidl(pidlNew))
            {
                int index = _DefaultInsertIndex();

                if (_fDropping)
                {
                    if (-1 == _tbim.iButton)
                        index = 0; // if qlinks has no items, _tbim.iButton is -1, but you can't insert there...
                    else if (_tbim.dwFlags & TBIMHT_AFTER)
                        index = _tbim.iButton + 1;
                    else
                        index = _tbim.iButton;
                }

                // We need to store this as the new order because a drag and drop has occured.
                // We will store this order and use it until the end of time.
                if (_fDropping)
                {
                    _fHasOrder = TRUE;
                    _fChangedOrder = TRUE;
                }


                _AddPidl(pidlNew, index);
                
                OrderList_Reorder(_hdpa);
           
                if (_fDropping)
                {
                    _Dropped(index, FALSE);
                    _fDropping = FALSE;
                }
                // BUGBUG: i'm nuking this call to SetDirty as it doesn't seem
                // necessary and we don't have a matching call to _SetDirty(FALSE);
                // mismatch of those calls causes nt5 bug #173868.  [tjgreen 5-15-98]
    
                //_SetDirty(TRUE);
            }
            else
            {
                ILFree(pidlNew);
            }
        }
    }
}


// This function syncronously removes the button, and deletes it's contents.
// This avoids Reentrancy problems, as well as Leaks caused by unhooked toolbars
BOOL_PTR CSFToolbar::InlineDeleteButton(int iIndex)
{
    BOOL_PTR fRet = FALSE;
    TBBUTTONINFO tbbi = {0};
    tbbi.cbSize = SIZEOF(tbbi);
    tbbi.dwMask = TBIF_LPARAM | TBIF_BYINDEX;
    if (ToolBar_GetButtonInfo(_hwndTB, iIndex, &tbbi) >= 0)
    {
        PIBDATA pibdata = (PIBDATA)tbbi.lParam;
        tbbi.lParam = NULL;

        ToolBar_SetButtonInfo(_hwndTB, iIndex, &tbbi);

        fRet = SendMessage(_hwndTB, TB_DELETEBUTTON, iIndex, 0);

        if (pibdata)
            delete pibdata;

    }

    return fRet;
}

// On a remove, rip out the old button and adjust existing ones
void CSFToolbar::_OnFSNotifyRemove(LPCITEMIDLIST pidl)
{
    int i;
    LPITEMIDLIST pidlButton = _GetButtonFromPidl(pidl, NULL, &i);
    if (pidlButton)
    {
        // remove it from the DPA before nuking the button. There is a rentrancy issue here.
        DPA_DeletePtr(_hdpa, i);
        InlineDeleteButton(i);
        ILFree(pidlButton);
        _fChangedOrder = TRUE;
    }
}

// On a rename, just change the text of the old button
//
void CSFToolbar::_OnFSNotifyRename(LPCITEMIDLIST pidlFrom, LPCITEMIDLIST pidlTo)
{
    TBBUTTONINFO tbbi = {0};
    LPITEMIDLIST pidlButton;
    int i;
    
    tbbi.cbSize = SIZEOF(tbbi);
    tbbi.dwMask = TBIF_COMMAND | TBIF_LPARAM;
    pidlButton = _GetButtonFromPidl(pidlFrom, &tbbi, &i);
    if (pidlButton)
    {
        LPITEMIDLIST pidlNew;

        if (_fFSNotify && !_ptscn)
        {
            if (FAILED(SHGetRealIDL(_psf, pidlTo, &pidlNew)))
                pidlNew = NULL;
        }
        else
        {
            pidlNew = ILClone(pidlTo);
        }

        if (pidlNew)
        {
            LPITEMIDLIST pidlFree = pidlNew;
            PORDERITEM poi = (PORDERITEM)DPA_FastGetPtr(_hdpa, i);
            if (EVAL(poi))
            {
                pidlFree = poi->pidl;
                poi->pidl = pidlNew;
            
                STRRET strret;
                TCHAR szName[MAX_PATH];
                if (SUCCEEDED(_psf->GetDisplayNameOf(pidlNew, SHGDN_NORMAL, &strret)) &&
                    SUCCEEDED(StrRetToBuf(&strret, pidlNew, szName, ARRAYSIZE(szName))))
                {
                    // _GetButtonFromPidl filled in tbbi.cbSize and tbbi.idCommand
                    //
                    PIBDATA pibdata = (PIBDATA)tbbi.lParam;
                    if (pibdata)
                        pibdata->SetOrderItem(poi);

                    tbbi.dwMask = TBIF_TEXT;
                    tbbi.pszText = szName;
                    EVAL(ToolBar_SetButtonInfo(_hwndTB, tbbi.idCommand, &tbbi));
                    // Just so that it's new location gets persisted
                    _fChangedOrder = TRUE;
                }
            }

            ILFree(pidlFree);
        }
    }
}

// On a complete update remove the old button and add it again
//
void CSFToolbar::_OnFSNotifyUpdate(LPCITEMIDLIST pidl)
{
    TBBUTTONINFO tbbi = {0};

    tbbi.cbSize = SIZEOF(tbbi);
    tbbi.dwMask = TBIF_COMMAND;
    LPITEMIDLIST pidlButton = _GetButtonFromPidl(pidl, &tbbi, NULL);
    if (pidlButton)
    {
        STRRET strret;
        TCHAR szName[MAX_PATH];

        if (SUCCEEDED(_psf->GetDisplayNameOf(pidlButton, SHGDN_NORMAL, &strret)) &&
            SUCCEEDED(StrRetToBuf(&strret, pidlButton, szName, ARRAYSIZE(szName))))
        {
            int iBitmap = _GetBitmap(tbbi.idCommand, _IDToPibData(tbbi.idCommand, NULL), FALSE);
            if (iBitmap >= 0)
            {
                tbbi.dwMask = TBIF_IMAGE | TBIF_TEXT;
                tbbi.iImage = iBitmap;
                tbbi.pszText = szName;

                ToolBar_SetButtonInfo(_hwndTB, tbbi.idCommand, &tbbi);
            }
        }
    }
}

void CSFToolbar::_Refresh()
{
    if (!_hdpa)
        return;

    _RememberOrder();

    _SetDirty(TRUE);
    if (_fShow)
        _FillToolbar();
}

LRESULT CSFToolbar::_OnTimer(WPARAM wParam)
{
    return 0;
}

LRESULT CSFToolbar::_DefWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg) 
    {
    case WM_DRAWITEM:
    case WM_MEASUREITEM:
    case WM_INITMENUPOPUP:
    case WM_MENUSELECT:
        if (_pcm2)
            _pcm2->HandleMenuMsg(uMsg, wParam, lParam);
        break;

    case WM_MENUCHAR:
        {
            LRESULT lres = 0;
            IContextMenu3* pcm3;
            if (_pcm2 && SUCCEEDED(_pcm2->QueryInterface(IID_IContextMenu3, (void**)&pcm3)))
            {
                pcm3->HandleMenuMsg2(uMsg, wParam, lParam, &lres);
                pcm3->Release();
            }
            return lres;
        }
        break;
    
    case WM_TIMER:
        if (_OnTimer(wParam)) 
        {
            return 1;
        }
        break;
    }
    
    return CNotifySubclassWndProc::_DefWindowProc(hwnd, uMsg, wParam, lParam);
}

/*----------------------------------------------------------
Purpose:
For future use. when renaming a parent of this shell folder
 we should rebind to it and refill us.

S_OK    Indicates successful handling of this notification
S_FALSE Indicates the notification is not a handled situation.
        The caller should handle the notification in this case.
Other   Failure code indicates a problem.  Caller should abort
        operation or handle the notification itself.

*/
HRESULT CSFToolbar::_OnRenameFolder(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    HRESULT hres = S_FALSE;
#if 0
    // This code is just busted. It was for the case when we rename the parent. We don't support this
    if (!_IsChildID(pidl1, FALSE) || !_IsChildID(pidl2, FALSE))
    {
        // Then this must be a parent of us. At this point we should rebind. The code that
        // was here did not work. I've removed it so that we can recode it in the future, but
        // now, we're just going to live with it
        TraceMsg(TF_SFTBAR, "CSFTBar::OnTranslateChange: RenameFolder: This is not a child folder.");
        hres = S_OK;
    }
#endif
    return hres;
}

HRESULT CSFToolbar::OnChange(LONG lEvent, LPCITEMIDLIST pidlOrg1, LPCITEMIDLIST pidlOrg2)
{
    HRESULT hres;
    LPITEMIDLIST pidl1 = (LPITEMIDLIST)pidlOrg1;
    LPITEMIDLIST pidl2 = (LPITEMIDLIST)pidlOrg2;
    LPITEMIDLIST pidl1ToFree = NULL;        // Used if we allocate a pidl that needs to be freed. (::TranslateIDs())
    LPITEMIDLIST pidl2ToFree = NULL;
    LPITEMIDLIST pidlOut1Event2 = NULL;        // Used if we allocate a pidl that needs to be freed. (::TranslateIDs())
    LPITEMIDLIST pidlOut2Event2 = NULL;
    LONG lEvent2 = (LONG)-1;
    if (_ptscn)
    {
        hres = _ptscn->TranslateIDs(&lEvent, pidlOrg1, pidlOrg2, &pidl1, &pidl2,
                                    &lEvent2, &pidlOut1Event2, &pidlOut2Event2);
            
        if (FAILED(hres))
            return hres;
        else
        {
            // if pidl1 doesn't equal pidlOrg1, then pidl1 was allocated and needs to be freed.
            pidl1ToFree = ((pidlOrg1 == pidl1) ? NULL : pidl1);
            pidl2ToFree = ((pidlOrg2 == pidl2) ? NULL : pidl2);
        }

        ASSERT(NULL == pidl1 || IS_VALID_PIDL(pidl1));
        ASSERT(NULL == pidl2 || IS_VALID_PIDL(pidl2));
    }

    hres = OnTranslatedChange(lEvent, pidl1, pidl2);

    // Do we have a second event to process?
    if (SUCCEEDED(hres) && lEvent2 != (LONG)-1)
    {
        // Yes, then go do it.
        hres = OnTranslatedChange(lEvent2, pidlOut1Event2, pidlOut2Event2);
    }
    ILFree(pidlOut1Event2);
    ILFree(pidlOut2Event2);
    ILFree(pidl1ToFree);
    ILFree(pidl2ToFree);

    return hres;
}

#ifdef DEBUG
void DBPrPidl(LPCSTR szPre, LPCITEMIDLIST pidl)
{
    TCHAR szName[MAX_PATH];

    szName[0] = '\0';
    if (pidl)
        SHGetNameAndFlags(pidl, SHGDN_FORPARSING, szName, SIZECHARS(szName), NULL);

    TraceMsg(TF_WARNING, "%hs%s", szPre, szName);
    return;
}
#endif

HRESULT CSFToolbar::OnTranslatedChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    HRESULT hres = S_OK;
    BOOL fSizeChanged = FALSE;

    TraceMsg(TF_SFTBAR, "CSFTBar::OnTranslateChange: lEvent=%x", lEvent);

    // If we weren't given a pidl we won't register for
    // SHChangeNotify calls, but our IShellChange interface
    // can still be QI()d so someone could errantly call us.
    //
    // If we change to using QS() for IShellChange interface
    // then we can put this check there...
    //
    if (NULL == _pidl)
    {
        // HACKHACK (scotth): resource-based menus (CMenuISF) don't set _pidl.
        //                    Right now allow SHCNE_UPDATEDIR thru...
        if (SHCNE_UPDATEDIR == lEvent)
            goto HandleUpdateDir;

        TraceMsg(TF_WARNING, "CSFToolbar::OnChange - _pidl is NULL");
        hres = E_FAIL;
        goto CleanUp;
    }

    if ( lEvent != SHCNE_UPDATEIMAGE && lEvent != SHCNE_RENAMEITEM && lEvent != SHCNE_RENAMEFOLDER &&
         lEvent != SHCNE_UPDATEDIR && lEvent != SHCNE_MEDIAREMOVED && lEvent != SHCNE_MEDIAINSERTED &&
         lEvent != SHCNE_EXTENDED_EVENT)
    {
        // We only handle notifications for immediate kids. (except SHCNE_RENAMEFOLDER)
        //
        
        if (!_IsChildID(pidl1, TRUE))
        {
            TraceMsg(TF_SFTBAR, "CSFTBar::OnTranslateChange: Not a child. Bailing");
            hres = E_FAIL;
            goto CleanUp;
        }
    }

    // This is no longer required. It also hinders us for several different notifications (Such as reorder notifies)
#if 0
    // If we're hidden we do not want to respond to any change notify
    // messages, so we unregister the toolbar. We mark the toolbar as 
    // dirty so the next time we are shown, we will reenumerate the filesystem.

    if (!_fShow && !_fDropping)
    {
        _SetDirty(TRUE);
        _UnregisterChangeNotify();
        hres = E_FAIL;
        goto CleanUp;
    }
#endif

    // Have we been shown yet?
    if (_hdpa == NULL)
    {
        // No. Well, then punt this. We'll catch it on the first enum.
        hres = E_FAIL;
        goto CleanUp;
    }

    switch (lEvent)
    {
    case SHCNE_EXTENDED_EVENT:
        {
            SHChangeDWORDAsIDList UNALIGNED * pdwidl = (SHChangeDWORDAsIDList UNALIGNED *)pidl1;
            if (pdwidl->dwItem1 == SHCNEE_ORDERCHANGED)
            {
                TraceMsg(TF_SFTBAR, "CSFTBar::OnTranslateChange: Reorder event");

                // Do this first so that we can say "We can handle it". This prevents the 
                // mnfolder code that works around a bug in some installers where they don't
                // send a Create Folder before the create item in that folder. It causes an
                // update dir...
                if (!pidl2 || ILIsEqual(_pidl, pidl2))
                {
                    // if this reorder came from us, blow it off
                    if (!SHChangeMenuWasSentByMe(this, pidl1))
                    {
                        // load new order stream
                        _LoadOrderStream();

                        // rebuild toolbar
                        _SetDirty(TRUE);
                        if (_fShow)
                            _FillToolbar();
                    }
                    hres = S_OK;
                }
            }
        }
        break;

    case SHCNE_DRIVEADD:
    case SHCNE_CREATE:
    case SHCNE_MKDIR:
        TraceMsg(TF_SFTBAR, "CSFTBar::OnTranslateChange: Adding item");
        pidl1 = ILFindLastID(pidl1);
        _OnFSNotifyAdd(pidl1);
        fSizeChanged = TRUE;
        break;

    case SHCNE_DRIVEREMOVED:
    case SHCNE_DELETE:
    case SHCNE_RMDIR:
        TraceMsg(TF_SFTBAR, "CSFTBar::OnTranslateChange: Removing item");
        pidl1 = ILFindLastID(pidl1);
        _OnFSNotifyRemove(pidl1);
        fSizeChanged = TRUE;
        break;

    case SHCNE_RENAMEFOLDER:
        TraceMsg(TF_SFTBAR, "CSFTBar::OnTranslateChange: RenameFolder");
        // Break if notif is handled or if this is not for our kid.
        //
        hres = _OnRenameFolder(pidl1, pidl2);
        if (S_OK == hres)
        {
            fSizeChanged = TRUE;
            break;
        }

        TraceMsg(TF_SFTBAR, "CSFTBar::OnTranslateChange: RenameFolder Falling through to RenameItem");
        // fall through
    case SHCNE_RENAMEITEM:
    {
        TraceMsg(TF_SFTBAR, "CSFTBar::OnTranslateChange: RenameItem");
        BOOL fOurKid1, fOurKid2;
        LPCITEMIDLIST p1 = pidl1;
        LPCITEMIDLIST p2 = pidl2;

        pidl1 = ILFindLastID(pidl1);
        pidl2 = ILFindLastID(pidl2);

        // An item can be renamed out of this folder.
        // Convert that into a remove.
        //

        fOurKid1 = _IsChildID(p1, TRUE);
        fOurKid2 = _IsChildID(p2, TRUE);
        if (fOurKid1 && fOurKid2)
        {
            TraceMsg(TF_SFTBAR, "CSFTBar::OnTranslateChange: Rename: Both are children");
            _OnFSNotifyRename(pidl1, pidl2);
            fSizeChanged = TRUE;
            hres = S_OK;
            break;
        }
        else if (fOurKid1)
        {
            TraceMsg(TF_SFTBAR, "CSFTBar::OnTranslateChange: Rename: Only one is a child. Removing pidl 1");
            _OnFSNotifyRemove(pidl1);
            fSizeChanged = TRUE;
            break;
        }
        else if (fOurKid2)
        {
            // An item can be renamed into this folder.
            // Convert that into an add.
            //
            TraceMsg(TF_SFTBAR, "CSFTBar::OnTranslateChange: Rename: Only one is a child. Adding pidl2");
            _OnFSNotifyAdd(pidl2);
            fSizeChanged = TRUE;
            break;
        }
        else 
        {
            // (we get here for guys below us who we don't care about,
            // and also for the fallthru from SHCNE_RENAMEFOLDER)
            TraceMsg(TF_SFTBAR, "CSFTBar::OnTranslateChange: Rename: Not our children");
            /*NOTHING*/
            hres = E_FAIL;
        }
        break;
    }

    case SHCNE_MEDIAINSERTED:
    case SHCNE_MEDIAREMOVED:
    case SHCNE_NETUNSHARE:
        if (_IsEqualID(pidl1))
            goto HandleUpdateDir;

    case SHCNE_NETSHARE:
    case SHCNE_UPDATEITEM:
        
        if (_IsChildID(pidl1, TRUE)) 
        {
            pidl1 = ILFindLastID(pidl1);

            _OnFSNotifyUpdate(pidl1);
            fSizeChanged = TRUE;
        }
        break;

    case SHCNE_UPDATEDIR:
        // in OnChange we picked off update dir notify and we didn't translate ids
        // now we can use ILIsEqual -- translate ids won't translate pidls in case
        // of update dir because it looks for immediate child of its, and fails when
        // it receives its own pidl

        // NOTE: When sftbar is registered recursivly, we only get the pidl of the
        // top pane. It is forwarded down to the children. Since this is now a "Child"
        // of the top pane, we check to see if this pidl is a child of that pidl, hence the
        // ILIsParent(pidl1, _pidl)
        // HACKHACK, HUGE HACK: normaly w/ update dir pidl2 is NULL but in start menu
        // augmergeisf can change some other notify (e.g. rename folder) to update dir
        // in which case pidl2 is not null and we have to see if it is our child to do the
        // update (11/18/98) reljai
        if (_IsEqualID(pidl1) ||                    // Calling UpdateDir on _THIS_ folder
            _IsChildID(pidl1, FALSE) ||             // BUGBUG (lamadio) Is this needed?
            (pidl2 && _IsChildID(pidl2, FALSE)) ||  // A changed to update (see comment)
            _IsParentID(pidl1))                     // Some parent in the chain (because it's recursive)
        {
HandleUpdateDir:
            // NOTE: if a series of UPDATEIMAGE notifies gets
            //       translated to UPDATEDIR and we flicker-perf
            //       _FillToolbar, we may lose image updates
            //       (in which case, _Refresh would fix it)
            //
            TraceMsg(TF_SFTBAR, "CSFTBar::OnTranslateChange: ******* Evil Update Dir *******");
            _Refresh();
            // don't set this here because filltoolbar will update
            //fSizeChanged = TRUE;
        }
        break;

    case SHCNE_ASSOCCHANGED:
        IEInvalidateImageList();    // We may need to use different icons.
        _Refresh(); // full refresh for now.
        break;

    case SHCNE_UPDATEIMAGE: // global
        if (pidl1)
        {
            int iImage = *(int UNALIGNED *)((BYTE *)pidl1 + 2);

            IEInvalidateImageList();    // We may need to use different icons.
            if ( pidl2 )
            {
                iImage = SHHandleUpdateImage( pidl2 );
                if ( iImage == -1 )
                {
                    break;
                }
            }
            
            if (iImage == -1 || TBHasImage(_hwndTB, iImage))
                _Refresh();
        } else
            _Refresh();
        // BUGBUG do we need an _UpdateButtons and fSizeChanged?
        break;

    default:
        hres = E_FAIL;
        break;
    }

    if (fSizeChanged)
    {
        if (_hwndPager)
            SendMessage(_hwndPager, PGMP_RECALCSIZE, (WPARAM) 0, (LPARAM) 0);
        _ToolbarChanged();
    }

CleanUp:
    return hres;
}

BOOL TBHasImage(HWND hwnd, int iImageIndex)
{
    BOOL fRefresh = FALSE;
    for (int i = ToolBar_ButtonCount(hwnd) - 1 ; i >= 0 ; i--)
    {
        TBBUTTON tbb;
        if (SendMessage(hwnd, TB_GETBUTTON, i, (LPARAM)&tbb)) 
        {
            if (tbb.iBitmap == iImageIndex) 
            {
                fRefresh = TRUE;
                break;
            }
        }
    }

    return fRefresh;
}

void CSFToolbar::_SetToolbarState()
{
    SHSetWindowBits(_hwndTB, GWL_STYLE, TBSTYLE_LIST, 
                  (_uIconSize != ISFBVIEWMODE_SMALLICONS || _fNoShowText) ? 0 : TBSTYLE_LIST);
}

int CSFToolbar::_DefaultInsertIndex()
{
    return DA_LAST;
}

BOOL CSFToolbar::_IsParentID(LPCITEMIDLIST pidl)
{
    // Is the pidl passed in a parent of one of the IDs in the namespace
    // or the only one i've got?
    if (_ptscn)
        return S_OK == _ptscn->IsEqualID(NULL, pidl);
    else
        return ILIsParent(pidl, _pidl, FALSE);
}

BOOL CSFToolbar::_IsEqualID(LPCITEMIDLIST pidl)
{
    if (_ptscn)
        return S_OK == _ptscn->IsEqualID(pidl, NULL);
    else
        return ILIsEqual(_pidl, pidl);
}

BOOL CSFToolbar::_IsChildID(LPCITEMIDLIST pidlChild, BOOL fImmediate)
{
    if (_ptscn)
        return S_OK == _ptscn->IsChildID(pidlChild, fImmediate);
    else
        return ILIsParent(_pidl, pidlChild, fImmediate);
}

void CSFToolbar::v_CalcWidth(int* pcxMin, int* pcxMax)
{
    ASSERT(IS_VALID_WRITE_PTR(pcxMin, int));
    ASSERT(IS_VALID_WRITE_PTR(pcxMax, int));
    // Calculate a decent button width given current state
    HIMAGELIST himl;
    int cxMax = 0;
    int cxMin = 0;

    himl = (HIMAGELIST)SendMessage(_hwndTB, TB_GETIMAGELIST, 0, 0);
    if (himl)
    {
        int cy;
        // Start with the width of the button
        ImageList_GetIconSize(himl, &cxMax, &cy);

        // We want at least a bit of space around the icon
        if (_uIconSize != ISFBVIEWMODE_SMALLICONS)
            cxMax += 20;
        else 
            cxMax += 4 * GetSystemMetrics(SM_CXEDGE);

    }

    // Add in any additional space needed
    // Text takes up a bit more space
    if (!_fNoShowText)
    {
        cxMax += 20;

        // Horizontal text takes up a lot
        // if we're smallicon with text (horizontal button)
        // mode, use the minimized metric to mimic the taskbar
        if (_uIconSize == ISFBVIEWMODE_SMALLICONS)
            cxMax = GetSystemMetrics(SM_CXMINIMIZED);
    }

    *pcxMin = cxMin;
    *pcxMax = cxMax;
}

// Adjust buttons based on current state.
//
void CSFToolbar::_UpdateButtons()
{
    if (_hwndTB)
    {
        // set "list" (text on right) or not (text underneath)
        // NOTE: list mode always displays some text, don't do it if no text
        _SetToolbarState();

        v_CalcWidth(&_cxMin, &_cxMax);

        SendMessage(_hwndTB, TB_SETBUTTONWIDTH, 0, MAKELONG(_cxMin, _cxMax));

        // We just changed the layout
        //
        SendMessage(_hwndTB, TB_AUTOSIZE, 0, 0);
        if (_hwndPager)
        {
            LRESULT lButtonSize = SendMessage(_hwndTB, TB_GETBUTTONSIZE, 0, 0);
            Pager_SetScrollInfo(_hwndPager, 50, 1, HIWORD(lButtonSize));
            SendMessage(_hwndPager, PGMP_RECALCSIZE, (WPARAM) 0, (LPARAM) 0);
        }
    }
}

/*----------------------------------------------------------
Purpose: Helper function that calls IShellFolder::GetUIObjectOf().

Returns: pointer to the requested interface
         NULL if failed
*/
LPVOID CSFToolbar::_GetUIObjectOfPidl(LPCITEMIDLIST pidl, REFIID riid)
{
    LPCITEMIDLIST * apidl = &pidl;
    LPVOID pv;
    if (FAILED(_psf->GetUIObjectOf(GetHWNDForUIObject(), 1, apidl, riid, 0, &pv)))
    {
        pv = NULL;
    }

    return(pv);
}

INT_PTR CALLBACK CSFToolbar::_RenameDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
    {
        ASSERT(lParam);
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        EnableWindow(GetDlgItem(hDlg, IDOK), FALSE);
        // cross-lang platform support
        SHSetDefaultDialogFont(hDlg, IDD_NAME);
        HWND hwndEdit = GetDlgItem(hDlg, IDD_NAME);
        SendMessage(hwndEdit, EM_LIMITTEXT, MAX_PATH - 1, 0);

        TCHAR szText[MAX_PATH + 80];
        TCHAR szTemplate[80];
        HWND hwndLabel = GetDlgItem(hDlg, IDD_PROMPT);
        GetWindowText(hwndLabel, szTemplate, ARRAYSIZE(szTemplate));
        wnsprintf(szText, ARRAYSIZE(szText), szTemplate, lParam);
        SetWindowText(hwndLabel, szText);
        SetWindowText(hwndEdit, (LPTSTR)lParam);
        break;
    }

    case WM_DESTROY:
        SHRemoveDefaultDialogFont(hDlg);
        return FALSE;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDD_NAME:
        {
            if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_UPDATE)
            {
                LPTSTR lpstrName = (LPTSTR) GetWindowLongPtr(hDlg, DWLP_USER);
                EnableOKButtonFromID(hDlg, IDD_NAME);
                GetDlgItemText(hDlg, IDD_NAME, lpstrName, MAX_PATH);
            }
            break;
        }

        case IDOK:
        {
            TCHAR  pszTmp[MAX_PATH];
            StrCpy(pszTmp, (LPTSTR) GetWindowLongPtr(hDlg, DWLP_USER));
            if (PathCleanupSpec(NULL,pszTmp))
            {
               HWND hwnd;

               MLShellMessageBox(hDlg,
                                 MAKEINTRESOURCE(IDS_FAVS_INVALIDFN),
                                 MAKEINTRESOURCE(IDS_FAVS_ADDTOFAVORITES), MB_OK | MB_ICONHAND);
               hwnd = GetDlgItem(hDlg, IDD_NAME);
               SetWindowText(hwnd, TEXT('\0'));
               EnableWindow(GetDlgItem(hDlg, IDOK), FALSE);
               SetFocus(hwnd);
               break;
            }
        }
        // fall through

        case IDCANCEL:
            EndDialog(hDlg, GET_WM_COMMAND_ID(wParam, lParam));
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}


// This window proc is used for a temporary worker window that is used to position dialogs 
// as well as maintain the correct Z-Order
// NOTE: This is used in mnfolder as well.
LRESULT CALLBACK HiddenWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
        // Make sure activation tracks back to the parent.
    case WM_ACTIVATE:
        {
            if (WA_ACTIVE != LOWORD(wParam))
                goto DefWnd;

            SetActiveWindow(GetParent(hwnd));
            return FALSE;
        }

    case WM_WINDOWPOSCHANGING:
        {
            WINDOWPOS* pwp = (WINDOWPOS*)lParam;
            pwp->flags |= SWP_NOOWNERZORDER;
        }
        break;
    }

DefWnd:
    return DefWindowProc(hwnd, uMsg, wParam, lParam);

}

HWND CSFToolbar::CreateWorkerWindow()
{
    if (!_hwndWorkerWindow)
    {
        _hwndWorkerWindow = SHCreateWorkerWindow(HiddenWndProc, GetHWNDForUIObject(), WS_EX_TOOLWINDOW /*| WS_EX_TOPMOST */, WS_POPUP, 0, _hwndTB);
    }

    return _hwndWorkerWindow;
}

HRESULT CSFToolbar::_OnRename(POINT *ppt, int id)
{
    ASSERT(_psf);
    
    TCHAR szName[MAX_PATH];
    LPCITEMIDLIST pidl = _IDToPidl(id);
    
    _ObtainPIDLName(pidl, szName, ARRAYSIZE(szName));

    // create a temp window so that placement of the dialog will be close to the point.
    // do this so that we'll use USER's code to get placement correctly w/ respect to multimon and work area
    _hwndWorkerWindow = CreateWorkerWindow();

    SetWindowPos(_hwndWorkerWindow, NULL, ppt->x, ppt->y, 0, 0, SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE);

    // Now the horrible work of disabling our UI parent window so we can go modal.
    // In an ideal world, we would pass our true parent window and USER will do
    // all the work of modality, but we have to use our worker window thingie
    // to get the dialog positioned correctly with respect to multimon,
    // so we have to find the modal parent and disable him the hard way.
    //
    IUnknown *punkSite;
    IUnknown *punkTLB;

    // Doesn't matter what we SAFECAST "this" to; just pick something to keep the compiler happy
    IUnknown_GetSite(SAFECAST(this, IWinEventHandler*), IID_PPV_ARG(IUnknown, &punkSite));
    IUnknown_QueryService(punkSite, SID_STopLevelBrowser, IID_PPV_ARG(IUnknown, &punkTLB));

    // Tell OLE to go modal
    HRESULT hrModeless = IUnknown_EnableModless(punkTLB, FALSE);

    // Tell USER to go modal
    HWND hwndDisable;
    IUnknown_GetWindow(punkTLB, &hwndDisable);
    BOOL bPrevEnabled = FALSE;
    while (hwndDisable && (GetWindowLong(hwndDisable, GWL_STYLE) & WS_CHILD))
        hwndDisable = GetParent(hwndDisable);
    if (hwndDisable)
        bPrevEnabled = !EnableWindow(hwndDisable, FALSE);

    while (1) 
    {
        if (DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(DLG_ISFBANDRENAME), _hwndWorkerWindow, _RenameDlgProc, (LPARAM)szName) != IDOK)
            break;

        WCHAR wsz[MAX_PATH];
        SHTCharToUnicode(szName, wsz, ARRAYSIZE(wsz));

        if (SUCCEEDED(_psf->SetNameOf(_hwndWorkerWindow, pidl, wsz, 0, NULL))) 
        {
            SHChangeNotifyHandleEvents();
            _SaveOrderStream();
            break;
        }
    }

    // (must undo modality in reverse order)

    // Tell USER to return to modeless (as appropriate)
    if (hwndDisable)
        EnableWindow(hwndDisable, bPrevEnabled);

    // Tell OLE to return to modeless (as appropriate)
    if (SUCCEEDED(hrModeless))
        IUnknown_EnableModless(punkTLB, TRUE);

    ATOMICRELEASE(punkTLB);
    ATOMICRELEASE(punkSite);

    return S_OK;
}


BOOL CSFToolbar::_UpdateIconSize(UINT uIconSize, BOOL fUpdateButtons)
{
    BOOL fChanged = (_uIconSize != uIconSize);
    
    _uIconSize = uIconSize;

    TraceMsg(TF_BAND, "ISFBand::_UpdateIconSize going %hs", (_uIconSize == ISFBVIEWMODE_LARGEICONS ? "LARGE" : (_uIconSize == ISFBVIEWMODE_SMALLICONS ? "SMALL" : "LOGOS")));

    if (_hwndTB)
    {
        HIMAGELIST himl = NULL;
        if (!_fNoIcons)
        {
            HIMAGELIST himlLarge, himlSmall;

            // set the imagelist size
            Shell_GetImageLists(&himlLarge, &himlSmall);
            himl = (_uIconSize == ISFBVIEWMODE_LARGEICONS ) ? himlLarge : himlSmall;
        }

        // sending a null himl is significant..  it means no image list
        SendMessage(_hwndTB, TB_SETIMAGELIST, 0, (LPARAM)himl);
                
        if (fUpdateButtons)
            _UpdateButtons();
    }
    
    return fChanged;
}

HMENU CSFToolbar::_GetContextMenu(IContextMenu* pcm, int* pid)
{
    HMENU hmenu = CreatePopupMenu();
    if (hmenu) {

        UINT fFlags = CMF_CANRENAME;
        if (0 > GetKeyState(VK_SHIFT))
            fFlags |= CMF_EXTENDEDVERBS;

        pcm->QueryContextMenu(hmenu, 0, *pid, CMD_ID_LAST, fFlags);
    }
    return hmenu;
}

void CSFToolbar::_OnDefaultContextCommand(int idCmd)
{
}

HRESULT CSFToolbar::_GetTopBrowserWindow(HWND* phwnd)
{
    IUnknown * punkSite;

    HRESULT hr = IUnknown_GetSite(SAFECAST(this, IWinEventHandler*), IID_IUnknown, (void**)&punkSite);
    if (SUCCEEDED(hr))
    {
        hr = SHGetTopBrowserWindow(punkSite, phwnd);
        punkSite->Release();
    }

    return hr;
}

HRESULT CSFToolbar::_OnOpen(int id, BOOL fExplore)
{
    HRESULT hr = E_FAIL;
    LPCITEMIDLIST pidl = _IDToPidl(id);
    if (pidl)
    {
        IUnknown* punkSite;

        hr = IUnknown_GetSite(SAFECAST(this, IWinEventHandler*), IID_IUnknown, (void**)&punkSite);
        if (SUCCEEDED(hr))
        {
            DWORD dwFlags = SBSP_DEFBROWSER | SBSP_DEFMODE;
            if (fExplore)
                dwFlags |= SBSP_EXPLOREMODE;

            hr = SHNavigateToFavorite(_psf, pidl, punkSite, dwFlags);

            punkSite->Release();
        }
    }

    return hr;
}

HRESULT CSFToolbar::_HandleSpecialCommand(IContextMenu* pcm, PPOINT ppt, int id, int idCmd)
{
    TCHAR szCommandString[40];

    HRESULT hres = ContextMenu_GetCommandStringVerb(pcm,
        idCmd,
        szCommandString,
        ARRAYSIZE(szCommandString));

    if (SUCCEEDED(hres))
    {
        if (lstrcmpi(szCommandString, TEXT("rename")) == 0)
            return _OnRename(ppt, id);
        else if (lstrcmpi(szCommandString, TEXT("open")) == 0)
            return _OnOpen(id, FALSE);
        else if (lstrcmpi(szCommandString, TEXT("explore")) == 0)
            return _OnOpen(id, TRUE);
    }

    return S_FALSE;
}

LRESULT CSFToolbar::_DoContextMenu(IContextMenu* pcm, LPPOINT ppt, int id, LPRECT prcExclude)
{
    LRESULT lres = 0;
    int idCmdFirst = CMD_ID_FIRST;
    HMENU hmContext = _GetContextMenu(pcm, &idCmdFirst);
    if (hmContext)
    {
        int idCmd;

        if (_hwndToolTips)
            SendMessage(_hwndToolTips, TTM_ACTIVATE, FALSE, 0L);

        TPMPARAMS tpm;
        TPMPARAMS * ptpm = NULL;

        if (prcExclude)
        {
            tpm.cbSize = SIZEOF(tpm);
            tpm.rcExclude = *((LPRECT)prcExclude);
            ptpm = &tpm;
        }
        idCmd = TrackPopupMenuEx(hmContext,
            TPM_RETURNCMD | TPM_RIGHTBUTTON | TPM_LEFTALIGN,
            ppt->x, ppt->y, _hwndTB, ptpm);

        if (_hwndToolTips)
            SendMessage(_hwndToolTips, TTM_ACTIVATE, TRUE, 0L);
        
        if (idCmd)
        {
            if (idCmd < idCmdFirst)
            {
                _OnDefaultContextCommand(idCmd);
            }
            else
            {
                idCmd -= idCmdFirst;

                if (_HandleSpecialCommand(pcm, ppt, id, idCmd) != S_OK)
                {
                    _hwndWorkerWindow = CreateWorkerWindow();

                    SetWindowPos(_hwndWorkerWindow, NULL, ppt->x, ppt->y, 0, 0, SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE);

                    CMINVOKECOMMANDINFO ici = {
                        SIZEOF(CMINVOKECOMMANDINFO),
                        0,
                        _hwndWorkerWindow,
                        MAKEINTRESOURCEA(idCmd),
                        NULL, NULL,
                        SW_NORMAL,
                    };

                    pcm->InvokeCommand(&ici);
                }
            }
        }

        // if we get this far
        // we need to return handled so that WM_CONTEXTMENU doesn't come through
        lres = 1;
        
        DestroyMenu(hmContext);
    }

    return lres;
}


LRESULT CSFToolbar::_OnContextMenu(WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;
    RECT rc;
    LPRECT prcExclude = NULL;
    POINT pt;
    int i;

    if (lParam != (LPARAM)-1) {
        pt.x = GET_X_LPARAM(lParam);
        pt.y = GET_Y_LPARAM(lParam);

        POINT pt2 = pt;
        MapWindowPoints(HWND_DESKTOP, _hwndTB, &pt2, 1);

        i = ToolBar_HitTest(_hwndTB, &pt2);
    } else {
        // keyboard context menu.
        i = (int)SendMessage(_hwndTB, TB_GETHOTITEM, 0, 0);
        if (i >= 0) {
            SendMessage(_hwndTB, TB_GETITEMRECT, i, (LPARAM)&rc);
            MapWindowPoints(_hwndTB, HWND_DESKTOP, (LPPOINT)&rc, 2);
            pt.x = rc.left;
            pt.y = rc.bottom;
            prcExclude = &rc;
        }
    }

    TraceMsg(TF_BAND, "NM_RCLICK %d,%d = %d", pt.x, pt.y, i);

    if (i >= 0)
    {
        UINT id = _IndexToID(i);
        LPCITEMIDLIST pidl = _IDToPidl(id, NULL);

        if (pidl)
        {
            LPCONTEXTMENU pcm = (LPCONTEXTMENU)_GetUIObjectOfPidl(pidl, IID_IContextMenu);
            if (pcm)
            {
                // grab pcm2 for owner draw support
                pcm->QueryInterface(IID_IContextMenu2, (LPVOID *)&_pcm2);

                ToolBar_MarkButton(_hwndTB, id, TRUE);

                lres = _DoContextMenu(pcm, &pt, id, prcExclude);

                ToolBar_MarkButton(_hwndTB, id, FALSE);

                if (lres)
                    _FlushNotifyMessages(_hwndTB);

                ATOMICRELEASE(_pcm2);
                pcm->Release();
            }
        }
    }

    return lres;
}


LRESULT CSFToolbar::_OnCustomDraw(NMCUSTOMDRAW* pnmcd)
{
    return CDRF_DODEFAULT;
}

void CSFToolbar::_OnDragBegin(int iItem, DWORD dwPreferedEffect)
{
    LPCITEMIDLIST pidl = _IDToPidl(iItem, &_iDragSource);
    ToolBar_SetHotItem(_hwndTB, _iDragSource);

    if (_hwndTB)
        DragDrop(_hwndTB, _psf, pidl, dwPreferedEffect, NULL);
    
    _iDragSource = -1;
}

LRESULT CSFToolbar::_OnHotItemChange(NMTBHOTITEM * pnm)
{
    LPNMTBHOTITEM  lpnmhi = (LPNMTBHOTITEM)pnm;

    if (_hwndPager && (lpnmhi->dwFlags & (HICF_ARROWKEYS | HICF_ACCELERATOR)) )
    {
        int iOldPos, iNewPos;
        RECT rc, rcPager;
        int heightPager;            
        
        int iSelected = lpnmhi->idNew;        
        iOldPos = (int)SendMessage(_hwndPager, PGM_GETPOS, (WPARAM)0, (LPARAM)0);
        iNewPos = iOldPos;
        SendMessage(_hwndTB, TB_GETITEMRECT, (WPARAM)iSelected, (LPARAM)&rc);
        
        if (rc.top < iOldPos) 
        {
             iNewPos =rc.top;
        }
        
        GetClientRect(_hwndPager, &rcPager);
        heightPager = RECTHEIGHT(rcPager);
        
        if (rc.top >= iOldPos + heightPager)  
        {
             iNewPos += (rc.bottom - (iOldPos + heightPager)) ;
        }
        
        if (iNewPos != iOldPos)
            SendMessage(_hwndPager, PGM_SETPOS, (WPARAM)0, (LPARAM)iNewPos);
    }

    return 0;
}

void CSFToolbar::_OnToolTipsCreated(NMTOOLTIPSCREATED* pnm)
{
    _hwndToolTips = pnm->hwndToolTips;
    SHSetWindowBits(_hwndToolTips, GWL_STYLE, TTS_ALWAYSTIP | TTS_TOPMOST | TTS_NOPREFIX, TTS_ALWAYSTIP | TTS_TOPMOST | TTS_NOPREFIX);

    // set the AutoPopTime (the duration of showing the tooltip) to a large value
    SendMessage(_hwndToolTips, TTM_SETDELAYTIME, TTDT_AUTOPOP, (LPARAM)MAXSHORT);
}

LRESULT CSFToolbar::_OnNotify(LPNMHDR pnm)
{
    LRESULT lres = 0;

    //The following statement traps all pager control notification messages.
    if((pnm->code <= PGN_FIRST)  && (pnm->code >= PGN_LAST)) 
    {
        return SendMessage(_hwndTB, WM_NOTIFY, (WPARAM)0, (LPARAM)pnm);
    }

    switch (pnm->code)
    {
    case TBN_DRAGOUT:
    {
        TBNOTIFY *ptbn = (TBNOTIFY*)pnm;
        _OnDragBegin(ptbn->iItem, 0);
        lres = 1;
        break;
    }
    
    case TBN_HOTITEMCHANGE:
        _OnHotItemChange((LPNMTBHOTITEM)pnm);
        break;


    case TBN_GETINFOTIP:
    {
        LPNMTBGETINFOTIP pnmTT = (LPNMTBGETINFOTIP)pnm;
        UINT uiCmd = pnmTT->iItem;
        DWORD dwFlags = _fNoShowText ? QITIPF_USENAME | QITIPF_LINKNOTARGET : QITIPF_LINKNOTARGET;

        if (!GetInfoTipEx(_psf, dwFlags, _IDToPidl(uiCmd), pnmTT->pszText, pnmTT->cchTextMax))
        {
            TBBUTTONINFO tbbi = { 0};
    
            tbbi.cbSize = SIZEOF(tbbi);
            tbbi.dwMask = TBIF_TEXT;
            tbbi.pszText = pnmTT->pszText;
            tbbi.cchText = pnmTT->cchTextMax;
    
            lres = (-1 != ToolBar_GetButtonInfo(_hwndTB, uiCmd, &tbbi));
        }

        break;
    }

    //BUGBUG: Right now I am calling the same function for both A and W version if this notification supports 
    // Strings then  it needs to thunk. Right now its only used for image
    case  TBN_GETDISPINFOA:
        _OnGetDispInfo(pnm,  FALSE);
        break;
    case  TBN_GETDISPINFOW:
        _OnGetDispInfo(pnm,  TRUE);
        break;
        
    case NM_TOOLTIPSCREATED:
        _OnToolTipsCreated((NMTOOLTIPSCREATED*)pnm);
        break;

    case NM_RCLICK:
        lres = _OnContextMenu(NULL, GetMessagePos());
        break;

    case NM_CUSTOMDRAW:
        return _OnCustomDraw((NMCUSTOMDRAW*)pnm);

    }

    return(lres);
}

DWORD CSFToolbar::_GetAttributesOfPidl(LPCITEMIDLIST pidl, DWORD dwAttribs)
{
    if (FAILED(_psf->GetAttributesOf(1, &pidl, &dwAttribs)))
        dwAttribs = 0;

    return dwAttribs;

}

PIBDATA CSFToolbar::_PosToPibData(UINT iPos)
{
    ASSERT(IsWindow(_hwndTB));

    // Initialize to NULL in case the GetButton Fails.
    TBBUTTON tbb = {0};
    PIBDATA pibData = NULL;
    
    if (ToolBar_GetButton(_hwndTB, iPos, &tbb))
    {
        pibData = (PIBDATA)tbb.dwData;
    }

    return pibData;
}

PIBDATA CSFToolbar::_IDToPibData(UINT uiCmd, int * piPos)
{
    PIBDATA pibdata = NULL;

    // Initialize to NULL in case the GetButtonInfo Fails.
    TBBUTTONINFO tbbi = {0};
    int iPos;

    tbbi.cbSize = SIZEOF(tbbi);
    tbbi.dwMask = TBIF_LPARAM;

    iPos = ToolBar_GetButtonInfo(_hwndTB, uiCmd, &tbbi);
    if (iPos >= 0)
        pibdata = (PIBDATA)tbbi.lParam;

    if (piPos)
        *piPos = iPos;

    return pibdata;
}    


LPCITEMIDLIST CSFToolbar::_IDToPidl(UINT uiCmd, int *piPos)
{
    LPCITEMIDLIST pidl;
    PIBDATA pibdata = _IDToPibData(uiCmd, piPos);

    if (pibdata)
        pidl = pibdata->GetPidl();
    else
        pidl = NULL;

    return pidl;
}

/*----------------------------------------------------------
Purpose: IWinEventHandler::OnWinEvent method

         Processes messages passed on from the bandsite.
*/
HRESULT CSFToolbar::OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    *plres = 0;
    // We are addref'n here because during the course of the
    // Context menu, the view could be changed which free's the menu.
    // We will release after we're sure the this pointer is no longer needed.
    AddRef();
    
    switch (uMsg) {
    case WM_WININICHANGE:
        if ((SHIsExplorerIniChange(wParam, lParam) == EICH_UNKNOWN) || 
            (wParam == SPI_SETNONCLIENTMETRICS))
        {
            _UpdateIconSize(_uIconSize, TRUE);
            _Refresh();
            goto L_WM_SYSCOLORCHANGE;
        }
        break;

    case WM_SYSCOLORCHANGE:
    L_WM_SYSCOLORCHANGE:
        SendMessage(_hwndTB, uMsg, wParam, lParam);
        InvalidateRect(_hwndTB, NULL, TRUE);
        break;

    case WM_PALETTECHANGED:
        InvalidateRect( _hwndTB, NULL, FALSE );
        SendMessage( _hwndTB, uMsg, wParam, lParam );
        break;
        
    case WM_COMMAND:
        *plres = _OnCommand(wParam, lParam);
        break;
        
    case WM_NOTIFY:
        *plres = _OnNotify((LPNMHDR)lParam);
        break;

    case WM_CONTEXTMENU:
        *plres = _OnContextMenu(wParam, lParam);
        break;
    }

    Release();
    return S_OK;
} 


// Map the information loaded (or ctor) into _psf, [_pidl]
//
HRESULT CSFToolbar::_AfterLoad()
{
    HRESULT hres = S_OK;

    // if we have a pidl then we need to get ready
    // for notifications...
    //
    if (_pidl)
    {
        // pidls must be rooted off the desktop
        //
        _fFSNotify = TRUE;

        // shortcut -- just specifying a pidl is good enough
        //
        if (!_psf)
        {
            _fPSFBandDesktop = TRUE;
            hres = IEBindToObject(_pidl, &_psf);
        }
    }

    return(hres);
}
// IDropTarget implementation
//

/*----------------------------------------------------------
Purpose: CDelegateDropTarget::GetWindowsDDT

*/
HRESULT CSFToolbar::GetWindowsDDT(HWND * phwndLock, HWND * phwndScroll)
{
    *phwndLock = _hwndTB;
    *phwndScroll = _hwndTB;
    return S_OK;
}


/*----------------------------------------------------------
Purpose: CDelegateDropTarget::HitTestDDT

*/
HRESULT CSFToolbar::HitTestDDT(UINT nEvent, LPPOINT ppt, DWORD_PTR * pdwId, DWORD *pdwEffect)
{
    TBINSERTMARK tbim;

    switch (nEvent)
    {
    case HTDDT_ENTER:
        return S_OK;

    case HTDDT_OVER:
        {
            int iButton = IBHT_BACKGROUND; // assume we hit the background

            // if we're the source, this may be a move operation
            //
            *pdwEffect = (_iDragSource >= 0) ? DROPEFFECT_MOVE : DROPEFFECT_NONE;
            if (!ToolBar_InsertMarkHitTest(_hwndTB, ppt, &tbim))
            {
                if (tbim.dwFlags & TBIMHT_BACKGROUND)
                {
                    RECT rc;
                    GetClientRect(_hwndTB, &rc);

                    // are we outside the toolbar window entirely?
                    if (!PtInRect(&rc, *ppt))
                    {
                        // rebar already did the hittesting so we are on the rebar
                        // but not the toolbar => we are in the title part
                        if (!_AllowDropOnTitle())
                        {
                            // yes; don't allow drop here
                            iButton = IBHT_OUTSIDEWINDOW;
                            *pdwEffect = DROPEFFECT_NONE;
                        }

                        // set tbim.iButton to invalid value so we don't draw insert mark
                        tbim.iButton = -1;
                    }
                }
                else
                {
                    // nope, we hit a real button
                    //
                    if (tbim.iButton == _iDragSource)
                    {
                        iButton = IBHT_SOURCE; // don't drop on the source button
                    }
                    else
                    {
                        iButton = tbim.iButton;
                    }
                    tbim.iButton = IBHT_BACKGROUND;

                    // we never force a move operation if we're on a real button
                    *pdwEffect = DROPEFFECT_NONE;
                }
            }

            *pdwId = iButton;
        }
        break;

    case HTDDT_LEAVE:
        // Reset
        tbim.iButton = IBHT_BACKGROUND;
        tbim.dwFlags = 0;
        break;

    default:
        return E_INVALIDARG;
    }

    // update ui
    if (tbim.iButton != _tbim.iButton || tbim.dwFlags != _tbim.dwFlags)
    {
        if (ppt)
            _tbim = tbim;

        // for now I don't want to rely on non-filesystem IShellFolder
        // implementations to call our OnChange method when a drop occurs,
        // so don't even show the insert mark.
        //
        if (_fFSNotify || _iDragSource >= 0)
        {
            DAD_ShowDragImage(FALSE);
            ToolBar_SetInsertMark(_hwndTB, &tbim);
            DAD_ShowDragImage(TRUE);
        }
    }

    return S_OK;
}


/*----------------------------------------------------------
Purpose: CDelegateDropTarget::GetObjectDDT

*/
HRESULT CSFToolbar::GetObjectDDT(DWORD_PTR dwId, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hres = E_NOINTERFACE;

    *ppvObj = NULL;

    if ((IBHT_SOURCE == dwId) || (IBHT_OUTSIDEWINDOW == dwId))
    {
        // do nothing
    }
    else if (IBHT_BACKGROUND == dwId)
    {
        // nash:41937: not sure how, but _psf can be NULL...
        if (EVAL(_psf))
            hres = _psf->CreateViewObject(_hwndTB, riid, ppvObj);
    }
    else
    {
        LPCITEMIDLIST pidl = _IDToPidl((UINT)dwId, NULL);

        if (pidl)
        {
            *ppvObj = _GetUIObjectOfPidl(pidl, riid);

            if (*ppvObj)
                hres = S_OK;
        }
    }

    //TraceMsg(TF_BAND, "SFToolbar::GetObject(%d) returns %x", dwId, hres);

    return hres;
}

HRESULT CSFToolbar::_SaveOrderStream()
{
    if (_fChangedOrder)
    {
        // Notify everyone that the order changed
        SHSendChangeMenuNotify(this, SHCNEE_ORDERCHANGED, 0, _pidl);
        _fChangedOrder = FALSE;
        return S_OK;
    }
    else
        return S_FALSE;
}

void CSFToolbar::_Dropped(int nIndex, BOOL fDroppedOnSource)
{
    _fDropped = TRUE;
    _fChangedOrder = TRUE;

    // Save new order stream
    _SaveOrderStream();

    if (fDroppedOnSource)
        _FlushNotifyMessages(_hwndTB);
}

/*----------------------------------------------------------
Purpose: CDelegateDropTarget::OnDropDDT

*/
HRESULT CSFToolbar::OnDropDDT(IDropTarget *pdt, IDataObject *pdtobj, DWORD * pgrfKeyState, POINTL pt, DWORD *pdwEffect)
{
    // Are we NOT the drag source? 
    if (_iDragSource == -1)
    {
        // No, we're not. Well, then the source may be the chevron menu
        // representing the hidden items in this menu. Let's check
        LPITEMIDLIST pidl;
        if (SUCCEEDED(SHPidlFromDataObject2(pdtobj, &pidl)))
        {
            // We've got a pidl, Are we the parent? Do we have a button?
            int iIndex;
            if (ILIsParent(_pidl, pidl, TRUE) &&
                _GetButtonFromPidl(ILFindLastID(pidl), NULL, &iIndex))
            {
                // We are the parent! Then let's copy that down and set it
                // as the drag source so that down below we reorder.
                _iDragSource = iIndex;
            }
            ILFree(pidl);
        }
    }

    if (_iDragSource >= 0)
    {
        if (_fAllowReorder)
        {
            TraceMsg(TF_BAND, "SFToolbar::OnDrop reorder %d to %d %s", _iDragSource, _tbim.iButton, _tbim.dwFlags & TBIMHT_AFTER ? "A" : "B");

            int iNewLocation = _tbim.iButton;
            if (_tbim.dwFlags & TBIMHT_AFTER)
                iNewLocation++;

            if (iNewLocation > _iDragSource)
                iNewLocation--;

            if (ToolBar_MoveButton(_hwndTB, _iDragSource, iNewLocation))
            {
                PORDERITEM poi = (PORDERITEM)DPA_FastGetPtr(_hdpa, _iDragSource);
                DPA_DeletePtr(_hdpa, _iDragSource);
                DPA_InsertPtr(_hdpa, iNewLocation, poi);

                OrderList_Reorder(_hdpa);

                // If we're dropping again, then we don't need the _hdpaOrder...
                OrderList_Destroy(&_hdpaOrder);

                // A reorder has occurred. We need to use the order stream as the order...
                _fHasOrder = TRUE;
                _fDropping = TRUE;
                _Dropped(iNewLocation, TRUE);     
                _fDropping = FALSE;
                _RememberOrder();
                _SetDirty(TRUE);
            }
        }

        // Don't forget to reset this!
        _iDragSource = -1;

        DragLeave();
    }
    else
    {
#ifndef UNIX
        // We want to override the default to be LINK (SHIFT+CONTROL)
        if ((GetPreferedDropEffect(pdtobj) == 0) &&
            !(*pgrfKeyState & (MK_CONTROL | MK_SHIFT | MK_ALT)))
        {
            // NOTE: not all data objects will allow us to call SetData()
            _SetPreferedDropEffect(pdtobj, DROPEFFECT_LINK);
        }
#endif

        _fDropping = TRUE;
        return S_OK;
    }

    return S_FALSE;
}

void CSFToolbar::_SortDPA(HDPA hdpa)
{
    // If we don't have a _psf, then we certainly can't sort it
    // If we don't have a hdpa, then we certainly can't sort it
    // If the hdpa is empty, then there's no point in sorting it
    if (_psf && hdpa && DPA_GetPtrCount(hdpa))
    {
        ORDERINFO   oinfo;
        oinfo.psf = _psf;
        (oinfo.psf)->AddRef();
        oinfo.dwSortBy = (_fNoNameSort ? OI_SORTBYORDINAL : OI_SORTBYNAME);
        DPA_Sort(hdpa, OrderItem_Compare, (LPARAM)&oinfo);
        ATOMICRELEASE(oinfo.psf);
    }
}

void CSFToolbar::_RememberOrder()
{
    OrderList_Destroy(&_hdpaOrder);

    if (_hdpa)
    {
        _hdpaOrder = OrderList_Clone(_hdpa);
        _SortDPA(_hdpaOrder);
    }
}

HMENU CSFToolbar::_GetBaseContextMenu()
{
    HMENU hmenu = LoadMenuPopup_PrivateNoMungeW(MENU_ISFBAND);
    // no logo view, remove the menu item...
    HMENU hView = GetSubMenu( hmenu, 0 );
    DeleteMenu( hView, ISFBIDM_LOGOS, MF_BYCOMMAND );
    return hmenu;
}

HMENU CSFToolbar::_GetContextMenu()
{
    HMENU hmenuSrc = _GetBaseContextMenu();
    if (hmenuSrc)
    {
        MENUITEMINFO mii;

        mii.cbSize = SIZEOF(mii);
        mii.fMask = MIIM_STATE;
        mii.fState = MF_CHECKED;

        UINT uCmdId = ISFBIDM_LOGOS;
        if ( _uIconSize != ISFBVIEWMODE_LOGOS )
            uCmdId = (_uIconSize == ISFBVIEWMODE_LARGEICONS ? ISFBIDM_LARGE : ISFBIDM_SMALL);
            
        SetMenuItemInfo(hmenuSrc, uCmdId, MF_BYCOMMAND, &mii);
        if (!_fNoShowText)
            SetMenuItemInfo(hmenuSrc, ISFBIDM_SHOWTEXT, MF_BYCOMMAND, &mii);
        
        if (!_fFSNotify || !_pidl || ILIsEmpty(_pidl))
            DeleteMenu(hmenuSrc, ISFBIDM_OPEN, MF_BYCOMMAND);

        HMENU hView = GetSubMenu( hmenuSrc, 0 );
        DeleteMenu( hView, ISFBIDM_LOGOS, MF_BYCOMMAND );


    }

    return hmenuSrc;
}
// IContextMenu implementation
//
HRESULT CSFToolbar::QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    HMENU hmenuSrc = _GetContextMenu();
    int i = 0;
    if ( hmenuSrc )
    {
        i += Shell_MergeMenus(hmenu, hmenuSrc, indexMenu, idCmdFirst, idCmdLast, MM_ADDSEPARATOR);
        DestroyMenu(hmenuSrc);
    }
    
    if (!_pcmSF && _fAllowRename && _psf)
    {
        _psf->CreateViewObject(_hwndTB, IID_IContextMenu, (LPVOID*)&_pcmSF);
    }
    
    if (_pcmSF)
    {
        HRESULT hresT;
        
        _idCmdSF = i - idCmdFirst;
        hresT = _pcmSF->QueryContextMenu(hmenu, indexMenu + i, i, 0x7fff, CMF_BANDCMD);
        if (SUCCEEDED(hresT))
            i += HRESULT_CODE(hresT);
    }
    
    return i;
}

BOOL CSFToolbar::_UpdateShowText(BOOL fNoShowText)
{
    BOOL fChanged = (!_fNoShowText != !fNoShowText);
        
    _fNoShowText = (fNoShowText != 0);

    TraceMsg(TF_BAND, "ISFBand::_UpdateShowText turning text %hs", _fNoShowText ? "OFF" : "ON");

    if (_hwndTB)
    {
        SendMessage(_hwndTB, TB_SETMAXTEXTROWS, _fNoShowText ? 0 : 1, 0L);

        _UpdateButtons();
    }
    
    return fChanged;
}

HRESULT CSFToolbar::InvokeCommand(LPCMINVOKECOMMANDINFO lpici)
{
    BOOL fChanged = FALSE;
    int idCmd = -1;

    if (!HIWORD(lpici->lpVerb))
        idCmd = LOWORD(lpici->lpVerb);

    switch (idCmd)
    {
    case ISFBIDM_REFRESH:
        _Refresh();
        break;
        
    case ISFBIDM_OPEN:
        OpenFolderPidl(_pidl);
        break;
                
    case ISFBIDM_LARGE:
        fChanged = _UpdateIconSize(ISFBVIEWMODE_LARGEICONS, TRUE);
        break;
    case ISFBIDM_SMALL:
        fChanged = _UpdateIconSize(ISFBVIEWMODE_SMALLICONS, TRUE);
        break;

    case ISFBIDM_SHOWTEXT:
        fChanged = _UpdateShowText(!_fNoShowText);
        break;
        
    default:
        if (_pcmSF && idCmd >= _idCmdSF)
        {
            LPCSTR  lpOldVerb = lpici->lpVerb;
            
            lpici->lpVerb = MAKEINTRESOURCEA(idCmd -= _idCmdSF);
            
            _pcmSF->InvokeCommand(lpici);
            _FlushNotifyMessages(_hwndTB);

            lpici->lpVerb = lpOldVerb;
        }
        else
            TraceMsg(TF_BAND, "SFToolbar::InvokeCommand %d not handled", idCmd);
        break;
    }
    
    // Our minimum sizes have changed, notify the bandsite
    //
    if (fChanged)
        _ToolbarChanged();

    return(S_OK);
}

HRESULT CSFToolbar::GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pwReserved, LPSTR pszName, UINT cchMax)
{
    return(E_NOTIMPL);
}


void CSFToolbar::_RegisterToolbar()
{
    // Since _SubclassWindow protects against multiply subclassing, 
    // This call is safe, and ensures that the toolbar is subclassed before
    // even trying to register it for change notify.
    if (_hwndTB && _SubclassWindow(_hwndTB) && _fRegisterChangeNotify)
        _RegisterChangeNotify();
    CDelegateDropTarget::Init();
}

void CSFToolbar::_UnregisterToolbar()
{
    if (_hwndTB)
    {
        if (_fRegisterChangeNotify) 
            _UnregisterChangeNotify();
        _UnsubclassWindow(_hwndTB);
    }
}

void CSFToolbar::_RegisterChangeNotify()
{
    // Since we want to register for change notify ONLY once,
    // and only if this is a file system toolbar.
    if (!_fFSNRegistered && _fFSNotify)
    {
        if (_ptscn)
            _ptscn->Register(_hwndTB, g_idFSNotify, _lEvents);
        else
            _RegisterWindow(_hwndTB, _pidl, _lEvents);

        _fFSNRegistered = TRUE;
    }
}

void CSFToolbar::_UnregisterChangeNotify()
{
    // Only unregister if we have been registered.
    if (_hwndTB && _fFSNRegistered && _fFSNotify)
    {
        _fFSNRegistered = FALSE;
        if (_ptscn)
            _ptscn->Unregister();
        else
            _UnregisterWindow(_hwndTB);

    }
}


void CSFToolbar::_ReleaseShellFolder()
{
    if (_psf)
    {
        IUnknown_SetOwner(_psf, NULL);
        ATOMICRELEASE(_psf);
    }
    ATOMICRELEASE(_ptscn);
}    

/*----------------------------------------------------------
Purpose: IWinEventHandler::IsWindowOwner method.

*/
HRESULT CSFToolbar::IsWindowOwner(HWND hwnd)
{
    if (hwnd == _hwndTB ||
        hwnd == _hwndToolTips ||
        hwnd == _hwndPager)
        return S_OK;
    
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\legacy\tbmenu.h ===
#ifndef CToolbarMenu_H
#define CToolbarMenu_H

#include "menuband.h"
#include "mnbase.h"
#include "cwndproc.h"

#define TF_TBMENU   0

class CToolbarMenu :    public CMenuToolbarBase,
                        public CNotifySubclassWndProc
                    
{

public:
    // *** IUnknown (override) ***
    virtual STDMETHODIMP_(ULONG) AddRef(void) { return CMenuToolbarBase::AddRef(); };
    virtual STDMETHODIMP_(ULONG) Release(void) { return CMenuToolbarBase::Release(); };
    virtual STDMETHODIMP QueryInterface(REFIID riid, void** ppvObj) { return CMenuToolbarBase::QueryInterface(riid, ppvObj); };

    // *** IWinEventHandler methods (override) ***
    virtual STDMETHODIMP IsWindowOwner(HWND hwnd);
    virtual STDMETHODIMP OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres);

       virtual BOOL v_TrackingSubContextMenu() { return _fTrackingSubMenu; };
    
    virtual void v_Show(BOOL fShow, BOOL fForceUpdate) ;
    virtual BOOL v_UpdateIconSize(UINT uIconSize, BOOL fUpdateButtons) { return FALSE; };
    virtual void v_UpdateButtons(BOOL fNegotiateSize) ;
    virtual HRESULT v_GetSubMenu(int iCmd, const GUID* pguidService, REFIID riid, void** pObj) {return E_FAIL;};
    virtual HRESULT v_CallCBItem(int idtCmd, UINT dwMsg, WPARAM wParam, LPARAM lParam) ;
    virtual HRESULT v_GetState(int idtCmd, LPSMDATA psmd);
    virtual HRESULT v_ExecItem(int iCmd);
    virtual DWORD v_GetFlags(int iCmd) { return 0; };
    virtual void v_Close(); // override


    virtual int  v_GetDragOverButton() { ASSERT(0); return 0;};
    virtual HRESULT v_GetInfoTip(int iCmd, LPTSTR psz, UINT cch) {return E_NOTIMPL;};
    virtual HRESULT v_CreateTrackPopup(int idCmd, REFIID riid, void** ppvObj) {ASSERT(0); return E_NOTIMPL;};
    virtual void v_Refresh() {/*ASSERT(0);*/};
    virtual void v_SendMenuNotification(UINT idCmd, BOOL fClear) {};
    
    CToolbarMenu(DWORD dwFlags, HWND hwndTB);


protected:

    virtual STDMETHODIMP OnChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2) { return E_NOTIMPL;    }
    virtual LRESULT _DefWindowProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam);


    virtual void CreateToolbar(HWND hwndParent);
    virtual void GetSize(SIZE* psize);

    void _CancelMenu();
    void _FillToolbar();

    HWND _hwndSubject;
    BITBOOL _fTrackingSubMenu:1;

    friend CMenuToolbarBase* ToolbarMenu_Create(HWND hwnd);
};

class CTrackShellMenu : public ITrackShellMenu,
                        public IShellMenu2,
                        public IObjectWithSite,
                        public IServiceProvider
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IShellMenu methods ***
    virtual STDMETHODIMP Initialize(IShellMenuCallback* psmc, UINT uId, UINT uIdAncestor, DWORD dwFlags);
    virtual STDMETHODIMP GetMenuInfo(IShellMenuCallback** ppsmc, UINT* puId, 
                                    UINT* puIdAncestor, DWORD* pdwFlags);
    virtual STDMETHODIMP SetShellFolder(IShellFolder* psf, LPCITEMIDLIST pidlFolder, HKEY hkey, DWORD dwFlags);
    virtual STDMETHODIMP GetShellFolder(DWORD* pdwFlags, LPITEMIDLIST* ppidl, REFIID riid, void** ppvObj);
    virtual STDMETHODIMP SetMenu(HMENU hmenu, HWND hwnd, DWORD dwFlags);
    virtual STDMETHODIMP GetMenu(HMENU* phmenu, HWND* phwnd, DWORD* pdwFlags);
    virtual STDMETHODIMP InvalidateItem(LPSMDATA psmd, DWORD dwFlags);
    virtual STDMETHODIMP GetState(LPSMDATA psmd);
    virtual STDMETHODIMP SetMenuToolbar(IUnknown* punk, DWORD dwFlags);

    // *** ITrackShellMenu methods ***
    virtual STDMETHODIMP SetObscured(HWND hwndTB, IUnknown* punkBand, DWORD dwSMSetFlags);
    virtual STDMETHODIMP Popup(HWND hwnd, POINTL *ppt, RECTL *prcExclude, DWORD dwFlags);

    // *** IObjectWithSite methods ***
    virtual STDMETHODIMP SetSite(IUnknown* punkSite);
    virtual STDMETHODIMP GetSite(REFIID ridd, void** ppvObj) { *ppvObj = NULL; return E_NOTIMPL; };

    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService,
                                  REFIID riid, void **ppvObj);

    // *** IShellMenu2 methods ***
    virtual STDMETHODIMP GetSubMenu(UINT idCmd, REFIID riid, void **ppvObj);
    virtual STDMETHODIMP SetToolbar(HWND hwnd, DWORD dwFlags);
    virtual STDMETHODIMP SetMinWidth(int cxMenu);
    virtual STDMETHODIMP SetNoBorder(BOOL fNoBorder);
    virtual STDMETHODIMP SetTheme(LPCWSTR pszTheme);

    CTrackShellMenu();
private:
    virtual ~CTrackShellMenu();

    IShellMenu*     _psmClient;
    IShellMenu*     _psm;
    IShellMenu2*    _psm2;
    IUnknown*       _punkSite;
    int             _cRef;
    HMENU           _hmenu;
    BITBOOL         _fDestroyTopLevel : 1;
};

HRESULT ToolbarMenu_Popup(HWND hwnd, LPRECT prc, IUnknown* punk, HWND hwndTB, int idMenu, DWORD dwFlags);
CMenuToolbarBase* ToolbarMenu_Create(HWND hwnd);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\legacy\tbmenu.cpp ===
#include "priv.h"
#include "resource.h"
#include "tbmenu.h"
#include "isfband.h"
#include "isfmenu.h"
#include "util.h"

#include "mluisupp.h"
#define SMFORWARD(x) if (!_psm) { return E_FAIL; } else return _psm->x

#define SUPERCLASS CMenuToolbarBase

CToolbarMenu::CToolbarMenu(DWORD dwFlags, HWND hwndTB) :
   CMenuToolbarBase(NULL, dwFlags),
   _hwndSubject(hwndTB)  // this is the toolbar that we are customizing
{
}

void CToolbarMenu::GetSize(SIZE* psize)
{
    ASSERT(_hwndMB);

    if (SendMessage(_hwndMB, TB_GETTEXTROWS, 0, 0) == 0) {
        // no text labels, so set a min width to make menu look 
        // pretty.  use min width of 4 * button width.
        LRESULT lButtonSize = SendMessage(_hwndMB, TB_GETBUTTONSIZE, 0, 0);
        LONG cxMin = 4 * LOWORD(lButtonSize);
        psize->cx = max(psize->cx, cxMin);
    }
    SUPERCLASS::GetSize(psize);
}

void CToolbarMenu::v_Show(BOOL fShow, BOOL fForceUpdate)
{
    if (fShow)
    {
        _fClickHandled = FALSE;
        _FillToolbar();
        _pcmb->SetTracked(NULL);  // Since hot item is NULL
        ToolBar_SetHotItem(_hwndMB, -1);
        if (fForceUpdate)
            v_UpdateButtons(TRUE);
    }
}

void CToolbarMenu::v_Close()
{
    _UnsubclassWindow(_hwndMB);
}


void CToolbarMenu::v_UpdateButtons(BOOL fNegotiateSize)
{
}


HRESULT CToolbarMenu::v_CallCBItem(int idtCmd, UINT dwMsg, WPARAM wParam, LPARAM lParam)
{
    return S_OK;
}

HRESULT CToolbarMenu::v_GetState(int idtCmd, LPSMDATA psmd)
{
    ASSERT(0);
    return E_NOTIMPL;
}

HRESULT CToolbarMenu::v_ExecItem(int idCmd)
{
    HRESULT hres = E_FAIL;
    TraceMsg(TF_TBMENU, "CToolbarMenu::v_ExecItem \tidCmd: %d", idCmd);
    return hres;
}

void CToolbarMenu::CreateToolbar(HWND hwndParent)
{
    if (!_hwndMB)
    {
        DWORD dwStyle = (WS_VISIBLE | WS_CHILD | TBSTYLE_FLAT |
                         WS_CLIPCHILDREN | WS_CLIPSIBLINGS | CCS_NODIVIDER | 
                         CCS_NOPARENTALIGN | CCS_NORESIZE  | TBSTYLE_REGISTERDROP | TBSTYLE_TOOLTIPS);

        INT_PTR nRows = SendMessage(_hwndSubject, TB_GETTEXTROWS, 0, 0);

        if (nRows > 0)
        {
            // We have text labels; make it TBSTYLE_LIST.  The base class will
            // set TBSTYLE_EX_VERTICAL for us.
            ASSERT(_fHorizInVerticalMB == FALSE);
            dwStyle |= TBSTYLE_LIST;
        }
        else
        {
            // No text labels; make it horizontal and TBSTYLE_WRAPABLE.  Set
            // _fHorizInVerticalMB so that the base class does not try and set
            // TBSTYLE_EX_VERTICAL.
            _fHorizInVerticalMB = TRUE;
            dwStyle |= TBSTYLE_WRAPABLE;
        }

        _hwndMB = CreateWindowEx(WS_EX_TOOLWINDOW, TOOLBARCLASSNAME, TEXT("Menu"), dwStyle,
                                 0, 0, 0, 0, hwndParent, (HMENU) FCIDM_TOOLBAR, HINST_THISDLL, NULL);

        if (!_hwndMB)
        {
            TraceMsg(TF_TBMENU, "CToolbarMenu::CreateToolbar: Failed to Create Toolbar");
            return;
        }

        HWND hwndTT = (HWND)SendMessage(_hwndMB, TB_GETTOOLTIPS, 0, 0);
        SHSetWindowBits(hwndTT, GWL_STYLE, TTS_ALWAYSTIP, TTS_ALWAYSTIP);
        SendMessage(_hwndMB, TB_BUTTONSTRUCTSIZE, SIZEOF(TBBUTTON), 0);
        SendMessage(_hwndMB, TB_SETMAXTEXTROWS, nRows, 0);
        SendMessage(_hwndMB, CCM_SETVERSION, COMCTL32_VERSION, 0);

        SendMessage(_hwndMB, TB_SETEXTENDEDSTYLE, TBSTYLE_EX_DRAWDDARROWS, TBSTYLE_EX_DRAWDDARROWS);

        int cPimgs = (int)SendMessage(_hwndSubject, TB_GETIMAGELISTCOUNT, 0, 0);
        for (int i = 0; i < cPimgs; i++)
        {
            HIMAGELIST himl = (HIMAGELIST)SendMessage(_hwndSubject, TB_GETIMAGELIST, i, 0);
            SendMessage(_hwndMB, TB_SETIMAGELIST, i, (LPARAM)himl);
            HIMAGELIST himlHot = (HIMAGELIST)SendMessage(_hwndSubject, TB_GETHOTIMAGELIST, i, 0);
            SendMessage(_hwndMB, TB_SETHOTIMAGELIST, i, (LPARAM)himlHot);
        }

        _SubclassWindow(_hwndMB);

        // Set the format to ANSI
        ToolBar_SetUnicodeFormat(_hwndMB, 0);

        CMenuToolbarBase::CreateToolbar(hwndParent);
        
    }
    else if (GetParent(_hwndMB) != hwndParent)
    {
        ::SetParent(_hwndMB, hwndParent);
    }
}


LRESULT CToolbarMenu::_DefWindowProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRes = CMenuToolbarBase::_DefWindowProcMB(hwnd, uMessage, wParam, lParam);

    if (lRes == 0)
        lRes = CNotifySubclassWndProc::_DefWindowProc(hwnd, uMessage, wParam, lParam);

    return lRes;
}

#define MAXLEN 256

void CToolbarMenu::_FillToolbar()
{
    RECT rcTB;
    TCHAR pszBuf[MAXLEN+1];
    LPTSTR psz;
    TBBUTTON tb;
    INT_PTR i, iCount;

    iCount = SendMessage(_hwndSubject, TB_BUTTONCOUNT, 0, 0L);
    GetClientRect(_hwndSubject, &rcTB);

    for (i = 0; i < iCount; i++) {
        if (SHIsButtonObscured(_hwndSubject, &rcTB, i)) {
            SendMessage(_hwndSubject, TB_GETBUTTON, i, (LPARAM)&tb);
            if (!(tb.fsStyle & BTNS_SEP)) {

                // autosize buttons look ugly here
                tb.fsStyle &= ~BTNS_AUTOSIZE;

                // need to rip off wrap bit; new toolbar will
                // figure out where wrapping should happen
                tb.fsState &= ~TBSTATE_WRAP;

                if (tb.iString == -1) {
                    // no string
                    psz = NULL;
                } else if (HIWORD(tb.iString)) {
                    // it's a string pointer
                    psz = (LPTSTR) tb.iString;
                } else {
                    // it's an index into toolbar string array
                    SendMessage(_hwndSubject, TB_GETSTRING, MAKELONG(MAXLEN, tb.iString), (LPARAM)pszBuf);
                    psz = pszBuf;
                }
                if (psz)
                    tb.iString = (INT_PTR)psz;
                else
                    tb.iString = -1;

                if (tb.iBitmap == -1) {
                    int id = GetDlgCtrlID(_hwndSubject);

                    NMTBDISPINFO  tbgdi = {0};
                    tbgdi.hdr.hwndFrom  = _hwndSubject;
                    tbgdi.hdr.idFrom    = id;
                    tbgdi.hdr.code      = TBN_GETDISPINFO;
                    tbgdi.dwMask        = TBNF_IMAGE;
                    tbgdi.idCommand     = tb.idCommand;
                    tbgdi.iImage        = 0;
                    tbgdi.lParam        = tb.dwData;

                    SendMessage(GetParent(_hwndSubject), WM_NOTIFY, (WPARAM)id, (LPARAM)&tbgdi);

                    if(tbgdi.dwMask & TBNF_DI_SETITEM)
                        tb.iBitmap = tbgdi.iImage;
                }

                SendMessage(_hwndMB, TB_ADDBUTTONS, 1, (LPARAM)&tb);
            }
        }
    }
}

STDMETHODIMP CToolbarMenu::IsWindowOwner(HWND hwnd) 
{ 
    if ( hwnd == _hwndMB) 
        return S_OK;
    else 
        return S_FALSE; 
}

void CToolbarMenu::_CancelMenu()
{
    IMenuPopup* pmp;
    if (EVAL(SUCCEEDED(_pcmb->QueryInterface(IID_IMenuPopup, (LPVOID*)&pmp)))) {
        // tell menuband it's time to die
        pmp->OnSelect(MPOS_FULLCANCEL);
        pmp->Release();
    }
}

STDMETHODIMP CToolbarMenu::OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres)
{
    HRESULT hres = S_FALSE;
    ASSERT(plres);

    switch (uMsg) {

    case WM_COMMAND:
        PostMessage(GetParent(_hwndSubject), WM_COMMAND, wParam, (LPARAM)_hwndSubject);
        _CancelMenu();
        hres = S_OK;
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;

            switch (pnmh->code) {

            case TBN_DROPDOWN:
                _fTrackingSubMenu = TRUE;
                pnmh->hwndFrom = _hwndSubject;
                MapWindowPoints(_hwndMB, _hwndSubject, (LPPOINT) &((LPNMTOOLBAR)pnmh)->rcButton, 2);
                *plres = SendMessage(GetParent(_hwndSubject), WM_NOTIFY, wParam, (LPARAM)pnmh);
                _CancelMenu();
                hres = S_OK;
                _fTrackingSubMenu = FALSE;
                break;

            case NM_CUSTOMDRAW:
                // override mnbase custom draw shiznits
                *plres = 0;
                hres = S_OK;
                break;

            default:
                goto DoDefault;
            }

            break;
        }
DoDefault:
    default:
        hres = SUPERCLASS::OnWinEvent(hwnd, uMsg, wParam, lParam, plres);
    }

    return hres;
}

CMenuToolbarBase* ToolbarMenu_Create(HWND hwnd)
{
    return new CToolbarMenu(0, hwnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\legacy\sftbar.h ===
#ifndef CSFTOOLBAR
#define CSFTOOLBAR

#include "iface.h"
#include "bands.h"
#include "cwndproc.h"
#include "droptgt.h"

// Each CISFBand toolbar button lParam points to one of these.
class IBDATA
{
protected:

    DWORD        _dwFlags;      // Class specific flags
    BITBOOL      _fNoIcon:1;
    PORDERITEM   _poi;

public:
    IBDATA(PORDERITEM poi)                  { _poi = poi; }
    virtual ~IBDATA()                       { /* Don't Delete Me */ }

    LPITEMIDLIST GetPidl()                  { return _poi ? _poi->pidl : NULL; }
    void         SetOrderItem(PORDERITEM poi) { _poi = poi; }
    DWORD        GetFlags()                 { return _dwFlags; }
    void         SetFlags(DWORD dwFlags)    { _dwFlags = dwFlags; }
    BOOL         GetNoIcon()                { return _fNoIcon; }
    void         SetNoIcon(BOOL b)          { _fNoIcon = BOOLIFY(b); }
    PORDERITEM   GetOrderItem()             { return _poi ; }
};

typedef IBDATA * PIBDATA;

// Special HitTest results
#define IBHT_SOURCE         (-32768)
#define IBHT_BACKGROUND     (-32767)
#define IBHT_PAGER          (-32766)
#define IBHT_OUTSIDEWINDOW  (-32765)

class CSFToolbar :  public IWinEventHandler, 
                    public IShellChangeNotify, 
                    public CDelegateDropTarget, 
                    public IContextMenu, 
                    public IShellFolderBand,
                    public CNotifySubclassWndProc
{
public:
    // *** IUnknown methods (override) ***
    virtual STDMETHODIMP_(ULONG) AddRef(void)  PURE;
    virtual STDMETHODIMP_(ULONG) Release(void) PURE;
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IWinEventHandler methods ***
    virtual STDMETHODIMP OnWinEvent (HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT* plre);
    virtual STDMETHODIMP IsWindowOwner(HWND hwnd);

    // *** IShellChangeNotify methods ***
    virtual STDMETHODIMP OnChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);

    // *** CDelegateDropTarget ***
    virtual HRESULT GetWindowsDDT (HWND * phwndLock, HWND * phwndScroll);
    virtual HRESULT HitTestDDT (UINT nEvent, LPPOINT ppt, DWORD_PTR * pdwId, DWORD *pdwEffect);
    virtual HRESULT GetObjectDDT (DWORD_PTR dwId, REFIID riid, LPVOID * ppvObj);
    virtual HRESULT OnDropDDT (IDropTarget *pdt, IDataObject *pdtobj, DWORD * pgrfKeyState, POINTL pt, DWORD *pdwEffect);

    // *** IContextMenu methods ***
    virtual STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT indexMenu,UINT idCmdFirst,UINT idCmdLast,UINT uFlags);
    virtual STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);
    virtual STDMETHODIMP GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pwReserved, LPSTR pszName, UINT cchMax);

    // *** IShellFolderBand ***
    virtual STDMETHODIMP InitializeSFB(LPSHELLFOLDER psf, LPCITEMIDLIST pidl) { return SetShellFolder(psf, pidl); };
    virtual STDMETHODIMP SetBandInfoSFB(BANDINFOSFB * pbi)  { return E_NOTIMPL; };
    virtual STDMETHODIMP GetBandInfoSFB(BANDINFOSFB * pbi)  { return E_NOTIMPL; };

    // Toolbar Management
    virtual HRESULT SetShellFolder(IShellFolder* psf, LPCITEMIDLIST pidl);
    virtual void    EmptyToolbar();

protected:
    CSFToolbar();
    virtual    ~CSFToolbar();

    virtual    void _CreateToolbar(HWND hwndParent);
    virtual HWND _CreatePager(HWND hwndParent);
    void    _DestroyToolbar();
    virtual void    _FillToolbar();
    void    _UnregisterToolbar();
    void    _RegisterToolbar();
    void    _RegisterChangeNotify();
    void    _UnregisterChangeNotify();      // Unregisters 

    void    _Refresh();
    void    _ReleaseShellFolder();

    virtual BOOL _AddPidl(LPITEMIDLIST pidl, int index);
    virtual PIBDATA _AddOrderItemTB(PORDERITEM poi, int index, TBBUTTON* ptbb);
    virtual void _FillDPA(HDPA hdpa, HDPA hdpaSort, DWORD dwEnumFlags);
    virtual PIBDATA _CreateItemData(PORDERITEM poi);
    virtual HWND GetHWNDForUIObject() { return _hwndTB; };
    virtual HRESULT _LoadOrderStream() { return E_NOTIMPL; };
    virtual HRESULT _SaveOrderStream();
    virtual BOOL    _AllowDropOnTitle() { return FALSE; };
    virtual HRESULT _GetIEnumIDList(DWORD dwEnumFlags, IEnumIDList **ppenum);

    LPITEMIDLIST    _pidl;
    IShellFolder*    _psf;
    ITranslateShellChangeNotify*    _ptscn;

    HWND            _hwndPager;
    HWND            _hwndTB;
    HWND            _hwndToolTips;

    DWORD           _dwStyle;           // style bits to be ORd in when _hwndTB is created
    TBINSERTMARK    _tbim;
    int             _iDragSource;
    HDPA            _hdpaOrder;         // current order list (if non-default)
    HDPA            _hdpa;              // current set of items, mirrors _hwndTB content
    long            _lEvents;

    int             _iButtonCur;
    IContextMenu    *_pcmSF;
    IContextMenu2 * _pcm2;

    int             _nNextCommandID;
    int             _idCmdSF;
    int             _cxMin;
    int             _cxMax;
    HWND            _hwndDD;
    HWND            _hwndWorkerWindow;

    // Flags
    BITBOOL         _fNoShowText :1;    // TRUE iff no text with icon
    BITBOOL         _fShow :1;          // TRUE when ShowDW has happened
    BITBOOL         _fDirty :1;         // TRUE iff hidden contents modified
    BITBOOL         _fCheckIds :1;      // TRUE iff _GetCommandID has wrapped
    BITBOOL         _fFSNotify :1;      // TRUE to receive FS Notifications
    BITBOOL         _fFSNRegistered :1; // are we already registered?
    BITBOOL         _fAccelerators :1;  // whether to show & as accel or as &
    BITBOOL         _fAllowRename :1;   // TRUE to query _psf for IContextMenu of _pidl
    BITBOOL         _fDropping :1;      // TRUE while doing drop.
    BITBOOL         _fDropped :1;       // TRUE if we have reordered, _hdpaOrder may not have been created yet
    BITBOOL         _fNoNameSort :1;    // TRUE if band should _not_ sort icons by name
    BITBOOL         _fVariableWidth :1; 
    BITBOOL         _fNoIcons :1;       // turns off icons
    BITBOOL         _fVertical :1;      // TRUE: band is displayed vertically
    BITBOOL         _fMulticolumn : 1;
    BITBOOL         _fHasOrder: 1;
    BITBOOL         _fPSFBandDesktop :1;// TRUE iff _psfBand came from desktop
                                            //          this implies psfDesktop->BindToObject(_pidl)
                                            //          results in the correct ISF
    BITBOOL         _fRegisterChangeNotify: 1;  // TRUE: We will register for change notify.
    BITBOOL         _fAllowReorder: 1;
    BITBOOL         _fChangedOrder: 1;      // Only send change notifies if we actually changed the order
    UINT            _uIconSize : 2;     // Large/Small/Logo


    // Virtual Function Overrides for Window Subclass
    virtual LRESULT _OnHotItemChange(NMTBHOTITEM * pnmhot);
    virtual HRESULT OnTranslatedChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    virtual LRESULT _OnTimer(WPARAM wParam);
    virtual LRESULT _DefWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual LRESULT _OnCustomDraw(NMCUSTOMDRAW* pnmcd);
    virtual void _OnDragBegin(int iItem, DWORD dwPreferedEffect);
    virtual void _OnToolTipsCreated(NMTOOLTIPSCREATED* pnm);
    virtual LRESULT _OnNotify(LPNMHDR pnm);
    virtual LRESULT _OnCommand(WPARAM wParam, LPARAM lParam) { return 0; };
    virtual void _OnFSNotifyAdd(LPCITEMIDLIST pidl);
    virtual void _OnFSNotifyRemove(LPCITEMIDLIST pidl);
    virtual void _OnFSNotifyRename(LPCITEMIDLIST pidlFrom, LPCITEMIDLIST pidlTo);
    virtual void _OnFSNotifyUpdate(LPCITEMIDLIST pidl);
    virtual HRESULT _OnRenameFolder(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    virtual HMENU _GetContextMenu(IContextMenu* pcm, int* pid);
    virtual void _OnDefaultContextCommand(int idCmd);
    virtual LRESULT _OnContextMenu(WPARAM wParam, LPARAM lParam);
    
    // Helper Functions
    int     _GetCommandID();
    virtual void    _ObtainPIDLName(LPCITEMIDLIST pidl, LPTSTR psz, int cchMax);
    BOOL    _IsParentID(LPCITEMIDLIST pidl);
    BOOL    _IsChildID(LPCITEMIDLIST pidlChild, BOOL fImmediate);
    BOOL    _IsEqualID(LPCITEMIDLIST pidl);
    LPVOID  _GetUIObjectOfPidl(LPCITEMIDLIST pidl, REFIID riid);
    HMENU   _GetBaseContextMenu();
    HRESULT _GetTopBrowserWindow(HWND* phwnd);
    HRESULT _OnOpen(int id, BOOL fExplore);
    HRESULT _HandleSpecialCommand(IContextMenu* pcm, PPOINT ppt, int id, int idCmd);
    LRESULT _DoContextMenu(IContextMenu* pcm, LPPOINT ppt, int id, LPRECT prcExclude);
    void _SortDPA(HDPA hdpa);
    virtual HWND CreateWorkerWindow();

    BOOL_PTR InlineDeleteButton(int iIndex);

    static INT_PTR CALLBACK _RenameDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    HRESULT _OnRename(LPPOINT ppt, int id);
    UINT    _IndexToID(int iIndex);
    LPCITEMIDLIST _IDToPidl(UINT uiCmd, int *piPos = NULL);
    PIBDATA _IDToPibData(UINT uiCmd, int * piPos = NULL);
    PIBDATA _PosToPibData(UINT iPos);
    void    _RememberOrder();
    void    _UpdateButtons();
    void    _OnGetDispInfo(LPNMHDR pnm, BOOL fUnicode);
    LPITEMIDLIST _GetButtonFromPidl(LPCITEMIDLIST pidl, TBBUTTONINFO * ptbbi, int * pIndex);
    DWORD   _GetAttributesOfPidl(LPCITEMIDLIST pidl, DWORD dwAttribs);
    BOOL    _UpdateShowText(BOOL fNoShowText);



    // Virtual Helper Functions
    virtual int     _GetBitmap(int iCommandID, PIBDATA pibdata, BOOL fUseCache);
    virtual void    _SetDirty(BOOL fDirty);
    virtual HMENU   _GetContextMenu();
    virtual BOOL    _UpdateIconSize(UINT uIconSize, BOOL fUpdateButton);
    virtual HRESULT _TBStyleForPidl(LPCITEMIDLIST pidl, 
                                   DWORD * pdwTBStyle, DWORD* pdwTBState, DWORD * pdwMIFFlags, int* piIcon);
    virtual BOOL    _FilterPidl(LPCITEMIDLIST pidl);
    virtual int     _DefaultInsertIndex();
    virtual void    _ToolbarChanged() { };
    virtual void    _Dropped(int nIndex, BOOL fDroppedOnSource);
    virtual HRESULT _AfterLoad();
    virtual void    v_CalcWidth(int* pcxMin, int* pcxMax);
    virtual void    _SetToolbarState();
    virtual void    v_NewItem(LPCITEMIDLIST pidl) {};

    static void s_NewItem(LPVOID pvParam, LPCITEMIDLIST pidl);
};

BOOL TBHasImage(HWND hwnd, int iImageIndex);
LRESULT CALLBACK HiddenWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\legacy\track.cpp ===
#include "priv.h"
#include "tbmenu.h"
#include "isfband.h"
#include "isfmenu.h"

#include "mluisupp.h"
#define SMFORWARD(x) if (!_psm) { return E_FAIL; } else return _psm->x

typedef struct
{
    WNDPROC pfnOriginal;
    IMenuBand* pmb;
} MENUHOOK;

#define SZ_MENUHOOKPROP TEXT("MenuHookProp")

LRESULT CALLBACK MenuHookWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    MENUHOOK* pmh = (MENUHOOK*)GetProp(hwnd, SZ_MENUHOOKPROP);

    if (pmh)
    {
        MSG msg;
        LRESULT lres;

        msg.hwnd = hwnd;
        msg.message = uMsg;
        msg.wParam = wParam;
        msg.lParam = lParam;

        if (pmh->pmb->TranslateMenuMessage(&msg, &lres) == S_OK)
            return lres;

        wParam = msg.wParam;
        lParam = msg.lParam;
        return CallWindowProc(pmh->pfnOriginal, hwnd, uMsg, wParam, lParam);
    }

    return 0;
}

HRESULT HookMenuWindow(HWND hwnd, IMenuBand* pmb)
{
    HRESULT hres = E_FAIL;

    ASSERT(IsWindow(hwnd));

    // make sure we haven't already hooked this window
    if (GetProp(hwnd, SZ_MENUHOOKPROP) == NULL)
    {
        MENUHOOK* pmh = new MENUHOOK;
        if (pmh)
        {
            pmh->pfnOriginal = (WNDPROC)GetWindowLongPtr(hwnd, GWLP_WNDPROC);
            pmh->pmb = pmb;

            SetProp(hwnd, SZ_MENUHOOKPROP, pmh);

            SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)MenuHookWndProc);

            hres = S_OK;
        }
    }
    return hres;
}

void UnHookMenuWindow(HWND hwnd)
{

    MENUHOOK* pmh = (MENUHOOK*)GetProp(hwnd, SZ_MENUHOOKPROP);
    if (pmh)
    {
        SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR) pmh->pfnOriginal);
        SetProp(hwnd, SZ_MENUHOOKPROP, NULL);
        delete pmh;
    }

}


// This class is here to implement a "Menu Filter". We need this because the old style of 
// implementing obscured Menus does not work because user munges the WM_INITMENUPOPUP information
// based on the relative position within the HMENU. So here we keep that information, we just hide the item.

class CShellMenuCallbackWrapper : public IShellMenuCallback,
                                  public CObjectWithSite
{
    int _cRef;
    IShellMenuCallback* _psmc;
    HWND    _hwnd;
    RECT    _rcTB;
    ~CShellMenuCallbackWrapper()
    {
        ATOMICRELEASE(_psmc);
    }

public:
    CShellMenuCallbackWrapper(HWND hwnd, IShellMenuCallback* psmc) : _cRef(1)
    {
        _psmc = psmc;
        if (_psmc)
            _psmc->AddRef();
        _hwnd = hwnd;
        GetClientRect(_hwnd, &_rcTB);
    }

    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface (REFIID riid, LPVOID * ppvObj)
    {
        static const QITAB qit[] = 
        {
            QITABENT(CShellMenuCallbackWrapper, IShellMenuCallback),
            QITABENT(CShellMenuCallbackWrapper, IObjectWithSite),
            { 0 },
        };

        return QISearch(this, qit, riid, ppvObj);
    }

    STDMETHODIMP_(ULONG) AddRef()
    {
        _cRef++;
        return _cRef;
    }

    STDMETHODIMP_(ULONG) Release()
    {
        ASSERT(_cRef > 0);
        _cRef--;

        if (_cRef > 0)
            return _cRef;

        delete this;
        return 0;
    }

    // *** CObjectWithSite methods (override)***
    STDMETHODIMP SetSite(IUnknown* punk)            {   return IUnknown_SetSite(_psmc, punk);   }
    STDMETHODIMP GetSite(REFIID riid, void** ppObj) {   return IUnknown_GetSite(_psmc, riid, ppObj); }

    // *** IShellMenuCallback methods ***
    STDMETHODIMP CallbackSM(LPSMDATA psmd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        HRESULT hres = S_FALSE;
        
        if (_psmc)
            hres = _psmc->CallbackSM(psmd, uMsg, wParam, lParam);

        if (uMsg == SMC_GETINFO)
        {
            SMINFO* psminfo = (SMINFO*)lParam;
            int iPos = (int)SendMessage(_hwnd, TB_COMMANDTOINDEX, psmd->uId, 0);

            if (psminfo->dwMask & SMIM_FLAGS &&
                iPos >= 0 && 
                !SHIsButtonObscured(_hwnd, &_rcTB, iPos))
            {
                psminfo->dwFlags |= SMIF_HIDDEN;
                hres = S_OK;
            }
        }

        return hres;
    }
};



//
// CTrackShellMenu implementation
//


STDAPI  CTrackShellMenu_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    HRESULT hres = E_OUTOFMEMORY;
    CTrackShellMenu* pObj = new CTrackShellMenu();
    if (pObj)
    {
        hres = pObj->QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
        pObj->Release();
    }

    return hres;
}

CTrackShellMenu::CTrackShellMenu() : _cRef(1)
{ 
    if (SUCCEEDED(CoCreateInstance(CLSID_MenuBand, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellMenu, &_psm))))
    {
        _psm->QueryInterface(IID_PPV_ARG(IShellMenu2, &_psm2));
    }
}

CTrackShellMenu::~CTrackShellMenu()
{
    ATOMICRELEASE(_psm2);
    ATOMICRELEASE(_psm);
    ATOMICRELEASE(_psmClient);
    ASSERT(!_punkSite);     // else someone neglected to call matching SetSite(NULL)
}

ULONG CTrackShellMenu::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CTrackShellMenu::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CTrackShellMenu::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENTMULTI(CTrackShellMenu, IShellMenu, ITrackShellMenu), 
        QITABENT(CTrackShellMenu, ITrackShellMenu),   
        QITABENT(CTrackShellMenu, IShellMenu2),   
        QITABENT(CTrackShellMenu, IObjectWithSite),
        QITABENT(CTrackShellMenu, IServiceProvider),
        { 0 },
    };

    HRESULT hres = QISearch(this, qit, riid, ppvObj);

    return hres;
}

// *** IServiceProvider methods ***
HRESULT CTrackShellMenu::QueryService(REFGUID guidService,
                                  REFIID riid, void **ppvObj)
{
    return IUnknown_QueryService(_psm, guidService, riid, ppvObj);
}

// *** IShellMenu methods ***
STDMETHODIMP CTrackShellMenu::Initialize(IShellMenuCallback* psmc, UINT uId, UINT uIdAncestor, DWORD dwFlags)
{ SMFORWARD(Initialize(psmc, uId, uIdAncestor, dwFlags)); }

STDMETHODIMP CTrackShellMenu::GetMenuInfo(IShellMenuCallback** ppsmc, UINT* puId, UINT* puIdAncestor, DWORD* pdwFlags)
{ SMFORWARD(GetMenuInfo(ppsmc, puId, puIdAncestor, pdwFlags)); }

STDMETHODIMP CTrackShellMenu::SetShellFolder(IShellFolder* psf, LPCITEMIDLIST pidlFolder, HKEY hkey, DWORD dwFlags)
{ SMFORWARD(SetShellFolder(psf, pidlFolder, hkey, dwFlags)); }

STDMETHODIMP CTrackShellMenu::GetShellFolder(DWORD* pdwFlags, LPITEMIDLIST* ppidl, REFIID riid, void** ppvObj)
{ SMFORWARD(GetShellFolder(pdwFlags, ppidl, riid, ppvObj)); }

STDMETHODIMP CTrackShellMenu::SetMenu(HMENU hmenu, HWND hwnd, DWORD dwFlags)
{ SMFORWARD(SetMenu(hmenu, hwnd, dwFlags)); }

STDMETHODIMP CTrackShellMenu::GetMenu(HMENU* phmenu, HWND* phwnd, DWORD* pdwFlags)
{ SMFORWARD(GetMenu(phmenu, phwnd, pdwFlags)); }

STDMETHODIMP CTrackShellMenu::InvalidateItem(LPSMDATA psmd, DWORD dwFlags)
{ SMFORWARD(InvalidateItem(psmd, dwFlags)); }

STDMETHODIMP CTrackShellMenu::GetState(LPSMDATA psmd)
{ SMFORWARD(GetState(psmd)); }

STDMETHODIMP CTrackShellMenu::SetMenuToolbar(IUnknown* punk, DWORD dwFlags)
{ SMFORWARD(SetMenuToolbar(punk, dwFlags)); }

STDMETHODIMP CTrackShellMenu::GetSubMenu(UINT idCmd, REFIID riid, void **ppvObj)
{
    if (_psm2)
    {
        return _psm2->GetSubMenu(idCmd, riid, ppvObj);
    }
    else
    {
        return E_NOTIMPL;
    }
}

STDMETHODIMP CTrackShellMenu::SetToolbar(HWND hwnd, DWORD dwFlags)
{
    if (_psm2)
    {
        return _psm2->SetToolbar(hwnd, dwFlags);
    }
    else
    {
        return E_NOTIMPL;
    }
}

STDMETHODIMP CTrackShellMenu::SetMinWidth(int cxMenu)
{
    if (_psm2)
    {
        return _psm2->SetMinWidth(cxMenu);
    }
    else
    {
        return E_NOTIMPL;
    }
}

STDMETHODIMP CTrackShellMenu::SetNoBorder(BOOL fNoBorder)
{
    if (_psm2)
    {
        return _psm2->SetNoBorder(fNoBorder);
    }
    else
    {
        return E_NOTIMPL;
    }
}

STDMETHODIMP CTrackShellMenu::SetTheme(LPCWSTR pszTheme)
{
    if (_psm2)
    {
        return _psm2->SetTheme(pszTheme);
    }
    else
    {
        return E_NOTIMPL;
    }
}

// *** ITrackShellMenu methods ***
HRESULT CTrackShellMenu::SetObscured(HWND hwndTB, IUnknown* punkBand, DWORD dwSMSetFlags)
{
    HRESULT hr = E_OUTOFMEMORY;

    // Make sure we created the Inner Shell Menu
    if (!_psm)
        return hr;

    if (punkBand && 
        SUCCEEDED(punkBand->QueryInterface(IID_PPV_ARG(IShellMenu, &_psmClient))))
    {
        UINT uId, uIdAncestor;
        DWORD dwFlags;
        IShellMenuCallback* psmcb;

        hr = _psmClient->GetMenuInfo(&psmcb, &uId, &uIdAncestor, &dwFlags);
        if (SUCCEEDED(hr))
        {
            IShellMenuCallback* psmcbClone = NULL;
            if (psmcb)
            {
                if (S_FALSE == psmcb->CallbackSM(NULL, SMC_GETOBJECT, 
                    (WPARAM)&IID_IShellMenuCallback,
                    (LPARAM)(LPVOID*)&psmcbClone))
                {
                    psmcbClone = psmcb;
                    psmcbClone->AddRef();
                }
            }

            dwFlags &= ~SMINIT_HORIZONTAL;

            CShellMenuCallbackWrapper* psmcw = new CShellMenuCallbackWrapper(hwndTB, psmcbClone);

            // We want the bands to think it is:
            // Top level - because it has no menuband parent
            // Vertical  - because it's not a menubar
            dwFlags |= SMINIT_TOPLEVEL | SMINIT_VERTICAL;
            hr = _psm->Initialize(psmcw, uId, ANCESTORDEFAULT, dwFlags);

            if (SUCCEEDED(hr))
            {
                HWND hwndOwner;
                HMENU hmenuObscured;
                hr = _psmClient->GetMenu(&hmenuObscured, &hwndOwner, NULL);
                if (SUCCEEDED(hr))
                {
                    hr = _psm->SetMenu(hmenuObscured, hwndOwner, dwSMSetFlags | SMSET_DONTOWN);   // Menuband takes ownership;
                }
            }

            if (psmcb)
                psmcb->Release();

            if (psmcbClone)
                psmcbClone->Release();

            if (psmcw)
                psmcw->Release();

        }
    }
    else
    {
        IShellMenu2 *psm2;
        hr = _psm->QueryInterface(IID_PPV_ARG(IShellMenu2, &psm2));
        if (SUCCEEDED(hr))
        {
            hr = psm2->SetToolbar(hwndTB, dwSMSetFlags);
            psm2->Release();
        }
    }

    return hr;
}

HRESULT CTrackShellMenu::Popup(HWND hwnd, POINTL *ppt, RECTL *prcExclude, DWORD dwFlags)
{
    IMenuBand* pmb;
    HRESULT hres = E_INVALIDARG;


    if (!_psm)
        return hres;

    hres = _psm->QueryInterface(IID_PPV_ARG(IMenuBand, &pmb));
    if (FAILED(hres))
        return hres;

    HWND hwndParent = GetTopLevelAncestor(hwnd);

    // Did the user set a menu into the Shell Menu?
    HWND hwndSubclassed = NULL;
    GetMenu(NULL, &hwndSubclassed, NULL);
    if (hwndSubclassed == NULL)
    {
        // No; We need to artificially set one so that the message filtering and stuff works
        SetMenu(NULL, hwndParent, 0);
    }

    SetForegroundWindow(hwndParent);

    IMenuPopup* pmp;
    hres = CoCreateInstance(CLSID_MenuDeskBar, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IMenuPopup, &pmp));
    if (SUCCEEDED(hres))
    {
        IBandSite* pbs;
        hres = CoCreateInstance(CLSID_MenuBandSite, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IBandSite, &pbs));
        if (SUCCEEDED(hres)) 
        {
            hres = pmp->SetClient(pbs);
            if (SUCCEEDED(hres)) 
            {
                IDeskBand* pdb;
                hres = _psm->QueryInterface(IID_PPV_ARG(IDeskBand, &pdb));
                if (SUCCEEDED(hres)) 
                {
                    hres = pbs->AddBand(pdb);
                    pdb->Release();
                }
            }
            pbs->Release();
        }

        // If we've got a site ourselves, have MenuDeskBar use that.
        if (_punkSite)
            IUnknown_SetSite(pmp, _punkSite);

        if (SUCCEEDED(hres))
        {
            CMBMsgFilter* pmf = GetMessageFilter();
            void* pvContext = GetMessageFilter()->GetContext();
            hres = HookMenuWindow(hwndParent, pmb);
            if (SUCCEEDED(hres))
            {
                // This collapses any modal menus before we proceed. When switching between
                // Chevron menus, we need to collapse the previous menu. Refer to the comment
                // at the function definition.
                pmf->ForceModalCollapse();

                pmp->Popup(ppt, (LPRECTL)prcExclude, dwFlags);

                pmf->SetModal(TRUE);

                MSG msg;
                while (GetMessage(&msg, NULL, 0, 0)) 
                {
                    HRESULT hres = pmb->IsMenuMessage(&msg);
                    if (hres == E_FAIL)
                    {
                        // menuband says it's time to pack up and go home.
                        // re-post this message so that it gets handled after
                        // we've cleaned up the menu (avoid re-entrancy issues &
                        // let rebar restore state of chevron button to unpressed)
                        PostMessage(msg.hwnd, msg.message, msg.wParam, msg.lParam);
                        break;
                    }
                    else if (hres != S_OK) 
                    {
                        // menuband didn't handle this one
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    }
                }

                hres = S_OK;
                UnHookMenuWindow(hwndParent);
                // We cannot change the context when modal, so unset the modal flag so that we can undo the context block.
                pmf->SetModal(FALSE); 
                pmf->SetContext(pvContext, TRUE);
            }
            pmb->Release();
        }

        if (_psmClient)
        {
            // This is to fix a bug where if there is a cached ISHellMenu in the submenu,
            // and you share the callback (For example, Broweser menu callback and the
            // favorites menu being shared between the browser bar and the chevron menu)
            // when on menu collapsed, we were destroying the sub menu by doing a set site.
            // since we no longer do the set site on the sub menu, we need a way to say "Reset
            // your parent". and this is the best way.
            IUnknown_Exec(_psmClient, &CGID_MenuBand, MBANDCID_REFRESH, 0, NULL, NULL);
        }

        // This call is required regardless of whether we had a _punkSite above;
        // MenuDeskBar does its cleanup on SetSite(NULL).
        IUnknown_SetSite(pmp, NULL);
        pmp->Release();
    }

    return hres;
}

// *** IObjectWithSite methods ***
HRESULT CTrackShellMenu::SetSite(IUnknown* punkSite)
{
    ASSERT(NULL == punkSite || IS_VALID_CODE_PTR(punkSite, IUnknown));

    ATOMICRELEASE(_punkSite);

    _punkSite = punkSite;

    if (punkSite)
        punkSite->AddRef();

    return S_OK;
}

BOOL IsISFBand(IUnknown* punk)
{
    OLECMD rgCmds[] = {
        ISFBID_PRIVATEID, 0,
    };

    IUnknown_QueryStatus(punk, &CGID_ISFBand, SIZEOF(rgCmds), rgCmds, NULL);

    return BOOLIFY(rgCmds[0].cmdf);
}

HRESULT DoISFBandStuff(ITrackShellMenu* ptsm, IUnknown* punk)
{
    HRESULT hr = E_INVALIDARG;

    if (punk && ptsm)
    {
        IShellFolderBand* psfb;
        hr = punk->QueryInterface(IID_PPV_ARG(IShellFolderBand, &psfb));

        if (SUCCEEDED(hr))
        {
            BANDINFOSFB bi;
            bi.dwMask = ISFB_MASK_IDLIST | ISFB_MASK_SHELLFOLDER;

            hr = psfb->GetBandInfoSFB(&bi);

            if (SUCCEEDED(hr))
            {
                CISFMenuCallback* pCallback = new CISFMenuCallback();

                if (pCallback)
                {
                    hr = pCallback->Initialize(punk);

                    if (SUCCEEDED(hr))
                    {
                        ptsm->Initialize(SAFECAST(pCallback, IShellMenuCallback*), 0, 
                            ANCESTORDEFAULT, SMINIT_VERTICAL | SMINIT_TOPLEVEL);

                        hr = ptsm->SetShellFolder(bi.psf, bi.pidl, NULL, SMSET_COLLAPSEONEMPTY);
                    }
                    pCallback->Release();
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

                bi.psf->Release();
                ILFree(bi.pidl);
            }

            psfb->Release();
        }
    }

    return hr;
}


// An API for internal use.
HRESULT ToolbarMenu_Popup(HWND hwnd, LPRECT prc, IUnknown* punk, HWND hwndTB, int idMenu, DWORD dwFlags)
{
    HRESULT hres = E_OUTOFMEMORY;
    ITrackShellMenu* ptsm;
    if (SUCCEEDED(CoCreateInstance(CLSID_TrackShellMenu, NULL, CLSCTX_INPROC_SERVER,
        IID_PPV_ARG(ITrackShellMenu, &ptsm))))
    {
        hres = S_OK;
        if (IsISFBand(punk))
        {
            hres = DoISFBandStuff(ptsm, punk);
        }
        else if (hwndTB)
        {
            ptsm->Initialize(NULL, 0, ANCESTORDEFAULT, SMINIT_TOPLEVEL | SMINIT_VERTICAL | SMINIT_RESTRICT_DRAGDROP);
            hres = ptsm->SetObscured(hwndTB, punk, SMSET_TOP);
        }

        IUnknown* punkSite;
        if (SUCCEEDED(IUnknown_GetSite(punk, IID_PPV_ARG(IUnknown, &punkSite))))
            IUnknown_SetSite(ptsm, punkSite);

        HMENU hmenu = idMenu ? LoadMenuPopup(idMenu) : NULL;

        if (SUCCEEDED(hres) && hmenu)
            hres = ptsm->SetMenu(hmenu, hwnd, SMSET_BOTTOM);

        if (SUCCEEDED(hres))
        {
            DWORD dwPopupFlags = MPPF_BOTTOM;

            // select first/last menu item if specified
            if (dwFlags == DBPC_SELECTFIRST)
            {
                dwPopupFlags |= MPPF_INITIALSELECT;
            }
            else if (dwFlags == DBPC_SELECTLAST)
            {
                dwPopupFlags |= MPPF_FINALSELECT;
            }
            else if (dwFlags != 0)
            {
                VARIANT var;
                var.vt = VT_I4;
                var.lVal = dwFlags;
                IShellMenu2* psm2;
                if (SUCCEEDED(ptsm->QueryInterface(IID_PPV_ARG(IShellMenu2, &psm2))))
                {
                    IUnknown_QueryServiceExec(psm2, SID_SMenuBandChild, &CGID_MenuBand, MBANDCID_SELECTITEM, 0, &var, NULL);
                    psm2->Release();
                }
            }

            POINTL ptPop = {prc->left, prc->bottom};
            hres = ptsm->Popup(hwnd, &ptPop, (LPRECTL)prc, dwPopupFlags);
        }

        IUnknown_SetSite(ptsm, NULL);
        ptsm->Release();
    }
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\resdll\makefile.inc ===
..\browselc.rc : $(SDK_LIB_PATH)\exdisp.tlb $(BROWSEUI_DEP)

!include $(CCSHELL_DIR)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\tools\uadump.cpp ===
#include "priv.h"
#include "resource.h"
#include "itbar.h"
#include "itbdrop.h"

#include <stdlib.h>
#include <stdio.h>

struct valstr {
    int     val;
    char *  str;
};

#define TABENT(id)  { id, # id },
struct valstr ValStrTab[] = {
    // these guys come from doing:
    // qgrep IDM_ *.h unicpp/*.h ../inc/*.h
    // qgrep DVM_ *.h unicpp/*.h ../inc/*.h
    // magic editor commands to change to the right format:
    //  g/#define/s/.*#define /TABENT(/
    //  g/TABENT/s/\([^ ]*\).*/\1)/

#if 0
    // itbar.h
    TABENT(CITIDM_ONINTERNET)
    TABENT(CITIDM_THEATER)
    TABENT(CITIDM_TEXTLABELS)
    TABENT(CITIDM_VIEWTOOLS)
    TABENT(CITIDM_VIEWADDRESS)
    TABENT(CITIDM_VIEWLINKS)
    TABENT(CITIDM_SHOWTOOLS)
    TABENT(CITIDM_SHOWADDRESS)
    TABENT(CITIDM_SHOWLINKS)
    TABENT(CITIDM_EDITPAGE)
    TABENT(CITIDM_BRANDSIZE)
    TABENT(CITIDM_VIEWMENU)
    TABENT(CITIDM_VIEWAUTOHIDE)
    TABENT(CITIDM_GETMINROWHEIGHT)
    TABENT(CITIDM_SHOWMENU)
    TABENT(CITIDM_STATUSCHANGED)
    TABENT(CITIDM_GETDEFAULTBRANDCOLOR)
    TABENT(CITIDM_DISABLESHOWMENU)
    TABENT(CITIDM_SET_DIRTYBIT)
    TABENT(CITIDM_VIEWTOOLBARCUSTOMIZE)
#endif
    // itbdrop.h
    TABENT(TBIDM_BACK)
    TABENT(TBIDM_FORWARD)
    TABENT(TBIDM_HOME)
    TABENT(TBIDM_SEARCH)
    TABENT(TBIDM_STOPDOWNLOAD)
    TABENT(TBIDM_REFRESH)
    TABENT(TBIDM_FAVORITES)
#ifdef TBIDM_PRINT // old-style (pre-chee) toolbar
    TABENT(TBIDM_PRINT)
#endif
    TABENT(TBIDM_THEATER)
#ifdef TBIDM_PRINT
    TABENT(TBIDM_EDIT)
    TABENT(TBIDM_SHOWTOOLS)
    TABENT(TBIDM_HIDETOOLS)
    TABENT(TBIDM_MAILNEWS)
    TABENT(TBIDM_FONTS)
#endif
    TABENT(TBIDM_HISTORY)
#if defined(ENABLE_CHANNELS) && defined(TBIDM_CHANNELS)
    TABENT(TBIDM_CHANNELS)
#endif
#ifdef TBIDM_PRINT
    TABENT(TBIDM_QUICKLINK1)
    TABENT(TBIDM_QUICKLINK2)
    TABENT(TBIDM_QUICKLINK3)
    TABENT(TBIDM_QUICKLINK4)
    TABENT(TBIDM_QUICKLINK5)
#endif
    // resource.h
    TABENT(BSIDM_CLOSEBAND)
    TABENT(BSIDM_SHOWTITLEBAND)
    TABENT(BSIDM_IEAK_DISABLE_DDCLOSE)
    TABENT(BSIDM_IEAK_DISABLE_MOVE)
    TABENT(ISFBIDM_LARGE)
    TABENT(ISFBIDM_SMALL)
    TABENT(ISFBIDM_LOGOS)
    TABENT(ISFBIDM_SHOWTEXT)
    TABENT(ISFBIDM_REFRESH)
    TABENT(ISFBIDM_OPEN)
    TABENT(DBIDM_NEWFOLDERBAND)
    TABENT(DBIDM_DESKTOPBAND)
    TABENT(DBIDM_LAUNCHBAND)
    TABENT(DBIDM_NEWBANDFIXEDLAST)
    TABENT(MNIDM_RESORT)
    TABENT(MNIDM_LAST)
    TABENT(IDM_AB_FIRST)
    TABENT(IDM_AB_LEFT)
    TABENT(IDM_AB_TOP)
    TABENT(IDM_AB_RIGHT)
    TABENT(IDM_AB_BOTTOM)
    TABENT(IDM_AB_BOTTOMMOST)
    TABENT(IDM_AB_TOPMOST)
    TABENT(IDM_AB_REGULAR)
    TABENT(IDM_AB_AUTOHIDE)
    TABENT(IDM_AB_CLOSE)
    TABENT(IDM_AB_ENABLEMODELESS)
    TABENT(IDM_AB_DISABLEMODELESS)
    TABENT(IDM_AB_ACTIVATE)
    TABENT(IDM_AB_LAST)
    TABENT(DVIDM_GOHOME)
    TABENT(FCIDM_DROPDRIVELIST)
    TABENT(DVIDM_OPEN)
    TABENT(DVIDM_SAVE)
    TABENT(DVIDM_SAVEASFILE)
    TABENT(DVIDM_PAGESETUP)
    TABENT(DVIDM_PRINT)
    TABENT(DVIDM_PROPERTIES)
    TABENT(DVIDM_CUT)
    TABENT(DVIDM_COPY)
    TABENT(DVIDM_PASTE)
    TABENT(DVIDM_REFRESH)
    TABENT(DVIDM_STOPDOWNLOAD)
    TABENT(DVIDM_ZOOMIN)
    TABENT(DVIDM_ZOOMOUT)
    TABENT(DVIDM_NEWWINDOW)
    TABENT(DVIDM_NEWMESSAGE)
    TABENT(DVIDM_SEND)
    TABENT(DVIDM_SENDPAGE)
    TABENT(DVIDM_SENDSHORTCUT)
    TABENT(DVIDM_DESKTOPSHORTCUT)
    TABENT(DVIDM_SENDTO)
    TABENT(DVIDM_SENDTOFIRST)
    TABENT(DVIDM_SENDTOLAST)
    TABENT(DVIDM_HELPABOUT)
    TABENT(DVIDM_HELPSEARCH)
    TABENT(DVIDM_HELPTUTORIAL)
    TABENT(DVIDM_HELPMSWEB)
    TABENT(DVIDM_HELPREPAIR)
    TABENT(DVIDM_HELPMSWEBLAST)
    TABENT(DVIDM_SUITE_APP_FIRST)
    TABENT(DVIDM_NEW)
    TABENT(DVIDM_NEWPOST)
    TABENT(DVIDM_NEWAPPOINTMENT)
    TABENT(DVIDM_NEWMEETING)
    TABENT(DVIDM_NEWCONTACT)
    TABENT(DVIDM_NEWTASK)
    TABENT(DVIDM_NEWTASKREQUEST)
    TABENT(DVIDM_NEWJOURNAL)
    TABENT(DVIDM_NEWNOTE)
    TABENT(DVIDM_CALL)
    TABENT(DVIDM_SUITE_APP_LAST)
    TABENT(DVIDM_NONSUITE_APP_FIRST)
    TABENT(DVIDM_NONSUITE_APP_LAST)
    TABENT(DVIDM_MSHTML_FIRST)
    TABENT(DVIDM_MSHTML_LAST)
    TABENT(FCIDM_FIRST)
    TABENT(FCIDM_LAST)
    TABENT(FCIDM_BROWSER_FILE)
    TABENT(FCIDM_FILECLOSE)
    TABENT(FCIDM_PREVIOUSFOLDER)
    TABENT(FCIDM_DELETE)
    TABENT(FCIDM_RENAME)
    TABENT(FCIDM_PROPERTIES)
    TABENT(FCIDM_VIEWOFFLINE)
    TABENT(FCIDM_FILENSCBANDSEP)
    // IE4 shipped with FCIDM_NEXTCTL as 0xA030 and we can not change it
    TABENT(FCIDM_NEXTCTL)
    TABENT(FCIDM_BACKSPACE)
#ifdef TEST_AMBIENTS
    TABENT(FCIDM_VIEWLOCALOFFLINE)
    TABENT(FCIDM_VIEWLOCALSILENT)
#endif
    TABENT(FCIDM_BROWSER_EDIT)
    TABENT(FCIDM_MOVE)
    TABENT(FCIDM_COPY)
    TABENT(FCIDM_PASTE)
    TABENT(FCIDM_SELECTALL)
    TABENT(FCIDM_LINK)
    TABENT(FCIDM_EDITPAGE)
    // APPCOMPAT:: IOmega relies on FCIDM_REFRESH was WM_COMMAND of A065
    TABENT(FCIDM_W95REFRESH)
    TABENT(FCIDM_BROWSER_TOOLS)
    TABENT(FCIDM_CONNECT)
    TABENT(FCIDM_DISCONNECT)
    TABENT(FCIDM_CONNECT_SEP)
    TABENT(FCIDM_GETSTATUSBAR)
    // IE4 shipped with FCIDM_FINDFILES as 0xA0085 and we can not change it
    TABENT(FCIDM_FINDFILES)
    // IE4 shipped with FCIDM_FINDFILES as 0xA0086 and we can not change it
    TABENT(FCIDM_FINDCOMPUTER)
    TABENT(FCIDM_SETSTATUSBAR)
    TABENT(FCIDM_PERSISTTOOLBAR)
    TABENT(FCIDM_MENU_TOOLS_FINDFIRST)
    TABENT(FCIDM_MENU_TOOLS_FINDLAST)
    TABENT(FCIDM_BROWSER_HELP)
    TABENT(FCIDM_HELPSEARCH)
    TABENT(FCIDM_HELPABOUT)
    TABENT(FCIDM_BROWSER_EXPLORE)
    TABENT(FCIDM_NAVIGATEBACK)
    TABENT(FCIDM_NAVIGATEFORWARD)
    TABENT(FCIDM_BROWSEROPTIONS)
    TABENT(FCIDM_LINKSSEPARATOR)
    TABENT(FCIDM_STARTPAGE)
    TABENT(FCIDM_UPDATEPAGE)
    TABENT(FCIDM_CHANNELGUIDE)
    TABENT(FCIDM_MAIL)
    TABENT(FCIDM_NEWS)
    TABENT(FCIDM_MAILNEWSSEPARATOR)
    TABENT(FCIDM_NEWMESSAGE)
    TABENT(FCIDM_SENDLINK)
    TABENT(FCIDM_SENDDOCUMENT)
    TABENT(FCIDM_SEARCHSIMILAR)
    TABENT(FCIDM_OPEN_SUBSCRIPTION)
    TABENT(FCIDM_MYCOMPUTER)
    TABENT(FCIDM_SEARCHMENU)
    TABENT(FCIDM_RECENTFIRST)
    TABENT(FCIDM_RECENTLAST)
    TABENT(FCIDM_RECENTMENU)
    TABENT(FCIDM_FAVS_FIRST)
    TABENT(FCIDM_ORGANIZEFAVORITES)
    TABENT(FCIDM_ADDTOFAVORITES)
    TABENT(FCIDM_FAVS_MORE)
    TABENT(FCIDM_FAVORITEFIRST)
    TABENT(FCIDM_UPDATESUBSCRIPTIONS)
    TABENT(FCIDM_SORTBY)
    TABENT(FCIDM_SORTBYNAME)
    TABENT(FCIDM_SORTBYVISIT)
    TABENT(FCIDM_SORTBYDATE)
    TABENT(FCIDM_FAVAUTOARRANGE)
    TABENT(FCIDM_SUBSCRIPTIONS)
    TABENT(FCIDM_SUBSCRIBE)
    TABENT(FCIDM_FAVORITELAST)
    TABENT(FCIDM_FAVORITE_ITEM)
    TABENT(FCIDM_FAVORITECMDFIRST)
    TABENT(FCIDM_FAVORITECMDLAST)
    TABENT(FCIDM_FAVS_LAST)
    TABENT(FCIDM_BROWSER_VIEW)
    TABENT(FCIDM_VIEWTOOLBAR)
    TABENT(FCIDM_VIEWSTATUSBAR)
    TABENT(FCIDM_VIEWOPTIONS)
    TABENT(FCIDM_VIEWTOOLS)
    TABENT(FCIDM_VIEWADDRESS)
    TABENT(FCIDM_VIEWLINKS)
    TABENT(FCIDM_VIEWTEXTLABELS)
#ifdef TBIDM_PRINT
    TABENT(FCIDM_VIEWTBCUST)
#endif
    TABENT(FCIDM_VIEWAUTOHIDE)
    TABENT(FCIDM_VIEWMENU)
    TABENT(FCIDM_STOP)
    TABENT(FCIDM_VIEWTREE)
    TABENT(FCIDM_VIEWSEARCH)
    TABENT(FCIDM_CUSTOMIZEFOLDER)
    TABENT(FCIDM_VIEWFONTS)
    // 1a is FCIDM_STOP
    TABENT(FCIDM_THEATER)
    TABENT(FCIDM_JAVACONSOLE)
    TABENT(FCIDM_VIEWTOOLBARCUSTOMIZE)
    TABENT(FCIDM_REFRESH)
    TABENT(FCIDM_ADDTOFAVNOUI)
    TABENT(FCIDM_VIEWITBAR)
    TABENT(FCIDM_SEARCHFIRST)
    TABENT(FCIDM_SEARCHLAST)
#ifdef FCIDM_PERFOLDERSEARCHFIRST
    TABENT(FCIDM_PERFOLDERSEARCHFIRST)
    TABENT(FCIDM_PERFOLDERSEARCHLAST)
#endif
    TABENT(FCIDM_VIEWBROWSERBARS)
    TABENT(FCIDM_VBBSEARCHBAND)
    TABENT(FCIDM_VBBFAVORITESBAND)
    TABENT(FCIDM_VBBHISTORYBAND)
#if defined(ENABLE_CHANNELS) && defined(FCIDM_VBBCHANNELSBAND)
    TABENT(FCIDM_VBBCHANNELSBAND)
#endif
    TABENT(FCIDM_VBBEXPLORERBAND)
    TABENT(FCIDM_VBBALL)
#ifdef FCIDM_VBBNONE
    TABENT(FCIDM_VBBNONE)
#endif
    TABENT(FCIDM_VBBFIXFIRST)
    TABENT(FCIDM_VBBFIXLAST)
    TABENT(FCIDM_VBBDYNFIRST)
    TABENT(FCIDM_VBBDYNLAST)
    TABENT(IDM_AC_FIRST)
    TABENT(IDM_AC_UNDO)
    TABENT(IDM_AC_CUT)
    TABENT(IDM_AC_COPY)
    TABENT(IDM_AC_PASTE)
    TABENT(IDM_AC_DELETE)
    TABENT(IDM_AC_SELECTALL)
    TABENT(IDM_AC_COMPLETIONS)
    TABENT(IDM_AC_FIRSTCOMPITEM)
    TABENT(IDM_AC_LASTCOMPITEM)
    TABENT(FCIDM_APPS_FIRST)
    TABENT(FCIDM_CONTACTS)
    TABENT(FCIDM_CALENDAR)
    TABENT(FCIDM_TASKS)
    TABENT(FCIDM_JOURNAL)
    TABENT(FCIDM_NOTES)
    TABENT(FCIDM_CALL)
    TABENT(FCIDM_APPS_LAST)
    TABENT(FCIDM_FILECTX_FIRST)
    TABENT(FCIDM_FILECTX_LAST)
    TABENT(FSIDM_NEWFOLDER)
    TABENT(FSIDM_NEWLINK)
    TABENT(FSIDM_NEWOTHER)
    TABENT(IDM_BROWBAND_REFRESH)
    TABENT(IDM_BROWBAND_OPENNEW)
};
#undef TABENT

void PrTab(struct valstr *pvs, int n);

int _cdecl main()
{
    PrTab(ValStrTab, ARRAYSIZE(ValStrTab));
    return 0;
}

void PrTab(struct valstr *pvs, int n)
{
    for (; n > 0; n--, pvs++) {
        printf("%s\t0x%x\r\n", pvs->str, pvs->val);
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\policy_6.0\xpsp1\sources.inc ===
!IF 0
Copyright (c) Microsoft Corporation
!ENDIF

TARGETTYPE=NOTARGET
TARGETPATH=$(_OBJ_DIR)
SOURCES=

SXS_MANIFEST=comctl.Manifest
SXS_REDIRECTED_ASSEMBLY_NAME=Microsoft.Windows.Common-Controls
SXS_ASSEMBLY_NAME=policy.6.0.$(SXS_REDIRECTED_ASSEMBLY_NAME)
SXS_SHORT_ASSEMBLY_NAME=policy.60100.comctl
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1
SXS_ASSEMBLY_IS_POLICY=1
SXS_ASSEMBLY_VERSION=6.0
SXS_ASSEMBLY_VERSION_PART_3=10
SXS_ASSEMBLY_VERSION_PART_4=0

SXS_MANIFEST_DEFINES=$(SXS_MANIFEST_DEFINES) \
 -DSXS_REDIRECTED_ASSEMBLY_NAME="\"$(SXS_REDIRECTED_ASSEMBLY_NAME)\"" \

#
# This is set because there exists a wow6432 specific assembly.
#
SXS_LOG_WOWBINS_W_ASMS_PREFIX=w
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\tools\rot13.cpp ===
//***
// SYNOPSIS
//  rot13 [-q] [-p:prefix] [-l:#] < file
//
//  -p prefix   only munge stuff between <prefix> and end-of-line
//  -q          only munge stuff between quotes
//  -l #        only munge stuff >= # chars long
//
//  -q is good for registry dumps.
//  -p prefix is good for ???.
// NOTES
//  NYI: -l #
//  NYI: ':' between arg and modifier
#include <stdlib.h>
#include <stdio.h>

#define TRUE        1
#define FALSE       0

#define TEXT(x)     x

void rot13(FILE *fpIn, FILE *fpOut);

char *PszPrefix;
int FQuote;

void usage()
{
    fprintf(stderr, "usage: rot13 [-p prefix] [-q] < file");
    exit(2);
}

int _cdecl main(int argc, char **argv)
{
    --argc; ++argv;

    for ( ; *argv != NULL; --argc, ++argv) {
        if (argv[0][0] != TEXT('-'))
            break;
        switch (argv[0][1]) {
        case TEXT('p'):
            --argc; ++argv;
            PszPrefix = *argv;
            break;
        case TEXT('q'):
            FQuote = TRUE;
            break;
        default:
            usage();
            break;
        }
    }

    rot13(stdin, stdout);
    return 0;
}

#define ROT13(i)    (((i) + 13) % 26)

#define ST_BEG  1
#define ST_MID  2
#define ST_END  3

void rot13(FILE *fpIn, FILE *fpOut)
{
    int fRot;
    int state;
    int fInQuote;
    char *pszPre;
    int ch;

    state = ST_BEG;
    fInQuote = FALSE;
    while ((ch = getc(fpIn)) != EOF) {
        fRot = !(PszPrefix || FQuote);
        if (PszPrefix) {
            switch (state) {
            case ST_BEG:
                if (ch == *PszPrefix) {
                    pszPre = PszPrefix + 1;
                    state = ST_MID;
                }
                break;
            case ST_MID:
                if (*pszPre == 0) {
                    state = ST_END;
                    goto Lend;
                }
                else if (*pszPre++ == ch)
                    ;
                else
                    state = ST_BEG;
                break;
            case ST_END:
        Lend:
                if (ch == TEXT('\n'))
                    state = ST_BEG;
                break;
            }

            if (state == ST_END)
                fRot = TRUE;
        }

        if (FQuote) {
            // todo: <\">, <\'>
            if (ch == TEXT('"') || ch == TEXT('\''))
                fInQuote = !fInQuote;
            if (fInQuote)
                fRot = TRUE;
        }

        if (fRot) {
            if (TEXT('a') <= ch && ch <= TEXT('z'))
                ch = TEXT('a') + ROT13(ch - TEXT('a'));
            else if (TEXT('A') <= ch && ch <= TEXT('Z'))
                ch = TEXT('A') + ROT13(ch - TEXT('A'));
            else
                ;
        }
        putc(ch, fpOut);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\ccontrol.h ===
class CControl
{
protected:
    
    //Function Memebers
    virtual LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void _OnPaint(HDC hdc);

    virtual ~CControl() {};
    virtual void v_OnNCPaint() {};
    virtual void v_OnPaint(HDC hdc) = 0;
    virtual LRESULT v_OnCreate() = 0;
    virtual void v_OnSize(int x, int y) = 0;
    virtual LRESULT v_OnCommand(WPARAM wParam, LPARAM lParam) { return 0;};
    virtual LRESULT v_OnNotify(WPARAM wParam, LPARAM lParam) { return 0;};
    virtual DWORD v_OnStyleChanged(WPARAM wParam, LPARAM lParam);
    
    virtual BOOL v_OnNCCalcSize(WPARAM wParam, LPARAM lParam, LRESULT* plres);

    //Data Members
    CONTROLINFO ci;     // common control header info
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\commonimagelist.h ===
#ifndef COMMONIMAGELIST_H
#define COMMONIMAGELIST_H

class CImageListValidation 
{
public:
	DWORD wMagic;
	CImageListValidation() : wMagic(IMAGELIST_SIG) { }

	// it is critical that we zero out wMagic in the destructor
	// Yes, the memory is theoretically being freed, but setting
	// it to zero ensures that CImageListBase::IsValid()
	// will never mistake a freed imagelist for a valid one
	~CImageListValidation() {wMagic = 0; }

};

// CImageListBase must begin with CImageListValidation for compat reasons
// We put the IUnknown immediately afterwards so all the people who derive
// from it will agree on where to find QueryInterface et al.
class CImageListBase : public IUnknown, public CImageListValidation
{
public:
    BOOL IsValid() 
    { 
        return this && !IsBadWritePtr(this, sizeof(*this)) && wMagic == IMAGELIST_SIG; 
    }
};


#ifndef offsetofclass
// (Magic stolen from atlbase.h because we don't use ATL2.1 any more)
#define offsetofclass(base, derived) ((ULONG_PTR)(static_cast<base*>((derived*)8))-8)
#endif


// Since we know that IUnknown is implemented on CImageListBase, we find out where exactly 
// the validation layer is by this macro. 
#define FindImageListBase(punk) (CImageListBase*)(CImageListValidation*)((UINT_PTR)punk - offsetofclass(CImageListValidation, CImageListBase));


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\apithk.h ===
//
//  APITHK.H
//


#ifndef _APITHK_H_
#define _APITHK_H_

BOOL NT5_AnimateWindow(IN HWND hwnd, IN DWORD dWTime, IN DWORD dwFlags);
#define AnimateWindow   NT5_AnimateWindow

// Other functions
STDAPI_(HCURSOR) LoadHandCursor(DWORD dwRes);
STDAPI_(void) CoolTooltipBubble(IN HWND hwnd, IN LPCRECT prc, BOOL fAllowFade, BOOL fAllowAnimate);
STDAPI_(BOOL) NT5_QueueUserWorkItem(LPTHREAD_START_ROUTINE Function,
    PVOID Context, BOOL PreferIo);
#define CCQueueUserWorkItem NT5_QueueUserWorkItem

STDAPI_(int)
NT5_GetCalendarInfoA(LCID lcid, CALID calid, CALTYPE cal,
                     LPSTR pszBuf, int cchBuf, LPDWORD pdwOut);


// =========================================================================
// things supported since NT5 and Memphis

#define PrivateDFCS_HOT             0x1000
#define PrivateSPI_GETSELECTIONFADE 0x1014

#define PrivateWM_CHANGEUISTATE     0x0127
#define PrivateWM_UPDATEUISTATE     0x0128
#define PrivateWM_QUERYUISTATE      0x0129

#define PrivateUIS_SET              1
#define PrivateUIS_CLEAR            2
#define PrivateUIS_INITIALIZE       3

#define PrivateUISF_HIDEFOCUS       0x1
#define PrivateUISF_HIDEACCEL       0x2

#define PrivateDT_HIDEPREFIX        0x00100000
#define PrivateDT_PREFIXONLY        0x00200000

#define PrivateSPI_GETCLEARTYPE          116
#define PrivateDFCS_TRANSPARENT        0x0800

#ifndef UNIX
#define KEYBOARDCUES
#endif

#define PrivateCAL_RETURN_NUMBER         LOCALE_RETURN_NUMBER
#define PrivateCAL_ITWODIGITYEARMAX      0x00000030
#define PrivateLOCALE_SYEARMONTH         0x00001006

#define PrivateSM_IMMENABLED        82

#if (WINVER >= 0x0500)

// for files in nt5api and w5api dirs, use the definition in sdk include.
// And make sure our private define is in sync with winuser.h.

#if DFCS_HOT != PrivateDFCS_HOT
#error inconsistant DFCS_HOT in winuser.h
#endif

#if SPI_GETSELECTIONFADE != PrivateSPI_GETSELECTIONFADE
#error inconsistant SPI_GETSELECTIONFADE in winuser.h
#endif

// We are checking this in at the same time that user is. This is to prevent
// sync problems.
#ifdef SPI_GETCLEARTYPE
    #if SPI_GETCLEARTYPE != PrivateSPI_GETCLEARTYPE
        #error inconsistant SPI_GETCLEARTYPE in winuser.h
    #endif
#else
    #define SPI_GETCLEARTYPE        PrivateSPI_GETCLEARTYPE
#endif

#if PrivateCAL_RETURN_NUMBER    != CAL_RETURN_NUMBER || \
    PrivateCAL_ITWODIGITYEARMAX != CAL_ITWODIGITYEARMAX
#error inconsistent CAL_RETURN_NUMBER/CAL_ITWODIGITYEARMAX in winnls.h
#endif

#if LOCALE_SYEARMONTH != PrivateLOCALE_SYEARMONTH
#error inconsistant LOCALE_SYEARMONTH in winnls.h
#endif

#ifdef SM_IMMENABLED
    #if SM_IMMENABLED != PrivateSM_IMMENABLED
        #error inconsistant SM_IMMENABLED in winuser.h
    #endif
#else
    #define SM_IMMENABLED       PrivateSM_IMMENABLED
#endif

#else

#define COLOR_HOTLIGHT  GetCOLOR_HOTLIGHT()
#define DFCS_HOT        PrivateDFCS_HOT
#define SPI_GETSELECTIONFADE    PrivateSPI_GETSELECTIONFADE

#define WM_CHANGEUISTATE        PrivateWM_CHANGEUISTATE     
#define WM_UPDATEUISTATE        PrivateWM_UPDATEUISTATE
#define WM_QUERYUISTATE         PrivateWM_QUERYUISTATE      

#define UIS_SET                 PrivateUIS_SET              
#define UIS_CLEAR               PrivateUIS_CLEAR            
#define UIS_INITIALIZE          PrivateUIS_INITIALIZE       

#define UISF_HIDEFOCUS          PrivateUISF_HIDEFOCUS       
#define UISF_HIDEACCEL          PrivateUISF_HIDEACCEL       

#define DT_HIDEPREFIX           PrivateDT_HIDEPREFIX
#define DT_PREFIXONLY           PrivateDT_PREFIXONLY

#define CAL_RETURN_NUMBER       PrivateCAL_RETURN_NUMBER
#define CAL_ITWODIGITYEARMAX    PrivateCAL_ITWODIGITYEARMAX
#define LOCALE_SYEARMONTH       PrivateLOCALE_SYEARMONTH
#define SPI_GETCLEARTYPE        PrivateSPI_GETCLEARTYPE
#define DFCS_TRANSPARENT        PrivateDFCS_TRANSPARENT

#define SM_IMMENABLED           PrivateSM_IMMENABLED

#endif // (WINVER >= 0x0500)
int GetCOLOR_HOTLIGHT();


// =========================================================================
// things supported since NT4 and Memphis

#define PrivateWM_MOUSEWHEEL            0x020A
#define PrivateSPI_GETWHEELSCROLLLINES  104

#if (_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)

// for files in w5api and all nt* dirs, use the definition in sdk include.
// And make sure our private define is in sync with winuser.h.

#if WM_MOUSEWHEEL != PrivateWM_MOUSEWHEEL
#error inconsistant WM_MOUSEWHEEL in winuser.h
#endif

#if SPI_GETWHEELSCROLLLINES != PrivateSPI_GETWHEELSCROLLLINES
#error inconsistant SPI_GETWHEELSCROLLLINES in winuser.h
#endif

#else

#define WM_MOUSEWHEEL           PrivateWM_MOUSEWHEEL
#define SPI_GETWHEELSCROLLLINES PrivateSPI_GETWHEELSCROLLLINES

#endif // (_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)

#endif // _APITHK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\ccver.h ===
//
//  ccver.h
//
//  App compat hack.  Apps, as always, mess up the major/minor version
//  check, so they think that 5.0 is less than 4.71 because they use
//
//    if (major < 4 && minor < 71) Fail();
//
//
//  So we artificially add 80 to our minor version, so 5.0 becomes 5.80,
//  etc.  Note that the hex version is 0x050, since 0x50 = 80 decimal.
//
//
//  The C preprocessor isn't smart enough to extract the commas out of
//  a value string, so we just do it all by hand and assert that nobody
//  has messed with <ntverp.h> or <ieverp.h> in a significant way.
//

#define VER_FILEVERSION             5,82,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE
#define VER_FILEVERSION_STR         "5.82"
#define VER_FILEVERSION_W           0x0552
#define VER_FILEVERSION_DW          (0x05520000 | VER_PRODUCTBUILD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\animate.c ===
#include "ctlspriv.h"
#include "rlefile.h"

#define RectWid(_rc)    ((_rc).right-(_rc).left)
#define RectHgt(_rc)    ((_rc).bottom-(_rc).top)

typedef struct {
    HWND        hwnd;                   // my window
    int         id;                     // my id
    HWND        hwndP;                  // my owner (get notify messages)
    DWORD       style;

    BOOL        fFirstPaint;            // TRUE until first paint.
    RLEFILE     *prle;

#ifdef WIN32
    CRITICAL_SECTION    crit;
#endif

    RECT        rc;
    int         NumFrames;
    int         Rate;

    int         iFrame;
    int         PlayCount;
    int         PlayFrom;
    int         PlayTo;
    HANDLE      PaintThread;
    HANDLE      hStopEvent;

}   ANIMATE;

#ifdef WIN32
#define Enter(p)    EnterCriticalSection(&p->crit)
#define Leave(p)    LeaveCriticalSection(&p->crit)
#else
#define Enter(p)
#define Leave(p)
#endif

#define OPEN_WINDOW_TEXT 42
#define Ani_UseThread(p) (!((p)->style & ACS_TIMER))

LRESULT CALLBACK AnimateWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

BOOL HandleOpen(ANIMATE *p, HINSTANCE hInst, LPCTSTR pszName, UINT flags);
BOOL HandleStop(ANIMATE *p);
BOOL HandlePlay(ANIMATE *p, int from, int to, int count);
void HandlePaint(ANIMATE *p, HDC hdc);
int  HandleTick(ANIMATE *p);

#pragma code_seg(CODESEG_INIT)

TCHAR c_szAnimateClass[] = ANIMATE_CLASS;

BOOL FAR PASCAL InitAnimateClass(HINSTANCE hInstance)
{
    WNDCLASS wc;

    if (!GetClassInfo(hInstance, c_szAnimateClass, &wc)) {
#ifndef WIN32
        extern LRESULT CALLBACK _AnimateWndProc(HWND, UINT, WPARAM, LPARAM);
        wc.lpfnWndProc   = _AnimateWndProc;
#else
        wc.lpfnWndProc   = AnimateWndProc;
#endif
        wc.lpszClassName = c_szAnimateClass;
        wc.style         = CS_DBLCLKS | CS_GLOBALCLASS;
        wc.cbClsExtra    = 0;
        wc.cbWndExtra    = sizeof(LPVOID);
        wc.hInstance     = hInstance;       // use DLL instance if in DLL
        wc.hIcon         = NULL;
        wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE+1);
        wc.lpszMenuName  = NULL;

        if (!RegisterClass(&wc))
            return FALSE;
    }

    return TRUE;
}
#pragma code_seg()

BOOL HandleOpen(ANIMATE *p, HINSTANCE hInst, LPCTSTR pszName, UINT flags)
{
    TCHAR ach[MAX_PATH];

    //
    // use window text as file name
    //
    if (flags == OPEN_WINDOW_TEXT)
    {
        GetWindowText(p->hwnd, ach, ARRAYSIZE(ach));
        pszName = ach;
    }

    if (hInst == NULL)
        hInst = (HINSTANCE)GetWindowLongPtr(p->hwnd, GWLP_HINSTANCE);

    HandleStop(p);              // stop a play first

    if (p->prle)
    {
        RleFile_Free(p->prle);
        p->prle = NULL;
    }

    p->iFrame = 0;
    p->NumFrames = 0;

    if (pszName == NULL || (!IS_INTRESOURCE(pszName) && *pszName == 0))
        return FALSE;
    //
    //  now open the file/resource we got.
    //
    p->prle = RleFile_New();

    if (p->prle == NULL)
        return FALSE;

    if (!RleFile_OpenFromResource(p->prle, hInst, pszName, TEXT("AVI")) &&
        !RleFile_OpenFromFile(p->prle, pszName))
    {
        RleFile_Free(p->prle);
        p->prle = NULL;
        return FALSE;
    }
    else
    {
        p->NumFrames = RleFile_NumFrames(p->prle);
        p->Rate = (int)RleFile_Rate(p->prle);
        SetRect(&p->rc, 0, 0, RleFile_Width(p->prle), RleFile_Height(p->prle));
    }

    //
    // handle a transparent color
    //
    if ((p->style & ACS_TRANSPARENT) && p->hwndP)
    {
        HDC hdc;
        HDC hdcM;
        HBITMAP hbm;
        COLORREF rgbS, rgbD;

        hdc = GetDC(p->hwnd);

        //
        //  create a bitmap and draw image into it.
        //  get upper left pixel and make that transparent.
        //
        hdcM= CreateCompatibleDC(hdc);
        hbm = CreateCompatibleBitmap(hdc, 1, 1);
        SelectObject(hdcM, hbm);
        HandlePaint(p, hdcM);
        rgbS = GetPixel(hdcM, 0, 0);
        DeleteDC(hdcM);
        DeleteObject(hbm);

        SendMessage(p->hwndP, GET_WM_CTLCOLOR_MSG(CTLCOLOR_STATIC),
            GET_WM_CTLCOLOR_MPS(hdc, p->hwnd, CTLCOLOR_STATIC));

        rgbD = GetBkColor(hdc);


        ReleaseDC(p->hwnd, hdc);

        //
        // now replace the color
        //
        RleFile_ChangeColor(p->prle, rgbS, rgbD);
    }

    //
    //  ok it worked, resize window.
    //
    if (p->style & ACS_CENTER)
    {
        RECT rc;
        GetClientRect(p->hwnd, &rc);
        OffsetRect(&p->rc, (rc.right-p->rc.right)/2,(rc.bottom-p->rc.bottom)/2);
    }
    else
    {
        RECT rc;
        rc = p->rc;
        AdjustWindowRectEx(&rc, GetWindowStyle(p->hwnd), FALSE, GetWindowExStyle(p->hwnd));
        SetWindowPos(p->hwnd, NULL, 0, 0, RectWid(rc), RectHgt(rc),
            SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE);
    }

    if (p->style & ACS_AUTOPLAY)
    {
        PostMessage(p->hwnd, ACM_PLAY, (UINT_PTR)-1, MAKELONG(0, -1));
    }
    else
    {
        InvalidateRect(p->hwnd, NULL, TRUE);
    }

    return TRUE;
}

void DoNotify(ANIMATE *p, int cmd)
{
    if (p->hwndP)
        PostMessage(p->hwndP, WM_COMMAND, GET_WM_COMMAND_MPS(p->id, p->hwnd, cmd));
}

BOOL HandleStop(ANIMATE *p)
{
    if (p == NULL || !p->PaintThread)
        return FALSE;

    if (Ani_UseThread(p)) {
        // set thread up to terminate between frames
        Enter( p );
        p->PlayCount = 0;
        Leave( p );
        if (p->hStopEvent)
            SetEvent(p->hStopEvent);
        WaitForSingleObject(p->PaintThread, INFINITE);
        // PORT QSY  RAID 4167
        // Under certain situations, both the CloseHandle()
        // and ExitThread() call try to remove MainWin internal
        // objects.
        // This is a work-around for preview 1.
        // I've raised another bug RAID  4250 for OE RTW 
#ifndef UNIX
        CloseHandle(p->PaintThread);
#endif
        // PORT QSY
        p->PaintThread = NULL;
        if (p->hStopEvent)
            CloseHandle(p->hStopEvent);
        p->hStopEvent = NULL;
    } else {
        KillTimer(p->hwnd, HandleToUlong(p->PaintThread)); // really was a UINT
        p->PaintThread = 0;
        DoNotify(p, ACN_STOP);
    }
    return TRUE;
}

int PlayThread(ANIMATE *p)
{
    int result;
    
    DoNotify(p, ACN_START);

    while (result = HandleTick(p))
    {
        // Sleep for a bit (4 seconds) longer if we are hidden
        //
        // Old code here slept, which can block the UI thread
        // if the app tries to stop/shutdown/change the animation
        // right near the beginning of the sleep.
        //        Sleep((result < 0 ? p->Rate+4000 : p->Rate));
        // Do a timed wait for the stop event instead
        //
        if (p->hStopEvent)
            WaitForSingleObject(p->hStopEvent, (result < 0 ? p->Rate+4000 : p->Rate));
        else
            Sleep((result < 0 ? p->Rate+4000 : p->Rate));
    }

    DoNotify(p, ACN_STOP);
    return 0;
}

BOOL HandlePlay(ANIMATE *p, int from, int to, int count)
{
    if (p == NULL || p->prle == NULL)
        return FALSE;

    HandleStop(p);

    if (from >= p->NumFrames)
        from = p->NumFrames-1;

    if (to == -1)
        to = p->NumFrames-1;

    if (to < 0)
        to = 0;

    if (to >= p->NumFrames)
        to = p->NumFrames-1;

    p->PlayCount = count;
    p->PlayTo    = to;
    if (from >= 0) {
        p->iFrame = from;
        p->PlayFrom  = from;
    } else
        from = p->PlayFrom;

    if ( (from == to) || !count )
    {
        InvalidateRect(p->hwnd, NULL, TRUE);
        return TRUE;
    }

    InvalidateRect(p->hwnd, NULL, FALSE);
    UpdateWindow(p->hwnd);

    if (Ani_UseThread(p))
    {
        DWORD dw;
        p->hStopEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        p->PaintThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)PlayThread, (void*)p, 0, &dw);
    }
    else
    {
        DoNotify(p, ACN_START);
        p->PaintThread = (HANDLE)SetTimer(p->hwnd, 42, (UINT)p->Rate, NULL);
    }
    return TRUE;
}

void HandleFirstPaint(ANIMATE *p)
{
    if (p->fFirstPaint)
    {
        p->fFirstPaint = FALSE;

        if (p->NumFrames == 0 &&
            (p->style & WS_CHILD))
        {
            HandleOpen(p, NULL, NULL, OPEN_WINDOW_TEXT);
        }
    }
}

void HandlePaint(ANIMATE *p, HDC hdc)
{
    if( p && p->prle )
    {
        Enter( p );
        RleFile_Paint( p->prle, hdc, p->iFrame, p->rc.left, p->rc.top );
        Leave( p );
    }
}

void HandleErase(ANIMATE * p, HDC hdc)
{
    HBRUSH hbr;
    RECT rc;

    hbr = (HBRUSH)SendMessage(p->hwndP, GET_WM_CTLCOLOR_MSG(CTLCOLOR_STATIC),
        GET_WM_CTLCOLOR_MPS(hdc, p->hwnd, CTLCOLOR_STATIC));
    GetClientRect(p->hwnd, &rc);
    FillRect(hdc, &rc, hbr);
}

void HandlePrint(ANIMATE *p, HDC hdc)
{
    HandleFirstPaint(p);
    HandlePaint(p, hdc);
}

int HandleTick(ANIMATE *p)
// - if something to do but we are hidden
// returns 0 if nothing left
// + if something to do
{
    int result = 0;

    if( p && p->prle )
    {
        HDC hdc;
        RECT dummy;

        Enter( p );
        hdc = GetDC( p->hwnd );

        if( GetClipBox( hdc, &dummy ) != NULLREGION )
        {
            // do a full repaint on first frame
            if( p->iFrame == p->PlayFrom )
                HandlePaint( p, hdc );
            else
                RleFile_Draw( p->prle, hdc, p->iFrame, p->rc.left, p->rc.top );

            if( p->iFrame >= p->PlayTo )
            {
                if( p->PlayCount > 0 )
                    p->PlayCount--;

                if( p->PlayCount != 0 )
                    p->iFrame = p->PlayFrom;
            }
            else
                p->iFrame++;


            // Something to do? and visible, return + value
            result = ( p->PlayCount != 0 );
        }
        else
        {
            // Something to do? but hidden, so return - value
            p->iFrame = p->PlayFrom;

            result = -( p->PlayCount != 0 );
        }

        ReleaseDC( p->hwnd, hdc );
        Leave( p );
    }

    return result;
}

void NEAR Ani_OnStyleChanged(ANIMATE* p, WPARAM gwl, LPSTYLESTRUCT pinfo)
{
    if (gwl == GWL_STYLE) {
        p->style = pinfo->styleNew;
    }
}

LRESULT CALLBACK AnimateWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    ANIMATE *p = (ANIMATE *)GetWindowPtr(hwnd, 0);
    HDC hdc;
    PAINTSTRUCT ps;

    // First, the messages that can handle p == NULL.
    // All these handlers must end with a "return" or a "goto DoDefault".

    switch (msg) {
    case WM_NCCREATE:

        #define lpcs ((LPCREATESTRUCT)lParam)

        p = (ANIMATE *)LocalAlloc(LPTR, sizeof(ANIMATE));

        if (!p)
            return 0;       // WM_NCCREATE failure is 0

        // note, zero init memory from above
        p->hwnd = hwnd;
        p->hwndP = lpcs->hwndParent;
        p->id = PtrToUlong(lpcs->hMenu);        // really was an int
        p->fFirstPaint = TRUE;
        p->style = lpcs->style;

        // Must do this before SetWindowBits because that will recursively
        // cause us to receive WM_STYLECHANGED and possibly even WM_SIZE
        // messages.
#ifdef WIN32
        InitializeCriticalSection(&p->crit);
#endif

        SetWindowPtr(hwnd, 0, p);

        //
        // UnMirror the control, if it is mirrored. We shouldn't mirror
        // a movie! [samera]
        //
        SetWindowBits(hwnd, GWL_EXSTYLE, RTL_MIRRORED_WINDOW, 0);

        goto DoDefault;

    case WM_CLOSE:
        Animate_Stop(hwnd);
        goto DoDefault;

    case WM_NCHITTEST:
        return HTTRANSPARENT;

    case WM_GETOBJECT:
        if( lParam == OBJID_QUERYCLASSNAMEIDX )
            return MSAA_CLASSNAMEIDX_ANIMATE;
        goto DoDefault;
    }

    // Okay, now the messages that cannot handle p == NULL.
    // We check p == NULL once and for all.

    if (!p) goto DoDefault;

    switch (msg) {
    case WM_DESTROY:
        Animate_Close(hwnd);
        DeleteCriticalSection(&p->crit);
        LocalFree((HLOCAL)p);
        SetWindowPtr(hwnd, 0, 0);
        break;

    case WM_ERASEBKGND:
        HandleErase(p, (HDC)wParam);
        return(1);

    case WM_PAINT:
        HandleFirstPaint(p);
        hdc = BeginPaint(hwnd, &ps);
        HandlePaint(p, hdc);
        EndPaint(hwnd, &ps);
        return 0;

    case WM_PRINTCLIENT:
        HandlePrint(p, (HDC)wParam);
        return 0;

    case WM_STYLECHANGED:
        Ani_OnStyleChanged(p, wParam, (LPSTYLESTRUCT)lParam);
        return 0L;
        
    case WM_SIZE:
        if (p->style & ACS_CENTER)
        {
            OffsetRect(&p->rc, (LOWORD(lParam)-RectWid(p->rc))/2-p->rc.left,
                       (HIWORD(lParam)-RectHgt(p->rc))/2-p->rc.top);
            InvalidateRect(hwnd, NULL, TRUE);
        }
        break;

    case WM_TIMER:
    {
        int result;
        result = HandleTick(p);
        if (!result)
        {
            HandleStop(p);
        }
        else if (result < 0)
        {
            p->PaintThread = (HANDLE)SetTimer(p->hwnd, 42, (UINT)p->Rate+4000, NULL);
        } else
        {
            p->PaintThread = (HANDLE)SetTimer(p->hwnd, 42, (UINT)p->Rate, NULL);
        }
    }
        break;

#ifdef UNICODE
    case ACM_OPENA:
    {
        WCHAR szFileNameW[MAX_PATH];
        LPTSTR lpFileName = szFileNameW;

        if (!IS_INTRESOURCE(lParam)) {
            MultiByteToWideChar (CP_ACP, 0, (LPCSTR)lParam, -1,
                                 szFileNameW, MAX_PATH);
        } else {
            lpFileName = (LPTSTR) lParam;
        }
        
        return HandleOpen(p, (HINSTANCE)wParam, lpFileName, 0);
    }
#endif

    case ACM_OPEN:
        return HandleOpen(p, (HINSTANCE)wParam, (LPCTSTR)lParam, 0);

    case ACM_STOP:
        return HandleStop(p);

    case ACM_PLAY:
        return HandlePlay(p, (int)(SHORT)LOWORD(lParam), (int)(SHORT)HIWORD(lParam), (int)wParam);

    }

DoDefault:
    return DefWindowProc(hwnd, msg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\apithk.c ===
//
//  APITHK.C
//
//  This file has API thunks that allow comctl32 to load and run on
//  multiple versions of NT or Win95.  Since this component needs
//  to load on the base-level NT 4.0 and Win95, any calls to system
//  APIs introduced in later OS versions must be done via GetProcAddress.
// 
//  Also, any code that may need to access data structures that are
//  post-4.0 specific can be added here.
//
//  NOTE:  this file does *not* use the standard precompiled header,
//         so it can set _WIN32_WINNT to a later version.
//

#include "ctlspriv.h"       // Don't use precompiled header here


typedef BOOL (* PFNANIMATEWINDOW)(HWND hwnd, DWORD dwTime, DWORD dwFlags);

/*----------------------------------------------------------
Purpose: Thunk for NT 5's AnimateWindow.

Returns: 
Cond:    --
*/
BOOL
NT5_AnimateWindow(
    IN HWND hwnd,
    IN DWORD dwTime,
    IN DWORD dwFlags)
{
    BOOL bRet = FALSE;
    static PFNANIMATEWINDOW pfn = NULL;

    if (NULL == pfn)
    {
        HMODULE hmod = GetModuleHandle(TEXT("USER32"));
        
        if (hmod)
            pfn = (PFNANIMATEWINDOW)GetProcAddress(hmod, "AnimateWindow");
    }

    if (pfn)
        bRet = pfn(hwnd, dwTime, dwFlags);

    return bRet;    
}

/*----------------------------------------------------------
Purpose: Shows the tooltip.  On NT4/Win95, this is a standard
         show window.  On NT5/Memphis, this slides the tooltip
         bubble from an invisible point.

Returns: --
Cond:    --
*/

#define CMS_TOOLTIP 135

void SlideAnimate(HWND hwnd, LPCRECT prc)
{
    DWORD dwPos, dwFlags;

    dwPos = GetMessagePos();
    if (GET_Y_LPARAM(dwPos) > prc->top + (prc->bottom - prc->top) / 2)
    {
        dwFlags = AW_VER_NEGATIVE;
    } 
    else
    {
        dwFlags = AW_VER_POSITIVE;
    }

    AnimateWindow(hwnd, CMS_TOOLTIP, dwFlags | AW_SLIDE);
}

STDAPI_(void) CoolTooltipBubble(IN HWND hwnd, IN LPCRECT prc, BOOL fAllowFade, BOOL fAllowAnimate)
{
    ASSERT(prc);

    if (g_bRunOnNT5 || g_bRunOnMemphis)
    {
#ifdef WINNT
        BOOL fAnimate = TRUE;
        SystemParametersInfo(SPI_GETTOOLTIPANIMATION, 0, &fAnimate, 0);
#else
        // Memphis doesn't support the tooltip SPI's, so we piggyback
        // off of SPI_GETSCREENREADER instead.  Note that we want to
        // animate if SPI_GETSCREENREADER is >off<, so we need to do some
        // flippery.  Fortunately, the compiler will optimize all this out.
        BOOL fScreenRead = FALSE;
        BOOL fAnimate;
        SystemParametersInfo(SPI_GETSCREENREADER, 0, &fScreenRead, 0);
        fAnimate = !fScreenRead;
#endif
        if (fAnimate)
        {
            fAnimate = FALSE;
#ifdef WINNT
            SystemParametersInfo(SPI_GETTOOLTIPFADE, 0, &fAnimate, 0);
#endif // WINNT
            if (fAnimate && fAllowFade)
            {
                AnimateWindow(hwnd, CMS_TOOLTIP, AW_BLEND);
            }
            else if (fAllowAnimate)
            {
                SlideAnimate(hwnd, prc);
            }
            else
                goto UseSetWindowPos;
        }
        else
            goto UseSetWindowPos;
    }
    else
    {
UseSetWindowPos:
        SetWindowPos(hwnd, NULL, 0, 0, 0, 0, 
                     SWP_NOACTIVATE|SWP_SHOWWINDOW|SWP_NOSIZE|SWP_NOMOVE|SWP_NOZORDER);
    }
}



/*----------------------------------------------------------
Purpose: Get the COLOR_HOTLIGHT system color index from NT5 or Memphis.
         Get COLOR_HIGHLIGHT from NT4 or Win95, where COLOR_HOTLIGHT is not defined.

Returns: --
Cond:    --
*/
int GetCOLOR_HOTLIGHT()
{
    return (g_bRunOnNT5 || g_bRunOnMemphis) ? COLOR_HOTLIGHT : COLOR_HIGHLIGHT;
}


STDAPI_(HCURSOR) LoadHandCursor(DWORD dwRes)
{
    if (g_bRunOnNT5 || g_bRunOnMemphis)
    {
        HCURSOR hcur = LoadCursor(NULL, IDC_HAND);  // from USER, system supplied
        if (hcur)
            return hcur;
    }

    return LoadCursor(HINST_THISDLL, MAKEINTRESOURCE(IDC_HAND_INTERNAL));
}

typedef BOOL (*PFNQUEUEUSERWORKITEM)(LPTHREAD_START_ROUTINE Function,
    PVOID Context, BOOL PreferIo);

STDAPI_(BOOL) NT5_QueueUserWorkItem(LPTHREAD_START_ROUTINE Function,
    PVOID Context, BOOL PreferIo)
{
    BOOL bRet = FALSE;
    static PFNQUEUEUSERWORKITEM pfn = (PFNQUEUEUSERWORKITEM)-1;

    if ((PFNQUEUEUSERWORKITEM)-1 == pfn)
    {
        HMODULE hmod = GetModuleHandle(TEXT("KERNEL32"));
        
        if (hmod)
            pfn = (PFNQUEUEUSERWORKITEM)GetProcAddress(hmod, "QueueUserWorkItem");
        else
            pfn = NULL;
    }

    if (pfn)
        bRet = pfn( Function, Context, PreferIo);

    return bRet;    
}

//
//  Here's how CAL_ITWODIGITYEARMAX works.
//
//  If a two-digit year is input from the user, we put it into the range
//  (N-99) ... N.  for example, if the maximum value is 2029, then all
//  two-digit numbers will be coerced into the range 1930 through 2029.
//
//  Win95 and NT4 don't have GetCalendarInfo, but they do have
//  EnumCalendarInfo, so you'd think we could avoid the GetProcAddress
//  by enumerating the one calendar we care about.
//
//  Unfortunately, Win98 has a bug where EnumCalendarInfo can't enumerate
//  the maximum two-digit year value!  What a lamer!
//
//  So we're stuck with GetProcAddress.
//
//  But wait, Win98 exports GetCalendarInfoW but doesn't implement it!
//  Double lame!
//
//  So we have to use the Ansi version exclusively.  Fortunately, we
//  are only interested in numbers (so far) so there is no loss of amenity.
//
//  First, here's the dummy function that emulates GetCalendarInfoA
//  on Win95 and NT4.
//

STDAPI_(int)
Emulate_GetCalendarInfoA(LCID lcid, CALID calid, CALTYPE cal,
                         LPSTR pszBuf, int cchBuf, LPDWORD pdwOut)
{
    //
    //  In the absence of the API, we go straight for the information
    //  in the registry.
    //
    BOOL fSuccess = FALSE;
    HKEY hkey;

    ASSERT(cal == CAL_RETURN_NUMBER + CAL_ITWODIGITYEARMAX);
    ASSERT(pszBuf == NULL);
    ASSERT(cchBuf == 0);

    if (RegOpenKeyExA(HKEY_CURRENT_USER,
                      "Control Panel\\International\\Calendars\\TwoDigitYearMax",
                      0, KEY_READ, &hkey) == ERROR_SUCCESS)
    {
        char szKey[16];
        char szBuf[64];
        DWORD dwSize;

        wsprintfA(szKey, "%d", calid);

        dwSize = sizeof(szBuf);
        if (RegQueryValueExA(hkey, szKey, 0, NULL, (LPBYTE)szBuf, &dwSize) == ERROR_SUCCESS)
        {
            *pdwOut = StrToIntA(szBuf);
            fSuccess = TRUE;
        }

        RegCloseKey(hkey);
    }
    return fSuccess;

}

typedef int (CALLBACK *GETCALENDARINFOA)(LCID, CALID, CALTYPE, LPSTR, int, LPDWORD);

GETCALENDARINFOA _GetCalendarInfoA;

STDAPI_(int)
NT5_GetCalendarInfoA(LCID lcid, CALID calid, CALTYPE cal,
                     LPSTR pszBuf, int cchBuf, LPDWORD pdwOut)
{
    // This is the only function our emulator supports
    ASSERT(cal == CAL_RETURN_NUMBER + CAL_ITWODIGITYEARMAX);
    ASSERT(pszBuf == NULL);
    ASSERT(cchBuf == 0);

    if (_GetCalendarInfoA == NULL)
    {
        HMODULE hmod = GetModuleHandle(TEXT("KERNEL32"));

        //
        //  Must keep in a local to avoid thread races.
        //
        GETCALENDARINFOA pfn = NULL;

        if (hmod)
            pfn = (GETCALENDARINFOA)
                    GetProcAddress(hmod, "GetCalendarInfoA");

        //
        //  If function is not available, then use our fallback
        //
        if (pfn == NULL)
            pfn = Emulate_GetCalendarInfoA;

        ASSERT(pfn != NULL);
        _GetCalendarInfoA = pfn;
    }

    return _GetCalendarInfoA(lcid, calid, cal, pszBuf, cchBuf, pdwOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\comctl32.inc ===
#
#  Common settings for comctl32
#

# Now the NT version have FE_IME etc. defined
C_DEFINES       = $(C_DEFINES) -DFE_IME -DDBCS -DWINDOWS_ME 

!if !defined(TARGET_WIN95)
C_DEFINES       = $(C_DEFINES) -DUSE_PRIVATE_VERSION_NUMBER
!else
C_DEFINES       = $(C_DEFINES) -DUNICODE
!endif

C_DEFINES       = $(C_DEFINES) -DFONT_LINK

# Turn structure validation ON in debug builds
#
!if "$(FREEBUILD)" == "0"
C_DEFINES       = $(C_DEFINES) -DVSTF
!endif

USE_LIBCMT      = 1

!include $(CCSHELL_DIR)\common.inc

SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

# we want to run on downlevel platforms
WIN32_IE_VERSION=0x501
WIN32_WINNT_VERSION=0x0400
WIN32_WIN95_VERSION=0x0400
SUBSYSTEM_VERSION=4.00
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\ccverp.h ===
//
// Version numbering for comctl32.dll
//

#ifndef FEATURE_IE40

#undef VER_PRODUCTBETA_STR
#undef VER_PRODUCTVERSION_STR
#undef VER_PRODUCTVERSION
#undef VER_PRODUCTVERSION_W
#undef VER_PRODUCTVERSION_DW

//
// NT SUR, IE 3.0
//

#define COMCTL32_BUILD_NUMBER	   1146

#ifdef WINNT
#define VER_PRODUCTVERSION          4,70,COMCTL32_BUILD_NUMBER,1
#else
#define VER_PRODUCTVERSION          4,70,0,COMCTL32_BUILD_NUMBER
#endif

#define VER_PRODUCTBETA_STR         ""
#define VER_PRODUCTVERSION_STR      "4.70"
#define VER_PRODUCTVERSION_W        (0x0446)
#define VER_PRODUCTVERSION_DW       (0x04460000 | COMCTL32_BUILD_NUMBER)

#endif  // FEATURE_IE40
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\cstrings.c ===
#include "ctlspriv.h"

const TCHAR c_szNULL[] = TEXT("");
const TCHAR c_szSpace[] = TEXT(" ");
const TCHAR c_szTabControlClass[] = WC_TABCONTROL;
const TCHAR c_szListViewClass[] = WC_LISTVIEW;
const TCHAR c_szHeaderClass[] = WC_HEADER;
const TCHAR c_szTreeViewClass[] = WC_TREEVIEW;
const TCHAR c_szStatusClass[] = STATUSCLASSNAME;
const TCHAR c_szSToolTipsClass[] = TOOLTIPS_CLASS;
const TCHAR c_szToolbarClass[] = TOOLBARCLASSNAME;
const TCHAR c_szReBarClass[] = REBARCLASSNAME;
const TCHAR c_szEllipses[] = TEXT("...");
const TCHAR c_szShell[] = TEXT("Shell");
const TCHAR c_szEdit[] = TEXT("EDIT");
const TCHAR c_szSelect[] = TEXT("CCSelect");
const TCHAR s_szUpdownClass[] = UPDOWN_CLASS;
const TCHAR s_szHOTKEY_CLASS[] = HOTKEY_CLASS;
const TCHAR s_szSTrackBarClass[] = TRACKBAR_CLASS;
const TCHAR s_szPROGRESS_CLASS[] = PROGRESS_CLASS;
const TCHAR c_szCC32Subclass[] = TEXT("CC32SubclassInfo");
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\cstrings.h ===
extern TCHAR const FAR c_szNULL[];
extern TCHAR const FAR c_szSpace[];
extern TCHAR const FAR c_szTabControlClass[];
extern TCHAR const FAR c_szListViewClass[];
extern TCHAR const FAR c_szHeaderClass[];
extern TCHAR const FAR c_szTreeViewClass[];
extern TCHAR const FAR c_szStatusClass[];
extern TCHAR const FAR c_szSToolTipsClass[];
extern TCHAR const FAR c_szToolbarClass[];
extern TCHAR const FAR c_szReBarClass[];
extern TCHAR const FAR c_szEllipses[];
extern TCHAR const FAR c_szShell[];
extern TCHAR const FAR c_szEdit[];
extern TCHAR const FAR c_szSelect[];

extern const TCHAR FAR s_szUpdownClass[];
extern const TCHAR FAR s_szBUTTONLISTBOX[];
#define s_szEllipses c_szEllipses
#ifdef WANT_SUCKY_HEADER
extern const TCHAR FAR s_szHeaderClass[];
#endif
extern const TCHAR FAR s_szHOTKEY_CLASS[];
extern const TCHAR FAR s_szSTrackBarClass[];
extern const TCHAR FAR s_szPROGRESS_CLASS[];

extern const TCHAR FAR c_szCC32Subclass[];

#define CCHELLIPSES 3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\comboex.c ===
#include "ctlspriv.h"

#ifdef UNIX

#define EDIT_SELECTALL( hwnd )
#define GetTextExtentPoint GetTextExtentPoint32

#else

#define EDIT_SELECTALL( hwnd )  Edit_SetSel(hwnd, 0, 0);  \
                                Edit_SetSel(hwnd, 0, -1);

#endif

const TCHAR FAR c_szComboBox[] = TEXT("combobox");
const TCHAR FAR c_szComboBoxEx[] = WC_COMBOBOXEX;


#define COMBO_MARGIN        4
#define COMBO_WIDTH         g_cxSmIcon
#define COMBO_HEIGHT        g_cySmIcon
#define COMBO_BORDER        3

typedef struct {
    LPTSTR pszText;
    int iImage;
    int iSelectedImage;
    int iOverlay;
    int iIndent;
    LPARAM lParam;
} CEITEM, *PCEITEM;


typedef struct {
    CONTROLINFO ci;
    HWND hwndCombo;
    HWND hwndEdit;
    DWORD dwExStyle;
    HIMAGELIST himl;
    HFONT hFont;
    int cxIndent;
    WPARAM iSel;
    CEITEM cei;
    BOOL fEditItemSet       :1;
    BOOL fEditChanged       :1;
    BOOL fFontCreated       :1;
    BOOL fInEndEdit         :1;
    BOOL fInDrop            :1;
} COMBOEX, *PCOMBOBOXEX;


void ComboEx_OnWindowPosChanging(PCOMBOBOXEX pce, LPWINDOWPOS pwp);
HFONT ComboEx_GetFont(PCOMBOBOXEX pce);
BOOL ComboEx_OnGetItem(PCOMBOBOXEX pce, PCOMBOBOXEXITEM pceItem);
int ComboEx_ComputeItemHeight(PCOMBOBOXEX pce, BOOL);
int ComboEx_OnFindStringExact(PCOMBOBOXEX pce, int iStart, LPCTSTR lpsz);
int WINAPI ShellEditWordBreakProc(LPTSTR lpch, int ichCurrent, int cch, int code);

LRESULT CALLBACK ComboSubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);
LRESULT CALLBACK EditSubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);
int ComboEx_StrCmp(PCOMBOBOXEX pce, LPCTSTR psz1, LPCTSTR psz2);

#define ComboEx_Editable(pce) (((pce)->ci.style & CBS_DROPDOWNLIST) == CBS_DROPDOWN)

void ComboEx_OnSetFont(PCOMBOBOXEX pce, HFONT hFont, BOOL fRedraw)
{
    int iHeight;
    HFONT hfontOld = NULL;

    if (pce->fFontCreated)
        hfontOld = ComboEx_GetFont(pce);

    if (!hFont) {
        LOGFONT lf;
        SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), &lf, FALSE);
        hFont = CreateFontIndirect(&lf);
        pce->fFontCreated = TRUE;
    } else {
        pce->fFontCreated = FALSE;
    }
    pce->ci.uiCodePage = GetCodePageForFont(hFont);

    SendMessage(pce->hwndCombo, WM_SETFONT, (WPARAM)hFont, fRedraw);
    if (pce->hwndEdit)
    {
        SendMessage(pce->hwndEdit, WM_SETFONT, (WPARAM)hFont, fRedraw);
        SendMessage(pce->hwndEdit, EM_SETMARGINS, EC_USEFONTINFO, 0L);
    }

    iHeight = ComboEx_ComputeItemHeight(pce, FALSE);
    SendMessage(pce->ci.hwnd, CB_SETITEMHEIGHT, (WPARAM)-1, (LPARAM)iHeight);
    SendMessage(pce->hwndCombo, CB_SETITEMHEIGHT, 0, (LPARAM)iHeight);

    // do this last so that we don't have a nuked font as we try to create the new one
    if (hfontOld)
        DeleteObject(hfontOld);
}


void ComboEx_OnDestroy(PCOMBOBOXEX pce)
{
    // don't need do destroy hwndCombo.. it will be destroyed along with us.
    SendMessage(pce->hwndCombo, CB_RESETCONTENT, 0, 0);
    // we may still have string allocated for the item in the edit box so free it
    if (pce->cei.pszText)
        Str_Set(&(pce->cei.pszText), NULL);
    if (pce->fFontCreated) {
        DeleteObject(ComboEx_GetFont(pce));
    }

    if (pce->hwndEdit)
        RemoveWindowSubclass(pce->hwndEdit,  EditSubclassProc,  0);

    if (pce->hwndCombo)
        RemoveWindowSubclass(pce->hwndCombo, ComboSubclassProc, 0);

    SetWindowPtr(pce->ci.hwnd, 0, 0);
    LocalFree(pce);
}

// this gets the client rect without the scrollbar part and the border
void ComboEx_GetComboClientRect(PCOMBOBOXEX pce, LPRECT lprc)
{
    GetClientRect(pce->hwndCombo, lprc);
    InflateRect(lprc, -g_cxEdge, -g_cyEdge);
    lprc->right -= g_cxScrollbar;
}

// returns the edit box (creating it if necessary) or NULL if the combo does
// not have an edit box
HWND ComboEx_GetEditBox(PCOMBOBOXEX pce)
{
    HFONT hfont;
    DWORD dwStyle;
    DWORD dwExStyle = 0;

    if (pce->hwndEdit)
        return(pce->hwndEdit);

    if (!ComboEx_Editable(pce))
        return(NULL);

    dwStyle = WS_VISIBLE | WS_CLIPSIBLINGS | WS_CHILD | ES_LEFT;

    if (pce->ci.style & CBS_AUTOHSCROLL)
        dwStyle |= ES_AUTOHSCROLL;
    if (pce->ci.style & CBS_OEMCONVERT)
        dwStyle |= ES_OEMCONVERT;
#if 0
    if (pce->ci.style & CBS_UPPERCASE)
        dwStyle |= ES_UPPERCASE;
    if (pce->ci.style & CBS_LOWERCASE)
        dwStyle |= ES_LOWERCASE;
#endif

    dwExStyle = pce->ci.dwExStyle & (WS_EX_RIGHT | WS_EX_RTLREADING | WS_EX_LEFTSCROLLBAR);

    pce->hwndEdit = CreateWindowEx(dwExStyle, c_szEdit, c_szNULL, dwStyle, 0, 0, 0, 0,
                                   pce->hwndCombo, IntToPtr_(HMENU, GetDlgCtrlID(pce->ci.hwnd)), HINST_THISDLL, 0);

    if (!pce->hwndEdit ||
        !SetWindowSubclass(pce->hwndEdit, EditSubclassProc, 0, (DWORD_PTR)pce))
    {
        return NULL;
    }

    hfont = ComboEx_GetFont(pce);
    if (hfont)
        FORWARD_WM_SETFONT(pce->hwndEdit, hfont,
                           FALSE, SendMessage);

    return(pce->hwndEdit);
}

///
/// the edit box handling...
/*

 we want the edit box up on CBN_SETFOCUS and CBN_CLOSEUP
 remove it on CBN_DROPDOWN and on CBN_KILLFOCUS

 this assumes that CBN_SETFOCUS and CBN_KILLFOCUS will come before and after
 CBN_DROPDOWN and CBN_CLOSEUP respectively
 */

// Really a BOOL return value
LRESULT ComboEx_EndEdit(PCOMBOBOXEX pce, int iWhy)
{
    NMCBEENDEDIT    nm;
    LRESULT         fRet;

    if (!ComboEx_GetEditBox(pce))
        return(FALSE);

    pce->fInEndEdit = TRUE;

    GetWindowText(pce->hwndEdit, nm.szText, ARRAYSIZE(nm.szText));

    nm.fChanged = pce->fEditChanged;
    nm.iWhy = iWhy;

    nm.iNewSelection = ComboEx_OnFindStringExact(pce, ComboBox_GetCurSel(pce->hwndCombo) - 1, nm.szText);
    fRet = BOOLFROMPTR(CCSendNotify(&pce->ci, CBEN_ENDEDIT, &nm.hdr));

    pce->fInEndEdit = FALSE;

    if (!fRet) 
    {
        if (nm.iNewSelection != ComboBox_GetCurSel(pce->hwndCombo))
        {
            if (nm.iNewSelection != -1)
            {
                SendMessage(pce->ci.hwnd, CB_SETCURSEL, nm.iNewSelection, 0);
            }
            else
            {
                //if the selection is -1 and if we do a CB_SETCURSEL  on comboboxex then it nukes the text in
                //the edit window. Which is not the desired behavior. We need to update the Current Selection in the                 
                //child combobox but leave the text as it is.
                SendMessage(pce->hwndCombo, CB_SETCURSEL, nm.iNewSelection,0);
            }
        }
        pce->fEditChanged = FALSE;
    }
    InvalidateRect(pce->hwndCombo, NULL, FALSE);

    return(fRet);
}

void ComboEx_SizeEditBox(PCOMBOBOXEX pce)
{
    RECT rc;
    int cxIcon = 0, cyIcon = 0;

    ComboEx_GetComboClientRect(pce, &rc);
    InvalidateRect(pce->hwndCombo, &rc, TRUE); // erase so that the selection highlight is erased
    if (pce->himl && !(pce->dwExStyle & CBES_EX_NOEDITIMAGEINDENT))
    {
        // Make room for icons.
        ImageList_GetIconSize(pce->himl, &cxIcon, &cyIcon);
        if (cxIcon)
            cxIcon += COMBO_MARGIN;
    }

    // combobox edit field is one border in from the entire combobox client
    // rect -- thus add one border to edit control's left side
    rc.left += g_cxBorder + cxIcon;
    rc.bottom -= g_cyBorder;
    rc.top = rc.bottom - ComboEx_ComputeItemHeight(pce, TRUE) - g_cyBorder;
    SetWindowPos(pce->hwndEdit, NULL, rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc),
                 SWP_NOACTIVATE | SWP_NOZORDER | SWP_SHOWWINDOW);

}

BOOL ComboEx_GetCurSelText(PCOMBOBOXEX pce, LPTSTR pszText, int cchText)
{

    COMBOBOXEXITEM cei;
    BOOL bRet = TRUE;

    cei.mask = CBEIF_TEXT;
    cei.pszText = pszText;
    cei.cchTextMax = cchText;
    cei.iItem = ComboBox_GetCurSel(pce->hwndCombo);
    
    if (cei.iItem == -1 ) 
    {
        pszText[0] = 0;
        bRet = FALSE;
    } 
    else 
    {
        ComboEx_OnGetItem(pce, &cei);
    }
    return bRet;
}

void ComboEx_UpdateEditText(PCOMBOBOXEX pce, BOOL fClearOnNoSel)
{
    if (!pce->fInEndEdit)
    {
        TCHAR szText[CBEMAXSTRLEN];

        HWND hwndEdit = ComboEx_Editable(pce) ? pce->hwndEdit : pce->hwndCombo;

        if (ComboEx_GetCurSelText(pce, szText, ARRAYSIZE(szText)) || fClearOnNoSel) {
            SendMessage(hwndEdit, WM_SETTEXT, 0, (LPARAM)szText);
            EDIT_SELECTALL( hwndEdit );
        }
    }
}

BOOL ComboEx_BeginEdit(PCOMBOBOXEX pce)
{
    if (!ComboEx_GetEditBox(pce))
        return(FALSE);

    SetFocus(pce->hwndEdit);
    return(TRUE);
}

BOOL ComboSubclass_HandleButton(PCOMBOBOXEX pce, WPARAM wParam, LPARAM lParam)
{
    RECT rc;
#ifndef UNIX
    POINT pt = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)};
#else
    POINT pt;
    pt.x = GET_X_LPARAM(lParam);
    pt.y = GET_Y_LPARAM(lParam);
#endif

    ComboEx_GetComboClientRect(pce, &rc);
    InflateRect(&rc, g_cxEdge, g_cyEdge);

    if (PtInRect(&rc, pt)) {

        //
        //  CheckForDragBegin yields, so we must revalidate on the way back.
        //
        HWND hwndCombo = pce->hwndCombo;
        if (CheckForDragBegin(pce->hwndCombo, LOWORD(lParam), HIWORD(lParam)))
        {
            NMCBEDRAGBEGIN  nmcbebd;
            LRESULT fRet;

            nmcbebd.iItemid = -1;
            GetWindowText(pce->hwndEdit, nmcbebd.szText, ARRAYSIZE(nmcbebd.szText));

            // BUGBUG - raymondc - why do we ignore the return code?
            fRet = CCSendNotify(&pce->ci, CBEN_DRAGBEGIN, &nmcbebd.hdr);
            return TRUE;
        }
        // CheckForDragBegin yields, so revalidate before continuing
        else if (IsWindow(hwndCombo)) {

            // a click on our border should start edit mode as well
            if (ComboEx_Editable(pce)) {
                if (!ComboEx_BeginEdit(pce))
                    SetFocus(pce->hwndCombo);
                return TRUE;
            }
            return FALSE;
        }
   }
   return FALSE;
}

BOOL ComboSubclass_HandleCommand(PCOMBOBOXEX pce, WPARAM wParam, LPARAM lParam)
{
    UINT idCmd = GET_WM_COMMAND_ID(wParam, lParam);
    UINT uCmd = GET_WM_COMMAND_CMD(wParam, lParam);
    HWND hwnd = GET_WM_COMMAND_HWND(wParam, lParam);

    switch (uCmd)
    {
        case EN_SETFOCUS:
            if (!pce->fInDrop)
            {
                EDIT_SELECTALL( pce->hwndEdit );
                CCSendNotify(&pce->ci, CBEN_BEGINEDIT, NULL);
                pce->fEditChanged = FALSE;
            }
            break;

        case EN_KILLFOCUS:
        {
            HWND hwndFocus;
            hwndFocus = GetFocus();
            if (hwndFocus != pce->hwndCombo)
            {
                ComboEx_EndEdit(pce, CBENF_KILLFOCUS);
                SendMessage(pce->hwndCombo, WM_KILLFOCUS, (WPARAM)hwndFocus, 0);
            }

            break;
        }

        case EN_CHANGE:
        {
            TCHAR szTextOrig[CBEMAXSTRLEN];
            TCHAR szTextNow[CBEMAXSTRLEN];
            WPARAM iItem;

            iItem = ComboBox_GetCurSel(pce->hwndCombo);

            if(iItem == -1)
            {
                if (pce->fEditItemSet && pce->cei.pszText) 
                {
                    Str_GetPtr(pce->cei.pszText, szTextOrig, ARRAYSIZE(szTextOrig));
                }
                else
                {
                    szTextOrig[0] = TEXT('\0');
                }
            }
            else 
            {
                ComboEx_GetCurSelText(pce,szTextOrig, ARRAYSIZE(szTextOrig));
            }

#ifndef UNIX
            GetWindowText(pce->hwndEdit, szTextNow, ARRAYSIZE(szTextNow));
#else
            GetWindowText(pce->hwndEdit, szTextNow, ARRAYSIZE(szTextNow)-1);
#endif
            pce->fEditChanged = (ComboEx_StrCmp(pce, szTextOrig, szTextNow) != 0);
            SendMessage(pce->ci.hwndParent, WM_COMMAND,
                    GET_WM_COMMAND_MPS(idCmd, pce->ci.hwnd, CBN_EDITCHANGE));

            break;
        }
    }

    return(hwnd == pce->hwndEdit);
}

void EraseWindow(HWND hwnd, HDC hdc, COLORREF clr)
{
    RECT rc;
    GetClientRect(hwnd, &rc);
    FillRectClr(hdc, &rc, clr);
}

LRESULT CALLBACK EditSubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
    PCOMBOBOXEX pce = (PCOMBOBOXEX)dwRefData;

    if (uMsg == WM_SETFONT ||
        uMsg == WM_WININICHANGE) {
        return DefSubclassProc(hwnd, uMsg, wParam, lParam);

    }

    switch(uMsg) {
    case WM_ERASEBKGND:
        EraseWindow(hwnd, (HDC)wParam, GetSysColor(COLOR_WINDOW));
        break;

    case WM_DESTROY:
        RemoveWindowSubclass(hwnd, EditSubclassProc, 0);
        break;

    case WM_CHAR:
        switch ((TCHAR)wParam) {
        case TEXT('\n'):
        case TEXT('\r'):
            // return... don't go to wndproc because
            // the edit control beeps on enter
            return 0;
        }
        break;

    case WM_SIZE:
        if (GetFocus() != hwnd) {
            Edit_SetSel(pce->hwndEdit, 0, 0);    // makesure everything is scrolled over first
        }
        break;

    case WM_KEYDOWN:
        switch(wParam) {
        case VK_RETURN:
            if (!ComboEx_EndEdit(pce, CBENF_RETURN))
                // we know we have an edit window, so FALSE return means
                // app returned FALSE to CBEN_ENDEDIT notification
                ComboEx_BeginEdit(pce);
            break;

        case VK_ESCAPE:
            pce->fEditChanged = FALSE;
            if (!ComboEx_EndEdit(pce, CBENF_ESCAPE)) {
                if(pce->fEditItemSet) {
                    if(pce->cei.pszText) {
                        SendMessage(pce->hwndEdit, WM_SETTEXT, (WPARAM)0, (LPARAM)pce->cei.pszText);
                        EDIT_SELECTALL( pce->hwndEdit );
                    }
                    RedrawWindow(pce->hwndCombo, NULL, NULL, RDW_ERASE | RDW_INVALIDATE);
                }else {
                    ComboEx_BeginEdit(pce);
                }
            }
            break;

        // Pass these to the combobox itself to make it work properly...
        case VK_HOME:
        case VK_END:
            if (!pce->fInDrop)
                break;

        case VK_F4:
        case VK_UP:
        case VK_DOWN:
        case VK_PRIOR:
        case VK_NEXT:
            if (pce->hwndCombo)
                return SendMessage(pce->hwndCombo, uMsg, wParam, lParam);
            break;
        }
        break;

    case WM_LBUTTONDOWN:
        if (GetFocus() != pce->hwndEdit)
        {
            SetFocus(pce->hwndEdit);
#ifndef UNIX
            // IEUNIX : since we disabled autoselection on first click in address bar,
            // we should not eat this message. This allows the dragging to begin with
            // the first click.
            return(0L); // eat this message
#endif
        }
        break;

    case WM_SYSKEYDOWN:
        switch(wParam) {
        // Pass these to the combobox itself to make it work properly...
        case VK_UP:
        case VK_DOWN:
            {
                LRESULT lR;
                if (pce->hwndCombo)
                {
                    lR=SendMessage(pce->hwndCombo, uMsg, wParam, lParam);
#ifdef KEYBOARDCUES
                    //notify of navigation key usage
                    CCNotifyNavigationKeyUsage(&(pce->ci), UISF_HIDEFOCUS);
#endif
                    return lR;
                }
            }
        }
    }

    return DefSubclassProc(hwnd, uMsg, wParam, lParam);
}

LRESULT ComboEx_GetLBText(PCOMBOBOXEX pce, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    COMBOBOXEXITEM cei;
    TCHAR szText[CBEMAXSTRLEN];
    cei.mask = CBEIF_TEXT;
    cei.pszText = szText;
    cei.cchTextMax = ARRAYSIZE(szText);
    cei.iItem = (INT_PTR)wParam;
    if (!ComboEx_OnGetItem(pce, &cei))
        return CB_ERR;

    if (lParam && uMsg == CB_GETLBTEXT) {
#ifdef UNICODE_WIN9x
        if (pce->ci.bUnicode) {
            lstrcpy((LPTSTR)lParam, szText);
        } else {
            WideCharToMultiByte(pce->ci.uiCodePage, 0, szText, -1, (LPSTR)lParam, CBEMAXSTRLEN, NULL,NULL);
        }
#else
        lstrcpy((LPTSTR)lParam, szText);
#endif
    }
    return lstrlen(szText);
}

LRESULT CALLBACK ComboSubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
    PCOMBOBOXEX pce = (PCOMBOBOXEX)dwRefData;

    switch (uMsg) {

    case WM_ERASEBKGND:
        EraseWindow(hwnd, (HDC)wParam, GetSysColor(COLOR_WINDOW));
        break;

    case CB_GETLBTEXT:
    case CB_GETLBTEXTLEN:
        return ComboEx_GetLBText(pce, uMsg, wParam, lParam);

    case WM_RBUTTONDOWN:
        //Fall Thru
    case WM_LBUTTONDOWN:
        if (ComboSubclass_HandleButton(pce, wParam, lParam)) {
            return 0;
        }
        break;

    case WM_COMMAND:
        if (ComboSubclass_HandleCommand(pce, wParam, lParam))
            return 0;
        break;

    case WM_DESTROY:
        RemoveWindowSubclass(hwnd, ComboSubclassProc, 0);
        break;

    case WM_SETCURSOR:
        if (pce) {
            NMMOUSE nm = {0};
            nm.dwHitInfo = lParam;
            if (CCSendNotify(&pce->ci, NM_SETCURSOR, &nm.hdr))
                return 0;
        }
        break;
    }

    return DefSubclassProc(hwnd, uMsg, wParam, lParam);
}

BOOL ComboEx_OnCreate(HWND hwnd, LPCREATESTRUCT lpcs)
{
    PCOMBOBOXEX pce;
    DWORD dwStyle;
    DWORD dwExStyle = 0;

    pce = (PCOMBOBOXEX)LocalAlloc(LPTR, sizeof(COMBOEX));
    if (!pce)
        return FALSE;

    SetWindowPtr(hwnd, 0, pce);

    // BUGBUG: force off borders off ourself
    lpcs->style &= ~(WS_BORDER | WS_VSCROLL | WS_HSCROLL | CBS_UPPERCASE | CBS_LOWERCASE);
    SetWindowLong(hwnd, GWL_STYLE, lpcs->style);
    CIInitialize(&pce->ci, hwnd, lpcs);

    // or in CBS_SIMPLE because we can never allow the sub combo box
    // to have just drop down.. it's either all simple or dropdownlist
    dwStyle = CBS_OWNERDRAWFIXED | CBS_SIMPLE | CBS_NOINTEGRALHEIGHT | WS_VISIBLE |WS_VSCROLL | WS_CLIPCHILDREN | WS_CLIPSIBLINGS;

    dwStyle |= (lpcs->style & (CBS_DROPDOWNLIST | CBS_HASSTRINGS | WS_CHILD));

    if ((lpcs->style & CBS_DROPDOWNLIST) == CBS_SIMPLE)
        dwStyle |= (lpcs->style & (CBS_AUTOHSCROLL | CBS_OEMCONVERT | CBS_UPPERCASE | CBS_LOWERCASE));

    dwExStyle = lpcs->dwExStyle & (WS_EX_RIGHT | WS_EX_RTLREADING | WS_EX_LEFTSCROLLBAR);

    pce->hwndCombo = CreateWindowEx(dwExStyle, c_szComboBox, lpcs->lpszName,
                                    dwStyle,
                                    0, 0, lpcs->cx, lpcs->cy,
                                    hwnd, lpcs->hMenu, lpcs->hInstance, 0);

    if (!pce->hwndCombo ||
        !SetWindowSubclass(pce->hwndCombo, ComboSubclassProc, 0, (DWORD_PTR)pce) ||
        (!ComboEx_GetEditBox(pce) && ComboEx_Editable(pce)))
    {
        ComboEx_OnDestroy(pce);
        return FALSE;
    }

    ComboEx_OnSetFont(pce, NULL, FALSE);
    pce->cxIndent = 10;
    pce->iSel = -1;

    ComboEx_OnWindowPosChanging(pce, NULL);
    return TRUE;
}


HIMAGELIST ComboEx_OnSetImageList(PCOMBOBOXEX pce, HIMAGELIST himl)
{
    int iHeight;
    HIMAGELIST himlOld = pce->himl;

    pce->himl = himl;

    iHeight = ComboEx_ComputeItemHeight(pce, FALSE);
    SendMessage(pce->ci.hwnd, CB_SETITEMHEIGHT, (WPARAM)-1, iHeight);
    SendMessage(pce->hwndCombo, CB_SETITEMHEIGHT, 0, iHeight);

    InvalidateRect(pce->hwndCombo, NULL, TRUE);

    if (pce->hwndEdit)
        ComboEx_SizeEditBox(pce);

    return himlOld;
}

void ComboEx_OnDrawItem(PCOMBOBOXEX pce, LPDRAWITEMSTRUCT pdis)
{
    HDC hdc = pdis->hDC;
    RECT rc = pdis->rcItem;
    TCHAR szText[CBEMAXSTRLEN];
    int offset = 0;
    int xString, yString, xCombo;
    int cxIcon = 0, cyIcon = 0;
    int iLen;
    BOOL fSelected = FALSE;
    SIZE sizeText;
    COMBOBOXEXITEM cei;
    BOOL fNoText = FALSE;
    BOOL fEnabled = IsWindowEnabled(pce->hwndCombo);
    BOOL fRTLReading = FALSE;
    UINT OldTextAlign;

    // Setup the dc before we use it.
    fRTLReading = GetWindowLong(pdis->hwndItem, GWL_EXSTYLE) & WS_EX_RTLREADING;
    if (fRTLReading) {
        OldTextAlign = GetTextAlign(hdc);
        SetTextAlign(hdc, OldTextAlign|TA_RTLREADING);
    }

    rc.top += g_cyBorder;

    szText[0] = 0;
    if (pdis->itemID != -1)
    {
        cei.mask = CBEIF_TEXT | CBEIF_IMAGE | CBEIF_OVERLAY | CBEIF_SELECTEDIMAGE| CBEIF_INDENT;
        cei.pszText = szText;
        cei.cchTextMax = ARRAYSIZE(szText);
        cei.iItem = pdis->itemID;

        ComboEx_OnGetItem(pce, &cei);

        if (pce->iSel == (int)pdis->itemID ||
            ((pce->iSel == -1) && ((int)pdis->itemID == ComboBox_GetCurSel(pce->hwndCombo))))
            fSelected = TRUE;
    }
    else {
        if(pce->fEditItemSet) {
            cei.mask = CBEIF_TEXT | CBEIF_IMAGE | CBEIF_OVERLAY | CBEIF_SELECTEDIMAGE| CBEIF_INDENT;
            cei.pszText = szText;
            cei.cchTextMax = ARRAYSIZE(szText);
            cei.iItem = pdis->itemID;

            ComboEx_OnGetItem(pce, &cei);
        }
    }

    if (pce->himl && !(pce->dwExStyle & CBES_EX_NOEDITIMAGEINDENT))
    {
        ImageList_GetIconSize(pce->himl, &cxIcon, &cyIcon);
        if (cxIcon)
            cxIcon += COMBO_MARGIN;
    }

    // if we're not drawing the edit box, figure out how far to indent
    // over
    if (!(pdis->itemState & ODS_COMBOBOXEDIT))
    {
        offset = (pce->cxIndent * cei.iIndent) + COMBO_BORDER;
    }
    else
    {
        if (pce->hwndEdit)
            fNoText = TRUE;

        if (pce->dwExStyle & CBES_EX_NOEDITIMAGEINDENT)
            cxIcon = 0;
    }

    xCombo = rc.left + offset;
    rc.left = xString = xCombo + cxIcon;
    iLen = lstrlen(szText);
    GetTextExtentPoint(hdc, szText, iLen, &sizeText);

    rc.right = rc.left + sizeText.cx;
    rc.left--;
    rc.right++;

    if (pdis->itemAction != ODA_FOCUS)
    {
        int yMid;
        BOOL fTextHighlight = FALSE;;

        yMid = (rc.top + rc.bottom) / 2;
        // center the string within rc
        yString = yMid - (sizeText.cy/2);

        if (pdis->itemState & ODS_SELECTED) {
            if (!(pdis->itemState & ODS_COMBOBOXEDIT) ||
                !ComboEx_Editable(pce)) {
                fTextHighlight = TRUE;
            }
        }

        if ( !fEnabled ) {
            SetBkColor(hdc, g_clrBtnFace);
            SetTextColor(hdc, GetSysColor(COLOR_GRAYTEXT));
        } else {
            SetBkColor(hdc, GetSysColor(fTextHighlight ?
                            COLOR_HIGHLIGHT : COLOR_WINDOW));
            SetTextColor(hdc, GetSysColor(fTextHighlight ?
                            COLOR_HIGHLIGHTTEXT : COLOR_WINDOWTEXT));
        }

        if ((pdis->itemState & ODS_COMBOBOXEDIT) &&
                (rc.right > pdis->rcItem.right))
        {
            // Need to clip as user does not!
            rc.right = pdis->rcItem.right;
        }

        if (!fNoText) {
            ExtTextOut(hdc, xString, yString, ETO_OPAQUE | ETO_CLIPPED, &rc, szText, iLen, NULL);
        }

        if (pce->himl && (pdis->itemID != -1 || pce->fEditItemSet) &&
            !((pce->dwExStyle & (CBES_EX_NOEDITIMAGE | CBES_EX_NOEDITIMAGEINDENT)) &&
              (pdis->itemState & ODS_COMBOBOXEDIT))) {

            DWORD fTransparent = 0;

            if ((pdis->itemState & ODS_COMBOBOXEDIT) && !fEnabled) {
                fTransparent = ILD_TRANSPARENT;
            }

            if (pce->himl && (pdis->itemID != -1 || pce->fEditItemSet) &&
                !((pce->dwExStyle & (CBES_EX_NOEDITIMAGE | CBES_EX_NOEDITIMAGEINDENT))))
            {
                ImageList_Draw(pce->himl,
                               (fSelected) ? cei.iSelectedImage : cei.iImage,
                               hdc, xCombo, yMid - (cyIcon/2),
                               INDEXTOOVERLAYMASK(cei.iOverlay) |
                               fTransparent |
                               ((pdis->itemState & ODS_SELECTED) ? (ILD_SELECTED | ILD_FOCUS) : ILD_NORMAL));
            }
        }
    }


    if ((pdis->itemAction == ODA_FOCUS ||
        (pdis->itemState & ODS_FOCUS))
#ifdef KEYBOARDCUES
        && !(CCGetUIState(&(pce->ci)) & UISF_HIDEFOCUS)
#endif
        )
    {
        if (!fNoText) {
            DrawFocusRect(hdc, &rc);
        }
    }

    // Restore the text align in the dc.
    if (fRTLReading) {
        SetTextAlign(hdc, OldTextAlign);
    }
}

int ComboEx_ComputeItemHeight(PCOMBOBOXEX pce, BOOL fTextOnly)
{
    HDC hdc;
    HFONT hfontOld;
    int dyDriveItem;
    SIZE siz;

    hdc = GetDC(NULL);
    hfontOld = ComboEx_GetFont(pce);
    if (hfontOld)
        hfontOld = SelectObject(hdc, hfontOld);

    GetTextExtentPoint(hdc, TEXT("W"), 1, &siz);
    dyDriveItem = siz.cy;

    if (hfontOld)
        SelectObject(hdc, hfontOld);
    ReleaseDC(NULL, hdc);

    if (fTextOnly)
        return dyDriveItem;

    dyDriveItem += COMBO_BORDER;

    // now take into account the icon
    if (pce->himl) {
        int cxIcon = 0, cyIcon = 0;
        ImageList_GetIconSize(pce->himl, &cxIcon, &cyIcon);

        if (dyDriveItem < cyIcon)
            dyDriveItem = cyIcon;
    }

    return dyDriveItem;
}

void ComboEx_OnMeasureItem(PCOMBOBOXEX pce, LPMEASUREITEMSTRUCT pmi)
{

    pmi->itemHeight = ComboEx_ComputeItemHeight(pce, FALSE);

}

void ComboEx_ISetItem(PCOMBOBOXEX pce, PCEITEM pcei, PCOMBOBOXEXITEM pceItem)
{
    if (pceItem->mask & CBEIF_INDENT)
        pcei->iIndent = pceItem->iIndent;
    if (pceItem->mask & CBEIF_IMAGE)
        pcei->iImage = pceItem->iImage;
    if (pceItem->mask & CBEIF_SELECTEDIMAGE)
        pcei->iSelectedImage = pceItem->iSelectedImage;
    if (pceItem->mask & CBEIF_OVERLAY)
        pcei->iOverlay = pceItem->iOverlay;

    if (pceItem->mask & CBEIF_TEXT) {
        Str_Set(&pcei->pszText, pceItem->pszText);
    }

    if (pceItem->mask & CBEIF_LPARAM) {
        pcei->lParam = pceItem->lParam;
    }

}

#define ComboEx_GetItemPtr(pce, iItem) \
        ((PCEITEM)SendMessage((pce)->hwndCombo, CB_GETITEMDATA, iItem, 0))
#define ComboEx_Count(pce) \
        ((int)SendMessage((pce)->hwndCombo, CB_GETCOUNT, 0, 0))


BOOL ComboEx_OnGetItem(PCOMBOBOXEX pce, PCOMBOBOXEXITEM pceItem)
{
    PCEITEM pcei;
    NMCOMBOBOXEX nm;

    if(pceItem->iItem != -1) {
        pcei = ComboEx_GetItemPtr(pce, pceItem->iItem);
    }
    else {
        pcei = &(pce->cei);
    }

    if ((!pcei) || (pcei == (PCEITEM)-1))
        return FALSE;

    nm.ceItem.mask = 0;

    if (pceItem->mask & CBEIF_TEXT) {

        if (pcei->pszText == LPSTR_TEXTCALLBACK) {
            nm.ceItem.mask |= CBEIF_TEXT;
        } else {
            if(pceItem->iItem != -1) {
                Str_GetPtr(pcei->pszText, pceItem->pszText, pceItem->cchTextMax);
            }else {
                SendMessage(pce->hwndEdit, WM_GETTEXT, (WPARAM)pceItem->cchTextMax, (LPARAM)pceItem->pszText);
            }
        }
    }

    if (pceItem->mask & CBEIF_IMAGE) {

        if (pcei->iImage == I_IMAGECALLBACK) {
            nm.ceItem.mask |= CBEIF_IMAGE;
        }
        pceItem->iImage = pcei->iImage;

    }

    if (pceItem->mask & CBEIF_SELECTEDIMAGE) {

        if (pcei->iSelectedImage == I_IMAGECALLBACK) {
            nm.ceItem.mask |= CBEIF_SELECTEDIMAGE;
        }
        pceItem->iSelectedImage = pcei->iSelectedImage;
    }

    if (pceItem->mask & CBEIF_OVERLAY) {

        if (pcei->iOverlay == I_IMAGECALLBACK) {
            nm.ceItem.mask |= CBEIF_OVERLAY;
        }
        pceItem->iOverlay = pcei->iOverlay;
    }

    if (pceItem->mask & CBEIF_INDENT) {

        if (pcei->iIndent == I_INDENTCALLBACK) {
            nm.ceItem.mask |= CBEIF_INDENT;
            pceItem->iIndent = 0;
        } else {
            pceItem->iIndent = pcei->iIndent;
        }
    }

    if (pceItem->mask & CBEIF_LPARAM) {
        pceItem->lParam = pcei->lParam;
    }



    // is there anything to call back for?
    if (nm.ceItem.mask) {
        UINT uMask = nm.ceItem.mask;

        nm.ceItem = *pceItem;
        nm.ceItem.lParam = pcei->lParam;
        nm.ceItem.mask = uMask;

        if ((nm.ceItem.mask & CBEIF_TEXT) &&
            nm.ceItem.cchTextMax) {
            // null terminate just in case they don't respond
            *nm.ceItem.pszText = 0;
        }

        CCSendNotify(&pce->ci, CBEN_GETDISPINFO, &nm.hdr);

        if (nm.ceItem.mask & CBEIF_INDENT)
            pceItem->iIndent = nm.ceItem.iIndent;

        if (nm.ceItem.mask & CBEIF_IMAGE)
            pceItem->iImage = nm.ceItem.iImage;

        if (nm.ceItem.mask & CBEIF_SELECTEDIMAGE)
            pceItem->iSelectedImage = nm.ceItem.iSelectedImage;

        if (nm.ceItem.mask & CBEIF_OVERLAY)
            pceItem->iOverlay = nm.ceItem.iOverlay;

        if (nm.ceItem.mask & CBEIF_TEXT)
        {
            if (pceItem->mask & CBEIF_TEXT)
                pceItem->pszText = CCReturnDispInfoText(nm.ceItem.pszText, pceItem->pszText, pceItem->cchTextMax);
            else
                pceItem->pszText = nm.ceItem.pszText;
        }

        if (nm.ceItem.mask & CBEIF_DI_SETITEM) {

            ComboEx_ISetItem(pce, pcei, &nm.ceItem);
        }
    }
    return TRUE;

}

#ifdef UNICODE
BOOL ComboEx_OnGetItemA(PCOMBOBOXEX pce, PCOMBOBOXEXITEMA pceItem)
{
    LPWSTR pwszText;
    LPSTR pszTextSave;
    BOOL fRet;

    if (!(pceItem->mask & CBEIF_TEXT)) {
        return ComboEx_OnGetItem(pce, (PCOMBOBOXEXITEM)pceItem);
    }

    pwszText = (LPWSTR)LocalAlloc(LPTR, (pceItem->cchTextMax+1)*sizeof(WCHAR));
    if (!pwszText)
        return FALSE;
    pszTextSave = pceItem->pszText;
    ((PCOMBOBOXEXITEM)pceItem)->pszText = pwszText;
    fRet = ComboEx_OnGetItem(pce, (PCOMBOBOXEXITEM)pceItem);
    pceItem->pszText = pszTextSave;

    if (fRet) {
        // BUGBUG: WCTMB failes w/ ERROR_INSUFFICIENT_BUFFER whereas the native-A implementation truncates
        WideCharToMultiByte(CP_ACP, 0, pwszText, -1,
                            (LPSTR)pszTextSave, pceItem->cchTextMax, NULL, NULL);
    }
    LocalFree(pwszText);
    return fRet;

}
#endif

BOOL ComboEx_OnSetItem(PCOMBOBOXEX pce, PCOMBOBOXEXITEM pceItem)
{
    if(pceItem->iItem != -1) {
        PCEITEM pcei = ComboEx_GetItemPtr(pce, pceItem->iItem);
        UINT rdwFlags = 0;

        if (pcei == (PCEITEM)-1)
            return FALSE;

        ComboEx_ISetItem(pce, pcei, pceItem);

        if (rdwFlags & (CBEIF_INDENT | CBEIF_IMAGE |CBEIF_SELECTEDIMAGE | CBEIF_TEXT | CBEIF_OVERLAY)) {
            rdwFlags = RDW_ERASE | RDW_INVALIDATE;
        }
        // BUGBUG: do something better..

        if (rdwFlags) {
            RedrawWindow(pce->hwndCombo, NULL, NULL, rdwFlags);
        }

        if (pceItem->iItem == ComboBox_GetCurSel(pce->hwndCombo))
            ComboEx_UpdateEditText(pce, FALSE);
        // BUGUBG: notify item changed
        return TRUE;

  } else {

        pce->cei.iImage = -1;
        pce->cei.iSelectedImage = -1;

        ComboEx_ISetItem(pce, &(pce->cei), pceItem);

        pce->fEditItemSet = TRUE;

        if (!pce->hwndEdit){
            Str_Set(&pce->cei.pszText, NULL);
            pce->fEditItemSet = FALSE;
            return(CB_ERR);
        }

        if(pce->cei.pszText) {
            SendMessage(pce->hwndEdit, WM_SETTEXT, (WPARAM)0, (LPARAM)pce->cei.pszText);
            EDIT_SELECTALL( pce->hwndEdit );
        }
        RedrawWindow(pce->hwndCombo, NULL, NULL, RDW_ERASE | RDW_INVALIDATE);
        return TRUE;

   }
}

void ComboEx_HandleDeleteItem(PCOMBOBOXEX pce, LPDELETEITEMSTRUCT pdis)
{
    PCEITEM pcei = (PCEITEM)pdis->itemData;
    if (pcei) {
        NMCOMBOBOXEX nm;

        Str_Set(&pcei->pszText, NULL);

        nm.ceItem.iItem = pdis->itemID;
        nm.ceItem.mask = CBEIF_LPARAM;
        nm.ceItem.lParam = pcei->lParam;
        CCSendNotify(&pce->ci, CBEN_DELETEITEM, &nm.hdr);

        LocalFree(pcei);
    }
}

LRESULT ComboEx_OnInsertItem(PCOMBOBOXEX pce, PCOMBOBOXEXITEM pceItem)
{
    LRESULT iRet;
    PCEITEM pcei = (PCEITEM)LocalAlloc(LPTR, sizeof(CEITEM));

    if (!pcei)
        return -1;

    pcei->iImage = -1;
    pcei->iSelectedImage = -1;
    //pcei->iOverlay = 0;
    //pcei->iIndent = 0;

    ComboEx_ISetItem(pce, pcei, pceItem);

    iRet = ComboBox_InsertString(pce->hwndCombo, pceItem->iItem, pcei);
    if (iRet != -1) {
        NMCOMBOBOXEX nm;

        nm.ceItem = *pceItem;
        CCSendNotify(&pce->ci, CBEN_INSERTITEM, &nm.hdr);
    }
    return iRet;
}


void ComboEx_OnWindowPosChanging(PCOMBOBOXEX pce, LPWINDOWPOS pwp)
{
    RECT rcWindow, rcClient;
    RECT rc;
    int  cxInner;
    int cy;

    GetWindowRect(pce->ci.hwnd, &rcWindow);

    if (pwp) {
        // check to see if our size & position aren't actually changing (rebar, for one, 
        // does lots of DeferWindowPos calls that don't actually change our size or position
        // but still generate WM_WINDOWPOSCHANGING msgs).  we avoid flicker by bailing here.
        RECT rcWp;
        SetRect(&rcWp, pwp->x, pwp->y, pwp->x + pwp->cx, pwp->y + pwp->cy);
        MapWindowRect(GetParent(pce->ci.hwnd), HWND_DESKTOP, (LPPOINT)&rcWp);
        if (EqualRect(&rcWp, &rcWindow)) {
            // this is a noop, so bail
            return;
        }
    }

    GetClientRect(pce->ci.hwnd, &rcClient);

    if (pwp)
        cxInner = pwp->cx + RECTWIDTH(rcWindow) - RECTWIDTH(rcClient);
    else
        cxInner = RECTWIDTH(rcClient);

    GetWindowRect(pce->hwndCombo, &rc);
    if (cxInner) {

        // don't size the inner combo if width is 0; otherwise, the below
        // computation will make the comboEX the height of the inner combo
        // top + inner combo dropdown instead of JUST the inner combo top
        cy = (pwp && ((pce->ci.style & CBS_DROPDOWNLIST) == CBS_SIMPLE)) ?  pwp->cy : RECTHEIGHT(rc);

        SetWindowPos(pce->hwndCombo, NULL, 0, 0, cxInner, cy,
                                          SWP_NOACTIVATE | (pce->hwndEdit ? SWP_NOREDRAW : 0));
    }

    GetWindowRect(pce->hwndCombo, &rc);

    cy = RECTHEIGHT(rc) + (RECTHEIGHT(rcWindow) - RECTHEIGHT(rcClient));

    if (pwp) {
        if (cy < pwp->cy || !(pce->dwExStyle & CBES_EX_NOSIZELIMIT)) {
            pwp->cy = cy;
        }
    } else {

        if (cy < RECTHEIGHT(rcWindow) || !(pce->dwExStyle & CBES_EX_NOSIZELIMIT)) {
            SetWindowPos(pce->ci.hwnd, NULL, 0, 0,
                         RECTWIDTH(rcWindow),
                         cy,
                         SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER);
        }
    }

    if (pce->hwndEdit)
    {
        ComboEx_SizeEditBox(pce);
        InvalidateRect(pce->hwndCombo, NULL, TRUE);
    }
}

LRESULT ComboEx_HandleCommand(PCOMBOBOXEX pce, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres;
    UINT idCmd = GET_WM_COMMAND_ID(wParam, lParam);
    UINT uCmd = GET_WM_COMMAND_CMD(wParam, lParam);

    if (!pce)
        return 0;

    if (uCmd == CBN_SELCHANGE)
        // update the edit text before forwarding this notification 'cause in
        // a normal combobox, the edit control will have already been updated
        // upon receipt of this notification
        ComboEx_UpdateEditText(pce, FALSE);

    lres = SendMessage(pce->ci.hwndParent, WM_COMMAND, GET_WM_COMMAND_MPS(idCmd, pce->ci.hwnd, uCmd));

    switch (uCmd) {

    case CBN_DROPDOWN:
        pce->iSel = ComboBox_GetCurSel(pce->hwndCombo);
        ComboEx_EndEdit(pce, CBENF_DROPDOWN);
        if (GetFocus() == pce->hwndEdit)
            SetFocus(pce->hwndCombo);
        pce->fInDrop = TRUE;
        break;

    case CBN_KILLFOCUS:
        ComboEx_EndEdit(pce, CBENF_KILLFOCUS);
        break;

    case CBN_CLOSEUP:
        pce->iSel = -1;
        ComboEx_BeginEdit(pce);
        pce->fInDrop = FALSE;
        break;

    case CBN_SETFOCUS:
        ComboEx_BeginEdit(pce);
        break;

    }

    return lres;
}

LRESULT ComboEx_OnGetItemData(PCOMBOBOXEX pce, WPARAM i)
{
    PCEITEM pcei = (PCEITEM)SendMessage(pce->hwndCombo, CB_GETITEMDATA, i, 0);
    if (pcei == NULL || pcei == (PCEITEM)CB_ERR) {
        return CB_ERR;
    }

    return pcei->lParam;
}

LRESULT ComboEx_OnSetItemData(PCOMBOBOXEX pce, int i, LPARAM lParam)
{
    PCEITEM pcei = (PCEITEM)SendMessage(pce->hwndCombo, CB_GETITEMDATA, i, 0);
    if (pcei == NULL || pcei == (PCEITEM)CB_ERR) {
        return CB_ERR;
    }
    pcei->lParam = lParam;
    return 0;
}

int ComboEx_OnFindStringExact(PCOMBOBOXEX pce, int iStart, LPCTSTR lpsz)
{
    int i;
    int iMax = ComboEx_Count(pce);
    TCHAR szText[CBEMAXSTRLEN];
    COMBOBOXEXITEM cei;

    if (iStart < 0)
        iStart = -1;

    cei.mask = CBEIF_TEXT;
    cei.pszText = szText;
    cei.cchTextMax = ARRAYSIZE(szText);

    for (i = iStart + 1 ; i < iMax; i++) {
        cei.iItem = i;
        if (ComboEx_OnGetItem(pce, &cei)) {
            if (!ComboEx_StrCmp(pce, lpsz, szText)) {
                return i;
            }
        }
    }

    for (i = 0; i <= iStart; i++) {
        cei.iItem = i;
        if (ComboEx_OnGetItem(pce, &cei)) {
            if (!ComboEx_StrCmp(pce, lpsz, szText)) {
                return i;
            }
        }
    }

    return CB_ERR;
}

int ComboEx_StrCmp(PCOMBOBOXEX pce, LPCTSTR psz1, LPCTSTR psz2)
{
    if (pce->dwExStyle & CBES_EX_CASESENSITIVE) {
        return lstrcmp(psz1, psz2);
    }
    return lstrcmpi(psz1, psz2);
}

DWORD ComboEx_OnSetExStyle(PCOMBOBOXEX pce, DWORD dwExStyle, DWORD dwExMask)
{
    DWORD dwRet;
    DWORD dwChange;

    if (dwExMask)
        dwExStyle = (pce->dwExStyle & ~ dwExMask) | (dwExStyle & dwExMask);

    dwRet = pce->dwExStyle;
    dwChange = (pce->dwExStyle ^ dwExStyle);

    pce->dwExStyle = dwExStyle;
    if (dwChange & (CBES_EX_NOEDITIMAGE | CBES_EX_NOEDITIMAGEINDENT)) {
        InvalidateRect(pce->ci.hwnd, NULL, TRUE);
        if (pce->hwndEdit)
        {
            ComboEx_SizeEditBox(pce);
            InvalidateRect(pce->hwndEdit, NULL, TRUE);
        }
    }

    if (dwChange & CBES_EX_PATHWORDBREAKPROC)
        SetPathWordBreakProc(pce->hwndEdit, (pce->dwExStyle & CBES_EX_PATHWORDBREAKPROC));

    return dwRet;
}

HFONT ComboEx_GetFont(PCOMBOBOXEX pce)
{
    if (pce->hwndCombo)
        return (HFONT)SendMessage(pce->hwndCombo, WM_GETFONT, 0, 0);

    return NULL;
}

LRESULT CALLBACK ComboExWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;
    PCOMBOBOXEX pce = (PCOMBOBOXEX)GetWindowPtr(hwnd, 0);

    if (!pce) {
        if (uMsg != WM_NCCREATE &&
            uMsg != WM_CREATE)
            goto DoDefault;
    }

    switch (uMsg) {
        HANDLE_MSG(pce, WM_SETFONT, ComboEx_OnSetFont);

    case WM_ENABLE:
        if (pce->hwndCombo)
            EnableWindow(pce->hwndCombo, (BOOL) wParam);
        if (pce->hwndEdit)
            EnableWindow(pce->hwndEdit, (BOOL) wParam);
        break;

    case WM_WININICHANGE:
        InitGlobalMetrics(wParam);
        // only need to re-create this font if we created it in the first place
        // and somebody changed the font (or did a wildcard change)
        //
        // NOTE: Some people broadcast a nonclient metrics change when they
        //       change the icon title logfont, so watch for both.
        //
        if (pce && pce->fFontCreated &&
            ((wParam == 0 && lParam == 0) ||
             wParam == SPI_SETICONTITLELOGFONT ||
             wParam == SPI_SETNONCLIENTMETRICS))
        {
            ComboEx_OnSetFont(pce, NULL, TRUE);
        }
        break;

    case WM_SYSCOLORCHANGE:
        InitGlobalColors();
        break;

    case WM_NOTIFYFORMAT:
        return CIHandleNotifyFormat(&pce->ci, lParam);
        break;

    case WM_NCCREATE:
        // strip off the scroll bits
        SetWindowBits(hwnd, GWL_STYLE, WS_BORDER | WS_VSCROLL | WS_HSCROLL, 0);
        goto DoDefault;

    case WM_CREATE:
        CCCreateWindow();
        if (!ComboEx_OnCreate(hwnd, (LPCREATESTRUCT)lParam))
            lres = -1; // OnCreate falied. Fail WM_CREATE
        break;


    case WM_DESTROY:
        ASSERT(pce);
        CCDestroyWindow();
        ComboEx_OnDestroy(pce);
        break;

    case WM_WINDOWPOSCHANGING:
        ComboEx_OnWindowPosChanging(pce, (LPWINDOWPOS)lParam);
        break;

#if 0
    case WM_SIZE:
        ComboEx_OnSize(pce);
        break;
#endif

    case WM_DRAWITEM:
        ComboEx_OnDrawItem(pce, (LPDRAWITEMSTRUCT)lParam);
        break;

    case WM_MEASUREITEM:
        ComboEx_OnMeasureItem(pce, (LPMEASUREITEMSTRUCT)lParam);
        break;

    case WM_COMMAND:
        return ComboEx_HandleCommand(pce, wParam, lParam);

    case WM_GETFONT:
        return (LRESULT)ComboEx_GetFont(pce);

    case WM_SETFOCUS:
        if (pce->hwndCombo)
            SetFocus(pce->hwndCombo);
        break;

    case WM_DELETEITEM:
        ComboEx_HandleDeleteItem(pce, (LPDELETEITEMSTRUCT)lParam);
        return TRUE;

#ifdef KEYBOARDCUES
    case WM_UPDATEUISTATE:
        //not sure need to set bit, will probably not use it, on the other hand this
        //  is consistent with remaining of common controls and not very expensive
        CCOnUIState(&(pce->ci), WM_UPDATEUISTATE, wParam, lParam);

        goto DoDefault;
#endif
    // this is for backcompat only.
    case CBEM_SETEXSTYLE:
        return ComboEx_OnSetExStyle(pce, (DWORD)wParam, 0);
        
    case CBEM_SETEXTENDEDSTYLE:
        return ComboEx_OnSetExStyle(pce, (DWORD)lParam, (DWORD)wParam);

    case CBEM_GETEXTENDEDSTYLE:
        return pce->dwExStyle;

    case CBEM_GETCOMBOCONTROL:
        return (LRESULT)pce->hwndCombo;

    case CBEM_SETIMAGELIST:
        return (LRESULT)ComboEx_OnSetImageList(pce, (HIMAGELIST)lParam);

    case CBEM_GETIMAGELIST:
        return (LRESULT)pce->himl;

#ifdef UNICODE
    case CBEM_GETITEMA:
        return ComboEx_OnGetItemA(pce, (PCOMBOBOXEXITEMA)lParam);
#endif

    case CBEM_GETITEM:
        return ComboEx_OnGetItem(pce, (PCOMBOBOXEXITEM)lParam);

#ifdef UNICODE
    case CBEM_SETITEMA: {
            LRESULT lResult;
            LPWSTR lpStrings;
            UINT   uiCount;
            LPSTR  lpAnsiString = (LPSTR) ((PCOMBOBOXEXITEM)lParam)->pszText;

           if ((((PCOMBOBOXEXITEM)lParam)->mask & CBEIF_TEXT) &&
               (((PCOMBOBOXEXITEM)lParam)->pszText != LPSTR_TEXTCALLBACK)) {

                uiCount = lstrlenA(lpAnsiString)+1;
                lpStrings = LocalAlloc(LPTR, (uiCount) * sizeof(TCHAR));

                if (!lpStrings)
                    return -1;

                MultiByteToWideChar(CP_ACP, 0, (LPCSTR) lpAnsiString, uiCount,
                                   lpStrings, uiCount);

                ((PCOMBOBOXEXITEMA)lParam)->pszText = (LPSTR)lpStrings;
                lResult = ComboEx_OnSetItem(pce, (PCOMBOBOXEXITEM)lParam);
                ((PCOMBOBOXEXITEMA)lParam)->pszText = lpAnsiString;
                LocalFree(lpStrings);

                return lResult;
            } else {
                return ComboEx_OnSetItem(pce, (PCOMBOBOXEXITEM)lParam);
            }
        }
#endif
    case CBEM_SETITEM:
        return ComboEx_OnSetItem(pce, (PCOMBOBOXEXITEM)lParam);

#ifdef UNICODE
    case CBEM_INSERTITEMA: {
            LRESULT lResult;
            LPWSTR lpStrings;
            UINT   uiCount;
            LPSTR  lpAnsiString = (LPSTR) ((PCOMBOBOXEXITEM)lParam)->pszText;

            if (!lpAnsiString || lpAnsiString == (LPSTR)LPSTR_TEXTCALLBACK)
                return ComboEx_OnInsertItem(pce, (PCOMBOBOXEXITEM)lParam);

            uiCount = lstrlenA(lpAnsiString)+1;
            lpStrings = LocalAlloc(LPTR, (uiCount) * sizeof(TCHAR));

            if (!lpStrings)
                return -1;

            MultiByteToWideChar(CP_ACP, 0, (LPCSTR) lpAnsiString, uiCount,
                               lpStrings, uiCount);

            ((PCOMBOBOXEXITEMA)lParam)->pszText = (LPSTR)lpStrings;
            lResult = ComboEx_OnInsertItem(pce, (PCOMBOBOXEXITEM)lParam);
            ((PCOMBOBOXEXITEMA)lParam)->pszText = lpAnsiString;
            LocalFree(lpStrings);

            return lResult;
        }
#endif

    case CBEM_INSERTITEM:
        return ComboEx_OnInsertItem(pce, (PCOMBOBOXEXITEM)lParam);



    case CBEM_GETEDITCONTROL:
        return (LRESULT)pce->hwndEdit;

    case CBEM_HASEDITCHANGED:
        return pce->fEditChanged;

    case CB_GETITEMDATA:
        return ComboEx_OnGetItemData(pce, (int)wParam);

    case CB_SETITEMDATA:
        return ComboEx_OnSetItemData(pce, (int)wParam, lParam);

    case CB_LIMITTEXT:
        if (ComboEx_GetEditBox(pce))
            Edit_LimitText(pce->hwndEdit, wParam);
        break;

    case CB_FINDSTRINGEXACT:
    {
        LPCTSTR psz = (LPCTSTR)lParam;
#ifdef UNICODE_WIN9x
        TCHAR szText[CBEMAXSTRLEN];
        if (!pce->ci.bUnicode) {
            MultiByteToWideChar(pce->ci.uiCodePage, 0, (LPCSTR)lParam, -1, szText, ARRAYSIZE(szText));
            psz = szText;
        }
#endif
        return ComboEx_OnFindStringExact(pce, (int)wParam, psz);
    }

    case CB_SETITEMHEIGHT:
        lres = SendMessage(pce->hwndCombo, uMsg, wParam, lParam);
        if (wParam == (WPARAM)-1) {
            RECT rcWindow, rcClient;
            int cy;

            GetWindowRect(pce->hwndCombo, &rcWindow);
            cy = RECTHEIGHT(rcWindow);

            GetWindowRect(pce->ci.hwnd, &rcWindow);
            GetClientRect(pce->ci.hwnd, &rcClient);

            cy = cy + (RECTHEIGHT(rcWindow) - RECTHEIGHT(rcClient));

            SetWindowPos(pce->ci.hwnd, NULL, 0, 0,
                         RECTWIDTH(rcWindow),
                         cy,
                         SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER);
        }
        break;

    case CB_INSERTSTRING:
    case CB_ADDSTRING:
    case CB_SETEDITSEL:
    case CB_FINDSTRING:
    case CB_DIR:
        // override to do nothing
        break;

    case CB_SETCURSEL:
    case CB_RESETCONTENT:
    case CB_DELETESTRING:
        lres = SendMessage(pce->hwndCombo, uMsg, wParam, lParam);
        ComboEx_UpdateEditText(pce, uMsg == CB_SETCURSEL);
        break;

    case WM_SETTEXT:
        if (!pce->hwndEdit)
            return(CB_ERR);
        
#ifdef UNICODE_WIN9x
        // these wm_* messages are always TCHAR
        lres = SendMessageA(pce->hwndEdit, uMsg, wParam, lParam);
#else
        lres = SendMessage(pce->hwndEdit, uMsg, wParam, lParam);
#endif
        EDIT_SELECTALL( pce->hwndEdit );
        RedrawWindow(pce->hwndCombo, NULL, NULL, RDW_ERASE | RDW_INVALIDATE);
        return(lres);

    case WM_CUT:
    case WM_COPY:
    case WM_PASTE:
    case WM_GETTEXT:
    case WM_GETTEXTLENGTH:
        if (!pce->hwndEdit)
            return 0;
#ifdef UNICODE_WIN9x
        // these wm_* messages are always TCHAR
        return(SendMessageA(pce->hwndEdit, uMsg, wParam, lParam));
#else
        return(SendMessage(pce->hwndEdit, uMsg, wParam, lParam));
#endif

    case WM_SETREDRAW:
        if (pce->hwndEdit)
            SendMessage(pce->hwndEdit, uMsg, wParam, lParam);
        break;

    case CB_GETEDITSEL:
        if (pce->hwndEdit)
            return SendMessage(pce->hwndEdit, EM_GETSEL, wParam, lParam);
        // else fall through

    // Handle it being in a dialog...
    // BUGBUG:: May want to handle it differently when edit control has
    // focus...
    case WM_GETDLGCODE:
    case CB_SHOWDROPDOWN:
    case CB_SETEXTENDEDUI:
    case CB_GETEXTENDEDUI:
    case CB_GETDROPPEDSTATE:
    case CB_GETDROPPEDCONTROLRECT:
    case CB_GETCURSEL:
    case CB_GETCOUNT:
    case CB_SELECTSTRING:
    case CB_GETITEMHEIGHT:
    case CB_SETDROPPEDWIDTH:
        return SendMessage(pce->hwndCombo, uMsg, wParam, lParam);

    case CB_GETLBTEXT:
    case CB_GETLBTEXTLEN:
        return ComboEx_GetLBText(pce, uMsg, wParam, lParam);

    default:
        if (CCWndProc(&pce->ci, uMsg, wParam, lParam, &lres))
            return lres;

DoDefault:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return lres;
}


BOOL InitComboExClass(HINSTANCE hinst)
{
    WNDCLASS wc;

    if (!GetClassInfo(hinst, c_szComboBoxEx, &wc)) {
        wc.lpfnWndProc     = ComboExWndProc;
        wc.hCursor         = LoadCursor(NULL, IDC_ARROW);
        wc.hIcon           = NULL;
        wc.lpszMenuName    = NULL;
        wc.hInstance       = hinst;
        wc.lpszClassName   = c_szComboBoxEx;
        wc.hbrBackground   = (HBRUSH)(COLOR_WINDOW + 1); // NULL;
        wc.style           = CS_GLOBALCLASS;
        wc.cbWndExtra      = sizeof(PCOMBOBOXEX);
        wc.cbClsExtra      = 0;

        return RegisterClass(&wc);
    }
    return TRUE;

}

//---------------------------------------------------------------------------
// SetPathWordBreakProc does special break processing for edit controls.
//
// The word break proc is called when ctrl-(left or right) arrow is pressed in the
// edit control.  Normal processing provided by USER breaks words at spaces or tabs,
// but for us it would be nice to break words at slashes, backslashes, & periods too
// since it may be common to have paths or url's typed in.
void WINAPI SetPathWordBreakProc(HWND hwndEdit, BOOL fSet)
{
#ifndef WINNT
    // There is a bug with how USER handles WH_CALLWNDPROC global hooks in Win95 that
    // causes us to blow up if one is installed and a wordbreakproc is set.  Thus,
    // if an app is running that has one of these hooks installed (intellipoint 1.1 etc.) then
    // if we install our wordbreakproc the app will fault when the proc is called.  There
    // does not appear to be any way for us to work around it since USER's thunking code
    // trashes the stack so this API is disabled for Win95.
    return;
#else
    FARPROC lpfnOld;
    // Don't shaft folks who set their own break proc - leave it alone.
    lpfnOld = (FARPROC)SendMessage(hwndEdit, EM_GETWORDBREAKPROC, 0, 0L);

    if (fSet) {
        if (!lpfnOld)
            SendMessage(hwndEdit, EM_SETWORDBREAKPROC, 0, (LPARAM)ShellEditWordBreakProc);
    } else {
        if (lpfnOld == (FARPROC)ShellEditWordBreakProc)
            SendMessage(hwndEdit, EM_SETWORDBREAKPROC, 0, 0L);
    }
#endif
}

#ifdef WINNT
BOOL IsDelimiter(TCHAR ch)
{
    return (ch == TEXT(' ')  ||
            ch == TEXT('\t') ||
            ch == TEXT('.')  ||
            ch == TEXT('/')  ||
            ch == TEXT('\\'));
}

int WINAPI ShellEditWordBreakProc(LPTSTR lpch, int ichCurrent, int cch, int code)
{
    LPTSTR lpchT = lpch + ichCurrent;
    int iIndex;
    BOOL fFoundNonDelimiter = FALSE;
    static BOOL fRight = FALSE;  // hack due to bug in USER

    switch (code) {
        case WB_ISDELIMITER:
            fRight = TRUE;
            // Simple case - is the current character a delimiter?
            iIndex = (int)IsDelimiter(*lpchT);
            break;

        case WB_LEFT:
            // Move to the left to find the first delimiter.  If we are
            // currently at a delimiter, then skip delimiters until we
            // find the first non-delimiter, then start from there.
            //
            // Special case for fRight - if we are currently at a delimiter
            // then just return the current word!
            while ((lpchT = CharPrev(lpch, lpchT)) != lpch) {
                if (IsDelimiter(*lpchT)) {
                    if (fRight || fFoundNonDelimiter)
                        break;
                } else {
                    fFoundNonDelimiter = TRUE;
                    fRight = FALSE;
                }
            }
            iIndex = (int) (lpchT - lpch);

            // We are currently pointing at the delimiter, next character
            // is the beginning of the next word.
            if (iIndex > 0 && iIndex < cch)
                iIndex++;

            break;

        case WB_RIGHT:
            fRight = FALSE;

            // If we are not at a delimiter, then skip to the right until
            // we find the first delimiter.  If we started at a delimiter, or
            // we have just finished scanning to the first delimiter, then
            // skip all delimiters until we find the first non delimiter.
            //
            // Careful - the string passed in to us may not be NULL terminated!
            fFoundNonDelimiter = !IsDelimiter(*lpchT);
            if (lpchT != (lpch + cch)) {
                while ((lpchT = FastCharNext(lpchT)) != (lpch + cch)) {
                    if (IsDelimiter(*lpchT)) {
                        fFoundNonDelimiter = FALSE;
                    } else {
                        if (!fFoundNonDelimiter)
                            break;
                    }
                }
            }
            // We are currently pointing at the next word.
            iIndex = (int) (lpchT - lpch);
            break;
    }

    return iIndex;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\commctrl.c ===
/***************************************************************************
 *  msctls.c
 *
 *      Utils library initialization code
 *
 ***************************************************************************/

#include "ctlspriv.h"

HINSTANCE g_hinst = 0;

#ifndef UNIX
CRITICAL_SECTION g_csDll = {{0},0, 0, NULL, NULL, 0 };
#else
/* IEUNIX:  MainWin uses DllMain as an entry point (Ref: mwdip) */
#define LibMain    DllMain
#include "mwversion.h"
#if defined(MW_STRUCTINIT_SUPPORTED)
CRITICAL_SECTION g_csDll = {{0},0, 0, NULL, NULL, 0 };
#else
CRITICAL_SECTION g_csDll;
#endif
#endif /* UNIX */

ATOM g_aCC32Subclass = 0;

#ifdef WINNT
BOOL g_bRunOnNT5 = FALSE;
BOOL g_bRemoteSession = FALSE;
#else
BOOL g_bRunOnMemphis = FALSE;
BOOL g_bRunOnBiDiWin95Loc = FALSE;
int g_cProcesses = 0;
#endif

UINT g_uiACP = CP_ACP;

// Is Mirroring enabled
BOOL g_bMirroredOS = FALSE;


#define PAGER //For Test Purposes

//
// Global DCs used during mirroring an Icon.
//
HDC g_hdc=NULL, g_hdcMask=NULL;

// per process mem to store PlugUI information
#ifdef WINNT
LANGID g_PUILangId = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
#else
HDPA g_hdpaPUI = NULL;
void InitPUI();
void DeInitPUI(int cProcesses);
#endif

BOOL PASCAL InitAnimateClass(HINSTANCE hInstance);
BOOL ListView_Init(HINSTANCE hinst);
BOOL TV_Init(HINSTANCE hinst);
BOOL InitComboExClass(HINSTANCE hinst);
BOOL PASCAL Header_Init(HINSTANCE hinst);
BOOL PASCAL Tab_Init(HINSTANCE hinst);
int InitIPAddr(HANDLE hInstance);

#if !defined(WINNT) && defined(FONT_LINK)
void InitMLANG();
void DeinitMLANG(int cProcesses);
#endif

#ifdef PAGER
BOOL InitPager(HINSTANCE hinst);
#endif
BOOL InitNativeFontCtl(HINSTANCE hinst);
void UnregisterClasses();
void Mem_Terminate();

#define DECLARE_DELAYED_FUNC(_ret, _fn, _args, _nargs) \
_ret (__stdcall * g_pfn##_fn) _args = NULL; \
_ret __stdcall _fn _args                \
{                                       \
     if (!g_pfn##_fn) {                  \
        AssertMsg(g_pfn##_fn != NULL, TEXT("GetProcAddress failed")); \
        return 0; \
     }     \
     return g_pfn##_fn _nargs; \
}
    
#define LOAD_DELAYED_FUNC(_ret, _fn, _args) \
    (*(FARPROC*)&(g_pfn##_fn) = GetProcAddress(hinst, #_fn))


DECLARE_DELAYED_FUNC(BOOL, ImmNotifyIME, (HIMC himc, DWORD dw1, DWORD dw2, DWORD dw3), (himc, dw1, dw2, dw3));
DECLARE_DELAYED_FUNC(HIMC, ImmAssociateContext, (HWND hwnd, HIMC himc), (hwnd, himc));
DECLARE_DELAYED_FUNC(BOOL, ImmReleaseContext, (HWND hwnd, HIMC himc), (hwnd, himc));
DECLARE_DELAYED_FUNC(HIMC, ImmGetContext, (HWND hwnd), (hwnd));
DECLARE_DELAYED_FUNC(LONG, ImmGetCompositionStringA, (HIMC himc, DWORD dw1, LPVOID p1, DWORD dw2), (himc, dw1, p1, dw2) );
DECLARE_DELAYED_FUNC(BOOL, ImmSetCompositionStringA, (HIMC himc, DWORD dw1, LPCVOID p1, DWORD dw2, LPCVOID p2, DWORD dw3), (himc, dw1, p1, dw2, p2, dw3));
#ifndef UNICODE_WIN9x
DECLARE_DELAYED_FUNC(LONG, ImmGetCompositionStringW, (HIMC himc, DWORD dw1, LPVOID p1, DWORD dw2), (himc, dw1, p1, dw2) );
DECLARE_DELAYED_FUNC(BOOL, ImmSetCompositionStringW, (HIMC himc, DWORD dw1, LPCVOID p1, DWORD dw2, LPCVOID p2, DWORD dw3), (himc, dw1, p1, dw2, p2, dw3));
#endif
DECLARE_DELAYED_FUNC(BOOL, ImmSetCandidateWindow, (HIMC himc, LPCANDIDATEFORM pcf), (himc, pcf));
DECLARE_DELAYED_FUNC(HIMC, ImmCreateContext, (void), ());
DECLARE_DELAYED_FUNC(BOOL, ImmDestroyContext, (HIMC himc), (himc));
    

BOOL g_fDBCSEnabled = FALSE;
BOOL g_fMEEnabled = FALSE;
BOOL g_fDBCSInputEnabled = FALSE;
#ifdef FONT_LINK
BOOL g_bComplexPlatform = FALSE;
#endif

#if defined(FE_IME) || !defined(WINNT)
void InitIme()
{
    g_fMEEnabled = GetSystemMetrics(SM_MIDEASTENABLED);
    
    g_fDBCSEnabled = g_fDBCSInputEnabled = GetSystemMetrics(SM_DBCSENABLED);

    if (!g_fDBCSInputEnabled && g_bRunOnNT5)
        g_fDBCSInputEnabled =  GetSystemMetrics(SM_IMMENABLED);
    
    // We load imm32.dll per process, but initialize proc pointers just once.
    // this is to solve two different problems.
    // 1) Debugging process on win95 would get our shared table trashed
    //    if we rewrite proc address each time we get loaded.
    // 2) Some lotus application rely upon us to load imm32. They do not
    //    load/link to imm yet they use imm(!)
    //
    if (g_fDBCSInputEnabled) {
        HANDLE hinst = LoadLibrary(TEXT("imm32.dll"));
        if (! g_pfnImmSetCandidateWindow && 
           (! hinst || 
            ! LOAD_DELAYED_FUNC(HIMC, ImmCreateContext, (void)) ||
            ! LOAD_DELAYED_FUNC(HIMC, ImmDestroyContext, (HIMC)) ||
            ! LOAD_DELAYED_FUNC(BOOL, ImmNotifyIME, (HIMC, DWORD, DWORD, DWORD)) ||
            ! LOAD_DELAYED_FUNC(HIMC, ImmAssociateContext, (HWND, HIMC)) ||
            ! LOAD_DELAYED_FUNC(BOOL, ImmReleaseContext, (HWND, HIMC)) ||
            ! LOAD_DELAYED_FUNC(HIMC, ImmGetContext, (HWND)) ||
            ! LOAD_DELAYED_FUNC(LONG, ImmGetCompositionStringA, (HIMC, DWORD, LPVOID, DWORD)) ||
            ! LOAD_DELAYED_FUNC(BOOL, ImmSetCompositionStringA, (HIMC, DWORD, LPCVOID, DWORD, LPCVOID, DWORD)) ||
#ifndef UNICODE_WIN9x
            ! LOAD_DELAYED_FUNC(LONG, ImmGetCompositionStringW, (HIMC, DWORD, LPVOID, DWORD)) ||
            ! LOAD_DELAYED_FUNC(BOOL, ImmSetCompositionStringW, (HIMC, DWORD, LPCVOID, DWORD, LPCVOID, DWORD)) ||
#endif
            ! LOAD_DELAYED_FUNC(BOOL, ImmSetCandidateWindow, (HIMC, LPCANDIDATEFORM)))) {

            // if we were unable to load then bail on using IME.
            g_fDBCSEnabled = FALSE;
            g_fDBCSInputEnabled = FALSE;

        }
    }
}
#else
#define InitIme() 0
#endif


#ifdef DEBUG

// Verify that the localizers didn't accidentally change
// DLG_PROPSHEET from a DIALOG to a DIALOGEX.  _RealPropertySheet
// relies on this (as well as any apps which parse the dialog template
// in their PSCB_PRECREATE handler).

BOOL IsSimpleDialog(LPCTSTR ptszDialog)
{
    HRSRC hrsrc;
    LPDLGTEMPLATE pdlg;
    BOOL fSimple = FALSE;

    if ( (hrsrc = FindResource(HINST_THISDLL, ptszDialog, RT_DIALOG)) &&
         (pdlg = LoadResource(HINST_THISDLL, hrsrc)))
    {
        fSimple = HIWORD(pdlg->style) != 0xFFFF;
    }
    return fSimple;
}

//
//  For sublanguages to work, every language in our resources must contain
//  a SUBLANG_NEUTRAL variation so that (for example) Austria gets
//  German dialog boxes instead of English ones.
//
//  The DPA is really a DSA of WORDs, but DPA's are easier to deal with.
//  We just collect all the languages into the DPA, and study them afterwards.
//
BOOL CALLBACK CheckLangProc(HINSTANCE hinst, LPCTSTR lpszType, LPCTSTR lpszName, WORD wIdLang, LPARAM lparam)
{
    HDPA hdpa = (HDPA)lparam;
    DPA_AppendPtr(hdpa, (LPVOID)(UINT_PTR)wIdLang);
    return TRUE;
}

void CheckResourceLanguages(void)
{
    HDPA hdpa = DPA_Create(8);
    if (hdpa) {
        int i, j;
        EnumResourceLanguages(HINST_THISDLL, RT_DIALOG,
                              MAKEINTRESOURCE(DLG_PROPSHEET), CheckLangProc,
                              (LPARAM)hdpa);

        // Walk the language list.  For each language we find, make sure
        // there is a SUBLANG_NEUTRAL version of it somewhere else
        // in the list.  We use an O(n^2) algorithm because this is debug
        // only code and happens only at DLL load.

        for (i = 0; i < DPA_GetPtrCount(hdpa); i++) {
            UINT_PTR uLangI = (UINT_PTR)DPA_FastGetPtr(hdpa, i);
            BOOL fFound = FALSE;

            //
            //  It is okay to have English (American) with no
            //  English (Neutral) because Kernel32 uses English (American)
            //  as its fallback, so we fall back to the correct language
            //  after all.
            //
            if (uLangI == MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US))
                continue;

            //
            //  If this language is already the Neutral one, then there's
            //  no point looking for it - here it is!
            //
            if (SUBLANGID(uLangI) == SUBLANG_NEUTRAL)
                continue;

            //
            //  Otherwise, this language is a dialect.  See if there is
            //  a Neutral version elsewhere in the table.
            //
            for (j = 0; j < DPA_GetPtrCount(hdpa); j++) {
                UINT_PTR uLangJ = (UINT_PTR)DPA_FastGetPtr(hdpa, j);
                if (PRIMARYLANGID(uLangI) == PRIMARYLANGID(uLangJ) &&
                    SUBLANGID(uLangJ) == SUBLANG_NEUTRAL) {
                    fFound = TRUE; break;
                }
            }

            //
            //  If this assertion fires, it means that the localization team
            //  added support for a new language but chose to specify the
            //  language as a dialect instead of the Neutral version.  E.g.,
            //  specifying Romanian (Romanian) instead of Romanian (Neutral).
            //  This means that people who live in Moldavia will see English
            //  strings, even though Romanian (Romanian) would almost
            //  certainly have been acceptable.
            //
            //  If you want to support multiple dialects of a language
            //  (e.g., Chinese), you should nominate one of the dialects
            //  as the Neutral one.  For example, we currently support
            //  both Chinese (PRC) and Chinese (Taiwan), but the Taiwanese
            //  version is marked as Chinese (Neutral), so people who live in
            //  Singapore get Chinese instead of English.  Sure, it's
            //  Taiwanese Chinese, but at least it's Chinese.
            //
            AssertMsg(fFound, TEXT("Localization bug: No SUBLANG_NEUTRAL for language %04x"), uLangI);
        }

        DPA_Destroy(hdpa);
    }
}

#endif

int _ProcessAttach(HANDLE hInstance)
{
    INITCOMMONCONTROLSEX icce;

    g_hinst = hInstance;

    g_uiACP = GetACP();

#if defined(MAINWIN)
    MwSet3dLook(TRUE);
#endif

#ifdef DEBUG
    CcshellGetDebugFlags();

    g_dwBreakFlags = 0;    // We do not want to break in comctl32 version 5 at ALL. Too many bad callers.
#endif


#ifdef WINNT
    InitializeCriticalSection(&g_csDll);

    g_bRunOnNT5 = staticIsOS(OS_WIN2000ORGREATER);
#ifdef FONT_LINK
    g_bComplexPlatform =  BOOLFROMPTR(GetModuleHandle(TEXT("LPK.DLL")));
#endif
#else
    ReinitializeCriticalSection(&g_csDll);

#ifdef FONT_LINK
    g_bComplexPlatform = ((g_uiACP == CP_ARABIC) || (g_uiACP == CP_HEBREW) || (g_uiACP == CP_THAI));
#endif
    g_bRunOnMemphis = staticIsOS(OS_WIN98ORGREATER);
    g_bRunOnBiDiWin95Loc = IsBiDiLocalizedWin95(FALSE);

    g_cProcesses++;
    {
        // HACK: we are intentionally incrementing the refcount on this atom
        // WE DO NOT WANT IT TO GO BACK DOWN so we will not delete it in process
        // detach (see comments for g_aCC32Subclass in subclass.c for more info)

        // on Win95 doe this as early as possible to avoid getting
        // a trashed atom. 

        ATOM a = GlobalAddAtom(c_szCC32Subclass);
        if (a != 0)
            g_aCC32Subclass = a;    // in case the old atom got nuked
    }
#endif

    //
    // Check if the mirroring APIs exist on the current
    // platform.
    //
    g_bMirroredOS = IS_MIRRORING_ENABLED();

#ifdef WINNT
    //
    //  Must detect Terminal Server before initializing global metrics
    //  because we need to force some features off if running Terminal Server.
    //
    {
        typedef BOOL (__stdcall * PFNPROCESSIDTOSESSIONID)(DWORD, PDWORD);
        PFNPROCESSIDTOSESSIONID ProcessIdToSessionId =
                    (PFNPROCESSIDTOSESSIONID)
                    GetProcAddress(GetModuleHandle(TEXT("KERNEL32")),
                                   "ProcessIdToSessionId");
        DWORD dwSessionId;
        g_bRemoteSession = ProcessIdToSessionId &&
                           ProcessIdToSessionId(GetCurrentProcessId(), &dwSessionId) &&
                           dwSessionId != 0;
    }
#endif

    InitGlobalMetrics(0);
    InitGlobalColors();
    
    InitIme();

#ifndef WINNT
#ifdef FONT_LINK
    InitMLANG();
#endif
    InitPUI();
#endif

#ifdef DEBUG
    ASSERT(IsSimpleDialog(MAKEINTRESOURCE(DLG_WIZARD)));
    ASSERT(IsSimpleDialog(MAKEINTRESOURCE(DLG_PROPSHEET)));
    CheckResourceLanguages();
#endif

    // BUGBUG: only do this for GetProcessVersion apps <= 0x40000
    // Newer apps MUST use InitCommonControlsEx.
    icce.dwSize = sizeof(icce);
    icce.dwICC = ICC_ALL_CLASSES;


    return InitCommonControlsEx(&icce);
}



void _ProcessDetach(HANDLE hInstance)
{
    //
    // Cleanup cached DCs. No need to synchronize the following section of
    // code since it is only called in DLL_PROCESS_DETACH which is 
    // synchronized by the OS Loader.
    //
#ifdef WINNT
    if (g_hdc)
        DeleteDC(g_hdc);

    if (g_hdcMask)
        DeleteDC(g_hdcMask);

    g_hdc = g_hdcMask = NULL;
#endif

#ifdef WINNT
    UnregisterClasses();
    DeleteCriticalSection(&g_csDll);
#else
    ENTERCRITICAL;
#ifdef FONT_LINK
    DeinitMLANG(g_cProcesses);
#endif
    DeInitPUI(g_cProcesses);
    if (--g_cProcesses == 0) 
    {
        if (g_hdc)
            DeleteDC(g_hdc);

       if (g_hdcMask)
            DeleteDC(g_hdcMask);

        g_hdc = g_hdcMask = NULL;
        
        Mem_Terminate();    // shared heap cleanup... all calls after this will die!
    }
    LEAVECRITICAL;
#endif
}


STDAPI_(BOOL) LibMain(HANDLE hDll, DWORD dwReason, LPVOID pv)
{
#ifndef WINNT
    STDAPI_(BOOL) Cctl1632_ThunkConnect32(LPCSTR pszDll16,LPCSTR pszDll32,HANDLE hIinst,DWORD dwReason);

    if (!Cctl1632_ThunkConnect32("commctrl.dll", "comctl32.dll", hDll, dwReason))
        return FALSE;
#endif

    switch(dwReason) {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hDll);
        return _ProcessAttach(hDll);

    case DLL_PROCESS_DETACH:
        _ProcessDetach(hDll);
        break;

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    default:
        break;

    } // end switch()

    return TRUE;

} // end DllEntryPoint()


/* Stub function to call if all you want to do is make sure this DLL is loaded
 */
void WINAPI InitCommonControls(void)
{
}

#ifdef WINNT
BOOL InitForWinlogon(HINSTANCE hInstance)
{
    //  Some people like to use comctl32 from inside winlogon, and
    //  for C2 security reasons, all global atoms are nuked from the
    //  window station when you log off.
    //
    //  So the rule is that all winlogon clients of comctl32 must
    //  call InitCommonControlsEx(ICC_WINLOGON_REINIT) immediately
    //  before doing any common control things (creating windows
    //  or property sheets/wizards) from winlogon.

    ATOM a = GlobalAddAtom(c_szCC32Subclass);
    if (a)
        g_aCC32Subclass = a;

    InitGlobalMetrics(0);
    InitGlobalColors();

    return TRUE;
}
#endif

/* InitCommonControlsEx creates the classes. Only those classes requested are created!
** The process attach figures out if it's an old app and supplies ICC_WIN95_CLASSES.
*/
typedef BOOL (PASCAL *PFNINIT)(HINSTANCE);
typedef struct {
    PFNINIT pfnInit;
#ifdef WINNT
    LPCTSTR pszName;
#endif
    DWORD dw;
} INITCOMMONCONTROLSINFO;

#ifdef WINNT
#define MAKEICC(pfnInit, pszClass, dwFlags) { pfnInit, pszClass, dwFlags }
#else
#define MAKEICC(pfnInit, pszClass, dwFlags) { pfnInit,           dwFlags }
#endif

const INITCOMMONCONTROLSINFO icc[] =
{
     // Init function      Class name         Requested class sets which use this class
MAKEICC(InitToolbarClass,  TOOLBARCLASSNAME,  ICC_BAR_CLASSES),
MAKEICC(InitReBarClass,    REBARCLASSNAME,    ICC_COOL_CLASSES),
MAKEICC(InitToolTipsClass, TOOLTIPS_CLASS,    ICC_TREEVIEW_CLASSES|ICC_BAR_CLASSES|ICC_TAB_CLASSES),
MAKEICC(InitStatusClass,   STATUSCLASSNAME,   ICC_BAR_CLASSES),
MAKEICC(ListView_Init,     WC_LISTVIEW,       ICC_LISTVIEW_CLASSES),
MAKEICC(Header_Init,       WC_HEADER,         ICC_LISTVIEW_CLASSES),
MAKEICC(Tab_Init,          WC_TABCONTROL,     ICC_TAB_CLASSES),
MAKEICC(TV_Init,           WC_TREEVIEW,       ICC_TREEVIEW_CLASSES),
MAKEICC(InitTrackBar,      TRACKBAR_CLASS,    ICC_BAR_CLASSES),
MAKEICC(InitUpDownClass,   UPDOWN_CLASS,      ICC_UPDOWN_CLASS),
MAKEICC(InitProgressClass, PROGRESS_CLASS,    ICC_PROGRESS_CLASS),
MAKEICC(InitHotKeyClass,   HOTKEY_CLASS,      ICC_HOTKEY_CLASS),
MAKEICC(InitAnimateClass,  ANIMATE_CLASS,     ICC_ANIMATE_CLASS),
MAKEICC(InitDateClasses,   DATETIMEPICK_CLASS,ICC_DATE_CLASSES),
MAKEICC(InitComboExClass,  WC_COMBOBOXEX,     ICC_USEREX_CLASSES),
MAKEICC(InitIPAddr,        WC_IPADDRESS,      ICC_INTERNET_CLASSES),
#ifdef PAGER
MAKEICC(InitPager,         WC_PAGESCROLLER,   ICC_PAGESCROLLER_CLASS),
#endif
MAKEICC(InitNativeFontCtl, WC_NATIVEFONTCTL,  ICC_NATIVEFNTCTL_CLASS),

//
//  These aren't really classes.  They're just goofy flags.
//
#ifdef WINNT
MAKEICC(InitForWinlogon,   NULL,              ICC_WINLOGON_REINIT),
#endif
};

BOOL WINAPI InitCommonControlsEx(LPINITCOMMONCONTROLSEX picce)
{
    int i;

#ifdef UNIX
    if (MwIsInitLite())
        return (TRUE);
#endif

    if (!picce ||
        (picce->dwSize != sizeof(INITCOMMONCONTROLSEX)) ||
        (picce->dwICC & ~ICC_ALL_VALID))
    {
        DebugMsg(DM_WARNING, TEXT("comctl32 - picce is bad"));
        return(FALSE);
    }

    for (i=0 ; i < ARRAYSIZE(icc) ; i++)
        if (picce->dwICC & icc[i].dw)
            if (!icc[i].pfnInit(HINST_THISDLL))
                return(FALSE);

    return(TRUE);
}
//
// InitMUILanguage / GetMUILanguage implementation
//
// we have a per process PUI language setting. For NT it's just a global
// initialized with LANG_NEUTRAL and SUBLANG_NEUTRAL
// For Win95 it's DPA slot for the current process.
// InitMUILanguage sets callers preferred language id for common control
// GetMUILangauge returns what the caller has set to us 
// 
#ifdef WINNT
LANGID PUIGetLangId(void)
{
    return g_PUILangId;
}
#else // WIN95
typedef struct tagPUIPROCSLOT
{
    DWORD dwPID;
    LANGID wLangId;
} PUIPROCSLOT, *PPUIPROCSLOT;

PPUIPROCSLOT PUICreateProcSlot(void)
{
    PPUIPROCSLOT pSlot = (PPUIPROCSLOT)Alloc(sizeof(PUIPROCSLOT));

    if (pSlot)
    {
        pSlot->dwPID  = GetCurrentProcessId();
        pSlot->wLangId = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
    }
    return pSlot;
}

int PUIGetProcIdx(DWORD dwProcessId)
{
    int i, cSlot = 0;

    ASSERTCRITICAL;

    if (g_hdpaPUI)
        cSlot = DPA_GetPtrCount(g_hdpaPUI);

    for (i = 0; i < cSlot; i++)
    {
        PPUIPROCSLOT pSlot = (PPUIPROCSLOT)DPA_FastGetPtr(g_hdpaPUI, i);

        if (pSlot && pSlot->dwPID == dwProcessId)
            return i;
    }
    return -1;
}

void InitPUI(void)
{
    if (NULL == g_hdpaPUI)
    {
        ENTERCRITICAL;
        if (NULL == g_hdpaPUI)
            g_hdpaPUI= DPA_Create(4);
        LEAVECRITICAL;
    }
}

void DeInitPUI(int cProcesses)
{
    int i = PUIGetProcIdx(GetCurrentProcessId());

    ASSERTCRITICAL;

    if (0 <= i)
    {
        Free((PPUIPROCSLOT)DPA_FastGetPtr(g_hdpaPUI, i));
        DPA_DeletePtr(g_hdpaPUI, i);
    }

    if (g_hdpaPUI&& 1 == cProcesses) // This is last process detach
    {
        DPA_Destroy(g_hdpaPUI);
        g_hdpaPUI= NULL;
    }
}

PPUIPROCSLOT PUIGetProcSlot(void)
{
    PPUIPROCSLOT pSlot = NULL;
    int i;

    ENTERCRITICAL;
    i = PUIGetProcIdx(GetCurrentProcessId());

    if (0 <= i)
    {
        pSlot = (PPUIPROCSLOT)DPA_FastGetPtr(g_hdpaPUI, i);
    }
    else
    {
        pSlot = PUICreateProcSlot();
        if (pSlot)
            DPA_AppendPtr(g_hdpaPUI, pSlot);
    }

    LEAVECRITICAL;

    return pSlot;
}

LANGID PUIGetLangId(void)
{
    PPUIPROCSLOT pSlot = PUIGetProcSlot();
    LANGID wLang;
    if (pSlot)
        wLang = pSlot->wLangId;
    else
        wLang = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);

    return wLang;
}
#endif // !WINNT

void WINAPI
InitMUILanguage(LANGID wLang)
{
#ifdef WINNT
    ENTERCRITICAL;
    g_PUILangId = wLang;
    LEAVECRITICAL;
#else
    PPUIPROCSLOT pSlot = PUIGetProcSlot();
    if(pSlot)
        pSlot->wLangId = wLang;
#endif
}
LANGID WINAPI
GetMUILanguage(void)
{
#ifdef WINNT
    return g_PUILangId;
#else
    return PUIGetLangId();
#endif
}
// end MUI functions

#ifdef WINNT
//
//  Unlike Win9x, WinNT does not automatically unregister classes
//  when a DLL unloads.  We have to do it manually.  Leaving the
//  class lying around means that if an app loads our DLL, then
//  unloads it, then reloads it at a different address, all our
//  leftover RegisterClass()es will point the WndProc at the wrong
//  place and we fault at the next CreateWindow().
//
//  This is not purely theoretical - NT4/FE hit this bug.
//
void UnregisterClasses()
{
    WNDCLASS wc;
    int i;

    for (i=0 ; i < ARRAYSIZE(icc) ; i++)
    {
        if (icc[i].pszName &&
            GetClassInfo(HINST_THISDLL, icc[i].pszName, &wc))
        {
            UnregisterClass(icc[i].pszName, HINST_THISDLL);
        }
    }
}
#endif

#if defined(DEBUG)
LRESULT WINAPI SendMessageD(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
    ASSERTNONCRITICAL;
#ifdef UNICODE
    return SendMessageW(hWnd, Msg, wParam, lParam);
#else
    return SendMessageA(hWnd, Msg, wParam, lParam);
#endif
}
#endif // defined(DEBUG)

#define COMPILE_MULTIMON_STUBS
#include "multimon.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\ctlspriv.h ===
#undef STRICT
#define STRICT

/* disable "non-standard extension" warnings in our code
 */
#ifndef RC_INVOKED
#pragma warning(disable:4001)
#endif

#ifdef WIN32
#define _COMCTL32_
#define _INC_OLE
#define _SHLWAPI_
#define CONST_VTABLE
#endif


#ifndef UNIX   // IEUNIX - build process on UNIX doen't define WINVER
#ifndef WINVER
// This stuff must run on Win95
// The NT build process already have these set as 0x0400
#define WINVER              0x0400
#endif
#endif // UNIX

#define CC_INTERNAL

#include <windows.h>

#if !defined(WINNT) && defined(_X86)

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

//
// If we are building Win95 binaries from a NT build environment,
// then we need to special case RtlMoveMemory (hmemcpy is defined to be
// RtlMoveMemory).  On Win95, RtlMoveMemory is exported from kernel32.dll
// but on NT, RtlMoveMemory is implemented as memmove exported from
// ntdll.dll.  So, NT's winnt.h defines RtlMoveMemory as memmove,
// but Win95's winnt.h doesn't.
//
// Since we are building with NT's winnt.h, but targeting Win95,
// undefine RtlMoveMemory and offer the function proto-type.
//

#undef RtlMoveMemory

NTSYSAPI
VOID
NTAPI
RtlMoveMemory (
   VOID UNALIGNED *Destination,
   CONST VOID UNALIGNED *Source,
   DWORD Length
   );

#ifdef __cplusplus
}
#endif // __cplusplus
#endif

#include <windowsx.h>
#include <ole2.h>               // to get IStream for image.c
#include <commctrl.h>
#define NO_SHLWAPI_UNITHUNK     // We have our own private thunks
#include <shlwapi.h>
#include <port32.h>

#if defined(UNICODE) && !defined(WINNT)
#define UNICODE_WIN9x
#endif

#include "wrapfns.h"            // This should be first than ccstock.h
                                // unless real W api is called on Win9x
#define DISALLOW_Assert
#include <debug.h>
#include <winerror.h>
#include <ccstock.h>
#if defined(FE_IME) || !defined(WINNT)
#include <imm.h>
#endif
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


#include "multimon.h"   // support for multiple monitor APIs on non-mm OSes
#include "thunk.h"      // Ansi / Wide string conversions
#include "apithk.h"     // Run-time thunks for different major revs of OSes
#include "mem.h"
#include "rcids.h"
#include "cstrings.h"
#include <crtfree.h>

#include "shpriv.h"

#ifdef MAINWIN
#include <mainwin.h>
#endif

#ifndef DS_BIDI_RTL
#define DS_BIDI_RTL  0x8000
#endif

#ifdef FONT_LINK
//
//  CodePages
//
#define CP_OEM_437       437
#define CP_IBM852        852
#define CP_IBM866        866
#define CP_THAI          874
#define CP_JAPAN         932
#define CP_CHINA         936
#define CP_KOREA         949
#define CP_TAIWAN        950
#define CP_EASTEUROPE    1250
#define CP_RUSSIAN       1251
#define CP_WESTEUROPE    1252
#define CP_GREEK         1253
#define CP_TURKISH       1254
#define CP_HEBREW        1255
#define CP_ARABIC        1256
#define CP_BALTIC        1257
#define CP_VIETNAMESE    1258
#define CP_RUSSIANKOI8R  20866
#define CP_RUSSIANKOI8RU 21866
#define CP_ISOEASTEUROPE 28592
#define CP_ISOTURKISH    28593
#define CP_ISOBALTIC     28594
#define CP_ISORUSSIAN    28595
#define CP_ISOARABIC     28596
#define CP_ISOGREEK      28597
#define CP_JAPANNHK      50220
#define CP_JAPANESC      50221
#define CP_JAPANSIO      50222
#define CP_KOREAISO      50225
#define CP_JAPANEUC      51932
#define CP_CHINAHZ       52936
#define CP_MAC_ROMAN     10000
#define CP_MAC_JAPAN     10001
#define CP_MAC_GREEK     10006
#define CP_MAC_CYRILLIC  10007
#define CP_MAC_LATIN2    10029
#define CP_MAC_TURKISH   10081
#define CP_DEFAULT       CP_ACP
#define CP_GETDEFAULT    GetACP()
#define CP_JOHAB         1361
#define CP_SYMBOL        42
#define CP_UTF8          65001
#define CP_UTF7          65000
#define CP_UNICODELITTLE 1200
#define CP_UNICODEBIG    1201

#define OEM437_CHARSET   254
#endif   //FONT_LINK

//
// inside comctl32 we always call _TrackMouseEvent...
//
#ifndef TrackMouseEvent
#define TrackMouseEvent _TrackMouseEvent
#endif

#define DCHF_LARGE          0x00000001  // default is small
#define DCHF_TOPALIGN       0x00000002  // default is center-align
#define DCHF_HORIZONTAL     0x00000004  // default is vertical
#define DCHF_HOT            0x00000008  // default is flat
#define DCHF_PUSHED         0x00000010  // default is flat
#define DCHF_FLIPPED        0x00000020  // if horiz, default is pointing right
                                        // if vert, default is pointing up
#define DCHF_TRANSPARENT    0x00000040
#define DCHF_INACTIVE       0x00000080
#define DCHF_NOBORDER       0x00000100

extern void DrawCharButton(HDC hdc, LPRECT lprc, UINT wControlState, TCHAR ch);
extern void DrawScrollArrow(HDC hdc, LPRECT lprc, UINT wControlState);
extern void DrawChevron(HDC hdc, LPRECT lprc, DWORD dwState);

//
// BOGUS -- This are all in \win\core\access\inc32\winable.h, but it's too
// tricky to mess with the build process.  The IE guys are not enlisted in
// core, just shell, so they won't be able to build COMCTL32 if we include
// that file.
//
extern void MyNotifyWinEvent(UINT, HWND, LONG, LONG_PTR);

#define     OBJID_WINDOW                ((LONG)0x00000000)
#define     OBJID_SYSMENU               ((LONG)0xFFFFFFFF)
#define     OBJID_TITLEBAR              ((LONG)0xFFFFFFFE)
#define     OBJID_MENU                  ((LONG)0xFFFFFFFD)
#define     OBJID_CLIENT                ((LONG)0xFFFFFFFC)
#define     OBJID_VSCROLL               ((LONG)0xFFFFFFFB)
#define     OBJID_HSCROLL               ((LONG)0xFFFFFFFA)
#define     OBJID_SIZEGRIP              ((LONG)0xFFFFFFF9)
#define     OBJID_CARET                 ((LONG)0xFFFFFFF8)
#define     OBJID_CURSOR                ((LONG)0xFFFFFFF7)
#define     OBJID_ALERT                 ((LONG)0xFFFFFFF6)
#define     OBJID_SOUND                 ((LONG)0xFFFFFFF5)
#define     OBJID_QUERYCLASSNAMEIDX     ((LONG)0xFFFFFFF4)


#define EVENT_OBJECT_CREATE             0x8000
#define EVENT_OBJECT_DESTROY            0x8001
#define EVENT_OBJECT_SHOW               0x8002
#define EVENT_OBJECT_HIDE               0x8003
#define EVENT_OBJECT_REORDER            0x8004
#define EVENT_OBJECT_FOCUS              0x8005
#define EVENT_OBJECT_SELECTION          0x8006
#define EVENT_OBJECT_SELECTIONADD       0x8007
#define EVENT_OBJECT_SELECTIONREMOVE    0x8008
#define EVENT_OBJECT_SELECTIONWITHIN    0x8009
#define EVENT_OBJECT_STATECHANGE        0x800A
#define EVENT_OBJECT_LOCATIONCHANGE     0x800B
#define EVENT_OBJECT_NAMECHANGE         0x800C
#define EVENT_OBJECT_DESCRIPTIONCHANGE  0x800D
#define EVENT_OBJECT_VALUECHANGE        0x800E

#define EVENT_SYSTEM_SOUND              0x0001
#define EVENT_SYSTEM_ALERT              0x0002
#define EVENT_SYSTEM_SCROLLINGSTART     0x0012
#define EVENT_SYSTEM_SCROLLINGEND       0x0013

// Secret SCROLLBAR index values
#define INDEX_SCROLLBAR_SELF            0
#define INDEX_SCROLLBAR_UP              1
#define INDEX_SCROLLBAR_UPPAGE          2
#define INDEX_SCROLLBAR_THUMB           3
#define INDEX_SCROLLBAR_DOWNPAGE        4
#define INDEX_SCROLLBAR_DOWN            5

#define INDEX_SCROLLBAR_MIC             1
#define INDEX_SCROLLBAR_MAC             5

#define INDEX_SCROLLBAR_LEFT            7
#define INDEX_SCROLLBAR_LEFTPAGE        8
#define INDEX_SCROLLBAR_HORZTHUMB       9
#define INDEX_SCROLLBAR_RIGHTPAGE       10
#define INDEX_SCROLLBAR_RIGHT           11

#define INDEX_SCROLLBAR_HORIZONTAL      6
#define INDEX_SCROLLBAR_GRIP            12

#define CHILDID_SELF                    0
#define INDEXID_OBJECT                  0
#define INDEXID_CONTAINER               0

#ifndef WM_GETOBJECT
#define WM_GETOBJECT                    0x003D
#endif

#define MSAA_CLASSNAMEIDX_BASE 65536L

#define MSAA_CLASSNAMEIDX_STATUS     (MSAA_CLASSNAMEIDX_BASE+11)
#define MSAA_CLASSNAMEIDX_TOOLBAR    (MSAA_CLASSNAMEIDX_BASE+12)
#define MSAA_CLASSNAMEIDX_PROGRESS   (MSAA_CLASSNAMEIDX_BASE+13)
#define MSAA_CLASSNAMEIDX_ANIMATE    (MSAA_CLASSNAMEIDX_BASE+14)
#define MSAA_CLASSNAMEIDX_TAB        (MSAA_CLASSNAMEIDX_BASE+15)
#define MSAA_CLASSNAMEIDX_HOTKEY     (MSAA_CLASSNAMEIDX_BASE+16)
#define MSAA_CLASSNAMEIDX_HEADER     (MSAA_CLASSNAMEIDX_BASE+17)
#define MSAA_CLASSNAMEIDX_TRACKBAR   (MSAA_CLASSNAMEIDX_BASE+18)
#define MSAA_CLASSNAMEIDX_LISTVIEW   (MSAA_CLASSNAMEIDX_BASE+19)
#define MSAA_CLASSNAMEIDX_UPDOWN     (MSAA_CLASSNAMEIDX_BASE+22)
#define MSAA_CLASSNAMEIDX_TOOLTIPS   (MSAA_CLASSNAMEIDX_BASE+24)
#define MSAA_CLASSNAMEIDX_TREEVIEW   (MSAA_CLASSNAMEIDX_BASE+25)
//
// End BOGUS insertion from \win\core\access\inc32\winable.h
//

#ifdef MAXINT
#undef MAXINT
#endif
#define MAXINT  (int)0x7FFFFFFF
// special value for pt.y or cyLabel indicating recomputation needed
// NOTE: icon ordering code considers (RECOMPUTE, RECOMPUTE) at end
// of all icons
//
#define RECOMPUTE  (DWORD)MAXINT
#define SRECOMPUTE ((short)0x7FFF)

#define RECTWIDTH(rc) ((rc).right - (rc).left)
#define RECTHEIGHT(rc) ((rc).bottom - (rc).top)
#define ABS(i)  (((i) < 0) ? -(i) : (i))
#define BOUND(x,low,high)   max(min(x, high),low)

#define LPARAM_TO_POINT(lParam, pt)       ((pt).x = LOWORD(lParam), \
                                           (pt).y = HIWORD(lParam))

// common control info stuff

typedef struct tagControlInfo {
    HWND        hwnd;
    HWND        hwndParent;
    DWORD       style;
    DWORD       dwCustom;
    BITBOOL     bUnicode : 1;
    BITBOOL     bInFakeCustomDraw:1;
    UINT        uiCodePage;
    DWORD       dwExStyle;
    LRESULT     iVersion;
#ifdef KEYBOARDCUES
    WORD        wUIState;
#endif
} CONTROLINFO, FAR *LPCONTROLINFO;

#ifdef KEYBOARDCUES
BOOL CCGetUIState(LPCONTROLINFO pControlInfo);

BOOL CCNotifyNavigationKeyUsage(LPCONTROLINFO pControlInfo, WORD wFlag);

BOOL NEAR PASCAL CCOnUIState(LPCONTROLINFO pCI, UINT uMessage, WPARAM wParam, LPARAM lParam);
#endif

BOOL CCWndProc(CONTROLINFO* pci, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres);
void FAR PASCAL CIInitialize(LPCONTROLINFO lpci, HWND hwnd, LPCREATESTRUCT lpcs);
LRESULT FAR PASCAL CIHandleNotifyFormat(LPCONTROLINFO lpci, LPARAM lParam);
DWORD NEAR PASCAL CICustomDrawNotify(LPCONTROLINFO lpci, DWORD dwStage, LPNMCUSTOMDRAW lpnmcd);
DWORD CIFakeCustomDrawNotify(LPCONTROLINFO lpci, DWORD dwStage, LPNMCUSTOMDRAW lpnmcd);
UINT RTLSwapLeftRightArrows(CONTROLINFO *pci, WPARAM wParam);
UINT CCSwapKeys(WPARAM wParam, UINT vk1, UINT vk2);
LPTSTR CCReturnDispInfoText(LPTSTR pszSrc, LPTSTR pszDest, UINT cchDest);

void FillRectClr(HDC hdc, LPRECT prc, COLORREF clr);

void CCCreateWindow();
void CCDestroyWindow();


//
// helpers for drag-drop enabled controls
//
typedef LRESULT (*PFNDRAGCB)(HWND hwnd, UINT code, WPARAM wp, LPARAM lp);
#define DPX_DRAGHIT   (0)  // WP = (unused)  LP = POINTL*         ret = item id
#define DPX_GETOBJECT (1)  // LP = nmobjectnotify   ret = HRESULT
#define DPX_SELECT    (2)  // WP = item id   LP = DROPEFFECT_     ret = (unused)
#define DPX_ENTER     (3)  // WP = (unused)  LP = (unused)        ret = BOOL
#define DPX_LEAVE     (4)  // WP = (unused)  LP = (unused)        ret = (unused)


// ddproxy.cpp

DECLARE_HANDLE(HDRAGPROXY);

STDAPI_(HDRAGPROXY) CreateDragProxy(HWND hwnd, PFNDRAGCB pfn, BOOL bRegister);
STDAPI_(void) DestroyDragProxy(HDRAGPROXY hdp);
STDAPI GetDragProxyTarget(HDRAGPROXY hdp, IDropTarget **ppdtgt);
STDAPI GetItemObject(CONTROLINFO *, UINT, const IID *, LPNMOBJECTNOTIFY);


#define SWAP(x,y, _type)  { _type i; i = x; x = y; y = i; }

#if !defined(WIN32) && (defined(MAINWIN))
//
// This is for 3.1 property sheet emulation
//
#define DLGC_RECURSE 0x8000
#endif

//
// This is for widened dispatch loop stuff
//
#ifdef WIN32
typedef MSG MSG32;
typedef MSG32 FAR *     LPMSG32;

#define GetMessage32(lpmsg, hwnd, min, max, f32)        GetMessage(lpmsg, hwnd, min, max)
#define PeekMessage32(lpmsg, hwnd, min, max, flags, f32)       PeekMessage(lpmsg, hwnd, min, max, flags)
#define TranslateMessage32(lpmsg, f32)  TranslateMessage(lpmsg)
#define DispatchMessage32(lpmsg, f32)   DispatchMessage(lpmsg)
#define CallMsgFilter32(lpmsg, u, f32)  CallMsgFilter(lpmsg, u)
#define IsDialogMessage32(hwnd, lpmsg, f32)   IsDialogMessage(hwnd, lpmsg)
#else


// This comes from ..\..\inc\usercmn.h--but I can't get commctrl to compile
// when I include it and I don't have the time to mess with this right now.

// DWORD wParam MSG structure
typedef struct tagMSG32
{
    HWND    hwnd;
    UINT    message;
    WPARAM  wParam;
    LPARAM  lParam;
    DWORD   time;
    POINT   pt;

    WPARAM  wParamHi;
} MSG32, FAR* LPMSG32;

BOOL    WINAPI GetMessage32(LPMSG32, HWND, UINT, UINT, BOOL);
BOOL    WINAPI PeekMessage32(LPMSG32, HWND, UINT, UINT, UINT, BOOL);
BOOL    WINAPI TranslateMessage32(const MSG32 FAR*, BOOL);
LONG    WINAPI DispatchMessage32(const MSG32 FAR*, BOOL);
BOOL    WINAPI CallMsgFilter32(LPMSG32, int, BOOL);
BOOL    WINAPI IsDialogMessage32(HWND, LPMSG32, BOOL);

#endif // WIN32


//
// This is a very important piece of performance hack for non-DBCS codepage.
//
// was !defined(DBCS) || defined(UNICODE)
#if defined(WINNT)
// NB - These are already macros in Win32 land.
#ifdef WIN32
#undef AnsiNext
#undef AnsiPrev
#endif

#define AnsiNext(x) ((x)+1)
#define AnsiPrev(y,x) ((x)-1)
#define IsDBCSLeadByte(x) ((x), FALSE)
#endif

// FastCharNext and FastCharPrev are like CharNext and CharPrev except that
// they don't check if you are at the beginning/end of the string.

#ifdef UNICODE
#define FastCharNext(pch) ((pch)+1)
#define FastCharPrev(pchStart, pch) ((pch)-1)
#else
#define FastCharNext        CharNext
#define FastCharPrev        CharPrev
#endif

#define CH_PREFIX TEXT('&')


#ifdef UNICODE
#define lstrfns_StrEndN         lstrfns_StrEndNW
#define ChrCmp                  ChrCmpW
#define ChrCmpI                 ChrCmpIW

#else
#define lstrfns_StrEndN         lstrfns_StrEndNA
#define ChrCmp                  ChrCmpA
#define ChrCmpI                 ChrCmpIA

#endif
BOOL ChrCmpIA(WORD w1, WORD wMatch);
BOOL ChrCmpIW(WCHAR w1, WCHAR wMatch);
void  TruncateString(char *sz, int cch); // from strings.c

void FAR PASCAL InitGlobalMetrics(WPARAM);
void FAR PASCAL InitGlobalColors();

BOOL FAR PASCAL InitToolbarClass(HINSTANCE hInstance);
BOOL FAR PASCAL InitReBarClass(HINSTANCE hInstance);
BOOL FAR PASCAL InitToolTipsClass(HINSTANCE hInstance);
BOOL FAR PASCAL InitStatusClass(HINSTANCE hInstance);
BOOL FAR PASCAL InitHeaderClass(HINSTANCE hInstance);
BOOL FAR PASCAL InitButtonListBoxClass(HINSTANCE hInstance);
BOOL FAR PASCAL InitTrackBar(HINSTANCE hInstance);
BOOL FAR PASCAL InitUpDownClass(HINSTANCE hInstance);
BOOL FAR PASCAL InitProgressClass(HINSTANCE hInstance);
BOOL FAR PASCAL InitHotKeyClass(HINSTANCE hInstance);
BOOL FAR PASCAL InitToolTips(HINSTANCE hInstance);
BOOL FAR PASCAL InitDateClasses(HINSTANCE hinst);

BOOL NEAR PASCAL ChildOfActiveWindow(HWND hwnd);

/* cutils.c */
HFONT CCGetHotFont(HFONT hFont, HFONT *phFontHot);
HFONT CCCreateStatusFont(void);
BOOL CCForwardEraseBackground(HWND hwnd, HDC hdc);
void CCPlaySound(LPCTSTR lpszName);
BOOL FAR PASCAL CheckForDragBegin(HWND hwnd, int x, int y);
void FAR PASCAL NewSize(HWND hWnd, int nHeight, LONG style, int left, int top, int width, int height);
BOOL FAR PASCAL MGetTextExtent(HDC hdc, LPCTSTR lpstr, int cnt, int FAR * pcx, int FAR * pcy);
void FAR PASCAL RelayToToolTips(HWND hwndToolTips, HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
void FAR PASCAL StripAccelerators(LPTSTR lpszFrom, LPTSTR lpszTo, BOOL fAmpOnly);
UINT GetCodePageForFont (HFONT hFont);
void* CCLocalReAlloc(void* p, UINT uBytes);
LONG GetMessagePosClient(HWND hwnd, LPPOINT ppt);
void FAR PASCAL FlipRect(LPRECT prc);
DWORD SetWindowBits(HWND hWnd, int iWhich, DWORD dwBits, DWORD dwValue);
BOOL CCDrawEdge(HDC hdc, LPRECT lprc, UINT edge, UINT flags, LPCOLORSCHEME lpclrsc);
void CCInvalidateFrame(HWND hwnd);
void FlipPoint(LPPOINT lppt);
void CCSetInfoTipWidth(HWND hwndOwner, HWND hwndToolTips);
#define CCResetInfoTipWidth(hwndOwner, hwndToolTips) \
    SendMessage(hwndToolTips, TTM_SETMAXTIPWIDTH, 0, -1)

// Incremental search
typedef struct ISEARCHINFO {
    int iIncrSearchFailed;
    LPTSTR pszCharBuf;                  // isearch string lives here
    int cbCharBuf;                      // allocated size of pszCharBuf
    int ichCharBuf;                     // number of live chars in pszCharBuf
    DWORD timeLast;                     // time of last input event
#if defined(FE_IME) || !defined(WINNT)
    BOOL fReplaceCompChar;
#endif

} ISEARCHINFO, *PISEARCHINFO;

#if defined(FE_IME) || !defined(WINNT)
BOOL FAR PASCAL IncrementSearchImeCompStr(PISEARCHINFO pis, BOOL fCompStr, LPTSTR lpszCompChar, LPTSTR FAR *lplpstr);
#endif
BOOL FAR PASCAL IncrementSearchString(PISEARCHINFO pis, UINT ch, LPTSTR FAR *lplpstr);
int FAR PASCAL GetIncrementSearchString(PISEARCHINFO pis, LPTSTR lpsz);
int FAR PASCAL GetIncrementSearchStringA(PISEARCHINFO pis, UINT uiCodePage, LPSTR lpsz);
void FAR PASCAL IncrementSearchBeep(PISEARCHINFO pis);

#define IncrementSearchFree(pis) ((pis)->pszCharBuf ? Free((pis)->pszCharBuf) : 0)

// For RTL mirroring use
void MirrorBitmapInDC( HDC hdc , HBITMAP hbmOrig );

// Locale manipulation (prsht.c)
//
//  The "proper thread locale" is the thread locale we should
//  be using for our UI elements.
//
//  If you need to change the thread locale temporarily
//  to the proper thread locale, use
//
//  LCID lcidPrev;
//  CCSetProperThreadLocale(&lcidPrev);
//  munge munge munge
//  CCRestoreThreadLocale(lcidPrev);
//
//  If you just want to retrieve the proper thread locale,
//  call CCGetProperThreadLocale(NULL).
//
//
LCID CCGetProperThreadLocale(OPTIONAL LCID *plcidPrev);

__inline void CCSetProperThreadLocale(LCID *plcidPrev) {
    SetThreadLocale(CCGetProperThreadLocale(plcidPrev));
}

#define CCRestoreThreadLocale(lcid) SetThreadLocale(lcid)

int CCLoadStringExInternal(HINSTANCE hInst, UINT uID, LPWSTR lpBuffer, int nBufferMax, WORD wLang);
int CCLoadStringEx(UINT uID, LPWSTR lpBuffer, int nBufferMax, WORD wLang);
int LocalizedLoadString(UINT uID, LPWSTR lpBuffer, int nBufferMax);
HRSRC FindResourceExRetry(HMODULE hmod, LPCTSTR lpType, LPCTSTR lpName, WORD wLang);

// assign most unlikely used value for the fake sublang id
#define SUBLANG_JAPANESE_ALTFONT 0x3f // max within 6bit

// used to get resource lang of shell32
#define DLG_EXITWINDOWS         1064

//
// Plug UI Setting funcions (commctrl.c)
//
LANGID WINAPI GetMUILanguage(void);

#ifdef UNICODE
//
// Tooltip thunking api's
//

BOOL ThunkToolTipTextAtoW (LPTOOLTIPTEXTA lpTttA, LPTOOLTIPTEXTW lpTttW, UINT uiCodePage);

#endif

HWND GetDlgItemRect(HWND hDlg, int nIDItem, LPRECT prc);

//
// Global variables
//
extern HINSTANCE g_hinst;
extern UINT uDragListMsg;
extern int g_iIncrSearchFailed;

#ifdef WINNT
#define g_bRunOnNT TRUE
#define g_bRunOnMemphis FALSE
extern BOOL g_bRunOnNT5;
extern BOOL g_bRemoteSession;
#else
#define g_bRunOnNT FALSE
#define g_bRunOnNT5 FALSE
#define g_bRemoteSession FALSE
extern BOOL g_bRunOnMemphis;
extern BOOL g_bRunOnBiDiWin95Loc;
#endif
extern UINT g_uiACP;

//
// Is Mirroring APIs enabled (BiDi Memphis and NT5 only)
//
extern BOOL g_bMirroredOS;

#ifdef FONT_LINK
extern BOOL g_bComplexPlatform;
#endif

//
// Icon mirroring stuff
//
extern HDC g_hdc;
extern HDC g_hdcMask;


#define HINST_THISDLL   g_hinst

#ifdef WIN32

#ifdef DEBUG
#undef SendMessage
#define SendMessage  SendMessageD
#ifdef __cplusplus
extern "C"
{
#endif
LRESULT WINAPI SendMessageD(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
int WINAPI Str_GetPtr0(LPCTSTR pszCurrent, LPTSTR pszBuf, int cchBuf);
#ifdef __cplusplus
}
#endif
#else  // !DEBUG
#define Str_GetPtr0     Str_GetPtr
#endif // DEBUG / !DEBUG

#endif // WIN32

// REVIEW, should this be a function? (inline may generate a lot of code)
#define CBBITMAPBITS(cx, cy, cPlanes, cBitsPerPixel)    \
        (((((cx) * (cBitsPerPixel) + 15) & ~15) >> 3)   \
        * (cPlanes) * (cy))

#define WIDTHBYTES(cx, cBitsPerPixel)   \
        ((((cx) * (cBitsPerPixel) + 31) / 32) * 4)

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))                          /* ;Internal */

#define InRange(id, idFirst, idLast)      ((UINT)((id)-(idFirst)) <= (UINT)((idLast)-(idFirst)))

void FAR PASCAL ColorDitherBrush_OnSysColorChange();
extern HBRUSH g_hbrMonoDither;              // gray dither brush from image.c
void FAR PASCAL InitDitherBrush();
void FAR PASCAL TerminateDitherBrush();


#ifndef DT_NOFULLWIDTHCHARBREAK
#define DT_NOFULLWIDTHCHARBREAK     0x00080000
#endif  // DT_NOFULLWIDTHCHARBREAK

#define SHDT_DRAWTEXT       0x0001
#define SHDT_ELLIPSES       0x0002
#define SHDT_CLIPPED        0x0004
#define SHDT_SELECTED       0x0008
#define SHDT_DESELECTED     0x0010
#define SHDT_DEPRESSED      0x0020
#define SHDT_EXTRAMARGIN    0x0040
#define SHDT_TRANSPARENT    0x0080
#define SHDT_SELECTNOFOCUS  0x0100
#define SHDT_HOTSELECTED    0x0200
#define SHDT_DTELLIPSIS     0x0400
#ifdef WINDOWS_ME
#define SHDT_RTLREADING     0x0800
#endif
#define SHDT_NODBCSBREAK    0x1000

void WINAPI SHDrawText(HDC hdc, LPCTSTR pszText, RECT FAR* prc,
        int fmt, UINT flags, int cyChar, int cxEllipses,
        COLORREF clrText, COLORREF clrTextBk);


// notify.c
LRESULT WINAPI CCSendNotify(CONTROLINFO * pci, int code, LPNMHDR pnm);
BOOL CCReleaseCapture(CONTROLINFO * pci);
void CCSetCapture(CONTROLINFO * pci, HWND hwndSet);


// treeview.c, listview.c for FE_IME code
LPTSTR GET_COMP_STRING(HIMC hImc, DWORD dwFlags);

// lvicon.c in-place editing
#define SEIPS_WRAP          0x0001
#ifdef DEBUG
#define SEIPS_NOSCROLL      0x0002      // Flag is used only in DEBUG
#endif
void FAR PASCAL SetEditInPlaceSize(HWND hwndEdit, RECT FAR *prc, HFONT hFont, UINT seips);
HWND FAR PASCAL CreateEditInPlaceWindow(HWND hwnd, LPCTSTR lpText, int cbText, LONG style, HFONT hFont);
void RescrollEditWindow(HWND hwndEdit);

// Global System metrics.

extern int g_cxEdge;
extern int g_cyEdge;
extern int g_cxBorder;
extern int g_cyBorder;
extern int g_cxScreen;
extern int g_cyScreen;
extern int g_cxDoubleClk;
extern int g_cyDoubleClk;

extern int g_cxSmIcon;
extern int g_cySmIcon;
//extern int g_cxIcon;
//extern int g_cyIcon;
extern int g_cxFrame;
extern int g_cyFrame;
extern int g_cxIconSpacing, g_cyIconSpacing;
extern int g_cxScrollbar, g_cyScrollbar;
extern int g_cxIconMargin, g_cyIconMargin;
extern int g_cyLabelSpace;
extern int g_cxLabelMargin;
//extern int g_cxIconOffset, g_cyIconOffset;
extern int g_cxVScroll;
extern int g_cyHScroll;
extern int g_cxHScroll;
extern int g_cyVScroll;
extern int g_fDragFullWindows;
extern int g_fDBCSEnabled;
extern int g_fMEEnabled;
extern int g_fDBCSInputEnabled;

extern COLORREF g_clrWindow;
extern COLORREF g_clrWindowText;
extern COLORREF g_clrWindowFrame;
extern COLORREF g_clrGrayText;
extern COLORREF g_clrBtnText;
extern COLORREF g_clrBtnFace;
extern COLORREF g_clrBtnShadow;
extern COLORREF g_clrBtnHighlight;
extern COLORREF g_clrHighlight;
extern COLORREF g_clrHighlightText;
extern COLORREF g_clrInfoText;
extern COLORREF g_clrInfoBk;
extern COLORREF g_clr3DDkShadow;
extern COLORREF g_clr3DLight;

extern HBRUSH g_hbrGrayText;
extern HBRUSH g_hbrWindow;
extern HBRUSH g_hbrWindowText;
extern HBRUSH g_hbrWindowFrame;
extern HBRUSH g_hbrBtnFace;
extern HBRUSH g_hbrBtnHighlight;
extern HBRUSH g_hbrBtnShadow;
extern HBRUSH g_hbrHighlight;

extern HFONT g_hfontSystem;
#define WHEEL_DELTA     120
extern UINT g_msgMSWheel;
extern UINT g_ucScrollLines;
extern int  gcWheelDelta;
extern UINT g_uDragImages;

#ifdef __cplusplus
}
#endif // __cplusplus
//
// Defining FULL_DEBUG makes us debug memory problems.
//
#if defined(FULL_DEBUG) && defined(WIN32)
#include "../inc/deballoc.h"
#endif // defined(FULL_DEBUG) && defined(WIN32)

typedef LRESULT (CALLBACK *SUBCLASSPROC)(HWND hWnd, UINT uMsg, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);

STDAPI_(BOOL) WINAPI SetWindowSubclass(HWND hWnd, SUBCLASSPROC pfnSubclass, UINT_PTR uIdSubclass,
    DWORD_PTR dwRefData);
STDAPI_(BOOL) WINAPI GetWindowSubclass(HWND hWnd, SUBCLASSPROC pfnSubclass, UINT_PTR uIdSubclass,
    DWORD_PTR *pdwRefData);
STDAPI_(BOOL) WINAPI RemoveWindowSubclass(HWND hWnd, SUBCLASSPROC pfnSubclass,
    UINT_PTR uIdSubclass);
STDAPI_(LRESULT) WINAPI DefSubclassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

#define CDIS_SHOWKEYBOARDCUES   0x0200


// TRACE FLAGS
//
#define TF_MONTHCAL     0x00000100  // MonthCal and DateTimePick
#define TF_BKIMAGE      0x00000200  // ListView background image
#define TF_TOOLBAR      0x00000400  // Toolbar stuff
#define TF_PAGER        0x00000800  // Pager  Stuff
#define TF_REBAR        0x00001000  // Rebar
#define TF_LISTVIEW     0x00002000  // Listview
#define TF_TREEVIEW     0x00004000  // Treeview
#define TF_STATUS       0x00008000  // Status bar

// Prototype flags
#define PTF_FLATLOOK    0x00000001  // Overall flatlook
#define PTF_NOISEARCHTO 0x00000002  // No incremental search timeout

#include <platform.h>

// Dummy union macros for code compilation on platforms not
// supporting nameless stuct/union

#ifdef NONAMELESSUNION
#define DUMMYUNION_MEMBER(member)   DUMMYUNIONNAME.member
#define DUMMYUNION2_MEMBER(member)  DUMMYUNIONNAME2.member
#define DUMMYUNION3_MEMBER(member)  DUMMYUNIONNAME3.member
#define DUMMYUNION4_MEMBER(member)  DUMMYUNIONNAME4.member
#define DUMMYUNION5_MEMBER(member)  DUMMYUNIONNAME5.member
#else
#define DUMMYUNION_MEMBER(member)    member
#define DUMMYUNION2_MEMBER(member)   member
#define DUMMYUNION3_MEMBER(member)   member
#define DUMMYUNION4_MEMBER(member)   member
#define DUMMYUNION5_MEMBER(member)   member
#endif

#ifdef  UNIX
#define ALLOC_NULLHEAP(heap, size) ControlAlloc( heap, size )
#define COLOR_STRUCT RGBQUAD
typedef struct tagRGBQUAD_COLORMAP {
    RGBQUAD from;
    RGBQUAD to;
} RGBQUAD_COLORMAP;
#else
#define ALLOC_NULLHEAP(heap, size) Alloc( size )
#define COLOR_STRUCT DWORD
#define QUAD_PART(a) ((a)##.QuadPart)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\cutils.c ===
/*
**  CUTILS.C
**
**  Common utilities for common controls
**
*/

#include "ctlspriv.h"
#include "advpub.h"             // For REGINSTALL
#include <ntverp.h>
#include "ccver.h"              // App compat version hacks

#ifndef SSW_EX_IGNORESETTINGS
#define SSW_EX_IGNORESETTINGS   0x00040000  // ignore system settings to turn on/off smooth scroll
#endif


//
// Globals - REVIEW_32
//

BOOL g_fAnimate;
BOOL g_fSmoothScroll;

int g_cxEdge;
int g_cyEdge;
int g_cxBorder;
int g_cyBorder;
int g_cxScreen;
int g_cyScreen;
int g_cxFrame;
int g_cyFrame;
int g_cxVScroll;
int g_cyHScroll;
int g_cxIcon, g_cyIcon;
int g_cxSmIcon, g_cySmIcon;
int g_cxIconSpacing, g_cyIconSpacing;
int g_cxIconMargin, g_cyIconMargin;
int g_cyLabelSpace;
int g_cxLabelMargin;
int g_cxDoubleClk;
int g_cyDoubleClk;
int g_cxScrollbar;
int g_cyScrollbar;
int g_fDragFullWindows;


COLORREF g_clrWindow;
COLORREF g_clrWindowText;
COLORREF g_clrWindowFrame;
COLORREF g_clrGrayText;
COLORREF g_clrBtnText;
COLORREF g_clrBtnFace;
COLORREF g_clrBtnShadow;
COLORREF g_clrBtnHighlight;
COLORREF g_clrHighlight;
COLORREF g_clrHighlightText;
COLORREF g_clrInfoText;
COLORREF g_clrInfoBk;
COLORREF g_clr3DDkShadow;
COLORREF g_clr3DLight;

HBRUSH g_hbrGrayText;
HBRUSH g_hbrWindow;
HBRUSH g_hbrWindowText;
HBRUSH g_hbrWindowFrame;
HBRUSH g_hbrBtnFace;
HBRUSH g_hbrBtnHighlight;
HBRUSH g_hbrBtnShadow;
HBRUSH g_hbrHighlight;


DWORD  g_dwHoverSelectTimeout;

HFONT g_hfontSystem;

#define CCS_ALIGN (CCS_TOP | CCS_NOMOVEY | CCS_BOTTOM)

int TrueMapWindowPoints(HWND hwndFrom, HWND hwndTo, LPPOINT lppt, UINT cPoints);

// Note that the default alignment is CCS_BOTTOM
//
void FAR PASCAL NewSize(HWND hWnd, int nThickness, LONG style, int left, int top, int width, int height)
{
    // Resize the window unless the user said not to
    //
    if (!(style & CCS_NORESIZE))
    {
        RECT rc, rcWindow, rcBorder;

        // Remember size that was passed in and don't bother calling SetWindowPos if we're not
        // actually going to change the window size
        int leftSave = left;
        int topSave = top;
        int widthSave = width;
        int heightSave = height;

        // Calculate the borders around the client area of the status bar
        GetWindowRect(hWnd, &rcWindow);
        rcWindow.right -= rcWindow.left;  // -> dx
        rcWindow.bottom -= rcWindow.top;  // -> dy

        GetClientRect(hWnd, &rc);

        //
        // If the window is mirrored, mirror the anchor point
        // since it will be passed to SWP which accepts screen
        // ccordinates. This mainly fixes the display of status bar
        // and others. [samera]
        //
        if (IS_WINDOW_RTL_MIRRORED(hWnd))
        {
            TrueMapWindowPoints(hWnd, NULL, (LPPOINT)&rc.left, 1);
        }
        else
        {
            ClientToScreen(hWnd, (LPPOINT)&rc);
        }

        rcBorder.left = rc.left - rcWindow.left;
        rcBorder.top  = rc.top  - rcWindow.top ;
        rcBorder.right  = rcWindow.right  - rc.right  - rcBorder.left;
        rcBorder.bottom = rcWindow.bottom - rc.bottom - rcBorder.top ;

        if (style & CCS_VERT)
            nThickness += rcBorder.left + rcBorder.right;
        else
            nThickness += rcBorder.top + rcBorder.bottom;

        // Check whether to align to the parent window
        //
        if (style & CCS_NOPARENTALIGN)
        {
            // Check out whether this bar is top aligned or bottom aligned
            //
            switch (style & CCS_ALIGN)
            {
            case CCS_TOP:
            case CCS_NOMOVEY:
                break;

            default: // CCS_BOTTOM
                if(style & CCS_VERT)
                    left = left + width - nThickness;
                else
                    top = top + height - nThickness;
            }
        }
        else
        {
            // It is assumed there is a parent by default
            //
            GetClientRect(GetParent(hWnd), &rc);

            // Don't forget to account for the borders
            //
            if(style & CCS_VERT)
            {
                top = -rcBorder.right;
                height = rc.bottom + rcBorder.top + rcBorder.bottom;
            }
            else
            {
                left = -rcBorder.left;
                width = rc.right + rcBorder.left + rcBorder.right;
            }

            if ((style & CCS_ALIGN) == CCS_TOP)
            {
                if(style & CCS_VERT)
                    left = -rcBorder.left;
                else
                    top = -rcBorder.top;
            }
            else if ((style & CCS_ALIGN) != CCS_NOMOVEY)
            {
                if (style & CCS_VERT)
                    left = rc.right - nThickness + rcBorder.right;
                else
                    top = rc.bottom - nThickness + rcBorder.bottom;
            }
        }
        if (!(style & CCS_NOMOVEY) && !(style & CCS_NODIVIDER))
        {
            if (style & CCS_VERT)
                left += g_cxEdge;
            else
                top += g_cyEdge;      // double pixel edge thing
        }

        if(style & CCS_VERT)
            width = nThickness;
        else
            height = nThickness;

        SetWindowPos(hWnd, NULL, left, top, width, height, SWP_NOZORDER);
    }
}


BOOL FAR PASCAL MGetTextExtent(HDC hdc, LPCTSTR lpstr, int cnt, int FAR * pcx, int FAR * pcy)
{
    BOOL fSuccess;
    SIZE size = {0,0};
    
    if (cnt == -1)
        cnt = lstrlen(lpstr);
    
    fSuccess=GetTextExtentPoint(hdc, lpstr, cnt, &size);
    if (pcx)
        *pcx=size.cx;
    if (pcy)
        *pcy=size.cy;

    return fSuccess;
}


// these are the default colors used to map the dib colors
// to the current system colors

#define RGB_BUTTONTEXT      (RGB(000,000,000))  // black
#define RGB_BUTTONSHADOW    (RGB(128,128,128))  // dark grey
#define RGB_BUTTONFACE      (RGB(192,192,192))  // bright grey
#define RGB_BUTTONHILIGHT   (RGB(255,255,255))  // white
#define RGB_BACKGROUNDSEL   (RGB(000,000,255))  // blue
#define RGB_BACKGROUND      (RGB(255,000,255))  // magenta

#ifdef UNIX
RGBQUAD CLR_TO_RGBQUAD( COLORREF clr)
{
    /* main modif for unix: keep the extra byte in the rgbReserved field
       This is used for our motif colors that are expressed in term of
       CMAPINDEX rather than real RGBs, this function is also portable
       and immune to endianness*/
    RGBQUAD rgbqResult;
    rgbqResult.rgbRed=GetRValue(clr);
    rgbqResult.rgbGreen=GetGValue(clr);
    rgbqResult.rgbBlue=GetBValue(clr);
    rgbqResult.rgbReserved=(BYTE)((clr>>24)&0xff);
    return rgbqResult;
}

COLORREF RGBQUAD_TO_CLR( RGBQUAD rgbQ )
{
    return ( ((DWORD)rgbQ.rgbRed) |  ((DWORD)(rgbQ.rgbGreen << 8)) | 
            ((DWORD)(rgbQ.rgbBlue << 16)) | ((DWORD)(rgbQ.rgbReserved << 24)) );
}

/* This is just plain wrong
   1) they definition of COLORMAP is based on COLORREFs but a
      DIB color map is RGBQUAD
   2) FlipColor as per previous definition does not flip at all
      since it goes from COLORREF to COLORREF
   so we are better doing nothing, so we dont loose our CMAP flag
   (Jose)
   */
#define FlipColor(rgb)      (rgb)
#else
#define FlipColor(rgb)      (RGB(GetBValue(rgb), GetGValue(rgb), GetRValue(rgb)))
#endif /* UNIX */


#define MAX_COLOR_MAPS      16

// This is almost the same as LoadImage(..., LR_MAP3DCOLORS) except that
//
//  -   The app can specify a custom color map,
//  -   The default color map maps colors beyond the 3D colors,
//  -   strange UNIX stuff happens that I'm afraid to mess with.
//
HBITMAP WINAPI CreateMappedBitmap(HINSTANCE hInstance, INT_PTR idBitmap,
      UINT wFlags, LPCOLORMAP lpColorMap, int iNumMaps)
{
  HDC                   hdc, hdcMem = NULL;
  HANDLE                h;
  COLOR_STRUCT FAR      *p;
  COLOR_STRUCT FAR      *lpTable;
  LPBYTE                lpBits;
  HANDLE                hRes;
  LPBITMAPINFOHEADER    lpBitmapInfo;
  HBITMAP               hbm = NULL, hbmOld;
  int numcolors, i;
  int wid, hgt;
  LPBITMAPINFOHEADER    lpMungeInfo;
  int                   offBits;
  COLOR_STRUCT          rgbMaskTable[16];
  COLOR_STRUCT          rgbBackground;

#ifdef UNIX
  const curColorRes = GetScreenDepth();
#endif /* UNIX */

  static const COLORMAP SysColorMap[] = {
    {RGB_BUTTONTEXT,    COLOR_BTNTEXT},     // black
    {RGB_BUTTONSHADOW,  COLOR_BTNSHADOW},   // dark grey
    {RGB_BUTTONFACE,    COLOR_BTNFACE},     // bright grey
    {RGB_BUTTONHILIGHT, COLOR_BTNHIGHLIGHT},// white
    {RGB_BACKGROUNDSEL, COLOR_HIGHLIGHT},   // blue
    {RGB_BACKGROUND,    COLOR_WINDOW}       // magenta
  };
  #define NUM_DEFAULT_MAPS (sizeof(SysColorMap)/sizeof(COLORMAP))
  COLORMAP DefaultColorMap[NUM_DEFAULT_MAPS];

#ifndef UNIX
  COLORMAP DIBColorMap[MAX_COLOR_MAPS];
#else
  COLORREF DIBColorRefs[MAX_COLOR_MAPS];
#endif

  h = FindResource(hInstance, MAKEINTRESOURCE(idBitmap), RT_BITMAP);
  if (!h)
      return NULL;

  hRes = LoadResource(hInstance, h);

  /* Lock the bitmap and get a pointer to the color table. */
  lpBitmapInfo = (LPBITMAPINFOHEADER)LockResource(hRes);
  if (!lpBitmapInfo)
        return NULL;

  // munge on a copy of the color table instead of the original
  // (prevent possibility of "reload" with messed table
  offBits = (int)lpBitmapInfo->biSize + ((1 << (lpBitmapInfo->biBitCount)) * sizeof(RGBQUAD));
  lpMungeInfo = GlobalAlloc(GPTR, offBits);
  if (!lpMungeInfo)
        goto Exit1;
  hmemcpy(lpMungeInfo, lpBitmapInfo, offBits);

  /* Get system colors for the default color map */
  if (!lpColorMap) {
        lpColorMap = DefaultColorMap;
    iNumMaps = NUM_DEFAULT_MAPS;
    for (i=0; i < iNumMaps; i++) {
      lpColorMap[i].from = SysColorMap[i].from;
      lpColorMap[i].to = GetSysColor((int)SysColorMap[i].to);
    }
  }

  /* Transform RGB color map to a BGR DIB format color map */
  if (iNumMaps > MAX_COLOR_MAPS)
    iNumMaps = MAX_COLOR_MAPS;


#ifndef UNIX
  /* IEUNIX
   1) their definition of COLORMAP is based on COLORREFs but a
      DIB color map is RGBQUAD
   2) FlipColor as per definition above does not flip at all
      since it goes from COLORREF to COLORREF
   so we are better doing nothing, this the(Jose)
   */
  for (i=0; i < iNumMaps; i++) {
    DIBColorMap[i].to = FlipColor(lpColorMap[i].to);
    DIBColorMap[i].from = FlipColor(lpColorMap[i].from);
  }
#endif /* !UNIX */

  // use the table in the munging buffer
  lpTable = p = (COLOR_STRUCT FAR *)(((LPBYTE)lpMungeInfo) + lpMungeInfo->biSize);

  /* Replace button-face and button-shadow colors with the current values
   */
  numcolors = 16;

#ifdef UNIX 
    for (i=0; i<numcolors; i++) {
        if (p[i].rgbReserved & 0x04)  // if colormap index
	   DIBColorRefs[i] = MwGetTrueRGBValue(RGBQUAD_TO_CLR(p[i]));
        else
	   DIBColorRefs[i] = RGB(p[i].rgbRed, p[i].rgbGreen, p[i].rgbBlue);
    }
#endif

  // if we are creating a mask, build a color table with white
  // marking the transparent section (where it used to be background)
  // and black marking the opaque section (everything else).  this
  // table is used below to build the mask using the original DIB bits.
#ifndef UNIX
  if (wFlags & CMB_MASKED) {
      rgbBackground = FlipColor(RGB_BACKGROUND);
      for (i = 0; i < 16; i++) {
          if (p[i] == rgbBackground)
              rgbMaskTable[i] = 0xFFFFFF;       // transparent section
          else
              rgbMaskTable[i] = 0x000000;       // opaque section
      }
  }

  while (numcolors-- > 0) {
      for (i = 0; i < iNumMaps; i++) {
          if ((*p & 0x00FFFFFF) == DIBColorMap[i].from) {
          *p = DIBColorMap[i].to;
              break;
          }
      }
      p++;
  }
#else
  if (wFlags & CMB_MASKED) {

      /* IEUNIX - Varmac: later on change the below to use MwXPixel */
      for (i = 0; i < 16; i++) {
	  if (DIBColorRefs[i] == RGB_BACKGROUND) {
              rgbMaskTable[i].rgbRed = 0xFF;   // transparent section
              rgbMaskTable[i].rgbGreen = 0xFF;
              rgbMaskTable[i].rgbBlue = 0xFF;
	  } else {
	      rgbMaskTable[i].rgbRed = 0x00;   // opaque section
              rgbMaskTable[i].rgbGreen = 0x00;
              rgbMaskTable[i].rgbBlue = 0x00;
	  }
          rgbMaskTable[i].rgbReserved = 0;
      }
  }
  p += (numcolors-1);

  while (numcolors-- > 0) {
      for (i = 0; i < iNumMaps; i++) {
	  if (DIBColorRefs[numcolors] == lpColorMap[i].from) {
//	      if (GetScreenDepth() < 2)  {
//	          if  (lpColorMap[i].from != RGB_BUTTONTEXT) 
//			*p = CLR_TO_RGBQUAD(RGB(255,255,255));
//	      } else	
	        *p = CLR_TO_RGBQUAD(lpColorMap[i].to);
              break;
          }
      }
      p--;
  }
#endif /* !UNIX */

  /* First skip over the header structure */
  lpBits = (LPBYTE)(lpBitmapInfo) + offBits;

  /* Create a color bitmap compatible with the display device */
  i = wid = (int)lpBitmapInfo->biWidth;
  hgt = (int)lpBitmapInfo->biHeight;
  hdc = GetDC(NULL);
  hdcMem = CreateCompatibleDC(hdc);
  if (!hdcMem)
      goto cleanup;

  // if creating a mask, the bitmap needs to be twice as wide.
  if (wFlags & CMB_MASKED)
      i = wid*2;

// discardable bitmaps aren't much use anymore...
//
//  if (wFlags & CMB_DISCARDABLE)
//      hbm = CreateDiscardableBitmap(hdc, i, hgt);
//  else
  if (wFlags & CMB_DIBSECTION)
  {
    // Have to edit the header slightly, since CreateDIBSection supports
    // only BI_RGB and BI_BITFIELDS.  This is the same whackery that USER
    // does in LoadImage.
    LPVOID pvDummy;
    DWORD dwCompression = lpMungeInfo->biCompression;
    if (dwCompression != BI_BITFIELDS)
      lpMungeInfo->biCompression = BI_RGB;
    hbm = CreateDIBSection(hdc, (LPBITMAPINFO)lpMungeInfo, DIB_RGB_COLORS,
                           &pvDummy, NULL, 0);
    lpMungeInfo->biCompression = dwCompression;
  }

  // If CMB_DIBSECTION failed, then create a DDB instead.  Not perfect,
  // but better than creating nothing.  We also get here if the caller
  // didn't ask for a DIB section.
  if (hbm == NULL)
      hbm = CreateCompatibleBitmap(hdc, i, hgt);

  if (hbm) {
      hbmOld = SelectObject(hdcMem, hbm);

      // set the main image
      StretchDIBits(hdcMem, 0, 0, wid, hgt, 0, 0, wid, hgt, lpBits,
                 (LPBITMAPINFO)lpMungeInfo, DIB_RGB_COLORS, SRCCOPY);

      // if building a mask, replace the DIB's color table with the
      // mask's black/white table and set the bits.  in order to
      // complete the masked effect, the actual image needs to be
      // modified so that it has the color black in all sections
      // that are to be transparent.
      if (wFlags & CMB_MASKED) {
          hmemcpy(lpTable, (DWORD FAR *)rgbMaskTable, 16 * sizeof(RGBQUAD));
          StretchDIBits(hdcMem, wid, 0, wid, hgt, 0, 0, wid, hgt, lpBits,
                 (LPBITMAPINFO)lpMungeInfo, DIB_RGB_COLORS, SRCCOPY);
#ifdef UNIX
          if (MwGetTrueRGBValue(GetSysColor(COLOR_WINDOW)) != 0xffffff)
#endif
          BitBlt(hdcMem, 0, 0, wid, hgt, hdcMem, wid, 0, 0x00220326);   // DSna
      }
      SelectObject(hdcMem, hbmOld);
  }

cleanup:
  if (hdcMem)
      DeleteObject(hdcMem);
  ReleaseDC(NULL, hdc);

  GlobalFree(lpMungeInfo);

Exit1:
  UnlockResource(hRes);
  FreeResource(hRes);

  return hbm;
}

// moved from shelldll\dragdrop.c

// should caller pass in message that indicates termination
// (WM_LBUTTONUP, WM_RBUTTONUP)?
//
// in:
//      hwnd    to do check on
//      x, y    in client coordinates
//
// returns:
//      TRUE    the user began to drag (moved mouse outside double click rect)
//      FALSE   mouse came up inside click rect
//
// BUGBUG, should support VK_ESCAPE to cancel

BOOL PASCAL CheckForDragBegin(HWND hwnd, int x, int y)
{
    RECT rc;
    int dxClickRect = GetSystemMetrics(SM_CXDRAG);
    int dyClickRect = GetSystemMetrics(SM_CYDRAG);

    if (dxClickRect < 4)
    {
        dxClickRect = dyClickRect = 4;
    }

    // See if the user moves a certain number of pixels in any direction

    SetRect(&rc, x - dxClickRect, y - dyClickRect, x + dxClickRect, y + dyClickRect);
    MapWindowRect(hwnd, HWND_DESKTOP, &rc); // client -> screen

    //
    //  SUBTLE!  We use PeekMessage+WaitMessage instead of GetMessage,
    //  because WaitMessage will return when there is an incoming
    //  SendMessage, whereas GetMessage does not.  This is important,
    //  because the incoming message might've been WM_CAPTURECHANGED.
    //

    SetCapture(hwnd);
    do {
        MSG32 msg32;
        if (PeekMessage32(&msg32, NULL, 0, 0, PM_REMOVE, TRUE))
        {
            // See if the application wants to process the message...
            if (CallMsgFilter32(&msg32, MSGF_COMMCTRL_BEGINDRAG, TRUE) != 0)
                continue;

            switch (msg32.message) {
            case WM_LBUTTONUP:
            case WM_RBUTTONUP:
            case WM_LBUTTONDOWN:
            case WM_RBUTTONDOWN:
                ReleaseCapture();
                return FALSE;

            case WM_MOUSEMOVE:
                if (IsWindow(hwnd) && !PtInRect(&rc, msg32.pt)) {
                    ReleaseCapture();
                    return TRUE;
                }
                break;

            default:
                TranslateMessage32(&msg32, TRUE);
                DispatchMessage32(&msg32, TRUE);
                break;
            }
        }
        else WaitMessage();

        // WM_CANCELMODE messages will unset the capture, in that
        // case I want to exit this loop
    } while (IsWindow(hwnd) && GetCapture() == hwnd);

    return FALSE;
}


/* Regular StrToInt; stops at first non-digit. */

int WINAPI StrToInt(LPCTSTR lpSrc)      // atoi()
{

#define ISDIGIT(c)  ((c) >= TEXT('0') && (c) <= TEXT('9'))

    int n = 0;
    BOOL bNeg = FALSE;

    if (*lpSrc == TEXT('-')) {
        bNeg = TRUE;
        lpSrc++;
    }

    while (ISDIGIT(*lpSrc)) {
        n *= 10;
        n += *lpSrc - TEXT('0');
        lpSrc++;
    }
    return bNeg ? -n : n;
}

#ifdef UNICODE

//
// Wrappers for StrToInt
//

int WINAPI StrToIntA(LPCSTR lpSrc)      // atoi()
{
    LPWSTR lpString;
    INT    iResult;

    lpString = ProduceWFromA (CP_ACP, lpSrc);

    if (!lpString) {
        return 0;
    }

    iResult = StrToIntW(lpString);

    FreeProducedString (lpString);

    return iResult;

}

#else

//
// Stub W version when Built ANSI
//
#ifndef UNIX
int WINAPI StrToIntW(LPCWSTR lpSrc)      // atoi()
{
    SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING);
    return 0;
}
#endif /* !UNIX */

#endif



#undef StrToLong

#ifdef WIN32

//
// No need to Unicode this since it is not
// exported.
//

LONG WINAPI StrToLong(LPCTSTR lpSrc)    // atoi()
{
    return StrToInt(lpSrc);
}

#else

/* Regular StrToLong; stops at first non-digit. */

LONG WINAPI StrToLong(LPCSTR lpSrc)     // atoi()
{

#define ISDIGIT(c)  ((c) >= '0' && (c) <= '9')

    LONG n = 0;
    BOOL bNeg = FALSE;

    if (*lpSrc == TEXT('-')) {
        bNeg = TRUE;
        lpSrc++;
    }

    while (ISDIGIT(*lpSrc)) {
        n *= 10;
        n += *lpSrc - TEXT('0');
        lpSrc++;
    }
    return bNeg ? -n : n;

}
#endif

#pragma code_seg(CODESEG_INIT)

//
// From zmouse.h in the Magellan SDK
//

#define MSH_MOUSEWHEEL TEXT("MSWHEEL_ROLLMSG")

// Class name for Magellan/Z MSWHEEL window
// use FindWindow to get hwnd to MSWHEEL
#define MOUSEZ_CLASSNAME  TEXT("MouseZ")           // wheel window class
#define MOUSEZ_TITLE      TEXT("Magellan MSWHEEL") // wheel window title

#define MSH_WHEELMODULE_CLASS (MOUSEZ_CLASSNAME)
#define MSH_WHEELMODULE_TITLE (MOUSEZ_TITLE)

#define MSH_SCROLL_LINES  TEXT("MSH_SCROLL_LINES_MSG")

#define DI_GETDRAGIMAGE TEXT("ShellGetDragImage")       // Copied from Shlobj.w

UINT g_msgMSWheel;
UINT g_ucScrollLines = 3;                        /* default */
int  gcWheelDelta;
UINT g_uDragImages;

void FAR PASCAL InitGlobalMetrics(WPARAM wParam)
{
    static BOOL fInitMouseWheel;
    static HWND hwndMSWheel;
    static UINT msgMSWheelGetScrollLines;

    if (!fInitMouseWheel)
    {
        fInitMouseWheel = TRUE;

        if (g_bRunOnNT || g_bRunOnMemphis)
            g_msgMSWheel = WM_MOUSEWHEEL;
        else
        {
            g_msgMSWheel = RegisterWindowMessage(MSH_MOUSEWHEEL);
            msgMSWheelGetScrollLines = RegisterWindowMessage(MSH_SCROLL_LINES);
            hwndMSWheel = FindWindow(MSH_WHEELMODULE_CLASS, MSH_WHEELMODULE_TITLE);
        }
    }

    g_uDragImages = RegisterWindowMessage(DI_GETDRAGIMAGE);

#ifndef UNIX
    if (g_bRunOnNT || g_bRunOnMemphis)
    {
        SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, &g_ucScrollLines, 0);
    }
    else if (hwndMSWheel && msgMSWheelGetScrollLines)
    {
        g_ucScrollLines =
              (UINT)SendMessage(hwndMSWheel, msgMSWheelGetScrollLines, 0, 0);
    }
#endif

    // bug fix HACK: these are NOT members of USER's NONCLIENTMETRICS struct
    g_cxIcon = GetSystemMetrics(SM_CXICON);
    g_cyIcon = GetSystemMetrics(SM_CYICON);
    g_cxSmIcon = GetSystemMetrics(SM_CXSMICON);
    g_cySmIcon = GetSystemMetrics(SM_CYSMICON);

    g_cxIconSpacing = GetSystemMetrics( SM_CXICONSPACING );
    g_cyIconSpacing = GetSystemMetrics( SM_CYICONSPACING );

    // Full window drag stays off if running remotely
    if (!g_bRemoteSession &&
        (wParam == 0 || wParam == SPI_SETDRAGFULLWINDOWS)) {
        SystemParametersInfo(SPI_GETDRAGFULLWINDOWS, sizeof(g_fDragFullWindows), &g_fDragFullWindows, 0);
    }

    // Smooth scrolling stays off if running remotely
    if (!g_bRemoteSession) {
        HKEY hkey;

        g_fSmoothScroll = TRUE;

        if (RegOpenKeyEx(HKEY_CURRENT_USER, TEXT("Control Panel\\Desktop"), 0, KEY_READ, &hkey) == ERROR_SUCCESS) {
            DWORD dwSize = sizeof(g_fSmoothScroll);
            RegQueryValueEx(hkey, TEXT("SmoothScroll"), 0, NULL, (LPBYTE)&g_fSmoothScroll, &dwSize);
            RegCloseKey(hkey);
        }
    }

    if (g_bRemoteSession)
    {
        // Nobody should've turned these on
        ASSERT(g_fDragFullWindows == FALSE);
        ASSERT(g_fSmoothScroll == FALSE);
    }

    // BUGBUG: some of these are also not members of NONCLIENTMETRICS
    if ((wParam == 0) || (wParam == SPI_SETNONCLIENTMETRICS))
    {
        NONCLIENTMETRICS ncm;

        // REVIEW, make sure all these vars are used somewhere.
        g_cxEdge = GetSystemMetrics(SM_CXEDGE);
        g_cyEdge = GetSystemMetrics(SM_CYEDGE);
        g_cxBorder = GetSystemMetrics(SM_CXBORDER);
        g_cyBorder = GetSystemMetrics(SM_CYBORDER);
        g_cxScreen = GetSystemMetrics(SM_CXSCREEN);
        g_cyScreen = GetSystemMetrics(SM_CYSCREEN);
        g_cxFrame  = GetSystemMetrics(SM_CXFRAME);
        g_cyFrame  = GetSystemMetrics(SM_CYFRAME);

        ncm.cbSize = sizeof(ncm);
        SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0);

        g_cxVScroll = g_cxScrollbar = (int)ncm.iScrollWidth;
        g_cyHScroll = g_cyScrollbar = (int)ncm.iScrollHeight;

        // this is true for 4.0 modules only
        // for 3.x modules user lies and adds one to these values
        // ASSERT(g_cxVScroll == GetSystemMetrics(SM_CXVSCROLL));
        // ASSERT(g_cyHScroll == GetSystemMetrics(SM_CYHSCROLL));

        g_cxIconMargin = g_cxBorder * 8;
        g_cyIconMargin = g_cyEdge;
        g_cyLabelSpace = g_cyIconMargin + (g_cyEdge);
        g_cxLabelMargin = g_cxEdge;

        g_cxDoubleClk = GetSystemMetrics(SM_CXDOUBLECLK);
        g_cyDoubleClk = GetSystemMetrics(SM_CYDOUBLECLK);
    }

#if defined(UNIX)
    g_dwHoverSelectTimeout = 0;
#elif defined(WINNT) && defined(SPI_GETMOUSEHOVERTIME)
    //NT 4.0 has this SPI_GETMOUSEHOVERTIME
    SystemParametersInfo(SPI_GETMOUSEHOVERTIME, 0, &g_dwHoverSelectTimeout, 0);
#else
    // For Win95, we get this from the registry directly.
    {
        HKEY  hkey;
        DWORD dwType;

        g_dwHoverSelectTimeout = 0;
        if (RegOpenKeyEx(HKEY_CURRENT_USER, TEXT("Control Panel\\Mouse"), 0, KEY_READ, &hkey) == ERROR_SUCCESS) {
            DWORD dwSize = sizeof(g_dwHoverSelectTimeout);
            if((RegQueryValueEx(hkey, TEXT("MouseHoverTime"), 0, &dwType, (LPBYTE)&g_dwHoverSelectTimeout, &dwSize) != ERROR_SUCCESS) ||
               (dwType != REG_DWORD))
                g_dwHoverSelectTimeout = 0;

            RegCloseKey(hkey);
        }
    }
#endif
}

void FAR PASCAL InitGlobalColors()
{
    g_clrWindow = GetSysColor(COLOR_WINDOW);
    g_clrWindowText = GetSysColor(COLOR_WINDOWTEXT);
    g_clrWindowFrame = GetSysColor(COLOR_WINDOWFRAME);
    g_clrGrayText = GetSysColor(COLOR_GRAYTEXT);
    g_clrBtnText = GetSysColor(COLOR_BTNTEXT);
    g_clrBtnFace = GetSysColor(COLOR_BTNFACE);
    g_clrBtnShadow = GetSysColor(COLOR_BTNSHADOW);
    g_clrBtnHighlight = GetSysColor(COLOR_BTNHIGHLIGHT);
    g_clrHighlight = GetSysColor(COLOR_HIGHLIGHT);
    g_clrHighlightText = GetSysColor(COLOR_HIGHLIGHTTEXT);
    g_clrInfoText = GetSysColor(COLOR_INFOTEXT);
    g_clrInfoBk = GetSysColor(COLOR_INFOBK);
    g_clr3DDkShadow = GetSysColor(COLOR_3DDKSHADOW);
    g_clr3DLight = GetSysColor(COLOR_3DLIGHT);

    g_hbrGrayText = GetSysColorBrush(COLOR_GRAYTEXT);
    g_hbrWindow = GetSysColorBrush(COLOR_WINDOW);
    g_hbrWindowText = GetSysColorBrush(COLOR_WINDOWTEXT);
    g_hbrWindowFrame = GetSysColorBrush(COLOR_WINDOWFRAME);
    g_hbrBtnFace = GetSysColorBrush(COLOR_BTNFACE);
    g_hbrBtnHighlight = GetSysColorBrush(COLOR_BTNHIGHLIGHT);
    g_hbrBtnShadow = GetSysColorBrush(COLOR_BTNSHADOW);
    g_hbrHighlight = GetSysColorBrush(COLOR_HIGHLIGHT);
    g_hfontSystem = GetStockObject(SYSTEM_FONT);
}

#pragma code_seg()

void FAR PASCAL RelayToToolTips(HWND hwndToolTips, HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    if(hwndToolTips) {
        MSG msg;
        msg.lParam = lParam;
        msg.wParam = wParam;
        msg.message = wMsg;
        msg.hwnd = hWnd;
        SendMessage(hwndToolTips, TTM_RELAYEVENT, 0, (LPARAM)(LPMSG)&msg);
    }
}

#define DT_SEARCHTIMEOUT    1000L       // 1 seconds

__inline BOOL IsISearchTimedOut(PISEARCHINFO pis)
{
    return GetMessageTime() - pis->timeLast > DT_SEARCHTIMEOUT &&
           !IsFlagSet(g_dwPrototype, PTF_NOISEARCHTO);

}

int FAR PASCAL GetIncrementSearchString(PISEARCHINFO pis, LPTSTR lpsz)
{
    if (IsISearchTimedOut(pis))
    {
        pis->iIncrSearchFailed = 0;
        pis->ichCharBuf = 0;
    }

    if (pis->ichCharBuf && lpsz) {
        lstrcpyn(lpsz, pis->pszCharBuf, pis->ichCharBuf + 1);
        lpsz[pis->ichCharBuf] = TEXT('\0');
    }
    return pis->ichCharBuf;
}

#if defined(FE_IME) 
// Now only Korean version is interested in incremental search with composition string.
BOOL FAR PASCAL IncrementSearchImeCompStr(PISEARCHINFO pis, BOOL fCompStr, LPTSTR lpszCompStr, LPTSTR FAR *lplpstr)
{
    BOOL fRestart = FALSE;

    if (!pis->fReplaceCompChar && IsISearchTimedOut(pis))
    {
        pis->iIncrSearchFailed = 0;
        pis->ichCharBuf = 0;
    }

    if (pis->ichCharBuf == 0)
    {
        fRestart = TRUE;
        pis->fReplaceCompChar = FALSE;
    }
    pis->timeLast = GetMessageTime();

    // Is there room for new character plus zero terminator?
    //
#ifdef UNICODE
    if (!pis->fReplaceCompChar && pis->ichCharBuf + 1 + 1 > pis->cbCharBuf)
#else
    if (!pis->fReplaceCompChar && pis->ichCharBuf + 2 + 1 > pis->cbCharBuf)
#endif
    {
        LPTSTR psz = ReAlloc(pis->pszCharBuf, sizeof(TCHAR)*(pis->cbCharBuf + 16));
        if (!psz)
            return fRestart;

        pis->cbCharBuf += 16;
        pis->pszCharBuf = psz;
    }

    if (pis->fReplaceCompChar)
    {
        if (lpszCompStr[0])
        {
#ifdef UNICODE
            pis->pszCharBuf[pis->ichCharBuf-1] = lpszCompStr[0];
#else
            pis->pszCharBuf[pis->ichCharBuf-2] = lpszCompStr[0];
            pis->pszCharBuf[pis->ichCharBuf-1] = lpszCompStr[1];
#endif
            pis->pszCharBuf[pis->ichCharBuf] = 0;
        }
        else
        {
#ifdef UNICODE
            pis->ichCharBuf--;
#else
            pis->ichCharBuf -= 2;
#endif
            pis->pszCharBuf[pis->ichCharBuf] = 0;
        }
    }
    else
    {
#ifdef UNICODE
        pis->pszCharBuf[pis->ichCharBuf++] = lpszCompStr[0];
#else
        pis->pszCharBuf[pis->ichCharBuf++] = lpszCompStr[0];
        pis->pszCharBuf[pis->ichCharBuf++] = lpszCompStr[1];
#endif
        pis->pszCharBuf[pis->ichCharBuf] = 0;
    }

    pis->fReplaceCompChar = (fCompStr && lpszCompStr[0]);

#ifdef UNICODE
    if (pis->ichCharBuf == 1 && pis->fReplaceCompChar)
#else
    if (pis->ichCharBuf == 2 && pis->fReplaceCompChar)
#endif
        fRestart = TRUE;

    *lplpstr = pis->pszCharBuf;

    return fRestart;

}
#endif FE_IME

#ifdef UNICODE
/*
 * Thunk for LVM_GETISEARCHSTRINGA
 */
int FAR PASCAL GetIncrementSearchStringA(PISEARCHINFO pis, UINT uiCodePage, LPSTR lpsz)
{
    if (IsISearchTimedOut(pis))
    {
        pis->iIncrSearchFailed = 0;
        pis->ichCharBuf = 0;
    }

    if (pis->ichCharBuf && lpsz) {
        ConvertWToAN( uiCodePage, lpsz, pis->ichCharBuf, pis->pszCharBuf, pis->ichCharBuf );
        lpsz[pis->ichCharBuf] = '\0';
    }
    return pis->ichCharBuf;
}
#endif

// Beep only on the first failure.

void FAR PASCAL IncrementSearchBeep(PISEARCHINFO pis)
{
    if (!pis->iIncrSearchFailed)
    {
        pis->iIncrSearchFailed = TRUE;
        MessageBeep(0);
    }
}

//
//  IncrementSearchString - Add or clear the search string
//
//      ch == 0:  Reset the search string.  Return value meaningless.
//
//      ch != 0:  Append the character to the search string, starting
//                a new search string if we timed out the last one.
//                lplpstr receives the string so far.
//                Return value is TRUE if a new search string was
//                created, or FALSE if we appended to an existing one.
//

BOOL FAR PASCAL IncrementSearchString(PISEARCHINFO pis, UINT ch, LPTSTR FAR *lplpstr)
{
    BOOL fRestart = FALSE;

    if (!ch) {
        pis->ichCharBuf =0;
        pis->iIncrSearchFailed = 0;
        return FALSE;
    }

    if (IsISearchTimedOut(pis))
    {
        pis->iIncrSearchFailed = 0;
        pis->ichCharBuf = 0;
    }

    if (pis->ichCharBuf == 0)
        fRestart = TRUE;

    pis->timeLast = GetMessageTime();

    // Is there room for new character plus zero terminator?
    //
    if (pis->ichCharBuf + 1 + 1 > pis->cbCharBuf)
    {
        LPTSTR psz = ReAlloc(pis->pszCharBuf, ((pis->cbCharBuf + 16) * sizeof(TCHAR)));
        if (!psz)
            return fRestart;

        pis->cbCharBuf += 16;
        pis->pszCharBuf = psz;
    }

    pis->pszCharBuf[pis->ichCharBuf++] = (TCHAR)ch;
    pis->pszCharBuf[pis->ichCharBuf] = 0;

    *lplpstr = pis->pszCharBuf;

    return fRestart;
}

// strips out the accelerators.  they CAN be the same buffers.
void PASCAL StripAccelerators(LPTSTR lpszFrom, LPTSTR lpszTo, BOOL fAmpOnly)
{

    BOOL fRet = FALSE;

    while ( *lpszTo = *lpszFrom ) {
#if !defined(UNICODE)  //  && defined(DBCS)
        if (IsDBCSLeadByte(*lpszFrom)) {
            (*((WORD FAR*)lpszTo)) = (*((WORD FAR *)lpszFrom));
            lpszTo += 2;
            lpszFrom += 2;
            continue;
        }
#endif
        if (!fAmpOnly && (g_fDBCSInputEnabled))
        {
            if (*lpszFrom == TEXT('(') && *(lpszFrom+1)==CH_PREFIX)
            {
                int i;
                LPTSTR psz = lpszFrom+2;

                for(i=0; i<2 && *psz;i++, psz=FastCharNext(psz))
                    ;


                if (*psz == '\0') {
                    *lpszTo = 0;
                    break;
                }
                else if (i == 2 && *psz == TEXT(')'))
                {
                    lpszTo--;
                    lpszFrom = psz+1;
                    continue;
                }
            }
        }

        if (*lpszFrom == TEXT('\t')) {
            *lpszTo = TEXT('\0');
            break;
        }

        if ( (*lpszFrom++ != CH_PREFIX) || (*lpszFrom == CH_PREFIX) ) {
            lpszTo++;
        }
    }
}


void ScrollShrinkRect(int x, int y, LPRECT lprc)
{
    if (lprc) {
        if (x > 0) {
            lprc->left += x;
        } else {
            lprc->right += x;
        }

        if (y > 0) {
            lprc->top += y;
        } else {
            lprc->bottom += y;
        }

    }
}



// common control info helpers
void FAR PASCAL CIInitialize(LPCONTROLINFO lpci, HWND hwnd, LPCREATESTRUCT lpcs)
{
    lpci->hwnd = hwnd;
    lpci->hwndParent = lpcs->hwndParent;
    lpci->style = lpcs->style;
    lpci->uiCodePage = CP_ACP;
    lpci->dwExStyle = lpcs->dwExStyle;

    lpci->bUnicode = lpci->hwndParent &&
                     SendMessage (lpci->hwndParent, WM_NOTIFYFORMAT,
                                 (WPARAM)lpci->hwnd, NF_QUERY) == NFR_UNICODE;

#ifdef KEYBOARDCUES
    if (lpci->hwndParent)
    {
        LRESULT lRes = SendMessage(lpci->hwndParent, WM_QUERYUISTATE, 0, 0);
            lpci->wUIState = LOWORD(lRes);
    }
#endif
}

LRESULT FAR PASCAL CIHandleNotifyFormat(LPCONTROLINFO lpci, LPARAM lParam)
{
    if (lParam == NF_QUERY) {
#ifdef UNICODE
        return NFR_UNICODE;
#else
        return NFR_ANSI;
#endif
    } else if (lParam == NF_REQUERY) {
        LRESULT uiResult;

        uiResult = SendMessage (lpci->hwndParent, WM_NOTIFYFORMAT,
                                (WPARAM)lpci->hwnd, NF_QUERY);

        lpci->bUnicode = BOOLIFY(uiResult == NFR_UNICODE);

        return uiResult;
    }
    return 0;
}

UINT CCSwapKeys(WPARAM wParam, UINT vk1, UINT vk2)
{
    if (wParam == vk1)
        return vk2;
    if (wParam == vk2)
        return vk1;
    return (UINT)wParam;
}

UINT RTLSwapLeftRightArrows(CONTROLINFO *pci, WPARAM wParam)
{
    if (pci->dwExStyle & RTL_MIRRORED_WINDOW) {
        return CCSwapKeys(wParam, VK_LEFT, VK_RIGHT);
    }
    return (UINT)wParam;
}

//
//  New for v5.01:
//
//  Accessibility (and some other callers, sometimes even us) relies on
//  a XXM_GETITEM call filling the buffer and not just redirecting the
//  pointer.  Accessibility is particularly impacted by this because they
//  live outside the process, so the redirected pointer means nothing
//  to them.  Here, we copy the result back into the app buffer and return
//  the raw pointer.  The caller will return the raw pointer back to the
//  app, so the answer is in two places, either the app buffer, or in
//  the raw pointer.
//
//  Usage:
//
//      if (nm.item.mask & LVIF_TEXT)
//          pitem->pszText = CCReturnDispInfoText(nm.item.pszText,
//                              pitem->pszText, pitem->cchTextMax);
//
LPTSTR CCReturnDispInfoText(LPTSTR pszSrc, LPTSTR pszDest, UINT cchDest)
{
    // Test pszSrc != pszDest first since the common case is that they
    // are equal.
    if (pszSrc != pszDest && !IsFlagPtr(pszSrc) && !IsFlagPtr(pszDest))
        StrCpyN(pszDest, pszSrc, cchDest);
    return pszSrc;
}

#define SUBSCROLLS 100
#define abs(x) ( ( x > 0 ) ? x : -x)


#define DEFAULT_MAXSCROLLTIME ((GetDoubleClickTime() / 2) + 1)  // Ensure >= 1
#define DEFAULT_MINSCROLL 8
int SmoothScrollWindow(PSMOOTHSCROLLINFO psi)
{
    int dx = psi->dx;
    int dy = psi->dy;
    LPCRECT lprcSrc = psi->lprcSrc;
    LPCRECT lprcClip = psi->lprcClip;
    HRGN hrgnUpdate = psi->hrgnUpdate;
    LPRECT lprcUpdate = psi->lprcUpdate;
    UINT fuScroll = psi->fuScroll;
    int iRet = SIMPLEREGION;
    RECT rcUpdate;
    RECT rcSrc;
    RECT rcClip;
    int xStep;
    int yStep;
    int iSlicesDone = 0;
    int iSlices;
    DWORD dwTimeStart, dwTimeNow;
    HRGN hrgnLocalUpdate;
    UINT cxMinScroll = psi->cxMinScroll;
    UINT cyMinScroll = psi->cyMinScroll;
    UINT uMaxScrollTime = psi->uMaxScrollTime;
    int iSubScrolls;
    PFNSMOOTHSCROLLPROC pfnScrollProc;

    if (!lprcUpdate)
        lprcUpdate = &rcUpdate;
    SetRectEmpty(lprcUpdate);

    if (psi->cbSize != sizeof(SMOOTHSCROLLINFO))
        return 0;

    // check the defaults
    if (!(psi->fMask & SSIF_MINSCROLL )
        || cxMinScroll == SSI_DEFAULT)
        cxMinScroll = DEFAULT_MINSCROLL;

    if (!(psi->fMask & SSIF_MINSCROLL)
        || cyMinScroll == SSI_DEFAULT)
        cyMinScroll = DEFAULT_MINSCROLL;

    if (!(psi->fMask & SSIF_MAXSCROLLTIME)
        || uMaxScrollTime == SSI_DEFAULT)
        uMaxScrollTime = DEFAULT_MAXSCROLLTIME;

    if (uMaxScrollTime < SUBSCROLLS)
        uMaxScrollTime = SUBSCROLLS;


    if ((!(fuScroll & SSW_EX_IGNORESETTINGS)) &&
        (!g_fSmoothScroll)) {
        fuScroll |= SSW_EX_IMMEDIATE;
    }

    if ((psi->fMask & SSIF_SCROLLPROC) && psi->pfnScrollProc) {
        pfnScrollProc = psi->pfnScrollProc;
    } else {
        pfnScrollProc = ScrollWindowEx;
    }

#ifdef ScrollWindowEx
#undef ScrollWindowEx
#endif

    if (fuScroll & SSW_EX_IMMEDIATE) {
        return pfnScrollProc(psi->hwnd, dx, dy, lprcSrc, lprcClip, hrgnUpdate,
                             lprcUpdate, LOWORD(fuScroll));
    }

    // copy input rects locally
    if (lprcSrc)  {
        rcSrc = *lprcSrc;
        lprcSrc = &rcSrc;
    }
    if (lprcClip) {
        rcClip = *lprcClip;
        lprcClip = &rcClip;
    }

    if (!hrgnUpdate)
        hrgnLocalUpdate = CreateRectRgn(0,0,0,0);
    else
        hrgnLocalUpdate = hrgnUpdate;

    //set up initial vars
    dwTimeStart = GetTickCount();

    if (fuScroll & SSW_EX_NOTIMELIMIT) {
        xStep = cxMinScroll * (dx < 0 ? -1 : 1);
        yStep = cyMinScroll * (dy < 0 ? -1 : 1);
    } else {
        iSubScrolls = (uMaxScrollTime / DEFAULT_MAXSCROLLTIME) * SUBSCROLLS;
        if (!iSubScrolls)
            iSubScrolls = SUBSCROLLS;
        xStep = dx / iSubScrolls;
        yStep = dy / iSubScrolls;
    }

    if (xStep == 0 && dx)
        xStep = dx < 0 ? -1 : 1;

    if (yStep == 0 && dy)
        yStep = dy < 0 ? -1 : 1;

    while (dx || dy) {
        int x,y;
        RECT rcTempUpdate;

        if (fuScroll & SSW_EX_NOTIMELIMIT) {
            x = xStep;
            y = yStep;
            if (abs(x) > abs(dx))
                x = dx;

            if (abs(y) > abs(dy))
                y = dy;

        } else {
            int iTimePerScroll = uMaxScrollTime / iSubScrolls;
            if (!iTimePerScroll)
                iTimePerScroll = 1;
            
            dwTimeNow = GetTickCount();

            iSlices = ((dwTimeNow - dwTimeStart) / iTimePerScroll) - iSlicesDone;
            if (iSlices < 0)
                iSlices = 0;


            do {

                int iRet = 0;

                iSlices++;
                if ((iSlicesDone + iSlices) <= iSubScrolls) {
                    x = xStep * iSlices;
                    y = yStep * iSlices;

                    // this could go over if we rounded ?Step up to 1(-1) above
                    if (abs(x) > abs(dx))
                        x = dx;

                    if (abs(y) > abs(dy))
                        y = dy;

                } else {
                    x = dx;
                    y = dy;
                }

                //DebugMsg(DM_TRACE, "SmoothScrollWindowCallback %d", iRet);

                if (x == dx && y == dy)
                    break;

                if ((((UINT)(abs(x)) >= cxMinScroll) || !x) &&
                    (((UINT)(abs(y)) >= cyMinScroll) || !y))
                    break;

            } while (1);
        }

        if (pfnScrollProc(psi->hwnd, x, y, lprcSrc, lprcClip, hrgnLocalUpdate, &rcTempUpdate, LOWORD(fuScroll)) == ERROR) {
            iRet = ERROR;
            goto Bail;
        }

        // we don't need to do this always because if iSlices >= iSlicesDone, we'll have scrolled blanks
        //if (iSlices < iSlicesDone)
        RedrawWindow(psi->hwnd, NULL, hrgnLocalUpdate, RDW_ERASE | RDW_ERASENOW | RDW_INVALIDATE);

        UnionRect(lprcUpdate, &rcTempUpdate, lprcUpdate);

        ScrollShrinkRect(x,y, (LPRECT)lprcSrc);
        ScrollShrinkRect(x,y, (LPRECT)lprcClip);

        dx -= x;
        dy -= y;
        iSlicesDone += iSlices;
    }

Bail:

    if (fuScroll & SW_SCROLLCHILDREN) {
        RedrawWindow(psi->hwnd, lprcUpdate, NULL, RDW_INVALIDATE);
    }

    if (hrgnLocalUpdate != hrgnUpdate)
        DeleteObject(hrgnLocalUpdate);

    return iRet;
}



typedef BOOL (WINAPI *PLAYSOUNDFN)(LPCTSTR lpsz, HANDLE hMod, DWORD dwFlags);
typedef UINT (WINAPI *UINTVOIDFN)();

TCHAR const c_szWinMMDll[] = TEXT("winmm.dll");
#ifdef UNICODE
char const c_szPlaySound[] = "PlaySoundW";
#else
char const c_szPlaySound[] = "PlaySoundA";
#endif
char const c_szwaveOutGetNumDevs[] = "waveOutGetNumDevs";
extern TCHAR const c_szExplorer[];

#define CCH_KEYMAX 256
BOOL g_fNeverPlaySound = FALSE;

void CCPlaySound(LPCTSTR lpszName)
{
    TCHAR szFileName[MAX_PATH];
    LONG cbSize = SIZEOF(szFileName);
    TCHAR szKey[CCH_KEYMAX];

    if (g_fNeverPlaySound)
        return;

    // check the registry first
    // if there's nothing registered, we blow off the play,
    // but we don't set the MM_DONTLOAD flag so taht if they register
    // something we will play it
    wsprintf(szKey, TEXT("AppEvents\\Schemes\\Apps\\.Default\\%s\\.current"), lpszName);
    if ((RegQueryValue(HKEY_CURRENT_USER, szKey, szFileName, &cbSize) == ERROR_SUCCESS) &&
        (cbSize > SIZEOF(szFileName[0]))) {

        PLAYSOUNDFN pfnPlaySound;
        UINTVOIDFN pfnwaveOutGetNumDevs;

        HANDLE hMM;
    
        hMM = GetModuleHandle(c_szWinMMDll);
        if (!hMM)
            hMM = LoadLibrary(c_szWinMMDll);
    
        if (!hMM)
            return;
    
        /// are there any devices?
        pfnwaveOutGetNumDevs = (UINTVOIDFN)GetProcAddress(hMM, c_szwaveOutGetNumDevs);
        pfnPlaySound = (PLAYSOUNDFN)GetProcAddress(hMM, c_szPlaySound);
        if (!pfnPlaySound || !pfnwaveOutGetNumDevs || !pfnwaveOutGetNumDevs()) {
            g_fNeverPlaySound = TRUE;
            return;
        }

        pfnPlaySound(szFileName, NULL, SND_FILENAME | SND_ASYNC);
    }
}

BOOL CCForwardEraseBackground(HWND hwnd, HDC hdc)
{
    HWND hwndParent = GetParent(hwnd);
    LRESULT lres = 0;

    if (hwndParent)
    {
        // Adjust the origin so the parent paints in the right place
        POINT pt = {0,0};

        MapWindowPoints(hwnd, hwndParent, &pt, 1);
        OffsetWindowOrgEx(hdc, 
                          pt.x, 
                          pt.y, 
                          &pt);

        lres = SendMessage(hwndParent, WM_ERASEBKGND, (WPARAM) hdc, 0L);

        SetWindowOrgEx(hdc, pt.x, pt.y, NULL);
    }
    return(lres != 0);
}

HFONT CCGetHotFont(HFONT hFont, HFONT *phFontHot)
{
    if (!*phFontHot) {
        LOGFONT lf;

        // create the underline font
        GetObject(hFont, sizeof(lf), &lf);
#ifndef DONT_UNDERLINE
        lf.lfUnderline = TRUE;
#endif
        *phFontHot = CreateFontIndirect(&lf);
    }
    return *phFontHot;
}


HFONT CCCreateStatusFont(void)
{
    NONCLIENTMETRICS ncm;

    ncm.cbSize = sizeof(NONCLIENTMETRICS);
    SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0);

    return CreateFontIndirect(&ncm.lfStatusFont);
}

void* CCLocalReAlloc(void* p, UINT uBytes)
{
    if (uBytes) {
        if (p) {
            return LocalReAlloc(p, uBytes, LMEM_MOVEABLE | LMEM_ZEROINIT);
        } else {
            return LocalAlloc(LPTR, uBytes);
        }
    } else {
        if (p)
            LocalFree(p);
        return NULL;
    }
}

/*----------------------------------------------------------
Purpose: This function provides the commctrl version info.  This
         allows the caller to distinguish running NT SUR vs.
         Win95 shell vs. Nashville, etc.

         This API was not supplied in Win95 or NT SUR, so
         the caller must GetProcAddress it.  If this fails,
         the caller is running on Win95 or NT SUR.

Returns: NO_ERROR
         ERROR_INVALID_PARAMETER if pinfo is invalid

Cond:    --
*/

// All we have to do is declare this puppy and CCDllGetVersion does the rest
// Note that we use VER_FILEVERSION_DW because comctl32 uses a funky
// version scheme
DLLVER_DUALBINARY(VER_FILEVERSION_DW, VER_PRODUCTBUILD_QFE);

//
// Translate the given font to a code page used for thunking text
//
UINT GetCodePageForFont (HFONT hFont)
{
#ifdef WINNT
    LOGFONT lf;
    TCHAR szFontName[MAX_PATH];
    CHARSETINFO csi;
    DWORD dwSize, dwType;
    HKEY hKey;


    if (!GetObject (hFont, sizeof(lf), &lf)) {
        return CP_ACP;
    }


    //
    // Check for font substitutes
    //

    lstrcpy (szFontName, lf.lfFaceName);

    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                      TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\FontSubstitutes"),
                      0, KEY_READ, &hKey) == ERROR_SUCCESS) {

        dwSize = MAX_PATH * sizeof(TCHAR);
        RegQueryValueEx (hKey, lf.lfFaceName, NULL, &dwType,
                         (LPBYTE) szFontName, &dwSize);

        RegCloseKey (hKey);
    }


    //
    //  This is to fix office for locales that use non 1252 versions
    //  of Ms Sans Serif and Ms Serif.  These fonts incorrectly identify
    //  themselves as having an Ansi charset, so TranslateCharsetInfo will
    //  return the wrong value.
    //
    //  NT bug 260697: Office 2000 uses Tahoma.
    //
    if ((lf.lfCharSet == ANSI_CHARSET) &&
        (!lstrcmpi(L"Helv", szFontName) ||
         !lstrcmpi(L"Ms Sans Serif", szFontName) ||
         !lstrcmpi(L"Ms Serif", szFontName) ||
         !lstrcmpi(L"Tahoma", szFontName)))
    {
        return CP_ACP;
    }
    //
    //  This is to fix FE office95a and Pro. msofe95.dll sets wrong charset when create
    //  listview control. so TranslateCharsetInfo will return the wrong value.
    //  Korea  : DotumChe.
    //  Taiwan : New MingLight
    //  China  : SongTi

    if ((lf.lfCharSet == SHIFTJIS_CHARSET) &&
        (!lstrcmpi(L"\xb3cb\xc6c0\xccb4", lf.lfFaceName))        || // Korea
        (!lstrcmpi(L"\x65b0\x7d30\x660e\x9ad4", lf.lfFaceName))  || // Taiwan
        (!lstrcmpi(L"\x5b8b\x4f53", lf.lfFaceName)))                // PRC
    {
        return CP_ACP;
    }

    if (!TranslateCharsetInfo((DWORD FAR *) lf.lfCharSet, &csi, TCI_SRCCHARSET)) {
        return CP_ACP;
    }

    return csi.ciACP;
#else

    return CP_ACP;

#endif
}

typedef void (CALLBACK* NOTIFYWINEVENTPROC)(UINT, HWND, LONG, LONG_PTR);

#define DONOTHING_NOTIFYWINEVENT ((NOTIFYWINEVENTPROC)1)

// --------------------------------------------------------------------------
//
//  MyNotifyWinEvent()
//
//  This tries to get the proc address of NotifyWinEvent().  If it fails, we
//  remember that and do nothing.
//
//  NOTE TO NT FOLKS:
//  Don't worry about this code.  It will do nothing on NT, nothing yet
//  that is.  Active Accessibility will be ported to NT for Service Pack #1
//  or at worst #2 after NT SUR ships, this code will work magically when
//  that is done/
//
// --------------------------------------------------------------------------
void MyNotifyWinEvent(UINT event, HWND hwnd, LONG idContainer, LONG_PTR idChild)
{
    static NOTIFYWINEVENTPROC s_pfnNotifyWinEvent = NULL;

    if (!s_pfnNotifyWinEvent)
    {
        HMODULE hmod;

        if (hmod = GetModuleHandle(TEXT("USER32")))
            s_pfnNotifyWinEvent = (NOTIFYWINEVENTPROC)GetProcAddress(hmod,
                "NotifyWinEvent");

        if (!s_pfnNotifyWinEvent)
            s_pfnNotifyWinEvent = DONOTHING_NOTIFYWINEVENT;
    }

    if (s_pfnNotifyWinEvent != DONOTHING_NOTIFYWINEVENT)
        (* s_pfnNotifyWinEvent)(event, hwnd, idContainer, idChild);
}


LONG GetMessagePosClient(HWND hwnd, LPPOINT ppt)
{
    LPARAM lParam;
    POINT pt;
    if (!ppt)
        ppt = &pt;
    
    lParam = GetMessagePos();
    ppt->x = GET_X_LPARAM(lParam);
    ppt->y = GET_Y_LPARAM(lParam);
    ScreenToClient(hwnd, ppt);

    return MAKELONG(ppt->x, ppt->y);
}


LPTSTR StrDup(LPCTSTR lpsz)
{
    LPTSTR lpszRet = (LPTSTR)LocalAlloc(LPTR, (lstrlen(lpsz) + 1) * sizeof(TCHAR));
    if (lpszRet) {
        lstrcpy(lpszRet, lpsz);
    }
    return lpszRet;
}

#ifdef UNICODE
LPSTR StrDupA(LPCSTR lpsz)
{
    LPSTR lpszRet = (LPSTR)LocalAlloc(LPTR, (lstrlenA(lpsz) + 1) * sizeof(CHAR));
    if (lpszRet) {
        lstrcpyA(lpszRet, lpsz);
    }
    return lpszRet;
}

#endif

HWND GetDlgItemRect(HWND hDlg, int nIDItem, LPRECT prc) //relative to hDlg
{
    HWND hCtrl = NULL;
    if (prc)
    {
        hCtrl = GetDlgItem(hDlg, nIDItem);
        if (hCtrl)
        {
            GetWindowRect(hCtrl, prc);
            MapWindowRect(NULL, hDlg, prc);
        }
        else
            SetRectEmpty(prc);
    }
    return hCtrl;
} 


/*----------------------------------------------------------
Purpose: Calls the ADVPACK entry-point which executes an inf
         file section.

*/
HRESULT CallRegInstall(LPSTR szSection)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");

        if (pfnri)
        {
            hr = pfnri(g_hinst, szSection, NULL);
        }

        FreeLibrary(hinstAdvPack);
    }

    return hr;
}


/*----------------------------------------------------------
Purpose: Install/uninstall user settings

*/
STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
#ifdef DEBUG
    if (IsFlagSet(g_dwBreakFlags, BF_ONAPIENTER))
    {
        TraceMsg(TF_ALWAYS, "Stopping in DllInstall");
        DEBUG_BREAK;
    }
#endif

    if (bInstall)
    {
        // Delete any old registration entries, then add the new ones.
        // Keep ADVPACK.DLL loaded across multiple calls to RegInstall.
        // (The inf engine doesn't guarantee DelReg/AddReg order, that's
        // why we explicitly unreg and reg here.)
        //
        CallRegInstall("RegDll");
    }
    else
    {
        CallRegInstall("UnregDll");
    }

    return S_OK;    
}    



//---------------------------------------------------------------------------------------
void FAR PASCAL FlipRect(LPRECT prc)
{
    SWAP(prc->left, prc->top, int);
    SWAP(prc->right, prc->bottom, int);
}


//---------------------------------------------------------------------------------------
//
//  Returns previous window bits.

DWORD SetWindowBits(HWND hWnd, int iWhich, DWORD dwBits, DWORD dwValue)
{
    DWORD dwStyle;
    DWORD dwNewStyle;

    dwStyle = GetWindowLong(hWnd, iWhich);
    dwNewStyle = ( dwStyle & ~dwBits ) | (dwValue & dwBits);
    if (dwStyle != dwNewStyle) {
        dwStyle = SetWindowLong(hWnd, iWhich, dwNewStyle);
    }
    return dwStyle;
}

//---------------------------------------------------------------------------------------

BOOL CCDrawEdge(HDC hdc, LPRECT lprc, UINT edge, UINT flags, LPCOLORSCHEME lpclrsc)
{
    RECT    rc, rcD;
    UINT    bdrType;
    COLORREF clrTL, clrBR;    

    //
    // Enforce monochromicity and flatness
    //    

    // if (oemInfo.BitCount == 1)
    //    flags |= BF_MONO;
    if (flags & BF_MONO)
        flags |= BF_FLAT;    

    CopyRect(&rc, lprc);

    //
    // Draw the border segment(s), and calculate the remaining space as we
    // go.
    //
    if (bdrType = (edge & BDR_OUTER))
    {
DrawBorder:
        //
        // Get colors.  Note the symmetry between raised outer, sunken inner and
        // sunken outer, raised inner.
        //

        if (flags & BF_FLAT)
        {
            if (flags & BF_MONO)
                clrBR = (bdrType & BDR_OUTER) ? g_clrWindowFrame : g_clrWindow;
            else
                clrBR = (bdrType & BDR_OUTER) ? g_clrBtnShadow: g_clrBtnFace;
            
            clrTL = clrBR;
        }
        else
        {
            // 5 == HILIGHT
            // 4 == LIGHT
            // 3 == FACE
            // 2 == SHADOW
            // 1 == DKSHADOW

            switch (bdrType)
            {
                // +2 above surface
                case BDR_RAISEDOUTER:           // 5 : 4
                    clrTL = ((flags & BF_SOFT) ? g_clrBtnHighlight : g_clr3DLight);
                    clrBR = g_clr3DDkShadow;     // 1
                    if (lpclrsc) {
                        if (lpclrsc->clrBtnHighlight != CLR_DEFAULT)
                            clrTL = lpclrsc->clrBtnHighlight;
                        if (lpclrsc->clrBtnShadow != CLR_DEFAULT)
                            clrBR = lpclrsc->clrBtnShadow;
                    }                                            
                    break;

                // +1 above surface
                case BDR_RAISEDINNER:           // 4 : 5
                    clrTL = ((flags & BF_SOFT) ? g_clr3DLight : g_clrBtnHighlight);
                    clrBR = g_clrBtnShadow;       // 2
                    if (lpclrsc) {
                        if (lpclrsc->clrBtnHighlight != CLR_DEFAULT)
                            clrTL = lpclrsc->clrBtnHighlight;
                        if (lpclrsc->clrBtnShadow != CLR_DEFAULT)
                            clrBR = lpclrsc->clrBtnShadow;
                    }                                            
                    break;

                // -1 below surface
                case BDR_SUNKENOUTER:           // 1 : 2
                    clrTL = ((flags & BF_SOFT) ? g_clr3DDkShadow : g_clrBtnShadow);
                    clrBR = g_clrBtnHighlight;      // 5
                    if (lpclrsc) {
                        if (lpclrsc->clrBtnShadow != CLR_DEFAULT)
                            clrTL = lpclrsc->clrBtnShadow;
                        if (lpclrsc->clrBtnHighlight != CLR_DEFAULT)
                            clrBR = lpclrsc->clrBtnHighlight;                        
                    }
                    break;

                // -2 below surface
                case BDR_SUNKENINNER:           // 2 : 1
                    clrTL = ((flags & BF_SOFT) ? g_clrBtnShadow : g_clr3DDkShadow);
                    clrBR = g_clr3DLight;        // 4
                    if (lpclrsc) {
                        if (lpclrsc->clrBtnShadow != CLR_DEFAULT)
                            clrTL = lpclrsc->clrBtnShadow;
                        if (lpclrsc->clrBtnHighlight != CLR_DEFAULT)
                            clrBR = lpclrsc->clrBtnHighlight;                        
                    }
                    break;

                default:
                    return(FALSE);
            }
        }

        //
        // Draw the sides of the border.  NOTE THAT THE ALGORITHM FAVORS THE
        // BOTTOM AND RIGHT SIDES, since the light source is assumed to be top
        // left.  If we ever decide to let the user set the light source to a
        // particular corner, then change this algorithm.
        //
            
        // Bottom Right edges
        if (flags & (BF_RIGHT | BF_BOTTOM))
        {            
            // Right
            if (flags & BF_RIGHT)
            {       
                rc.right -= g_cxBorder;
                // PatBlt(hdc, rc.right, rc.top, g_cxBorder, rc.bottom - rc.top, PATCOPY);
                rcD.left = rc.right;
                rcD.right = rc.right + g_cxBorder;
                rcD.top = rc.top;
                rcD.bottom = rc.bottom;

                FillRectClr(hdc, &rcD, clrBR);
            }
            
            // Bottom
            if (flags & BF_BOTTOM)
            {
                rc.bottom -= g_cyBorder;
                // PatBlt(hdc, rc.left, rc.bottom, rc.right - rc.left, g_cyBorder, PATCOPY);
                rcD.left = rc.left;
                rcD.right = rc.right;
                rcD.top = rc.bottom;
                rcD.bottom = rc.bottom + g_cyBorder;

                FillRectClr(hdc, &rcD, clrBR);
            }
        }
        
        // Top Left edges
        if (flags & (BF_TOP | BF_LEFT))
        {
            // Left
            if (flags & BF_LEFT)
            {
                // PatBlt(hdc, rc.left, rc.top, g_cxBorder, rc.bottom - rc.top, PATCOPY);
                rc.left += g_cxBorder;

                rcD.left = rc.left - g_cxBorder;
                rcD.right = rc.left;
                rcD.top = rc.top;
                rcD.bottom = rc.bottom; 

                FillRectClr(hdc, &rcD, clrTL);
            }
            
            // Top
            if (flags & BF_TOP)
            {
                // PatBlt(hdc, rc.left, rc.top, rc.right - rc.left, g_cyBorder, PATCOPY);
                rc.top += g_cyBorder;

                rcD.left = rc.left;
                rcD.right = rc.right;
                rcD.top = rc.top - g_cyBorder;
                rcD.bottom = rc.top;

                FillRectClr(hdc, &rcD, clrTL);
            }
        }
        
    }

    if (bdrType = (edge & BDR_INNER))
    {
        //
        // Strip this so the next time through, bdrType will be 0.
        // Otherwise, we'll loop forever.
        //
        edge &= ~BDR_INNER;
        goto DrawBorder;
    }

    //
    // Fill the middle & clean up if asked
    //
    if (flags & BF_MIDDLE)    
        FillRectClr(hdc, &rc, (flags & BF_MONO) ? g_clrWindow : g_clrBtnFace);

    if (flags & BF_ADJUST)
        CopyRect(lprc, &rc);

    return(TRUE);
}

//---------------------------------------------------------------------------------------
//CCInvalidateFrame -- SWP_FRAMECHANGED, w/o all the extra params
//
void CCInvalidateFrame(HWND hwnd)
{
    SetWindowPos(hwnd, NULL, 0, 0, 0, 0, SWP_FRAMECHANGED|SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_NOACTIVATE);
    return;
}

//---------------------------------------------------------------------------------------
// FlipPoint - flip the x and y coordinates of a point
//
void FlipPoint(LPPOINT lppt)
{
    SWAP(lppt->x, lppt->y, int);
}

//
//  When we want to turn a tooltip into an infotip, we set its
//  width to 300 "small pixels", where there are 72 small pixels
//  per inch when you are in small fonts mode.
//
//  Scale this value based on the magnification in effect
//  on the owner's monitor.  But never let the tooltip get
//  bigger than 3/4 of the screen.
//
void CCSetInfoTipWidth(HWND hwndOwner, HWND hwndToolTips)
{
    HDC hdc = GetDC(hwndOwner);
    int iWidth = MulDiv(GetDeviceCaps(hdc, LOGPIXELSX), 300, 72);
    int iMaxWidth = GetDeviceCaps(hdc, HORZRES) * 3 / 4;
    SendMessage(hwndToolTips, TTM_SETMAXTIPWIDTH, 0, min(iWidth, iMaxWidth));
    ReleaseDC(hwndOwner, hdc);
}

// Mirror a bitmap in a DC (mainly a text object in a DC)
//
// [samera]
//
void MirrorBitmapInDC( HDC hdc , HBITMAP hbmOrig )
{
  HDC     hdcMem;
  HBITMAP hbm;
  BITMAP  bm;


  if( !GetObject( hbmOrig , sizeof(BITMAP) , &bm ))
    return;

  hdcMem = CreateCompatibleDC( hdc );

  if( !hdcMem )
    return;

  hbm = CreateCompatibleBitmap( hdc , bm.bmWidth , bm.bmHeight );

  if( !hbm )
  {
    DeleteDC( hdcMem );
    return;
  }

  //
  // Flip the bitmap
  //
  SelectObject( hdcMem , hbm );
  SET_DC_RTL_MIRRORED(hdcMem);

  BitBlt( hdcMem , 0 , 0 , bm.bmWidth , bm.bmHeight ,
          hdc , 0 , 0 , SRCCOPY );

  SET_DC_LAYOUT(hdcMem,0);

  //
  // BUGBUG : The offset by 1 is to solve the off-by-one (in hdcMem) problem. Solved.
  // [samera]
  //
  BitBlt( hdc , 0 , 0 , bm.bmWidth , bm.bmHeight ,
          hdcMem , 0 , 0 , SRCCOPY );


  DeleteDC( hdcMem );
  DeleteObject( hbm );

  return;
}

// returns TRUE if handled
BOOL CCWndProc(CONTROLINFO* pci, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres)
{
    if (uMsg >= CCM_FIRST && uMsg < CCM_LAST) {
        LRESULT lres = 0;
        switch (uMsg) {
        case CCM_SETUNICODEFORMAT:
            lres = pci->bUnicode;
            pci->bUnicode = BOOLFROMPTR(wParam);
            break;

        case CCM_GETUNICODEFORMAT:
            lres = pci->bUnicode;
            break;
            
        case CCM_SETVERSION:
            if (wParam <= COMCTL32_VERSION) {
                lres = pci->iVersion;
                pci->iVersion = (int)wParam;
            } else 
                lres = -1;
            break;
            
        case CCM_GETVERSION:
            lres = pci->iVersion;
            break;

        }
        
        ASSERT(plres);
        *plres = lres;
        
        return TRUE;
    }
    
    return FALSE;
}

#ifdef KEYBOARDCUES
// The return value tells if the state changed or not (TRUE == change)
BOOL NEAR PASCAL CCOnUIState(LPCONTROLINFO pControlInfo,
                                  UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    WORD wOldUIState = pControlInfo->wUIState;

    // That's the only message we handle
    if (WM_UPDATEUISTATE == uMessage)
    {
        switch (LOWORD(wParam))
        {
            case UIS_SET:
                pControlInfo->wUIState |= HIWORD(wParam);
                break;

            case UIS_CLEAR:
                pControlInfo->wUIState &= ~(HIWORD(wParam));
                break;
        }
    }

    // These message always need to be passed to DefWindowProc
    return (wOldUIState != pControlInfo->wUIState);
}

BOOL CCNotifyNavigationKeyUsage(LPCONTROLINFO pControlInfo, WORD wFlag)
{
    BOOL fRet = FALSE;

    // do something only if not already in keyboard mode
    if ((CCGetUIState(pControlInfo) & (UISF_HIDEFOCUS | UISF_HIDEACCEL)) != wFlag)
    {
        SendMessage(pControlInfo->hwndParent, WM_CHANGEUISTATE, 
            MAKELONG(UIS_CLEAR, wFlag), 0);

        pControlInfo->wUIState &= ~(HIWORD(wFlag));

        // we did the notify
        fRet = TRUE;
    }

    return fRet;
}

BOOL CCGetUIState(LPCONTROLINFO pControlInfo)
{
    return pControlInfo->wUIState;
}

#endif

LONG g_dwWindowCount = 0;

void CCCreateWindow()
{
    if (InterlockedIncrement(&g_dwWindowCount) == 1)
    {
        // If the count goes to one, Refresh the global metrics
        InitGlobalColors();
        InitGlobalMetrics(0);
    }
}

void CCDestroyWindow()
{
    InterlockedDecrement(&g_dwWindowCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\da.c ===
// Dynamic Array APIs
#include "ctlspriv.h"

//
// Heapsort is a bit slower, but it doesn't use any stack or memory...
// Mergesort takes a bit of memory (O(n)) and stack (O(log(n)), but very fast...
//
#ifdef WIN32
#define MERGESORT
#else
#define USEHEAPSORT
#endif

#ifdef DEBUG
#define DSA_MAGIC   ('S' | ('A' << 8))
#define IsDSA(pdsa) ((pdsa) && (pdsa)->magic == DSA_MAGIC)
#define DPA_MAGIC   ('P' | ('A' << 8))
#define IsDPA(pdpa) ((pdpa) && (pdpa)->magic == DPA_MAGIC)
#else
#define IsDSA(pdsa)
#define IsDPA(pdsa)
#endif


typedef struct {
    void FAR* FAR* pp;
    PFNDPACOMPARE pfnCmp;
    LPARAM lParam;
    int cp;
#ifdef MERGESORT
    void FAR* FAR* ppT;
#endif
} SORTPARAMS;

BOOL NEAR DPA_QuickSort(SORTPARAMS FAR* psp);
BOOL NEAR DPA_QuickSort2(int i, int j, SORTPARAMS FAR* psp);
BOOL NEAR DPA_HeapSort(SORTPARAMS FAR* psp);
void NEAR DPA_HeapSortPushDown(int first, int last, SORTPARAMS FAR* psp);
BOOL NEAR DPA_MergeSort(SORTPARAMS FAR* psp);
void NEAR DPA_MergeSort2(SORTPARAMS FAR* psp, int iFirst, int cItems);



//========== Dynamic structure array ====================================

// Dynamic structure array

typedef struct _DSA {
// NOTE: The following field MUST be defined at the beginning of the
// structure in order for GetItemCount() to work.
//
    int cItem;		// # of elements in dsa

    void FAR* aItem;	// memory for elements
    int cItemAlloc;	// # items which fit in aItem
    int cbItem;		// size of each item
    int cItemGrow;	// # items to grow cItemAlloc by
#ifdef DEBUG
    UINT magic;
#endif
} DSA;

#define DSA_PITEM(pdsa, index)    ((void FAR*)(((BYTE FAR*)(pdsa)->aItem) + ((index) * (pdsa)->cbItem)))


#ifdef DEBUG
#define BF_ONDAVALIDATE     0x00001000

void DABreakFn(void)
{
    if (IsFlagSet(g_dwBreakFlags, BF_ONDAVALIDATE))
        ASSERT(0);
}

#define DABreak()    DABreakFn()
#else
#define DABreak()
#endif


HDSA WINAPI DSA_Create(int cbItem, int cItemGrow)
{
    HDSA pdsa = Alloc(sizeof(DSA));

    ASSERT(cbItem);

    if (pdsa)
    {
        ASSERT(pdsa->cItem == 0);
        ASSERT(pdsa->cItemAlloc == 0);
        pdsa->cbItem = cbItem;
        pdsa->cItemGrow = (cItemGrow == 0 ? 1 : cItemGrow);
        ASSERT(pdsa->aItem == NULL);
#ifdef DEBUG
        pdsa->magic = DSA_MAGIC;
#endif
    }
    return pdsa;
}

BOOL WINAPI DSA_Destroy(HDSA pdsa)
{

    if (pdsa == NULL)       // allow NULL for low memory cases
        return TRUE;

    // Components rely on not having to check for NULL
    ASSERT(IsDSA(pdsa));

#ifdef DEBUG
    pdsa->cItem = 0;
    pdsa->cItemAlloc = 0;
    pdsa->cbItem = 0;
    pdsa->magic = 0;
#endif
    if (pdsa->aItem && !Free(pdsa->aItem))
        return FALSE;

    return Free(pdsa);
}

void WINAPI DSA_EnumCallback(HDSA pdsa, PFNDSAENUMCALLBACK pfnCB, LPVOID pData)
{
    int i;
    
    if (!pdsa)
        return;
    
    ASSERT(IsDSA(pdsa));

    for (i = 0; i < pdsa->cItem; i++) {
        if (!pfnCB(DSA_GetItemPtr(pdsa, i), pData))
            break;
    }
}

void WINAPI DSA_DestroyCallback(HDSA pdsa, PFNDSAENUMCALLBACK pfnCB, LPVOID pData)
{
    DSA_EnumCallback(pdsa, pfnCB, pData);
    DSA_Destroy(pdsa);
}


BOOL WINAPI DSA_GetItem(HDSA pdsa, int index, void FAR* pitem)
{
    ASSERT(IsDSA(pdsa));
    ASSERT(pitem);

    if (index < 0 || index >= pdsa->cItem)
    {
#ifdef DEBUG
        // Don't assert if index == pdsa->cItems as some clients simply want to walk the list and no need to call getcount...

        if (index != pdsa->cItem)
        {
            DebugMsg(DM_ERROR, TEXT("DSA: GetItem: Invalid index: %d"), index);
            DABreak();
        }
#endif
        return FALSE;
    }

    hmemcpy(pitem, DSA_PITEM(pdsa, index), pdsa->cbItem);
    return TRUE;
}

void FAR* WINAPI DSA_GetItemPtr(HDSA pdsa, int index)
{
    ASSERT(IsDSA(pdsa));

    if (index < 0 || index >= pdsa->cItem)
    {
        DebugMsg(DM_ERROR, TEXT("DSA: GetItemPtr: Invalid index: %d"), index);
        // DABreak();   // caller knows 
        return NULL;
    }
    return DSA_PITEM(pdsa, index);
}

BOOL WINAPI DSA_SetItem(HDSA pdsa, int index, void FAR* pitem)
{
    ASSERT(pitem);
    ASSERT(IsDSA(pdsa));

    if (index < 0)
    {
        DebugMsg(DM_ERROR, TEXT("DSA: SetItem: Invalid index: %d"), index);
        DABreak();
        return FALSE;
    }

    if (index >= pdsa->cItem)
    {
        if (index + 1 > pdsa->cItemAlloc)
        {
            int cItemAlloc = (((index + 1) + pdsa->cItemGrow - 1) / pdsa->cItemGrow) * pdsa->cItemGrow;

            void FAR* aItemNew = ReAlloc(pdsa->aItem, cItemAlloc * pdsa->cbItem);
            if (!aItemNew)
                return FALSE;

            pdsa->aItem = aItemNew;
            pdsa->cItemAlloc = cItemAlloc;
        }
        pdsa->cItem = index + 1;
    }

    hmemcpy(DSA_PITEM(pdsa, index), pitem, pdsa->cbItem);

    return TRUE;
}

int WINAPI DSA_InsertItem(HDSA pdsa, int index, void FAR* pitem)
{
    ASSERT(pitem);
    ASSERT(IsDSA(pdsa));

    if (index < 0)
    {
        DebugMsg(DM_ERROR, TEXT("DSA: InsertItem: Invalid index: %d"), index);
        DABreak();
        return -1;
    }

    if (index > pdsa->cItem)
        index = pdsa->cItem;

    if (pdsa->cItem + 1 > pdsa->cItemAlloc)
    {
        void FAR* aItemNew = ReAlloc(pdsa->aItem,
                (pdsa->cItemAlloc + pdsa->cItemGrow) * pdsa->cbItem);
        if (!aItemNew)
            return -1;

        pdsa->aItem = aItemNew;
        pdsa->cItemAlloc += pdsa->cItemGrow;
    }

    if (index < pdsa->cItem)
    {
        hmemcpy(DSA_PITEM(pdsa, index + 1), DSA_PITEM(pdsa, index),
            (pdsa->cItem - index) * pdsa->cbItem);
    }
    pdsa->cItem++;
    hmemcpy(DSA_PITEM(pdsa, index), pitem, pdsa->cbItem);

    return index;
}

BOOL WINAPI DSA_DeleteItem(HDSA pdsa, int index)
{
    ASSERT(IsDSA(pdsa));

    if (index < 0 || index >= pdsa->cItem)
    {
        DebugMsg(DM_ERROR, TEXT("DSA: DeleteItem: Invalid index: %d"), index);
        DABreak();
        return FALSE;
    }

    if (index < pdsa->cItem - 1)
    {
        hmemcpy(DSA_PITEM(pdsa, index), DSA_PITEM(pdsa, index + 1),
            (pdsa->cItem - (index + 1)) * pdsa->cbItem);
    }
    pdsa->cItem--;

    if (pdsa->cItemAlloc - pdsa->cItem > pdsa->cItemGrow)
    {
        void FAR* aItemNew = ReAlloc(pdsa->aItem,
                (pdsa->cItemAlloc - pdsa->cItemGrow) * pdsa->cbItem);
        if (aItemNew)
            pdsa->aItem = aItemNew;
        else
        {
            // If the shrink fails, then just continue with the old (slightly
            // too big) allocation.  Go ahead and let cItemAlloc decrease
            // so we don't keep trying to realloc smaller
        }
        pdsa->cItemAlloc -= pdsa->cItemGrow;
    }
    return TRUE;
}

BOOL WINAPI DSA_DeleteAllItems(HDSA pdsa)
{
    ASSERT(IsDSA(pdsa));

    if (pdsa->aItem && !Free(pdsa->aItem))
        return FALSE;

    pdsa->aItem = NULL;
    pdsa->cItem = pdsa->cItemAlloc = 0;
    return TRUE;
}


//================== Dynamic pointer array implementation ===========

typedef struct _DPA {
// NOTE: The following two fields MUST be defined in this order, at
// the beginning of the structure in order for the macro APIs to work.
//
    int cp;
    void FAR* FAR* pp;

    HANDLE hheap;        // Heap to allocate from if NULL use shared

    int cpAlloc;
    int cpGrow;
#ifdef DEBUG
    UINT magic;
#endif
} DPA;



HDPA WINAPI DPA_Create(int cpGrow)
{
    return DPA_CreateEx(cpGrow, NULL);
}

// Should nuke the standard DPA above...
HDPA WINAPI DPA_CreateEx(int cpGrow, HANDLE hheap)
{
    HDPA pdpa;
    if (hheap == NULL)
    {
#ifdef WIN32
#ifdef WINNT
        hheap = GetProcessHeap();
#else
        hheap = GetSharedHeapHandle();
#endif
#endif

        pdpa = ALLOC_NULLHEAP(hheap, sizeof(DPA));
    }
    else
        pdpa = ControlAlloc(hheap, sizeof(DPA));
    if (pdpa)
    {
        ASSERT(pdpa->cp == 0);
        ASSERT(pdpa->cpAlloc == 0);
        pdpa->cpGrow = (cpGrow < 8 ? 8 : cpGrow);
        ASSERT(pdpa->pp == NULL);
        pdpa->hheap = hheap;
#ifdef DEBUG
        pdpa->magic = DPA_MAGIC;
#endif
    }
    return pdpa;
}

BOOL WINAPI DPA_Destroy(HDPA pdpa)
{
    if (pdpa == NULL)       // allow NULL for low memory cases, still assert
        return TRUE;

    ASSERT(IsDPA(pdpa));

#ifndef UNIX
    ASSERT(pdpa->hheap);
#endif

#ifdef DEBUG
    pdpa->cp = 0;
    pdpa->cpAlloc = 0;
    pdpa->magic = 0;
#endif
    if (pdpa->pp && !ControlFree(pdpa->hheap, pdpa->pp))
        return FALSE;

    return ControlFree(pdpa->hheap, pdpa);
}

HDPA WINAPI DPA_Clone(HDPA pdpa, HDPA pdpaNew)
{
    BOOL fAlloc = FALSE;

    if (!pdpaNew)
    {
        pdpaNew = DPA_CreateEx(pdpa->cpGrow, pdpa->hheap);
        if (!pdpaNew)
            return NULL;

        fAlloc = TRUE;
    }

    if (!DPA_Grow(pdpaNew, pdpa->cpAlloc)) {
        if (!fAlloc)
            DPA_Destroy(pdpaNew);
        return NULL;
    }

    pdpaNew->cp = pdpa->cp;
    hmemcpy(pdpaNew->pp, pdpa->pp, pdpa->cp * sizeof(void FAR*));

    return pdpaNew;
}

void FAR* WINAPI DPA_GetPtr(HDPA pdpa, INT_PTR index)
{
    ASSERT(IsDPA(pdpa));

    if (!pdpa || index < 0 || index >= pdpa->cp)
        return NULL;

    return pdpa->pp[index];
}

int WINAPI DPA_GetPtrIndex(HDPA pdpa, void FAR* p)
{
    void FAR* FAR* pp;
    void FAR* FAR* ppMax;

    ASSERT(IsDPA(pdpa));
    if (pdpa && pdpa->pp)
    {
        pp = pdpa->pp;
        ppMax = pp + pdpa->cp;
        for ( ; pp < ppMax; pp++)
        {
            if (*pp == p)
                return (int) (pp - pdpa->pp);
        }
    }
    return -1;
}

BOOL WINAPI DPA_Grow(HDPA pdpa, int cpAlloc)
{
    ASSERT(IsDPA(pdpa));

    if (!pdpa)
        return FALSE;

    if (cpAlloc > pdpa->cpAlloc)
    {
        void FAR* FAR* ppNew;

        cpAlloc = ((cpAlloc + pdpa->cpGrow - 1) / pdpa->cpGrow) * pdpa->cpGrow;

        if (pdpa->pp)
            ppNew = (void FAR* FAR*)ControlReAlloc(pdpa->hheap, pdpa->pp, cpAlloc * sizeof(void FAR*));
        else
            ppNew = (void FAR* FAR*)ControlAlloc(pdpa->hheap, cpAlloc * sizeof(void FAR*));
        if (!ppNew)
            return FALSE;

        pdpa->pp = ppNew;
        pdpa->cpAlloc = cpAlloc;

        //
        // Grow more agressively as we get bigger, up to a maximum of
        // 512 at a time.  Note, we'll only hit our outer bound growth
        // at a time limit once we've already got that many items in the
        // DPA anyway...
        //
        if (pdpa->cpGrow < 256)
        {
            pdpa->cpGrow = pdpa->cpGrow << 1;
        }
    }
    return TRUE;
}

BOOL WINAPI DPA_SetPtr(HDPA pdpa, int index, void FAR* p)
{
    ASSERT(IsDPA(pdpa));

    if (!pdpa)
        return FALSE;

    if (index < 0)
    {
        DebugMsg(DM_ERROR, TEXT("DPA: SetPtr: Invalid index: %d"), index);
        DABreak();
        return FALSE;
    }

    if (index >= pdpa->cp)
    {
        if (!DPA_Grow(pdpa, index + 1))
            return FALSE;
        // If we grew by more than one, must zero-init all the stuff in the middle
        ZeroMemory(pdpa->pp + pdpa->cp, sizeof(LPVOID) * (index - pdpa->cp));
        pdpa->cp = index + 1;
    }

    pdpa->pp[index] = p;

    return TRUE;
}

int WINAPI DPA_InsertPtr(HDPA pdpa, int index, void FAR* p)
{
    ASSERT(IsDPA(pdpa));

    if (!pdpa)
        return -1;

    if (index < 0)
    {
        DebugMsg(DM_ERROR, TEXT("DPA: InsertPtr: Invalid index: %d"), index);
        DABreak();
        return -1;
    }
    if (index > pdpa->cp)
        index = pdpa->cp;

    // Make sure we have room for one more item
    //
    if (pdpa->cp + 1 > pdpa->cpAlloc)
    {
        if (!DPA_Grow(pdpa, pdpa->cp + 1))
            return -1;
    }

    // If we are inserting, we need to slide everybody up
    //
    if (index < pdpa->cp)
    {
        hmemcpy(&pdpa->pp[index + 1], &pdpa->pp[index],
            (pdpa->cp - index) * sizeof(void FAR*));
    }

    pdpa->pp[index] = p;
    pdpa->cp++;

    return index;
}

void FAR* WINAPI DPA_DeletePtr(HDPA pdpa, int index)
{
    void FAR* p;

    ASSERT(IsDPA(pdpa));

    if (!pdpa)
        return FALSE;

    if (index < 0 || index >= pdpa->cp)
    {
        DebugMsg(DM_ERROR, TEXT("DPA: DeltePtr: Invalid index: %d"), index);
        DABreak();
        return NULL;
    }

    p = pdpa->pp[index];

    if (index < pdpa->cp - 1)
    {
        hmemcpy(&pdpa->pp[index], &pdpa->pp[index + 1],
            (pdpa->cp - (index + 1)) * sizeof(void FAR*));
    }
    pdpa->cp--;

    if (pdpa->cpAlloc - pdpa->cp > pdpa->cpGrow)
    {
        void FAR* FAR* ppNew;
        ppNew = ControlReAlloc(pdpa->hheap, pdpa->pp, (pdpa->cpAlloc - pdpa->cpGrow) * sizeof(void FAR*));

        if (ppNew)
            pdpa->pp = ppNew;
        else
        {
            // If the shrink fails, then just continue with the old (slightly
            // too big) allocation.  Go ahead and let cpAlloc decrease
            // so we don't keep trying to realloc smaller
        }
        pdpa->cpAlloc -= pdpa->cpGrow;
    }
    return p;
}

BOOL WINAPI DPA_DeleteAllPtrs(HDPA pdpa)
{
    if (!pdpa)
        return FALSE;

    ASSERT(IsDPA(pdpa));

    if (pdpa->pp && !ControlFree(pdpa->hheap, pdpa->pp))
        return FALSE;
    pdpa->pp = NULL;
    pdpa->cp = pdpa->cpAlloc = 0;
    return TRUE;
}

void WINAPI DPA_EnumCallback(HDPA pdpa, PFNDPAENUMCALLBACK pfnCB, LPVOID pData)
{
    int i;
    
    if (!pdpa)
        return;
    
    ASSERT(IsDPA(pdpa));

    for (i = 0; i < pdpa->cp; i++) {
        if (!pfnCB(DPA_FastGetPtr(pdpa, i), pData))
            break;
    }
}

void WINAPI DPA_DestroyCallback(HDPA pdpa, PFNDPAENUMCALLBACK pfnCB, LPVOID pData)
{
    DPA_EnumCallback(pdpa, pfnCB, pData);
    DPA_Destroy(pdpa);
}


typedef struct _DPASTREAMHEADER
{
    DWORD cbSize;       // Size of entire stream
    DWORD dwVersion;    // For versioning
    int   celem;
} DPASTREAMHEADER;

#define DPASTREAM_VERSION   1


/*----------------------------------------------------------
Purpose: Saves the DPA to a stream by writing out a header,
         and then calling the given callback to write each
         element.

         The callback can end the write early by returning 
         something other than S_OK.  Returning an error will
         cancel the entire write.  Returning S_FALSE will 
         stop the write.

Returns: S_OK or S_FALSE for success.  
         S_FALSE only if callback stops early
         errors
*/
HRESULT
WINAPI
DPA_SaveStream(
    IN HDPA         pdpa,
    IN PFNDPASTREAM pfn,
    IN IStream *    pstm,
    IN LPVOID       pvInstData)
{
    HRESULT hres = E_INVALIDARG;

    if (IS_VALID_HANDLE(pdpa, DPA) &&
        IS_VALID_CODE_PTR(pstm, IStream *) &&
        IS_VALID_CODE_PTR(pfn, PFNDPASTREAM))
    {
        DPASTREAMHEADER header;
        LARGE_INTEGER dlibMove = { 0 };
        ULARGE_INTEGER ulPosBegin;

        // Get the current seek position, so we can update the header
        // once we know how much we've written
        hres = pstm->lpVtbl->Seek(pstm, dlibMove, STREAM_SEEK_CUR, &ulPosBegin);
        if (SUCCEEDED(hres))
        {
            // Write the header (we will update some of this once we're
            // finished)
            header.cbSize = 0;
            header.dwVersion = DPASTREAM_VERSION;
            header.celem = 0;

            // First write out the header
            hres = pstm->lpVtbl->Write(pstm, &header, sizeof(header), NULL);

            if (SUCCEEDED(hres))
            {
                DPASTREAMINFO info;
                int cel = DPA_GetPtrCount(pdpa);
                LPVOID * ppv = DPA_GetPtrPtr(pdpa);

                // This keeps the count of what is actually written
                info.iPos = 0;

                // Write each element
                for (; 0 < cel; cel--, ppv++) 
                {
                    info.pvItem = *ppv;
                    hres = pfn(&info, pstm, pvInstData);

                    // Returning S_FALSE from callback means it didn't
                    // write anything for this element, so don't increment 
                    // the iPos (which refers to the count written).

                    if (S_OK == hres)
                        info.iPos++;
                    else if (FAILED(hres))
                    {
                        hres = S_FALSE;
                        break;
                    }
                }

                if (FAILED(hres))
                {
                    // Reposition pointer to beginning
                    dlibMove.LowPart = ulPosBegin.LowPart;
                    dlibMove.HighPart = ulPosBegin.HighPart;
                    pstm->lpVtbl->Seek(pstm, dlibMove, STREAM_SEEK_SET, NULL);
                }
                else
                {
                    ULARGE_INTEGER ulPosEnd;

                    // Calculate how much was written
                    hres = pstm->lpVtbl->Seek(pstm, dlibMove, STREAM_SEEK_CUR, 
                                              &ulPosEnd);
                    if (SUCCEEDED(hres))
                    {
                        // We only save the low part
                        ASSERT(ulPosEnd.HighPart == ulPosBegin.HighPart);

                        // Update the header
                        header.celem = info.iPos;
                        header.cbSize = ulPosEnd.LowPart - ulPosBegin.LowPart;

                        dlibMove.LowPart = ulPosBegin.LowPart;
                        dlibMove.HighPart = ulPosBegin.HighPart;
                        pstm->lpVtbl->Seek(pstm, dlibMove, STREAM_SEEK_SET, NULL);
                        pstm->lpVtbl->Write(pstm, &header, sizeof(header), NULL);

                        // Reposition pointer
                        dlibMove.LowPart = ulPosEnd.LowPart;
                        dlibMove.HighPart = ulPosEnd.HighPart;
                        pstm->lpVtbl->Seek(pstm, dlibMove, STREAM_SEEK_SET, NULL);
                    }
                }
            }
        }
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: Loads the DPA from a stream by calling the given callback 
         to read each element.

         The callback can end the read early by returning 
         something other than S_OK.  

Returns: S_OK on success
         S_FALSE if the callback aborted early or the stream ended
           abruptly. DPA is partially filled.
         error on anything else
*/
HRESULT
WINAPI
DPA_LoadStream(
    OUT HDPA *      ppdpa,
    IN PFNDPASTREAM pfn,
    IN IStream *    pstm,
    IN LPVOID       pvInstData)
{
    HRESULT hres = E_INVALIDARG;

    if (IS_VALID_WRITE_PTR(ppdpa, HDPA) &&
        IS_VALID_CODE_PTR(pstm, IStream *) &&
        IS_VALID_CODE_PTR(pfn, PFNDPASTREAM))
    {
        DPASTREAMHEADER header;
        LARGE_INTEGER dlibMove = { 0 };
        ULARGE_INTEGER ulPosBegin;
        ULONG cbRead;

        *ppdpa = NULL;

        // Get the current seek position so we can position pointer 
        // correctly upon error.
        hres = pstm->lpVtbl->Seek(pstm, dlibMove, STREAM_SEEK_CUR, &ulPosBegin);
        if (SUCCEEDED(hres))
        {
            // Read the header
            hres = pstm->lpVtbl->Read(pstm, &header, sizeof(header), &cbRead);
            if (SUCCEEDED(hres))
            {
                if (sizeof(header) > cbRead ||
                    sizeof(header) > header.cbSize ||
                    DPASTREAM_VERSION != header.dwVersion)
                {
                    hres = E_FAIL;
                }
                else
                {
                    // Create the list 
                    HDPA pdpa = DPA_Create(header.celem);
                    if ( !pdpa || !DPA_Grow(pdpa, header.celem))
                        hres = E_OUTOFMEMORY;
                    else
                    {
                        // Read each element
                        DPASTREAMINFO info;
                        LPVOID * ppv = DPA_GetPtrPtr(pdpa);

                        for (info.iPos = 0; info.iPos < header.celem; ) 
                        {
                            info.pvItem = NULL;
                            hres = pfn(&info, pstm, pvInstData);

                            // Returning S_FALSE from the callback means
                            // it skipped this stream element.
                            // Don't increment iPos (which refers to the
                            // count read).
                            if (S_OK == hres)
                            {
                                *ppv = info.pvItem;

                                info.iPos++;
                                ppv++;    
                            }
                            else if (FAILED(hres))
                            {
                                hres = S_FALSE;
                                break;
                            }
                        }

                        pdpa->cp = info.iPos;
                        *ppdpa = pdpa;
                    }
                }

                // Reposition pointer if we failed
                if (S_OK != hres)
                {
                    if (S_FALSE == hres)
                    {
                        // Position pointer to the end
                        dlibMove.LowPart = ulPosBegin.LowPart + header.cbSize;
                    }
                    else
                    {
                        // Position pointer to beginning 
                        dlibMove.LowPart = ulPosBegin.LowPart;
                    }
                    dlibMove.HighPart = ulPosBegin.HighPart;
                    pstm->lpVtbl->Seek(pstm, dlibMove, STREAM_SEEK_SET, NULL);
                }
            }
        }

        ASSERT(SUCCEEDED(hres) && *ppdpa ||
               FAILED(hres) && NULL == *ppdpa);
    }

    return hres;
}



/*----------------------------------------------------------
Purpose: Merge two DPAs.  This takes two arrays and merges the
         source array into the destination.   

         Merge options:

          DPAM_SORTED       The arrays are already sorted; don't sort
          DPAM_UNION        The resulting array is the union of all elements
                            in both arrays.
          DPAM_INTERSECT    Only elements in the source array that intersect
                            with the dest array are merged.  
          DPAM_NORMAL       Like DPAM_INTERSECT except the dest array 
                            also maintains its original, additional elements.


Returns: S_OK for success.  
         errors if merge fails

Cond:    --
*/
BOOL
WINAPI
DPA_Merge(
    IN HDPA          pdpaDest,
    IN HDPA          pdpaSrc,
    IN DWORD         dwFlags,
    IN PFNDPACOMPARE pfnCompare,
    IN PFNDPAMERGE   pfnMerge,
    IN LPARAM        lParam)
{
    BOOL bRet = FALSE;

    if (IS_VALID_HANDLE(pdpaSrc, DPA) &&
        IS_VALID_HANDLE(pdpaDest, DPA) &&
        IS_VALID_CODE_PTR(pfnCompare, PFNDPACOMPARE) &&
        IS_VALID_CODE_PTR(pfnMerge, PFNDPAMERGE))
    {
        int iSrc;
        int iDest;
        int nCmp;
        LPVOID * ppvSrc;
        LPVOID * ppvDest;

        bRet = TRUE;

        // Are the arrays already sorted?
        if ( !(dwFlags & DPAM_SORTED) )
        {
            // No; sort them
            DPA_Sort(pdpaSrc, pfnCompare, lParam);
            DPA_Sort(pdpaDest, pfnCompare, lParam);
        }

        // This merges in-place. The size of the resulting DPA 
        // depends on the options:
        //
        //   DPAM_NORMAL    Same size as the dest DPA before 
        //                  the merge.  
        //
        //   DPAM_UNION     Min size is the larger of the two.
        //                  Max size is the sum of the two.
        //
        //   DPAM_INTERSECT Min size is zero.
        //                  Max size is the smaller of the two.
        // 
        // We iterate backwards to minimize the amount of moves we 
        // incur by calling DPA_DeletePtr.
        //

        iSrc = pdpaSrc->cp - 1;
        iDest = pdpaDest->cp - 1;
        ppvSrc = &DPA_FastGetPtr(pdpaSrc, iSrc);
        ppvDest = &DPA_FastGetPtr(pdpaDest, iDest);

        while (0 <= iSrc && 0 <= iDest)
        {
            LPVOID pv;

            nCmp = pfnCompare(*ppvDest, *ppvSrc, lParam);

            if (0 == nCmp)
            {
                // Elements match; merge them.  
                pv = pfnMerge(DPAMM_MERGE, *ppvDest, *ppvSrc, lParam);
                if (NULL == pv)
                {
                    bRet = FALSE;
                    break;
                }
                *ppvDest = pv;

                iSrc--;
                ppvSrc--;
                iDest--;
                ppvDest--;
            }
            else if (0 < nCmp)
            {
                // pvSrc < pvDest. The source array doesn't have pvDest.
                if (dwFlags & DPAM_INTERSECT)
                {
                    // Delete pvDest 
                    pfnMerge(DPAMM_DELETE, DPA_DeletePtr(pdpaDest, iDest), NULL, lParam);
                }
                else
                {
                    ; // Keep it (do nothing)
                }

                // Move onto the next element in the dest array
                iDest--;
                ppvDest--;
            }
            else
            {
                // pvSrc > pvDest. The dest array doesn't have pvSrc.
                if (dwFlags & DPAM_UNION)
                {
                    // Add pvSrc
                    pv = pfnMerge(DPAMM_INSERT, *ppvSrc, NULL, lParam);
                    if (NULL == pv)
                    {
                        bRet = FALSE;
                        break;
                    }

                    DPA_InsertPtr(pdpaDest, iDest+1, pv);
                    // DPA_InsertPtr may end up reallocating the pointer array
                    // thus making ppvDest invalid
                    ppvDest = &DPA_FastGetPtr(pdpaDest, iDest);
                }
                else
                {
                    ;  // Skip it (do nothing)
                }

                // Move onto the next element in the source array
                iSrc--;
                ppvSrc--;
            }
        }
        // there are some items left in src
        if ((dwFlags & DPAM_UNION) && 0 <= iSrc)
        {
            for (; 0 <= iSrc; iSrc--, ppvSrc--)
            {
                LPVOID pv = pfnMerge(DPAMM_INSERT, *ppvSrc, NULL, lParam);
                if (NULL == pv)
                {
                    bRet = FALSE;
                    break;
                }
                DPA_InsertPtr(pdpaDest, 0, pv);
            }
        }
    }

    return bRet;
}


BOOL WINAPI DPA_Sort(HDPA pdpa, PFNDPACOMPARE pfnCmp, LPARAM lParam)
{
    SORTPARAMS sp;

    sp.cp = pdpa->cp;
    sp.pp = pdpa->pp;
    sp.pfnCmp = pfnCmp;
    sp.lParam = lParam;

#ifdef USEQUICKSORT
    return DPA_QuickSort(&sp);
#endif
#ifdef USEHEAPSORT
    return DPA_HeapSort(&sp);
#endif
#ifdef MERGESORT
    return DPA_MergeSort(&sp);
#endif
}

#ifdef USEQUICKSORT

BOOL NEAR DPA_QuickSort(SORTPARAMS FAR* psp)
{
    return DPA_QuickSort2(0, psp->cp - 1, psp);
}

BOOL NEAR DPA_QuickSort2(int i, int j, SORTPARAMS FAR* psp)
{
    void FAR* FAR* pp = psp->pp;
    LPARAM lParam = psp->lParam;
    PFNDPACOMPARE pfnCmp = psp->pfnCmp;

    int iPivot;
    void FAR* pFirst;
    int k;
    int result;

    iPivot = -1;
    pFirst = pp[i];
    for (k = i + 1; k <= j; k++)
    {
        result = (*pfnCmp)(pp[k], pFirst, lParam);

        if (result > 0)
        {
            iPivot = k;
            break;
        }
        else if (result < 0)
        {
            iPivot = i;
            break;
        }
    }

    if (iPivot != -1)
    {
        int l = i;
        int r = j;
        void FAR* pivot = pp[iPivot];

        do
        {
            void FAR* p;

            p = pp[l];
            pp[l] = pp[r];
            pp[r] = p;

            while ((*pfnCmp)(pp[l], pivot, lParam) < 0)
                l++;
            while ((*pfnCmp)(pp[r], pivot, lParam) >= 0)
                r--;
        } while (l <= r);

        if (l - 1 > i)
            DPA_QuickSort2(i, l - 1, psp);
        if (j > l)
            DPA_QuickSort2(l, j, psp);
    }
    return TRUE;
}
#endif  // USEQUICKSORT

#ifdef USEHEAPSORT

void NEAR DPA_HeapSortPushDown(int first, int last, SORTPARAMS FAR* psp)
{
    void FAR* FAR* pp = psp->pp;
    LPARAM lParam = psp->lParam;
    PFNDPACOMPARE pfnCmp = psp->pfnCmp;
    int r;
    int r2;
    void FAR* p;

    r = first;
    while (r <= last / 2)
    {
        int wRTo2R;
        r2 = r * 2;

        wRTo2R = (*pfnCmp)(pp[r-1], pp[r2-1], lParam);

        if (r2 == last)
        {
            if (wRTo2R < 0)
            {
                p = pp[r-1]; pp[r-1] = pp[r2-1]; pp[r2-1] = p;
            }
            break;
        }
        else
        {
            int wR2toR21 = (*pfnCmp)(pp[r2-1], pp[r2+1-1], lParam);

            if (wRTo2R < 0 && wR2toR21 >= 0)
            {
                p = pp[r-1]; pp[r-1] = pp[r2-1]; pp[r2-1] = p;
                r = r2;
            }
            else if ((*pfnCmp)(pp[r-1], pp[r2+1-1], lParam) < 0 && wR2toR21 < 0)
            {
                p = pp[r-1]; pp[r-1] = pp[r2+1-1]; pp[r2+1-1] = p;
                r = r2 + 1;
            }
            else
            {
                break;
            }
        }
    }
}

BOOL NEAR DPA_HeapSort(SORTPARAMS FAR* psp)
{
    void FAR* FAR* pp = psp->pp;
    int c = psp->cp;
    int i;

    for (i = c / 2; i >= 1; i--)
        DPA_HeapSortPushDown(i, c, psp);

    for (i = c; i >= 2; i--)
    {
        void FAR* p = pp[0]; pp[0] = pp[i-1]; pp[i-1] = p;

        DPA_HeapSortPushDown(1, i - 1, psp);
    }
    return TRUE;
}
#endif  // USEHEAPSORT

#if defined(MERGESORT) && defined(WIN32)

#define SortCompare(psp, pp1, i1, pp2, i2) \
    (psp->pfnCmp(pp1[i1], pp2[i2], psp->lParam))

//
//  This function merges two sorted lists and makes one sorted list.
//   psp->pp[iFirst, iFirst+cItes/2-1], psp->pp[iFirst+cItems/2, iFirst+cItems-1]
//
void NEAR DPA_MergeThem(SORTPARAMS FAR* psp, int iFirst, int cItems)
{
    //
    // Notes:
    //  This function is separated from DPA_MergeSort2() to avoid comsuming
    // stack variables. Never inline this.
    //
    int cHalf = cItems/2;
    int iIn1, iIn2, iOut;
    LPVOID * ppvSrc = &psp->pp[iFirst];

    // Copy the first part to temp storage so we can write directly into
    // the final buffer.  Note that this takes at most psp->cp/2 DWORD's
    hmemcpy(psp->ppT, ppvSrc, cHalf*sizeof(LPVOID));

    for (iIn1=0, iIn2=cHalf, iOut=0;;)
    {
        if (SortCompare(psp, psp->ppT, iIn1, ppvSrc, iIn2) <= 0) {
            ppvSrc[iOut++] = psp->ppT[iIn1++];

            if (iIn1==cHalf) {
                // We used up the first half; the rest of the second half
                // should already be in place
                break;
            }
        } else {
            ppvSrc[iOut++] = ppvSrc[iIn2++];
            if (iIn2==cItems) {
                // We used up the second half; copy the rest of the first half
                // into place
                hmemcpy(&ppvSrc[iOut], &psp->ppT[iIn1], (cItems-iOut)*sizeof(LPVOID));
                break;
            }
        }
    }
}

//
//  This function sorts a give list (psp->pp[iFirst,iFirst-cItems-1]).
//
void NEAR DPA_MergeSort2(SORTPARAMS FAR* psp, int iFirst, int cItems)
{
    //
    // Notes:
    //   This function is recursively called. Therefore, we should minimize
    //  the number of local variables and parameters. At this point, we
    //  use one local variable and three parameters.
    //
    int cHalf;

    switch(cItems)
    {
    case 1:
        return;

    case 2:
        // Swap them, if they are out of order.
        if (SortCompare(psp, psp->pp, iFirst, psp->pp, iFirst+1) > 0)
        {
            psp->ppT[0] = psp->pp[iFirst];
            psp->pp[iFirst] = psp->pp[iFirst+1];
            psp->pp[iFirst+1] = psp->ppT[0];
        }
        break;

    default:
        cHalf = cItems/2;

        // Sort each half
        DPA_MergeSort2(psp, iFirst, cHalf);
        DPA_MergeSort2(psp, iFirst+cHalf, cItems-cHalf);
        // Then, merge them.
        DPA_MergeThem(psp, iFirst, cItems);
        break;
    }
}

BOOL NEAR DPA_MergeSort(SORTPARAMS FAR* psp)
{
    if (psp->cp==0)
        return TRUE;

    // Note that we divide by 2 below; we want to round down
    psp->ppT = LocalAlloc(LPTR, psp->cp/2 * sizeof(LPVOID));
    if (!psp->ppT)
        return FALSE;

    DPA_MergeSort2(psp, 0, psp->cp);
    LocalFree(psp->ppT);
    return TRUE;
}
#endif // MERGESORT

// Search function
//
int WINAPI DPA_Search(HDPA pdpa, void FAR* pFind, int iStart,
            PFNDPACOMPARE pfnCompare, LPARAM lParam, UINT options)
{
    int cp = DPA_GetPtrCount(pdpa);

    ASSERT(pfnCompare);
    ASSERT(0 <= iStart);

    // Only allow these wierd flags if the list is sorted
    ASSERT((options & DPAS_SORTED) || !(options & (DPAS_INSERTBEFORE | DPAS_INSERTAFTER)));

    if (!(options & DPAS_SORTED))
    {
        // Not sorted: do linear search.
        int i;

        for (i = iStart; i < cp; i++)
        {
            if (0 == pfnCompare(pFind, DPA_FastGetPtr(pdpa, i), lParam))
                return i;
        }
        return -1;
    }
    else
    {
        // Search the array using binary search.  If several adjacent
        // elements match the target element, the index of the first
        // matching element is returned.

        int iRet = -1;      // assume no match
        BOOL bFound = FALSE;
        int nCmp = 0;
        int iLow = 0;       // Don't bother using iStart for binary search
        int iMid = 0;
        int iHigh = cp - 1;

        // (OK for cp == 0)
        while (iLow <= iHigh)
        {
            iMid = (iLow + iHigh) / 2;

            nCmp = pfnCompare(pFind, DPA_FastGetPtr(pdpa, iMid), lParam);

            if (0 > nCmp)
                iHigh = iMid - 1;       // First is smaller
            else if (0 < nCmp)
                iLow = iMid + 1;        // First is larger
            else
            {
                // Match; search back for first match
                bFound = TRUE;
                while (0 < iMid)
                {
                    if (0 != pfnCompare(pFind, DPA_FastGetPtr(pdpa, iMid-1), lParam))
                        break;
                    else
                        iMid--;
                }
                break;
            }
        }

        if (bFound)
        {
            ASSERT(0 <= iMid);
            iRet = iMid;
        }

        // Did the search fail AND
        // is one of the strange search flags set?
        if (!bFound && (options & (DPAS_INSERTAFTER | DPAS_INSERTBEFORE)))
        {
            // Yes; return the index where the target should be inserted
            // if not found
            if (0 < nCmp)       // First is larger
                iRet = iLow;
            else
                iRet = iMid;
            // (We don't distinguish between the two flags anymore)
        }
        else if ( !(options & (DPAS_INSERTAFTER | DPAS_INSERTBEFORE)) )
        {
            // Sanity check with linear search
            ASSERT(DPA_Search(pdpa, pFind, iStart, pfnCompare, lParam, options & ~DPAS_SORTED) == iRet);
        }
        return iRet;
    }
}

//===========================================================================
//
// String ptr management routines
//
// Copy as much of *psz to *pszBuf as will fit
//
// Warning:  this same code is duplicated below.
//
int WINAPI Str_GetPtr(LPCTSTR pszCurrent, LPTSTR pszBuf, int cchBuf)
{
    int cchToCopy;

    if (!pszCurrent)
    {
        ASSERT(FALSE);
        
        if (cchBuf > 0)
            *pszBuf = TEXT('\0');

        return 0;
    }

    cchToCopy = lstrlen(pszCurrent);

    // if pszBuf is NULL, or they passed cchBuf = 0, return the needed buff size
    if (!pszBuf || !cchBuf)
        return cchToCopy + 1;
    
    if (cchToCopy >= cchBuf)
        cchToCopy = cchBuf - 1;

    hmemcpy(pszBuf, pszCurrent, cchToCopy * SIZEOF(TCHAR));
    pszBuf[cchToCopy] = TEXT('\0');

    return cchToCopy + 1;
}

#ifdef DEBUG
//
//  Str_GetPtr0 is just like Str_GetPtr except that it doesn't assert if
//  pszCurrent = NULL.
//
int WINAPI Str_GetPtr0(LPCTSTR pszCurrent, LPTSTR pszBuf, int cchBuf)
{
    return Str_GetPtr(pszCurrent ? pszCurrent : c_szNULL, pszBuf, cchBuf);
}
#endif

#ifdef UNICODE
//
// If we are build Unicode, then this is the ANSI version
// of the above function.
//

int WINAPI Str_GetPtrA(LPCSTR pszCurrent, LPSTR pszBuf, int cchBuf)
{
    int cchToCopy;

    if (!pszCurrent)
    {
        ASSERT(FALSE);

        if (cchBuf > 0)
            *pszBuf = '\0';

        return 0;
    }

    cchToCopy = lstrlenA(pszCurrent);

    // if pszBuf is NULL, or they passed cchBuf = 0, return the needed buff size
    if (!pszBuf || !cchBuf)
        return cchToCopy + 1;
    
    if (cchToCopy >= cchBuf)
        cchToCopy = cchBuf - 1;

    // BUGBUG: Must call TruncateString, as we may be in the middle of DBCS char
    hmemcpy(pszBuf, pszCurrent, cchToCopy * SIZEOF(CHAR));
    pszBuf[cchToCopy] = TEXT('\0');

    return cchToCopy + 1;
}

#else

//
// Unicode stub if this code is built ANSI
//

int WINAPI Str_GetPtrW(LPCWSTR psz, LPWSTR pszBuf, int cchBuf)
{
    SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING);
    return -1;
}

#endif

#ifdef WIN32

//
// This function is not exported.
//

BOOL Str_Set(LPTSTR *ppsz, LPCTSTR psz)
{
    if (!psz || (psz == LPSTR_TEXTCALLBACK))
    {
        if (*ppsz)
        {
            if (*ppsz != (LPSTR_TEXTCALLBACK))
                LocalFree(*ppsz);
        }
        *ppsz = (LPTSTR)psz;
    }
    else
    {
        LPTSTR pszNew = *ppsz;
        UINT cbSize = (lstrlen(psz) + 1) * sizeof(TCHAR);

        if (pszNew == LPSTR_TEXTCALLBACK)
            pszNew = NULL;
        
        pszNew = CCLocalReAlloc(pszNew, cbSize);

        if (!pszNew)
            return FALSE;

        lstrcpy(pszNew, psz);
        *ppsz = pszNew;
    }
    return TRUE;
}
#endif

// Set *ppszCurrent to a copy of pszNew, and free the previous value, if necessary
//
// WARNING:  This same code is duplicated below
//
BOOL WINAPI Str_SetPtr(LPTSTR * ppszCurrent, LPCTSTR pszNew)
{
    int cchLength;
    LPTSTR pszOld;
    LPTSTR pszNewCopy = NULL;

    if (pszNew)
    {
        cchLength = lstrlen(pszNew);

        // alloc a new buffer w/ room for the null terminator
        pszNewCopy = (LPTSTR) Alloc((cchLength + 1) * SIZEOF(TCHAR));

        if (!pszNewCopy)
            return FALSE;

        lstrcpyn(pszNewCopy, pszNew, cchLength + 1);
    }
    
    pszOld = InterlockedExchangePointer((LPVOID *)ppszCurrent, pszNewCopy);

    if (pszOld)
        Free(pszOld);

    return TRUE;
}

#ifdef UNICODE
//
// ANSI stub when built Unicode.
//

BOOL WINAPI Str_SetPtrA(LPSTR * ppszCurrent, LPCSTR pszNew)
{
    int cchLength;
    LPSTR pszOld;
    LPSTR pszNewCopy = NULL;

    if (pszNew)
    {
        cchLength = lstrlenA(pszNew);

        // alloc a new buffer w/ room for the null terminator
        pszNewCopy = (LPSTR) Alloc((cchLength + 1) * SIZEOF(CHAR));

        if (!pszNewCopy)
            return FALSE;

        lstrcpynA(pszNewCopy, pszNew, cchLength + 1);
    }

    pszOld = InterlockedExchangePointer((LPVOID *)ppszCurrent, pszNewCopy);

    if (pszOld)
        Free(pszOld);

    return TRUE;
}

#else
// Unicode stub if this is built ANSI

BOOL WINAPI Str_SetPtrW(LPWSTR *ppwzCurrent, LPCWSTR pszNew)
{
    int cchLength;
    LPWSTR pwzOld;
    LPWSTR pwzNewCopy = NULL;

    if (pszNew)
    {
        cchLength = lstrlenW(pszNew);       // Yes this is implemented on Win95.

        // alloc a new buffer w/ room for the null terminator
        pwzNewCopy = (LPWSTR) Alloc((cchLength + 1) * SIZEOF(WCHAR));

        if (!pwzNewCopy)
            return FALSE;

        // lstrcpynW is thunked in unicwrap.cpp for Win95 machines.
        StrCpyNW(pwzNewCopy, pszNew, cchLength + 1);
    }

    pwzOld = InterlockedExchangePointer((LPVOID *)ppwzCurrent, pwzNewCopy);

    if (pwzOld)
        Free(pwzOld);

    return TRUE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\dlgcvt.h ===
#ifndef _INC_COMCTL32_DLGCVT_H
#define _INC_COMCTL32_DLGCVT_H



#ifndef _INC_WINDOWSX
#   include <windowsx.h>
#endif
#ifndef __CCSTOCK_H__
#   include <ccstock.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif 

HRESULT CvtDlgToDlgEx(LPDLGTEMPLATE pTemplate, LPDLGTEMPLATEEX *ppTemplateExOut, int iCharset);

#ifdef __cplusplus
} // extern "C"
#endif



#endif // _INC_COMCTL32_DLGCVT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\draglist.c ===
#include "ctlspriv.h"

#define DF_ACTUALLYDRAG	0x0001
#define DF_DEFERRED	0x0002

#define INITLINESPERSECOND	6
#define VERTCHANGENUMLINES	25

#define TIMERID		238
#define TIMERLEN	50

#define DX_INSERT	16
#define DY_INSERT	16


typedef struct {
    HWND hwndDrag;
    UINT uFlags;
} DRAGPROP, *PDRAGPROP;

UINT uDragListMsg = 0;
#ifndef WINNT
#pragma data_seg(DATASEG_READONLY)
#endif
const TCHAR szDragListMsgString[] = DRAGLISTMSGSTRING;
#ifndef WINNT
#pragma data_seg()
#endif

BOOL NEAR PASCAL PtInLBItem(HWND hLB, int nItem, POINT pt, int xInflate, int yInflate)
{
  RECT rc;

  if (nItem < 0)
      nItem = (int)SendMessage(hLB, LB_GETCURSEL, 0, 0L);

  if (SendMessage(hLB, LB_GETITEMRECT, nItem, (LPARAM)(LPRECT)&rc) == LB_ERR)
      return(FALSE);

  InflateRect(&rc, xInflate, yInflate);

  return(PtInRect(&rc, pt));
}


/*
 * DragListSubclassProc
 * --------------------
 *
 * Window procedure for subclassed list boxes
 */
LRESULT CALLBACK DragListSubclassProc(HWND hLB, UINT uMsg, WPARAM wParam,
      LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
  PDRAGPROP pDragProp;
  DRAGLISTINFO sNotify;
  BOOL bDragging;
  POINT pt;

  pDragProp = (PDRAGPROP)dwRefData;
  bDragging = pDragProp->hwndDrag == hLB;

  switch (uMsg)
    {
      case WM_NCDESTROY:
        if (bDragging)
            SendMessage(hLB, WM_RBUTTONDOWN, 0, 0L);	/* cancel drag */

        RemoveWindowSubclass(hLB, DragListSubclassProc, 0);

        if (pDragProp)
            LocalFree((HLOCAL)pDragProp);
        break;

      case WM_LBUTTONDOWN:
        {
          int nItem;

          if (bDragging)				/* nested button-down */
              SendMessage(hLB, WM_RBUTTONDOWN, 0, 0L);	/* cancel drag */

          SetFocus(hLB);

          pt.x = GET_X_LPARAM(lParam);
          pt.y = GET_Y_LPARAM(lParam);
          ClientToScreen(hLB, &pt);
          nItem = LBItemFromPt(hLB, pt, FALSE);

          if (nItem >= 0)
            {
              SendMessage(hLB, LB_SETCURSEL, nItem, 0L);
              if (GetWindowLong(hLB, GWL_STYLE) & LBS_NOTIFY)
                  SendMessage(GetParent(hLB), WM_COMMAND,
                              GET_WM_COMMAND_MPS(GetDlgCtrlID(hLB), hLB, LBN_SELCHANGE));
              sNotify.uNotification = DL_BEGINDRAG;
              goto QueryParent;
            }
          else
              goto FakeDrag;
        }

      case WM_TIMER:
        if (wParam != TIMERID)
            break;
        lParam = GetMessagePosClient(hLB, &pt);


        // fall through
      case WM_MOUSEMOVE:
	if (bDragging)
	  {
	    HWND hwndParent;
	    LRESULT lResult;

	    /* We may be just simulating a drag, but not actually doing
	     * anything.
	     */
	    if (!(pDragProp->uFlags&DF_ACTUALLYDRAG))
		return(0L);

	    /* We don't want to do any dragging until the user has dragged
	     * outside of the current selection.
	     */
	    if (pDragProp->uFlags & DF_DEFERRED)
	      {
                pt.x = GET_X_LPARAM(lParam);
                pt.y = GET_Y_LPARAM(lParam);
		if (PtInLBItem(hLB, -1, pt, 0, 4))
		    return 0;
		pDragProp->uFlags &= ~DF_DEFERRED;
	      }

	    sNotify.uNotification = DL_DRAGGING;

QueryParent:
	    hwndParent = GetParent(hLB);
	    sNotify.hWnd = hLB;

            sNotify.ptCursor.x = GET_X_LPARAM(lParam);
            sNotify.ptCursor.y = GET_Y_LPARAM(lParam);
	    ClientToScreen(hLB, &sNotify.ptCursor);

            lResult = SendMessage(hwndParent, uDragListMsg, GetDlgCtrlID(hLB),
		  (LPARAM)(LPDRAGLISTINFO)&sNotify);

	    if (uMsg == WM_LBUTTONDOWN)
	      {
		/* Some things may not be draggable
		 */
		if (lResult)
		  {
		    SetTimer(hLB, TIMERID, TIMERLEN, NULL);
		    pDragProp->uFlags = DF_DEFERRED | DF_ACTUALLYDRAG;
		  }
		else
		  {
FakeDrag:
		    pDragProp->uFlags = 0;
		  }

		/* Set capture and change mouse cursor
		 */
		pDragProp->hwndDrag = hLB;

		SetCapture(hLB);
	      }
	    else
	      {
		switch (lResult)
		  {
		    case DL_STOPCURSOR:
                      SetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_NO)));
		      break;

		    case DL_COPYCURSOR:
                      SetCursor(LoadCursor(HINST_THISDLL, MAKEINTRESOURCE(IDC_COPY)));
		      break;

		    case DL_MOVECURSOR:
                      SetCursor(LoadCursor(HINST_THISDLL, MAKEINTRESOURCE(IDC_MOVE)));
		      break;

		    default:
		      break;
		  }
	      }

	    /* Don't call the def proc, since it may try to change the
	     * selection or set timers or things like that.
	     */
	    return(0L);
	  }
	break;

      case  WM_RBUTTONDOWN:
      case  WM_LBUTTONUP:
	/* if we are capturing mouse - release it and check for acceptable place
	 * where mouse is now to decide drop or not
	 */
	if (bDragging)
	  {
	    HWND hwndParent;

	    pDragProp->hwndDrag = NULL;
	    KillTimer(hLB, TIMERID);
	    ReleaseCapture();
	    SetCursor(LoadCursor(NULL, IDC_ARROW));

	    hwndParent = GetParent(hLB);

	    sNotify.uNotification = uMsg==WM_LBUTTONUP ? DL_DROPPED : DL_CANCELDRAG;
	    sNotify.hWnd = hLB;
            sNotify.ptCursor.x = GET_X_LPARAM(lParam);
            sNotify.ptCursor.y = GET_Y_LPARAM(lParam);
	    ClientToScreen(hLB, &sNotify.ptCursor);

	    SendMessage(hwndParent, uDragListMsg, GetDlgCtrlID(hLB),
		  (LPARAM)(LPDRAGLISTINFO)&sNotify);

	    /* We need to make sure to return 0 in case this is from a
	     * keyboard message.
	     */
	    return(0L);
	  }
	break;

      case WM_GETDLGCODE:
	if (bDragging)
          {
            return (DefSubclassProc(hLB, uMsg, wParam, lParam) |
                DLGC_WANTMESSAGE);
          }
	break;

      case WM_KEYDOWN:
        if (wParam == VK_ESCAPE)
          {
            SendMessage(hLB, WM_RBUTTONDOWN, 0, 0L);
          }
        // fall through
      case WM_CHAR:
      case WM_KEYUP:
	/* We don't want the listbox processing this if we are dragging.
	 */
	if (bDragging)
	    return(0L);
	break;

      default:
	break;
    }

  return(DefSubclassProc(hLB, uMsg, wParam, lParam));
}


BOOL WINAPI MakeDragList(HWND hLB)
{
  PDRAGPROP pDragProp;

  if (!uDragListMsg)
      uDragListMsg = RegisterWindowMessage(szDragListMsgString);

  /* Check that we have not already subclassed this window.
   */
  if (GetWindowSubclass(hLB, DragListSubclassProc, 0, NULL))
      return(TRUE);

  pDragProp = (PDRAGPROP)LocalAlloc(LPTR, sizeof(DRAGPROP));
  if (!pDragProp)
      return(FALSE);

  if (!SetWindowSubclass(hLB, DragListSubclassProc, 0, (DWORD_PTR)pDragProp))
  {
      LocalFree((HLOCAL)pDragProp);
      return(FALSE);
  }

  return(TRUE);
}


int WINAPI LBItemFromPt(HWND hLB, POINT pt, BOOL bAutoScroll)
{
  static LONG dwLastScroll = 0;

  RECT rc;
  DWORD dwNow;
  int nItem;
  WORD wScrollDelay, wActualDelay;

  ScreenToClient(hLB, &pt);
  GetClientRect(hLB, &rc);

  nItem = (int)SendMessage(hLB, LB_GETTOPINDEX, 0, 0L);

  /* Is the point in the LB client area?
   */
  if (PtInRect(&rc, pt))
    {
      /* Check each visible item in turn.
       */
      for ( ; ; ++nItem)
	{
	  if (SendMessage(hLB, LB_GETITEMRECT, nItem, (LPARAM)(LPRECT)&rc)
		== LB_ERR)
	      break;

	  if (PtInRect(&rc, pt))
	      return(nItem);
	}
    }
  else
    {
      /* If we want autoscroll and the point is directly above or below the
       * LB, determine the direction and if it is time to scroll yet.
       */
      if (bAutoScroll && (UINT)pt.x<(UINT)rc.right)
	{
	  if (pt.y <= 0)
	    {
	      --nItem;
	    }
	  else
	    {
	      ++nItem;
	      pt.y = rc.bottom - pt.y;
	    }
	  wScrollDelay = (WORD)(1000 /
		(INITLINESPERSECOND - pt.y/VERTCHANGENUMLINES));

	  dwNow = GetTickCount();
	  wActualDelay = (WORD)(dwNow - dwLastScroll);

	  if (wActualDelay > wScrollDelay)
	    {
	      /* This will the actual number of scrolls per second to be
	       * much closer to the required number.
	       */
	      if (wActualDelay > wScrollDelay * 2)
		  dwLastScroll = dwNow;
	      else
		  dwLastScroll += wScrollDelay;

	      SendMessage(hLB, LB_SETTOPINDEX, nItem, 0L);
	    }
	}
    }

  return(-1);
}


void WINAPI DrawInsert(HWND hwndParent, HWND hLB, int nItem)
{
  static POINT ptLastInsert;
  static int nLastInsert = -1;

  RECT rc;

  /* Erase the old mark if necessary
   */
  if (nLastInsert>=0 && nItem!=nLastInsert)
    {
      rc.left = ptLastInsert.x;
      rc.top = ptLastInsert.y;
      rc.right = rc.left + DX_INSERT;
      rc.bottom = rc.top + DY_INSERT;

      /* Need to update immediately in case the insert rects overlap.
       */
      InvalidateRect(hwndParent, &rc, TRUE);
      UpdateWindow(hwndParent);

      nLastInsert = -1;
    }

  /* Draw a new mark if necessary
   */
  if (nItem!=nLastInsert && nItem>=0)
    {
      HICON hInsert = NULL;

      if (!hInsert)
	  hInsert = LoadIcon(HINST_THISDLL, MAKEINTRESOURCE(IDI_INSERT));

      if (hInsert)
	{
	  HDC hDC;

	  GetWindowRect(hLB, &rc);
	  ScreenToClient(hLB, (LPPOINT)&rc);
	  ptLastInsert.x = rc.left - DX_INSERT;

	  SendMessage(hLB, LB_GETITEMRECT, nItem, (LPARAM)(LPRECT)&rc);
	  ptLastInsert.y = rc.top - DY_INSERT/2;

	  nLastInsert = nItem;

	  ClientToScreen(hLB, &ptLastInsert);
	  ScreenToClient(hwndParent, &ptLastInsert);

	  hDC = GetDC(hwndParent);
	  DrawIcon(hDC, ptLastInsert.x, ptLastInsert.y, hInsert);
	  ReleaseDC(hwndParent, hDC);
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\ddproxy.cpp ===
#include "ctlspriv.h"
#include "olestuff.h"

//------------------------------------------------------------------------------

STDAPI GetItemObject(CONTROLINFO *pci, UINT uMsg, const IID *piid, LPNMOBJECTNOTIFY pnon)
{
    pnon->piid = piid;
    pnon->pObject = NULL;
    pnon->hResult = E_NOINTERFACE;

    CCSendNotify(pci, uMsg, &pnon->hdr);

    ASSERT(SUCCEEDED(pnon->hResult) ? (pnon->pObject != NULL) : (pnon->pObject == NULL));
    
    return pnon->hResult;
}

//------------------------------------------------------------------------------

class CDragProxy : public IDropTarget
{

public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDropTarget
    STDMETHODIMP DragEnter(IDataObject *, DWORD, POINTL, DWORD *);
    STDMETHODIMP DragOver(DWORD, POINTL, DWORD *);
    STDMETHODIMP DragLeave();
    STDMETHODIMP Drop(IDataObject *, DWORD, POINTL, DWORD *);

    CDragProxy(HWND hwnd, PFNDRAGCB pfn);
    BOOL Register();
    void RevokeAndFreeCB();

private:
    ~CDragProxy();

    int          _cRef;             // object reference count
    HWND         _hwnd;             // window that owns us
    PFNDRAGCB    _pfnCallback;      // callback for that window
    IDataObject *_pdtobj;           // data object being dragged
    IDropTarget *_pdtgtItem;        // drop target of item under mouse
    int          _idItem;           // id of item under mouse
    DWORD        _dwFlags;
    int          _idDefault;        // id to use when outside a drag etc
    DWORD        _dwEffectItem;     // DROPEFFECT returned for item under mouse
    DWORD        _fKeysLast;        // key flags from last DragOver
    POINTL       _ptLast;           // location of last DragOver
    DWORD        _dwEffectLast;     // effect available from last DragOver
    HMODULE      _hmodOLE;          // OLE32 ref, also indicates we did a Register()

    void SetTargetItem(int id, DWORD dwFlags);
    void SetDropTarget(IDropTarget *pdt);
    void UpdateSelection(DWORD dwEffect);
    LRESULT CallCB(UINT code, WPARAM wp, LPARAM lp);
};

//------------------------------------------------------------------------------

STDAPI_(HDRAGPROXY) CreateDragProxy(HWND hwnd, PFNDRAGCB pfn, BOOL bRegister)
{
    CDragProxy *pdp = new CDragProxy(hwnd, pfn);

    //
    // register as needed
    //
    if (pdp && bRegister && !pdp->Register())
    {
        pdp->Release();
        pdp = NULL;
    }

    return (HDRAGPROXY)pdp;
}

STDAPI_(void) DestroyDragProxy(HDRAGPROXY hdp)
{
    if (hdp)
    {
        ((CDragProxy *)hdp)->RevokeAndFreeCB();
        ((CDragProxy *)hdp)->Release();
    }
}

STDAPI GetDragProxyTarget(HDRAGPROXY hdp, IDropTarget **ppdtgt)
{
    if (hdp)
    {
        *ppdtgt = SAFECAST((CDragProxy *)hdp, IDropTarget *);
        ((CDragProxy *)hdp)->AddRef();
        return NOERROR;
    }

    *ppdtgt = NULL;
    return E_FAIL;
}


//------------------------------------------------------------------------------

CDragProxy::CDragProxy(HWND hwnd, PFNDRAGCB pfn)
    :   _hwnd(hwnd), _pfnCallback(pfn),
        _cRef(1), 
        _hmodOLE(NULL),
        _pdtobj(NULL), 
        _pdtgtItem(NULL),
        _dwEffectItem(DROPEFFECT_NONE)
{
    _idDefault = _idItem = (int)CallCB(DPX_DRAGHIT, 0, 0);
}

CDragProxy::~CDragProxy()
{
    DragLeave();

}

HRESULT CDragProxy::QueryInterface(REFIID iid, void **ppv)
{
    if (IsEqualIID(iid, IID_IDropTarget) || IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = SAFECAST(this, IDropTarget *);
    }
    else 
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    _cRef++;
    return NOERROR;
}

ULONG CDragProxy::AddRef()
{
    return ++_cRef;
}

ULONG CDragProxy::Release()
{
    if (--_cRef)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CDragProxy::DragEnter(IDataObject *pdo, DWORD fKeys, POINTL pt, DWORD *pdwEffect)
{
    //
    // some sanity
    //
    ASSERT(!_pdtgtItem);
    ASSERT(!_pdtobj);

    if (!pdo)
    {
        ASSERT(FALSE);
        return E_INVALIDARG;
    }

    //
    // make sure our callback will allow us to do d/d now
    //
    if (!CallCB(DPX_ENTER, 0, 0))
        return E_FAIL;

    //
    // save away the data object
    //
    pdo->AddRef();
    _pdtobj = pdo;

    //
    // and process this like a DragOver
    //
    DragOver(fKeys, pt, pdwEffect);

    //
    // always succeed DragEnter
    //
    return NOERROR;
}

HRESULT CDragProxy::DragLeave()
{
    //
    // release any drop target that we are holding
    //
    SetDropTarget(NULL);
    _idItem = _idDefault;

    //
    // if we had a data object then we were actually dragging
    //
    if (_pdtobj)
    {
        CallCB(DPX_LEAVE, 0, 0);

        IDataObject* p = _pdtobj;
        _pdtobj = NULL;
        p->Release();
    }

    //
    // all done
    //
    return NOERROR;
}

HRESULT CDragProxy::DragOver(DWORD fKeys, POINTL pt, DWORD *pdwEffect)
{
    DWORD dwFlags = 0;
    HRESULT hres;
    int id;
    ASSERT(_pdtobj);

    //
    // save the current drag state
    //
    _fKeysLast    = fKeys;
    _ptLast       = pt;
    _dwEffectLast = *pdwEffect;

    //
    // make sure we have the correct drop target for this location
    //
    id = (int)CallCB(DPX_DRAGHIT, (WPARAM)&dwFlags, (LPARAM)&pt);
    SetTargetItem(id, dwFlags);
    //
    // do we have a target to drop on?
    //
    if (_pdtgtItem)
    {
        //
        // forward the DragOver along to the item's drop target (if any)
        //
        hres = _pdtgtItem->DragOver(fKeys, pt, pdwEffect);
    }
    else
    {
        //
        // can't drop here
        //
        *pdwEffect = DROPEFFECT_NONE;
        hres = NOERROR;
    }

    //
    // and update our selection state accordingly
    //
    UpdateSelection(*pdwEffect);

    return hres;
}

HRESULT CDragProxy::Drop(IDataObject *pdo, DWORD fKeys, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hres;

    AddRef();

    //
    // do we have a target to drop on?
    //
    if (_pdtgtItem)
    {
        // From a comment in browseui, there's apparently a chance to put up UI
        // which could cause us to get re-entered.  Hard to believe, but see if
        // this fixes the fault:
        //
        IDropTarget * pdtCur = _pdtgtItem;
        _pdtgtItem = NULL;
        
        //
        // do the drop
        //
        hres = pdtCur->Drop(pdo, fKeys, pt, pdwEffect);

        //
        // we call our DragLeave below but we don't want the item's to be
        // called (since it already saw the Drop) so we release right away
        //
        pdtCur->Release();
    }
    else
    {
        //
        // can't drop here
        //
        *pdwEffect = DROPEFFECT_NONE;
        hres = NOERROR;
    }

    //
    // now clean up
    //
    DragLeave();

    Release();
    
    return hres;
}

void CDragProxy::SetTargetItem(int id, DWORD dwFlags)
{
    //
    // anything to do?
    //
    if (id == _idItem && dwFlags == _dwFlags)
        return;

    //
    // deselect the old item (if any)
    //
    // the GETOBJECT below could take a long time and we don't want a
    // lingering highlight on the object we are leaving
    //

    UpdateSelection(DROPEFFECT_NONE);

    //
    // get a drop target for the new item
    //
    _idItem = id;
    _dwFlags = dwFlags;

    NMOBJECTNOTIFY non;
    non.iItem = id;
    non.dwFlags = dwFlags;
    if (!_pdtobj || FAILED((HRESULT)CallCB(DPX_GETOBJECT, 0, (LPARAM)&non)))
        non.pObject = NULL;

        //
    // use this drop target (if any)
    //
    SetDropTarget((IDropTarget*)non.pObject);

    //
    // release our ref from the GETOBJECT above
    //
    if (non.pObject)
        ((IDropTarget*)non.pObject)->Release();
}

void CDragProxy::SetDropTarget(IDropTarget *pdt)
{
    //
    // NOTE: we intentionally skip the test for drop-target equality here
    // this allows controls owners to share a target among multiple items
    // while retaining the proper leave/enter sequence...
    //
    // BOGUS: we should actually compare here when the Internet Toolbar gets
    //  fixed (see comment in CDragProxy::SetTargetItem).  anybody who wants
    //  to share a target like this should just do the right hit-testing in
    //  their DragOver implementation
    //


    //
    // make sure nothing is selected
    //
    UpdateSelection(DROPEFFECT_NONE);

    //
    // leave/release the old item
    //
    if (_pdtgtItem)
    {
        _pdtgtItem->DragLeave();
        _pdtgtItem->Release();
    }

    //
    // store the new item
    //
    _pdtgtItem = pdt;

    //
    // addref/enter the new item
    //
    if (_pdtgtItem)
    {
        ASSERT(_pdtobj);    // must have a data object by now

        _pdtgtItem->AddRef();

        DWORD dwEffect = _dwEffectLast;
        if (FAILED(_pdtgtItem->DragEnter(_pdtobj, _fKeysLast, _ptLast, &dwEffect)))
            dwEffect = DROPEFFECT_NONE;

        //
        // update the selection
        //
        UpdateSelection(dwEffect);
    }
}

void CDragProxy::UpdateSelection(DWORD dwEffect)
{
    //
    // anything to do?
    //
    if (dwEffect == _dwEffectItem)
        return;

    //
    // update the flags and tell the callback they changed
    //
    _dwEffectItem = dwEffect;
    CallCB(DPX_SELECT, (WPARAM)_idItem, (LPARAM)dwEffect);
}

LRESULT CDragProxy::CallCB(UINT code, WPARAM wp, LPARAM lp)
{
    return _pfnCallback ? _pfnCallback(_hwnd, code, wp, lp) : (LRESULT)-1;
}

BOOL CDragProxy::Register()
{
    _hmodOLE = PrivLoadOleLibrary();
    if (_hmodOLE)
    {
        if (SUCCEEDED(PrivCoInitialize(_hmodOLE)))
        {
            if (SUCCEEDED(PrivRegisterDragDrop(_hmodOLE, _hwnd, this)))
                return TRUE;

            PrivCoUninitialize(_hmodOLE);
        }

        PrivFreeOleLibrary(_hmodOLE);
        _hmodOLE = NULL;
    }

    return FALSE;
}

void CDragProxy::RevokeAndFreeCB()
{
    if (_hmodOLE)
    {
        PrivRevokeDragDrop(_hmodOLE, _hwnd);
        PrivCoUninitialize(_hmodOLE);
        PrivFreeOleLibrary(_hmodOLE);
    }
    _pfnCallback = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\flat_sb.c ===
#include "ctlspriv.h"
#include "flat_sb.h"

//  Following interfaces are imported from newwsbctl.c and newsb.c. These
//  functions are for internal use only.

void FlatSB_Internal_CalcSBStuff(WSBState *, BOOL);
void FlatSB_Internal_DoScroll(WSBState *, int, int, BOOL);
void FlatSB_Internal_EndScroll(WSBState *, BOOL);
void FlatSB_Internal_DrawArrow(WSBState *, HDC, CONST RECT *, int, int);
void FlatSB_Internal_DrawElevator(WSBState *, HDC, LPRECT, BOOL);
void FlatSB_Internal_DrawGroove(WSBState *, HDC, LPRECT, BOOL);
void FlatSB_Internal_DrawSize(WSBState *, HDC, int, int);
void FlatSB_Internal_DrawScrollBar(WSBState *, HDC, BOOL, BOOL);
void FlatSB_Internal_DrawThumb(WSBState *, BOOL);
void FlatSB_Internal_DrawThumb2(WSBState *, HDC, BOOL, UINT);
UINT FlatSB_Internal_GetSBFlags(WSBState *, BOOL);
BOOL FlatSB_Internal_EnableScrollBar(WSBState *, int, UINT);
WSBState * FlatSB_Internal_InitPwSB(HWND);
void FlatSB_Internal_RedrawScrollBar(WSBState *, BOOL);
void FlatSB_Internal_SBTrackInit(WSBState *, HWND, LPARAM, int, BOOL);
void FlatSB_Internal_TrackBox(WSBState *, int message, WPARAM, LPARAM);
void FlatSB_Internal_TrackThumb(WSBState *, int message, WPARAM, LPARAM);
BOOL FlatSB_Internal_IsSizeBox(HWND);

LRESULT FlatSB_Internal_SetScrollBar(WSBState *, int, LPSCROLLINFO, BOOL);
LRESULT CALLBACK FlatSB_SubclassWndProc(HWND, UINT, WPARAM, LPARAM, WPARAM, ULONG_PTR);

void FlatSB_Internal_NotifyWinEvent(WSBState *pWState, UINT event, LONG_PTR idChild)
{
    MyNotifyWinEvent(event, pWState->sbHwnd,
                     pWState->fTrackVert ? OBJID_VSCROLL : OBJID_HSCROLL,
                     idChild);
}

#define IsHottrackable(STYLE)   ((STYLE == FSB_FLAT_MODE) || (STYLE == FSB_ENCARTA_MODE))

HRESULT WINAPI UninitializeFlatSB(HWND hwnd)
{
    SCROLLINFO hsi, vsi;
    WSBState * pWState;
    int style, vFlags, hFlags;
    BOOL hValid = FALSE, vValid = FALSE;

    GetWindowSubclass(hwnd, FlatSB_SubclassWndProc, 0, (ULONG_PTR *)&pWState);
    if (pWState == (WSBState *)NULL)
        return S_FALSE;
    else if (pWState == WSB_UNINIT_HANDLE)   {
        RemoveWindowSubclass(hwnd, FlatSB_SubclassWndProc, 0);
        return S_FALSE;
    }

    if (pWState->fTracking)
        return E_FAIL;          //  Can't do this!

    style = pWState->style;
    vsi.cbSize = hsi.cbSize = sizeof(SCROLLINFO);
    vsi.fMask = hsi.fMask = SIF_ALL | SIF_DISABLENOSCROLL;

    hValid = FlatSB_GetScrollInfo(hwnd, SB_HORZ, &hsi);
    hFlags = FlatSB_Internal_GetSBFlags(pWState, SB_HORZ);
    vValid = FlatSB_GetScrollInfo(hwnd, SB_VERT, &vsi);
    vFlags = FlatSB_Internal_GetSBFlags(pWState, SB_VERT);

    DeleteObject(pWState->hbm_Bkg);
    DeleteObject(pWState->hbr_Bkg);
    LocalFree((HLOCAL)pWState);
    RemoveWindowSubclass(hwnd, FlatSB_SubclassWndProc, 0);

    if (vValid) {
        SetScrollInfo(hwnd, SB_VERT, &vsi, FALSE);
        EnableScrollBar(hwnd, SB_VERT, vFlags);
    }

    if (hValid) {
        SetScrollInfo(hwnd, SB_HORZ, &hsi, FALSE);
        EnableScrollBar(hwnd, SB_HORZ, hFlags);
    }

    SetWindowBits(hwnd, GWL_STYLE, WS_HSCROLL | WS_VSCROLL, style & (WS_HSCROLL | WS_VSCROLL));

    //  Force the WM_NCCALCSIZE/WM_NCPAINT to be sent.
    CCInvalidateFrame(hwnd);
    return S_OK;
}

//
//  For accessibility - We keep the original USER scrollbars around and
//  keep USER's view of the scrollbar in sync with the flat view.  This
//  means keeping the WS_[HV]SCROLL styles on the window, forwarding
//  all scrollbar APIs into USER, etc.  That way, when OLEACC asks USER
//  for the scrollbar state, USER returns values that match the flat_sb
//  values.
//
//  Even though the styles are enabled, the UI isn't affected since we
//  take over all nonclient painting and hit-testing so USER never gets
//  a chance to paint or hit-test the scrollbars that we took over.
//
BOOL WINAPI InitializeFlatSB(HWND hwnd)
{
    int newStyle, style;
    SCROLLINFO hsi, vsi, siTmp;
    WSBState * pWState;
    BOOL hValid = FALSE, vValid = FALSE;

    style = GetWindowLong(hwnd, GWL_STYLE);
    siTmp.cbSize = vsi.cbSize = hsi.cbSize = sizeof(SCROLLINFO);
    vsi.fMask = hsi.fMask = SIF_ALL | SIF_DISABLENOSCROLL;

    if (style & WS_HSCROLL)
        hValid = GetScrollInfo(hwnd, SB_HORZ, &hsi);

    if (style & WS_VSCROLL)
        vValid = GetScrollInfo(hwnd, SB_VERT, &vsi);

    newStyle = style & (WS_VSCROLL | WS_HSCROLL);
    style &= ~(WS_VSCROLL | WS_HSCROLL);

    GetWindowSubclass(hwnd, FlatSB_SubclassWndProc, 0, (ULONG_PTR *)&pWState);
    if (!vValid && !hValid)   {
        if (NULL == pWState)    {
            if (!SetWindowSubclass(hwnd, FlatSB_SubclassWndProc, 0, (ULONG_PTR)WSB_UNINIT_HANDLE))
                return FALSE;
        } else  {
            //  It seems to me unreasonable to do nothing while the caller wants
            //  to init again the flat SB we are already using.
        }
        return TRUE;
    }

    if ((NULL == pWState) || (WSB_UNINIT_HANDLE == pWState))    {
        pWState = FlatSB_Internal_InitPwSB(hwnd);
        if ((WSBState *)NULL == pWState)
            return FALSE;

        if (!SetWindowSubclass(hwnd,FlatSB_SubclassWndProc, 0,(ULONG_PTR)pWState)) {
            DeleteObject(pWState->hbm_Bkg);
            DeleteObject(pWState->hbr_Bkg);
            LocalFree((HLOCAL)pWState);
            return FALSE;
        }
    }

    pWState->style = newStyle;
    if (hValid)
        FlatSB_Internal_SetScrollBar(pWState, SB_HORZ, &hsi, FALSE);

    if (vValid)
        FlatSB_Internal_SetScrollBar(pWState, SB_VERT, &vsi, FALSE);

    //  Force the WM_NCCALCSIZE/WM_NCPAINT to be sent.
    CCInvalidateFrame(hwnd);

    return TRUE;
}


LRESULT FlatSB_NCDestroyProc(WSBState * pWState, HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    ASSERT(pWState);

    if (pWState != WSB_UNINIT_HANDLE)   {
        DeleteObject(pWState->hbm_Bkg);
        DeleteObject(pWState->hbr_Bkg);
        LocalFree((HLOCAL)pWState);
    }

    RemoveWindowSubclass(hwnd, FlatSB_SubclassWndProc, 0);
    return DefSubclassProc(hwnd, WM_NCDESTROY, wParam, lParam);
}

LRESULT FlatSB_NCCalcProc(WSBState * pWState, HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    RECT * rc = (RECT *) lParam;
    NCCALCSIZE_PARAMS * pnc = (NCCALCSIZE_PARAMS *)lParam;
    RECT    rcClient, rcWin;
    LRESULT lres;
    DWORD dwStyle;

    //  ZDC:
    //
    //  Note:
    //      It's said that if wParam is true, new rgrc[1|2] are also
    //      computed. Since I didn't see the implementation in the 'user'
    //      code, I leave it unimplemented.


    if ((BOOL)wParam == TRUE)
        CopyRect(&rcWin, &(pnc->rgrc[0]));
    else
        CopyRect(&rcWin, rc);

    dwStyle = SetWindowBits(hwnd, GWL_STYLE, WS_VSCROLL | WS_HSCROLL, 0);

    // Save pnc->rgrc[0] to keep USER happy (see below)
    CopyRect(&rcClient, &pnc->rgrc[0]);

    lres = DefSubclassProc(hwnd, WM_NCCALCSIZE, wParam, lParam);

    SetWindowBits(hwnd, GWL_STYLE, WS_VSCROLL | WS_HSCROLL, dwStyle);

    // USER does funky internal state munging during the WM_NCCALCSIZE
    // and we want USER's internal state to see the scrollbars even though
    // we're drawing them.  So give USER one last look at the original
    // values so he will think the scroll bars are really there.  This
    // sets internal WFVPRESENT and WFHPRESENT flags that OLEACC secretly
    // looks at via the undocumented GetScrollBarInfo().
    DefSubclassProc(hwnd, WM_NCCALCSIZE, FALSE, (LPARAM)&rcClient);

    if ((BOOL)wParam == TRUE)
        CopyRect(&rcClient, &(pnc->rgrc[0]));
    else
        CopyRect(&rcClient, rc);

    pWState->style &= ~(WFVPRESENT | WFHPRESENT);
    if (TestSTYLE(pWState->style, WS_VSCROLL)
        && (rcClient.right - rcClient.left >= pWState->x_VSBArrow)) {
        pWState->style |= WFVPRESENT;
        rcClient.right -= pWState->x_VSBArrow;
    }

    if (TestSTYLE(pWState->style, WS_HSCROLL)
        && (rcClient.bottom - rcClient.top > pWState->y_HSBArrow)) {
        pWState->style |= WFHPRESENT;
        rcClient.bottom -= pWState->y_HSBArrow;
    }

    if ((BOOL)wParam == TRUE)
        CopyRect(&(pnc->rgrc[0]), &rcClient);
    else
        CopyRect(rc, &rcClient);

    pWState->rcClient.top = rcClient.top - rcWin.top;
    pWState->rcClient.bottom = rcClient.bottom - rcWin.top;
    pWState->rcClient.left = rcClient.left - rcWin.left;
    pWState->rcClient.right = rcClient.right - rcWin.left;

    return lres;
}


LRESULT FlatSB_NCPaintProc(WSBState * pWState, HWND hwnd, WPARAM wParam,  LPARAM lParam)
{
    HDC     hdc;
    int     oldLoc, newLoc;
    LRESULT lres;
    DWORD dwStyle;
    RECT rcClient;

    ASSERT(pWState);
    ASSERT(pWState != WSB_UNINIT_HANDLE);

    //
    //  DefWindowProc(WM_NCPAINT) is going to try to draw USER's scrollbars,
    //  and will draw them in the wrong place if our scrollbar width is
    //  different from the system default width.  (Argh.)
    //
    //  So remove the scrollbar styles, do the paint, then put them back.
    //
    dwStyle = SetWindowBits(hwnd, GWL_STYLE, WS_VSCROLL | WS_HSCROLL, 0);

    GetWindowRect(hwnd, &rcClient);
    DefSubclassProc(hwnd, WM_NCCALCSIZE, FALSE, (LPARAM)&rcClient);

    lres = DefSubclassProc(hwnd, WM_NCPAINT, wParam, lParam);

    SetWindowBits(hwnd, GWL_STYLE, WS_VSCROLL | WS_HSCROLL, dwStyle);

    GetWindowRect(hwnd, &rcClient);
    DefSubclassProc(hwnd, WM_NCCALCSIZE, FALSE, (LPARAM)&rcClient);

//  hdc = GetDCEx(hwnd, (HRGN) wParam, DCX_WINDOW |
//                DCX_INTERSECTRGN | DCX_LOCKWINDOWUPDATE);

    //  ZDC:
    //
    //  Note:
    //      For some reason(wParam == 1) the statements above did not give
    //      the result we expected. I am not sure if it's the only case that
    //      GetDCEx will disappoint us.

    hdc = GetWindowDC(hwnd);
    newLoc = WSB_MOUSELOC_OUTSIDE;
    oldLoc = pWState->locMouse;

    if (TestSTYLE(pWState->style, WFHPRESENT)
        && TestSTYLE(pWState->style, WFVPRESENT))   {
        int cxFrame, cyFrame;

        cxFrame = pWState->rcClient.right;
        cyFrame = pWState->rcClient.bottom;
        FlatSB_Internal_DrawSize(pWState, hdc, cxFrame, cyFrame);
    }

    if (TestSTYLE(pWState->style, WFHPRESENT))  {
        FlatSB_Internal_DrawScrollBar(pWState, hdc, FALSE, FALSE);
        if (pWState->fHActive)
            newLoc = pWState->locMouse;
    }

    if (TestSTYLE(pWState->style, WFVPRESENT))  {
        pWState->locMouse = oldLoc;
        FlatSB_Internal_DrawScrollBar(pWState, hdc, TRUE, FALSE);
        if (pWState->fVActive)
            newLoc = pWState->locMouse;
    }
    pWState->locMouse = newLoc;

    ReleaseDC(hwnd, hdc);

    return lres;
}

LRESULT FlatSB_NCHitTestProc(WSBState *pWState, HWND hwnd, WPARAM wParam, LPARAM lParam, BOOL fTrack);

VOID CALLBACK TimerMouseLeave(
    HWND hwnd,  // handle of window for timer messages
    UINT uMsg,  // WM_TIMER message
    UINT_PTR idEvent,  // timer identifier
    DWORD dwTime   // current system time
)
{
    WSBState * pWState;

    if (idEvent != IDWSB_TRACK)
        return;

    GetWindowSubclass(hwnd, FlatSB_SubclassWndProc, 0, (ULONG_PTR *)&pWState);
    if ((pWState == (WSBState *)NULL) || (pWState == WSB_UNINIT_HANDLE))    {
        KillTimer(hwnd, IDWSB_TRACK);
        return;
    }

    if (pWState->fTracking) {
        return;
    }

    FlatSB_NCHitTestProc(pWState, hwnd, 0, 0, TRUE);
    return;
}

LRESULT FlatSB_NCHitTestProc(WSBState *pWState, HWND hwnd, WPARAM wParam, LPARAM lParam, BOOL fTTrack)
{
    LRESULT lres, lHTCode=HTBOTTOMRIGHT;
    RECT    rcTest, rcWindow;
    POINT   pt;
    BOOL    fVChanged = FALSE, fHChanged = FALSE;
    BOOL    fWinActive = ChildOfActiveWindow(hwnd);
    int     newLoc, oldLoc;

    ASSERT(pWState);
    ASSERT(pWState != WSB_UNINIT_HANDLE);

    GetWindowRect(hwnd, &rcWindow);
    if (fTTrack) {
        lres = HTNOWHERE;
        if (fWinActive)
            GetCursorPos(&pt);
        else    {
            pt.x = rcWindow.left - 1;      //  NOWHERE --- to fool CalcSBtuff2
            pt.y = rcWindow.top - 1;
        }
    } else    {
        lres = DefSubclassProc(hwnd, WM_NCHITTEST, wParam, lParam);
        pt.x = GET_X_LPARAM(lParam);
        pt.y = GET_Y_LPARAM(lParam);
    }

    //
    // If this is a RTL mirrored window, then measure
    // the client coordinates from the visual right edge.
    // [samera]
    //
    if (IS_WINDOW_RTL_MIRRORED(hwnd)) {
        pt.x = rcWindow.right - pt.x;
        lHTCode = HTBOTTOMLEFT;
    } else {
        pt.x -= rcWindow.left;
    }
    pt.y -= rcWindow.top;

    if (fTTrack && fWinActive && (pt.x == pWState->ptMouse.x) && (pt.y == pWState->ptMouse.y))
        return lres /* Meaningless result*/;

    //  We shouldn't get HTVSCROLL / HTHSCROLL for system scrollbar here.
    if (lres != HTNOWHERE)  {
        goto Redraw;
    }

    if (TestSTYLE(pWState->style, WFVPRESENT))  {
        rcTest.left = pWState->rcClient.right;
        rcTest.right = pWState->rcClient.right + pWState->x_VSBArrow;
        rcTest.top = pWState->rcClient.top;
        rcTest.bottom = pWState->rcClient.bottom;

        if (PtInRect(&rcTest, pt))  {
            lres = HTVSCROLL;
            goto Redraw;
        }
    }

    if (TestSTYLE(pWState->style, WFHPRESENT))  {
        rcTest.left = pWState->rcClient.left;
        rcTest.right = pWState->rcClient.right;
        rcTest.top = pWState->rcClient.bottom;
        rcTest.bottom = pWState->rcClient.bottom + pWState->y_HSBArrow;

        if (PtInRect(&rcTest, pt))  {
            lres = HTHSCROLL;
            goto Redraw;
        }
    }

    if (TestSTYLE(pWState->style, WFHPRESENT) && TestSTYLE(pWState->style, WFVPRESENT))
    {
        rcTest.left = pWState->rcClient.right;
        rcTest.right = pWState->rcClient.right + pWState->x_VSBArrow;
        rcTest.top = pWState->rcClient.bottom;
        rcTest.bottom = pWState->rcClient.bottom + pWState->y_HSBArrow;

        if (PtInRect(&rcTest, pt))  {
            if (!FlatSB_Internal_IsSizeBox(hwnd))
                lres = HTSIZE;
            else
                lres = lHTCode;
            goto Redraw;
        }
    }

    lres = HTNOWHERE;

Redraw:
    if(pWState->fTracking)
        return lres;

    if (!fWinActive) {
        fVChanged = pWState->fVActive; pWState->fVActive = FALSE;
        fHChanged = pWState->fHActive; pWState->fHActive = FALSE;
    } else  {
        switch (lres)   {
        case HTVSCROLL:
            fVChanged = TRUE; pWState->fVActive = TRUE;
            fHChanged = pWState->fHActive; pWState->fHActive = FALSE;
            break;
        case HTHSCROLL:
            fVChanged = pWState->fVActive; pWState->fVActive = FALSE;
            fHChanged = TRUE; pWState->fHActive = TRUE;
            break;
        default:
            fVChanged = pWState->fVActive; pWState->fVActive = FALSE;
            fHChanged = pWState->fHActive; pWState->fHActive = FALSE;
            break;
        }
    }

    pWState->ptMouse.x = pt.x;
    pWState->ptMouse.y = pt.y;

    newLoc = WSB_MOUSELOC_OUTSIDE;
    oldLoc = pWState->locMouse;
    if (fVChanged && IsHottrackable(pWState->vStyle))  {

        FlatSB_Internal_RedrawScrollBar(pWState, TRUE);
        if (pWState->fVActive)
            newLoc = pWState->locMouse;
    }

    if (fHChanged && IsHottrackable(pWState->hStyle))  {
        pWState->locMouse = oldLoc;
        FlatSB_Internal_RedrawScrollBar(pWState, FALSE);
        if (pWState->fHActive)
            newLoc = pWState->locMouse;
    }
    pWState->locMouse = newLoc;

    if (pWState->fVActive || pWState->fHActive) {
        if (pWState->hTrackSB == 0)
            pWState->hTrackSB = SetTimer(hwnd, IDWSB_TRACK,
                        GetDoubleClickTime()/2,
                        TimerMouseLeave);
    } else  {
        if (pWState->hTrackSB)  {
            KillTimer(hwnd, IDWSB_TRACK);
            pWState->hTrackSB = 0;
        }
    }

    return lres;
}

LRESULT FlatSB_SysCommandProc(WSBState * pWState, HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres;
    unsigned uCmdType;
    int     hitArea;

    ASSERT(pWState);
    ASSERT(pWState != WSB_UNINIT_HANDLE);

    uCmdType = (unsigned) wParam & 0xFFF0;        // type of system command requested
    hitArea = (int) wParam & 0x000F;
    if (uCmdType != SC_HSCROLL && uCmdType != SC_VSCROLL)
        return DefSubclassProc(hwnd, WM_SYSCOMMAND, wParam, lParam);
    else
        //  There are some initialization we may need.
#define SC_INVALID 0
        lres = DefSubclassProc(hwnd, WM_SYSCOMMAND, (WPARAM)SC_INVALID, lParam);
#undef  SC_INVALID

    FlatSB_Internal_SBTrackInit(pWState, hwnd, lParam, hitArea, GetKeyState(VK_SHIFT) < 0);
    return 0;
}

LRESULT FlatSB_CancelModeProc(WSBState * pWState, HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres;

    ASSERT(pWState);
    ASSERT(pWState != WSB_UNINIT_HANDLE);

    lres = DefSubclassProc(hwnd, WM_CANCELMODE, wParam, lParam);

    //  A good citizen of Subclass, we have to wait the DefSubclassProc
    //  release capture first!

    if (pWState->pfnSB)
        FlatSB_Internal_EndScroll(pWState, TRUE);

    return lres;
}

//
//  This updates the system metrics and points pPWState->pwmet at the
//  application metrics or system metrics, depending on whether a
//  screenreader is running.
//
void FlatSB_InitWSBMetrics(WSBState *pWState)
{
    BOOL fScreenRead;

    pWState->metSys.cxHSBThumb = GetSystemMetrics(SM_CXHTHUMB);
    pWState->metSys.cyVSBThumb = GetSystemMetrics(SM_CYVTHUMB);
    pWState->metSys.cxVSBArrow = GetSystemMetrics(SM_CXVSCROLL);
    pWState->metSys.cyVSBArrow = GetSystemMetrics(SM_CYVSCROLL);
    pWState->metSys.cxHSBArrow = GetSystemMetrics(SM_CXHSCROLL);
    pWState->metSys.cyHSBArrow = GetSystemMetrics(SM_CYHSCROLL);

    fScreenRead = FALSE;
    SystemParametersInfo(SPI_GETSCREENREADER, 0, &fScreenRead, 0);

    // If a screen reader is running, then the active metrics are the
    // system metrics; otherwise, it's the app metrics.
    pWState->pmet = fScreenRead ? &pWState->metSys : &pWState->metApp;

}

LRESULT FlatSB_OnSettingChangeProc(WSBState *pWState, HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    ASSERT(pWState);
    ASSERT(pWState != WSB_UNINIT_HANDLE);

    FlatSB_InitWSBMetrics(pWState);

    // These new metrics will most likely have altered our frame, so
    // recompute our frame stuff too
    CCInvalidateFrame(hwnd);

    return DefSubclassProc(hwnd, WM_SETTINGCHANGE, wParam, lParam);
}

LRESULT FlatSB_OnScrollProc(WSBState *pWState, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (GET_WM_HSCROLL_HWND(wParam, lParam) == NULL && !pWState->fInDoScroll) {
        // Somebody on the outside (probably USER) changed our scroll stuff,
        // so re-sync with the USER values.
        if (GET_WM_HSCROLL_CODE(wParam, lParam) == SB_ENDSCROLL)
            FlatSB_NCPaintProc(pWState, hwnd, (WPARAM)1, 0);
    }
    return DefSubclassProc(hwnd, uMsg, wParam, lParam);
}

LRESULT CALLBACK FlatSB_SubclassWndProc
(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    WPARAM uIdSubclass,
    ULONG_PTR dwRefData
)
{
    WSBState * pWState = (WSBState *)dwRefData;

    ASSERT (dwRefData);

    if (pWState == (WSBState *)NULL)
        return DefSubclassProc(hwnd, uMsg, wParam, lParam);
    else if (pWState == WSB_UNINIT_HANDLE && uMsg != WM_NCDESTROY)
        return DefSubclassProc(hwnd, uMsg, wParam, lParam);

    switch (uMsg)
    {
    case WM_NCDESTROY:
        return FlatSB_NCDestroyProc(pWState, hwnd, wParam, lParam);
    case WM_NCCALCSIZE:
        return FlatSB_NCCalcProc(pWState, hwnd, wParam, lParam);
    case WM_NCPAINT:
        return FlatSB_NCPaintProc(pWState, hwnd, wParam, lParam);
    case WM_NCHITTEST:
        return FlatSB_NCHitTestProc(pWState, hwnd, wParam, lParam, FALSE);
    case WM_SYSCOMMAND:
        return FlatSB_SysCommandProc(pWState, hwnd, wParam, lParam);
    case WM_CANCELMODE:
        return FlatSB_CancelModeProc(pWState, hwnd, wParam, lParam);
    case WM_SETTINGCHANGE:
        return FlatSB_OnSettingChangeProc(pWState, hwnd, wParam, lParam);

    case WM_VSCROLL:
    case WM_HSCROLL:
        return FlatSB_OnScrollProc(pWState, hwnd, uMsg, wParam, lParam);
    }
    return DefSubclassProc(hwnd, uMsg, wParam, lParam);
}


//=------------------------------------------------------------------
//  Start of drawing functions.
//=-------------------------------------------------------------------


#define WSB_BUTTON_UPARROW      DFCS_SCROLLUP
#define WSB_BUTTON_DOWNARROW    DFCS_SCROLLDOWN
#define WSB_BUTTON_LEFTARROW    DFCS_SCROLLLEFT
#define WSB_BUTTON_RIGHTARROW   DFCS_SCROLLRIGHT

#define WSB_RESTING_MODE        0
#define WSB_HOTTRACKED_MODE     1
#define WSB_MOUSEDOWN_MODE      2
#define WSB_DISABLED_MODE       3

void FlatSB_Internal_DrawBox(HDC hdc, CONST RECT * prct, int mode)
{
    HBRUSH hbrOld, hbrEdge, hbrFace;
    int w, h, l, t;

    if (prct->left > prct->right)
        return;
    else if (prct->top > prct->bottom)
        return;

    l = prct->left;
    t = prct->top;
    w = prct->right - prct->left;
    h = prct->bottom - prct->top;

    switch (mode)   {
    case WSB_HOTTRACKED_MODE:
        hbrEdge = GetSysColorBrush(COLOR_3DSHADOW);
        hbrFace = hbrEdge;
        break;
    case WSB_MOUSEDOWN_MODE:
        hbrEdge = GetSysColorBrush(COLOR_3DSHADOW);
        hbrFace = (HBRUSH)GetStockObject(BLACK_BRUSH);
        break;
    case WSB_DISABLED_MODE:
        hbrEdge = GetSysColorBrush(COLOR_3DHILIGHT);
        hbrFace = GetSysColorBrush(COLOR_3DFACE);
        break;
    case WSB_RESTING_MODE:
    default:
        hbrEdge = GetSysColorBrush(COLOR_3DSHADOW);
        hbrFace = GetSysColorBrush(COLOR_3DFACE);
        break;
    }
    hbrOld = SelectObject(hdc, hbrEdge);
    PatBlt(hdc, l, t, w, 1, PATCOPY);
    PatBlt(hdc, l, t, 1, h, PATCOPY);
    PatBlt(hdc, l, t + h - 1, w, 1, PATCOPY);
    PatBlt(hdc, l + w - 1, t, 1, h, PATCOPY);

    SelectObject(hdc, hbrFace);
    PatBlt(hdc, l + 1, t + 1, w - 2, h - 2, PATCOPY);
    SelectObject(hdc, hbrOld);
}

void FlatSB_Internal_DrawEncartaBox(HDC hdc, CONST RECT * prct, int mode)
{
    HBRUSH hbrOld, hbrLite, hbrDark, hbrFace;

    int w, h, l, t;

    if (prct->left > prct->right)
        return;
    else if (prct->top > prct->bottom)
        return;

    l = prct->left;
    t = prct->top;
    w = prct->right - prct->left;
    h = prct->bottom - prct->top;

    switch (mode)   {
    case WSB_HOTTRACKED_MODE:
        hbrLite = GetSysColorBrush(COLOR_3DHILIGHT);
        hbrDark = GetSysColorBrush(COLOR_3DSHADOW);
        break;
    case WSB_MOUSEDOWN_MODE:
        hbrDark = GetSysColorBrush(COLOR_3DHILIGHT);
        hbrLite = GetSysColorBrush(COLOR_3DSHADOW);
        break;
    case WSB_DISABLED_MODE:
        hbrDark = hbrLite = GetSysColorBrush(COLOR_3DHILIGHT);
        break;
    case WSB_RESTING_MODE:
    default:
        hbrDark = hbrLite = GetSysColorBrush(COLOR_3DSHADOW);
        break;
    }

    hbrFace = GetSysColorBrush(COLOR_3DFACE);

    hbrOld = SelectObject(hdc, hbrLite);
    PatBlt(hdc, l, t, w, 1, PATCOPY);
    PatBlt(hdc, l, t, 1, h, PATCOPY);

    SelectObject(hdc, hbrDark);
    PatBlt(hdc, l, t + h - 1, w, 1, PATCOPY);
    PatBlt(hdc, l + w - 1, t, 1, h, PATCOPY);

    SelectObject(hdc, hbrFace);
    PatBlt(hdc, l + 1, t + 1, w - 2, h - 2, PATCOPY);

    SelectObject(hdc, hbrOld);
}

void FlatSB_Internal_DrawArrow(WSBState * pWState, HDC hdc, CONST RECT * rcArrow, int buttonIndex, int extraModeBits)
{
    COLORREF rgb;
    LPCTSTR strIndex;
    HFONT   hFont, hOldFont;
    int     x, y, cx, cy, iOldBk, c;
    BOOL    fDisabled = extraModeBits & DFCS_INACTIVE;
    BOOL    fMouseDown = extraModeBits & DFCS_PUSHED;
    BOOL    fHotTracked;
    int     mode, style;

    if (rcArrow->left >= rcArrow->right)
        return;
    else if (rcArrow->top >= rcArrow->bottom)
        return;

    if (buttonIndex == WSB_BUTTON_LEFTARROW || buttonIndex == WSB_BUTTON_RIGHTARROW)
        style = pWState->hStyle;
    else
        style = pWState->vStyle;

    switch (buttonIndex)    {
    case WSB_BUTTON_LEFTARROW:
        fHotTracked = (pWState->locMouse == WSB_MOUSELOC_ARROWLF);
        strIndex = TEXT("3");
        break;
    case WSB_BUTTON_RIGHTARROW:
        fHotTracked = (pWState->locMouse == WSB_MOUSELOC_ARROWRG);
        strIndex = TEXT("4");
        break;
    case WSB_BUTTON_UPARROW:
        fHotTracked = (pWState->locMouse == WSB_MOUSELOC_ARROWUP);
        strIndex = TEXT("5");
        break;
    case WSB_BUTTON_DOWNARROW:
        fHotTracked = (pWState->locMouse == WSB_MOUSELOC_ARROWDN);
        strIndex = TEXT("6");
        break;
    default:
        return;
    }

    if (!fDisabled && fHotTracked && pWState->fHitOld)
        fMouseDown = TRUE;

    if (style == FSB_REGULAR_MODE) {
        RECT rc;

        CopyRect(&rc, rcArrow);
        if (fDisabled)
            DrawFrameControl(hdc, &rc, DFC_SCROLL, buttonIndex | DFCS_INACTIVE);
        else if (fMouseDown)
            DrawFrameControl(hdc, &rc, DFC_SCROLL, buttonIndex | DFCS_FLAT);
        else
            DrawFrameControl(hdc, &rc, DFC_SCROLL, buttonIndex);
        return;
    }

    if (fDisabled)
        mode = WSB_DISABLED_MODE;
    else if (fMouseDown)
        mode = WSB_MOUSEDOWN_MODE;
    else if (fHotTracked)
        mode = WSB_HOTTRACKED_MODE;
    else
        mode = WSB_RESTING_MODE;

    if (style == FSB_ENCARTA_MODE)  {
        FlatSB_Internal_DrawEncartaBox(hdc, rcArrow, mode);
    } else  {
        FlatSB_Internal_DrawBox(hdc, rcArrow, mode);
    }

    cx = rcArrow->right - rcArrow->left;
    cy = rcArrow->bottom - rcArrow->top;
    c = min(cx, cy);

    if (c < 4)      // Couldn't fill in a char after drawing the edges.
        return;

    x = rcArrow->left + ((cx - c) / 2) + 2;
    y = rcArrow->top + ((cy - c) / 2) + 2;

    c -= 4;

    if (style == FSB_FLAT_MODE) {
        switch (mode)   {
        case WSB_RESTING_MODE:
            rgb = RGB(0, 0, 0);
            break;
        case WSB_HOTTRACKED_MODE:
        case WSB_MOUSEDOWN_MODE:
            rgb = RGB(255, 255, 255);
            break;
        case WSB_DISABLED_MODE:
            rgb = GetSysColor(COLOR_3DSHADOW);
            break;
        default:
            rgb = RGB(0, 0, 0);
            break;
        }
    } else  {   //  FSB_ENCARTA_MODE
        switch (mode)   {
        case WSB_DISABLED_MODE:
            rgb = GetSysColor(COLOR_3DSHADOW);
            break;
        case WSB_RESTING_MODE:
        case WSB_HOTTRACKED_MODE:
        case WSB_MOUSEDOWN_MODE:
        default:
            rgb = RGB(0, 0, 0);
            break;
        }
    }

    hFont = CreateFont(c, 0, 0, 0, FW_NORMAL, 0, 0, 0, SYMBOL_CHARSET, 0, 0, 0, 0, WSB_SYS_FONT);
    iOldBk = SetBkMode(hdc, TRANSPARENT);
    hOldFont = SelectObject(hdc, hFont);

    rgb = SetTextColor(hdc, rgb);
    TextOut(hdc, x, y, strIndex, 1);

    SetBkMode(hdc, iOldBk);
    SelectObject(hdc, hOldFont);
    DeleteObject(hFont);

    return;
}

void FlatSB_Internal_DrawElevator(WSBState * pWState, HDC hdc, LPRECT lprc, BOOL fVert)
{
    BOOL    fHit;
    int     mode;
    int     style;

    fHit = (fVert)?(pWState->locMouse == WSB_MOUSELOC_V_THUMB)
                  :(pWState->locMouse == WSB_MOUSELOC_H_THUMB);

    style = (fVert)?pWState->vStyle:pWState->hStyle;
    switch (style)  {
    case FSB_FLAT_MODE:
    case FSB_ENCARTA_MODE:
        if ((pWState->cmdSB == SB_THUMBPOSITION) && (fVert == pWState->fTrackVert))
            mode = WSB_HOTTRACKED_MODE;
        else
            mode = (fHit)?WSB_HOTTRACKED_MODE:WSB_RESTING_MODE;

        if (style == FSB_FLAT_MODE)
            FlatSB_Internal_DrawBox(hdc, lprc, mode);
        else
            FlatSB_Internal_DrawEncartaBox(hdc, lprc, mode);
        break;
    case FSB_REGULAR_MODE:
    default:
        {
            RECT rc;

            CopyRect(&rc, lprc);
            DrawFrameControl(hdc, &rc, DFC_BUTTON, DFCS_BUTTONPUSH);
        }
        break;
    }
}

//=-------------------------------------------------------------
//  FlatSB_Internal_DrawSize
//      Draw the size grip if needed.
//=-------------------------------------------------------------

void FlatSB_Internal_DrawSize(WSBState * pWState, HDC hdc, int x, int y)
{
    HBRUSH  hbrSave, hbr3DFACE;
    RECT    rcWindow;
    HWND    hwnd = pWState->sbHwnd;
    int     style;

    style = GetWindowLong(hwnd, GWL_STYLE);
    if (!FlatSB_Internal_IsSizeBox(hwnd))
    {
        hbr3DFACE = GetSysColorBrush(COLOR_3DFACE);
        hbrSave = SelectObject(hdc, hbr3DFACE);
        PatBlt(hdc, x, y, pWState->x_VSBArrow, pWState->y_HSBArrow, PATCOPY);
        SelectBrush(hdc, hbrSave);
    }
    else
    {
        rcWindow.left = x;
        rcWindow.right = x + pWState->x_VSBArrow;
        rcWindow.top = y;
        rcWindow.bottom = y + pWState->y_HSBArrow;
        DrawFrameControl(hdc, &rcWindow, DFC_SCROLL, DFCS_SCROLLSIZEGRIP);
    }
}

//=-------------------------------------------------------------
//  FlatSB_Internal_DrawGroove
//      Draw lines & middle of the thumb groove
//=-------------------------------------------------------------

void FlatSB_Internal_DrawGroove(WSBState * pWState, HDC hdc, LPRECT prct, BOOL fVert)
{
    HBRUSH   hbrLight;
    COLORREF cBkg, cFg;
    HPALETTE oldPal = 0;

    if (fVert)  {
        hbrLight = pWState->hbr_VSBBkg;
        cBkg = pWState->col_VSBBkg;
    } else  {
        hbrLight = pWState->hbr_HSBBkg;
        cBkg = pWState->col_HSBBkg;
    }

    if (hbrLight == (HBRUSH)NULL)   {
        hbrLight = GetSysColorBrush(COLOR_3DLIGHT);
        FillRect(hdc, prct, hbrLight);
        return;
    }

    if (pWState->hPalette != (HPALETTE)NULL)    {
        oldPal = SelectPalette(hdc, pWState->hPalette, TRUE);
        RealizePalette(hdc);
    }

    cFg = SetTextColor(hdc, GetSysColor(COLOR_3DFACE));
    cBkg = SetBkColor(hdc, cBkg);
    FillRect(hdc, prct, hbrLight);
    if (oldPal != (HPALETTE)NULL)
        SelectPalette(hdc, oldPal, TRUE);

    SetTextColor(hdc, cFg);
    SetBkColor(hdc, cBkg);
}


//=-------------------------------------------------------------------
//  Following functions are ported from winsbctl.c in user code.
//=-------------------------------------------------------------------


//=-------------------------------------------------------------------------
//  SBPosFromPx() -
//=-------------------------------------------------------------------------

int FlatSB_Internal_SBPosFromPx(WSBState * pWState, int px)
{
    int * pw;

    if (pWState->fTrackVert)
        pw = &(pWState->sbVMinPos);
    else
        pw = &(pWState->sbHMinPos);

    if (px < pWState->pxUpArrow)
        return pw[SBO_MIN];

    if (px >= pWState->pxDownArrow)
            return (pw[SBO_MAX] - (pw[SBO_PAGE]?pw[SBO_PAGE] - 1 : 0));

    return (pw[SBO_MIN] + DMultDiv(pw[SBO_MAX] - pw[SBO_MIN] - (pw[SBO_PAGE]?pw[SBO_PAGE] - 1 : 0),
                                   px - pWState->pxUpArrow,
                                   pWState->cpxSpace)
           );
}

//=-------------------------------------------------------------------------
//  InvertScrollHilite()
//=-------------------------------------------------------------------------

void FlatSB_Internal_InvertScrollHilite(WSBState * pWState)
{
    HWND hwnd = pWState->sbHwnd;
    HDC hdc;

    // Don't invert if the thumb is all the way at the top or bottom
    // or you will end up inverting the line between the arrow and the thumb.
    if (!IsRectEmpty(&(pWState->rcTrack)))
    {
        hdc = GetWindowDC(hwnd);
        InvertRect(hdc, &(pWState->rcTrack));
        ReleaseDC(hwnd, hdc);
    }
}

//=-------------------------------------------------------------------------
//  FlatSB_Internal_MoveThumb()
//=-------------------------------------------------------------------------

void FlatSB_Internal_MoveThumb(WSBState * pWState, int px)
{
    HWND    hwnd = pWState->sbHwnd;
    HDC     hdc;

    if (px == pWState->pxOld)
        return;

pxReCalc:

    pWState->posNew = FlatSB_Internal_SBPosFromPx(pWState, px);

    /* Tentative position changed -- notify the guy. */
    if (pWState->posNew != pWState->posOld) {
        FlatSB_Internal_DoScroll(pWState, SB_THUMBTRACK, pWState->posNew, pWState->fTrackVert);
        if (!pWState->fTracking)
            return;

        pWState->posOld = pWState->posNew;

        //
        // Anything can happen after the SendMessage above in DoScroll!
        // Make sure that the SBINFO structure contains data for the
        // window being tracked -- if not, recalculate data in SBINFO
        // If fVertSB is TRUE, the last CalcSBStuff call is for SB_VERT.
        // If fTrackVert != fVertSB, we got garbage in pWState.
        //

        if (pWState->fTrackVert != pWState->fVertSB)
            FlatSB_Internal_CalcSBStuff(pWState, pWState->fTrackVert);

        // when we yield, our range can get messed with
        // so make sure we handle this

        if (px >= pWState->pxDownArrow - pWState->cpxThumb) {
            px = pWState->pxDownArrow - pWState->cpxThumb;
            goto pxReCalc;
        }
    }

    hdc = GetWindowDC(hwnd);

    pWState->pxThumbTop = px;
    pWState->pxThumbBottom = pWState->pxThumbTop + pWState->cpxThumb;

    //  At this point, the disable flags are always going to be 0 --
    //  we're in the middle of tracking.

    //  We are Okay in this case, since in DrawElevator we decide the mode by
    //  cmd == SB_THUMBPOSITION.
    FlatSB_Internal_DrawThumb2(pWState, hdc, pWState->fTrackVert, 0);
    ReleaseDC(hwnd, hdc);

    pWState->pxOld = px;
}

//=-------------------------------------------------------------------------
//  DrawInvertScrollArea() -
//=-------------------------------------------------------------------------

void FlatSB_Internal_DrawInvertScrollArea(WSBState * pWState, BOOL fHit, int cmd)
{
    HWND hwnd = pWState->sbHwnd;
    HDC  hdc;

    if ((cmd != SB_LINEUP) && (cmd != SB_LINEDOWN))
    {
        FlatSB_Internal_InvertScrollHilite(pWState);
        FlatSB_Internal_NotifyWinEvent(pWState, EVENT_OBJECT_STATECHANGE,
                         cmd == SB_PAGEUP ? INDEX_SCROLLBAR_UPPAGE
                                          : INDEX_SCROLLBAR_DOWNPAGE);
        return;
    }

    hdc = GetWindowDC(hwnd);
    if (cmd == SB_LINEUP) {
        if (pWState->fTrackVert)   {
            FlatSB_Internal_DrawArrow(pWState, hdc, &(pWState->rcTrack), DFCS_SCROLLUP, (fHit) ? DFCS_PUSHED : 0);
        } else  {
            FlatSB_Internal_DrawArrow(pWState, hdc, &(pWState->rcTrack), DFCS_SCROLLLEFT, (fHit) ? DFCS_PUSHED : 0);
        }
    } else {
        if (pWState->fTrackVert)   {
            FlatSB_Internal_DrawArrow(pWState, hdc, &(pWState->rcTrack), DFCS_SCROLLDOWN, (fHit) ? DFCS_PUSHED : 0);
        } else  {
            FlatSB_Internal_DrawArrow(pWState, hdc, &(pWState->rcTrack), DFCS_SCROLLRIGHT, (fHit) ? DFCS_PUSHED : 0);
        }
    }

    FlatSB_Internal_NotifyWinEvent(pWState, EVENT_OBJECT_STATECHANGE,
                     cmd == SB_LINEUP ? INDEX_SCROLLBAR_UP : INDEX_SCROLLBAR_DOWN);

    ReleaseDC(hwnd, hdc);

}

//=-------------------------------------------------------------------------
//  FlatSB_Internal_EndScroll() -
//=-------------------------------------------------------------------------

void FlatSB_Internal_EndScroll(WSBState * pWState, BOOL fCancel)
{
    HWND hwnd = pWState->sbHwnd;
    BOOL fVert = pWState->fTrackVert;
    int oldcmd;

    if (pWState->fTracking)
    {
        oldcmd = pWState->cmdSB;
        pWState->cmdSB = 0;

        //  will not have capture if called by CancelModeProc
        if (GetCapture() == hwnd)
            ReleaseCapture();

        if (pWState->pfnSB == FlatSB_Internal_TrackThumb)
        {
            if (fCancel)    {
                pWState->posOld = pWState->posStart;
            }

            FlatSB_Internal_DoScroll(pWState, SB_THUMBPOSITION, pWState->posOld, fVert);
            FlatSB_Internal_DrawThumb(pWState, fVert);
        }
        else if (pWState->pfnSB == FlatSB_Internal_TrackBox)
        {
            DWORD   lpt;
            RECT    rcWindow;
            POINT   pt;

            if (pWState->hTimerSB)
                KillTimer(hwnd, IDSYS_SCROLL);

            lpt = GetMessagePos();

            ASSERT(hwnd != GetDesktopWindow());

            GetWindowRect(hwnd, &rcWindow);
            pt.x = GET_X_LPARAM(lpt) - rcWindow.left;
            pt.y = GET_Y_LPARAM(lpt) - rcWindow.top;

            if (PtInRect(&(pWState->rcTrack), pt))  {
                pWState->fHitOld = FALSE;
                FlatSB_Internal_DrawInvertScrollArea(pWState, FALSE, oldcmd);
            }
        }

        //  Always send SB_ENDSCROLL message.
        pWState->pfnSB = NULL;

        //  Anything can happen here. Client can call GetScrollInfo for THUMBPOSITION, and we
        //  should return 0, so we should set pfnSB to NULL first.
        FlatSB_Internal_DoScroll(pWState, SB_ENDSCROLL, 0, fVert);
        pWState->fTracking = FALSE;
        pWState->fHitOld = FALSE;

        FlatSB_Internal_NotifyWinEvent(pWState, EVENT_SYSTEM_SCROLLINGEND,
                                       INDEXID_CONTAINER);
        //  Redraw the components.
        FlatSB_NCHitTestProc(pWState, hwnd, 0, 0, TRUE);
    }
}

//=-------------------------------------------------------------------------
//  FlatSB_Internal_DoScroll() -
//=-------------------------------------------------------------------------

void FlatSB_Internal_DoScroll(WSBState *pWState, int cmd, int pos, BOOL fVert)
{
    if (pWState->sbHwnd)
    {
        pWState->fInDoScroll++;
        SendMessage(pWState->sbHwnd, (fVert ? WM_VSCROLL : WM_HSCROLL), (WPARAM)(LOWORD(pos) << 16 | (cmd & 0xffff)), (LPARAM)NULL);
        pWState->fInDoScroll--;
    }
}


//=-------------------------------------------------------------------------
//  TimerScroll()
//=--------------------------------------------------------------------------

VOID CALLBACK TimerScroll(HWND hwnd, UINT message, UINT_PTR id, DWORD time)
{
    LONG    pos;
    POINT   pt;
    UINT    dblClkTime, dtScroll;
    WSBState * pWState;
    RECT    rcWindow;


    GetWindowSubclass(hwnd, FlatSB_SubclassWndProc, 0, (ULONG_PTR *)&pWState);
    if ((pWState == (WSBState *)NULL) || (pWState == WSB_UNINIT_HANDLE))    {
        KillTimer(hwnd, IDSYS_SCROLL);
        return;
    }

    ASSERT(hwnd != GetDesktopWindow());

    pos = GetMessagePos();
    pt.x = GET_X_LPARAM(pos), pt.y = GET_Y_LPARAM(pos);
    dblClkTime = GetDoubleClickTime();
    dtScroll = (dblClkTime * 4) / 5;
    GetWindowRect(hwnd, &rcWindow);

    pt.x -= rcWindow.left;
    pt.y -= rcWindow.top;

    pos = LOWORD(pt.y) << 16 | LOWORD(pt.x);
    FlatSB_Internal_TrackBox(pWState, WM_NULL, 0, (LPARAM) pos);

    if (pWState->fHitOld)
    {
        pWState->hTimerSB = SetTimer(hwnd, IDSYS_SCROLL, dtScroll / 8, TimerScroll);
        FlatSB_Internal_DoScroll(pWState, pWState->cmdSB, 0, pWState->fTrackVert);
    }
    return;
}

//=-------------------------------------------------------------------------
//  FlatSB_Internal_TrackBox() -
//=-------------------------------------------------------------------------

void FlatSB_Internal_TrackBox(WSBState * pWState, int message, WPARAM wParam, LPARAM lParam)
{
    HWND hwnd = pWState->sbHwnd;
    BOOL fHit, fVert = pWState->fTrackVert;
    BOOL fHitOld = pWState->fHitOld;
    POINT pt;
    int cmsTimer;
    UINT dblClkTime, dtScroll;

    if (message && (message < WM_MOUSEFIRST || message > WM_MOUSELAST))
        return;

    dblClkTime = GetDoubleClickTime();
    dtScroll = (dblClkTime * 4) / 5;

    pt.x = GET_X_LPARAM(lParam);
    pt.y = GET_Y_LPARAM(lParam);

    fHit = PtInRect(&(pWState->rcTrack), pt);

    if (fHit != fHitOld)   {
        pWState->fHitOld = fHit;
        FlatSB_Internal_DrawInvertScrollArea(pWState, fHit, pWState->cmdSB);
    }

    cmsTimer = dtScroll / 8;

    switch (message)
    {
        case WM_LBUTTONUP:
            FlatSB_Internal_EndScroll(pWState, FALSE);
            break;

        case WM_LBUTTONDOWN:
            pWState->hTimerSB = 0;
            cmsTimer = dtScroll;

            /*** FALL THRU ***/

        case WM_MOUSEMOVE:
            if (fHit && (fHit != fHitOld))
            {
                /* We moved back into the normal rectangle: reset timer */
                pWState->hTimerSB = SetTimer(hwnd, IDSYS_SCROLL, cmsTimer, TimerScroll);
                FlatSB_Internal_DoScroll(pWState, pWState->cmdSB, 0, fVert);
            }
    }
}

//=-------------------------------------------------------------------------
//  FlatSB_Internal_TrackThumb() -
//=-------------------------------------------------------------------------

void FlatSB_Internal_TrackThumb(WSBState * pWState, int message, WPARAM wParam, LPARAM lParam)
{
    HWND    hwnd = pWState->sbHwnd;
    BOOL    fVert = pWState->fTrackVert;
    POINT   pt;

    if (message < WM_MOUSEFIRST || message > WM_MOUSELAST)
        return;

    // Make sure that the SBINFO structure contains data for the
    // window being tracked -- if not, recalculate data in SBINFO
    if (pWState->fTrackVert != pWState->fVertSB)
        FlatSB_Internal_CalcSBStuff(pWState, pWState->fTrackVert);

    pt.x = GET_X_LPARAM(lParam);
    pt.y = GET_Y_LPARAM(lParam);
     if (!PtInRect(&(pWState->rcTrack), pt))
        pWState->px = pWState->pxStart;
    else
    {
        pWState->px = (fVert ? GET_Y_LPARAM(lParam) : GET_X_LPARAM(lParam)) + pWState->dpxThumb;
        if (pWState->px < pWState->pxUpArrow)
            pWState->px = pWState->pxUpArrow;
        else if (pWState->px >= (pWState->pxDownArrow - pWState->cpxThumb))
            pWState->px = pWState->pxDownArrow - pWState->cpxThumb;
    }

    FlatSB_Internal_MoveThumb(pWState, pWState->px);

    if (message == WM_LBUTTONUP)
        FlatSB_Internal_EndScroll(pWState, FALSE);
}

//=-------------------------------------------------------------------------
//  FlatSB_Internal_SBTrackLoop() -
//=-------------------------------------------------------------------------

void FlatSB_Internal_SBTrackLoop(WSBState * pWState, LPARAM lParam)
{
    HWND    hwnd = pWState->sbHwnd;
    MSG     msg;
    int     cmd, newlParam;
    POINT   pt;

    if (!pWState->fTracking)
        return;

    FlatSB_Internal_NotifyWinEvent(pWState, EVENT_SYSTEM_SCROLLINGSTART,
                                   INDEXID_CONTAINER);

    (*(pWState->pfnSB))(pWState, WM_LBUTTONDOWN, 0, lParam);

    while (GetCapture() == hwnd)
    {
        if (!GetMessage(&msg, NULL, 0, 0))
            break;

        if (!CallMsgFilter(&msg, MSGF_SCROLLBAR)) {
            cmd = msg.message;

            if (msg.hwnd == hwnd &&
                ((cmd >= WM_MOUSEFIRST && cmd <= WM_MOUSELAST) ||
                (cmd >= WM_KEYFIRST && cmd <= WM_KEYLAST  )    ))
            {
            // Process Key
#define ALT_PRESSED 0x20000000L
                if (cmd >= WM_SYSKEYDOWN
                    && cmd <= WM_SYSDEADCHAR
                    && msg.lParam & ALT_PRESSED)
                    cmd -= (WM_SYSKEYDOWN - WM_KEYDOWN);
#undef ALT_PRESSED
                if (!pWState->fTracking)
                    return;

                // Change to coordinates according to left-top corner of the window.
                pt.x = GET_X_LPARAM(msg.lParam) + pWState->rcClient.left;
                pt.y = GET_Y_LPARAM(msg.lParam) + pWState->rcClient.top;

                newlParam = LOWORD(pt.y) << 16 | LOWORD(pt.x);

                (*(pWState->pfnSB))(pWState, cmd, msg.wParam, (LPARAM)newlParam);
            } else {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }
}

//=-------------------------------------------------------------------------
//  FlatSB_Internal_SBTrackInit() -
//=-------------------------------------------------------------------------

void FlatSB_Internal_SBTrackInit(WSBState * pWState, HWND hwnd, LPARAM lParam, int hitArea, BOOL fDirect)
{
    int     hitX = GET_X_LPARAM(lParam);
    int     hitY = GET_Y_LPARAM(lParam);
    int     px;
    int    *pwX;
    int    *pwY;
    int     wDisable;   // Scroll bar disable flags;
    RECT    rcWindow;
    BOOL    fVert;
    POINT   pt;

    // hitArea = 0 indicates a scroll bar control
    // otherwise, curArea will have the hit test area

    if (hitArea == HTHSCROLL)
        fVert = FALSE;
    else if (hitArea == HTVSCROLL)
        fVert = TRUE;
    else
        return;

    ASSERT(hwnd != GetDesktopWindow());

    GetWindowRect(hwnd, &rcWindow);
    pt.x = GET_X_LPARAM(lParam) - rcWindow.left;
    pt.y = GET_Y_LPARAM(lParam) - rcWindow.top;
    lParam = LOWORD(pt.y) << 16 | LOWORD(pt.x);

    wDisable = FlatSB_Internal_GetSBFlags(pWState, fVert);

    if ((wDisable & ESB_DISABLE_BOTH) == ESB_DISABLE_BOTH)  {
        // Whole Scroll Bar is disabled -- do not respond
        pWState->pfnSB = NULL;
        pWState->fTracking = FALSE;
        return;
    }

    pWState->hTimerSB = 0;
    pWState->fHitOld = FALSE;
    pWState->fTracking = FALSE;

    //  For the case we click on scroll bar of a nonactive window. The mode is set to FLAT
    //  by HitTestProc. This will work because we set the tracking flag right away.
    if (fVert)  {
        pWState->fVActive = TRUE;   pWState->fHActive = FALSE;
    } else  {
        pWState->fHActive = TRUE;   pWState->fVActive = FALSE;
    }

    //  This will give us the right locMouse. We will keep it till EndScroll.
    FlatSB_Internal_CalcSBStuff(pWState, fVert);

    //  From now till EndScroll, CalcSBStuff won't compute new locMouse.
    pWState->pfnSB = FlatSB_Internal_TrackBox;
    pWState->fTracking = TRUE;

    // Initialize rcSB to the Rectangle of the Entire Scroll Bar
    pwX = (int *)&(pWState->rcSB);
    pwY = pwX + 1;

    if (!fVert)
        pwX = pwY--;

    pwX[0] = pWState->pxLeft;
    pwY[0] = pWState->pxTop;
    pwX[2] = pWState->pxRight;
    pwY[2] = pWState->pxBottom;

    px = (fVert ? pt.y : pt.x);

    pWState->px = px;
    if (px < pWState->pxUpArrow)
    {   // The click occurred on Left/Up arrow
        if(wDisable & LTUPFLAG)
        {   // Disabled -- do not respond
            pWState->pfnSB = NULL;
            pWState->fTracking = FALSE;
            return;
        }

        // LINEUP -- make rcSB the Up Arrow's Rectangle
        pWState->cmdSB = SB_LINEUP;
        pwY[2] = pWState->pxUpArrow;
    }
    else if (px >= pWState->pxDownArrow)
    {   // The click occurred on Right/Down arrow
        if(wDisable & RTDNFLAG)
        {   // Disabled -- do not respond
            pWState->pfnSB = NULL;
            pWState->fTracking = FALSE;
            return;
        }

        // LINEDOWN -- make rcSB the Down Arrow's Rectangle
        pWState->cmdSB = SB_LINEDOWN;
        pwY[0] = pWState->pxDownArrow;
    }
    else if (px < pWState->pxThumbTop)
    {
        // PAGEUP -- make rcSB the rectangle between Up Arrow and Thumb
        pWState->cmdSB = SB_PAGEUP;

        pwY[0] = pWState->pxUpArrow;
        pwY[2] = pWState->pxThumbTop;
    }
    else if (px < pWState->pxThumbBottom)
    {
DoThumbPos:
        if (pWState->pxDownArrow - pWState->pxUpArrow <= pWState->cpxThumb) {
            // Not enough room -- elevator isn't there
            pWState->pfnSB = NULL;
            pWState->fTracking = FALSE;
            return;
        }
        // THUMBPOSITION -- we're tracking with the thumb
        pWState->cmdSB = SB_THUMBPOSITION;
        pWState->fTrackVert = fVert;
        CopyRect(&(pWState->rcTrack), &(pWState->rcSB));

        if (pWState->sbGutter < 0) {
            // Negative gutter means "infinite size"
            pWState->rcTrack.top = MINLONG;
            pWState->rcTrack.left = MINLONG;
            pWState->rcTrack.right = MAXLONG;
            pWState->rcTrack.bottom = MAXLONG;
        } else
        if (fVert)
            InflateRect(&(pWState->rcTrack),
                        (pWState->rcTrack.right - pWState->rcTrack.left) * pWState->sbGutter,
                        pWState->y_VSBThumb * pWState->sbGutter);
        else
            InflateRect(&(pWState->rcTrack),
                        pWState->x_HSBThumb * pWState->sbGutter,
                        (pWState->rcTrack.bottom - pWState->rcTrack.top) * pWState->sbGutter);

        pWState->pfnSB = FlatSB_Internal_TrackThumb;
        pWState->pxOld  = pWState->pxStart  = pWState->pxThumbTop;
        pWState->posOld = pWState->posNew = pWState->posStart = fVert?pWState->sbVThumbPos:pWState->sbHThumbPos;
        pWState->dpxThumb = pWState->pxThumbTop - pWState->px;

        SetCapture(hwnd);
        FlatSB_Internal_DoScroll(pWState, SB_THUMBTRACK, pWState->posOld, fVert);
        FlatSB_Internal_DrawThumb(pWState, fVert);
    }
    else if (px < pWState->pxDownArrow)
    {
        // PAGEDOWN -- make rcSB the rectangle between Thumb and Down Arrow
        pWState->cmdSB = SB_PAGEDOWN;

        pwY[0] = pWState->pxThumbBottom;
        pwY[2] = pWState->pxDownArrow;
    }

    // NT5-style tracking:  Shift+Click = "Go here"
    if (g_bRunOnNT5 && fDirect && pWState->cmdSB != SB_LINEUP && pWState->cmdSB != SB_LINEDOWN) {
        if (pWState->cmdSB != SB_THUMBPOSITION) {
            goto DoThumbPos;
        }
        pWState->dpxThumb = -(pWState->cpxThumb / 2);
    }

    if (pWState->cmdSB != SB_THUMBPOSITION) {
        pWState->fTrackVert = fVert;
        SetCapture(hwnd);
        CopyRect(&(pWState->rcTrack), &(pWState->rcSB));
    }

    FlatSB_Internal_SBTrackLoop(pWState, lParam);
}

//=-------------------------------------------------------------------------
//  GetScroll...() -
//=-------------------------------------------------------------------------

int WINAPI FlatSB_GetScrollPos(HWND hwnd, int code)
{
    WSBState * pWState;

    ASSERT (code != SB_CTL);

    GetWindowSubclass(hwnd, FlatSB_SubclassWndProc, 0, (ULONG_PTR *)&pWState);
    if (pWState == (WSBState *)NULL)    {
        return GetScrollPos(hwnd, code);
    } else if (pWState == WSB_UNINIT_HANDLE) {
        return 0;
    } else if (pWState->sbHwnd != hwnd) {
        return 0;
    } else  {
        return ((code == SB_VERT)?pWState->sbVThumbPos:pWState->sbHThumbPos);
    }
}

BOOL WINAPI FlatSB_GetScrollPropPtr(HWND hwnd, int propIndex, PINT_PTR pValue)
{
    WSBState * pWState;

    if (!pValue)
        return FALSE;
    else
        *pValue = 0;    //  If we can't set it, we reset it.

    GetWindowSubclass(hwnd, FlatSB_SubclassWndProc, 0, (ULONG_PTR *)&pWState);
    if (pWState == (WSBState *)NULL)    {
        return FALSE;
    } else if (pWState == WSB_UNINIT_HANDLE) {
        pWState = FlatSB_Internal_InitPwSB(hwnd);
        if (pWState == (WSBState *)NULL)
            return FALSE;
        else if (!SetWindowSubclass(hwnd, FlatSB_SubclassWndProc, 0,  (ULONG_PTR)pWState)) {
            DeleteObject(pWState->hbm_Bkg);
            DeleteObject(pWState->hbr_Bkg);
            LocalFree((HLOCAL)pWState);
            return FALSE;
        } else  {
        //  Fall through.
        }
    } else if (pWState->sbHwnd != hwnd) {
        return FALSE;
    }

    switch (propIndex)  {
    case WSB_PROP_CYVSCROLL:
        *pValue = pWState->metApp.cyVSBArrow;
        break;
    case WSB_PROP_CXVSCROLL:
        *pValue = pWState->metApp.cxVSBArrow;
        break;
    case WSB_PROP_CYHSCROLL:
        *pValue = pWState->metApp.cyHSBArrow;
        break;
    case WSB_PROP_CXHSCROLL:
        *pValue = pWState->metApp.cxHSBArrow;
        break;
    case WSB_PROP_CXHTHUMB:
        *pValue = pWState->metApp.cxHSBThumb;
        break;
    case WSB_PROP_CYVTHUMB:
        *pValue = pWState->metApp.cyVSBThumb;
        break;
    case WSB_PROP_WINSTYLE:
        //  To check if a scrollbar is present, the WF(HV)PRESENT bits may
        //  be more useful than WS_(HV)SCROLL bits.
        *pValue = pWState->style;
        break;
    case WSB_PROP_HSTYLE:
        *pValue = pWState->hStyle;
        break;
    case WSB_PROP_VSTYLE:
        *pValue = pWState->vStyle;
        break;
    case WSB_PROP_HBKGCOLOR:
        *pValue = pWState->col_HSBBkg;
        break;
    case WSB_PROP_VBKGCOLOR:
        *pValue = pWState->col_VSBBkg;
        break;
    case WSB_PROP_PALETTE:
        *pValue = (INT_PTR)pWState->hPalette;
        break;
    case WSB_PROP_GUTTER:
        *pValue = pWState->sbGutter;
        break;
    default:
        return FALSE;
    }
    return TRUE;
}

#ifdef _WIN64

BOOL WINAPI FlatSB_GetScrollProp(HWND hwnd, int propIndex, LPINT pValue)
{
    INT_PTR iValue;
    BOOL fRc;

    if (!pValue)
        return FALSE;

#ifdef DEBUG
    if (propIndex == WSB_PROP_PALETTE)
    {
        TraceMsg(TF_ERROR, "FlatSB_GetScrollProp(WSB_PROP_PALETTE): Use GetScrollPropPtr for Win64 compat");
    }
#endif

    fRc = FlatSB_GetScrollPropPtr(hwnd, propIndex, &iValue);
    *pValue = (int)iValue;

    return fRc;
}
#endif

BOOL WINAPI FlatSB_GetScrollRange(HWND hwnd, int code, LPINT lpposMin, LPINT lpposMax)
{
    int     *pw;
    WSBState * pWState;

    ASSERT(code != SB_CTL);
    if (!lpposMin || !lpposMax)
        return FALSE;

    GetWindowSubclass(hwnd, FlatSB_SubclassWndProc, 0, (ULONG_PTR *)&pWState);
    if (pWState == (WSBState *)NULL)    {
        return GetScrollRange(hwnd, code, lpposMin, lpposMax);
//        *lpposMin = 0;
//        *lpposMax = 0;
    } else if (pWState == WSB_UNINIT_HANDLE) {
        *lpposMin = 0;
        *lpposMax = 0;
    } else if (pWState->sbHwnd != hwnd) {
        return FALSE;
    } else {
        pw = (code == SB_VERT) ? &(pWState->sbVMinPos) : &(pWState->sbHMinPos);
        *lpposMin = pw[SBO_MIN];
        *lpposMax = pw[SBO_MAX];
    }

    return TRUE;
}

BOOL WINAPI FlatSB_GetScrollInfo(HWND hwnd, int fnBar, LPSCROLLINFO lpsi)
{
    int *pw;
    WSBState * pWState;

    ASSERT(fnBar != SB_CTL);

    //  ZDC@Oct. 10, Detect GP faults here.
    if ((LPSCROLLINFO)NULL == lpsi)
        return FALSE;

    if (lpsi->cbSize < sizeof (SCROLLINFO))
        return FALSE;

    //  ZDC@Oct. 11, Don't zero out buffer anymore.
    GetWindowSubclass(hwnd, FlatSB_SubclassWndProc, 0, (ULONG_PTR *)&pWState);
    if (pWState == (WSBState *)NULL)    {
        return GetScrollInfo(hwnd, fnBar, lpsi);
    } else if (pWState == WSB_UNINIT_HANDLE) {
        return FALSE;
    } else if (pWState->sbHwnd != hwnd) {
        return FALSE;
    } else if (fnBar == SB_VERT)    {
        pw = &(pWState->sbVMinPos);
    } else if (fnBar == SB_HORZ)    {
        pw = &(pWState->sbHMinPos);
    } else {
        return FALSE;
    }

    if (lpsi->fMask & SIF_RANGE)
        lpsi->nMin = pw[SBO_MIN], lpsi->nMax = pw[SBO_MAX];
    if (lpsi->fMask & SIF_POS)
        lpsi->nPos = pw[SBO_POS];
    if (lpsi->fMask & SIF_PAGE)
        lpsi->nPage = pw[SBO_PAGE];
    // ZDC@Oct 9, Add support for SIF_TRACKPOS
    if (lpsi->fMask & SIF_TRACKPOS) {
        //  This is the olny place that pfnSB is used instead of fTracking.
        if (pWState->pfnSB != NULL) {
            if ((fnBar == SB_VERT) && pWState->fTrackVert)
                lpsi->nTrackPos = pWState->posNew;
            else if ((fnBar == SB_HORZ) && !(pWState->fTrackVert))
                lpsi->nTrackPos = pWState->posNew;
            else
                lpsi->nTrackPos = pw[SBO_POS];
        } else
            lpsi->nTrackPos = pw[SBO_POS];
    }

    return TRUE;
}

BOOL WINAPI FlatSB_ShowScrollBar(HWND hwnd, int fnBar, BOOL fShow)
{
    BOOL fChanged = FALSE;
    int newStyle = 0;
    WSBState * pWState;

    ASSERT(fnBar != SB_CTL);

    GetWindowSubclass(hwnd, FlatSB_SubclassWndProc, 0, (ULONG_PTR *)&pWState);
    if (pWState == (WSBState *)NULL)
        return ShowScrollBar(hwnd, fnBar, fShow);

    switch (fnBar) {
    case SB_VERT:
        newStyle = WS_VSCROLL;
        break;
    case SB_HORZ:
        newStyle = WS_HSCROLL;
        break;
    case SB_BOTH:
        newStyle = WS_VSCROLL | WS_HSCROLL;
        break;
    default:
        return FALSE;
    }

    if (pWState == WSB_UNINIT_HANDLE) {
        if (fShow)  {
            pWState = FlatSB_Internal_InitPwSB(hwnd);
            if (pWState == (WSBState *)NULL)
                return FALSE;
            else if (!SetWindowSubclass(hwnd, FlatSB_SubclassWndProc, 0,  (ULONG_PTR)pWState)) {
                DeleteObject(pWState->hbm_Bkg);
                DeleteObject(pWState->hbr_Bkg);
                LocalFree((HLOCAL)pWState);
                return FALSE;
            }
        } else  {
            return FALSE;
        }
    }

    if (!fShow) {
        if (pWState->style & newStyle) {
            fChanged = TRUE;
            pWState->style &= ~newStyle;
        }
    } else {
        if ((pWState->style & newStyle) != newStyle)    {
            fChanged = TRUE;
            pWState->style |= newStyle;
        }
    }

    if (fChanged) {
        // Keep USER scrollbars in sync for accessibility
        ShowScrollBar(hwnd, fnBar, fShow);
        CCInvalidateFrame(hwnd);
    }

    return TRUE;
}

//=------------------------------------------------------------------
//  Following functions are ported from winsb.c in user code.
//=------------------------------------------------------------------

//=--------------------------------------------------------------
// InitPwSB
//     [in]    hwnd
// Note:
//     This function is only a memory allocating func. It won't
//     do any check. On the other hand, this function should be
//     called before any consequent functions are used.
//=--------------------------------------------------------------

WSBState * FlatSB_Internal_InitPwSB(HWND hwnd)
{
    int     patGray[4];
    HBITMAP hbm;
    WSBState * pw;

    pw = (WSBState *)LocalAlloc(LPTR, sizeof(WSBState));
    // The buffer should already be zero-out.

    if (pw == (WSBState *)NULL)
        return pw;

    patGray[0] = 0x005500AA;
    patGray[1] = 0x005500AA;
    patGray[2] = 0x005500AA;
    patGray[3] = 0x005500AA;

    pw->sbVMaxPos = pw->sbHMaxPos = 100;
    pw->sbHwnd = hwnd;

    // We start out with app metrics equal to system metrics
    FlatSB_InitWSBMetrics(pw);
    pw->metApp = pw->metSys;

    //
    //  NT5's gutter is 8; Win9x's and NT4's gutter is 2.
    //
    pw->sbGutter = g_bRunOnNT5 ? 8 : 2;

    // ZDC
    //     make sure get hbm_Bkg and hbr_Bkg deleted.
    hbm = CreateBitmap(8, 8, 1, 1, (LPSTR)patGray);

    if ((HBITMAP)NULL == hbm)   {
        LocalFree((HLOCAL)pw);
        return NULL;
    }

    pw->hbr_VSBBkg = CreatePatternBrush(hbm);
    if ((HBRUSH)NULL == pw->hbr_VSBBkg)  {
        DeleteObject(hbm);
        LocalFree((HLOCAL)pw);
        return NULL;
    }

    pw->hbr_Bkg = pw->hbr_HSBBkg = pw->hbr_VSBBkg;
    pw->col_VSBBkg = pw->col_HSBBkg = RGB(255, 255, 255);
    pw->hbm_Bkg = hbm;
    pw->hStyle = pw->vStyle = FSB_FLAT_MODE;    //  Default state: Flat.
    pw->ptMouse.x = -1;
    pw->ptMouse.y = -1;

    return(pw);
}

void FlatSB_Internal_RedrawScrollBar(WSBState * pWState, BOOL fVert)
{
    HDC hdc;

    hdc = GetWindowDC(pWState->sbHwnd);
    FlatSB_Internal_DrawScrollBar(pWState, hdc, fVert, TRUE);
    ReleaseDC(pWState->sbHwnd, hdc);
}

//=-------------------------------------------------------------
// FlatSB_Internal_GetSBFlags
//=-------------------------------------------------------------

UINT FlatSB_Internal_GetSBFlags(WSBState * pWState, BOOL fVert)
{
    int wFlags;

    if (pWState == (WSBState *)NULL)    {
        return(0);
    }

    wFlags = pWState->sbFlags;

    return(fVert ? (wFlags & WSB_VERT) >> 2 : wFlags & WSB_HORZ);
}

//=--------------------------------------------------------------
//  return TRUE if there is a change.
//=--------------------------------------------------------------

BOOL WINAPI FlatSB_EnableScrollBar(HWND hwnd, int wSBflags, UINT wArrows)
{
    WSBState * pWState;

    GetWindowSubclass(hwnd, FlatSB_SubclassWndProc, 0, (ULONG_PTR *)&pWState);
    if (pWState == (WSBState *)NULL)    {
        return EnableScrollBar(hwnd, wSBflags, wArrows);
    } else if (pWState == WSB_UNINIT_HANDLE) {
        if (wArrows == ESB_ENABLE_BOTH)
            //  Leave it to later calls.
            return FALSE;
        else    {
            pWState = FlatSB_Internal_InitPwSB(hwnd);
            if (pWState == (WSBState *)NULL)
                return FALSE;
            else if (!SetWindowSubclass(hwnd, FlatSB_SubclassWndProc, 0,  (ULONG_PTR)pWState)) {
                DeleteObject(pWState->hbm_Bkg);
                DeleteObject(pWState->hbr_Bkg);
                LocalFree((HLOCAL)pWState);
                return FALSE;
            }
        }
    } else if (hwnd != pWState->sbHwnd) {
        return FALSE;
    }

    return FlatSB_Internal_EnableScrollBar(pWState, wSBflags, wArrows);
}

//=-------------------------------------------------------------
// FlatSB_Internal_EnableScrollBar
//
// Note:
//     The func will simply fail in case of uninitialized pointer
//     pWState is passed.
//     Since we now use WSBState * as handle, we always hope it's
//     valid already.
//
//     The following func is implemented following the comments in
//     winsbctl.c and the comment of the in MSDN library. In
//     access\inc16\windows.h you can find:
//     #define SB_DISABLE_MASK ESB_DISABLE_BOTH    // 0x03
//
//     The sbFlags is slightly different with rgwScroll[SB_FLAGS].
//=-------------------------------------------------------------

BOOL FlatSB_Internal_EnableScrollBar(WSBState * pWState, int wSBflags, UINT wArrows)
{
    int     wOldFlags;
    int     style;
    BOOL    bRetValue = FALSE;
    BOOL    bDrawHBar = FALSE;
    BOOL    bDrawVBar = FALSE;
    HDC     hdc;
    HWND    hwnd;

    ASSERT (wSBflags != SB_CTL);

    wOldFlags = pWState->sbFlags;
    hwnd = pWState->sbHwnd;

    style = GetWindowLong(hwnd, GWL_STYLE);

    switch (wSBflags)   {
    case SB_HORZ:
    case SB_BOTH:
        if (wArrows == ESB_ENABLE_BOTH)
            pWState->sbFlags &= ~WSB_HORZ;
        else
            pWState->sbFlags |= wArrows;

        if (wOldFlags != pWState->sbFlags)
        {
            bRetValue = TRUE;

            if (TestSTYLE(pWState->style, WFHPRESENT)
                && !TestSTYLE(style, WS_MINIMIZE)
                && IsWindowVisible(hwnd))
                bDrawHBar = TRUE;
        }

        if (wSBflags == SB_HORZ)
            break;
        else
            wOldFlags = pWState->sbFlags;       //  Fall through

    case SB_VERT:
        if (wArrows == ESB_ENABLE_BOTH)
            pWState->sbFlags &= ~WSB_VERT;
        else
            pWState->sbFlags |= (wArrows<<2);

        if (wOldFlags != pWState->sbFlags)
        {
            bRetValue = TRUE;

            if (TestSTYLE(pWState->style, WFVPRESENT)
                && !TestSTYLE(style, WS_MINIMIZE)
                && IsWindowVisible(hwnd))
                bDrawVBar = TRUE;
        }
        break;
    default:
        return FALSE;
    }

    if (bDrawVBar || bDrawHBar) {
        int oldLoc = pWState->locMouse;
        int newLoc;

        if (!(hdc = GetWindowDC(hwnd)))
            return(FALSE);

        newLoc = oldLoc;
        if (bDrawHBar)  {
            FlatSB_Internal_DrawScrollBar(pWState, hdc, FALSE, FALSE);
            if (pWState->fHActive)
                newLoc = pWState->locMouse;
        }
        if (bDrawVBar) {
            pWState->locMouse = oldLoc;
            FlatSB_Internal_DrawScrollBar(pWState, hdc, TRUE, FALSE);
            if (pWState->fVActive)
                newLoc = pWState->locMouse;
        }
        pWState->locMouse = newLoc;

        ReleaseDC(hwnd, hdc);
    }

    // Keep USER scrollbar in sync for accessibility
    if (bRetValue)
        EnableScrollBar(hwnd, wSBflags, wArrows);

    return bRetValue;
}

//=-------------------------------------------------------------
// FlatSB_Internal_DrawThumb2
//=-------------------------------------------------------------

void FlatSB_Internal_DrawThumb2(WSBState * pWState, HDC hdc, BOOL fVert, UINT wDisable)
{
    int     *pLength;
    int     *pWidth;
    HWND    hwnd;
    HBRUSH  hbr;

    hwnd = pWState->sbHwnd;
    hbr = (fVert)?pWState->hbr_VSBBkg:pWState->hbr_HSBBkg;

    // Bail out if the scrollbar has an empty rect
    if ((pWState->pxTop >= pWState->pxBottom)
        || (pWState->pxLeft >= pWState->pxRight))
        return;

    pLength = (int *) &(pWState->rcSB);
    if (fVert)
        pWidth = pLength++;
    else
        pWidth = pLength + 1;

    pWidth[0] = pWState->pxLeft;
    pWidth[2] = pWState->pxRight;

    // If both scroll arrows are disabled or if there isn't enough room for
    // the thumb, just erase the whole slide area and return
    if (((wDisable & LTUPFLAG) && (wDisable & RTDNFLAG)) ||
        ((pWState->pxDownArrow - pWState->pxUpArrow) < pWState->cpxThumb))
    {
        pLength[0] = pWState->pxUpArrow;
        pLength[2] = pWState->pxDownArrow;

        FlatSB_Internal_DrawGroove(pWState, hdc, &(pWState->rcSB), fVert);
        return;
    }

    //  UI designers want a at least 1 pixel gap between arrow and thumb.
    //  Have to do this :(
    if (pWState->pxUpArrow <= pWState->pxThumbTop)
    {
        // Fill in space above Thumb
        pLength[0] = pWState->pxUpArrow;
        pLength[2] = pWState->pxThumbTop;

        FlatSB_Internal_DrawGroove(pWState, hdc, &(pWState->rcSB), fVert);
    }

    if (pWState->pxThumbBottom <= pWState->pxDownArrow)
    {
        // Fill in space below Thumb
        pLength[0] = pWState->pxThumbBottom;
        pLength[2] = pWState->pxDownArrow;

        FlatSB_Internal_DrawGroove(pWState, hdc, &(pWState->rcSB), fVert);
    }

    // Draw elevator
    pLength[0] = pWState->pxThumbTop;
    pLength[2] = pWState->pxThumbBottom;

    FlatSB_Internal_DrawElevator(pWState, hdc, &(pWState->rcSB), fVert);

    // If we're tracking a page scroll, then we've obliterated the hilite.
    // We need to correct the hiliting rectangle, and rehilite it.

    if ((pWState->cmdSB == SB_PAGEUP || pWState->cmdSB == SB_PAGEDOWN)
        && pWState->fTrackVert == fVert)
    {
        pLength = (int *) &pWState->rcTrack;

        if (fVert)
            pLength++;

        if (pWState->cmdSB == SB_PAGEUP)
            pLength[2] = pWState->pxThumbTop;
        else
            pLength[0] = pWState->pxThumbBottom;

        if (pLength[0] < pLength[2])
            InvertRect(hdc, &(pWState->rcTrack));
    }
}

//=-------------------------------------------------------------
// DrawSB2
//=-------------------------------------------------------------

void FlatSB_Internal_DrawSB2(WSBState * pWState, HDC hdc, BOOL fVert, BOOL fRedraw, int oldLoc)
{
    int     cLength;
    int     cWidth;
    int     cpxArrow;
    int     *pwX;
    int     *pwY;
    int     newLoc = pWState->locMouse;
    UINT    wDisable = FlatSB_Internal_GetSBFlags(pWState, fVert);
    HBRUSH  hbrSave;
    HWND    hwnd;
    RECT    rc, * prcSB;

    hwnd = pWState->sbHwnd;
    cLength = (pWState->pxBottom - pWState->pxTop) / 2;
    cWidth = (pWState->pxRight - pWState->pxLeft);

    if ((cLength <= 0) || (cWidth <= 0))
        return;

    cpxArrow = (fVert) ? pWState->y_VSBArrow : pWState->x_HSBArrow;

    if (cLength > cpxArrow)
        cLength = cpxArrow;
    prcSB = &(pWState->rcSB);
    pwX = (int *)prcSB;
    pwY = pwX + 1;
    if (!fVert)
        pwX = pwY--;

    pwX[0] = pWState->pxLeft;
    pwY[0] = pWState->pxTop;
    pwX[2] = pWState->pxRight;
    pwY[2] = pWState->pxBottom;

    hbrSave = SelectObject(hdc, GetSysColorBrush(COLOR_BTNTEXT));

    CopyRect(&rc, prcSB);
    if (fVert)
    {
        rc.bottom = rc.top + cLength;
        if (!fRedraw || newLoc == WSB_MOUSELOC_ARROWUP
                     || oldLoc == WSB_MOUSELOC_ARROWUP)
            FlatSB_Internal_DrawArrow(pWState, hdc, &rc, DFCS_SCROLLUP,
               ((wDisable & LTUPFLAG) ? DFCS_INACTIVE : 0));

        rc.bottom = prcSB->bottom;
        rc.top = prcSB->bottom - cLength;
        if (!fRedraw || newLoc == WSB_MOUSELOC_ARROWDN
                     || oldLoc == WSB_MOUSELOC_ARROWDN)
            FlatSB_Internal_DrawArrow(pWState, hdc, &rc, DFCS_SCROLLDOWN,
               ((wDisable & RTDNFLAG) ? DFCS_INACTIVE : 0));
    }
    else
    {
        rc.right = rc.left + cLength;
        if (!fRedraw || newLoc == WSB_MOUSELOC_ARROWLF
                     || oldLoc == WSB_MOUSELOC_ARROWLF)
            FlatSB_Internal_DrawArrow(pWState, hdc, &rc, DFCS_SCROLLLEFT,
                ((wDisable & LTUPFLAG) ? DFCS_INACTIVE : 0));

        rc.right = prcSB->right;
        rc.left = prcSB->right - cLength;
        if (!fRedraw || newLoc == WSB_MOUSELOC_ARROWRG
                     || oldLoc == WSB_MOUSELOC_ARROWRG)
            FlatSB_Internal_DrawArrow(pWState, hdc, &rc, DFCS_SCROLLRIGHT,
                ((wDisable & RTDNFLAG) ? DFCS_INACTIVE : 0));
    }

    SelectObject(hdc, hbrSave);

    if (!fRedraw)
        FlatSB_Internal_DrawThumb2(pWState, hdc, fVert, wDisable);
    else if (!fVert  || newLoc == WSB_MOUSELOC_H_THUMB
                     || oldLoc == WSB_MOUSELOC_H_THUMB)
        FlatSB_Internal_DrawThumb2(pWState, hdc, fVert, wDisable);
    else if (fVert   || newLoc == WSB_MOUSELOC_V_THUMB
                     || oldLoc == WSB_MOUSELOC_V_THUMB)
        FlatSB_Internal_DrawThumb2(pWState, hdc, fVert, wDisable);
    else
        return;
}

//=-------------------------------------------------------------
// FlatSB_Internal_CalcSBStuff2
//=-------------------------------------------------------------

void FlatSB_Internal_CalcSBStuff2(WSBState * pWState, LPRECT lprc, BOOL fVert)
{
    int     cpxThumb;    // Height of (V)scroll bar thumb.
    int     cpxArrow;    // Height of (V)scroll bar arrow.
    int     cpxSpace;    // The space in scroll bar;
    int     pxTop;
    int     pxBottom;
    int     pxLeft;
    int     pxRight;
    int     pxUpArrow;
    int     pxDownArrow;
    int     pxThumbTop;
    int     pxThumbBottom;
    int     pxMouse;
    int     locMouse;
    int     dwRange, page, relPos;
    BOOL    fSBActive;

    if (fVert) {
        pxTop    = lprc->top;
        pxBottom = lprc->bottom;
        pxLeft   = lprc->left;
        pxRight  = lprc->right;
        cpxArrow = pWState->y_VSBArrow;
        cpxThumb = pWState->y_VSBThumb;
        relPos = pWState->sbVThumbPos - pWState->sbVMinPos;
        page = pWState->sbVPage;
        dwRange = pWState->sbVMaxPos - pWState->sbVMinPos + 1;
        pxMouse = pWState->ptMouse.y;
        fSBActive = pWState->fVActive;
    } else {
        // For horiz scroll bars, "left" & "right" are "top" and "bottom",
        // and vice versa.
        pxTop    = lprc->left;
        pxBottom = lprc->right;
        pxLeft   = lprc->top;
        pxRight  = lprc->bottom;
        cpxArrow = pWState->x_HSBArrow;
        cpxThumb = pWState->x_HSBThumb;
        relPos = pWState->sbHThumbPos - pWState->sbHMinPos;
        page = pWState->sbHPage;
        dwRange = pWState->sbHMaxPos - pWState->sbHMinPos + 1;
        pxMouse = pWState->ptMouse.x;
        fSBActive = pWState->fHActive;
    }

    // For the case of short scroll bars that don't have enough
    // room to fit the full-sized up and down arrows, shorten
    // their sizes to make 'em fit

    cpxArrow = min((pxBottom - pxTop) >> 1, cpxArrow);

    pxUpArrow   = pxTop    + cpxArrow;
    pxDownArrow = pxBottom - cpxArrow;

    cpxSpace = pxDownArrow - pxUpArrow;
    if (page)
    {
        // JEFFBOG -- This is the one and only place where we should
        // see 'range'.  Elsewhere it should be 'range - page'.
        cpxThumb = max(DMultDiv(cpxSpace, page, dwRange),
                        min(cpxThumb, MINITHUMBSIZE));
    }
    cpxSpace -= cpxThumb;

    pxThumbTop = DMultDiv(relPos, cpxSpace, dwRange - (page ? page : 1)) + pxUpArrow;
    pxThumbBottom = pxThumbTop + cpxThumb;

    // Save it to local structure
    pWState->pxLeft     = pxLeft;
    pWState->pxRight    = pxRight;
    pWState->pxTop      = pxTop;
    pWState->pxBottom   = pxBottom;
    pWState->pxUpArrow  = pxUpArrow;
    pWState->pxDownArrow    = pxDownArrow;
    pWState->pxThumbTop = pxThumbTop;
    pWState->pxThumbBottom  = pxThumbBottom;
    pWState->cpxArrow   = cpxArrow;
    pWState->cpxThumb   = cpxThumb;
    pWState->cpxSpace   = cpxSpace;
    pWState->fVertSB    = fVert;

    if (pWState->fTracking) {
        return;
    } else if (!fSBActive)  {
        locMouse = WSB_MOUSELOC_OUTSIDE;
    } else if (pxMouse < pxTop) {
        locMouse = WSB_MOUSELOC_OUTSIDE;
    } else if (pxMouse < pxUpArrow) {
        locMouse = WSB_MOUSELOC_ARROWUP;
    } else if (pxMouse < pxThumbTop) {
        locMouse = WSB_MOUSELOC_V_GROOVE;
    } else if (pxMouse >= pxBottom) {
        locMouse = WSB_MOUSELOC_OUTSIDE;
    } else if (pxMouse >= pxDownArrow) {
        locMouse = WSB_MOUSELOC_ARROWDN;
    } else if (pxMouse >= pxThumbBottom) {
        locMouse = WSB_MOUSELOC_V_GROOVE;
    } else    {   //   pxThumbTop <= pxMouse < pxThumbBottom
        if (pxDownArrow - pxUpArrow <= cpxThumb)    {   //  No space for thumnb.
            locMouse = WSB_MOUSELOC_V_GROOVE;
        } else  {
            locMouse = WSB_MOUSELOC_V_THUMB;
        }
    }
    if ((!fVert) && locMouse)
        locMouse += 4;

    pWState->locMouse = locMouse;
}

//=-------------------------------------------------------------
// FlatSB_Internal_CalcSBStuff
//
// Note:
//  We won't call InitPwSB in this func.
//=-------------------------------------------------------------

void FlatSB_Internal_CalcSBStuff(WSBState * pWState, BOOL fVert)
{
    HWND    hwnd;
    RECT    rcT;
    int     style;

    if (pWState == (WSBState *)NULL)
        return;

    hwnd = pWState->sbHwnd;
    style = GetWindowLong(hwnd, GWL_STYLE);

    if (fVert)
    {
        // Only add on space if vertical scrollbar is really there.
        rcT.right = rcT.left = pWState->rcClient.right;
        if (TestSTYLE(pWState->style, WFVPRESENT))
            rcT.right += pWState->x_VSBArrow;
        rcT.top = pWState->rcClient.top;
        rcT.bottom = pWState->rcClient.bottom;
    }
    else
    {
        // Only add on space if horizontal scrollbar is really there.
        rcT.bottom = rcT.top = pWState->rcClient.bottom;
        if (TestSTYLE(pWState->style, WFHPRESENT))
            rcT.bottom += pWState->y_HSBArrow;

        rcT.left = pWState->rcClient.left;
        rcT.right = pWState->rcClient.right;
    }

    FlatSB_Internal_CalcSBStuff2(pWState, &rcT, fVert);
}

//=-------------------------------------------------------------
// FlatSB_Internal_DrawThumb
//=-------------------------------------------------------------

void FlatSB_Internal_DrawThumb(WSBState * pWState, BOOL fVert)
{
    HWND    hwnd = pWState->sbHwnd;
    HDC     hdc;
    UINT    wDisableFlags;

    hdc = (HDC) GetWindowDC(hwnd);
    FlatSB_Internal_CalcSBStuff(pWState, fVert);

    wDisableFlags = FlatSB_Internal_GetSBFlags(pWState, fVert);
    FlatSB_Internal_DrawThumb2(pWState, hdc, fVert, wDisableFlags);
    ReleaseDC(hwnd, hdc);
}

BOOL FlatSB_Internal_SBSetParms(int * pw, SCROLLINFO si, BOOL * lpfScroll, LRESULT * lplres, BOOL bOldPos)
{
    // pass the struct because we modify the struct but don't want that
    // modified version to get back to the calling app

    BOOL fChanged = FALSE;

    if (bOldPos)
        // save previous position
        *lplres = pw[SBO_POS];

    if (si.fMask & SIF_RANGE)
    {
        // if the range MAX is below the range MIN -- then treat is as a
        // zero range starting at the range MIN.
        if (si.nMax < si.nMin)
            si.nMax = si.nMin;

        if ((pw[SBO_MIN] != si.nMin) || (pw[SBO_MAX] != si.nMax))
        {
            pw[SBO_MIN] = si.nMin;
            pw[SBO_MAX] = si.nMax;

            if (!(si.fMask & SIF_PAGE))
            {
                si.fMask |= SIF_PAGE;
                si.nPage = pw[SBO_PAGE];
            }

            if (!(si.fMask & SIF_POS))
            {
                si.fMask |= SIF_POS;
                si.nPos = pw[SBO_POS];
            }

            fChanged = TRUE;
        }
    }

    if (si.fMask & SIF_PAGE)
    {
        unsigned dwMaxPage = abs(pw[SBO_MAX] - pw[SBO_MIN]) + 1;

        if (si.nPage > dwMaxPage)
            si.nPage = dwMaxPage;

        if (pw[SBO_PAGE] != (int) si.nPage)
        {
            pw[SBO_PAGE] = (int) si.nPage;

            if (!(si.fMask & SIF_POS))
            {
                si.fMask |= SIF_POS;
                si.nPos = pw[SBO_POS];
            }

            fChanged = TRUE;
        }
    }

    if (si.fMask & SIF_POS)
    {
        // Clip pos to posMin, posMax - (page - 1).
        int lMaxPos = pw[SBO_MAX] - ((pw[SBO_PAGE]) ? pw[SBO_PAGE] - 1 : 0);

        // * BOGUS -- show this to SIMONK -- the following doesn't generate *
        // * proper code so I had to use the longer form                    *
        // * si.nPos = min(max(si.nPos, pw[SBO_MIN]), lMaxPos);             *

        if (si.nPos < pw[SBO_MIN])
            si.nPos = pw[SBO_MIN];
        else if (si.nPos > lMaxPos)
            si.nPos = lMaxPos;

        if (pw[SBO_POS] != si.nPos)
        {
            pw[SBO_POS] = si.nPos;
            fChanged = TRUE;
        }
    }

    if (!(bOldPos))
        // Return the new position
        *lplres = pw[SBO_POS];

    if (si.fMask & SIF_RANGE)
    {
        if (*lpfScroll = (pw[SBO_MIN] != pw[SBO_MAX]))
            goto checkPage;
    }
    else if (si.fMask & SIF_PAGE)
checkPage:
        *lpfScroll = (pw[SBO_PAGE] <= (pw[SBO_MAX] - pw[SBO_MIN]));

    return(fChanged);
}


//=-------------------------------------------------------------
// FlatSB_Internal_SetScrollBar
//
// Note:
//     This func is called by SetScrollPos/Range/Info. We let
//     the callers take care of checking pWState.
//     Return 0 if failed.
//=-------------------------------------------------------------

LRESULT FlatSB_Internal_SetScrollBar(WSBState *pWState, int code, LPSCROLLINFO lpsi, BOOL fRedraw)
{
    BOOL    fVert;
    int     *pw;
    BOOL    fOldScroll;
    BOOL    fScroll;
    BOOL    bReturnOldPos = TRUE;
    LRESULT lres;
    int     wfScroll;
    HWND    hwnd = pWState->sbHwnd;

    ASSERT (code != SB_CTL);

    // window must be visible to redraw
    if (fRedraw)
        fRedraw = IsWindowVisible(hwnd);

    fVert = (code != SB_HORZ);
    bReturnOldPos = (lpsi->fMask == SIF_POS);

    wfScroll = (fVert) ? WS_VSCROLL : WS_HSCROLL;

    fScroll = fOldScroll = (TestSTYLE(pWState->style, wfScroll)) ? TRUE : FALSE;

    // Don't do anything if we're NOT setting the range and the scroll doesn't
    // exist.
    if (!(lpsi->fMask & SIF_RANGE) && !fOldScroll)
    {
        return(0);
    }

    pw = &(pWState->sbFlags);

    // user.h: SBO_VERT = 5, SBO_HORZ = 1;
    //  pw += (fVert) ? SBO_VERT : SBO_HORZ;
    pw += (fVert)? 5 : 1;

    // Keep USER scrollbars in sync for accessibility
    SetScrollInfo(hwnd, code, lpsi, FALSE);

    if (!FlatSB_Internal_SBSetParms(pw, *lpsi, &fScroll, &lres, bReturnOldPos))
    {
        // no change -- but if REDRAW is specified and there's a scrollbar,
        // redraw the thumb
        if (fOldScroll && fRedraw)
            goto redrawAfterSet;

        return(lres);
    }

    if (fScroll)
        pWState->style |= wfScroll;
    else
        pWState->style &= ~wfScroll;

    // Keep style bits in sync so OLEACC can read them
    SetWindowBits(hwnd, GWL_STYLE, WS_VSCROLL | WS_HSCROLL, pWState->style);

    if (lpsi->fMask & SIF_DISABLENOSCROLL)
    {
        if (fOldScroll)
        {
            pWState->style |= wfScroll;

            // Keep style bits in sync so OLEACC can read them
            SetWindowBits(hwnd, GWL_STYLE, WS_VSCROLL | WS_HSCROLL, pWState->style);

            FlatSB_Internal_EnableScrollBar(pWState, code, (fScroll) ? ESB_ENABLE_BOTH : ESB_DISABLE_BOTH);
        }
    }
    else if (fOldScroll ^ fScroll)
    {
        CCInvalidateFrame(hwnd);
        return(lres);
    }

    if (fScroll && fRedraw && (fVert ? TestSTYLE(pWState->style, WFVPRESENT) : TestSTYLE(pWState->style, WFHPRESENT)))
    {
redrawAfterSet:

        // Don't send this, since USER already sent one for us when we
        // called SetScrollBar.
        // FlatSB_Internal_NotifyWinEvent(pWState, EVENT_OBJECT_VALUECHANGE, INDEX_SCROLLBAR_SELF);

        // Bail out if the caller is trying to change a scrollbar which is
        // in the middle of tracking.  We'll hose FlatSB_Internal_TrackThumb() otherwise.

        // BUGBUG: CalcSBStuff will change locMouse!
        if (pWState->pfnSB == FlatSB_Internal_TrackThumb)
        {
            FlatSB_Internal_CalcSBStuff(pWState, fVert);
            return(lres);
        }
        FlatSB_Internal_DrawThumb(pWState, fVert);
    }

    return(lres);
}

//=-------------------------------------------------------------
//  SetScrollPos()
//=-------------------------------------------------------------

int WINAPI FlatSB_SetScrollPos(HWND hwnd, int code, int pos, BOOL fRedraw)
{
    SCROLLINFO  si;
    WSBState * pWState;

    GetWindowSubclass(hwnd, FlatSB_SubclassWndProc, 0, (ULONG_PTR *)&pWState);
    if (pWState == (WSBState *)NULL)    {
        return SetScrollPos(hwnd, code, pos, fRedraw);
    } else if (pWState == WSB_UNINIT_HANDLE) {
        return 0;
    } else if (hwnd != pWState->sbHwnd) {
        return 0;
    }

    si.cbSize = sizeof(si);
    si.fMask = SIF_POS;
    si.nPos = pos;
    
    return (int)FlatSB_Internal_SetScrollBar(pWState, code, &si, fRedraw);
}

//=-------------------------------------------------------------
//  SetScrollRange()
//=-------------------------------------------------------------

BOOL WINAPI FlatSB_SetScrollRange(HWND hwnd, int code, int nMin, int nMax, BOOL fRedraw)
{
    SCROLLINFO si;
    WSBState * pWState;

    GetWindowSubclass(hwnd, FlatSB_SubclassWndProc, 0, (ULONG_PTR *)&pWState);
    if (pWState == (WSBState *)NULL)    {
        return SetScrollRange(hwnd, code, nMin, nMax, fRedraw);
    } else if (pWState == WSB_UNINIT_HANDLE) {
        pWState = FlatSB_Internal_InitPwSB(hwnd);
        if (pWState == (WSBState *)NULL)
            return FALSE;
        else if (!SetWindowSubclass(hwnd, FlatSB_SubclassWndProc, 0,  (ULONG_PTR)pWState))  {
            DeleteObject(pWState->hbm_Bkg);
            DeleteObject(pWState->hbr_Bkg);
            LocalFree((HLOCAL)pWState);
            return FALSE;
        }
        //  In this case we always need to (re)draw the scrollbar.
        fRedraw = TRUE;
    } else if (hwnd != pWState->sbHwnd) {
        return FALSE;
    }


    //
    // Still need MAXINT check for PackRat 4.  32-bit apps don't
    // go thru this--we wrap 'em to SetScrollInfo() on the 32-bit side,
    // so DWORD precision is preserved.
    //
    if ((UINT)(nMax - nMin) > 0x7FFF)
        return FALSE;

    si.cbSize = sizeof(si);
    si.fMask = SIF_RANGE;
    si.nMin = nMin;
    si.nMax = nMax;

    FlatSB_Internal_SetScrollBar(pWState, code, &si, fRedraw);

    return(TRUE);
}


//=-------------------------------------------------------------
//  SetScrollInfo()
//
//  Note:
//      Inconsistent with 'user' code. Under no circumstance will
//      we create a new scrollbar(by allocate a new buffer).
//=-------------------------------------------------------------

int WINAPI FlatSB_SetScrollInfo(HWND hwnd, int code, LPSCROLLINFO lpsi, BOOL fRedraw)
{
    WSBState * pWState;

    //  ZDC@Oct. 10, Detect GP faults here.
    if ((LPSCROLLINFO)NULL == lpsi)
        return FALSE;

    if (lpsi->cbSize < sizeof (SCROLLINFO))
        return FALSE;

    GetWindowSubclass(hwnd, FlatSB_SubclassWndProc, 0, (ULONG_PTR *)&pWState);
    if (pWState == (WSBState *)NULL)    {
        return SetScrollInfo(hwnd, code, lpsi, fRedraw);
    } else if (pWState == WSB_UNINIT_HANDLE) {
        if (!(lpsi->fMask & SIF_RANGE))
            return 0;
        pWState = FlatSB_Internal_InitPwSB(hwnd);
        if (pWState == (WSBState *)NULL)
            return 0;
        else if (!SetWindowSubclass(hwnd, FlatSB_SubclassWndProc, 0,  (ULONG_PTR)pWState)) {
            DeleteObject(pWState->hbm_Bkg);
            DeleteObject(pWState->hbr_Bkg);
            LocalFree((HLOCAL)pWState);
            return 0;
        }

        //  In this case we always need to (re)draw the scrollbar.
        fRedraw = TRUE;
    } else if (hwnd != pWState->sbHwnd) {
        return 0;
    }

    //  ZDC@Oct 9, We should always return new pos. How ever, if the fMask
    //  is SIF_POS, SetScrollBar returns the old pos.
    if (lpsi->fMask == SIF_POS)
        lpsi->fMask = SIF_POS | SIF_TRACKPOS;

    return (int)FlatSB_Internal_SetScrollBar(pWState, code, lpsi, fRedraw);
}

//=-------------------------------------------------------------
// FlatSB_SetScrollProp
//     This functions shouldn't be called we we are tracking.
//=-------------------------------------------------------------

BOOL WINAPI FlatSB_SetScrollProp(HWND hwnd, UINT index, INT_PTR newValue, BOOL fRedraw)
{
    BOOL    fResize = FALSE;
    BOOL    fVert = FALSE;
    WSBState * pWState;

    GetWindowSubclass(hwnd, FlatSB_SubclassWndProc, 0, (ULONG_PTR *)&pWState);
    if (pWState == (WSBState *)NULL)
        return FALSE;
    else if (pWState == WSB_UNINIT_HANDLE)  {
        pWState = FlatSB_Internal_InitPwSB(hwnd);
        if (pWState == (WSBState *)NULL)
            return 0;
        else if (!SetWindowSubclass(hwnd, FlatSB_SubclassWndProc, 0,  (ULONG_PTR)pWState)) {
            DeleteObject(pWState->hbm_Bkg);
            DeleteObject(pWState->hbr_Bkg);
            LocalFree((HLOCAL)pWState);
            return 0;
        }

        //  In this case we don't want to (re)draw the scrollbar.
        fRedraw = FALSE;
    }

    if (pWState->fTracking)
        return FALSE;

    switch (index) {
    case WSB_PROP_CXVSCROLL:
        if ((int)newValue == pWState->metApp.cxVSBArrow)
            return TRUE;
        pWState->metApp.cxVSBArrow = (int)newValue;
        fResize = TRUE;
        break;

    case WSB_PROP_CXHSCROLL:
        if ((int)newValue == pWState->metApp.cxHSBArrow)
            return TRUE;
        pWState->metApp.cxHSBArrow = (int)newValue;
        fResize = TRUE;
        break;

    case WSB_PROP_CYVSCROLL:
        if ((int)newValue == pWState->metApp.cyVSBArrow)
            return TRUE;
        pWState->metApp.cyVSBArrow = (int)newValue;
        fResize = TRUE;
        break;

    case WSB_PROP_CYHSCROLL:
        if ((int)newValue == pWState->metApp.cyHSBArrow)
            return TRUE;
        pWState->metApp.cyHSBArrow = (int)newValue;
        fResize = TRUE;
        break;

    case WSB_PROP_CXHTHUMB:
        if ((int)newValue == pWState->metApp.cxHSBThumb)
            return TRUE;
        pWState->metApp.cxHSBThumb = (int)newValue;
        fResize = TRUE;
        break;

    case WSB_PROP_CYVTHUMB:
        if ((int)newValue == pWState->metApp.cyVSBThumb)
            return TRUE;
        pWState->metApp.cyVSBThumb = (int)newValue;
        fResize = TRUE;
        break;

    case WSB_PROP_VBKGCOLOR:
        if ((COLORREF)newValue == pWState->col_VSBBkg)
            return TRUE;
        pWState->col_VSBBkg = (COLORREF)newValue;
        fVert = TRUE;
        break;
    case WSB_PROP_HBKGCOLOR:
        if ((COLORREF)newValue == pWState->col_HSBBkg)
            return TRUE;
        pWState->col_HSBBkg = (COLORREF)newValue;
        break;

    case WSB_PROP_PALETTE:
        if ((HPALETTE)newValue == pWState->hPalette)
            return TRUE;
        pWState->hPalette = (HPALETTE)newValue;
        break;
    case WSB_PROP_VSTYLE:
        if ((int)newValue == pWState->vStyle)
            return TRUE;
        pWState->vStyle = (int)newValue;
        fVert = TRUE;
        break;
    case WSB_PROP_HSTYLE:
        if ((int)newValue == pWState->hStyle)
            return TRUE;
        pWState->hStyle = (int)newValue;
        break;
    case WSB_PROP_GUTTER:
        if ((int)newValue == pWState->sbGutter)
            return TRUE;
        pWState->sbGutter = (int)newValue;
        break;

    default:
        return FALSE;
    }

    if (fResize)    {
    // Always redraw after we change the size.
        CCInvalidateFrame(hwnd);
    } else if (fRedraw) {
        HDC hdc;
        int oldLoc = pWState->locMouse;
        int fSBActive = (fVert)?pWState->fVActive:pWState->fHActive;

        hdc = GetWindowDC(hwnd);
        FlatSB_Internal_DrawScrollBar(pWState, hdc, fVert, FALSE /* Not redraw*/);
        if (!fSBActive)
            pWState->locMouse = oldLoc;
        ReleaseDC(hwnd, hdc);
    }
    return TRUE;
}

//=-------------------------------------------------------------
//  FlatSB_Internal_DrawScrollBar()
//=-------------------------------------------------------------

void FlatSB_Internal_DrawScrollBar(WSBState * pWState, HDC hdc, BOOL fVert, BOOL fRedraw)
{
    int oldLoc = pWState->locMouse;

    FlatSB_Internal_CalcSBStuff(pWState, fVert);
    if ((!fRedraw) || oldLoc != pWState->locMouse)
        FlatSB_Internal_DrawSB2(pWState, hdc, fVert, fRedraw, oldLoc);
}

//=------------------------------------------------------------
//  FlatSB_Internal_IsSizeBox
//      It's still an incomplete mimic of SizeBoxWnd in user/winwhere.c
//=------------------------------------------------------------

BOOL FlatSB_Internal_IsSizeBox(HWND hwndStart)
{
    int style;
    HWND hwnd, hwndDesktop;
    int cxEdge, cyEdge;
    RECT rcChild, rcParent;

    ASSERT(hwndStart);
    hwnd = hwndStart;
    hwndDesktop = GetDesktopWindow();

    cxEdge = GetSystemMetrics(SM_CXEDGE);
    cyEdge = GetSystemMetrics(SM_CYEDGE);
    if (!GetWindowRect(hwnd, &rcChild))
        return FALSE;
    do  {
        style = GetWindowStyle(hwnd);
        if (TestSTYLE(style, WS_SIZEBOX))   {
            if (IsZoomed(hwnd))
                return FALSE;
            else    {
                POINT pt;

                GetClientRect(hwnd, &rcParent);

                pt.x = rcParent.right;
                pt.y = rcParent.bottom;

                ClientToScreen(hwnd, &pt);

                if (rcChild.right + cxEdge < pt.x)
                    return FALSE;
                if (rcChild.bottom + cyEdge < pt.y)
                    return FALSE;
                return TRUE;
            }
        } else  {
            hwnd = GetParent(hwnd);
        }
    }

    while ((hwnd) && (hwnd != hwndDesktop));
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\dlgcset.cpp ===
//
// File: dlgcset.cpp
//
// This file contains the code that implements CNativeFont class.
//
// history:
//     7-21-97 created; 
// 
#include "ctlspriv.h"
#include "ccontrol.h"

#define THISCLASS CNativeFont
#define SUPERCLASS CControl

typedef enum 
{
    FAS_NOTINITIALIZED = 0,
    FAS_DISABLED,
    FAS_ENABLED,
} FASTATUS;

class CNativeFont : public CControl
{
public:
    //Function Memebers
    virtual LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static LRESULT NativeFontWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    
protected:
    
    CNativeFont();
    
    //Function Members    

    virtual void v_OnPaint(HDC hdc) ;
    virtual LRESULT v_OnCreate();
    virtual void v_OnSize(int x, int y)  {};

    virtual LRESULT v_OnCommand(WPARAM wParam, LPARAM lParam);
    virtual LRESULT v_OnNotify(WPARAM wParam, LPARAM lParam);
    virtual DWORD v_OnStyleChanged(WPARAM wParam, LPARAM lParam) { return 0; };    
    
    HRESULT _GetNativeDialogFont(HWND hDlg);
    static HRESULT _GetFontAssocStatus(FASTATUS  *uiAssoced);
    static BOOL _SetFontEnumProc(HWND hwnd, LPARAM lparam);
    static LRESULT _SubclassDlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam, WPARAM uIdSubclass, ULONG_PTR dwRefData);

    HFONT   m_hfontOrg;
    HFONT   m_hfontNative;
    HFONT   m_hfontDelete;
    typedef struct {
                HFONT hfontSet;
                DWORD dwStyle;
            } NFENUMCHILDDATA;
    static FASTATUS _s_uiFontAssocStatus;
};

// static variable initialization
FASTATUS CNativeFont::_s_uiFontAssocStatus = FAS_NOTINITIALIZED;

// reg keys
static const TCHAR s_szRegFASettings[] = TEXT("System\\CurrentControlSet\\Control\\FontAssoc\\Associated Charset");

CNativeFont::CNativeFont(void)
{
    m_hfontOrg = NULL;
    m_hfontNative = NULL;
    m_hfontDelete = NULL;
}

LRESULT THISCLASS::NativeFontWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CNativeFont *pn = (CNativeFont *)GetWindowLongPtr(hwnd, 0);
    if (uMsg == WM_CREATE) {
        ASSERT(!pn);
        pn = new CNativeFont();
        if (!pn)
            return 0L;
    } 

    if (pn) {
        return pn->v_WndProc(hwnd, uMsg, wParam, lParam);
    }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

void THISCLASS::v_OnPaint(HDC hdc)
{
    return;
}

LRESULT THISCLASS::v_OnCommand(WPARAM wParam, LPARAM lParam)
{
    // forward to parent (do we really need this?)
    return SendMessage(ci.hwndParent, WM_COMMAND, wParam, lParam);
}

LRESULT THISCLASS::v_OnNotify(WPARAM wParam, LPARAM lParam)
{
    // forward to parent
    LPNMHDR lpNmhdr = (LPNMHDR)lParam;
    
    return SendNotifyEx(ci.hwndParent, (HWND) -1,
                         lpNmhdr->code, lpNmhdr, ci.bUnicode);
}

LRESULT THISCLASS::v_OnCreate()
{
    return TRUE;
}

BOOL THISCLASS::_SetFontEnumProc(HWND hwnd, LPARAM lparam)
{
     NFENUMCHILDDATA *  pdt = (NFENUMCHILDDATA *)lparam; 
     BOOL bMatch = FALSE;
     
     if (pdt && pdt->hfontSet)
     {
         if (pdt->dwStyle & NFS_ALL)
         {
             bMatch = TRUE;
         }
         else
         {
             TCHAR szClass[32];
             
             GetClassName(hwnd, szClass, ARRAYSIZE(szClass));
             
             if (pdt->dwStyle & NFS_EDIT)
             {
                 bMatch |= (lstrcmpi(TEXT("Edit"), szClass) == 0);
                 bMatch |= (lstrcmpi(TEXT("RichEdit20A"), szClass) == 0);
                 bMatch |= (lstrcmpi(TEXT("RichEdit20W"), szClass) == 0);
             }
             
             if (pdt->dwStyle & NFS_STATIC)
                 bMatch |= (lstrcmpi(TEXT("Static"), szClass) == 0);
             
             if (pdt->dwStyle & NFS_BUTTON)
                 bMatch |= (lstrcmpi(TEXT("Button"), szClass) == 0);

             if (pdt->dwStyle & NFS_LISTCOMBO)
             {
                 bMatch |= (lstrcmpi(TEXT("ListBox"), szClass) == 0);
                 bMatch |= (lstrcmpi(TEXT("ComboBox"), szClass) == 0);
                 bMatch |= (lstrcmpi(TEXT("ComboBoxEx32"), szClass) == 0);
                 bMatch |= (lstrcmpi(TEXT("SysListView32"), szClass) == 0);
             }
         }

         if (bMatch) 
             SendMessage(hwnd, WM_SETFONT, (WPARAM)pdt->hfontSet, MAKELPARAM(FALSE, 0));

         return TRUE;
     }
     else
         return FALSE;
}

LRESULT THISCLASS::_SubclassDlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam, WPARAM uIdSubclass, ULONG_PTR dwRefData)
{
    LRESULT lret = 0;
    CNativeFont * pnf = (CNativeFont *)dwRefData;
    
    if (pnf)
    {
    
        switch (uMsg)
        {
            case WM_INITDIALOG:
                // we enumerate its children so they get font 
                // in native charset selected if necessary
                // 
                if (S_OK == pnf->_GetNativeDialogFont(hdlg))
                {
                    // S_OK means we have different charset from 
                    // the default of the platform on which we're 
                    // running.
                    NFENUMCHILDDATA dt;
                    dt.hfontSet = pnf->m_hfontNative;
                    dt.dwStyle = pnf->ci.style;
                    EnumChildWindows(hdlg, pnf->_SetFontEnumProc, (LPARAM)&dt);
                }
                // we no longer need subclass procedure.
                // assumes no one has subclassed this dialog by now
                break;

            case WM_DESTROY:
                // if we've created a font, we have to clean it up.
                if (pnf->m_hfontDelete)
                {
                    NFENUMCHILDDATA dt;
                
                    dt.hfontSet = pnf->m_hfontOrg;
                    dt.dwStyle = pnf->ci.style;
                    // just in case anyone is still alive
                    EnumChildWindows(hdlg, pnf->_SetFontEnumProc, (LPARAM)&dt);
                    DeleteObject(pnf->m_hfontDelete);
                    pnf->m_hfontDelete = NULL;
                }
                RemoveWindowSubclass(hdlg, pnf->_SubclassDlgProc, 0);

                break;
        }
    
        lret = DefSubclassProc(hdlg, uMsg, wParam, lParam);
    }
 
    return lret;
}

LRESULT THISCLASS::v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HWND hdlg;
    
    switch (uMsg)
    {
        case WM_CREATE:
        // subclass the parent dialog just to get notified for WM_INITDIALOG
            hdlg = GetParent(hwnd);
            if (hdlg)
            {
                // if we had an error just do nothing, we have to succeed in creating
                // window anyway otherwise dialog fails.
                SetWindowSubclass(hdlg, _SubclassDlgProc, 0, (ULONG_PTR)this);
            }
            break;
    }
    return SUPERCLASS::v_WndProc(hwnd, uMsg, wParam, lParam);
}

// _GetNativeDialogFont
//
// Retreive font handle in platform native character set
//
// returns S_OK if the given dialogbox requires setting font
//              in native charset
//         S_FALSE if the given dialogbox already has native
//              charset.
//         E_FAIL if anyother error occurs
//
HRESULT THISCLASS::_GetNativeDialogFont(HWND hDlg)
{
    HRESULT hres = E_FAIL;
    
    if(!m_hfontNative)
    {
        HFONT hfontNative, hfont = GetWindowFont(hDlg);
        LOGFONT lf, lfNative;
        FASTATUS uiFAStat = FAS_NOTINITIALIZED;
        GetObject(hfont, sizeof(LOGFONT), &lf);

        SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &lfNative, 0);
        
        // there are two cases we don't want to create/set font
        // for the platform native character set.
        // 1) we already have matching character set
        // 2) the platform has 'font assoc' enabled or 'font link'
        //    and our client wants to use it instead of
        //    setting the right character set. (NFS_USEFONTASSOC)
        //    this solution sometimes provides better
        //    appearance (thought it is broken in its 
        //    font metrics) because it would use 
        //    'western font' as is.
        if (ci.style & NFS_USEFONTASSOC)
        {
            _GetFontAssocStatus(&uiFAStat);
        }

        if ( uiFAStat == FAS_ENABLED
           || lfNative.lfCharSet == lf.lfCharSet)
        {
                
            m_hfontOrg = m_hfontNative = hfont;
        }
        else
        {
            // we have non-native charset for the platform
            // Save away the original font first.
            m_hfontOrg = hfont;
            
            // Use the height of original dialog font
            lfNative.lfHeight = lf.lfHeight;
            if (!(hfontNative=CreateFontIndirect(&lfNative)))
            {
                hfontNative = hfont;
            }

            // save it away so we can delete it later
            if (hfontNative != hfont)
                m_hfontDelete = hfont;
        
            // set this variable to avoid calling createfont twice
            // if we get called again.
            m_hfontNative = hfontNative;
        }
    }

    return hres = (m_hfontNative == m_hfontOrg ? S_FALSE : S_OK);
}

//
// _GetFontAssocStatus
//
// synopsis: check to see if the platform has "Font Association"
//           enabled or 'Font Link' capability
//
HRESULT THISCLASS::_GetFontAssocStatus(FASTATUS  *puiAssoced)
{
    HRESULT hr = S_OK;
    ASSERT(puiAssoced);
    
    // I assume the setting won't change without rebooting
    // the system
    //
    if (FAS_NOTINITIALIZED == _s_uiFontAssocStatus)
    {
        if (g_bRunOnNT5)
        {
            // NT5 has fontlink functionality
            _s_uiFontAssocStatus = FAS_ENABLED;
        }
        else
        {
            HKEY hkey;
            TCHAR szYesOrNo[16] = {0};
            if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                              s_szRegFASettings,
                             0, KEY_READ, &hkey) == ERROR_SUCCESS) 
            {
                DWORD dwSize = sizeof(szYesOrNo);
                RegQueryValueEx(hkey, TEXT("ANSI(00)"), 0, NULL, (LPBYTE)szYesOrNo, &dwSize);
                RegCloseKey(hkey);
            }
            else
            {
                // this only indicates the reg func failed
                // we can't always assume the key is there (Western)
                //
                hr = S_FALSE; 
            }
        
            if (SUCCEEDED(hr) && !lstrcmpi(szYesOrNo, TEXT("yes")))
            {
                // font assoc is enabled
                _s_uiFontAssocStatus = FAS_ENABLED;
            }
            else
                _s_uiFontAssocStatus = FAS_DISABLED;
        }
    }
    *puiAssoced = _s_uiFontAssocStatus;

    return hr;
}

extern "C" {
    
BOOL InitNativeFontCtl(HINSTANCE hinst)
{
    WNDCLASS wc;

    if (!GetClassInfo(hinst, WC_NATIVEFONTCTL, &wc)) {
        wc.lpfnWndProc     = THISCLASS::NativeFontWndProc;
        wc.hCursor         = LoadCursor(NULL, IDC_ARROW);
        wc.hIcon           = NULL;
        wc.lpszMenuName    = NULL;
        wc.hInstance       = hinst;
        wc.lpszClassName   = WC_NATIVEFONTCTL;
        wc.hbrBackground   = (HBRUSH)(COLOR_BTNFACE + 1); // NULL;
        wc.style           = CS_GLOBALCLASS;
        wc.cbWndExtra      = sizeof(LPVOID);
        wc.cbClsExtra      = 0;

        return RegisterClass(&wc);
    }
    return TRUE;
}

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\flat_sb.h ===
#ifndef _NEW_WSBCONTROL_H
#define _NEW_WSBCONTROL_H

//
//  When a screen reader is running, we switch to system metrics rather
//  than using the app metrics.  All the metrics are kept in this structure
//  so we can switch between them easily.
//
typedef struct WSBMETRICS {
    int cxVSBArrow;     //  x size of arrow for vertical scrollbar.
    int cxHSBArrow;
    int cxHSBThumb;

    int cyVSBArrow;
    int cyHSBArrow;
    int cyVSBThumb;

} WSBMETRICS, *PWSBMETRICS;

typedef struct WSBState {
    PWSBMETRICS pmet;       // The metrics that are active
    int style;          //  Win style.
                            //  px: Current coord. Used in Tracking.
    int px;                 //  Mouse message coord.
    int pxStart;            //  back to pxStart if tracking out of box.
    int dpxThumb;           //  pxThumbTop - px
    int pxBottom;       
    int pxDownArrow;
    int pxLeft;
    int pxOld;
    int pxRight;
    int pxThumbBottom;
    int pxThumbTop;
    int pxTop;
    int pxUpArrow;
    int cpxThumb;           //  cpx: Current size.
    int cpxArrow;
    int cpxSpace;

    int cmdSB;              //  Current scroll command.
    int posOld;             //  Thumb pos of last time.
    int posNew;             //  To support GetScrollInfo with SIF_TRACKPOS
    int posStart;           //  Thumb pos when we start tracking.

    void ( * pfnSB )(struct WSBState *, int, WPARAM, LPARAM);
    BOOL    fVertSB;        //  This variable shows if the last valid 
                            //  computation is on Vertical SB.
    BOOL    fHitOld;
    BOOL    fTrackVert;     //  This variable shows which scrollbar we are
                            //  tracking.
    BOOL    fTracking;      //  Critical section lock for locMouse.

    BOOL    fVActive;       //  Is mouse hovering on vertical SB?
    BOOL    fHActive;
    int     fInDoScroll;    //  Are we in the middle of a DoScroll?

    UINT_PTR hTimerSB;
    UINT_PTR hTrackSB;

    RECT rcSB;
    RECT rcClient;
    RECT rcTrack;
    
    int vStyle;             //  Style.
    int hStyle;

#define WSB_MOUSELOC_OUTSIDE    0
#define WSB_MOUSELOC_ARROWUP    1
#define WSB_MOUSELOC_ARROWDN    2
#define WSB_MOUSELOC_V_THUMB    3
#define WSB_MOUSELOC_V_GROOVE   4
#define WSB_MOUSELOC_ARROWLF    5
#define WSB_MOUSELOC_ARROWRG    6
#define WSB_MOUSELOC_H_THUMB    7
#define WSB_MOUSELOC_H_GROOVE   8

    POINT ptMouse;          //  to left-top corner of window
    int locMouse;

    COLORREF col_VSBBkg;
    COLORREF col_HSBBkg;
    HBRUSH hbr_VSBBkg;
    HBRUSH hbr_HSBBkg;
    HBRUSH hbr_Bkg;
    HBITMAP hbm_Bkg;
    HPALETTE hPalette;
    HWND sbHwnd;

    int sbFlags;
    int sbHMinPos;
    int sbHMaxPos;
    int sbHPage;
    int sbHThumbPos;
    int sbVMinPos;
    int sbVMaxPos;
    int sbVPage;
    int sbVThumbPos;
    int sbGutter;

    //
    //  Since OLEACC assumes that all scrollbars are the standard size,
    //  we revert to normal-sized scrollbars when a screenreader is running.
    //  The pmet member tells us which of these two is the one to use.
    WSBMETRICS metApp;      // The metrics the app selected
    WSBMETRICS metSys;      // The metrics from the system
} WSBState;

//
//  These macros let you get at the current metrics without realizing that
//  they could be shunted between the app metrics and system metrics.
//
#define x_VSBArrow      pmet->cxVSBArrow
#define x_HSBArrow      pmet->cxHSBArrow
#define x_HSBThumb      pmet->cxHSBThumb
#define y_VSBArrow      pmet->cyVSBArrow
#define y_HSBArrow      pmet->cyHSBArrow
#define y_VSBThumb      pmet->cyVSBThumb

#define WSB_HORZ_LF  0x0001  // Represents the Left arrow of the horizontal scroll bar.
#define WSB_HORZ_RT  0x0002  // Represents the Right arrow of the horizontal scroll bar.
#define WSB_VERT_UP  0x0004  // Represents the Up arrow of the vert scroll bar.
#define WSB_VERT_DN  0x0008  // Represents the Down arrow of the vert scroll bar.

#define WSB_VERT   (WSB_VERT_UP | WSB_VERT_DN)
#define WSB_HORZ   (WSB_HORZ_LF | WSB_HORZ_RT)

#define LTUPFLAG    0x0001
#define RTDNFLAG    0x0002
#define WFVPRESENT  0x00000002L
#define WFHPRESENT  0x00000004L

#define SBO_MIN     0
#define SBO_MAX     1
#define SBO_PAGE    2
#define SBO_POS     3   

#define TestSTYLE(STYLE, MASK) ((STYLE) & (MASK))
#define DMultDiv(A, B, C)   (((C) == 0)? (A):(MulDiv((A), (B), (C))))

#define VMODE(WSTATE)   ((WSTATE)->vStyle == FSB_FLAT_MODE) ? (WSTATE)->vMode \
                                :(((WSTATE)->vStyle == FSB_ENCARTA_MODE)?   \
                                WSB_2D_MODE : WSB_3D_MODE))
#define HMODE(WSTATE)   ((WSTATE)->hStyle == FSB_FLAT_MODE) ? (WSTATE)->hMode \
                                :(((WSTATE)->hStyle == FSB_ENCARTA_MODE)?   \
                                WSB_2D_MODE : WSB_3D_MODE))
#define ISINACTIVE(WSTATE) ((WSTATE) == WSB_UNINIT_HANDLE || (WSTATE)->fScreenRead)


//  This IDSYS_SCROLL has the same value we used in 'user' code.
#define IDSYS_SCROLL    0x0000FFFEL
//  Following ID is for tracking. I hope it won't conflict with 
//  interest of anybody else.
//  IDWSB_TRACK is now following the ID_MOUSExxxx we use in TrackMe.c
#define IDWSB_TRACK     0xFFFFFFF2L

#define MINITHUMBSIZE       10

#define WSB_SYS_FONT        TEXT("MARLETT")

#define WSB_UNINIT_HANDLE   ((WSBState *)-1)

#endif  //  _NEW_WSBCONTROL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\dlgcvt.cpp ===
//
// This module provides the following functions:
//
//      CvtDlgToDlgEx - Converts a DLGTEMPLATE to a DLGTEMPLATEEX
//
//
#include "ctlspriv.h"


#include "dlgcvt.h"

//
// Define the amount (bytes) the stream buffer grows when required.
// It will grow enough to satisfy the required write PLUS this
// amount.
//
#ifdef DEBUG
#   define STREAM_GROW_BYTES 32     // Exercise stream growth.
#else
#   define STREAM_GROW_BYTES 512
#endif

//
// Simple MIN/MAX inline helpers.
//

#if (defined UNIX && defined ux10)
//IEUNIX: hp's version of "/usr/local/include/sys/param.h defines MAX and MIN
//macro's and breaks hp's build
#undef MAX(a,b)
#undef MIN(a,b)
#endif //UNIX && ux10

template <class T>
inline const T& MIN(const T& a, const T& b)
{
    return a < b ? a : b;
}

template <class T>
inline const T& MAX(const T& a, const T& b)
{
    return a > b ? a : b;
}

//
// This class implements a simple dynamic stream that grows as you
// add data to it.  It's modeled after the strstream class provided
// by the C++ std lib.  Unlike the std lib implementation, this one
// doesn't require C++ EH to be enabled.  If comctl32 compiled with
// C++ EH enabled, I would have used strstream instead.
// [brianau - 10/5/98]
// 
class CByteStream
{
    public:
        explicit CByteStream(int cbDefGrow = 512);
        ~CByteStream(void);

        //
        // Used as argument to AlignXXXX member functions.
        //
        enum AlignType { eAlignWrite, eAlignRead };
        //
        // Basic read/write functions.
        //
        int Read(LPVOID pb, int cb);
        int Write(const VOID *pb, int cb);
        //
        // Determine if there was an error when reading or 
        // writing to the stream.
        //
        bool ReadError(void) const
            { return m_bReadErr; }

        bool WriteError(void) const
            { return m_bWriteErr; }
        //
        // Reset the stream read or write pointer.
        //
        void ResetRead(void)
            { m_pbRead = m_pbBuf; m_bReadErr = false; }

        void ResetWrite(void)
            { m_pbWrite = m_pbBuf; m_bWriteErr = false; }
        //
        // Reset the stream.
        //
        void Reset(void);
        //
        // These functions align the read and write stream pointers.
        //
        void AlignReadWord(void)
            { Align(eAlignRead, sizeof(WORD)); }

        void AlignReadDword(void)
            { Align(eAlignRead, sizeof(DWORD)); }

        void AlignReadQword(void)
            { Align(eAlignRead, sizeof(ULONGLONG)); }

        void AlignWriteWord(void)
            { Align(eAlignWrite, sizeof(WORD)); }

        void AlignWriteDword(void)
            { Align(eAlignWrite, sizeof(DWORD)); }

        void AlignWriteQword(void)
            { Align(eAlignWrite, sizeof(ULONGLONG)); }

        //
        // GetBuffer returns the address of the stream buffer in memory.
        // The buffer is "frozen" so it will not be released if the stream
        // object is destroyed.  At this point, you own the buffer.
        // If bPermanent is false, you can call ReleaseBuffer to return 
        // control of the buffer to the stream object.
        //
        LPBYTE GetBuffer(bool bPermanent = false);
        //
        // ReleaseBuffer returns control of the buffer obtained with GetBuffer
        // to the stream object.
        //
        bool ReleaseBuffer(LPBYTE pbBuf);
        //
        // Overload the insertion and extraction operators so we can
        // work like a normal std lib stream class.
        //
        template <class T>
        CByteStream& operator >> (T& x)
            { Read(&x, sizeof(x)); return *this; }

        template <class T>
        CByteStream& operator << (const T& x)
            { Write(&x, sizeof(x)); return *this; }

    private:
        int    m_cbDefGrow;  // Default amount (bytes) to grow when expanding buffer.
        LPBYTE m_pbBuf;      // Addr of allocated buffer.
        LPBYTE m_pbRead;     // Addr for next read.
        LPBYTE m_pbWrite;    // Addr for next write.
        LPBYTE m_pbEnd;      // Addr of byte following last byte in buffer.
        bool   m_bWriteErr;  // Any read errors?
        bool   m_bReadErr;   // Any write errors?
        bool   m_bOwnsBuf;   // true == delete buffer in dtor.

        //
        // Expand the buffer as needed.
        //
        bool GrowBuffer(int cb = 0);
        //
        // Align the read or write buffer pointer.
        // Used internally by the AlignXXXXX member functions.
        //
        void Align(AlignType a, size_t n);
        //
        // Internal consistency checks for debug builds.
        //
        void Validate(void) const;
        //
        // Prevent copy.
        //
        CByteStream(const CByteStream& rhs);
        CByteStream& operator = (const CByteStream& rhs);
};


//
// Class for converting in-memory dialog templates between the two
// structures DLGTEMPLATE <-> DLGTEMPLATEEX.
//
// Currently, the object only converts from DLGTEMPLATE -> DLGTEMPLATEEX.
// It would be simple to create the code for the inverse conversion.  However,
// it's currently not needed so I didn't create it.
//
class CDlgTemplateConverter
{
    public:
        explicit CDlgTemplateConverter(int iCharSet = DEFAULT_CHARSET)
            : m_iCharset(iCharSet),
              m_stm(STREAM_GROW_BYTES) { }

        ~CDlgTemplateConverter(void) { }

        HRESULT DlgToDlgEx(LPDLGTEMPLATE pTemplateIn, LPDLGTEMPLATEEX *ppTemplateOut);

        HRESULT DlgExToDlg(LPDLGTEMPLATEEX pTemplateIn, LPDLGTEMPLATE *ppTemplateOut)
            { return E_NOTIMPL; }

    private:
        int         m_iCharset;
        CByteStream m_stm;       // For converted template.

#ifndef UNIX
        HRESULT DlgHdrToDlgEx(CByteStream& s, LPWORD *ppw);
        HRESULT DlgItemToDlgEx(CByteStream& s, LPWORD *ppw);
#else
        HRESULT DlgHdrToDlgEx(CByteStream& s, LPDWORD *ppw);
        HRESULT DlgItemToDlgEx(CByteStream& s, LPDWORD *ppw);
#endif

        HRESULT DlgExHdrToDlg(CByteStream& s, LPWORD *ppw)
            { return E_NOTIMPL; }
        HRESULT DlgExItemToDlg(CByteStream& s, LPWORD *ppw)
            { return E_NOTIMPL; }
        //
        // Copy a string from pszW into a CByteStream object.
        // Copies at most cch chars.  If cch is -1, assumes the string is 
        // nul-terminated and will copy all chars in string including
        // terminating NULL.
        //
        int CopyStringW(CByteStream& stm, LPWSTR pszW, int cch = -1);
        //
        // Prevent copy.
        //
        CDlgTemplateConverter(const CDlgTemplateConverter& rhs);
        CDlgTemplateConverter& operator = (const CDlgTemplateConverter& rhs);
};


//
// Generic alignment function.
// Give it an address and an alignment size and it returns
// the address adjusted for the requested alignment.
//
// n :  2 = 16-bit
//      4 = 32-bit
//      8 = 64-bit
//
LPVOID Align(LPVOID pv, size_t n)
{
    const ULONG_PTR x = static_cast<ULONG_PTR>(n) - 1;
    return reinterpret_cast<LPVOID>((reinterpret_cast<ULONG_PTR>(pv) + x) & ~x);
}

inline LPVOID AlignWord(LPVOID pv)
{
    return ::Align(pv, sizeof(WORD));
}

inline LPVOID AlignDWord(LPVOID pv)
{
    return ::Align(pv, sizeof(DWORD));
}

inline LPVOID AlignQWord(LPVOID pv)
{
    return ::Align(pv, sizeof(ULONGLONG));
}



CByteStream::CByteStream(
    int cbDefGrow
    ) : m_cbDefGrow(MAX(cbDefGrow, 1)),
        m_pbBuf(NULL),
        m_pbRead(NULL),
        m_pbWrite(NULL),
        m_pbEnd(NULL),
        m_bWriteErr(false),
        m_bReadErr(false),
        m_bOwnsBuf(true) 
{ 

}


CByteStream::~CByteStream(
    void
    )
{
    if (m_bOwnsBuf && NULL != m_pbBuf)
    {
        LocalFree(m_pbBuf);
    }
}

//
// Simple checks to validate stream state.
// In non-debug builds, this will be a no-op.
// Use ASSERT_VALIDSTREAM macro.
//
void
CByteStream::Validate(
    void
    ) const
{
    ASSERT(m_pbEnd >= m_pbBuf);
    ASSERT(m_pbWrite >= m_pbBuf);
    ASSERT(m_pbRead >= m_pbBuf);
    ASSERT(m_pbWrite <= m_pbEnd);
    ASSERT(m_pbRead <= m_pbEnd);
}

#ifdef DEBUG
#   define ASSERT_VALIDSTREAM(ps)  ps->Validate()
#else
#   define ASSERT_VALIDSTREAM(ps)
#endif

//
// Read "cb" bytes from the stream and write them to 
// the location specified in "pb".  Return number
// of bytes read.  Note that if we don't "own" the
// buffer (i.e. the client has called GetBuffer but
// not ReleaseBuffer), no read will occur.
//
int 
CByteStream::Read(
    LPVOID pb,
    int cb
    )
{
    ASSERT_VALIDSTREAM(this);

    int cbRead = 0;
    if (m_bOwnsBuf)
    {
        cbRead = MIN(static_cast<int>(m_pbEnd - m_pbRead), cb);
        CopyMemory(pb, m_pbRead, cbRead);
        m_pbRead += cbRead;
        if (cb != cbRead)
            m_bReadErr = true;
    }

    ASSERT_VALIDSTREAM(this);

    return cbRead;
}


//
// Write "cb" bytes from location "pb" into the stream.
// Return number of bytes written.  Note that if we don't "own" the
// buffer (i.e. the client has called GetBuffer but
// not ReleaseBuffer), no write will occur.
//
int 
CByteStream::Write(
    const VOID *pb,
    int cb
    )
{
    ASSERT_VALIDSTREAM(this);

    int cbWritten = 0;
    if (m_bOwnsBuf)
    {
        if (m_pbWrite + cb < m_pbEnd || 
            GrowBuffer(static_cast<int>(m_pbEnd - m_pbBuf) + cb + m_cbDefGrow))
        {
            CopyMemory(m_pbWrite, pb, cb);
            m_pbWrite += cb;
            cbWritten = cb;
        }
        else
            m_bWriteErr = true;
    }

    ASSERT_VALIDSTREAM(this);

    return cbWritten;
}

//
// Reallocate the buffer by cb or m_cbDefGrow.
// Copy existing contents to new buffer.  All internal
// pointers are updated.
//
bool 
CByteStream::GrowBuffer(
    int cb               // optional.  Default is 0 causing us to use m_cbDefGrow.
    )
{
    bool bResult         = false;
    int cbGrow           = 0 < cb ? cb : m_cbDefGrow;
    ULONG_PTR ulReadOfs  = m_pbRead - m_pbBuf;
    ULONG_PTR ulWriteOfs = m_pbWrite - m_pbBuf;
    ULONG_PTR cbAlloc    = m_pbEnd - m_pbBuf;
    LPBYTE pNew = static_cast<LPBYTE>(LocalAlloc(LPTR, cbAlloc + cbGrow));
    if (NULL != pNew)
    {
        if (NULL != m_pbBuf)
        {
            CopyMemory(pNew, m_pbBuf, cbAlloc);
            LocalFree(m_pbBuf);
        }
        m_pbBuf   = pNew;
        m_pbRead  = m_pbBuf + ulReadOfs;
        m_pbWrite = m_pbBuf + ulWriteOfs;
        m_pbEnd   = m_pbBuf + cbAlloc + cbGrow;
        bResult   = true;
    }

    ASSERT_VALIDSTREAM(this);
    return bResult;
}

//
// Align the read or write pointer on the stream.
// The write pointer is aligned by padding skipped bytes with 0.
//
void
CByteStream::Align(
    CByteStream::AlignType a,
    size_t n
    )
{
    static const BYTE fill[8] = {0};
    if (m_bOwnsBuf)
    {
        switch(a)
        {
            case eAlignWrite:
                Write(fill, static_cast<int>(reinterpret_cast<LPBYTE>(::Align(m_pbWrite, n)) - m_pbWrite));
                break;

            case eAlignRead:
                m_pbRead = reinterpret_cast<LPBYTE>(::Align(m_pbRead, n));
                if (m_pbRead >= m_pbEnd)
                    m_bReadErr = true;
                break;

            default:
                break;
        }
    }
    ASSERT_VALIDSTREAM(this);
}


//
// Caller takes ownership of the buffer.
//
LPBYTE 
CByteStream::GetBuffer(
    bool bPermanent       // optional.  Default is false.
    )
{ 
    LPBYTE pbRet = m_pbBuf;
    if (bPermanent)
    {
        //
        // Caller now permanently owns the buffer.
        // Can't return it through ReleaseBuffer().
        // Reset the internal stream control values.
        //
        m_pbBuf = m_pbWrite = m_pbRead = m_pbEnd = NULL;
        m_bWriteErr = m_bReadErr = false;
        m_bOwnsBuf = true;
    }
    else
    {
        //
        // Caller now owns the buffer but it can be returned
        // through ReleaseBuffer().
        //
        m_bOwnsBuf = false; 
    }
    return pbRet; 
}


//
// Take back ownership of the buffer.
// Returns:  
//
//      true   = CByteStream object took back ownership.
//      false  = CByteStream object couldn't take ownership.
//
bool 
CByteStream::ReleaseBuffer(
    LPBYTE pbBuf
    )
{
    if (pbBuf == m_pbBuf)
    {
        m_bOwnsBuf = true;
        return true;
    }
    return false;
}
     

//
// Reset the stream.
//
void 
CByteStream::Reset(
    void
    )
{
    if (NULL != m_pbBuf)
    {
        LocalFree(m_pbBuf);
    }
    m_pbBuf = m_pbWrite = m_pbRead = m_pbEnd = NULL;
    m_bWriteErr = m_bReadErr = false;
    m_bOwnsBuf = true;
}


//
// Copy one or more WORDs from the location provided in "pszW" into
// the stream.  If cch is -1, it's assumed that the string is nul-terminated.
// Returns the number of WCHARs written.
//    
int 
CDlgTemplateConverter::CopyStringW(
    CByteStream& stm,
    LPWSTR pszW,
    int cch
    )
{
    if (-1 == cch)
        cch = lstrlenW(pszW) + 1;
    return stm.Write(pszW, cch * sizeof(WCHAR)) / sizeof(WCHAR);
}

//
// Convert a DLGTEMPLATE structure to a DLGTEMPLATEEX structure.
// pti is the address of the DLGTEMPLATE to be converted.
// ppto points to a LPDLGTEMPLATEEX ptr to receive the address of the
// converted template structure.  Caller is responsible for freeing
// this buffer with LocalFree.
//
// Returns:  E_OUTOFMEMORY, NOERROR
//
HRESULT
CDlgTemplateConverter::DlgToDlgEx(
    LPDLGTEMPLATE pti,
    LPDLGTEMPLATEEX *ppto
    )
{
    HRESULT hr = NOERROR;
#ifndef UNIX
    LPWORD pw = reinterpret_cast<LPWORD>(pti);
#else
    LPDWORD pw = reinterpret_cast<LPDWORD>(pti);
#endif

    *ppto = NULL;

    //
    // Reset the stream.
    //
    m_stm.Reset();
    //
    // Convert DLGTEMPLATE -> DLGTEMPLATEEX
    //
    hr = DlgHdrToDlgEx(m_stm, &pw);
    //
    // Convert each DLGITEMTEMPLATE -> DLGITEMTEMPLATEEX
    //
    for (int i = 0; i < pti->cdit && SUCCEEDED(hr); i++)
    {
#ifndef UNIX
        pw = reinterpret_cast<LPWORD>(::AlignDWord(pw));
#else
        pw = reinterpret_cast<LPDWORD>(::AlignDWord(pw));
#endif
        m_stm.AlignWriteDword();
        hr = DlgItemToDlgEx(m_stm, &pw);
    }

    if (SUCCEEDED(hr))
    {
        //
        // Return the buffer to the caller.  Buffer is permanently
        // detached from the stream object so the stream's dtor
        // won't free it.
        //
        *ppto = reinterpret_cast<LPDLGTEMPLATEEX>(m_stm.GetBuffer(true));    
    }
    return hr;
};


//
// Convert DLGTEMPLATE -> DLGTEMPLATEEX
//
// s   = Stream to hold converted template.
// ppw = Address of current read pointer into the template being converted.
//       On exit, the referenced pointer is updated with the current read location.
//
// Returns:  E_OUTOFMEMORY, NOERROR
//
HRESULT
CDlgTemplateConverter::DlgHdrToDlgEx(
    CByteStream& s,
#ifndef UNIX
    LPWORD *ppw
#else
    LPDWORD *ppw
#endif
    )
{
#ifndef UNIX
    LPWORD pw = *ppw;
#else
    LPDWORD pw = *ppw;
#endif
    LPDLGTEMPLATE pt = reinterpret_cast<LPDLGTEMPLATE>(pw);

    //
    // Convert the fixed-length stuff.
    //
    s << static_cast<WORD>(1)                        // wDlgVer
      << static_cast<WORD>(0xFFFF)                   // wSignature
      << static_cast<DWORD>(0)                       // dwHelpID
      << static_cast<DWORD>(pt->dwExtendedStyle)
      << static_cast<DWORD>(pt->style)
      << static_cast<WORD>(pt->cdit)
      << static_cast<short>(pt->x)
      << static_cast<short>(pt->y)
      << static_cast<short>(pt->cx)
      << static_cast<short>(pt->cy);

    //
    // Arrays are always WORD aligned.
    //
#ifndef UNIX
    pw = reinterpret_cast<LPWORD>(::AlignWord(reinterpret_cast<LPBYTE>(pw) + sizeof(DLGTEMPLATE)));
    s.AlignWriteWord();
#else
    pw = reinterpret_cast<LPDWORD>(::AlignDWord(reinterpret_cast<LPBYTE>(pw) + sizeof(DLGTEMPLATE)));
    s.AlignWriteDword();
#endif

    //
    // Copy the menu array.
    //
    switch(*pw)
    {
        case 0xFFFF:
            s << *pw++;
            //
            // Fall through...
            //
        case 0x0000:
            s << *pw++;
            break;
                        
        default:
#ifndef UNIX
            pw += CopyStringW(s, (LPWSTR)pw);
#else
            pw += CopyStringW (s, reinterpret_cast<LPWSTR>(pw));
#endif
            break;
    };
    //
    // Copy the class array.
    //
    switch(*pw)
    {
        case 0xFFFF:
            s << *pw++;
            //
            // Fall through...
            //
        case 0x0000:
            s << *pw++;
            break;
            
        default:
#ifndef UNIX
            pw += CopyStringW(s, (LPWSTR)pw);
#else
            pw += CopyStringW (s, reinterpret_cast<LPWSTR>(pw));
#endif
            break;
    };
    //
    // Copy the title array.
    //
    switch(*pw)
    {
        case 0x0000:
            s << *pw++;
            break;

        default:
#ifndef UNIX
            pw += CopyStringW(s, (LPWSTR)pw);
#else
            pw += CopyStringW (s, reinterpret_cast<LPWSTR>(pw));
#endif
            break;
    };
    //
    // Copy font information if it's present.
    //
    if (DS_SETFONT & pt->style)
    {
        s << *pw++;                              // pt size
        s << static_cast<WORD>(FW_NORMAL);       // weight (default, not in DLGTEMPLATE)
        s << static_cast<BYTE>(FALSE);           // italic (default, not in DLGTEMPLATE)
        s << static_cast<BYTE>(m_iCharset);        // charset (default if not given, 
                                                 //          not in DLGTEMPLATE)
#ifndef UNIX
        pw += CopyStringW(s, (LPWSTR)pw);
#else
        pw += CopyStringW (s, reinterpret_cast<LPWSTR>(pw));
#endif
    }

    *ppw = pw;

    return s.WriteError() ? E_OUTOFMEMORY : NOERROR;
}


//
// Convert DLGITEMTEMPLATE -> DLGITEMTEMPLATEEX
//
// s   = Stream to hold converted template.
// ppw = Address of current read pointer into the template being converted.
//       On exit, the referenced pointer is updated with the current read location.
//
// Returns:  E_OUTOFMEMORY, NOERROR
//
HRESULT
CDlgTemplateConverter::DlgItemToDlgEx(
    CByteStream& s,
#ifndef UNIX
    LPWORD *ppw
#else
    LPDWORD *ppw
#endif
    )
{
#ifndef UNIX
    LPWORD pw = *ppw;
#else
    LPDWORD pw = *ppw;
#endif
    LPDLGITEMTEMPLATE pit = reinterpret_cast<LPDLGITEMTEMPLATE>(pw);

    //
    // Convert the fixed-length stuff.
    //
    s << static_cast<DWORD>(0)                     // dwHelpID
      << static_cast<DWORD>(pit->dwExtendedStyle)
      << static_cast<DWORD>(pit->style)
      << static_cast<short>(pit->x)
      << static_cast<short>(pit->y)
      << static_cast<short>(pit->cx)
      << static_cast<short>(pit->cy)
      << static_cast<DWORD>(pit->id);

    //
    // Arrays are always word aligned.
    //
#ifndef UNIX
    pw = reinterpret_cast<LPWORD>(::AlignWord(reinterpret_cast<LPBYTE>(pw) + sizeof(DLGITEMTEMPLATE)));
    s.AlignWriteWord();
#else
    pw = reinterpret_cast<LPDWORD>(::AlignWord(reinterpret_cast<LPBYTE>(pw) + sizeof(DLGITEMTEMPLATE)));
    s.AlignWriteDword();
#endif
    //
    // Copy the class array.
    //
    switch(*pw)
    {
        case 0xFFFF:
            s << *pw++;
            s << *pw++;   // Class code.
            break;
            
        default:
#ifndef UNIX
            pw += CopyStringW(s, (LPWSTR)pw);
#else
            pw += CopyStringW (s, reinterpret_cast<LPWSTR>(pw));
#endif
            break;
    };
    //
    // Copy the title array.
    //
    switch(*pw)
    {
        case 0xFFFF:
            s << *pw++;
            s << *pw++;   // Resource ordinal value.
            break;
            
        default:
#ifndef UNIX
            pw += CopyStringW(s, (LPWSTR)pw);
#else
            pw += CopyStringW (s, reinterpret_cast<LPWSTR>(pw));
#endif
            break;
    };
    //
    // Copy the creation data.
    // *pw is either 0 or the number of bytes of creation data,
    // including *pw.
    //
    switch(*pw)
    {
        case 0x0000:
            s << *pw++;
            break;

        default:
#ifndef UNIX
            pw += s.Write(pw, *pw) / sizeof(WORD);
#else
            pw += s.Write(pw, *pw) / sizeof(DWORD);
#endif
            break;
    };

    *ppw = pw;

    return s.WriteError() ? E_OUTOFMEMORY : NOERROR;
}


//
// This is the public function for converting a DLGTEMPLATE to
// a DLGTEMPLATEEX.
//
// Returns:  E_OUTOFMEMORY, NOERROR
//
HRESULT 
CvtDlgToDlgEx(
    LPDLGTEMPLATE pTemplate, 
    LPDLGTEMPLATEEX *ppTemplateExOut,
    int iCharset
    )
{
    CDlgTemplateConverter dtc(iCharset);
    return dtc.DlgToDlgEx(pTemplate, ppTemplateExOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\fontlink.cpp ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1994-1995
//
//  File:       fontlink.cpp
//
//  Contents:   Wrappers for font link functions.
//
//----------------------------------------------------------------------------
#include "ctlspriv.h"

#ifdef FONT_LINK

#include <mlang.h>
#include "fontlink.h"
#include "unicwrap.h"

#undef DrawTextW
#undef DrawTextExW
#undef ExtTextOutW
#undef TextOutW
#undef GetCharWidthW
#undef GetTextExtentPointW
#undef GetTextExtentPoint32W

#ifndef WINNT
//
//  Win9x will crash if uLastChar == 0xFFFF.  You can't squeak the width of
//  the 0xFFFF character by setting uLastChar to 0x10000, since the Win16
//  thunk will truncate it to 0x0000, and then the validation layer will
//  reject the request since uLastChar > uFirstChar.
//
//  So assume that the width of 0xFFFF is equal to the width of 0xFFFE.
//  Both are invalid unicode characters, so hopefully the widths are the same.
//

BOOL SafeGetCharWidthW(HDC hdc, UINT uFirstChar, UINT uLastChar, LPINT lpnWidths)
{
    BOOL fRc;
    ASSERT(uFirstChar <= uLastChar);
    ASSERT(uLastChar <= 0xFFFF);

    if (uLastChar != 0xFFFF) {
        fRc = GetCharWidthW(hdc, uFirstChar, uLastChar, lpnWidths);
    } else {
        if (uLastChar > uFirstChar) {
            // If asking for multiple characters, this means we are asking
            // for a range that ends at 0xFFFF.  Change it to a range that
            // ends at 0xFFFE, and copy the result for 0xFFFE into 0xFFFF.
            fRc = GetCharWidthW(hdc, uFirstChar, uLastChar - 1, lpnWidths);
            lpnWidths[uLastChar-uFirstChar] = lpnWidths[uLastChar-uFirstChar-1];
        } else {
            // If asking for just one character, that character must be
            // 0xFFFF, so change it to a request for 0xFFFE.
            fRc = GetCharWidthW(hdc, 0xFFFE, 0xFFFE, lpnWidths);
        }
    }

    return fRc;
}

#define GetCharWidthW   SafeGetCharWidthW

#endif

#ifdef WINNT
HRESULT (*g_pfnGetGlobalFontLinkObject)(IMLangFontLink **) = NULL;

BOOL LoadMLFontLink(IMLangFontLink **ppMLFontLink)
{
    ENTERCRITICAL;
    *ppMLFontLink = NULL;
    if (NULL == g_pfnGetGlobalFontLinkObject)
    {
        HMODULE hmod = LoadLibrary(TEXT("MLANG.DLL"));

        if (hmod)
            g_pfnGetGlobalFontLinkObject = (HRESULT (*)(IMLangFontLink **))GetProcAddress(hmod, "GetGlobalFontLinkObject");
    }
    if (g_pfnGetGlobalFontLinkObject)
        g_pfnGetGlobalFontLinkObject(ppMLFontLink);
    LEAVECRITICAL;

    return (*ppMLFontLink)? TRUE: FALSE;
}
#else
HDPA g_hdpaMLANG = NULL;

typedef struct tagPROCITEM
{
    DWORD dwProcessId;
    HRESULT (*pfnGetGlobalFontLinkObject)(IMLangFontLink **);
} PROCITEM, *PPROCITEM;

PPROCITEM CreatePROCITEM(void)
{
    PPROCITEM pItem = (PPROCITEM)Alloc(sizeof(PROCITEM));

    if (pItem)
    {
        HMODULE hmod = LoadLibrary(TEXT("MLANG.DLL"));

        if (hmod)
        {
            pItem->dwProcessId = GetCurrentProcessId();
            pItem->pfnGetGlobalFontLinkObject = (HRESULT (*)(IMLangFontLink **))GetProcAddress(hmod, "GetGlobalFontLinkObject");
        }
    }
    return pItem;
}

int GetPROCITEM(DWORD dwProcessId)
{
    int i, cItems = 0;

    ASSERTCRITICAL;

    if (g_hdpaMLANG)
        cItems = DPA_GetPtrCount(g_hdpaMLANG);

    for (i = 0; i < cItems; i++)
    {
        PPROCITEM pItem = (PPROCITEM)DPA_FastGetPtr(g_hdpaMLANG, i);

        if (pItem && pItem->dwProcessId == dwProcessId)
            return i;
    }
    return -1;
}

STDAPI_(void) InitMLANG(void)
{
    ENTERCRITICAL;
    if (NULL == g_hdpaMLANG)
    {
        ASSERTCRITICAL;
        g_hdpaMLANG = DPA_Create(4);
    }

    int i = GetPROCITEM(GetCurrentProcessId());

    // If the previous app with my process id crashed, erase my entry
    // so I won't crash, too.
    if (0 <= i)
    {
        Free((PPROCITEM)DPA_FastGetPtr(g_hdpaMLANG, i));
        DPA_DeletePtr(g_hdpaMLANG, i);
    }

    LEAVECRITICAL;
}

STDAPI_(void) DeinitMLANG(int cProcesses)
{
    int i = GetPROCITEM(GetCurrentProcessId());

    ASSERTCRITICAL;

    if (0 <= i)
    {
        Free((PPROCITEM)DPA_FastGetPtr(g_hdpaMLANG, i));
        DPA_DeletePtr(g_hdpaMLANG, i);
    }

    if (g_hdpaMLANG && 1 == cProcesses) // This is last process detach
    {
        DPA_Destroy(g_hdpaMLANG);
        g_hdpaMLANG = NULL;
    }
}

BOOL LoadMLFontLink(IMLangFontLink **ppMLFontLink)
{
    PPROCITEM pItem = NULL;
    int i;

    ENTERCRITICAL;
    *ppMLFontLink = NULL;
    i = GetPROCITEM(GetCurrentProcessId());

    if (0 <= i)
    {
        pItem = (PPROCITEM)DPA_FastGetPtr(g_hdpaMLANG, i);
    }
    else
    {
        pItem = CreatePROCITEM();
        if (pItem)
            DPA_AppendPtr(g_hdpaMLANG, pItem);
    }

    if (pItem && pItem->pfnGetGlobalFontLinkObject)
        pItem->pfnGetGlobalFontLinkObject(ppMLFontLink);
    LEAVECRITICAL;

    return (*ppMLFontLink)? TRUE: FALSE;
}
#endif

#define _MAX_WCHAR_BUFFER_SIZE      256     // Should be enough for shell space name strings
#define _MAX_MB_BUFFER_SIZE         _MAX_WCHAR_BUFFER_SIZE * sizeof(WCHAR)

//
// Helper function to decide whether we need MLang font link
// On return:
//      S_OK    : Yes, we need MLang font link and MLang can be loaded succesfully
//      S_FALSE : No, we don't need MLang since text can be handled natively with font assciation (ANSI) and font link.
//      E_FAIL  : Need MLang, but, we couldn't load it

HRESULT FDoFontLink(HDC hdc, IMLangFontLink **ppMLFontLink, LPCWSTR pwszName, int cch)
{
    HRESULT hr;
    BOOL fNotDisplayable = TRUE;    
    int cchWChar;
    int cchMB = cch * sizeof(WCHAR);
    // When possible, we'll use internal buffer to avoid memory operations
    char szBuffer[_MAX_MB_BUFFER_SIZE];
    WCHAR wszBuffer[_MAX_WCHAR_BUFFER_SIZE];
    char *pszBuffer = szBuffer;
    WCHAR *pwszBuffer = wszBuffer;
    UINT uiCharset;
    CHARSETINFO csi;

    ASSERT(ppMLFontLink);

    uiCharset = GetTextCharsetInfo(hdc, NULL, 0);
    TranslateCharsetInfo(IntToPtr_(DWORD *, uiCharset), &csi, TCI_SRCCHARSET);

    if (cch>0 && g_uiACP == csi.ciACP)
    {
        // Alloc buffer if multibyte buffer is not enough    
        if (cch > _MAX_WCHAR_BUFFER_SIZE)
            pszBuffer = (char *)LocalAlloc(LPTR, cchMB);

        if (pszBuffer)
        {
            cchMB = WideCharToMultiByte(CP_ACP, 0, pwszName, cch, pszBuffer, cchMB, NULL, &fNotDisplayable);

            // Round-trip verification
            if (!fNotDisplayable)
            {
                // Alloc buffer if wide char buffer is not enough    
                if (cch > _MAX_WCHAR_BUFFER_SIZE)
                    pwszBuffer = (WCHAR *)LocalAlloc(LPTR, cch*sizeof(WCHAR));

                if (pwszBuffer)
                {
                    cchWChar = MultiByteToWideChar(CP_ACP, 0, pszBuffer, cchMB, pwszBuffer, cch); 

                    if (cch == cchWChar)            
                    {
                        for (int i=0; i<cch; i++)
                        {
                            if (pwszBuffer[i] != pwszName[i])
                            {
                                fNotDisplayable = TRUE;
                                break;
                            }
                        }
                    }
                    else
                    {
                        fNotDisplayable = TRUE;
                    }

                    if (pwszBuffer != wszBuffer)
                        LocalFree(pwszBuffer);
                }
                else
                {
                    fNotDisplayable = TRUE;
                }
            }

            if (pszBuffer != szBuffer)
                LocalFree(pszBuffer);
        }
    }

    if (fNotDisplayable)
    {
        if (LoadMLFontLink(ppMLFontLink))
            hr = S_OK;          // Need MLang font link
        else
            hr = E_FAIL;        // Unable to load MLang
    }
    else
    {
            hr = S_FALSE;           // Doesn't need MLang font link, but, we still need to call GDI in ANSI for Win9x FA to work properly
    }    

    return hr;
}

//
// For _GetCharWidthWFontLink()
//
HRESULT FDoFontLink(HDC hdc, IMLangFontLink **ppMLFontLink, WCHAR wFirstChar, WCHAR wLastChar)
{
    WCHAR wszBuffer[_MAX_WCHAR_BUFFER_SIZE];
    int i = 0;
    int cch = wFirstChar - wLastChar + 1;
    WCHAR *pwszBuffer = wszBuffer;
    HRESULT hr = E_FAIL;

    if (cch > _MAX_WCHAR_BUFFER_SIZE)
        pwszBuffer = (WCHAR *)LocalAlloc(LPTR, cch*sizeof(WCHAR));

    if (pwszBuffer)
    {
        while (i < cch)
        {
            pwszBuffer[i] = wFirstChar+i;
            i++;
        }

        hr = FDoFontLink(hdc, ppMLFontLink, pwszBuffer, cch);

        if (pwszBuffer != wszBuffer)
            LocalFree(pwszBuffer);
    }

    return hr;
}

//
//  BUGBUG: Review for removing below big table and UsrFromWch() ...
//
__inline BOOL FChsDbcs(UINT chs)
{
    return (chs == SHIFTJIS_CHARSET ||
            chs == HANGEUL_CHARSET ||
            chs == CHINESEBIG5_CHARSET ||
            chs == GB2312_CHARSET);
}

__inline int FChsBiDi(int chs)
{
    return (chs == ARABIC_CHARSET ||
            chs == HEBREW_CHARSET);
}

__inline BOOL FCpgChinese(UINT cpg)
{
    if (cpg == CP_ACP)
        cpg = GetACP();
    return (cpg == CP_TAIWAN || cpg == CP_CHINA);
}

__inline BOOL FCpgTaiwan(UINT cpg)
{
    if (cpg == CP_ACP)
        cpg = GetACP();
    return (cpg == CP_TAIWAN);
}

__inline BOOL FCpgPRC(UINT cpg)
{
    if (cpg == CP_ACP)
        cpg = GetACP();
    return (cpg == CP_CHINA);
}
    
__inline BOOL FCpgFarEast(UINT cpg)
{
    if (cpg == CP_ACP)
        cpg = GetACP();
    return (cpg == CP_JAPAN || cpg == CP_TAIWAN || cpg == CP_CHINA ||
            cpg == CP_KOREA || cpg == CP_MAC_JAPAN);
}

__inline BOOL FCpgDbcs(UINT cpg)
{
    return (cpg == CP_JAPAN ||
            cpg == CP_KOREA ||
            cpg == CP_TAIWAN ||
            cpg == CP_CHINA);
}

__inline int FCpgBiDi(int cpg)
{
    return (cpg == CP_ARABIC ||
            cpg == CP_HEBREW);
}

#ifndef WINNT
HFONT GetBiDiFont(HDC hdc)
{
    HFONT   hfont    = NULL;
    HFONT   hfontTmp;
    LOGFONT lf;

    hfontTmp = (HFONT)GetCurrentObject(hdc, OBJ_FONT);
    GetObject(hfontTmp, sizeof(lf), &lf);
    // BUGBUG: Should I loop on the string to check if it contains BiDi chars?
    if ( !FChsBiDi(lf.lfCharSet))
    {
        lf.lfCharSet = DEFAULT_CHARSET;
        hfont        = CreateFontIndirect(&lf);
    }
    return hfont;
}
#endif

// Table to map Unicode high byte value to first sub range for this high byte
const BYTE mpbHighusr[256]  =
{
    /*          0   1   2   3   4   5   6   7   8   9   a   b   c   d   e   f   */
    /*  0   */  0,  2,  3,  6,  9,  10, 13, 0,  0,  15, 17, 19, 21, 23, 24, 0,
    /*  1   */  26, 28, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  29, 30,
    /*  2   */  31, 35, 38, 39, 40, 43, 46, 47, 0,  0,  0,  0,  0,  0,  0,  0,
    /*  3   */  48, 51, 54, 55, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    /*  4   */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  59, 59,
    /*  5   */  59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,
    /*  6   */  59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,
    /*  7   */  59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,
    /*  8   */  59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,
    /*  9   */  59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,
    /*  a   */  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  56, 56, 56, 56,
    /*  b   */  56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
    /*  c   */  56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
    /*  d   */  56, 56, 56, 56, 56, 56, 56, 56, 0,  0,  0,  0,  0,  0,  0,  0,
    /*  e   */  60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,
    /*  f   */  60, 60, 60, 60, 60, 60, 60, 60, 60, 61, 61, 62, 63, 63, 64, 68
};

int UsrFromWch(WCHAR wch)
{
    UCHAR bLow = LOBYTE(wch);
    int usr;
    
    switch (usr = mpbHighusr[HIBYTE(wch)])
    {
    case usrBasicLatin:
        if (bLow < 0x80)
            break;
        ++usr;
        break;
    case usrLatinXA:
        if (bLow < 0x80)
            break;
        ++usr;              
        break;
    case usrLatinXB:
        if (bLow < 0x50)
        {
//          ASSERT(wch <= 0x217);
            break;
        }
        ++usr;
        if (bLow < 0xb0)
        {
//          ASSERT(wch <= 0x2a8);
            break;;
        }
        ++usr;
//      ASSERT(wch <= 0x2e9);
        break;
    case usrCombDiacritical:
        if (bLow < 0x70)
        {
//          ASSERT(wch <= 0x345 || wch == 0x360 || wch == 0x361);
            break;
        }
        ++usr;
        if (bLow < 0xd0)
        {
//          ASSERT(wch == 0x374 || wch == 0x375 || wch == 0x37a || wch == 0x37e || (wch >= 0x384 && wch <= 0x38a) || wch == 0x38c ||
//                  (wch >= 0x38e && wch <= 0x3ce));
            break;
        }
        ++usr;
//      ASSERT(wch <= 0x3d6 || wch == 0x3da || wch == 0x3dc || wch == 0x3de || wch == 0x3e0 || (wch >= 0x3e2 && wch <= 0x3f3));
        break;
    case usrCyrillic:
//      ASSERT((wch >= 0x401 && wch <= 0x40c) || (wch >= 0x40e && wch <= 0x44f) || (wch >= 0x450 && wch <= 0x45c) ||
//             (wch >= 0x45e && wch <= 0x486) || (wch >= 0x490 && wch <= 0x4cc) || (wch >= 0x4d0 && wch <= 0x4f9));
        break;
    case usrArmenian:
        if (bLow < 0x90)
        {
//          ASSERT((wch >= 0x531 && wch <= 0x556) || (wch >= 0x559 && wch <= 0x55f) || (wch >= 0x561 && wch <= 0x587) || wch == 0x589);
            break;
        }
        ++usr;
        if (bLow >= 0xd0)
        {
//          ASSERT(wch <= 0x5ea || (wch >= 0x5f0 && wch <= 0x5f4));
            break;
        }
        ++usr;
//      ASSERT(wch >= 0x5b0 && wch <= 0x5c3);
        break;
    case usrBasicArabic:
        if (bLow < 0x53)
        {
//          ASSERT(wch == 0x60c || wch == 0x61b || wch == 0x61f || (wch >= 0x621 && wch <= 0x63a) || (wch >= 0x640 && wch <= 0x652));
            break;
        }
        ++usr;
//      ASSERT((wch >= 0x660 && wch <= 0x66d) || (wch >= 0x670 && wch <= 0x6b7) || (wch >= 0x6ba && wch <= 0x6be) ||
//                  (wch >= 0x6c0 && wch <= 0x6ce) || (wch >= 0x6d0 && wch <= 0x6ed) || (wch >= 0x6f0 && wch <= 0x6f9));

        break;
    case usrDevangari:
    case usrGurmukhi:
    case usrOriya:
    case usrTelugu:
    case usrThai:
        // REVIEW: Added asserts for these
        if (bLow < 0x80)
            break;
        ++usr;
        break;
    case usrMalayalam:
//      ASSERT(wch < 0xd80);
        break;
    case usrBasicGeorgian:
        if (bLow >= 0xD0)
            break;
        ++usr;
//      ASSERT(bLow >= 0xa0);
        break;
    case usrHangulJamo:
//      ASSERT(wch <= 0x11f9);
        break;
    case usrLatinExtendedAdd:
//      ASSERT(wch <= 0x1ef9);
        break;
    case usrGreekExtended:
//      ASSERT(wch <= 0x1ffe);
        break;
    case usrGeneralPunct:
        if (bLow < 0x70)
        {
//          ASSERT(wch <= 0x2046 || (wch >= 0x206a && wch <= 0x206f));
            break;
        }
        ++usr;
        if (bLow < 0xa0)
        {
//          ASSERT(wch == 0x2070 || (wch >= 0x2074 && wch <= 0x208e));
            break;
        }
        ++usr;
        if (bLow < 0xd0)
        {
//          ASSERT(wch <= 0x20aa);
            break;
        }
        ++usr;
//      ASSERT(wch <= 0x20e1);
        break;
    case usrLetterlikeSymbols:
        if (bLow < 0x50)
        {
//          ASSERT(wch <= 0x2138);
            break;
        }
        ++usr;
        if (bLow < 0x90)
        {
//          ASSERT((wch >= 0x2153 && wch <= 0x2182));
            break;
        }
        ++usr;
//      ASSERT(wch <= 0x21ea);
        break;
    case usrMathematicalOps:
//      ASSERT(wch <= 0x22f1);
        break;
    case usrMiscTechnical:
//      ASSERT(wch <= 0x237a);
        break;
    case usrControlPictures:
        if (bLow < 0x40)
        {
//          ASSERT(wch <= 0x2424);
            break;
        }
        ++usr;
        if (bLow < 0x60)
        {
//          ASSERT(wch <= 0x244a);
            break;
        }
        ++usr;
//      ASSERT(wch <= 0x24ea);
        break;
    case usrBoxDrawing:
        if (bLow < 0x80)
            break;
        ++usr;
        if (bLow < 0xa0)
        {
//          ASSERT(wch <= 0x2595);
            break;
        }
        ++usr;
//      ASSERT(wch <= 0x25ef);
        break;
    case usrMiscDingbats:
//      ASSERT(wch <= 0x2613 || (wch >= 0x261a && wch <= 0x266f));
        break;
    case usrDingbats:
        break;
    case usrCJKSymAndPunct:
        if (bLow < 0x40)
        {
//          ASSERT(wch <= 0x3037 || wch == 0x303f);
            break;
        }
        ++usr;
        if (bLow < 0xa0)
        {
//          ASSERT((wch >= 0x3041 && wch <= 0x3094) || (wch >= 0x3099 && wch <= 0x309e));
            break;
        }
        ++usr;
//      ASSERT(wch >= 0x30a1 && wch <= 0x30fe);
        break;
    case usrBopomofo:
        if (bLow < 0x30)
        {
//          ASSERT(wch >= 0x3105 && wch <= 0x312c);
            break;
        }
        ++usr;
        if (bLow < 0x90)
        {
//          ASSERT(wch >= 0x3131 && wch <= 0x318e);
            break;
        }
        ++usr;
//      ASSERT(wch <= 0x319f);
        break;
    case usrEnclosedCJKLtMnth:
//      ASSERT((wch >= 0x3200 && wch <= 0x321c) || (wch >= 0x3220 && wch <= 0x3243) || (wch >= 0x3260 && wch <= 0x327b) ||
//      (wch >= 0x327f && wch <= 0x32b0) || (wch >= 0x32c0 && wch <= 0x32cb) || (wch >= 0x32d0 && wch <= 0x32fe));
        break;
    case usrCJKCompatibility:
//      ASSERT(wch <= 0x3376 || (wch >= 0x337b && wch <= 0x33dd) || (wch >= 0x33e0 && wch <= 0x33FE));
        break;
    case usrHangul:
//      ASSERT(wch <= 0xd7a3);
        break;
    case usrCJKUnifiedIdeo:
        break;
    case usrPrivateUseArea:
        break;
    case usrCJKCompatibilityIdeographs:
//      ASSERT(wch <= 0xfa2d);
        break;
    case usrAlphaPresentationForms:
        if (bLow < 0x50)
        {
            break;
        }
        ++usr;
        break;
    case usrArabicPresentationFormsA:
//      ASSERT(wch <= 0xfdfb);
        break;
    case usrCombiningHalfMarks:
        if (bLow < 0x30)
        {
//          ASSERT(wch >= 0xfe20 && wch <= 0xfe23);
            break;
        }
        ++usr;
        if (bLow < 0x50)
        {
//          ASSERT((wch >= 0xfe30 && wch <= 0xfe44) || wch >= 0xfe49);
            break;
        }
        ++usr;
        if (bLow < 0x70)
        {
//          ASSERT((wch >= 0xfe50 && wch <= 0xfe52) || (wch >= 0xfe54 && wch <= 0xfe66) || (wch >= 0xfe68 && wch <= 0xfe6b));
            break;
        }
        ++usr;
        // REVIEW : Need assert for this range
        break;
    case usrHFWidthForms:
        if (bLow < 0xf0)
        {
//          ASSERT((wch >= 0xff01 && wch <= 0xff5e) || (wch >= 0xff61 && wch <= 0xffbe) || (wch >= 0xffc2 && wch <= 0xffc7) ||
//              (wch >= 0xffca && wch <= 0xffcf) || (wch >= 0xffd2 && wch <= 0xffd7) || (wch >= 0xffda && wch <= 0xffdc) ||
//              (wch >= 0xffe0 && wch <= 0xffe6));
            break;
        }
        ++usr;
//      ASSERT(wch == 0xfffd);
        break;
    default:
        ASSERT(FALSE); // bad Unicode character!!
        break;
    }
    return usr;
}

BOOL _OtherGetCharWidthW(HDC hdc, UINT uFirstChar, UINT uLastChar, LPINT lpnWidths)
{
    ASSERT(uFirstChar <= uLastChar);

#ifdef WINNT
    return GetCharWidthW(hdc, uFirstChar, uLastChar, lpnWidths);
#else
    if (uLastChar <= 127)
    {
        if (GetCharWidthA(hdc, uFirstChar, uLastChar, lpnWidths))
            return TRUE;
    }

    if (g_fDBCSEnabled)
    {
        TEXTMETRIC tm;
        WCHAR   wch;
        int     iWidth;
        BOOL    fRet;

        // This is a workaround for FE Win95 bug which causes GPF when obtaining widths of
        // characters between 0xF000 to 0xF0FF if the font isn't SYMBOL_CHARSET.
        if (uLastChar >= 0xF000 && uFirstChar <= 0xF0FF)
        {
            GetTextMetrics(hdc, &tm);
            if (SYMBOL_CHARSET != tm.tmCharSet)
            {
                fRet = GetCharWidthW(hdc, tm.tmDefaultChar, tm.tmDefaultChar, &iWidth);
                for (wch = (WCHAR)uFirstChar; wch <= (WCHAR)uLastChar; wch++)
                    lpnWidths[wch - uFirstChar] = iWidth;
                return fRet;
            }
            else
                goto LCallGetCharWidthW;

        }
        else if (!FCpgChinese(g_uiACP))
            goto LCheck00b7;

        GetTextMetrics(hdc, &tm);
        if (!FChsDbcs(tm.tmCharSet))
            goto LCheck00b7;

        if (FCpgPRC(g_uiACP))
        // This is a workaround for Win95 PRC bug which causes quite a few Chinese
        // characters to have only nearly half the actual width.
        {
#define uPUAFirst   0xe815
#define uPUALast    0xe964

            int     usr;

            if (fRet = GetCharWidthW(hdc, uFirstChar, uLastChar, lpnWidths))
            {
                if (((usr = UsrFromWch((WCHAR)uFirstChar)) == usrCJKUnifiedIdeo ||
                        usr == usrCJKCompatibilityIdeographs || FBetween(uFirstChar, uPUAFirst, uPUALast)) ||
                     ((usr = UsrFromWch((WCHAR)uLastChar)) == usrCJKUnifiedIdeo ||
                        usr == usrCJKCompatibilityIdeographs || FBetween(uLastChar, uPUAFirst, uPUALast)))
                {
                    fRet = GetCharWidthW(hdc, 0x4e00, 0x4e00, &iWidth);

                    for (wch = (WCHAR)uFirstChar; wch <= (WCHAR)uLastChar; wch ++)
                        if ((usr = UsrFromWch(wch)) == usrCJKUnifiedIdeo ||
                                usr == usrCJKCompatibilityIdeographs || FBetween(wch, uPUAFirst, uPUALast))
                            lpnWidths[wch - uFirstChar] = iWidth;
                }
            }
        }
        else if (FCpgTaiwan(g_uiACP))
            // This is a workaround for Win95 TWN, since GetCharWidthW may return wrong values
            // for some characters. We assume all Full-Width characters have the same width, and
            // still use GetCharWidthA for the common used Half-Width characters.  - willisc
        {
            UINT ich;
            int dxpWidth;

            fRet = TRUE;
            GetCharWidthW(hdc, 0x4e00, 0x4e00, &dxpWidth);  // width of Chinese character '1'
            for (ich = uFirstChar; ich <= uLastChar; ich++)
            {
                if ((ich >= 0x4e00 && ich <= 0x9fff) || (ich >= 0xe000 && ich <= 0xffe5))
                    // hit most Full-Width characters, always use width of Chinese '1'
                    lpnWidths[ich - uFirstChar] = dxpWidth;
                else if (ich >= 0x20 && ich <= 0x7d)
                    // hit most Half-Width characters, use trustable GetCharWidthA
                    GetCharWidthA(hdc, ich, ich, &(lpnWidths[ich - uFirstChar]));
                else
                {
                    if (ich == 0x2018 || ich == 0x2019) // these two may be mapped to full
                        lpnWidths[ich - uFirstChar] = dxpWidth;
                    else
                    {   // for others, use WideChar->MultiByte to check its full or half width
                        UCHAR uChar[3];
                        if (WideCharToMultiByte(CP_TAIWAN, 0, (LPCWSTR)&ich, 1,
                                (LPSTR)uChar, 2, NULL, NULL) == 2)
                            lpnWidths[ich - uFirstChar] = dxpWidth;
                        else    // half-width, use GetCharWidthA
                            GetCharWidthA(hdc, *uChar, *uChar, &(lpnWidths[ich - uFirstChar]));
                    }
                }
                //  REVIEW:  PETERO:  fRet only reflects uLastChar
            }
        }
        return fRet;
    }
    else
LCheck00b7:
        if (FBetween(0x00b7, uFirstChar, uLastChar))
    {
        // This is a workaround for Win95 bug which causes U+00B7 character to
        // be rendered improperly when using the wide API (substituting U+2219
        // achieves the desired effect for some reason!)
        //
        // REVIEW nobuyah: is this a performance bottleneck?
        BOOL fRet;

        fRet = GetCharWidthW(hdc, uFirstChar, uLastChar, lpnWidths);
        if (fRet)
            fRet = GetCharWidthW(hdc, 0x2219, 0x2219, lpnWidths + 0x00b7 - uFirstChar);
        return (fRet);
    }
    else
    {
LCallGetCharWidthW:
        return (GetCharWidthW(hdc, uFirstChar, uLastChar, lpnWidths));
    }
#endif
}

//
//  _GetCharWidthWFontLink
//
//  This is a filter for _GetCharWidthW() calls that does font linking.
//
//  The input string is scanned and fonts are switched if not all chars are
//  supported by the current font in the HDC.
//
BOOL _GetCharWidthWFontLink(HDC hdc, UINT uFirstChar, UINT uLastChar, LPINT lpnWidths)
{
    HFONT hfont = NULL;
    HFONT hfontSav = NULL;
    HFONT hfontMap = NULL;
    WCHAR xch, xchFirst, xchLast = (WCHAR)uLastChar;
    DWORD dwFontCodePages, dwCharCodePages;
    BOOL fRet = FALSE;
    IMLangFontLink *pMLFontLink = NULL;

    switch (FDoFontLink(hdc, &pMLFontLink, (WCHAR)uFirstChar, (WCHAR)uLastChar))
    {
        case S_OK:
            break;
        case S_FALSE:
            UINT ui;
            UINT uCharAnsi;
            ASSERT(uFirstChar <= uLastChar);
            for (ui=uFirstChar; ui<= uLastChar; ui++)
            {
                uCharAnsi = 0;
                if (WideCharToMultiByte(CP_ACP, 0, (LPCWSTR) &ui, 1, (LPSTR) &uCharAnsi, sizeof(uCharAnsi), NULL, NULL))
                    fRet = GetCharWidthA(hdc, uCharAnsi, uCharAnsi, &(lpnWidths[ui - uFirstChar]));
                if (!fRet)
                    break;
            }
            return fRet;
        default:
            return FALSE;
    }

    hfont = (HFONT)GetCurrentObject(hdc, OBJ_FONT);
    pMLFontLink->GetFontCodePages(hdc, hfont, &dwFontCodePages);

    // See if whole string can be handled by current font
    for (xch = (WCHAR)uFirstChar; xch <= xchLast; xch++)
    {
        pMLFontLink->GetCharCodePages(xch, &dwCharCodePages);
        if (!(dwFontCodePages & dwCharCodePages))
        {
            // Output the run
            if ((xch - uFirstChar) > 0)
                fRet = _OtherGetCharWidthW(hdc, uFirstChar, xch - 1, lpnWidths);
            break;
        }
    }

    while (xch <= xchLast)
    {
        xchFirst = xch;
        pMLFontLink->MapFont(hdc, dwCharCodePages, hfont, &hfontMap);
        hfontSav = (HFONT)SelectObject(hdc, hfontMap);
        pMLFontLink->GetFontCodePages(hdc, hfontMap, &dwFontCodePages);

        // Collect up run of characters supported by this font
        for (xch++; xch <= xchLast; xch++)
        {
            pMLFontLink->GetCharCodePages(xch, &dwCharCodePages);
            if (!(dwFontCodePages & dwCharCodePages))
                break;
        }
                              
        // Output the run
        fRet = _OtherGetCharWidthW(hdc, xchFirst, xch - 1, lpnWidths + (xchFirst - uFirstChar));

        SelectObject(hdc, hfontSav);
        pMLFontLink->ReleaseFont(hfontMap);

        // BUGBUG:
        if (!fRet)
            break;
    }
    pMLFontLink->Release();
    return fRet;
}

BOOL GetCharWidthWrap(HDC hdc, UINT uFirstChar, UINT uLastChar, LPINT lpnWidths)
{
    BOOL fRet      = FALSE;
#ifndef WINNT
    HFONT hfont    = NULL;
    HFONT hfontSav = NULL;
#endif

    // On NT5, we use system API behavior including fontlink
    if (g_bRunOnNT5)
        return GetCharWidthW(hdc, uFirstChar, uLastChar, lpnWidths);

    if (uLastChar > 127)    // Optimization, skip for below 127
    {
#ifndef WINNT
        if (g_fMEEnabled && (hfont = GetBiDiFont(hdc)))
            hfontSav = (HFONT)SelectObject(hdc, hfont);
#endif
        fRet = _GetCharWidthWFontLink(hdc, uFirstChar, uLastChar, lpnWidths);
    }

    if (!fRet)
        fRet = _OtherGetCharWidthW(hdc, uFirstChar, uLastChar, lpnWidths);

#ifndef WINNT
    if (hfont)
    {
        SelectObject(hdc, hfontSav);
        DeleteObject(hfont);
    }
#endif
    return fRet;
}

BOOL _OtherGetTextExtentPointW(HDC hdc, LPCWSTR lpwch, int cch, LPSIZE lpSize)
{
    BOOL fRet;

    if (cch == 0)
    {
        fRet = GetTextExtentPointA(hdc, " ", 1, lpSize);
        lpSize->cx = 0;
        return fRet;
    }

#ifdef WINNT
    return GetTextExtentPoint32W(hdc, lpwch, cch, lpSize);
#else
    if (g_fMEEnabled || g_fDBCSEnabled)
    {
        UINT cpg, chs;
        CHARSETINFO csi;

        chs = GetTextCharsetInfo(hdc, NULL, 0);
        TranslateCharsetInfo(IntToPtr_(DWORD *, chs), &csi, TCI_SRCCHARSET);
        cpg = csi.ciACP;

        if ((FChsBiDi(chs) || FChsDbcs(chs)) && IsValidCodePage(cpg))
        {
            int cchOut = cch;
            int fUsedDefaultChar;
            char *pchT;
            int cchMax;
            int fRet = FALSE;

            cchMax = cchOut * sizeof(WCHAR);
            pchT = (char *)LocalAlloc(LPTR, cchMax);
            if (pchT)
            {
                cchOut = WideCharToMultiByte(cpg, 0, lpwch, cchOut, pchT, cchMax, NULL, &fUsedDefaultChar);
                if (fUsedDefaultChar)
                {
                    LocalFree(pchT);
                    goto L95GDIHack;
                }
                fRet = GetTextExtentPointA(hdc, pchT, cchOut, lpSize);
                LocalFree(pchT);
            }
            return fRet;
        }
    }
L95GDIHack:
    if (g_fDBCSEnabled)
    {
        WCHAR wchX = 'X';
        int dxp, dxpX, dxpT;

        // GetTextExtentPoint32W() GPFs on Win 95 FE for chars above U+00FF
        // Instead use a sum of GetCharWidthWrap() calls, plus the difference
        // between GetCharWidthWrap() of 'X' and GetTextExtentPoint32W() of 'X'
        fRet = GetTextExtentPoint32W(hdc, &wchX, 1, lpSize);
        if (fRet)
        {
            LPWSTR lpwchT;
            LPWSTR lpwchEnd = (LPWSTR)lpwch + cch;

            _OtherGetCharWidthW(hdc, 'X', 'X', &dxpX);
            for (dxp = 0, lpwchT = (LPWSTR)lpwch; lpwchT < lpwchEnd; lpwchT++)
            {
                _OtherGetCharWidthW(hdc, *lpwchT, *lpwchT, &dxpT);
                dxp += dxpT;
            }
            lpSize->cx = lpSize->cx - dxpX + dxp;
        }
    }
    else
        fRet = GetTextExtentPoint32W(hdc, lpwch, cch, lpSize);

    return fRet;
#endif
}

//
//  _GetTextExtentPointWFontLink
//
//  This is a filter for GetTextExtentPointW() that does font linking.
//
//  The input string is scanned and fonts are switched if not all chars are
//  supported by the current font in the HDC.
//
BOOL _GetTextExtentPointWFontLink(HDC hdc, LPCWSTR lpwch, int cch, LPSIZE lpSize)
{
    HFONT hfont = NULL;
    HFONT hfontSav = NULL;
    HFONT hfontMap = NULL;
    BOOL fRet = FALSE;
    int cchDone;
    long cchCodePages;
    DWORD dwACP, dwFontCodePages, dwCodePages;
    SIZE size;
    IMLangFontLink *pMLFontLink = NULL;

    ASSERT(cch != 0);

    switch (FDoFontLink(hdc, &pMLFontLink, lpwch, cch))
    {
        case S_OK:
            break;
        case S_FALSE:
            {
                // Times by the size of WCHAR should be enough for multibyte string buffer
                char *lpStr = (char *)LocalAlloc(LPTR, cch*sizeof(WCHAR));
                if (lpStr)
                {
                    if (cch = WideCharToMultiByte(CP_ACP,0,lpwch, cch, lpStr, cch*sizeof(WCHAR), NULL, NULL))                    
                        fRet = GetTextExtentPointA(hdc, lpStr, cch, lpSize);
                    LocalFree(lpStr);
                }
            }
            return fRet;
        default:
            return FALSE;
    }

    hfont = (HFONT)GetCurrentObject(hdc, OBJ_FONT);
    pMLFontLink->GetFontCodePages(hdc, hfont, &dwFontCodePages);
    pMLFontLink->CodePageToCodePages(g_uiACP, &dwACP); // Give priority to CP_ACP

    // See if whole string can be handled by current font
    pMLFontLink->GetStrCodePages(lpwch, cch, dwACP, &dwCodePages, &cchCodePages);

    // current font supports whole string ?
    if ((dwFontCodePages & dwCodePages) && cch == cchCodePages)
    {
        pMLFontLink->Release();
        return FALSE;
    }
    // Get Hight of DC font
    if (!(fRet = GetTextExtentPointA(hdc, " ", 1, lpSize)))
    {
        pMLFontLink->Release();
        return FALSE;
    }
    lpSize->cx = 0;

    for (cchDone = 0; cchDone < cch; cchDone += cchCodePages)
    {
        pMLFontLink->GetStrCodePages(lpwch + cchDone, cch - cchDone, dwACP, &dwCodePages, &cchCodePages);

        if (!(dwFontCodePages & dwCodePages))
        {
            pMLFontLink->MapFont(hdc, dwCodePages, hfont, &hfontMap);
            hfontSav = (HFONT)SelectObject(hdc, hfontMap);
        }

        // cchCodePages shouldn't be 0
        ASSERT(cchCodePages);

        if (cchCodePages > 0)
        {
            fRet = _OtherGetTextExtentPointW(hdc, lpwch + cchDone, cchCodePages, &size);
            lpSize->cx += size.cx;
        }

        if (NULL != hfontSav)
        {
            SelectObject(hdc, hfontSav);
            pMLFontLink->ReleaseFont(hfontMap);
            hfontSav = NULL;
        }
    }
    pMLFontLink->Release();
    return fRet;
}

BOOL GetTextExtentPointWrap(HDC hdc, LPCWSTR lpwch, int cch, LPSIZE lpSize)
{
    BOOL fRet      = FALSE;
#ifndef WINNT
    HFONT hfont    = NULL;
    HFONT hfontSav = NULL;
#endif

    // On NT5, we use system API behavior including fontlink
    if (g_bRunOnNT5)
        return GetTextExtentPointW(hdc, lpwch, cch, lpSize);

    if (cch)
    {
        // Optimize for all < 128 case
        if (cch < 256 && lpwch[0] <= 127)
        {
            char lpchA[256];
            int ich;
            BOOL fAscii = TRUE;

            for (ich = 0; ich < cch; ich++)
            {
                WCHAR wch = lpwch[ich];

                if (wch <= 127)
                    lpchA[ich] = (char) wch;
                else
                {
                    fAscii = FALSE;
                    break;
                }
            }
            if (fAscii)
                return GetTextExtentPointA(hdc, lpchA, cch, lpSize);
        }
#ifndef WINNT
        if (g_fMEEnabled && (hfont = GetBiDiFont(hdc)))
            hfontSav = (HFONT)SelectObject(hdc, hfont);
#endif
        fRet = _GetTextExtentPointWFontLink(hdc, lpwch, cch, lpSize);
    }
    if (!fRet)
        fRet = _OtherGetTextExtentPointW(hdc, lpwch, cch, lpSize);
#ifndef WINNT
    if (hfont)
    {
        SelectObject(hdc, hfontSav);
        DeleteObject(hfont);
    }
#endif
    return fRet;
}

BOOL GetTextExtentPoint32Wrap(HDC hdc, LPCWSTR lpwch, int cch, LPSIZE lpSize)
{
    return GetTextExtentPointWrap(hdc, lpwch, cch, lpSize);
}
 
void _RgwchRgdxpCpToRgchRgdxp(const WCHAR *pwchSrc,
                              const int *pdxpSrc,
                              char *pchDest,
                              int *pdxpDest,
                              int *pcch,
                              UINT cpg,
                              int *pfUsedDefaultChar)
{
    int cchIn = *pcch;
    int cch;
    char *pch = pchDest;
    char rgch[2];
    int fUsedDefaultChar;

    if (pfUsedDefaultChar)
        *pfUsedDefaultChar = 0;
    while (--cchIn >= 0)
    {
        cch = WideCharToMultiByte(cpg,
                                  0,
                                  pwchSrc++,
                                  1,
                                  rgch,
                                  sizeof(rgch),
                                  NULL,
                                  &fUsedDefaultChar);
        if (pfUsedDefaultChar)
            *pfUsedDefaultChar |= fUsedDefaultChar;
        if (cch == 0)
        {
            cch = WideCharToMultiByte(CP_ACP,
                                      0,
                                      pwchSrc-1,
                                      1,
                                      rgch,
                                      sizeof(rgch),
                                      NULL,
                                      NULL);
        }

        if (cch == 0)
        {
            ASSERT(FALSE);
            return;
        }
        *(pch++) = rgch[0];
        *(pdxpDest++) = *(pdxpSrc++);
        if (cch == 2)
        {
            *(pch++) = rgch[1];
            *(pdxpDest++) = 0;
        }
    }
    *pcch = (int)(pch - pchDest);
}

BOOL _ExtTextOutWForWin95(HDC hdc, int xp, int yp, UINT eto,
                          CONST RECT *lprect, LPCWSTR lpwch, UINT cLen,
                          CONST INT *lpdxp)
{
    WCHAR sz[256];
    LPWSTR lpwchAlloc = sz;
    LPWSTR lpwchT = (LPWSTR)lpwch;
    LPWSTR lpwchEnd = (LPWSTR)lpwch + cLen;
    BOOL fCopied = FALSE;
    BOOL fRet;

    // This is a workaround for Win95 bug which causes U+00B7 character to
    // be rendered improperly when using the wide API (substituting U+2219
    // achieves the desired effect for some reason!)
    while (lpwchT < lpwchEnd)
    {
        if (*lpwchT == 0x00b7)
        {
            if (!fCopied)
            {
                if (cLen > 256)
                    lpwchAlloc = (LPWSTR)LocalAlloc(LPTR, cLen * sizeof(WCHAR));
                memcpy(lpwchAlloc, lpwch, cLen * sizeof(WCHAR));
                lpwchT = lpwchAlloc + (lpwchT - lpwch);
                lpwchEnd = lpwchAlloc + cLen;
                fCopied = TRUE;
            }
            *lpwchT = 0x2219;
        }
        lpwchT++;
    }

    fRet = ExtTextOutW(hdc, xp, yp, eto, lprect, fCopied ? lpwchAlloc : lpwch, cLen, lpdxp);
    if (lpwchAlloc != sz)
        LocalFree(lpwchAlloc);

    return fRet;
}

BOOL _OtherExtTextOutW(HDC hdc, int xp, int yp, UINT eto, CONST RECT *lprect,
                       LPCWSTR lpwch, UINT cLen, CONST INT *lpdxp)
{
    UINT cpg = CP_DEFAULT;

    if (!(eto & ETO_GLYPH_INDEX) && cLen < 256 && lpwch[0] <= 127)
    {
        char lpchA[256];
        UINT ich;
        BOOL fAscii = TRUE;

        for (ich = 0; ich < cLen; ich++)
        {
            WCHAR wch = lpwch[ich];

            if (wch <= 127)
                lpchA[ich] = (char) wch;
            else
            {
                fAscii = FALSE;
                break;
            }
        }
        if (fAscii)
            return ExtTextOutA(hdc, xp, yp, eto, lprect, lpchA, cLen, lpdxp);
    }

#ifdef WINNT
    return (ExtTextOutW(hdc, xp, yp, eto, lprect, lpwch, cLen, lpdxp));
#else   
    {
        UINT chs;
        CHARSETINFO csi;

        // BUGBUG: Do we need DT_METAFILE handling in comctl32?
        ASSERT(GetDeviceCaps(hdc, TECHNOLOGY) != DT_METAFILE);

        chs = GetTextCharsetInfo(hdc, NULL, 0);
        TranslateCharsetInfo(IntToPtr_(DWORD *, chs), &csi, TCI_SRCCHARSET);
        cpg = csi.ciACP;

        // This is a workaround for Win95ME bug
        if (FChsBiDi(chs) && IsValidCodePage(cpg) && g_fMEEnabled && !g_bRunOnMemphis)
        {
            int cchOut = cLen;
            int *pdxp = NULL;
            char *pchT;
            int cchMax;
            int fRet = FALSE;

            cchMax = cchOut * sizeof(WCHAR);
            pchT = (char *)LocalAlloc(LPTR, cchMax);
            if (pchT)
            {
                if (lpdxp)
                {
                    pdxp = (int *)LocalAlloc(LPTR, cchMax * sizeof(int));
                    if (pdxp)
                        _RgwchRgdxpCpToRgchRgdxp(lpwch, lpdxp, pchT, pdxp, &cchOut,
                                                 cpg, NULL);
                }
                else
                    cchOut = WideCharToMultiByte(cpg, 0, lpwch, cchOut, pchT, cchMax, NULL, NULL);
                fRet = ExtTextOutA(hdc, xp, yp, eto, lprect, pchT, cchOut, pdxp);
                LocalFree(pchT);
            }
            if (pdxp)
                LocalFree(pdxp);

            return fRet;
        }

        // This is a workaround for Win95FE bug
        if (FChsDbcs(chs) && IsValidCodePage(cpg) && g_fDBCSEnabled)
        {
            int cchOut = cLen;
            int fUsedDefaultChar;
            int *pdxp = NULL;
            char *pchT;
            int cchMax;
            int fRet;

            cchMax = cchOut * sizeof(WCHAR);
            pchT = (char *)LocalAlloc(LPTR, cchMax);
            if (pchT)
            {
                if (lpdxp)
                {
                    pdxp = (int *)LocalAlloc(LPTR, cchMax * sizeof(int));
                    _RgwchRgdxpCpToRgchRgdxp(lpwch, lpdxp, pchT, pdxp, &cchOut,
                                             cpg, &fUsedDefaultChar);
                    if (fUsedDefaultChar)
                    {
                        LocalFree(pchT);
                        if (pdxp)
                            LocalFree(pdxp);
                        goto L95GDIHack;
                    }
                    fRet = ExtTextOutA(hdc, xp, yp, eto, lprect, pchT, cchOut, pdxp);
                }
                else
                {
                    cchOut = WideCharToMultiByte(cpg, 0, lpwch, cchOut, pchT, cchMax, NULL, &fUsedDefaultChar);
                    if (fUsedDefaultChar)
                    {
                        LocalFree(pchT);
                        goto L95GDIHack;
                    }
                    fRet = ExtTextOutA(hdc, xp, yp, eto, lprect, pchT, cchOut, NULL);
                }
                LocalFree(pchT);
            }
            if (pdxp)
                LocalFree(pdxp);
            return fRet;
        }
        else
        {
L95GDIHack:
            if (g_fDBCSEnabled) // Running on an FE system?
            {
                // This is a work around for Win95FE bugs that cause GPFs in GDI if multiple
                // characters above Unicode 0xFF are passed to ExtTextOutW.
                LPCWSTR lpwchT = lpwch;
                LPCWSTR lpwchStart = lpwchT;
                LPCWSTR lpwchEnd = lpwch + cLen;
                BOOL    fFirst = TRUE;
                BOOL    fErased = FALSE;
                POINT   pt;
                int     cwch;
                BOOL    fRet;
                int     dxpMul = 0;
                int     dypMul = 0;
                int     dzpAdvance;
                CONST int *lpdxpCur;

                while (lpwchT < lpwchEnd)
                {
                    if (*lpwchT > 0x00FF)
                    {
                        if (fFirst)
                        {
                            // Ok, time to figure out the Escapement
                            // this is done by rendering a space and discovering the
                            // delta from the current position UGLY but it works!!!
                            RECT  rect;
                            WCHAR wch = SPACE_CHAR;
                            POINT ptT;
                            UINT  uiTextAlign = GetTextAlign(hdc);

                            // Cache current location
                            MoveToEx(hdc, xp, yp, &pt);
                            // Render a safe character (clipped) at xp,yp
                            rect.top = rect.bottom = rect.left = rect.right = 0;
                            if (!(uiTextAlign & TA_UPDATECP))
                                SetTextAlign(hdc, TA_UPDATECP);
                            fRet = _ExtTextOutWForWin95(hdc, xp, yp, ETO_CLIPPED, &rect, &wch, 1, NULL);                            
                            if (!(uiTextAlign & TA_UPDATECP))
                                SetTextAlign(hdc, TA_NOUPDATECP);
                            // Get the current point location and calculate escapement from that point
                            MoveToEx(hdc, pt.x, pt.y, &ptT);
                            if (ptT.x != xp)
                                dxpMul = ptT.x > xp ? 1 : -1;
                            else
                                dypMul = ptT.y > yp ? 1 : -1;

                            fFirst = FALSE;
                        }

                        if ((cwch = lpwchT - lpwchStart) > 0)
                        {
                            lpdxpCur = lpdxp ? lpdxp + (lpwchStart - lpwch) : (int *)NULL;

                            // Output the run of chars less than 0xFF
                            fRet = _ExtTextOutWForWin95(hdc, xp, yp, eto, lprect, lpwchStart, cwch, lpdxpCur);
                            if (!fRet)
                                return fRet;
                            eto &= ~ETO_OPAQUE; // Don't erase mutliple times!!!
                            // Calculate advance amount
                            if (lpdxpCur)
                            {
                                dzpAdvance = 0;
                                while (cwch--)
                                    dzpAdvance += *lpdxpCur++;
                            }
                            else
                            {
                                SIZE size;
                                GetTextExtentPointWrap(hdc, lpwchStart, cwch, &size);
                                dzpAdvance = size.cx;
                            }
                            if (dxpMul)
                                xp += dzpAdvance * dxpMul;
                            else
                                yp += dzpAdvance * dypMul;

                            lpwchStart = lpwchT;
                        }

                        // Output chars above 0xFF one at a time to prevent GPF
                        lpdxpCur = lpdxp ? lpdxp + (lpwchStart - lpwch) : (int *)NULL;
                        fRet = _ExtTextOutWForWin95(hdc, xp, yp, eto, lprect, lpwchStart, 1, lpdxpCur);
                        if (!fRet)
                            return fRet;
                        eto &= ~ETO_OPAQUE; // Don't erase mutliple times!!!

                        if (lpdxpCur)
                            dzpAdvance = *lpdxpCur;
                        else
                        {
                            SIZE size;
                            GetTextExtentPointWrap(hdc, lpwchStart, 1, &size);
                            dzpAdvance = size.cx;
                        }

                        if (dxpMul)
                            xp += dzpAdvance * dxpMul;
                        else
                            yp += dzpAdvance * dypMul;

                        lpwchStart++;
                    }
                    lpwchT++;
                }

                if ((cwch = lpwchT - lpwchStart) > 0)
                {
                    fRet = _ExtTextOutWForWin95(hdc, xp, yp, eto, lprect, lpwchStart, cwch,
                                        lpdxp ? lpdxp + (lpwchStart - lpwch) : (int *)NULL);
                }
                return fRet;
            }
            else            
                return (_ExtTextOutWForWin95(hdc, xp, yp, eto, lprect, lpwch, cLen, lpdxp));
        }
    }
#endif
    ASSERT(FALSE);
    return FALSE;
}

BOOL _ExtTextOutWFontLink(HDC hdc, int xp, int yp, UINT eto, CONST RECT *lprect,
    LPCWSTR lpwch, UINT cLen, CONST INT *lpdxp)
{
    HFONT hfont = NULL;
    HFONT hfontSav = NULL;
    HFONT hfontMap = NULL;
    BOOL fRet = FALSE;
    UINT ta;
    int fDoTa = FALSE;
    int fQueryTa = TRUE;
    POINT pt;
    int cchDone;
    DWORD dwACP, dwFontCodePages, dwCodePages;
    long cchCodePages;
    IMLangFontLink *pMLFontLink = NULL;

    if (cLen == 0)
        return FALSE;

    switch (FDoFontLink(hdc, &pMLFontLink, lpwch, cLen))
    {
        case S_OK:
            break;
        case S_FALSE:
            {
                // Times by the size of WCHAR should be enough for multibyte string buffer
                char *lpStr = (char *)LocalAlloc(LPTR, cLen*sizeof(WCHAR));
                if (lpStr)
                {
                    if (cLen = WideCharToMultiByte(CP_ACP,0,lpwch, cLen, lpStr, cLen*sizeof(WCHAR), NULL, NULL))
                        fRet = ExtTextOutA(hdc, xp, yp, eto, lprect, lpStr, cLen, lpdxp);
                    LocalFree(lpStr);
                }
            }
            return fRet;
        default:
            return FALSE;
    }

    hfont = (HFONT)GetCurrentObject(hdc, OBJ_FONT);
    pMLFontLink->GetFontCodePages(hdc, hfont, &dwFontCodePages);
    pMLFontLink->CodePageToCodePages(g_uiACP, &dwACP); // Give priority to CP_ACP

    // See if whole string can be handled by current font
    pMLFontLink->GetStrCodePages(lpwch, cLen, dwACP, &dwCodePages, &cchCodePages);

    // current font supports whole string ?
    if ((dwFontCodePages & dwCodePages) && cLen == (UINT)cchCodePages)
    {
        pMLFontLink->Release();
        return FALSE;
    }
    for (cchDone = 0; (UINT)cchDone < cLen; cchDone += cchCodePages)
    {
        pMLFontLink->GetStrCodePages(lpwch + cchDone, cLen - cchDone, dwACP, &dwCodePages, &cchCodePages);

        if (!(dwFontCodePages & dwCodePages))
        {
            pMLFontLink->MapFont(hdc, dwCodePages, hfont, &hfontMap);   // BUGBUG: Baseline?
            hfontSav = (HFONT)SelectObject(hdc, hfontMap);
        }

        // cchCodePages shouldn't be 0
        ASSERT(cchCodePages);

        if (cchCodePages > 0)
        {
            // If rendering in multiple parts, need to use TA_UPDATECP
            if ((UINT)cchCodePages != cLen && fQueryTa)
            {
                ta = GetTextAlign(hdc);
                if ((ta & TA_UPDATECP) == 0) // Don't do the move if x, y aren't being used
                {
                    MoveToEx(hdc, xp, yp, &pt);
                    fDoTa = TRUE;
                }
                fQueryTa = FALSE;
            }

            if (fDoTa)
                SetTextAlign(hdc, ta | TA_UPDATECP);

            fRet = _OtherExtTextOutW(hdc, xp, yp, eto, lprect, lpwch + cchDone, cchCodePages,
                        lpdxp ? lpdxp + cchDone : NULL);
            eto = eto & ~ETO_OPAQUE; // Don't do mupltiple OPAQUEs!!!
            if (fDoTa)
                SetTextAlign(hdc, ta);
            if (!fRet)
                break;
        }

        if (NULL != hfontSav)
        {
            SelectObject(hdc, hfontSav);
            pMLFontLink->ReleaseFont(hfontMap);
            hfontSav = NULL;
        }
    }
    if (fDoTa) // Don't do the move if x, y aren't being used
        MoveToEx(hdc, pt.x, pt.y, NULL);

    pMLFontLink->Release();
    return fRet;
}

BOOL ExtTextOutWrap(HDC hdc, int xp, int yp, UINT eto, CONST RECT *lprect, LPCWSTR lpwch, UINT cLen, CONST INT *lpdxp)
{
    BOOL fRet      = FALSE;
#ifndef WINNT
    HFONT hfont    = NULL;
    HFONT hfontSav = NULL;
#endif

    // On NT5, we use system API behavior including fontlink
    if (g_bRunOnNT5)
        return ExtTextOutW(hdc, xp, yp, eto, lprect, lpwch, cLen, lpdxp);

    if (cLen == 0)
    {
        char chT;
        return ExtTextOutA(hdc, xp, yp, eto, lprect, &chT, cLen, lpdxp);
    }

    // Optimize for all < 128 case
    if (!(eto & ETO_GLYPH_INDEX) && cLen < 256 && lpwch[0] <= 127)
    {
        char lpchA[256];
        UINT ich;
        BOOL fAscii = TRUE;

        for (ich = 0; ich < cLen; ich++)
        {
            WCHAR wch = lpwch[ich];

            if (wch <= 127)
                lpchA[ich] = (char) wch;
            else
            {
                fAscii = FALSE;
                break;
            }
        }
        if (fAscii)
            return ExtTextOutA(hdc, xp, yp, eto, lprect, lpchA, cLen, lpdxp);
    }

#ifdef DEBUG
    TEXTMETRIC tm;

    // BisharaK: fix bugs#40706, 43200 -- Meta is assumed false for Glyph out.
    if (!(eto & ETO_GLYPH_INDEX))
    {
        switch (GetObjectType(hdc))
        {
            case OBJ_METADC:
            case OBJ_ENHMETADC:
                ASSERT(0 && "MetafileExtTextOutW wrapper need.");
                break;

            default:
                break;
        }
    }

    GetTextMetrics(hdc, &tm);
    if (tm.tmCharSet == SYMBOL_CHARSET)
    {
        ASSERT(0 && "SymbolExtTextOutW wrapper need.");
    }
    else if (tm.tmPitchAndFamily & TMPF_DEVICE)
    {
        ASSERT(0 && "DevExtTextOutW wrapper need.");
    }
    else
#endif
    {
#ifndef WINNT
        if (g_fMEEnabled && !(eto & ETO_GLYPH_INDEX) && (hfont = GetBiDiFont(hdc)))
            hfontSav = (HFONT)SelectObject(hdc, hfont);
#endif
        // Font linking support for UI rendering
        fRet = _ExtTextOutWFontLink(hdc, xp, yp, eto, lprect, lpwch, cLen, lpdxp);
    }

    if (!fRet)
        fRet = _OtherExtTextOutW(hdc, xp, yp, eto, lprect, lpwch, cLen, lpdxp);
#ifndef WINNT
    if (hfont)
    {
        SelectObject(hdc, hfontSav);
        DeleteObject(hfont);
    }
#endif
    return fRet;
}

BOOL TextOutWrap(HDC hdc, int xp, int yp, LPCWSTR lpwch, int cLen)
{
    return ExtTextOutWrap(hdc, xp, yp, 0, NULL, lpwch, cLen, NULL);
}    


typedef  struct   {
    RECT     rcFormat;          // Format rectangle.
    int      cxTabLength;       // Tab length in pixels.
    int      iXSign;
    int      iYSign;
    int      cyLineHeight;      // Height of a line based on DT_EXTERNALLEADING
    int      cxMaxWidth;        // Width of the format rectangle.
    int      cxMaxExtent;       // Width of the longest line drawn.
    int      cxRightMargin;     // Right margin in pixels (with proper sign) on DT_NOPREFIX flag.
    int      cxOverhang;        // Character overhang.
} DRAWTEXTDATA, *LPDRAWTEXTDATA;

#define CR          13
#define LF          10
#define DT_HFMTMASK 0x03
#define DT_VFMTMASK 0x0C

// FE support both Kanji and English mnemonic characters,
// toggled from control panel.  Both mnemonics are embedded in menu
// resource templates.  The following prefixes guide their parsing.
#define CH_ENGLISHPREFIX 0x1E
#define CH_KANJIPREFIX   0x1F

#define CCHELLIPSIS 3
static CONST WCHAR szEllipsis[CCHELLIPSIS+1] = TEXT("...");

// Max length of a full path is around 260. But, most of the time, it will
// be less than 128. So, we alloc only this much on stack. If the string is
// longer, we alloc from local heap (which is slower).
//
// BOGUS: For international versions, we need to give some more margin here.
//
#define MAXBUFFSIZE     128

/***************************************************************************\
*  There are word breaking characters which are compatible with
* Japanese Windows 3.1 and FarEast Windows 95.
*
*  SJ - Country Japan , Charset SHIFTJIS, Codepage  932.
*  GB - Country PRC   , Charset GB2312  , Codepage  936.
*  B5 - Country Taiwan, Charset BIG5    , Codepage  950.
*  WS - Country Korea , Charset WANGSUNG, Codepage  949.
*  JB - Country Korea , Charset JOHAB   , Codepage 1361. *** LATER ***
*
* [START BREAK CHARACTERS]
*
*   These character should not be the last charatcer of the line.
*
*  Unicode   Japan      PRC     Taiwan     Korea
*  -------+---------+---------+---------+---------+
*
* + ASCII
*
*   U+0024 (SJ+0024)                     (WS+0024) Dollar sign
*   U+0028 (SJ+0028)                     (WS+0028) Opening parenthesis
*   U+003C (SJ+003C)                               Less-than sign
*   U+005C (SJ+005C)                               Backslash
*   U+005B (SJ+005B) (GB+005B)           (WS+005B) Opening square bracket
*   U+007B (SJ+007B) (GB+007B)           (WS+007B) Opening curly bracket
*
* + General punctuation
*
*   U+2018                               (WS+A1AE) Single Turned Comma Quotation Mark
*   U+201C                               (WS+A1B0) Double Comma Quotation Mark
*
* + CJK symbols and punctuation
*
*   U+3008                               (WS+A1B4) Opening Angle Bracket
*   U+300A (SJ+8173)                     (WS+A1B6) Opening Double Angle Bracket
*   U+300C (SJ+8175)                     (WS+A1B8) Opening Corner Bracket
*   U+300E (SJ+8177)                     (WS+A1BA) Opening White Corner Bracket
*   U+3010 (SJ+9179)                     (WS+A1BC) Opening Black Lenticular Bracket
*   U+3014 (SJ+816B)                     (WS+A1B2) Opening Tortoise Shell Bracket
*
* + Fullwidth ASCII variants
*
*   U+FF04                               (WS+A3A4) Fullwidth Dollar Sign
*   U+FF08 (SJ+8169)                     (WS+A3A8) Fullwidth opening parenthesis
*   U+FF1C (SJ+8183)                               Fullwidth less-than sign
*   U+FF3B (SJ+816D)                     (WS+A3DB) Fullwidth opening square bracket
*   U+FF5B (SJ+816F)                     (WS+A3FB) Fullwidth opening curly bracket
*
* + Halfwidth Katakana variants
*
*   U+FF62 (SJ+00A2)                               Halfwidth Opening Corner Bracket
*
* + Fullwidth symbol variants
*
*   U+FFE1                               (WS+A1CC) Fullwidth Pound Sign
*   U+FFE6                               (WS+A3DC) Fullwidth Won Sign
*
* [END BREAK CHARACTERS]
*
*   These character should not be the top charatcer of the line.
*
*  Unicode   Japan      PRC     Taiwan     Korea
*  -------+---------+---------+---------+---------+
*
* + ASCII
*
*   U+0021 (SJ+0021) (GB+0021) (B5+0021) (WS+0021) Exclamation mark
*   U+0025                               (WS+0025) Percent Sign
*   U+0029 (SJ+0029)                     (WS+0029) Closing parenthesis
*   U+002C (SJ+002C) (GB+002C) (B5+002C) (WS+002C) Comma
*   U+002E (SJ+002E) (GB+002E) (B5+002E) (WS+002E) Priod
*   U+003A                               (WS+003A) Colon
*   U+003B                               (WS+003B) Semicolon
*   U+003E (SJ+003E)                               Greater-than sign
*   U+003F (SJ+003F) (GB+003F) (B5+003F) (WS+003F) Question mark
*   U+005D (SJ+005D) (GB+005D) (B5+005D) (WS+005D) Closing square bracket
*   U+007D (SJ+007D) (GB+007D) (B5+007D) (WS+007D) Closing curly bracket
*
* + Latin1
*
*   U+00A8           (GB+A1A7)                     Spacing diaeresis
*   U+00B0                               (WS+A1C6) Degree Sign
*   U+00B7                     (B5+A150)           Middle Dot
*
* + Modifier letters
*
*   U+02C7           (GB+A1A6)                     Modifier latter hacek
*   U+02C9           (GB+A1A5)                     Modifier letter macron
*
* + General punctuation
*
*   U+2013                     (B5+A156)           En Dash
*   U+2014                     (b5+A158)           Em Dash
*   U+2015           (GB+A1AA)                     Quotation dash
*   U+2016           (GB+A1AC)                     Double vertical bar
*   U+2018           (GB+A1AE)                     Single turned comma quotation mark
*   U+2019           (GB+A1AF) (B5+A1A6) (WS+A1AF) Single comma quotation mark
*   U+201D           (GB+A1B1) (B5+A1A8) (WS+A1B1) Double comma quotation mark
*   U+2022           (GB+A1A4)                     Bullet
*   U+2025                     (B5+A14C)           Two Dot Leader
*   U+2026           (GB+A1AD) (B5+A14B)           Horizontal ellipsis
*   U+2027                     (B5+A145)           Hyphenation Point
*   U+2032                     (B5+A1AC) (WS+A1C7) Prime
*   U+2033                               (WS+A1C8) Double Prime
*
* + Letterlike symbols
*
*   U+2103                               (WS+A1C9) Degrees Centigrade
*
* + Mathemetical opetartors
*
*   U+2236           (GB+A1C3)                     Ratio
*
* + Form and Chart components
*
*   U+2574                     (B5+A15A)           Forms Light Left
*
* + CJK symbols and punctuation
*
*   U+3001 (SJ+8141) (GB+A1A2) (B5+A142)           Ideographic comma
*   U+3002 (SJ+8142) (GB+A1A3) (B5+A143)           Ideographic period
*   U+3003           (GB+A1A8)                     Ditto mark
*   U+3005           (GB+A1A9)                     Ideographic iteration
*   U+3009           (GB+A1B5) (B5+A172) (WS+A1B5) Closing angle bracket
*   U+300B (SJ+8174) (GB+A1B7) (B5+A16E) (WS+A1B7) Closing double angle bracket
*   U+300D (SJ+8176) (GB+A1B9) (B5+A176) (WS+A1B9) Closing corner bracket
*   U+300F (SJ+8178) (GB+A1BB) (B5+A17A) (WS+A1BB) Closing white corner bracket
*   U+3011 (SJ+817A) (GB+A1BF) (B5+A16A) (WS+A1BD) Closing black lenticular bracket
*   U+3015 (SJ+816C) (GB+A1B3) (B5+A166) (WS+A1B3) Closing tortoise shell bracket
*   U+3017           (GB+A1BD)                     Closing white lenticular bracket
*   U+301E                     (B5+A1AA)           Double Prime Quotation Mark
*
* + Hiragana
*
*   U+309B (SJ+814A)                               Katakana-Hiragana voiced sound mark
*   U+309C (SJ+814B)                               Katakana-Hiragana semi-voiced sound mark
*
* + CNS 11643 compatibility
*
*   U+FE30                     (B5+A14A)           Glyph for Vertical 2 Dot Leader
*   U+FE31                     (B5+A157)           Glyph For Vertical Em Dash
*   U+FE33                     (B5+A159)           Glyph for Vertical Spacing Underscore
*   U+FE34                     (B5+A15B)           Glyph for Vertical Spacing Wavy Underscore
*   U+FE36                     (B5+A160)           Glyph For Vertical Closing Parenthesis
*   U+FE38                     (B5+A164)           Glyph For Vertical Closing Curly Bracket
*   U+FE3A                     (B5+A168)           Glyph For Vertical Closing Tortoise Shell Bracket
*   U+FE3C                     (B5+A16C)           Glyph For Vertical Closing Black Lenticular Bracket
*   U+FE3E                     (B5+A16E)           Closing Double Angle Bracket
*   U+FE40                     (B5+A174)           Glyph For Vertical Closing Angle Bracket
*   U+FE42                     (B5+A178)           Glyph For Vertical Closing Corner Bracket
*   U+FE44                     (B5+A17C)           Glyph For Vertical Closing White Corner Bracket
*   U+FE4F                     (B5+A15C)           Spacing Wavy Underscore
*
* + Small variants
*
*   U+FE50                     (B5+A14D)           Small Comma
*   U+FE51                     (B5+A14E)           Small Ideographic Comma
*   U+FE52                     (B5+A14F)           Small Period
*   U+FE54                     (B5+A151)           Small Semicolon
*   U+FE55                     (B5+A152)           Small Colon
*   U+FE56                     (B5+A153)           Small Question Mark
*   U+FE57                     (B5+A154)           Small Exclamation Mark
*   U+FE5A                     (B5+A17E)           Small Closing Parenthesis
*   U+FE5C                     (B5+A1A2)           Small Closing Curly Bracket
*   U+FE5E                     (B5+A1A4)           Small Closing Tortoise Shell Bracket
*
* + Fullwidth ASCII variants
*
*   U+FF01 (SJ+8149) (GB+A3A1) (B5+A149) (WS+A3A1) Fullwidth exclamation mark
*   U+FF02           (GB+A3A2)                     Fullwidth Quotation mark
*   U+FF05                               (WS+A3A5) Fullwidth Percent Sign
*   U+FF07           (GB+A3A7)                     Fullwidth Apostrophe
*   U+FF09 (SJ+816A) (GB+A3A9) (B5+A15E) (WS+A3A9) Fullwidth Closing parenthesis
*   U+FF0C (SJ+8143) (GB+A3AC) (B5+A141) (WS+A3AC) Fullwidth comma
*   U+FF0D           (GB+A3AD)                     Fullwidth Hyphen-minus
*   U+FF0E (SJ+8144)           (B5+A144) (WS+A3AE) Fullwidth period
*   U+FF1A           (GB+A3BA) (B4+A147) (WS+A3BA) Fullwidth colon
*   U+FF1B           (GB+A3BB) (B5+A146) (WS+A3BB) Fullwidth semicolon
*   U+FF1E (SJ+8184)                               Fullwidth Greater-than sign
*   U+FF1F (SJ+8148) (GB+A3BF) (B5+A148) (WS+A3BF) Fullwidth question mark
*   U+FF3D (SJ+816E) (GB+A3DD)           (WS+A3DD) Fullwidth Closing square bracket
*   U+FF5C                     (B5+A155)           Fullwidth Vertical Bar
*   U+FF5D (SJ+8170)           (B5+A162) (WS+A3FD) Fullwidth Closing curly bracket
*   U+FF5E           (GB+A1AB)                     Fullwidth Spacing tilde
*
* + Halfwidth Katakana variants
*
*   U+FF61 (SJ+00A1)                               Halfwidth Ideographic period
*   U+FF63 (SJ+00A3)                               Halfwidth Closing corner bracket
*   U+FF64 (SJ+00A4)                               Halfwidth Ideographic comma
*   U+FF9E (SJ+00DE)                               Halfwidth Katakana voiced sound mark
*   U+FF9F (SJ+00DF)                               Halfwidth Katakana semi-voiced sound mark
*
* + Fullwidth symbol variants
*
*   U+FFE0                               (WS+A1CB) Fullwidth Cent Sign
*
\***************************************************************************/

#if 0   // not currently used --- FYI only
/***************************************************************************\
* Start Break table
*  These character should not be the last charatcer of the line.
\***************************************************************************/

CONST BYTE aASCII_StartBreak[] = {
/* 00       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
/* 2X */                1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
/* 3X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
/* 4X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 5X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0,
/* 6X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 7X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1
};

CONST BYTE aCJKSymbol_StartBreak[] = {
/* 30       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
/* 0X */                            1, 0, 1, 0, 1, 0, 1, 0,
/* 1X */    1, 0, 0, 0, 1
};

CONST BYTE aFullWidthHalfWidthVariants_StartBreak[] = {
/* FF       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
/* 0X */                1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
/* 1X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
/* 2X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 3X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
/* 4X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 5X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
/* 6X */    0, 0, 1
};
#endif

/***************************************************************************\
* End Break table.
*  These character should not be the top charatcer of the line.
\***************************************************************************/

CONST BYTE aASCII_Latin1_EndBreak[] = {
/* 00       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
/* 2X */       1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0,
/* 3X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1,
/* 4X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 5X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
/* 6X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 7X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
/* 8X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 9X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* AX */    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
/* BX */    1, 0, 0, 0, 0, 0, 0, 1
};

CONST BYTE aGeneralPunctuation_EndBreak[] = {
/* 20       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
/* 1X */             1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0,
/* 2X */    0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
/* 3X */    0, 0, 1, 1
};

CONST BYTE aCJKSymbol_EndBreak[] = {
/* 30       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
/* 0X */       1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1,
/* 1X */    0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1
};

CONST BYTE aCNS11643_SmallVariants_EndBreak[] = {
/* FE       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
/* 3X */    1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
/* 4X */    1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
/* 5X */    1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1
};

CONST BYTE aFullWidthHalfWidthVariants_EndBreak[] = {
/* FF       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
/* 0X */       1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0,
/* 1X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1,
/* 2X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 3X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
/* 4X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 5X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0,
/* 6X */    0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 7X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 8X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 9X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1
};

/***************************************************************************\
*  UserIsFELineBreak() - Detects Far East word breaking characters.         *
*                                                                           *
* History:                                                                  *
* 10-Mar-1996 HideyukN  Created.                                            *
\***************************************************************************/

#if 0   // not currently used --- FYI only
BOOL UserIsFELineBreakStart(WCHAR wch)
{
    switch (wch>>8)
    {
        case 0x00:
            // Check if word breaking chars in ASCII.
            if ((wch >= 0x0024) && (wch <= 0x007B))
                return ((BOOL)(aASCII_StartBreak[wch - 0x0024]));
            else
                return FALSE;

        case 0x20:
            // Check if work breaking chars in "General punctuation"
            if ((wch == 0x2018) || (wch == 0x201C))
                return TRUE;
            else
                return FALSE;

        case 0x30:
            // Check if word breaking chars in "CJK symbols and punctuation"
            // and Hiragana.
            if ((wch >= 0x3008) && (wch <= 0x3014))
                return ((BOOL)(aCJKSymbol_StartBreak[wch - 0x3008]));
            else
                return FALSE;

        case 0xFF:
            // Check if word breaking chars in "Fullwidth ASCII variants",
            // "Halfwidth Katakana variants" or "Fullwidth Symbol variants".
            if ((wch >= 0xFF04) && (wch <= 0xFF62))
                return ((BOOL)(aFullWidthHalfWidthVariants_StartBreak[wch - 0xFF04]));
            else if ((wch == 0xFFE1) || (wch == 0xFFE6))
                return TRUE;
            else
                return FALSE;

        default:
            return FALSE;
    }
}
#endif

BOOL UserIsFELineBreakEnd(WCHAR wch)
{
    switch (wch>>8)
    {
        case 0x00:
            // Check if word breaking chars in ASCII or Latin1.
            if ((wch >= 0x0021) && (wch <= 0x00B7))
                return ((BOOL)(aASCII_Latin1_EndBreak[wch - 0x0021]));
            else
                return FALSE;

        case 0x02:
            // Check if work breaking chars in "Modifier letters"
            if ((wch == 0x02C7) || (wch == 0x02C9))
                return TRUE;
            else
                return FALSE;

        case 0x20:
            // Check if work breaking chars in "General punctuation"
            if ((wch >= 0x2013) && (wch <= 0x2033))
                return ((BOOL)(aGeneralPunctuation_EndBreak[wch - 0x2013]));
            else
                return FALSE;

        case 0x21:
            // Check if work breaking chars in "Letterlike symbols"
            if (wch == 0x2103)
                return TRUE;
            else
                return FALSE;

        case 0x22:
            // Check if work breaking chars in "Mathemetical opetartors"
            if (wch == 0x2236)
                return TRUE;
            else
                return FALSE;

        case 0x25:
            // Check if work breaking chars in "Form and Chart components"
            if (wch == 0x2574)
                return TRUE;
            else
                return FALSE;

        case 0x30:
            // Check if word breaking chars in "CJK symbols and punctuation"
            // and Hiragana.
            if ((wch >= 0x3001) && (wch <= 0x301E))
                return ((BOOL)(aCJKSymbol_EndBreak[wch - 0x3001]));
            else if ((wch == 0x309B) || (wch == 0x309C))
                return TRUE;
            else
                return FALSE;

        case 0xFE:
            // Check if word breaking chars in "CNS 11643 compatibility"
            // or "Small variants".
            if ((wch >= 0xFE30) && (wch <= 0xFE5E))
                return ((BOOL)(aCNS11643_SmallVariants_EndBreak[wch - 0xFE30]));
            else
                return FALSE;

        case 0xFF:
            // Check if word breaking chars in "Fullwidth ASCII variants",
            // "Halfwidth Katakana variants" or "Fullwidth symbol variants".
            if ((wch >= 0xFF01) && (wch <= 0xFF9F))
                return ((BOOL)(aFullWidthHalfWidthVariants_EndBreak[wch - 0xFF01]));
            else if (wch >= 0xFFE0)
                return TRUE;
            else
                return FALSE;

        default:
            return FALSE;
    }
}

#define UserIsFELineBreak(wChar)    UserIsFELineBreakEnd(wChar)

typedef struct _FULLWIDTH_UNICODE {
    WCHAR Start;
    WCHAR End;
} FULLWIDTH_UNICODE, *PFULLWIDTH_UNICODE;

#define NUM_FULLWIDTH_UNICODES    4

CONST FULLWIDTH_UNICODE FullWidthUnicodes[] =
{
   { 0x4E00, 0x9FFF }, // CJK_UNIFIED_IDOGRAPHS
   { 0x3040, 0x309F }, // HIRAGANA
   { 0x30A0, 0x30FF }, // KATAKANA
   { 0xAC00, 0xD7A3 }  // HANGUL
};

BOOL UserIsFullWidth(WCHAR wChar)
{
    int index;

    // Early out for ASCII.
    if (wChar < 0x0080)
    {
        // if the character < 0x0080, it should be a halfwidth character.
        return FALSE;
    }
    // Scan FullWdith definition table... most of FullWidth character is
    // defined here... this is more faster than call NLS API.
    for (index = 0; index < NUM_FULLWIDTH_UNICODES; index++)
    {
        if ((wChar >= FullWidthUnicodes[index].Start) && (wChar <= FullWidthUnicodes[index].End))
            return TRUE;
    }

    // BUGBUG: We need one more case here to match NT5 implementation - beomoh
    // if this Unicode character is mapped to Double-Byte character,
    // this is also FullWidth character..

    return FALSE;
}

LPCWSTR GetNextWordbreak(LPCWSTR lpch,
                         LPCWSTR lpchEnd,
                         DWORD  dwFormat,
                         LPDRAWTEXTDATA lpDrawInfo)
{
    /* ichNonWhite is used to make sure we always make progress. */
    int ichNonWhite = 1;
    int ichComplexBreak = 0;        // Breaking opportunity for complex scripts
#if ((DT_WORDBREAK & ~0xff) != 0)
#error cannot use BOOLEAN for DT_WORDBREAK, or you should use "!!" before assigning it
#endif
    BOOLEAN fBreakSpace = (BOOLEAN)(dwFormat & DT_WORDBREAK);
    // If DT_WORDBREAK and DT_NOFULLWIDTHCHARBREAK are both set, we must
    // stop assuming FullWidth characters as word as we're doing in
    // NT4 and Win95. Instead, CR/LF and/or white space will only be
    // a line-break characters.
    BOOLEAN fDbcsCharBreak = (fBreakSpace && !(dwFormat & DT_NOFULLWIDTHCHARBREAK));

    // We must terminate this loop before lpch == lpchEnd, otherwise, we may gp fault during *lpch.
    while (lpch < lpchEnd)
    {
        switch (*lpch)
        {
            case CR:
            case LF:
                return lpch;

            case '\t':
            case ' ':
                if (fBreakSpace)
                    return (lpch + ichNonWhite);

            // FALL THRU //

            default:
                // Since most Japanese writing don't use space character
                // to separate each word, we define each Kanji character
                // as a word.
                if (fDbcsCharBreak && UserIsFullWidth(*lpch))
                {
                    if (!ichNonWhite)
                        return lpch;

                    // if the next character is the last character of this string,
                    // We return the character, even this is a "KINSOKU" charcter...
                    if ((lpch+1) != lpchEnd)
                    {
                        // Check next character of FullWidth character.
                        // if the next character is "KINSOKU" character, the character
                        // should be handled as a part of previous FullWidth character.
                        // Never handle is as A character, and should not be a Word also.
                        if (UserIsFELineBreak(*(lpch+1)))
                        {
                            // Then if the character is "KINSOKU" character, we return
                            // the next of this character,...
                            return (lpch + 1 + 1);
                        }
                    }
                    // Otherwise, we just return the chracter that is next of FullWidth
                    // Character. Because we treat A FullWidth chacter as A Word.
                    return (lpch + 1);
                }
                lpch++;
                ichNonWhite = 0;
        }
    }
    return lpch;
}

// This routine returns the count of accelerator mnemonics and the
// character location (starting at 0) of the character to underline.
// A single CH_PREFIX character will be striped and the following character
// underlined, all double CH_PREFIX character sequences will be replaced by
// a single CH_PREFIX (this is done by PSMTextOut). This routine is used
// to determine the actual character length of the string that will be
// printed, and the location the underline should be placed. Only
// cch characters from the input string will be processed. If the lpstrCopy
// parameter is non-NULL, this routine will make a printable copy of the
// string with all single prefix characters removed and all double prefix
// characters collapsed to a single character. If copying, a maximum
// character count must be specified which will limit the number of
// characters copied.
//
// The location of the single CH_PREFIX is returned in the low order
// word, and the count of CH_PREFIX characters that will be striped
// from the string during printing is in the hi order word. If the
// high order word is 0, the low order word is meaningless. If there
// were no single prefix characters (i.e. nothing to underline), the
// low order word will be -1 (to distinguish from location 0).
//
// These routines assume that there is only one single CH_PREFIX character
// in the string.
//
// WARNING! this rountine returns information in BYTE count not CHAR count
// (so it can easily be passed onto GreExtTextOutW which takes byte
// counts as well)
LONG GetPrefixCount(
    LPCWSTR lpstr,
    int cch,
    LPWSTR lpstrCopy,
    int charcopycount)
{
    int chprintpos = 0;         // Num of chars that will be printed
    int chcount = 0;            // Num of prefix chars that will be removed
    int chprefixloc = -1;       // Pos (in printed chars) of the prefix
    WCHAR ch;

    // If not copying, use a large bogus count...
    if (lpstrCopy == NULL)
        charcopycount = 32767;

    while ((cch-- > 0) && *lpstr && charcopycount-- != 0)
    {
        // Is this guy a prefix character ?
        if ((ch = *lpstr++) == CH_PREFIX)
        {
            // Yup - increment the count of characters removed during print.
            chcount++;

            // Is the next also a prefix char?
            if (*lpstr != CH_PREFIX)
            {
                // Nope - this is a real one, mark its location.
                chprefixloc = chprintpos;
            }
            else
            {
                // yup - simply copy it if copying.
                if (lpstrCopy != NULL)
                    *(lpstrCopy++) = CH_PREFIX;
                cch--;
                lpstr++;
                chprintpos++;
            }
        }
        else if (ch == CH_ENGLISHPREFIX)    // Still needs to be parsed
        {
            // Yup - increment the count of characters removed during print.
            chcount++;

            // Next character is a real one, mark its location.
            chprefixloc = chprintpos;
        }
        else if (ch == CH_KANJIPREFIX)    // Still needs to be parsed
        {
            // We only support Alpha Numeric(CH_ENGLISHPREFIX).
            // no support for Kana(CH_KANJIPREFIX).

            // Yup - increment the count of characters removed during print.
            chcount++;

            if(cch)
            {
                // don't copy the character
                chcount++;
                lpstr++;
                cch--;
            }
        }
        else
        {
            // Nope - just inc count of char.  that will be printed
            chprintpos++;
            if (lpstrCopy != NULL)
                *(lpstrCopy++) = ch;
        }
    }

    if (lpstrCopy != NULL)
        *lpstrCopy = 0;

    // Return the character counts
    return MAKELONG(chprefixloc, chcount);
}

// Returns total width of prefix character. Japanese Windows has
// three shortcut prefixes, '&',\036 and \037.  They may have
// different width.
int KKGetPrefixWidth(HDC hdc, LPCWSTR lpStr, int cch)
{
    SIZE size;
    SIZE iPrefix1 = {-1L,-1L};
    SIZE iPrefix2 = {-1L,-1L};
    SIZE iPrefix3 = {-1L,-1L};
    int  iTotal   = 0;

    while (cch-- > 0 && *lpStr)
    {
        switch(*lpStr)
        {
            case CH_PREFIX:
                if (lpStr[1] != CH_PREFIX)
                {
                    if (iPrefix1.cx == -1)
                        GetTextExtentPointWrap(hdc, lpStr, 1, &iPrefix1);
                    iTotal += iPrefix1.cx;
                }
                else
                {
                    lpStr++;
                    cch--;
                }
                break;

            case CH_ENGLISHPREFIX:
                if (iPrefix2.cx == -1)
                     GetTextExtentPointWrap(hdc, lpStr, 1, &iPrefix2);
                iTotal += iPrefix2.cx;
                break;

            case CH_KANJIPREFIX:
                if (iPrefix3.cx == -1)
                     GetTextExtentPointWrap(hdc, lpStr, 1, &iPrefix3);
                iTotal += iPrefix3.cx;

                // In NT, always alpha numeric mode, Then we have to sum
                // KANA accel key prefix non visible char width.
                // so always add the extent for next char.
                GetTextExtentPointWrap(hdc, lpStr, 1, &size);
                iTotal += size.cx;
                break;
            default:
                // No need to taking care of Double byte since 2nd byte of
                // DBC is grater than 0x2f but all shortcut keys are less
                // than 0x30.
                break;
        }
        lpStr++;
    }
    return iTotal;
}

// Outputs the text and puts and _ below the character with an &
// before it. Note that this routine isn't used for menus since menus
// have their own special one so that it is specialized and faster...
void PSMTextOut(
    HDC hdc,
    int xLeft,
    int yTop,
    LPWSTR lpsz,
    int cch,
    DWORD dwFlags)
{
    int cx;
    LONG textsize, result;
    WCHAR achWorkBuffer[255];
    WCHAR *pchOut = achWorkBuffer;
    TEXTMETRICW textMetric;
    SIZE size;
    RECT rc;
    COLORREF color;

    if (dwFlags & DT_NOPREFIX)
    {
        TextOutWrap(hdc, xLeft, yTop, lpsz, cch);
        return;
    }

    if (cch > sizeof(achWorkBuffer)/sizeof(WCHAR))
    {
        pchOut = (WCHAR*)LocalAlloc(LPTR, (cch+1) * sizeof(WCHAR));
        if (pchOut == NULL)
            return;
    }

    result = GetPrefixCount(lpsz, cch, pchOut, cch);

    // DT_PREFIXONLY is a new 5.0 option used when switching from keyboard cues off to on.
    if (!(dwFlags & DT_PREFIXONLY))
        TextOutWrap(hdc, xLeft, yTop, pchOut, cch - HIWORD(result));

    // Any true prefix characters to underline?
    if (LOWORD(result) == 0xFFFF || dwFlags & DT_HIDEPREFIX)
    {
        if (pchOut != achWorkBuffer)
            LocalFree(pchOut);
        return;
    }

    if (!GetTextMetricsW(hdc, &textMetric))
    {
        textMetric.tmOverhang = 0;
        textMetric.tmAscent = 0;
    }

    // For proportional fonts, find starting point of underline.
    if (LOWORD(result) != 0)
    {
        // How far in does underline start (if not at 0th byte.).
        GetTextExtentPointWrap(hdc, pchOut, LOWORD(result), &size);
        xLeft += size.cx;

        // Adjust starting point of underline if not at first char and there is
        // an overhang.  (Italics or bold fonts.)
        xLeft = xLeft - textMetric.tmOverhang;
    }

    // Adjust for proportional font when setting the length of the underline and
    // height of text.
    GetTextExtentPointWrap(hdc, pchOut + LOWORD(result), 1, &size);
    textsize = size.cx;

    // Find the width of the underline character.  Just subtract out the overhang
    // divided by two so that we look better with italic fonts.  This is not
    // going to effect embolded fonts since their overhang is 1.
    cx = LOWORD(textsize) - textMetric.tmOverhang / 2;

    // Get height of text so that underline is at bottom.
    yTop += textMetric.tmAscent + 1;

    // Draw the underline using the foreground color.
    SetRect(&rc, xLeft, yTop, xLeft+cx, yTop+1);
    color = SetBkColor(hdc, GetTextColor(hdc));
    ExtTextOutWrap(hdc, xLeft, yTop, ETO_OPAQUE, &rc, TEXT(""), 0, NULL);
    SetBkColor(hdc, color);

    if (pchOut != achWorkBuffer)
        LocalFree(pchOut);
}

int DT_GetExtentMinusPrefixes(HDC hdc, LPCWSTR lpchStr, int cchCount, UINT wFormat, int iOverhang)
{
    int iPrefixCount;
    int cxPrefixes = 0;
    WCHAR PrefixChar = CH_PREFIX;
    SIZE size;

    if (!(wFormat & DT_NOPREFIX) &&
        (iPrefixCount = HIWORD(GetPrefixCount(lpchStr, cchCount, NULL, 0))))
    {
        // Kanji Windows has three shortcut prefixes...
        if (g_fDBCSEnabled)
        {
            // 16bit apps compatibility
            cxPrefixes = KKGetPrefixWidth(hdc, lpchStr, cchCount) - (iPrefixCount * iOverhang);
        }
        else
        {
            cxPrefixes = GetTextExtentPointWrap(hdc, &PrefixChar, 1, &size);
            cxPrefixes = size.cx - iOverhang;
            cxPrefixes *=  iPrefixCount;
        }
    }
    GetTextExtentPointWrap(hdc, lpchStr, cchCount, &size);
    return (size.cx - cxPrefixes);
}

// This will draw the given string in the given location without worrying
// about the left/right justification. Gets the extent and returns it.
// If fDraw is TRUE and if NOT DT_CALCRECT, this draws the text.
// NOTE: This returns the extent minus Overhang.
int DT_DrawStr(HDC hdc, int  xLeft, int yTop, LPCWSTR lpchStr,
               int cchCount, BOOL fDraw, UINT wFormat,
               LPDRAWTEXTDATA lpDrawInfo)
{
    LPCWSTR lpch;
    int     iLen;
    int     cxExtent;
    int     xOldLeft = xLeft;   // Save the xLeft given to compute the extent later
    int     xTabLength = lpDrawInfo->cxTabLength;
    int     iTabOrigin = lpDrawInfo->rcFormat.left;

    // Check if the tabs need to be expanded
    if (wFormat & DT_EXPANDTABS)
    {
        while (cchCount)
        {
            // Look for a tab
            for (iLen = 0, lpch = lpchStr; iLen < cchCount; iLen++)
                if(*lpch++ == TEXT('\t'))
                    break;

            // Draw text, if any, upto the tab
            if (iLen)
            {
                // Draw the substring taking care of the prefixes.
                if (fDraw && !(wFormat & DT_CALCRECT))  // Only if we need to draw text
                    PSMTextOut(hdc, xLeft, yTop, (LPWSTR)lpchStr, iLen, wFormat);
                // Get the extent of this sub string and add it to xLeft.
                xLeft += DT_GetExtentMinusPrefixes(hdc, lpchStr, iLen, wFormat, lpDrawInfo->cxOverhang) - lpDrawInfo->cxOverhang;
            }

            //if a TAB was found earlier, calculate the start of next sub-string.
            if (iLen < cchCount)
            {
                iLen++;  // Skip the tab
                if (xTabLength) // Tab length could be zero
                    xLeft = (((xLeft - iTabOrigin)/xTabLength) + 1)*xTabLength + iTabOrigin;
            }

            // Calculate the details of the string that remains to be drawn.
            cchCount -= iLen;
            lpchStr = lpch;
        }
        cxExtent = xLeft - xOldLeft;
    }
    else
    {
        // If required, draw the text
        if (fDraw && !(wFormat & DT_CALCRECT))
            PSMTextOut(hdc, xLeft, yTop, (LPWSTR)lpchStr, cchCount, wFormat);
        // Compute the extent of the text.
        cxExtent = DT_GetExtentMinusPrefixes(hdc, lpchStr, cchCount, wFormat, lpDrawInfo->cxOverhang) - lpDrawInfo->cxOverhang;
    }
    return cxExtent;
}

// This function draws one complete line with proper justification
void DT_DrawJustifiedLine(HDC hdc, int yTop, LPCWSTR lpchLineSt, int cchCount, UINT wFormat, LPDRAWTEXTDATA lpDrawInfo)
{
    LPRECT  lprc;
    int     cxExtent;
    int     xLeft;

    lprc = &(lpDrawInfo->rcFormat);
    xLeft = lprc->left;

    // Handle the special justifications (right or centered) properly.
    if (wFormat & (DT_CENTER | DT_RIGHT))
    {
        cxExtent = DT_DrawStr(hdc, xLeft, yTop, lpchLineSt, cchCount, FALSE, wFormat, lpDrawInfo)
                 + lpDrawInfo->cxOverhang;
        if(wFormat & DT_CENTER)
            xLeft = lprc->left + (((lprc->right - lprc->left) - cxExtent) >> 1);
        else
            xLeft = lprc->right - cxExtent;
    }
    else
        xLeft = lprc->left;

    // Draw the whole line.
    cxExtent = DT_DrawStr(hdc, xLeft, yTop, lpchLineSt, cchCount, TRUE, wFormat, lpDrawInfo)
             + lpDrawInfo->cxOverhang;
    if (cxExtent > lpDrawInfo->cxMaxExtent)
        lpDrawInfo->cxMaxExtent = cxExtent;
}

// This is called at the begining of DrawText(); This initializes the
// DRAWTEXTDATA structure passed to this function with all the required info.
BOOL DT_InitDrawTextInfo(
    HDC                 hdc,
    LPRECT              lprc,
    UINT                wFormat,
    LPDRAWTEXTDATA      lpDrawInfo,
    LPDRAWTEXTPARAMS    lpDTparams)
{
    SIZE        sizeViewPortExt = {0, 0}, sizeWindowExt = {0, 0};
    TEXTMETRICW tm;
    LPRECT      lprcDest;
    int         iTabLength = 8;   // Default Tab length is 8 characters.
    int         iLeftMargin;
    int         iRightMargin;

    if (lpDTparams)
    {
        // Only if DT_TABSTOP flag is mentioned, we must use the iTabLength field.
        if (wFormat & DT_TABSTOP)
            iTabLength = lpDTparams->iTabLength;
        iLeftMargin = lpDTparams->iLeftMargin;
        iRightMargin = lpDTparams->iRightMargin;
    }
    else
        iLeftMargin = iRightMargin = 0;

    // Get the View port and Window extents for the given DC
    // If this call fails, hdc must be invalid
    if (!GetViewportExtEx(hdc, &sizeViewPortExt))
        return FALSE;
    GetWindowExtEx(hdc, &sizeWindowExt);

    // For the current mapping mode,  find out the sign of x from left to right.
    lpDrawInfo->iXSign = (((sizeViewPortExt.cx ^ sizeWindowExt.cx) & 0x80000000) ? -1 : 1);

    // For the current mapping mode,  find out the sign of y from top to bottom.
    lpDrawInfo->iYSign = (((sizeViewPortExt.cy ^ sizeWindowExt.cy) & 0x80000000) ? -1 : 1);

    // Calculate the dimensions of the current font in this DC.
    GetTextMetrics(hdc, &tm);

    // cyLineHeight is in pixels (This will be signed).
    lpDrawInfo->cyLineHeight = (tm.tmHeight +
        ((wFormat & DT_EXTERNALLEADING) ? tm.tmExternalLeading : 0)) * lpDrawInfo->iYSign;

    // cxTabLength is the tab length in pixels (This will not be signed)
    lpDrawInfo->cxTabLength = tm.tmAveCharWidth * iTabLength;

    // Set the cxOverhang
    lpDrawInfo->cxOverhang = tm.tmOverhang;

    // Set up the format rectangle based on the margins.
    lprcDest = &(lpDrawInfo->rcFormat);
    *lprcDest = *lprc;

    // We need to do the following only if the margins are given
    if (iLeftMargin | iRightMargin)
    {
        lprcDest->left += iLeftMargin * lpDrawInfo->iXSign;
        lprcDest->right -= (lpDrawInfo->cxRightMargin = iRightMargin * lpDrawInfo->iXSign);
    }
    else
        lpDrawInfo->cxRightMargin = 0;  // Initialize to zero.

    // cxMaxWidth is unsigned.
    lpDrawInfo->cxMaxWidth = (lprcDest->right - lprcDest->left) * lpDrawInfo->iXSign;
    lpDrawInfo->cxMaxExtent = 0;  // Initialize this to zero.

    return TRUE;
}

// In the case of WORDWRAP, we need to treat the white spaces at the
// begining/end of each line specially. This function does that.
// lpStNext = points to the begining of next line.
// lpiCount = points to the count of characters in the current line.
LPCWSTR  DT_AdjustWhiteSpaces(LPCWSTR lpStNext, LPINT lpiCount, UINT wFormat)
{
    switch (wFormat & DT_HFMTMASK)
    {
        case DT_LEFT:
            // Prevent a white space at the begining of a left justfied text.
            // Is there a white space at the begining of next line......
            if ((*lpStNext == L' ') || (*lpStNext == L'\t'))
            {
                // ...then, exclude it from next line.
                lpStNext++;
            }
            break;

        case DT_RIGHT:
            // Prevent a white space at the end of a RIGHT justified text.
            // Is there a white space at the end of current line,.......
            if ((*(lpStNext-1) == L' ') || (*(lpStNext - 1) == L'\t'))
            {
                // .....then, Skip the white space from the current line.
                (*lpiCount)--;
            }
            break;

        case DT_CENTER:
            // Exclude white spaces from the begining and end of CENTERed lines.
            // If there is a white space at the end of current line.......
            if ((*(lpStNext-1) == L' ') || (*(lpStNext - 1) == L'\t'))
                (*lpiCount)--;    //...., don't count it for justification.
            // If there is a white space at the begining of next line.......
            if ((*lpStNext == L' ') || (*lpStNext == L'\t'))
                lpStNext++;       //...., exclude it from next line.
            break;
    }
    return lpStNext;
}

// A word needs to be broken across lines and this finds out where to break it.
LPCWSTR  DT_BreakAWord(HDC hdc, LPCWSTR lpchText, int iLength, int iWidth, UINT wFormat, int iOverhang)
{
  int  iLow = 0, iHigh = iLength;
  int  iNew;

  while ((iHigh - iLow) > 1)
  {
      iNew = iLow + (iHigh - iLow)/2;
      if(DT_GetExtentMinusPrefixes(hdc, lpchText, iNew, wFormat, iOverhang) > iWidth)
          iHigh = iNew;
      else
          iLow = iNew;
  }
  // If the width is too low, we must print atleast one char per line.
  // Else, we will be in an infinite loop.
  if(!iLow && iLength)
      iLow = 1;
  return (lpchText+iLow);
}

// This finds out the location where we can break a line.
// Returns LPCSTR to the begining of next line.
// Also returns via lpiLineLength, the length of the current line.
// NOTE: (lpstNextLineStart - lpstCurrentLineStart) is not equal to the
// line length; This is because, we exclude some white spaces at the begining
// and/or end of lines; Also, CR/LF is excluded from the line length.
LPWSTR DT_GetLineBreak(
    HDC             hdc,
    LPCWSTR         lpchLineStart,
    int             cchCount,
    DWORD           dwFormat,
    LPINT           lpiLineLength,
    LPDRAWTEXTDATA  lpDrawInfo)
{
    LPCWSTR lpchText, lpchEnd, lpch, lpchLineEnd;
    int   cxStart, cxExtent, cxNewExtent;
    BOOL  fAdjustWhiteSpaces = FALSE;
    WCHAR ch;

    cxStart = lpDrawInfo->rcFormat.left;
    cxExtent = cxNewExtent = 0;
    lpchText = lpchLineStart;
    lpchEnd = lpchLineStart + cchCount;

    while(lpchText < lpchEnd)
    {
        lpchLineEnd = lpch = GetNextWordbreak(lpchText, lpchEnd, dwFormat, lpDrawInfo);
        // DT_DrawStr does not return the overhang; Otherwise we will end up
        // adding one overhang for every word in the string.

        // For simulated Bold fonts, the summation of extents of individual
        // words in a line is greater than the extent of the whole line. So,
        // always calculate extent from the LineStart.
        // BUGTAG: #6054 -- Win95B -- SANKAR -- 3/9/95 --
        cxNewExtent = DT_DrawStr(hdc, cxStart, 0, lpchLineStart, (int)(((PBYTE)lpch - (PBYTE)lpchLineStart)/sizeof(WCHAR)),
                                 FALSE, dwFormat, lpDrawInfo);

        if ((dwFormat & DT_WORDBREAK) && ((cxNewExtent + lpDrawInfo->cxOverhang) > lpDrawInfo->cxMaxWidth))
        {
            // Are there more than one word in this line?
            if (lpchText != lpchLineStart)
            {
                lpchLineEnd = lpch = lpchText;
                fAdjustWhiteSpaces = TRUE;
            }
            else
            {
                //One word is longer than the maximum width permissible.
                //See if we are allowed to break that single word.
                if((dwFormat & DT_EDITCONTROL) && !(dwFormat & DT_WORD_ELLIPSIS))
                {
                    lpchLineEnd = lpch = DT_BreakAWord(hdc, lpchText, (int)(((PBYTE)lpch - (PBYTE)lpchText)/sizeof(WCHAR)),
                          lpDrawInfo->cxMaxWidth - cxExtent, dwFormat, lpDrawInfo->cxOverhang); //Break that word
                    //Note: Since we broke in the middle of a word, no need to
                    // adjust for white spaces.
                }
                else
                {
                    fAdjustWhiteSpaces = TRUE;
                    // Check if we need to end this line with ellipsis
                    if(dwFormat & DT_WORD_ELLIPSIS)
                    {
                        // Don't do this if already at the end of the string.
                        if (lpch < lpchEnd)
                        {
                            // If there are CR/LF at the end, skip them.
                            if ((ch = *lpch) == CR || ch == LF)
                            {
                                if ((++lpch < lpchEnd) && (*lpch == (WCHAR)(ch ^ (LF ^ CR))))
                                    lpch++;
                                fAdjustWhiteSpaces = FALSE;
                            }
                        }
                    }
                }
            }
            // Well! We found a place to break the line. Let us break from this loop;
            break;
        }
        else
        {
            // Don't do this if already at the end of the string.
            if (lpch < lpchEnd)
            {
                if ((ch = *lpch) == CR || ch == LF)
                {
                    if ((++lpch < lpchEnd) && (*lpch == (WCHAR)(ch ^ (LF ^ CR))))
                        lpch++;
                    fAdjustWhiteSpaces = FALSE;
                    break;
                }
            }
        }
        // Point at the beginning of the next word.
        lpchText = lpch;
        cxExtent = cxNewExtent;
    }
    // Calculate the length of current line.
    *lpiLineLength = (INT)((PBYTE)lpchLineEnd - (PBYTE)lpchLineStart)/sizeof(WCHAR);

    // Adjust the line length and lpch to take care of spaces.
    if(fAdjustWhiteSpaces && (lpch < lpchEnd))
        lpch = DT_AdjustWhiteSpaces(lpch, lpiLineLength, dwFormat);

    // return the begining of next line;
    return (LPWSTR)lpch;
}

// This function checks whether the given string fits within the given
// width or we need to add end-ellipse. If it required end-ellipses, it
// returns TRUE and it returns the number of characters that are saved
// in the given string via lpCount.
BOOL  NeedsEndEllipsis(
    HDC             hdc,
    LPCWSTR         lpchText,
    LPINT           lpCount,
    LPDRAWTEXTDATA  lpDTdata,
    UINT            wFormat)
{
    int   cchText;
    int   ichMin, ichMax, ichMid;
    int   cxMaxWidth;
    int   iOverhang;
    int   cxExtent;
    SIZE size;
    cchText = *lpCount;  // Get the current count.

    if (cchText == 0)
        return FALSE;

    cxMaxWidth  = lpDTdata->cxMaxWidth;
    iOverhang   = lpDTdata->cxOverhang;

    cxExtent = DT_GetExtentMinusPrefixes(hdc, lpchText, cchText, wFormat, iOverhang);

    if (cxExtent <= cxMaxWidth)
        return FALSE;
    // Reserve room for the "..." ellipses;
    // (Assumption: The ellipses don't have any prefixes!)
    GetTextExtentPointWrap(hdc, szEllipsis, CCHELLIPSIS, &size);
    cxMaxWidth -= size.cx - iOverhang;

    // If no room for ellipses, always show first character.
    //
    ichMax = 1;
    if (cxMaxWidth > 0)
    {
        // Binary search to find characters that will fit.
        ichMin = 0;
        ichMax = cchText;
        while (ichMin < ichMax)
        {
            // Be sure to round up, to make sure we make progress in
            // the loop if ichMax == ichMin + 1.
            ichMid = (ichMin + ichMax + 1) / 2;

            cxExtent = DT_GetExtentMinusPrefixes(hdc, lpchText, ichMid, wFormat, iOverhang);

            if (cxExtent < cxMaxWidth)
                ichMin = ichMid;
            else
            {
                if (cxExtent > cxMaxWidth)
                    ichMax = ichMid - 1;
                else
                {
                    // Exact match up up to ichMid: just exit.
                    ichMax = ichMid;
                    break;
                }
            }
        }
        // Make sure we always show at least the first character...
        if (ichMax < 1)
            ichMax = 1;
    }
    *lpCount = ichMax;
    return TRUE;
}

// Returns a pointer to the last component of a path string.
//
// in:
//      path name, either fully qualified or not
//
// returns:
//      pointer into the path where the path is.  if none is found
//      returns a poiter to the start of the path
//
//  c:\foo\bar  -> bar
//  c:\foo      -> foo
//  c:\foo\     -> c:\foo\      (REVIEW: is this case busted?)
//  c:\         -> c:\          (REVIEW: this case is strange)
//  c:          -> c:
//  foo         -> foo
LPWSTR PathFindFileName(LPCWSTR pPath, int cchText)
{
    LPCWSTR pT;

    for (pT = pPath; cchText > 0 && *pPath; pPath++, cchText--)
    {
        if ((pPath[0] == L'\\' || pPath[0] == L':') && pPath[1])
            pT = pPath + 1;
    }
    return (LPWSTR)pT;
}

// This adds a path ellipse to the given path name.
// Returns TRUE if the resultant string's extent is less the the
// cxMaxWidth. FALSE, if otherwise.
int AddPathEllipsis(
    HDC    hdc,
    LPWSTR lpszPath,
    int    cchText,
    UINT   wFormat,
    int    cxMaxWidth,
    int    iOverhang)
{
    int    iLen;
    UINT   dxFixed, dxEllipsis;
    LPWSTR lpEnd;          /* end of the unfixed string */
    LPWSTR lpFixed;        /* start of text that we always display */
    BOOL   bEllipsisIn;
    int    iLenFixed;
    SIZE   size;

    lpFixed = PathFindFileName(lpszPath, cchText);
    if (lpFixed != lpszPath)
        lpFixed--;  // point at the slash
    else
        return cchText;

    lpEnd = lpFixed;
    bEllipsisIn = FALSE;
    iLenFixed = cchText - (int)(lpFixed - lpszPath);
    dxFixed = DT_GetExtentMinusPrefixes(hdc, lpFixed, iLenFixed, wFormat, iOverhang);

    // It is assumed that the "..." string does not have any prefixes ('&').
    GetTextExtentPointWrap(hdc, szEllipsis, CCHELLIPSIS, &size);
    dxEllipsis = size.cx - iOverhang;

    while (TRUE)
    {
        iLen = dxFixed + DT_GetExtentMinusPrefixes(hdc, lpszPath, (int)((PBYTE)lpEnd - (PBYTE)lpszPath)/sizeof(WCHAR),
                                                   wFormat, iOverhang) - iOverhang;

        if (bEllipsisIn)
            iLen += dxEllipsis;

        if (iLen <= cxMaxWidth)
            break;

        bEllipsisIn = TRUE;

        if (lpEnd <= lpszPath)
        {
            // Things didn't fit.
            lpEnd = lpszPath;
            break;
        }
        // Step back a character.
        lpEnd--;
    }

    if (bEllipsisIn && (lpEnd + CCHELLIPSIS < lpFixed))
    {
        // NOTE: the strings could over lap here. So, we use LCopyStruct.
        MoveMemory((lpEnd + CCHELLIPSIS), lpFixed, iLenFixed * sizeof(WCHAR));
        CopyMemory(lpEnd, szEllipsis, CCHELLIPSIS * sizeof(WCHAR));

        cchText = (int)(lpEnd - lpszPath) + CCHELLIPSIS + iLenFixed;

        // now we can NULL terminate the string
        *(lpszPath + cchText) = TEXT('\0');
    }
    return cchText;
}

// This function returns the number of characters actually drawn.
int AddEllipsisAndDrawLine(
    HDC            hdc,
    int            yLine,
    LPCWSTR        lpchText,
    int            cchText,
    DWORD          dwDTformat,
    LPDRAWTEXTDATA lpDrawInfo)
{
    LPWSTR pEllipsis = NULL;
    WCHAR  szTempBuff[MAXBUFFSIZE];
    LPWSTR lpDest;
    BOOL   fAlreadyCopied = FALSE;

    // Check if this is a filename with a path AND
    // Check if the width is too narrow to hold all the text.
    if ((dwDTformat & DT_PATH_ELLIPSIS) &&
        ((DT_GetExtentMinusPrefixes(hdc, lpchText, cchText, dwDTformat, lpDrawInfo->cxOverhang)) > lpDrawInfo->cxMaxWidth))
    {
        // We need to add Path-Ellipsis. See if we can do it in-place.
        if (!(dwDTformat & DT_MODIFYSTRING)) {
            // NOTE: When you add Path-Ellipsis, the string could grow by
            // CCHELLIPSIS bytes.
            if((cchText + CCHELLIPSIS + 1) <= MAXBUFFSIZE)
                lpDest = szTempBuff;
            else
            {
                // Alloc the buffer from local heap.
                if(!(pEllipsis = (LPWSTR)LocalAlloc(LPTR, (cchText+CCHELLIPSIS+1)*sizeof(WCHAR))))
                    return 0;
                lpDest = (LPWSTR)pEllipsis;
            }
            // Source String may not be NULL terminated. So, copy just
            // the given number of characters.
            CopyMemory(lpDest, lpchText, cchText*sizeof(WCHAR));
            lpchText = lpDest;        // lpchText points to the copied buff.
            fAlreadyCopied = TRUE;    // Local copy has been made.
        }
        // Add the path ellipsis now!
        cchText = AddPathEllipsis(hdc, (LPWSTR)lpchText, cchText, dwDTformat, lpDrawInfo->cxMaxWidth, lpDrawInfo->cxOverhang);
    }

    // Check if end-ellipsis are to be added.
    if ((dwDTformat & (DT_END_ELLIPSIS | DT_WORD_ELLIPSIS)) &&
        NeedsEndEllipsis(hdc, lpchText, &cchText, lpDrawInfo, dwDTformat))
    {
        // We need to add end-ellipsis; See if we can do it in-place.
        if (!(dwDTformat & DT_MODIFYSTRING) && !fAlreadyCopied)
        {
            // See if the string is small enough for the buff on stack.
            if ((cchText+CCHELLIPSIS+1) <= MAXBUFFSIZE)
                lpDest = szTempBuff;  // If so, use it.
            else {
                // Alloc the buffer from local heap.
                if (!(pEllipsis = (LPWSTR)LocalAlloc(LPTR, (cchText+CCHELLIPSIS+1)*sizeof(WCHAR))))
                    return 0;
                lpDest = pEllipsis;
            }
            // Make a copy of the string in the local buff.
            CopyMemory(lpDest, lpchText, cchText*sizeof(WCHAR));
            lpchText = lpDest;
        }
        // Add an end-ellipsis at the proper place.
        CopyMemory((LPWSTR)(lpchText+cchText), szEllipsis, (CCHELLIPSIS+1)*sizeof(WCHAR));
        cchText += CCHELLIPSIS;
    }

    // Draw the line that we just formed.
    DT_DrawJustifiedLine(hdc, yLine, lpchText, cchText, dwDTformat, lpDrawInfo);

    // Free the block allocated for End-Ellipsis.
    if (pEllipsis)
        LocalFree(pEllipsis);

    return cchText;
}

#ifdef WINNT
BOOL IsComplexScriptPresent(LPWSTR lpchText, int cchText)
{
    if (g_bComplexPlatform) {
        for (int i = 0; i < cchText; i++) {
            if (InRange(lpchText[i], 0x0590, 0x0FFF)) {
                return TRUE;
            }
        }
    }
    return FALSE;
}
#else
#define IsComplexScriptPresent(lpchText, cchText)  g_bComplexPlatform
#endif

int  DrawTextExPrivWrap(
   HDC               hdc,
   LPWSTR            lpchText,
   int               cchText,
   LPRECT            lprc,
   UINT              dwDTformat,
   LPDRAWTEXTPARAMS  lpDTparams)
{
    DRAWTEXTDATA DrawInfo;
    WORD         wFormat = LOWORD(dwDTformat);
    LPWSTR       lpchTextBegin;
    LPWSTR       lpchEnd;
    LPWSTR       lpchNextLineSt;
    int          iLineLength;
    int          iySign;
    int          yLine;
    int          yLastLineHeight;
    HRGN         hrgnClip;
    int          iLineCount;
    RECT         rc;
    BOOL         fLastLine;
    WCHAR        ch;
    UINT         oldAlign;

    // On NT5, we use system API behavior including fontlink
    if (g_bRunOnNT5)
        return DrawTextExW(hdc, lpchText, cchText, lprc, dwDTformat, lpDTparams);

    if ((cchText == 0) && lpchText && (*lpchText))
    {
        // infoview.exe passes lpchText that points to '\0'
        // Lotus Notes doesn't like getting a zero return here
        return 1;
    }

    if (cchText == -1)
        cchText = lstrlenW(lpchText);
    else if (lpchText[cchText - 1] == L'\0')
        cchText--;      // accommodate counting of NULLS for ME

    // We got the string length, then check if it a complex string or not.
    // If yes then call the system DrawTextEx API to do the job it knows how to
    // handle the complex scripts.
    if (IsComplexScriptPresent(lpchText, cchText))
    {
#ifdef WINNT
        //Call the system DrawtextExW
        return DrawTextExW(hdc, lpchText, cchText, lprc, dwDTformat, lpDTparams);
#else
        HFONT hfont    = NULL;
        HFONT hfontSav = NULL;
        int iRet;

        if (hfont = GetBiDiFont(hdc))
            hfontSav = (HFONT)SelectObject(hdc, hfont);

        CStrIn  str(lpchText, cchText);
        iRet = DrawTextExA(hdc, str, str.strlen(), lprc, dwDTformat, lpDTparams);

        if (hfont)
        {
            SelectObject(hdc, hfontSav);
            DeleteObject(hfont);
        }
        return iRet;
#endif
    }

    if ((lpDTparams) && (lpDTparams->cbSize != sizeof(DRAWTEXTPARAMS)))
    {
        ASSERT(0 && "DrawTextExWorker: cbSize is invalid");
        return 0;
    }


    // If DT_MODIFYSTRING is specified, then check for read-write pointer.
    if ((dwDTformat & DT_MODIFYSTRING) &&
        (dwDTformat & (DT_END_ELLIPSIS | DT_PATH_ELLIPSIS)))
    {
        if(IsBadWritePtr(lpchText, cchText))
        {
            ASSERT(0 && "DrawTextExWorker: For DT_MODIFYSTRING, lpchText must be read-write");
            return 0;
        }
    }

    // Initialize the DrawInfo structure.
    if (!DT_InitDrawTextInfo(hdc, lprc, dwDTformat, (LPDRAWTEXTDATA)&DrawInfo, lpDTparams))
        return 0;

    // If the rect is too narrow or the margins are too wide.....Just forget it!
    //
    // If wordbreak is specified, the MaxWidth must be a reasonable value.
    // This check is sufficient because this will allow CALCRECT and NOCLIP
    // cases.  --SANKAR.
    //
    // This also fixed all of our known problems with AppStudio.
    if (DrawInfo.cxMaxWidth <= 0)
    {
        if (wFormat & DT_WORDBREAK)
        {
            ASSERT(0 && "DrawTextExW: FAILURE DrawInfo.cxMaxWidth <= 0");
            return 1;
        }
    }

    // if we're not doing the drawing, initialise the lpk-dll
    if (dwDTformat & DT_RTLREADING)
        oldAlign = SetTextAlign(hdc, TA_RTLREADING | GetTextAlign(hdc));

    // If we need to clip, let us do that.
    if (!(wFormat & DT_NOCLIP))
    {
        // Save clipping region so we can restore it later.
        hrgnClip = CreateRectRgn(0,0,0,0);
        if (hrgnClip != NULL)
        {
            if (GetClipRgn(hdc, hrgnClip) != 1)
            {
                DeleteObject(hrgnClip);
                hrgnClip = (HRGN)-1;
            }
            rc = *lprc;
            IntersectClipRect(hdc, rc.left, rc.top, rc.right, rc.bottom);
        }
    }
    else
        hrgnClip = NULL;

    lpchTextBegin = lpchText;
    lpchEnd = lpchText + cchText;

ProcessDrawText:

    iLineCount = 0;  // Reset number of lines to 1.
    yLine = lprc->top;

    if (wFormat & DT_SINGLELINE)
    {
        iLineCount = 1;  // It is a single line.

        // Process single line DrawText.
        switch (wFormat & DT_VFMTMASK)
        {
            case DT_BOTTOM:
                yLine = lprc->bottom - DrawInfo.cyLineHeight;
                break;

            case DT_VCENTER:
                yLine = lprc->top + ((lprc->bottom - lprc->top - DrawInfo.cyLineHeight) / 2);
                break;
        }

        cchText = AddEllipsisAndDrawLine(hdc, yLine, lpchText, cchText, dwDTformat, &DrawInfo);
        yLine += DrawInfo.cyLineHeight;
        lpchText += cchText;
    }
    else
    {
        // Multiline
        // If the height of the rectangle is not an integral multiple of the
        // average char height, then it is possible that the last line drawn
        // is only partially visible. However, if DT_EDITCONTROL style is
        // specified, then we must make sure that the last line is not drawn if
        // it is going to be partially visible. This will help imitate the
        // appearance of an edit control.
        if (wFormat & DT_EDITCONTROL)
            yLastLineHeight = DrawInfo.cyLineHeight;
        else
            yLastLineHeight = 0;

        iySign = DrawInfo.iYSign;
        fLastLine = FALSE;
        // Process multiline DrawText.
        while ((lpchText < lpchEnd) && (!fLastLine))
        {
            // Check if the line we are about to draw is the last line that needs
            // to be drawn.
            // Let us check if the display goes out of the clip rect and if so
            // let us stop here, as an optimisation;
            if (!(wFormat & DT_CALCRECT) && // We don't need to calc rect?
                !(wFormat & DT_NOCLIP) &&   // Must we clip the display ?
                                            // Are we outside the rect?
                ((yLine + DrawInfo.cyLineHeight + yLastLineHeight)*iySign > (lprc->bottom*iySign)))
            {
                fLastLine = TRUE;    // Let us quit this loop
            }

            // We do the Ellipsis processing only for the last line.
            if (fLastLine && (dwDTformat & (DT_END_ELLIPSIS | DT_PATH_ELLIPSIS)))
                lpchText += AddEllipsisAndDrawLine(hdc, yLine, lpchText, cchText, dwDTformat, &DrawInfo);
            else
            {
                lpchNextLineSt = (LPWSTR)DT_GetLineBreak(hdc, lpchText, cchText, dwDTformat, &iLineLength, &DrawInfo);

                // Check if we need to put ellipsis at the end of this line.
                // Also check if this is the last line.
                if ((dwDTformat & DT_WORD_ELLIPSIS) ||
                    ((lpchNextLineSt >= lpchEnd) && (dwDTformat & (DT_END_ELLIPSIS | DT_PATH_ELLIPSIS))))
                    AddEllipsisAndDrawLine(hdc, yLine, lpchText, iLineLength, dwDTformat, &DrawInfo);
                else
                    DT_DrawJustifiedLine(hdc, yLine, lpchText, iLineLength, dwDTformat, &DrawInfo);
                cchText -= (int)((PBYTE)lpchNextLineSt - (PBYTE)lpchText) / sizeof(WCHAR);
                lpchText = lpchNextLineSt;
            }
            iLineCount++; // We draw one more line.
            yLine += DrawInfo.cyLineHeight;
        }

        // For Win3.1 and NT compatibility, if the last char is a CR or a LF
        // then the height returned includes one more line.
        if (!(dwDTformat & DT_EDITCONTROL) &&
            (lpchEnd > lpchTextBegin) &&   // If zero length it will fault.
            (((ch = (*(lpchEnd-1))) == CR) || (ch == LF)))
            yLine += DrawInfo.cyLineHeight;
    }

    // If DT_CALCRECT, modify width and height of rectangle to include
    // all of the text drawn.
    if (wFormat & DT_CALCRECT)
    {
        DrawInfo.rcFormat.right = DrawInfo.rcFormat.left + DrawInfo.cxMaxExtent * DrawInfo.iXSign;
        lprc->right = DrawInfo.rcFormat.right + DrawInfo.cxRightMargin;

        // If the Width is more than what was provided, we have to redo all
        // the calculations, because, the number of lines can be less now.
        // (We need to do this only if we have more than one line).
        if((iLineCount > 1) && (DrawInfo.cxMaxExtent > DrawInfo.cxMaxWidth))
        {
            DrawInfo.cxMaxWidth = DrawInfo.cxMaxExtent;
            lpchText = lpchTextBegin;
            cchText = (int)((PBYTE)lpchEnd - (PBYTE)lpchTextBegin) / sizeof(WCHAR);
            goto  ProcessDrawText;  // Start all over again!
        }
        lprc->bottom = yLine;
    }

    if (hrgnClip != NULL)
    {
        if (hrgnClip == (HRGN)-1)
            ExtSelectClipRgn(hdc, NULL, RGN_COPY);
        else
        {
            ExtSelectClipRgn(hdc, hrgnClip, RGN_COPY);
            DeleteObject(hrgnClip);
        }
    }

    if (dwDTformat & DT_RTLREADING)
        SetTextAlign(hdc, oldAlign);

    // Copy the number of characters actually drawn
    if(lpDTparams != NULL)
        lpDTparams->uiLengthDrawn = (UINT)((PBYTE)lpchText - (PBYTE)lpchTextBegin) / sizeof(WCHAR);

    if (yLine == lprc->top)
        return 1;

    return (yLine - lprc->top);
}

int DrawTextWrap(HDC hdc, LPCWSTR lpchText, int cchText, LPRECT lprc, UINT format)
{
    DRAWTEXTPARAMS DTparams;
    LPDRAWTEXTPARAMS lpDTparams = NULL;

    if (cchText < -1)
        return(0);

    if (format & DT_TABSTOP)
    {
        DTparams.cbSize      = sizeof(DRAWTEXTPARAMS);
        DTparams.iLeftMargin = DTparams.iRightMargin = 0;
        DTparams.iTabLength  = (format & 0xff00) >> 8;
        lpDTparams           = &DTparams;
        format              &= 0xffff00ff;
    }
    return DrawTextExPrivWrap(hdc, (LPWSTR)lpchText, cchText, lprc, format, lpDTparams);
}

#endif  // FONT_LINK
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\fwd.c ===
//============================================================================
//
// 
//
//
//============================================================================

#include "ctlspriv.h"


LPSTR 
FwdStrChrA(
    LPCSTR lpStart, 
    WORD wMatch)
    {
    return StrChrA(lpStart, wMatch);
    }


LPWSTR 
FwdStrChrW(
    LPCWSTR lpStart, 
    WORD wMatch)
    {
    return StrChrW(lpStart, wMatch);
    }


LPSTR 
FwdStrRChrA(
    LPCSTR lpStart, 
    LPCSTR lpEnd, 
    WORD wMatch)
    {
    return StrRChrA(lpStart, lpEnd, wMatch);
    }

LPWSTR 
FwdStrRChrW(
    LPCWSTR lpStart, 
    LPCWSTR lpEnd, 
    WORD wMatch)
    {
    return StrRChrW(lpStart, lpEnd, wMatch);
    }


int 
FwdStrCmpNA(
    LPCSTR lpStr1, 
    LPCSTR lpStr2, 
    int nChar)
    {
    return StrCmpNA(lpStr1, lpStr2, nChar);
    }


int 
FwdStrCmpNW(
    LPCWSTR lpStr1, 
    LPCWSTR lpStr2, 
    int nChar)
    {
    return StrCmpNW(lpStr1, lpStr2, nChar);
    }


LPSTR 
FwdStrStrA(
    LPCSTR lpFirst, 
    LPCSTR lpSrch)
    {
    return StrStrA(lpFirst, lpSrch);
    }


LPWSTR 
FwdStrStrW(
    LPCWSTR lpFirst, 
    LPCWSTR lpSrch)
    {
    return StrStrW(lpFirst, lpSrch);
    }


int 
FwdStrCmpNIA(
    LPCSTR lpStr1, 
    LPCSTR lpStr2, 
    int nChar)
    {
    return StrCmpNIA(lpStr1, lpStr2, nChar);
    }


int 
FwdStrCmpNIW(
    LPCWSTR lpStr1, 
    LPCWSTR lpStr2, 
    int nChar)
    {
    return StrCmpNIW(lpStr1, lpStr2, nChar);
    }


LPSTR 
FwdStrStrIA(
    LPCSTR lpFirst, 
    LPCSTR lpSrch)
    {
    return StrStrIA(lpFirst, lpSrch);
    }


LPWSTR 
FwdStrStrIW(
    LPCWSTR lpFirst, 
    LPCWSTR lpSrch)
    {
    return StrStrIW(lpFirst, lpSrch);
    }


int 
FwdStrCSpnA(
    LPCSTR lpStr, 
    LPCSTR lpSet)
    {
    return StrCSpnA(lpStr, lpSet);
    }


int 
FwdStrCSpnW(
    LPCWSTR lpStr, 
    LPCWSTR lpSet)
    {
    return StrCSpnW(lpStr, lpSet);
    }


int 
FwdStrToIntA(
    LPCSTR lpSrc)
    {
    return StrToIntA(lpSrc);
    }


int 
FwdStrToIntW(
    LPCWSTR lpSrc)
    {
    return StrToIntW(lpSrc);
    }


LPSTR 
FwdStrChrIA(
    LPCSTR lpStart, 
    WORD wMatch)
    {
    return StrChrIA(lpStart, wMatch);
    }


LPWSTR 
FwdStrChrIW(
    LPCWSTR lpStart, 
    WORD wMatch)
    {
    return StrChrIW(lpStart, wMatch);
    }


LPSTR 
FwdStrRChrIA(
    LPCSTR lpStart, 
    LPCSTR lpEnd, 
    WORD wMatch)
    {
    return StrRChrIA(lpStart, lpEnd, wMatch);
    }


LPWSTR 
FwdStrRChrIW(
    LPCWSTR lpStart, 
    LPCWSTR lpEnd, 
    WORD wMatch)
    {
    return StrRChrIW(lpStart, lpEnd, wMatch);
    }


LPSTR 
FwdStrRStrIA(
    LPCSTR lpSource, 
    LPCSTR lpLast, 
    LPCSTR lpSrch)
    {
    return StrRStrIA(lpSource, lpLast, lpSrch);
    }


LPWSTR 
FwdStrRStrIW(
    LPCWSTR lpSource, 
    LPCWSTR lpLast, 
    LPCWSTR lpSrch)
    {
    return StrRStrIW(lpSource, lpLast, lpSrch);
    }


int 
FwdStrCSpnIA(
    LPCSTR lpStr, 
    LPCSTR lpSet)
    {
    return StrCSpnIA(lpStr, lpSet);
    }


int 
FwdStrCSpnIW(
    LPCWSTR lpStr, 
    LPCWSTR lpSet)
    {
    return StrCSpnIW(lpStr, lpSet);
    }


LPSTR
FwdStrPBrkA(
    LPCSTR psz, 
    LPCSTR pszSet)
    {
    return StrPBrkA(psz, pszSet);
    }


LPWSTR
FwdStrPBrkW(
    LPCWSTR psz, 
    LPCWSTR pszSet)
    {
    return StrPBrkW(psz, pszSet);
    }


int
FwdStrSpnA(
    LPCSTR psz,
    LPCSTR pszSet)
    {
    return StrSpnA(psz, pszSet);
    }


int
FwdStrSpnW(
    LPCWSTR psz,
    LPCWSTR pszSet)
    {
    return StrSpnW(psz, pszSet);
    }


BOOL 
FwdStrToIntExA(
    LPCSTR    pszString,
    DWORD     dwFlags,          // STIF_ bitfield 
    int FAR * piRet)
    {
    return StrToIntExA(pszString, dwFlags, piRet);
    }


BOOL 
FwdStrToIntExW(
    LPCWSTR   pszString,
    DWORD     dwFlags,          // STIF_ bitfield 
    int FAR * piRet)
    {
    return StrToIntExW(pszString, dwFlags, piRet);
    }


LPWSTR 
FwdStrCpyW(
    LPWSTR psz1, 
    LPCWSTR psz2)
    {
    return StrCpyW(psz1, psz2);
    }


LPSTR 
FwdStrDupA(
    LPCSTR lpsz)
    {
    return StrDupA(lpsz);
    }


LPWSTR 
FwdStrDupW(
    LPCWSTR lpsz)
    {
    return StrDupW(lpsz);
    }


int 
FwdStrCmpW(
    LPCWSTR lpsz1, 
    LPCWSTR lpsz2)
    {
    return StrCmpW(lpsz1, lpsz2);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\header.c ===
#include "ctlspriv.h"
#include "image.h"

#define CCHLABELMAX MAX_PATH            // borrowed from listview.h
#define HDDF_NOIMAGE  0x0001
#define HDDF_NOEDGE  0x0002

#define HDI_ALL95 0x001f

#define TF_HEADER TF_LISTVIEW

#define HD_EDITCHANGETIMER 0x100

#define c_cxFilterBarEdge (1)
#define c_cyFilterBarEdge (1)

#define c_cxFilterImage   (13)
#define c_cyFilterImage   (12)

typedef struct {
    int     x;              // this is the x position of the RIGHT side (divider) of this item
    int     cxy;
    int     fmt;
    LPTSTR  pszText;
    HBITMAP hbm;
    int     iImage;         // index of bitmap in imagelist
    LPARAM  lParam;
    int     xBm;            // cached values 
    int     xText;          // for implementing text and bitmap in header
    int     cxTextAndBm;    
    
    // information used for the filter contol
    UINT    idOperator;
    UINT    type;
    HD_TEXTFILTER textFilter;
    int     intFilter;

} HDI;

// BUGBUG: store the style here too, set at create time
typedef struct {
    
    CONTROLINFO ci;
    
    UINT flags;
    int cxEllipses;
    int cxDividerSlop;
    int cyChar;
    HFONT hfont;
    HIMAGELIST hFilterImage;
    HDSA hdsaHDI;       // list of HDI's
    
    // tracking state info
    int iTrack;
    BITBOOL bTrackPress :1;		// is the button pressed?
    BITBOOL fTrackSet:1;
    BITBOOL fOwnerDraw:1;
    BITBOOL fFocus:1;
    BITBOOL fFilterChangePending:1;
    UINT flagsTrack;
    int dxTrack;                    // the distance from the divider that the user started tracking
    int xTrack;                     // the current track position (or starting track position on a button drag)
    int xMinTrack;                  // the x of the end of the previous item (left limit)
    int xTrackOldWidth;
    HIMAGELIST himl;            // handle to our image list

    HDSA hdsaOrder;     // this is an index array of the hdsaHDI items.
                        // this is the physical order of items
                        
    int iHot ;
    HIMAGELIST himlDrag;
    int iNewOrder;      // what's the new insertion point for a d/d?

    int iTextMargin; // The margin to place on either side of text or bitmaps
    int iBmMargin;   // Normally, 3 * g_cxLabelMargin

    int iFocus;         // focus object
    int iEdit;          // editing object
    int iButtonDown;
    int iFilterChangeTimeout;
    HWND hwndEdit;
    WNDPROC pfnEditWndProc;
    int typeOld;
    LPTSTR pszFilterOld;
    int intFilterOld;
} HD;


LRESULT CALLBACK Header_WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

// Message handler functions

BOOL NEAR Header_OnCreate(HD* phd, CREATESTRUCT FAR* lpCreateStruct);
void NEAR Header_OnNCDestroy(HD* phd);

HIMAGELIST NEAR Header_OnSetImageList(HD* phd, HIMAGELIST himl);
HIMAGELIST NEAR Header_OnGetImageList(HD* phd);

void NEAR Header_OnPaint(HD* phd, HDC hdcIn);
#if 0
BOOL NEAR Header_OnEraseBkgnd(HD* phd, HDC hdc);
#endif
void NEAR Header_OnCommand(HD* phd, int id, HWND hwndCtl, UINT codeNotify);
void NEAR Header_OnEnable(HD* phd, BOOL fEnable);
UINT NEAR Header_OnGetDlgCode(HD* phd, MSG FAR* lpmsg);
void NEAR Header_OnLButtonDown(HD* phd, BOOL fDoubleClick, int x, int y, UINT keyFlags);
BOOL NEAR Header_IsTracking(HD* phd);
void NEAR Header_OnMouseMove(HD* phd, int x, int y, UINT keyFlags);
void NEAR Header_OnLButtonUp(HD* phd, int x, int y, UINT keyFlags);
void NEAR Header_OnSetFont(HD* plv, HFONT hfont, BOOL fRedraw);
int NEAR PASCAL Header_OnHitTest(HD* phd, HD_HITTESTINFO FAR *phdht);
HFONT NEAR Header_OnGetFont(HD* plv);
HIMAGELIST Header_OnCreateDragImage(HD* phd, int i);
BOOL NEAR Header_OnGetItemRect(HD* phd, int i, RECT FAR* prc);
void NEAR Header_Draw(HD* phd, HDC hdc, RECT FAR* prcClip);
void NEAR Header_InvalidateItem(HD* phd, int i, UINT uFlags );
void Header_GetDividerRect(HD* phd, int i, LPRECT prc);
LPARAM Header_OnSetHotDivider(HD* phd, BOOL fPos, LPARAM lParam);
void Header_GetFilterRects(LPRECT prcItem, LPRECT prcHeader, LPRECT prcEdit, LPRECT prcButton);
BOOL Header_BeginFilterEdit(HD* phd, int i);
VOID Header_StopFilterEdit(HD* phd, BOOL fDiscardChanges);
VOID Header_FilterChanged(HD* phd, BOOL fWait);
VOID Header_OnFilterButton(HD* phd, INT i);
LRESULT Header_OnClearFilter(HD* phd, INT i);

// HDM_* Message handler functions

int NEAR Header_OnInsertItem(HD* phd, int i, const HD_ITEM FAR* pitem);
BOOL NEAR Header_OnDeleteItem(HD* phd, int i);
BOOL NEAR Header_OnGetItem(HD* phd, int i, HD_ITEM FAR* pitem);
BOOL NEAR Header_OnSetItem(HD* phd, int i, const HD_ITEM FAR* pitem);
BOOL NEAR Header_OnLayout(HD* phd, HD_LAYOUT FAR* playout);
BOOL NEAR Header_OnSetCursor(HD* phd, HWND hwndCursor, UINT codeHitTest, UINT msg);
void NEAR Header_DrawDivider(HD* phd, int x);
#ifdef UNICODE
int NEAR Header_OnInsertItemA(HD* phd, int i, HD_ITEMA FAR* pitem);
BOOL NEAR Header_OnGetItemA(HD* phd, int i, HD_ITEMA FAR* pitem);
BOOL NEAR Header_OnSetItemA(HD* phd, int i, HD_ITEMA FAR* pitem);
#endif

void Header_EndDrag(HD* phd);
BOOL NEAR Header_SendChange(HD* phd, int i, int code, const HD_ITEM FAR* pitem);
BOOL NEAR Header_Notify(HD* phd, int i, int iButton, int code);

#define Header_GetItemPtr(phd, i)   (HDI FAR*)DSA_GetItemPtr((phd)->hdsaHDI, (i))
#define Header_GetCount(phd) (DSA_GetItemCount((phd)->hdsaHDI))

#pragma code_seg(CODESEG_INIT)

BOOL FAR PASCAL Header_Init(HINSTANCE hinst)
{
    WNDCLASS wc;

    if (!GetClassInfo(hinst, c_szHeaderClass, &wc)) {
    	wc.lpfnWndProc     = Header_WndProc;
    	wc.hCursor         = NULL;	// we do WM_SETCURSOR handling
    	wc.hIcon           = NULL;
    	wc.lpszMenuName    = NULL;
    	wc.hInstance       = hinst;
        wc.lpszClassName   = c_szHeaderClass;
        wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE+1);
    	wc.style           = CS_DBLCLKS | CS_GLOBALCLASS;
    	wc.cbWndExtra      = sizeof(HD*);
    	wc.cbClsExtra      = 0;

    	return RegisterClass(&wc);
    }

    return TRUE;
}
#pragma code_seg()

// returns -1 if failed to find the item
int Header_OnGetItemOrder(HD* phd, int i)
{
    int iIndex;

    // if there's no hdsaOrder, then it's in index order
    if (phd->hdsaOrder) {
        int j;
        int iData;
        
        iIndex = -1;
        
        for (j = 0; j < DSA_GetItemCount(phd->hdsaOrder); j++) {
            DSA_GetItem(phd->hdsaOrder, j, &iData);
            if (iData == i) {
                iIndex = j;
                break;
            }
        }
        
    } else {
        iIndex = i;
    }
    
    return iIndex;
}


int Header_ItemOrderToIndex(HD* phd, int iOrder)
{
    RIPMSG(iOrder < DSA_GetItemCount(phd->hdsaHDI), "HDM_ORDERTOINDEX: Invalid order %d", iOrder);
    if (phd->hdsaOrder) {
        ASSERT(DSA_GetItemCount(phd->hdsaHDI) == DSA_GetItemCount(phd->hdsaOrder));
#ifdef DEBUG
        // DSA_GetItem will assert on an invalid index, so filter it out
        // so all we get is the RIP above.
        if (iOrder < DSA_GetItemCount(phd->hdsaOrder))
#endif
        DSA_GetItem(phd->hdsaOrder, iOrder, &iOrder);
    }
    
    return iOrder;
}

HDI* Header_GetItemPtrByOrder(HD* phd, int iOrder)
{
    int iIndex = Header_ItemOrderToIndex(phd, iOrder);
    return Header_GetItemPtr(phd, iIndex);
}

HDSA Header_InitOrderArray(HD* phd) 
{
    int i;
    
    if (!phd->hdsaOrder && !(phd->ci.style & HDS_OWNERDATA)) {

        // not initialized yet..
        // create an array with i to i mapping
        phd->hdsaOrder = DSA_Create(sizeof(int), 4);

        if (phd->hdsaOrder) {
            for (i = 0; i < Header_GetCount(phd); i++) {
                if (DSA_InsertItem(phd->hdsaOrder, i, &i) == -1) {
                    // faild to add... bail
                    DSA_Destroy(phd->hdsaOrder);
                    phd->hdsaOrder = NULL;
                }
            }
        }
    }
    return phd->hdsaOrder;
}

// this moves all items starting from iIndex over by dx
void Header_ShiftItems(HD* phd, int iOrder, int dx)
{
    for(; iOrder < Header_GetCount(phd); iOrder++) {
        HDI* phdi = Header_GetItemPtrByOrder(phd, iOrder);
        phdi->x += dx;
    }
}

void Header_OnSetItemOrder(HD* phd, int iIndex, int iOrder)
{
    if (iIndex < Header_GetCount(phd) &&
        iOrder < Header_GetCount(phd) &&
        Header_InitOrderArray(phd)) {
        int iCurOrder = Header_OnGetItemOrder(phd, iIndex);
        
        // only do work if the order is changing
        if (iOrder != iCurOrder) {
        
            // delete the current order location
            HDI* phdi = Header_GetItemPtr(phd, iIndex);
            HDI* phdiOld = Header_GetItemPtrByOrder(phd, iOrder);

            // stop editing the filter    
            Header_StopFilterEdit(phd, FALSE);

            // remove iIndex from the current order
            // (slide stuff to the right down by our width)
            Header_ShiftItems(phd, iCurOrder + 1, -phdi->cxy);
            DSA_DeleteItem(phd->hdsaOrder, iCurOrder);
            
            // insert it into the order and slide everything else over
            // (slide stuff to the right of the new position up by our width)
            DSA_InsertItem(phd->hdsaOrder, iOrder, &iIndex);
            // set our right edge to where their left edge was
            Header_ShiftItems(phd, iOrder + 1, phdi->cxy);

            if (iOrder == 0) {
                phdi->x = phdi->cxy;
            } else {
                phdiOld = Header_GetItemPtrByOrder(phd, iOrder - 1);
                phdi->x = phdiOld->x + phdi->cxy;
            }
            
            // BUGBUG: do something better...
            RedrawWindow(phd->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
        }
    }
}

void NEAR Header_SetHotItem(HD* phd, int i)
{
    if (i != phd->iHot) {
        Header_InvalidateItem(phd, i, RDW_INVALIDATE);
        Header_InvalidateItem(phd, phd->iHot, RDW_INVALIDATE);
        phd->iHot = i;
    }
}

LRESULT Header_OnGetOrderArray(HD* phd, int iCount, LPINT lpi)
{
    int i;
    
    if (Header_GetCount(phd) != iCount)
        return FALSE;
    
    for (i = 0; i < Header_GetCount(phd) ; i++) {
        lpi[i] = Header_ItemOrderToIndex(phd, i);
    }
    return TRUE;
}

LRESULT Header_OnSetOrderArray(HD* phd, int iCount, LPINT lpi)
{
    int i;
    
    if (Header_GetCount(phd) != iCount)
        return FALSE;
    
    for (i = 0; i < Header_GetCount(phd); i++) {
        Header_OnSetItemOrder(phd, lpi[i], i);
    }

    MyNotifyWinEvent(EVENT_OBJECT_REORDER, phd->ci.hwnd, OBJID_CLIENT, 0);

    return TRUE;
}

BOOL HDDragFullWindows(HD* phd)
{
    return (g_fDragFullWindows && (phd->ci.style & HDS_FULLDRAG));
}

LRESULT CALLBACK Header_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HD* phd = (HD*)GetWindowPtr(hwnd, 0);
    
#if 0
    if (uMsg >= WM_USER) { 
        DebugMsg(DM_TRACE, TEXT("Header_WndProc %d %d %d"), uMsg, wParam, lParam);
    }
#endif
    
    if (phd == NULL)
    {
        if (uMsg == WM_NCCREATE)
        {
            phd = (HD*)NearAlloc(sizeof(HD));

            if (phd == NULL)
                return 0L;

            phd->ci.hwnd = hwnd;
            phd->ci.hwndParent = ((LPCREATESTRUCT)lParam)->hwndParent;
            SetWindowPtr(hwnd, 0, phd);

            // fall through to call DefWindowProc
        }

        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    else
    {
        if (uMsg == WM_NCDESTROY)
        {
            Header_OnNCDestroy(phd);
            NearFree(phd);
            SetWindowInt(hwnd, 0, 0);
    
            return 0;
        }

        // was this key hit since the last time we asked?
        if (uMsg == WM_CAPTURECHANGED ||
            uMsg == WM_RBUTTONDOWN || GetAsyncKeyState(VK_ESCAPE) & 0x01) {

            if (phd->himlDrag) {
                // if this is the end of a drag, 
                // notify the user.
                HDITEM item;
                
                item.mask = HDI_ORDER;
                item.iOrder = -1; // abort order changing
                Header_EndDrag(phd);
                
                Header_SendChange(phd, phd->iTrack, HDN_ENDDRAG, &item);
                
            } else if (phd->flagsTrack & (HHT_ONDIVIDER | HHT_ONDIVOPEN)) {
                HD_ITEM item;
                item.mask = HDI_WIDTH;
                item.cxy = phd->xTrackOldWidth;

                phd->flagsTrack = 0;
                KillTimer(phd->ci.hwnd, 1);
                CCReleaseCapture(&phd->ci);

                Header_SendChange(phd, phd->iTrack, HDN_ENDTRACK, &item);
                if (HDDragFullWindows(phd)) {

                    // incase they changed something
                    item.mask = HDI_WIDTH;
                    item.cxy = phd->xTrackOldWidth;
                    Header_OnSetItem(phd, phd->iTrack, &item);

                    RedrawWindow(phd->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);

                } else {
                    // Undraw the last divider we displayed
                    Header_DrawDivider(phd, phd->xTrack);
                }
            }
        }

        if ((uMsg >= WM_MOUSEFIRST) && (uMsg <= WM_MOUSELAST) &&
            (phd->ci.style & HDS_HOTTRACK) && !phd->fTrackSet) {

            TRACKMOUSEEVENT tme;

            phd->fTrackSet = TRUE;

            tme.cbSize = sizeof(tme);
            tme.hwndTrack = phd->ci.hwnd;
            tme.dwFlags = TME_LEAVE;

            TrackMouseEvent(&tme);
        }

        // ROBUSTNESS: keep this switch within the if (phd) block
        //
        switch (uMsg)
        {
            HANDLE_MSG(phd, WM_CREATE, Header_OnCreate);
#if 0
            HANDLE_MSG(phd, WM_ERASEBKGND, Header_OnEraseBkgnd);
            HANDLE_MSG(phd, WM_ENABLE, Header_OnEnable);
#endif
            HANDLE_MSG(phd, WM_SETCURSOR, Header_OnSetCursor);
            HANDLE_MSG(phd, WM_MOUSEMOVE, Header_OnMouseMove);
            HANDLE_MSG(phd, WM_LBUTTONDOWN, Header_OnLButtonDown);
            HANDLE_MSG(phd, WM_LBUTTONDBLCLK, Header_OnLButtonDown);
            HANDLE_MSG(phd, WM_LBUTTONUP, Header_OnLButtonUp);
            HANDLE_MSG(phd, WM_GETDLGCODE, Header_OnGetDlgCode);
            HANDLE_MSG(phd, WM_SETFONT, Header_OnSetFont);
            HANDLE_MSG(phd, WM_GETFONT, Header_OnGetFont);
        
        case WM_COMMAND:
            if ( (phd->iEdit>=0) && ((HWND)lParam == phd->hwndEdit) )
            {
                // when filtering we will receive notifications that the filter
                // has been edited, therefore lets send those down to the
                // parent.

                if ( HIWORD(wParam)==EN_CHANGE )
                {
                    Header_FilterChanged(phd, TRUE);
                    return(0);
                }
            }
            break;

        case WM_TIMER:
            if (wParam == HD_EDITCHANGETIMER)
            {
                Header_FilterChanged(phd, FALSE);
                return(0);
            }
            break;

        case WM_SETFOCUS:
        case WM_KILLFOCUS:
            // filter bar and not editing then take caret into edit first column
            if (phd->ci.style & HDS_FILTERBAR) 
            {
                phd->fFocus = (uMsg==WM_SETFOCUS);
                Header_InvalidateItem(phd, Header_ItemOrderToIndex(phd, phd->iFocus), RDW_INVALIDATE);
                UpdateWindow(phd->ci.hwnd);
                return(0);
            }
            break;

        case WM_KEYDOWN:
            if ( phd->fFocus )
            {
                // handle the key events that the header control receives, when the filter
                // bar is displayed we then allow the user to enter filter mode and drop the
                // filter menu.
                //
                //  F2 = enter filter mode
                //  F4 = drop filter menu
                //  -> = next column
                //  <- = previous column

                if ( wParam == VK_F2 )
                {
                    // start editing the currently focused column
                    Header_BeginFilterEdit(phd, Header_ItemOrderToIndex(phd, phd->iFocus));
#ifdef KEYBOARDCUES
                    //notify of navigation key usage
                    CCNotifyNavigationKeyUsage(&(phd->ci), UISF_HIDEFOCUS);
#endif
                    return 0L;
                }                                                                   
                else if ( wParam == VK_F4 )
                {
                    // drop the filter menu (this exits edit mode)
                    Header_OnFilterButton(phd, Header_ItemOrderToIndex(phd, phd->iFocus));
#ifdef KEYBOARDCUES
                    //notify of navigation key usage
                    CCNotifyNavigationKeyUsage(&(phd->ci), UISF_HIDEFOCUS);
#endif
                    return 0L;
                }
                else if ( (wParam == VK_LEFT)||(wParam == VK_RIGHT) )
                {
                    INT iFocus = phd->iFocus;

                    // move to previous or next column
                    if ( wParam == VK_RIGHT )
                    {
                        phd->iFocus = (iFocus+1) % Header_GetCount(phd);
                    }
                    else
                    {
                        phd->iFocus = iFocus-1;
                        if ( phd->iFocus < 0 )
                            phd->iFocus = max(Header_GetCount(phd)-1, 0);
                    }

                    // did the focused column change? if so then update the control
                    // as required.
                    if ( iFocus != phd->iFocus )
                    {                
                        Header_InvalidateItem(phd, Header_ItemOrderToIndex(phd, iFocus), RDW_INVALIDATE);
                        Header_InvalidateItem(phd, Header_ItemOrderToIndex(phd, phd->iFocus), RDW_INVALIDATE);
                        UpdateWindow(phd->ci.hwnd);
                    }
#ifdef KEYBOARDCUES
                    //notify of navigation key usage
                    CCNotifyNavigationKeyUsage(&(phd->ci), UISF_HIDEFOCUS);
#endif
                    return 0L;
                }
            }
            break;

        case WM_MOUSELEAVE:
            Header_SetHotItem(phd, -1);
            phd->fTrackSet = FALSE;
            break;
        
        case WM_PRINTCLIENT:
        case WM_PAINT:
            Header_OnPaint(phd, (HDC)wParam);
            return(0);
        
        case WM_RBUTTONUP:
            if (CCSendNotify(&phd->ci, NM_RCLICK, NULL))
                return(0);
            break;
        
        case WM_STYLECHANGED:
            if (wParam == GWL_STYLE) {
                LPSTYLESTRUCT pss = (LPSTYLESTRUCT)lParam;
                
                phd->ci.style = pss->styleNew;

                // if the filter is changing then discard it if its active
                if ((pss->styleOld & HDS_FILTERBAR) != (pss->styleNew & HDS_FILTERBAR))
                    Header_StopFilterEdit(phd, TRUE);

                // we don't cache our style so relay out and invaidate
                InvalidateRect(phd->ci.hwnd, NULL, TRUE);
            }
            return(0);
        
        case WM_NOTIFYFORMAT:
            return CIHandleNotifyFormat(&phd->ci, lParam);
        
        case HDM_GETITEMCOUNT:
            return (LPARAM)(UINT)DSA_GetItemCount(phd->hdsaHDI);
        
        case HDM_INSERTITEM:
            return (LPARAM)Header_OnInsertItem(phd, (int)wParam, (const HD_ITEM FAR*)lParam);
        
        case HDM_DELETEITEM:
            return (LPARAM)Header_OnDeleteItem(phd, (int)wParam);
        
        case HDM_GETITEM:
            return (LPARAM)Header_OnGetItem(phd, (int)wParam, (HD_ITEM FAR*)lParam);
        
        case HDM_SETITEM:
            return (LPARAM)Header_OnSetItem(phd, (int)wParam, (const HD_ITEM FAR*)lParam);
        
        case HDM_LAYOUT:
            return (LPARAM)Header_OnLayout(phd, (HD_LAYOUT FAR*)lParam);
            
        case HDM_HITTEST:
            return (LPARAM)Header_OnHitTest(phd, (HD_HITTESTINFO FAR *)lParam);
            
        case HDM_GETITEMRECT:
            return (LPARAM)Header_OnGetItemRect(phd, (int)wParam, (LPRECT)lParam);
            
        case HDM_SETIMAGELIST:
            return (LRESULT)(ULONG_PTR)Header_OnSetImageList(phd, (HIMAGELIST)lParam);
            
        case HDM_GETIMAGELIST:
            return (LRESULT)(ULONG_PTR)phd->himl;
            
#ifdef UNICODE
        case HDM_INSERTITEMA:
            return (LPARAM)Header_OnInsertItemA(phd, (int)wParam, (HD_ITEMA FAR*)lParam);
        
        case HDM_GETITEMA:
            return (LPARAM)Header_OnGetItemA(phd, (int)wParam, (HD_ITEMA FAR*)lParam);
        
        case HDM_SETITEMA:
            return (LPARAM)Header_OnSetItemA(phd, (int)wParam, (HD_ITEMA FAR*)lParam);
#endif
            
        case HDM_ORDERTOINDEX:
            return Header_ItemOrderToIndex(phd, (int)wParam);
            
        case HDM_CREATEDRAGIMAGE:
            return (LRESULT)Header_OnCreateDragImage(phd, Header_OnGetItemOrder(phd, (int)wParam));
            
        case HDM_SETORDERARRAY:
            return Header_OnSetOrderArray(phd, (int)wParam, (LPINT)lParam);
            
        case HDM_GETORDERARRAY:
            return Header_OnGetOrderArray(phd, (int)wParam, (LPINT)lParam);
            
        case HDM_SETHOTDIVIDER:
            return Header_OnSetHotDivider(phd, (int)wParam, lParam);

        case HDM_SETBITMAPMARGIN:
            phd->iBmMargin = (int)wParam;
            TraceMsg(TF_ALWAYS, "Setting bmMargin = %d",wParam);
            return TRUE;

        case HDM_GETBITMAPMARGIN:
            return phd->iBmMargin;

        case HDM_EDITFILTER:
            Header_StopFilterEdit(phd, (BOOL)LOWORD(lParam));
            return Header_BeginFilterEdit(phd, (int)wParam);

        case HDM_SETFILTERCHANGETIMEOUT:
            if ( lParam ) {
                int iOldTimeout = phd->iFilterChangeTimeout;
                phd->iFilterChangeTimeout = (int)lParam;
                return(iOldTimeout);
            }
            return(phd->iFilterChangeTimeout);

        case HDM_CLEARFILTER:
            return Header_OnClearFilter(phd, (int)wParam);

        case WM_GETOBJECT:
            if( lParam == OBJID_QUERYCLASSNAMEIDX )
                return MSAA_CLASSNAMEIDX_HEADER;
            break;
            
        default:
        {
            LRESULT lres;
            if (CCWndProc(&phd->ci, uMsg, wParam, lParam, &lres))
                return lres;
        }
        }
        
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

}


BOOL NEAR Header_SendChange(HD* phd, int i, int code, const HD_ITEM FAR* pitem)
{
    NMHEADER nm;

    nm.iItem = i;
    nm.pitem = (HD_ITEM FAR*)pitem;
    nm.iButton = 0;
    
    return !(BOOL)CCSendNotify(&phd->ci, code, &nm.hdr);
}

BOOL NEAR Header_Notify(HD* phd, int i, int iButton, int code)
{
    NMHEADER nm;
    nm.iItem = i;
    nm.iButton = iButton;
    nm.pitem = NULL;

    return !(BOOL)CCSendNotify(&phd->ci, code, &nm.hdr);
}


void NEAR Header_NewFont(HD* phd, HFONT hfont)
{
    HDC hdc;
    SIZE siz;

    hdc = GetDC(HWND_DESKTOP);

    if (hfont)
        SelectFont(hdc, hfont);

    GetTextExtentPoint(hdc, c_szEllipses, CCHELLIPSES, &siz);

    phd->cxEllipses = siz.cx;
    phd->cyChar = siz.cy;
    phd->hfont = hfont;
    phd->ci.uiCodePage = GetCodePageForFont(hfont);

    ReleaseDC(HWND_DESKTOP, hdc);
}

BOOL NEAR Header_OnCreate(HD* phd, CREATESTRUCT FAR* lpCreateStruct)
{
    ASSERT(phd); // we are only called if phd is valid

    CIInitialize(&phd->ci, phd->ci.hwnd, (LPCREATESTRUCT)lpCreateStruct);
#ifdef DEBUG            
    if (GetAsyncKeyState(VK_SHIFT) < 0) {
        phd->ci.style |= HDS_DRAGDROP;
    }
#endif
    phd->flags = 0;
    phd->hfont = NULL;
    phd->hFilterImage = NULL;

    phd->iNewOrder = -1;
    phd->iHot = -1;
    
    phd->iFocus = 0;
    phd->iEdit = -1;
    phd->iButtonDown = -1;
    phd->iFilterChangeTimeout = GetDoubleClickTime()*2;
    phd->hwndEdit = NULL;

    phd->hdsaHDI = DSA_Create(sizeof(HDI), 4);

    if (!phd->hdsaHDI)
        return (BOOL)-1;

    phd->cxDividerSlop = 8 * g_cxBorder;

    // Warning!  ListView_RSetColumnWidth knows these values.
    phd->iTextMargin = 3 * g_cxLabelMargin;
    phd->iBmMargin = 3 * g_cxLabelMargin;
    
    // phd->himl = NULL;   
    Header_NewFont(phd, NULL);
    return TRUE;
}

int Header_DestroyItemCallback(LPVOID p, LPVOID d)
{
    HDI * phdi = (HDI*)p;
    if (phdi)
    {
        Str_Set(&phdi->pszText, NULL);

        if ( (phdi->type & HDFT_ISMASK)==HDFT_ISSTRING )
            Str_Set(&phdi->textFilter.pszText, NULL);
    }
    return 1;
}

void NEAR Header_OnNCDestroy(HD* phd)
{
    // stop editing the filter    
    if ( phd->hFilterImage )
        ImageList_Destroy(phd->hFilterImage);

    Header_StopFilterEdit(phd, TRUE);

    // We must walk through and destroy all of the string pointers that
    // are contained in the structures before we pass it off to the
    // DSA_Destroy function...

    DSA_DestroyCallback(phd->hdsaHDI, Header_DestroyItemCallback, 0);
    phd->hdsaHDI = NULL;
    if (phd->hdsaOrder)
    {
        DSA_Destroy(phd->hdsaOrder);
        phd->hdsaOrder = NULL;
    }
}

HIMAGELIST NEAR Header_OnSetImageList(HD* phd, HIMAGELIST himl)
{
    HIMAGELIST hImageOld = phd->himl;
    phd->himl = himl;
    return hImageOld;
}
    
void NEAR Header_OnPaint(HD* phd, HDC hdc)
{
    PAINTSTRUCT ps;
    HDC hdcUse;

    if (!phd)
        return;

    if (hdc)
    {
        hdcUse = hdc;
        GetClientRect(phd->ci.hwnd, &ps.rcPaint);
    }
    else
    {
        hdcUse = BeginPaint(phd->ci.hwnd, &ps);
    }

    Header_Draw(phd, hdcUse, &ps.rcPaint);

    if (!hdc) {
        EndPaint(phd->ci.hwnd, &ps);
    }
}

#if 0
BOOL NEAR Header_OnEraseBkgnd(HD* phd, HDC hdc)
{
    RECT rc;

    GetClientRect(phd->ci.hwnd, &rc);
    FillRect(hdc, &rc, g_hbrBtnFace);
    return TRUE;
}

void NEAR Header_OnCommand(HD* phd, int id, HWND hwndCtl, UINT codeNotify)
{
}

void NEAR Header_OnEnable(HD* phd, BOOL fEnable)
{
}
#endif

UINT NEAR Header_OnGetDlgCode(HD* phd, MSG FAR* lpmsg)
{    
    return DLGC_WANTTAB | DLGC_WANTARROWS;
}


int NEAR Header_HitTest(HD* phd, int x, int y, UINT FAR* pflags)
{
    UINT flags = 0;
    POINT pt;
    RECT rc;
    HDI FAR* phdi;
    int i;

    pt.x = x; pt.y = y;

    GetClientRect(phd->ci.hwnd, &rc);

    flags = 0;
    i = -1;
    if (x < rc.left)
        flags |= HHT_TOLEFT;
    else if (x >= rc.right)
        flags |= HHT_TORIGHT;
    if (y < rc.top)
        flags |= HHT_ABOVE;
    else if (y >= rc.bottom)
        flags |= HHT_BELOW;

    if (flags == 0)
    {
        int cItems = DSA_GetItemCount(phd->hdsaHDI);
        int xPrev = 0;
        BOOL fPrevZero = FALSE;
        int xItem;
        int cxSlop;

        //DebugMsg(DM_TRACE, "Hit Test begin");
        for (i = 0; i <= cItems; i++, phdi++, xPrev = xItem)
        {
            if (i == cItems) 
                xItem = rc.right;
            else {
                phdi = Header_GetItemPtrByOrder(phd, i);
                xItem = phdi->x;
            }

            // DebugMsg(DM_TRACE, "x = %d xItem = %d xPrev = %d fPrevZero = %d", x, xItem, xPrev, xPrev == xItem);
            if (xItem == xPrev)
            {
                // Skip zero width items...
                //
                fPrevZero = TRUE;
                continue;
            }

            cxSlop = min((xItem - xPrev) / 4, phd->cxDividerSlop);

            if (x >= xPrev && x < xItem)
            {
                if ( phd->ci.style & HDS_FILTERBAR )
                {
                    RECT rcItem;
                    RECT rcHeader, rcFilter, rcButton;

                    rcItem.left   = xPrev;
                    rcItem.top    = rc.top;
                    rcItem.right  = xItem;
                    rcItem.bottom = rc.bottom ;

                    Header_GetFilterRects(&rcItem, &rcHeader, &rcFilter, &rcButton);

                    if ( y >= rcFilter.top )
                    {
                        if ( x >= rcFilter.right )
                        {
                            // hit check the entire button, forget about the divider
                            // when over the filter glyph
                            flags = HHT_ONFILTERBUTTON;
                            break;
                        }
                        else
                        {
                            flags = HHT_ONFILTER;
                        }
                    }
                    else if ( y < rcHeader.bottom )
                        flags = HHT_ONHEADER;
                }
                else
                {
                    flags = HHT_ONHEADER;
                }

                if (i > 0 && x < xPrev + cxSlop)
                {
                    i--;
                    flags = HHT_ONDIVIDER;

                    if (fPrevZero && x > xPrev)
                    {
                        flags = HHT_ONDIVOPEN;
                    }
                }
                else if (x >= xItem - cxSlop)
                {
                    flags = HHT_ONDIVIDER;
                }

                break;
            }
            fPrevZero = FALSE;
        }
        if (i == cItems)
        {
            i = -1;
            flags = HHT_NOWHERE;
        } else {
            // now convert order index to real index
            i = Header_ItemOrderToIndex(phd, i);
        }
            
    }
    *pflags = flags;
    return i;
}

int NEAR PASCAL Header_OnHitTest(HD* phd, HD_HITTESTINFO FAR *phdht)
{
    if (phdht && phd) {
        phdht->iItem = Header_HitTest(phd, phdht->pt.x, phdht->pt.y, &phdht->flags);
        return phdht->iItem;
    } else
        return -1;
}

BOOL NEAR Header_OnSetCursor(HD* phd, HWND hwndCursor, UINT codeHitTest, UINT msg)
{
    POINT pt;
    UINT flags;
    LPCTSTR lpCur;
    HINSTANCE hinst;
    INT iItem;

    if (!phd)
        return FALSE;

    if (phd->ci.hwnd != hwndCursor || codeHitTest >= 0x8000)
        return FALSE;

    GetMessagePosClient(hwndCursor, &pt);

    iItem = Header_HitTest(phd, pt.x, pt.y, &flags);

    hinst = HINST_THISDLL;
    switch (flags)
    {
    case HHT_ONDIVIDER:
        lpCur = MAKEINTRESOURCE(IDC_DIVIDER);
        break;
    case HHT_ONDIVOPEN:
        lpCur = MAKEINTRESOURCE(IDC_DIVOPEN);
        break;

    case HHT_ONFILTER:
    {
        HDI* phdi = Header_GetItemPtrByOrder(phd, iItem);
        ASSERT(phdi);

        lpCur = IDC_ARROW;              // default to the arrow
	    hinst = NULL;

        switch ( phdi->type & HDFT_ISMASK )
        {
            case HDFT_ISSTRING:
            case HDFT_ISNUMBER:
                lpCur = IDC_IBEAM;
                break;

            default:
// BUGBUG: handle custom filters
                break;
        }
        break;
    }

    default:
        lpCur = IDC_ARROW;
	    hinst = NULL;
        break;
    }
    SetCursor(LoadCursor(hinst, lpCur));
    return TRUE;
}

void NEAR Header_DrawDivider(HD* phd, int x)
{
    RECT rc;
    HDC hdc = GetDC(phd->ci.hwnd);

    GetClientRect(phd->ci.hwnd, &rc);
    rc.left = x;
    rc.right = x + g_cxBorder;

    InvertRect(hdc, &rc);

    ReleaseDC(phd->ci.hwnd, hdc);
}

int NEAR Header_PinDividerPos(HD* phd, int x)
{
    x += phd->dxTrack;
    if (x < phd->xMinTrack)
        x = phd->xMinTrack;
    return x;
}

void NEAR Header_OnLButtonDown(HD* phd, BOOL fDoubleClick, int x, int y, UINT keyFlags)
{
    HD_ITEM hd;
    int i;
    UINT flags;

    if (!phd)
        return;

    Header_StopFilterEdit(phd, FALSE);

    i = Header_HitTest(phd, x, y, &flags);
    if (flags & (HHT_ONDIVIDER))
    {
        if (fDoubleClick) {
            Header_SendChange(phd, i, HDN_DIVIDERDBLCLICK, NULL);
        }  
    }
    
    if ((flags & (HHT_ONDIVIDER | HHT_ONHEADER | HHT_ONDIVOPEN))
        && !fDoubleClick)
    {
        phd->iTrack = i;
        phd->flagsTrack = flags;
        phd->xTrack = x;
        SetCapture(phd->ci.hwnd);

        // this is just to get messages so we can
        // check for the escape key being hit
        SetTimer(phd->ci.hwnd, 1, 100, NULL);
        GetAsyncKeyState(VK_ESCAPE);
    }
    
    if (flags & (HHT_ONDIVIDER | HHT_ONDIVOPEN) &&
        !fDoubleClick)
    {
        //
        // We should first send out the HDN_BEGINTRACK notification
        //
        HDI FAR * phdi;
        
        int iOrder = Header_OnGetItemOrder(phd, i);
        phdi = Header_GetItemPtr(phd, i);
        phd->xMinTrack = phdi->x - phdi->cxy;
        phd->xTrack = phdi->x;
        phd->dxTrack = phd->xTrack - x;
        phd->xTrackOldWidth = phdi->cxy;

        hd.mask = HDI_WIDTH;
        hd.cxy = phd->xTrackOldWidth;
        if (!Header_SendChange(phd, i, HDN_BEGINTRACK, &hd))
        {
            // They said no!
            phd->flagsTrack = 0;
            CCReleaseCapture(&phd->ci);
            KillTimer(phd->ci.hwnd, 1);
            return;
        }

        if (!HDDragFullWindows(phd)) {
            x = Header_PinDividerPos(phd, x);
            Header_DrawDivider(phd, x);
        }
    }
    else if ((flags & HHT_ONHEADER) && (phd->ci.style & HDS_BUTTONS))
    {
        if (fDoubleClick) {
            Header_SendChange(phd, i, HDN_ITEMDBLCLICK, NULL);
        } else {
            phd->bTrackPress = TRUE;
            Header_InvalidateItem(phd, phd->iTrack, RDW_INVALIDATE| RDW_ERASE);
        }
    }

    if ( flags & HHT_ONFILTER )
    {
        Header_BeginFilterEdit(phd, i);
    }

    if ( flags & HHT_ONFILTERBUTTON )
    {
        Header_OnFilterButton(phd, i);
    }
}

void Header_StartDrag(HD* phd, int i, int x, int y)
{
    RECT rc;

    if ((phd->ci.style & HDS_DRAGDROP) &&
        Header_Notify(phd, i, MK_LBUTTON, HDN_BEGINDRAG)) {
        // clear the hot bit and 
        // update before we do the BeginDrag so that the save bitmap won't
        // have the hot drawing on it.
        Header_SetHotItem(phd, -1);
        UpdateWindow(phd->ci.hwnd);


        phd->himlDrag = Header_OnCreateDragImage(phd, Header_OnGetItemOrder(phd,i));
        if (!phd->himlDrag)
            return;

        // find the delta between the start of the item and the cursor
        Header_OnGetItemRect(phd, i, &rc);
        phd->dxTrack = rc.left - x;

        ImageList_BeginDrag(phd->himlDrag, 0, 0, 0);
        ImageList_DragEnter(phd->ci.hwnd, x, 0);
    }
}

void Header_InvalidateDivider(HD* phd, int iItem)
{
    RECT rc;
    Header_GetDividerRect(phd, iItem, &rc);
    InvalidateRect(phd->ci.hwnd, &rc, FALSE);
}

void _Header_SetHotDivider(HD* phd, int iNewOrder)
{
    if (iNewOrder != phd->iNewOrder) {
        if (phd->himlDrag)
            ImageList_DragShowNolock(FALSE);
        Header_InvalidateDivider(phd, phd->iNewOrder);
        Header_InvalidateDivider(phd, iNewOrder);
        phd->iNewOrder = iNewOrder;
        UpdateWindow(phd->ci.hwnd);
        if (phd->himlDrag)
            ImageList_DragShowNolock(TRUE);
    }
}

LPARAM Header_OnSetHotDivider(HD* phd, BOOL fPos, LPARAM lParam)
{
    int iNewOrder = -1;
    if (fPos) {
        RECT rc;
        int y = GET_Y_LPARAM(lParam);
        int x = GET_X_LPARAM(lParam);
        
        // this means that lParam is the cursor position (in client coordinates)
    
        GetClientRect(phd->ci.hwnd, &rc);
        InflateRect(&rc, 0, g_cyHScroll * 2);

        // show only if the y point is reasonably close to the header
        // (a la scrollbar)
        if (y >= rc.top &&
            y <= rc.bottom) {

            //
            // find out the new insertion point
            //
            if (x <= 0) {
                iNewOrder = 0;
            } else {
                UINT flags;
                int iIndex;
                iIndex = Header_HitTest(phd, x, (rc.top + rc.bottom)/2, &flags);

                // if we didn't find an item, see if it's on the far right
                if (iIndex == -1) {

                    int iLast = Header_ItemOrderToIndex(phd, Header_GetCount(phd) -1);
                    if (Header_OnGetItemRect(phd, iLast, &rc)) {
                        if (x >= rc.right) {
                            iNewOrder = Header_GetCount(phd);
                        }
                    }

                } else {
                    Header_OnGetItemRect(phd, iIndex, &rc);
                    iNewOrder= Header_OnGetItemOrder(phd, iIndex);
                    // if it was past the midpoint, the insertion point is the next one
                    if (x > ((rc.left + rc.right)/2)) {
                        // get the next item... translate to item order then back to index.
                        iNewOrder++;
                    }
                }
            }
        }
    } else {
        iNewOrder = (int)lParam;
    }
    _Header_SetHotDivider(phd, iNewOrder);
    return iNewOrder;
}

void Header_MoveDrag(HD* phd, int x, int y)
{
    LPARAM iNewOrder = -1;
        
    iNewOrder = Header_OnSetHotDivider(phd, TRUE, MAKELONG(x, y));

    if (iNewOrder == -1) {
        ImageList_DragShowNolock(FALSE);
    } else {
        ImageList_DragShowNolock(TRUE);
        ImageList_DragMove(x + phd->dxTrack, 0);
    }
}

void Header_EndDrag(HD* phd)
{
    ImageList_EndDrag();
    ImageList_Destroy(phd->himlDrag);
    phd->himlDrag = NULL;
    _Header_SetHotDivider(phd, -1);
}

// iOrder
void Header_GetDividerRect(HD* phd, int iOrder, LPRECT prc)
{
    int iIndex;
    BOOL fLeft;

    if (iOrder == -1)
    {
        SetRectEmpty(prc);
        return;
    }
    
    // if we're getting the divider slot of < N then 
    // it's the left of the rect of item i.
    // otherwise it's the right of the last item.
    if (iOrder < Header_GetCount(phd)) {
        fLeft = TRUE;
    } else { 
        fLeft = FALSE;
        iOrder--;
    }
    
    iIndex = Header_ItemOrderToIndex(phd, iOrder);
    Header_OnGetItemRect(phd, iIndex, prc);
    if (fLeft) {
        prc->right = prc->left;
    } else {
        prc->left = prc->right;
    }
    InflateRect(prc, g_cxBorder, 0);
}

void NEAR Header_OnMouseMove(HD* phd, int x, int y, UINT keyFlags)
{
    UINT flags;
    int i;
    HD_ITEM hd;

    if (!phd)
        return;

    // do the hot tracking
    // but not if anything is ownerdraw or if we're in d/d mode
    if ((phd->ci.style & HDS_HOTTRACK) && !phd->fOwnerDraw && !phd->himlDrag) {
        // only do this if we're in button mode meaning you can actually click
        if (phd->ci.style & HDS_BUTTONS) {
            i = Header_HitTest(phd, x, y, &flags);
            Header_SetHotItem(phd, i);
        }
    }
    
    if (Header_IsTracking(phd))
    {
        if (phd->flagsTrack & (HHT_ONDIVIDER | HHT_ONDIVOPEN))
        {
            x = Header_PinDividerPos(phd, x);

            //
            // Let the Owner have a chance to update this.
            //
            hd.mask = HDI_WIDTH;
            hd.cxy = x - phd->xMinTrack;
            if (!HDDragFullWindows(phd) && !Header_SendChange(phd, phd->iTrack, HDN_TRACK, &hd))
            {
                // We need to cancel tracking
                phd->flagsTrack = 0;
                CCReleaseCapture(&phd->ci);
                KillTimer(phd->ci.hwnd, 1);

                // Undraw the last divider we displayed
                Header_DrawDivider(phd, phd->xTrack);
                return;
            }

            // We should update our x depending on what caller did
            x = hd.cxy + phd->xMinTrack;
            
            // if full window track is turned on, go ahead and set the width
            if (HDDragFullWindows(phd)) {            
                HD_ITEM item;

                item.mask = HDI_WIDTH;
                item.cxy = hd.cxy;

                DebugMsg(DM_TRACE, TEXT("Tracking header.  item %d gets width %d...  %d %d"), phd->iTrack, item.cxy, phd->xMinTrack, x);
                // Let the owner have a chance to say yes.
                Header_OnSetItem(phd, phd->iTrack, &item);

                UpdateWindow(phd->ci.hwnd);
            } else {

                // do the cheezy old stuff
                Header_DrawDivider(phd, phd->xTrack);
                Header_DrawDivider(phd, x);
            }
            
            phd->xTrack = x;
            
        }
        else if (phd->flagsTrack & HHT_ONHEADER)
        {
            i = Header_HitTest(phd, x, y, &flags);
            
            if (ABS(x - phd->xTrack) > 
                GetSystemMetrics(SM_CXDRAG)) {
                if (!phd->himlDrag) {
                    Header_StartDrag(phd, i, phd->xTrack, y);
                } 
            }
            
            if (phd->himlDrag) {
                Header_MoveDrag(phd, x, y);
            } else {
                // if pressing on button and it's not pressed, press it
                if (flags & HHT_ONHEADER && i == phd->iTrack)
                {
                    if ((!phd->bTrackPress) && (phd->ci.style & HDS_BUTTONS))
                    {
                        phd->bTrackPress = TRUE;
                        Header_InvalidateItem(phd, phd->iTrack, RDW_INVALIDATE| RDW_ERASE);
                    }
                }
                // tracked off of button.  if pressed, pop it
                else if ((phd->bTrackPress) && (phd->ci.style & HDS_BUTTONS))
                {
                    phd->bTrackPress = FALSE;
                    Header_InvalidateItem(phd, phd->iTrack, RDW_INVALIDATE| RDW_ERASE);
                }
            }
        }
    }
}

void NEAR Header_OnLButtonUp(HD* phd, int x, int y, UINT keyFlags)
{
    if (!phd)
        return;

    if (Header_IsTracking(phd))
    {
        if (phd->flagsTrack & (HHT_ONDIVIDER | HHT_ONDIVOPEN))
        {
            HD_ITEM item;

            if (!HDDragFullWindows(phd)) {
                Header_DrawDivider(phd, phd->xTrack);
            }

            item.mask = HDI_WIDTH;
            item.cxy = phd->xTrack - phd->xMinTrack;

            // Let the owner have a chance to say yes.


            if (Header_SendChange(phd, phd->iTrack, HDN_ENDTRACK, &item))
                Header_OnSetItem(phd, phd->iTrack, &item);

            RedrawWindow(phd->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
        }
        else if ((phd->flagsTrack & HHT_ONHEADER)
                 && (phd->bTrackPress || phd->himlDrag))
        {
            if (phd->himlDrag) {
                // if this is the end of a drag, 
                // notify the user.
                HDITEM item;
                
                item.mask = HDI_ORDER;
                item.iOrder = phd->iNewOrder; // BUGBUG:  FIXTHIS!
                
                
                if (item.iOrder > Header_OnGetItemOrder(phd, phd->iTrack)) {
                    // if the new order is greater than the old one,
                    // we subtract one because it's leaving the old place
                    // which decs the count by one.
                    item.iOrder--;
                }
                
                Header_EndDrag(phd);
                
                if (Header_SendChange(phd, phd->iTrack, HDN_ENDDRAG, &item)) {
                    if (item.iOrder != -1) {
                        // all's well... change the item order
                        Header_OnSetItemOrder(phd, phd->iTrack, item.iOrder);

                        MyNotifyWinEvent(EVENT_OBJECT_REORDER, phd->ci.hwnd, OBJID_CLIENT, 0);
                    }
                }
                
            } else {
                // Notify the owner that the item has been clicked
                Header_Notify(phd, phd->iTrack, 0, HDN_ITEMCLICK);
            }
            phd->bTrackPress = FALSE;
            Header_InvalidateItem(phd, phd->iTrack, RDW_INVALIDATE| RDW_ERASE);
        }
        
        phd->flagsTrack = 0;
        CCReleaseCapture(&phd->ci);
        KillTimer(phd->ci.hwnd, 1);
    }
}


BOOL NEAR Header_IsTracking(HD* phd)
{
    if (!phd->flagsTrack)
    {
        return FALSE;
    } else if  (GetCapture() != phd->ci.hwnd) {
        phd->flagsTrack = 0;
        return FALSE;
    }

    return TRUE;
}

void NEAR Header_OnSetFont(HD* phd, HFONT hfont, BOOL fRedraw)
{
    if (!phd)
        return;

    if (hfont != phd->hfont)
    {
        Header_NewFont(phd, hfont);
        
        if (fRedraw)
            RedrawWindow(phd->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
    }
}

HFONT NEAR Header_OnGetFont(HD* phd)
{
    if (!phd)
        return NULL;

    return phd->hfont;
}

//**********************************************************************

#ifdef UNICODE
int NEAR Header_OnInsertItemA(HD* phd, int i, HD_ITEMA FAR* pitem) {
    LPWSTR pszW = NULL;
    LPSTR pszC = NULL;
    HD_TEXTFILTERW textFilterW;
    LPHD_TEXTFILTERA ptextFilterA = NULL;
    int iRet;


    //HACK ALERT -- this code assumes that HD_ITEMA is exactly the same
    // as HD_ITEMW except for the pointer to the string.
    ASSERT(sizeof(HD_ITEMA) == sizeof(HD_ITEMW))

    if (!pitem || !phd)
        return -1;

    if ((pitem->mask & HDI_TEXT) && (pitem->pszText != LPSTR_TEXTCALLBACKA) &&
        (pitem->pszText != NULL)) {
        pszC = pitem->pszText;
        if ((pszW = ProduceWFromA(phd->ci.uiCodePage, pszC)) == NULL)
            return -1;
        pitem->pszText = (LPSTR)pszW;
    }

    if ( (pitem->mask & HDI_FILTER) &&
            ((pitem->type & HDFT_ISMASK) == HDFT_ISSTRING) ) {
        // pick up the filter if there is one for us to thunk
        if ( pitem->pvFilter ) {
            ptextFilterA = pitem->pvFilter;
            ASSERT(ptextFilterA);

            textFilterW.pszText = NULL;
            textFilterW.cchTextMax = ptextFilterA->cchTextMax;

            if ( !(pitem->type & HDFT_HASNOVALUE) ) {
                textFilterW.pszText = ProduceWFromA(phd->ci.uiCodePage, ptextFilterA->pszText);
                if ( !textFilterW.pszText ) {
                    if ( pszW )
                        FreeProducedString(pszW)
                    return -1;
                }
            }

            pitem->pvFilter = &textFilterW;
        }
    }

    iRet = Header_OnInsertItem(phd, i, (const HD_ITEM FAR*) pitem);

    if (pszW != NULL) {
        pitem->pszText = pszC;

        FreeProducedString(pszW);
    }

    if (ptextFilterA)
    {
        pitem->pvFilter = ptextFilterA;
        FreeProducedString(textFilterW.pszText);
    }

    return iRet;
}
#endif

int NEAR Header_OnInsertItem(HD* phd, int i, const HD_ITEM FAR* pitem)
{
    HDI hdi = {0};
    int x;
    HDI FAR* phdi;
    int iOrder;
    int cxy;

    if (!pitem || !phd)
    	return -1;
    	
    if (pitem->mask == 0)
        return -1;

    cxy = pitem->cxy;
    if (cxy < 0)
        cxy = 0;

    x = cxy;

    if (i > DSA_GetItemCount(phd->hdsaHDI))
        i = DSA_GetItemCount(phd->hdsaHDI);

    // stop editing the filter    
    Header_StopFilterEdit(phd, FALSE);

    iOrder = i;    
    // can't have order info if it's owner data
    if (!(phd->ci.style & HDS_OWNERDATA)) {

        // the iOrder field wasn't there in win95...
        // so access it only if the bit is there.
        if (pitem->mask & HDI_ORDER) {

            if ((pitem->iOrder != i) && (pitem->iOrder <= Header_GetCount(phd))) {
                if (Header_InitOrderArray(phd))
                    iOrder = pitem->iOrder;
            }
        }
    }

    if (iOrder > 0)
    {

        phdi = Header_GetItemPtrByOrder(phd, iOrder - 1);
        if (phdi)
            x += phdi->x;

    }
    
    // move everything else over
    Header_ShiftItems(phd, iOrder, cxy);

    if (phd->hdsaOrder) {
        int j;
        int iIndex;
        
        // an index is added, all the current indices
        // need to be incr by one
        for (j = 0; j < DSA_GetItemCount(phd->hdsaOrder); j++) {
            DSA_GetItem(phd->hdsaOrder, j, &iIndex);
            if (iIndex >= i) {
                iIndex++;
                DSA_SetItem(phd->hdsaOrder, j, &iIndex);
            }
        }
        DSA_InsertItem(phd->hdsaOrder, iOrder, &i);
    }
    
    hdi.x = x;
    hdi.lParam = pitem->lParam;
    hdi.fmt = pitem->fmt;
    //hdi.pszText = NULL;
    //hdi.iImage = 0;
    hdi.cxy = cxy;
    hdi.xText = hdi.xBm = RECOMPUTE;
    hdi.type = HDFT_ISSTRING|HDFT_HASNOVALUE;
    //hdi.textFilter.pszText = NULL;
    hdi.textFilter.cchTextMax = MAX_PATH;

    if ((pitem->mask & HDI_TEXT) && (pitem->pszText != NULL))
    {
        if (!Str_Set(&hdi.pszText, pitem->pszText))
            return -1;

        // Unless ownerdraw make sure the text bit is on!
        if ((pitem->mask & HDF_OWNERDRAW) == 0)
            hdi.fmt |= HDF_STRING;
    }
    else
    {
        hdi.fmt &= ~(HDF_STRING);
    }

    if ((pitem->mask & HDI_BITMAP) && (pitem->hbm != NULL))
    {
        
        hdi.hbm = pitem->hbm;

        // Unless ownerdraw make sure the text bit is on!
        if ((pitem->mask & HDF_OWNERDRAW) == 0)
            hdi.fmt |= HDF_BITMAP;
    }
    else 
    {
        hdi.hbm = NULL;
        hdi.fmt &= ~(HDF_BITMAP);
    }
        
    if (pitem->mask & HDI_IMAGE) 
    {
        hdi.iImage = pitem->iImage;
        
        // Unless ownerdraw make sure the image bit is on!
        if ((pitem->mask & HDF_OWNERDRAW) == 0)
            hdi.fmt |= HDF_IMAGE;
    }

    if ( pitem->mask & HDI_FILTER ) {
        // pick up the new filter, handling the case where the filter value is
        // being discarded, and/or there is none
        
        hdi.type = pitem->type;

        switch ( hdi.type & HDFT_ISMASK ) {
            case HDFT_ISSTRING:
            {
                if ( pitem->pvFilter ) {
                    LPHDTEXTFILTER ptextFilter = (LPHDTEXTFILTER)pitem->pvFilter;
                    ASSERT(ptextFilter);
    
                    if ( !(pitem->type & HDFT_HASNOVALUE) )
                        Str_Set(&hdi.textFilter.pszText, ptextFilter->pszText);                    
                    hdi.textFilter.cchTextMax = ptextFilter->cchTextMax;
                }
                break;
            }

            case HDFT_ISNUMBER:
            {
                if ( !(pitem->type & HDFT_HASNOVALUE) && pitem->pvFilter )
                    hdi.intFilter = *((int*)pitem->pvFilter);
                break;
            }
        }       
    }


    i = DSA_InsertItem(phd->hdsaHDI, i, &hdi);
    if (i == -1) {
        // failed to add
        Str_Set(&hdi.pszText, NULL);
        if ( (hdi.type & HDFT_ISMASK) == HDFT_ISSTRING )
            Str_Set(&hdi.textFilter.pszText, NULL);
    } else {
        RECT rc;
        
        // succeeded!  redraw
        GetClientRect(phd->ci.hwnd, &rc);
        rc.left = x - cxy;
        RedrawWindow(phd->ci.hwnd, &rc, NULL, RDW_INVALIDATE | RDW_ERASE);

        MyNotifyWinEvent(EVENT_OBJECT_CREATE, phd->ci.hwnd, OBJID_CLIENT, i+1);
    }

    return i;
}

BOOL NEAR Header_OnDeleteItem(HD* phd, int i)
{
    HDI hdi;
    RECT rc;
    int iWidth;
    int iOrder;

    if (!phd)
        return FALSE;

    if (!DSA_GetItem(phd->hdsaHDI, i, &hdi))
        return FALSE;

    MyNotifyWinEvent(EVENT_OBJECT_DESTROY, phd->ci.hwnd, OBJID_CLIENT, i+1);

    Header_StopFilterEdit(phd, FALSE);
    phd->iFocus = 0;

    GetClientRect(phd->ci.hwnd, &rc);
    iWidth = rc.right;
    Header_OnGetItemRect(phd, i, &rc);
    InflateRect(&rc, g_cxBorder, g_cyBorder);

    // move everything else over
    iOrder = Header_OnGetItemOrder(phd, i);
    Header_ShiftItems(phd, iOrder, -hdi.cxy);

    if (!DSA_DeleteItem(phd->hdsaHDI, i))
        return FALSE;
    
    if (phd->hdsaOrder) {
        int j;
        int iIndex;
        DSA_DeleteItem(phd->hdsaOrder, iOrder);
        
        
        // an index is going away, all the current indices
        // need to be decremented by one
        for (j = 0; j < DSA_GetItemCount(phd->hdsaOrder); j++) {
            DSA_GetItem(phd->hdsaOrder, j, &iIndex);
            ASSERT(iIndex != i);
            if (iIndex > i) {
                iIndex--;
                DSA_SetItem(phd->hdsaOrder, j, &iIndex);
            }
        }

    }

    Header_DestroyItemCallback(&hdi, NULL);

    rc.right = iWidth;
    InvalidateRect(phd->ci.hwnd, &rc, TRUE);
    return TRUE;
}

#ifdef UNICODE
BOOL NEAR Header_OnGetItemA(HD* phd, int i, HD_ITEMA FAR* pitem) {
    LPWSTR pszW = NULL;
    LPSTR pszC = NULL;
    HD_TEXTFILTERW textFilterW;
    LPHD_TEXTFILTERA ptextFilterA = NULL;
    BOOL fRet;

    //HACK ALERT -- this code assumes that HD_ITEMA is exactly the same
    // as HD_ITEMW except for the pointer to the string.
    ASSERT(sizeof(HD_ITEMA) == sizeof(HD_ITEMW))

    if (!pitem || !phd)
        return FALSE;

    if ((pitem->mask & HDI_TEXT) && (pitem->pszText != LPSTR_TEXTCALLBACKA) &&
        (pitem->pszText != NULL)) {
        pszC = pitem->pszText;
        pszW = LocalAlloc(LMEM_FIXED, pitem->cchTextMax * sizeof(WCHAR));
        if (pszW == NULL)
            return FALSE;
        pitem->pszText = (LPSTR)pszW;
    }

    if ( (pitem->mask & HDI_FILTER) &&
            ((pitem->type & HDFT_ISMASK)==HDFT_ISSTRING) ) {
        if ( pitem->pvFilter ) {
            ptextFilterA = pitem->pvFilter;
            ASSERT(ptextFilterA);

            textFilterW.pszText = LocalAlloc(LMEM_FIXED, ptextFilterA->cchTextMax * sizeof(WCHAR));
            textFilterW.cchTextMax = ptextFilterA->cchTextMax;

            if ( !textFilterW.pszText ) {                    
                if ( pszW )
                    LocalFree(pszW);
                return FALSE;
            }

            pitem->pvFilter = &textFilterW;        
        }
    }

    fRet = Header_OnGetItem(phd, i, (HD_ITEM *) pitem);

    if (pszW != NULL) {
        ConvertWToAN(phd->ci.uiCodePage, pszC, pitem->cchTextMax, pszW, -1);
        pitem->pszText = pszC;

        LocalFree(pszW);
    }

    if (ptextFilterA)
    {
        ConvertWToAN(phd->ci.uiCodePage, ptextFilterA->pszText, ptextFilterA->cchTextMax, 
                                         textFilterW.pszText, -1);
        pitem->pvFilter = ptextFilterA;
    }

    return fRet;
}
#endif

BOOL NEAR Header_OnGetItem(HD* phd, int i, HD_ITEM FAR* pitem)
{
    HDI FAR* phdi;
    UINT mask;
    NMHDDISPINFO nm;

    ASSERT(pitem);

    if (!pitem || !phd)
    	return FALSE;

    // Crappy hack to fix norton commander.  MFC has a bug where it
    // passes in stack trash (in addition to the desired bits) to HDM_GETITEM.
    // Fix it here by stripping down to Win95 bits if more bits than the
    // current valid bits are defined. 
    if (pitem->mask & ~HDI_ALL)
        pitem->mask &= HDI_ALL95;
    
    nm.mask = 0;
    mask = pitem->mask;

#ifdef DEBUG
    if (i < 0 || i >= Header_GetCount(phd))
    {
        RIPMSG(0, "HDM_GETITEM: Invalid item number %d", i);
        return FALSE; // Return immediately so Header_GetItemPtr doesn't assert
    }
#endif

    phdi = Header_GetItemPtr(phd, i);
    if (!phdi)
        return FALSE;

    if (mask & HDI_WIDTH)
    {
        pitem->cxy = phdi->cxy;
    }

    if (mask & HDI_FORMAT)
    {
        pitem->fmt = phdi->fmt;
    }
    
    if (mask & HDI_ORDER)
    {
        pitem->iOrder = Header_OnGetItemOrder(phd, i);
    }

    if (mask & HDI_LPARAM)
    {
        pitem->lParam = phdi->lParam;
    }

    if (mask & HDI_TEXT)
    {
        if (phdi->pszText != LPSTR_TEXTCALLBACK) {
            
            // BUGBUG: warning... this is different than Chicago behavior.
            // if pszText was NULL and you tried to retrieve it, we would bail
            // and return FALSE, now we may return TRUE.
            Str_GetPtr0(phdi->pszText, pitem->pszText, pitem->cchTextMax);
        }
        else {
            // need to recalc the xText because they could keep changing it on us
            phdi->xText = RECOMPUTE;
            nm.mask |= HDI_TEXT;
        }
    }
      
    if (mask & HDI_BITMAP)
        pitem->hbm = phdi->hbm;
    
    if (mask & HDI_IMAGE)
    {
        if (phdi->iImage == I_IMAGECALLBACK)
            nm.mask |= HDI_IMAGE;
        else
            pitem->iImage = phdi->iImage;
    }
    
    if (mask & HDI_FILTER)
    {
        if (pitem->pvFilter)
        {
            if ((phdi->type & HDFT_ISMASK) != (pitem->type & HDFT_ISMASK))
                return FALSE;

            switch (phdi->type & HDFT_ISMASK) 
            {
                case HDFT_ISSTRING:
                {
                    LPHDTEXTFILTER ptextFilter = (LPHDTEXTFILTER)pitem->pvFilter;
                    ASSERT(ptextFilter);

                    if ( !Str_GetPtr(phdi->textFilter.pszText, ptextFilter->pszText, ptextFilter->cchTextMax) )
                        return FALSE;
    
                    ptextFilter->cchTextMax = phdi->textFilter.cchTextMax;
                    break;
                }

                case HDFT_ISNUMBER:
                {
                    *((int*)pitem->pvFilter) = phdi->intFilter;
                    break;
                }

                default:
                    return FALSE;
            }
        }

        pitem->type = phdi->type;
    }

    if (nm.mask) {
        // just in case HDI_IMAGE is set and callback doesn't fill it in
        // ... we'd rather have a -1 than watever garbage is on the stack
        nm.iImage = -1;
        nm.lParam = phdi->lParam;
        
        if (nm.mask & HDI_TEXT) {
            ASSERT(pitem->pszText);
            nm.pszText = pitem->pszText;
            nm.cchTextMax = pitem->cchTextMax;
            
            // Make sure the buffer is zero terminated...
            if (nm.cchTextMax)
                *nm.pszText = 0;
        }
            
        CCSendNotify(&phd->ci, HDN_GETDISPINFO, &nm.hdr);
    
        if (nm.mask & HDI_IMAGE)
            pitem->iImage = nm.iImage;

        if (nm.mask & HDI_TEXT)
        {
            if (mask & HDI_TEXT)
                pitem->pszText = CCReturnDispInfoText(nm.pszText, pitem->pszText, pitem->cchTextMax);
            else
                pitem->pszText = nm.pszText;
        }
    }
    
    if (phdi && (nm.mask & HDI_DI_SETITEM)) {
        if (nm.mask & HDI_IMAGE)
            phdi->iImage = nm.iImage;
        
        if (nm.mask & HDI_TEXT)
            if (nm.pszText) {
                ASSERT(phdi->pszText == LPSTR_TEXTCALLBACK);
                Str_Set(&phdi->pszText, nm.pszText);
            }
    }
            
    pitem->mask = mask;
    return TRUE;
}

#ifdef UNICODE
BOOL NEAR Header_OnSetItemA(HD* phd, int i, HD_ITEMA FAR* pitem) {
    LPWSTR pszW = NULL;
    LPSTR pszC = NULL;
    HD_TEXTFILTERW textFilterW;
    LPHD_TEXTFILTERA ptextFilterA = NULL;
    BOOL fRet;

    //HACK ALERT -- this code assumes that HD_ITEMA is exactly the same
    // as HD_ITEMW except for the pointer to the string.
    ASSERT(sizeof(HD_ITEMA) == sizeof(HD_ITEMW));

    if (!pitem || !phd)
        return FALSE;


    if ((pitem->mask & HDI_TEXT) && (pitem->pszText != LPSTR_TEXTCALLBACKA) &&
        (pitem->pszText != NULL)) {
        pszC = pitem->pszText;
        if ((pszW = ProduceWFromA(phd->ci.uiCodePage, pszC)) == NULL)
            return FALSE;
        pitem->pszText = (LPSTR)pszW;
    }

    if ( (pitem->mask & HDI_FILTER) &&
            ((pitem->type & HDFT_ISMASK) == HDFT_ISSTRING) )
    {
        if ( pitem->pvFilter )
        {
            ptextFilterA = pitem->pvFilter;
            ASSERT(ptextFilterA);

            textFilterW.pszText = NULL;
            textFilterW.cchTextMax = ptextFilterA->cchTextMax;

            if ( !(pitem->type & HDFT_HASNOVALUE) )
            {
                textFilterW.pszText = ProduceWFromA(phd->ci.uiCodePage, ptextFilterA->pszText);
                if ( !textFilterW.pszText ) {
                    if ( pszW )
                        FreeProducedString(pszW)
                    return FALSE;
                }
            }

            pitem->pvFilter = &textFilterW;
        }
    }
    
    fRet = Header_OnSetItem(phd, i, (const HD_ITEM FAR*) pitem);

    if (pszW != NULL) {
        pitem->pszText = pszC;
        FreeProducedString(pszW);
    }

    if (ptextFilterA)
    {
        pitem->pvFilter = ptextFilterA;
        FreeProducedString(textFilterW.pszText);
    }

    return fRet;

}
#endif

BOOL NEAR Header_OnSetItem(HD* phd, int i, const HD_ITEM FAR* pitem)
{
    HDI FAR* phdi;
    UINT mask;
    int xOld;
    BOOL fInvalidate = FALSE;
    
    ASSERT(pitem);

    if (!pitem || !phd)
    	return FALSE;
    	
#ifdef DEBUG
    if (i < 0 || i >= Header_GetCount(phd))
    {
        RIPMSG(0, "HDM_SETITEM: Invalid item number %d", i);
        return FALSE; // Return immediately so Header_GetItemPtr doesn't assert
    }
#endif

    phdi = Header_GetItemPtr(phd, i);
    if (!phdi)
        return FALSE;

    mask = pitem->mask;

    if (mask == 0)
        return TRUE;

    // stop editing the filter    
    //Header_StopFilterEdit(phd, FALSE);

    if (!Header_SendChange(phd, i, HDN_ITEMCHANGING, pitem))
        return FALSE;

    xOld = phdi->x;
    if (mask & HDI_WIDTH)
    {
        RECT rcClip;
        int iOrder;
        int dx;
        int cxy = pitem->cxy;
        
        if (cxy < 0)
            cxy = 0;

        DebugMsg(DM_TRACE, TEXT("Header--SetWidth x=%d, cxyOld=%d, cxyNew=%d, dx=%d"),
                 phdi->x, phdi->cxy, cxy, (cxy-phdi->cxy));
        dx = cxy - phdi->cxy;
        phdi->cxy = cxy;

        // scroll everything over
        GetClientRect(phd->ci.hwnd, &rcClip);
        rcClip.left = phdi->x; // we want to scroll the divider as well
        
        // the scrolling rect needs to be the largest rect of the before
        // and after.  so if dx is negative, we want to enlarge the rect
        if (dx < 0)
            rcClip.left += dx;
        iOrder = Header_OnGetItemOrder(phd, i);
        Header_ShiftItems(phd, iOrder, dx);
        
        phdi->xText = phdi->xBm = RECOMPUTE;
        
        {
#ifndef UNIX
            SMOOTHSCROLLINFO si = {
                sizeof(si),
                0,
                phd->ci.hwnd,
                dx,
                0,
                NULL,
                &rcClip, 
                NULL,
                NULL,
                SW_ERASE | SW_INVALIDATE,
            };
#else
            SMOOTHSCROLLINFO si;
            si.cbSize = sizeof(si);
            si.fMask = 0;
            si.hwnd = phd->ci.hwnd;
            si.dx = dx;
            si.dy = 0;
            si.lprcSrc = NULL;
            si.lprcClip = &rcClip;
            si.hrgnUpdate = NULL;
            si.lprcUpdate = NULL;
            si.fuScroll = SW_ERASE | SW_INVALIDATE;
            si.uMaxScrollTime = SSI_DEFAULT;
            si.cxMinScroll = SSI_DEFAULT;
            si.cyMinScroll = SSI_DEFAULT;
            si.pfnScrollProc = NULL;
#endif

            SmoothScrollWindow(&si);
        }

        UpdateWindow(phd->ci.hwnd);
        // now invalidate this item itself
        Header_OnGetItemRect(phd, i, &rcClip);
        InvalidateRect(phd->ci.hwnd, &rcClip, FALSE);
        
    }
    if (mask & HDI_FORMAT) {
        phdi->fmt = pitem->fmt;
        phdi->xText = phdi->xBm = RECOMPUTE;
        fInvalidate = TRUE;
    }
    if (mask & HDI_LPARAM)
        phdi->lParam = pitem->lParam;

    if (mask & HDI_TEXT)
    {
        if (!Str_Set(&phdi->pszText, pitem->pszText))
            return FALSE;
        phdi->xText = RECOMPUTE;
        fInvalidate = TRUE;
    }

    if (mask & HDI_BITMAP)
    {
        phdi->hbm = pitem->hbm;
        
        phdi->xBm = RECOMPUTE;
        fInvalidate = TRUE;
    }
    
    if (mask & HDI_IMAGE)
    {
        phdi->iImage = pitem->iImage;
        phdi->xBm = RECOMPUTE;
        fInvalidate = TRUE;
    }
    
    if (mask & HDI_ORDER)
    {
        if (pitem->iOrder >= 0 && pitem->iOrder < Header_GetCount(phd))
        {
            Header_OnSetItemOrder(phd, i, pitem->iOrder);
            MyNotifyWinEvent(EVENT_OBJECT_REORDER, phd->ci.hwnd, OBJID_CLIENT, 0);
        }
    }

    if ( mask & HDI_FILTER )
    {
        if ( (phdi->type & HDFT_ISMASK) == HDFT_ISSTRING )
            Str_Set(&phdi->textFilter.pszText, NULL);

        // pick up the new filter, handling the case where the filter value is
        // being discarded, and/or there is none
        
        phdi->type = pitem->type;

        switch ( phdi->type & HDFT_ISMASK )
        {
            case HDFT_ISSTRING:
            {
                if ( pitem->pvFilter )
                {
                    LPHDTEXTFILTER ptextFilter = (LPHDTEXTFILTER)pitem->pvFilter;
                    ASSERT(ptextFilter);
    
                    if ( !(pitem->type & HDFT_HASNOVALUE) )
                        Str_Set(&phdi->textFilter.pszText, ptextFilter->pszText);                    
                    phdi->textFilter.cchTextMax = ptextFilter->cchTextMax;
                }
                break;
            }

            case HDFT_ISNUMBER:
            {
                if ( !(pitem->type & HDFT_HASNOVALUE) && pitem->pvFilter )
                    phdi->intFilter = *((int*)pitem->pvFilter);
                break;
            }
        }       

        fInvalidate = TRUE;
    }

    Header_SendChange(phd, i, HDN_ITEMCHANGED, pitem);
    
    if ( mask & HDI_FILTER )
    	Header_Notify(phd, i, 0, HDN_FILTERCHANGE);	       // send out a notify of change

    if (fInvalidate) {
        if (xOld == phdi->x) {
            // no change in x
            Header_InvalidateItem(phd, i, RDW_INVALIDATE| RDW_ERASE);
        } else {
            RECT rc;
            GetClientRect(phd->ci.hwnd, &rc);
            
            if (i > 0) {
                HDI FAR * phdiTemp;
                phdiTemp = Header_GetItemPtrByOrder(phd, i - 1);
                if (phdiTemp) {
                    rc.left = phdi->x;
                }
            }
            RedrawWindow(phd->ci.hwnd, &rc, NULL, RDW_INVALIDATE | RDW_ERASE);
        }
    }
 
    return TRUE;
}

// Compute layout for header bar, and leftover rectangle.
//
BOOL NEAR Header_OnLayout(HD* phd, HD_LAYOUT FAR* playout)
{
    int cyHeader;
    WINDOWPOS FAR* pwpos;
    RECT FAR* prc;

    RIPMSG(playout != NULL, "HDM_LAYOUT: Invalid NULL pointer");

    if (!playout || !phd)
    	return FALSE;

    if (!(playout->pwpos && playout->prc))
	return FALSE;

    pwpos = playout->pwpos;
    prc = playout->prc;

    cyHeader = phd->cyChar + 2 * g_cyEdge;

    // when filter bar is enabled then lets show that region
    if ( phd->ci.style & HDS_FILTERBAR )
        cyHeader += phd->cyChar + (2*g_cyEdge) + c_cyFilterBarEdge;

    // BUGBUG: we should store the style at creat  time
    // internal hack style for use with LVS_REPORT|LVS_NOCOLUMNHEADER! edh
    if (phd->ci.style & HDS_HIDDEN)
	    cyHeader = 0;

    pwpos->hwndInsertAfter = NULL;
    pwpos->flags = SWP_NOZORDER | SWP_NOACTIVATE;

    // BUGBUG: ASSERT(phd->style & HDS_HORZ);

    pwpos->x  = prc->left;
    pwpos->cx = prc->right - prc->left;
    pwpos->y  = prc->top;
    pwpos->cy = cyHeader;

    prc->top += cyHeader;
    return TRUE;
}

BOOL NEAR Header_OnGetItemRect(HD* phd, int i, RECT FAR* prc)
{
    HDI FAR* phdi;

    phdi = Header_GetItemPtr(phd, i);
    if (!phdi)
        return FALSE;

    GetClientRect(phd->ci.hwnd, prc);

    prc->right = phdi->x;
    prc->left = prc->right - phdi->cxy;
    return TRUE;
}

void NEAR Header_InvalidateItem(HD* phd, int i, UINT uFlags)
{
    RECT rc;

    if (i != -1) {
        Header_OnGetItemRect(phd, i, &rc);
        InflateRect(&rc, g_cxBorder, g_cyBorder);
        RedrawWindow(phd->ci.hwnd, &rc, NULL, uFlags);
    }
}

int NEAR _Header_DrawBitmap(HDC hdc, HIMAGELIST himl, HD_ITEM* pitem, 
                            RECT FAR *prc, int fmt, UINT flags, LPRECT prcDrawn, int iMargin) 
{
    // This routine returns either the left of the image
    // or the right of the image depending on the justification.
    // This return value is used in order to properly tack on the 
    // bitmap when both the HDF_IMAGE and HDF_BITMAP flags are set.
    
    RECT rc;
    int xBitmap = 0;
    int yBitmap = 0;
    int cxBitmap;
    int cyBitmap;
    IMAGELISTDRAWPARAMS imldp;
    HBITMAP hbmOld;
    BITMAP bm;
    HDC hdcMem;
    int cxRc; 
    
    SetRectEmpty(prcDrawn);
    
    if (IsRectEmpty(prc)) 
        return prc->left;
        
    rc = *prc;
    
    rc.left  += iMargin;
    rc.right -= iMargin;

//  rc.right -= g_cxEdge; // handle edge

    if (rc.left >= rc.right) 
        return rc.left;
    
    if (pitem->fmt & HDF_IMAGE) 
        ImageList_GetIconSize(himl, &cxBitmap, &cyBitmap);

    else { // pitem->fmt & BITMAP
        if (GetObject(pitem->hbm, sizeof(bm), &bm) != sizeof(bm))
            return rc.left;     // could not get the info about bitmap.


        hdcMem = CreateCompatibleDC(hdc);
        
        if (!hdcMem || ((hbmOld = SelectObject(hdcMem, pitem->hbm)) == ERROR))
            return rc.left;     // an error happened.
        
        cxBitmap = bm.bmWidth;
        cyBitmap = bm.bmHeight;
    }

    if (flags & SHDT_DEPRESSED)
        OffsetRect(&rc, g_cxBorder, g_cyBorder);

    // figure out all the formatting...
    
    cxRc = rc.right - rc.left;          // cache this value

    if (fmt == HDF_LEFT)
    {
        if (cxBitmap > cxRc)
            cxBitmap = cxRc;
    }
    else if (fmt == HDF_CENTER)
    {
        if (cxBitmap > cxRc)
        {
            xBitmap =  (cxBitmap - cxRc) / 2;
            cxBitmap = cxRc;
        }
        else
            rc.left = (rc.left + rc.right - cxBitmap) / 2;
    }
    else  // fmt == HDF_RIGHT
    {
        if (cxBitmap > cxRc)
        {
            xBitmap =  cxBitmap - cxRc;
            cxBitmap = cxRc;
        }
        else
            rc.left = rc.right - cxBitmap;
    }

    // Now setup vertically
    if (cyBitmap > (rc.bottom - rc.top))
    {
        yBitmap = (cyBitmap - (rc.bottom - rc.top)) / 2;
        cyBitmap = rc.bottom - rc.top;
    }
    else
        rc.top = (rc.bottom - rc.top - cyBitmap) / 2;

    
    if (pitem->fmt & HDF_IMAGE) {
        imldp.cbSize = sizeof(imldp);
        imldp.himl   = himl;
        imldp.hdcDst = hdc;
        imldp.i      = pitem->iImage;
        imldp.x      = rc.left;
        imldp.y      = rc.top;
        imldp.cx     = cxBitmap;
        imldp.cy     = cyBitmap;
        imldp.xBitmap= xBitmap;
        imldp.yBitmap= yBitmap;
        imldp.rgbBk  = CLR_DEFAULT;
        imldp.rgbFg  = CLR_DEFAULT;
        imldp.fStyle = ILD_NORMAL;
    
        ImageList_DrawIndirect(&imldp);
    }
    
    else { // pitem->fmt & HDF_BITMAP
  
        TraceMsg(TF_HEADER, "h_db: BitBlt to (%d,%d) from (%d, %d)", rc.left, rc.top, xBitmap, yBitmap);
        // Last but not least we will do the bitblt.
        BitBlt(hdc, rc.left, rc.top, cxBitmap, cyBitmap,
                hdcMem, xBitmap, yBitmap, SRCCOPY);

        // Unselect our object from the DC
        SelectObject(hdcMem, hbmOld);
        
        // Also free any memory dcs we may have created
        DeleteDC(hdcMem);
    }
    
    *prcDrawn = rc;
    prcDrawn->bottom = rc.top + cyBitmap;
    prcDrawn->right = rc.left + cxBitmap;
    return ((pitem->fmt & HDF_RIGHT) ? rc.left : rc.left+cxBitmap);
}

void Header_DrawButtonEdges(HD* phd, HDC hdc, LPRECT prc, BOOL fItemSunken)
{
    UINT uEdge;
    UINT uBF;
    if (phd->ci.style & HDS_BUTTONS)
    {
        if (fItemSunken) {
            uEdge = EDGE_SUNKEN;
            uBF = BF_RECT | BF_SOFT | BF_FLAT;
        } else {
            uEdge = EDGE_RAISED;
            uBF = BF_RECT | BF_SOFT;
        }
    }                
    else
    {
        uEdge = EDGE_ETCHED;
        if (phd->ci.style & WS_BORDER)
            uBF = BF_RIGHT;
        else
            uBF = BF_BOTTOMRIGHT;
    }
    
    DrawEdge(hdc, prc, uEdge, uBF);
    
}

void Header_DrawFilterGlyph(HD* phd, HDC hdc, RECT* prc, BOOL fPressed)
{
    UINT uEdge = BDR_RAISEDOUTER|BDR_RAISEDINNER;
    UINT uBF = BF_RECT;
    RECT rc = *prc;

    if ( fPressed )
    {
        uEdge = EDGE_SUNKEN;
        uBF = BF_RECT | BF_SOFT | BF_FLAT;
    }
    
    if ( !phd->hFilterImage )
    {
        phd->hFilterImage = ImageList_LoadBitmap(HINST_THISDLL, MAKEINTRESOURCE(IDB_FILTERIMAGE), c_cxFilterImage, 0, RGB(128, 0, 0));
        ASSERT(phd->hFilterImage);

        if ( !phd->hFilterImage )
            return;
    }
        
    DrawEdge(hdc, &rc, uEdge, uBF|BF_MIDDLE);

    if (fPressed)
        OffsetRect(&rc, g_cxBorder, g_cyBorder);

    ImageList_Draw(phd->hFilterImage, 0, hdc, 
                    rc.left+(((rc.right-rc.left)-c_cxFilterImage)/2),
                    rc.top+(((rc.bottom-rc.top)-c_cyFilterImage)/2),
                    ILD_NORMAL);
}

//
//  Oh boy, here come the pictures.
//
//  For a left-justified header item, the items are arranged like this.
//
//          rcHeader.left                           rcHeader.right
//          |        iTextMargin   iTextMargin       |
//          |        ->| |<-        ->| |<-          |
//          |          | |            | |            |
//          v          |<--textSize-->| |            v
//          +----------------------------------------+
//          | |BMPBMP| | |TEXTTEXTTEXT| |            |
//          +----------------------------------------+
//          |<-bmSize->|              | |
//          | |      | |              | |
//        ->| |<-  ->| |<-            | |
//      iBmMargin iBmMargin           | |
//          |                         | |
//          |<-------cxTextAndBm------->|
//
//
//  For a right-justified header item, the items are arranged like this.
//
//          rcHeader.left                           rcHeader.right
//          |        iBmMargin   iBmMargin           |
//          |          ->| |<-  ->| |<-              |
//          |            | |      | |                |
//          v            |<-bmSize->|                v
//          +----------------------------------------+
//          |            | |BMPBMP| | |TEXTTEXTTEXT| |
//          +----------------------------------------+
//                       |          |<---textSize--->|
//                       |          | |            | |
//                       |        ->| |<-        ->| |<-
//                       |      iTextMargin     iTextMargin
//                       |                           |
//                       |<-------cxTextAndBm------->|
//
//  Obvious variations apply to center-justified, bitmap-on-right, etc.
//  The point is that all the sizes are accounted for in the manner above.
//  There are no gratuitous +1's or g_cxEdge's.
//

void Header_DrawItem(HD* phd, HDC hdc, int i, int iIndex, LPRECT prc, UINT uFlags)
{
    RECT rcHeader;      
    RECT rcFilter, rcButton;
    RECT rcText;                        // item text clipping rect
    RECT rcBm;                          // item bitmap clipping rect
    COLORREF clrText;
    COLORREF clrBk;
    DWORD dwRet = CDRF_DODEFAULT;
    HDI FAR* phdi;                      // pointer to current header item
    BOOL fItemSunken;
    HD_ITEM item;                       // used for text callback
    BOOL fTracking = Header_IsTracking(phd);
    UINT uDrawTextFlags;
    NMCUSTOMDRAW nmcd;
    TCHAR ach[CCHLABELMAX];             // used for text callback
    HRGN hrgnClip = NULL;
    
    rcHeader = rcFilter = *prc;         // private copies for us to dork

    phdi = Header_GetItemPtrByOrder(phd,i);

    fItemSunken = (fTracking && (phd->flagsTrack & HHT_ONHEADER) &&
                   (phd->iTrack == iIndex) && phd->bTrackPress);

    // Note that SHDT_EXTRAMARGIN requires phd->iTextMargin >= 3*g_cxLabelMargin
    uDrawTextFlags = SHDT_ELLIPSES | SHDT_EXTRAMARGIN | SHDT_CLIPPED;

    if(fItemSunken)
        uDrawTextFlags |= SHDT_DEPRESSED;

    if (phdi->fmt & HDF_OWNERDRAW)
    {
        DRAWITEMSTRUCT dis;

        phd->fOwnerDraw = TRUE;

        dis.CtlType = ODT_HEADER;
        dis.CtlID = GetWindowID(phd->ci.hwnd);
        dis.itemID = iIndex;
        dis.itemAction = ODA_DRAWENTIRE;
        dis.itemState = (fItemSunken) ? ODS_SELECTED : 0;
        dis.hwndItem = phd->ci.hwnd;
        dis.hDC = hdc;
        dis.rcItem = *prc;
        dis.itemData = phdi->lParam;

        // Now send it off to my parent...
        if (SendMessage(phd->ci.hwndParent, WM_DRAWITEM, dis.CtlID,
                        (LPARAM)(DRAWITEMSTRUCT FAR *)&dis))
            goto DrawEdges;  //Ick, but it works
    } else {

        nmcd.dwItemSpec = iIndex;
        nmcd.hdc = hdc;
        nmcd.rc = *prc;
        nmcd.uItemState = (fItemSunken) ? CDIS_SELECTED : 0;
        nmcd.lItemlParam = phdi->lParam;
#ifdef KEYBOARDCUES
        if (!(CCGetUIState(&(phd->ci)) & UISF_HIDEFOCUS))
            nmcd.uItemState |= CDIS_SHOWKEYBOARDCUES;
#endif
        dwRet = CICustomDrawNotify(&phd->ci, CDDS_ITEMPREPAINT, &nmcd);

        if (dwRet & CDRF_SKIPDEFAULT) {
            return;
        }
    }

    // this is to fetch out any changes the caller might have changed
    clrText = GetTextColor(hdc);
    clrBk = GetBkColor(hdc);
    
    //
    // Now neet to handle the different combinatations of
    // text, bitmaps, and images...
    //

    if ( phd->ci.style & HDS_FILTERBAR )
        Header_GetFilterRects(prc, &rcHeader, &rcFilter, &rcButton);

    rcText = rcBm = rcHeader;

#ifdef DEBUG            
    if (GetAsyncKeyState(VK_SHIFT) < 0) {
        phdi->fmt ^= HDF_BITMAP_ON_RIGHT;
        phdi->xText = RECOMPUTE;
    }
#endif
    if (phdi->fmt & (HDF_STRING | HDF_IMAGE | HDF_BITMAP)) {
        item.mask = HDI_TEXT | HDI_IMAGE | HDI_FORMAT | HDI_BITMAP;
        item.pszText = ach;
        item.cchTextMax = ARRAYSIZE(ach);
        Header_OnGetItem(phd,iIndex,&item);
    }

    //
    // If we have a string and either an image or a bitmap...
    //

    if ((phdi->fmt & HDF_STRING) && (phdi->fmt & (HDF_BITMAP|HDF_IMAGE)))
    {
        // BEGIN RECOMPUTE ////////////////////////
        //
        if ((phdi->xText == RECOMPUTE) || (phdi->xBm == RECOMPUTE)) 
        {
            BITMAP bm;                          // used to calculate bitmap width
            
            // calculate the placement of bitmap rect and text rect
            SIZE textSize,bmSize;  int dx; 

            // get total textwidth 
            GetTextExtentPoint(hdc,item.pszText,lstrlen(item.pszText),
                               &textSize);
            TraceMsg(TF_HEADER, "h_di: GetTextExtentPoint returns %d", textSize.cx);
            textSize.cx += 2 * phd->iTextMargin;

            // get total bitmap width
            if (phdi->fmt & HDF_IMAGE) {
                ImageList_GetIconSize(phd->himl,(LPINT)&bmSize.cx,(LPINT)&bmSize.cy);
            }
            else {  // phdi->fmt & HDF_BITMAP
                GetObject(phdi->hbm,sizeof(bm), &bm);
                bmSize.cx = bm.bmWidth;
                TraceMsg(TF_HEADER, "h_di: Bitmap size is %d", bmSize.cx);
            }
            bmSize.cx += 2 * phd->iBmMargin; 

            phdi->cxTextAndBm = bmSize.cx + textSize.cx;

            // calculate how much extra space we have, if any.
            dx = rcHeader.right-rcHeader.left - phdi->cxTextAndBm;
            if (dx < 0) {
                dx = 0;
                phdi->cxTextAndBm = rcHeader.right-rcHeader.left;
            }

            if (phdi->fmt & HDF_BITMAP_ON_RIGHT) {
                switch (phdi->fmt & HDF_JUSTIFYMASK) {
                case HDF_LEFT: 
                    phdi->xText = rcHeader.left;  
                    break;
                case HDF_RIGHT: 
                    phdi->xText = rcHeader.right - phdi->cxTextAndBm;
                    break;
                case HDF_CENTER:
                    phdi->xText = rcHeader.left + dx/2; 
                    break;
                }

                // show as much of the bitmap as possible..
                // if we start running out of room, scoot the bitmap
                // back on.
                if (dx == 0) 
                    phdi->xBm = rcHeader.right - bmSize.cx;
                else
                    phdi->xBm = phdi->xText + textSize.cx;

                // clip the values
                if (phdi->xBm < rcHeader.left) phdi->xBm = rcHeader.left;
            }
            else { // BITMAP_ON_LEFT
                switch (phdi->fmt & HDF_JUSTIFYMASK) {
                case HDF_LEFT:
                    phdi->xBm = rcHeader.left;  
                    break;
                case HDF_RIGHT:
                    phdi->xBm = rcHeader.right - phdi->cxTextAndBm;
                    break;
                case HDF_CENTER:
                    phdi->xBm = rcHeader.left + dx/2;  
                    break;
                }
                phdi->xText = phdi->xBm + bmSize.cx;
                // clip the values
                if (phdi->xText > rcHeader.right) phdi->xText = rcHeader.right;
            }

            // xBm and xText are now absolute coordinates..
            // change them to item relative coordinates
            phdi->xBm -= rcHeader.left;
            phdi->xText -= rcHeader.left;
            TraceMsg(TF_HEADER, "h_di: phdi->xBm = %d, phdi->xText=%d",phdi->xBm, phdi->xText );
        }
        
        //
        // END RECOMPUTE /////////////////////////////////

        // calculate text and bitmap rectangles
        //
        rcBm.left = phdi->xBm + rcHeader.left;
        rcText.left = phdi->xText + rcHeader.left;

        if (phdi->fmt & HDF_BITMAP_ON_RIGHT) {
            rcBm.right = rcText.left + phdi->cxTextAndBm;
            rcText.right = rcBm.left;
        }
        else { // BITMAP_ON_LEFT
            rcBm.right = rcText.left;
            rcText.right = rcBm.left + phdi->cxTextAndBm;
        }
    }


    //
    // If we have a bitmap and/or an image...
    //

    if ((phdi->fmt & HDF_IMAGE) || (phdi->fmt & HDF_BITMAP))
    {
        BOOL fDrawBoth = FALSE;
        RECT rcDrawn;
        HRGN hrgn1 = NULL, hrgn2 = NULL;

        int temp;   // used to determine placement of bitmap.

        if ((phdi->fmt & HDF_IMAGE) && (phdi->fmt & HDF_BITMAP)) {
            // we have to do both
            fDrawBoth = TRUE;

            // first do just the image... turn off the bitmap bit

            // HACK ALERT! -- Don't call _Header_DrawBitmap with
            //                both the bitmap and image flags on

            // Draw the image...
            item.fmt ^= HDF_BITMAP;    // turn off bitmap bit
        }

        if (!(uFlags & HDDF_NOIMAGE)) {
            TraceMsg(TF_HEADER, "h_di: about to draw bitmap at rcBm= (%d,%d,%d,%d)",
                rcBm.left, rcBm.top, rcBm.right, rcBm.bottom );
            temp = _Header_DrawBitmap(hdc, phd->himl, &item, &rcBm,
                                      item.fmt & HDF_JUSTIFYMASK, uDrawTextFlags,
                                      &rcDrawn, phd->iBmMargin);
            hrgn1 = CreateRectRgnIndirect(&rcDrawn);
        }
        
        if (fDrawBoth) {
            // Tack on the bitmap...
            // Always tack the bitmap on the right of the image and
            // text unless we are right justified.  then, tack it on
            // left.

            item.fmt ^= HDF_BITMAP;    // turn on bitmap bit
            item.fmt ^= HDF_IMAGE;     // and turn off image bit
            if (item.fmt & HDF_RIGHT) {
                rcBm.right = temp;

                if (item.fmt & HDF_STRING) {
                    rcBm.right = ((rcBm.left < rcText.left) ?
                                  rcBm.left : rcText.left);
                }
                rcBm.left = rcHeader.left;
            }
            else {
                rcBm.left = temp;

                if (item.fmt & HDF_STRING) {
                    rcBm.left = ((rcBm.right > rcText.right) ? rcBm.right:rcText.right);
                }
                rcBm.right = rcHeader.right;
            }

            if (!(uFlags & HDDF_NOIMAGE)) {
                _Header_DrawBitmap(hdc, phd->himl, &item, &rcBm,
                                   item.fmt & HDF_RIGHT, uDrawTextFlags,
                                   &rcDrawn, phd->iBmMargin);
                hrgn2 = CreateRectRgnIndirect(&rcDrawn);
            }
            
            item.fmt ^= HDF_IMAGE;     // turn on the image bit

        }

        // if there were any regions created, union them together
        if(hrgn1 && hrgn2) {
            hrgnClip = CreateRectRgn(0,0,0,0);
            CombineRgn(hrgnClip, hrgn1, hrgn2, RGN_OR);
            DeleteObject(hrgn1);
            DeleteObject(hrgn2);
        } else if (hrgn1) {
            hrgnClip = hrgn1;
            hrgn1 = NULL;
        } else if (hrgn2) {
            hrgnClip = hrgn2;
            hrgn2 = NULL;
        }

        // this only happens in the drag/drop case
        if ((uFlags & HDDF_NOIMAGE) && !hrgnClip ) {
            // this means we didn't draw the images, which means we 
            // don't have the rects for them,
            // which means we need to create a dummy empty hrgnClip;
            hrgnClip = CreateRectRgn(0,0,0,0);
        }
        
        SaveDC(hdc);
    }


    if (phdi->fmt & HDF_STRING)
    {

#ifdef WINDOWS_ME
        if (item.fmt & HDF_RTLREADING)
        {
            uDrawTextFlags |= SHDT_RTLREADING;
        }
#endif

        TraceMsg(TF_HEADER, "h_di: about to draw text rcText=(%d,%d,%d,%d)",
            rcText.left, rcText.top, rcText.right, rcText.bottom );
        SHDrawText(hdc, item.pszText, &rcText,
                   item.fmt & HDF_JUSTIFYMASK,
                   uDrawTextFlags, phd->cyChar, phd->cxEllipses,
                   clrText, clrBk);
        if (hrgnClip) {
            // if we're building a clipping region, add the text to it.
            HRGN hrgnText;
            
            hrgnText = CreateRectRgnIndirect(&rcText);
            CombineRgn(hrgnClip, hrgnText, hrgnClip, RGN_OR);
            DeleteObject(hrgnText);            
        }
    } 
    

    if (phd->ci.style & HDS_FILTERBAR)
    {
        TCHAR szBuffer[32] = {'\0'};
        LPTSTR pBuffer = szBuffer;
        DWORD dwButtonState = DFCS_BUTTONPUSH;

        uDrawTextFlags = SHDT_ELLIPSES | SHDT_EXTRAMARGIN | SHDT_CLIPPED;

#ifdef WINDOWS_ME
        if (item.fmt & HDF_RTLREADING)
            uDrawTextFlags |= SHDT_RTLREADING;
#endif
        
        if (phdi->type & HDFT_HASNOVALUE)
        {
//BUGBUG: should be cached            
            LocalizedLoadString(IDS_ENTERTEXTHERE, szBuffer, ARRAYSIZE(szBuffer));
            clrText = g_clrGrayText;
        }
        else
        {
            clrText = g_clrWindowText;
            switch (phdi->type & HDFT_ISMASK)
            {
                case HDFT_ISSTRING:
                    pBuffer = phdi->textFilter.pszText;
                    break;

                case HDFT_ISNUMBER:
                    wsprintf(szBuffer, TEXT("%d"), phdi->intFilter);
                    break;

                default:
                    ASSERT(FALSE);
                    break;
            }
        }

        SHDrawText(hdc, pBuffer, &rcFilter, 
                   0, uDrawTextFlags, 
                   phd->cyChar, phd->cxEllipses,
                   clrText, g_clrWindow);

        PatBlt(hdc, rcFilter.left, rcFilter.bottom, rcFilter.right-rcFilter.left, c_cyFilterBarEdge, BLACKNESS);
        Header_DrawFilterGlyph(phd, hdc, &rcButton, (i==phd->iButtonDown));
        
        if (hrgnClip) {
            // if we're building a clipping region, add the text to it.
            HRGN hrgnFilter;

            hrgnFilter = CreateRectRgn( rcFilter.left, rcButton.top, rcButton.right, rcButton.bottom );
            CombineRgn(hrgnClip, hrgnFilter, hrgnClip, RGN_OR);
            DeleteObject(hrgnFilter);            
        }

        if ( phd->fFocus && (phd->iFocus == i)
#ifdef KEYBOARDCUES
            && !(CCGetUIState(&(phd->ci)) & UISF_HIDEFOCUS)
#endif
            )
        {
            InflateRect(&rcFilter, -g_cxEdge/2, -g_cyEdge/2);
            SetTextColor(hdc, g_clrWindowText);
            DrawFocusRect(hdc, &rcFilter);
        }
    }

    if (hrgnClip) {
        HRGN hrgnAll;
        HRGN hrgn;
        // hrgnClip is the union of everyplace we've drawn..
        // we want just the opposite.. so xor it
        hrgnAll = CreateRectRgnIndirect(&rcHeader);
        hrgn = CreateRectRgn(0, 0,0,0);
        CombineRgn(hrgn, hrgnAll, hrgnClip, RGN_XOR);
                   
        SelectClipRgn(hdc, hrgn);
                   
        ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rcHeader, NULL, 0, NULL);
        RestoreDC(hdc, -1);
        
        DeleteObject(hrgnClip);
        DeleteObject(hrgn);
        DeleteObject(hrgnAll);
    }

DrawEdges:
    
    if (!(uFlags & HDDF_NOEDGE)) {
        Header_DrawButtonEdges(phd, hdc, &rcHeader, fItemSunken);
    }
    if (dwRet & CDRF_NOTIFYPOSTPAINT) {
        CICustomDrawNotify(&phd->ci, CDDS_ITEMPOSTPAINT, &nmcd);
    }
    
}

void NEAR Header_Draw(HD* phd, HDC hdc, RECT FAR* prcClip)
{
    int i;                          // index of current header item
    int cItems;                         // number of items in header
    
    RECT rc;                            // item clipping rect
    BOOL fTracking;
    HFONT hfontOld = NULL;
    HDC hdcMem = NULL;
    int iIndex;
    NMCUSTOMDRAW nmcd;
    COLORREF clrText;
            
    fTracking = Header_IsTracking(phd);

    if (phd->hfont)
        hfontOld = SelectFont(hdc, phd->hfont);

    cItems = DSA_GetItemCount(phd->hdsaHDI);

    
    nmcd.hdc = hdc;
    nmcd.uItemState = 0;
    nmcd.lItemlParam = 0;
    nmcd.rc = *prcClip;
    phd->ci.dwCustom = CICustomDrawNotify(&phd->ci, CDDS_PREPAINT, &nmcd);
    
    for (i = 0 ; i < cItems; i++)
    {
        
        iIndex = Header_ItemOrderToIndex(phd, i);
        Header_OnGetItemRect(phd, iIndex, &rc);

        if (prcClip)
        {
            if (rc.right < prcClip->left)
                continue;
            if (rc.left >= prcClip->right)
                break;
        }
        
        if (iIndex == phd->iHot) {
            clrText = GetSysColor(COLOR_HOTLIGHT);
        } else {
            clrText = g_clrBtnText;
        }

        SetTextColor(hdc, clrText);
        SetBkColor(hdc, g_clrBtnFace);
        
        Header_DrawItem(phd, hdc, i, iIndex, &rc, 0);
    }
    
    if (i == cItems) {
        // we got through the loop... now we need to do the blank area on the right
        rc.left = rc.right;
        rc.right = 32000;
        Header_DrawButtonEdges(phd, hdc, &rc, FALSE);
    }

    if (!HDDragFullWindows(phd) && fTracking && (phd->flagsTrack & (HHT_ONDIVIDER | HHT_ONDIVOPEN)))
        Header_DrawDivider(phd, phd->xTrack);
    
    // draw the hot divider
    if (phd->iNewOrder != -1) {
        RECT rc;
        COLORREF clrHot = GetSysColor(COLOR_HOTLIGHT);
        
        Header_GetDividerRect(phd, phd->iNewOrder, &rc);
        FillRectClr(hdc, &rc, clrHot);
        
    }

    if (phd->ci.dwCustom & CDRF_NOTIFYPOSTPAINT) {
        CICustomDrawNotify(&phd->ci, CDDS_POSTPAINT, &nmcd);
    }
    
    if (hfontOld)
	SelectFont(hdc, hfontOld);
}

HIMAGELIST Header_OnCreateDragImage(HD* phd, int i)
{
    HDC hdcMem;
    RECT rc;
    HBITMAP hbmImage = NULL;
    HBITMAP hbmMask = NULL;
    HFONT hfontOld = NULL;
    HIMAGELIST himl = NULL;
    HIMAGELIST himlDither = NULL;
    HBITMAP hbmOld = NULL;
    BOOL bMirroredWnd = (phd->ci.dwExStyle&RTL_MIRRORED_WINDOW);
    int iIndex = Header_ItemOrderToIndex(phd, i);
    
    // IEUNIX : Fixing crash in OE while dragging the message 
    // header.
    if( !Header_OnGetItemRect(phd, iIndex, &rc) )
        goto Bail;

    // draw the header into this bitmap
    OffsetRect(&rc, -rc.left, -rc.top);
    
    if (!(hdcMem = CreateCompatibleDC(NULL)))
        goto Bail;
    
    if (!(hbmImage = CreateColorBitmap(rc.right, rc.bottom)))
        goto Bail;
    if (!(hbmMask = CreateMonoBitmap(rc.right, rc.bottom)))
	goto Bail;

    //
    // Mirror the memory DC so that the transition from
    // mirrored(memDC)->non-mirrored(imagelist DCs)->mirrored(screenDC)
    // is consistent. [samera]
    //
    if (bMirroredWnd) {
        SET_DC_RTL_MIRRORED(hdcMem);
    }

    if (phd->hfont)
        hfontOld = SelectFont(hdcMem, phd->hfont);

    if (!(himl = ImageList_Create(rc.right, rc.bottom, ILC_MASK, 1, 0)))
	goto Bail;

    if (!(himlDither = ImageList_Create(rc.right, rc.bottom, ILC_MASK, 1, 0)))
	goto Bail;
    

    // have the darker background
    SetTextColor(hdcMem, g_clrBtnText);
    SetBkColor(hdcMem, g_clrBtnShadow);
    hbmOld = SelectObject(hdcMem, hbmImage);
    Header_DrawItem(phd, hdcMem, i, iIndex, &rc, HDDF_NOEDGE);

    //
    // If the header is RTL mirrored, then
    // mirror the Memory DC, so that when copying back
    // we don't get any image-flipping. [samera]
    //
    if (bMirroredWnd)
        MirrorBitmapInDC(hdcMem, hbmImage);
    
    // fill the mask with all black
    SelectObject(hdcMem, hbmMask);
    PatBlt(hdcMem, 0, 0, rc.right, rc.bottom, BLACKNESS);
    
    // put the image into an imagelist
    SelectObject(hdcMem, hbmOld);
    ImageList_SetBkColor(himl, CLR_NONE);
    ImageList_Add(himl, hbmImage, hbmMask);


    // have the darker background
    // now put the text in undithered.
    SetTextColor(hdcMem, g_clrBtnText);
    SetBkColor(hdcMem, g_clrBtnShadow);
    hbmOld = SelectObject(hdcMem, hbmImage);
    Header_DrawItem(phd, hdcMem, i, iIndex, &rc, HDDF_NOIMAGE | HDDF_NOEDGE);
    DrawEdge(hdcMem, &rc, EDGE_BUMP, BF_RECT | BF_FLAT);

    //
    // If the header is RTL mirrored, then
    // mirror the Memory DC, so that when copying back
    // we don't get any image-flipping. [samera]
    //
    if (bMirroredWnd)
        MirrorBitmapInDC(hdcMem, hbmImage);

    /*
    // initialize this to transparent
    SelectObject(hdcMem, hbmImage);
    PatBlt(hdcMem, 0, 0, rc.right, rc.bottom, BLACKNESS);
    SelectObject(hdcMem, hbmMask);
    PatBlt(hdcMem, 0, 0, rc.right, rc.bottom, WHITENESS);
    */
    
    SelectObject(hdcMem, hbmOld);
    ImageList_AddMasked(himlDither, hbmImage, g_clrBtnShadow);
    
    // dither image into himlDithered
    ImageList_CopyDitherImage(himlDither, 0, 0, 0, 
                              himl, 0, 0);
    
Bail:
    
    if (himl) {
        ImageList_Destroy(himl);
    }

    if (hdcMem) {
        if (hbmOld) 
            SelectObject(hdcMem, hbmOld);
        if (hfontOld)
            SelectFont(hdcMem, hfontOld);
	DeleteObject(hdcMem);
    }
    
    if (hbmImage)
	DeleteObject(hbmImage);
    if (hbmMask)
	DeleteObject(hbmMask);
    

    return himlDither;
} 

void Header_GetFilterRects(LPRECT prcItem, LPRECT prcHeader, LPRECT prcFilter, LPRECT prcButton)
{
    INT cyFilter = ((prcItem->bottom-prcItem->top)-c_cyFilterBarEdge)/2;
    *prcButton = *prcFilter = *prcHeader = *prcItem;
    prcHeader->bottom = prcHeader->top + cyFilter;  
    prcButton->left = prcFilter->right = prcFilter->right -= (g_cxBorder*4)+c_cxFilterImage;
    prcButton->top = prcFilter->top = prcHeader->bottom;
    prcFilter->bottom = prcFilter->top + cyFilter;
}

//
// Subclass the edit control to ensure we get the keys we are interested in
//

LRESULT CALLBACK Header_EditWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    HD* phd = (HD*)GetWindowPtr(GetParent(hwnd), 0);
    ASSERT(phd);

    switch (msg)
    {
        case WM_KILLFOCUS:
            Header_StopFilterEdit(phd, FALSE);
            return 0L;

        case WM_KEYDOWN:
        {
            if (wParam == VK_RETURN) 
            {
                Header_StopFilterEdit(phd, FALSE);
                return 0L;
            } 
            else if (wParam == VK_ESCAPE) 
            {
                Header_StopFilterEdit(phd, TRUE);
                return 0L;
            } 
            else if (wParam == VK_F4 )
            {
                Header_OnFilterButton(phd, phd->iEdit);
                return 0L;
            }
            break;
        }

        case WM_CHAR:
        {
            switch (wParam)
            {
                case VK_RETURN:
                case VK_ESCAPE:
                case VK_TAB:
                    return 0L;                              // eat these so we don't beep
            }
#ifdef KEYBOARDCUES
            //notify of navigation key usage
            CCNotifyNavigationKeyUsage(&(phd->ci), UISF_HIDEFOCUS);
#endif
            break;
        }

        case WM_GETDLGCODE:
            return DLGC_WANTALLKEYS | DLGC_HASSETSEL;        /* editing name, no dialog handling right now */

#ifdef KEYBOARDCUES
        case WM_UPDATEUISTATE:
        {
            DWORD dwUIStateMask = MAKEWPARAM(0xFFFF, UISF_HIDEFOCUS);

            if (CCOnUIState(&(phd->ci), WM_UPDATEUISTATE, wParam & dwUIStateMask, lParam))
                InvalidateRect(hwnd, NULL, TRUE);

            break;
        }
#endif
    }

    return CallWindowProc(phd->pfnEditWndProc, hwnd, msg, wParam, lParam);
}

//
// Begin to edit the given column, displaying the editor as required
//

BOOL Header_BeginFilterEdit(HD* phd, int i)
{
    RECT rc, rcHeader, rcFilter, rcButton;
    int iIndex = i;
    int cxEdit, cyEdit;
    TCHAR szBuffer[MAX_PATH];
    LPTSTR pBuffer = szBuffer;
    int cchBuffer = MAX_PATH;
    UINT uFlags = WS_CLIPSIBLINGS|WS_VISIBLE|WS_CHILD|ES_AUTOHSCROLL;
    HDI* phdi = Header_GetItemPtr(phd, i);
    
    if ( !phdi || (i < 0) )
        return FALSE;            // yikes

    // lets create an edit control that allows the user to 
    // modify the current filter, note that we first must
    // format the data to be displayed in the control
    
    Header_OnGetItemRect(phd, iIndex, &rc);
    Header_GetFilterRects(&rc, &rcHeader, &rcFilter, &rcButton);

    phd->typeOld = phdi->type;          // keep the type field safe

    switch (phdi->type & HDFT_ISMASK)
    {
        case HDFT_ISSTRING:
            Str_Set(&phd->pszFilterOld, phdi->textFilter.pszText);
            pBuffer = phdi->textFilter.pszText;
            // This count does not include the terminating null
            cchBuffer = phdi->textFilter.cchTextMax;
            break;

        case HDFT_ISNUMBER:
            phd->intFilterOld = phdi->intFilter;
            wsprintf(szBuffer, TEXT("%d"), phdi->intFilter);
            cchBuffer = 11;                                  // 10 digits, plus sign
            uFlags |= ES_NUMBER;
            break;

        default:
            return FALSE;
    }

    cxEdit = (rcFilter.right-rcFilter.left)-(g_cxLabelMargin*6);
    cyEdit = (rcFilter.bottom-rcFilter.top)-(g_cyEdge*2);
    phd->hwndEdit = CreateWindow(TEXT("EDIT"), 
                                 !(phdi->type & HDFT_HASNOVALUE) ? pBuffer:TEXT(""), 
                                 uFlags,
                                 rcFilter.left+(g_cxLabelMargin*3), 
                                 rcFilter.top+g_cyEdge,
                                 cxEdit, cyEdit,
                                 phd->ci.hwnd,
                                 NULL, HINST_THISDLL, NULL);
    if ( phd->hwndEdit ) 
    {
        INT iOldFocus = phd->iFocus;

        //
        // Setup the edit mode for this object?
        //

        phd->iEdit = i;                                 // now editing this column
        phd->iFocus = Header_OnGetItemOrder(phd, i);

        Header_OnGetItemRect(phd,  Header_ItemOrderToIndex(phd, iOldFocus), &rc);                     // nb: iOldFocus
        Header_GetFilterRects(&rc, &rcHeader, &rcFilter, &rcButton);
        RedrawWindow(phd->ci.hwnd, &rcFilter, NULL, RDW_INVALIDATE | RDW_ERASE);

        //
        // Now subclass the edit control so we can trap the keystrokes we are interested in
        //

        phd->pfnEditWndProc = SubclassWindow(phd->hwndEdit, Header_EditWndProc);
        ASSERT(phd->pfnEditWndProc);

        Edit_LimitText(phd->hwndEdit, cchBuffer);
        Edit_SetSel(phd->hwndEdit, 0, -1);
        FORWARD_WM_SETFONT(phd->hwndEdit, phd->hfont, FALSE, SendMessage);

        SetFocus(phd->hwndEdit);
    }

    return(phd->hwndEdit != NULL);
}

//
// Stop editing the fitler, discarding the change if we need to, otherwise
// the item has the correct information stored within it.
//

VOID Header_StopFilterEdit(HD* phd, BOOL fDiscardChanges)
{
    if ( phd->iEdit >= 0 )
    {
        HDI* phdi = Header_GetItemPtr(phd, phd->iEdit);
        HD_ITEM hdi;
        HD_TEXTFILTER textFilter;
        int intFilter;
        ASSERT(phdi);
    
        if ( fDiscardChanges )
        {
            hdi.mask = HDI_FILTER;
            hdi.type = phd->typeOld;

            switch (phdi->type & HDFT_ISMASK)
            {
                case HDFT_ISSTRING:
                    textFilter.pszText = phd->pszFilterOld;
                    textFilter.cchTextMax = phdi->textFilter.cchTextMax;
                    hdi.pvFilter = &textFilter;
                    break;

                case HDFT_ISNUMBER:
                    intFilter = phd->intFilterOld;                    
                    hdi.pvFilter = &intFilter;
                    break;
            }

            Header_OnSetItem(phd, phd->iEdit, &hdi);
        }
        else
        {
            Header_FilterChanged(phd, FALSE);          // ensure we flush the changes        
        }

        if ( phd->hwndEdit )
        {
            SubclassWindow(phd->hwndEdit, phd->pfnEditWndProc);
            DestroyWindow(phd->hwndEdit);
            phd->hwndEdit = NULL;
        }

        phd->iEdit = -1;
        phd->pszFilterOld = NULL;
    }
}

//
// Send a filter change to the parent, either now or wait until the timeout
// expires.  
//
 
VOID Header_FilterChanged(HD* phd, BOOL fWait)
{
    if ( phd->iEdit < 0 )
        return;

    if ( fWait )
    {
        // defering the notify, therefore lets set the timer (killing any
        // previous ones) and marking that we are waiting on it.

        KillTimer(phd->ci.hwnd, HD_EDITCHANGETIMER);
        SetTimer(phd->ci.hwnd, HD_EDITCHANGETIMER, phd->iFilterChangeTimeout, NULL);
        phd->fFilterChangePending = TRUE;
    }
    else
    {
        HDI* phdi = Header_GetItemPtrByOrder(phd, phd->iEdit);            
        ASSERT(phdi);

        // if we have a change notify pending then lets send it to
        // the parent window, otherwise we just swallow it.

        if ( phd->fFilterChangePending )
        {
            TCHAR szBuffer[MAX_PATH];
            HD_ITEM hdi;
            HD_TEXTFILTER textFilter;
            int intFilter;

            KillTimer(phd->ci.hwnd, HD_EDITCHANGETIMER);
            phd->fFilterChangePending = FALSE;
        
            hdi.mask = HDI_FILTER;
            hdi.type = phdi->type & ~HDFT_HASNOVALUE;

            if ( !GetWindowText(phd->hwndEdit, szBuffer, ARRAYSIZE(szBuffer)) )
                hdi.type |= HDFT_HASNOVALUE;
    
            switch (phdi->type & HDFT_ISMASK)
            {
                case HDFT_ISSTRING:
                    textFilter.pszText = szBuffer;
                    textFilter.cchTextMax = phdi->textFilter.cchTextMax;
                    hdi.pvFilter = &textFilter;
                    break;

                case HDFT_ISNUMBER:
                    intFilter = StrToInt(szBuffer);                    
                    hdi.pvFilter = &intFilter;
                    break;
            }

            Header_OnSetItem(phd, phd->iEdit, &hdi);
        }
    }
}

//
// Handle the user displaying the filter menu
//

VOID Header_OnFilterButton(HD* phd, INT i)
{
    NMHDFILTERBTNCLICK fbc;
    RECT rc, rcHeader, rcFilter;

    // filter button being depressed so depress it, then tell the user
    // that it went down so they can display the UI they want, before
    // we pop the button.  if the notify returns TRUE then send
    // a change notify around.

    Header_StopFilterEdit(phd, FALSE);

    ASSERT(phd->iButtonDown == -1);
    phd->iButtonDown = i;

    Header_InvalidateItem(phd, i, RDW_INVALIDATE);
    UpdateWindow(phd->ci.hwnd);

    ZeroMemory(&fbc, SIZEOF(fbc));
    fbc.iItem = i;
    // fbc.rc = { 0, 0, 0, 0 };

    Header_OnGetItemRect(phd, i, &rc);
    Header_GetFilterRects(&rc, &rcHeader, &rcFilter, &fbc.rc);

    if ( CCSendNotify(&phd->ci, HDN_FILTERBTNCLICK, &fbc.hdr) )
        Header_Notify(phd, i, 0, HDN_FILTERCHANGE);
  
    phd->iButtonDown = -1;
    Header_InvalidateItem(phd, i, RDW_INVALIDATE);
    UpdateWindow(phd->ci.hwnd);
}

//
// Handle clearing the filter for the given item
//

LRESULT Header_OnClearFilter(HD* phd, INT i)
{
    HDI* phdi;
    HD_ITEM hdi;
    INT iChanged = 0;
    
    Header_StopFilterEdit(phd, FALSE);

    if ( i == -1 )
    {
        //
        // clear all filters by setting setting the HDFT_HASNOVALUEFLAG on all items
        // remember to release the filter data.  For each item we also send an item
        // changing indicating that the filter is changing and then a item changed
        // to indicat that we really did fix the value.
        //
    
        for ( i = 0 ; i < DSA_GetItemCount(phd->hdsaHDI); i++ )
        {
            phdi = Header_GetItemPtrByOrder(phd, i);            
            ASSERT(phdi);

            if ( !(phdi->type & HDFT_HASNOVALUE) )
            {
                hdi.mask = HDI_FILTER;
                hdi.type = phdi->type|HDFT_HASNOVALUE;
                hdi.pvFilter = NULL;

                if ( Header_SendChange(phd, i, HDN_ITEMCHANGING, &hdi) )
                {
                    if ( (phdi->type & HDFT_ISMASK) == HDFT_ISSTRING )
                        Str_Set(&phdi->textFilter.pszText, NULL);

                    phdi->type |= HDFT_HASNOVALUE;                      // item is now empty

                    Header_SendChange(phd, i, HDN_ITEMCHANGED, &hdi);

                    iChanged++;
                }
            }
        }        

        if ( iChanged )
        {
            //
            // item == -1 indicating that we are cleared all filters, then invalidate
            // the window so that the filter values are no longer visible
            //

    	    Header_Notify(phd, -1, 0, HDN_FILTERCHANGE);	       // send out a notify of change
            RedrawWindow(phd->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
        }
    }
    else
    {
        if ( (i < 0) || (i > DSA_GetItemCount(phd->hdsaHDI)) )
            return 0L;

        phdi = Header_GetItemPtrByOrder(phd, i);            
        ASSERT(phdi);

        if ( !(phdi->type & HDFT_HASNOVALUE) )
        {
            //
            // clear a single filter by setting the HDFT_HASNOVALUE flag 
            //

            hdi.mask = HDI_FILTER;
            hdi.type = phdi->type|HDFT_HASNOVALUE;
            hdi.pvFilter = NULL;

            Header_OnSetItem(phd, i, &hdi);
        }
    }

    return 1L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\fontlink.h ===
#ifndef _FONTLINK_H_

#define SPACE_CHAR       0x20
#define EURODOLLAR_CHAR  0x20A0 // New Euro dollar symbol
#define CAPZCARON_CHAR   0x017D
#define SMALLZCARON_CHAR 0x017E

//
//  Unicode SubRange (USR) definitions
//
#define usrBasicLatin           0       // 0x20->0x7f
#define usrLatin1               1       // 0xa0->0xff
#define usrLatinXA              2       // 0x100->0x17f
#define usrLatinXB              3       // 0x180->0x24f
#define usrIPAExtensions        4       // 0x250->0x2af
#define usrSpacingModLetters    5       // 0x2b0->0x2ff
#define usrCombDiacritical      6       // 0x300->0x36f
#define usrBasicGreek           7       // 0x370->0x3cf
#define usrGreekSymbolsCop      8       // 0x3d0->0x3ff
#define usrCyrillic             9       // 0x400->0x4ff
#define usrArmenian             10      // 0x500->0x58f
#define usrBasicHebrew          11      // 0x5d0->0x5ff
#define usrHebrewXA             12      // 0x590->0x5cf
#define usrBasicArabic          13      // 0x600->0x652
#define usrArabicX              14      // 0x653->0x6ff
#define usrDevangari            15      // 0x900->0x97f
#define usrBengali              16      // 0x980->0x9ff
#define usrGurmukhi             17      // 0xa00->0xa7f
#define usrGujarati             18      // 0xa80->0xaff
#define usrOriya                19      // 0xb00->0xb7f
#define usrTamil                20      // 0x0B80->0x0BFF
#define usrTelugu               21      // 0x0C00->0x0C7F
#define usrKannada              22      // 0x0C80->0x0CFF
#define usrMalayalam            23      // 0x0D00->0x0D7F
#define usrThai                 24      // 0x0E00->0x0E7F
#define usrLao                  25      // 0x0E80->0x0EFF
#define usrBasicGeorgian        26      // 0x10D0->0x10FF
#define usrGeorgianExtended     27      // 0x10A0->0x10CF
#define usrHangulJamo           28      // 0x1100->0x11FF
#define usrLatinExtendedAdd     29      // 0x1E00->0x1EFF
#define usrGreekExtended        30      // 0x1F00->0x1FFF
#define usrGeneralPunct         31      // 0x2000->0x206F
#define usrSuperAndSubscript    32      // 0x2070->0x209F
#define usrCurrencySymbols      33      // 0x20A0->0x20CF
#define usrCombDiacriticsS      34      // 0x20D0->0x20FF   
#define usrLetterlikeSymbols    35      // 0x2100->0x214F   
#define usrNumberForms          36      // 0x2150->0x218F   
#define usrArrows               37      // 0x2190->0x21FF   
#define usrMathematicalOps      38      // 0x2200->0x22FF   
#define usrMiscTechnical        39      // 0x2300->0x23FF   
#define usrControlPictures      40      // 0x2400->0x243F   
#define usrOpticalCharRecog     41      // 0x2440->0x245F   
#define usrEnclosedAlphanum     42      // 0x2460->0x24FF   
#define usrBoxDrawing           43      // 0x2500->0x257F   
#define usrBlockElements        44      // 0x2580->0x259F   
#define usrGeometricShapes      45      // 0x25A0->0x25FF   
#define usrMiscDingbats         46      // 0x2600->0x26FF   
#define usrDingbats             47      // 0x2700->0x27BF   
#define usrCJKSymAndPunct       48      // 0x3000->0x303F   
#define usrHiragana             49      // 0x3040->0x309F   
#define usrKatakana             50      // 0x30A0->0x30FF   
#define usrBopomofo             51      // 0x3100->0x312F   
#define usrHangulCompatJamo     52      // 0x3130->0x318F   
#define usrCJKMisc              53      // 0x3190->0x319F   
#define usrEnclosedCJKLtMnth    54      // 0x3200->0x32FF   
#define usrCJKCompatibility     55      // 0x3300->0x33FF   
#define usrHangul               56      // 0xac00->0xd7a3
#define usrReserved1            57
#define usrReserved2            58
#define usrCJKUnifiedIdeo       59      // 0x4E00->0x9FFF   
#define usrPrivateUseArea       60      // 0xE000->0xF8FF   
#define usrCJKCompatibilityIdeographs   61      // 0xF900->0xFAFF   
#define usrAlphaPresentationForms       62      // 0xFB00->0xFB4F   
#define usrArabicPresentationFormsA     63      // 0xFB50->0xFDFF   
#define usrCombiningHalfMarks           64      // 0xFE20->0xFE2F   
#define usrCJKCompatForms               65      // 0xFE30->0xFE4F   
#define usrSmallFormVariants            66      // 0xFE50->0xFE6F   
#define usrArabicPresentationFormsB     67      // 0xFE70->0xFEFE   
#define usrHFWidthForms                 68      // 0xFF00->0xFFEF   
#define usrSpecials                     69      // 0xFFF0->0xFFFD   
#define usrMax                          70

#define FBetween(a, b, c)  (((unsigned)((a) - (b))) <= (c) - (b))

#endif  // _FONTLINK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\image.h ===
#ifndef _INC_IMAGE
#define _INC_IMAGE


// internal image stuff
EXTERN_C void FAR PASCAL InitDitherBrush(void);
EXTERN_C void FAR PASCAL TerminateDitherBrush(void);

EXTERN_C HBITMAP FAR PASCAL CreateMonoBitmap(int cx, int cy);
EXTERN_C HBITMAP FAR PASCAL CreateColorBitmap(int cx, int cy);

EXTERN_C void WINAPI ImageList_CopyDitherImage(HIMAGELIST pimlDest, WORD iDst,
    int xDst, int yDst, HIMAGELIST pimlSrc, int iSrc, UINT fStyle);

// function to create a imagelist using the params of a given image list
EXTERN_C HIMAGELIST WINAPI ImageList_Clone(HIMAGELIST himl, int cx, int cy,
    UINT flags, int cInitial, int cGrow);

#define GLOW_RADIUS     10
#define DROP_SHADOW     3

#ifndef ILC_COLORMASK
#define ILC_COLORMASK   0x00FE
#define ILD_BLENDMASK   0x000E
#endif
#undef ILC_COLOR
#undef ILC_BLEND

#define CLR_WHITE   0x00FFFFFFL
#define CLR_BLACK   0x00000000L

#define IsImageListIndex(i) ((i) >= 0 && (i) < _cImage)

#define IMAGELIST_SIG   mmioFOURCC('H','I','M','L') // in memory magic
#define IMAGELIST_MAGIC ('I' + ('L' * 256))         // file format magic
// Version has to stay 0x0101 if we want both back ward and forward compatibility for
// our imagelist_read code
#define IMAGELIST_VER0  0x0101                      // file format ver
// #define IMAGELIST_VER1  0x0102                      // Image list version 2 -- this one has 15 overlay slots

#define BFTYPE_BITMAP   0x4D42      // "BM"

#define CBDIBBUF        4096

#endif  // _INC_IMAGE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\ipaddr.c ===
/* Copyright (c) 1991, Microsoft Corporation, all rights reserved

 ipaddr.c - TCP/IP Address custom control

 November 9, 1992    Greg Strange
 */

#include "ctlspriv.h"


// The character that is displayed between address fields.
#define FILLER          TEXT('.')
#define SZFILLER        TEXT(".")
#define SPACE           TEXT(' ')
#define BACK_SPACE      8

/* Min, max values */
#define NUM_FIELDS      4
#define CHARS_PER_FIELD 3
#define HEAD_ROOM       1       // space at top of control
#define LEAD_ROOM       3       // space at front of control
#define MIN_FIELD_VALUE 0       // default minimum allowable field value
#define MAX_FIELD_VALUE 255     // default maximum allowable field value


// All the information unique to one control is stuffed in one of these
// structures in global memory and the handle to the memory is stored in the
// Windows extra space.

typedef struct tagFIELD {
    HANDLE      hWnd;
    WNDPROC     lpfnWndProc;
    BYTE        byLow;  // lowest allowed value for this field.
    BYTE        byHigh; // Highest allowed value for this field.
} FIELD;

typedef struct tagIPADDR {
    HWND        hwndParent;
    HWND        hwnd;
    UINT        uiFieldWidth;
    UINT        uiFillerWidth;
    BOOL        fEnabled : 1;
    BOOL        fPainted : 1;
    BOOL        bControlInFocus : 1;        // TRUE if the control is already in focus, dont't send another focus command
    BOOL        bCancelParentNotify : 1;    // Don't allow the edit controls to notify parent if TRUE
    BOOL        fInMessageBox : 1;  // Set when a message box is displayed so that
    BOOL        fFontCreated :1;
    HFONT       hfont;
    // we don't send a EN_KILLFOCUS message when
    // we receive the EN_KILLFOCUS message for the
    // current field.
    FIELD       Children[NUM_FIELDS];
} IPADDR;


// The following macros extract and store the CONTROL structure for a control.
#define    IPADDRESS_EXTRA            sizeof(DWORD)

#define GET_IPADDR_HANDLE(hWnd)        ((HGLOBAL)(GetWindowLongPtr((hWnd), GWLP_USERDATA)))
#define SAVE_IPADDR_HANDLE(hWnd,x)     (SetWindowLongPtr((hWnd), GWLP_USERDATA, (LONG_PTR)(x)))


/* internal IPAddress function prototypes */
LRESULT IPAddressWndFn( HWND, UINT, WPARAM, LPARAM );
LRESULT IPAddressFieldProc(HWND, UINT, WPARAM, LPARAM);
BOOL SwitchFields(IPADDR FAR *, int, int, WORD, WORD);
void EnterField(FIELD FAR *, WORD, WORD);
BOOL ExitField(IPADDR FAR *, int iField);
int GetFieldValue(FIELD FAR *);
void SetFieldValue(IPADDR *pipa, int iField, int iValue);
BOOL IsDBCS();





/*
 IPAddrInit() - IPAddress custom control initialization
 call
 hInstance = library or application instance
 return
 TRUE on success, FALSE on failure.

 This function does all the one time initialization of IPAddress custom
 controls.  Specifically it creates the IPAddress window class.
 */
int InitIPAddr(HANDLE hInstance)
{
    WNDCLASS        wc;

    if (!GetClassInfo(hInstance, WC_IPADDRESS, &wc)) {
        /* define class attributes */
        wc.lpszClassName = WC_IPADDRESS;
        wc.hCursor =       LoadCursor(NULL,IDC_IBEAM);
        wc.hIcon           = NULL;
        wc.lpszMenuName =  (LPCTSTR)NULL;
        wc.style =         CS_HREDRAW|CS_VREDRAW|CS_DBLCLKS|CS_GLOBALCLASS;
        wc.lpfnWndProc =   IPAddressWndFn;
        wc.hInstance =     hInstance;
        wc.hIcon =         NULL;
        wc.cbWndExtra =    IPADDRESS_EXTRA;
        wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1 );
        wc.cbClsExtra      = 0;

        /* register IPAddress window class */
        return RegisterClass(&wc);
    }
    return TRUE;
}


/*
 IPAddressWndFn() - Main window function for an IPAddress control.

 call
 hWnd    handle to IPAddress window
 wMsg    message number
 wParam  word parameter
 lParam  long parameter
 */

void FormatIPAddress(LPTSTR pszString, DWORD* dwValue)
{
    int nField, nPos;
    BOOL fFinish = FALSE;

    dwValue[0] = 0; dwValue[1] = 0; dwValue[2] = 0; dwValue[3] = 0;

    if (pszString[0] == 0)
        return;

    for( nField = 0, nPos = 0; !fFinish; nPos++)
    {
        if (( pszString[nPos]<TEXT('0')) || (pszString[nPos]>TEXT('9')))
        {
            // not a number
            nField++;
            fFinish = (nField == 4);
        }
        else
        {
            dwValue[nField] *= 10;
            dwValue[nField] += (pszString[nPos]-TEXT('0'));
        }
    }
}

void IP_OnSetFont(IPADDR* pipa, HFONT hfont, BOOL fRedraw)
{
    int i;
    RECT rect;
    HFONT OldFont;
    BOOL fNewFont = FALSE;
    UINT uiFieldStart;
    HDC hdc;
    
    if (hfont) {
        fNewFont = TRUE;
    } else {
        hfont = (HFONT)SendMessage(pipa->hwnd, WM_GETFONT, 0, 0);
    }
    
    hdc = GetDC(pipa->hwnd);
    OldFont = SelectObject(hdc, hfont);
    GetCharWidth(hdc, FILLER, FILLER,
                 (int *)(&pipa->uiFillerWidth));
    SelectObject(hdc, OldFont);
    ReleaseDC(pipa->hwnd, hdc);
    
    GetClientRect(pipa->hwnd, &rect);
    pipa->hfont = hfont;
    pipa->uiFieldWidth = (RECTWIDTH(rect)
                          - LEAD_ROOM
                          - pipa->uiFillerWidth
                          *(NUM_FIELDS-1))
        / NUM_FIELDS;


    uiFieldStart = LEAD_ROOM;

    for (i = 0; i < NUM_FIELDS; i++) {

        HWND hwnd = pipa->Children[i].hWnd;
        
        if (fNewFont)
            SendMessage(hwnd, WM_SETFONT, (WPARAM)hfont, (LPARAM)fRedraw);
        
        SetWindowPos(hwnd, NULL,
                     uiFieldStart,
                     HEAD_ROOM,
                     pipa->uiFieldWidth,
                     (rect.bottom-rect.top),
                     SWP_NOACTIVATE);

        uiFieldStart += pipa->uiFieldWidth
            + pipa->uiFillerWidth;

    }
    
}

LRESULT IPAddressWndFn( hWnd, wMsg, wParam, lParam )
    HWND            hWnd;
    UINT            wMsg;
    WPARAM            wParam;
    LPARAM            lParam;
{
    LRESULT lResult;
    IPADDR *pipa;
    int i;

    pipa = (IPADDR *)GET_IPADDR_HANDLE(hWnd);
    lResult = TRUE;

    switch( wMsg )
    {

        // use empty string (not NULL) to set to blank
        case WM_SETTEXT:
        {
            TCHAR szBuf[CHARS_PER_FIELD+1];
            DWORD dwValue[4];
#ifdef UNICODE_WIN9x
            WCHAR szTemp[80];
            LPTSTR pszString = szTemp;
            ConvertAToWN(CP_ACP, szTemp, ARRAYSIZE(szTemp), (LPSTR)lParam, -1);
#else
            LPTSTR pszString = (LPTSTR)lParam;
#endif

            FormatIPAddress(pszString, &dwValue[0]);
            pipa->bCancelParentNotify = TRUE;

            for (i = 0; i < NUM_FIELDS; ++i)
            {
                if (pszString[0] == 0)
                {
                    szBuf[0] = 0;
                }
                else
                {
                    wsprintf(szBuf, TEXT("%d"), dwValue[i]);
                }
                SendMessage(pipa->Children[i].hWnd, WM_SETTEXT,
                            0, (LPARAM) (LPSTR) szBuf);
            }

            pipa->bCancelParentNotify = FALSE;

            SendMessage(pipa->hwndParent, WM_COMMAND,
                        MAKEWPARAM(GetDlgCtrlID(hWnd), EN_CHANGE), (LPARAM)hWnd);
        }
        break;

    case WM_GETTEXTLENGTH:
    case WM_GETTEXT:
    {
        int iFieldValue;
        DWORD dwValue[4];
#ifdef UNICODE_WIN9x
        char pszResult[30];
        char *pszDest = (char *)lParam;
#else
        TCHAR pszResult[30];
        TCHAR *pszDest = (TCHAR *)lParam;
#endif

        lResult = 0;
        dwValue[0] = 0;
        dwValue[1] = 0;
        dwValue[2] = 0;
        dwValue[3] = 0;
        for (i = 0; i < NUM_FIELDS; ++i)
        {
            iFieldValue = GetFieldValue(&(pipa->Children[i]));
            if (iFieldValue == -1)
                iFieldValue = 0;
            else
                ++lResult;
            dwValue[i] = iFieldValue;
        }
#ifdef UNICODE_WIN9x
        wsprintfA( pszResult, "%d.%d.%d.%d", dwValue[0], dwValue[1], dwValue[2], dwValue[3] );
#else
        wsprintf( pszResult, TEXT("%d.%d.%d.%d"), dwValue[0], dwValue[1], dwValue[2], dwValue[3] );
#endif
        if (wMsg == WM_GETTEXT) {
#ifdef UNICODE_WIN9x
            lstrcpynA(pszDest, pszResult, (int) wParam);
            lResult = lstrlenA( pszDest );
#else
            StrCpyN(pszDest, pszResult, (int) wParam);
            lResult = lstrlen( pszDest );
#endif

        } else {
#ifdef UNICODE_WIN9x
            lResult = lstrlenA( pszResult );
#else
            lResult = lstrlen( pszResult );
#endif
        }
    }
        break;

    case WM_GETDLGCODE :
        lResult = DLGC_WANTCHARS;
        break;

    case WM_NCCREATE:
        SetWindowBits(hWnd, GWL_EXSTYLE, WS_EX_CLIENTEDGE, WS_EX_CLIENTEDGE);
        lResult = TRUE;
        break;

    case WM_CREATE : /* create pallette window */
    {
        LONG id;

        CCCreateWindow();

        pipa = (IPADDR*)LocalAlloc(LPTR, sizeof(IPADDR));

        if (pipa)
        {

#define LPCS    ((CREATESTRUCT *)lParam)

            pipa->fEnabled = TRUE;
            pipa->hwndParent = LPCS->hwndParent;
            pipa->hwnd = hWnd;

            id = GetDlgCtrlID(hWnd);
            for (i = 0; i < NUM_FIELDS; ++i)
            {
                pipa->Children[i].byLow = MIN_FIELD_VALUE;
                pipa->Children[i].byHigh = MAX_FIELD_VALUE;

                pipa->Children[i].hWnd = CreateWindowEx(0,
                                                        TEXT("Edit"),
                                                        NULL,
                                                        WS_CHILD |
                                                        ES_CENTER, 
                                                        0, 10, 100, 100,
                                                        hWnd,
                                                        (HMENU)(LONG_PTR)id,
                                                        LPCS->hInstance,
                                                        (LPVOID)NULL);

                SAVE_IPADDR_HANDLE(pipa->Children[i].hWnd, i);
                SendMessage(pipa->Children[i].hWnd, EM_LIMITTEXT,
                            CHARS_PER_FIELD, 0L);

                pipa->Children[i].lpfnWndProc =
                    (WNDPROC) GetWindowLongPtr(pipa->Children[i].hWnd,
                                               GWLP_WNDPROC);

                SetWindowLongPtr(pipa->Children[i].hWnd,
                                 GWLP_WNDPROC, (LONG_PTR)IPAddressFieldProc);

            }

            SAVE_IPADDR_HANDLE(hWnd, pipa);
            
            IP_OnSetFont(pipa, NULL, FALSE);
            for (i = 0; i < NUM_FIELDS; ++i)
                ShowWindow(pipa->Children[i].hWnd, SW_SHOW);


#undef LPCS
        }
        else
            DestroyWindow(hWnd);
    }
        lResult = 0;
        break;

    case WM_PAINT: /* paint IPADDR window */
    {
        PAINTSTRUCT Ps;
        RECT rect;
        COLORREF TextColor;
        COLORREF cRef;
        HFONT OldFont;

        BeginPaint(hWnd, (LPPAINTSTRUCT)&Ps);
        OldFont = SelectObject( Ps.hdc, pipa->hfont);
        GetClientRect(hWnd, &rect);
        if (pipa->fEnabled)
        {
            TextColor = GetSysColor(COLOR_WINDOWTEXT);
            cRef = GetSysColor(COLOR_WINDOW);
        }
        else
        {
            TextColor = GetSysColor(COLOR_GRAYTEXT);
            cRef = GetSysColor(COLOR_3DFACE);
        }

        FillRectClr(Ps.hdc, &rect, cRef);
        SetRect(&rect, 0, HEAD_ROOM, pipa->uiFillerWidth, (rect.bottom-rect.top));


        SetBkColor(Ps.hdc, cRef);
        SetTextColor(Ps.hdc, TextColor);

        for (i = 0; i < NUM_FIELDS-1; ++i)
        {
            rect.left += pipa->uiFieldWidth + pipa->uiFillerWidth;
            rect.right += rect.left + pipa->uiFillerWidth;
            ExtTextOut(Ps.hdc, rect.left, HEAD_ROOM, ETO_OPAQUE, &rect, SZFILLER, 1, NULL);
        }

        pipa->fPainted = TRUE;

        SelectObject(Ps.hdc, OldFont);
        EndPaint(hWnd, &Ps);
    }
        break;

    case WM_SETFOCUS : /* get focus - display caret */
        EnterField(&(pipa->Children[0]), 0, CHARS_PER_FIELD);
        break;
        
        HANDLE_MSG(pipa, WM_SETFONT, IP_OnSetFont);

    case WM_LBUTTONDOWN : /* left button depressed - fall through */
        SetFocus(hWnd);
        break;

    case WM_ENABLE:
    {
        pipa->fEnabled = (BOOL)wParam;
        for (i = 0; i < NUM_FIELDS; ++i)
        {
            EnableWindow(pipa->Children[i].hWnd, (BOOL)wParam);
        }
        if (pipa->fPainted)    
            InvalidateRect(hWnd, NULL, FALSE);
    }
        break;

    case WM_DESTROY :
        CCDestroyWindow();
        // Restore all the child window procedures before we delete our memory block.
        for (i = 0; i < NUM_FIELDS; ++i)
        {
            SendMessage(pipa->Children[i].hWnd, WM_DESTROY, 0, 0);
            SetWindowLongPtr(pipa->Children[i].hWnd, GWLP_WNDPROC,
                             (LONG_PTR)pipa->Children[i].lpfnWndProc);
        }

        LocalFree(pipa);
        break;

    case WM_COMMAND:
        switch (HIWORD(wParam))
        {
            // One of the fields lost the focus, see if it lost the focus to another field
            // of if we've lost the focus altogether.  If its lost altogether, we must send
            // an EN_KILLFOCUS notification on up the ladder.
            case EN_KILLFOCUS:
            {
                HWND hFocus;

                if (!pipa->fInMessageBox)
                {
                    hFocus = GetFocus();
                    for (i = 0; i < NUM_FIELDS; ++i)
                        if (pipa->Children[i].hWnd == hFocus)
                            break;

                    if (i >= NUM_FIELDS)
                    {
                        SendMessage(pipa->hwndParent, WM_COMMAND,
                                    MAKEWPARAM(GetDlgCtrlID(hWnd),
                                               EN_KILLFOCUS), (LPARAM)hWnd);
                        pipa->bControlInFocus = FALSE;
                    }
                }
            }
            break;

        case EN_SETFOCUS:
        {
            HWND hFocus;

            if (!pipa->fInMessageBox)
            {
                hFocus = (HWND)lParam;

                for (i = 0; i < NUM_FIELDS; ++i)
                    if (pipa->Children[i].hWnd == hFocus)
                        break;

                // send a focus message when the
                if (i < NUM_FIELDS && pipa->bControlInFocus == FALSE)
                {
                    SendMessage(pipa->hwndParent, WM_COMMAND,
                                MAKEWPARAM(GetDlgCtrlID(hWnd),
                                           EN_SETFOCUS), (LPARAM)hWnd);

                    pipa->bControlInFocus = TRUE; // only set the focus once
                }
            }
        }
            break;

        case EN_CHANGE:
            if (pipa->bCancelParentNotify == FALSE)
            {
                SendMessage(pipa->hwndParent, WM_COMMAND,
                            MAKEWPARAM(GetDlgCtrlID(hWnd), EN_CHANGE), (LPARAM)hWnd);

            }
            break;
        }
        break;

        // Get the value of the IP Address.  The address is placed in the DWORD pointed
        // to by lParam and the number of non-blank fields is returned.
        case IPM_GETADDRESS:
        {
            int iFieldValue;
            DWORD dwValue;

            lResult = 0;
            dwValue = 0;
            for (i = 0; i < NUM_FIELDS; ++i)
            {
                iFieldValue = GetFieldValue(&(pipa->Children[i]));
                if (iFieldValue == -1)
                    iFieldValue = 0;
                else
                    ++lResult;
                dwValue = (dwValue << 8) + iFieldValue;
            }
            *((DWORD *)lParam) = dwValue;
        }
        break;

        // Clear all fields to blanks.
        case IPM_CLEARADDRESS:
        {
            pipa->bCancelParentNotify = TRUE;
            for (i = 0; i < NUM_FIELDS; ++i)
            {
                SendMessage(pipa->Children[i].hWnd, WM_SETTEXT,
                            0, (LPARAM) (LPSTR) TEXT(""));
            }
            pipa->bCancelParentNotify = FALSE;
            SendMessage(pipa->hwndParent, WM_COMMAND,
                        MAKEWPARAM(GetDlgCtrlID(hWnd), EN_CHANGE), (LPARAM)hWnd);
        }
        break;

        // Set the value of the IP Address.  The address is in the lParam with the
        // first address byte being the high byte, the second being the second byte,
        // and so on.  A lParam value of -1 removes the address.
        case IPM_SETADDRESS:
        {
            pipa->bCancelParentNotify = TRUE;

            for (i = 0; i < NUM_FIELDS; ++i)
            {
                BYTE bVal = HIBYTE(HIWORD(lParam));
                if (pipa->Children[i].byLow <= bVal &&
                    bVal <= pipa->Children[i].byHigh) {
                    SetFieldValue(pipa, i, bVal);

                } else {
                    lResult = FALSE;
                }

                lParam <<= 8;
            }

            pipa->bCancelParentNotify = FALSE;

            SendMessage(pipa->hwndParent, WM_COMMAND,
                        MAKEWPARAM(GetDlgCtrlID(hWnd), EN_CHANGE), (LPARAM)hWnd);
        }
        break;

    case IPM_SETRANGE:
        if (wParam < NUM_FIELDS && LOBYTE(LOWORD(lParam)) <= HIBYTE(LOWORD(lParam)))
        {
            lResult = MAKEIPRANGE(pipa->Children[wParam].byLow, pipa->Children[wParam].byHigh);
            pipa->Children[wParam].byLow = LOBYTE(LOWORD(lParam));
            pipa->Children[wParam].byHigh = HIBYTE(LOWORD(lParam));
            break;
        }
        lResult = 0;
        break;

        // Set the focus to this IPADDR.
        // wParam = the field number to set focus to, or -1 to set the focus to the
        // first non-blank field.
    case IPM_SETFOCUS:

        if (wParam >= NUM_FIELDS)
        {
            for (wParam = 0; wParam < NUM_FIELDS; ++wParam)
                if (GetFieldValue(&(pipa->Children[wParam])) == -1)   break;
            if (wParam >= NUM_FIELDS)    wParam = 0;
        }
        EnterField(&(pipa->Children[wParam]), 0, CHARS_PER_FIELD);
        break;

        // Determine whether all four subfields are blank
    case IPM_ISBLANK:

        lResult = TRUE;
        for (i = 0; i < NUM_FIELDS; ++i)
        {
            if (GetFieldValue(&(pipa->Children[i])) != -1)
            {
                lResult = FALSE;
                break;
            }
        }
        break;

    default:
        lResult = DefWindowProc( hWnd, wMsg, wParam, lParam );
        break;
    }
    return( lResult );
}




/*
 IPAddressFieldProc() - Edit field window procedure

 This function sub-classes each edit field.
 */
LRESULT IPAddressFieldProc(HWND hWnd,
                                   UINT wMsg,
                                   WPARAM wParam,
                                   LPARAM lParam)
{
    IPADDR *pipa;
    FIELD *pField;
    HWND hIPADDRWindow;
    WORD wChildID;
    LRESULT lresult;

    if (!(hIPADDRWindow = GetParent(hWnd)))
        return 0;

    pipa = (IPADDR *)GET_IPADDR_HANDLE(hIPADDRWindow);
    if (!pipa)
        return 0;
    
    wChildID = (WORD)GET_IPADDR_HANDLE(hWnd);
    pField = &(pipa->Children[wChildID]);

    if (pField->hWnd != hWnd)    
        return 0;

    switch (wMsg)
    {
    case WM_DESTROY:
        DeleteObject((HGDIOBJ)SendMessage(hWnd, WM_GETFONT, 0, 0));
        return 0;

    case WM_CHAR:

        // Typing in the last digit in a field, skips to the next field.
        if (wParam >= TEXT('0') && wParam <= TEXT('9'))
        {
            LRESULT lResult;

            lResult = CallWindowProc(pipa->Children[wChildID].lpfnWndProc,
                                      hWnd, wMsg, wParam, lParam);
            lResult = SendMessage(hWnd, EM_GETSEL, 0, 0L);

            if (lResult == MAKELPARAM(CHARS_PER_FIELD, CHARS_PER_FIELD)
                && ExitField(pipa, wChildID)
                && wChildID < NUM_FIELDS-1)
            {
                EnterField(&(pipa->Children[wChildID+1]),
                           0, CHARS_PER_FIELD);
            }
            return lResult;
        }

        // spaces and periods fills out the current field and then if possible,
        // goes to the next field.
        else if (wParam == FILLER || wParam == SPACE )
        {
            LRESULT lResult;
            lResult = SendMessage(hWnd, EM_GETSEL, 0, 0L);
            if (lResult != 0L && HIWORD(lResult) == LOWORD(lResult)
                && ExitField(pipa, wChildID))
            {
                if (wChildID >= NUM_FIELDS-1)
                    MessageBeep((UINT)-1);
                else
                {
                    EnterField(&(pipa->Children[wChildID+1]),
                               0, CHARS_PER_FIELD);
                }
            }
            return 0;
        }

        // Backspaces go to the previous field if at the beginning of the current field.
        // Also, if the focus shifts to the previous field, the backspace must be
        // processed by that field.
        else if (wParam == BACK_SPACE)
        {
            if (wChildID > 0 && SendMessage(hWnd, EM_GETSEL, 0, 0L) == 0L)
            {
                if (SwitchFields(pipa, wChildID, wChildID-1,
                                 CHARS_PER_FIELD, CHARS_PER_FIELD)
                    && SendMessage(pipa->Children[wChildID-1].hWnd,
                                   EM_LINELENGTH, 0, 0L) != 0L)
                {
                    SendMessage(pipa->Children[wChildID-1].hWnd,
                                wMsg, wParam, lParam);
                }
                return 0;
            }
        }

        // Any other printable characters are not allowed.
        else if (wParam > SPACE)
        {
            MessageBeep((UINT)-1);
            return 0;
        }
        break;

    case WM_KEYDOWN:
        switch (wParam)
        {

            // Arrow keys move between fields when the end of a field is reached.
            case VK_LEFT:
        case VK_RIGHT:
        case VK_UP:
        case VK_DOWN:
            if (GetKeyState(VK_CONTROL) < 0)
            {
                if ((wParam == VK_LEFT || wParam == VK_UP) && wChildID > 0)
                {
                    SwitchFields(pipa, wChildID, wChildID-1,
                                 0, CHARS_PER_FIELD);
                    return 0;
                }
                else if ((wParam == VK_RIGHT || wParam == VK_DOWN)
                         && wChildID < NUM_FIELDS-1)
                {
                    SwitchFields(pipa, wChildID, wChildID+1,
                                 0, CHARS_PER_FIELD);
                    return 0;
                }
            }
            else
            {
                DWORD dwResult;
                WORD wStart, wEnd;

                dwResult = (DWORD)SendMessage(hWnd, EM_GETSEL, 0, 0L);
                wStart = LOWORD(dwResult);
                wEnd = HIWORD(dwResult);
                if (wStart == wEnd)
                {
                    if ((wParam == VK_LEFT || wParam == VK_UP)
                        && wStart == 0
                        && wChildID > 0)
                    {
                        SwitchFields(pipa, wChildID, wChildID-1,
                                     CHARS_PER_FIELD, CHARS_PER_FIELD);
                        return 0;
                    }
                    else if ((wParam == VK_RIGHT || wParam == VK_DOWN)
                             && wChildID < NUM_FIELDS-1)
                    {
                        dwResult = (DWORD)SendMessage(hWnd, EM_LINELENGTH, 0, 0L);
                        if (wStart >= dwResult)
                        {
                            SwitchFields(pipa, wChildID, wChildID+1, 0, 0);
                            return 0;
                        }
                    }
                }
            }
            break;

            // Home jumps back to the beginning of the first field.
            case VK_HOME:
                if (wChildID > 0)
                {
                    SwitchFields(pipa, wChildID, 0, 0, 0);
                    return 0;
                }
            break;

            // End scoots to the end of the last field.
            case VK_END:
                if (wChildID < NUM_FIELDS-1)
                {
                    SwitchFields(pipa, wChildID, NUM_FIELDS-1,
                                 CHARS_PER_FIELD, CHARS_PER_FIELD);
                    return 0;
                }
            break;


        } // switch (wParam)

        break;

    case WM_KILLFOCUS:
        if ( !ExitField( pipa, wChildID ))
        {
            return 0;
        }

    } // switch (wMsg)

    lresult = CallWindowProc( pipa->Children[wChildID].lpfnWndProc,
                             hWnd, wMsg, wParam, lParam);
    return lresult;
}




/*
 Switch the focus from one field to another.
 call
 pipa = Pointer to the IPADDR structure.
 iOld = Field we're leaving.
 iNew = Field we're entering.
 hNew = Window of field to goto
 wStart = First character selected
 wEnd = Last character selected + 1
 returns
 TRUE on success, FALSE on failure.

 Only switches fields if the current field can be validated.
 */
BOOL SwitchFields(IPADDR *pipa, int iOld, int iNew, WORD wStart, WORD wEnd)
{
    if (!ExitField(pipa, iOld))    return FALSE;
    EnterField(&(pipa->Children[iNew]), wStart, wEnd);
    return TRUE;
}



/*
 Set the focus to a specific field's window.
 call
 pField = pointer to field structure for the field.
 wStart = First character selected
 wEnd = Last character selected + 1
 */
void EnterField(FIELD *pField, WORD wStart, WORD wEnd)
{
    SetFocus(pField->hWnd);
    SendMessage(pField->hWnd, EM_SETSEL, wStart, wEnd);
}

void SetFieldValue(IPADDR *pipa, int iField, int iValue)
{
    TCHAR szBuf[CHARS_PER_FIELD+1];
    FIELD* pField = &(pipa->Children[iField]);

    wsprintf(szBuf, TEXT("%d"), iValue);
    SendMessage(pField->hWnd, WM_SETTEXT, 0, (LPARAM) (LPSTR) szBuf);
}

/*
 Exit a field.
 call
 pipa = pointer to IPADDR structure.
 iField = field number being exited.
 returns
 TRUE if the user may exit the field.
 FALSE if he may not.
 */
BOOL ExitField(IPADDR  *pipa, int iField)
{
    FIELD *pField;
    int i;
    NMIPADDRESS nm;
    int iOldValue;

    pField = &(pipa->Children[iField]);
    i = GetFieldValue(pField);
    iOldValue = i;
    
    nm.iField = iField;
    nm.iValue = i;
    
    SendNotifyEx(pipa->hwndParent, pipa->hwnd, IPN_FIELDCHANGED, &nm.hdr, FALSE);
    i = nm.iValue;
    
    if (i != -1) {

        if (i < (int)(UINT)pField->byLow || i > (int)(UINT)pField->byHigh)
        {
            
            if ( i < (int)(UINT) pField->byLow )
            {
                /* too small */
                i = (int)(UINT)pField->byLow;
            }
            else
            {
                /* must be bigger */
                i = (int)(UINT)pField->byHigh;
            }
            SetFieldValue(pipa, iField, i);
            // CHEEBUGBUG: send notify up
            return FALSE;
        }
    } 

    if (iOldValue != i) {
        SetFieldValue(pipa, iField, i);
    }
    return TRUE;
}


/*
 Get the value stored in a field.
 call
 pField = pointer to the FIELD structure for the field.
 returns
 The value (0..255) or -1 if the field has not value.
 */
int GetFieldValue(FIELD *pField)
{
    WORD wLength;
    TCHAR szBuf[CHARS_PER_FIELD+1];
    INT i;

    *(WORD *)szBuf = (sizeof(szBuf)/sizeof(TCHAR)) - 1;
    wLength = (WORD)SendMessage(pField->hWnd,EM_GETLINE,0,(LPARAM)(LPSTR)szBuf);
    if (wLength != 0)
    {
        szBuf[wLength] = TEXT('\0');
        i = StrToInt(szBuf);
        return i;
    }
    else
        return -1;
}



BOOL IsDBCS()
{
    LANGID langid;
    langid = PRIMARYLANGID(GetThreadLocale());
    if (langid == LANG_CHINESE || langid == LANG_JAPANESE || langid == LANG_KOREAN)
    {
        return (TRUE);
    }
    else
    {
        return (FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\hotkey.c ===
/*-----------------------------------------------------------------------
**
** Hotkey.c
**
** Hotkey edit control.
**
**-----------------------------------------------------------------------*/
//
// Win32 REVIEW:
//  See all the Get/SetWindowInt().
//
#include "ctlspriv.h"

#define F_EXT       0x01000000L

#define GWU_VIRTKEY  0
#define GWU_MODS     1*sizeof(ULONG_PTR)
#define GWU_INVALID  2*sizeof(ULONG_PTR)
#define GWU_DEFAULT  3*sizeof(ULONG_PTR)
#define GWU_HFONT    4*sizeof(ULONG_PTR)
#define GWU_YFONT    5*sizeof(ULONG_PTR)
#define NUM_WND_EXTRA (GWU_YFONT+sizeof(ULONG_PTR))

LRESULT CALLBACK HotKeyWndProc(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam);

#ifndef WIN32
#pragma code_seg(CODESEG_INIT)
#endif

BOOL FAR PASCAL InitHotKeyClass(HINSTANCE hInstance)
{
    WNDCLASS wc;

    if (!GetClassInfo(hInstance, HOTKEY_CLASS, &wc))
    {
#ifndef WIN32
        extern LRESULT CALLBACK _HotKeyWndProc(HWND, UINT, WPARAM, LPARAM);
        wc.lpfnWndProc   = _HotKeyWndProc;
#else
        wc.lpfnWndProc   = HotKeyWndProc;
#endif
        wc.lpszClassName = s_szHOTKEY_CLASS;
        wc.style         = CS_GLOBALCLASS;
        wc.hInstance     = hInstance;
        wc.hIcon         = NULL;
        wc.hCursor       = NULL;
        wc.hbrBackground = NULL;
        wc.lpszMenuName  = NULL;
        wc.cbClsExtra    = 0;
        wc.cbWndExtra    = NUM_WND_EXTRA;

        if (!RegisterClass(&wc))
            return FALSE;
    }
    return TRUE;
}

#ifndef WIN32
#pragma code_seg()
#endif


#ifndef WINNT
#pragma data_seg(DATASEG_READONLY)
#endif
const UINT s_Combos[8] = {
                    HKCOMB_NONE,
                    HKCOMB_S,
                    HKCOMB_C,
                    HKCOMB_SC,
                    HKCOMB_A,
                    HKCOMB_SA,
                    HKCOMB_CA,
                    HKCOMB_SCA};
#ifndef WINNT
#pragma data_seg()
#endif

void NEAR PASCAL SetHotKey(HWND hwnd, WORD wVirtKey, WORD wMods, BOOL fSendNotify)
{
    /* don't invalidate if it's the same
     */
    if (wVirtKey == GetWindowInt(hwnd, GWU_VIRTKEY) &&
        wMods == GetWindowInt(hwnd, GWU_MODS))
        return;

    SetWindowInt(hwnd, GWU_VIRTKEY ,wVirtKey);
    SetWindowInt(hwnd, GWU_MODS ,wMods);
    InvalidateRect(hwnd,NULL,TRUE);

    if (fSendNotify) {
        FORWARD_WM_COMMAND(GetParent(hwnd), GetDlgCtrlID(hwnd), hwnd, EN_CHANGE, SendMessage);
    }

    MyNotifyWinEvent(EVENT_OBJECT_VALUECHANGE, hwnd, OBJID_CLIENT, 0);
}

void NEAR PASCAL GetKeyName(UINT vk, LPTSTR lpsz, BOOL fExt)
{
    LONG scan;

    scan = (LONG)MapVirtualKey(vk,0) << 16;
    if (fExt)
        scan |= F_EXT;

    GetKeyNameText(scan,lpsz,50);
}

void NEAR PASCAL PaintHotKey(register HWND hwnd)
{
    TCHAR sz[128];
    TCHAR szPlus[10];
    int cch;
    register HDC hdc;
    UINT wMods;
    UINT wVirtKey;
    PAINTSTRUCT ps;
    int x, y;
    HANDLE hFont;
    // DWORD dwColor;
    // DWORD dwBkColor;

    LocalizedLoadString(IDS_PLUS, szPlus, ARRAYSIZE(szPlus));

    wVirtKey = (UINT) GetWindowInt(hwnd, GWU_VIRTKEY);
    wMods = (UINT) GetWindowInt(hwnd, GWU_MODS);
    if (wVirtKey || wMods)
    {
        sz[0] = 0;
        cch = 0;
        if (wMods & HOTKEYF_CONTROL)
        {
            GetKeyName(VK_CONTROL, sz, FALSE);
            lstrcat(sz,(LPTSTR)szPlus);
        }
        if (wMods & HOTKEYF_SHIFT)
        {
            GetKeyName(VK_SHIFT, sz+lstrlen(sz), FALSE);
            lstrcat(sz,szPlus);
        }
        if (wMods & HOTKEYF_ALT)
        {
            GetKeyName(VK_MENU, sz+lstrlen(sz), FALSE);
            lstrcat(sz,szPlus);
        }

        GetKeyName(wVirtKey, sz+lstrlen(sz), wMods & HOTKEYF_EXT);
    }
    else
        LocalizedLoadString(IDS_NONE,sz,100);

    cch = lstrlen(sz);

    HideCaret(hwnd);

    InvalidateRect(hwnd, NULL, TRUE);
    hdc = BeginPaint(hwnd,&ps);


    hFont = SelectObject(hdc, (HFONT)GetWindowInt(hwnd,GWU_HFONT));

    x = g_cxBorder;
    y = g_cyBorder;

    if (IsWindowEnabled(hwnd))
    {
        SetBkColor(hdc, g_clrWindow);
        SetTextColor(hdc, g_clrWindowText);
        TextOut(hdc,x,y,sz,cch);
    }
    else
    {
        // set the background color to Grayed like edit controls
        SetBkColor(hdc, g_clrBtnFace);
        if (g_clrGrayText)
        {
            SetTextColor(hdc,g_clrGrayText);
            TextOut(hdc,x,y,sz,cch);
        }
        else
        {
            GrayString(hdc,NULL,NULL,(ULONG_PTR)(LPTSTR)sz,cch,x,y,0,0);
        }
    }

    MGetTextExtent(hdc, sz, cch, &x, NULL);
     if (GetFocus() == hwnd)
         SetCaretPos(x+g_cxBorder,
                    g_cyBorder);
    ShowCaret(hwnd);

#if 0
    if (hFont)
        SelectObject(hdc,hFont);
#endif

    EndPaint(hwnd,&ps);
}

void NEAR PASCAL HKMSetRules(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    SetWindowInt(hwnd, GWU_INVALID, wParam);
    SetWindowInt(hwnd, GWU_DEFAULT, lParam);
}

HFONT NEAR PASCAL HKMSetFont(HWND hwnd, HFONT wParam)
{
    HFONT lParam;
    HDC hdc;
    INT cy;

    lParam = (HFONT)GetWindowInt(hwnd,GWU_HFONT);
    SetWindowInt(hwnd,GWU_HFONT,(LONG_PTR)wParam);
    hdc = GetDC(hwnd);
    if (wParam)
        wParam = SelectObject(hdc, wParam);
    MGetTextExtent(hdc, TEXT("C"), 1, NULL, &cy);
    SetWindowInt(hwnd,GWU_YFONT,cy);
    if (wParam)
        SelectObject(hdc, wParam);
    ReleaseDC(hwnd,hdc);
    InvalidateRect(hwnd,NULL,TRUE);
    return lParam;
}

LRESULT CALLBACK HotKeyWndProc(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    WORD wVirtKey;
    WORD wMods;
    RECT rc;
    HDC hdc;

    switch (wMsg)
    {
    case WM_NCCREATE:
        SetWindowBits(hwnd, GWL_EXSTYLE, WS_EX_CLIENTEDGE, WS_EX_CLIENTEDGE);
        CCCreateWindow();
        InitGlobalColors();
        return TRUE;

    case WM_DESTROY:
        CCDestroyWindow();
        break;

    case WM_CREATE:
        SetHotKey(hwnd, 0, 0, FALSE);
        HKMSetRules(hwnd, 0, 0);
        HKMSetFont(hwnd, g_hfontSystem);
        break;

    case WM_SETFOCUS:
        InvalidateRect(hwnd,NULL,TRUE);
        CreateCaret(hwnd,NULL,0,(int)GetWindowInt(hwnd,GWU_YFONT));
        ShowCaret(hwnd);
        break;

    case WM_KILLFOCUS:
        if (!GetWindowInt(hwnd, GWU_VIRTKEY))
        SetHotKey(hwnd, 0, 0, TRUE);
        DestroyCaret();
        break;

    case WM_GETDLGCODE:
        return DLGC_WANTCHARS | DLGC_WANTARROWS; // | DLGC_WANTALLKEYS;

    case HKM_SETHOTKEY:
        SetHotKey(hwnd, LOBYTE(wParam), HIBYTE(wParam), FALSE);
        break;

    case HKM_GETHOTKEY:
        return (256*(BYTE)GetWindowInt(hwnd, GWU_MODS)) +
                ((BYTE)GetWindowInt(hwnd, GWU_VIRTKEY));
        break;

    case HKM_SETRULES:
        HKMSetRules(hwnd, wParam, LOWORD(lParam));
        break;

    case WM_LBUTTONDOWN:
        SetFocus(hwnd);
        break;

    case WM_SYSKEYDOWN:
    case WM_KEYDOWN:
        switch (wParam)
        {
        case VK_RETURN:
        case VK_TAB:
        case VK_SPACE:
        case VK_DELETE:
        case VK_ESCAPE:
        case VK_BACK:
        case VK_LWIN:
        case VK_RWIN:
        case VK_APPS:
            SetHotKey(hwnd, 0, 0, TRUE);
            return DefWindowProc(hwnd,wMsg,wParam,lParam);

        case VK_MENU:
        case VK_SHIFT:
        case VK_CONTROL:
            wVirtKey = 0;
            goto SetNewHotKey;

        default:
            wVirtKey = (WORD) wParam;
SetNewHotKey:
            wMods = 0;
            if (GetKeyState(VK_CONTROL) < 0)
                wMods |= HOTKEYF_CONTROL;
            if (GetKeyState(VK_SHIFT) < 0)
                wMods |= HOTKEYF_SHIFT;
            if (GetKeyState(VK_MENU) < 0)
                wMods |= HOTKEYF_ALT;

            #define IsFUNKEY(vk) ((vk) >= VK_F1 && (vk) <= VK_F24)
            #define IsNUMKEY(vk) ((vk) >= VK_NUMPAD0 && (vk) <= VK_DIVIDE)

            //
            //  dont enforce any rules on the Function keys or
            //  on the number pad keys.
            //
            // if this combination is invalid, use the default
            if (!IsFUNKEY(wVirtKey) &&
                !IsNUMKEY(wVirtKey) &&
                (s_Combos[wMods] & GetWindowInt(hwnd, GWU_INVALID)))
            {
                wMods = (WORD)GetWindowInt(hwnd, GWU_DEFAULT);
            }

            if (lParam & F_EXT)
                wMods |= HOTKEYF_EXT;

            SetHotKey(hwnd, wVirtKey, wMods, TRUE);
            break;
        }
        break;

    case WM_SYSKEYUP:
    case WM_CHAR:
    case WM_SYSCHAR:
    case WM_KEYUP:
        if (!GetWindowInt(hwnd, GWU_VIRTKEY))
            SetHotKey(hwnd, 0, 0, TRUE);
        break;

    case WM_GETFONT:
        return GetWindowInt(hwnd,GWU_HFONT);

    case WM_SETFONT:
        return (LRESULT)(UINT_PTR)HKMSetFont(hwnd, (HFONT)wParam);

    case WM_PAINT:
        PaintHotKey(hwnd);
        break;

    case WM_ERASEBKGND:
        HideCaret(hwnd);
        hdc = GetDC(hwnd);
        GetClientRect(hwnd, &rc);
        if (IsWindowEnabled(hwnd)) {
            FillRect(hdc, &rc, g_hbrWindow);
        } else {
            FillRect(hdc, &rc, g_hbrBtnFace);
        }
        ReleaseDC(hwnd, hdc);
        // lParam = DefWindowProc(hwnd,wMsg,wParam,lParam);
        ShowCaret(hwnd);
        return TRUE;

    case WM_GETOBJECT:
        if( lParam == OBJID_QUERYCLASSNAMEIDX )
            return MSAA_CLASSNAMEIDX_HOTKEY;
        goto DoDefault;

    case WM_ENABLE:
        InvalidateRect(hwnd, NULL, TRUE);
        goto DoDefault;

    default:
DoDefault:
        return DefWindowProc(hwnd,wMsg,wParam,lParam);
    }
    return 0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\listview.h ===
// LISTVIEW PRIVATE DECLARATIONS

#ifndef _INC_LISTVIEW
#define _INC_LISTVIEW

#include "selrange.h"
#include <urlmon.h>
#define COBJMACROS
#include <iimgctx.h>

//
//  Apps steal our userdata space so make sure we don't use it.
//
#undef GWLP_USERDATA
#undef GWL_USERDATA

// define this to get single click activate to activate immediately.
// if a second click comes to the same window within a double-click-timeout
// period, we blow it off. we try to keep focus on the app that launched,
// but we can't figure out how to do that yet... with this not defined,
// the single-click-activate waits a double-click-timeout before activating.
//
//#define ONECLICKHAPPENED

// REVIEW: max items in a OWNERDATA listview
// due to currently unknown reasons the listview will not handle much more
// items than this.  Since this number is very high, no time has yet been
// spent on finding the reason(s).
//
#define MAX_LISTVIEWITEMS (100000000)

#define CLIP_HEIGHT                ( (plv->cyLabelChar * 2) + g_cyEdge)
#define CLIP_HEIGHT_DI             ( (plvdi->plv->cyLabelChar * 2) + g_cyEdge)

// Timer IDs
#define IDT_NAMEEDIT    42
#define IDT_SCROLLWAIT  43
#define IDT_MARQUEE     44
#define IDT_ONECLICKOK  45
#define IDT_ONECLICKHAPPENED 46

//
//  use g_cxIconSpacing   when you want the the global system metric
//  use lv_cxIconSpacing  when you want the padded size of "icon" in a ListView
//
extern int g_cxIcon;
extern int g_cyIcon;
#define lv_cxIconSpacing  plv->cxIconSpacing
#define lv_cyIconSpacing  plv->cyIconSpacing

#define  g_cxIconOffset ((g_cxIconSpacing - g_cxIcon) / 2)
#define  g_cyIconOffset (g_cyBorder * 2)    // NOTE: Must be >= cyIconMargin!

#define DT_LV       (DT_CENTER | DT_SINGLELINE | DT_NOPREFIX | DT_EDITCONTROL)
#define DT_LVWRAP   (DT_CENTER | DT_WORDBREAK | DT_NOPREFIX | DT_EDITCONTROL)
#define CCHLABELMAX MAX_PATH  // BUGBUG dangerous???

BOOL FAR ListView_Init(HINSTANCE hinst);


LRESULT CALLBACK _export ListView_WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
#define ListView_DefProc  DefWindowProc

typedef struct _IMAGE IMAGE;

typedef struct _LISTITEM    // li
{
    LPTSTR pszText;
    POINT pt;
    short iImage;
    short cxSingleLabel;
    short cxMultiLabel;
    short cyFoldedLabel;
    short cyUnfoldedLabel;
    short iWorkArea;        // Which workarea do I belong

    WORD state;     // LVIS_*
    short iIndent;
    LPARAM lParam;

    // Region listview stuff
    HRGN hrgnIcon;      // Region which describes the icon for this item
    POINT ptRgn;        // Location that this item's hrgnIcon was calculated for
    RECT rcTextRgn;
    
} LISTITEM;

// Report view sub-item structure

typedef struct _LISTSUBITEM
{
    LPTSTR pszText;
    short iImage;
    WORD state;
} LISTSUBITEM, *PLISTSUBITEM;


#define COLUMN_VIEW

#define LV_HDPA_GROW   16  // Grow chunk size for DPAs
#define LV_HIML_GROW   8   // Grow chunk size for ImageLists

typedef struct _LV
{
    CONTROLINFO ci;     // common control header info

    BOOL fNoDismissEdit:1;  // don't dismiss in-place edit control
    BOOL fButtonDown:1;     // we're tracking the mouse with a button down
    BOOL fOneClickOK:1;     // true from creation to double-click-timeout
    BOOL fOneClickHappened:1; // true from item-activate to double-click-timeout
    BOOL fPlaceTooltip:1;   // should we do the placement of tooltip over the text?
    BOOL fImgCtxComplete:1; // TRUE if we have complete bk image
    BOOL fNoEmptyText:1;    // we don't have text for an empty view.

    HDPA hdpa;          // item array structure
    DWORD flags;        // LVF_ state bits
    DWORD exStyle;      // the listview LVM_SETEXTENDEDSTYLE
    DWORD dwExStyle;    // the windows ex style
    HFONT hfontLabel;   // font to use for labels
    COLORREF clrBk;     // Background color
    COLORREF clrBkSave; // Background color saved during disable
    COLORREF clrText;   // text color
    COLORREF clrTextBk; // text background color
    HBRUSH hbrBk;
    HANDLE hheap;        // The heap to use to allocate memory from.
    int cyLabelChar;    // height of '0' in hfont
    int cxLabelChar;    // width of '0'
    int cxEllipses;     // width of "..."
    int iDrag;          // index of item being dragged
    int iFocus;         // index of currently-focused item
    int iMark;          // index of "mark" for range selection
    int iItemDrawing;   // item currently being drawn
    int iFirstChangedNoRedraw;  // Index of first item added during no redraw.
    UINT stateCallbackMask; // item state callback mask
    SIZE sizeClient;      // current client rectangle
    int nWorkAreas;                            // Number of workareas
    LPRECT prcWorkAreas;      // The workarea rectangles -- nWorkAreas of them.
    UINT nSelected;
    UINT uDBCSChar;         // DBCS character for incremental search
    int iPuntChar;
    HRGN hrgnInval;
    HWND hwndToolTips;      // handle of the tooltip window for this view
    int iTTLastHit;         // last item hit for text
    int iTTLastSubHit;      // last subitem hit for text
    LPTSTR pszTip;          // buffer for tip

    // Small icon view fields

    HIMAGELIST himlSmall;   // small icons
    int cxSmIcon;          // image list x-icon size
    int cySmIcon;          // image list y-icon size
    int xOrigin;        // Horizontal scroll posiiton
    int cxItem;         // Width of small icon items
    int cyItem;         // item height
    int cItemCol;       // Number of items per column

    int cxIconSpacing;
    int cyIconSpacing;

    // Icon view fields

    HIMAGELIST himl;
    int cxIcon;             // image list x-icon size
    int cyIcon;             // image list y-icon size
    HDPA hdpaZOrder;        // Large icon Z-order array
    POINT ptOrigin;         // Scroll position
    RECT rcView;            // Bounds of all icons (ptOrigin relative)
    int iFreeSlot;          // Most-recently found free icon slot since last reposition (-1 if none)

    HWND hwndEdit;          // edit field for edit-label-in-place
    int iEdit;              // item being edited
    WNDPROC pfnEditWndProc; // edit field subclass proc

    NMITEMACTIVATE nmOneClickHappened;

#define SMOOTHSCROLLLIMIT 10

    int iScrollCount; // how many times have we gotten scroll messages before an endscroll?

    // Report view fields

    int cCol;
    HDPA hdpaSubItems;
    HWND hwndHdr;           // Header control
    int yTop;               // First usable pixel (below header)
    int xTotalColumnWidth;  // Total width of all columns
    POINTL ptlRptOrigin;    // Origin of Report.
    int iSelCol;            // to handle column width changing. changing col
    int iSelOldWidth;       // to handle column width changing. changing col width
    int cyItemSave;        // in ownerdrawfixed mode, we put the height into cyItem.  use this to save the old value

    // state image stuff
    HIMAGELIST himlState;
    int cxState;
    int cyState;

    // OWNERDATA stuff
    ILVRange *plvrangeSel;  // selection ranges
    ILVRange *plvrangeCut;  // Cut Range    
    int cTotalItems;        // number of items in the ownerdata lists
    int iDropHilite;        // which item is drop hilited, assume only 1
    int iMSAAMin, iMSAAMax; // keep track of what we told accessibility

    UINT uUnplaced;     // items that have been added but not placed (pt.x == RECOMPUTE)

    int iHot;  // which item is hot
    HFONT hFontHot; // the underlined font .. assume this has the same size metrics as hFont
    int iNoHover; // don't allow hover select on this guy because it's the one we just hover selected (avoids toggling)
    DWORD dwHoverTime;      // Defaults to HOVER_DEFAULT
    HCURSOR hCurHot; // the cursor when we're over a hot item

    // BkImage stuff
    IImgCtx *pImgCtx;       // Background image interface
    ULONG ulBkImageFlags;   // LVBKIF_*
    HBITMAP hbmBkImage;     // Background bitmap (LVBKIF_SOURCE_HBITMAP)
    LPTSTR pszBkImage;      // Background URL (LVBKIF_SOURCE_URL)
    int xOffsetPercent;     // X offset for LVBKIF_STYLE_NORMAL images
    int yOffsetPercent;     // Y offset for LVBKIF_STYLE_NORMAL images
    HPALETTE hpalHalftone;  // Palette for drawing bk images BUGBUG ImgCtx supposed to do this

    LPTSTR pszEmptyText;    // buffer for empty view text.

    COLORREF clrHotlight;     // Hot light color set explicitly for this listview.
    POINT ptCapture;

    //incremental search stuff
    ISEARCHINFO is;
} LV;

#define LV_StateImageValue(pitem) ((int)(((DWORD)((pitem)->state) >> 12) & 0xF))
#define LV_StateImageIndex(pitem) (LV_StateImageValue(pitem) - 1)

// listview flag values
#define LVF_FOCUSED       0x0001
#define LVF_VISIBLE       0x0002
#define LVF_ERASE         0x0004 /* is hrgnInval to be erased? */
#define LVF_NMEDITPEND    0x0008
#define LVF_REDRAW        0x0010 /* Value from WM_SETREDRAW message */
#define LVF_ICONPOSSML    0x0020 /* X, Y coords are in small icon view */
#define LVF_INRECOMPUTE   0x0040 /* Check to make sure we are not recursing */
#define LVF_UNFOLDED      0x0080
#define LVF_FONTCREATED   0x0100 /* we created the LV font */
#define LVF_SCROLLWAIT    0x0200 /* we're waiting to scroll */
#define LVF_COLSIZESET    0x0400 /* Has the caller explictly set width for list view */
#define LVF_USERBKCLR     0x0800 /* user set the bk color (don't follow syscolorchange) */
#define LVF_ICONSPACESET  0x1000 /* the user has set the icon spacing */
#define LVF_CUSTOMFONT    0x2000 /* there is at least one item with a custom font */

#if defined(FE_IME) || !defined(WINNT)
#define LVF_DONTDRAWCOMP  0x4000 /* do not draw IME composition if true */
#define LVF_INSERTINGCOMP 0x8000 /* Avoid recursion */
#endif
#define LVF_INRECALCREGION  0x00010000 /* prevents recursion in RecalcRegion */

#define ENTIRE_REGION   1

// listview DrawItem flags
#define LVDI_NOIMAGE            0x0001  // don't draw image
#define LVDI_TRANSTEXT          0x0002  // draw text transparently in black
#define LVDI_NOWAYFOCUS         0x0004  // don't allow focus to drawing
#define LVDI_FOCUS              0x0008  // focus is set (for drawing)
#define LVDI_SELECTED           0x0010  // draw selected text
#define LVDI_SELECTNOFOCUS      0x0020
#define LVDI_HOTSELECTED        0x0040
#define LVDI_UNFOLDED           0x0080  // draw the item umfolded (forced)

typedef struct {
    LV* plv;
    LPPOINT lpptOrg;
    LPRECT prcClip;
    UINT flags;

    LISTITEM FAR* pitem;

    DWORD dwCustom;
    NMLVCUSTOMDRAW nmcd;
} LVDRAWITEM, *PLVDRAWITEM;

// listview child control ids
#define LVID_HEADER             0

// Instance data pointer access functions

#define ListView_GetPtr(hwnd)      (LV*)GetWindowPtr(hwnd, 0)
#define ListView_SetPtr(hwnd, p)   (LV*)SetWindowPtr(hwnd, 0, p)

// view type check functions

#define ListView_IsIconView(plv)    (((plv)->ci.style & (UINT)LVS_TYPEMASK) == (UINT)LVS_ICON)
#define ListView_IsSmallView(plv)   (((plv)->ci.style & (UINT)LVS_TYPEMASK) == (UINT)LVS_SMALLICON)
#define ListView_IsListView(plv)    (((plv)->ci.style & (UINT)LVS_TYPEMASK) == (UINT)LVS_LIST)
#define ListView_IsReportView(plv)  (((plv)->ci.style & (UINT)LVS_TYPEMASK) == (UINT)LVS_REPORT)

#define ListView_IsOwnerData( plv )     (plv->ci.style & (UINT)LVS_OWNERDATA)
#define ListView_CheckBoxes(plv)        (plv->exStyle & LVS_EX_CHECKBOXES)
#define ListView_FullRowSelect(plv)     (plv->exStyle & LVS_EX_FULLROWSELECT)
#define ListView_IsInfoTip(plv)         (plv->exStyle & LVS_EX_INFOTIP)
#define ListView_OwnerDraw(plv)         (plv->ci.style & LVS_OWNERDRAWFIXED)
#define ListView_IsLabelTip(plv)        (plv->exStyle & LVS_EX_LABELTIP)

// Some helper macros for checking some of the flags...
#define ListView_RedrawEnabled(plv) ((plv->flags & (LVF_REDRAW | LVF_VISIBLE)) == (LVF_REDRAW|LVF_VISIBLE))

// The hdpaZorder is acutally an array of DWORDS which contains the
// indexes of the items and not actual pointers...
// NOTE: linear search! this can be slow
#define ListView_ZOrderIndex(plv, i) DPA_GetPtrIndex((plv)->hdpaZOrder, IntToPtr(i))

// Message handler functions (listview.c):

LRESULT CALLBACK _export ListView_WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

BOOL NEAR ListView_NotifyCacheHint( LV* plv, int iFrom, int iTo );
void NEAR ListView_NotifyRecreate(LV *plv);
BOOL NEAR ListView_OnCreate(LV* plv, CREATESTRUCT FAR* lpCreateStruct);
void NEAR ListView_OnNCDestroy(LV* plv);
void NEAR ListView_OnPaint(LV* plv, HDC hdc);
BOOL NEAR ListView_OnEraseBkgnd(LV* plv, HDC hdc);
void NEAR ListView_OnCommand(LV* plv, int id, HWND hwndCtl, UINT codeNotify);
void NEAR ListView_OnEnable(LV* plv, BOOL fEnable);
BOOL NEAR ListView_OnWindowPosChanging(LV* plv, WINDOWPOS FAR* lpwpos);
void NEAR ListView_OnWindowPosChanged(LV* plv, const WINDOWPOS FAR* lpwpos);
void NEAR ListView_OnSetFocus(LV* plv, HWND hwndOldFocus);
void NEAR ListView_OnKillFocus(LV* plv, HWND hwndNewFocus);
void NEAR ListView_OnKey(LV* plv, UINT vk, BOOL fDown, int cRepeat, UINT flags);
BOOL NEAR ListView_OnImeComposition(LV* plv, WPARAM wParam, LPARAM lParam);
#ifndef UNICODE
BOOL FAR PASCAL SameDBCSChars(LPTSTR lpsz, WORD w);
#endif
void NEAR ListView_OnChar(LV* plv, UINT ch, int cRepeat);
void NEAR ListView_OnButtonDown(LV* plv, BOOL fDoubleClick, int x, int y, UINT keyFlags);
void NEAR ListView_OnLButtonUp(LV* plv, int x, int y, UINT keyFlags);
void NEAR ListView_OnCancelMode(LV* plv);
void NEAR ListView_OnTimer(LV* plv, UINT id);
void NEAR ListView_SetupPendingNameEdit(LV* plv);
#define ListView_CancelPendingEdit(plv) ListView_CancelPendingTimer(plv, LVF_NMEDITPEND, IDT_NAMEEDIT)
#define ListView_CancelScrollWait(plv) ListView_CancelPendingTimer(plv, LVF_SCROLLWAIT, IDT_SCROLLWAIT)
BOOL NEAR ListView_CancelPendingTimer(LV* plv, UINT fFlag, int idTimer);
void NEAR ListView_OnHScroll(LV* plv, HWND hwndCtl, UINT code, int pos);
void NEAR ListView_OnVScroll(LV* plv, HWND hwndCtl, UINT code, int pos);
BOOL NEAR ListView_CommonArrange(LV* plv, UINT style, HDPA hdpaSort);
BOOL NEAR ListView_CommonArrangeEx(LV* plv, UINT style, HDPA hdpaSort, int iWorkArea);
BOOL NEAR ListView_OnSetCursor(LV* plv, HWND hwndCursor, UINT codeHitTest, UINT msg);
UINT NEAR ListView_OnGetDlgCode(LV* plv, MSG FAR* lpmsg);
HBRUSH NEAR ListView_OnCtlColor(LV* plv, HDC hdc, HWND hwndChild, int type);
void NEAR ListView_OnSetFont(LV* plvCtl, HFONT hfont, BOOL fRedraw);
HFONT NEAR ListView_OnGetFont(LV* plv);
void NEAR ListViews_OnTimer(LV* plv, UINT id);
void NEAR ListView_OnWinIniChange(LV* plv, WPARAM wParam, LPARAM lParam);
void NEAR PASCAL ListView_OnSysColorChange(LV* plv);
void NEAR ListView_OnSetRedraw(LV* plv, BOOL fRedraw);
HIMAGELIST NEAR ListView_OnCreateDragImage(LV *plv, int iItem, LPPOINT lpptUpLeft);
BOOL FAR PASCAL ListView_ISetColumnWidth(LV* plv, int iCol, int cx, BOOL fExplicit);

typedef void (FAR PASCAL *SCROLLPROC)(LV*, int dx, int dy, UINT uSmooth);
void FAR PASCAL ListView_ComOnScroll(LV* plv, UINT code, int posNew, int sb,
                                     int cLine, int cPage);

#ifdef UNICODE
BOOL NEAR ListView_OnGetItemA(LV* plv, LV_ITEMA FAR* plvi);
BOOL NEAR ListView_OnSetItemA(LV* plv, LV_ITEMA FAR* plvi);
int NEAR ListView_OnInsertItemA(LV* plv, LV_ITEMA FAR* plvi);
int  NEAR ListView_OnFindItemA(LV* plv, int iStart, LV_FINDINFOA FAR* plvfi);
int NEAR ListView_OnGetStringWidthA(LV* plv, LPCSTR psz, HDC hdc);
BOOL NEAR ListView_OnGetColumnA(LV* plv, int iCol, LV_COLUMNA FAR* pcol);
BOOL NEAR ListView_OnSetColumnA(LV* plv, int iCol, LV_COLUMNA FAR* pcol);
int NEAR ListView_OnInsertColumnA(LV* plv, int iCol, LV_COLUMNA FAR* pcol);
int NEAR PASCAL ListView_OnGetItemTextA(LV* plv, int i, LV_ITEMA FAR *lvitem);
BOOL WINAPI ListView_OnSetItemTextA(LV* plv, int i, int iSubItem, LPCSTR pszText);
BOOL WINAPI ListView_OnGetBkImageA(LV* plv, LPLVBKIMAGEA pbiA);
BOOL WINAPI ListView_OnSetBkImageA(LV* plv, LPLVBKIMAGEA pbiA);
#endif

BOOL ListView_IsItemUnfolded2(LV* plv, int iItem, int iSubItem, LPTSTR pszText, int cchTextMax);
BOOL WINAPI ListView_OnSetBkImage(LV* plv, LPLVBKIMAGE pbi);
BOOL WINAPI ListView_OnGetBkImage(LV* plv, LPLVBKIMAGE pbi);
BOOL NEAR ListView_OnSetBkColor(LV* plv, COLORREF clrBk);
HIMAGELIST NEAR ListView_OnSetImageList(LV* plv, HIMAGELIST himl, BOOL fSmallImages);
BOOL NEAR ListView_OnDeleteAllItems(LV* plv);
int  NEAR ListView_OnInsertItem(LV* plv, const LV_ITEM FAR* plvi);
BOOL NEAR ListView_OnDeleteItem(LV* plv, int i);
BOOL NEAR ListView_OnReplaceItem(LV* plv, const LV_ITEM FAR* plvi);
int  NEAR ListView_OnFindItem(LV* plv, int iStart, const LV_FINDINFO FAR* plvfi);
BOOL NEAR ListView_OnSetItemPosition(LV* plv, int i, int x, int y);
BOOL NEAR ListView_OnSetItem(LV* plv, const LV_ITEM FAR* plvi);
BOOL NEAR ListView_OnGetItem(LV* plv, LV_ITEM FAR* plvi);
BOOL NEAR ListView_OnGetItemPosition(LV* plv, int i, POINT FAR* ppt);
BOOL NEAR ListView_OnEnsureVisible(LV* plv, int i, BOOL fPartialOK);
BOOL NEAR ListView_OnScroll(LV* plv, int dx, int dy);
int NEAR ListView_OnHitTest(LV* plv, LV_HITTESTINFO FAR* pinfo);
int NEAR ListView_OnGetStringWidth(LV* plv, LPCTSTR psz, HDC hdc);
BOOL NEAR ListView_OnGetItemRect(LV* plv, int i, RECT FAR* prc);
int NEAR ListView_OnInsertItem(LV* plv, const LV_ITEM FAR* plvi);
BOOL NEAR ListView_OnRedrawItems(LV* plv, int iFirst, int iLast);
int NEAR ListView_OnGetNextItem(LV* plv, int i, UINT flags);
BOOL NEAR ListView_OnSetColumnWidth(LV* plv, int iCol, int cx);
int NEAR ListView_OnGetColumnWidth(LV* plv, int iCol);
void NEAR ListView_OnStyleChanging(LV* plv, UINT gwl, LPSTYLESTRUCT pinfo);
void NEAR ListView_OnStyleChanged(LV* plv, UINT gwl, LPSTYLESTRUCT pinfo);
int NEAR ListView_OnGetTopIndex(LV* plv);
int NEAR ListView_OnGetCountPerPage(LV* plv);
BOOL NEAR ListView_OnGetOrigin(LV* plv, POINT FAR* ppt);
int NEAR PASCAL ListView_OnGetItemText(LV* plv, int i, LV_ITEM FAR *lvitem);
BOOL WINAPI ListView_OnSetItemText(LV* plv, int i, int iSubItem, LPCTSTR pszText);
HIMAGELIST NEAR ListView_OnGetImageList(LV* plv, int iImageList);

UINT NEAR PASCAL ListView_OnGetItemState(LV* plv, int i, UINT mask);
BOOL NEAR PASCAL ListView_OnSetItemState(LV* plv, int i, UINT data, UINT mask);

// Private functions (listview.c):

BOOL NEAR ListView_Notify(LV* plv, int i, int iSubItem, int code);
void NEAR ListView_GetRects(LV* plv, int i,
        RECT FAR* prcIcon, RECT FAR* prcLabel,
        RECT FAR* prcBounds, RECT FAR* prcSelectBounds);
BOOL NEAR ListView_DrawItem(PLVDRAWITEM);

#define ListView_InvalidateItem(p,i,s,r) ListView_InvalidateItemEx(p,i,s,r,0)
void NEAR ListView_InvalidateItemEx(LV* plv, int i, BOOL fSelectionOnly,
    UINT fRedraw, UINT maskChanged);

BOOL NEAR ListView_StartDrag(LV* plv, int iDrag, int x, int y);
void NEAR ListView_TypeChange(LV* plv, DWORD styleOld);
void NEAR PASCAL ListView_DeleteHrgnInval(LV* plv);

void NEAR ListView_Redraw(LV* plv, HDC hdc, RECT FAR* prc);
void NEAR ListView_RedrawSelection(LV* plv);
BOOL NEAR ListView_FreeItem(LV* plv, LISTITEM FAR* pitem);
void ListView_FreeSubItem(PLISTSUBITEM plsi);
LISTITEM FAR* NEAR ListView_CreateItem(LV* plv, const LV_ITEM FAR* plvi);
void NEAR ListView_UpdateScrollBars(LV* plv);

int NEAR ListView_SetFocusSel(LV* plv, int iNewFocus, BOOL fSelect, BOOL fDeselectAll, BOOL fToggleSel);

void NEAR ListView_GetRectsOwnerData(LV* plv, int iItem,
        RECT FAR* prcIcon, RECT FAR* prcLabel, RECT FAR* prcBounds,
        RECT FAR* prcSelectBounds, LISTITEM* pitem);

void ListView_CalcMinMaxIndex( LV* plv, PRECT prcBounding, int* iMin, int* iMax );
int ListView_LCalcViewItem( LV* plv, int x, int y );
void LVSeeThruScroll(LV *plv, LPRECT lprcUpdate);

BOOL NEAR ListView_UnfoldRects(LV* plv, int iItem,
                               RECT FAR* prcIcon, RECT FAR* prcLabel,
                               RECT FAR* prcBounds, RECT FAR* prcSelectBounds);

__inline int ListView_Count(LV *plv)
{
    ASSERT(ListView_IsOwnerData(plv) || plv->cTotalItems == DPA_GetPtrCount(plv->hdpa));
    return plv->cTotalItems;
}

// Forcing (i) to UINT lets us catch bogus negative numbers, too.
#define ListView_IsValidItemNumber(plv, i) ((UINT)(i) < (UINT)ListView_Count(plv))


#define ListView_GetItemPtr(plv, i)         ((LISTITEM FAR*)DPA_GetPtr((plv)->hdpa, (i)))

#ifdef DEBUG
#define ListView_FastGetItemPtr(plv, i)     ((LISTITEM FAR*)DPA_GetPtr((plv)->hdpa, (i)))
#define ListView_FastGetZItemPtr(plv, i)    ((LISTITEM FAR*)DPA_GetPtr((plv)->hdpa, \
                                                  (int)OFFSETOF(DPA_GetPtr((plv)->hdpaZOrder, (i)))))

#else
#define ListView_FastGetItemPtr(plv, i)     ((LISTITEM FAR*)DPA_FastGetPtr((plv)->hdpa, (i)))
#define ListView_FastGetZItemPtr(plv, i)    ((LISTITEM FAR*)DPA_FastGetPtr((plv)->hdpa, \
                                                  (int)OFFSETOF(DPA_FastGetPtr((plv)->hdpaZOrder, (i)))))

#endif

BOOL NEAR ListView_CalcMetrics();
void NEAR PASCAL ListView_ColorChange();
void NEAR PASCAL ListView_DrawBackground(LV* plv, HDC hdc, RECT *prcClip);

BOOL NEAR ListView_NeedsEllipses(HDC hdc, LPCTSTR pszText, RECT FAR* prc, int FAR* pcchDraw, int cxEllipses);
int NEAR ListView_CompareString(LV* plv, int i, LPCTSTR pszFind, UINT flags, int iLen);
int NEAR ListView_GetLinkedTextWidth(HDC hdc, LPCTSTR psz, UINT cch, BOOL bLink);

int NEAR ListView_GetCxScrollbar(LV* plv);
int NEAR ListView_GetCyScrollbar(LV* plv);
DWORD NEAR ListView_GetWindowStyle(LV* plv);
#define ListView_GetScrollInfo(plv, flag, lpsi)                             \
    ((plv)->exStyle & LVS_EX_FLATSB ?                                       \
        FlatSB_GetScrollInfo((plv)->ci.hwnd, (flag), (lpsi)) :              \
        GetScrollInfo((plv)->ci.hwnd, (flag), (lpsi)))
int ListView_SetScrollInfo(LV *plv, int fnBar, LPSCROLLINFO lpsi, BOOL fRedraw);
#define ListView_SetScrollRange(plv, flag, min, max, fredraw)               \
    ((plv)->exStyle & LVS_EX_FLATSB ?                                       \
        FlatSB_SetScrollRange((plv)->ci.hwnd, (flag), (min), (max), (fredraw)) : \
        SetScrollRange((plv)->ci.hwnd, (flag), (min), (max), (fredraw)))

// lvicon.c functions

BOOL NEAR ListView_OnArrange(LV* plv, UINT style);
HWND NEAR ListView_OnEditLabel(LV* plv, int i, LPTSTR pszText);

int ListView_IItemHitTest(LV* plv, int x, int y, UINT FAR* pflags, int *piSubItem);
void NEAR ListView_IGetRects(LV* plv, LISTITEM FAR* pitem, RECT FAR* prcIcon,
        RECT FAR* prcLabel, LPRECT prcBounds);
void NEAR ListView_ScaleIconPositions(LV* plv, BOOL fSmallIconView);
void NEAR ListView_IGetRectsOwnerData(LV* plv, int iItem, RECT FAR* prcIcon,
        RECT FAR* prcLabel, LISTITEM* pitem, BOOL fUsepitem);
void NEAR PASCAL _ListView_GetRectsFromItem(LV* plv, BOOL bSmallIconView,
                                            LISTITEM FAR *pitem,
                                            LPRECT prcIcon, LPRECT prcLabel, LPRECT prcBounds, LPRECT prcSelectBounds);

__inline void ListView_SetSRecompute(LISTITEM *pitem)
{
    pitem->cxSingleLabel = SRECOMPUTE;
    pitem->cxMultiLabel = SRECOMPUTE;
    pitem->cyFoldedLabel = SRECOMPUTE;
    pitem->cyUnfoldedLabel = SRECOMPUTE;
}

void NEAR ListView_Recompute(LV* plv);

void NEAR ListView_RecomputeLabelSize(LV* plv, LISTITEM FAR* pitem, int i, HDC hdc, BOOL fUsepitem);

BOOL NEAR ListView_SetIconPos(LV* plv, LISTITEM FAR* pitem, int iSlot, int cSlot);
BOOL NEAR ListView_IsCleanRect(LV * plv, RECT * prc, int iExcept, BOOL * pfUpdate, HDC hdc);
int NEAR ListView_FindFreeSlot(LV* plv, int i, int iSlot, int cSlot, BOOL FAR* pfUpdateSB, BOOL FAR* pfAppend, HDC hdc);
int NEAR ListView_CalcHitSlot( LV* plv, POINT pt, int cslot );

void NEAR ListView_GetViewRect2(LV* plv, RECT FAR* prcView, int cx, int cy);
int CALLBACK ArrangeIconCompare(LISTITEM FAR* pitem1, LISTITEM FAR* pitem2, LPARAM lParam);
int NEAR ListView_GetSlotCountEx(LV* plv, BOOL fWithoutScroll, int iWorkArea);
int NEAR ListView_GetSlotCount(LV* plv, BOOL fWithoutScroll);
void NEAR ListView_IUpdateScrollBars(LV* plv);
DWORD NEAR ListView_GetClientRect(LV* plv, RECT FAR* prcClient, BOOL fSubScrolls, RECT FAR *prcViewRect);

void NEAR ListView_SetEditSize(LV* plv);
BOOL NEAR ListView_DismissEdit(LV* plv, BOOL fCancel);
LRESULT CALLBACK _export ListView_EditWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);


UINT NEAR PASCAL ListView_DrawImageEx(LV* plv, LV_ITEM FAR* pitem, HDC hdc, int x, int y, UINT fDraw, int xMax);
#define ListView_DrawImage(plv, pitem, hdc, x, y, fDraw) \
        ListView_DrawImageEx(plv, pitem, hdc, x, y, fDraw, -1)

#if defined(FE_IME) || !defined(WINNT)
void NEAR PASCAL ListView_SizeIME(HWND hwnd);
void NEAR PASCAL ListView_InsertComposition(HWND hwnd, WPARAM wParam, LPARAM lParam, LV *plv);
void NEAR PASCAL ListView_PaintComposition(HWND hwnd, LV *plv);
#endif

// lvsmall.c functions:


void NEAR ListView_SGetRects(LV* plv, LISTITEM FAR* pitem, RECT FAR* prcIcon,
        RECT FAR* prcLabel, LPRECT prcBounds);
void NEAR ListView_SGetRectsOwnerData(LV* plv, int iItem, RECT FAR* prcIcon,
        RECT FAR* prcLabel, LISTITEM* pitem, BOOL fUsepitem);
int ListView_SItemHitTest(LV* plv, int x, int y, UINT FAR* pflags, int *piSubItem);

int NEAR ListView_LookupString(LV* plv, LPCTSTR lpszLookup, UINT flags, int iStart);

// lvlist.c functions:


void NEAR ListView_LGetRects(LV* plv, int i, RECT FAR* prcIcon,
        RECT FAR* prcLabel, RECT FAR *prcBounds, RECT FAR* prcSelectBounds);
int ListView_LItemHitTest(LV* plv, int x, int y, UINT FAR* pflags, int *piSubItem);
void NEAR ListView_LUpdateScrollBars(LV* plv);
BOOL FAR PASCAL ListView_MaybeResizeListColumns(LV* plv, int iFirst, int iLast);

// lvrept.c functions:

int ListView_OnSubItemHitTest(LV* plv, LPLVHITTESTINFO lParam);
void ListView_GetSubItem(LV* plv, int i, int iSubItem, PLISTSUBITEM plsi);
BOOL LV_ShouldItemDrawGray(LV* plv, UINT fText);
int NEAR ListView_OnInsertColumn(LV* plv, int iCol, const LV_COLUMN FAR* pcol);
BOOL NEAR ListView_OnDeleteColumn(LV* plv, int iCol);
BOOL NEAR ListView_OnGetColumn(LV* plv, int iCol, LV_COLUMN FAR* pcol);
BOOL NEAR ListView_OnSetColumn(LV* plv, int iCol, const LV_COLUMN FAR* pcol);
BOOL NEAR ListView_ROnEnsureVisible(LV* plv, int i, BOOL fPartialOK);
void NEAR PASCAL ListView_RInitialize(LV* plv, BOOL fInval);
BOOL ListView_OnGetSubItemRect(LV* plv, int i, LPRECT lprc);
#define ListView_RYHitTest(plv, cy)  ((int)(((cy) + plv->ptlRptOrigin.y - plv->yTop) / plv->cyItem))

BOOL NEAR ListView_SetSubItem(LV* plv, const LV_ITEM FAR* plvi);
void NEAR PASCAL ListView_RAfterRedraw(LV* plv, HDC hdc);

int NEAR ListView_RGetColumnWidth(LV* plv, int iCol);
BOOL NEAR ListView_RSetColumnWidth(LV* plv, int iCol, int cx);
LPTSTR NEAR ListView_GetSubItemText(LV* plv, int i, int iCol);

void NEAR ListView_RDestroy(LV* plv);
LPTSTR NEAR ListView_RGetItemText(LV* plv, int i, int iCol);
int ListView_RItemHitTest(LV* plv, int x, int y, UINT FAR* pflags, int *piSubItem);
void NEAR ListView_RUpdateScrollBars(LV* plv);
void NEAR ListView_RGetRects(LV* plv, int iItem, RECT FAR* prcIcon,
        RECT FAR* prcLabel, RECT FAR* prcBounds, RECT FAR* prcSelectBounds);

LRESULT ListView_HeaderNotify(LV* plv, HD_NOTIFY *pnm);
int NEAR ListView_FreeColumnData(LPVOID d, LPVOID p);

BOOL FAR PASCAL SameChars(LPTSTR lpsz, TCHAR c);

#define ListView_GetSubItemDPA(plv, idpa) \
    ((HDPA)DPA_GetPtr((plv)->hdpaSubItems, (idpa)))

int  NEAR ListView_Arrow(LV* plv, int iStart, UINT vk);

BOOL ListView_IsItemUnfolded(LV *plv, int item);
BOOL ListView_IsItemUnfoldedPtr(LV *plv, LISTITEM *pitem);

// Fake customdraw.  See comment block in lvrept.c

typedef struct LVFAKEDRAW {
    NMLVCUSTOMDRAW nmcd;
    LV* plv;
    DWORD dwCustomPrev;
    DWORD dwCustomItem;
    DWORD dwCustomSubItem;
    LV_ITEM *pitem;
    HFONT hfontPrev;
} LVFAKEDRAW, *PLVFAKEDRAW;

void ListView_BeginFakeCustomDraw(LV* plv, PLVFAKEDRAW plvfd, LV_ITEM *pitem);
DWORD ListView_BeginFakeItemDraw(PLVFAKEDRAW plvfd);
void ListView_EndFakeItemDraw(PLVFAKEDRAW plvfd);
void ListView_EndFakeCustomDraw(PLVFAKEDRAW plvfd);

//============ External declarations =======================================

//extern HFONT g_hfontLabel;
extern HBRUSH g_hbrActiveLabel;
extern HBRUSH g_hbrInactiveLabel;
extern HBRUSH g_hbrBackground;


// function tables
#define LV_TYPEINDEX(plv) ((plv)->ci.style & (UINT)LVS_TYPEMASK)

BOOL ListView_RDrawItem(PLVDRAWITEM);
BOOL ListView_IDrawItem(PLVDRAWITEM);
BOOL ListView_LDrawItem(PLVDRAWITEM);

typedef BOOL (*PFNLISTVIEW_DRAWITEM)(PLVDRAWITEM);
extern const PFNLISTVIEW_DRAWITEM pfnListView_DrawItem[4];
#define _ListView_DrawItem(plvdi) \
        pfnListView_DrawItem[LV_TYPEINDEX(plvdi->plv)](plvdi)


void NEAR ListView_RUpdateScrollBars(LV* plv);

typedef void (*PFNLISTVIEW_UPDATESCROLLBARS)(LV* plv);
extern const PFNLISTVIEW_UPDATESCROLLBARS pfnListView_UpdateScrollBars[4];
#define _ListView_UpdateScrollBars(plv) \
        pfnListView_UpdateScrollBars[LV_TYPEINDEX(plv)](plv)


typedef DWORD (*PFNLISTVIEW_APPROXIMATEVIEWRECT)(LV* plv, int, int, int);
extern const PFNLISTVIEW_APPROXIMATEVIEWRECT pfnListView_ApproximateViewRect[4];
#define _ListView_ApproximateViewRect(plv, iCount, iWidth, iHeight) \
        pfnListView_ApproximateViewRect[LV_TYPEINDEX(plv)](plv, iCount, iWidth, iHeight)


typedef int (*PFNLISTVIEW_ITEMHITTEST)(LV* plv, int, int, UINT FAR *, int *);
extern const PFNLISTVIEW_ITEMHITTEST pfnListView_ItemHitTest[4];
#define _ListView_ItemHitTest(plv, x, y, pflags, piSubItem) \
        pfnListView_ItemHitTest[LV_TYPEINDEX(plv)](plv, x, y, pflags, piSubItem)



void ListView_IOnScroll(LV* plv, UINT code, int posNew, UINT fVert);
void ListView_LOnScroll(LV* plv, UINT code, int posNew, UINT sb);
void ListView_ROnScroll(LV* plv, UINT code, int posNew, UINT sb);

typedef void (*PFNLISTVIEW_ONSCROLL)(LV* plv, UINT, int, UINT );
extern const PFNLISTVIEW_ONSCROLL pfnListView_OnScroll[4];
#define _ListView_OnScroll(plv, x, y, pflags) \
        pfnListView_OnScroll[LV_TYPEINDEX(plv)](plv, x, y, pflags)


void ListView_Scroll2(LV* plv, int dx, int dy);
void ListView_IScroll2(LV* plv, int dx, int dy, UINT uSmooth);
void ListView_LScroll2(LV* plv, int dx, int dy, UINT uSmooth);
void ListView_RScroll2(LV* plv, int dx, int dy, UINT uSmooth);

typedef void (*PFNLISTVIEW_SCROLL2)(LV* plv, int, int, UINT );
extern const PFNLISTVIEW_SCROLL2 pfnListView_Scroll2[4];
#define _ListView_Scroll2(plv, x, y, pflags) \
        pfnListView_Scroll2[LV_TYPEINDEX(plv)](plv, x, y, pflags)

int ListView_IGetScrollUnitsPerLine(LV* plv, UINT sb);
int ListView_LGetScrollUnitsPerLine(LV* plv, UINT sb);
int ListView_RGetScrollUnitsPerLine(LV* plv, UINT sb);

typedef int (*PFNLISTVIEW_GETSCROLLUNITSPERLINE)(LV* plv, UINT sb);
extern const PFNLISTVIEW_GETSCROLLUNITSPERLINE pfnListView_GetScrollUnitsPerLine[4];
#define _ListView_GetScrollUnitsPerLine(plv, sb) \
        pfnListView_GetScrollUnitsPerLine[LV_TYPEINDEX(plv)](plv, sb)


#define LVMI_PLACEITEMS (WM_USER)

#endif  //!_INC_LISTVIEW
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\image.cpp ===
#include "ctlspriv.h"
#include "image.h"
#include "../CommonImageList.h"

#define __IOleControl_INTERFACE_DEFINED__       // There is a conflict with the IOleControl's def of CONTROLINFO
#include "CommonControls.h"

// Define this structure such that it will read and write the same
// format for both 16 and 32 bit applications...
#pragma pack(2)
typedef struct _ILFILEHEADER
{
    WORD    magic;
    WORD    version;
    SHORT   cImage;
    SHORT   cAlloc;
    SHORT   cGrow;
    SHORT   cx;
    SHORT   cy;
    COLORREF clrBk;
    SHORT    flags;
    SHORT       aOverlayIndexes[NUM_OVERLAY_IMAGES];  // array of special images
} ILFILEHEADER;

// This is the old size which has only 4 overlay slots
#define ILFILEHEADER_SIZE0 (SIZEOF(ILFILEHEADER) - SIZEOF(SHORT) * (NUM_OVERLAY_IMAGES - NUM_OVERLAY_IMAGES_0)) 

#pragma pack()

void ImageList_DeleteDragBitmaps();

HRESULT Stream_WriteBitmap(LPSTREAM pstm, HBITMAP hbm, int cBitsPerPixel);
HRESULT Stream_ReadBitmap(LPSTREAM pstm, BOOL f, HBITMAP* hbmp);
BOOL ImageList_SetDragImage(HIMAGELIST piml, int i, int dxHotspot, int dyHotspot);


class CImageList : public CImageListBase, public IImageList, public IImageListPriv, public IPersistStream
{
    long _cRef;

    ~CImageList();
    void _Destroy();

public:
    CImageList();

    HRESULT Initialize(int cx, int cy, UINT flags, int cInitial, int cGrow);
    void _RemoveItemBitmap(int i);
    BOOL _IsSameObject(IUnknown* punk);
    HRESULT _SetIconSize(int cxImage, int cyImage);
    HBITMAP _CreateMirroredBitmap(HBITMAP hbmOrig);
    HRESULT _ReAllocBitmaps(int cAlloc);
    HRESULT _Add(HBITMAP hbmImage, HBITMAP hbmMask, int cImage, int xStart, int yStart, int* pi);
    HRESULT _AddMasked(HBITMAP hbmImage, COLORREF crMask, int* pi);
    HRESULT _AddValidated(HBITMAP hbmImage, HBITMAP hbmMask, int* pi);
    HRESULT _ReplaceValidated(int i, HBITMAP hbmImage, HBITMAP hbmMask);
    HRESULT _Replace(int i, int cImage, HBITMAP hbmImage, HBITMAP hbmMask, int xStart, int yStart);
    HRESULT _Remove(int i);
    HRESULT _SetOverlayImage(int iImage, int iOverlay);
    HRESULT _ReplaceIcon(int i, HICON hIcon, int* pi);
    HBITMAP _CopyBitmap(HBITMAP hbm, HDC hdc);
    void    _Merge(IImageList* pux, int i, int dx, int dy);
    HRESULT _Merge(int i1, IUnknown* punk, int i2, int dx, int dy, CImageList** ppiml);
    HRESULT _Read(ILFILEHEADER *pilfh, HBITMAP hbmImage, HBITMAP hbmMask);
    BOOL    _MoreOverlaysUsed();
    BOOL GetSpareImageRect(RECT * prcImage);
    void _CopyOneImage(int iDst, int x, int y, CImageList* piml, int iSrc);
    BOOL CreateDragBitmaps();
    COLORREF _SetBkColor(COLORREF clrBk);
    HBITMAP _CreateBitmap(int cx, int cy);
    void _ResetBkColor(int iFirst, int iLast, COLORREF clr);

    
    static BOOL GlobalInit(void);
    static void GlobalUninit(void);
    static void SelectDstBitmap(HBITMAP hbmDst);
    static void SelectSrcBitmap(HBITMAP hbmSrc);
    static CImageList* Create(int cx, int cy, UINT flags, int cInitial, int cGrow);
    static void    _DeleteBitmap(HBITMAP hbmp);

    BOOL        _fInitialized;
    BOOL        _fSolidBk;   // is the bkcolor a solid color (in hbmImage)
    BOOL        _fColorsSet;  // The DIB colors have been set with SetColorTable()
    int         _cImage;     // count of images in image list
    int         _cAlloc;     // # of images we have space for
    int         _cGrow;      // # of images to grow bitmaps by
    int         _cx;         // width of each image
    int         _cy;         // height
    int         _cStrip;     // # images in horizontal strip
    UINT        _flags;      // ILC_* flags
    COLORREF    _clrBlend;   // last blend color
    COLORREF    _clrBk;      // bk color or CLR_NONE for transparent.
    HBRUSH      _hbrBk;      // bk brush or black
    HBITMAP     _hbmImage;   // all images are in here
    HBITMAP     _hbmMask;    // all image masks are in here.
    HDC         _hdcImage;
    HDC         _hdcMask;
    int         _aOverlayIndexes[NUM_OVERLAY_IMAGES];    // array of special images
    int         _aOverlayX[NUM_OVERLAY_IMAGES];          // x offset of image
    int         _aOverlayY[NUM_OVERLAY_IMAGES];          // y offset of image
    int         _aOverlayDX[NUM_OVERLAY_IMAGES];         // cx offset of image
    int         _aOverlayDY[NUM_OVERLAY_IMAGES];         // cy offset of image
    int         _aOverlayF[NUM_OVERLAY_IMAGES];          // ILD_ flags for image
    CImageList* _pimlMirror;  // Set only when another mirrored imagelist is needed (ILC_MIRROR)    

    //
    // used for "blending" effects on a HiColor display.
    // assumes layout of a DIBSECTION.
    //
    struct 
    {
        BITMAP              bm;
        BITMAPINFOHEADER    bi;
        DWORD               ct[256];
    }   dib;

    // *** IUnknown ***
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG)AddRef();
    STDMETHODIMP_(ULONG)Release();


    // *** IImageList ***
    STDMETHODIMP Add(HBITMAP hbmImage, HBITMAP hbmMask, int* pi);
    STDMETHODIMP ReplaceIcon(int i, HICON hIcon, int* pi);
    STDMETHODIMP SetOverlayImage(int iImage, int iOverlay);
    STDMETHODIMP Replace(int i, HBITMAP hbmImage, HBITMAP hbmMask);
    STDMETHODIMP AddMasked(HBITMAP hbmImage, COLORREF crMask, int* pi);
    STDMETHODIMP Draw(IMAGELISTDRAWPARAMS* pimldp);
    STDMETHODIMP Remove(int i);
    STDMETHODIMP GetIcon(int i, UINT flags, HICON* phicon);
    STDMETHODIMP GetImageInfo(int i, IMAGEINFO * pImageInfo);
    STDMETHODIMP Copy(int iDst, IUnknown* punkSrc, int iSrc, UINT uFlags);
    STDMETHODIMP Merge(int i1, IUnknown* punk, int i2, int dx, int dy, REFIID riid, void** ppv);
    STDMETHODIMP Clone(REFIID riid, void** ppv);
    STDMETHODIMP GetImageRect(int i, RECT * prcImage);
    STDMETHODIMP SetIconSize(int cxImage, int cyImage);
    STDMETHODIMP GetIconSize(int* pcx, int* pcy);
    STDMETHODIMP SetImageCount(UINT uAlloc);
    STDMETHODIMP GetImageCount(int* pi);
    STDMETHODIMP SetBkColor(COLORREF clrBk, COLORREF* pclr);
    STDMETHODIMP GetBkColor(COLORREF* pclr);
    STDMETHODIMP BeginDrag(int iTrack, int dxHotspot, int dyHotspot);
    STDMETHODIMP DragEnter(HWND hwndLock, int x, int y);
    STDMETHODIMP DragMove(int x, int y);
    STDMETHODIMP DragLeave(HWND hwndLock);
    STDMETHODIMP EndDrag();
    STDMETHODIMP SetDragCursorImage(IUnknown* punk, int i, int dxHotspot, int dyHotspot);
    STDMETHODIMP DragShowNolock(BOOL fShow);
    STDMETHODIMP GetDragImage(POINT * ppt, POINT * pptHotspot, REFIID riid, void** ppv);
    STDMETHODIMP GetItemFlags(int i, DWORD *dwFlags);
    STDMETHODIMP GetOverlayImage(int iOverlay, int* piImage);


    // *** IImageListPriv ***
    STDMETHODIMP SetFlags(UINT uFlags);
    STDMETHODIMP GetFlags(UINT* puFlags);
    STDMETHODIMP SetColorTable(int start, int len, RGBQUAD *prgb, int* pi);
    STDMETHODIMP GetPrivateGoo(HBITMAP* hbmp, HDC* hdc, HBITMAP* hbmpMask, HDC* hdcMask);
    STDMETHODIMP GetMirror(REFIID riid, void** ppv);
    STDMETHODIMP CopyDitherImage(WORD iDst, int xDst, int yDst, IUnknown* punkSrc, int iSrc, UINT fStyle);


    // *** IPersist ***
    STDMETHODIMP GetClassID(CLSID *pClassID)    {   *pClassID = CLSID_ImageList; return S_OK;   }
    STDMETHODIMP IsDirty()                      {   return E_NOTIMPL; }

    // *** IPersistStream ***
    STDMETHODIMP Load(IStream *pStm);
    STDMETHODIMP Save(IStream *pStm, int fClearDirty);
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER * pcbSize)   { return E_NOTIMPL; }
};

HDC g_hdcSrc = NULL;
HBITMAP g_hbmSrc = NULL;
HBITMAP g_hbmDcDeselect = NULL;

HDC g_hdcDst = NULL;
HBITMAP g_hbmDst = NULL;
int g_iILRefCount = 0;

HRESULT HIMAGELIST_QueryInterface(HIMAGELIST himl, REFIID riid, void** ppv)
{
    *ppv = NULL;
    if (himl)
    {
        // First Convert the HIMAGELIST to an IUnknown.
        IUnknown* punk = reinterpret_cast<IUnknown*>(himl);

        // Now, we need to validate the object. CImageListBase contains the goo needed to figure out if this
        // is a valid imagelist.
        CImageListBase* pval = FindImageListBase(punk);

        // Now we call some private member.
        if (pval->IsValid())
        {
            // If it's valid then we can QI safely.
            return punk->QueryInterface(riid, ppv);
        }
    }

    return E_POINTER;
}

HRESULT WimpyDrawEx(IImageList* pux, int i, HDC hdcDst, int x, int y, int cx, int cy, COLORREF rgbBk, COLORREF rgbFg, UINT fStyle)
{
    IMAGELISTDRAWPARAMS imldp = {0};

    imldp.cbSize = sizeof(imldp);
    imldp.himl   = reinterpret_cast<HIMAGELIST>(pux);
    imldp.i      = i;
    imldp.hdcDst = hdcDst;
    imldp.x      = x;
    imldp.y      = y;
    imldp.cx     = cx;
    imldp.cy     = cy;
    imldp.rgbBk  = rgbBk;
    imldp.rgbFg  = rgbFg;
    imldp.fStyle = fStyle;
    imldp.dwRop  = SRCCOPY;
    
    return pux->Draw(&imldp);
}

HRESULT WimpyDraw(IImageList* pux, int i, HDC hdcDst, int x, int y, UINT fStyle)
{
    IMAGELISTDRAWPARAMS imldp = {0};

    imldp.cbSize = sizeof(imldp);
    imldp.himl   = reinterpret_cast<HIMAGELIST>(pux);
    imldp.i      = i;
    imldp.hdcDst = hdcDst;
    imldp.x      = x;
    imldp.y      = y;
    imldp.rgbBk  = CLR_DEFAULT;
    imldp.rgbFg  = CLR_DEFAULT;
    imldp.fStyle = fStyle;
    imldp.dwRop  = SRCCOPY;
    
    return pux->Draw(&imldp);
}


CImageList::CImageList() : _cRef(1)
{
}

CImageList::~CImageList()
{
    if (_pimlMirror)
    {
        _pimlMirror->Release();
    }

    _Destroy();
}

HRESULT CImageList::Initialize(int cxI, int cyI, UINT flagsI, int cInitialI, int cGrowI)
{
    HRESULT hr = E_OUTOFMEMORY;

    if (cGrowI < 4)
    {
        cGrowI = 4;
    }
    else 
    {
        // round up by 4's
        cGrowI = (cGrowI + 3) & ~3;
    }
    _cStrip = 4;
    _cGrow = cGrowI;
    _cx = cxI;
    _cy = cyI;
    _clrBlend = CLR_NONE;
    _clrBk = CLR_NONE;
    _hbrBk = (HBRUSH)GetStockObject(BLACK_BRUSH);
    _fSolidBk = TRUE;
    _flags = flagsI;
    _pimlMirror = NULL;        

    //
    // Initialize the overlay indexes to -1 since 0 is a valid index.
    //

    for (int i = 0; i < NUM_OVERLAY_IMAGES; i++) 
    {
        _aOverlayIndexes[i] = -1;
    }

    _hdcImage = CreateCompatibleDC(NULL);

    if (_hdcImage)
    {
        hr = S_OK;
        if (_flags & ILC_MASK)
        {
            _hdcMask = CreateCompatibleDC(NULL);

            if (!_hdcMask)
                hr = E_OUTOFMEMORY;
        }

        if (SUCCEEDED(hr))
        {
            hr = _ReAllocBitmaps(cInitialI + 1);
            if (FAILED(hr))
            {
                hr = _ReAllocBitmaps(1);
            }
        }
    }

    // Don't do this if we are already initialized, we just want to pass new information....
    if (SUCCEEDED(hr) && !_fInitialized)
        g_iILRefCount++;

    _fInitialized = TRUE;

    return hr;
}


HRESULT CImageList::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr = E_NOINTERFACE;
    if (riid == IID_IUnknown ||
        riid == IID_IImageList)
    {
        *ppv = (IImageList*)this;
        hr = S_OK;
    }
    else if (riid == IID_IImageListPriv)
    {
        *ppv = (IImageListPriv*)this;
        hr = S_OK;
    }
    else if (riid == IID_IPersist)
    {
        *ppv = (IPersist*)this;
        hr = S_OK;
    }
    else if (riid == IID_IPersistStream)
    {
        *ppv = (IPersistStream*)this;
        hr = S_OK;
    }

    if (SUCCEEDED(hr))
        AddRef();

    return hr;
}

ULONG CImageList::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CImageList::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CImageList::GetPrivateGoo(HBITMAP* phbmp, HDC* phdc, HBITMAP* phbmpMask, HDC* phdcMask)
{
    if (phbmp)
        *phbmp = _hbmImage;

    if (phdc)
        *phdc = _hdcImage;

    if (phbmpMask)
        *phbmpMask = _hbmMask;

    if (phdcMask)
        *phdcMask = _hdcMask;

    return S_OK;
}

HRESULT CImageList::GetMirror(REFIID riid, void** ppv)
{
    if (_pimlMirror)
        return _pimlMirror->QueryInterface(riid, ppv);

    return E_NOINTERFACE;
}

//
// global work buffer, this buffer is always a DDB never a DIBSection
//
HBITMAP g_hbmWork = NULL;                   // work buffer.
BITMAP  g_bmWork = {0};                     // work buffer size

HBRUSH g_hbrMonoDither = NULL;              // gray dither brush for dragging
HBRUSH g_hbrStripe = NULL;

#define NOTSRCAND       0x00220326L
#define ROP_PSo         0x00FC008A
#define ROP_DPo         0x00FA0089
#define ROP_DPna        0x000A0329
#define ROP_DPSona      0x00020c89
#define ROP_SDPSanax    0x00E61ce8
#define ROP_DSna        0x00220326
#define ROP_PSDPxax     0x00b8074a

#define ROP_PatNotMask  0x00b8074a      // D <- S==0 ? P : D
#define ROP_PatMask     0x00E20746      // D <- S==1 ? P : D
#define ROP_MaskPat     0x00AC0744      // D <- P==1 ? D : S

#define ROP_DSo         0x00EE0086L
#define ROP_DSno        0x00BB0226L
#define ROP_DSa         0x008800C6L

static int g_iDither = 0;

void InitDitherBrush()
{
    HBITMAP hbmTemp;
    static const WORD graybits[] = {0xAAAA, 0x5555, 0xAAAA, 0x5555,
                       0xAAAA, 0x5555, 0xAAAA, 0x5555};

    if (g_iDither) 
    {
        g_iDither++;
    } 
    else 
    {
        // build the dither brush.  this is a fixed 8x8 bitmap
        hbmTemp = CreateBitmap(8, 8, 1, 1, graybits);
        if (hbmTemp)
        {
            // now use the bitmap for what it was really intended...
            g_hbrMonoDither = CreatePatternBrush(hbmTemp);
            DeleteObject(hbmTemp);
            g_iDither++;
        }
    }
}

void TerminateDitherBrush()
{
    g_iDither--;
    if (g_iDither == 0) 
    {
        DeleteObject(g_hbrMonoDither);
        g_hbrMonoDither = NULL;
    }
}

/*
** GetScreenDepth()
*/
int GetScreenDepth()
{
    int i;
    HDC hdc = GetDC(NULL);
    i = GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES);
    ReleaseDC(NULL, hdc);
    return i;
}

//
// should we use a DIB section on the current device?
//
// the main goal of using DS is to save memory, but they draw slow
// on some devices.
//
// 4bpp Device (ie 16 color VGA)    dont use DS
// 8bpp Device (ie 256 color SVGA)  use DS if DIBENG based.
// >8bpp Device (ie 16bpp 24bpp)    always use DS, saves memory
//

#define CAPS1           94          /* other caps */
#define C1_DIBENGINE    0x0010      /* DIB Engine compliant driver          */

//
// create a bitmap compatible with the given ImageList
//
HBITMAP CImageList::_CreateBitmap(int cx, int cy)
{
    HDC hdc;
    HBITMAP hbm;
    void* lpBits;

    struct 
    {
        BITMAPINFOHEADER bi;
        DWORD            ct[256];
    } dib;

    //
    // create a compatible bitmap if the imagelist has a bitmap already.
    //
    if (_hbmImage && _hdcImage)
    {
        return CreateCompatibleBitmap(_hdcImage, cx, cy);
    }

    hdc = GetDC(NULL);

    // no color depth was specifed
    //
    // if we are on a DIBENG based DISPLAY, we use 4bit DIBSections to save
    // memory.
    //
    if ((_flags & ILC_COLORMASK) == 0)
    {
        _flags |= ILC_COLOR4;
    }

    if ((_flags & ILC_COLORMASK) != ILC_COLORDDB)
    {
        dib.bi.biSize            = sizeof(BITMAPINFOHEADER);
        dib.bi.biWidth           = cx;
        dib.bi.biHeight          = cy;
        dib.bi.biPlanes          = 1;
        dib.bi.biBitCount        = (_flags & ILC_COLORMASK);
        dib.bi.biCompression     = BI_RGB;
        dib.bi.biSizeImage       = 0;
        dib.bi.biXPelsPerMeter   = 0;
        dib.bi.biYPelsPerMeter   = 0;
        dib.bi.biClrUsed         = 16;
        dib.bi.biClrImportant    = 0;
        dib.ct[0]                = 0x00000000;    // 0000  black
        dib.ct[1]                = 0x00800000;    // 0001  dark red
        dib.ct[2]                = 0x00008000;    // 0010  dark green
        dib.ct[3]                = 0x00808000;    // 0011  mustard
        dib.ct[4]                = 0x00000080;    // 0100  dark blue
        dib.ct[5]                = 0x00800080;    // 0101  purple
        dib.ct[6]                = 0x00008080;    // 0110  dark turquoise
        dib.ct[7]                = 0x00C0C0C0;    // 1000  gray
        dib.ct[8]                = 0x00808080;    // 0111  dark gray
        dib.ct[9]                = 0x00FF0000;    // 1001  red
        dib.ct[10]               = 0x0000FF00;    // 1010  green
        dib.ct[11]               = 0x00FFFF00;    // 1011  yellow
        dib.ct[12]               = 0x000000FF;    // 1100  blue
        dib.ct[13]               = 0x00FF00FF;    // 1101  pink (magenta)
        dib.ct[14]               = 0x0000FFFF;    // 1110  cyan
        dib.ct[15]               = 0x00FFFFFF;    // 1111  white

        if (dib.bi.biBitCount == 8)
        {
            HPALETTE hpal;
            int i;

            if (hpal = CreateHalftonePalette(NULL))
            {
                i = GetPaletteEntries(hpal, 0, 256, (LPPALETTEENTRY)&dib.ct[0]);
                DeleteObject(hpal);

                if (i > 64)
                {
                    dib.bi.biClrUsed = i;
                    for (i=0; i<(int)dib.bi.biClrUsed; i++)
                        dib.ct[i] = RGB(GetBValue(dib.ct[i]),GetGValue(dib.ct[i]),GetRValue(dib.ct[i]));
                }
            }
            else
            {
                dib.bi.biBitCount = (_flags & ILC_COLORMASK);
                dib.bi.biClrUsed = 256;
            }

            if (dib.bi.biClrUsed <= 16)
                dib.bi.biBitCount = 4;
        }

        hbm = CreateDIBSection(hdc, (LPBITMAPINFO)&dib, DIB_RGB_COLORS, &lpBits, NULL, 0);
    }
    else
    {
        hbm = CreateCompatibleBitmap(hdc, cx, cy);
    }

    ReleaseDC(NULL, hdc);

    return hbm;
}

EXTERN_C HBITMAP CreateColorBitmap(int cx, int cy)
{
    HBITMAP hbm;
    HDC hdc;

    hdc = GetDC(NULL);

    //
    // on a multimonitor system with mixed bitdepths
    // always use a 32bit bitmap for our work buffer
    // this will prevent us from losing colors when
    // blting to and from the screen.  this is mainly
    // important for the drag & drop offscreen buffers.
    //
    if (!(GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE) &&
        GetSystemMetrics(SM_CMONITORS) > 1 &&
        GetSystemMetrics(SM_SAMEDISPLAYFORMAT) == 0)
    {
        void* p;
        BITMAPINFO bi = {sizeof(BITMAPINFOHEADER), cx, cy, 1, 32};
        hbm = CreateDIBSection(hdc, &bi, DIB_RGB_COLORS, &p, NULL, 0);
    }
    else
    {
        hbm = CreateCompatibleBitmap(hdc, cx, cy);
    }

    ReleaseDC(NULL, hdc);
    return hbm;
}

EXTERN_C HBITMAP CreateMonoBitmap(int cx, int cy)
{
    return CreateBitmap(cx, cy, 1, 1, NULL);
}

//============================================================================

BOOL CImageList::GlobalInit(void)
{
    HDC hdcScreen;
    static const WORD stripebits[] = {0x7777, 0xdddd, 0x7777, 0xdddd,
                         0x7777, 0xdddd, 0x7777, 0xdddd};
    HBITMAP hbmTemp;

    // if already initialized, there is nothing to do
    if (g_hdcDst)
        return TRUE;

    hdcScreen = GetDC(HWND_DESKTOP);

    g_hdcSrc = CreateCompatibleDC(hdcScreen);
    g_hdcDst = CreateCompatibleDC(hdcScreen);

    InitDitherBrush();

    hbmTemp = CreateBitmap(8, 8, 1, 1, stripebits);
    if (hbmTemp)
    {
        // initialize the deselect 1x1 bitmap
        g_hbmDcDeselect = SelectBitmap(g_hdcDst, hbmTemp);
        SelectBitmap(g_hdcDst, g_hbmDcDeselect);

        g_hbrStripe = CreatePatternBrush(hbmTemp);
        DeleteObject(hbmTemp);
    }

    ReleaseDC(HWND_DESKTOP, hdcScreen);

    if (!g_hdcSrc || !g_hdcDst || !g_hbrMonoDither)
    {
        CImageList::GlobalUninit();
        TraceMsg(TF_ERROR, "ImageList: Unable to initialize");
        return FALSE;
    }
    return TRUE;
}

void CImageList::GlobalUninit()
{
    TerminateDitherBrush();

    if (g_hbrStripe)
    {
        DeleteObject(g_hbrStripe);
        g_hbrStripe = NULL;
    }

    ImageList_DeleteDragBitmaps();

    if (g_hdcDst)
    {
        CImageList::SelectDstBitmap(NULL);
        DeleteDC(g_hdcDst);
        g_hdcDst = NULL;
    }

    if (g_hdcSrc)
    {
        CImageList::SelectSrcBitmap(NULL);
        DeleteDC(g_hdcSrc);
        g_hdcSrc = NULL;
    }

    if (g_hbmWork)
    {
        DeleteBitmap(g_hbmWork);
        g_hbmWork = NULL;
    }
}

void CImageList::SelectDstBitmap(HBITMAP hbmDst)
{
    ASSERTCRITICAL;

    if (hbmDst != g_hbmDst)
    {
        // If it's selected in the source DC, then deselect it first
        //
        if (hbmDst && hbmDst == g_hbmSrc)
            CImageList::SelectSrcBitmap(NULL);

        SelectBitmap(g_hdcDst, hbmDst ? hbmDst : g_hbmDcDeselect);
        g_hbmDst = hbmDst;
    }
}

void CImageList::SelectSrcBitmap(HBITMAP hbmSrc)
{
    ASSERTCRITICAL;

    if (hbmSrc != g_hbmSrc)
    {
        // If it's selected in the dest DC, then deselect it first
        //
        if (hbmSrc && hbmSrc == g_hbmDst)
            CImageList::SelectDstBitmap(NULL);

        SelectBitmap(g_hdcSrc, hbmSrc ? hbmSrc : g_hbmDcDeselect);
        g_hbmSrc = hbmSrc;
    }
}

HDC ImageList_GetWorkDC(HDC hdc, int dx, int dy)
{
    ASSERTCRITICAL;

    if (g_hbmWork == NULL ||
        GetDeviceCaps(hdc, BITSPIXEL) != g_bmWork.bmBitsPixel ||
        g_bmWork.bmWidth  < dx || g_bmWork.bmHeight < dy)
    {
        CImageList::_DeleteBitmap(g_hbmWork);
        g_hbmWork = NULL;

        if (dx == 0 || dy == 0)
            return NULL;

        if (g_hbmWork = CreateCompatibleBitmap(hdc, dx, dy))
        {
            GetObject(g_hbmWork, sizeof(g_bmWork), &g_bmWork);
        }
    }

    CImageList::SelectSrcBitmap(g_hbmWork);

    if (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)
    {
        HPALETTE hpal = (HPALETTE)SelectPalette(hdc, (HPALETTE)GetStockObject(DEFAULT_PALETTE), TRUE);
        SelectPalette(g_hdcSrc, hpal, TRUE);
    }

    return g_hdcSrc;
}

void ImageList_ReleaseWorkDC(HDC hdc)
{
    ASSERTCRITICAL;
    ASSERT(hdc == g_hdcSrc);

    if (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)
    {
        SelectPalette(hdc, (HPALETTE)GetStockObject(DEFAULT_PALETTE), TRUE);
    }
}

void CImageList::_DeleteBitmap(HBITMAP hbm)
{
    ASSERTCRITICAL;
    if (hbm)
    {
        if (g_hbmDst == hbm)
            CImageList::SelectDstBitmap(NULL);
        if (g_hbmSrc == hbm)
            CImageList::SelectSrcBitmap(NULL);
        DeleteBitmap(hbm);
    }
}


#define ILC_WIN95   (ILC_MASK | ILC_COLORMASK | ILC_SHARED | ILC_PALETTE)


//============================================================================

HRESULT ImageList_InitGlobals()
{
    HRESULT hr = S_OK;
    ENTERCRITICAL;
    if (!g_iILRefCount)
    {
        if (!CImageList::GlobalInit())
        {
            hr = E_OUTOFMEMORY;
        }
    }
    LEAVECRITICAL;

    return S_OK;
}

CImageList* CImageList::Create(int cx, int cy, UINT flags, int cInitial, int cGrow)
{
    CImageList* piml = NULL;
    HRESULT hr = S_OK;

    if (cx < 0 || cy < 0)
        return NULL;

    // Validate the flags
    if (flags & ~ILC_VALID)
        return NULL;

    hr = ImageList_InitGlobals();
    ENTERCRITICAL;

    if (SUCCEEDED(hr))
    {
        piml = new CImageList();

        // allocate the bitmap PLUS one re-usable entry
        if (piml)
        {
            hr = piml->Initialize(cx, cy, flags, cInitial, cGrow);
            if (FAILED(hr))
            {
                piml->Release();
                piml = NULL;
            }
        }
    }

    LEAVECRITICAL;

    return piml;
}



void CImageList::_Destroy()
{
    ENTERCRITICAL;
    // nuke dc's
    if (_hdcImage)
    {
        SelectObject(_hdcImage, g_hbmDcDeselect);
        DeleteDC(_hdcImage);
    }
    if (_hdcMask)
    {
        SelectObject(_hdcMask, g_hbmDcDeselect);
        DeleteDC(_hdcMask);
    }

    // nuke bitmaps
    if (_hbmImage)
        _DeleteBitmap(_hbmImage);

    if (_hbmMask)
        _DeleteBitmap(_hbmMask);

    if (_hbrBk)
        DeleteObject(_hbrBk);

    // one less use of imagelists.  if it's the last, terminate the imagelist
    g_iILRefCount--;
    if (!g_iILRefCount)
        CImageList::GlobalUninit();
    LEAVECRITICAL;
}

HRESULT CImageList::GetImageCount(int* pi)
{
    *pi = _cImage;

    return S_OK;
}

HRESULT CImageList::SetImageCount(UINT uAlloc)
{
    ENTERCRITICAL;
    HRESULT hr = _ReAllocBitmaps(-((int)uAlloc + 1));
    if (SUCCEEDED(hr))
    {
        _cImage = (int)uAlloc;
    }
    LEAVECRITICAL;

    return hr;
}

HRESULT CImageList::GetIconSize(int* pcx, int* pcy)
{
    if (!pcx || !pcy)
        return E_INVALIDARG;

    *pcx = _cx;
    *pcy = _cy;
    return S_OK;
}

//
//  change the size of a existing image list
//  also removes all items
//
HRESULT CImageList::_SetIconSize(int cxImage, int cyImage)
{
    if (_cx == cxImage && _cy == cyImage)
        return S_FALSE;       // no change

    if (_cx < 0 || _cy < 0)
        return E_INVALIDARG;       // invalid dimensions

    _cx = cxImage;
    _cy = cyImage;

    return Remove(-1);
}

HRESULT CImageList::SetIconSize(int cxImage, int cyImage)
{
   if (_pimlMirror)
   {
       _pimlMirror->_SetIconSize(cxImage, cyImage);
   }

   return _SetIconSize(cxImage, cyImage);
}

//
//  ImageList_SetFlags
//
//  change the image list flags, then rebuilds the bitmaps.
//
//  the only reason to call this function is to change the
//  color depth of the image list, the shell needs to do this
//  when the screen depth changes and it wants to use HiColor icons.
//
HRESULT CImageList::SetFlags(UINT uFlags)
{
    HBITMAP hOldImage;
    // check for valid input flags
    if (_flags & ~ILC_VALID)
        return E_INVALIDARG;

    // you cant change these flags.
    if ((uFlags ^ _flags) & ILC_SHARED)
        return E_INVALIDARG;

    // now change the flags and rebuild the bitmaps.
    _flags = uFlags;

    // set the old bitmap to NULL, so when Imagelist_remove calls
    // ImageList_createBitmap, it will not call CreatecomptibleBitmap,
    // it will create the spec for the bitmap from scratch..
    hOldImage = _hbmImage;
    _hbmImage = NULL;
    
    Remove(-1);

    // imagelist::remove will have ensured that the old image is no longer selected
    // thus we can now delete it...
    if ( hOldImage )
        DeleteObject( hOldImage );
        
    return S_OK;
}

HRESULT CImageList::GetFlags(UINT* puFlags)
{
    *puFlags = (_flags & ILC_VALID) | (_pimlMirror ? ILC_MIRROR : 0);

    return S_OK;
}

// reset the background color of images iFirst through iLast

void CImageList::_ResetBkColor(int iFirst, int iLast, COLORREF clr)
{
    HBRUSH hbrT=NULL;
    DWORD  rop;

    if (_hdcMask == NULL)
        return;

    if (clr == CLR_BLACK || clr == CLR_NONE)
    {
        rop = ROP_DSna;
    }
    else if (clr == CLR_WHITE)
    {
        rop = ROP_DSo;
    }
    else
    {
        ASSERT(_hbrBk);
        ASSERT(_clrBk == clr);

        rop = ROP_PatMask;
        hbrT = SelectBrush(_hdcImage, _hbrBk);
    }

    for ( ;iFirst <= iLast; iFirst++)
    {
        RECT rc;

        GetImageRect(iFirst, &rc);

        BitBlt(_hdcImage, rc.left, rc.top, _cx, _cy,
        _hdcMask, rc.left, rc.top, rop);
    }

    if (hbrT)
        SelectBrush(_hdcImage, hbrT);
}

//
//  GetNearestColor is problematic.  If you have a 32-bit HDC with a 16-bit bitmap
//  selected into it, and you call GetNearestColor, GDI ignores the
//  color-depth of the bitmap and thinks you have a 32-bit bitmap inside,
//  so of course it returns the same color unchanged.
//
//  So instead, we have to emulate GetNearestColor with SetPixel.
//
COLORREF GetNearestColor32(HDC hdc, COLORREF rgb)
{
    COLORREF rgbT;

    rgbT = GetPixel(hdc, 0, 0);
    rgb = SetPixel(hdc, 0, 0, rgb);
    SetPixelV(hdc, 0, 0, rgbT);

    return rgb;
}

COLORREF CImageList::_SetBkColor(COLORREF clrBkI)
{
    COLORREF clrBkOld;

    // Quick out if there is no change in color
    if (_clrBk == clrBkI)
    {
        return _clrBk;
    }

    // The following code deletes the brush, resets the background color etc.,
    // so, protect it with a critical section.
    ENTERCRITICAL;
    
    if (_hbrBk)
    {
        DeleteBrush(_hbrBk);
    }

    clrBkOld = _clrBk;
    _clrBk = clrBkI;

    if (_clrBk == CLR_NONE)
    {
        _hbrBk = (HBRUSH)GetStockObject(BLACK_BRUSH);
        _fSolidBk = TRUE;
    }
    else
    {
        _hbrBk = CreateSolidBrush(_clrBk);
        _fSolidBk = GetNearestColor32(_hdcImage, _clrBk) == _clrBk;
    }

    if (_cImage > 0)
    {
        _ResetBkColor(0, _cImage - 1, _clrBk);
    }

    LEAVECRITICAL;
    
    return clrBkOld;
}

HRESULT CImageList::SetBkColor(COLORREF clrBk, COLORREF* pclr)
{
   if (_pimlMirror)
   {
       _pimlMirror->_SetBkColor(clrBk);
   }    

   *pclr = _SetBkColor(clrBk);
   return S_OK;
}

HRESULT CImageList::GetBkColor(COLORREF* pclr)
{
    *pclr = _clrBk;
    return S_OK;
}

HRESULT CImageList::_ReAllocBitmaps(int cAllocI)
{
    HBITMAP hbmImageNew;
    HBITMAP hbmMaskNew;
    int cxL, cyL;

    // HACK: don't shrink unless the caller passes a negative count
    if (cAllocI > 0)
    {
        if (_cAlloc >= cAllocI)
            return S_OK;
    }
    else
        cAllocI *= -1;

    hbmMaskNew = NULL;
    hbmImageNew = NULL;

    cxL = _cx * _cStrip;
    cyL = _cy * ((cAllocI + _cStrip - 1) / _cStrip);
    if (cAllocI > 0)
    {
        if (_flags & ILC_MASK)
        {
            hbmMaskNew = CreateMonoBitmap(cxL, cyL);
            if (!hbmMaskNew)
            {
                TraceMsg(TF_ERROR, "ImageList: Can't create bitmap");
                return E_OUTOFMEMORY;
            }
        }
        hbmImageNew = _CreateBitmap(cxL, cyL);
        if (!hbmImageNew)
        {
            if (hbmMaskNew)
                CImageList::_DeleteBitmap(hbmMaskNew);
            TraceMsg(TF_ERROR, "ImageList: Can't create bitmap");
            return E_OUTOFMEMORY;
        }
    }

    if (_cImage > 0)
    {
        int cyCopy = _cy * ((min(cAllocI, _cImage) + _cStrip - 1) / _cStrip);

        if (_flags & ILC_MASK)
        {
            CImageList::SelectDstBitmap(hbmMaskNew);
            BitBlt(g_hdcDst, 0, 0, cxL, cyCopy, _hdcMask, 0, 0, SRCCOPY);
        }

        CImageList::SelectDstBitmap(hbmImageNew);
        BitBlt(g_hdcDst, 0, 0, cxL, cyCopy, _hdcImage, 0, 0, SRCCOPY);
    }

    // select into DC's, delete then assign
    CImageList::SelectDstBitmap(NULL);
    CImageList::SelectSrcBitmap(NULL);
    SelectObject(_hdcImage, hbmImageNew);

    if (_hdcMask)
        SelectObject(_hdcMask, hbmMaskNew);

    if (_hbmMask)
        CImageList::_DeleteBitmap(_hbmMask);

    if (_hbmImage)
        CImageList::_DeleteBitmap(_hbmImage);

    _hbmMask = hbmMaskNew;
    _hbmImage = hbmImageNew;
    _clrBlend = CLR_NONE;

    _cAlloc = cAllocI;

    return S_OK;
}

HBITMAP CImageList::_CreateMirroredBitmap(HBITMAP hbmOrig)
{
    HBITMAP hbm = NULL, hOld_bm1, hOld_bm2;
    BITMAP  bm;

    if (!hbmOrig)
        return NULL;

    if (!GetObject(hbmOrig, sizeof(BITMAP), &bm))
        return NULL;

    // Grab the screen DC
    HDC hdc = GetDC(NULL);

    HDC hdcMem1 = CreateCompatibleDC(hdc);

    if (!hdcMem1)
    {
        ReleaseDC(NULL, hdc);
        return NULL;
    }
    
    HDC hdcMem2 = CreateCompatibleDC(hdc);
    if (!hdcMem2)
    {
        DeleteDC(hdcMem1);
        ReleaseDC(NULL, hdc);
        return NULL;
    }

    hbm = CreateColorBitmap(bm.bmWidth, bm.bmHeight);

    if (!hbm)
    {
        DeleteDC(hdcMem2);
        DeleteDC(hdcMem1);        
        ReleaseDC(NULL, hdc);
        return NULL;
    }

    //
    // Flip the bitmap
    //
    hOld_bm1 = (HBITMAP)SelectObject(hdcMem1, hbmOrig);
    hOld_bm2 = (HBITMAP)SelectObject(hdcMem2 , hbm );

    SET_DC_RTL_MIRRORED(hdcMem2);

    BitBlt(hdcMem2, 0, 0, bm.bmWidth, bm.bmHeight, hdcMem1, 0, 0, SRCCOPY);

    SelectObject(hdcMem1, hOld_bm1 );
    SelectObject(hdcMem1, hOld_bm2 );
    
    DeleteDC(hdcMem2);
    DeleteDC(hdcMem1);
    ReleaseDC(NULL, hdc);

    return hbm;
}

HRESULT CImageList::SetColorTable(int start, int len, RGBQUAD *prgb, int* pi)
{
    // mark it that we have set the color table so that it won't be overwritten 
    // by the first bitmap add....
    _fColorsSet = TRUE;
    if (_hdcImage)
    {
        *pi = SetDIBColorTable(_hdcImage, start, len, prgb);

        return S_OK;
    }

    return E_FAIL;
}


HRESULT CImageList::_Add(HBITMAP hbmImageI, HBITMAP hbmMaskI, int cImageI, int xStart, int yStart, int* pi)
{
    int i = -1;
    HRESULT hr = S_OK;

    ENTERCRITICAL;

    //
    // if the ImageList is empty clone the color table of the first
    // bitmap you add to the imagelist.
    //
    // the ImageList needs to be a 8bpp image list
    // the bitmap being added needs to be a 8bpp DIBSection
    //
    if (hbmImageI && _cImage == 0 &&
        (_flags & ILC_COLORMASK) != ILC_COLORDDB)
    {
        if (!_fColorsSet)
        {
            int n;
            RGBQUAD argb[256];

            CImageList::SelectDstBitmap(hbmImageI);

            if (n = GetDIBColorTable(g_hdcDst, 0, 256, argb))
            {
                int i;
                SetColorTable(0, n, argb, &i);
            }

            CImageList::SelectDstBitmap(NULL);
        }
        
        _clrBlend = CLR_NONE;
    }

    if (_cImage + cImageI + 1 > _cAlloc)
    {
        hr = _ReAllocBitmaps(_cAlloc + max(cImageI, _cGrow) + 1);
    }

    if (SUCCEEDED(hr))
    {
        i = _cImage;
        _cImage += cImageI;

        if (hbmImageI)
        {
            hr = _Replace(i, cImageI, hbmImageI, hbmMaskI, xStart, yStart);

            if (FAILED(hr))
            {
                _cImage -= cImageI;
                i = -1;
            }
        }
    }

    LEAVECRITICAL;
    *pi = i;

    return hr;
}


HRESULT CImageList::_AddValidated(HBITMAP hbmImage, HBITMAP hbmMask, int* pi)
{
    BITMAP bm;
    int cImageI;

    if (GetObject(hbmImage, sizeof(bm), &bm) != sizeof(bm) || bm.bmWidth < _cx)
    {
        return E_INVALIDARG;
    }

    ASSERT(hbmImage);
    ASSERT(_cx);

    cImageI = bm.bmWidth / _cx;     // # of images in source

    // serialization handled within Add2.
    return  _Add(hbmImage, hbmMask, cImageI, 0, 0, pi);
}

HRESULT CImageList::Add(HBITMAP hbmImage, HBITMAP hbmMask, int* pi)
{
   if (_pimlMirror)
   {
       HBITMAP hbmMirroredImage = _CreateMirroredBitmap(hbmImage);
       HBITMAP hbmMirroredMask = _CreateMirroredBitmap(hbmMask);

       _pimlMirror->_AddValidated(hbmMirroredImage, hbmMirroredMask, pi);

       // The caller will take care of deleting hbmImage, hbmMask
       // He knows nothing about hbmMirroredImage, hbmMirroredMask
       DeleteObject(hbmMirroredImage);
       DeleteObject(hbmMirroredMask);
   }    

   return _AddValidated(hbmImage, hbmMask, pi);
}

HRESULT CImageList::_AddMasked(HBITMAP hbmImageI, COLORREF crMask, int* pi)
{
    HRESULT hr = S_OK;
    COLORREF crbO, crtO;
    HBITMAP hbmMaskI;
    int cImageI;
    int n,i;
    BITMAP bm;
    DWORD ColorTableSave[256];
    DWORD ColorTable[256];

    *pi = -1;

    if (GetObject(hbmImageI, sizeof(bm), &bm) != sizeof(bm))
        return E_INVALIDARG;

    hbmMaskI = CreateMonoBitmap(bm.bmWidth, bm.bmHeight);
    if (!hbmMaskI)
        return E_OUTOFMEMORY;

    ENTERCRITICAL;

    // copy color to mono, with crMask turning 1 and all others 0, then
    // punch all crMask pixels in color to 0
    CImageList::SelectSrcBitmap(hbmImageI);
    CImageList::SelectDstBitmap(hbmMaskI);

    // crMask == CLR_DEFAULT, means use the pixel in the upper left
    //
    if (crMask == CLR_DEFAULT)
        crMask = GetPixel(g_hdcSrc, 0, 0);

    // DIBSections dont do color->mono like DDBs do, so we have to do it.
    // this only works for <=8bpp DIBSections, this method does not work
    // for HiColor DIBSections.
    //
    // This code is a workaround for a problem in Win32 when a DIB is converted to 
    // monochrome. The conversion is done according to closeness to white or black
    // and without regard to the background color. This workaround is is not required 
    // under MainWin. 
    //
    // Please note, this code has an endianship problems the comparision in the if statement
    // below is sensitive to endianship
    // ----> if (ColorTableSave[i] == RGB(GetBValue(crMask),GetGValue(crMask),GetRValue(crMask))
    //
    if (bm.bmBits != NULL && bm.bmBitsPixel <= 8)
    {
        n = GetDIBColorTable(g_hdcSrc, 0, 256, (RGBQUAD*)ColorTableSave);

        for (i=0; i<n; i++)
        {
            if (ColorTableSave[i] == RGB(GetBValue(crMask),GetGValue(crMask),GetRValue(crMask)))
                ColorTable[i] = 0x00FFFFFF;
            else
                ColorTable[i] = 0x00000000;
        }

        SetDIBColorTable(g_hdcSrc, 0, n, (RGBQUAD*)ColorTable);
    }

    crbO = ::SetBkColor(g_hdcSrc, crMask);
    BitBlt(g_hdcDst, 0, 0, bm.bmWidth, bm.bmHeight, g_hdcSrc, 0, 0, SRCCOPY);
    ::SetBkColor(g_hdcSrc, 0x00FFFFFFL);
    crtO = SetTextColor(g_hdcSrc, 0x00L);
    BitBlt(g_hdcSrc, 0, 0, bm.bmWidth, bm.bmHeight, g_hdcDst, 0, 0, ROP_DSna);
    ::SetBkColor(g_hdcSrc, crbO);
    SetTextColor(g_hdcSrc, crtO);

    if (bm.bmBits != NULL && bm.bmBitsPixel <= 8)
    {
        SetDIBColorTable(g_hdcSrc, 0, n, (RGBQUAD*)ColorTableSave);
    }

    CImageList::SelectSrcBitmap(NULL);
    CImageList::SelectDstBitmap(NULL);

    ASSERT(_cx);
    cImageI = bm.bmWidth / _cx;    // # of images in source

    hr = _Add(hbmImageI, hbmMaskI, cImageI, 0, 0, pi);

    DeleteObject(hbmMaskI);
    LEAVECRITICAL;
    return hr;
}

HRESULT CImageList::AddMasked(HBITMAP hbmImage, COLORREF crMask, int* pi)
{
   if (_pimlMirror)
   {
       HBITMAP hbmMirroredImage = CImageList::_CreateMirroredBitmap(hbmImage);

       _pimlMirror->_AddMasked(hbmMirroredImage, crMask, pi);

       // The caller will take care of deleting hbmImage
       // He knows nothing about hbmMirroredImage
       DeleteObject(hbmMirroredImage);

   }    

   return _AddMasked(hbmImage, crMask, pi);
}

HRESULT CImageList::_ReplaceValidated(int i, HBITMAP hbmImage, HBITMAP hbmMask)
{
    HRESULT hr = E_INVALIDARG;
    if (!IsImageListIndex(i))
        return hr;

    ENTERCRITICAL;
    hr = _Replace(i, 1, hbmImage, hbmMask, 0, 0);
    LEAVECRITICAL;

    return hr;
}

HRESULT CImageList::Replace(int i, HBITMAP hbmImage, HBITMAP hbmMask)
{
   if (_pimlMirror)
   {
       HBITMAP hbmMirroredImage = CImageList::_CreateMirroredBitmap(hbmImage);
       if (hbmMirroredImage)
       {
           HBITMAP hbmMirroredMask = CImageList::_CreateMirroredBitmap(hbmMask);
           if (hbmMirroredMask)
           {
               _pimlMirror->_ReplaceValidated(i, hbmMirroredImage, hbmMirroredMask);

               // The caller will take care of deleting hbmImage, hbmMask
               // He knows nothing about hbmMirroredImage, hbmMirroredMask
               DeleteObject(hbmMirroredMask);
           }
       
           DeleteObject(hbmMirroredImage);
       }
       
   }    

   return _ReplaceValidated(i, hbmImage, hbmMask);
}


// replaces images in piml with images from bitmaps
//
// in:
//    piml
//    i    index in image list to start at (replace)
//    _cImage    count of images in source (hbmImage, hbmMask)
//

HRESULT CImageList::_Replace(int i, int cImageI, HBITMAP hbmImageI, HBITMAP hbmMaskI,
    int xStart, int yStart)
{
    RECT rcImage;
    int x, iImage;

    ASSERT(_hbmImage);

    CImageList::SelectSrcBitmap(hbmImageI);
    if (_hdcMask) 
        CImageList::SelectDstBitmap(hbmMaskI); // using as just a second source hdc

    for (x = xStart, iImage = 0; iImage < cImageI; iImage++, x += _cx) 
    {
    
        GetImageRect(i + iImage, &rcImage);

        if (_hdcMask)
        {
            BitBlt(_hdcMask, rcImage.left, rcImage.top, _cx, _cy,
                    g_hdcDst, x, yStart, SRCCOPY);
        }

        BitBlt(_hdcImage, rcImage.left, rcImage.top, _cx, _cy,
                g_hdcSrc, x, yStart, SRCCOPY);
    }

    _ResetBkColor(i, i + cImageI - 1, _clrBk);

    CImageList::SelectSrcBitmap(NULL);
    if (_hdcMask) 
        CImageList::SelectDstBitmap(NULL);

    return S_OK;
}

HRESULT CImageList::GetIcon(int i, UINT flags, HICON* phicon)
{
    UINT cxImage, cyImage;
    HICON hIcon = NULL;
    HBITMAP hbmMask, hbmColor;
    ICONINFO ii;
    HRESULT hr = E_OUTOFMEMORY;

    if (!IsImageListIndex(i))
        return E_INVALIDARG;

    cxImage = _cx;
    cyImage = _cy;

    hbmColor = CreateColorBitmap(cxImage, cyImage);
    if (hbmColor)
    {
        hbmMask = CreateMonoBitmap(cxImage, cyImage);
        if (hbmMask)
        {
            ENTERCRITICAL;
            CImageList::SelectDstBitmap(hbmMask);
            PatBlt(g_hdcDst, 0, 0, cxImage, cyImage, WHITENESS);
            WimpyDraw(SAFECAST(this, IImageList*), i, g_hdcDst, 0, 0, ILD_MASK | flags);

            CImageList::SelectDstBitmap(hbmColor);
            PatBlt(g_hdcDst, 0, 0, cxImage, cyImage, BLACKNESS);
            WimpyDraw(SAFECAST(this, IImageList*), i, g_hdcDst, 0, 0, ILD_TRANSPARENT | flags);

            CImageList::SelectDstBitmap(NULL);
            LEAVECRITICAL;

            ii.fIcon    = TRUE;
            ii.xHotspot = 0;
            ii.yHotspot = 0;
            ii.hbmColor = hbmColor;
            ii.hbmMask  = hbmMask;
            hIcon = CreateIconIndirect(&ii);
            DeleteObject(hbmMask);

            hr = S_OK;
        }
        DeleteObject(hbmColor);
    }
    *phicon = hIcon;

    return hr;
}

// this removes an image from the bitmap but doing all the
// proper shuffling.
//
//   this does the following:
//    if the bitmap being removed is not the last in the row
//        it blts the images to the right of the one being deleted
//        to the location of the one being deleted (covering it up)
//
//    for all rows until the last row (where the last image is)
//        move the image from the next row up to the last position
//        in the current row.  then slide over all images in that
//        row to the left.

void CImageList::_RemoveItemBitmap(int i)
{
    RECT rc1;
    RECT rc2;
    int dx, y;
    int x;
    
    GetImageRect(i, &rc1);
    GetImageRect(_cImage - 1, &rc2);

    // the row with the image being deleted, do we need to shuffle?
    // amount of stuff to shuffle
    dx = _cStrip * _cx - rc1.right;

    if (dx) 
    {
        // yes, shuffle things left
        BitBlt(_hdcImage, rc1.left, rc1.top, dx, _cy, _hdcImage, rc1.right, rc1.top, SRCCOPY);
        if (_hdcMask)  
            BitBlt(_hdcMask,  rc1.left, rc1.top, dx, _cy, _hdcMask,  rc1.right, rc1.top, SRCCOPY);
    }

    y = rc1.top;    // top of row we are working on
    x = _cx * (_cStrip - 1); // x coord of last bitmaps in each row
    while (y < rc2.top) 
    {
    
        // copy first from row below to last image position on this row
        BitBlt(_hdcImage, x, y,
                   _cx, _cy, _hdcImage, 0, y + _cy, SRCCOPY);

            if (_hdcMask)
                BitBlt(_hdcMask, x, y,
                   _cx, _cy, _hdcMask, 0, y + _cy, SRCCOPY);

        y += _cy;    // jump to row to slide left

        if (y <= rc2.top) 
        {

            // slide the rest over to the left
            BitBlt(_hdcImage, 0, y, x, _cy,
                       _hdcImage, _cx, y, SRCCOPY);

            // slide the rest over to the left
            if (_hdcMask)
            {
                BitBlt(_hdcMask, 0, y, x, _cy,
                       _hdcMask, _cx, y, SRCCOPY);
            }
        }
    }
}

//
//  ImageList_Remove - remove a image from the image list
//
//  i - image to remove, or -1 to remove all images.
//
//  NOTE all images are "shifted" down, ie all image index's
//  above the one deleted are changed by 1
//
HRESULT CImageList::_Remove(int i)
{
    HRESULT hr = S_OK;

    ENTERCRITICAL;

    if (i == -1)
    {
        _cImage = 0;
        _cAlloc = 0;

        for (i=0; i<NUM_OVERLAY_IMAGES; i++)
            _aOverlayIndexes[i] = -1;

        _ReAllocBitmaps(-_cGrow);
    }
    else
    {
        if (!IsImageListIndex(i))
        {
            hr = E_INVALIDARG;
        }
        else
        {
            _RemoveItemBitmap(i);

            --_cImage;

            if (_cAlloc - (_cImage + 1) > _cGrow)
                _ReAllocBitmaps(_cAlloc - _cGrow);
        }
    }
    LEAVECRITICAL;

    return hr;
}

HRESULT CImageList::Remove(int i)
{
    if (_pimlMirror)
    {
        _pimlMirror->_Remove(i);
    }

    return _Remove(i);
}

BOOL CImageList::_IsSameObject(IUnknown* punk)
{
    BOOL fRet = FALSE;
    IUnknown* me;
    IUnknown* them;

    if (punk == NULL)
        return FALSE;

    QueryInterface(IID_PPV_ARG(IUnknown, &me));
    if (SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IUnknown, &them))))
    {
        fRet = (me == them);
        them->Release();
    }

    me->Release();

    return fRet;
}

//
//  ImageList_Copy - move an image in the image list
//
HRESULT CImageList::Copy(int iDst, IUnknown* punkSrc, int iSrc, UINT uFlags)
{
    RECT rcDst, rcSrc, rcTmp;
    CImageList* pimlTmp;
    CImageList* pimlSrc;
    HRESULT hr = E_FAIL;

    if (uFlags & ~ILCF_VALID)
    {
        // don't let hosers pass bogus flags
        RIPMSG(0, "ImageList_Copy: Invalid flags %08x", uFlags);
        return E_INVALIDARG;
    }

    // Not supported 
    if (!_IsSameObject(punkSrc))
    {
        return E_INVALIDARG;
    }


    // We only support copies on ourself... Weird
    pimlSrc = this;

    ENTERCRITICAL;
    pimlTmp = (uFlags & ILCF_SWAP)? pimlSrc : NULL;

    if (SUCCEEDED(GetImageRect(iDst, &rcDst)) &&
        SUCCEEDED(pimlSrc->GetImageRect(iSrc, &rcSrc)) &&
        (!pimlTmp || pimlTmp->GetSpareImageRect(&rcTmp)))
    {
        int cx = pimlSrc->_cx;
        int cy = pimlSrc->_cy;

        //
        // iff we are swapping we need to save the destination image
        //
        if (pimlTmp)
        {
            BitBlt(pimlTmp->_hdcImage, rcTmp.left, rcTmp.top, cx, cy,
                   _hdcImage, rcDst.left, rcDst.top, SRCCOPY);

            if (pimlTmp->_hdcMask)
            {
                BitBlt(pimlTmp->_hdcMask, rcTmp.left, rcTmp.top, cx, cy,
                       _hdcMask, rcDst.left, rcDst.top, SRCCOPY);
            }
        }

        //
        // copy the image
        //
        BitBlt(_hdcImage, rcDst.left, rcDst.top, cx, cy,
           pimlSrc->_hdcImage, rcSrc.left, rcSrc.top, SRCCOPY);

        if (pimlSrc->_hdcMask)
        {
            BitBlt(_hdcMask, rcDst.left, rcDst.top, cx, cy,
                   pimlSrc->_hdcMask, rcSrc.left, rcSrc.top, SRCCOPY);
        }

        //
        // iff we are swapping we need to copy the saved image too
        //
        if (pimlTmp)
        {
            BitBlt(pimlSrc->_hdcImage, rcSrc.left, rcSrc.top, cx, cy,
                   pimlTmp->_hdcImage, rcTmp.left, rcTmp.top, SRCCOPY);

            if (pimlSrc->_hdcMask)
            {
                BitBlt(pimlSrc->_hdcMask, rcSrc.left, rcSrc.top, cx, cy,
                       pimlTmp->_hdcMask, rcTmp.left, rcTmp.top, SRCCOPY);
            }
        }

        hr = S_OK;
    }

    LEAVECRITICAL;
    return hr;
}

// IS_WHITE_PIXEL, BITS_ALL_WHITE are macros for looking at monochrome bits
// to determine if certain pixels are white or black.  Note that within a byte
// the most significant bit represents the left most pixel.
//
#define IS_WHITE_PIXEL(pj,x,y,cScan) \
    ((pj)[((y) * (cScan)) + ((x) >> 3)] & (1 << (7 - ((x) & 7))))

#define BITS_ALL_WHITE(b) (b == 0xff)

// Set the image iImage as one of the special images for us in combine
// drawing.  to draw with these specify the index of this
// in:
//      piml    imagelist
//      iImage  image index to use in speical drawing
//      iOverlay        index of special image, values 1-4

HRESULT CImageList::_SetOverlayImage(int iImage, int iOverlay)
{
    RECT    rcImage;
    RECT    rc;
    int     x,y;
    int     cxI,cyI;
    ULONG   cScan;
    ULONG   cBits;
    HBITMAP hbmMem;
    HRESULT hr = S_FALSE;

    iOverlay--;         // make zero based
    if (_hdcMask == NULL ||
        iImage < 0 || iImage >= _cImage ||
        iOverlay < 0 || iOverlay >= NUM_OVERLAY_IMAGES)
    {
        return E_INVALIDARG;
    }

    if (_aOverlayIndexes[iOverlay] == (SHORT)iImage)
        return S_OK;

    _aOverlayIndexes[iOverlay] = (SHORT)iImage;

    //
    // find minimal rect that bounds the image
    //
    GetImageRect(iImage, &rcImage);
    SetRect(&rc, 0x7FFF, 0x7FFF, 0, 0);

    //
    // now compute the black box.  This is much faster than GetPixel but
    // could still be improved by doing more operations looking at entire
    // bytes.  We basicaly get the bits in monochrome form and then use
    // a private GetPixel.  This decreased time on NT from 50 milliseconds to
    // 1 millisecond for a 32X32 image.
    //
    cxI     = rcImage.right  - rcImage.left;
    cyI     = rcImage.bottom - rcImage.top;

    // compute the number of bytes in a scan.  Note that they are WORD alligned
    cScan  = (((cxI + (sizeof(SHORT)*8 - 1)) / 16) * 2);
    cBits  = cScan * cyI;

    hbmMem = CreateBitmap(cxI,cyI,1,1,NULL);

    if (hbmMem)
    {
        HDC     hdcMem = CreateCompatibleDC(_hdcMask);

        if (hdcMem)
        {
            PBYTE   pBits  = (PBYTE)LocalAlloc(LMEM_FIXED,cBits);
            PBYTE   pScan;

            if (pBits)
            {
                SelectObject(hdcMem,hbmMem);

                //
                // map black pixels to 0, white to 1
                //
                BitBlt(hdcMem, 0, 0, cxI, cyI, _hdcMask, rcImage.left, rcImage.top, SRCCOPY);

                //
                // fill in the bits
                //
                GetBitmapBits(hbmMem,cBits,pBits);

                //
                // for each scan, find the bounds
                //
                for (y = 0, pScan = pBits; y < cyI; ++y,pScan += cScan)
                {
                    int i;

                    //
                    // first go byte by byte through white space
                    //
                    for (x = 0, i = 0; (i < (cxI >> 3)) && BITS_ALL_WHITE(pScan[i]); ++i)
                    {
                        x += 8;
                    }

                    //
                    // now finish the scan bit by bit
                    //
                    for (; x < cxI; ++x)
                    {
                        if (!IS_WHITE_PIXEL(pBits, x,y,cScan))
                        {
                            rc.left   = min(rc.left, x);
                            rc.right  = max(rc.right, x+1);
                            rc.top    = min(rc.top, y);
                            rc.bottom = max(rc.bottom, y+1);

                            // now that we found one, quickly jump to the known right edge

                            if ((x >= rc.left) && (x < rc.right))
                            {
                                x = rc.right-1;
                            }
                        }
                    }
                }

                if (rc.left == 0x7FFF) 
                {
                    rc.left = 0;
                    ASSERT(0);
                }

                if (rc.top == 0x7FFF) 
                {
                    rc.top = 0;
                    ASSERT(0);
                }

                _aOverlayDX[iOverlay] = (SHORT)(rc.right - rc.left);
                _aOverlayDY[iOverlay] = (SHORT)(rc.bottom- rc.top);
                _aOverlayX[iOverlay]  = (SHORT)(rc.left);
                _aOverlayY[iOverlay]  = (SHORT)(rc.top);
                _aOverlayF[iOverlay]  = 0;

                //
                // see if the image is non-rectanglar
                //
                // if the overlay does not require a mask to be drawn set the
                // ILD_IMAGE flag, this causes ImageList_DrawEx to just
                // draw the image, ignoring the mask.
                //
                for (y=rc.top; y<rc.bottom; y++)
                {
                    for (x=rc.left; x<rc.right; x++)
                    {
                        if (IS_WHITE_PIXEL(pBits, x, y,cScan))
                            break;
                    }

                    if (x != rc.right)
                        break;
                }

                if (y == rc.bottom)
                    _aOverlayF[iOverlay] = ILD_IMAGE;

                LocalFree(pBits);

                hr = S_OK;
            }

            DeleteDC(hdcMem);
        }

        DeleteObject(hbmMem);
    }

    return hr;
}

HRESULT CImageList::SetOverlayImage(int iImage, int iOverlay)
{
    if (_pimlMirror)
    {
        _pimlMirror->_SetOverlayImage(iImage, iOverlay);
    }

    return _SetOverlayImage(iImage, iOverlay);
}

/*
**  BlendCT
**
*/
void BlendCT(DWORD *pdw, DWORD rgb, UINT n, UINT count)
{
    UINT i;

    for (i=0; i<count; i++)
    {
        pdw[i] = RGB(
            ((UINT)GetRValue(pdw[i]) * (100-n) + (UINT)GetBValue(rgb) * (n)) / 100,
            ((UINT)GetGValue(pdw[i]) * (100-n) + (UINT)GetGValue(rgb) * (n)) / 100,
            ((UINT)GetBValue(pdw[i]) * (100-n) + (UINT)GetRValue(rgb) * (n)) / 100);
    }
}

/*
** ImageList_BlendDither
**
**  copy the source to the dest blended with the given color.
**
**  simulate a blend with a dither pattern.
**
*/
void ImageList_BlendDither(HDC hdcDst, int xDst, int yDst, CImageList* piml, int x, int y, int cx, int cy, COLORREF rgb, UINT fStyle)
{
    HBRUSH hbr;
    HBRUSH hbrT;
    HBRUSH hbrMask;
    HBRUSH hbrFree = NULL;         // free if non-null

    ASSERT(GetTextColor(hdcDst) == CLR_BLACK);
    ASSERT(::GetBkColor(hdcDst) == CLR_WHITE);

    // choose a dither/blend brush

    switch (fStyle & ILD_BLENDMASK)
    {
        default:
        case ILD_BLEND50:
            hbrMask = g_hbrMonoDither;
            break;
    }

    // create (or use a existing) brush for the blend color

    switch (rgb)
    {
        case CLR_DEFAULT:
            hbr = g_hbrHighlight;
            break;

        case CLR_NONE:
            hbr = piml->_hbrBk;
            break;

        default:
            if (rgb == piml->_clrBk)
                hbr = piml->_hbrBk;
            else
                hbr = hbrFree = CreateSolidBrush(rgb);
            break;
    }

    hbrT = (HBRUSH)SelectObject(hdcDst, hbr);
    PatBlt(hdcDst, xDst, yDst, cx, cy, PATCOPY);
    SelectObject(hdcDst, hbrT);

    hbrT = (HBRUSH)SelectObject(hdcDst, hbrMask);
    BitBlt(hdcDst, xDst, yDst, cx, cy, piml->_hdcImage, x, y, ROP_MaskPat);
    SelectObject(hdcDst, hbrT);

    if (hbrFree)
        DeleteBrush(hbrFree);
}

/*
** ImageList_BlendCT
**
**  copy the source to the dest blended with the given color.
**
*/
void ImageList_BlendCT(HDC hdcDst, int xDst, int yDst, CImageList* piml, int x, int y, int cx, int cy, COLORREF rgb, UINT fStyle)
{
    BITMAP bm;

    GetObject(piml->_hbmImage, sizeof(bm), &bm);

    if (rgb == CLR_DEFAULT)
        rgb = GetSysColor(COLOR_HIGHLIGHT);

    ASSERT(rgb != CLR_NONE);

    //
    // get the DIB color table and blend it, only do this when the
    // blend color changes
    //
    if (piml->_clrBlend != rgb)
    {
        int n,cnt;

        piml->_clrBlend = rgb;

        GetObject(piml->_hbmImage, sizeof(piml->dib), &piml->dib.bm);
        cnt = GetDIBColorTable(piml->_hdcImage, 0, 256, (LPRGBQUAD)&piml->dib.ct);

        if ((fStyle & ILD_BLENDMASK) == ILD_BLEND50)
            n = 50;
        else
            n = 25;

        BlendCT(piml->dib.ct, rgb, n, cnt);
    }

    //
    // draw the image with a different color table
    //
    StretchDIBits(hdcDst, xDst, yDst, cx, cy,
        x, piml->dib.bi.biHeight-(y+cy), cx, cy,
        bm.bmBits, (LPBITMAPINFO)&piml->dib.bi, DIB_RGB_COLORS, SRCCOPY);
}


/*
**  RGB555 macros
*/
#define RGB555(r,g,b)       (((((r)>>3)&0x1F)<<10) | ((((g)>>3)&0x1F)<<5) | (((b)>>3)&0x1F))
#define R_555(w)            (int)(((w) >> 7) & 0xF8)
#define G_555(w)            (int)(((w) >> 2) & 0xF8)
#define B_555(w)            (int)(((w) << 3) & 0xF8)

/*
**  DIBXY16() macro - compute a pointer to a pixel given a (x,y)
*/
#define DIBXY16(bm,x,y) \
    (WORD*)((BYTE*)bm.bmBits + (bm.bmHeight-1-(y))*bm.bmWidthBytes + (x)*2)

/*
**  Blend16
**
**  dest.r = source.r * (1-a) + (rgb.r * a)
*/
void Blend16(
    WORD*   dst,        // destination RGB 555 bits
    int     dst_pitch,  // width in bytes of a dest scanline
    WORD*   src,        // source RGB 555 bits
    int     src_pitch,  // width in bytes of a source scanline
    int     cx,         // width in pixels
    int     cy,         // height in pixels
    DWORD   rgb,        // color to blend
    int     a)          // alpha value
{
    int i,x,y,r,g,b,sr,sg,sb;

    // subtract off width from pitch
    dst_pitch = dst_pitch - cx*2;
    src_pitch = src_pitch - cx*2;

    if (rgb == CLR_NONE)
    {
        // blending with the destination, we ignore the alpha and always
        // do 50% (this is what the old dither mask code did)

        for (y=0; y<cy; y++)
        {
            for (x=0; x<cx; x++)
            {
                *dst++ = ((*dst & 0x7BDE) >> 1) + ((*src++ & 0x7BDE) >> 1);
            }
            dst = (WORD *)((BYTE *)dst + dst_pitch);
            src = (WORD *)((BYTE *)src + src_pitch);
        }
    }
    else
    {
        // blending with a solid color

        // pre multiply source (constant) rgb by alpha
        sr = GetRValue(rgb) * a;
        sg = GetGValue(rgb) * a;
        sb = GetBValue(rgb) * a;

        // compute inverse alpha for inner loop
        a = 256 - a;

        // special case a 50% blend, to avoid a multiply

        if (a == 128)
        {
            sr = RGB555(sr>>8,sg>>8,sb>>8);

            for (y=0; y<cy; y++)
            {
                for (x=0; x<cx; x++)
                {
                    i = *src++;
                    i = sr + ((i & 0x7BDE) >> 1);
                    *dst++ = (WORD) i;
                }
                dst = (WORD *)((BYTE *)dst + dst_pitch);
                src = (WORD *)((BYTE *)src + src_pitch);
            }
        }
        else
        {
            for (y=0; y<cy; y++)
            {
                for (x=0; x<cx; x++)
                {
                    i = *src++;
                    r = (R_555(i) * a + sr) >> 8;
                    g = (G_555(i) * a + sg) >> 8;
                    b = (B_555(i) * a + sb) >> 8;
                    *dst++ = RGB555(r,g,b);
                }
                dst = (WORD *)((BYTE *)dst + dst_pitch);
                src = (WORD *)((BYTE *)src + src_pitch);
            }
        }
    }
}

/*
** ImageList_Blend16
**
**  copy the source to the dest blended with the given color.
**
**  source is assumed to be a 16 bit (RGB 555) bottom-up DIBSection
**  (this is the only kind of DIBSection we create)
*/
void ImageList_Blend16(HDC hdcDst, int xDst, int yDst, CImageList* piml, int x, int y, int cx, int cy, COLORREF rgb, UINT fStyle)
{
    BITMAP bm;
    RECT rc;
    int  a;

    // get bitmap info for source bitmap
    GetObject(piml->_hbmImage, sizeof(bm), &bm);
    ASSERT(bm.bmBitsPixel==16);

    // get blend RGB
    if (rgb == CLR_DEFAULT)
        rgb = GetSysColor(COLOR_HIGHLIGHT);

    // get blend factor as a fraction of 256
    // only 50% or 25% is currently used.
    if ((fStyle & ILD_BLENDMASK) == ILD_BLEND50)
        a = 128;
    else
        a = 64;

    // blend the image with the specified color and place at end of image list
    piml->GetSpareImageRect(&rc);

    // if blending with the destination, copy the dest to our work buffer
    if (rgb == CLR_NONE)
        BitBlt(piml->_hdcImage, rc.left, rc.top, cx, cy, hdcDst, xDst, yDst, SRCCOPY);

    // sometimes the user can change the icon size (via plustab) between 32x32 and 48x48,
    // thus the values we have might be bigger than the actual bitmap. To prevent us from
    // crashing in Blend16 when this happens we do some bounds checks here
    if (rc.left + cx <= bm.bmWidth  &&
        rc.top  + cy <= bm.bmHeight &&
        x + cx       <= bm.bmWidth  &&
        y + cy       <= bm.bmHeight)
    {
        Blend16(DIBXY16(bm,rc.left,rc.top), -(int)bm.bmWidthBytes,
                DIBXY16(bm,x,y), -(int)bm.bmWidthBytes, cx, cy, rgb, a);
    }

    // blt blended image to the dest DC
    BitBlt(hdcDst, xDst, yDst, cx, cy, piml->_hdcImage, rc.left, rc.top, SRCCOPY);
}

/*
** ImageList_Blend
**
**  copy the source to the dest blended with the given color.
**  top level function to decide what blend function to call
*/
void ImageList_Blend(HDC hdcDst, int xDst, int yDst, CImageList* piml, int x, int y, int cx, int cy, COLORREF rgb, UINT fStyle)
{
    BITMAP bm;
    int bpp = GetDeviceCaps(hdcDst, BITSPIXEL);

    GetObject(piml->_hbmImage, sizeof(bm), &bm);

    //
    // if _hbmImage is a DIBSection and we are on a HiColor device
    // the do a "real" blend
    //
    if (bm.bmBits && bm.bmBitsPixel <= 8 && (bpp > 8 || bm.bmBitsPixel==8))
    {
        // blend from a 4bit or 8bit DIB
        ImageList_BlendCT(hdcDst, xDst, yDst, piml, x, y, cx, cy, rgb, fStyle);
    }
    else if (bm.bmBits && bm.bmBitsPixel == 16 && bpp > 8)
    {
        // blend from a 16bit 555 DIB
        ImageList_Blend16(hdcDst, xDst, yDst, piml, x, y, cx, cy, rgb, fStyle);
    }
    else
    {
        // simulate a blend with a dither pattern.
        ImageList_BlendDither(hdcDst, xDst, yDst, piml, x, y, cx, cy, rgb, fStyle);
    }
}

BOOL BlurBitmap(ULONG* plBitmapBits, SIZE size, COLORREF crFill)
{
    USHORT aus0[64];
    USHORT aus1[64];
    USHORT aus2[64];
    USHORT aus3[64];
    USHORT aus4[64];
    PUSHORT apus[5];
    PULONG pulIn = (PULONG) plBitmapBits;
    PULONG pulTmp;
    USHORT *pus, *pusEnd;
    ULONG j;
    PULONG pulOut = (PULONG) (plBitmapBits + 2 * size.cx) + 2;
    ULONG ulNumScans = size.cy - 4;
    ULONG ulNext = 0;



    if (size.cx > 64)
    {
        apus[0] = (PUSHORT) LocalAlloc(LPTR, size.cx * sizeof(USHORT) * 5);
        if (apus[0])
        {
            apus[1] = apus[0] + size.cx;
            apus[2] = apus[1] + size.cx;
            apus[3] = apus[2] + size.cx;
            apus[4] = apus[3] + size.cx;
        }
    }
    else
    {
        apus[0] = aus0;
        apus[1] = aus1;
        apus[2] = aus2;
        apus[3] = aus3;
        apus[4] = aus4;
    }

    if (apus[0] == NULL)
    {
        return FALSE;
    }

    // Fill up the scanline memory with 3x1 boxcar sums for the
    // first three scanlines.

    for (j = 0; j < 5; j++)
    {
        // Compute the scanline sum.  Note that output is two pixels
        // smaller than the input.

        pus = apus[j];
        pusEnd = pus + (size.cx - 4);
        pulTmp = pulIn;

        while (pus < pusEnd)
        {
            *pus = (USHORT) ((pulTmp[0] >> 24) + (pulTmp[1] >> 24) + (pulTmp[2] >> 24) + (pulTmp[3] >> 24) + (pulTmp[4] >> 24));
            pus    += 1;
            pulTmp += 1;
        }

        // Next scanline.

        pulIn = (PULONG)(pulIn + size.cx);
    }

    // Compute the average (3x3 boxcar convolution) for each output
    // scanline.

    while (ulNumScans--)
    {
        // Setup output pointers.

        PULONG pulAvg = pulOut;
        PULONG pulAvgEnd = pulAvg + (size.cx - 4);

        // Setup pointers to run the scanline 3x1 sums.

        PUSHORT pusTmp[5];

        pusTmp[0] = apus[0];
        pusTmp[1] = apus[1];
        pusTmp[2] = apus[2];
        pusTmp[3] = apus[4];
        pusTmp[4] = apus[3];

        // Compute the average scanline.

        while (pulAvg < pulAvgEnd)
        {
            USHORT usSum;
            BYTE alpha;

            // Unroll this...

            // Strictly speaking we should divide the sum by 9, but since
            // this is just for looks, we can approximate as a divide by 8
            // minus a divide by 64 (will produce in a slightly too small
            // result).
            //
            //      1/9                = 0.111111111...    in decimal
            //                         = 0.000111000111... in binary

            //      1/25
            //
            // Approximations:
            //
            //      1/8 - 1/64                  = 0.109375
            //      1/8 - 1/64 + 1/512          = 0.111328125
            //      1/8 - 1/64 + 1/512 - 1/4096 = 0.111083984

            usSum = *pusTmp[0] + *pusTmp[1] + *pusTmp[2] + *pusTmp[3] + *pusTmp[4];
            //*pulAvg = (usSum / 9) << 24;
            //*pulAvg = ((usSum >> 3) - (usSum >> 6)) << 24;
            alpha = usSum/25; //(usSum >> 5) - (usSum >> 4);

            ((RGBQUAD*)pulAvg)->rgbReserved = (BYTE)alpha;
            ((RGBQUAD*)pulAvg)->rgbRed      = ((GetRValue(crFill) * alpha) + 128) / 255;
            ((RGBQUAD*)pulAvg)->rgbGreen    = ((GetGValue(crFill) * alpha) + 128) / 255;
            ((RGBQUAD*)pulAvg)->rgbBlue     = ((GetBValue(crFill) * alpha) + 128) / 255;

            pulAvg    += 1;
            pusTmp[0] += 1;
            pusTmp[1] += 1;
            pusTmp[2] += 1;
            pusTmp[3] += 1;
            pusTmp[4] += 1;
        }

        // Next output scanline.

        pulOut = (PULONG) (pulOut + size.cx);

        // Need to compute 3x1 boxcar sum for the next scanline.

        if (ulNumScans)
        {
            // Compute the scanline sum.  Note that output is two pixels
            // smaller than the input.

            pus = apus[ulNext];
            pusEnd = pus + (size.cx - 4);
            pulTmp = pulIn;

            while (pus < pusEnd)
            {
                *pus = (USHORT) ((pulTmp[0] >> 24) + (pulTmp[1] >> 24) + (pulTmp[2] >> 24) + (pulTmp[3] >> 24) + (pulTmp[4] >> 24));
                pus    += 1;
                pulTmp += 1;
            }

            // Next scanline.

            pulIn = (PULONG)(pulIn + size.cx);

            // Next scanline summation buffer.

            ulNext++;
            if (ulNext >= 5)
                ulNext = 0;
        }
    }

    // Cleanup temporary memory.

    if (apus[0] != aus0)
    {
        LocalFree(apus[0]);
    }

    return TRUE;
}


/*
** Draw the image, either selected, transparent, or just a blt
**
** For the selected case, a new highlighted image is generated
** and used for the final output.
**
**      piml    ImageList to get image from.
**      i       the image to get.
**      hdc     DC to draw image to
**      x,y     where to draw image (upper left corner)
**      cx,cy   size of image to draw (0,0 means normal size)
**
**      rgbBk   background color
**              CLR_NONE            - draw tansparent
**              CLR_DEFAULT         - use bk color of the image list
**
**      rgbFg   foreground (blend) color (only used if ILD_BLENDMASK set)
**              CLR_NONE            - blend with destination (transparent)
**              CLR_DEFAULT         - use windows hilight color
**
**  if blend
**      if blend with color
**          copy image, and blend it with color.
**      else if blend with dst
**          copy image, copy mask, blend mask 50%
##
**  if ILD_TRANSPARENT
**      draw transparent (two blts) special case black or white background
**      unless we copied the mask or image
**  else if (rgbBk == piml->rgbBk && _fSolidBk)
**      just blt it
**  else if mask
**      copy image
**      replace bk color
**      blt it.
**  else
**      just blt it
*/

extern "C" void SaturateDC(void* pvBitmapBits, int Amount, RECT* prcColumn, RECT* prcImage);


HRESULT CImageList::Draw(IMAGELISTDRAWPARAMS* pimldp) 
{
    RECT rcImage;
    RECT rc;
    HBRUSH  hbrT;

    BOOL    fImage;
    HDC     hdcMaskI;
    HDC     hdcImageI;
    int     xMask, yMask;
    int     xImage, yImage;

    IMAGELISTDRAWPARAMS imldp = {0};


    if (pimldp->cbSize != sizeof(IMAGELISTDRAWPARAMS))
    {
        if (pimldp->cbSize == IMAGELISTDRAWPARAMS_V3_SIZE)
        {
            memcpy(&imldp, pimldp, IMAGELISTDRAWPARAMS_V3_SIZE);
            imldp.cbSize = sizeof(IMAGELISTDRAWPARAMS);
            pimldp = &imldp;
        }
        else
            return E_INVALIDARG;
    }
    
    if (!IsImageListIndex(pimldp->i))
        return E_INVALIDARG;

    //
    // If we need to use the mirrored imagelist, then let's set it.
    //
    if (_pimlMirror &&
        (IS_DC_RTL_MIRRORED(pimldp->hdcDst)))
    {
        return _pimlMirror->Draw(pimldp);
    }

    ENTERCRITICAL;

    GetImageRect(pimldp->i, &rcImage);
    rcImage.left += pimldp->xBitmap;
    rcImage.top += pimldp->yBitmap;
        
    if (pimldp->rgbBk == CLR_DEFAULT)
        pimldp->rgbBk = _clrBk;

    if (pimldp->rgbBk == CLR_NONE)
        pimldp->fStyle |= ILD_TRANSPARENT;

    if (pimldp->cx == 0)
        pimldp->cx = rcImage.right  - rcImage.left;

    if (pimldp->cy == 0)
        pimldp->cy = rcImage.bottom - rcImage.top;

again:
    hdcMaskI = _hdcMask;
    xMask = rcImage.left;
    yMask = rcImage.top;

    hdcImageI = _hdcImage;
    xImage = rcImage.left;
    yImage = rcImage.top;

    if (pimldp->fStyle & ILD_BLENDMASK)
    {
        // make a copy of the image, because we will have to modify it
        hdcImageI = ImageList_GetWorkDC(pimldp->hdcDst, pimldp->cx, pimldp->cy);
        xImage = 0;
        yImage = 0;

        //
        //  blend with the destination
        //  by "oring" the mask with a 50% dither mask
        //
        if (pimldp->rgbFg == CLR_NONE && hdcMaskI)
        {
            if ((_flags & ILC_COLORMASK) == ILC_COLOR16 &&
                !(pimldp->fStyle & ILD_MASK))
            {
                // copy dest to our work buffer
                BitBlt(hdcImageI, 0, 0, pimldp->cx, pimldp->cy, pimldp->hdcDst, pimldp->x, pimldp->y, SRCCOPY);

                // blend source into our work buffer
                ImageList_Blend16(hdcImageI, 0, 0,
                    this, rcImage.left, rcImage.top, pimldp->cx, pimldp->cy, pimldp->rgbFg, pimldp->fStyle);
            }
            else
            {
                GetSpareImageRect(&rc);
                xMask = rc.left;
                yMask = rc.top;

                // copy the source image
                BitBlt(hdcImageI, 0, 0, pimldp->cx, pimldp->cy,
                       _hdcImage, rcImage.left, rcImage.top, SRCCOPY);

                // make a dithered copy of the mask
                hbrT = (HBRUSH)SelectObject(hdcMaskI, g_hbrMonoDither);
                BitBlt(hdcMaskI, rc.left, rc.top, pimldp->cx, pimldp->cy,
                       _hdcMask, rcImage.left, rcImage.top, ROP_PSo);
                SelectObject(hdcMaskI, hbrT);
            }

            pimldp->fStyle |= ILD_TRANSPARENT;
        }
        else
        {
            // blend source into our work buffer
            ImageList_Blend(hdcImageI, 0, 0,
                this, rcImage.left, rcImage.top, pimldp->cx, pimldp->cy, pimldp->rgbFg, pimldp->fStyle);
        }
    }

    // is the source image from the image list (not hdcWork)
    fImage = hdcImageI == _hdcImage;

    if ((pimldp->fStyle & ILD_MASK) && hdcMaskI)
    {
    //
    // ILD_MASK means draw the mask only
    //
        DWORD dwRop;
        
        ASSERT(GetTextColor(pimldp->hdcDst) == CLR_BLACK);
        ASSERT(::GetBkColor(pimldp->hdcDst) == CLR_WHITE);
        
        if (pimldp->fStyle & ILD_ROP)
            dwRop = pimldp->dwRop;
        else if (pimldp->fStyle & ILD_TRANSPARENT)
            dwRop = SRCAND;
        else 
            dwRop = SRCCOPY;
        
        BitBlt(pimldp->hdcDst, pimldp->x, pimldp->y, pimldp->cx, pimldp->cy, hdcMaskI, xMask, yMask, dwRop);
    }
    else if (pimldp->fStyle & ILD_IMAGE)
    {
        COLORREF clrBk = ::GetBkColor(hdcImageI);
        DWORD dwRop;
        
        if (pimldp->rgbBk != CLR_DEFAULT) 
        {
            ::SetBkColor(hdcImageI, pimldp->rgbBk);
        }
        
        if (pimldp->fStyle & ILD_ROP)
            dwRop = pimldp->dwRop;
        else
            dwRop = SRCCOPY;
        
        BitBlt(pimldp->hdcDst, pimldp->x, pimldp->y, pimldp->cx, pimldp->cy, hdcImageI, xImage, yImage, dwRop);
        
        ::SetBkColor(hdcImageI, clrBk);
    }
    else if ((pimldp->fStyle & ILD_TRANSPARENT) && hdcMaskI)
    {
    //
    // if there is a mask and the drawing is to be transparent,
    // use the mask for the drawing.
    //

    //
    // on NT dont mess around, just call MaskBlt
    //
#if defined(USE_MASKBLT) && !defined(MAINWIN)
        MaskBlt(pimldp->hdcDst, pimldp->x, pimldp->y, pimldp->cx, pimldp->cy, hdcImageI, xImage, yImage, _hbmMask, xMask, yMask, 0xCCAA0000);
#else
        COLORREF clrTextSave;
        COLORREF clrBkSave;

        //
        //  we have some special cases:
        //
        //  if the background color is black, we just do a AND then OR
        //  if the background color is white, we just do a OR then AND
        //  otherwise change source, then AND then OR
        //

        clrTextSave = SetTextColor(pimldp->hdcDst, CLR_BLACK);
        clrBkSave = ::SetBkColor(pimldp->hdcDst, CLR_WHITE);

        // we cant do white/black special cases if we munged the mask or image

        if (fImage && _clrBk == CLR_WHITE)
        {
            BitBlt(pimldp->hdcDst, pimldp->x, pimldp->y, pimldp->cx, pimldp->cy, hdcMaskI,  xMask, yMask,   ROP_DSno);
            BitBlt(pimldp->hdcDst, pimldp->x, pimldp->y, pimldp->cx, pimldp->cy, hdcImageI, xImage, yImage, ROP_DSa);
        }
        else if (fImage && (_clrBk == CLR_BLACK || _clrBk == CLR_NONE))
        {
            BitBlt(pimldp->hdcDst, pimldp->x, pimldp->y, pimldp->cx, pimldp->cy, hdcMaskI,  xMask, yMask,   ROP_DSa);
            BitBlt(pimldp->hdcDst, pimldp->x, pimldp->y, pimldp->cx, pimldp->cy, hdcImageI, xImage, yImage, ROP_DSo);
        }
        else
        {
            ASSERT(GetTextColor(hdcImageI) == CLR_BLACK);
            ASSERT(::GetBkColor(hdcImageI) == CLR_WHITE);

            // black out the source image.
            BitBlt(hdcImageI, xImage, yImage, pimldp->cx, pimldp->cy, hdcMaskI, xMask, yMask, ROP_DSna);

            BitBlt(pimldp->hdcDst, pimldp->x, pimldp->y, pimldp->cx, pimldp->cy, hdcMaskI,  xMask,  yMask,  ROP_DSa);
            BitBlt(pimldp->hdcDst, pimldp->x, pimldp->y, pimldp->cx, pimldp->cy, hdcImageI, xImage, yImage, ROP_DSo);

            // restore the bkcolor, if it came from the image list
            if (fImage)
                _ResetBkColor(pimldp->i, pimldp->i, _clrBk);
        }

        SetTextColor(pimldp->hdcDst, clrTextSave);
        ::SetBkColor(pimldp->hdcDst, clrBkSave);
#endif
    }
    else if (fImage && pimldp->rgbBk == _clrBk && _fSolidBk)
    {
        BitBlt(pimldp->hdcDst, pimldp->x, pimldp->y, pimldp->cx, pimldp->cy, hdcImageI, xImage, yImage, SRCCOPY);
    }
    else if (hdcMaskI)
    {
        if (fImage && 
            ((pimldp->rgbBk == _clrBk && 
               !_fSolidBk) || 
              GetNearestColor32(hdcImageI, pimldp->rgbBk) != pimldp->rgbBk))
        {
            // make a copy of the image, because we will have to modify it
            hdcImageI = ImageList_GetWorkDC(pimldp->hdcDst, pimldp->cx, pimldp->cy);
            xImage = 0;
            yImage = 0;
            fImage = FALSE;

            BitBlt(hdcImageI, 0, 0, pimldp->cx, pimldp->cy, _hdcImage, rcImage.left, rcImage.top, SRCCOPY);
        }

        SetBrushOrgEx(hdcImageI, xImage-pimldp->x, yImage-pimldp->y, NULL);
        hbrT = SelectBrush(hdcImageI, CreateSolidBrush(pimldp->rgbBk));
        BitBlt(hdcImageI, xImage, yImage, pimldp->cx, pimldp->cy, hdcMaskI, xMask, yMask, ROP_PatMask);
        DeleteObject(SelectBrush(hdcImageI, hbrT));
        SetBrushOrgEx(hdcImageI, 0, 0, NULL);

        BitBlt(pimldp->hdcDst, pimldp->x, pimldp->y, pimldp->cx, pimldp->cy, hdcImageI, xImage, yImage, SRCCOPY);

        if (fImage)
            _ResetBkColor(pimldp->i, pimldp->i, _clrBk);
    }
    else
    {
        BitBlt(pimldp->hdcDst, pimldp->x, pimldp->y, pimldp->cx, pimldp->cy, hdcImageI, xImage, yImage, SRCCOPY);
    }

    //
    // now deal with a overlay image, use the minimal bounding rect (and flags)
    // we computed in ImageList_SetOverlayImage()
    //
    if (pimldp->fStyle & ILD_OVERLAYMASK)
    {
        int n = OVERLAYMASKTOINDEX(pimldp->fStyle);

        if (n < NUM_OVERLAY_IMAGES) 
        {
            pimldp->i = _aOverlayIndexes[n];
            GetImageRect(pimldp->i, &rcImage);

            pimldp->cx = _aOverlayDX[n];
            pimldp->cy = _aOverlayDY[n];
            pimldp->x += _aOverlayX[n];
            pimldp->y += _aOverlayY[n];
            rcImage.left += _aOverlayX[n]+pimldp->xBitmap;
            rcImage.top  += _aOverlayY[n]+pimldp->yBitmap;

            pimldp->fStyle &= ILD_MASK;
            pimldp->fStyle |= ILD_TRANSPARENT;
            pimldp->fStyle |= _aOverlayF[n];

            if (pimldp->cx > 0 && pimldp->cy > 0)
                goto again;  // ImageList_DrawEx(piml, i, hdcDst, x, y, 0, 0, CLR_DEFAULT, CLR_NONE, fStyle);
        }
    }

    if (!fImage)
    {
        ImageList_ReleaseWorkDC(hdcImageI);
    }

    LEAVECRITICAL;

    return S_OK;
}


HRESULT CImageList::GetImageInfo(int i, IMAGEINFO * pImageInfo)
{
    RIPMSG(pImageInfo != NULL, "ImageList_GetImageInfo: Invalid NULL pointer");
    RIPMSG(IsImageListIndex(i), "ImageList_GetImageInfo: Invalid image index %d", i);
    if (!pImageInfo || !IsImageListIndex(i))
        return E_POINTER;

    pImageInfo->hbmImage      = _hbmImage;
    pImageInfo->hbmMask       = _hbmMask;

    return GetImageRect(i, &pImageInfo->rcImage);
}

//
// Parameter:
//  i -- -1 to add
//
HRESULT CImageList::_ReplaceIcon(int i, HICON hIcon, int* pi)
{
    HICON hIconT = hIcon;
    RECT rc;
    HRESULT hr = S_OK;

    *pi = -1;
    
    // be win95 compatible
    if (i < -1)
        return E_INVALIDARG;
    

    //
    //  re-size the icon (iff needed) by calling CopyImage
    //
    hIcon = (HICON)CopyImage(hIconT, IMAGE_ICON, _cx, _cy,LR_COPYFROMRESOURCE | LR_COPYRETURNORG);

    if (hIcon == NULL)
        return E_OUTOFMEMORY;

    //
    //  alocate a slot for the icon
    //
    if (i == -1)
        hr = _Add(NULL,NULL,1,0,0,&i);

    if (i == -1)
        return hr;

    //
    //  now draw it into the image bitmaps
    //
    hr = GetImageRect(i, &rc);
    if (FAILED(hr))
        return hr;

    FillRect(_hdcImage, &rc, _hbrBk);
    DrawIconEx(_hdcImage, rc.left, rc.top, hIcon, 0, 0, 0, NULL, DI_NORMAL);

    if (_hdcMask)
        DrawIconEx(_hdcMask, rc.left, rc.top, hIcon, 0, 0, 0, NULL, DI_MASK);

    //
    // if we had user size a new icon, delete it.
    //
    if (hIcon != hIconT)
        DestroyIcon(hIcon);

    *pi = i;

    return S_OK;
}

HRESULT CImageList::ReplaceIcon(int i, HICON hIcon, int* pi)
{
    // Let's add it first to the mirrored image list, if one exists
    if (_pimlMirror)
    {
        HICON hIconT = CopyIcon(hIcon);
        if (hIconT)
        {
            MirrorIcon(&hIconT, NULL);
            _pimlMirror->_ReplaceIcon(i, hIconT, pi);
            DestroyIcon(hIconT);
        }
    }

    return _ReplaceIcon(i, hIcon,pi);
}

// make a dithered copy of the source image in the destination image.
// allows placing of the final image in the destination.

HRESULT CImageList::CopyDitherImage(WORD iDst, int xDst, int yDst, IUnknown* punkSrc, int iSrc, UINT fStyle)
{
    IImageList* pux;
    HRESULT hr = punkSrc->QueryInterface(IID_PPV_ARG(IImageList, &pux));

    if (FAILED(hr))
        return hr;

    RECT rc;
    int x, y;

    GetImageRect(iDst, &rc);

    // coordinates in destination image list
    x = xDst + rc.left;
    y = yDst + rc.top;

    fStyle &= ILD_OVERLAYMASK;
    WimpyDrawEx(pux, iSrc, _hdcImage, x, y, 0, 0, CLR_DEFAULT, CLR_NONE, ILD_IMAGE | fStyle);

    //
    // dont dither the mask on a hicolor device, we will draw the image
    // with blending while dragging.
    //
    if (_hdcMask && GetScreenDepth() > 8)
    {
        WimpyDrawEx(pux, iSrc, _hdcMask, x, y, 0, 0, CLR_NONE, CLR_NONE, ILD_MASK | fStyle);
    }
    else if (_hdcMask)
    {
        WimpyDrawEx(pux, iSrc, _hdcMask,  x, y, 0, 0, CLR_NONE, CLR_NONE, ILD_BLEND50|ILD_MASK | fStyle);
    }

    _ResetBkColor(iDst, iDst+1, _clrBk);

    pux->Release();

    return hr;
}

//
// ImageList_CopyBitmap
//
// Worker function for ImageList_Duplicate.
//
// Given a bitmap and an hdc, creates and returns a copy of the passed in bitmap.
//
HBITMAP CImageList::_CopyBitmap(HBITMAP hbm, HDC hdc)
{
    ASSERT(hbm);

    BITMAP bm;
    HBITMAP hbmCopy = NULL;

    if (GetObject(hbm, sizeof(bm), &bm) == sizeof(bm))
    {
        ENTERCRITICAL;
        if (hbmCopy = CreateCompatibleBitmap(hdc, bm.bmWidth, bm.bmHeight))
        {
            CImageList::SelectDstBitmap(hbmCopy);

            BitBlt(g_hdcDst, 0, 0, bm.bmWidth, bm.bmHeight,
                    hdc, 0, 0, SRCCOPY);

            CImageList::SelectDstBitmap(NULL);
        }
        LEAVECRITICAL;
    }
    return hbmCopy;
}

HRESULT CImageList::Clone(REFIID riid, void** ppv)
{
    HBITMAP hbmImageI;
    HBITMAP hbmMaskI = NULL;
    HRESULT hr = S_OK;
    CImageList* pimlCopy = NULL;

    *ppv = NULL;

    ENTERCRITICAL;

    hbmImageI = _CopyBitmap(_hbmImage, _hdcImage);
    if (!hbmImageI)
        hr = E_OUTOFMEMORY;

    if (SUCCEEDED(hr))
    {

        if (_hdcMask)
        {
            hbmMaskI = _CopyBitmap(_hbmMask, _hdcMask);
            if (!hbmMaskI)
                hr = E_OUTOFMEMORY;
        }

        if (SUCCEEDED(hr))
        {
            pimlCopy = CImageList::Create(_cx, _cy, _flags, 0, _cGrow);

            if (pimlCopy) 
            {

                // Slam in our bitmap copies and delete the old ones
                SelectObject(pimlCopy->_hdcImage, hbmImageI);
                CImageList::_DeleteBitmap(pimlCopy->_hbmImage);
                if (pimlCopy->_hdcMask) 
                {
                    SelectObject(pimlCopy->_hdcMask, hbmMaskI);
                    CImageList::_DeleteBitmap(pimlCopy->_hbmMask);
                }
                pimlCopy->_hbmImage = hbmImageI;
                pimlCopy->_hbmMask = hbmMaskI;

                // Make sure other info is correct
                pimlCopy->_cImage = _cImage;
                pimlCopy->_cAlloc = _cAlloc;
                pimlCopy->_cStrip = _cStrip;
                pimlCopy->_clrBlend = _clrBlend;
                pimlCopy->_clrBk = _clrBk;

                // Delete the old brush and create the correct one
                if (pimlCopy->_hbrBk)
                    DeleteObject(pimlCopy->_hbrBk);
                if (pimlCopy->_clrBk == CLR_NONE)
                {
                    pimlCopy->_hbrBk = (HBRUSH)GetStockObject(BLACK_BRUSH);
                    pimlCopy->_fSolidBk = TRUE;
                }
                else
                {
                    pimlCopy->_hbrBk = CreateSolidBrush(pimlCopy->_clrBk);
                    pimlCopy->_fSolidBk = GetNearestColor32(pimlCopy->_hdcImage, pimlCopy->_clrBk) == pimlCopy->_clrBk;
                }
            } 
        }

        LEAVECRITICAL;
    }

    if (FAILED(hr))
    {
        if (hbmImageI)
            CImageList::_DeleteBitmap(hbmImageI);
        if (hbmMaskI)
            CImageList::_DeleteBitmap(hbmMaskI);
    }

    if (pimlCopy)
    {
        hr = pimlCopy->QueryInterface(riid, ppv);
        pimlCopy->Release();
    }

    return hr;

}

void CImageList::_Merge(IImageList* pux, int i, int dx, int dy)
{
    if (_hdcMask)
    {
        IImageListPriv* puxp;
        if (SUCCEEDED(pux->QueryInterface(IID_PPV_ARG(IImageListPriv, &puxp))))
        {
            HDC hdcMaskI;
            if (SUCCEEDED(puxp->GetPrivateGoo(NULL, NULL, NULL, &hdcMaskI)) && hdcMaskI)
            {
                RECT rcMerge;
                int cxI, cyI;
                pux->GetIconSize(&cxI, &cyI);

                pux->GetImageRect(i, &rcMerge);

                BitBlt(_hdcMask, dx, dy, cxI, cyI,
                       hdcMaskI, rcMerge.left, rcMerge.top, SRCAND);
            }
            puxp->Release();
        }
    }

    WimpyDraw(pux, i, _hdcImage, dx, dy, ILD_TRANSPARENT);
}

HRESULT CImageList::_Merge(int i1, IUnknown* punk, int i2, int dx, int dy, CImageList** ppiml)
{
    CImageList* pimlNew = NULL;
    IImageListPriv* puxp;
    HRESULT hr = punk->QueryInterface(IID_PPV_ARG(IImageListPriv, &puxp));
    if (SUCCEEDED(hr))
    {
        IImageList* pux;
        hr = punk->QueryInterface(IID_PPV_ARG(IImageList, &pux));
        if (SUCCEEDED(hr))
        {
            RECT rcNew;
            RECT rc1;
            RECT rc2;
            int cxI, cyI;
            int c1, c2;
            UINT wFlags;
            UINT uSrcFlags;

            puxp->GetFlags(&uSrcFlags);
            pux->GetIconSize(&cxI, &cyI);

            ENTERCRITICAL;

            SetRect(&rc1, 0, 0, _cx, _cy);
            SetRect(&rc2, dx, dy, cxI + dx, cyI + dy);
            UnionRect(&rcNew, &rc1, &rc2);

            cxI = RECTWIDTH(rcNew);
            cyI = RECTHEIGHT(rcNew);

            //
            // If one of images are shared, create a shared image.
            //
            wFlags = (_flags | uSrcFlags) & ~ILC_COLORMASK;

            c1 = (_flags & ILC_COLORMASK);
            c2 = (uSrcFlags & ILC_COLORMASK);

            if (c1 == 16 && c2 == ILC_COLORDDB)
            {
                c2 = 16;
            }

            wFlags |= max(c1,c2);

            pimlNew = CImageList::Create(cxI, cyI, ILC_MASK|wFlags, 1, 0);
            if (pimlNew)
            {
                pimlNew->_cImage++;

                if (pimlNew->_hdcMask) 
                    PatBlt(pimlNew->_hdcMask,  0, 0, cxI, cyI, WHITENESS);
                PatBlt(pimlNew->_hdcImage, 0, 0, cxI, cyI, BLACKNESS);

                pimlNew->_Merge(SAFECAST(this, IImageList*), i1, rc1.left - rcNew.left, rc1.top - rcNew.top);
                pimlNew->_Merge(pux, i2, rc2.left - rcNew.left, rc2.top - rcNew.top);
            }
            else
                hr = E_OUTOFMEMORY;

            LEAVECRITICAL;
            pux->Release();
        }
        puxp->Release();
    }

    *ppiml = pimlNew;

    return hr;
}

HRESULT CImageList::Merge(int i1, IUnknown* punk, int i2, int dx, int dy, REFIID riid, void** ppv)
{
    CImageList* piml;
    HRESULT hr = _Merge(i1, punk, i2, dx, dy, &piml);

    if (piml)
    {
        hr = piml->QueryInterface(riid, ppv);
        piml->Release();
    }

    return hr;
}

HRESULT CImageList::_Read(ILFILEHEADER *pilfh, HBITMAP hbmImageI, HBITMAP hbmMaskI)
{
    int i;
    HRESULT hr = Initialize(pilfh->cx, pilfh->cy, pilfh->flags, 1, pilfh->cGrow);

    if (SUCCEEDED(hr))
    {
        // select into DC's before deleting existing bitmaps
        // patch in the bitmaps we loaded
        SelectObject(_hdcImage, hbmImageI);
        DeleteObject(_hbmImage);
        _hbmImage = hbmImageI;
        _clrBlend = CLR_NONE;

        // Same for the mask (if necessary)
        if (_hdcMask) 
        {
            SelectObject(_hdcMask, hbmMaskI);
            DeleteObject(_hbmMask);
            _hbmMask = hbmMaskI;
        }

        _cAlloc = pilfh->cAlloc;

        //
        // Call ImageList_SetBkColor with 0 in piml->_cImage to avoid
        // calling expensive ImageList__ResetBkColor
        //
        _cImage = 0;
        _SetBkColor(pilfh->clrBk);
        _cImage = pilfh->cImage;

        for (i=0; i<NUM_OVERLAY_IMAGES; i++)
            _SetOverlayImage(pilfh->aOverlayIndexes[i], i+1);

    }
    else
    {
        DeleteObject(hbmImageI);
        DeleteObject(hbmMaskI);
    }
    return hr;
}




STDMETHODIMP CImageList::Load(IStream *pstm)
{

    if (pstm == NULL)
        return E_INVALIDARG;

    HRESULT hr = ImageList_InitGlobals();

    if (SUCCEEDED(hr))
    {
        ENTERCRITICAL;
        ILFILEHEADER ilfh = {0};
        HBITMAP hbmImageI;
        HBITMAP hbmMaskI;

        HBITMAP hbmMirroredImage;
        HBITMAP hbmMirroredMask;
        BOOL bMirroredIL = FALSE;
   
        // fist read in the old struct
        hr = pstm->Read(&ilfh, ILFILEHEADER_SIZE0, NULL);

        if (SUCCEEDED(hr) && (ilfh.magic != IMAGELIST_MAGIC ||
                              ilfh.version != IMAGELIST_VER0))
        {
            hr = E_FAIL;
        }

        if (SUCCEEDED(hr))
        {
            hbmMaskI = NULL;
            hbmMirroredMask = NULL;
            hr = Stream_ReadBitmap(pstm, (ilfh.flags&ILC_COLORMASK), &hbmImageI);
            if (SUCCEEDED(hr))
            {
                if (ilfh.flags & ILC_MASK)
                {
                    hr = Stream_ReadBitmap(pstm, FALSE, &hbmMaskI);
                    if (FAILED(hr))
                    {
                        DeleteBitmap(hbmImageI);
                    }
                }

                if (SUCCEEDED(hr))
                {
                    // Read in the rest of the struct, new overlay stuff.
                    if (ilfh.flags & ILC_MOREOVERLAY)
                    {
                        hr = pstm->Read((LPBYTE)&ilfh + ILFILEHEADER_SIZE0, sizeof(ilfh) - ILFILEHEADER_SIZE0, NULL);
                        if (SUCCEEDED(hr))
                            ilfh.flags &= ~ILC_MOREOVERLAY;
                    }
                }

                if (SUCCEEDED(hr))
                {
                    if (ilfh.flags & ILC_MIRROR)
                    {
                        ilfh.flags &= ~ILC_MIRROR;
                        bMirroredIL = TRUE;
                        hr = Stream_ReadBitmap(pstm, (ilfh.flags&ILC_COLORMASK), &hbmMirroredImage);

                        if (SUCCEEDED(hr) && ilfh.flags & ILC_MASK)
                        {
                            hr = Stream_ReadBitmap(pstm, FALSE, &hbmMirroredMask);
                            if (FAILED(hr))
                            {
                                DeleteBitmap(hbmMirroredImage);
                            }
                        }        
                    }

                    if (SUCCEEDED(hr))
                    {
                        hr = _Read(&ilfh, hbmImageI, hbmMaskI);

                        if(SUCCEEDED(hr) && bMirroredIL)
                        {
                            _pimlMirror = new CImageList();
                            if (_pimlMirror)
                            {
                                _pimlMirror->_Read(&ilfh, hbmMirroredImage, hbmMirroredMask);
                            }
                            else
                            {
                                hr = E_OUTOFMEMORY;
                                // if we failed to read mirrored imagelist, let's force fail.
                                DeleteBitmap(hbmImageI);

                                if (hbmMaskI)
                                    DeleteBitmap(hbmMaskI);
                            }

                        }
                    }
                }
            }
        }

        LEAVECRITICAL;
    }
    
    return hr;
}

BOOL CImageList::_MoreOverlaysUsed()
{
    int i;
    for (i = NUM_OVERLAY_IMAGES_0; i < NUM_OVERLAY_IMAGES; i++)
        if (_aOverlayIndexes[i] != -1)
            return TRUE;
    return FALSE;
}


STDMETHODIMP CImageList::Save(IStream *pstm, int fClearDirty)
{
    int i;
    ILFILEHEADER ilfh;
    HRESULT hr = S_OK;

    if (pstm == NULL)
        return E_INVALIDARG;

    ilfh.magic   = IMAGELIST_MAGIC;
    ilfh.version = IMAGELIST_VER0;
    ilfh.cImage  = (SHORT) _cImage;
    ilfh.cAlloc  = (SHORT) _cAlloc;
    ilfh.cGrow   = (SHORT) _cGrow;
    ilfh.cx      = (SHORT) _cx;
    ilfh.cy      = (SHORT) _cy;
    ilfh.clrBk   = _clrBk;
    ilfh.flags   = (SHORT) _flags;

    //
    // Store mirror flags
    //
    if (_pimlMirror)
        ilfh.flags |= ILC_MIRROR;   

    if (_MoreOverlaysUsed())
        ilfh.flags |= ILC_MOREOVERLAY;
    
    for (i=0; i < NUM_OVERLAY_IMAGES; i++)
        ilfh.aOverlayIndexes[i] =  (SHORT) _aOverlayIndexes[i];

    hr = pstm->Write(&ilfh, ILFILEHEADER_SIZE0, NULL);

    hr = Stream_WriteBitmap(pstm, _hbmImage, 0);

    if (SUCCEEDED(hr))
    {

        if (_hdcMask)
        {
            hr = Stream_WriteBitmap(pstm, _hbmMask, 1);
        }

        if (SUCCEEDED(hr))
        {
            if (ilfh.flags & ILC_MOREOVERLAY)
                hr = pstm->Write((LPBYTE)&ilfh + ILFILEHEADER_SIZE0, sizeof(ilfh) - ILFILEHEADER_SIZE0, NULL);

            if (_pimlMirror)
            {
                // Don't call pidlMirror's Save, because of the header difference.
                hr = Stream_WriteBitmap(pstm, _pimlMirror->_hbmImage, 0);

                if (_pimlMirror->_hdcMask)
                {
                    hr = Stream_WriteBitmap(pstm, _pimlMirror->_hbmMask, 1);
                }
            
            }
        }
    }
        
    return hr;
}




HRESULT Stream_WriteBitmap(LPSTREAM pstm, HBITMAP hbm, int cBitsPerPixel)
{
    BOOL fSuccess;
    BITMAP bm;
    int cx, cy;
    BITMAPFILEHEADER bf;
    BITMAPINFOHEADER bi;
    BITMAPINFOHEADER * pbi;
    BYTE * pbuf;
    HDC hdc;
    UINT cbColorTable;
    int cLines;
    int cLinesWritten;
    HRESULT hr = E_INVALIDARG;

    ASSERT(pstm);

    fSuccess = FALSE;
    hdc = NULL;
    pbi = NULL;
    pbuf = NULL;

    if (GetObject(hbm, sizeof(bm), &bm) != sizeof(bm))
        goto Error;

    hdc = GetDC(HWND_DESKTOP);

    cx = bm.bmWidth;
    cy = bm.bmHeight;

    if (cBitsPerPixel == 0)
        cBitsPerPixel = bm.bmPlanes * bm.bmBitsPixel;

    if (cBitsPerPixel <= 8)
        cbColorTable = (1 << cBitsPerPixel) * sizeof(RGBQUAD);
    else
        cbColorTable = 0;

    bi.biSize           = sizeof(bi);
    bi.biWidth          = cx;
    bi.biHeight         = cy;
    bi.biPlanes         = 1;
    bi.biBitCount       = (WORD) cBitsPerPixel;
    bi.biCompression    = BI_RGB;       // RLE not supported!
    bi.biSizeImage      = 0;
    bi.biXPelsPerMeter  = 0;
    bi.biYPelsPerMeter  = 0;
    bi.biClrUsed        = 0;
    bi.biClrImportant   = 0;

    bf.bfType           = BFTYPE_BITMAP;
    bf.bfOffBits        = sizeof(BITMAPFILEHEADER) +
                          sizeof(BITMAPINFOHEADER) + cbColorTable;
    bf.bfSize           = bf.bfOffBits + bi.biSizeImage;
    bf.bfReserved1      = 0;
    bf.bfReserved2      = 0;

    hr = E_OUTOFMEMORY;
    pbi = (BITMAPINFOHEADER *)LocalAlloc(LPTR, sizeof(BITMAPINFOHEADER) + cbColorTable);

    if (!pbi)
        goto Error;

    // Get the color table and fill in the rest of *pbi
    //
    *pbi = bi;
    if (GetDIBits(hdc, hbm, 0, cy, NULL, (BITMAPINFO *)pbi, DIB_RGB_COLORS) == 0)
        goto Error;

    if (cBitsPerPixel == 1)
    {
        ((DWORD *)(pbi+1))[0] = CLR_BLACK;
        ((DWORD *)(pbi+1))[1] = CLR_WHITE;
    }

    pbi->biSizeImage = WIDTHBYTES(cx, cBitsPerPixel) * cy;

    hr = pstm->Write(&bf, sizeof(bf), NULL);
    if (FAILED(hr))
        goto Error;

    hr = pstm->Write(pbi, sizeof(bi) + cbColorTable, NULL);
    if (FAILED(hr))
        goto Error;

    //
    // if we have a DIBSection just write the bits out
    //
    if (bm.bmBits != NULL)
    {
        hr = pstm->Write(bm.bmBits, pbi->biSizeImage, NULL);
        if (FAILED(hr))
            goto Error;

        goto Done;
    }

    // Calculate number of horizontal lines that'll fit into our buffer...
    //
    cLines = CBDIBBUF / WIDTHBYTES(cx, cBitsPerPixel);

    hr = E_OUTOFMEMORY;
    pbuf = (PBYTE)LocalAlloc(LPTR, CBDIBBUF);

    if (!pbuf)
        goto Error;

    for (cLinesWritten = 0; cLinesWritten < cy; cLinesWritten += cLines)
    {
        hr = E_OUTOFMEMORY;
        if (cLines > cy - cLinesWritten)
            cLines = cy - cLinesWritten;

        if (GetDIBits(hdc, hbm, cLinesWritten, cLines,
                pbuf, (BITMAPINFO *)pbi, DIB_RGB_COLORS) == 0)
            goto Error;

        hr = pstm->Write(pbuf, WIDTHBYTES(cx, cBitsPerPixel) * cLines, NULL);
        if (FAILED(hr))
            goto Error;
    }

Done:
    hr = S_OK;

Error:
    if (hdc)
        ReleaseDC(HWND_DESKTOP, hdc);
    if (pbi)
        LocalFree((HLOCAL)pbi);
    if (pbuf)
        LocalFree((HLOCAL)pbuf);

    return hr;
}

HRESULT Stream_ReadBitmap(LPSTREAM pstm, BOOL fDS, HBITMAP* phbmp)
{
    HDC hdc;
    HBITMAP hbm;
    BITMAPFILEHEADER bf;
    BITMAPINFOHEADER bi;
    BITMAPINFOHEADER * pbi;
    BYTE * pbuf=NULL;
    int cBitsPerPixel;
    UINT cbColorTable;
    int cx, cy;
    int cLines, cLinesRead;

    ASSERT(pstm);

    hdc = NULL;
    hbm = NULL;
    pbi = NULL;

    HRESULT hr = pstm->Read(&bf, sizeof(bf), NULL);
    if (FAILED(hr))
        goto Error;

    hr = E_INVALIDARG;
    if (bf.bfType != BFTYPE_BITMAP)
        goto Error;

    hr = pstm->Read(&bi, sizeof(bi), NULL);
    if (FAILED(hr))
        goto Error;

    hr = E_INVALIDARG;
    if (bi.biSize != sizeof(bi))
        goto Error;

    cx = (int)bi.biWidth;
    cy = (int)bi.biHeight;

    cBitsPerPixel = (int)bi.biBitCount * (int)bi.biPlanes;

    if (cBitsPerPixel <= 8)
        cbColorTable = (1 << cBitsPerPixel) * sizeof(RGBQUAD);
    else
        cbColorTable = 0;

    hr = E_OUTOFMEMORY;
    pbi = (BITMAPINFOHEADER*)LocalAlloc(LPTR, sizeof(bi) + cbColorTable);
    if (!pbi)
        goto Error;
    *pbi = bi;

    pbi->biSizeImage = WIDTHBYTES(cx, cBitsPerPixel) * cy;

    if (cbColorTable)
    {
        hr = pstm->Read(pbi + 1, cbColorTable, NULL);
        if (FAILED(hr))
            goto Error;
    }

    hdc = GetDC(HWND_DESKTOP);

    //
    //  see if we can make a DIBSection
    //
    if ((cBitsPerPixel > 1) && (fDS != ILC_COLORDDB))
    {
        //
        // create DIBSection and read the bits directly into it!
        //
        hr = E_OUTOFMEMORY;
        hbm = CreateDIBSection(hdc, (LPBITMAPINFO)pbi, DIB_RGB_COLORS, (void**)&pbuf, NULL, 0);

        if (hbm == NULL)
            goto Error;

        hr = pstm->Read(pbuf, pbi->biSizeImage, NULL);
        if (FAILED(hr))
            goto Error;

        pbuf = NULL;        // dont free this
        goto Done;
    }

    //
    //  cant make a DIBSection make a mono or color bitmap.
    //
    else if (cBitsPerPixel > 1)
        hbm = CreateColorBitmap(cx, cy);
    else
        hbm = CreateMonoBitmap(cx, cy);

    hr = E_OUTOFMEMORY;
    if (!hbm)
        return NULL;

    // Calculate number of horizontal lines that'll fit into our buffer...
    //
    cLines = CBDIBBUF / WIDTHBYTES(cx, cBitsPerPixel);

    hr = E_OUTOFMEMORY;
    pbuf = (PBYTE)LocalAlloc(LPTR, CBDIBBUF);

    if (!pbuf)
        goto Error;

    for (cLinesRead = 0; cLinesRead < cy; cLinesRead += cLines)
    {
        if (cLines > cy - cLinesRead)
            cLines = cy - cLinesRead;

        hr = pstm->Read(pbuf, WIDTHBYTES(cx, cBitsPerPixel) * cLines, NULL);
        if (FAILED(hr))
            goto Error;

        hr = E_OUTOFMEMORY;
        if (!SetDIBits(hdc, hbm, cLinesRead, cLines,
                pbuf, (BITMAPINFO *)pbi, DIB_RGB_COLORS))
        {
            goto Error;
        }
    }

Done:
    hr = S_OK;

Error:
    if (hdc)
        ReleaseDC(HWND_DESKTOP, hdc);
    if (pbi)
        LocalFree((HLOCAL)pbi);
    if (pbuf)
        LocalFree((HLOCAL)pbuf);

    if (FAILED(hr) && hbm)
    {
        DeleteBitmap(hbm);
        hbm = NULL;
    }

    *phbmp = hbm;

    return hr;
}

HRESULT CImageList::GetImageRect(int i, RECT * prcImage)
{
    int x, y;
    ASSERT(prcImage);

    if (!prcImage || !IsImageListIndex(i))
        return E_FAIL;

    x = _cx * (i % _cStrip);
    y = _cy * (i / _cStrip);

    SetRect(prcImage, x, y, x + _cx, y + _cy);
    return S_OK;
}


BOOL CImageList::GetSpareImageRect(RECT * prcImage)
{
    BOOL fRet;

    // special hacking to use the one scratch image at tail of list :)
    _cImage++;
    fRet = (S_OK == GetImageRect(_cImage-1, prcImage));
    _cImage--;

    return fRet;
}



// Drag Drop
// copy an image from one imagelist to another at x,y within iDst in pimlDst.
// pimlDst's image size should be larger than pimlSrc
void CImageList::_CopyOneImage(int iDst, int x, int y, CImageList* piml, int iSrc)
{
    RECT rcSrc, rcDst;


    piml->GetImageRect(iSrc, &rcSrc);
    GetImageRect(iDst, &rcDst);

    if (piml->_hdcMask && _hdcMask)
    {
        BitBlt(_hdcMask, rcDst.left + x, rcDst.top + y, piml->_cx, piml->_cy,
               piml->_hdcMask, rcSrc.left, rcSrc.top, SRCCOPY);

    }

    BitBlt(_hdcImage, rcDst.left + x, rcDst.top + y, piml->_cx, piml->_cy,
           piml->_hdcImage, rcSrc.left, rcSrc.top, SRCCOPY);
}


//
//  Cached bitmaps that we use during drag&drop. We re-use those bitmaps
// across multiple drag session as far as the image size is the same.
//
struct DRAGRESTOREBMP 
{
    int     BitsPixel;
    HBITMAP hbmOffScreen;
    HBITMAP hbmRestore;
    SIZE    sizeRestore;
} 
g_drb = 
{
    0, NULL, NULL, {-1,-1}
};

BOOL CImageList::CreateDragBitmaps()
{
    HDC hdc;

    hdc = GetDC(NULL);

    if (_cx != g_drb.sizeRestore.cx ||
        _cy != g_drb.sizeRestore.cy ||
        GetDeviceCaps(hdc, BITSPIXEL) != g_drb.BitsPixel)
    {
        ImageList_DeleteDragBitmaps();

        g_drb.BitsPixel      = GetDeviceCaps(hdc, BITSPIXEL);
        g_drb.sizeRestore.cx = _cx;
        g_drb.sizeRestore.cy = _cy;
        g_drb.hbmRestore   = CreateColorBitmap(g_drb.sizeRestore.cx, g_drb.sizeRestore.cy);
        g_drb.hbmOffScreen = CreateColorBitmap(g_drb.sizeRestore.cx * 2 - 1, g_drb.sizeRestore.cy * 2 - 1);


        if (!g_drb.hbmRestore || !g_drb.hbmOffScreen)
        {
            ImageList_DeleteDragBitmaps();
            ReleaseDC(NULL, hdc);
            return FALSE;
        }
    }
    ReleaseDC(NULL, hdc);
    return TRUE;
}

void ImageList_DeleteDragBitmaps()
{
    if (g_drb.hbmRestore)
    {
        CImageList::_DeleteBitmap(g_drb.hbmRestore);
        g_drb.hbmRestore = NULL;
    }
    if (g_drb.hbmOffScreen)
    {
        CImageList::_DeleteBitmap(g_drb.hbmOffScreen);
        g_drb.hbmOffScreen = NULL;
    }

    g_drb.sizeRestore.cx = -1;
    g_drb.sizeRestore.cy = -1;
}

//
//  Drag context. We don't reuse none of them across two different
// drag sessions. I'm planning to allocate it for each session
// to minimize critical sections.
//
struct DRAGCONTEXT 
{
    CImageList* pimlDrag;    // Image to be drawin while dragging
    IImageList* puxCursor;  // Overlap cursor image
    CImageList* pimlDither;  // Dithered image
    IImageList* puxDragImage; // The context of the drag.
    int        iCursor;     // Image index of the cursor
    POINT      ptDrag;      // current drag position (hwndDC coords)
    POINT      ptDragHotspot;
    POINT      ptCursor;
    BOOL       fDragShow;
    BOOL       fHiColor;
    HWND       hwndDC;
} 
g_dctx = 
{
    (CImageList*)NULL, (CImageList*)NULL, (CImageList*)NULL, (IImageList*)NULL,
    -1,
    {0, 0}, {0, 0}, {0, 0},
    FALSE,
    FALSE,
    (HWND)NULL
};

HDC ImageList_GetDragDC()
{
    HDC hdc = GetDCEx(g_dctx.hwndDC, NULL, DCX_WINDOW | DCX_CACHE | DCX_LOCKWINDOWUPDATE);
    //
    // If hdc is mirrored then mirror the 2 globals DCs.
    //
    if (IS_DC_RTL_MIRRORED(hdc)) 
    {
        SET_DC_RTL_MIRRORED(g_hdcDst);
        SET_DC_RTL_MIRRORED(g_hdcSrc);
    }
    return hdc;
}

void ImageList_ReleaseDragDC(HDC hdc)
{
    //
    // If the hdc is mirrored then unmirror the 2 globals DCs.
    //
    if (IS_DC_RTL_MIRRORED(hdc)) 
    {
        SET_DC_LAYOUT(g_hdcDst, 0);
        SET_DC_LAYOUT(g_hdcSrc, 0);
    }

    ReleaseDC(g_dctx.hwndDC, hdc);
}

//
//  x, y     -- Specifies the initial cursor position in the coords of hwndLock,
//              which is specified by the previous ImageList_StartDrag call.
//
HRESULT CImageList::DragMove(int x, int y)
{
    int IncOne = 0;
    ENTERCRITICAL;
    if (g_dctx.fDragShow)
    {
        RECT rcOld, rcNew, rcBounds;
        int dx, dy;

        dx = x - g_dctx.ptDrag.x;
        dy = y - g_dctx.ptDrag.y;
        rcOld.left = g_dctx.ptDrag.x - g_dctx.ptDragHotspot.x;
        rcOld.top = g_dctx.ptDrag.y - g_dctx.ptDragHotspot.y;
        rcOld.right = rcOld.left + g_drb.sizeRestore.cx;
        rcOld.bottom = rcOld.top + g_drb.sizeRestore.cy;
        rcNew = rcOld;
        OffsetRect(&rcNew, dx, dy);

        if (!IntersectRect(&rcBounds, &rcOld, &rcNew))
        {
            //
            // No intersection. Simply hide the old one and show the new one.
            //
            ImageList_DragShowNolock(FALSE);
            g_dctx.ptDrag.x = x;
            g_dctx.ptDrag.y = y;
            ImageList_DragShowNolock(TRUE);
        }
        else
        {
            //
            // Some intersection.
            //
            HDC hdcScreen;
            int cx, cy;

            UnionRect(&rcBounds, &rcOld, &rcNew);

            hdcScreen = ImageList_GetDragDC();
            
            if (hdcScreen)
            {
                //
                // If the DC is RTL mirrored, then restrict the
                // screen bitmap  not to go beyond the screen since 
                // we will end up copying the wrong bits from the
                // hdcScreen to the hbmOffScreen when the DC is mirrored.
                // GDI will skip invalid screen coord from the screen into
                // the destination bitmap. This will result in copying un-init
                // bits back to the screen (since the screen is mirrored).
                // [samera]
                //
                if (IS_DC_RTL_MIRRORED(hdcScreen))
                {
                    RECT rcWindow;
                    GetWindowRect(g_dctx.hwndDC, &rcWindow);
                    rcWindow.right -= rcWindow.left;

                    if (rcBounds.right > rcWindow.right)
                    {
                        rcBounds.right = rcWindow.right;
                    }

                    if (rcBounds.left < 0)
                    {
                        rcBounds.left = 0;
                    }
                }

                cx = rcBounds.right - rcBounds.left;
                cy = rcBounds.bottom - rcBounds.top;

                //
                // Copy the union rect from the screen to hbmOffScreen.
                //
                CImageList::SelectDstBitmap(g_drb.hbmOffScreen);
                BitBlt(g_hdcDst, 0, 0, cx, cy,
                        hdcScreen, rcBounds.left, rcBounds.top, SRCCOPY);

                //
                // Hide the cursor on the hbmOffScreen by copying hbmRestore.
                //
                CImageList::SelectSrcBitmap(g_drb.hbmRestore);
                BitBlt(g_hdcDst,
                        rcOld.left - rcBounds.left,
                        rcOld.top - rcBounds.top,
                        g_drb.sizeRestore.cx, g_drb.sizeRestore.cy,
                        g_hdcSrc, 0, 0, SRCCOPY);

                //
                // Copy the original screen bits to hbmRestore
                //
                BitBlt(g_hdcSrc, 0, 0, g_drb.sizeRestore.cx, g_drb.sizeRestore.cy,
                        g_hdcDst,
                        rcNew.left - rcBounds.left,
                        rcNew.top - rcBounds.top,
                        SRCCOPY);

                //
                // Draw the image on hbmOffScreen
                //
                if (g_dctx.fHiColor)
                {
                    WimpyDrawEx(SAFECAST(g_dctx.pimlDrag, IImageList*), 0, g_hdcDst,
                            rcNew.left - rcBounds.left + IncOne,
                            rcNew.top - rcBounds.top, 0, 0, CLR_NONE, CLR_NONE, ILD_BLEND50);

                    if (g_dctx.puxCursor)
                    {
                        WimpyDraw(g_dctx.puxCursor, g_dctx.iCursor, g_hdcDst,
                                rcNew.left - rcBounds.left + g_dctx.ptCursor.x + IncOne,
                                rcNew.top - rcBounds.top + g_dctx.ptCursor.y,
                                ILD_NORMAL);
                            
                    }
                }
                else
                {
                    WimpyDraw(SAFECAST(g_dctx.pimlDrag, IImageList*), 0, g_hdcDst,
                            rcNew.left - rcBounds.left + IncOne,
                            rcNew.top - rcBounds.top, ILD_NORMAL);
                }

                //
                // Copy the hbmOffScreen back to the screen.
                //
                BitBlt(hdcScreen, rcBounds.left, rcBounds.top, cx, cy,
                        g_hdcDst, 0, 0, SRCCOPY);

                ImageList_ReleaseDragDC(hdcScreen);
            }
            g_dctx.ptDrag.x = x;
            g_dctx.ptDrag.y = y;
        }
    }
    LEAVECRITICAL;
    return S_OK;
}

HRESULT CImageList::BeginDrag(int iTrack, int dxHotspot, int dyHotspot)
{
    HRESULT hr = E_ACCESSDENIED;
    ENTERCRITICAL;
    if (!g_dctx.pimlDrag)
    {
        UINT newflags;
        int cxI = 0, cyI = 0;

        g_dctx.fDragShow = FALSE;
        g_dctx.hwndDC = NULL;
        g_dctx.fHiColor = GetScreenDepth() > 8;

        newflags = _flags|ILC_SHARED;

        if (g_dctx.fHiColor)
        {
            newflags = (newflags & ~ILC_COLORMASK) | ILC_COLOR16;
        }


        g_dctx.pimlDither = CImageList::Create(_cx, _cy, newflags, 1, 0);

        if (g_dctx.pimlDither)
        {
            g_dctx.pimlDither->_cImage++;
            g_dctx.ptDragHotspot.x = dxHotspot;
            g_dctx.ptDragHotspot.y = dyHotspot;

            g_dctx.pimlDither->_CopyOneImage(0, 0, 0, this, iTrack);

            hr = ImageList_SetDragImage(NULL, 0, dxHotspot, dyHotspot);
        }
    }
    LEAVECRITICAL;

    return hr;
}

HRESULT CImageList::DragEnter(HWND hwndLock, int x, int y)
{
    HRESULT hr = S_FALSE;

    hwndLock = hwndLock ? hwndLock : GetDesktopWindow();

    ENTERCRITICAL;
    if (!g_dctx.hwndDC)
    {
        g_dctx.hwndDC = hwndLock;

        g_dctx.ptDrag.x = x;
        g_dctx.ptDrag.y = y;

        ImageList_DragShowNolock(TRUE);
        hr = S_OK;
    }
    LEAVECRITICAL;

    return hr;
}


HRESULT CImageList::DragLeave(HWND hwndLock)
{
    HRESULT hr = S_FALSE;

    hwndLock = hwndLock ? hwndLock : GetDesktopWindow();

    ENTERCRITICAL;
    if (g_dctx.hwndDC == hwndLock)
    {
        ImageList_DragShowNolock(FALSE);
        g_dctx.hwndDC = NULL;
        hr = S_OK;
    }
    LEAVECRITICAL;

    return hr;
}

HRESULT CImageList::DragShowNolock(BOOL fShow)
{
    HDC hdcScreen;
    int x, y;
    int IncOne = 0;

    x = g_dctx.ptDrag.x - g_dctx.ptDragHotspot.x;
    y = g_dctx.ptDrag.y - g_dctx.ptDragHotspot.y;

    if (!g_dctx.pimlDrag)
        return E_ACCESSDENIED;

    //
    // REVIEW: Why this block is in the critical section? We are supposed
    //  to have only one dragging at a time, aren't we?
    //
    ENTERCRITICAL;
    if (fShow && !g_dctx.fDragShow)
    {
        hdcScreen = ImageList_GetDragDC();

        CImageList::SelectSrcBitmap(g_drb.hbmRestore);

        BitBlt(g_hdcSrc, 0, 0, g_drb.sizeRestore.cx, g_drb.sizeRestore.cy,
                hdcScreen, x, y, SRCCOPY);

        if (g_dctx.fHiColor)
        {
            WimpyDrawEx(SAFECAST(g_dctx.pimlDrag, IImageList*), 0, hdcScreen, x + IncOne, y, 0, 0, CLR_NONE, CLR_NONE, ILD_BLEND50);
            
            if (g_dctx.puxCursor)
            {
                WimpyDraw(g_dctx.puxCursor, g_dctx.iCursor, hdcScreen,
                    x + g_dctx.ptCursor.x + IncOne, y + g_dctx.ptCursor.y, ILD_NORMAL);
            }
        }
        else
        {
            WimpyDraw(SAFECAST(g_dctx.pimlDrag, IImageList*), 0, hdcScreen, x + IncOne, y, ILD_NORMAL);
        }

        ImageList_ReleaseDragDC(hdcScreen);
    }
    else if (!fShow && g_dctx.fDragShow)
    {
        hdcScreen = ImageList_GetDragDC();

        CImageList::SelectSrcBitmap(g_drb.hbmRestore);

        BitBlt(hdcScreen, x, y, g_drb.sizeRestore.cx, g_drb.sizeRestore.cy,
                g_hdcSrc, 0, 0, SRCCOPY);

        ImageList_ReleaseDragDC(hdcScreen);
    }

    g_dctx.fDragShow = fShow;
    LEAVECRITICAL;

    return S_OK;
}

// this hotspot stuff is broken in design
BOOL ImageList_MergeDragImages(int dxHotspot, int dyHotspot)
{
    CImageList* pimlNew;
    BOOL fRet = FALSE;

    if (g_dctx.pimlDither)
    {
        if (g_dctx.puxCursor)
        {
            IImageList* pux = NULL;
            IImageListPriv* puxpCursor;
            if (SUCCEEDED(g_dctx.puxCursor->QueryInterface(IID_PPV_ARG(IImageListPriv, &puxpCursor))))
            {
                // If the cursor list has a mirrored list, let's use that.
                if (FAILED(puxpCursor->GetMirror(IID_PPV_ARG(IImageList, &pux))))
                {
                    pux = g_dctx.puxCursor;
                    if (pux)
                        pux->AddRef();
                }
                puxpCursor->Release();
            }
            g_dctx.pimlDither->_Merge(0, pux, g_dctx.iCursor, dxHotspot, dyHotspot, &pimlNew);

            if (pimlNew && pimlNew->CreateDragBitmaps())
            {
                // WARNING: Don't destroy pimlDrag if it is pimlDither.
                if (g_dctx.pimlDrag && (g_dctx.pimlDrag != g_dctx.pimlDither))
                {
                    g_dctx.pimlDrag->Release();
                }

                g_dctx.pimlDrag = pimlNew;
                fRet = TRUE;
            }

            pux->Release();
        }
        else
        {
            if (g_dctx.pimlDither->CreateDragBitmaps())
            {
                g_dctx.pimlDrag = g_dctx.pimlDither;
                fRet = TRUE;
            }
        }
    } 
    else 
    {
        // not an error case if both aren't set yet
        // only an error if we actually tried the merge and failed
        fRet = TRUE;
    }

    return fRet;
}

BOOL ImageList_SetDragImage(HIMAGELIST piml, int i, int dxHotspot, int dyHotspot)
{
    BOOL fVisible = g_dctx.fDragShow;
    BOOL fRet;

    ENTERCRITICAL;
    if (fVisible)
        ImageList_DragShowNolock(FALSE);

    // only do this last step if everything is there.
    fRet = ImageList_MergeDragImages(dxHotspot, dyHotspot);

    if (fVisible)
        ImageList_DragShowNolock(TRUE);

    LEAVECRITICAL;
    return fRet;
}

HRESULT CImageList::GetDragImage(POINT * ppt, POINT * pptHotspot, REFIID riid, void** ppv)
{
    if (ppt)
    {
        ppt->x = g_dctx.ptDrag.x;
        ppt->y = g_dctx.ptDrag.y;
    }
    if (pptHotspot)
    {
        pptHotspot->x = g_dctx.ptDragHotspot.x;
        pptHotspot->y = g_dctx.ptDragHotspot.y;
    }
    if (g_dctx.pimlDrag)
    {
        return g_dctx.pimlDrag->QueryInterface(riid, ppv);
    }

    return E_ACCESSDENIED;
}


HRESULT CImageList::GetItemFlags(int i, DWORD *dwFlags)
{
    return E_NOTIMPL;
}

HRESULT CImageList::GetOverlayImage(int iOverlay, int* piIndex)
{
    return E_NOTIMPL;
}

HRESULT CImageList::SetDragCursorImage(IUnknown* punk, int i, int dxHotspot, int dyHotspot)
{
    HRESULT hr = E_INVALIDARG;
    BOOL fVisible = g_dctx.fDragShow;
    IImageList* pux;

    if (SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IImageList, &pux))))
    {
        ENTERCRITICAL;

        // do work only if something has changed
        if ((g_dctx.puxCursor != pux) || (g_dctx.iCursor != i)) 
        {

            if (fVisible)
                ImageList_DragShowNolock(FALSE);

            IImageList* puxOld = g_dctx.puxCursor;
            g_dctx.puxCursor = pux;
            g_dctx.puxCursor->AddRef();

            if (puxOld)
                puxOld->Release();
            g_dctx.iCursor = i;
            g_dctx.ptCursor.x = dxHotspot;
            g_dctx.ptCursor.y = dyHotspot;

            hr = ImageList_MergeDragImages(dxHotspot, dyHotspot)? S_OK: E_FAIL;

            if (fVisible)
                ImageList_DragShowNolock(TRUE);
        }
        LEAVECRITICAL;

        pux->Release();
    }
    return hr;
}

HRESULT CImageList::EndDrag()
{
    ENTERCRITICAL;
    ImageList_DragShowNolock(FALSE);

    // WARNING: Don't destroy pimlDrag if it is pimlDither.
    if (g_dctx.pimlDrag && (g_dctx.pimlDrag != g_dctx.pimlDither))
    {
        g_dctx.pimlDrag->Release();
    }
    g_dctx.pimlDrag = NULL;

    if (g_dctx.pimlDither)
    {
        g_dctx.pimlDither->Release();
        g_dctx.pimlDither = NULL;
    }

    if (g_dctx.puxCursor)
    {
        g_dctx.puxCursor->Release();
        g_dctx.puxCursor = NULL;
    }

    g_dctx.iCursor = -1;
    g_dctx.hwndDC = NULL;
    LEAVECRITICAL;

    return S_OK;
}


// APIs

BOOL WINAPI ImageList_SetDragCursorImage(HIMAGELIST piml, int i, int dxHotspot, int dyHotspot)
{
    BOOL fRet = FALSE;
    IUnknown* punk;
    HRESULT hr = HIMAGELIST_QueryInterface(piml, IID_PPV_ARG(IUnknown, &punk));
    if (SUCCEEDED(hr))
    {
        if (g_dctx.puxDragImage)
        {
            fRet = (S_OK == g_dctx.puxDragImage->SetDragCursorImage(punk, i, dxHotspot, dyHotspot));
        }

        punk->Release();
    }

    return fRet;
}

HIMAGELIST WINAPI ImageList_GetDragImage(POINT * ppt, POINT * pptHotspot)
{
    if (g_dctx.puxDragImage)
    {
        IImageList* punk;
        g_dctx.puxDragImage->GetDragImage(ppt, pptHotspot, IID_PPV_ARG(IImageList, &punk));

        return reinterpret_cast<HIMAGELIST>(punk);
    }

    return NULL;
}



void WINAPI ImageList_EndDrag()
{
    ENTERCRITICAL;
    if (g_dctx.puxDragImage)
    {
        g_dctx.puxDragImage->EndDrag();
        g_dctx.puxDragImage->Release();
        g_dctx.puxDragImage = NULL;
    }
    LEAVECRITICAL;
}


BOOL WINAPI ImageList_BeginDrag(HIMAGELIST pimlTrack, int iTrack, int dxHotspot, int dyHotspot)
{
    IImageList* pux;

    if (SUCCEEDED(HIMAGELIST_QueryInterface(pimlTrack, IID_PPV_ARG(IImageList, &pux))))
    {
        if (SUCCEEDED(pux->BeginDrag(iTrack, dxHotspot, dyHotspot)))
        {
            g_dctx.puxDragImage = pux;
            return TRUE;
        }
    }

    return FALSE;
}

BOOL WINAPI ImageList_DragEnter(HWND hwndLock, int x, int y)
{
    BOOL fRet = FALSE;
    if (g_dctx.puxDragImage)
    {
        fRet = (S_OK == g_dctx.puxDragImage->DragEnter(hwndLock, x, y));
    }

    return fRet;
}

BOOL WINAPI ImageList_DragMove(int x, int y)
{
    BOOL fRet = FALSE;
    if (g_dctx.puxDragImage)
    {
        fRet = (S_OK == g_dctx.puxDragImage->DragMove(x, y));
    }

    return fRet;
}

BOOL WINAPI ImageList_DragLeave(HWND hwndLock)
{
    BOOL fRet = FALSE;
    if (g_dctx.puxDragImage)
    {
        fRet = (S_OK == g_dctx.puxDragImage->DragLeave(hwndLock));
    }

    return fRet;
}

BOOL WINAPI ImageList_DragShowNolock(BOOL fShow)
{
    BOOL fRet = FALSE;
    if (g_dctx.puxDragImage)
    {
        fRet = (S_OK == g_dctx.puxDragImage->DragShowNolock(fShow));
    }

    return fRet;
}


//============================================================================
// ImageList_Clone - clone a image list
//
// create a new imagelist with the same properties as the given
// imagelist, except mabey a new icon size
//
//      piml    - imagelist to clone
//      cx,cy   - new icon size (0,0) to use clone icon size.
//      flags   - new flags (used if no clone)
//      cInitial- initial size
//      cGrow   - grow value (used if no clone)
//============================================================================

EXTERN_C HIMAGELIST WINAPI ImageList_Clone(HIMAGELIST himl, int cx, int cy, UINT flags, int cInitial, int cGrow)
{
    IImageListPriv* puxp;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageListPriv, &puxp))))
    {
        // always use the clone flags
        puxp->GetFlags(&flags);
        
        IUnknown* punkMirror;
        if (SUCCEEDED(puxp->GetMirror(IID_PPV_ARG(IUnknown, &punkMirror))))
        {
            flags |= ILC_MIRROR;
            punkMirror->Release();
        }

        IImageList* pux;
        if (SUCCEEDED(puxp->QueryInterface(IID_PPV_ARG(IImageList, &pux))))
        {
            int cxI, cyI;
            pux->GetIconSize(&cxI, &cyI);
            if (cx == 0)           
                cx = cxI;
            if (cy == 0)           
                cy = cyI;

            pux->Release();
        }

        puxp->Release();
    }

    return ImageList_Create(cx,cy,flags,cInitial,cGrow);
}


HRESULT WINAPI ImageList_CreateInstance(int cx, int cy, UINT flags, int cInitial, int cGrow, REFIID riid, void** ppv)
{
    CImageList* piml=NULL;
    HRESULT hr = E_OUTOFMEMORY;

    *ppv = NULL;

    piml = CImageList::Create(cx, cy, flags, cInitial, cGrow);

    if (piml)
    {
        //
        // Let's create a mirrored imagelist, if requested.
        //
        if (piml->_flags & ILC_MIRROR)
        {
            piml->_flags &= ~ILC_MIRROR;
            piml->_pimlMirror = CImageList::Create(cx, cy, flags, cInitial, cGrow);
            if (piml->_pimlMirror)
            {
                piml->_pimlMirror->_flags &= ~ILC_MIRROR;
            }
        }

        hr = piml->QueryInterface(riid, ppv);
        piml->Release();
    }

    return hr;

}

HIMAGELIST WINAPI ImageList_Create(int cx, int cy, UINT flags, int cInitial, int cGrow)
{
    IImageList* pux;
    ImageList_CreateInstance(cx, cy, flags, cInitial, cGrow, IID_PPV_ARG(IImageList, &pux));
    return reinterpret_cast<HIMAGELIST>(pux);
}

#ifdef UNICODE
//
// When this code is compiled Unicode, this implements the
// ANSI version of the ImageList_LoadImage api.
//

HIMAGELIST WINAPI ImageList_LoadImageA(HINSTANCE hi, LPCSTR lpbmp, int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags)
{
   HIMAGELIST lpResult;
   LPWSTR   lpBmpW;

   if (!IS_INTRESOURCE(lpbmp)) 
   {
       lpBmpW = ProduceWFromA(CP_ACP, lpbmp);

       if (!lpBmpW) 
       {
           return NULL;
       }

   }  
   else 
   {
       lpBmpW = (LPWSTR)lpbmp;
   }

   lpResult = ImageList_LoadImageW(hi, lpBmpW, cx, cGrow, crMask, uType, uFlags);

   if (!IS_INTRESOURCE(lpbmp))
       FreeProducedString(lpBmpW);

   return lpResult;
}
#else

//
// When this code is compiled ANSI, this stubs the
// Unicode version of the ImageList_LoadImage api.
//

IMAGELIST* WINAPI ImageList_LoadImageW(HINSTANCE hi, LPCWSTR lpbmp, int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags)
{
   SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING);
   return NULL;
}

#endif


HIMAGELIST WINAPI ImageList_LoadImage(HINSTANCE hi, LPCTSTR lpbmp, int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags)
{
    HBITMAP hbmImage;
    HIMAGELIST piml = NULL;
    BITMAP bm;
    int cy, cInitial;
    UINT flags;

    hbmImage = (HBITMAP)LoadImage(hi, lpbmp, uType, 0, 0, uFlags);
    if (hbmImage && (sizeof(bm) == GetObject(hbmImage, sizeof(bm), &bm)))
    {
        // If cx is not stated assume it is the same as cy.
        // ASSERT(cx);
        cy = bm.bmHeight;

        if (cx == 0)
            cx = cy;

        cInitial = bm.bmWidth / cx;

        ENTERCRITICAL;

        flags = 0;
        if (crMask != CLR_NONE)
            flags |= ILC_MASK;
        if (bm.bmBits)
            flags |= (bm.bmBitsPixel & ILC_COLORMASK);

        piml = ImageList_Create(cx, cy, flags, cInitial, cGrow);
        if (piml)
        {
            int added;

            if (crMask == CLR_NONE)
                added = ImageList_Add(piml, hbmImage, NULL);
            else
                added = ImageList_AddMasked(piml, hbmImage, crMask);

            if (added < 0)
            {
                ImageList_Destroy(piml);
                piml = NULL;
            }
        }
        LEAVECRITICAL;
    }

    if (hbmImage)
        DeleteObject(hbmImage);

    return reinterpret_cast<HIMAGELIST>((IImageList*)piml);
}

//
//
#undef ImageList_AddIcon
EXTERN_C int WINAPI ImageList_AddIcon(HIMAGELIST himl, HICON hIcon)
{
    return ImageList_ReplaceIcon(himl, -1, hIcon);
}

EXTERN_C void WINAPI ImageList_CopyDitherImage(HIMAGELIST himlDst, WORD iDst,
    int xDst, int yDst, HIMAGELIST himlSrc, int iSrc, UINT fStyle)
{
    IImageListPriv* puxp;

    if (SUCCEEDED(HIMAGELIST_QueryInterface(himlDst, IID_PPV_ARG(IImageListPriv, &puxp))))
    {
        IUnknown* punk;
        if (SUCCEEDED(HIMAGELIST_QueryInterface(himlSrc, IID_PPV_ARG(IUnknown, &punk))))
        {
            puxp->CopyDitherImage(iDst, xDst, yDst, punk, iSrc, fStyle);
            punk->Release();
        }
        puxp->Release();
    }
}

//
// ImageList_Duplicate
//
// Makes a copy of the passed in imagelist.
//
HIMAGELIST  WINAPI ImageList_Duplicate(HIMAGELIST himl)
{
    IImageList* pret = NULL;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        pux->Clone(IID_PPV_ARG(IImageList, &pret));
        pux->Release();
    }

    return reinterpret_cast<HIMAGELIST>(pret);
}

BOOL WINAPI ImageList_Write(HIMAGELIST himl, LPSTREAM pstm)
{
    BOOL fRet = FALSE;
    IPersistStream* pps;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IPersistStream, &pps))))
    {
        if (SUCCEEDED(pps->Save(pstm, TRUE)))
        {
            fRet = TRUE;
        }
        pps->Release();
    }

    return fRet;
}

HIMAGELIST WINAPI ImageList_Read(LPSTREAM pstm)
{
    CImageList* piml = new CImageList();
    if (piml)
    {
        if (SUCCEEDED(piml->Load(pstm)))
        {
            return reinterpret_cast<HIMAGELIST>((IImageList*)piml);
        }

        piml->Release();
    }

    return NULL;

}

BOOL WINAPI ImageList_GetImageRect(HIMAGELIST himl, int i, RECT * prcImage)
{
    BOOL fRet = FALSE;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        if (SUCCEEDED(pux->GetImageRect(i, prcImage)))
        {
            fRet = TRUE;
        }
        pux->Release();
    }

    return fRet;
}

BOOL        WINAPI ImageList_Destroy(HIMAGELIST himl)
{
    BOOL fRet = FALSE;
    IImageList* pux;
    // Weirdness: We are doing a Query Interface first to verify that 
    // this is actually a valid imagelist, then we are calling release twice
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        // Release the interface we QI'd for
        pux->Release();

        // Release a second time to destroy the object
        pux->Release();

        fRet = TRUE;
    }

    return fRet;
}

int         WINAPI ImageList_GetImageCount(HIMAGELIST himl)
{
    int fRet = 0;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        pux->GetImageCount(&fRet);
        pux->Release();
    }

    return fRet;
}

BOOL        WINAPI ImageList_SetImageCount(HIMAGELIST himl, UINT uNewCount)
{
    BOOL fRet = FALSE;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        fRet = (S_OK == pux->SetImageCount(uNewCount));
        pux->Release();
    }

    return fRet;
}
int         WINAPI ImageList_Add(HIMAGELIST himl, HBITMAP hbmImage, HBITMAP hbmMask)
{
    int fRet = -1;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        pux->Add(hbmImage, hbmMask, &fRet);
        pux->Release();
    }

    return fRet;
}

int         WINAPI ImageList_ReplaceIcon(HIMAGELIST himl, int i, HICON hicon)
{
    int fRet = -1;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        pux->ReplaceIcon(i, hicon, &fRet);
        pux->Release();
    }

    return fRet;
}

COLORREF    WINAPI ImageList_SetBkColor(HIMAGELIST himl, COLORREF clrBk)
{
    COLORREF fRet = clrBk;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        pux->SetBkColor(clrBk, &fRet);
        pux->Release();
    }

    return fRet;
}

COLORREF    WINAPI ImageList_GetBkColor(HIMAGELIST himl)
{
    COLORREF fRet = RGB(0,0,0);
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        pux->GetBkColor(&fRet);
        pux->Release();
    }

    return fRet;
}

BOOL        WINAPI ImageList_SetOverlayImage(HIMAGELIST himl, int iImage, int iOverlay)
{
    BOOL fRet = FALSE;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        fRet = (S_OK == pux->SetOverlayImage(iImage, iOverlay));
        pux->Release();
    }

    return fRet;
}

BOOL        WINAPI ImageList_Replace(HIMAGELIST himl, int i, HBITMAP hbmImage, HBITMAP hbmMask)
{
    BOOL fRet = FALSE;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        fRet = (S_OK == pux->Replace(i, hbmImage, hbmMask));
        pux->Release();
    }

    return fRet;
}

int         WINAPI ImageList_AddMasked(HIMAGELIST himl, HBITMAP hbmImage, COLORREF crMask)
{
    int fRet = -1;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        pux->AddMasked(hbmImage, crMask, &fRet);
        pux->Release();
    }

    return fRet;
}

BOOL        WINAPI ImageList_DrawEx(HIMAGELIST himl, int i, HDC hdcDst, int x, int y, int dx, int dy, COLORREF rgbBk, COLORREF rgbFg, UINT fStyle)
{
    BOOL fRet = FALSE;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        IMAGELISTDRAWPARAMS imldp = {0};
        imldp.cbSize = sizeof(imldp);
        imldp.himl   = himl;
        imldp.i      = i;
        imldp.hdcDst = hdcDst;
        imldp.x      = x;
        imldp.y      = y;
        imldp.cx     = dx;
        imldp.cy     = dy;
        imldp.rgbBk  = rgbBk;
        imldp.rgbFg  = rgbFg;
        imldp.fStyle = fStyle;

        fRet = (S_OK == pux->Draw(&imldp));
        pux->Release();
    }

    return fRet;
}

BOOL WINAPI ImageList_Draw(HIMAGELIST himl, int i, HDC hdcDst, int x, int y, UINT fStyle)
{
    BOOL fRet = FALSE;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        IMAGELISTDRAWPARAMS imldp = {0};
        imldp.cbSize = sizeof(imldp);
        imldp.himl   = himl;
        imldp.i      = i;
        imldp.hdcDst = hdcDst;
        imldp.x      = x;
        imldp.y      = y;
        imldp.rgbBk  = CLR_DEFAULT;
        imldp.rgbFg  = CLR_DEFAULT;
        imldp.fStyle = fStyle;
    
        fRet = (S_OK == pux->Draw(&imldp));
        pux->Release();
    }

    return fRet;
}


BOOL        WINAPI ImageList_DrawIndirect(IMAGELISTDRAWPARAMS* pimldp)
{
    BOOL fRet = FALSE;
    IImageList* pux;

    if (!pimldp)
        return fRet;

    if (SUCCEEDED(HIMAGELIST_QueryInterface(pimldp->himl, IID_PPV_ARG(IImageList, &pux))))
    {
        fRet = (S_OK == pux->Draw(pimldp));
        pux->Release();
    }

    return fRet;
}

BOOL        WINAPI ImageList_Remove(HIMAGELIST himl, int i)
{
    BOOL fRet = FALSE;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        fRet = (S_OK == pux->Remove(i));
        pux->Release();
    }

    return fRet;
}

HICON       WINAPI ImageList_GetIcon(HIMAGELIST himl, int i, UINT flags)
{
    HICON fRet = NULL;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        pux->GetIcon(i, flags, &fRet);
        pux->Release();
    }

    return fRet;
}
BOOL        WINAPI ImageList_Copy(HIMAGELIST himlDst, int iDst, HIMAGELIST himlSrc, int iSrc, UINT uFlags)
{
    BOOL fRet = FALSE;

    if (himlDst == himlSrc)
    {
        IImageList* pux;
        if (SUCCEEDED(HIMAGELIST_QueryInterface(himlDst, IID_PPV_ARG(IImageList, &pux))))
        {
            fRet = (S_OK == pux->Copy(iDst,(IUnknown*)pux, iSrc, uFlags));
            pux->Release();
        }

    }

    return fRet;
}

BOOL        WINAPI ImageList_GetIconSize(HIMAGELIST himl, int FAR *cx, int FAR *cy)
{
    BOOL fRet = FALSE;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        fRet = (S_OK == pux->GetIconSize(cx, cy));
        pux->Release();
    }

    return fRet;
}

BOOL        WINAPI ImageList_SetIconSize(HIMAGELIST himl, int cx, int cy)
{
    BOOL fRet = FALSE;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        fRet = (S_OK == pux->SetIconSize(cx, cy));
        pux->Release();
    }

    return fRet;
}
BOOL        WINAPI ImageList_GetImageInfo(HIMAGELIST himl, int i, IMAGEINFO FAR* pImageInfo)
{
    BOOL fRet = FALSE;
    IImageList* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageList, &pux))))
    {
        fRet = (S_OK == pux->GetImageInfo(i, pImageInfo));
        pux->Release();
    }

    return fRet;
}

HIMAGELIST  WINAPI ImageList_Merge(HIMAGELIST himl1, int i1, HIMAGELIST himl2, int i2, int dx, int dy)
{
    IImageList* fRet = NULL;
    IImageList* pux1;
    IImageList* pux2;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl1, IID_PPV_ARG(IImageList, &pux1))))
    {
        if (SUCCEEDED(HIMAGELIST_QueryInterface(himl2, IID_PPV_ARG(IImageList, &pux2))))
        {
            pux1->Merge(i1, (IUnknown*)pux2, i2, dx, dy, IID_PPV_ARG(IImageList, &fRet));
            pux2->Release();

        }
        pux1->Release();
    }

    return reinterpret_cast<HIMAGELIST>(fRet);
}

BOOL        WINAPI ImageList_SetFlags(HIMAGELIST himl, UINT flags)
{
    BOOL fRet = FALSE;
    IImageListPriv* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageListPriv, &pux))))
    {
        fRet = (S_OK == pux->SetFlags(flags));
        pux->Release();
    }

    return fRet;
}

BOOL        WINAPI ImageList_SetFilter(HIMAGELIST himl, PFNIMLFILTER pfnFilter, LPARAM lParamFilter)
{
    return FALSE;
}

int         ImageList_SetColorTable(HIMAGELIST himl, int start, int len, RGBQUAD *prgb)
{
    int fRet = -1;
    IImageListPriv* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageListPriv, &pux))))
    {
        pux->SetColorTable(start, len, prgb, &fRet);
        pux->Release();
    }

    return fRet;
}

UINT        WINAPI ImageList_GetFlags(HIMAGELIST himl)
{
    UINT fRet = 0;
    IImageListPriv* pux;
    if (SUCCEEDED(HIMAGELIST_QueryInterface(himl, IID_PPV_ARG(IImageListPriv, &pux))))
    {
        pux->GetFlags(&fRet);
        pux->Release();
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\listview.c ===
#include "ctlspriv.h"
#include "listview.h"
#include "image.h"
#include <mlang.h>
#include <inetreg.h>

#define __IOleControl_INTERFACE_DEFINED__       // There is a conflict with the IOleControl's def of CONTROLINFO
#include "shlobj.h"

#define IE_SETTINGS          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced")
#define USE_DBL_CLICK_TIMER  TEXT("UseDoubleClickTimer")

int g_bUseDblClickTimer;

#define LVMP_WINDOWPOSCHANGED (WM_USER + 1)
HRESULT WINAPI UninitializeFlatSB(HWND hwnd);

#define COLORISLIGHT(clr) ((5*GetGValue((clr)) + 2*GetRValue((clr)) + GetBValue((clr))) > 8*128)

void NEAR ListView_HandleMouse(LV* plv, BOOL fDoubleClick, int x, int y, UINT keyFlags, BOOL bMouseWheel);

/// function table setup
const PFNLISTVIEW_DRAWITEM pfnListView_DrawItem[4] = {
    ListView_IDrawItem,
    ListView_RDrawItem,
    ListView_IDrawItem,
    ListView_LDrawItem,
};

void ListView_HandleStateIconClick(LV* plv, int iItem);

DWORD ListView_IApproximateViewRect(LV* ,int, int, int);
DWORD ListView_RApproximateViewRect(LV* ,int, int, int);
DWORD ListView_LApproximateViewRect(LV* ,int, int, int);

const PFNLISTVIEW_APPROXIMATEVIEWRECT pfnListView_ApproximateViewRect[4] = {
    ListView_IApproximateViewRect,
    ListView_RApproximateViewRect,
    ListView_IApproximateViewRect,
    ListView_LApproximateViewRect,
};

const PFNLISTVIEW_UPDATESCROLLBARS pfnListView_UpdateScrollBars[4] = {
    ListView_IUpdateScrollBars,
    ListView_RUpdateScrollBars,
    ListView_IUpdateScrollBars,
    ListView_LUpdateScrollBars,
};

const PFNLISTVIEW_ITEMHITTEST pfnListView_ItemHitTest[4] = {
    ListView_IItemHitTest,
    ListView_RItemHitTest,
    ListView_SItemHitTest,
    ListView_LItemHitTest,
};

const PFNLISTVIEW_ONSCROLL pfnListView_OnScroll[4] = {
    ListView_IOnScroll,
    ListView_ROnScroll,
    ListView_IOnScroll,
    ListView_LOnScroll,
};

const PFNLISTVIEW_SCROLL2 pfnListView_Scroll2[4] = {
    ListView_IScroll2,
    ListView_RScroll2,
    ListView_IScroll2,
    ListView_LScroll2,
};

const PFNLISTVIEW_GETSCROLLUNITSPERLINE pfnListView_GetScrollUnitsPerLine[4] = {
    ListView_IGetScrollUnitsPerLine,
    ListView_RGetScrollUnitsPerLine,
    ListView_IGetScrollUnitsPerLine,
    ListView_LGetScrollUnitsPerLine,
};


// redefine to trace at most calls to ListView_SendChange
#define DM_LVSENDCHANGE 0


// BUGBUG -- penwin.h is messed up; define local stuff for now
#define HN_BEGINDIALOG        40    // Lens/EditText/garbage detection dialog is about
                                    // to come up on this hedit/bedit
#define HN_ENDDIALOG          41    // Lens/EditText/garbage detection dialog has
                                    // just been destroyed

//---------------------------------------------------------
// no way am I gonna make TWO function calls where I can do FOUR comparisons!
//
#define RECTS_IN_SIZE( sz, r2 ) (!RECTS_NOT_IN_SIZE( sz, r2 ))

#define RECTS_NOT_IN_SIZE( sz, r2 ) (\
   ( (sz).cx <= (r2).left ) ||\
   ( 0 >= (r2).right ) ||\
   ( (sz).cy <= (r2).top ) ||\
   ( 0 >= (r2).bottom ) )

//---------------------------------------------------------


void NEAR ListView_OnUpdate(LV* plv, int i);
void NEAR ListView_OnDestroy(LV* plv);
BOOL NEAR PASCAL ListView_ValidateScrollParams(LV* plv, int FAR * dx, int FAR *dy);
UINT LV_IsItemOnViewEdge(LV* plv, LISTITEM *pitem);
void PASCAL ListView_ButtonSelect(LV* plv, int iItem, UINT keyFlags, BOOL bSelected);
void NEAR ListView_DeselectAll(LV* plv, int iDontDeselect);
void ListView_LRInvalidateBelow(LV* plv, int i, int fSmoothScroll);
void ListView_IInvalidateBelow(LV* plv, int i);
void NEAR ListView_InvalidateFoldedItem(LV* plv, int iItem, BOOL fSelectionOnly, UINT fRedraw);
void ListView_ReleaseBkImage(LV *plv);
void ListView_RecalcRegion(LV *plv, BOOL fForce, BOOL fRedraw);

BOOL g_fSlowMachine = -1;

#pragma code_seg(CODESEG_INIT)

BOOL FAR ListView_Init(HINSTANCE hinst)
{
    WNDCLASS wc;

    if (!GetClassInfo(hinst, c_szListViewClass, &wc)) {
#ifndef WIN32
        LRESULT CALLBACK _ListView_WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
        wc.lpfnWndProc     = _ListView_WndProc;
#else
        wc.lpfnWndProc     = ListView_WndProc;
#endif
        wc.hCursor         = LoadCursor(NULL, IDC_ARROW);
        wc.hIcon           = NULL;
        wc.lpszMenuName    = NULL;
        wc.hInstance       = hinst;
        wc.lpszClassName   = c_szListViewClass;
        wc.hbrBackground   = (HBRUSH)(COLOR_WINDOW + 1); // NULL;
        wc.style           = CS_DBLCLKS | CS_GLOBALCLASS;
        wc.cbWndExtra      = sizeof(LV*);
        wc.cbClsExtra      = 0;

        return RegisterClass(&wc);
    }
    return TRUE;
}
#pragma code_seg()


BOOL NEAR ListView_GetRegIASetting(BOOL *pb)
{
    HKEY        hkey;
    BOOL        bRet = FALSE;
    BOOL        bValue = TRUE;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, IE_SETTINGS, 0, KEY_READ, &hkey) == ERROR_SUCCESS)
    {
        DWORD dwType;
        DWORD dwValue;
        DWORD cbValue = sizeof(DWORD);

        if (RegQueryValueEx(hkey, (LPTSTR)USE_DBL_CLICK_TIMER, 0, &dwType, (LPBYTE)&dwValue, &cbValue) == ERROR_SUCCESS)
        {
            bValue = (BOOL)dwValue;
            bRet = TRUE;
        }
        RegCloseKey(hkey);
    }

    *pb = bValue;
    return bRet;
}


BOOL NEAR ListView_NotifyCacheHint(LV* plv, int iFrom, int iTo)
{
    NM_CACHEHINT nm;

    ASSERT( iFrom <= iTo );
    if (iFrom <= iTo)
    {
        nm.iFrom = iFrom;
        nm.iTo = iTo;
        return !(BOOL)CCSendNotify(&plv->ci, LVN_ODCACHEHINT, &nm.hdr);
    }
    return FALSE;
}

void NEAR ListView_LazyCreateObjects(LV *plv, int iMin, int iMax)
{
    for ( ; iMin < iMax; iMin++)
        MyNotifyWinEvent(EVENT_OBJECT_CREATE, plv->ci.hwnd, OBJID_CLIENT, 1 + iMin);
}

//
//  Owner-data causes MSAA lots of grief, because there is no way to tell
//  MSAA "I just created 25 million items".  You have to tell it one at a
//  time.  Instead of sending out 25 million "add item" notifications, we
//  just send them out as they scroll into view.
//
//  plv->iMSAAMin and plv->iMSAAMax are the range of items we most
//  recently told MSAA about.  MSAAMax is *exclusive*, just like RECTs.
//  It makes the math easier.
//
//  We use iMSAAMin and iMSAAMax to avoid sending blatantly redundant
//  notifications, which would other happen very frequently.
//
void NEAR ListView_LazyCreateWinEvents(LV *plv, int iFrom, int iTo)
{
    int iMin = iFrom;
    int iMax = iTo+1;           // Convert from [From,To] to [Min,Max)

#ifdef LVDEBUG
    DebugMsg(TF_LISTVIEW, TEXT("lv.CWE old: [%d,%d), new=[%d,%d)"),
            plv->iMSAAMin, plv->iMSAAMax,
            iMin, iMax);
#endif

    //
    //  If the incoming range is entirely contained within the existing
    //  range, then there is nothing to do.  This happens a lot.
    //
    if (iMin >= plv->iMSAAMin && iMax <= plv->iMSAAMax)
        return;

    //
    //  If the incoming range is adjacent to or overlaps the low end
    //  of the existing range...  (This happens when scrolling backwards.)
    //
    if (iMin <= plv->iMSAAMin && iMax >= plv->iMSAAMin) {

        // Notify the low end.
        ListView_LazyCreateObjects(plv, iMin, plv->iMSAAMin);

        // Extend the list of things we've notified.
        plv->iMSAAMin = iMin;

        // Remove it from the things left to be notified.
        iMin = plv->iMSAAMax;
    }

    //
    //  Now do the same thing to the top end.
    //  (This happens when scrolling forwards.)
    //
    if (iMax >= plv->iMSAAMax && iMin <= plv->iMSAAMax) {

        // Notify the top end.
        ListView_LazyCreateObjects(plv, plv->iMSAAMax, iMax);

        // Extend the list of things we've notified.
        plv->iMSAAMax = iMax;

        // Remove it from the things left to be notified.
        iMax = plv->iMSAAMin;
    }

    //
    //  If there are still things to be notified, then it means that the
    //  incoming range isn't contiguous with the previous range, so throw
    //  away the old range and just set it to the current range.
    //  (This happens when you grab the scrollbar and jump to a completely
    //  unrelated part of the listview.)
    //
    if (iMin < iMax) {
        plv->iMSAAMin = iMin;
        plv->iMSAAMax = iMax;
        ListView_LazyCreateObjects(plv, iMin, iMax);
    }

#ifdef LVDEBUG
    DebugMsg(TF_LISTVIEW, TEXT("lv.CWE aft: [%d,%d)"), plv->iMSAAMin, plv->iMSAAMax);
#endif

}

LRESULT NEAR ListView_RequestFindItem(LV* plv, CONST LV_FINDINFO* plvfi, int iStart)
{
    NM_FINDITEM nm;

    nm.lvfi = *plvfi;
    nm.iStart = iStart;
    return CCSendNotify(&plv->ci, LVN_ODFINDITEM, &nm.hdr);
}

BOOL NEAR ListView_SendChange(LV* plv, int i, int iSubItem, int code, UINT oldState, UINT newState,
                              UINT changed, LPARAM lParam)
{
    NM_LISTVIEW nm;

    nm.iItem = i;
    nm.iSubItem = iSubItem;
    nm.uNewState = newState;
    nm.uOldState = oldState;
    nm.uChanged = changed;
    nm.ptAction.x = 0;
    nm.ptAction.y = 0;
    nm.lParam = lParam;

    return !CCSendNotify(&plv->ci, code, &nm.hdr);
}

void NEAR ListView_SendODChangeAndInvalidate(LV* plv, int iFrom, int iTo, UINT oldState,
                                UINT newState)
{
    NM_ODSTATECHANGE nm;

    nm.iFrom = iFrom;
    nm.iTo = iTo;
    nm.uNewState = newState;
    nm.uOldState = oldState;

    CCSendNotify(&plv->ci, LVN_ODSTATECHANGED, &nm.hdr);

    // Tell accessibility, "Selection changed in a complex way"
    MyNotifyWinEvent(EVENT_OBJECT_SELECTIONWITHIN, plv->ci.hwnd, OBJID_CLIENT, CHILDID_SELF);

    // considerable speed increase less than 100 to do this method
    // while over 100, the other method works faster
    if ((iTo - iFrom) > 100)
    {
        InvalidateRect( plv->ci.hwnd, NULL, FALSE );
    }
    else
    {
        while (iFrom <= iTo)
        {
            ListView_InvalidateItem(plv, iFrom, TRUE, RDW_INVALIDATE);
            iFrom++;
        }
    }
}

BOOL NEAR ListView_Notify(LV* plv, int i, int iSubItem, int code)
{
    NM_LISTVIEW nm;
    nm.iItem = i;
    nm.iSubItem = iSubItem;
    nm.uNewState = nm.uOldState = 0;
    nm.uChanged = 0;
    nm.lParam = 0;

   if (!ListView_IsOwnerData( plv )) {
       if (code == LVN_DELETEITEM) {
           LISTITEM FAR * pItem = ListView_GetItemPtr(plv, i);
           if (pItem) {
               nm.lParam = pItem->lParam;
           }
       }
   }

    return (BOOL)CCSendNotify(&plv->ci, code, &nm.hdr);
}

BOOL NEAR ListView_GetEmptyText(LV* plv)
{
    NMLVDISPINFO nm;
    BOOL ret;
    TCHAR szText[80];

    if (plv->fNoEmptyText)
        return FALSE;

    if (plv->pszEmptyText)
        return TRUE;

    // For each listview control, we will only send this notify
    // once if necessary.

    memset(&nm, 0, SIZEOF(NMLVDISPINFO));
    nm.item.mask = LVIF_TEXT;
    nm.item.cchTextMax = ARRAYSIZE(szText);
    nm.item.pszText = szText;
    szText[0] = TEXT('\0');

    ret = (BOOL)CCSendNotify(&plv->ci, LVN_GETEMPTYTEXT, &nm.hdr);

    if (ret)
        // save the text so we don't notify again.
        Str_Set(&plv->pszEmptyText, szText);
    else
        // set a flag so we don't notify again.
        plv->fNoEmptyText = TRUE;

    return ret;
}

void NEAR ListView_NotifyFocusEvent(LV *plv)
{
    if (plv->iFocus != -1 && IsWindowVisible(plv->ci.hwnd) && GetFocus() == plv->ci.hwnd)
        MyNotifyWinEvent(EVENT_OBJECT_FOCUS, plv->ci.hwnd, OBJID_CLIENT,
                plv->iFocus+1);
}

//
//  Call this function when the listview has changed in a radical manner.
//  It notifies MSAA that "Whoa, things are completely different now."
//
void NEAR ListView_NotifyRecreate(LV *plv)
{
    MyNotifyWinEvent(EVENT_OBJECT_DESTROY, plv->ci.hwnd, OBJID_CLIENT, CHILDID_SELF);
    MyNotifyWinEvent(EVENT_OBJECT_CREATE, plv->ci.hwnd, OBJID_CLIENT, CHILDID_SELF);
    plv->iMSAAMin = plv->iMSAAMax = 0;
}

int NEAR ListView_OnSetItemCount(LV *plv, int iItems, DWORD dwFlags)
{
   BOOL frt = TRUE;

   // For compatability we assume 0 for flags implies old (Athena) type of functionality and
   // does a Invalidate all otherwise if low bit is set we try to be a bit smarter.  First pass
   // If the first added item is visible invalidate all.  Yes we can do better...
   if (ListView_IsOwnerData( plv )) {
       int iItem;
       int cTotalItemsOld = plv->cTotalItems;
       BOOL fInvalidateAll = ((dwFlags & LVSICF_NOINVALIDATEALL) == 0);

       if ((iItems >= 0) && (iItems <= MAX_LISTVIEWITEMS)) {

           plv->cTotalItems = iItems;

           // check focus
           if (plv->iFocus >= iItems)
              plv->iFocus = -1;
          if (plv->iDropHilite >= iItems)
              plv->iDropHilite = -1;

           // check mark
           if (plv->iMark >= iItems)
              plv->iMark = -1;

           // make sure no selections above number of items
           plv->plvrangeCut->lpVtbl->ExcludeRange(plv->plvrangeCut, iItems, SELRANGE_MAXVALUE );
           if (FAILED(plv->plvrangeSel->lpVtbl->ExcludeRange(plv->plvrangeSel, iItems, SELRANGE_MAXVALUE ))) {
               //BUGBUG:  Return low memory status
               //MemoryLowDlg( plv->ci.hwnd );
               return FALSE;
           }


           plv->rcView.left = RECOMPUTE;  // recompute view rect

           if ( ListView_IsSmallView(plv) || ListView_IsIconView(plv) ) {
               // Call off to the arrange function.
               ListView_OnArrange(plv, LVA_DEFAULT);

               if (!fInvalidateAll)
               {
                   // Try to be smart and invalidate only what we need to.
                   // Add a little logic to erase any message like no items found when
                   // the view was previously empty...
                   if (cTotalItemsOld < iItems)
                       iItem = cTotalItemsOld;
                   else
                       iItem = iItems - 1;  // Get the index

                   if ((iItem >= 0) && (cTotalItemsOld > 0))
                       ListView_IInvalidateBelow(plv, iItem);
                   else
                       fInvalidateAll = TRUE;
               }

           } else {
               ListView_Recompute(plv);
               // if we have empty text and old count was zero... then we should redraw all
               if (plv->pszEmptyText && (cTotalItemsOld == 0) && (iItems > 0))
                   fInvalidateAll = TRUE;

               // Try to do smart invalidates...
               if (!fInvalidateAll)
               {
                   // Try to be smart and invalidate only what we need to.
                   if (cTotalItemsOld < iItems)
                       iItem = cTotalItemsOld;
                   else
                       iItem = iItems - 1;  // Get the index

                   if (iItem >= 0)
                       ListView_LRInvalidateBelow(plv, iItem, FALSE);
               }


               // We may try to resize the column
               ListView_MaybeResizeListColumns(plv, 0, ListView_Count(plv)-1);

               // For compatability we assume 0 for flags implies old type
               // of functionality and scrolls the important item into view.
               // If second bit is set, we leave the scroll position alone.
               if ((dwFlags & LVSICF_NOSCROLL) == 0) {
                   // what is the important item
                   iItem = (plv->iFocus >= 0) ?
                           plv->iFocus :
                           ListView_OnGetNextItem(plv, -1, LVNI_SELECTED);

                   iItem = max(0, iItem);

                   // make important item visable
                   ListView_OnEnsureVisible(plv, iItem, FALSE);
               }
           }


           if (fInvalidateAll)
               InvalidateRect(plv->ci.hwnd, NULL, TRUE);
           ListView_UpdateScrollBars(plv);

           ListView_NotifyRecreate(plv);
           ListView_NotifyFocusEvent(plv);

       } else {
           frt = FALSE;
       }

   } else {
       if (plv->hdpaSubItems)
       {
           int iCol;
           for (iCol = plv->cCol - 1; iCol >= 0; iCol--)
           {
               HDPA hdpa = ListView_GetSubItemDPA(plv, iCol);
               if (hdpa)   // this is optional, call backs don't have them
                   DPA_Grow(hdpa, iItems);
           }
       }

       DPA_Grow(plv->hdpa, iItems);
       DPA_Grow(plv->hdpaZOrder, iItems);
    }

    return frt;
}

typedef struct _LVSortInfo
{
    LV*     plv;
    BOOL fSortIndices;
    PFNLVCOMPARE        pfnCompare;
    LPARAM              lParam;
    BOOL                bPassLP;
} LVSortInfo;

int CALLBACK ListView_SortCallback(LPVOID dw1, LPVOID dw2, LPARAM lParam)
{
    LISTITEM FAR *pitem1;
    LISTITEM FAR *pitem2;
    LVSortInfo FAR *pSortInfo = (LVSortInfo FAR *)lParam;

    ASSERT(!ListView_IsOwnerData(pSortInfo->plv));

    // determine whether  dw1 and dw2 are indices or the real items
    // and assign pitem? accordingly
    if (pSortInfo->fSortIndices) {
        pitem1 = ListView_GetItemPtr(pSortInfo->plv, PtrToUlong(dw1));
        pitem2 = ListView_GetItemPtr(pSortInfo->plv, PtrToUlong(dw2));
    } else {
        pitem1 = (LISTITEM FAR *)dw1;
        pitem2 = (LISTITEM FAR *)dw2;
    }

    if (!pSortInfo->pfnCompare) {
        // Treat NULL pszText like null string.
        LPCTSTR pszText1 = pitem1->pszText ? pitem1->pszText : c_szNULL;
        LPCTSTR pszText2 = pitem2->pszText ? pitem2->pszText : c_szNULL;

        // bugbug, should allow callbacks in text
        if (pszText1 != LPSTR_TEXTCALLBACK &&
            pszText2 != LPSTR_TEXTCALLBACK )
        {
            return lstrcmpi(pitem1->pszText, pitem2->pszText);
        }
        RIPMSG(0, "LVM_SORTITEM(EX): Cannot combine NULL callback with LPSTR_TEXTCALLBACK");
        return -1;
    } else
    {
        if (pSortInfo->bPassLP)
            return(pSortInfo->pfnCompare(pitem1->lParam, pitem2->lParam, pSortInfo->lParam));
        else 
        {
            if (pSortInfo->fSortIndices)
                return(pSortInfo->pfnCompare((LPARAM)dw1, (LPARAM)dw2, pSortInfo->lParam));
            else
            {
                // we want to sort by the indices, but all we've got are pointers to the items
                // and there is no way to get back from that pointer to an index
                ASSERT(0);
                return -1;
            }
        }

    }
    ASSERT(0);
    return -1;
}

VOID ListView_InvalidateTTLastHit(LV* plv, int iNewHit)
{
    if (plv->iTTLastHit == iNewHit)
    {
        plv->iTTLastHit = -1;
        if (plv->pszTip && plv->pszTip != LPSTR_TEXTCALLBACK)
        {
            plv->pszTip[0] = 0;
        }
    }
}

BOOL NEAR PASCAL ListView_SortAllColumns(LV* plv, LVSortInfo FAR * psi)
{
    ASSERT(!ListView_IsOwnerData(plv));

    ListView_InvalidateTTLastHit(plv, plv->iTTLastHit);

    // don't do this optimization if we will need the indices to sort by
    if (psi->bPassLP && ((!plv->hdpaSubItems) || !DPA_GetPtrCount(plv->hdpaSubItems))) {
        psi->fSortIndices = FALSE;
        return (DPA_Sort(plv->hdpa, ListView_SortCallback, (LPARAM)psi));
    } else {
        // if we need to sort several hdpa's, create one DPA of just indices
        // and sort that, then fix up all the dpa's
        BOOL fReturn = FALSE;
        HDPA hdpa;
        int i;
        int iMax;
        void FAR * FAR * ph;
        void FAR * FAR *pNewIndices;

        // initialize the hdpa with indices
        hdpa = DPA_Clone(plv->hdpa, NULL);
        if (hdpa) {
            ASSERT(DPA_GetPtrCount(plv->hdpa) == DPA_GetPtrCount(hdpa));
            ph = pNewIndices = DPA_GetPtrPtr(hdpa);
            iMax = DPA_GetPtrCount(hdpa);
            for( i = 0; i < iMax; ph++, i++) {
                *ph = IntToPtr(i);
            }

            psi->fSortIndices = TRUE;
            if (DPA_Sort(hdpa, ListView_SortCallback, (LPARAM)psi)) {
#ifdef WIN32
                ph = LocalAlloc(LPTR, sizeof(LPVOID) * iMax);
#else
                ph = Alloc(sizeof(LPVOID) * iMax);
#endif

                if (ph) {
                    int j;
                    void FAR * FAR *pSubItems;

                    // we could get here because bPassLP is false, even if we don't have subitems
                    if (plv->hdpaSubItems && DPA_GetPtrCount(plv->hdpaSubItems))
                    {
                        for (i = DPA_GetPtrCount(plv->hdpaSubItems) - 1; i >= 0; i--) {
                            HDPA hdpaSubItem = ListView_GetSubItemDPA(plv, i);

                            if (hdpaSubItem) {

                                // make sure it's of the right size
                                while (DPA_GetPtrCount(hdpaSubItem) < iMax) {
                                    if (DPA_InsertPtr(hdpaSubItem, iMax, NULL) == -1)
                                        goto Bail;
                                }


                                // actually copy across the dpa with the new indices
                                pSubItems = DPA_GetPtrPtr(hdpaSubItem);
                                for (j = 0; j < iMax; j++) {
                                    ph[j] = pSubItems[PtrToUlong(pNewIndices[j])];
                                }

                                // finally, copy it all back to the pSubItems;
                                hmemcpy(pSubItems, ph, sizeof(LPVOID) * iMax);
                            }
                        }
                    }

                    // now do the main hdpa
                    pSubItems = DPA_GetPtrPtr(plv->hdpa);
                    for (j = 0; j < iMax; j++) {
                        ph[j] = pSubItems[PtrToUlong(pNewIndices[j])];
                    }

                    // finally, copy it all back to the pSubItems;
                    hmemcpy(pSubItems, ph, sizeof(LPVOID) * iMax);
                    fReturn = TRUE;
Bail:
#ifdef WIN32
                    LocalFree(ph);
#else
                    Free(ph);
#endif

                }
            }
            DPA_Destroy(hdpa);
        }
        return fReturn;

    }
}

DWORD ListView_OnApproximateViewRect(LV* plv, int iCount, int iWidth, int iHeight)
{
    if (iCount == -1)
        iCount = ListView_Count(plv);

    if (iWidth == -1)
        iWidth = plv->sizeClient.cx;

    if (iHeight == -1)
        iHeight = plv->sizeClient.cy;

    return _ListView_ApproximateViewRect(plv, iCount, iWidth, iHeight);
}

DWORD ListView_OnSetLVRangeObject(LV* plv, int iWhich, ILVRange *plvrange)
{
    ILVRange **pplvrange;
    switch (iWhich)
    {
    case LVSR_SELECTION:
        pplvrange = &plv->plvrangeSel;
        break;
    case LVSR_CUT:
        pplvrange = &plv->plvrangeCut;
        break;
    default:
        return FALSE;
    }
    if (*pplvrange)
    {
        // Release the old one
        (*pplvrange)->lpVtbl->Release(*pplvrange);
    }
    *pplvrange = plvrange;

    // Hold onto the pointer...
    if (plvrange)
        plvrange->lpVtbl->AddRef(plvrange);

    return TRUE;
}


BOOL NEAR PASCAL ListView_OnSortItems(LV *plv, LPARAM lParam, PFNLVCOMPARE pfnCompare, BOOL bPassLP)
{
    LVSortInfo SortInfo;
    LISTITEM FAR *pitemFocused;
    SortInfo.pfnCompare = pfnCompare;
    SortInfo.lParam     = lParam;
    SortInfo.plv = plv;
    SortInfo.bPassLP = bPassLP;

   if (ListView_IsOwnerData(plv)) {
      RIPMSG(0, "LVM_SORTITEMS: Invalid for owner-data listview");
      return FALSE;
   }

    ListView_DismissEdit(plv, TRUE);    // cancel edits

    // we're going to mess with the indices, so stash away the pointer to the
    // focused item.
    if (plv->iFocus != -1) {
        pitemFocused = ListView_GetItemPtr(plv, plv->iFocus);
    } else
        pitemFocused = NULL;

    if (ListView_SortAllColumns(plv, &SortInfo)) {

        // restore the focused item.
        if (pitemFocused) {
            int i;
            for (i = ListView_Count(plv) - 1; i >= 0 ; i--) {
                if (ListView_GetItemPtr(plv, i) == pitemFocused) {
                    plv->iFocus = i;
                    plv->iMark = i;
                }
            }
        }

        if (ListView_IsSmallView(plv) || ListView_IsIconView(plv))
        {
            ListView_CommonArrange(plv, LVA_DEFAULT, plv->hdpa);
        }
        else if (ListView_IsReportView(plv) || ListView_IsListView(plv))
        {
            InvalidateRect(plv->ci.hwnd, NULL, TRUE);
        }

        // The items in the view have moved around; let apps know
        MyNotifyWinEvent(EVENT_OBJECT_REORDER, plv->ci.hwnd, OBJID_CLIENT, 0);
        return(TRUE);
    }
    return FALSE;
}


void PASCAL ListView_EnableWindow(LV* plv, BOOL wParam)
{
    if (wParam) {
        if (plv->ci.style & WS_DISABLED) {
            plv->ci.style &= ~WS_DISABLED;      // enabled
            ListView_OnSetBkColor(plv, plv->clrBkSave);
        }
    } else {
        if (!(plv->ci.style & WS_DISABLED)) {
            plv->clrBkSave = plv->clrBk;
            plv->ci.style |= WS_DISABLED;       // disabled
            ListView_OnSetBkColor(plv, g_clrBtnFace);
        }
    }
    RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
}


BOOL NEAR ListView_IsItemVisible(LV* plv, int i)
// Assumes parmss ok etc for speed. Called inside region calc code.
{
    RECT rcBounds;
    RECT rc, rcScratch;

    // get bounding rect of item
    ListView_GetRects(plv, i, NULL, NULL, &rcBounds, NULL);

    // setup rect for listview client. Should perf this up for
    // multimonitor case where there are dead zones in work area...
    rc.left  = 0;
    rc.top   = 0;
    rc.right = plv->sizeClient.cx;
    rc.bottom= plv->sizeClient.cy;

    return IntersectRect(&rcScratch, &rc, &rcBounds);
}



// Helper for ListView_RecalcRegion
#define BitOn(lpbits, x, y, cx) (*((BYTE *)(lpbits + ((y * cx) + (x / 8)))) & (0x80 >> (x % 8)))

void ListView_RecalcRegion(LV* plv, BOOL fForce, BOOL fRedraw)
{
    HRGN hrgnUnion = NULL;
    HRGN hrgn = NULL;
    int i;
    HDC hdc = NULL;
    BYTE * lpBits = NULL;
    HBITMAP hbmp = NULL, hbmpOld = NULL;
    RECT rc, rcIcon;
    LISTITEM FAR * pitem;
    BITMAP bm;

    // Bail out if we don't need to do any work
    if (!(plv->exStyle & LVS_EX_REGIONAL) || !ListView_RedrawEnabled(plv) ||
        (plv->flags & LVF_INRECALCREGION))
        return;

    // To prevent recursion
    plv->flags |= LVF_INRECALCREGION;

    if ((ListView_Count(plv) > 0)) {
        int cxIcon, cyIcon;
        int dxOffset, dyOffset;

        // Run through first to see if anything changed - bail if not!
        if (!fForce) {
            for (i = 0; i < ListView_Count(plv); i++) {
                pitem = ListView_FastGetItemPtr(plv, i);

                if (!ListView_IsItemVisible(plv, i))
                {
                    if (pitem->hrgnIcon == (HANDLE)-1 || !pitem->hrgnIcon)
                        // Item was invisible and still is. Nothing changed.
                        continue;

                    if (pitem->hrgnIcon)
                    {
                        // Item was visible and now is invisible... Something
                        // changed.
                        pitem->ptRgn.x = RECOMPUTE;
                        pitem->ptRgn.y = RECOMPUTE;
                        DeleteObject(pitem->hrgnIcon);
                        pitem->hrgnIcon = NULL;
                    }
                }

                ListView_GetRects(plv, i, NULL, &rc, NULL, NULL);

                // If the location of the icon or the text rectangle have
                // changed, then we need to continue so that we can recalculate
                // the region.
                if ((pitem->pt.x != pitem->ptRgn.x) ||
                    (pitem->pt.y != pitem->ptRgn.y) ||
                    (!pitem->hrgnIcon) ||
                    !EqualRect((CONST RECT *)&pitem->rcTextRgn, (CONST RECT *)&rc))
                    goto changed;

            }
            // If we go through all the items and nothing changed, then
            // we can return without doing any work!
            ASSERT(i == ListView_Count(plv));
            goto exit;
changed:;
        }

        // Figure out the dimensions of the Icon rectangle - assumes
        // each Icon rectangle is the same size.
        ListView_GetRects(plv, 0, &rcIcon, NULL, NULL, NULL);

        // Center the icon in the rectangle
        ImageList_GetIconSize(plv->himl, &cxIcon, &cyIcon);
        dxOffset = (rcIcon.right - rcIcon.left - cxIcon) / 2;
        dyOffset = (rcIcon.bottom - rcIcon.top - cyIcon) / 2;
        cxIcon = rcIcon.right - rcIcon.left;
        cyIcon = rcIcon.bottom - rcIcon.top;

        if (!(hdc = CreateCompatibleDC(NULL)) ||
            (!(hbmp = CreateBitmap(cxIcon, cyIcon, 1, 1, NULL)))) {
            goto BailOut;
        }

        GetObject(hbmp, SIZEOF(bm), &bm);

        if (!(lpBits = (BYTE *)GlobalAlloc(GPTR, bm.bmWidthBytes * bm.bmHeight)))
            goto BailOut;

        hbmpOld = SelectObject(hdc, hbmp);
        PatBlt(hdc, 0, 0, cxIcon, cyIcon, WHITENESS);

        if (hrgnUnion = CreateRectRgn(0, 0, 0, 0)) {
            for (i = 0; i < ListView_Count(plv); i++)
            {
                int x, y, iResult;
                BOOL fStarted = FALSE;
                LPRECT lprc;

                pitem = ListView_FastGetItemPtr(plv, i);

                if (pitem->pt.y == RECOMPUTE)
                    continue;

                if (!ListView_IsItemVisible(plv, i))
                {
                    // ignore invisible items
                    if (pitem->hrgnIcon && pitem->hrgnIcon!=(HANDLE)-1)
                    {
                        pitem->ptRgn.x = RECOMPUTE;
                        pitem->ptRgn.y = RECOMPUTE;
                        DeleteObject(pitem->hrgnIcon);
                        pitem->hrgnIcon = (HANDLE)-1;
                    }
                    continue;
                }

                // Add the region for the icon text first
                ListView_GetRects(plv, i, &rcIcon, &rc, NULL, NULL);

                // If we're in edit mode always use rcTextRgn
                if (i == plv->iEdit)
                    lprc = &pitem->rcTextRgn;
                else
                    lprc = &rc;

                if (!(hrgn = CreateRectRgnIndirect(lprc)))
                    goto Error;

                iResult = CombineRgn(hrgnUnion, hrgn, hrgnUnion, RGN_OR);

                DeleteObject(hrgn);

                if (iResult == ERROR) {
                    // Error case - out of memory.  Just select in a NULL region.
Error:
                    DeleteObject(hrgnUnion);
                    hrgnUnion = NULL;
                    break;
                }

                // Succeeded, copy the rectangle to rcTextRgn so we
                // can test against it in the future.  Don't copy over
                // it if we are in edit mode, the rectangle is used to
                // store the edit window in that case.
                if (plv->iEdit != i)
                    CopyRect(&pitem->rcTextRgn, (CONST RECT *)&rc);

                // Now create a region for the icon mask - or use the cached one
                if (!pitem->hrgnIcon || pitem->hrgnIcon == (HANDLE)-1) {
//                    (pitem->pt.x != pitem->ptRgn.x) ||
//                    (pitem->pt.y != pitem->ptRgn.y)) {
                    HRGN hrgnIcon = NULL;

                    // On slow machines, we'll just wrap the icon with a rectangle.  But on
                    // faster machines, we'll build a region that corresponds to the
                    // mask for the icon so it looks sweet.
                    if (g_fSlowMachine) {
                        // Modify the rectangle slightly so it looks better

                        // Glue the icon and text rectangles together
                        rcIcon.bottom = rc.top;
                        // Shrink the width of the rectangle so it's only as big as the icon itself
                        InflateRect(&rcIcon, -dxOffset, 0);
                        hrgnIcon = CreateRectRgnIndirect(&rcIcon);
                    } else {
                        // If the image isn't around, get it now.
                        if (pitem->iImage == I_IMAGECALLBACK) {
                            LV_ITEM item;

                            item.iItem = i;
                            item.iSubItem = 0;
                            item.mask = LVIF_IMAGE;
                            item.stateMask = LVIS_ALL;
                            item.pszText = NULL;
                            item.cchTextMax = 0;
                            // BOGUS - do we need to worry about our state
                            // getting messed up during the callback?
                            ListView_OnGetItem(plv, &item);
                        }

                        ImageList_Draw(plv->himl, pitem->iImage, hdc, 0, 0, ILD_MASK | (pitem->state & LVIS_OVERLAYMASK));

                        GetBitmapBits(hbmp, bm.bmWidthBytes * bm.bmHeight, (LPVOID)lpBits);

                        for (y = 0; y < cyIcon; y++) {
                            for (x = 0; x < cxIcon; x++) {
                                if (!fStarted && !BitOn(lpBits, x, y, bm.bmWidthBytes)) {
                                    rc.left = x;
                                    rc.top = y;
                                    rc.bottom = y + 1;
                                    fStarted = TRUE;
                                    if (x == (cxIcon - 1)) {
                                        x++;
                                        goto AddIt;
                                    } else {
                                        continue;
                                    }
                                }

                                if (fStarted && BitOn(lpBits, x, y, bm.bmWidthBytes)) {
AddIt:
                                    rc.right = x;
                                    //
                                    // Mirror the region so that the icons get displayed ok. [samera]
                                    //
                                    if (plv->ci.dwExStyle & RTL_MIRRORED_WINDOW)
                                    {
                                        int iLeft = rc.left;
                                        rc.left = (cxIcon - (rc.right+1));
                                        rc.right = (cxIcon - (iLeft+1));
                                        OffsetRect(&rc, rcIcon.left - dxOffset, rcIcon.top + dyOffset);
                                    }
                                    else
                                        OffsetRect(&rc, rcIcon.left + dxOffset, rcIcon.top + dyOffset);


                                    if (hrgn = CreateRectRgnIndirect(&rc)) {
                                        if (hrgnIcon || (hrgnIcon = CreateRectRgn(0, 0, 0, 0)))
                                            iResult = CombineRgn(hrgnIcon, hrgn, hrgnIcon, RGN_OR);
                                        else
                                            iResult = ERROR;

                                        DeleteObject(hrgn);
                                    }

                                    if (!hrgn || (iResult == ERROR)) {
                                        if (hrgnIcon)
                                            DeleteObject(hrgnIcon);
                                        goto Error;
                                    }

                                    fStarted = FALSE;
                                }
                            }
                        }
                    }

                    if (hrgnIcon) {
                        // Cache it since it takes a long time to build it
                        if (pitem->hrgnIcon && pitem->hrgnIcon != (HANDLE)-1)
                            DeleteObject(pitem->hrgnIcon);
                        pitem->hrgnIcon = hrgnIcon;
                        pitem->ptRgn = pitem->pt;

                        // Add it to the accumulated window region
                        if (ERROR == CombineRgn(hrgnUnion, hrgnIcon, hrgnUnion, RGN_OR))
                            goto Error;
                    }
                } else {
                    OffsetRgn(pitem->hrgnIcon, pitem->pt.x - pitem->ptRgn.x, pitem->pt.y - pitem->ptRgn.y);
                    pitem->ptRgn = pitem->pt;
                    if (ERROR == CombineRgn(hrgnUnion, pitem->hrgnIcon, hrgnUnion, RGN_OR))
                        goto Error;
                }
            }
        }
    }

BailOut:
    if (lpBits)
        GlobalFree((HGLOBAL)lpBits);
    if (hbmp) {
        SelectObject(hdc, hbmpOld);
        DeleteObject(hbmp);
    }
    if (hdc)
        DeleteDC(hdc);

    // Windows takes ownership of the region when we select it in to the window
    SetWindowRgn(plv->ci.hwnd, hrgnUnion, fRedraw);

exit:
    plv->flags &= ~LVF_INRECALCREGION;
}

HIMAGELIST CreateCheckBoxImagelist(HIMAGELIST himl, BOOL fTree, BOOL fUseColorKey, BOOL fMirror)
{
    int cxImage, cyImage;
    HBITMAP hbm;
    HBITMAP hbmTemp;
    COLORREF clrMask;
    HDC hdcDesk = GetDC(NULL);
    HDC hdc;
    RECT rc;
    int nImages = fTree ? 3 : 2;

    if (!hdcDesk)
        return NULL;

    hdc = CreateCompatibleDC(hdcDesk);
    ReleaseDC(NULL, hdcDesk);

    if (!hdc)
        return NULL;

    // Must protect against ImageList_GetIconSize failing in case app
    // gave us a bad himl
    if (himl && ImageList_GetIconSize(himl, &cxImage, &cyImage)) {
        // cxImage and cyImage are okay
    } else {
        cxImage = g_cxSmIcon;
        cyImage = g_cySmIcon;
    }

    himl = ImageList_Create(cxImage, cyImage, ILC_MASK, 0, nImages);
    hbm = CreateColorBitmap(cxImage * nImages, cyImage);

    if (fUseColorKey)
    {
        clrMask = RGB(255,000,255); // magenta
        if (clrMask == g_clrWindow)
            clrMask = RGB(000,000,255); // blue
    }
    else
    {
        clrMask = g_clrWindow;
    }

    // fill
    hbmTemp = SelectObject(hdc, hbm);

    rc.left = rc.top = 0;
    rc.bottom = cyImage;
    rc.right = cxImage * nImages;
    FillRectClr(hdc, &rc, clrMask);

    rc.right = cxImage;
    // now draw the real controls on
    InflateRect(&rc, -g_cxEdge, -g_cyEdge);
    rc.right++;
    rc.bottom++;

    if (fTree)
        OffsetRect(&rc, cxImage, 0);

    DrawFrameControl(hdc, &rc, DFC_BUTTON, DFCS_BUTTONCHECK | DFCS_FLAT | 
        (fUseColorKey? 0 : DFCS_TRANSPARENT));
    OffsetRect(&rc, cxImage, 0);
    // [msadek]; For the mirrored case, there is an off-by-one somewhere in MirrorIcon() or System API.
    // Since I will not be touching MirrorIcon() by any mean and no chance to fix a system API,
    // let's compensate for it here.
    if(fMirror)
    {
        OffsetRect(&rc, -1, 0);  
    }

    DrawFrameControl(hdc, &rc, DFC_BUTTON, DFCS_BUTTONCHECK | DFCS_FLAT | DFCS_CHECKED | 
        (fUseColorKey? 0 : DFCS_TRANSPARENT));

    SelectObject(hdc, hbmTemp);

    if (fUseColorKey)
    {
        ImageList_AddMasked(himl, hbm, clrMask);
    }
    else
    {
        ImageList_Add(himl, hbm, NULL);
    }

    if(fMirror)
    {
        HICON hIcon = ImageList_ExtractIcon(0, himl, nImages-1);
        MirrorIcon(&hIcon, NULL);
        ImageList_ReplaceIcon(himl, nImages-1, hIcon);
    }

    DeleteDC(hdc);
    DeleteObject( hbm );
    return himl;
}

void ListView_InitCheckBoxes(LV* plv, BOOL fInitializeState)
{
    HIMAGELIST himlCopy = (plv->himlSmall ? plv->himlSmall : plv->himl);
    HIMAGELIST himl;
    BOOL fNoColorKey = FALSE;    // Backwards: If Cleartype is turned on, then we don't use colorkey.
    BOOL bMirror = FALSE;
    if (g_bRunOnNT5)
    {
#ifdef CLEARTYPE    // Don't use SPI_CLEARTYPE because it's defined because of APIThk, but not in NT.
        SystemParametersInfo(SPI_GETCLEARTYPE, 0, &fNoColorKey, 0);
#endif
    }

    // [msadek], CheckBoxed need not to be mirrored.
    // mirroer it during imagelist creation time so that it displays correctly
    
    himl = CreateCheckBoxImagelist(himlCopy, FALSE, !fNoColorKey, IS_WINDOW_RTL_MIRRORED(plv->ci.hwnd));
    ImageList_SetBkColor(himl, fNoColorKey ? (CLR_NONE) : (plv->clrBk));
    ListView_OnSetImageList(plv, himl, LVSIL_STATE);

    if (fInitializeState)
        ListView_OnSetItemState(plv, -1, INDEXTOSTATEIMAGEMASK(1), LVIS_STATEIMAGEMASK);
}

void ListView_PopBubble(LV *plv)
{
    if (plv->hwndToolTips)
        SendMessage( plv->hwndToolTips, TTM_POP, 0, 0 );
}

DWORD NEAR PASCAL ListView_ExtendedStyleChange(LV* plv, DWORD dwNewStyle, DWORD dwExMask)
{
    DWORD dwOldStyle = plv->exStyle;

    // this messge didn't come till 3, so version is at least 3
    if (plv->ci.iVersion < 3) {
        plv->ci.iVersion = 3;
        // this will change the listview report size and painting algorithm
        // because of the leading edge, so need to re-update scroll bars
        // and repaint everything
        if (ListView_IsReportView(plv))
        {
            ListView_RUpdateScrollBars(plv);
            InvalidateRect(plv->ci.hwnd, NULL, TRUE);
        }
    }

    // Change of styles may also changes tooltip policy, so pop it
    ListView_PopBubble(plv);

    if (dwExMask)
        dwNewStyle = (plv->exStyle & ~ dwExMask) | (dwNewStyle & dwExMask);

    // Currently, the LVS_EX_REGIONAL style is only supported for large icon view
    if (!ListView_IsIconView(plv)) {
        dwNewStyle &= ~(LVS_EX_REGIONAL | LVS_EX_MULTIWORKAREAS);
    }

    // LVS_EX_REGIONAL is not supported for ownerdata
    if (ListView_IsOwnerData(plv)) {
        dwNewStyle &= ~LVS_EX_REGIONAL;
    }

    plv->exStyle = dwNewStyle;

    // do any invalidation or whatever is needed here.
    if ((dwOldStyle ^ dwNewStyle) & LVS_EX_GRIDLINES) {
        if (ListView_IsReportView(plv)) {
            InvalidateRect(plv->ci.hwnd, NULL, TRUE);
        }
    }

    if ((dwOldStyle ^ dwNewStyle) & (LVS_EX_UNDERLINEHOT | LVS_EX_UNDERLINECOLD |
                                     LVS_EX_ONECLICKACTIVATE | LVS_EX_TWOCLICKACTIVATE |
                                     LVS_EX_SUBITEMIMAGES)) {
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
    }

    if ((dwOldStyle ^ dwNewStyle) & LVS_EX_CHECKBOXES) {
        if (dwNewStyle & LVS_EX_CHECKBOXES) {
            ListView_InitCheckBoxes(plv, TRUE);
        } else {
            // destroy the check boxes!
            HIMAGELIST himl = ListView_OnSetImageList(plv, NULL, LVSIL_STATE);
            if (himl)
                ImageList_Destroy(himl);
        }
    }

    if ((dwOldStyle ^ dwNewStyle) & LVS_EX_FLATSB) {
        if (dwNewStyle & LVS_EX_FLATSB) {
            InitializeFlatSB(plv->ci.hwnd);
        } else {
            UninitializeFlatSB(plv->ci.hwnd);
        }
    }

    if ((dwOldStyle ^ dwNewStyle) & LVS_EX_REGIONAL) {
        if (g_fSlowMachine == -1) {
#ifdef NEVER
            // Because some Alpha machines and faster pentiums were detected
            // as slow machines (bug #30972 in IE4 database), it was decided
            // to turn off this code.
            SYSTEM_INFO si;
            GetSystemInfo(&si);
            g_fSlowMachine = (BOOL)((si.dwProcessorType == PROCESSOR_INTEL_386) ||
                                      (si.dwProcessorType == PROCESSOR_INTEL_486));
#else
            g_fSlowMachine = FALSE;
#endif
        }
        if (dwNewStyle & LVS_EX_REGIONAL) {
            ListView_RecalcRegion(plv, TRUE, TRUE);
        } else {
            int i;
            LISTITEM FAR * pitem;

            // Delete all the cached regions, then NULL out our selected region.
            for (i = 0; i < ListView_Count(plv); i++) {
                pitem = ListView_FastGetItemPtr(plv, i);
                if (pitem->hrgnIcon && pitem->hrgnIcon!=(HANDLE)-1) {
                    DeleteObject(pitem->hrgnIcon);
                }
                pitem->hrgnIcon = NULL;
            }
            SetWindowRgn(plv->ci.hwnd, (HRGN)NULL, TRUE);
        }
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
    }

    return dwOldStyle;
}

// BUGBUG raymondc v6.0:  Doesn't detect WM_WINDOWPOSCHANGING as a way
// of being shown.  NT5 defview has to hack around it pretty grossly.
// Fix for v6.0.

void NEAR PASCAL LV_OnShowWindow(LV* plv, BOOL fShow)
{
    if (fShow) {
        if (!(plv->flags & LVF_VISIBLE)) {
            plv->flags |= LVF_VISIBLE;
            ListView_UpdateScrollBars(plv);
        }
    } else
        plv->flags &= ~LVF_VISIBLE;

}

LRESULT NEAR PASCAL ListView_OnHelp(LV* plv, LPHELPINFO lpHelpInfo)
{

    //  If we're seeing WM_HELP because of our child header control, then
    //  munge the HELPINFO structure to use the ListView's control id.
    //  win\core\user\combo.c has similiar code to handle the child edit
    //  control of a combo box.
    if ((lpHelpInfo != NULL) && ((plv->ci.style & LVS_TYPEMASK) == LVS_REPORT) &&
        (lpHelpInfo->iCtrlId == LVID_HEADER)) {

        lpHelpInfo->hItemHandle = plv->ci.hwnd;
        lpHelpInfo->iCtrlId = GetWindowID(plv->ci.hwnd);
        //  Shouldn't have to do this: USER would have filled in the appropriate
        //  context id by walking up the parent hwnd chain.
        //lpHelpInfo->dwContextId = GetContextHelpId(hwnd);

    }

    return DefWindowProc(plv->ci.hwnd, WM_HELP, 0, (LPARAM)lpHelpInfo);

}

DWORD NEAR PASCAL ListView_OnSetIconSpacing(LV* plv, LPARAM lParam)
{
    DWORD dwOld = MAKELONG(plv->cxIconSpacing, plv->cyIconSpacing);

    if (lParam == (LPARAM)-1) {
        // go back to using defaults
        plv->flags &= ~LVF_ICONSPACESET;
        plv->cxIconSpacing = (plv->cxIcon + (g_cxIconSpacing - g_cxIcon));
        plv->cyIconSpacing = (plv->cyIcon + (g_cyIconSpacing - g_cyIcon));
    } else {
        if (LOWORD(lParam))
            plv->cxIconSpacing = LOWORD(lParam);
        if (HIWORD(lParam))
            plv->cyIconSpacing = HIWORD(lParam);

        plv->flags |= LVF_ICONSPACESET;
    }
    plv->iFreeSlot = -1;

    return dwOld;
}

BOOL ListView_OnSetCursorMsg(LV* plv)
{
    if (plv->exStyle & (LVS_EX_ONECLICKACTIVATE|LVS_EX_TWOCLICKACTIVATE)) {
        if (plv->iHot != -1) {
            if (((plv->exStyle & LVS_EX_ONECLICKACTIVATE && plv->fOneClickOK)) ||
                ListView_OnGetItemState(plv, plv->iHot, LVIS_SELECTED)) {
                if (!plv->hCurHot)
                    plv->hCurHot = LoadHandCursor(0);
                SetCursor(plv->hCurHot);

                return TRUE;
            }
        }
    }

    return FALSE;
}

void ListView_OnSetHotItem(LV* plv, int iItem)
{
    UINT maskChanged;

    if (iItem != plv->iHot) {
        BOOL fSelectOnly;
        UINT fRedraw = RDW_INVALIDATE;
#ifndef DONT_UNDERLINE
        if (plv->clrTextBk == CLR_NONE)
            fRedraw |= RDW_ERASE;
#endif
        fSelectOnly = ListView_FullRowSelect(plv);
        maskChanged = (plv->exStyle & LVS_EX_BORDERSELECT) ? LVIF_TEXT | LVIF_IMAGE : LVIF_TEXT;
        ListView_InvalidateItemEx(plv, plv->iHot, fSelectOnly, fRedraw, maskChanged);
        ListView_InvalidateItemEx(plv, iItem, fSelectOnly, RDW_INVALIDATE, maskChanged);
        plv->iHot = iItem;
    }
}


/// Usability test prototype
// CHEEBUGBUG
BOOL fShouldFirstClickActivate()
{
    static BOOL fInited = FALSE;
    static BOOL fActivate = TRUE;
    if (!fInited) {
        long cb = 0;
        if (RegQueryValue(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\NoFirstClickActivate"),
                      NULL, &cb) == ERROR_SUCCESS)
            fActivate = FALSE;
        fInited = TRUE;
    }
    return fActivate;
}

BOOL ChildOfDesktop(HWND hwnd)
{
    return IsChild(GetShellWindow(), hwnd);
}


void ListView_OnMouseMove(LV* plv, int x, int y, UINT uFlags)
{
    if (plv->exStyle & (LVS_EX_TRACKSELECT|LVS_EX_ONECLICKACTIVATE|LVS_EX_TWOCLICKACTIVATE)

        // CHEEBUGBUG: for usability testing
        && (ChildOfActiveWindow(plv->ci.hwnd) || fShouldFirstClickActivate() ||
              ChildOfDesktop(plv->ci.hwnd))

       ) {
        int iItem;
        LV_HITTESTINFO ht;
        NMLISTVIEW nm;

        ht.pt.x = x;
        ht.pt.y = y;
        iItem = ListView_OnSubItemHitTest(plv, &ht);
        if (ht.iSubItem != 0) {
            // if we're not in full row select,
            // hitting on a subitem is like hitting on nowhere
            // also, in win95, ownerdraw fixed effectively had full row select
            if (!ListView_FullRowSelect(plv) &&
                !(plv->ci.style & LVS_OWNERDRAWFIXED)) {
                iItem = -1;
                ht.flags = LVHT_NOWHERE;
            }
        }

        if (ht.flags & LVHT_NOWHERE ||
           ht.flags & LVHT_ONITEMSTATEICON) {
            iItem = -1; // this is possible in the list mode
        }

        nm.iItem = iItem;
        nm.iSubItem = ht.iSubItem;
        nm.uChanged = 0;
        nm.ptAction.x = x;
        nm.ptAction.y = y;

        if (!CCSendNotify(&plv->ci, LVN_HOTTRACK, &nm.hdr)) {

#ifdef DEBUG
            if ((nm.iItem != -1) && nm.iSubItem != 0)
                nm.iItem = -1;
#endif

            ListView_OnSetHotItem(plv, nm.iItem);
            // Ensure our cursor is correct now since the WM_SETCURSOR
            // message was already generated for this mouse event.
            ListView_OnSetCursorMsg(plv);

            // this lets us know when we've left an item
            // and can then reselect/toggle it on hover events
            if (iItem != plv->iNoHover) {
                plv->iNoHover = -1;
            }
        }
    }
}

BOOL EditBoxHasFocus()
{
    HWND hwndFocus = GetFocus();

    if (hwndFocus) {
        if (SendMessage(hwndFocus, WM_GETDLGCODE, 0, 0) & DLGC_HASSETSEL)
            return TRUE;
    }

    return FALSE;
}

void ListView_OnMouseHover(LV* plv, int x, int y, UINT uFlags)
{
    int iItem;
    BOOL bSelected;
    LV_HITTESTINFO ht;
    BOOL fControl;
    BOOL fShift;
    BOOL fNotifyReturn = FALSE;

    if (GetCapture() || !ChildOfActiveWindow(plv->ci.hwnd) ||
       EditBoxHasFocus())
        return;  // ignore hover while editing or any captured (d/d) operation

    if (CCSendNotify(&plv->ci, NM_HOVER, NULL)) {
        return;
    }

    // REVIEW: right button implies no shift or control stuff
    // Single selection style also implies no modifiers
    //if (RIGHTBUTTON(keyFlags) || (plv->ci.style & LVS_SINGLESEL))
    if ((plv->ci.style & LVS_SINGLESEL)) {
        fControl = FALSE;
        fShift = FALSE;
    } else {
        fControl = GetAsyncKeyState(VK_CONTROL) < 0;
        fShift = GetAsyncKeyState(VK_SHIFT) < 0;
    }

    ht.pt.x = x;
    ht.pt.y = y;
    iItem = ListView_OnHitTest(plv, &ht);

    if (iItem == -1 ||
        iItem == plv->iNoHover)
        return;

    //before we hover select we launch any pending item
    //this prevents clicking on one item and hover selecting other before
    //the timer goes off which result in wrong item being launched
    if (plv->exStyle & LVS_EX_ONECLICKACTIVATE && plv->fOneClickHappened && plv->fOneClickOK)
    {
        HWND hwnd = plv->ci.hwnd;

        KillTimer(plv->ci.hwnd, IDT_ONECLICKHAPPENED);
        plv->fOneClickHappened = FALSE;
        CCSendNotify(&plv->ci, LVN_ITEMACTIVATE, &(plv->nmOneClickHappened.hdr));
        if (!IsWindow(hwnd))
            return;
    }

    plv->iNoHover = iItem;
    bSelected = ListView_OnGetItemState(plv, iItem, LVIS_SELECTED);

    if (ht.flags & (LVHT_ONITEMLABEL | LVHT_ONITEMICON))
    {
        UINT keyFlags = 0;

        if (fShift)
            keyFlags |= MK_SHIFT;
        if (fControl)
            keyFlags |= MK_CONTROL;

        if (!bSelected) {
            // if it wasn't selected, we're about to select it... play
            // a little ditty for us...
            CCPlaySound(c_szSelect);
        }

        ListView_ButtonSelect(plv, iItem, keyFlags, bSelected);

        if (fControl)
        {
            ListView_SetFocusSel(plv, iItem, !fShift, FALSE, !fShift);
        }

        if (!fShift)
            plv->iMark = iItem;

        ListView_OnSetCursorMsg(plv);

        SetFocus(plv->ci.hwnd);    // activate this window

    }
}

BOOL EqualRects(LPRECT prcNew, LPRECT prcOld, int nRects)
{
    int i;
    for (i = 0; i < nRects; i++)
        if (!EqualRect(&prcNew[i], &prcOld[i]))
            return FALSE;
    return TRUE;
}

BOOL ListView_FindWorkArea(LV * plv, POINT pt, short * piWorkArea)
{
    int iWork;
    for (iWork = 0; iWork < plv->nWorkAreas; iWork++)
    {
        if (PtInRect(&plv->prcWorkAreas[iWork], pt))
        {
            *piWorkArea = (short)iWork;
            return TRUE;
        }
    }

    // (dli) default case is the primary work area
    *piWorkArea = 0;
    return FALSE;
}

void ListView_BullyIconsOnWorkarea(LV * plv, HDPA hdpaLostItems)
{
    int ihdpa;
    int iFree = -1;  // the last free slot number
    LVFAKEDRAW lvfd;
    LV_ITEM item;

    // Caller should've filtered this case out
    ASSERT(DPA_GetPtrCount(hdpaLostItems) > 0);

    // Set up in case caller is customdraw
    ListView_BeginFakeCustomDraw(plv, &lvfd, &item);
    item.mask = LVIF_PARAM;
    item.iSubItem = 0;

    // Go through my hdpa list of lost icons and try to place them within bound
    for (ihdpa = 0; ihdpa < DPA_GetPtrCount(hdpaLostItems); ihdpa++)
    {
        POINT ptNew, pt;
        RECT rcBound;
        int cxBound, cyBound;
        int iWidth, iHeight;
        int iItem;
        LISTITEM FAR * pitem;

        iItem = PtrToUlong(DPA_GetPtr(hdpaLostItems, ihdpa));
        pitem = ListView_FastGetItemPtr(plv, iItem);
        pt = pitem->pt;

        iWidth  = RECTWIDTH(plv->prcWorkAreas[pitem->iWorkArea]);
        iHeight = RECTHEIGHT(plv->prcWorkAreas[pitem->iWorkArea]);

        ListView_GetRects(plv, iItem, NULL, NULL, &rcBound, NULL);
        cxBound = RECTWIDTH(rcBound);
        cyBound = RECTHEIGHT(rcBound);

        pt.x -= plv->prcWorkAreas[pitem->iWorkArea].left;
        pt.y -= plv->prcWorkAreas[pitem->iWorkArea].top;

        if (pt.x < (-cxBound / 2)) {
            ptNew.x = 0;
        } else if (pt.x > (iWidth - (cxBound / 2))) {
            ptNew.x = iWidth - cxBound;
        } else
            ptNew.x = pt.x;

        if (pt.y < (-cyBound/2)) {
            ptNew.y = 0;
        } else if (pt.y > (iHeight - (cyBound / 2))) {
            ptNew.y = iHeight - cyBound;
        } else
            ptNew.y = pt.y;

        if ((ptNew.x != pt.x) || (ptNew.y != pt.y))
        {
            BOOL fUpdate;
            RECT rcTest;
            ptNew.x += plv->prcWorkAreas[pitem->iWorkArea].left;
            ptNew.y += plv->prcWorkAreas[pitem->iWorkArea].top;

            // See if the potential rectangle intersects other items.
            rcTest.left = ptNew.x - plv->ptOrigin.x;
            rcTest.top = ptNew.y - plv->ptOrigin.y;
            rcTest.right = rcTest.left + cxBound;
            rcTest.bottom = rcTest.top + cyBound;

            item.iItem = iItem;
            item.lParam = pitem->lParam;
            ListView_BeginFakeItemDraw(&lvfd);

            if (!ListView_IsCleanRect(plv, &rcTest, iItem, &fUpdate, lvfd.nmcd.nmcd.hdc))
            {
                // doh! We hit another item, let's try to find an available location
                // for this item
                BOOL fUpdateSB;
                BOOL fAppendAtEnd = FALSE;
                int cSlots = ListView_GetSlotCountEx(plv, FALSE, pitem->iWorkArea);
                iFree = ListView_FindFreeSlot(plv, iItem, iFree + 1, cSlots, &fUpdateSB, &fAppendAtEnd, lvfd.nmcd.nmcd.hdc);
                if (iFree == -1)
                    goto SetFirstGuess;
                ListView_SetIconPos(plv, pitem, iFree, cSlots);
                ListView_EndFakeItemDraw(&lvfd);
                continue;
            }
SetFirstGuess:
            ListView_EndFakeItemDraw(&lvfd);
            ListView_OnSetItemPosition(plv, iItem, ptNew.x, ptNew.y);
        }
    }
    ListView_EndFakeCustomDraw(&lvfd);
}

#define DPA_LAST    0x7fffffff

//
// ListView_OnSetWorkAreas
//
// set the "work areas" for the list view.
// the "work areas" are a group of sub rectanges of the list view client rect
// where icons are aranged, and parked by default.
//
void NEAR ListView_OnSetWorkAreas(LV* plv, int nWorkAreas, LPRECT prc)
{
    int nOldWorkAreas;
    int iWork;
    BOOL bAutoArrange;
    HDPA hdpaLostItems = NULL;
    RECT rcOldWorkAreas[LV_MAX_WORKAREAS];

    bAutoArrange = plv->ci.style & LVS_AUTOARRANGE;

    nOldWorkAreas = plv->nWorkAreas;

    if (nOldWorkAreas > 0)
    {
        ASSERT(plv->prcWorkAreas != NULL);
        hmemcpy(&rcOldWorkAreas[0], &plv->prcWorkAreas[0], SIZEOF(RECT) * nOldWorkAreas);
    }
    // for the mirrored case, the coordinates are reversed. IsRectEmpty() will always succeed
    if (nWorkAreas == 0 || prc == NULL || ((IsRectEmpty(prc)) && !(plv->ci.dwExStyle & RTL_MIRRORED_WINDOW)))
        plv->nWorkAreas = 0;
    else
    {
        plv->nWorkAreas = min(nWorkAreas, LV_MAX_WORKAREAS);

        if (plv->prcWorkAreas == NULL)
            plv->prcWorkAreas = (LPRECT)LocalAlloc(LPTR, SIZEOF(RECT) * LV_MAX_WORKAREAS);

        if (plv->prcWorkAreas == NULL)
            return;

        //BUGBUG: Should we check if they intersect? This problem is sort of
        // solved (or made more confusing) by ListView_GetFreeSlot since it checks all of the icons for
        // intersection instead of just the ones in the workarea.
        for (iWork = 0; iWork < plv->nWorkAreas; iWork++)
            CopyRect(&plv->prcWorkAreas[iWork], &prc[iWork]);
    }

    // We don't support workareas for owner-data because our icon placement
    // algorithm (ListView_IGetRectsOwnerData) completely ignores workareas
    // and just dumps the icons in a rectangular array starting at (0,0).
    if (!ListView_IsOwnerData(plv) &&
        plv->nWorkAreas > 0 &&
        ((plv->nWorkAreas  != nOldWorkAreas) ||
         (!EqualRects(&plv->prcWorkAreas[0], &rcOldWorkAreas[0], nOldWorkAreas))))
    {
        int iItem;
        LISTITEM FAR * pitem;

        //
        //  Subtle - ListView_Recompute cleans up all the RECOMPUTE icons,
        //  but in order to do that, it needs to have valid work area
        //  rectangles. So the call must happen after the CopyRect but before
        //  the loop that checks the icon positions.
        //
        ListView_Recompute(plv);

        for (iItem = 0; iItem < ListView_Count(plv); iItem++)
        {
            pitem = ListView_FastGetItemPtr(plv, iItem);

            if (pitem->pt.x == RECOMPUTE || pitem->pt.y == RECOMPUTE)
            {
                // ListView_Recompute should've fixed these if we were in
                // an iconical view.
                ASSERT(!(ListView_IsIconView(plv) || ListView_IsSmallView(plv)));
                continue;
            }

            // Try to move me to the same location relative to the same workarea.
            // This will give the cool shift effect when tools bars take the border areas.
            // And we only want to do this for the workareas that changed

            // Don't bully the icons on the workareas, Autoarrange will do the work for us

            if (nOldWorkAreas > 0)
            {
                int iOldWorkArea;
                iOldWorkArea = pitem->iWorkArea;
                if (iOldWorkArea >= plv->nWorkAreas)
                {
                    // My workarea is gone, put me on the primary workarea i.e. #0
                    pitem->iWorkArea = 0;
                    if (!bAutoArrange)
                    {
                        // If this item point location is already in the new primary workarea,
                        // move it out, and let ListView_BullyIconsOnWorkarea arrange it to the
                        // right place. NOTE: this could happen in the case the old secondary monitor
                        // is to the left of the old primary monitor, and user kills the secondary monitor
                        if (PtInRect(&plv->prcWorkAreas[0], pitem->pt))
                        {
                            pitem->pt.x = plv->prcWorkAreas[0].right + 1;
                            plv->iFreeSlot = -1; // an item moved -- old slot info is invalid
                        }
                        goto  InsertLostItemsArray;
                    }
                }
                else if ((!bAutoArrange) && (!EqualRect(&plv->prcWorkAreas[iOldWorkArea], &rcOldWorkAreas[iOldWorkArea])))
                {
                    RECT rcBound;
                    POINT ptCenter;
                    pitem->pt.x += plv->prcWorkAreas[iOldWorkArea].left - rcOldWorkAreas[iOldWorkArea].left;
                    pitem->pt.y += plv->prcWorkAreas[iOldWorkArea].top - rcOldWorkAreas[iOldWorkArea].top;

                    // Use the center of this icon to determine whether it's out of bound
                    ListView_GetRects(plv, iItem, NULL, NULL, &rcBound, NULL);
                    ptCenter.x = pitem->pt.x + RECTWIDTH(rcBound) / 2;
                    ptCenter.y = pitem->pt.y + RECTHEIGHT(rcBound) / 2;

                    // If this shifted me out of bounds, register to be bullied on the workarea
                    if (!PtInRect(&plv->prcWorkAreas[iOldWorkArea], ptCenter))
                    {
InsertLostItemsArray:
                        if (!hdpaLostItems)
                        {
                            hdpaLostItems = DPA_Create(4);
                            if (!hdpaLostItems)
                                // we ran out of memory
                                ASSERT(0);
                        }

                        if (hdpaLostItems)
                            DPA_InsertPtr(hdpaLostItems, DPA_LAST, IntToPtr(iItem));
                    }
                }

            }
            else
            {
                // My first time in a multi-workarea system, so find out my workarea
                if (!ListView_FindWorkArea(plv, pitem->pt, &(pitem->iWorkArea)) && !bAutoArrange)
                    goto InsertLostItemsArray;
            }

            if ((plv->exStyle & LVS_EX_REGIONAL) && (pitem->hrgnIcon))
            {
                if (pitem->hrgnIcon != (HANDLE)-1)
                    DeleteObject(pitem->hrgnIcon);
                pitem->hrgnIcon = NULL;
            }
        }

        if (hdpaLostItems)
        {
            ASSERT(!bAutoArrange);
            if (DPA_GetPtrCount(hdpaLostItems) > 0)
                ListView_BullyIconsOnWorkarea(plv, hdpaLostItems);

            DPA_Destroy(hdpaLostItems);
        }

        if (plv->exStyle & LVS_EX_REGIONAL)
            ListView_RecalcRegion(plv, TRUE, TRUE);

        if ((plv->ci.style & LVS_AUTOARRANGE) &&
            (ListView_IsSmallView(plv) || ListView_IsIconView(plv)))
            ListView_OnArrange(plv, LVA_DEFAULT);
    }

    RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
}

void NEAR ListView_OnGetNumberOfWorkAreas(LV* plv, int * pnWorkAreas)
{
    if (pnWorkAreas)
        *pnWorkAreas = plv->nWorkAreas;
}

void NEAR ListView_OnGetWorkAreas(LV* plv, int nWorkAreas, LPRECT prc)
{
    int i;
    ASSERT(prc);
    for (i = 0; i < min(plv->nWorkAreas, nWorkAreas); i++)
    {
        if (i < plv->nWorkAreas)
            CopyRect(&prc[i], &plv->prcWorkAreas[i]);
        else
            // Set the workareas to all zeros if we don't have it.
            ZeroMemory(&prc[i], sizeof(RECT));
    }
}

// test an item to see if it is unfolded (because it is focused)

BOOL ListView_IsItemUnfolded(LV *plv, int item)
{
    return plv && (item >= 0) && ListView_IsIconView(plv) &&
           (plv->flags & LVF_UNFOLDED) && (plv->iFocus == item);
}

BOOL ListView_IsItemUnfoldedPtr(LV *plv, LISTITEM *pitem)
{
    return plv && pitem && ListView_IsIconView(plv) &&
           (plv->flags & LVF_UNFOLDED) && (pitem->state & LVIS_FOCUSED);
}

// Returns TRUE if unfolding the item will be worthwhile
BOOL ListView_GetUnfoldedRect(LV* plv, int iItem, RECT *prc)
{
    ListView_GetRects(plv, iItem, NULL, prc, NULL, NULL);
    return ListView_UnfoldRects(plv, iItem, NULL, prc, NULL, NULL);
}

LRESULT ListView_OnNotify(LV* plv, WPARAM wParam, LPNMHDR pnmh)
{
    // we can't switch on the control ID because the tooltip is a WS_POPUP window
    // and does not have a control ID. (header and tooltip both have 0 as ID)

    if (plv->hwndHdr && (plv->hwndHdr == pnmh->hwndFrom))
    {
        // this is a notify for the header, deal with it as needed

        return ListView_HeaderNotify(plv, (HD_NOTIFY *)pnmh);
    }
    else if (plv->hwndToolTips && (plv->hwndToolTips == pnmh->hwndFrom))
    {
        // implement unfolding the text for items as well as info tip support

        switch (pnmh->code)
        {
        case TTN_NEEDTEXT:
        {
            POINT pt;
            UINT uFlags;
            int iNewHit;
            int iNewSubHit;
            NMTTDISPINFO *pttt = (NMTTDISPINFO *)pnmh;

            GetMessagePosClient(plv->ci.hwnd, &pt);
            iNewHit = _ListView_ItemHitTest(plv, pt.x, pt.y, &uFlags, &iNewSubHit);

            if (iNewHit != plv->iTTLastHit || iNewSubHit != plv->iTTLastSubHit)
            {
                plv->fPlaceTooltip = FALSE;     // Set it to TRUE only if Unfolding tip is set
                Str_Set(&plv->pszTip, NULL);    // clear the old tip

                plv->iTTLastHit = iNewHit;
                plv->iTTLastSubHit = iNewSubHit;

                if ((iNewHit >= 0) && (plv->iEdit == -1))
                {
                    TCHAR szBuf[INFOTIPSIZE], szBuf2[INFOTIPSIZE];
                    BOOL bItemUnfolded;
                    BOOL fInfoTip = FALSE;
                    LPTSTR pszTip = szBuf;  // Use this one first

                    szBuf[0] = 0;
                    szBuf2[0] = 0;

                    // preload the tip text for folder items. this
                    // may be overridden by callback below
                    bItemUnfolded = ListView_IsItemUnfolded2(plv, plv->iTTLastHit, plv->iTTLastSubHit, szBuf, ARRAYSIZE(szBuf));
                    lstrcpyn(szBuf2, szBuf, ARRAYSIZE(szBuf2)); // Backup the unfolding text

                    if (ListView_IsInfoTip(plv) && iNewSubHit == 0)
                    {
                        NMLVGETINFOTIP git;

                        git.dwFlags = bItemUnfolded ? LVGIT_UNFOLDED : 0;
                        git.pszText = szBuf;
                        git.cchTextMax = ARRAYSIZE(szBuf);
                        git.iItem = plv->iTTLastHit;
                        git.iSubItem = 0;
                        git.lParam = 0;

                        // for folded items pszText is prepopulated with the
                        // item text, clients should append to this

                        CCSendNotify(&plv->ci, LVN_GETINFOTIP, &git.hdr);

                        // Sometimes defview gets confused and nulls out the
                        // buffer instead of leaving it alone (sigh)

                        if (szBuf[0] == TEXT('\0'))
                        {
                            pszTip = szBuf2;  // Use the original text
                        }
                        else if (lstrcmp(szBuf, szBuf2) != 0)
                        {
                            // App changed something - there is a real infotip
                            fInfoTip = TRUE;
                        }

                    }
                    
                    //
                    // Set the margins now before the TTN_SHOW because it will be too late then.
                    //
                    // We want fat margins if we're an infotip, thin margins if we're an
                    // in-place tooltip.
                    //
                    if (fInfoTip)
                    {
                        static const RECT rcMargin = {4, 4, 4, 4};
                        SendMessage(plv->hwndToolTips, TTM_SETMARGIN, 0, (LPARAM)&rcMargin);
                        CCSetInfoTipWidth(plv->ci.hwnd, plv->hwndToolTips);

                    }
                    else
                    {
                        static const RECT rcMargin = {0, 0, 0, 0};
                        plv->fPlaceTooltip = TRUE;
                        SendMessage(plv->hwndToolTips, TTM_SETMARGIN, 0, (LPARAM)&rcMargin);
                        CCResetInfoTipWidth(plv->ci.hwnd, plv->hwndToolTips);
                    }

                    Str_Set(&plv->pszTip, pszTip);
                }
            }

            pttt->lpszText = plv->pszTip;     // here it is...
        }
        break;

        // Handle custom draw as we want the tooltip painted as a multi-line that
        // matches the formatting used by the list view.

        case NM_CUSTOMDRAW:
        {
            LPNMTTCUSTOMDRAW pnm = (LPNMTTCUSTOMDRAW) pnmh;

            if (plv->fPlaceTooltip &&
                (pnm->nmcd.dwDrawStage == CDDS_PREPAINT ||
                 pnm->nmcd.dwDrawStage == CDDS_ITEMPREPAINT))
            {
                DWORD dwCustom = 0;

                //
                //  Set up the customdraw DC to match the font of the LV item.
                //
                if (plv->iTTLastHit != -1)
                {
                    LVFAKEDRAW lvfd;
                    LV_ITEM item;
                    ListView_BeginFakeCustomDraw(plv, &lvfd, &item);

                    item.iItem = plv->iTTLastHit;
                    item.iSubItem = plv->iTTLastSubHit;
                    item.mask = LVIF_PARAM;
                    ListView_OnGetItem(plv, &item);
                    dwCustom = ListView_BeginFakeItemDraw(&lvfd);

                    // If client changed the font, then transfer the font
                    // from our private hdc into the tooltip's HDC.  We use
                    // a private HDC because we only want to let the app change
                    // the font, not the colors or anything else.
                    if (dwCustom & CDRF_NEWFONT)
                    {
                        SelectObject(pnm->nmcd.hdc, GetCurrentObject(lvfd.nmcd.nmcd.hdc, OBJ_FONT));
                    }
                    ListView_EndFakeItemDraw(&lvfd);
                    ListView_EndFakeCustomDraw(&lvfd);

                }

                //
                //  The Large Icon tooltip needs to be drawn specially.
                //
                if (ListView_IsIconView(plv))
                {
                    pnm->uDrawFlags &= ~(DT_SINGLELINE|DT_LEFT);
                    pnm->uDrawFlags |= DT_CENTER|DT_LVWRAP;

                    if ( pnm->uDrawFlags & DT_CALCRECT )
                    {
                        pnm->nmcd.rc.right = pnm->nmcd.rc.left + (lv_cxIconSpacing - g_cxLabelMargin * 2);
                        pnm->nmcd.rc.bottom = pnm->nmcd.rc.top + 0x10000;           // big number, no limit!
                    }
                }

                // Don't return other wacky flags to TT, since all we
                // did was change the font (if even that)
                return dwCustom & CDRF_NEWFONT;
            }
        }
        break;

        case TTN_SHOW:
            if (plv->iTTLastHit != -1)
            {
                if (plv->fPlaceTooltip)
                {
                    LPNMTTSHOWINFO psi = (LPNMTTSHOWINFO)pnmh;
                    RECT rcLabel;

                    // In case we're doing subitem hit-testing
                    rcLabel.top = plv->iTTLastSubHit;
                    rcLabel.left = LVIR_LABEL;

                    // reposition to allign with the text rect and
                    // set it to topmost
                    if (plv->iTTLastSubHit && ListView_OnGetSubItemRect(plv, plv->iTTLastHit, &rcLabel)) {
                        LV_ITEM item;

                        // we got the subitem rect. When we draw subitems, we give
                        // them SHDT_EXTRAMARGIN, so we have to also
                        rcLabel.left += g_cxLabelMargin * 3;
                        rcLabel.right -= g_cxLabelMargin * 3;

                        // And take the image into account, too.
                        // ListView_OnGetItem will worry about LVS_EX_SUBITEMIMAGES.
                        item.mask = LVIF_IMAGE;
                        item.iImage = -1;
                        item.iItem = plv->iTTLastHit;
                        item.iSubItem = plv->iTTLastSubHit;
                        ListView_OnGetItem(plv, &item);
                        if (item.iImage != -1)
                            rcLabel.left += plv->cxSmIcon;
                    } else {                    // a tip from subitem zero
                        ListView_GetUnfoldedRect(plv, plv->iTTLastHit, &rcLabel);
                        // SHDrawText actually leaves a g_cxLabelMargin margin
                        rcLabel.left += g_cxLabelMargin;
                        rcLabel.right -= g_cxLabelMargin;
                    }

                    // In report and list views, SHDrawText does vertical
                    // centering (without consulting the custom-draw client,
                    // even, so it just centers by a random amount).
                    if (ListView_IsListView(plv) || ListView_IsReportView(plv))
                    {
                        rcLabel.top += (rcLabel.bottom - rcLabel.top - plv->cyLabelChar) / 2;
                    }

                    SendMessage(plv->hwndToolTips, TTM_ADJUSTRECT, TRUE, (LPARAM)&rcLabel);
                    MapWindowRect(plv->ci.hwnd, HWND_DESKTOP, &rcLabel);

                    if (!ListView_IsIconView(plv))
                    {
                        // In non-large-icon view, the label size may be greater than the rect returned by ListView_GetUnfoldedRect.
                        // So don't specify the size
                        SetWindowPos(plv->hwndToolTips, HWND_TOP,
                                 rcLabel.left, rcLabel.top,
                                 0, 0, SWP_NOSIZE | SWP_NOACTIVATE | SWP_HIDEWINDOW);
                    }
                    else
                    {
                        SetWindowPos(plv->hwndToolTips, HWND_TOP,
                                 rcLabel.left, rcLabel.top,
                                 (rcLabel.right - rcLabel.left), (rcLabel.bottom - rcLabel.top),
                                 SWP_NOACTIVATE | SWP_HIDEWINDOW);
                    }
                    // This is an inplace tooltip, so disable animation.
                    psi->dwStyle |= TTS_NOANIMATE;
                    return TRUE;
                }
            }
            break;

        }
    }

    return 0;
}

// Pass the focus to the given window, and then check to see if it exists.
// Passing focus can cause the window to be destroyed (by the Explorer
// when renaming).

BOOL NEAR ListView_SetFocus(HWND hwnd)
{
    SetFocus(hwnd);
    return IsWindow(hwnd);
}

void NEAR ListView_Realize(LV* plv, HDC hdcParam, BOOL fBackground, BOOL fForceRepaint)
{
    if (plv->hpalHalftone)
    {
        HDC hdc = hdcParam ? hdcParam : GetDC(plv->ci.hwnd);

        if (hdc)
        {
            BOOL fRepaint;

            SelectPalette(hdc, plv->hpalHalftone, fBackground);
            fRepaint = RealizePalette(hdc) || fForceRepaint;

            if (!hdcParam)
                ReleaseDC(plv->ci.hwnd, hdc);

            if (fRepaint)
            {
                InvalidateRect(plv->ci.hwnd, NULL, TRUE);
            }
        }
    }
}

BOOL RectInRect(const RECT* prcOuter, const RECT* prcInner)
{
#ifdef COMPLETELYINRECT
    return (prcOuter->left   <= prcInner->left  ) &&
           (prcOuter->top    <= prcInner->top   ) &&
           (prcOuter->right  >= prcInner->right ) &&
           (prcOuter->bottom >= prcInner->bottom);
#else
    RECT rcDummy;
    return IntersectRect(&rcDummy, prcOuter, prcInner);
#endif
}


LRESULT LVGenerateDragImage(LV* plv, SHDRAGIMAGE* pshdi)
{
    LRESULT lRet = 0;
    int iNumSelected = plv->nSelected;
    int iIndex;
    int iSelectedItem;
    RECT rc = {0, 0, 0, 0};
    RECT rcVisRect;
    HBITMAP hbmpOld = NULL;
    HDC  hdcDragImage;

    // First loop through can get the selection rect
    if (ListView_IsOwnerData( plv )) 
    {
        plv->plvrangeSel->lpVtbl->CountIncluded(plv->plvrangeSel, &iNumSelected);
    }

    if (iNumSelected == 0)
        return FALSE;

    GetClientRect(plv->ci.hwnd, &rcVisRect);


    // Loop Through and calculate the enclosing rect.
    for (iIndex = iNumSelected - 1, iSelectedItem = -1; iIndex >= 0; iIndex--)
    {
        iSelectedItem = ListView_OnGetNextItem(plv, iSelectedItem, LVNI_SELECTED);
        if (iSelectedItem != -1)
        {
            RECT rcItemBounds;

            // Make sure this is in the visible region
            if (ListView_GetItemRect(plv->ci.hwnd, iSelectedItem, &rcItemBounds, LVIR_SELECTBOUNDS) &&
                RectInRect(&rcVisRect, &rcItemBounds))
            {
                UnionRect(&rc, &rc, &rcItemBounds);
            }
        }
    }

    hdcDragImage = CreateCompatibleDC(NULL);

    if (!hdcDragImage)
        return 0;

    // After this rc contains the bounds of all the items in Client Coordinates.
    //
    // Mirror the the DC, if the listview is mirrored.
    //
    if (plv->ci.dwExStyle & RTL_MIRRORED_WINDOW)
    {
        SET_DC_RTL_MIRRORED(hdcDragImage);
    }

#define MAX_DRAG_RECT_WIDTH 300
#define MAX_DRAG_RECT_HEIGHT 300
    // If this rect is too big, fix it.
    if (RECTWIDTH(rc) > MAX_DRAG_RECT_WIDTH)
    {
        int iLeft = MAX_DRAG_RECT_WIDTH / 2;
        int iRight = MAX_DRAG_RECT_WIDTH /2;

        int iRectOriginalLeft = rc.left;
        // Is the left boundry outside the visible rect?
        if (rc.left < plv->ptCapture.x - iLeft)
        {
            // Yes, then we have to clip it.
            rc.left = plv->ptCapture.x - iLeft;
        }
        else
        {
            // No? Well then shift the visible rect to the right, so that we have
            // more room.
            iRight += rc.left - (plv->ptCapture.x - iLeft);
        }

        // Is the right boundry outside the visible rect?
        if (rc.right > plv->ptCapture.x + iRight)
        {
            // Yes, then we have to clip it.
            rc.right = plv->ptCapture.x + iRight;
        }
        else
        {
            // No? Then try and add it to the left
            if (rc.left > iRectOriginalLeft)
            {
                rc.left -= iRight - (rc.right - plv->ptCapture.x);
                if (rc.left < iRectOriginalLeft)
                    rc.left = iRectOriginalLeft;
            }
        }
    }

    if (RECTHEIGHT(rc) > MAX_DRAG_RECT_HEIGHT)
    {
        // same for top and bottom:
        // Is the top boundry outside the visible rect?
        int iTop = MAX_DRAG_RECT_HEIGHT / 2;
        int iBottom = MAX_DRAG_RECT_HEIGHT /2;
        int iRectOriginalTop = rc.top;
        if (rc.top < plv->ptCapture.y - iTop)
        {
            // Yes, then we have to clip it.
            rc.top = plv->ptCapture.y - iTop;
        }
        else
        {
            // No? Well then shift the visible rect to the right, so that we have
            // more room.
            iBottom += rc.top - (plv->ptCapture.y - iTop);
        }

        // Is the right boundry outside the visible rect?
        if (rc.bottom > plv->ptCapture.y + iBottom)
        {
            // Yes, then we have to clip it.
            rc.bottom = plv->ptCapture.y + iBottom;
        }
        else
        {
            // No? Then try and add it to the top
            if (rc.top > iRectOriginalTop)
            {
                rc.top -= iBottom - (rc.bottom - plv->ptCapture.y);
                if (rc.top < iRectOriginalTop)
                    rc.top = iRectOriginalTop;
            }
        }
    }

    pshdi->sizeDragImage.cx = RECTWIDTH(rc);
    pshdi->sizeDragImage.cy = RECTHEIGHT(rc);
    pshdi->hbmpDragImage = CreateBitmap( pshdi->sizeDragImage.cx, pshdi->sizeDragImage.cy,
        GetDeviceCaps(hdcDragImage, PLANES), GetDeviceCaps(hdcDragImage, BITSPIXEL),
        NULL);

    if (pshdi->hbmpDragImage)
    {
        LVDRAWITEM lvdi;
        DWORD dwType;
        int cItem;

        RECT  rcImage = {0, 0, pshdi->sizeDragImage.cx, pshdi->sizeDragImage.cy};
        hbmpOld = SelectObject(hdcDragImage, pshdi->hbmpDragImage);

        pshdi->crColorKey = RGB(0xFF, 0x00, 0x55);
        FillRectClr(hdcDragImage, &rcImage, pshdi->crColorKey);
        pshdi->crColorKey = GetPixel(hdcDragImage, 0, 0);

        // Calculate the offset... The cursor should be in the bitmap rect.

        if (plv->ci.dwExStyle & RTL_MIRRORED_WINDOW)
            pshdi->ptOffset.x = rc.right - plv->ptCapture.x;
        else
            pshdi->ptOffset.x = plv->ptCapture.x - rc.left;
        pshdi->ptOffset.y = plv->ptCapture.y - rc.top;

        lvdi.prcClip = NULL;
        lvdi.plv = plv;
        lvdi.nmcd.nmcd.hdc = hdcDragImage;
        lvdi.pitem = NULL;
        dwType = plv->ci.style & LVS_TYPEMASK;
        cItem = ListView_Count(plv);

        // Now loop through again for the paint cycle
        for (iIndex = cItem - 1, iSelectedItem = -1; iIndex >= 0; iIndex--)
        {
            if (ListView_IsOwnerData( plv )) 
            {
                iSelectedItem++;
                plv->plvrangeSel->lpVtbl->NextSelected(plv->plvrangeSel, iSelectedItem, &iSelectedItem);
            }
            else
            {
                LISTITEM FAR* pitem;
                iSelectedItem = (int)(UINT_PTR)DPA_FastGetPtr(plv->hdpaZOrder, iIndex);
                pitem = ListView_FastGetItemPtr(plv, iSelectedItem);
                if (!(pitem->state & LVIS_SELECTED))
                    iSelectedItem = -1;
            }

            if (iSelectedItem != -1)
            {
                int     iOldItemDrawing;
                COLORREF crSave;
                POINT ptOrigin = {-rc.left, -rc.top};     //Offset the rects by...
                RECT  rcItemBounds;
                RECT rcTemp;

                iOldItemDrawing = plv->iItemDrawing;
                plv->iItemDrawing = iSelectedItem;
                lvdi.nmcd.nmcd.dwItemSpec = iSelectedItem;
                ListView_GetRects(plv, iSelectedItem, NULL, NULL, &rcItemBounds, NULL);

                // Make sure this is in the visible region
                if (IntersectRect(&rcTemp, &rcVisRect, &rcItemBounds))
                {
                    ptOrigin.x += rcItemBounds.left;
                    ptOrigin.y += rcItemBounds.top;
                    // these may get changed
                    lvdi.lpptOrg = &ptOrigin;
                    lvdi.flags = 0;
                    lvdi.nmcd.clrText = plv->clrText;
                    lvdi.nmcd.clrTextBk = plv->clrTextBk;

                    // Save the Background color!
                    crSave = plv->clrBk;
                    plv->clrBk = pshdi->crColorKey;

                    ListView_DrawItem(&lvdi);

                    plv->clrBk = crSave;
                }
                plv->iItemDrawing = iOldItemDrawing;
            }
        }

        SelectObject(hdcDragImage, hbmpOld);
        DeleteDC(hdcDragImage);

        // We're passing back the created HBMP.
        return 1;
    }


    return lRet;
}

LRESULT CALLBACK ListView_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LV* plv = ListView_GetPtr(hwnd);

    if (plv == NULL)
    {
        if (uMsg == WM_NCCREATE)
        {
            plv = (LV*)NearAlloc(sizeof(LV));
            if (!plv)
            {
                DebugMsg(DM_ERROR, TEXT("ListView: Out of near memory"));
                return 0L;      // fail the window create
            }

            plv->ci.hwnd = hwnd;
            plv->flags = LVF_REDRAW;    // assume that redrawing enabled!
            plv->iFocus = -1;           // no focus
            plv->iMark = -1;
            plv->iSelCol = -1;
            plv->iDropHilite = -1;      // Assume no item has drop hilite...
            plv->cyItem = plv->cyItemSave = 1; // never let these be zero, not even for a moment
#ifdef WIN32
            plv->hheap = GetProcessHeap();
#else
            // plv->hheap = NULL;  // not used in 16 bits...
#endif
            ListView_SetPtr(hwnd, plv);
        }
        goto DoDefault;
    }

    if ((uMsg >= WM_MOUSEFIRST) && (uMsg <= WM_MOUSELAST)) {
        if (plv->exStyle & (LVS_EX_TRACKSELECT|LVS_EX_ONECLICKACTIVATE|LVS_EX_TWOCLICKACTIVATE)) {
            TRACKMOUSEEVENT tme;

            tme.cbSize = sizeof(tme);
            tme.hwndTrack = plv->ci.hwnd;
            tme.dwHoverTime = plv->dwHoverTime;
            tme.dwFlags = TME_LEAVE | TME_HOVER | TME_QUERY;

            // see what's set
            TrackMouseEvent(&tme);
            tme.dwFlags &= TME_HOVER | TME_LEAVE;

            // set these bits if they aren't already set
            tme.dwFlags ^= TME_LEAVE;
            if (plv->exStyle & LVS_EX_TRACKSELECT) {
                tme.dwFlags ^= TME_HOVER;
            }

            tme.cbSize = sizeof(tme);
            tme.hwndTrack = plv->ci.hwnd;
            tme.dwHoverTime = plv->dwHoverTime;
            // set it if there's anything to set
            if (tme.dwFlags & (TME_HOVER | TME_LEAVE)) {
                TrackMouseEvent(&tme);
            }
        }
    }

    if (uMsg == g_uDragImages)
    {
        return LVGenerateDragImage(plv, (SHDRAGIMAGE*)lParam);
    }

    switch (uMsg)
    {
        HANDLE_MSG(plv, WM_CREATE, ListView_OnCreate);
        HANDLE_MSG(plv, WM_DESTROY, ListView_OnDestroy);
        HANDLE_MSG(plv, WM_ERASEBKGND, ListView_OnEraseBkgnd);
        HANDLE_MSG(plv, WM_COMMAND, ListView_OnCommand);
        HANDLE_MSG(plv, WM_SETFOCUS, ListView_OnSetFocus);
        HANDLE_MSG(plv, WM_KILLFOCUS, ListView_OnKillFocus);

        HANDLE_MSG(plv, WM_HSCROLL, ListView_OnHScroll);
        HANDLE_MSG(plv, WM_VSCROLL, ListView_OnVScroll);
        HANDLE_MSG(plv, WM_GETDLGCODE, ListView_OnGetDlgCode);
        HANDLE_MSG(plv, WM_SETFONT, ListView_OnSetFont);
        HANDLE_MSG(plv, WM_GETFONT, ListView_OnGetFont);
        HANDLE_MSG(plv, WM_TIMER, ListView_OnTimer);
        HANDLE_MSG(plv, WM_SETREDRAW, ListView_OnSetRedraw);
        HANDLE_MSG(plv, WM_NCDESTROY, ListView_OnNCDestroy);

    case WM_SETCURSOR:
        if (ListView_OnSetCursorMsg(plv))
            return TRUE;
        break;

    case WM_PALETTECHANGED:
        if ((HWND)wParam == hwnd)
            break;
    case WM_QUERYNEWPALETTE:
        // Want to pass FALSE if WM_QUERYNEWPALETTE...
        ListView_Realize(plv, NULL, uMsg == WM_PALETTECHANGED, uMsg == WM_PALETTECHANGED);
        return TRUE;

    case LVMP_WINDOWPOSCHANGED:
    case WM_WINDOWPOSCHANGED:
        HANDLE_WM_WINDOWPOSCHANGED(plv, wParam, lParam, ListView_OnWindowPosChanged);
        break;

    case WM_MBUTTONDOWN:
        if (ListView_SetFocus(hwnd) && plv->hwndToolTips)
            RelayToToolTips(plv->hwndToolTips, hwnd, uMsg, wParam, lParam);
        break;

    case WM_LBUTTONDBLCLK:
    case WM_RBUTTONDBLCLK:
        if (plv->hwndToolTips)
            RelayToToolTips(plv->hwndToolTips, hwnd, uMsg, wParam, lParam);
        ListView_OnButtonDown(plv, TRUE, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), (UINT) wParam);
        break;

    case WM_LBUTTONDOWN:
    case WM_RBUTTONDOWN:
        if (plv->hwndToolTips)
            RelayToToolTips(plv->hwndToolTips, hwnd, uMsg, wParam, lParam);
        ListView_OnButtonDown(plv, FALSE, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), (UINT) wParam);
        break;

    case WM_LBUTTONUP:
    case WM_RBUTTONUP:
    case WM_MBUTTONUP:
    case WM_NCMOUSEMOVE:
        if (plv->hwndToolTips)
            RelayToToolTips(plv->hwndToolTips, hwnd, uMsg, wParam, lParam);
        break;

    case WM_PRINTCLIENT:
    case WM_PAINT:
        ListView_OnPaint(plv, (HDC)wParam);
        return(0);

    case WM_SHOWWINDOW:
        LV_OnShowWindow(plv, BOOLFROMPTR(wParam));
        break;

    case WM_MOUSEHOVER:
        ListView_OnMouseHover(plv, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), (UINT) wParam);
        break;

    case WM_MOUSELEAVE:
        ListView_OnSetHotItem(plv, -1);
        plv->iNoHover = -1;

        break;

    case WM_KEYUP:
        plv->iScrollCount = 0;
        break;

    case WM_KEYDOWN:
        HANDLE_WM_KEYDOWN(plv, wParam, lParam, ListView_OnKey);
        break;

#if defined(FE_IME) || !defined(WINNT)
    case WM_IME_COMPOSITION:
        // Now only Korean version is interested in incremental search with composition string.
        if (g_fDBCSInputEnabled) {
        if (((ULONG_PTR)GetKeyboardLayout(0L) & 0xF000FFFFL) == 0xE0000412L)
        {
            if (ListView_OnImeComposition(plv, wParam, lParam))
            {
                lParam &= ~GCS_RESULTSTR;
                break;
            }
            else
                return 0;
        }
        }
        break;
#endif

    case WM_CHAR:
        if (plv->iPuntChar) {
            plv->iPuntChar--;
            return TRUE;
        } else {
            return HANDLE_WM_CHAR(plv, wParam, lParam, ListView_OnChar);
        }

    case WM_WININICHANGE:
        ListView_OnWinIniChange(plv, wParam, lParam);
        break;

    case WM_NOTIFYFORMAT:
        return CIHandleNotifyFormat(&plv->ci, lParam);

    case WM_ENABLE:
        // HACK: we don't get WM_STYLECHANGE on EnableWindow()
        ListView_EnableWindow(plv, BOOLFROMPTR(wParam));
        break;

    case WM_SYSCOLORCHANGE:
        InitGlobalColors();
        if (plv->ci.style & WS_DISABLED)
        {
            if (!(plv->flags & LVF_USERBKCLR))
                plv->clrBkSave = g_clrWindow;
            ListView_OnSetBkColor(plv, g_clrBtnFace);
        }
        else if (!(plv->flags & LVF_USERBKCLR))
        {
            ListView_OnSetBkColor(plv, g_clrWindow);
        }

        if (plv->exStyle & LVS_EX_CHECKBOXES)
        {
            ListView_InitCheckBoxes(plv, FALSE);
        }

//  98/11/19 #249967 vtan: Always invalidate the list view
//  rectangle so that the color change causes a refresh.

        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
        break;

        // don't use HANDLE_MSG because this needs to go to the default handler
    case WM_SYSKEYDOWN:
        HANDLE_WM_SYSKEYDOWN(plv, wParam, lParam, ListView_OnKey);
        break;

#ifdef KEYBOARDCUES
    case WM_UPDATEUISTATE:
    {
        DWORD dwUIStateMask = MAKEWPARAM(0xFFFF, UISF_HIDEFOCUS);

        // we care only about focus not accel, and redraw only if changed
        if (CCOnUIState(&(plv->ci), WM_UPDATEUISTATE, wParam & dwUIStateMask, lParam))
        {
            if(plv->iFocus >= 0)
            {
                // an item has the focus, invalidate it
                ListView_InvalidateItem(plv, plv->iFocus, FALSE, RDW_INVALIDATE | RDW_ERASE);
            }
        }

        goto DoDefault;
    }
#endif
#ifdef UNICODE
    case LVM_GETITEMA:
        return (LRESULT)ListView_OnGetItemA(plv, (LV_ITEMA *)lParam);

    case LVM_SETITEMA:
        return (LRESULT)ListView_OnSetItemA(plv, (LV_ITEMA *)lParam);

    case LVM_INSERTITEMA:
        return (LRESULT)ListView_OnInsertItemA(plv, (LV_ITEMA *)lParam);

    case LVM_FINDITEMA:
        return (LRESULT)ListView_OnFindItemA(plv, (int)wParam, (LV_FINDINFOA *)lParam);

    case LVM_GETSTRINGWIDTHA:
        return (LRESULT)ListView_OnGetStringWidthA(plv, (LPCSTR)lParam, NULL);

    case LVM_GETCOLUMNA:
        return (LRESULT)ListView_OnGetColumnA(plv, (int)wParam, (LV_COLUMNA *)lParam);

    case LVM_SETCOLUMNA:
        return (LRESULT)ListView_OnSetColumnA(plv, (int)wParam, (LV_COLUMNA *)lParam);

    case LVM_INSERTCOLUMNA:
        return (LRESULT)ListView_OnInsertColumnA(plv, (int)wParam, (LV_COLUMNA *)lParam);

    case LVM_GETITEMTEXTA:
        return (LRESULT)ListView_OnGetItemTextA(plv, (int)wParam, (LV_ITEMA FAR *)lParam);

    case LVM_SETITEMTEXTA:
        if (!lParam)
            return FALSE;

        return (LRESULT)ListView_OnSetItemTextA(plv, (int)wParam,
                                                ((LV_ITEMA *)lParam)->iSubItem,
                                                (LPCSTR)((LV_ITEMA FAR *)lParam)->pszText);

    case LVM_GETBKIMAGEA:
        return (LRESULT)ListView_OnGetBkImageA(plv, (LPLVBKIMAGEA)lParam);

    case LVM_SETBKIMAGEA:
        return (LRESULT)ListView_OnSetBkImageA(plv, (LPLVBKIMAGEA)lParam);

#else

#ifdef DEBUG

    case LVM_GETITEMW:
    case LVM_SETITEMW:
    case LVM_INSERTITEMW:
    case LVM_FINDITEMW:
    case LVM_GETSTRINGWIDTHW:
    case LVM_GETCOLUMNW:
    case LVM_SETCOLUMNW:
    case LVM_INSERTCOLUMNW:
    case LVM_GETITEMTEXTW:
    case LVM_SETITEMTEXTW:
    case LVM_GETBKIMAGEW:
    case LVM_SETBKIMAGEW:
    case LVM_GETISEARCHSTRINGW:
    case LVM_EDITLABELW:
        break;
#endif

#endif
    case WM_STYLECHANGING:
        ListView_OnStyleChanging(plv, (UINT)wParam, (LPSTYLESTRUCT)lParam);
        return 0;

    case WM_STYLECHANGED:
        ListView_OnStyleChanged(plv, (UINT) wParam, (LPSTYLESTRUCT)lParam);
        return 0L;

    case WM_HELP:
        return ListView_OnHelp(plv, (LPHELPINFO)lParam);


    case LVM_GETIMAGELIST:
        return (LRESULT)(UINT_PTR)(ListView_OnGetImageList(plv, (int)wParam));

    case LVM_SETIMAGELIST:
        return (LRESULT)(UINT_PTR)ListView_OnSetImageList(plv, (HIMAGELIST)lParam, (int)wParam);

    case LVM_GETBKCOLOR:
        return (LRESULT)(plv->ci.style & WS_DISABLED ? plv->clrBkSave : plv->clrBk);

    case LVM_SETBKCOLOR:
        plv->flags |= LVF_USERBKCLR;
        if (plv->ci.style & WS_DISABLED) {
            plv->clrBkSave = (COLORREF)lParam;
            return TRUE;
        } else {
            return (LRESULT)ListView_OnSetBkColor(plv, (COLORREF)lParam);
        }

    case LVM_GETTEXTCOLOR:
        return (LRESULT)plv->clrText;
    case LVM_SETTEXTCOLOR:
        plv->clrText = (COLORREF)lParam;
        return TRUE;
    case LVM_GETTEXTBKCOLOR:
        return (LRESULT)plv->clrTextBk;
    case LVM_SETTEXTBKCOLOR:
        plv->clrTextBk = (COLORREF)lParam;
        return TRUE;
    case LVM_GETHOTLIGHTCOLOR:
        return (LRESULT)plv->clrHotlight;
    case LVM_SETHOTLIGHTCOLOR:
        plv->clrHotlight = (COLORREF)lParam;
        return(TRUE);

    case LVM_GETITEMCOUNT:
        if (ListView_IsOwnerData(plv))
            return((LRESULT)plv->cTotalItems);
        else if (!plv->hdpa)
            return(0);
        else
            return((LRESULT)DPA_GetPtrCount(plv->hdpa));
        break;

    case LVM_GETITEM:
        return (LRESULT)ListView_OnGetItem(plv, (LV_ITEM FAR*)lParam);

    case LVM_GETITEMSTATE:
        return (LRESULT)ListView_OnGetItemState(plv, (int)wParam, (UINT)lParam);

    case LVM_SETITEMSTATE:
        if (!lParam)
            return FALSE;

        return (LRESULT)ListView_OnSetItemState(plv, (int)wParam,
                                                ((LV_ITEM FAR *)lParam)->state,
                                                ((LV_ITEM FAR *)lParam)->stateMask);

    case LVM_SETITEMTEXT:
        if (!lParam)
            return FALSE;

        return (LRESULT)ListView_OnSetItemText(plv, (int)wParam,
                                                ((LV_ITEM FAR *)lParam)->iSubItem,
                                                (LPCTSTR)((LV_ITEM FAR *)lParam)->pszText);

    case LVM_GETITEMTEXT:
        return (LRESULT)ListView_OnGetItemText(plv, (int)wParam, (LV_ITEM FAR *)lParam);

    case LVM_GETBKIMAGE:
        return (LRESULT)ListView_OnGetBkImage(plv, (LPLVBKIMAGE)lParam);

    case LVM_SETBKIMAGE:
        return (LRESULT)ListView_OnSetBkImage(plv, (LPLVBKIMAGE)lParam);

    case LVM_SETITEM:
        return (LRESULT)ListView_OnSetItem(plv, (const LV_ITEM FAR*)lParam);

    case LVM_INSERTITEM:
        return (LRESULT)ListView_OnInsertItem(plv, (const LV_ITEM FAR*)lParam);

    case LVM_DELETEITEM:
        return (LRESULT)ListView_OnDeleteItem(plv, (int)wParam);

    case LVM_UPDATE:
        ListView_OnUpdate(plv, (int)wParam);
        UpdateWindow(plv->ci.hwnd);
        return TRUE;

    case LVM_DELETEALLITEMS:
        lParam = (LRESULT)ListView_OnDeleteAllItems(plv);
        // Optimization:  Instead of sending out a zillion EVENT_OBJECT_DESTROY's,
        // we send out a destroy of ourselves followed by a fresh create.
        // For compatibility with IE4, we still send out the REORDER notification.
        MyNotifyWinEvent(EVENT_OBJECT_REORDER, hwnd, OBJID_CLIENT, 0);
        ListView_NotifyRecreate(plv);
        return(lParam);

    case LVM_GETITEMRECT:
        return (LRESULT)ListView_OnGetItemRect(plv, (int)wParam, (RECT FAR*)lParam);

    case LVM_GETSUBITEMRECT:
        return (LRESULT)ListView_OnGetSubItemRect(plv, (int)wParam, (LPRECT)lParam);

    case LVM_SUBITEMHITTEST:
        return (LRESULT)ListView_OnSubItemHitTest(plv, (LPLVHITTESTINFO)lParam);

#ifdef UNICODE
    case LVM_GETISEARCHSTRINGA:
        if (GetFocus() == plv->ci.hwnd)
            return (LRESULT)GetIncrementSearchStringA(&plv->is, plv->ci.uiCodePage, (LPSTR)lParam);
        else
            return 0;

#endif

    case LVM_GETISEARCHSTRING:
        if (GetFocus() == plv->ci.hwnd)
            return (LRESULT)GetIncrementSearchString(&plv->is, (LPTSTR)lParam);
        else
            return 0;

    case LVM_GETITEMSPACING:
        if (wParam)
            return MAKELONG(plv->cxItem, plv->cyItem);
        else
            return MAKELONG(lv_cxIconSpacing, lv_cyIconSpacing);

    case LVM_GETNEXTITEM:
        return (LRESULT)ListView_OnGetNextItem(plv, (int)wParam, (UINT)lParam);

    case LVM_FINDITEM:
        return (LRESULT)ListView_OnFindItem(plv, (int)wParam, (const LV_FINDINFO FAR*)lParam);

    case LVM_SETSELECTIONMARK:
    {
        int iOldMark = plv->iMark;
        int iNewMark = (int)lParam;
        if (iNewMark == -1 || ListView_IsValidItemNumber(plv, iNewMark)) {
            plv->iMark = iNewMark;
        }
        return iOldMark;
    }

    case LVM_GETSELECTIONMARK:
        return plv->iMark;

    case LVM_GETITEMPOSITION:
        return (LRESULT)ListView_OnGetItemPosition(plv, (int)wParam,
                (POINT FAR*)lParam);

    case LVM_SETITEMPOSITION:
        return (LRESULT)ListView_OnSetItemPosition(plv, (int)wParam,
                GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));

    case LVM_SETITEMPOSITION32:
        if (!lParam)
            return FALSE;

        return (LRESULT)ListView_OnSetItemPosition(plv, (int)wParam,
                ((LPPOINT)lParam)->x, ((LPPOINT)lParam)->y);

    case LVM_SCROLL:
    {
        int dx = (int)wParam;
        int dy = (int)lParam;
        return (LRESULT)
            (ListView_ValidateScrollParams(plv, &dx, &dy) &&
             ListView_OnScroll(plv, dx, dy));
    }

    case LVM_ENSUREVISIBLE:
        return (LRESULT)ListView_OnEnsureVisible(plv, (int)wParam, BOOLFROMPTR(lParam));

    case LVM_REDRAWITEMS:
        return (LRESULT)ListView_OnRedrawItems(plv, (int)wParam, (int)lParam);

    case LVM_ARRANGE:
        return (LRESULT)ListView_OnArrange(plv, (UINT)wParam);

    case LVM_GETEDITCONTROL:
        return (LRESULT)(UINT_PTR)plv->hwndEdit;

#ifdef UNICODE
    case LVM_EDITLABELA:
        {
        LPWSTR lpEditString = NULL;
        HWND   hRet;

        if (lParam) {
            lpEditString = ProduceWFromA(plv->ci.uiCodePage, (LPSTR)lParam);
        }

        hRet = ListView_OnEditLabel(plv, (int)wParam, lpEditString);

        if (lpEditString) {
            FreeProducedString(lpEditString);
        }

        return (LRESULT)hRet;
        }
#endif

    case LVM_EDITLABEL:
        return (LRESULT)(UINT_PTR)ListView_OnEditLabel(plv, (int)wParam, (LPTSTR)lParam);

    case LVM_HITTEST:
        return (LRESULT)ListView_OnHitTest(plv, (LV_HITTESTINFO FAR*)lParam);

    case LVM_GETSTRINGWIDTH:
        return (LRESULT)ListView_OnGetStringWidth(plv, (LPCTSTR)lParam, NULL);

    case LVM_GETCOLUMN:
        return (LRESULT)ListView_OnGetColumn(plv, (int)wParam, (LV_COLUMN FAR*)lParam);

    case LVM_SETCOLUMN:
        return (LRESULT)ListView_OnSetColumn(plv, (int)wParam, (const LV_COLUMN FAR*)lParam);

    case LVM_SETCOLUMNORDERARRAY:
        return SendMessage(plv->hwndHdr, HDM_SETORDERARRAY, wParam, lParam);

    case LVM_GETCOLUMNORDERARRAY:
        return SendMessage(plv->hwndHdr, HDM_GETORDERARRAY, wParam, lParam);

    case LVM_GETHEADER:
    {
        HWND hwndOld = plv->hwndHdr;
        if (lParam && IsWindow((HWND)lParam)) {
            plv->hwndHdr = (HWND)lParam;
        }
        return (LRESULT)hwndOld;
    }

    case LVM_INSERTCOLUMN:
        return (LRESULT)ListView_OnInsertColumn(plv, (int)wParam, (const LV_COLUMN FAR*)lParam);

    case LVM_DELETECOLUMN:
        return (LRESULT)ListView_OnDeleteColumn(plv, (int)wParam);

    case LVM_CREATEDRAGIMAGE:
        return (LRESULT)(UINT_PTR)ListView_OnCreateDragImage(plv, (int)wParam, (LPPOINT)lParam);


    case LVMI_PLACEITEMS:
        if (plv->uUnplaced) {
            ListView_Recompute(plv);
            ListView_UpdateScrollBars(plv);
        }
        return 0;

    case LVM_GETVIEWRECT:
        if (!lParam)
            return FALSE;

        ListView_GetViewRect2(plv, (RECT FAR*)lParam, plv->sizeClient.cx, plv->sizeClient.cy);
        return (LPARAM)TRUE;

    case LVM_GETCOLUMNWIDTH:
        return (LPARAM)ListView_OnGetColumnWidth(plv, (int)wParam);

    case LVM_SETCOLUMNWIDTH:
        return (LPARAM)ListView_ISetColumnWidth(plv, (int)wParam,
            GET_X_LPARAM(lParam), TRUE);

    case LVM_SETCALLBACKMASK:
        plv->stateCallbackMask = (UINT)wParam;
        return (LPARAM)TRUE;

    case LVM_GETCALLBACKMASK:
        return (LPARAM)(UINT)plv->stateCallbackMask;

    case LVM_GETTOPINDEX:
        return (LPARAM)ListView_OnGetTopIndex(plv);

    case LVM_GETCOUNTPERPAGE:
        return (LPARAM)ListView_OnGetCountPerPage(plv);

    case LVM_GETORIGIN:
        return (LPARAM)ListView_OnGetOrigin(plv, (POINT FAR*)lParam);

    case LVM_SETITEMCOUNT:
        return ListView_OnSetItemCount(plv, (int)wParam, (DWORD)lParam);

    case LVM_GETSELECTEDCOUNT:
        if (ListView_IsOwnerData( plv )) {
            plv->plvrangeSel->lpVtbl->CountIncluded(plv->plvrangeSel, &plv->nSelected);
        }

        return plv->nSelected;

    case LVM_SORTITEMS:
        return ListView_OnSortItems(plv, (LPARAM)wParam, (PFNLVCOMPARE)lParam, TRUE);

    case LVM_SORTITEMSEX:
        return ListView_OnSortItems(plv, (LPARAM)wParam, (PFNLVCOMPARE)lParam, FALSE);

    case LVM_SETEXTENDEDLISTVIEWSTYLE:
        return ListView_ExtendedStyleChange(plv, (DWORD) lParam, (DWORD) wParam);

    case LVM_GETEXTENDEDLISTVIEWSTYLE:
        return plv->exStyle;

    case LVM_GETHOVERTIME:
        return plv->dwHoverTime;

    case LVM_SETHOVERTIME:
    {
        DWORD dwRet = plv->dwHoverTime;
        plv->dwHoverTime = (DWORD)lParam;
        return dwRet;
    }

    case LVM_GETTOOLTIPS:
        return (LRESULT)plv->hwndToolTips;

    case LVM_SETTOOLTIPS:
    {
        HWND hwndToolTips = plv->hwndToolTips;
        plv->hwndToolTips = (HWND)wParam;
        return (LRESULT)hwndToolTips;
    }

    case LVM_SETICONSPACING:
    {
        DWORD dwRet = ListView_OnSetIconSpacing(plv, lParam);

        // rearrange as necessary
        if (ListView_RedrawEnabled(plv) &&
            ((plv->ci.style & LVS_AUTOARRANGE) &&
             (ListView_IsSmallView(plv) || ListView_IsIconView(plv))))
        {
            // Call off to the arrange function.
            ListView_OnArrange(plv, LVA_DEFAULT);
        }
        return dwRet;
    }

    case LVM_SETHOTITEM:
    {
        int iOld = plv->iHot;
        int iNew = (int)wParam;
        if (iNew == -1 || ListView_IsValidItemNumber(plv, iNew)) {
            ListView_OnSetHotItem(plv, (int)wParam);
        }
        return iOld;
    }

    case LVM_GETHOTITEM:
        return plv->iHot;

    // hCurHot is used iff LVS_EX_TRACKSELECT
    case LVM_SETHOTCURSOR:
    {
        HCURSOR hCurOld = plv->hCurHot;
        plv->hCurHot = (HCURSOR)lParam;
        return (LRESULT)hCurOld;
    }

    case LVM_GETHOTCURSOR:
        if (!plv->hCurHot)
            plv->hCurHot = LoadHandCursor(0);
        return (LRESULT)plv->hCurHot;

    case LVM_APPROXIMATEVIEWRECT:
        return ListView_OnApproximateViewRect(plv, (int)wParam, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));

    case LVM_SETLVRANGEOBJECT:
        return ListView_OnSetLVRangeObject(plv, (int)wParam, (ILVRange *)lParam);

#ifdef LVM_SETWORKAREAS  // until the headers are in ssync.....
    case LVM_SETWORKAREAS:
        ListView_OnSetWorkAreas(plv, (int)wParam, (RECT FAR *)lParam);
        return 0;

    case LVM_GETWORKAREAS:
        ListView_OnGetWorkAreas(plv, (int)wParam, (RECT FAR *)lParam);
        return 0;

    case LVM_GETNUMBEROFWORKAREAS:
        ListView_OnGetNumberOfWorkAreas(plv, (int *)lParam);
        return 0;

    case LVM_RESETEMPTYTEXT:
        plv->fNoEmptyText = FALSE;
        Str_Set(&plv->pszEmptyText, NULL);
        if (ListView_Count(plv) == 0)
            InvalidateRect(plv->ci.hwnd, NULL, TRUE);
        return 1;
#endif
    case WM_SIZE:
        if (plv)
        {
            if (plv->hwndToolTips) {
                TOOLINFO ti;

                if (ListView_IsLabelTip(plv))
                {
                    // A truncated label may have been exposed or vice versa.
                    ListView_InvalidateTTLastHit(plv, plv->iTTLastHit);
                }

                ti.cbSize = sizeof(ti);
                ti.hwnd = plv->ci.hwnd;
                ti.uId = 0;

                // Resize the tooltip control so that it covers the entire
                // area of the window when its parent gets resized.

                GetClientRect( plv->ci.hwnd, &ti.rect );
                SendMessage( plv->hwndToolTips, TTM_NEWTOOLRECT, 0, (LPARAM) &ti );
            }
            // if we're supposed to center the image,
            // we need to do a full redraw on each size
            if ((plv->ulBkImageFlags & LVBKIF_SOURCE_MASK) &&
                (plv->xOffsetPercent || plv->yOffsetPercent)) {
                InvalidateRect(plv->ci.hwnd, NULL, TRUE);
            }

        }
        break;

    case WM_NOTIFY:
        return ListView_OnNotify(plv, wParam, (LPNMHDR)lParam);


    case WM_MOUSEMOVE:
        if (plv->hwndToolTips)
        {
            UINT uFlags;
            int iHit, iSubHit;

            RelayToToolTips(plv->hwndToolTips, hwnd, uMsg, wParam, lParam);

            // check that we are still on the hit item, pop it!
            iHit = _ListView_ItemHitTest( plv, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), &uFlags, &iSubHit );

            if (iHit != plv->iTTLastHit || iSubHit != plv->iTTLastSubHit)
                ListView_PopBubble(plv);
        }

        ListView_OnMouseMove(plv, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), (UINT) wParam);
        break;

    case WM_GETOBJECT:
        if( lParam == OBJID_QUERYCLASSNAMEIDX )
            return MSAA_CLASSNAMEIDX_LISTVIEW;
        break;

    default:
        {
            LRESULT lres;
            if (CCWndProc(&plv->ci, uMsg, wParam, lParam, &lres))
                return lres;
        }

        // Special handling of magellan mouse message
        if (uMsg == g_msgMSWheel) {
            BOOL            fScroll;
            BOOL            fDataZoom;
            DWORD           dwStyle;
            int             sb;
            SCROLLINFO      si;
            int             cScrollUnitsPerLine;
            int             cPage;
            int             cLinesPerDetant;
            int             cDetants;
            int             dPos;
            int iWheelDelta;

            if (g_bRunOnNT || g_bRunOnMemphis)
            {
                iWheelDelta = (int)(short)HIWORD(wParam);
                fScroll = !(wParam & (MK_SHIFT | MK_CONTROL));
                fDataZoom = (BOOL) (wParam & MK_SHIFT);
            }
            else
            {
                iWheelDelta = (int)wParam;
                fDataZoom = (GetKeyState(VK_SHIFT) < 0);
                fScroll = !fDataZoom && GetKeyState(VK_CONTROL) >= 0;
            }

            // Update count of scroll amount
            gcWheelDelta -= iWheelDelta;
            cDetants = gcWheelDelta / WHEEL_DELTA;
            if (cDetants != 0) {
                gcWheelDelta %= WHEEL_DELTA;
            }

            if (fScroll) {
                if (g_ucScrollLines > 0 &&
                    cDetants != 0 &&
                    ((WS_VSCROLL | WS_HSCROLL) & (dwStyle = ListView_GetWindowStyle(plv)))) {

                    sb = (dwStyle & WS_VSCROLL) ? SB_VERT : SB_HORZ;

                    // Get the scroll amount of one line
                    cScrollUnitsPerLine = _ListView_GetScrollUnitsPerLine(plv, sb);
                    ASSERT(cScrollUnitsPerLine > 0);

                    si.cbSize = sizeof(SCROLLINFO);
                    si.fMask = SIF_PAGE | SIF_POS;
                    if (!ListView_GetScrollInfo(plv, sb, &si))
                        return 1;

                    // The size of a page is at least one line, and
                    // leaves one line of overlap
                    cPage = (max(cScrollUnitsPerLine, (int)si.nPage - cScrollUnitsPerLine)) / cScrollUnitsPerLine;

                    // Don't scroll more than one page per detant
                    cLinesPerDetant = (int) min((ULONG) cPage, (ULONG) g_ucScrollLines);

                    dPos = cLinesPerDetant * cDetants * cScrollUnitsPerLine;

                    ListView_DismissEdit(plv, FALSE);
                    ListView_ComOnScroll(
                            plv, SB_THUMBTRACK, si.nPos + dPos, sb, cScrollUnitsPerLine, - 1);
                    ListView_UpdateScrollBars(plv);

                    // After scrolling, the tooltip might need to change
                    // so send the tooltip a fake mousemove message to force
                    // a recompute.  We use WM_NCMOUSEMOVE since our lParam
                    // is in screen coordinates, not client coordinates.
                    ListView_PopBubble(plv);
                    RelayToToolTips(plv->hwndToolTips, plv->ci.hwnd,
                                    WM_NCMOUSEMOVE, HTCLIENT, lParam);
                }
                return 1;
            } else if (fDataZoom) {
                LV_HITTESTINFO ht;
                ht.pt.x = GET_X_LPARAM(lParam);
                ht.pt.y = GET_Y_LPARAM(lParam);
                ScreenToClient(hwnd, &(ht.pt));

                // If we are rolling forward and we hit an item then navigate
                // into that item (simulate dblclk which will open it).  Otherwise
                // just fall through so it isn't handled.  In that case if we
                // are being hosted in explorer it will do a backwards
                // history navigation.
                if ((iWheelDelta > 0) && (ListView_OnSubItemHitTest(plv, &ht) >= 0) &&
                    (ht.flags & LVHT_ONITEM) && cDetants != 0) {
                    BYTE aKeyState[256];
                    // This is a bit yucky but when ListView_HandleMouse sends the
                    // notification to the listview owner we need to make sure that
                    // it doesn't think the shift key is down.  Otherwise it may
                    // perform some "alternate" action but in this case we always
                    // want it to perform the default open action.
                    //
                    // Strip the high bit of VK_SHIFT so that the shift key is
                    // not down.
                    GetKeyboardState(aKeyState);
                    aKeyState[VK_SHIFT] &= 0x7f;
                    SetKeyboardState(aKeyState);
                    ListView_HandleMouse(plv, FALSE, ht.pt.x, ht.pt.y, 0, TRUE);
                    ListView_HandleMouse(plv, TRUE, ht.pt.x, ht.pt.y, 0, TRUE);
                    return 1;
                }
                // else fall through
            }
        }

        break;
    }

DoDefault:
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

void NEAR ListView_OnWinIniChange(LV* plv, WPARAM wParam, LPARAM lParam)
{
    // BUGBUG:  will this also catch sysparametersinfo?
    // we need a general way of handling this, not
    // just relying on the listview.
    InitGlobalMetrics(wParam);

    switch (wParam) {
        case 0:
        case SPI_SETNONCLIENTMETRICS:
        case SPI_SETICONTITLELOGFONT:
        case SPI_SETICONMETRICS:
            // If wParam is 0, only reload settings if lParam is 0 too.  This catches the wild-card scenario
            // (like the old plus tab which does WM_WININICHANGE, 0, 0) but allows us to ignore wParam = 0
            // and lParam = lpszSectionName.  Reduces unecessary flashing.
            if (wParam || !lParam)
            {
                if (!(plv->flags & LVF_ICONSPACESET))
                    ListView_OnSetIconSpacing(plv, (LPARAM)-1);

                if (plv->flags & LVF_FONTCREATED)
                    ListView_OnSetFont(plv, NULL, TRUE);

                // Force a recalc of all the icon regions by stripping and
                // then adding back the LVS_EX_REGIONAL bit.
                if (plv->exStyle & LVS_EX_REGIONAL) {
                    ListView_ExtendedStyleChange(plv, 0, LVS_EX_REGIONAL);
                    ListView_ExtendedStyleChange(plv, LVS_EX_REGIONAL, LVS_EX_REGIONAL);
                }
            }
            break;

        default:
            break;
    }

    // If we are in an Iconic view and the user is in autoarrange mode,
    // then we need to arrange the items.
    //
    if ((ListView_IsOwnerData( plv ) || (plv->ci.style & LVS_AUTOARRANGE)) &&
        (ListView_IsSmallView(plv) || ListView_IsIconView(plv)))
    {
        // Call off to the arrange function.
        ListView_OnArrange(plv, LVA_DEFAULT);
    }
}

BOOL NEAR ListView_OnCreate(LV* plv, CREATESTRUCT FAR* lpCreateStruct)
{
    CCCreateWindow();
#ifdef WINNT
    InitDitherBrush();
#endif


    CIInitialize(&plv->ci, plv->ci.hwnd, lpCreateStruct);

#ifdef DEBUG
    if (GetAsyncKeyState(VK_SHIFT) < 0 &&
        GetAsyncKeyState(VK_CONTROL) < 0) {
        //plv->exStyle |= LVS_EX_SUBITEMIMAGES;
        plv->exStyle |= LVS_EX_FULLROWSELECT;
        plv->ci.style |= LVS_SHOWSELALWAYS;
        SetWindowLong(plv->ci.hwnd, GWL_STYLE, plv->ci.style);
    }
#endif

    plv->dwExStyle = lpCreateStruct->dwExStyle;

    if (plv->ci.style & WS_VISIBLE)
        plv->flags |= LVF_VISIBLE;

    ListView_GetRegIASetting(&g_bUseDblClickTimer);

    if (ListView_IsOwnerData(plv))
    {
        // ownerdata initialization
        plv->plvrangeSel = LVRange_Create();
        if (NULL == plv->plvrangeSel)
           goto error0;

       plv->plvrangeCut = LVRange_Create();
       if (NULL == plv->plvrangeCut)
          goto error0;
    }
    else
    {
        ASSERT(plv->plvrangeSel == NULL);
        ASSERT(plv->plvrangeCut == NULL);

        plv->hdpa = DPA_CreateEx(LV_HDPA_GROW, plv->hheap);
        if (!plv->hdpa)
            goto error0;

        plv->hdpaZOrder = DPA_CreateEx(LV_HDPA_GROW, plv->hheap);
        if (!plv->hdpaZOrder)
            goto error1;
    }

    ASSERT(plv->nWorkAreas == 0);
    ASSERT(plv->prcWorkAreas == NULL);
    plv->iNoHover = -1;
    plv->dwHoverTime = HOVER_DEFAULT;
    plv->iHot = -1;
    plv->iEdit = -1;
    plv->iFocus = -1;
    plv->iDrag = -1;
    plv->iTTLastHit = -1;
    plv->iFreeSlot = -1;
    plv->rcView.left = RECOMPUTE;
    ASSERT(plv->iMSAAMin == plv->iMSAAMax);

    plv->sizeClient.cx = lpCreateStruct->cx;
    plv->sizeClient.cy = lpCreateStruct->cy;

    // Setup flag to say if positions are in small or large view
    if (ListView_IsSmallView(plv))
        plv->flags |= LVF_ICONPOSSML;

    // force calculation of listview metrics
    ListView_OnSetFont(plv, NULL, FALSE);

    plv->cxItem = 16 * plv->cxLabelChar + plv->cxSmIcon;

    // if we're in ownerdraw report mode, the size got saved to cyItemSave
    // at creation time, both need to have this
    if ((plv->ci.style & LVS_OWNERDRAWFIXED) && ListView_IsReportView(plv))
        plv->cyItem = plv->cyItemSave;
    else
        plv->cyItemSave = plv->cyItem;

    ListView_OnSetIconSpacing(plv, (LPARAM)-1);

    ListView_UpdateScrollBars(plv);     // sets plv->cItemCol

    plv->clrBk = CLR_NONE;
    plv->clrText = CLR_DEFAULT;
    plv->clrTextBk = CLR_DEFAULT;
    plv->clrHotlight = CLR_DEFAULT;

    // create the bk brush, and set the imagelists colors if needed
    ListView_OnSetBkColor(plv, g_clrWindow);

    // Initialize report view fields
    plv->xTotalColumnWidth = RECOMPUTE;

    if (ListView_IsReportView(plv))
        ListView_RInitialize(plv, FALSE);

    if (plv->ci.style & WS_DISABLED) {
        plv->ci.style &= ~WS_DISABLED;
        ListView_EnableWindow(plv, FALSE);
    }

    // tooltip for unfolding name lables

    plv->hwndToolTips = CreateWindow(TOOLTIPS_CLASS, NULL,
                                     WS_POPUP|TTS_NOPREFIX, 0, 0, 0, 0,
                                     NULL, NULL, g_hinst, NULL);
    if ( plv->hwndToolTips )
    {
        TOOLINFO ti;

        ti.cbSize = sizeof(ti);
        ti.uFlags = TTF_TRANSPARENT;
        ti.hwnd = plv->ci.hwnd;
        ti.uId = 0;
        ti.hinst = NULL;
        ti.lpszText = LPSTR_TEXTCALLBACK;

        GetClientRect( plv->ci.hwnd, &ti.rect );
        SendMessage( plv->hwndToolTips, TTM_ADDTOOL, 0, (LPARAM) &ti );

        /* Ensure that the tooltips use the same font as the view */
        FORWARD_WM_SETFONT(plv->hwndToolTips, plv->hfontLabel, FALSE, SendMessage);
    }
    ASSERT(plv->hwndToolTips);

    ASSERT(FALSE == plv->fOneClickOK);
    SetTimer(plv->ci.hwnd, IDT_ONECLICKOK, GetDoubleClickTime(), NULL);

    return TRUE;

error1:
    DPA_Destroy(plv->hdpa);
error0:
    if ( plv->plvrangeSel )
        plv->plvrangeSel->lpVtbl->Release( plv->plvrangeSel );
    if ( plv->plvrangeCut)
        plv->plvrangeCut->lpVtbl->Release( plv->plvrangeCut );
    return FALSE;
}

void NEAR PASCAL ListView_DeleteHrgnInval(LV* plv)
{
    if (plv->hrgnInval && plv->hrgnInval != (HRGN)ENTIRE_REGION)
        DeleteObject(plv->hrgnInval);
    plv->hrgnInval = NULL;
}

void NEAR ListView_OnDestroy(LV* plv)
{
    //
    // The tooltip window may or may not exist at this point.  It
    // depends if the owning window of the tips is also being destroy.
    // If so, then the tips are gone already.
    //

    if (IsWindow(plv->hwndToolTips))
        DestroyWindow(plv->hwndToolTips);

    if (plv->hCurHot)
        DestroyCursor(plv->hCurHot);

    plv->hwndToolTips = NULL;

    Str_Set(&plv->pszTip, NULL);
    Str_Set(&plv->pszEmptyText, NULL);

#ifdef WINNT
    TerminateDitherBrush();
#endif

    if (!ListView_IsOwnerData(plv)) {
       // Make sure to notify the app
       ListView_OnDeleteAllItems(plv);
    }

    if ((plv->flags & LVF_FONTCREATED) && plv->hfontLabel) {
        DeleteObject(plv->hfontLabel);
        // plv->flags &= ~LVF_FONTCREATED;
        // plv->hwfontLabel = NULL;
    }
    if (plv->hFontHot)
        DeleteObject(plv->hFontHot);
    ListView_DeleteHrgnInval(plv);

    if (plv->prcWorkAreas)
    {
        // This assert is bogus: If the app created work areas then deleted
        // them, nWorkAreas will be 0 but prcWorkAreas will be non-NULL.
        // ASSERT(plv->nWorkAreas > 0);
        LocalFree(plv->prcWorkAreas);
    }
}

void NEAR ListView_OnNCDestroy(LV* plv)
{
    CCDestroyWindow();

    if ((!(plv->ci.style & LVS_SHAREIMAGELISTS)) || ListView_CheckBoxes(plv)) {

        if (plv->himlState &&
            (plv->himlState != plv->himl) &&
            (plv->himlState != plv->himlSmall))
        {
            ImageList_Destroy(plv->himlState);
        }
    }

    if (!(plv->ci.style & LVS_SHAREIMAGELISTS))
    {
        if (plv->himl)
            ImageList_Destroy(plv->himl);
        if (plv->himlSmall)
            ImageList_Destroy(plv->himlSmall);
    }

    if (ListView_IsOwnerData(plv)) {
        plv->plvrangeSel->lpVtbl->Release( plv->plvrangeSel );
        plv->plvrangeCut->lpVtbl->Release( plv->plvrangeCut );
        plv->cTotalItems = 0;
    }

    ListView_ReleaseBkImage(plv);

    if (plv->hbrBk)
        DeleteBrush(plv->hbrBk);

    if (plv->hdpa)
        DPA_Destroy(plv->hdpa);

    if (plv->hdpaZOrder)
        DPA_Destroy(plv->hdpaZOrder);

    ListView_RDestroy(plv);

    IncrementSearchFree(&plv->is);

    ListView_SetPtr(plv->ci.hwnd, NULL);
    NearFree(plv);
}


// sets the background color for the listview
//
// this creats the brush for drawing the background as well
// as sets the imagelists background color if needed

BOOL NEAR ListView_OnSetBkColor(LV* plv, COLORREF clrBk)
{
    if (plv->clrBk != clrBk)
    {
        if (plv->hbrBk)
        {
            DeleteBrush(plv->hbrBk);
            plv->hbrBk = NULL;
        }

        if (clrBk != CLR_NONE)
        {
            plv->hbrBk = CreateSolidBrush(clrBk);
            if (!plv->hbrBk)
                return FALSE;
        }

        // don't mess with the imagelist color if things are shared

        if (!(plv->ci.style & LVS_SHAREIMAGELISTS)) {

            if (plv->himl)
                ImageList_SetBkColor(plv->himl, clrBk);

            if (plv->himlSmall)
                ImageList_SetBkColor(plv->himlSmall, clrBk);

            if (plv->himlState)
                ImageList_SetBkColor(plv->himlState, clrBk);
        }

        plv->clrBk = clrBk;
    }
    return TRUE;
}

void PASCAL InitBrushOrg(LV* plv, HDC hdc)
{
    int x;
    if (ListView_IsSmallView(plv) || ListView_IsIconView(plv)) {
        x = plv->ptOrigin.x;
    } else if (ListView_IsListView(plv)) {
        x = plv->xOrigin;
    } else {
        x = (int)plv->ptlRptOrigin.x;
    }
    SetBrushOrgEx(hdc, -x, 0, NULL);
}

void NEAR PASCAL ListView_InvalidateRegion(LV* plv, HRGN hrgn)
{
    if (hrgn) {
        if (plv->hrgnInval == NULL) {
            plv->hrgnInval = hrgn;
        } else {

            // union it in if the entire region isn't marked for invalidate
            if (plv->hrgnInval != (HRGN)ENTIRE_REGION) {
                UnionRgn(plv->hrgnInval, plv->hrgnInval, hrgn);
            }
            DeleteObject(hrgn);
        }
    }
}


// ----------------------------------------------------------------------------
//
//  LVSeeThruScroll
//
//  Used when a watermark is the listview's background (detected via clrTextBk
//  being CLR_NONE) to perform a flicker-free scroll of the client area, using
//  an offscreen bitmap
//
//  potential perf issue -- caching DC and/or bitmap instead of create/destroy
//                          on each call
//
//  jeffbog 2/29/96
//
// ----------------------------------------------------------------------------

void LVSeeThruScroll(LV *plv, LPRECT lprcUpdate)
{
    HDC     hdcOff;
    HBITMAP hbmpOff;
    int     x,y,cx,cy;
    HDC     hdc = GetDC(plv->ci.hwnd);

    if (!lprcUpdate)
    {
        x = y = 0;
        cx = plv->sizeClient.cx;
        cy = plv->sizeClient.cy;
    }
    else
    {
        x  = lprcUpdate->left;
        y  = lprcUpdate->top;
        cx = lprcUpdate->right - x;
        cy = lprcUpdate->bottom - y;
    }

    hdcOff  = CreateCompatibleDC(hdc);
    hbmpOff = CreateCompatibleBitmap(hdc, plv->sizeClient.cx, plv->sizeClient.cy);
    SelectObject(hdcOff, hbmpOff);

    SendMessage(plv->ci.hwnd, WM_PRINT, (WPARAM)hdcOff, PRF_CLIENT | PRF_ERASEBKGND);
    BitBlt(hdc, x, y, cx, cy, hdcOff, x, y, SRCCOPY);
    ReleaseDC(plv->ci.hwnd, hdc);
    DeleteDC(hdcOff);
    DeleteObject(hbmpOff);
}

void NEAR ListView_OnPaint(LV* plv, HDC hdc)
{
    PAINTSTRUCT ps;
    RECT rcUpdate;


    // Before handling WM_PAINT, go ensure everything's recomputed...
    //
    if (plv->rcView.left == RECOMPUTE)
        ListView_Recompute(plv);

    // If we're in report view, update the header window: it looks
    // better this way...
    //
    if (ListView_IsReportView(plv) && plv->hwndHdr)
        UpdateWindow(plv->hwndHdr);

    // If nothing to do (i.e., we recieved a WM_PAINT because
    // of an RDW_INTERNALPAINT, and we didn't invalidate anything)
    // don't bother with the Begin/EndPaint.
    //
    if (hdc || GetUpdateRect(plv->ci.hwnd, &rcUpdate, FALSE))
    {
        if (!(plv->flags & LVF_VISIBLE)) {
            plv->flags |= LVF_VISIBLE;
            // We may try to resize the column
            ListView_MaybeResizeListColumns(plv, 0, ListView_Count(plv)-1);
            ListView_UpdateScrollBars(plv);
        }

        // this needs to be done before the beginpaint because it clears
        // out the update region
        if (!(plv->flags & LVF_REDRAW)) {
            // add this region to our local invalidate region
            HRGN hrgn = CreateRectRgn(0, 0, 0,0);
            if (hrgn) {

                // ok if GetUpdateRgn fails... then hrgn will still be
                // and empty region..
                GetUpdateRgn(plv->ci.hwnd, hrgn, FALSE);
                ListView_InvalidateRegion(plv, hrgn);
            }
        }

        if (hdc)
        {
            InitBrushOrg(plv, hdc);
            SetRect(&ps.rcPaint, 0, 0, plv->sizeClient.cx, plv->sizeClient.cy);
            if (ListView_RedrawEnabled(plv))
                ListView_Redraw(plv, hdc, &ps.rcPaint);
        }
        else
        {
            hdc = BeginPaint(plv->ci.hwnd, &ps);
            InitBrushOrg(plv, hdc);
            if (ListView_RedrawEnabled(plv))
                ListView_Redraw(plv, hdc, &ps.rcPaint);
            EndPaint(plv->ci.hwnd, &ps);
        }
    }
}

void ListView_DrawSimpleBackground(LV *plv, HDC hdc, RECT *prcClip)
{
    if (plv->clrBk != CLR_NONE)
    {
        //
        // We just have a simple background color.
        //
        FillRect(hdc, prcClip, plv->hbrBk);
    }
    else
    {
        //
        // Parent HWND draws the background for us.
        //
        SendMessage(plv->ci.hwndParent, WM_ERASEBKGND, (WPARAM)hdc, 0);
    }
}

void ListView_DrawBackground(LV *plv, HDC hdc, RECT *prcClip)
{
    HRGN hrgnClipSave;
    RECT rcClip;

    // Optimize the common/simple case
    if (!(plv->pImgCtx && plv->fImgCtxComplete))
    {
        ListView_DrawSimpleBackground(plv, hdc, prcClip);
        return;
    }

    //
    // Save the old clipping region,
    // since we whack on it a lot.
    //
    hrgnClipSave = CreateRectRgnIndirect(prcClip);
    if (hrgnClipSave)
    {
        if (GetClipRgn(hdc, hrgnClipSave) <= 0)
        {
            DeleteObject(hrgnClipSave);
            hrgnClipSave = NULL;
        }
    }

    //
    // Clip the clipping region to the caller's rectangle,
    // and save the final clipping rectangle in rcClip.
    //
    if (prcClip != NULL)
    {
        IntersectClipRect(hdc, prcClip->left, prcClip->top,
                               prcClip->right, prcClip->bottom);
    }
    GetClipBox(hdc, &rcClip);

    //
    // If we have an image to draw, go draw it and
    // exclue it from the clipping region.
    //
    if (plv->pImgCtx && plv->fImgCtxComplete)
    {
        RECT rcImage, rcClient;
        ULONG ulState;
        SIZE sizeImg;
        POINT ptBackOrg;

        //
        // Compute ptBackOrg (aka scrolling offset), based on view style.
        //
        switch (plv->ci.style & LVS_TYPEMASK)
        {
            case LVS_LIST:
                ptBackOrg.x = -plv->xOrigin;
                ptBackOrg.y = 0;
                break;

            case LVS_REPORT:
                ptBackOrg.x = -plv->ptlRptOrigin.x;
                ptBackOrg.y = -plv->ptlRptOrigin.y + plv->yTop;
                break;

            default:
                ptBackOrg.x = -plv->ptOrigin.x;
                ptBackOrg.y = -plv->ptOrigin.y;
                break;
        }

        ListView_Realize(plv, hdc, TRUE, FALSE);

        switch (plv->ulBkImageFlags & LVBKIF_STYLE_MASK)
        {
        case LVBKIF_STYLE_TILE:
            IImgCtx_Tile(plv->pImgCtx, hdc, &ptBackOrg, prcClip, NULL);
            ExcludeClipRect(hdc, prcClip->left, prcClip->top,
                                 prcClip->right, prcClip->bottom);
            break;

#if 0
        case LVBKIF_STYLE_STRETCH:
            //
            // Stretch the image to the extents of the client & view areas.
            //
            GetClientRect(plv->ci.hwnd, &rcImage);
            UnionRect(&rcImage, &rcImage, &plv->rcView);

            //
            // Adjust for ptBackOrg (scrolling offset).
            //
            rcImage.left += ptBackOrg.x;
            rcImage.top += ptBackOrg.y;
            rcImage.right += ptBackOrg.x;
            rcImage.bottom += ptBackOrg.y;

            //
            // Draw the image, if necessary.
            //
            if (RectVisible(hdc, &rcImage))
            {
                IImgCtx_Draw(plv->pImgCtx, hdc, &rcImage);
                ExcludeClipRect(hdc, prcClip->left, prcClip->top,
                                     prcClip->right, prcClip->bottom);
            }
            break;
#endif
        case LVBKIF_STYLE_NORMAL:
            //
            // Start with the base image.
            //
            IImgCtx_GetStateInfo(plv->pImgCtx, &ulState, &sizeImg, FALSE);
            rcImage.left = 0;
            rcImage.top = 0;
            rcImage.right = sizeImg.cx;
            rcImage.bottom = sizeImg.cy;

            //
            // Adjust for caller offsets.
            //
            GetClientRect(plv->ci.hwnd, &rcClient);
            if (plv->xOffsetPercent)
            {
                LONG dx = plv->xOffsetPercent * (rcClient.right - sizeImg.cx) / 100;

                rcImage.left += dx;
                rcImage.right += dx;
            }
            if (plv->yOffsetPercent)
            {
                LONG dy = plv->yOffsetPercent * (rcClient.bottom - sizeImg.cy) / 100;

                rcImage.top += dy;
                rcImage.bottom += dy;
            }

            //
            // Adjust for ptBackOrg (scrolling offset).
            //
            rcImage.left += ptBackOrg.x;
            rcImage.top += ptBackOrg.y;
            rcImage.right += ptBackOrg.x;
            rcImage.bottom += ptBackOrg.y;

            //
            // Draw the image, if necessary.
            //
            if (RectVisible(hdc, &rcImage))
            {
                IImgCtx_Draw(plv->pImgCtx, hdc, &rcImage);
                ExcludeClipRect(hdc, rcImage.left, rcImage.top,
                                     rcImage.right, rcImage.bottom);
            }
            break;
        }
    }

    //
    // Now draw the rest of the background.
    //
    if (RectVisible(hdc, prcClip))
    {
        ListView_DrawSimpleBackground(plv, hdc, prcClip);
    }

    //
    // Restore old clipping region.
    //
    SelectClipRgn(hdc, hrgnClipSave);
    if (hrgnClipSave)
    {
        DeleteObject(hrgnClipSave);
    }
}

BOOL NEAR ListView_OnEraseBkgnd(LV *plv, HDC hdc)
{
    RECT rcClip;

    // Regional listviews only need to erase if we're on a slow machine
    if (!(plv->exStyle & LVS_EX_REGIONAL) || g_fSlowMachine) {
        //
        // We draw our own background, erase with it.
        //
        GetClipBox(hdc, &rcClip);
        ListView_DrawBackground(plv, hdc, &rcClip);
    }

    return TRUE;
}

void NEAR ListView_OnCommand(LV* plv, int id, HWND hwndCtl, UINT codeNotify)
{
    if (hwndCtl == plv->hwndEdit)
    {
        switch (codeNotify)
        {
        case EN_UPDATE:
#if defined(FE_IME) || !defined(WINNT)
            // We don't want flicker during replacing current selection
            // as we use selection for IME composition.
            //
            if ((g_fDBCSInputEnabled) && (plv->flags & LVF_INSERTINGCOMP))
                break;
#endif
            // We will use the ID of the window as a Dirty flag...
            if (IsWindowVisible(plv->hwndEdit)) {
                SetWindowID(plv->hwndEdit, 1);
                ListView_SetEditSize(plv);
            }
            break;

        case EN_KILLFOCUS:
            // We lost focus, so dismiss edit and save changes
            // (Note that the owner might reject the change and restart
            // edit mode, which traps the user.  Owners need to give the
            // user a way to get out.)
            //
#if 0       // BUGBUG raymondc v6.0
            //
            //  Fix horrible undocumented hanging problem:  LVN_ENDLABELEDIT
            //  is sent in response to EN_KILLFOCUS, which is send in response
            //  to WM_KILLFOCUS, and it is undocumented that you cannot display
            //  UI during WM_KILLFOCUS when a journal record hook is active,
            //  because the presence of a hook forces serialization of activation,
            //  and so when you put up UI, you generate activation changes, which
            //  get stuck because you haven't finished responding to the previous
            //  WM_KILLFOCUS message yet.
            //
            //  See NT bug 414634.
            //
            if (InSendMessage())
                ReplyMessage(0);
#endif
             if (!ListView_DismissEdit(plv, FALSE))
                return;
             break;

         case HN_BEGINDIALOG:  // pen windows is bringing up a dialog
             ASSERT(GetSystemMetrics(SM_PENWINDOWS)); // only on a pen system
             plv->fNoDismissEdit = TRUE;
             break;

         case HN_ENDDIALOG: // pen windows has destroyed dialog
             ASSERT(GetSystemMetrics(SM_PENWINDOWS)); // only on a pen system
             plv->fNoDismissEdit = FALSE;
             break;
        }

        // Forward edit control notifications up to parent
        //
        if (IsWindow(hwndCtl))
            FORWARD_WM_COMMAND(plv->ci.hwndParent, id, hwndCtl, codeNotify, SendMessage);
    }
}

void NEAR ListView_OnWindowPosChanged(LV* plv, const WINDOWPOS FAR* lpwpos)
{
    if (!lpwpos || !(lpwpos->flags & SWP_NOSIZE))
    {
        RECT rc;

        int iOldSlots;

        if (ListView_IsOwnerData(plv) &&
                (ListView_IsSmallView(plv) || ListView_IsIconView(plv)))
        {
            iOldSlots = ListView_GetSlotCount(plv, TRUE);
        }

        GetClientRect(plv->ci.hwnd, &rc);
        plv->sizeClient.cx = rc.right;
        plv->sizeClient.cy = rc.bottom;

        if ((plv->ci.style & LVS_AUTOARRANGE) &&
                (ListView_IsSmallView(plv) || ListView_IsIconView(plv)))
        {
            // Call off to the arrange function.
            ListView_OnArrange(plv, LVA_DEFAULT);
        }

        if (ListView_IsOwnerData(plv))
        {
            plv->rcView.left = RECOMPUTE;
            ListView_Recompute(plv);

            ListView_DismissEdit(plv, FALSE);
            if (ListView_IsSmallView(plv) || ListView_IsIconView(plv))
            {
                // Uses the
                int iNewSlots = ListView_GetSlotCount(plv, TRUE);
                if ((iNewSlots != iOldSlots) && (ListView_Count(plv) > min(iNewSlots, iOldSlots)))
                    RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
            }
        }

        ListView_RInitialize(plv, TRUE);

        // Always make sure the scrollbars are updated to the new size
        ListView_UpdateScrollBars(plv);
    }
}


void ListView_InvalidateSelectedOrCutOwnerData(LV* plv, ILVRange *plvrangeSel)
{
    UINT rdwFlags = RDW_INVALIDATE;
    int cItem = ListView_Count( plv );
    DWORD dwType = plv->ci.style & LVS_TYPEMASK;
    int i;
    RECT rcView;

    ASSERT(ListView_IsOwnerData(plv));
    ASSERT(plv );

    GetClientRect( plv->ci.hwnd, &rcView );

    if (plv->clrTextBk == CLR_NONE
        || (plv->himl && (plv->clrBk != ImageList_GetBkColor(plv->himl)))) {
        // always do an erase, otherwise the text background won't paint right
        rdwFlags |= RDW_ERASE;
    }

    // calculate start of items and end of items visible on the view
    //
    switch (dwType)
    {
    case LVS_REPORT:
        i = ListView_RYHitTest(plv, rcView.top);
        cItem = ListView_RYHitTest(plv, rcView.bottom) + 1;
        break;

    case LVS_LIST:
      i = ListView_LCalcViewItem(plv, rcView.left, rcView.top );
      cItem = ListView_LCalcViewItem( plv, rcView.right, rcView.bottom ) + 1;
        break;

   default:
        ListView_CalcMinMaxIndex( plv, &rcView, &i, &cItem );
        break;
    }

   i = max( i, 0 );

   cItem = min( ListView_Count( plv ), cItem );
    if (cItem > i)
    {
        ListView_NotifyCacheHint( plv, i, cItem-1 );
    }

    for (; i < cItem; i++)
    {
        if (plvrangeSel->lpVtbl->IsSelected(plvrangeSel, i ) == S_OK)
        {
            ListView_InvalidateItem(plv, i, FALSE, rdwFlags);
        }
    }
}

void NEAR ListView_RedrawSelection(LV* plv)
{

    if (ListView_IsOwnerData(plv)) {
        ListView_InvalidateSelectedOrCutOwnerData( plv, plv->plvrangeSel );

    } else {

        int i = -1;

        while ((i = ListView_OnGetNextItem(plv, i, LVNI_SELECTED)) != -1) {
            ListView_InvalidateItem(plv, i, TRUE, RDW_INVALIDATE);
        }


        if (ListView_IsReportView(plv)) {
            int iEnd = ListView_RYHitTest(plv, plv->sizeClient.cy) + 1;

            iEnd = min(iEnd, ListView_Count(plv));

            // if we're in report mode, sub items may have selection focus
            for (i = ListView_RYHitTest(plv, 0); i < iEnd; i++) {
                int iCol;

                for (iCol = 1; iCol < plv->cCol; iCol++) {
                    LISTSUBITEM lsi;
                    ListView_GetSubItem(plv, i, iCol, &lsi);
                    if (lsi.state & LVIS_SELECTED) {
                        ListView_InvalidateItem(plv, i, FALSE, RDW_INVALIDATE);
                    }
                    break;
                }
            }
        }
    }

    UpdateWindow( plv->ci.hwnd );
}

void NEAR ListView_OnSetFocus(LV* plv, HWND hwndOldFocus)
{
    ASSERT(gcWheelDelta == 0);

    // due to the way listview call SetFocus on themselves on buttondown,
    // the window can get a strange sequence of focus messages: first
    // set, then kill, and then set again.  since these are not really
    // focus changes, ignore them and only handle "real" cases.
    //
    // But still send out the accessibility notification because USER
    // has already pushed focus back to the listview instead of to the
    // focus item.

    if (hwndOldFocus == plv->ci.hwnd)
    {
        ListView_NotifyFocusEvent(plv);
        return;
    }

    plv->flags |= LVF_FOCUSED | LVF_UNFOLDED;
    if (IsWindowVisible(plv->ci.hwnd))
    {
        if (plv->iFocus != -1)
        {
            ListView_InvalidateItem(plv, plv->iFocus, TRUE, RDW_INVALIDATE);
            ListView_NotifyFocusEvent(plv);
        }

        ListView_RedrawSelection(plv);
    }

    // Let the parent window know that we are getting the focus.
    CCSendNotify(&plv->ci, NM_SETFOCUS, NULL);
}

void NEAR ListView_OnKillFocus(LV* plv, HWND hwndNewFocus)
{
    // Reset wheel scroll amount
    gcWheelDelta = 0;

    // due to the way listview call SetFocus on themselves on buttondown,
    // the window can get a strange sequence of focus messages: first
    // set, then kill, and then set again.  since these are not really
    // focus changes, ignore them and only handle "real" cases.
    if (!plv || hwndNewFocus == plv->ci.hwnd)
        return;

    plv->flags &= ~(LVF_FOCUSED|LVF_UNFOLDED);

    // Blow this off if we are not currently visible (being destroyed!)
    if (IsWindowVisible(plv->ci.hwnd))
    {
        if (plv->iFocus != -1)
        {
            UINT fRedraw = RDW_INVALIDATE;
            if (plv->clrTextBk == CLR_NONE)
                fRedraw |= RDW_ERASE;
            ListView_InvalidateFoldedItem( plv, plv->iFocus, TRUE, fRedraw );
        }
        ListView_RedrawSelection(plv);
    }

    // Let the parent window know that we are losing the focus.
    CCSendNotify(&plv->ci, NM_KILLFOCUS, NULL);
    IncrementSearchString(&plv->is, 0, NULL);
}

void NEAR ListView_DeselectAll(LV* plv, int iDontDeselect)
{
    int i = -1;
    int nSkipped = 0;
    BOOL fWasSelected = FALSE;

    if (iDontDeselect != -1) {
        if (ListView_OnGetItemState(plv, iDontDeselect, LVIS_SELECTED))
            fWasSelected = TRUE;
    }

    if (ListView_IsOwnerData(plv)) {

        // if there's only one item selected, and that item is the iDontDeselect
        // then our work is done...
        plv->plvrangeSel->lpVtbl->CountIncluded(plv->plvrangeSel, &plv->nSelected);
        if (plv->nSelected == 1 && fWasSelected)
            return;

        ListView_InvalidateSelectedOrCutOwnerData(plv, plv->plvrangeSel);

        ListView_OnSetItemState(plv, -1, 0, LVIS_SELECTED);
        if (fWasSelected) {
            ListView_OnSetItemState(plv, iDontDeselect, LVIS_SELECTED, LVIS_SELECTED);
            nSkipped = 1;
        }

   } else {

       if (iDontDeselect != plv->iFocus) {
           ListView_OnSetItemState(plv, plv->iFocus, 0, LVIS_SELECTED);
       }

       while ((plv->nSelected - nSkipped) && (i = ListView_OnGetNextItem(plv, i, LVNI_SELECTED)) != -1) {
           if (i != iDontDeselect) {
               ListView_OnSetItemState(plv, i, 0, LVIS_SELECTED);
           } else {
               if (fWasSelected) {
                   nSkipped++;
               }
           }
       }
    }

    ASSERT((plv->nSelected - nSkipped) == 0);
    plv->nSelected = nSkipped;
}

// toggle the selection state of an item

void NEAR ListView_ToggleSelection(LV* plv, int iItem)
{
    UINT cur_state;
    if (iItem != -1) {
        cur_state = ListView_OnGetItemState(plv, iItem, LVIS_SELECTED);
        ListView_OnSetItemState(plv, iItem, cur_state ^ LVIS_SELECTED, LVIS_SELECTED);
    }
}

// Selects (or toggles) a range of items in the list.
//      The curent iFocus is the starting location
//      iItem - is the ending item
//      fToggle - Well set all of the selection state of all of the items to
//          inverse the starting location
//
void NEAR ListView_SelectRangeTo(LV* plv, int iItem, BOOL fResetRest)
{
    int iMin, iMax;
    int i = -1;
    UINT uSelVal = LVIS_SELECTED;


    if (plv->iMark == -1)
    {
        ListView_SetFocusSel(plv, iItem, TRUE, TRUE, FALSE);
        return;
    }

    if (!fResetRest)
        uSelVal = ListView_OnGetItemState(plv, plv->iMark, LVIS_SELECTED);

    // If we are in report view or list view we simply walk through the
    // indexes to see which items to select or deselect. otherwise it
    // is is based off of the location of the objects being within the
    // rectangle that is defined by
    if (ListView_IsListView(plv) || ListView_IsReportView(plv))
    {
        iMin = min(iItem, plv->iMark);
        iMax = max(iItem, plv->iMark);

        if (ListView_IsOwnerData( plv )) {

            if (fResetRest)
            {
                ListView_DeselectAll( plv, -1 );
            }

            if (iMax > iMin)
            {
                if (LVIS_SELECTED & uSelVal)
                {
                    if (FAILED(plv->plvrangeSel->lpVtbl->IncludeRange(plv->plvrangeSel, iMin, iMax )))
                        return;
                }
                else
                {
                    if (FAILED(plv->plvrangeSel->lpVtbl->ExcludeRange(plv->plvrangeSel, iMin, iMax )))
                        return;
                }
                ListView_SendODChangeAndInvalidate(plv, iMin, iMax, uSelVal ^ LVIS_SELECTED, uSelVal);
            }
            else
            {
                ListView_OnSetItemState(plv, iMin, uSelVal, LVIS_SELECTED);
            }

        }
        else
        {
            if (fResetRest)
            {
                while ((i = ListView_OnGetNextItem(plv, i, LVNI_SELECTED)) != -1)
                {
                    if (i < iMin || i > iMax)
                        ListView_OnSetItemState(plv, i, 0, LVIS_SELECTED);
                }
            }

            while (iMin <= iMax)
            {
                ListView_OnSetItemState(plv, iMin, uSelVal, LVIS_SELECTED);
                iMin++;
            }
        }
    }
    else
    {
        // Iconic views first calculate the bounding rectangle of the two
        // items.
        RECT    rcTemp;
        RECT    rcTemp2;
        RECT    rcBounding;
        POINT   pt;         //

        ListView_GetRects(plv, plv->iMark, NULL, NULL, NULL, &rcTemp);
        ListView_GetRects(plv, iItem, NULL, NULL, NULL, &rcTemp2);
        UnionRect(&rcBounding, &rcTemp, &rcTemp2);

        // since ownerdata icon views are always arranged, we can assume that
        // all items are in order and we can search only those between the
        // indexes found using the bouding rect
        //
        if (ListView_IsOwnerData( plv ))
        {
            ListView_CalcMinMaxIndex( plv, &rcBounding, &iMin, &iMax );
            if (fResetRest)
            {
              ListView_DeselectAll( plv, -1 );
            }

            iMax = min( iMax, ListView_Count( plv ) );
            iMin = max( iMin, 0 );

        }
        else
        {
           iMax = ListView_Count(plv);
           iMin = 0;

        }

        if (ListView_IsOwnerData(plv)  && (iMax > iMin))
        {
            if (LVIS_SELECTED & uSelVal)
            {
                if (FAILED(plv->plvrangeSel->lpVtbl->IncludeRange(plv->plvrangeSel, iMin, iMax - 1 )))
                    return;
            }
            else
            {
                if (FAILED(plv->plvrangeSel->lpVtbl->ExcludeRange(plv->plvrangeSel, iMin, iMax - 1 )))
                    return;
            }

            ListView_SendODChangeAndInvalidate(plv, iMin, iMax, uSelVal ^ LVIS_SELECTED, uSelVal);

        } else {

            for (i = iMin; i < iMax; i++)
            {
                ListView_GetRects(plv, i, NULL, NULL, NULL, &rcTemp2);
                pt.x = (rcTemp2.right + rcTemp2.left) / 2;  // center of item
                pt.y = (rcTemp2.bottom + rcTemp2.top) / 2;

                if (PtInRect(&rcBounding, pt))
                {
                  int iZ;

                  if (!ListView_IsOwnerData( plv ))
                  {
                      iZ = ListView_ZOrderIndex(plv, i);

                      if (iZ > 0)
                          DPA_InsertPtr(plv->hdpaZOrder, 0, DPA_DeletePtr(plv->hdpaZOrder, iZ));
                  }

                      ListView_OnSetItemState(plv, i, uSelVal, LVIS_SELECTED);
                }
                else if (fResetRest)
                    ListView_OnSetItemState(plv, i, 0, LVIS_SELECTED);
            }
        }
    }
}

// makes an item the focused item and optionally selects it
//
// in:
//      iItem           item to get the focus
//      fSelectAlso     select this item as well as set it as the focus
//      fDeselectAll    deselect all items first
//      fToggleSel      toggle the selection state of the item
//
// returns:
//      index of focus item (if focus change was refused)

// Bugbug::this is getting to have a lot of parameters
int NEAR ListView_SetFocusSel(LV* plv, int iItem, BOOL fSelectAlso,
        BOOL fDeselectAll, BOOL fToggleSel)
{
    int iFocus = plv->iFocus;

    // if we're single sel mode, don't bother with this because
    // the set item will do it for us
    if (!(plv->ci.style & LVS_SINGLESEL) && (fDeselectAll))
        ListView_DeselectAll(plv, -1);

    if (iItem != plv->iFocus)
    {
        // remove the old focus
        if (plv->iFocus != -1)
        {
            // If he refuses to give up the focus, bail out.
            if (!ListView_OnSetItemState(plv, plv->iFocus, 0, LVIS_FOCUSED))
                return plv->iFocus;
        }
    }

   if (!ListView_IsOwnerData( plv )) {

       if (fSelectAlso)
       {
           if (ListView_IsIconView(plv) || ListView_IsSmallView(plv))
           {
               int iZ = ListView_ZOrderIndex(plv, iItem);

               if (iZ > 0)
                   DPA_InsertPtr(plv->hdpaZOrder, 0, DPA_DeletePtr(plv->hdpaZOrder, iZ));
           }
       }
    }

    /* Ensure that when moving focus that we refresh the previous focus
     owner properly. */

    if (iFocus != -1 && iFocus != plv->iFocus && ( plv->flags & LVF_UNFOLDED ) )
        ListView_InvalidateFoldedItem( plv, iFocus, FALSE, RDW_INVALIDATE );

    if (plv->iMark == -1)
        plv->iMark = iItem;

    SetTimer(plv->ci.hwnd, IDT_SCROLLWAIT, GetDoubleClickTime(), NULL);
    plv->flags |= LVF_SCROLLWAIT;

    if (fToggleSel)
    {
        ListView_ToggleSelection(plv, iItem);
        ListView_OnSetItemState(plv, iItem, LVIS_FOCUSED, LVIS_FOCUSED);
    }
    else
    {
        UINT flags;

        flags = ((fSelectAlso || plv->ci.style & LVS_SINGLESEL) ?
                 (LVIS_SELECTED | LVIS_FOCUSED) : LVIS_FOCUSED);
        ListView_OnSetItemState(plv, iItem, flags, flags);
    }

    return iItem;
}

UINT GetLVKeyFlags()
{
    UINT uFlags = 0;

    if (GetKeyState(VK_MENU) < 0)
        uFlags |= LVKF_ALT;
    if (GetKeyState(VK_CONTROL) < 0)
        uFlags |= LVKF_CONTROL;
    if (GetKeyState(VK_SHIFT) < 0)
        uFlags |= LVKF_SHIFT;

    return uFlags;
}

void NEAR ListView_OnKey(LV* plv, UINT vk, BOOL fDown, int cRepeat, UINT flags)
{
    UINT lvni = 0;
    int iNewFocus;
    BOOL fCtlDown;
    BOOL fShiftDown;
    LV_KEYDOWN nm;
    HWND hwnd = plv->ci.hwnd;

    if (!fDown)
        return;

    // Swap the left and right arrow key if the control is mirrored.
    vk = RTLSwapLeftRightArrows(&plv->ci, vk);

    //prevent any change in selected items before the dbl click timer goes off
    //so that we don't launch wrong item(s)
    if (plv->exStyle & LVS_EX_ONECLICKACTIVATE && plv->fOneClickHappened && plv->fOneClickOK)
    {
        //if a key is pressed with a mouse click with one click activate and double click
        //timer, we end up setting up a timer and then processing the keydown
        //this causes an item to be launched right away (from this code) and in case
        //of return being pressed it causes double activation
        //prevent these cases:
        if (vk == VK_SHIFT || vk == VK_CONTROL || vk == VK_MENU || vk == VK_RETURN)
            return;
        KillTimer(plv->ci.hwnd, IDT_ONECLICKHAPPENED);
        plv->fOneClickHappened = FALSE;
        CCSendNotify(&plv->ci, LVN_ITEMACTIVATE, &(plv->nmOneClickHappened.hdr));
        if (!IsWindow(hwnd))
            return;
    }

    // Notify
    nm.wVKey = (WORD) vk;
    nm.flags = flags;
    if (CCSendNotify(&plv->ci, LVN_KEYDOWN, &nm.hdr)) {
        plv->iPuntChar++;
        return;
    } else if (plv->iPuntChar) {
        // this is tricky...  if we want to punt the char, just increment the
        // count.  if we do NOT, then we must clear the queue of WM_CHAR's
        // this is to preserve the iPuntChar to mean "punt the next n WM_CHAR messages
        MSG msg;
        while(plv->iPuntChar && PeekMessage(&msg, plv->ci.hwnd, WM_CHAR, WM_CHAR, PM_REMOVE)) {
            plv->iPuntChar--;
        }
        ASSERT(!plv->iPuntChar);
    }

    if (ListView_Count(plv) == 0)   // don't blow up on empty list
        return;

    fCtlDown = GetKeyState(VK_CONTROL) < 0;
    fShiftDown = GetKeyState(VK_SHIFT) < 0;

    switch (vk)
    {
    case VK_SPACE:
#ifdef DEBUG
        if (fCtlDown && fShiftDown) {
            SendMessage(plv->ci.hwnd, LVM_SETEXTENDEDLISTVIEWSTYLE, 0,
                        (SendMessage(plv->ci.hwnd, LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0) ^ LVS_EX_GRIDLINES) | LVS_EX_CHECKBOXES);
        }
#endif

        // If shift (extend) or control (disjoint) select,
        // then toggle selection state of focused item.
        if (fCtlDown)
        {
            plv->iMark = plv->iFocus;
            ListView_ToggleSelection(plv, plv->iFocus);
            plv->iPuntChar++;
        }

        // BUGBUG: Implement me
        if ( fShiftDown) {
            ListView_SelectRangeTo(plv, plv->iFocus, TRUE);
        }

        if (ListView_CheckBoxes(plv)) {
            if (plv->iFocus != -1)
                ListView_HandleStateIconClick(plv, plv->iFocus);
        }
#ifdef KEYBOARDCUES
        //notify of navigation key usage
        CCNotifyNavigationKeyUsage(&(plv->ci), UISF_HIDEFOCUS);
#endif
        return;
    case VK_RETURN:
#ifdef DEBUG
        if (fCtlDown && fShiftDown) {
            if (plv->iFocus != -1) {
                LV_ITEM lvi;
                lvi.iSubItem = 1;
                lvi.iItem = plv->iFocus;
                lvi.iImage = 3;
                lvi.state = LVIS_SELECTED;
                lvi.stateMask = LVIS_SELECTED;
                lvi.mask = LVIF_STATE | LVIF_IMAGE;
                SendMessage(plv->ci.hwnd, LVM_SETITEM, 0, (LPARAM)&lvi);
            }
            return;
        }
#endif
        CCSendNotify(&plv->ci, NM_RETURN, NULL);

        /// some (comdlg32 for example) destroy on double click
        // we need to bail if that happens because plv is no longer valid
        if (!IsWindow(hwnd))
            return;

        {
            NMITEMACTIVATE nm;

            nm.iItem = plv->iFocus;
            nm.iSubItem = 0;
            nm.uChanged = 0;
            nm.ptAction.x = -1;
            nm.ptAction.y = -1;
            nm.uKeyFlags = GetLVKeyFlags();
            CCSendNotify(&plv->ci, LVN_ITEMACTIVATE, &nm.hdr);
            if (!IsWindow(hwnd))
                return;
        }
#ifdef KEYBOARDCUES
        //notify of navigation key usage
        CCNotifyNavigationKeyUsage(&(plv->ci), UISF_HIDEFOCUS);
#endif
        return;

    case VK_ADD:
        if (ListView_IsReportView(plv) && (GetKeyState(VK_CONTROL) < 0))
        {
            HCURSOR hcurPrev;
            int i;

            hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));
            for (i=0; i < plv->cCol; i++)
            {
                ListView_RSetColumnWidth(plv, i, -1);
            }

            SetCursor(hcurPrev);
#ifdef KEYBOARDCUES
            //notify of navigation key usage
            CCNotifyNavigationKeyUsage(&(plv->ci), UISF_HIDEFOCUS);
#endif
            return;
        }
    }

    if (GetKeyState(VK_MENU) < 0)
        return;

    // For a single selection listview, disable extending the selection
    // by turning off the keyboard modifiers.
    if (plv->ci.style & LVS_SINGLESEL) {
        fCtlDown = FALSE;
        fShiftDown = FALSE;
    }

    //
    // Let the Arrow function attempt to process the key.
    //
    iNewFocus = ListView_Arrow(plv, plv->iFocus, vk);

    // If control (disjoint) selection, don't change selection.
    // If shift (extend) or control selection, don't deselect all.
    //
    if (iNewFocus != -1) {
        if (fShiftDown)
        {
            ListView_SelectRangeTo(plv, iNewFocus, TRUE);
            ListView_SetFocusSel(plv, iNewFocus, FALSE, FALSE, FALSE);
        }
        else {
            if (!fCtlDown)
                plv->iMark = iNewFocus;
            ListView_SetFocusSel(plv, iNewFocus, !fCtlDown, !fShiftDown && !fCtlDown, FALSE);
        }
        IncrementSearchString(&plv->is, 0, NULL);
        CCPlaySound(c_szSelect);
    }

    // on keyboard movement, scroll immediately.
    if (ListView_CancelScrollWait(plv)) {
        ListView_OnEnsureVisible(plv, plv->iFocus, FALSE);
        UpdateWindow(plv->ci.hwnd);
    }
#ifdef KEYBOARDCUES
    //notify of navigation key usage
    CCNotifyNavigationKeyUsage(&(plv->ci), UISF_HIDEFOCUS);
#endif
}

//
//  LVN_INCREMENTALSEARCH gives the app the opportunity to customize
//  incremental search.  For example, if the items are numeric,
//  the app can do numerical search instead of string search.
//
//  App sets pnmfi->lvfi.lParam to the result of the incremental search,
//  or to -2 to fai the search and just beep.
//
//  App can return 2 to indicate that all processing should stop, if
//  app wants to take over incremental search completely.
//
BOOL ListView_IncrementalSearch(LV *plv, int iStartFrom, LPNMLVFINDITEM pnmfi, int *pi)
{
    INT_PTR fRc;

    ASSERT(!(pnmfi->lvfi.flags & LVFI_PARAM));
    pnmfi->lvfi.lParam = -1;

    fRc = CCSendNotify(&plv->ci, LVN_INCREMENTALSEARCH, &pnmfi->hdr);
    *pi = (int)pnmfi->lvfi.lParam;

    // Cannot just return fRc because some apps return 1 to all WM_NOTIFY's
    return fRc == 2;
}

#if defined(FE_IME)
// Now only Korean version is interested in incremental search with composition string.
LPTSTR GET_COMP_STRING(HIMC hImc, DWORD dwFlags)
{
    LONG iNumComp;
    PTSTR pszCompStr;
    iNumComp = ImmGetCompositionString(hImc, dwFlags, NULL, 0);
    pszCompStr = (PTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*(iNumComp+1));
    if (pszCompStr)
    {
        if (iNumComp)
            ImmGetCompositionString(hImc, dwFlags, pszCompStr, iNumComp+1);
        pszCompStr[iNumComp] = TEXT('\0');
    }
    return pszCompStr;
}

#define FREE_COMP_STRING(pszCompStr)    LocalFree((HLOCAL)(pszCompStr))

BOOL NEAR ListView_OnImeComposition(LV* plv, WPARAM wParam, LPARAM lParam)
{
    LPTSTR lpsz;
    NMLVFINDITEM nmfi;
    int i;
    int iStartFrom = -1;
    int iLen;
    int iCount;
    HIMC hImc;
    TCHAR *pszCompStr;
    BOOL fRet = TRUE;

    iCount = ListView_Count(plv);

    if (!iCount || plv->iFocus == -1)
        return fRet;

    if (hImc = ImmGetContext(plv->ci.hwnd))
    {
        if (lParam & GCS_RESULTSTR)
        {
            fRet = FALSE;
            pszCompStr = GET_COMP_STRING(hImc, GCS_RESULTSTR);
            if (pszCompStr)
            {
                IncrementSearchImeCompStr(&plv->is, FALSE, pszCompStr, &lpsz);
                FREE_COMP_STRING(pszCompStr);
            }
        }
        if (lParam & GCS_COMPSTR)
        {
            fRet = TRUE;
            pszCompStr = GET_COMP_STRING(hImc, GCS_COMPSTR);
            if (pszCompStr)
            {
                if (IncrementSearchImeCompStr(&plv->is, TRUE, pszCompStr, &lpsz))
                    iStartFrom = plv->iFocus;
                else
                    iStartFrom = ((plv->iFocus - 1) + iCount)% iCount;

                nmfi.lvfi.flags = LVFI_SUBSTRING | LVFI_STRING | LVFI_WRAP;
                nmfi.lvfi.psz = lpsz;
                iLen = lstrlen(lpsz);

                // special case space as the first character
                if ((iLen == 1) && (*lpsz == TEXT(' '))) {
                    if (plv->iFocus != -1) {
                        ListView_OnSetItemState(plv, plv->iFocus, LVIS_SELECTED, LVIS_SELECTED);
                        IncrementSearchString(&plv->is, 0, NULL);
                    }
#ifdef KEYBOARDCUES
                    //notify of navigation key usage
                    CCNotifyNavigationKeyUsage(&(plv->ci), UISF_HIDEFOCUS);
#endif
                    return fRet;
                }

                // Give caller full string in case they want to do something custom
                if (ListView_IncrementalSearch(plv, iStartFrom, &nmfi, &i))
                    return fRet;

#ifdef UNICODE
                if (iLen > 0 && SameChars(lpsz, lpsz[0])) {
#else
                if (iLen > 1 && SameDBCSChars(lpsz, (WORD)((BYTE)lpsz[0] << 8 | (BYTE)lpsz[1]))) {
#endif

                    //
                    //  The user has been typing the same char over and over again.
                    //  Switch from incremental search to Windows 3.1 style search.
                    //
                    iStartFrom = plv->iFocus;
                    nmfi.lvfi.psz = lpsz + iLen - 1;
                }

                if (i == -1)
                    i = ListView_OnFindItem(plv, iStartFrom, &nmfi.lvfi);

                if (!ListView_IsValidItemNumber(plv, i)) {
                    i = -1;
                }

#ifdef LVDEBUG
                DebugMsg(TF_LISTVIEW, TEXT("CIme listsearch %d %s %d"), (LPTSTR)lpsz, (LPTSTR)lpsz, i);
#endif

                if (i != -1) {
                    ListView_SetFocusSel(plv, i, TRUE, TRUE, FALSE);
                    plv->iMark = i;
                    if (ListView_CancelScrollWait(plv))
                            ListView_OnEnsureVisible(plv, i, FALSE);
                } else {
                    // Don't beep on spaces, we use it for selection.
                    IncrementSearchBeep(&plv->is);
                }

#ifdef KEYBOARDCUES
                //notify of navigation key usage
                CCNotifyNavigationKeyUsage(&(plv->ci), UISF_HIDEFOCUS);
#endif
                FREE_COMP_STRING(pszCompStr);
            }
        }
        ImmReleaseContext(plv->ci.hwnd, hImc);
    }
    return fRet;
}

#ifndef UNICODE
BOOL FAR PASCAL SameDBCSChars(LPSTR lpsz,  WORD w)
{
    while (*lpsz) {
        if (IsDBCSLeadByte(*lpsz) == FALSE)
            return FALSE;
        if ((WORD)((BYTE)*lpsz++ << 8 | (BYTE)*lpsz++) != w)
            return FALSE;
    }
    return TRUE;
}
#endif
#endif FE_IME

// REVIEW: We will want to reset ichCharBuf to 0 on certain conditions,
// such as: focus change, ENTER, arrow key, mouse click, etc.
//
void NEAR ListView_OnChar(LV* plv, UINT ch, int cRepeat)
{
    LPTSTR lpsz;
    NMLVFINDITEM nmfi;
    int i;
    int iStartFrom = -1;
    int iLen;
    int iCount;

    iCount = ListView_Count(plv);

    if (!iCount || plv->iFocus == -1)
        return;

    // Don't search for chars that cannot be in a file name (like ENTER and TAB)
    // BUGBUG raymondc fix for v6: The Polish keyboard layout uses CTRL+ALT to
    // enter some normal letters, so don't punt if the CTRL key is down or
    // people in Poland are in trouble!
    if (ch < TEXT(' ') || GetKeyState(VK_CONTROL) < 0)
    {
        IncrementSearchString(&plv->is, 0, NULL);
        return;
    }

#ifdef UNICODE_WIN9x
    if (g_fDBCSEnabled && (IsDBCSLeadByteEx(plv->ci.uiCodePage, (BYTE)ch) || plv->uDBCSChar))
    {
        WCHAR wch;

        if (!plv->uDBCSChar)
        {
            // Save DBCS LeadByte character
            plv->uDBCSChar = ch & 0x00ff;
            return;
        }
        else
        {
            // Combine DBCS characters
            plv->uDBCSChar |=  ((ch & 0x00ff) << 8);

            // Convert to UNICODE
            if (MultiByteToWideChar(plv->ci.uiCodePage, MB_ERR_INVALID_CHARS, (LPCSTR)&plv->uDBCSChar, 2, &wch, 1))
            {
                ch = wch;
            }

            plv->uDBCSChar = 0;
        }
    }
    else
    {
        if (ch >= 0x80)     // no need conversion for low ansi character
        {
            WCHAR wch;

            if (MultiByteToWideChar(plv->ci.uiCodePage, 0, (LPCSTR)&ch, 1, &wch, 1))
                ch = wch;
        }
    }
#endif

    if (IncrementSearchString(&plv->is, ch, &lpsz))
        iStartFrom = plv->iFocus;
    else
        iStartFrom = ((plv->iFocus - 1) + iCount)% iCount;

    nmfi.lvfi.flags = LVFI_SUBSTRING | LVFI_STRING | LVFI_WRAP;
    nmfi.lvfi.psz = lpsz;
    iLen = lstrlen(lpsz);

    // special case space as the first character
    if ((iLen == 1) && (*lpsz == ' ')) {
        if (plv->iFocus != -1) {
            ListView_OnSetItemState(plv, plv->iFocus, LVIS_SELECTED, LVIS_SELECTED);
            IncrementSearchString(&plv->is, 0, NULL);
        }
#ifdef KEYBOARDCUES
        //notify of navigation key usage
        CCNotifyNavigationKeyUsage(&(plv->ci), UISF_HIDEFOCUS);
#endif
        return;
    }

    // Give caller full string in case they want to do something custom
    if (ListView_IncrementalSearch(plv, iStartFrom, &nmfi, &i))
        return;

    if (iLen > 0 && SameChars(lpsz, lpsz[0])) {
        //
        //  The user has been typing the same char over and over again.
        //  Switch from incremental search to Windows 3.1 style search.
        //
        iStartFrom = plv->iFocus;
        nmfi.lvfi.psz = lpsz + iLen - 1;
    }

    if (i == -1)
        i = ListView_OnFindItem(plv, iStartFrom, &nmfi.lvfi);

    if (!ListView_IsValidItemNumber(plv, i)) {
        i = -1;
    }

#ifdef LVDEBUG
    DebugMsg(TF_LISTVIEW, TEXT("listsearch %d %s %d"), (LPTSTR)lpsz, (LPTSTR)lpsz, i);
#endif

    if (i != -1) {
        ListView_SetFocusSel(plv, i, TRUE, TRUE, FALSE);
        plv->iMark = i;
        if (ListView_CancelScrollWait(plv))
                ListView_OnEnsureVisible(plv, i, FALSE);
    } else {
        // Don't beep on spaces, we use it for selection.
        IncrementSearchBeep(&plv->is);
    }

#ifdef KEYBOARDCUES
    //notify of navigation key usage
    CCNotifyNavigationKeyUsage(&(plv->ci), UISF_HIDEFOCUS);
#endif
}

BOOL FAR PASCAL SameChars(LPTSTR lpsz, TCHAR c)
{
    while (*lpsz) {
        if (*lpsz++ != c)
            return FALSE;
    }
    return TRUE;
}

UINT NEAR ListView_OnGetDlgCode(LV* plv, MSG FAR* lpmsg)
{
    return DLGC_WANTARROWS | DLGC_WANTCHARS;
}

int ListView_ComputeCYItemSize(LV* plv)
{
    int cy;

    cy = max(plv->cyLabelChar, plv->cySmIcon);

    if (plv->himlState)
        cy = max(cy, plv->cyState);

    cy += g_cyBorder;

    ASSERT(cy);
    return cy;
}

void NEAR ListView_InvalidateCachedLabelSizes(LV* plv)
{
    int i;

    ListView_InvalidateTTLastHit(plv, plv->iTTLastHit);

    // Label wrapping has changed, so we need to invalidate the
    // size of the items, such that they will be recomputed.
    //
    if (!ListView_IsOwnerData( plv ))
    {
        for (i = ListView_Count(plv) - 1; i >= 0; i--)
        {
            LISTITEM FAR* pitem = ListView_FastGetItemPtr(plv, i);
            ListView_SetSRecompute(pitem);
        }
    }
    plv->rcView.left = RECOMPUTE;

    if ((plv->ci.style & LVS_OWNERDRAWFIXED) && ListView_IsReportView(plv))
        plv->cyItemSave = ListView_ComputeCYItemSize(plv);
    else {
        plv->cyItem = ListView_ComputeCYItemSize(plv);
    }
}


int LV_GetNewColWidth(LV* plv, int iFirst, int iLast);

void NEAR ListView_OnStyleChanging(LV* plv, UINT gwl, LPSTYLESTRUCT pinfo)
{
    if (gwl == GWL_STYLE) {
        // Don't allow LVS_OWNERDATA to change after creation
        DWORD stylePreserve = LVS_OWNERDATA;

        // Don't allow a LVS_EX_REGIONAL listview to change type, since
        // it must be LVS_ICON
        if (plv->exStyle & LVS_EX_REGIONAL)
            stylePreserve |= LVS_TYPEMASK;

        // Preserve the bits that must be preserved
        pinfo->styleNew ^= (pinfo->styleNew ^ pinfo->styleOld) & stylePreserve;
    }
}

void NEAR ListView_OnStyleChanged(LV* plv, UINT gwl, LPSTYLESTRUCT pinfo)
{
    // Style changed: redraw everything...
    //
    // try to do this smartly, avoiding unnecessary redraws
    if (gwl == GWL_STYLE)
    {
        BOOL fRedraw = FALSE, fShouldScroll = FALSE;
        DWORD changeFlags, styleOld;

        ListView_DismissEdit(plv, FALSE);   // BUGBUG:  FALSE == apply edits.  Is this correct?

        changeFlags = plv->ci.style ^ pinfo->styleNew;
        styleOld = plv->ci.style;

        // (dli) Setting the small icon width here and only in the case when we go
        // from large icon view to some other view because of three reasons:
        // 1. According to chee, we want to set this before we change the style bit in
        // plv or after we scale.
        // 2. We don't want to do it after we scale because we want to set the width to
        // the maximum value so that the items in this listview do not cover each other
        // 3. we do it from large icon view because large icon view has fixed width for
        // each item, small icon view width can be scaled.
        //
        if ((changeFlags & LVS_TYPEMASK) && ((styleOld & LVS_TYPEMASK) == LVS_ICON))
            ListView_ISetColumnWidth(plv, 0,
                                     LV_GetNewColWidth(plv, 0, ListView_Count(plv)-1), FALSE);

        plv->ci.style = pinfo->styleNew;        // change our version

        if (changeFlags & (WS_BORDER | WS_CAPTION | WS_THICKFRAME)) {
            // the changing of these bits affect the size of the window
            // but not until after this message is handled
            // so post ourself a message.
            PostMessage(plv->ci.hwnd, LVMP_WINDOWPOSCHANGED, 0, 0);
        }

        if (changeFlags & LVS_NOCOLUMNHEADER) {
            if (plv->hwndHdr) {
                SetWindowBits(plv->hwndHdr, GWL_STYLE, HDS_HIDDEN,
                              (plv->ci.style & LVS_NOCOLUMNHEADER) ? HDS_HIDDEN : 0);

                fRedraw = TRUE;
                fShouldScroll = TRUE;
            }
        }


        if (changeFlags & LVS_NOLABELWRAP)
        {
            ListView_InvalidateCachedLabelSizes(plv);
            fShouldScroll = TRUE;
            fRedraw = TRUE;
        }

        if (changeFlags & LVS_TYPEMASK)
        {
            ListView_TypeChange(plv, styleOld);
            fShouldScroll = TRUE;
            fRedraw = TRUE;
        }

        if ((changeFlags & LVS_AUTOARRANGE) && (plv->ci.style & LVS_AUTOARRANGE))
        {
            ListView_OnArrange(plv, LVA_DEFAULT);
            fRedraw = TRUE;
        }

        // bugbug, previously, this was the else to
        // (changeFlags & LVS_AUTOARRANGE && (plv->ci.style & LVS_AUTOARRANGE))
        // I'm not sure that was really the right thing..
        if (fShouldScroll)
        {
            // Else we would like to make the most important item to still
            // be visible.  So first we will look for a cursorered item
            // if this fails, we will look for the first selected item,
            // else we will simply ask for the first item (assuming the
            // count > 0
            //
            int i;

            // And make sure the scrollbars are up to date Note this
            // also updates some variables that some views need
            ListView_UpdateScrollBars(plv);

            i = (plv->iFocus >= 0) ? plv->iFocus : ListView_OnGetNextItem(plv, -1, LVNI_SELECTED);
            if ((i == -1)  && (ListView_Count(plv) > 0))
                i = 0;

            if (i != -1)
                ListView_OnEnsureVisible(plv, i, TRUE);

        }

        if (fRedraw)
            RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
    }
    else if (gwl == GWL_EXSTYLE)
    {
        //
        // If the RTL_MIRROR extended style bit had changed, let's
        // repaint the control window.
        //
        if ((plv->ci.dwExStyle&RTL_MIRRORED_WINDOW) !=  (pinfo->styleNew&RTL_MIRRORED_WINDOW))
            RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);

        //
        // Save the new ex-style bits
        //
        plv->ci.dwExStyle = pinfo->styleNew;
    }


    // Change of styles also changes tooltip policy, so pop it
    ListView_PopBubble(plv);

}

void NEAR ListView_TypeChange(LV* plv, DWORD styleOld)
{
    RECT rc;

    //
    //  Invalidate all cached string metrics because customdraw clients
    //  may draw differently depending on the type.  This happens more
    //  often than you might think, not on purpose, but because apps are
    //  buggy.
    //
    //  APP COMPAT!  You'd think this was completely safe.  After all,
    //  all we're doing is invalidating our cache so we ask the parent
    //  afresh the next time we need the strings.  But noooooooo,
    //  Outlook98 will FAULT if you ask it for information that it thinks
    //  you by all rights already know.  Sigh.  So guard this with a v5.
    //
    if (plv->ci.iVersion >= 5 && !ListView_IsOwnerData(plv))
    {
        int i;
        for (i = 0; i < ListView_Count(plv); i++)
        {
            LISTITEM *pitem = ListView_FastGetItemPtr(plv, i);
            ListView_SetSRecompute(pitem);
        }
    }

    switch (styleOld & LVS_TYPEMASK)
    {
    case LVS_REPORT:
        ShowWindow(plv->hwndHdr, SW_HIDE);
        if (styleOld & LVS_OWNERDRAWFIXED) {
            // swap cyItem and cyFixed;
            int temp = plv->cyItem;
            plv->cyItem = plv->cyItemSave;
            plv->cyItemSave = temp;
        }
        break;

    default:
        break;
    }

    // Now handle any special setup needed for the new view
    switch (plv->ci.style & LVS_TYPEMASK)
    {
    case (UINT)LVS_ICON:
        ListView_ScaleIconPositions(plv, FALSE);
        break;

    case (UINT)LVS_SMALLICON:
        ListView_ScaleIconPositions(plv, TRUE);
        break;

    case (UINT)LVS_LIST:
        // We may need to resize the columns
        ListView_MaybeResizeListColumns(plv, 0, ListView_Count(plv)-1);
        break;

    case (UINT)LVS_REPORT:
        // if it's owner draw fixed, we may have to do funky stuff
        if ((styleOld & LVS_TYPEMASK) != LVS_REPORT) {
            plv->cyItemSave = plv->cyItem;
        }
        ListView_RInitialize(plv, FALSE);
        break;

    default:
        break;
    }

    ListView_InvalidateTTLastHit(plv, plv->iTTLastHit);

    GetClientRect(plv->ci.hwnd, &rc);
    plv->sizeClient.cx = rc.right;
    plv->sizeClient.cy = rc.bottom;
}

int NEAR ListView_OnHitTest(LV* plv, LV_HITTESTINFO FAR* pinfo)
{
    UINT flags;
    int x, y;

    if (!pinfo) return -1;

    x = pinfo->pt.x;
    y = pinfo->pt.y;

    pinfo->iItem = -1;
    flags = 0;
    if (x < 0)
        flags |= LVHT_TOLEFT;
    else if (x >= plv->sizeClient.cx)
        flags |= LVHT_TORIGHT;
    if (y < 0)
        flags |= LVHT_ABOVE;
    else if (y >= plv->sizeClient.cy)
        flags |= LVHT_BELOW;

    if (flags == 0)
    {
        pinfo->iItem = _ListView_ItemHitTest(plv, x, y, &flags, NULL);
    }

    pinfo->flags = flags;

    if (pinfo->iItem >= ListView_Count(plv)) {
        pinfo->iItem = -1;
        pinfo->flags = LVHT_NOWHERE;
    }
    return pinfo->iItem;
}

int NEAR ScrollAmount(int large, int iSmall, int unit)
{

    return (((large - iSmall) + (unit - 1)) / unit) * unit;
}

// NOTE: this is duplicated in shell32.dll
//
// checks to see if we are at the end position of a scroll bar
// to avoid scrolling when not needed (avoid flashing)
//
// in:
//      code        SB_VERT or SB_HORZ
//      bDown       FALSE is up or left
//                  TRUE  is down or right
BOOL NEAR PASCAL CanScroll(LV* plv, int code, BOOL bDown)
{
    SCROLLINFO si;

    si.cbSize = sizeof(SCROLLINFO);
    si.fMask = SIF_RANGE | SIF_PAGE | SIF_POS;

    if (ListView_GetScrollInfo(plv, code, &si))
    {
        if (bDown)
        {
            if (si.nPage)
                si.nMax -= si.nPage - 1;
            return si.nPos < si.nMax;
        }
        else
        {
            return si.nPos > si.nMin;
        }
    }
    else
    {
        return FALSE;
    }
}

// detect if we should auto scroll the window
//
// in:
//      pt  cursor pos in hwnd's client coords
// out:
//      pdx, pdy ammount scrolled in x and y
//
// REVIEW, this should make sure a certain amount of time has passed
// before scrolling.

void NEAR ScrollDetect(LV* plv, POINT pt, int FAR *pdx, int FAR *pdy)
{
    int dx, dy;

    *pdx = *pdy = 0;

    if (!(plv->ci.style & (WS_HSCROLL | WS_VSCROLL)))
        return;

    dx = dy = plv->cyIcon / 16;
    if (ListView_IsReportView(plv)) {
        dy = plv->cyItem;       // we scroll in units of items...
        if (!dx)
            dx = plv->cxSmIcon;
    }
    if (ListView_IsListView(plv))
        dx = plv->cxItem;

    if (!dx)
        dx = 1;

    if (!dy)
        dy = 1;

    // we need to check if we can scroll before acutally doing it
    // since the selection rect is adjusted based on how much
    // we scroll by

    if (plv->ci.style & WS_VSCROLL) { // scroll vertically?

        if (pt.y >= plv->sizeClient.cy) {
            if (CanScroll(plv, SB_VERT, TRUE))
                *pdy = ScrollAmount(pt.y, plv->sizeClient.cy, dy);   // down
        } else if (pt.y <= 0) {
            if (CanScroll(plv, SB_VERT, FALSE))
                *pdy = -ScrollAmount(0, pt.y, dy);     // up
        }
    }

    if (plv->ci.style & WS_HSCROLL) { // horizontally

        if (pt.x >= plv->sizeClient.cx) {
            if (CanScroll(plv, SB_HORZ, TRUE))
                *pdx = ScrollAmount(pt.x, plv->sizeClient.cx, dx);    // right
        } else if (pt.x <= 0) {
            if (CanScroll(plv, SB_HORZ, FALSE))
                *pdx = -ScrollAmount(0, pt.x, dx);    // left
        }
    }

    // BUGBUG: this will potentially scroll outside the bounds of the
    // listview.  we should bound the scroll amount in CanScroll()
    // or ScrollAmount().

    if (*pdx || *pdy) {
        ListView_ValidateScrollParams(plv, pdx, pdy);
    }
}

#define swap(pi1, pi2) {int i = *(pi1) ; *(pi1) = *(pi2) ; *(pi2) = i ;}

void NEAR OrderRect(RECT FAR *prc)
{
    if (prc->left > prc->right)
        swap(&prc->left, &prc->right);

    if (prc->bottom < prc->top)
        swap(&prc->bottom, &prc->top);
}

// in:
//      x, y    starting point in client coords

#define SCROLL_FREQ     (GetDoubleClickTime()/2)     // 1/5 of a second between scrolls

//----------------------------------------------------------------------------
BOOL ShouldScroll(LV* plv, LPPOINT ppt, LPRECT lprc)
{
    ASSERT(ppt);

    if (plv->ci.style & WS_VSCROLL)
    {
        if (ppt->y >= lprc->bottom)
        {
            if (CanScroll(plv, SB_VERT, TRUE))
                return TRUE;
        }
        else if (ppt->y <= lprc->top)
        {
            if (CanScroll(plv, SB_VERT, FALSE))
                return TRUE;
        }
    }

    if (plv->ci.style & WS_HSCROLL)
    {
        if (ppt->x >= lprc->right)
        {
            if (CanScroll(plv, SB_HORZ, TRUE))
                return TRUE;
        }
        else if (ppt->x <= lprc->left)
        {
            if (CanScroll(plv, SB_HORZ, FALSE))
                return TRUE;
        }
    }

    return FALSE;
}

#ifdef WIN95MARQUEE
#define DrawFocusRectClip(a, b, c) DrawFocusRect(a, b)
#else
BOOL DrawFocusRectClip(HDC hdc, CONST RECT * prc, CONST RECT * prcClip)
{
    RECT rc;

    IntersectRect(&rc, prc, prcClip);

    return DrawFocusRect(hdc, &rc);
}
#endif

//----------------------------------------------------------------------------
void NEAR ListView_DragSelect(LV *plv, int x, int y)
{
    RECT rc, rcWindow, rcOld, rcUnion, rcTemp2, rcClip;
    POINT pt;
    MSG32 msg32;
    HDC hdc;
    HWND hwnd = plv->ci.hwnd;
    int i, iEnd, dx, dy;
    BOOL bInOld, bInNew = FALSE, bLocked = FALSE;
    DWORD dwTime, dwNewTime;
    HRGN hrgnUpdate = NULL, hrgnLV = NULL;

    rc.left = rc.right = x;
    rc.top = rc.bottom = y;

    rcOld = rc;

    UpdateWindow(plv->ci.hwnd);

    if (plv->exStyle & LVS_EX_REGIONAL) {
        if ((hrgnUpdate = CreateRectRgn(0,0,0,0)) &&
            (hrgnLV = CreateRectRgn(0,0,0,0)) &&
            (LockWindowUpdate(GetParent(hwnd)))) {
            hdc = GetDCEx(hwnd, NULL, DCX_PARENTCLIP | DCX_LOCKWINDOWUPDATE);
            bLocked = TRUE;
        } else {
            goto BailOut;
        }
    } else {
        hdc = GetDC(hwnd);
    }

    SetCapture(hwnd);

    DrawFocusRect(hdc, &rc);

    GetClientRect(hwnd, &rcClip);
    GetWindowRect(hwnd, &rcWindow);

    dwTime = GetTickCount();

    for (;;)
    {
        // WM_CANCELMODE messages will unset the capture, in that
        // case I want to exit this loop
        if (GetCapture() != hwnd)
        {
            break;
        }

        if (!PeekMessage32(&msg32, NULL, 0, 0, PM_REMOVE, TRUE)) {

            // if the cursor is outside of the window rect
            // we need to generate messages to make autoscrolling
            // keep going

            if (!PtInRect(&rcWindow, msg32.pt))
            {
                // If we may be able to scroll, generate a mouse move.
                if (ShouldScroll(plv, &msg32.pt, &rcWindow))
                    SetCursorPos(msg32.pt.x, msg32.pt.y);
            }
            else
            {
                WaitMessage();
            }
            continue;
        }


        // See if the application wants to process the message...
        if (CallMsgFilter32(&msg32, MSGF_COMMCTRL_DRAGSELECT, TRUE) != 0)
            continue;

        switch (msg32.message)
        {

        case WM_LBUTTONUP:
        case WM_RBUTTONUP:
        case WM_LBUTTONDOWN:
        case WM_MBUTTONDOWN:
        case WM_MBUTTONUP:
        case WM_RBUTTONDOWN:
            CCReleaseCapture(&plv->ci);
            goto EndOfLoop;


        case WM_TIMER:
            if (msg32.wParam != IDT_MARQUEE)
                goto DoDefault;
            // else fall through

        case WM_MOUSEMOVE:
        {
            int dMax = -1;
            pt = msg32.pt;
            ScreenToClient(hwnd, &pt);

            dwNewTime = GetTickCount();
//            if (1 || (dwNewTime - dwTime) > SCROLL_FREQ)
//          {
                dwTime = dwNewTime;     // reset scroll timer
                ScrollDetect(plv, pt, &dx, &dy);
//          }
//          else
//          {
//              dx = dy = 0;
//          }
            //SetTimer(plv->ci.hwnd, IDT_MARQUEE, SCROLL_FREQ, NULL);

            y -= dy;    // scroll up/down
            x -= dx;    // scroll left/right

            rc.left = x;
            rc.top = y;
            rc.right = pt.x;
            rc.bottom = pt.y;

            // clip drag rect to the window
            //
            if (rc.right > rcClip.right)
                rc.right = rcClip.right;
            if (rc.right < rcClip.left)
                rc.right = rcClip.left;
            if (rc.bottom > rcClip.bottom)
                rc.bottom = rcClip.bottom;
            if (rc.bottom < rcClip.top)
                rc.bottom = rcClip.top;

            OrderRect(&rc);

            if (EqualRect(&rc, &rcOld))
                break;

            // move the old rect
            DrawFocusRect(hdc, &rcOld); // erase old
            if (dx || dy)
                ListView_OnScroll(plv, dx, dy);
            OffsetRect(&rcOld, -dx, -dy);

            //
            // For Report and List view, we can speed things up by
            // only searching through those items that are visible.  We
            // use the hittest to calculate the first item to paint.
            // BUGBUG:: We are using state specific info here...
            //
            UnionRect(&rcUnion, &rc, &rcOld);

            if (ListView_IsReportView(plv))
            {
                i = (int)((plv->ptlRptOrigin.y + rcUnion.top  - plv->yTop)
                        / plv->cyItem);
                iEnd = (int)((plv->ptlRptOrigin.y + rcUnion.bottom  - plv->yTop)
                        / plv->cyItem) + 1;
            }

            else if (ListView_IsListView(plv))
            {
                i = ((plv->xOrigin + rcUnion.left)/ plv->cxItem)
                        * plv->cItemCol + rcUnion.top / plv->cyItem;

                iEnd = ((plv->xOrigin + rcUnion.right)/ plv->cxItem)
                        * plv->cItemCol + rcUnion.bottom / plv->cyItem + 1;
            }

            else
            {
                if (ListView_IsOwnerData( plv ))
                {
                    ListView_CalcMinMaxIndex( plv, &rcUnion, &i, &iEnd );
                }
                else
                {
                    i = 0;
                    iEnd = ListView_Count(plv);
                }
            }

            // make sure our endpoint is in range.
            if (iEnd > ListView_Count(plv))
                iEnd = ListView_Count(plv);

            if (i < 0)
                i = 0;

            if (ListView_IsOwnerData(plv) && (i < iEnd)) {
                ListView_NotifyCacheHint(plv, i, iEnd-1);
            }

            if (bInNew && !(msg32.wParam & (MK_CONTROL | MK_SHIFT))) {
                plv->iMark = -1;
            }

            for (; i  < iEnd; i++) {
                RECT dummy;
                ListView_GetRects(plv, i, NULL, NULL, NULL, &rcTemp2);

                // don't do this infaltion if we're in report&full row mode
                // in that case, just touching is good enough
                if (!(ListView_IsReportView(plv) && ListView_FullRowSelect(plv))) {
                    int cxInflate = (rcTemp2.right - rcTemp2.left) / 4;
                    if (ListView_IsListView(plv)) {
                        cxInflate = min(cxInflate, plv->cxSmIcon);
                    }
                    InflateRect(&rcTemp2, -cxInflate, -(rcTemp2.bottom - rcTemp2.top) / 4);
                }

                bInOld = (IntersectRect(&dummy, &rcOld, &rcTemp2) != 0);
                bInNew = (IntersectRect(&dummy, &rc, &rcTemp2) != 0);

                if (msg32.wParam & MK_CONTROL) {
                    if (bInOld != bInNew) {
                        ListView_ToggleSelection(plv, i);
                    }
                } else {
                    // was there a change?
                    if (bInOld != bInNew) {
                        ListView_OnSetItemState(plv, i, bInOld ? 0 : LVIS_SELECTED, LVIS_SELECTED);
                    }

                    // if no alternate keys are down.. set the mark to
                    // the item furthest from the cursor
                    if (bInNew && !(msg32.wParam & (MK_CONTROL | MK_SHIFT))) {
                        int dItem;
                        dItem = (rcTemp2.left - pt.x) * (rcTemp2.left - pt.x) +
                            (rcTemp2.top - pt.y) * (rcTemp2.top - pt.y);
                        // if it's further away, set this as the mark
                        //DebugMsg(TF_LISTVIEW, "dItem = %d, dMax = %d", dItem, dMax);
                        if (dItem > dMax) {
                            //DebugMsg(TF_LISTVIEW, "taking dItem .. iMark = %d", i);
                            dMax = dItem;
                            plv->iMark = i;
                        }
                    }
                }
            }

            //DebugMsg(TF_LISTVIEW, "Final iMark = %d", plv->iMark);
            if (bLocked) {
                if (GetUpdateRgn(plv->ci.hwnd, hrgnUpdate, FALSE) > NULLREGION) {
                    ValidateRect(plv->ci.hwnd, NULL);
                    GetWindowRgn(plv->ci.hwnd, hrgnLV);
                    CombineRgn(hrgnUpdate, hrgnUpdate, hrgnLV, RGN_AND);
                    SelectClipRgn(hdc, hrgnUpdate);
                    SendMessage(plv->ci.hwnd, WM_PRINTCLIENT, (WPARAM)hdc, 0);
                    SelectClipRgn(hdc, NULL);
                }
            } else {
                UpdateWindow(plv->ci.hwnd);    // make selection draw
            }


            DrawFocusRect(hdc, &rc);

            rcOld = rc;
            break;
        }

        case WM_KEYDOWN:
            switch (msg32.wParam) {
            case VK_ESCAPE:
                ListView_DeselectAll(plv, -1);
                goto EndOfLoop;
            }
        case WM_CHAR:
        case WM_KEYUP:
            // don't process thay keyboard stuff during marquee
            break;


        default:

            // don't process mouse wheel stuff
            if (msg32.message == g_msgMSWheel)
                break;

        DoDefault:
            TranslateMessage32(&msg32, TRUE);
            DispatchMessage32(&msg32, TRUE);
        }
    }

EndOfLoop:
    DrawFocusRect(hdc, &rcOld); // erase old
    ReleaseDC(hwnd, hdc);

BailOut:
    if (hrgnUpdate)
        DeleteObject(hrgnUpdate);
    if (hrgnLV)
        DeleteObject(hrgnLV);
    if (bLocked)
        LockWindowUpdate(NULL);
}


#define SHIFT_DOWN(keyFlags)    (keyFlags & MK_SHIFT)
#define CONTROL_DOWN(keyFlags)  (keyFlags & MK_CONTROL)
#define RIGHTBUTTON(keyFlags)   (keyFlags & MK_RBUTTON)

void PASCAL ListView_ButtonSelect(LV* plv, int iItem, UINT keyFlags, BOOL bSelected)
{
    if (SHIFT_DOWN(keyFlags))
    {
        ListView_SelectRangeTo(plv, iItem, !CONTROL_DOWN(keyFlags));
        ListView_SetFocusSel(plv, iItem, TRUE, FALSE, FALSE);
    }
    else if (!CONTROL_DOWN(keyFlags))
    {
        ListView_SetFocusSel(plv, iItem, TRUE, !bSelected, FALSE);
    }
}

void ListView_HandleStateIconClick(LV* plv, int iItem)
{
    int iState =
        ListView_OnGetItemState(plv, iItem, LVIS_STATEIMAGEMASK);

    iState = STATEIMAGEMASKTOINDEX(iState) -1;
    iState++;
    iState %= ImageList_GetImageCount(plv->himlState);
    iState++;
    ListView_OnSetItemState(plv, iItem, INDEXTOSTATEIMAGEMASK(iState), LVIS_STATEIMAGEMASK);
}

BOOL ListView_RBeginMarquee(LV* plv, int x, int y, LPLVHITTESTINFO plvhti)
{
    if (ListView_FullRowSelect(plv) &&
        ListView_IsReportView(plv) &&
        !(plv->ci.style & LVS_SINGLESEL) &&
        !ListView_OwnerDraw(plv) &&
        plvhti->iSubItem == 0) {
        // can only begin marquee in column 0.

        if (plvhti->flags == LVHT_ONITEM) {
            return TRUE;
        }
    }

    return FALSE;
}

void NEAR ListView_HandleMouse(LV* plv, BOOL fDoubleClick, int x, int y, UINT keyFlags, BOOL bMouseWheel)
{
    LV_HITTESTINFO ht;
    NMITEMACTIVATE nm;
    int iItem, click, drag;
    BOOL bSelected, fHadFocus, fNotifyReturn = FALSE;
    BOOL fActive;
    HWND hwnd = plv->ci.hwnd;

    if (plv->fButtonDown)
        return;
    plv->fButtonDown = TRUE;


    if (plv->exStyle & LVS_EX_ONECLICKACTIVATE && plv->fOneClickHappened && plv->fOneClickOK)
    {
        KillTimer(plv->ci.hwnd, IDT_ONECLICKHAPPENED);
        plv->fOneClickHappened = FALSE;
        CCSendNotify(&plv->ci, LVN_ITEMACTIVATE, &(plv->nmOneClickHappened.hdr));
        if (!IsWindow(hwnd))
            return;
    }

    fHadFocus = (GetFocus() == plv->ci.hwnd);
    click = RIGHTBUTTON(keyFlags) ? NM_RCLICK : NM_CLICK;
    drag  = RIGHTBUTTON(keyFlags) ? LVN_BEGINRDRAG : LVN_BEGINDRAG;

    fActive = ChildOfActiveWindow(plv->ci.hwnd) || fShouldFirstClickActivate() ||
              ChildOfDesktop(plv->ci.hwnd);

#ifdef LVDEBUG
    DebugMsg(TF_LISTVIEW, TEXT("ListView_OnButtonDown %d"), fDoubleClick);
#endif

    SetCapture(plv->ci.hwnd);

    plv->ptCapture.x = x;
    plv->ptCapture.y = y;


    if (!ListView_DismissEdit(plv, FALSE) && GetCapture() != plv->ci.hwnd)
        goto EndButtonDown;
    CCReleaseCapture(&plv->ci);

    // REVIEW: right button implies no shift or control stuff
    // Single selection style also implies no modifiers
    //if (RIGHTBUTTON(keyFlags) || (plv->ci.style & LVS_SINGLESEL))
    if ((plv->ci.style & LVS_SINGLESEL))
        keyFlags &= ~(MK_SHIFT | MK_CONTROL);

    ht.pt.x = x;
    ht.pt.y = y;
    iItem = ListView_OnSubItemHitTest(plv, &ht);
    if (ht.iSubItem != 0) {
        // if we're not in full row select,
        // hitting on a subitem is like hitting on nowhere
        // also, in win95, ownerdraw fixed effectively had full row select
        if (!ListView_FullRowSelect(plv) &&
            !(plv->ci.style & LVS_OWNERDRAWFIXED)) {
            iItem = -1;
            ht.flags = LVHT_NOWHERE;
        }
    }

    nm.iItem = iItem;
    nm.iSubItem = ht.iSubItem;
    nm.uChanged = 0;
    nm.ptAction.x = x;
    nm.ptAction.y = y;
    nm.uKeyFlags = GetLVKeyFlags();

    // FProt Profesional assumed that if the notification structure pointer + 14h bytes
    // had a value 2 that it was a displayinfo structure and they then used offset +2c as lparam...
    nm.uNewState = 0;

    plv->iNoHover = iItem;


    bSelected = (iItem >= 0) && ListView_OnGetItemState(plv, iItem, LVIS_SELECTED);

    if (fDoubleClick)
    {
        //
        // Cancel any name editing that might happen.
        //
        ListView_CancelPendingEdit(plv);
        KillTimer(plv->ci.hwnd, IDT_SCROLLWAIT);

        if (ht.flags & LVHT_NOWHERE) {
            // this would have been done in the first click in win95 except
            // now we blow off the first click on focus change
            if (!SHIFT_DOWN(keyFlags) && !CONTROL_DOWN(keyFlags))
                ListView_DeselectAll(plv, -1);
        }

        click = RIGHTBUTTON(keyFlags) ? NM_RDBLCLK : NM_DBLCLK ;
        if (CCSendNotify(&plv->ci, click, &nm.hdr))
            goto EndButtonDown;

        /// some (comdlg32 for example) destroy on double click
        // we need to bail if that happens because plv is no longer valid
        if (!IsWindow(hwnd))
            return;

        if (click == NM_DBLCLK)
        {
            // these shift control flags are to mirror when we don't send out the activate on the single click,
            // but are in the oneclick activate mode  (see below)
            if (ht.flags & (LVHT_ONITEMLABEL | LVHT_ONITEMICON))
            {
                // possible scenarios below:
                // 1) we're using classic windows style so double click => launch
                // 2) we're using single click activate
                //    a) shift is down and item is selected => launch
                //       this implies that the first click selected it
                //    b) control is down => launch
                //       the first click toggled the selection so if the item was
                //       the only item selected and we double clicked on it
                //       the first click deselects it and no item is selected
                //       so nothing will be launched - this is win95 behavior
                if (!(plv->exStyle & LVS_EX_ONECLICKACTIVATE && plv->fOneClickOK) ||
                    (plv->exStyle & LVS_EX_ONECLICKACTIVATE &&  plv->fOneClickOK &&
                     (SHIFT_DOWN(keyFlags) || CONTROL_DOWN(keyFlags))))
                {
                    CCSendNotify(&plv->ci, LVN_ITEMACTIVATE, &nm.hdr);
                }
            }
            // Double-click on checkbox state icon cycles it just like single click
            else if ((ht.flags & LVHT_ONITEMSTATEICON) && ListView_CheckBoxes(plv)) {
                ListView_HandleStateIconClick(plv, iItem);
            }
        }

        if (!IsWindow(hwnd))
            return;
        goto EndButtonDown;
    }

    if (ht.flags & (LVHT_ONITEMLABEL | LVHT_ONITEMICON))
    {

        // if it wasn't selected, we're about to select it... play
        // a little ditty for us...
        CCPlaySound(c_szSelect);

        if (!RIGHTBUTTON(keyFlags) || (!CONTROL_DOWN(keyFlags) && !SHIFT_DOWN(keyFlags)))
            ListView_ButtonSelect(plv, iItem, keyFlags, bSelected);

        // handle full row select
        // If single-select listview, disable marquee selection.
        //
        // Careful - CheckForDragBegin yields and the app may have
        // destroyed the item we were thinking about dragging!
        //
        if (!bMouseWheel && CheckForDragBegin(plv->ci.hwnd, x, y))
        {
            // should we do a marquee?
            if (ListView_RBeginMarquee(plv, x, y, &ht) &&
                !CCSendNotify(&plv->ci, LVN_MARQUEEBEGIN, &nm.hdr))
            {
                ListView_DragSelect(plv, x, y);
                fNotifyReturn = !CCSendNotify(&plv->ci, click, &nm.hdr);
            }
            else
            {
                // Before we start dragging, make it sure that it is
                // selected and has the focus.
                ListView_SetFocusSel(plv, iItem, TRUE, FALSE, FALSE);

                if (!SHIFT_DOWN(keyFlags))
                    plv->iMark = iItem;

                // Then, we need to update the window before start dragging
                // to show the selection chagne.
                UpdateWindow(plv->ci.hwnd);

                CCSendNotify(&plv->ci, drag, &nm.hdr);

                goto EndButtonDown;
            }
        }

        // CheckForDragBegin yields, so revalidate before continuing
        else if (IsWindow(hwnd))
        {
            // button came up and we are not dragging

            if (!RIGHTBUTTON(keyFlags))
            {
                if (CONTROL_DOWN(keyFlags))
                {
                    // do this on the button up so that ctrl-dragging a range
                    // won't toggle the select.

                    if (SHIFT_DOWN(keyFlags))
                        ListView_SetFocusSel(plv, iItem, FALSE, FALSE, FALSE);
                    else
                    {
                        ListView_SetFocusSel(plv, iItem, TRUE, FALSE, TRUE);
                    }
                }
            }
            if (!SHIFT_DOWN(keyFlags))
                plv->iMark = iItem;

            if (!ListView_SetFocus(plv->ci.hwnd))    // activate this window
                return;

            // now do the deselect stuff
            if (!SHIFT_DOWN(keyFlags) && !CONTROL_DOWN(keyFlags) && !RIGHTBUTTON(keyFlags))
            {
                ListView_DeselectAll(plv, iItem);
                if ((ht.flags & LVHT_ONITEMLABEL) && bSelected &&
                    !(plv->exStyle & (LVS_EX_ONECLICKACTIVATE|LVS_EX_TWOCLICKACTIVATE)))
                {

                    // doing this check for ownerdrawfixed is for compatability.
                    // we don't want to go into edit mode if the user just happened to click
                    // to this window when a different one had focus,
                    // but ms hammer relied upon the notification being sent (and we
                    // don't go into edit mode anyways for ownerdraw)
                    if (fHadFocus ||
                        (plv->ci.style & LVS_OWNERDRAWFIXED)) {
                        // Click on item label.  It was selected and
                        // no modifier keys were pressed and no drag operation
                        // So setup for name edit mode.  Still need to wait
                        // to make sure user is not doing double click.
                        //
                        ListView_SetupPendingNameEdit(plv);
                    }
                }
            }

            fNotifyReturn = !CCSendNotify(&plv->ci, click, &nm.hdr);
            if (!IsWindow(hwnd))
                return;

            if (plv->exStyle & (LVS_EX_ONECLICKACTIVATE|LVS_EX_TWOCLICKACTIVATE))
            {
                if (!RIGHTBUTTON(keyFlags))
                {
                    // We don't ItemActivate within one double-click time of creating
                    // this listview. This is a common occurence for people used to
                    // double-clicking. The first click pops up a new window which
                    // receives the second click and ItemActivates the item...
                    //
                    if ((plv->exStyle & LVS_EX_ONECLICKACTIVATE && plv->fOneClickOK) || bSelected)
                    {
                        if (fActive)
                        {
                            // condition: if we're in a single click activate mode
                            // don't launch if control or shift keys are pressed
                            BOOL bCond = plv->exStyle & LVS_EX_ONECLICKACTIVATE && !CONTROL_DOWN(keyFlags) && !SHIFT_DOWN(keyFlags);

                            if ((bSelected && plv->exStyle & LVS_EX_TWOCLICKACTIVATE) ||
                                (bCond && !g_bUseDblClickTimer))
                            {
                                CCSendNotify(&plv->ci, LVN_ITEMACTIVATE, &nm.hdr);
                                if (!IsWindow(hwnd))
                                    return;
                            }
                            else if (bCond && g_bUseDblClickTimer)
                            {
                                plv->fOneClickHappened = TRUE;
                                plv->nmOneClickHappened = nm;
                                SetTimer(plv->ci.hwnd, IDT_ONECLICKHAPPENED, GetDoubleClickTime(), NULL);
                            }
                        }
                    }
                }
            }
        }
        else
        {
            // IsWindow() failed.  Bail.
            return;
        }
    }
    else if (ht.flags & LVHT_ONITEMSTATEICON)
    {
        // Should activate window and send notificiation to parent...
        if (!ListView_SetFocus(plv->ci.hwnd))   // activate this window
            return;
        fNotifyReturn = !CCSendNotify(&plv->ci, click, &nm.hdr);
        if (fNotifyReturn && ListView_CheckBoxes(plv)) {
            ListView_HandleStateIconClick(plv, iItem);
        }
    }
    else if (ht.flags & LVHT_NOWHERE)
    {
        if (!ListView_SetFocus(plv->ci.hwnd))   // activate this window
            return;

        // If single-select listview, disable marquee selection.
        if (!(plv->ci.style & LVS_SINGLESEL) && CheckForDragBegin(plv->ci.hwnd, x, y) &&
            !CCSendNotify(&plv->ci, LVN_MARQUEEBEGIN, &nm.hdr))
        {
            if (!SHIFT_DOWN(keyFlags) && !CONTROL_DOWN(keyFlags))
                ListView_DeselectAll(plv, -1);
            ListView_DragSelect(plv, x, y);
            fNotifyReturn = !CCSendNotify(&plv->ci, click, &nm.hdr);
        } else if (IsWindow(hwnd)) {
            // if we didn't have focus and aren't showing selection always,
            // make the first click just set focus
            BOOL fDoFirstClickSelection = (fHadFocus || plv->ci.style & LVS_SHOWSELALWAYS ||
                                           CONTROL_DOWN(keyFlags) || SHIFT_DOWN(keyFlags) ||
                                           RIGHTBUTTON(keyFlags));

            if (fDoFirstClickSelection && fActive) {

                if (!SHIFT_DOWN(keyFlags) && !CONTROL_DOWN(keyFlags))
                    ListView_DeselectAll(plv, -1);

                fNotifyReturn = !CCSendNotify(&plv->ci, click, &nm.hdr);
            }
        }
        else
        {
            // IsWindow() failed.  Bail.
            return;
        }
    }

    // re-check the key state so we don't get confused by multiple clicks

    // this needs to check the GetKeyState stuff only when we've gone into
    // a modal loop waiting for the rbutton up.
    if (fNotifyReturn && (click == NM_RCLICK)) // && (GetKeyState(VK_RBUTTON)>=0))
    {
        POINT pt = { x, y };
        ClientToScreen(plv->ci.hwnd, &pt);
        FORWARD_WM_CONTEXTMENU(plv->ci.hwnd, plv->ci.hwnd, pt.x, pt.y, SendMessage);
    }

EndButtonDown:
    if (IsWindow(hwnd))
        plv->fButtonDown = FALSE;
}

void NEAR ListView_OnButtonDown(LV* plv, BOOL fDoubleClick, int x, int y, UINT keyFlags)
{
    ListView_HandleMouse(plv, fDoubleClick, x, y, keyFlags, FALSE);
}

#define ListView_CancelPendingEdit(plv) ListView_CancelPendingTimer(plv, LVF_NMEDITPEND, IDT_NAMEEDIT)
#define ListView_CancelScrollWait(plv) ListView_CancelPendingTimer(plv, LVF_SCROLLWAIT, IDT_SCROLLWAIT)

BOOL NEAR ListView_CancelPendingTimer(LV* plv, UINT fFlags, int idTimer)
{
    if (plv->flags & fFlags)
    {
        KillTimer(plv->ci.hwnd, idTimer);
        plv->flags &= ~fFlags;
        return TRUE;
    }
    return FALSE;
}

//
// ListView_OnTimer:
//     process the WM_TIMER message.  If the timer id is thta
//     of the name editing, we should then start the name editing mode.
//
void NEAR ListView_OnTimer(LV* plv, UINT id)
{
    KillTimer(plv->ci.hwnd, id);

    if (id == IDT_NAMEEDIT)
    {
        // Kill the timer as we wont need any more messages from it.

        if (ListView_CancelPendingEdit(plv)) {
            // And start name editing mode.
            if (!ListView_OnEditLabel(plv, plv->iFocus, NULL))
            {
                ListView_DismissEdit(plv, FALSE);
                ListView_SetFocusSel(plv, plv->iFocus, TRUE, TRUE, FALSE);
            }
        }
    } else if (id == IDT_SCROLLWAIT) {

        if (ListView_CancelScrollWait(plv)) {
            ListView_OnEnsureVisible(plv, plv->iFocus, TRUE);
        }
    } else if (id == IDT_ONECLICKOK) {
        plv->fOneClickOK = TRUE;
    } else if (id == IDT_ONECLICKHAPPENED) {
        //if (!g_bUseDblClickTimer)
        //{
        ////    EnableWindow(plv->ci.hwnd, TRUE);
        //    SetWindowBits(plv->ci.hwnd, GWL_STYLE, WS_DISABLED, 0);
        //    plv->fOneClickHappened = FALSE;
        //}
        // check the bit just in case they double-clicked
        //else
        if (plv->fOneClickHappened)
        {
            plv->fOneClickHappened = FALSE;
            CCSendNotify(&plv->ci, LVN_ITEMACTIVATE, &(plv->nmOneClickHappened.hdr));
        }
    }
}

//
// ListView_SetupPendingNameEdit:
//      Sets up a timer to begin name editing at a delayed time.  This
//      will allow the user to double click on the already selected item
//      without going into name editing mode, which is especially important
//      in those views that only show a small icon.
//
void NEAR ListView_SetupPendingNameEdit(LV* plv)
{
    SetTimer(plv->ci.hwnd, IDT_NAMEEDIT, GetDoubleClickTime(), NULL);
    plv->flags |= LVF_NMEDITPEND;
}

void NEAR PASCAL ListView_OnHVScroll(LV* plv, UINT code, int pos, int sb)
{
    int iScrollCount = 0;

#ifdef SIF_TRACKPOS
    SCROLLINFO si;

    si.cbSize = sizeof(SCROLLINFO);
    si.fMask = SIF_TRACKPOS;


    // if we're in 32bits, don't trust the pos since it's only 16bit's worth
    if (ListView_GetScrollInfo(plv, sb, &si))
        pos = (int)si.nTrackPos;
#endif
    ListView_DismissEdit(plv, FALSE);


    _ListView_OnScroll(plv, code, pos, sb);

    switch (code) {
    case SB_PAGELEFT:
    case SB_PAGERIGHT:
        if (plv->iScrollCount < SMOOTHSCROLLLIMIT)
            plv->iScrollCount += 3;
        break;

    case SB_LINELEFT:
    case SB_LINERIGHT:
        if (plv->iScrollCount < SMOOTHSCROLLLIMIT)
            plv->iScrollCount++;
        break;

    case SB_ENDSCROLL:
        plv->iScrollCount = 0;
        break;

    }
}

void NEAR ListView_OnVScroll(LV* plv, HWND hwndCtl, UINT code, int pos)
{
    ListView_OnHVScroll(plv, code, pos, SB_VERT);
}

void NEAR ListView_OnHScroll(LV* plv, HWND hwndCtl, UINT code, int pos)
{
    ListView_OnHVScroll(plv, code, pos, SB_HORZ);
}

int ListView_ValidateOneScrollParam(LV* plv, int iDirection, int dx)
{
    SCROLLINFO si;

    si.cbSize = sizeof(SCROLLINFO);
    si.fMask = SIF_PAGE | SIF_RANGE | SIF_POS;



    if (!ListView_GetScrollInfo(plv, iDirection, &si))
        return 0;

    si.nMax -= (si.nPage - 1);
    si.nPos += dx;
    if (si.nPos < si.nMin) {
        dx += (int)(si.nMin - si.nPos);
    } else if (si.nPos > si.nMax) {
        dx -= (int)(si.nPos - si.nMax);
    }

    return dx;
}

BOOL NEAR PASCAL ListView_ValidateScrollParams(LV* plv, int FAR * pdx, int FAR *pdy)
{
    int dx = *pdx;
    int dy = *pdy;

    if (plv->ci.style & LVS_NOSCROLL)
        return FALSE;

    if (ListView_IsListView(plv))
    {
        ListView_MaybeResizeListColumns(plv, 0, ListView_Count(plv)-1);
#ifdef COLUMN_VIEW
        if (dx < 0)
            dx = (dx - plv->cxItem - 1) / plv->cxItem;
        else
            dx = (dx + plv->cxItem - 1) / plv->cxItem;

        if (dy)
            return FALSE;
#else
        if (dy < 0)
            dy = (dy - plv->cyItem - 1) / plv->cyItem;
        else
            dy = (dy + plv->cyItem - 1) / plv->cyItem;

        if (dx)
            return FALSE;
#endif
    }
    else if (ListView_IsReportView(plv))
    {
        //
        // Note: This function expects that dy is in number of lines
        // and we are working with pixels so do a conversion use some
        // rounding up and down to make it right
        if (dy > 0)
            dy = (dy + plv->cyItem/2) / plv->cyItem;
        else
            dy = (dy - plv->cyItem/2) / plv->cyItem;
    }

    if (dy) {
        dy = ListView_ValidateOneScrollParam(plv, SB_VERT, dy);
        if (ListView_IsReportView(plv)
#ifndef COLUMN_VIEW
            || ListView_IsListView(plv)
#endif
            ) {
           // convert back to pixels
           dy *= plv->cyItem;
        }
        *pdy = dy;
    }

    if (dx) {

        dx = ListView_ValidateOneScrollParam(plv, SB_HORZ, dx);
#ifdef COLUMN_VIEW
        if (ListView_IsListView(plv)) {
            dx *= plv->cxItem;
        }
#endif
        *pdx = dx;
    }

    return TRUE;
}


BOOL NEAR ListView_OnScroll(LV* plv, int dx, int dy)
{

    if (plv->ci.style & LVS_NOSCROLL)
        return FALSE;

    if (ListView_IsListView(plv))
    {
        // Scale pixel count to column count
        //
#ifdef COLUMN_VIEW
        if (dx < 0)
            dx -= plv->cxItem - 1;
        else
            dx += plv->cxItem - 1;

        dx = dx / plv->cxItem;

        if (dy)
            return FALSE;
#else
        if (dy < 0)
            dy -= plv->cyItem - 1;
        else
            dy += plv->cyItem - 1;

        dy = dy / plv->cyItem;

        if (dx)
            return FALSE;
#endif
    }
    else if (ListView_IsReportView(plv))
    {
        //
        // Note: This function expects that dy is in number of lines
        // and we are working with pixels so do a conversion use some
        // rounding up and down to make it right
        if (dy > 0)
            dy = (dy + plv->cyItem/2) / plv->cyItem;
        else
            dy = (dy - plv->cyItem/2) / plv->cyItem;
    }
    _ListView_Scroll2(plv, dx, dy, 0);
    ListView_UpdateScrollBars(plv);
    return TRUE;
}

BOOL NEAR ListView_OnEnsureVisible(LV* plv, int i, BOOL fPartialOK)
{
        RECT rcBounds;
        RECT rc;
        int dx, dy;

    if (!ListView_IsValidItemNumber(plv, i) || plv->ci.style & LVS_NOSCROLL)
        return FALSE;

    // we need to do this again inside because some callers don't do it.
    // other callers that do this need to do it outside so that
    // they can know not to call us if there's not wait pending
    ListView_CancelScrollWait(plv);

    if (ListView_IsReportView(plv))
        return ListView_ROnEnsureVisible(plv, i, fPartialOK);


        ListView_GetRects(plv, i, &rc, NULL, &rcBounds, NULL);

        if (!fPartialOK)
                rc = rcBounds;

    // If any part of rc is outside of rcClient, then
    // scroll so that all of rcBounds is visible.
    //
        dx = 0;
        if (rc.left < 0 || rc.right >= plv->sizeClient.cx)
        {
                dx = rcBounds.left - 0;
                if (dx >= 0)
                {
                        dx = rcBounds.right - plv->sizeClient.cx;
                        if (dx <= 0)
                                dx = 0;
                        else if ((rcBounds.left - dx) < 0)
                                dx = rcBounds.left - 0; // Not all fits...
                }
        }
        dy = 0;
        if (rc.top < 0 || rc.bottom >= plv->sizeClient.cy)
        {
                dy = rcBounds.top - 0;
                if (dy >= 0)
                {
                        dy = rcBounds.bottom - plv->sizeClient.cy;
                        if (dy < 0)
                                dy = 0;
                }
        }

    if (dx | dy)
        return ListView_OnScroll(plv, dx, dy);

    return TRUE;
}

void NEAR ListView_UpdateScrollBars(LV* plv)
{
    RECT rc;
    DWORD dwStyle;

    if ((plv->ci.style & LVS_NOSCROLL) ||
        (!(ListView_RedrawEnabled(plv))))
        return;

    _ListView_UpdateScrollBars(plv);

    GetClientRect(plv->ci.hwnd, &rc);
    plv->sizeClient.cx = rc.right;
    plv->sizeClient.cy = rc.bottom;

    dwStyle = ListView_GetWindowStyle(plv);
    plv->ci.style = (plv->ci.style & ~(WS_HSCROLL | WS_VSCROLL)) | (dwStyle & WS_HSCROLL | WS_VSCROLL);
}

#ifndef WINNT
#pragma optimize ("gle", off)
// Crappy hack for Sage, which passes unitialized memory to SetWindowPlacement.
// They used to get lucky and get zeros for the max position, but now they end
// up with non-zero stack trash that causes bad things to happen when sage is
// maximized.  Thus, zero a bunch of stack to save their tail...
void ZeroSomeStackForSage()
{
    BYTE aByte[1024];

    memset(aByte, 0, sizeof(aByte));

    aByte;
}
#pragma optimize ("", on)
#endif

void NEAR ListView_OnSetFont(LV* plv, HFONT hfont, BOOL fRedraw)
{
    HDC hdc;
    SIZE siz;
    LOGFONT lf;
    HFONT hfontPrev;
 
    if ((plv->flags & LVF_FONTCREATED) && plv->hfontLabel) {
        DeleteObject(plv->hfontLabel);
        plv->flags &= ~LVF_FONTCREATED;
    }

    if (hfont == NULL) {
        SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), &lf, FALSE);
#ifdef WINNT
        // B#210235 - because NT4 initializes icontitle logfont with Ansi charset
        // no matter what font is selected, following A/W conversion would fail
        // on non US environment if we use this logfont to get codepage. 
        // The ACP is guaranteed to work with any Ansi apps because these apps
        // assume ACP to be matching to their desired codepage.
        if (staticIsOS(OS_NT4ORGREATER) && !staticIsOS(OS_WIN2000ORGREATER))
        {
            CHARSETINFO csi;
            TranslateCharsetInfo(IntToPtr_(DWORD *, g_uiACP), &csi, TCI_SRCCODEPAGE);
            lf.lfCharSet = (BYTE)csi.ciCharset;
        }
#endif
        hfont = CreateFontIndirect(&lf);
        plv->flags |= LVF_FONTCREATED;
    }

    hdc = GetDC(HWND_DESKTOP);

    hfontPrev = SelectFont(hdc, hfont);

    GetTextExtentPoint(hdc, TEXT("0"), 1, &siz);

    plv->cyLabelChar = siz.cy;
    plv->cxLabelChar = siz.cx;

    GetTextExtentPoint(hdc, c_szEllipses, CCHELLIPSES, &siz);
    plv->cxEllipses = siz.cx;

    SelectFont(hdc, hfontPrev);
    ReleaseDC(HWND_DESKTOP, hdc);

    plv->hfontLabel = hfont;

    plv->ci.uiCodePage = GetCodePageForFont(hfont);

    ListView_InvalidateCachedLabelSizes(plv);

    /* Ensure that our tooltip control uses the same font as the list view is using, therefore
    /  avoiding any nasty formatting problems. */

    if ( plv->hwndToolTips )
    {
        FORWARD_WM_SETFONT( plv->hwndToolTips, plv->hfontLabel, FALSE, SendMessage );
    }

    // If we have a header window, we need to forward this to it also
    // as we have destroyed the hfont that they are using...
    if (plv->hwndHdr) {
        FORWARD_WM_SETFONT(plv->hwndHdr, plv->hfontLabel, FALSE, SendMessage);
        ListView_UpdateScrollBars(plv);
    }

    if (plv->hFontHot) {
        DeleteObject(plv->hFontHot);
        plv->hFontHot = NULL;
    }

    CCGetHotFont(plv->hfontLabel, &plv->hFontHot);
    plv->iFreeSlot = -1;

    if (fRedraw)
        RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
    #ifndef WINNT
    ZeroSomeStackForSage();
    #endif
}

HFONT NEAR ListView_OnGetFont(LV* plv)
{
    return plv->hfontLabel;
}

// This function process the WM_SETREDRAW message by setting or clearing
// a bit in the listview structure, which several places in the code will
// check...
//
// REVIEW: Should probably forward to DefWindowProc()
//
void NEAR ListView_OnSetRedraw(LV* plv, BOOL fRedraw)
{
    if (fRedraw)
    {
        BOOL fChanges = FALSE;
        // Only do work if we're turning redraw back on...
        //
        if (!(plv->flags & LVF_REDRAW))
        {
            plv->flags |= LVF_REDRAW;

            // deal with any accumulated invalid regions
            if (plv->hrgnInval)
            {
                UINT fRedraw = (plv->flags & LVF_ERASE) ? RDW_INVALIDATE | RDW_ERASE | RDW_UPDATENOW : RDW_UPDATENOW|RDW_INVALIDATE;
                if (plv->hrgnInval == (HRGN)ENTIRE_REGION)
                    plv->hrgnInval = NULL;

                RedrawWindow(plv->ci.hwnd, NULL, plv->hrgnInval, fRedraw);
                ListView_DeleteHrgnInval(plv);
                fChanges = TRUE;
            }
            plv->flags &= ~LVF_ERASE;

            // now deal with the optimized stuff
            if (ListView_IsListView(plv) || ListView_IsReportView(plv))
            {
                if (plv->iFirstChangedNoRedraw != -1)
                {
                    // We may try to resize the column
                    if (!ListView_MaybeResizeListColumns(plv, plv->iFirstChangedNoRedraw,
                            ListView_Count(plv)-1))
                        ListView_OnUpdate(plv, plv->iFirstChangedNoRedraw);
                }
                else
                    ListView_UpdateScrollBars(plv);
            } else {
                int iCount;

                if (plv->iFirstChangedNoRedraw != -1) {
                    for (iCount = ListView_Count(plv) ; plv->iFirstChangedNoRedraw < iCount; plv->iFirstChangedNoRedraw++) {
                        ListView_InvalidateItem(plv, plv->iFirstChangedNoRedraw, FALSE, RDW_INVALIDATE);
                    }
                    fChanges = TRUE;
                }
                if (fChanges)
                    ListView_RecalcRegion(plv, TRUE, TRUE);
                if ((plv->ci.style & LVS_AUTOARRANGE) && fChanges) {
                    ListView_OnUpdate(plv, plv->iFirstChangedNoRedraw);
                } else {
                    ListView_UpdateScrollBars(plv);
                }
            }
        }
    }
    else
    {
        plv->iFirstChangedNoRedraw = -1;
        plv->flags &= ~LVF_REDRAW;
    }
}

HIMAGELIST NEAR ListView_OnGetImageList(LV* plv, int iImageList)
{
    switch (iImageList)
    {
        case LVSIL_NORMAL:
            return plv->himl;

        case LVSIL_SMALL:
            return plv->himlSmall;

        case LVSIL_STATE:
            return plv->himlState;
    }
    ASSERT(0);
    return NULL;
}


HIMAGELIST NEAR ListView_OnSetImageList(LV* plv, HIMAGELIST himl, int iImageList)
{
    HIMAGELIST hImageOld = NULL;

    switch (iImageList)
    {
        case LVSIL_NORMAL:
            hImageOld = plv->himl;
            plv->himl = himl;
            if (himl) {
                ImageList_GetIconSize(himl, &plv->cxIcon , &plv->cyIcon);

                if (!(plv->flags & LVF_ICONSPACESET)) {
                    ListView_OnSetIconSpacing(plv, (LPARAM)-1);
                }
            }
            break;

        case LVSIL_SMALL:
            hImageOld = plv->himlSmall;
            plv->himlSmall = himl;
            if (himl)
                ImageList_GetIconSize(himl, &plv->cxSmIcon , &plv->cySmIcon);
            plv->cxItem = 16 * plv->cxLabelChar + plv->cxSmIcon;
            plv->cyItem = ListView_ComputeCYItemSize(plv);
            if (plv->hwndHdr)
                SendMessage(plv->hwndHdr, HDM_SETIMAGELIST, 0, (LPARAM)himl);
            break;

        case LVSIL_STATE:
            if (himl) {
                ImageList_GetIconSize(himl, &plv->cxState , &plv->cyState);
            } else {
                plv->cxState = 0;
            }
            hImageOld = plv->himlState;
            plv->himlState = himl;
            plv->cyItem = ListView_ComputeCYItemSize(plv);
            break;

        default:
#ifdef LVDEBUG
            DebugMsg(TF_LISTVIEW, TEXT("sh TR - LVM_SETIMAGELIST: unrecognized iImageList"));
#endif
            break;
    }

    if (himl && !(plv->ci.style & LVS_SHAREIMAGELISTS))
        ImageList_SetBkColor(himl, plv->clrBk);

    if (ListView_Count(plv) > 0)
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);

    return hImageOld;
}

#ifdef UNICODE
BOOL NEAR ListView_OnGetItemA(LV* plv, LV_ITEMA *plvi) {
    LPWSTR pszW = NULL;
    LPSTR pszC = NULL;
    BOOL fRet;

    //HACK ALERT -- this code assumes that LV_ITEMA is exactly the same
    // as LV_ITEMW except for the pointer to the string.
    ASSERT(sizeof(LV_ITEMA) == sizeof(LV_ITEMW))

    if (!plvi)
        return FALSE;

    if ((plvi->mask & LVIF_TEXT) && (plvi->pszText != NULL)) {
        pszC = plvi->pszText;
        pszW = LocalAlloc(LMEM_FIXED, plvi->cchTextMax * sizeof(WCHAR));
        if (pszW == NULL)
            return FALSE;
        plvi->pszText = (LPSTR)pszW;
    }

    fRet = ListView_OnGetItem(plv, (LV_ITEM *) plvi);

    if (pszW)
    {
        if (plvi->pszText != LPSTR_TEXTCALLBACKA)
        {
            if (fRet && plvi->cchTextMax)
                ConvertWToAN(plv->ci.uiCodePage, pszC, plvi->cchTextMax, (LPWSTR)plvi->pszText, -1);
            plvi->pszText = pszC;
        }

        LocalFree(pszW);
    }

    return fRet;

}
#endif

BOOL NEAR ListView_OnGetItem(LV* plv, LV_ITEM FAR* plvi)
{
    UINT mask;
    LISTITEM FAR* pitem = NULL;
    LV_DISPINFO nm;

    if (!plvi)
    {
        RIPMSG(0, "LVM_GET(ITEM|ITEMTEXT): Invalid pitem = NULL");
        return FALSE;
    }

    if (!ListView_IsValidItemNumber(plv, plvi->iItem))
    {
#ifdef DEBUG
        // owner data views (e.g. docfind) may change the number of items in listview
        // while we are doing something, thus hitting this rip
        if (!ListView_IsOwnerData(plv))
            RIPMSG(0, "LVM_GET(ITEM|ITEMTEXT|ITEMSTATE): item=%d does not exist", plvi->iItem);
#endif
        return FALSE;
    }

    nm.item.mask = 0;
    mask = plvi->mask;

    if (!ListView_IsOwnerData(plv))
    {
        // Standard listviews
        pitem = ListView_FastGetItemPtr(plv, plvi->iItem);
        ASSERT(pitem);

        // Handle sub-item cases for report view
        //
        if (plvi->iSubItem != 0)
        {
            LISTSUBITEM lsi;

            ListView_GetSubItem(plv, plvi->iItem, plvi->iSubItem, &lsi);
            if (mask & LVIF_TEXT)
            {
                if (lsi.pszText != LPSTR_TEXTCALLBACK)
                {
                    Str_GetPtr0(lsi.pszText, plvi->pszText, plvi->cchTextMax);
                } else {
                    // if this is LVIF_NORECOMPUTE we will update pszText later
                    nm.item.mask |= LVIF_TEXT;
                }
            }

            if ((mask & LVIF_IMAGE) && (plv->exStyle & LVS_EX_SUBITEMIMAGES))
            {
                plvi->iImage = lsi.iImage;
                if (lsi.iImage == I_IMAGECALLBACK)
                    nm.item.mask |= LVIF_IMAGE;
            }

            if (mask & LVIF_STATE) {

                if (ListView_FullRowSelect(plv)) {
                    // if we're in full row select,
                    // the state bit for select and focus follows column 0.
                    lsi.state |= pitem->state & (LVIS_SELECTED | LVIS_FOCUSED | LVIS_DROPHILITED);
                }

                plvi->state = lsi.state & plvi->stateMask;


                if (plv->stateCallbackMask)
                {
                    nm.item.stateMask = (plvi->stateMask & plv->stateCallbackMask);
                    if (nm.item.stateMask)
                    {
                        nm.item.mask |= LVIF_STATE;
                        nm.item.state = 0;
                    }
                }
            }

        } else {

            if (mask & LVIF_TEXT)
            {
                if (pitem->pszText != LPSTR_TEXTCALLBACK)
                {
                    Str_GetPtr0(pitem->pszText, plvi->pszText, plvi->cchTextMax);
                } else {
                    // if this is LVIF_NORECOMPUTE we will update pszText later
                    nm.item.mask |= LVIF_TEXT;
                }
            }

            if (mask & LVIF_IMAGE)
            {
                plvi->iImage = pitem->iImage;
                if (pitem->iImage == I_IMAGECALLBACK)
                    nm.item.mask |= LVIF_IMAGE;
            }

            if (mask & LVIF_INDENT)
            {
                plvi->iIndent = pitem->iIndent;
                if (pitem->iIndent == I_INDENTCALLBACK)
                    nm.item.mask |= LVIF_INDENT;
            }

            if (mask & LVIF_STATE)
            {
                plvi->state = (pitem->state & plvi->stateMask);

                if (plv->stateCallbackMask)
                {
                    nm.item.stateMask = (plvi->stateMask & plv->stateCallbackMask);
                    if (nm.item.stateMask)
                    {
                        nm.item.mask |= LVIF_STATE;
                        nm.item.state = 0;
                    }
                }
            }
        }

        if (mask & LVIF_PARAM)
            plvi->lParam = pitem->lParam;
    }
    else
    {
        // Complete call back for info...

        // Handle sub-item cases for report view
        //
        if (plvi->iSubItem != 0)
        {
            // if there are no subitem images, don't query for them
            if (!(plv->exStyle & LVS_EX_SUBITEMIMAGES))
                mask &= ~LVIF_IMAGE;

            // don't allow indent on the non-0th column
            mask &= ~LVIF_INDENT;
        }

        if (mask & LVIF_PARAM)
            plvi->lParam = 0L;      // Dont have any to return now...

        if (mask & LVIF_STATE)
        {
            plvi->state = 0;

            if ((plvi->iSubItem == 0) || ListView_FullRowSelect(plv))
            {
                if (plvi->iItem == plv->iFocus)
                    plvi->state |= LVIS_FOCUSED;

                if (plv->plvrangeSel->lpVtbl->IsSelected(plv->plvrangeSel, plvi->iItem) == S_OK)
                    plvi->state |= LVIS_SELECTED;

                if (plv->plvrangeCut->lpVtbl->IsSelected(plv->plvrangeCut, plvi->iItem) == S_OK)
                    plvi->state |= LVIS_CUT;

                if (plvi->iItem == plv->iDropHilite)
                    plvi->state |= LVIS_DROPHILITED;

                plvi->state &= plvi->stateMask;
            }

            if (plv->stateCallbackMask)
            {
                nm.item.stateMask = (plvi->stateMask & plv->stateCallbackMask);
                if (nm.item.stateMask)
                {
                    nm.item.mask |= LVIF_STATE;
                    nm.item.state = 0;
                }
            }
        }

        nm.item.mask |= (mask & (LVIF_TEXT | LVIF_IMAGE | LVIF_INDENT));
    }

    if (mask & LVIF_NORECOMPUTE)
    {
        if (nm.item.mask & LVIF_TEXT)
            plvi->pszText = LPSTR_TEXTCALLBACK;
    }
    else if (nm.item.mask)
    {
        nm.item.iItem  = plvi->iItem;
        nm.item.iSubItem = plvi->iSubItem;
        if (ListView_IsOwnerData( plv ))
            nm.item.lParam = 0L;
        else
            nm.item.lParam = pitem->lParam;

        // just in case LVIF_IMAGE is set and callback doesn't fill it in
        // ... we'd rather have a -1 than whatever garbage is on the stack
        nm.item.iImage = -1;
        nm.item.iIndent = 0;
        if (nm.item.mask & LVIF_TEXT)
        {
            RIPMSG(plvi->pszText != NULL, "LVM_GET(ITEM|ITEMTEXT) null string pointer");

            if (plvi->pszText) {
                nm.item.pszText = plvi->pszText;
                nm.item.cchTextMax = plvi->cchTextMax;

                // Make sure the buffer is zero terminated...
                if (nm.item.cchTextMax)
                    *nm.item.pszText = 0;
            } else {
                // Don't make caller smash null pointer
                nm.item.mask &= ~LVIF_TEXT;
            }
        }

        CCSendNotify(&plv->ci, LVN_GETDISPINFO, &nm.hdr);

        // use nm.item.mask to give the app a chance to change values
        if (nm.item.mask & LVIF_INDENT)
            plvi->iIndent = nm.item.iIndent;
        if (nm.item.mask & LVIF_STATE)
            plvi->state ^= ((plvi->state ^ nm.item.state) & nm.item.stateMask);
        if (nm.item.mask & LVIF_IMAGE)
            plvi->iImage = nm.item.iImage;
        if (nm.item.mask & LVIF_TEXT)
            if (mask & LVIF_TEXT)
                plvi->pszText = CCReturnDispInfoText(nm.item.pszText, plvi->pszText, plvi->cchTextMax);
            else
                plvi->pszText = nm.item.pszText;

        if (pitem && (nm.item.mask & LVIF_DI_SETITEM))
        {

            // BUGBUG HACKHACK
            //
            // The SendNotify above can set about a terrible series of events
            // whereby asking for DISPINFO causes the shell to look around
            // (call peekmessage) to see if its got a new async icon for the
            // listview.  This lets other messages be delivered, such as an
            // UPDATEIMAGE of Index == -1 (if the user is changing icon sizing
            // at the same time).  This causes a re-enumeration of the desktop
            // and hence this very listview is torn down and rebuilt while
            // we're sitting here for the DISPINFO to finish.  Thus, as a cheap
            // and dirty solution, I check to see if the item I think I have
            // is the same one I had when I made the notify, and if not, I
            // bail.  Don't blame me, I'm just cleaning up the mess.

            if (!EVAL(pitem == ListView_GetItemPtr(plv, plvi->iItem)))
            {
                return FALSE;
            }

            if (nm.item.iSubItem == 0)
            {
                //DebugMsg(TF_LISTVIEW, "SAVING ITEMS!");
                if (nm.item.mask & LVIF_IMAGE)
                    pitem->iImage = (short) nm.item.iImage;

                if (nm.item.mask & LVIF_INDENT)
                    pitem->iIndent = (short) nm.item.iIndent;

                if (nm.item.mask & LVIF_TEXT)
                    if (nm.item.pszText) {
                        Str_Set(&pitem->pszText, nm.item.pszText);
                    }

                if (nm.item.mask & LVIF_STATE)
                    pitem->state ^= ((pitem->state ^ nm.item.state) & nm.item.stateMask);
            }
            else
            {
                ListView_SetSubItem(plv, &nm.item);
            }
        }
    }

    return TRUE;
}

#ifdef UNICODE
BOOL NEAR ListView_OnSetItemA(LV* plv, LV_ITEMA FAR* plvi) {
    LPWSTR pszW = NULL;
    LPSTR pszC = NULL;
    BOOL fRet;

    // Let ListView_OnSetItem() handle owner-data validation

    //HACK ALERT -- this code assumes that LV_ITEMA is exactly the same
    // as LV_ITEMW except for the pointer to the string.
    ASSERT(sizeof(LV_ITEMA) == sizeof(LV_ITEMW));

    if (!plvi)
        return FALSE;

    if ((plvi->mask & LVIF_TEXT) && (plvi->pszText != NULL)) {
        pszC = plvi->pszText;
        pszW = ProduceWFromA(plv->ci.uiCodePage, pszC);
        if (pszW == NULL)
            return FALSE;
        plvi->pszText = (LPSTR)pszW;
    }

    fRet = ListView_OnSetItem(plv, (const LV_ITEM FAR*) plvi);

    if (pszW != NULL) {
        plvi->pszText = pszC;

        FreeProducedString(pszW);
    }

    return fRet;

}
#endif

BOOL NEAR ListView_OnSetItem(LV* plv, const LV_ITEM FAR* plvi)
{
    LISTITEM FAR* pitem = NULL;
    UINT mask;
    UINT maskChanged;
    UINT rdwFlags=RDW_INVALIDATE;
    int i;
    UINT stateOld, stateNew;
    BOOL fFocused = FALSE;
    BOOL fSelected = FALSE;
    BOOL fStateImageChanged = FALSE;

    if (ListView_IsOwnerData(plv)) {
      RIPMSG(0, "LVM_SETITEM: Invalid for owner-data listview");
      return FALSE;
    }

    if (!plvi)
        return FALSE;

    ASSERT(plvi->iSubItem >= 0);

    if (plv->himl && (plv->clrBk != ImageList_GetBkColor(plv->himl)))
        rdwFlags |= RDW_ERASE;

    mask = plvi->mask;
    if (!mask)
        return TRUE;

    // If we're setting a subitem, handle it elsewhere...
    //
    if (plvi->iSubItem > 0)
        return ListView_SetSubItem(plv, plvi);

    i = plvi->iItem;

    ListView_InvalidateTTLastHit(plv, i);

    pitem = ListView_GetItemPtr(plv, i);
    if (!pitem)
        return FALSE;

    //REVIEW: This is a BOGUS HACK, and should be fixed.
    //This incorrectly calculates the old state (since we may
    // have to send LVN_GETDISPINFO to get it).
    //
    stateOld = stateNew = 0;
    if (mask & LVIF_STATE)
    {
        stateOld = pitem->state & plvi->stateMask;
        stateNew = plvi->state & plvi->stateMask;
    }

    // Prevent multiple selections in a single-select listview.
    if ((plv->ci.style & LVS_SINGLESEL) && (mask & LVIF_STATE) && (stateNew & LVIS_SELECTED)) {
        ListView_DeselectAll(plv, i);

        // Refresh the old state information
        stateOld = pitem->state & plvi->stateMask;
    }

    if (!ListView_SendChange(plv, i, 0, LVN_ITEMCHANGING, stateOld, stateNew, mask, pitem->lParam))
        return FALSE;

    maskChanged = 0;
    if (mask & LVIF_STATE)
    {
        UINT change = (pitem->state ^ plvi->state) & plvi->stateMask;

        if (change)
        {
            pitem->state ^= change;

            maskChanged |= LVIF_STATE;

            // the selection state has changed.. update selected count
            if (change & LVIS_SELECTED)
            {
                fSelected = TRUE;

                if (pitem->state & LVIS_SELECTED) {
                    plv->nSelected++;
                } else {
                    if (plv->nSelected > 0)
                        plv->nSelected--;
                }
            }

            // For some bits we can only invert the label area...
            // fSelectOnlyChange = ((change & ~(LVIS_SELECTED | LVIS_FOCUSED | LVIS_DROPHILITED)) == 0);
            // fEraseItem = ((change & ~(LVIS_SELECTED | LVIS_DROPHILITED)) != 0);

            // try to steal focus from the previous guy.
            if (change & LVIS_FOCUSED)
            {
                BOOL fUnfolded = ListView_IsItemUnfolded(plv, plv->iFocus);
                int iOldFocus = plv->iFocus;
                RECT rcLabel;

                fFocused = TRUE;

                if (plv->iFocus != i) {
                    if ((plv->iFocus == -1) || ListView_OnSetItemState(plv, plv->iFocus, 0, LVIS_FOCUSED)) {
                        ASSERT(pitem->state & LVIS_FOCUSED);
                        plv->iFocus = i;
                        if (plv->iMark == -1)
                            plv->iMark = i;
                    } else {
                        fFocused = FALSE;
                        pitem->state &= ~LVIS_FOCUSED;
                    }
                } else {
                    ASSERT(!(pitem->state & LVIS_FOCUSED));
                    plv->iFocus = -1;
                }

                // If we were previously unfolded and we move the focus we must
                // attempt to refresh the previous focus owner to referect this change.

                if (fUnfolded && !ListView_IsItemUnfolded(plv, iOldFocus) && (plv->iItemDrawing != iOldFocus))
                {
                    ListView_GetUnfoldedRect(plv, iOldFocus, &rcLabel);
                    RedrawWindow(plv->ci.hwnd, &rcLabel, NULL, RDW_INVALIDATE|RDW_ERASE);
                }

                // Kill the tooltip if focus moves, it causes us headaches otherwise!
                ListView_PopBubble(plv);
            }

            if (change & LVIS_CUT ||
                plv->clrTextBk == CLR_NONE)
                rdwFlags |= RDW_ERASE;

            if (change & LVIS_OVERLAYMASK) {
                // Overlay changed, so need to blow away icon region cache
                if (pitem->hrgnIcon) {
                    if (pitem->hrgnIcon != (HANDLE) -1)
                        DeleteObject(pitem->hrgnIcon);
                    pitem->hrgnIcon = NULL;
                }
            }

            fStateImageChanged = (change & LVIS_STATEIMAGEMASK);

        }
    }

    if (mask & LVIF_TEXT)
    {
        // need to do this now because we're changing the text
        // so we need to get the rect of the thing before the text changes
        // but don't redraw the item we are currently painting
        if (plv->iItemDrawing != i)
        {
            ListView_InvalidateItemEx(plv, i, FALSE,
                RDW_INVALIDATE | RDW_ERASE, LVIF_TEXT);
        }

        if (!Str_Set(&pitem->pszText, plvi->pszText))
            return FALSE;

        plv->rcView.left = RECOMPUTE;
        ListView_SetSRecompute(pitem);
        maskChanged |= LVIF_TEXT;
    }

    if (mask & LVIF_INDENT) {
        if (pitem->iIndent != plvi->iIndent)
        {
            pitem->iIndent = (short) plvi->iIndent;
            maskChanged |= LVIF_INDENT;

            if (ListView_IsReportView(plv))
                rdwFlags |= RDW_ERASE;
        }
    }

    if (mask & LVIF_IMAGE)
    {
        if (pitem->iImage != plvi->iImage)
        {
            pitem->iImage = (short) plvi->iImage;
            maskChanged |= LVIF_IMAGE;

            if (pitem->hrgnIcon) {
                if (pitem->hrgnIcon != (HANDLE) -1)
                    DeleteObject(pitem->hrgnIcon);
                pitem->hrgnIcon = NULL;
            }

            // erase if there was a set image
            if (pitem->iImage != I_IMAGECALLBACK)
                rdwFlags |= RDW_ERASE;
        }
    }

    if (mask & LVIF_PARAM)
    {
        if (pitem->lParam != plvi->lParam)
        {
            pitem->lParam = plvi->lParam;
            maskChanged |= LVIF_PARAM;
        }
    }


    if (maskChanged)
    {
        // don't redraw the item we are currently painting
        if (plv->iItemDrawing != i)
            ListView_InvalidateItemEx(plv, i, FALSE, rdwFlags, maskChanged);

        DebugMsg(DM_LVSENDCHANGE, TEXT("LV - SendChange %d %d %d %d"), i, stateOld, stateNew, maskChanged);
        ListView_SendChange(plv, i, 0, LVN_ITEMCHANGED, stateOld, stateNew, maskChanged, pitem->lParam);

        if (maskChanged & LVIF_TEXT)
            MyNotifyWinEvent(EVENT_OBJECT_NAMECHANGE, plv->ci.hwnd, OBJID_CLIENT, i+1);

        if (maskChanged & LVIF_STATE)
        {
            if (fFocused)
                ListView_NotifyFocusEvent(plv);

            if (fSelected)
            {
                if (stateNew & LVIS_SELECTED)
                {
                    MyNotifyWinEvent((plv->nSelected == 1) ? EVENT_OBJECT_SELECTION :
                        EVENT_OBJECT_SELECTIONADD, plv->ci.hwnd, OBJID_CLIENT, i+1);
                }
                else
                {
                    MyNotifyWinEvent(EVENT_OBJECT_SELECTIONREMOVE, plv->ci.hwnd, OBJID_CLIENT, i+1);
                }
            }

            if (fStateImageChanged)
                MyNotifyWinEvent(EVENT_OBJECT_STATECHANGE, plv->ci.hwnd, OBJID_CLIENT, i+1);
        }
    }
    return TRUE;
}

UINT NEAR PASCAL ListView_OnGetItemState(LV* plv, int i, UINT mask)
{
    LV_ITEM lvi;

    lvi.mask = LVIF_STATE;
    lvi.stateMask = mask;
    lvi.iItem = i;
    lvi.iSubItem = 0;
    if (!ListView_OnGetItem(plv, &lvi))
        return 0;

    return lvi.state;
}


BOOL NEAR PASCAL ListView_OnSetItemState(LV* plv, int i, UINT data, UINT mask)
{
    UINT rdwFlags = RDW_INVALIDATE;
    LV_ITEM lvi;

    lvi.mask    = LVIF_STATE;
    lvi.state   = data;
    lvi.stateMask = mask;
    lvi.iItem   = i;
    lvi.iSubItem = 0;

    // if the item is -1, we will do it for all items.  We special case
    // a few cases here as to speed it up.  For example if the mask is
    // LVIS_SELECTED and data is zero it implies that we will deselect
    // all items...
    //
    if (ListView_IsOwnerData( plv ))
    {
        UINT uOldData = 0;

        // these are the only two we handled
        mask &= (LVIS_SELECTED | LVIS_FOCUSED | LVIS_CUT | LVIS_DROPHILITED);
        if (!mask)
            return TRUE;

        if (plv->clrTextBk == CLR_NONE
            || (plv->himl && (plv->clrBk != ImageList_GetBkColor(plv->himl))))
        {
            rdwFlags |= RDW_ERASE;
        }

        if (i == -1)
        {

            // request selection state change for all
            if (mask & LVIS_SELECTED)
            {
                if (data & LVIS_SELECTED)
                {  // set selection
                    if ((plv->ci.style & LVS_SINGLESEL))
                    {   // cant make multiple selections in a single-select listview.
                        return( FALSE );
                    }

                    if (plv->cTotalItems)
                    {
                        if (FAILED(plv->plvrangeSel->lpVtbl->IncludeRange(plv->plvrangeSel, 0, plv->cTotalItems - 1)))
                            return( FALSE );
                    }

                    RedrawWindow( plv->ci.hwnd, NULL, NULL, rdwFlags );

                }
                else
                {  // clear selection
                    if (plv->nSelected > 0) {

                        ListView_InvalidateSelectedOrCutOwnerData(plv, plv->plvrangeSel);
                        if (FAILED(plv->plvrangeSel->lpVtbl->Clear( plv->plvrangeSel )))
                            return FALSE;
                    } else {
                        // if nothing was selected, then there's nothing to clear
                        // no change.
                        mask &= ~ LVIS_SELECTED;
                    }
                }
                uOldData |= (LVIS_SELECTED & (mask ^ data));

                // Update our internal count to what the list thinks is the number selected...
                plv->plvrangeSel->lpVtbl->CountIncluded(plv->plvrangeSel, &plv->nSelected);

            }

            // can maybe combine with above code...
            if (mask & LVIS_CUT)
            {
                if (data & LVIS_CUT)
                {  // set selection

                    if (plv->cTotalItems)
                        if (FAILED(plv->plvrangeCut->lpVtbl->IncludeRange(plv->plvrangeCut, 0, plv->cTotalItems - 1)))
                            return( FALSE );

                    RedrawWindow( plv->ci.hwnd, NULL, NULL, rdwFlags );

                }
                else
                {  // clear selection
                    if (plv->plvrangeCut->lpVtbl->IsEmpty(plv->plvrangeCut) != S_OK) {
                        ListView_InvalidateSelectedOrCutOwnerData(plv, plv->plvrangeCut);
                        if (FAILED(plv->plvrangeCut->lpVtbl->Clear( plv->plvrangeCut)))
                            return( FALSE );

                    } else {
                        // if nothing was selected, then there's nothing to clear
                        // no change.
                        mask &= ~ LVIS_CUT;
                    }
                }
                uOldData |= (LVIS_CUT & (mask ^ data));

            }

            // request focus state change
            if (mask & LVIS_FOCUSED)
            {
                if (data & LVIS_FOCUSED)
                {  // cant set focus to all
                    return( FALSE );
                }
                else if (plv->iFocus != -1)
                {
                    int iOldFocus = plv->iFocus;
                    // clear focus
                    uOldData |= (LVIS_FOCUSED & (mask ^ data));
                    plv->iFocus = -1;
                    // notify that the old focus is being lost
                    DebugMsg(DM_LVSENDCHANGE, TEXT("VLV: LVN_ITEMCHANGED: %d %d %d"), iOldFocus, LVIS_FOCUSED, 0);
                    ListView_SendChange(plv, iOldFocus, 0, LVN_ITEMCHANGED, LVIS_FOCUSED, 0, LVIF_STATE, 0);
                    ListView_InvalidateFoldedItem(plv, iOldFocus, TRUE, RDW_INVALIDATE |RDW_ERASE);
                }
            }

            if (mask & LVIS_DROPHILITED)
            {
                if (data & LVIS_DROPHILITED)
                {  // cant set focus to all
                    return( FALSE );
                }
                else if (plv->iDropHilite != -1)
                {
                    int iOldDropHilite = plv->iDropHilite;
                    // clear focus
                    uOldData |= (LVIS_FOCUSED & (mask ^ data));
                    plv->iDropHilite = -1;
                    // notify that the old focus is being lost
                    ListView_SendChange(plv, iOldDropHilite, 0, LVN_ITEMCHANGED, LVIS_DROPHILITED, 0, LVIF_STATE, 0);
                    ListView_InvalidateFoldedItem(plv, iOldDropHilite, TRUE, RDW_INVALIDATE |RDW_ERASE);
                }
            }

            // invalidate and notify if there was a change
            if (uOldData ^ (data & mask)) {
                DebugMsg(DM_LVSENDCHANGE, TEXT("VLV: LVN_ITEMCHANGED: %d %d %d"), i, uOldData, data);
                ListView_SendChange(plv, i, 0, LVN_ITEMCHANGED, uOldData, data, LVIF_STATE, 0);

                if (mask & LVIS_SELECTED)
                {
                    // Tell accessibility, "Selection changed in a complex way"
                    // (There is no "select all" or "select none" notification)
                    MyNotifyWinEvent(EVENT_OBJECT_SELECTIONWITHIN, plv->ci.hwnd, OBJID_CLIENT, CHILDID_SELF);
                }

            }
        }
        else
        {
            if (!ListView_IsValidItemNumber(plv, i))
                return (FALSE);

            // request selection state change
            // and the selection state is new...
            if ((mask & LVIS_SELECTED)) {


                if (((plv->plvrangeSel->lpVtbl->IsSelected(plv->plvrangeSel, i) == S_OK) ? LVIS_SELECTED : 0) ^ (data & LVIS_SELECTED))
                {
                    if (data & LVIS_SELECTED)
                    {  // set selection
                        if ((plv->ci.style & LVS_SINGLESEL))
                        {
                            // in single selection mode, we need to deselect everything else
                            if (!ListView_OnSetItemState(plv, -1, 0, LVIS_SELECTED))
                                return FALSE;
                        }

                        // now select the new item
                        if (FAILED(plv->plvrangeSel->lpVtbl->IncludeRange(plv->plvrangeSel, i, i)))
                            return FALSE;

                    }
                    else
                    {  // clear selection
                        if (FAILED(plv->plvrangeSel->lpVtbl->ExcludeRange(plv->plvrangeSel, i, i )))
                            return( FALSE );
                    }

                    // something actually changed (or else we wouldn't be in this
                    // if block
                    uOldData |= (LVIS_SELECTED & (mask ^ data));

                } else {

                    // nothing changed... so make the uOldData be the same for this bit
                    // else make this the same as
                    uOldData |= (LVIS_SELECTED & (mask & data));
                }

                // Update our internal count to what the list thinks is the number selected...
                plv->plvrangeSel->lpVtbl->CountIncluded(plv->plvrangeSel, &plv->nSelected);
            }

            if ((mask & LVIS_CUT)) {

                if (((plv->plvrangeCut->lpVtbl->IsSelected(plv->plvrangeCut, i) == S_OK) ? LVIS_CUT : 0) ^ (data & LVIS_CUT))
                {
                    if (data & LVIS_CUT)
                    {
                        // now select the new item
                        if (FAILED(plv->plvrangeCut->lpVtbl->IncludeRange(plv->plvrangeCut, i, i )))
                            return FALSE;
                    }
                    else
                    {  // clear selection
                        if (FAILED(plv->plvrangeCut->lpVtbl->ExcludeRange(plv->plvrangeCut, i, i )))
                            return( FALSE );
                    }

                    // something actually changed (or else we wouldn't be in this
                    // if block
                    uOldData |= (LVIS_CUT & (mask ^ data));
                    rdwFlags |= RDW_ERASE;

                } else {

                    // nothing changed... so make the uOldData be the same for this bit
                    // else make this the same as
                    uOldData |= (LVIS_CUT & (mask & data));
                }
            }

            // request focus state change
            if (mask & LVIS_FOCUSED)
            {
                int iOldFocus = plv->iFocus;

                if (data & LVIS_FOCUSED)
                {  // set focus
                    if (i != plv->iFocus)
                    {
                        // we didn't have the focus before
                        plv->iFocus = i;
                        if (plv->iMark == -1)
                            plv->iMark = i;
                        if (iOldFocus != -1) {

                            // we're stealing it from someone
                            // notify of the change
                            DebugMsg(DM_LVSENDCHANGE, TEXT("VLV: LVN_ITEMCHANGED: %d %d %d"), iOldFocus, LVIS_FOCUSED, 0);
                            ListView_SendChange(plv, iOldFocus, 0, LVN_ITEMCHANGED, LVIS_FOCUSED, 0, LVIF_STATE, 0);

                        }
                    } else {
                        // we DID have the focus before
                        uOldData |= LVIS_FOCUSED;
                    }
                }
                else
                {  // clear focus
                    if (i == plv->iFocus)
                    {
                        plv->iFocus = -1;
                        uOldData |= LVIS_FOCUSED;
                    }
                }

            }

            // request focus state change
            if (mask & LVIS_DROPHILITED)
            {
                int iOldDropHilite = plv->iDropHilite;

                if (data & LVIS_DROPHILITED)
                {  // set Drop Hilite
                    if (i != plv->iDropHilite)
                    {
                        // we didn't have the Drop Hilite before
                        plv->iDropHilite = i;
                        if (iOldDropHilite != -1) {

                            // we're stealing it from someone
                            // notify of the change
                            ListView_SendChange(plv, iOldDropHilite, 0, LVN_ITEMCHANGED, LVIS_DROPHILITED, 0, LVIF_STATE, 0);
                            ListView_InvalidateFoldedItem(plv, iOldDropHilite, TRUE, RDW_INVALIDATE |RDW_ERASE);

                        }
                    } else {
                        // we DID have the Drop Hilite before
                        uOldData |= LVIS_DROPHILITED;
                    }
                }
                else
                {  // clear Drop Hilite
                    if (i == plv->iDropHilite)
                    {
                        plv->iDropHilite = -1;
                        uOldData |= LVIS_DROPHILITED;
                    }
                }

            }

            // invalidate and notify if there was a change
            if (uOldData ^ (data & mask)) {
                DebugMsg(DM_LVSENDCHANGE, TEXT("VLV: LVN_ITEMCHANGED: %d %d %d"), i, uOldData, data);
                ListView_SendChange(plv, i, 0, LVN_ITEMCHANGED, uOldData, data, LVIF_STATE, 0);
                ListView_InvalidateItem(plv, i, TRUE, rdwFlags);

                // Kill the tooltip if focus moves, it causes us headaches otherwise!
                if ((uOldData ^ (data & mask)) & LVIS_FOCUSED)
                {
                    ListView_PopBubble(plv);
                    ListView_NotifyFocusEvent(plv);
                }

                // Tell accessibility about the changes
                if (mask & LVIS_SELECTED) {
                    UINT event;

                    if (data & LVIS_SELECTED) {
                        if (plv->nSelected == 1)
                            event = EVENT_OBJECT_SELECTION; // this object is the entire selection
                        else
                            event = EVENT_OBJECT_SELECTIONADD; // this object is selected
                    } else
                        event = EVENT_OBJECT_SELECTIONREMOVE; // this object is unselected
                    MyNotifyWinEvent(event, plv->ci.hwnd, OBJID_CLIENT, i + 1);
                }
            }
        }

    } else {

        if (i != -1) {
            return ListView_OnSetItem(plv, &lvi);
        } else {
            UINT flags = LVNI_ALL;


            if (data == 0)
            {
                switch (mask)
                {
                case LVIS_SELECTED:
                    flags = LVNI_SELECTED;
                    break;
                case LVIS_CUT:
                    flags = LVNI_CUT;
                    break;
                }
            }
            else if ((plv->ci.style & LVS_SINGLESEL) && (mask == LVIS_SELECTED))
                return FALSE;   /* can't select all in single-select listview */
            else if ((mask & data) & LVIS_FOCUSED) {
                return FALSE; // can't set focus to everything
            }

            //
            // Now iterate over all of the items that match our criteria and
            // set their new value.
            //
            while ((lvi.iItem = ListView_OnGetNextItem(plv, lvi.iItem,
                                                       flags)) != -1) {
                ListView_OnSetItem(plv, &lvi);
            }
        }
    }
    return(TRUE);
}

//
// Returns TRUE if the label of an item is not truncated (is unfolded) and FALSE
// otherwise. If FALSE is returned, it also fills the Unfolding text in pszText.
// If TRUE is returned, pszText is set to empty string.
//
BOOL ListView_IsItemUnfolded2(LV* plv, int iItem, int iSubItem, LPTSTR pszText, int cchTextMax)
{
    BOOL bItemUnfolded = ListView_IsItemUnfolded(plv, iItem);

    if (pszText && cchTextMax > 0)    // Sanity checks on input params.
    {
        pszText[0] = 0;


        if (!bItemUnfolded)
        {
            RECT rcLabel;
            LV_ITEM item;

            item.iItem = iItem;
            item.iSubItem = iSubItem;
            item.mask = LVIF_TEXT | LVIF_PARAM;
            if (!ListView_IsIconView(plv))
            {
                if (ListView_IsLabelTip(plv) || ListView_IsInfoTip(plv))
                {
                    BOOL fSuccess;

                    rcLabel.left = LVIR_LABEL;

                    if (iSubItem) {
                        rcLabel.top = iSubItem;
                        fSuccess = ListView_OnGetSubItemRect(plv, iItem, &rcLabel);
                    } else {
                        fSuccess = ListView_OnGetItemRect(plv, iItem, &rcLabel);
                    }

                    if (fSuccess)
                    {
                        TCHAR szText[INFOTIPSIZE];

                        item.pszText = szText;
                        item.cchTextMax = min(ARRAYSIZE(szText), cchTextMax);
                        if (ListView_OnGetItem(plv, &item) && item.pszText != LPSTR_TEXTCALLBACK)
                        {
                            SIZE siz;
                            LVFAKEDRAW lvfd;
                            int cx;

                            ListView_BeginFakeCustomDraw(plv, &lvfd, &item);
                            ListView_BeginFakeItemDraw(&lvfd);

                            //        ---------Label width----------- ---Client width---
                             cx = min(rcLabel.right - g_cxLabelMargin, plv->sizeClient.cx);

                            if (GetTextExtentPoint32(lvfd.nmcd.nmcd.hdc, item.pszText, lstrlen(item.pszText), &siz) &&
                                (rcLabel.left + g_cxLabelMargin + siz.cx) > cx)
                            {
                                lstrcpyn(pszText, item.pszText, item.cchTextMax);
                            }
                            else
                            {
                                // Not truncated after all
                                bItemUnfolded = TRUE;
                            }

                            ListView_EndFakeItemDraw(&lvfd);
                            ListView_EndFakeCustomDraw(&lvfd);
                        }
                    }
                }
            }
            else
            {
                // Large icon view is the only one that folds
                if (ListView_GetUnfoldedRect(plv, iItem, &rcLabel))
                {
                    item.pszText = pszText;
                    item.cchTextMax = cchTextMax;
                    ListView_OnGetItem(plv, &item);
                }
                else
                {
                    // Item was never folded
                    bItemUnfolded = TRUE;
                }
            }
        }
    }
    return bItemUnfolded;
}

#ifdef UNICODE

// Rather than thunking to ListView_OnGetItemText, we let ListView_GetItemA
// do the work.

int NEAR PASCAL ListView_OnGetItemTextA(LV* plv, int i, LV_ITEMA FAR *plvi)
{
    if (!plvi)
        return 0;

    RIPMSG(plvi->pszText != NULL, "LVM_GETITEMTEXT null string pointer");

    plvi->mask = LVIF_TEXT;
    plvi->iItem = i;
    if (!ListView_OnGetItemA(plv, plvi))
        return 0;

    return lstrlenA(plvi->pszText);
}
#endif

int NEAR PASCAL ListView_OnGetItemText(LV* plv, int i, LV_ITEM FAR *plvi)
{
    if (!plvi)
        return 0;

    RIPMSG(plvi->pszText != NULL, "LVM_GETITEMTEXT null string pointer");

    plvi->mask = LVIF_TEXT;
    plvi->iItem = i;
    if (!ListView_OnGetItem(plv, plvi))
        return 0;

    return lstrlen(plvi->pszText);
}


#ifdef UNICODE
BOOL WINAPI ListView_OnSetItemTextA(LV* plv, int i, int iSubItem, LPCSTR pszText) {
    LPWSTR pszW = NULL;
    BOOL fRet;

    // Let ListView_OnSetItemText() handle owner-data validation

    if (pszText != NULL) {
        pszW = ProduceWFromA(plv->ci.uiCodePage, pszText);
        if (pszW == NULL) {
            return FALSE;
        }
    }

    fRet = ListView_OnSetItemText(plv, i, iSubItem, pszW);

    FreeProducedString(pszW);

    return fRet;
}
#endif

BOOL WINAPI ListView_OnSetItemText(LV* plv, int i, int iSubItem, LPCTSTR pszText)
{
    LV_ITEM lvi;

    if (ListView_IsOwnerData(plv))
    {
       RIPMSG(0, "LVM_SETITEMTEXT: Invalid for owner-data listview");
       return FALSE;
    }

    ListView_InvalidateTTLastHit(plv, i);

    lvi.mask = LVIF_TEXT;
    lvi.pszText = (LPTSTR)pszText;
    lvi.iItem = i;
    lvi.iSubItem = iSubItem;

    return ListView_OnSetItem(plv, &lvi);
}

VOID CALLBACK ImgCtxCallback(void * pvImgCtx, void * pvArg)
{
    LV *plv = (LV *)pvArg;
    ULONG ulState;
    SIZE sizeImg;
    IImgCtx *pImgCtx = plv->pImgCtx;

    IImgCtx_GetStateInfo(pImgCtx, &ulState, &sizeImg, TRUE);

    if (ulState & (IMGLOAD_STOPPED | IMGLOAD_ERROR))
    {
        TraceMsg(TF_BKIMAGE, "Error!");
        plv->fImgCtxComplete = FALSE;
    }

    else if (ulState & IMGCHG_COMPLETE)
    {
        TraceMsg(TF_BKIMAGE, "Complete!");
        plv->fImgCtxComplete = TRUE;
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
    }
}

void ListView_ReleaseBkImage(LV *plv)
{
    if (plv->pImgCtx)
    {
        IImgCtx_Release(plv->pImgCtx);
        plv->pImgCtx = NULL;

        if (plv->hpalHalftone)
        {
            // No need to delete the half tone palette since we really
            // share it with the image context and it will clean up.
            plv->hpalHalftone = NULL;
        }
    }

    if (plv->hbmBkImage)
    {
        DeleteObject(plv->hbmBkImage);
        plv->hbmBkImage = NULL;
    }

    if (plv->pszBkImage)
    {
        LocalFree(plv->pszBkImage);
        plv->pszBkImage = NULL;
    }
}

BOOL WINAPI ListView_OnSetBkImage(LV* plv, LPLVBKIMAGE pbi)
{
    LPCTSTR pszImage = pbi->pszImage;
    BOOL fRet = FALSE;
    LONG fl;

    switch (pbi->ulFlags & LVBKIF_SOURCE_MASK)
    {
    case LVBKIF_SOURCE_NONE:
        TraceMsg(TF_BKIMAGE, "LV SetBkImage to none");
        ListView_ReleaseBkImage(plv);
        break;

    case LVBKIF_SOURCE_HBITMAP:
        TraceMsg(TF_BKIMAGE, "LV SetBkImage to hBitmap %08lX", pbi->hbm);
        ListView_ReleaseBkImage(plv);
        if (pbi->hbm)
        {
            plv->hbmBkImage = pbi->hbm;
            ASSERT(0); // KenSy hasn't implemented init from bitmap yet...
        }
        else
        {
            pbi->ulFlags &= ~LVBKIF_SOURCE_HBITMAP;
        }
        break;

    case LVBKIF_SOURCE_URL:
        TraceMsg(TF_BKIMAGE, "LV SetBkImage to URL");
        ListView_ReleaseBkImage(plv);
        if (pszImage && pszImage[0])
        {
            HRESULT (*pfnCoCreateInstance)(REFCLSID, LPUNKNOWN, DWORD, REFIID, LPVOID *);
            HRESULT hr;
            HMODULE hmodOLE;

            plv->pszBkImage = LocalAlloc(LPTR, (lstrlen(pszImage) + 1) * sizeof(TCHAR));
            if (plv->pszBkImage == NULL)
            {
                TraceMsg(TF_BKIMAGE, "Wow, could not allocate memory for string!");
                return FALSE;
            }
            lstrcpy(plv->pszBkImage, pszImage);

            if (((hmodOLE = GetModuleHandle(TEXT("OLE32"))) == NULL) ||
                ((pfnCoCreateInstance = (HRESULT (*)(REFCLSID, LPUNKNOWN, DWORD, REFIID, LPVOID *))GetProcAddress(hmodOLE, "CoCreateInstance")) == NULL))
            {
                TraceMsg(TF_BKIMAGE, "Could not find CoCreateInstance!");
                TraceMsg(TF_BKIMAGE, "Did the caller remember to call CoInitialize?");
                return FALSE;
            }

            hr = pfnCoCreateInstance(&CLSID_IImgCtx, NULL, CLSCTX_INPROC_SERVER,
                                     &IID_IImgCtx, (LPVOID *)&plv->pImgCtx);

            if (FAILED(hr))
            {
                TraceMsg(TF_BKIMAGE, "Could not create a pImgCtx!");
                TraceMsg(TF_BKIMAGE, "Did you remember to register IEIMAGE.DLL?");
                return FALSE;
            }
            //
            // Mirror the downloaded image if the listview window is RTL mirrored,
            // so that it would be displayed as is. [samera]
            //
            fl = ((IS_WINDOW_RTL_MIRRORED(plv->ci.hwnd)) ? DWN_MIRRORIMAGE : 0);

#ifdef UNICODE
            hr = IImgCtx_Load(plv->pImgCtx, pszImage, fl);
#else
            {
                //
                // Darn IImgCtx::Load only takes wide URLs, sigh
                //
                LPWSTR pwszImage;

                pwszImage = ProduceWFromA(plv->ci.uiCodePage, pszImage);
                if (!pwszImage)
                {
                    IImgCtx_Release(plv->pImgCtx);
                    plv->pImgCtx = NULL;
                    TraceMsg(TF_BKIMAGE, "Could not convert URL to wide!");
                    return FALSE;
                }
                hr = IImgCtx_Load(plv->pImgCtx, pwszImage, fl);
                FreeProducedString(pwszImage);
            }
#endif
            if (FAILED(hr))
            {
                IImgCtx_Release(plv->pImgCtx);
                plv->pImgCtx = NULL;
                TraceMsg(TF_BKIMAGE, "Could not init a pImgCtx!");
                return FALSE;
            }
        }
        else
        {
            pbi->ulFlags &= ~LVBKIF_SOURCE_URL;
        }
        break;

    default:
        RIPMSG(0, "LVM_SETBKIMAGE: Unsupported image type %d", pbi->ulFlags & LVBKIF_SOURCE_MASK);
        return FALSE;
    }

    plv->ulBkImageFlags = pbi->ulFlags;
    plv->xOffsetPercent = pbi->xOffsetPercent;
    plv->yOffsetPercent = pbi->yOffsetPercent;

    //
    // If we actually created a pImgCtx, initialize it here.
    //
    if (plv->pImgCtx)
    {
        if (plv->hpalHalftone == NULL)
        {
            IImgCtx_GetPalette(plv->pImgCtx, &plv->hpalHalftone);
        }

        plv->fImgCtxComplete = FALSE;
        IImgCtx_SetCallback(plv->pImgCtx, ImgCtxCallback, plv);
        IImgCtx_SelectChanges(plv->pImgCtx, IMGCHG_COMPLETE, 0, TRUE);

        TraceMsg(TF_BKIMAGE, "  SUCCESS!");
        fRet = TRUE;
    }
    InvalidateRect(plv->ci.hwnd, NULL, TRUE);

    return fRet;
}

#ifdef UNICODE
BOOL WINAPI ListView_OnSetBkImageA(LV* plv, LPLVBKIMAGEA pbiA)
{
    BOOL fProducedString = FALSE;
    BOOL fRet;
    LVBKIMAGEW biW;

    CopyMemory(&biW, pbiA, SIZEOF(LVBKIMAGE));

    switch (biW.ulFlags & LVBKIF_SOURCE_MASK)
    {
    case LVBKIF_SOURCE_NONE:
    case LVBKIF_SOURCE_HBITMAP:
        break;

    case LVBKIF_SOURCE_URL:
        if (biW.pszImage != NULL)
        {
            biW.pszImage = ProduceWFromA(plv->ci.uiCodePage, (LPCSTR)biW.pszImage);
            if (biW.pszImage == (LPARAM)NULL)
            {
                return FALSE;
            }
            fProducedString = TRUE;
        }
        break;

    default:
        // Let ListView_OnSetBkImage() complain about the invalid parameter
        break;
    }

    fRet = ListView_OnSetBkImage(plv, &biW);

    if (fProducedString)
    {
        FreeProducedString((LPVOID)biW.pszImage);
    }

    return fRet;
}
#endif

BOOL WINAPI ListView_OnGetBkImage(LV* plv, LPLVBKIMAGE pbi)
{
    BOOL fRet = FALSE;

    if (!IsBadWritePtr(pbi, sizeof(*pbi)))
    {
        pbi->ulFlags = plv->ulBkImageFlags;

        switch (plv->ulBkImageFlags & LVBKIF_SOURCE_MASK)
        {
        case LVBKIF_SOURCE_NONE:
            fRet = TRUE;
            break;

        case LVBKIF_SOURCE_HBITMAP:
            pbi->hbm = plv->hbmBkImage;
            fRet = TRUE;
            break;

        case LVBKIF_SOURCE_URL:
            if (!IsBadWritePtr(pbi->pszImage, pbi->cchImageMax * SIZEOF(TCHAR)))
            {
                lstrcpyn(pbi->pszImage, plv->pszBkImage, pbi->cchImageMax);
                fRet = TRUE;
            }
            break;

        default:
            ASSERT(0);
            break;
        }

        pbi->xOffsetPercent = plv->xOffsetPercent;
        pbi->yOffsetPercent = plv->yOffsetPercent;
    }

    return fRet;
}

#ifdef UNICODE
BOOL WINAPI ListView_OnGetBkImageA(LV* plv, LPLVBKIMAGEA pbiA)
{
    BOOL fRet = FALSE;

    if (!IsBadWritePtr(pbiA, sizeof(*pbiA)))
    {
        pbiA->ulFlags = plv->ulBkImageFlags;

        switch (plv->ulBkImageFlags & LVBKIF_SOURCE_MASK)
        {
        case LVBKIF_SOURCE_NONE:
            fRet = TRUE;
            break;

        case LVBKIF_SOURCE_HBITMAP:
            pbiA->hbm = plv->hbmBkImage;
            fRet = TRUE;
            break;

        case LVBKIF_SOURCE_URL:
            if (!IsBadWritePtr(pbiA->pszImage, pbiA->cchImageMax))
            {
                ConvertWToAN(plv->ci.uiCodePage, pbiA->pszImage,
                             pbiA->cchImageMax, plv->pszBkImage, -1);
                fRet = TRUE;
            }
            break;

        default:
            ASSERT(0);
            break;
        }

        pbiA->xOffsetPercent = plv->xOffsetPercent;
        pbiA->yOffsetPercent = plv->yOffsetPercent;
    }

    return fRet;
}
#endif

void ListView_FreeSubItem(PLISTSUBITEM plsi)
{
    if (plsi) {
        Str_Set(&plsi->pszText, NULL);
        LocalFree(plsi);
    }
}

int NEAR ListView_GetCxScrollbar(LV* plv)
{
    int cx;

    if (((plv->exStyle & LVS_EX_FLATSB) == 0) ||
        !FlatSB_GetScrollProp(plv->ci.hwnd, WSB_PROP_CXVSCROLL, &cx))
    {
        cx = g_cxScrollbar;
    }

    return cx;
}

int NEAR ListView_GetCyScrollbar(LV* plv)
{
    int cy;

    if (((plv->exStyle & LVS_EX_FLATSB) == 0) ||
        !FlatSB_GetScrollProp(plv->ci.hwnd, WSB_PROP_CYHSCROLL, &cy))
    {
        cy = g_cyScrollbar;
    }

    return cy;
}

DWORD NEAR ListView_GetWindowStyle(LV* plv)
{
    DWORD dwStyle;

    if (((plv->exStyle & LVS_EX_FLATSB) == 0) ||
        !FlatSB_GetScrollProp(plv->ci.hwnd, WSB_PROP_WINSTYLE, (LPINT)&dwStyle))
    {
        dwStyle = GetWindowStyle(plv->ci.hwnd);
    }

    return dwStyle;
}

int ListView_SetScrollInfo(LV *plv, int fnBar, LPSCROLLINFO lpsi, BOOL fRedraw)
{
    int iRc;

    if (plv->exStyle & LVS_EX_FLATSB)
    {
        iRc = FlatSB_SetScrollInfo(plv->ci.hwnd, fnBar, lpsi, fRedraw);
    }
    else
    {
        iRc = SetScrollInfo(plv->ci.hwnd, fnBar, lpsi, fRedraw);
    }

    //
    //  You'd think we were finished, but in fact the game is only half over.
    //
    //  Some apps (e.g., Font Folder) will do
    //
    //      SetWindowLong(hwnd, GWL_STYLE, newStyle);
    //
    //  where newStyle toggles the WS_HSCROLL and/or WS_VSCROLL bits.
    //  This causes USER's internal bookkeeping to go completely out
    //  of whack:  The ScrollInfo says that there is a scrollbar, but
    //  the window style says there isn't, or vice versa.  The result
    //  is that we get a scrollbar when we shouldn't or vice versa.
    //
    //  So each time we tweak the scroll info in a manner that changes
    //  the range and page, we kick USER in the head to make sure USER's
    //  view of the world (via style bits) is the same as the scroll
    //  bar's view of the world (via SCROLLINFO).
    //

    //
    //  We should always change SIF_PAGE and SIF_RANGE at the same time.
    //
    ASSERT((lpsi->fMask & (SIF_PAGE | SIF_RANGE)) == 0 ||
           (lpsi->fMask & (SIF_PAGE | SIF_RANGE)) == (SIF_PAGE | SIF_RANGE));

    if ((lpsi->fMask & (SIF_PAGE | SIF_RANGE)) == (SIF_PAGE | SIF_RANGE))
    {
        BOOL fShow;
        fShow = lpsi->nMax && (int)lpsi->nPage <= lpsi->nMax;

#ifdef DEBUG
        {
            DWORD dwStyle, dwScroll, dwWant;
            dwScroll = (fnBar == SB_VERT) ? WS_VSCROLL : WS_HSCROLL;
            //
            //  We can short-circuit some logic with secret knowledge about how
            //  ListView uses SetScrollInfo.
            //
            ASSERT(lpsi->nMin == 0);

            dwWant = fShow ? dwScroll : 0;
            dwStyle = ListView_GetWindowStyle(plv);
            if ((dwStyle & dwScroll) != dwWant)
            {
                TraceMsg(TF_LISTVIEW, "ListView_SetScrollInfo: App twiddled WS_[VH]SCROLL");
            }
        }
#endif

        if (plv->exStyle & LVS_EX_FLATSB)
            FlatSB_ShowScrollBar(plv->ci.hwnd, fnBar, fShow);
        else
            ShowScrollBar(plv->ci.hwnd, fnBar, fShow);
    }

    return iRc;
}

// Add/remove/replace item

BOOL NEAR ListView_FreeItem(LV* plv, LISTITEM FAR* pitem)
{
    ASSERT( !ListView_IsOwnerData(plv));

    if (pitem)
    {
        Str_Set(&pitem->pszText, NULL);
        if (pitem->hrgnIcon && pitem->hrgnIcon!=(HANDLE)-1)
            DeleteObject(pitem->hrgnIcon);
        // NOTE: We never remove items from the image list; that's
        // the app's responsibility.
        // REVIEW: Should we do this?  Or should we just provide
        // a message that will adjust image indices for the guy
        // when one is removed?
        //
        ControlFree(plv->hheap, pitem);
    }
    return FALSE;
}

LISTITEM FAR* NEAR ListView_CreateItem(LV* plv, const LV_ITEM FAR* plvi)
{
    LISTITEM FAR* pitem = ControlAlloc(plv->hheap, sizeof(LISTITEM));

    ASSERT(!ListView_IsOwnerData(plv));

    if (pitem)
    {
        if (plvi->mask & LVIF_STATE) {
            if (plvi->state & ~LVIS_ALL)  {
                DebugMsg(DM_ERROR, TEXT("ListView: Invalid state: %04x"), plvi->state);
                return NULL;
            }

            // If adding a selected item to a single-select listview, deselect
            // any other items.
            if ((plv->ci.style & LVS_SINGLESEL) && (plvi->state & LVIS_SELECTED))
                ListView_DeselectAll(plv, -1);

            pitem->state  = (plvi->state & ~(LVIS_FOCUSED | LVIS_SELECTED));
        }
        if (plvi->mask & LVIF_PARAM)
            pitem->lParam = plvi->lParam;

        if (plvi->mask & LVIF_IMAGE)
            pitem->iImage = (short) plvi->iImage;

        if (plvi->mask & LVIF_INDENT)
            pitem->iIndent = (short) plvi->iIndent;

        pitem->pt.x = pitem->pt.y = RECOMPUTE;
        ListView_SetSRecompute(pitem);

        pitem->pszText = NULL;
        if (plvi->mask & LVIF_TEXT) {
            if (!Str_Set(&pitem->pszText, plvi->pszText))
            {
                ListView_FreeItem(plv, pitem);
                return NULL;
            }
        }
    }
    return pitem;
}

// HACK ALERT!! -- fSmoothScroll is an added parameter!  It allows for smooth
// scrolling when deleting items.  ListView_LRInvalidateBelow is only currently
// called from ListView_OnUpdate and ListView_OnDeleteItem.  Both these calls
// have been modified to work correctly and be backwards compatible.
//
void ListView_LRInvalidateBelow(LV* plv, int i, int fSmoothScroll)
{
    if (ListView_IsListView(plv) || ListView_IsReportView(plv)) {
        RECT rcItem;

        if (!ListView_RedrawEnabled(plv) ||
            (ListView_IsReportView(plv) && (plv->pImgCtx != NULL)))
            fSmoothScroll = FALSE;

        if (i >= 0)
        {
            ListView_GetRects(plv, i, NULL, NULL, &rcItem, NULL);
        }
        else
        {
            rcItem.left = rcItem.top = 0;
            rcItem.right = plv->sizeClient.cx;
            rcItem.bottom = plv->sizeClient.cy;
        }

        // Don't try to scroll over the header part
        if (ListView_IsReportView(plv) && rcItem.top < plv->yTop)
            rcItem.top = plv->yTop;

        // For both List and report view need to erase the item and
        // below.  Note: do simple test to see if there is anything
        // to redraw

        // we can't check for bottom/right > 0 because if we nuked something
        // above or to the left of the view, it may affect us all
        if ((rcItem.top <= plv->sizeClient.cy) &&
            (rcItem.left <= plv->sizeClient.cx))
        {
            rcItem.bottom = plv->sizeClient.cy;

            if (ListView_RedrawEnabled(plv)) {
                if ((plv->clrBk == CLR_NONE) && (plv->pImgCtx == NULL))
                {
                    LVSeeThruScroll(plv, &rcItem);
                }
                else if (ListView_IsReportView(plv) && fSmoothScroll)
                {
#ifndef UNIX
                    SMOOTHSCROLLINFO si =
                    {
                        sizeof(si),
                        SSIF_MINSCROLL,
                        plv->ci.hwnd,
                        0,
                        -(plv->cyItem),
                        &rcItem,
                        &rcItem,
                        NULL,
                        NULL,
                        SW_INVALIDATE|SW_ERASE,
                        SSI_DEFAULT,
                        1,
                        1,
                    };
#else
                    SMOOTHSCROLLINFO si;
                    si.cbSize = sizeof(si);
                    si.fMask = SSIF_MINSCROLL;
                    si.hwnd = plv->ci.hwnd;
                    si.dx = 0;
                    si.dy = -(plv->cyItem);
                    si.lprcSrc = &rcItem;
                    si.lprcClip = &rcItem;
                    si.hrgnUpdate = NULL;
                    si.lprcUpdate = NULL;
                    si.fuScroll = SW_INVALIDATE|SW_ERASE;
                    si.uMaxScrollTime = SSI_DEFAULT;
                    si.cxMinScroll = 1;
                    si.cyMinScroll = 1;
                    si.pfnScrollProc = NULL;
#endif

                    SmoothScrollWindow(&si);
                } else {
                    RedrawWindow(plv->ci.hwnd, &rcItem, NULL, RDW_INVALIDATE | RDW_ERASE);
                }
            } else {
                RedrawWindow(plv->ci.hwnd, &rcItem, NULL, RDW_INVALIDATE | RDW_ERASE);
            }

            if (ListView_IsListView(plv))
            {
                RECT rcClient;
                // For Listview we need to erase the other columns...
                rcClient.left = rcItem.right;
                rcClient.top = 0;
                rcClient.bottom = plv->sizeClient.cy;
                rcClient.right = plv->sizeClient.cx;
                RedrawWindow(plv->ci.hwnd, &rcClient, NULL, RDW_INVALIDATE | RDW_ERASE);
            }
        }
    }
}

// Used in Ownerdata Icon views to try to not invalidate the whole world...
void ListView_IInvalidateBelow(LV* plv, int i)
{
    RECT rcItem;

    if (i >= 0)
    {
        ListView_GetRects(plv, i, NULL, NULL, &rcItem, NULL);
    }
    else
    {
        rcItem.left = rcItem.top = 0;
        rcItem.right = plv->sizeClient.cx;
        rcItem.bottom = plv->sizeClient.cy;
    }

    // For Iconviews we need to invalidate everything to the right of us in this
    // row and everything below the row...
    // below.  Note: do simple test to see if there is anything
    // to redraw

    if ((rcItem.top <= plv->sizeClient.cy) &&
        (rcItem.left <= plv->sizeClient.cx))
    {
        rcItem.right = plv->sizeClient.cx;
        RedrawWindow(plv->ci.hwnd, &rcItem, NULL, RDW_INVALIDATE | RDW_ERASE);

        // Now erase everything below...
        rcItem.top = rcItem.bottom;
        rcItem.bottom = plv->sizeClient.cy;
        rcItem.left = 0;
        RedrawWindow(plv->ci.hwnd, &rcItem, NULL, RDW_INVALIDATE | RDW_ERASE);
    }
}


void NEAR ListView_OnUpdate(LV* plv, int i)
{
    // If in icon/small view, don't call InvalidateItem, since that'll force
    // FindFreeSlot to get called, which is pig-like.  Instead, just
    // force a WM_PAINT message, which we'll catch and call Recompute with.
    //
    if (ListView_IsIconView(plv) || ListView_IsSmallView(plv))
    {
        if (plv->ci.style & LVS_AUTOARRANGE)
            ListView_OnArrange(plv, LVA_DEFAULT);
        else
            RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_INTERNALPAINT | RDW_NOCHILDREN);
    }
    else
    {
        // HACK ALERT!! -- The third parameter is new.  It allows for
        // smooth scrolling when items are deleted in reportview.
        // Passing 0, tells it NOT to scroll.
        //
        ListView_LRInvalidateBelow(plv, i, 0);
    }
    ListView_UpdateScrollBars(plv);
}

#ifdef UNICODE
int NEAR ListView_OnInsertItemA(LV* plv, LV_ITEMA FAR* plvi) {
    LPWSTR pszW = NULL;
    LPSTR pszC = NULL;
    int iRet;

    //HACK ALERT -- this code assumes that LV_ITEMA is exactly the same
    // as LV_ITEMW except for the pointer to the string.
    ASSERT(sizeof(LV_ITEMA) == sizeof(LV_ITEMW));

    if (!plvi)
    {
        return -1;
    }


    if ((plvi->mask & LVIF_TEXT) && (plvi->pszText != NULL)) {
        pszC = plvi->pszText;
        pszW = ProduceWFromA(plv->ci.uiCodePage, pszC);
        if (pszW == NULL)
            return -1;
        plvi->pszText = (LPSTR)pszW;
    }

    iRet = ListView_OnInsertItem(plv, (const LV_ITEM FAR*) plvi);

    if (pszW != NULL) {
        plvi->pszText = pszC;

        FreeProducedString(pszW);
    }

    return iRet;

}
#endif

int NEAR ListView_OnInsertItem(LV* plv, const LV_ITEM FAR* plvi)
{
    int iItem;

    if (!plvi || (plvi->iSubItem != 0))    // can only insert the 0th item
    {
        RIPMSG(0, "ListView_InsertItem: iSubItem must be 0 (app passed %d)", plvi->iSubItem);
        return -1;
    }

    // If sorted, then insert sorted.
    //
    if (plv->ci.style & (LVS_SORTASCENDING | LVS_SORTDESCENDING)
        && !ListView_IsOwnerData( plv ))
    {
        if (plvi->pszText == LPSTR_TEXTCALLBACK)
        {
            DebugMsg(DM_ERROR, TEXT("Don't use LPSTR_TEXTCALLBACK with LVS_SORTASCENDING or LVS_SORTDESCENDING"));
            return -1;
        }
        iItem = ListView_LookupString(plv, plvi->pszText, LVFI_SUBSTRING | LVFI_NEARESTXY, 0);
    }
    else
        iItem = plvi->iItem;

    ListView_InvalidateTTLastHit(plv, plv->iTTLastHit);

    if ( !ListView_IsOwnerData(plv))
    {
        int iZ;
        LISTITEM FAR *pitem = ListView_CreateItem(plv, plvi);
        UINT uSelMask = plvi->mask & LVIF_STATE ?
                (plvi->state & (LVIS_FOCUSED | LVIS_SELECTED))
                : 0;
        UINT uSel = uSelMask;

        if (!pitem)
            return -1;

        iItem = DPA_InsertPtr(plv->hdpa, iItem, pitem);
        if (iItem == -1)
        {
            ListView_FreeItem(plv, pitem);
            return -1;
        }

        plv->cTotalItems++;

        if (plv->hdpaSubItems)
        {
            int iCol;
            // slide all the colum DPAs down to match the location of the
            // inserted item
            //
            for (iCol = plv->cCol - 1; iCol >= 0; iCol--)
            {
                HDPA hdpa = ListView_GetSubItemDPA(plv, iCol);
                if (hdpa)       // this is optional, call backs don't have them
                {
                    // insert a blank item (REVIEW: should this be callback?)

                    // since this can be a tail sparce array,
                    // we need to make sure enough items are there.
                    if (iItem >= DPA_GetPtrCount(hdpa))
                        DPA_SetPtr(hdpa, iItem, NULL);
                    else if (DPA_InsertPtr(hdpa, iItem, NULL) != iItem)
                        goto Failure;
                    // Bad assert since hdpa can be tail sparse
                    // ASSERT(ListView_Count(plv) == DPA_GetPtrCount(hdpa));
                    ASSERT(ListView_Count(plv) >= DPA_GetPtrCount(hdpa));
                }
            }
        }

        // Add item to end of z order
        //
        iZ = DPA_InsertPtr(plv->hdpaZOrder, ListView_Count(plv), IntToPtr(iItem));

        if (iZ == -1)
        {
Failure:
            DebugMsg(TF_LISTVIEW, TEXT("ListView_OnInsertItem() failed"));
            if (DPA_DeletePtr(plv->hdpa, iItem))
                plv->cTotalItems--;
            ListView_FreeItem(plv, pitem);
            return -1;
        }

        // if we inserted before the focus point, move the focus point up one
        if (iItem <= plv->iFocus)
            plv->iFocus++;
        // do the same thing for the mark
        if (iItem <= plv->iMark)
            plv->iMark++;

        // If the item was not added at the end of the list we need
        // to update the other indexes in the list
        if (iItem != ListView_Count(plv) - 1)
        {
            int i2;
            for (i2 = iZ - 1; i2 >= 0; i2--)
            {
                int iItemZ = (int)(UINT_PTR)DPA_FastGetPtr(plv->hdpaZOrder, i2);
                if (iItemZ >= iItem)
                    DPA_SetPtr(plv->hdpaZOrder, i2, (LPVOID)(UINT_PTR)(iItemZ + 1));
            }
        }

        if (ListView_CheckBoxes(plv)) {
            uSelMask |= LVIS_STATEIMAGEMASK;
            uSel |= INDEXTOSTATEIMAGEMASK(1);
        }

        if (uSelMask) {

            // we masked off these in the createitem above.
            // because turning these on means more than setting the bits.
            ListView_OnSetItemState(plv, iItem, uSel, uSelMask);
        }
    }
    else
    {
        //
        // simply adjust selection and count
        //
        if ((iItem >= 0) && (iItem <= MAX_LISTVIEWITEMS))
        {
            if (FAILED(plv->plvrangeSel->lpVtbl->InsertItem(plv->plvrangeSel, iItem )))
            {
                return( -1 );
            }
            plv->cTotalItems++;
            plv->rcView.left = RECOMPUTE;
            ListView_Recompute(plv);
            if (!ListView_IsReportView(plv) && !ListView_IsListView(plv))
                {
                // We need to erase the background so that we don't leave
                // turds from wrapped labels in large icon mode.  This could
                // be optimized by only invalidating to the right of and
                // below the inserted item.
                InvalidateRect( plv->ci.hwnd, NULL, TRUE );
                }
            // if we inserted before the focus point, move the focus point up
            if (iItem <= plv->iFocus)
                plv->iFocus++;
            // do the same thing for the mark
            if (iItem <= plv->iMark)
                plv->iMark++;
        }

    }

    if (!ListView_IsOwnerData(plv))
        ASSERT(ListView_Count(plv) == DPA_GetPtrCount(plv->hdpaZOrder));

    if (ListView_RedrawEnabled(plv))
    {
        // Update region
        ListView_RecalcRegion(plv, TRUE, TRUE);

        // The Maybe resize colmns may resize things in which case the next call
        // to Update is not needed.
        if (!ListView_MaybeResizeListColumns(plv, iItem, iItem))
            ListView_OnUpdate(plv, iItem);

        // this trick makes inserting lots of items cheap
        // even if redraw is enabled.... don't calc or position items
        // until this postmessage comes around
        if (!plv->uUnplaced) {
            PostMessage(plv->ci.hwnd, LVMI_PLACEITEMS, 0, 0);
        }
        plv->uUnplaced++;
    }
    else
    {
        //
        // Special case code to make using SetRedraw work reasonably well
        // for adding items to a listview which is in a non layout mode...
        //
        if ((plv->iFirstChangedNoRedraw == -1) ||
                (iItem < plv->iFirstChangedNoRedraw))
            plv->iFirstChangedNoRedraw = iItem;

    }

    ListView_Notify(plv, iItem, 0, LVN_INSERTITEM);

    MyNotifyWinEvent(EVENT_OBJECT_CREATE, plv->ci.hwnd, OBJID_CLIENT, iItem+1);

    return iItem;
}

BOOL NEAR ListView_OnDeleteItem(LV* plv, int iItem)
{
    int iCount = ListView_Count(plv);

    if (!ListView_IsValidItemNumber(plv, iItem))
        return FALSE;   // out of range

    MyNotifyWinEvent(EVENT_OBJECT_DESTROY, plv->ci.hwnd, OBJID_CLIENT, iItem+1);

    ListView_DismissEdit(plv, TRUE);  // cancel edits

    ListView_OnSetItemState(plv, iItem, 0, LVIS_SELECTED);

    if (plv->iFocus == iItem)
        ListView_OnSetItemState(plv, (iItem==iCount-1 ? iItem-1 : iItem+1), LVIS_FOCUSED, LVIS_FOCUSED);

    ListView_InvalidateTTLastHit(plv, plv->iTTLastHit);

    if (!ListView_IsOwnerData(plv))
    {
        LISTITEM FAR* pitem;
        int iZ;

        if ((plv->rcView.left != RECOMPUTE) && (ListView_IsIconView(plv) || ListView_IsSmallView(plv))) {
            pitem = ListView_FastGetItemPtr(plv, iItem);
            if (LV_IsItemOnViewEdge(plv, pitem)) {
                plv->rcView.left = RECOMPUTE;
            }

        }

        // We don't need to invalidate the item in report view because we
        // will be scrolling on top of it.
        //
        if (!ListView_IsReportView(plv))
            ListView_InvalidateItem(plv, iItem, FALSE, RDW_INVALIDATE | RDW_ERASE);

        // this notify must be done AFTER the Invalidate because some items need callbacks
        // to calculate the rect, but the notify might free it out
        ListView_Notify(plv, iItem, 0, LVN_DELETEITEM);

        // During the notify, the app might've done something to the listview
        // so revalidate the item number pointer so we don't fault
#ifdef DEBUG
        // Validate internally because DPA_DeletePtr will ASSERT if you ask it
        // to delete something that doesn't exist.
        if (!ListView_IsValidItemNumber(plv, iItem))
            pitem = NULL;
        else
#endif
            pitem = DPA_DeletePtr(plv->hdpa, iItem);

        if (!pitem)
        {
            RIPMSG(0, "Something strange happened during LVN_DELETEITEM; abandoning LVM_DELETEITEM");
            return FALSE;
        }

        plv->cTotalItems = DPA_GetPtrCount(plv->hdpa);

        // remove from the z-order, this is a linear search to find this!

        DPA_DeletePtr(plv->hdpaZOrder, ListView_ZOrderIndex(plv, iItem));

        //
        // As the Z-order hdpa is a set of indexes we also need to decrement
        // all indexes that exceed the one we are deleting.
        //
        for (iZ = ListView_Count(plv) - 1; iZ >= 0; iZ--)
        {
            int iItemZ = (int)(UINT_PTR)DPA_FastGetPtr(plv->hdpaZOrder, iZ);
            if (iItemZ > iItem)
                DPA_SetPtr(plv->hdpaZOrder, iZ, IntToPtr(iItemZ - 1));
        }

        // remove from sub item DPAs if necessary

        if (plv->hdpaSubItems)
        {
            int iCol;
            for (iCol = plv->cCol - 1; iCol >= 0; iCol--)
            {
                HDPA hdpa = ListView_GetSubItemDPA(plv, iCol);
                if (hdpa) {     // this is optional, call backs don't have them
                    PLISTSUBITEM plsi;

                    // These DPAs are tail sparse, so don't get upset if we
                    // try to delete something that's past the end of the list
#ifdef DEBUG
                    plsi = iItem < DPA_GetPtrCount(hdpa) ? DPA_DeletePtr(hdpa, iItem) : NULL;
#else
                    plsi = DPA_DeletePtr(hdpa, iItem);
#endif
                    ListView_FreeSubItem(plsi);
                }
            }
        }

        ListView_FreeItem(plv, pitem);  // ... finaly the item pointer

    }
    else
    {
        //
        // simply notify and then fixup selection state and count
        //
        if ((iItem >= 0) && (iItem <= MAX_LISTVIEWITEMS))
        {
            ListView_Notify(plv, iItem, 0, LVN_DELETEITEM);

            if (FAILED(plv->plvrangeSel->lpVtbl->RemoveItem(plv->plvrangeSel, iItem)))
            {
                // BUGBUG: return out of memory status
                //MemoryLowDlg( plv->ci.hwnd );
                return FALSE;
            }
            plv->cTotalItems--;
            plv->rcView.left = RECOMPUTE;
            ListView_Recompute(plv);

            if (!ListView_IsReportView(plv) && !ListView_IsListView(plv))
                {
                // We need to erase the background so that the last item gets
                // erased in both icon modes and so that we don't leave turds
                // from wrapped labels in large icon mode.  This could be
                // optimized by only invalidating to the right of and below
                // the deleted item.
                InvalidateRect( plv->ci.hwnd, NULL, TRUE );
                }
        }
        else
        {
            return FALSE;
        }
    }

    iCount = ListView_Count(plv);       // regrab count incase someone updated item...

    if (!ListView_IsOwnerData(plv))
        ASSERT(ListView_Count(plv) == DPA_GetPtrCount(plv->hdpaZOrder));

    if (plv->iFocus == iItem) {
        if (plv->iFocus >= iCount) {
            plv->iFocus = iCount - 1;
        }
    } if (plv->iFocus > iItem) {
        plv->iFocus--;          // slide the focus index down
    }

    // same with the mark
    if (plv->iMark == iItem)  { // deleted the mark item

        if (plv->iMark >= iCount) // did we nuke the last item?
            plv->iMark = iCount - 1;

    } else if (plv->iMark > iItem)
        plv->iMark--;          // slide the mark index down

    // Deleting an icon invalidates the icon positioning cache
    plv->iFreeSlot = -1;

    // HACK ALERT!! -- This construct with ReportView steals code from
    // ListView_OnUpdate.  Currently, it will work exactly the same as before,
    // EXCEPT, that it won't call ListView_OnUpdate.  This is to allow us to
    // send a flag to ListView_LRUpdateBelow to tell it we're scrolling up.
    //
    if (ListView_IsReportView(plv)) {

        // if the new count is zero and we will be showing empty text, simply invalidate the
        // rect and redraw, else go through the invalidate below code...
        
        // we don't know if we are going to show empty text if pszEmptyText is NULL, or not
        // because we may get one through notify, so if iCount is 0 invalidate everything
        if (iCount == 0)
            InvalidateRect( plv->ci.hwnd, NULL, TRUE );
        else
            ListView_LRInvalidateBelow(plv,iItem,1);



        if (ListView_RedrawEnabled(plv))
            ListView_UpdateScrollBars(plv);
        else {
            //
            // Special case code to make using SetRedraw work reasonably well
            // for adding items to a listview which is in a non layout mode...
            //
            if ((plv->iFirstChangedNoRedraw != -1) && (iItem < plv->iFirstChangedNoRedraw))
                plv->iFirstChangedNoRedraw--;
        }
    }
    else {
        if (ListView_RedrawEnabled(plv))
            ListView_OnUpdate(plv, iItem);

        else
        {
            ListView_LRInvalidateBelow(plv, iItem, 0);
            //
            // Special case code to make using SetRedraw work reasonably well
            // for adding items to a listview which is in a non layout mode...
            //
            if ((plv->iFirstChangedNoRedraw != -1) && (iItem < plv->iFirstChangedNoRedraw))
                plv->iFirstChangedNoRedraw--;
        }
    }
    ListView_RecalcRegion(plv, TRUE, TRUE);

    return TRUE;
}

BOOL NEAR ListView_OnDeleteAllItems(LV* plv)
{
    int i;
    BOOL bAlreadyNotified;
    BOOL fHasItemData;

    fHasItemData = !ListView_IsOwnerData(plv);

    ListView_DismissEdit(plv, TRUE);    // cancel edits

    // Must neutralize the focus because some apps will call
    // ListView_OnGetNextItem(LVNI_FOCUSED) during delete notifications,
    // so we need to make sure the focus is in a safe place.
    // May as well neutralize the mark, too.
    plv->iMark = plv->iFocus = -1;

    // Also nuke the icon positioning cache
    plv->iFreeSlot = -1;

    bAlreadyNotified = (BOOL)ListView_Notify(plv, -1, 0, LVN_DELETEALLITEMS);

    ListView_InvalidateTTLastHit(plv, plv->iTTLastHit);

    if (fHasItemData || !bAlreadyNotified)
    {
        for (i = ListView_Count(plv) - 1; i >= 0; i--)
        {
            if (!bAlreadyNotified)
                ListView_Notify(plv, i, 0, LVN_DELETEITEM);

            if (fHasItemData)
            {
                ListView_FreeItem(plv, ListView_FastGetItemPtr(plv, i));
                //
                //  CAREFUL!  Applications such as NT Backup call back
                //  into ListView during the LVN_DELETEITEM notification,
                //  so we need to kill this item or we will fault at the
                //  next iteration because everybody relies on
                //  ListView_Count for validation.
                //
                DPA_FastDeleteLastPtr(plv->hdpa);
                plv->cTotalItems--;
            }
        }
    }

   if (ListView_IsOwnerData( plv ))
    {
      if (FAILED(plv->plvrangeSel->lpVtbl->Clear( plv->plvrangeSel )))
        {
            // BUGBUG: return low memory status
            //MemoryLowDlg( plv->ci.hwnd );
        }
        plv->cTotalItems = 0;
    }
    else
    {
        DPA_DeleteAllPtrs(plv->hdpa);
        DPA_DeleteAllPtrs(plv->hdpaZOrder);
        plv->cTotalItems = 0;

        if (plv->hdpaSubItems)
        {
            int iCol;
            for (iCol = plv->cCol - 1; iCol >= 0; iCol--)
            {
                HDPA hdpa = ListView_GetSubItemDPA(plv, iCol);
                if (hdpa) {
                    DPA_EnumCallback(hdpa, ListView_FreeColumnData, 0);
                    DPA_DeleteAllPtrs(hdpa);
                }
            }
        }
    }

    plv->rcView.left = RECOMPUTE;
    plv->xOrigin = 0;
    plv->nSelected = 0;

    plv->ptlRptOrigin.x = 0;
    plv->ptlRptOrigin.y = 0;

    // reset the cxItem width
    if (!(plv->flags & LVF_COLSIZESET))
        plv->cxItem = 16 * plv->cxLabelChar + plv->cxSmIcon;

    RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
    ListView_UpdateScrollBars(plv);

    return TRUE;
}

int PASCAL ListView_IFindNearestItem(LV* plv, int left, int top, UINT vk)
{
   int iMin = -1;

   if (ListView_IsOwnerData( plv ))
   {
      POINT pt;
      int cSlots;

      ASSERT( !ListView_IsReportView( plv ) && !ListView_IsListView( plv ) );

      pt.x = left + plv->ptOrigin.x;
      pt.y = top + plv->ptOrigin.y;

      cSlots = ListView_GetSlotCount( plv, TRUE );
      iMin = ListView_CalcHitSlot( plv, pt, cSlots );

      switch( vk )
      {
      case VK_HOME:
         iMin = 0;
         break;

      case VK_END:
         iMin = ListView_Count( plv ) - 1;
         break;

      case VK_LEFT:
         if (iMin % cSlots)
            iMin -= 1;
         break;

      case VK_RIGHT:
         if ((iMin + 1) % cSlots)
            iMin += 1;
         break;

      case VK_UP:
         if (iMin >= cSlots)
            iMin -= cSlots;
         break;

      case VK_DOWN:
         if (iMin + cSlots < ListView_Count( plv ))
            iMin += cSlots;
         break;

      default: ;
      }

      iMin = max( 0, iMin );
      iMin = min( ListView_Count( plv ) - 1, iMin );

   }
   else
    {
       DWORD dMin = 0;
       int cyItem;
       int yEnd = 0, yLimit = 0, xEnd = 0;
       int iCount;
       int i;

       if (ListView_IsIconView(plv)) {
           cyItem = plv->cyIcon;
       } else {
           cyItem = plv->cyItem;
       }

       iCount = ListView_Count(plv);
       if (iCount == 1)
           return 0;

       if (vk == VK_HOME) {
           yEnd = yLimit = plv->rcView.bottom;
           xEnd = plv->rcView.right;
       } else if (vk == VK_END) {

           yEnd = yLimit = plv->rcView.top;
           xEnd = plv->rcView.left;

       }
       for (i = 0; i < iCount; i++)
       {
           RECT rc;
           int dx;
           DWORD dxAbs, dyAbs;
           int dy;
           DWORD dOffset;

           ListView_GetRects(plv, i, &rc, NULL, NULL, NULL);

           dx = rc.left - left;
           dxAbs = (DWORD)(dx < 0 ? -dx : dx);
           dy = rc.top - top;
           dyAbs = (DWORD)(dy < 0 ? -dy : dy);

           if ((vk == VK_LEFT) && (dxAbs < dyAbs || dx >= 0))
               continue;
           else if ((vk == VK_RIGHT) && (dxAbs < dyAbs || dx <= 0))
               continue;
           else if ((vk == VK_UP) && (dxAbs > dyAbs || dy >= 0))
               continue;
           else if ((vk == VK_DOWN) && (dxAbs > dyAbs || dy <= 0))
               continue;

           if (vk == VK_HOME || vk == VK_END) {

               // home is not the nearest to the top corner, it's the leftmost of the top row.
               // ditto (reversed) for end.  thus we can't use the stuff below. bummer
               if (vk == VK_HOME) {
                   if ((rc.top + cyItem < yEnd) ||  // if it's fully above the highest line so far, take it!
                       ((rc.top < yLimit) &&  // if it's on the same row as the top item to date
                        (rc.left < xEnd))) {
                       iMin = i;
                       xEnd = rc.left;
                       yEnd = rc.top;
                       if (rc.top + cyItem < yLimit)
                           yLimit = rc.top + cyItem;
                   }
               } else {
                   if ((rc.top > yEnd) || //if it's full below the lowest row
                       ((rc.top + cyItem > yLimit) && // if it's on the same row
                        (rc.right > xEnd))) {

                       iMin = i;
                       xEnd = rc.right;
                       yEnd = rc.top;
                       if (rc.top > yLimit)
                           yLimit = rc.top;
                   }
               }

           } else {

               dOffset = ((dxAbs * dxAbs) + (dyAbs * dyAbs));
               if (iMin == -1 || (dMin > dOffset))
               {
                   dMin = dOffset;
                   iMin = i;
               }
           }
       }
    }
    return iMin;
}

int NEAR ListView_Arrow(LV* plv, int iStart, UINT vk)
{
    RECT rcFocus;
    int i;
    int dx;
    int iCount;

    //
    // The algorithm to find which item depends if we are in a view
    // that is arrange(layout) oriented or a sorted (list) view.
    // For the sorted views we will use some optimizations to make
    // it faster
    //
    iCount = ListView_Count(plv);
    if (ListView_IsReportView(plv) || ListView_IsListView(plv))
    {
        //
        // For up and down arrows, simply increment or decrement the
        // index.  Note: in listview this will cause it to wrap columns
        // which is fine as it is compatible with the file manager
        //
        // Assumes only one of these flags is set...

        switch (vk)
        {
        case VK_LEFT:
            if (ListView_IsReportView(plv))
            {
                ListView_ROnScroll(plv, (GetAsyncKeyState(VK_CONTROL) < 0) ? SB_PAGELEFT : SB_LINELEFT, 0, SB_HORZ);
            }
            else
                iStart -= plv->cItemCol;
            break;

        case VK_RIGHT:
            if (ListView_IsReportView(plv))
            {
                // Make this horizontally scroll the report view
                ListView_ROnScroll(plv, (GetAsyncKeyState(VK_CONTROL) < 0) ? SB_PAGERIGHT : SB_LINERIGHT, 0, SB_HORZ);
            }
            else
                iStart += plv->cItemCol;
            break;

        case VK_UP:
            iStart--;
            break;

        case VK_DOWN:
            iStart++;
            break;

        case VK_HOME:
            iStart = 0;
            break;

        case VK_END:
            iStart = iCount -1;
            break;

        case VK_NEXT:
            if (ListView_IsReportView(plv))
            {
                i = iStart; // save away to make sure we dont go wrong way!

                // First go to end of page...
                iStart = (int)(((LONG)(plv->sizeClient.cy - (plv->cyItem)
                        - plv->yTop) + plv->ptlRptOrigin.y) / plv->cyItem);

                // If Same item, increment by page size.
                if (iStart <= i)
                    iStart = i + max(
                            (plv->sizeClient.cy - plv->yTop)/ plv->cyItem - 1,
                            1);

                if (iStart >= iCount)
                    iStart = iCount - 1;

            } else {
                // multiply by 2/3 to give a good feel.. when the item is mostly shown
                // you want to go to the next column
                dx = (plv->sizeClient.cx + (plv->cxItem*2)/3) / plv->cxItem;
                if (!dx)
                    dx = 1;

                iStart += plv->cItemCol *  dx;
                if (plv->cItemCol) {
                    while (iStart >= iCount)
                        iStart -= plv->cItemCol;
                }
            }
            break;

        case VK_PRIOR:

            if (ListView_IsReportView(plv))
            {
                i = iStart; // save away to make sure we dont go wrong way!

                // First go to end of page...
                iStart = (int)(plv->ptlRptOrigin.y / plv->cyItem);

                // If Same item, increment by page size.
                if (iStart >= i)
                    iStart = i - max(
                            (plv->sizeClient.cy - plv->yTop)/ plv->cyItem - 1,
                            1);

                if (iStart < 0)
                    iStart = 0;

            } else {
                dx = (plv->sizeClient.cx + (plv->cxItem*2)/3) / plv->cxItem;
                if (!dx)
                    dx = 1;
                iStart -= plv->cItemCol * dx;
                if (plv->cItemCol) {
                    while (iStart < 0)
                        iStart += plv->cItemCol;
                }

            }
            break;

        default:
            return -1;      // Out of range
        }

        // Make sure it is in range!.
        if ((iStart >= 0) && (iStart < iCount))
            return iStart;
        else if (iCount == 1)
            return 0;
        else
            return -1;
    }

    else
    {
        //
        // Layout type view. we need to use the position of the items
        // to figure out the next item
        //

        if (ListView_IsOwnerData( plv ))
        {
          iStart = max( 0, iStart );

            // if it does not matches any of the entries in the case statement below
            // this is done to skip the call back by the GetRects
            //
            if ( vk != VK_LEFT  &&
                    vk != VK_RIGHT &&
                    vk != VK_UP &&
                    vk != VK_DOWN &&
                    vk != VK_HOME &&
                    vk != VK_END &&
                    vk != VK_NEXT &&
                    vk != VK_PRIOR )
            {
                return -1;
            }
            ListView_GetRects(plv, iStart, &rcFocus, NULL, NULL, NULL);
        }
        else
        {
            if (iStart != -1) {
                ListView_GetRects(plv, iStart, &rcFocus, NULL, NULL, NULL);
            }
        }

        switch (vk)
        {
        // For standard arrow keys just fall out of here.
        case VK_LEFT:
        case VK_RIGHT:
        case VK_UP:
        case VK_DOWN:
            if (ListView_IsOwnerData( plv ))
            {
                break;
            }
            else
            {
                if (iStart != -1) {
                    // all keys map to VK_HOME except VK_END
                    break;
                }

                // Fall through
                vk = VK_HOME;
            }

        case VK_HOME:
            rcFocus.left = - plv->ptOrigin.x;
            rcFocus.top = - plv->ptOrigin.y;
            break;

        case VK_END:
            rcFocus.left = plv->rcView.right;
            rcFocus.top = plv->rcView.bottom;
            break;

        case VK_NEXT:
            rcFocus.top += plv->sizeClient.cy;
            vk = VK_UP;
            break;

        case VK_PRIOR:
            vk = VK_DOWN;
            rcFocus.top -= plv->sizeClient.cy;
            break;
        default:
            return -1;      // Out of range
        }

        return ListView_IFindNearestItem(plv, rcFocus.left, rcFocus.top, vk);
    }
}

int NEAR ListView_OnGetNextItem(LV* plv, int i, UINT flags)
{
    int iStart = i;
    int cItemMax = ListView_Count(plv);

    // Note that -1 is a valid starting point
    if (i < -1 || i >= cItemMax)
        return -1;

    if (ListView_IsOwnerData( plv ))
    {
        if (flags & (LVNI_CUT | LVNI_DROPHILITED | LVNI_PREVIOUS))
        {
            return( -1 );
        }
    }

    if (flags & LVNI_FOCUSED)
    {
        // we know which item is focused, jump right to it.
        // but we have to mimick the code below exactly for compat:
        //     if directional bits are set, they take precedence.
        if (!(flags & (LVNI_ABOVE | LVNI_BELOW | LVNI_TORIGHT | LVNI_TOLEFT)))
        {
            // there are no more focused items after iFocus
            if (i >= plv->iFocus)
                return -1;

            // subtract one here -- we increment it below
            i = plv->iFocus - 1;
        }
    }

    while (TRUE)
    {
        // BUGBUG: does anyone call this now???
        if (flags & (LVNI_ABOVE | LVNI_BELOW | LVNI_TORIGHT | LVNI_TOLEFT))
        {
            UINT vk;
            if (flags & LVNI_ABOVE)
                vk = VK_UP;
            else if (flags & LVNI_BELOW)
                vk = VK_DOWN;
            else if (flags & LVNI_TORIGHT)
                vk = VK_RIGHT;
            else
                vk = VK_LEFT;

            if (i != -1)
                i = ListView_Arrow(plv, i, vk);
            if (i == -1)
                return i;

        }
        else
        {
            i++;
            if (i == cItemMax)
                return -1;
        }

        // See if any other restrictions are set
        if (flags & ~(LVNI_ABOVE | LVNI_BELOW | LVNI_TORIGHT | LVNI_TOLEFT))
        {
            WORD wItemState;

            if (ListView_IsOwnerData( plv ))
            {
                if (flags & LVNI_FOCUSED)
                {
                    // we check LVNI_FOCUSED before the loop, so i == iFocus
                    ASSERT(i == plv->iFocus && i != -1);
                    if (flags & LVNI_SELECTED)
                    {
                        if (plv->plvrangeSel->lpVtbl->IsSelected(plv->plvrangeSel, i ) != S_OK)
                        {
                            i = -1;
                        }
                    }
                }
                else if (flags & LVNI_SELECTED)
                {
                    i = max( i, 0 );
                    plv->plvrangeSel->lpVtbl->NextSelected(plv->plvrangeSel, i, &i );
                }
                else
                {
                    i = -1;
                }
            }
            else
            {
                {
                    LISTITEM FAR* pitem = ListView_FastGetItemPtr(plv, i);
                    wItemState = pitem->state;
                }

                // for LVNI_FOCUSED, we start at the LVIS_FOCUSED element, if we're
                // not on that element, one of the below continues was hit, so
                // we'll never find the element. bail out early.
                if ((flags & LVNI_FOCUSED) && !(wItemState & LVIS_FOCUSED))
                {
                    ASSERT(i == plv->iFocus || i == plv->iFocus+1);
                    return(-1);
                }

                if (((flags & LVNI_SELECTED) && !(wItemState & LVIS_SELECTED)) ||
                    ((flags & LVNI_CUT) && !(wItemState & LVIS_CUT)) ||
                    ((flags & LVNI_DROPHILITED) && !(wItemState & LVIS_DROPHILITED))) {
                    if (i != iStart)
                        continue;
                    else {
                        // we've looped and we can't find anything to fit this criteria
                        return -1;
                    }
                }
            }
        }
        return i;
    }
}

int NEAR ListView_CompareString(LV* plv, int i, LPCTSTR pszFind, UINT flags, int iLen)
{
    // BUGBUG: non protected globals
    int cb;
    TCHAR ach[CCHLABELMAX];
    LV_ITEM item;

    ASSERT(!ListView_IsOwnerData(plv));
    ASSERT(pszFind);

    item.iItem = i;
    item.iSubItem = 0;
    item.mask = LVIF_TEXT;
    item.pszText = ach;
    item.cchTextMax = ARRAYSIZE(ach);
    ListView_OnGetItem(plv, &item);

    if (!(flags & (LVFI_PARTIAL | LVFI_SUBSTRING)))
        return lstrcmpi(item.pszText, pszFind);

    // REVIEW: LVFI_SUBSTRING is not really implemented yet.

    cb = lstrlen(pszFind);
    if (iLen && (cb > iLen)) {
            cb = iLen;
    }

    //
    // If the sub strings not equal then return the ordering based
    // on the entire string.
    //
#ifndef UNIX
    return IntlStrEqNI(item.pszText, pszFind, cb) ? 0 : lstrcmp(item.pszText, pszFind);
#else
    return IntlStrEqNI(item.pszText, pszFind, cb) ? 0 : lstrcmpi(item.pszText, pszFind);
#endif

}

#ifdef UNICODE
int NEAR ListView_OnFindItemA(LV* plv, int iStart, LV_FINDINFOA * plvfi) {
    LPWSTR pszW = NULL;
    LPCSTR pszC = NULL;
    int iRet;

    //HACK ALERT -- this code assumes that LV_FINDINFOA is exactly the same
    // as LV_FINDINFOW except for the pointer to the string.
    ASSERT(sizeof(LV_FINDINFOA) == sizeof(LV_FINDINFOW));

    if (!plvfi)
        return -1;

    if (!(plvfi->flags & LVFI_PARAM) && !(plvfi->flags & LVFI_NEARESTXY)) {
        pszC = plvfi->psz;
        if ((pszW = ProduceWFromA(plv->ci.uiCodePage, pszC)) == NULL)
            return -1;
        plvfi->psz = (LPSTR)pszW;
    }

    iRet = ListView_OnFindItem(plv, iStart, (const LV_FINDINFO FAR *)plvfi);

    if (pszW != NULL) {
        plvfi->psz = pszC;

        FreeProducedString(pszW);
    }

    return iRet;
}
#endif

int NEAR ListView_OnFindItem(LV* plv, int iStart, const LV_FINDINFO FAR* plvfi)
{
    int i;
    int j;
    int cItem;
    UINT flags;

    if (!plvfi)
        return -1;

    if (plvfi->flags & LVFI_NEARESTXY) {
        if (ListView_IsIconView(plv) || ListView_IsSmallView(plv)) {
            return ListView_IFindNearestItem(plv, plvfi->pt.x, plvfi->pt.y, plvfi->vkDirection);
        } else
            return -1;
    }

    // Note that -1 is a valid starting point
    if (iStart < -1 || iStart >= ListView_Count(plv))
        return -1;

    if (ListView_IsOwnerData( plv ))
    {
        // call back to owner for search
        return( (int) ListView_RequestFindItem( plv, plvfi, iStart + 1 ) );
    }
    else
    {
        flags  = plvfi->flags;
        i = iStart;
        cItem = ListView_Count(plv);
        if (flags & LVFI_PARAM)
        {
            LPARAM lParam = plvfi->lParam;

            // Linear search with wraparound...
            //
            for (j = cItem; j-- != 0; )
            {
                ++i;
                if (i == cItem) {
                    if (flags & LVFI_WRAP)
                        i = 0;
                    else
                        break;
                }

                if (ListView_FastGetItemPtr(plv, i)->lParam == lParam)
                    return i;
            }
        }
        else // if (flags & (LVFI_STRING | LVFI_SUBSTRING | LVFI_PARTIAL))
        {
            LPCTSTR pszFind = plvfi->psz;
            if (!pszFind)
                return -1;

            if (plv->ci.style & (LVS_SORTASCENDING | LVS_SORTDESCENDING))
                return ListView_LookupString(plv, pszFind, flags, i + 1);

            for (j = cItem; j-- != 0; )
            {
                ++i;
                if (i == cItem) {
                    if (flags & LVFI_WRAP)
                        i = 0;
                    else
                        break;
                }

                if (ListView_CompareString(plv,
                                           i,
                                           pszFind,
                                           (flags & (LVFI_PARTIAL | LVFI_SUBSTRING)), 0) == 0)
                {
                    return i;
                }
            }
        }
    }
    return -1;
}

BOOL NEAR ListView_OnGetItemRect(LV* plv, int i, RECT FAR* prc)
{
#ifndef UNIX
    LPRECT pRects[LVIR_MAX];
#else
    volatile LPRECT pRects[LVIR_MAX]; /* this is used by the irix compiler */
#endif

    // validate parameters
    if (!ListView_IsValidItemNumber(plv, i))
    {
        RIPMSG(0, "LVM_GETITEMRECT: invalid index %d", i);
        return FALSE;
    }

    if (!prc || prc->left >= LVIR_MAX || prc->left < 0)
    {
        RIPMSG(0, "LVM_GETITEMRECT: invalid rect pointer");
        return FALSE;
    }

    pRects[0] = NULL;
    pRects[1] = NULL;
    pRects[2] = NULL;
    pRects[3] = NULL;

    pRects[prc->left] = prc;
    ListView_GetRects(plv, i, pRects[LVIR_ICON], pRects[LVIR_LABEL],
                      pRects[LVIR_BOUNDS], pRects[LVIR_SELECTBOUNDS]);
    return TRUE;
}

//
// in:
//      plv
//      iItem           MUST be a valid item index (in range)
// out:
//   prcIcon            icon bounding rect
//   prcLabel           label text bounding rect, for details this is the first column
//   prcBounds          entire item (all text and icon), including columns in details
//   prcSelectionBounds union of icon and label rects, does NOT include columns
//                      in details view

// BUGBUG raymondc - Need to pass an HDC parameter for measurement
// since sometimes we do this while painting

void NEAR ListView_GetRects(LV* plv, int iItem,
        RECT FAR* prcIcon, RECT FAR* prcLabel, RECT FAR* prcBounds,
        RECT FAR* prcSelectBounds)
{
    ASSERT(plv);

    if (ListView_IsReportView(plv))
    {
        ListView_RGetRects(plv, iItem, prcIcon, prcLabel, prcBounds, prcSelectBounds);
    }
    else if (ListView_IsListView(plv))
    {
        ListView_LGetRects(plv, iItem, prcIcon, prcLabel, prcBounds, prcSelectBounds);
    }
    else
    {
       if (ListView_IsOwnerData( plv ))
       {
           RECT rcIcon;
           RECT rcTextBounds;
           LISTITEM item;
           
           if (ListView_IsIconView(plv))
               ListView_IGetRectsOwnerData(plv, iItem, &rcIcon, &rcTextBounds, &item, FALSE);
           else if (ListView_IsSmallView(plv))
               ListView_SGetRectsOwnerData(plv, iItem, &rcIcon, &rcTextBounds, &item, FALSE);
           if (prcIcon)
               *prcIcon = rcIcon;
           if (prcLabel)
               *prcLabel = rcTextBounds;
           
           if (prcBounds)
               UnionRect(prcBounds, &rcIcon, &rcTextBounds);
           
           if (prcSelectBounds)
               UnionRect(prcSelectBounds, &rcIcon, &rcTextBounds);
       }
       else
       {
           if (iItem >= ListView_Count(plv))
           {
               return;
           }
           else
           {
               LISTITEM FAR *pitem = ListView_FastGetItemPtr(plv, iItem);
               
               if (pitem->cyFoldedLabel == SRECOMPUTE)
               {
                   ListView_RecomputeLabelSize(plv, pitem, iItem, NULL, FALSE);
               }
               _ListView_GetRectsFromItem(plv, ListView_IsSmallView(plv), pitem,
                   prcIcon, prcLabel, prcBounds, prcSelectBounds);
           }
       }
    }
}

void NEAR ListView_GetRectsOwnerData(LV* plv, int iItem,
        RECT FAR* prcIcon, RECT FAR* prcLabel, RECT FAR* prcBounds,
        RECT FAR* prcSelectBounds, LISTITEM* pitem)
{
    ASSERT(plv);
    ASSERT(ListView_IsOwnerData(plv));

    if (ListView_IsReportView(plv))
    {
        ListView_RGetRects(plv, iItem, prcIcon, prcLabel, prcBounds,
                prcSelectBounds);
    }
    else if (ListView_IsListView(plv))
    {
        ListView_LGetRects(plv, iItem, prcIcon, prcLabel, prcBounds,
                prcSelectBounds);
    }
    else
    {
      RECT rcIcon;
      RECT rcTextBounds;

        if (ListView_IsIconView(plv))
            ListView_IGetRectsOwnerData(plv, iItem, &rcIcon, &rcTextBounds, pitem, TRUE);
        else if (ListView_IsSmallView(plv))
            ListView_SGetRectsOwnerData(plv, iItem, &rcIcon, &rcTextBounds, pitem, TRUE);

        // Don't need to check for folding here, as will have been handled in user data
        // rectangle fetching functions.

       if (prcIcon)
           *prcIcon = rcIcon;
       if (prcLabel)
           *prcLabel = rcTextBounds;

       if (prcBounds)
           UnionRect(prcBounds, &rcIcon, &rcTextBounds);

       if (prcSelectBounds)
           UnionRect(prcSelectBounds, &rcIcon, &rcTextBounds);
    }
}


BOOL NEAR ListView_OnRedrawItems(LV* plv, int iFirst, int iLast)
{
    int iCount = ListView_Count(plv);

    if (iFirst < iCount) {

        if (iLast >= iCount)
            iLast = iCount - 1;

        while (iFirst <= iLast)
            ListView_InvalidateItem(plv, iFirst++, FALSE, RDW_INVALIDATE | RDW_ERASE);
    }
    return TRUE;
}

// fSelectionOnly       use the selection bounds only, ie. don't include
//                      columns in invalidation if in details view
//
void NEAR ListView_InvalidateItemEx(LV* plv, int iItem, BOOL fSelectionOnly,
    UINT fRedraw, UINT maskChanged)
{
    RECT rc;
    LPRECT prcIcon;
    LPRECT prcLabel;
    LPRECT prcBounds;
    LPRECT prcSelectBounds;

    if (iItem == -1)
        return;

    prcIcon = prcLabel = prcBounds = prcSelectBounds = NULL;

    // if we're in owner draw mode, and there's been a new font,
    // we don't really know what the selection bounds is, so always use the bounds
    // in that case... unless we're in fullrowselect mode
    if (ListView_IsOwnerData(plv) && plv->flags & LVF_CUSTOMFONT &&
       !ListView_FullRowSelect(plv)) {
        fSelectionOnly = FALSE;
    }

    // if we're owner draw, there's no such thing as selection only
    if (plv->ci.style & LVS_OWNERDRAWFIXED)
        fSelectionOnly = FALSE;

    if (fSelectionOnly) {
        // In report mode non-fullrowselect,
        // we have to use the full label rectangle rather
        // than just the selection bounds, since the stuff outside the
        // rectangle might need redrawing, too.

        if (ListView_IsReportView(plv) && !ListView_FullRowSelect(plv))
            prcLabel = &rc;
        else
            prcSelectBounds = &rc;
    } else {

        // if _only_the_text_ or _only_the_image_ changed then limit the redraw
        switch (maskChanged) {

        case LVIF_IMAGE:
            prcIcon = &rc;
            break;

        case LVIF_TEXT:
            prcLabel = &rc;
            break;

        default:
            prcBounds = &rc;
            break;
        }
    }

    if (ListView_RedrawEnabled(plv)) {

        ListView_GetRects(plv, iItem,
            prcIcon, prcLabel, prcBounds, prcSelectBounds);

        if (RECTS_IN_SIZE(plv->sizeClient, rc))
        {
            if (plv->exStyle & LVS_EX_BORDERSELECT)
                InflateRect(&rc, 4 + g_cxIconMargin, 4 + g_cyIconMargin);     // account for selection border and seperation since drawing otside of icon
            RedrawWindow(plv->ci.hwnd, &rc, NULL, fRedraw);
        }

    } else {

        // if we're not visible, we'll get a full
        // erase bk when we do become visible, so only do this stuff when
        // we're on setredraw false
        if (!(plv->flags & LVF_REDRAW)) {

            // if we're invalidating that's new (thus hasn't been painted yet)
            // blow it off
            if ((plv->iFirstChangedNoRedraw != -1) &&
                (iItem >= plv->iFirstChangedNoRedraw)) {
                return;
            }

            ListView_GetRects(plv, iItem,
                prcIcon, prcLabel, prcBounds, prcSelectBounds);

            // if it had the erase bit, add it to our region
            if (RECTS_IN_SIZE(plv->sizeClient, rc)) {

                HRGN hrgn = CreateRectRgnIndirect(&rc);

                ListView_InvalidateRegion(plv, hrgn);

                if (fRedraw & RDW_ERASE)
                    plv->flags |= LVF_ERASE;
            }
        }
    }
}

// this returns BF_* flags to indicate which if any edge the item I is touching
// or crossing...
UINT LV_IsItemOnViewEdge(LV* plv, LISTITEM* pitem)
{
    RECT rcItem;
    RECT rcView = plv->rcView;
    UINT uRet = 0;

    // the view rect is enlarged a bit to allow for a little space around
    // the text (see ListView_Recompute())
    rcView.bottom -= g_cyEdge;
    rcView.right -= g_cxEdge;

    _ListView_GetRectsFromItem(plv, ListView_IsSmallView(plv), pitem,
                               NULL, NULL, &rcItem, NULL);
    // translate from window coordinates to listview coordinate
    OffsetRect(&rcItem, plv->ptOrigin.x, plv->ptOrigin.y);

    if (rcItem.right >= rcView.right)
        uRet |= BF_RIGHT;

    if (rcItem.left <= rcView.left)
        uRet |= BF_LEFT;

    if (rcItem.top <= rcView.top)
        uRet |= BF_TOP;

    if (rcItem.bottom >= rcView.bottom)
        uRet |= BF_BOTTOM;

    return uRet;
}

void LV_AdjustViewRectOnMove(LV* plv, LISTITEM *pitem, int x, int y)
{
    plv->iFreeSlot = -1; // The "free slot" cache is no good once an item moves

    // if we have to recompute anyways, don't bother
    if (!ListView_IsOwnerData( plv )) {
        if ((plv->rcView.left != RECOMPUTE) &&
            x != RECOMPUTE && y != RECOMPUTE &&
            pitem->cyFoldedLabel != SRECOMPUTE) {
            RECT rcAfter;
            RECT rcView = plv->rcView;

            // the view rect is enlarged a bit to allow for a little space around
            // the text (see ListView_Recompute())
            rcView.bottom -= g_cyEdge;
            rcView.right -= g_cxEdge;

            if (pitem->pt.x != RECOMPUTE) {
                UINT uEdges;

                uEdges = LV_IsItemOnViewEdge(plv, pitem);

                pitem->pt.x = x;
                pitem->pt.y = y;

                // before and after the move, they need to be touching the
                // same edges or not at all
                if (uEdges != LV_IsItemOnViewEdge(plv, pitem)) {
                    goto FullRecompute;
                }
            } else {
                // if the position wasn't set before
                // we just need to find out what it is afterwards and
                // enlarge the view... we don't need to shrink it
                pitem->pt.x = x;
                pitem->pt.y = y;


            }

            _ListView_GetRectsFromItem(plv, ListView_IsSmallView(plv), pitem,
                                       NULL, NULL, &rcAfter, NULL);
            // translate from window coordinates to listview coordinate
            OffsetRect(&rcAfter, plv->ptOrigin.x, plv->ptOrigin.y);

            // if we make it here, we just have to make sure the new view rect
            // encompases this new item
            UnionRect(&rcView, &rcView, &rcAfter);
            rcView.right += g_cxEdge;
            rcView.bottom += g_cyEdge;

            DebugMsg(TF_LISTVIEW, TEXT("Score! (%d %d %d %d) was (%d %d %d %d)"),
                     rcView.left, rcView.top, rcView.right, rcView.bottom,
                     plv->rcView.left, plv->rcView.top, plv->rcView.right, plv->rcView.bottom);

            plv->rcView = rcView;

        } else {
    FullRecompute:
            plv->rcView.left = RECOMPUTE;
        }
    }

    DebugMsg(TF_LISTVIEW, TEXT("LV -- AdjustViewRect pitem %d -- (%x, %x)"),
             pitem,
             pitem->pt.x, pitem->pt.y);

    pitem->pt.x = x;
    pitem->pt.y = y;

    // Compute the workarea of this item if applicable
    ListView_FindWorkArea(plv, pitem->pt, &(pitem->iWorkArea));
}

BOOL NEAR ListView_OnSetItemPosition(LV* plv, int i, int x, int y)
{
    LISTITEM FAR* pitem;

    if (ListView_IsListView(plv))
        return FALSE;

    if (ListView_IsOwnerData( plv ))
    {
       RIPMSG(0, "LVM_SETITEMPOSITION: Invalid for owner-data listview");
       return FALSE;
    }

    pitem = ListView_GetItemPtr(plv, i);
    if (!pitem)
        return FALSE;

    //
    // this is a hack to fix a bug in OLE drag/drop loop
    //
    if (x >= 0xF000 && x < 0x10000)
    {
        DebugMsg(TF_LISTVIEW, TEXT("LV -- On SetItemPosition fixing truncated negative number 0x%08X"), x);
        x = x - 0x10000;
    }

    if (y >= 0xF000 && y < 0x10000)
    {
        DebugMsg(TF_LISTVIEW, TEXT("LV -- On SetItemPosition fixing truncated negative number 0x%08X"), y);
        y = y - 0x10000;
    }

    ListView_InvalidateTTLastHit(plv, plv->iTTLastHit);

    if (pitem->cyFoldedLabel == SRECOMPUTE)
    {
        ListView_RecomputeLabelSize(plv, pitem, i, NULL, FALSE);
    }

    // erase old

    if (y != pitem->pt.y || x != pitem->pt.x) {
        // Don't invalidate if it hasn't got a position yet
        if (pitem->pt.y != RECOMPUTE) {
            ListView_InvalidateItem(plv, i, FALSE, RDW_INVALIDATE | RDW_ERASE);
        } else if (plv->uUnplaced) {
            // this means an unplaced item got placed
            plv->uUnplaced--;
            if (!plv->uUnplaced) {
                MSG msg;
                // if this is now 0, pull out the postmessage
                PeekMessage(&msg, plv->ci.hwnd, LVMI_PLACEITEMS, LVMI_PLACEITEMS, PM_REMOVE);
            }
        }

        if (y == RECOMPUTE) {
            // if they're setting the new position to be a "any open spot" post that we
            // need to calc this later
            if (!plv->uUnplaced) {
                PostMessage(plv->ci.hwnd, LVMI_PLACEITEMS, 0, 0);
            }
            plv->uUnplaced++;
        }
    }

    DebugMsg(TF_LISTVIEW, TEXT("LV -- On SetItemPosition %d %d %d %d -- (%x, %x)"),
             plv->rcView.left, plv->rcView.top, plv->rcView.right, plv->rcView.bottom,
             pitem->pt.x, pitem->pt.y);


    LV_AdjustViewRectOnMove(plv, pitem, x, y);

    // and draw at new position
    ListView_RecalcRegion(plv, FALSE, TRUE);
    ListView_InvalidateItem(plv, i, FALSE, RDW_INVALIDATE);

    // If autoarrange is turned on, do it now...
    if (ListView_RedrawEnabled(plv)) {
        if (plv->ci.style & LVS_AUTOARRANGE)
            ListView_OnArrange(plv, LVA_DEFAULT);
        else
            ListView_UpdateScrollBars(plv);
    }

    return TRUE;
}

BOOL NEAR ListView_OnGetItemPosition(LV* plv, int i, POINT FAR* ppt)
{
    LISTITEM FAR* pitem;

    //
    // This needs to handle all views as it is used to figure out
    // where the item is during drag and drop and the like
    //
    if (!ppt)
    {
        RIPMSG(0, "LVM_GETITEMPOSITION: Invalid ppt = NULL");
        return FALSE;
    }

    if (ListView_IsListView(plv) || ListView_IsReportView(plv)
        || ListView_IsOwnerData( plv ))
    {
        RECT rcIcon;
        ListView_GetRects(plv, i, &rcIcon, NULL, NULL, NULL);
        ppt->x = rcIcon.left;
        ppt->y = rcIcon.top;

    } else {

        pitem = ListView_GetItemPtr(plv, i);
        if (!pitem)
            return FALSE;

        if (pitem->pt.x == RECOMPUTE)
            ListView_Recompute(plv);

        ppt->x = pitem->pt.x;
        ppt->y = pitem->pt.y;
    }
    return TRUE;
}




BOOL NEAR ListView_OnGetOrigin(LV* plv, POINT FAR* ppt)
{
    if (!ppt) {
        DebugMsg(DM_ERROR, TEXT("ListView_OnGetOrigin: ppt is NULL"));
        return FALSE;
    }

    if (ListView_IsListView(plv) || ListView_IsReportView(plv))
        return FALSE;

    *ppt = plv->ptOrigin;
    return TRUE;
}



#ifdef UNICODE
int NEAR ListView_OnGetStringWidthA(LV* plv, LPCSTR psz, HDC hdc) {
    LPWSTR pszW = NULL;
    int iRet;

    if (!psz)
        return 0;

    if ((psz != NULL) && (pszW = ProduceWFromA(plv->ci.uiCodePage, psz)) == NULL)
        return 0;

    iRet = ListView_OnGetStringWidth(plv, pszW, hdc);

    FreeProducedString(pszW);

    return iRet;
}
#endif

int NEAR ListView_OnGetStringWidth(LV* plv, LPCTSTR psz, HDC hdc)
{
    SIZE siz;
    HDC hdcFree = NULL;
    HFONT hfontPrev;

    if (!psz || psz == LPSTR_TEXTCALLBACK)
        return 0;

    if (!hdc) {
        hdcFree = hdc = GetDC(plv->ci.hwnd);
        hfontPrev = SelectFont(hdc, plv->hfontLabel);
    }

    GetTextExtentPoint(hdc, psz, lstrlen(psz), &siz);

    if (hdcFree) {
        SelectFont(hdc, hfontPrev);
        ReleaseDC(plv->ci.hwnd, hdcFree);
    }

    return siz.cx;
}

int NEAR ListView_OnGetColumnWidth(LV* plv, int iCol)
{
    if (ListView_IsReportView(plv))
        return ListView_RGetColumnWidth(plv, iCol);
    else if (ListView_IsListView(plv))
        return plv->cxItem;

    return 0;
}

BOOL FAR PASCAL ListView_ISetColumnWidth(LV* plv, int iCol, int cx, BOOL fExplicit)
{

    if (ListView_IsListView(plv))
    {
        if (iCol != 0 || cx <= 0)
            return FALSE;

        // if it's different and this is an explicit set, or we've never set it explicitly
        if (plv->cxItem != cx && (fExplicit || !(plv->flags & LVF_COLSIZESET)))
        {
            // REVIEW: Should optimize what gets invalidated here...

            plv->cxItem = cx;
            if (fExplicit)
                plv->flags |= LVF_COLSIZESET;   // Set the fact that we explictly set size!.

            if (ListView_IsLabelTip(plv))
            {
                // A truncated label may have been exposed or vice versa.
                ListView_InvalidateTTLastHit(plv, plv->iTTLastHit);
            }

            RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
            ListView_UpdateScrollBars(plv);
        }
        return TRUE;
    }
    else if (ListView_IsReportView(plv))
    {
        if (ListView_IsLabelTip(plv))
        {
            // A truncated label may have been exposed or vice versa.
            ListView_InvalidateTTLastHit(plv, plv->iTTLastHit);
        }
        return ListView_RSetColumnWidth(plv, iCol, cx);
    } else {
        if (cx && plv->cxItem != cx && (fExplicit || !(plv->flags & LVF_COLSIZESET)))
        {
            // REVIEW: Should optimize what gets invalidated here...
            plv->cxItem = cx;
            if (fExplicit)
                plv->flags |= LVF_COLSIZESET;   // Set the fact that we explictly set size!.

            RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
            ListView_UpdateScrollBars(plv);
        }
        // BUG-FOR-BUG COMPATIBILITY:  IE4 accidentally returned FALSE here.
    }
    return FALSE;
}

void NEAR ListView_Redraw(LV* plv, HDC hdc, RECT FAR* prcClip)
{
    int i;
    int cItem = ListView_Count(plv);
    DWORD dwType = plv->ci.style & LVS_TYPEMASK;
    NMCUSTOMDRAW nmcd;
    LVDRAWITEM lvdi;

    SetBkMode(hdc, TRANSPARENT);
    SelectFont(hdc, plv->hfontLabel);

    nmcd.hdc = hdc;

    /// not implemented yet
    //if (ptb->ci.hwnd == GetFocus())
    //nmcd.uItemState = CDIS_FOCUS;
    //else
    nmcd.uItemState = 0;
    nmcd.lItemlParam = 0;
    nmcd.rc = *prcClip;
    plv->ci.dwCustom = CICustomDrawNotify(&plv->ci, CDDS_PREPAINT, &nmcd);
    if (!(plv->ci.dwCustom & CDRF_SKIPDEFAULT)) {
        // Just before doing any painting, see if the region is up to date...
        ListView_RecalcRegion(plv, FALSE, TRUE);

        //
        // For list view and report view, we can save a lot of time
        // by calculating the index of the first item that may need
        // painting...
        //

        switch (dwType) {
        case LVS_REPORT:
            i = ListView_RYHitTest(plv, prcClip->top);
            cItem = ListView_RYHitTest(plv, prcClip->bottom) + 1;
            break;

        case LVS_LIST:
            i = ListView_LCalcViewItem(plv, prcClip->left, prcClip->top );
            cItem = ListView_LCalcViewItem( plv, prcClip->right, prcClip->bottom ) + 1;
            break;

        default:
            if (ListView_IsOwnerData( plv ))
            {
                ListView_CalcMinMaxIndex( plv, prcClip, &i, &cItem );
                break;
            }
            else
            {
                // REVIEW: we can keep a flag which tracks whether the view is
                // presently in pre-arranged order and bypass Zorder when it is
                i = 0;  // Icon views no such hint
            }
        }

        if (i < 0)
            i = 0;

        cItem = min( ListView_Count( plv ), cItem );
        if (ListView_IsOwnerData( plv ) && (cItem > i))
        {
            ListView_NotifyCacheHint( plv, i, cItem-1 );
            ListView_LazyCreateWinEvents( plv, i, cItem-1);
        }

        lvdi.plv = plv;
        lvdi.nmcd.nmcd.hdc = hdc;
        lvdi.prcClip = prcClip;
        lvdi.pitem = NULL;

        for (; i < cItem; i++)
        {
            BOOL bSuccess;
            int i2;

            if ((dwType == LVS_ICON || dwType == LVS_SMALLICON)
                && (!ListView_IsOwnerData(plv)))
            {
                LISTITEM FAR *pitem;

                // Icon views: Draw back-to-front mapped through
                // Z-order array for proper Z order appearance - If autoarrange
                // is on, we don't need to do this as our arrange code is setup
                // to not overlap items!
                //
                // For the cases where we might have overlap, we sped this up,
                // by converting the hdpaZorder into a list of indexes instead
                // of pointers.  This ovoids the costly convert pointer to
                // index call.
                //
                i2 = (int)(UINT_PTR)DPA_FastGetPtr(plv->hdpaZOrder, (cItem - 1) -i);

                //
                // do a fast clip check on the item so we dont even try to
                // draw it unless it is visible
                //
                // for small icon view we cant clip on the left without
                // getting the text
                //
                // for large icon view we cant clip on the top without
                // getting the text
                //
                // for large icon view in NOLABELWRAP mode, we can't clip
                // on the top without getting the text, nor can we clip to
                // the left or right in case the text is long.
                //
                // we can always clip to the bottom
                //
                pitem = ListView_FastGetItemPtr(plv, i2);

                if (pitem->pt.x != RECOMPUTE)
                {
                    if (pitem->pt.y - plv->ptOrigin.y > prcClip->bottom)
                        continue;

                    if (dwType == LVS_SMALLICON)
                    {
                        if (pitem->pt.x - plv->ptOrigin.x - plv->cxState > prcClip->right)
                            continue;

                        if (pitem->pt.y + plv->cyItem - plv->ptOrigin.y < prcClip->top)
                            continue;
                    }
                    else if (!(plv->ci.style & LVS_NOLABELWRAP))
                    {
                        if (pitem->pt.x - plv->cxIconSpacing - plv->ptOrigin.x > prcClip->right)
                            continue;

                        if (pitem->pt.x + plv->cxIconSpacing - plv->ptOrigin.x < prcClip->left)
                            continue;
                    }
                }
            }
            else
                i2 = i;

            plv->iItemDrawing = i2;

            lvdi.nmcd.nmcd.dwItemSpec = i2;

            // these may get changed
            lvdi.lpptOrg = NULL;
            lvdi.flags = 0;
            lvdi.nmcd.clrText = plv->clrText;
            lvdi.nmcd.clrTextBk = plv->clrTextBk;

            bSuccess = ListView_DrawItem(&lvdi);

            if (!bSuccess) {
                break;
            }
        }

        if ((dwType == LVS_ICON || dwType == LVS_SMALLICON)
            && (ListView_IsOwnerData(plv)) && 
            plv->iFocus != -1) {
            // since there's no zorder in ownerdata, we explicitly draw the focus guy last (again)
            // so that it'll appear on top
            // we may potentially want to do this for all items that are selected
            plv->iItemDrawing = plv->iFocus;

            lvdi.nmcd.nmcd.dwItemSpec = plv->iItemDrawing;

            // these may get changed
            lvdi.lpptOrg = NULL;
            lvdi.flags = 0;
            lvdi.nmcd.clrText = plv->clrText;
            lvdi.nmcd.clrTextBk = plv->clrTextBk;

            ListView_DrawItem(&lvdi);
        }


            
        // this is an NT5/Memphis feature.

        if (ListView_Count(plv) == 0)
        {
            // there're no items in this view
            // check if we need to display some text in this case.

            if (ListView_GetEmptyText(plv))
            {
                RECT rcClip;
                UINT flags = 0;

                // Put some edging between the text and the border of the
                // window so we don't slam up against the border.
                // This keeps DBCS from looking horrid.
                rcClip.left = g_cxEdge;
                rcClip.top = g_cyEdge;

#ifdef WINDOWS_ME
                if (plv->dwExStyle & WS_EX_RTLREADING)
                    flags |= SHDT_RTLREADING;
#endif
                // if its a report view && we have a header then move the text down
                if (ListView_IsReportView(plv) && (!(plv->ci.style & LVS_NOCOLUMNHEADER)))
                    rcClip.top += plv->cyItem;

                // Note: Use the full sizeClient.cx as the right margin
                // in case pszEmptyText is wider than the client rectangle.

                rcClip.left -= (int)plv->ptlRptOrigin.x;
                rcClip.right = plv->sizeClient.cx;
                rcClip.bottom = rcClip.top + plv->cyItem;

                SHDrawText(hdc, plv->pszEmptyText,
                    &rcClip, LVCFMT_LEFT, flags,
                    plv->cyLabelChar, plv->cxEllipses,
                    plv->clrText, plv->clrBk);
            }
        }

        plv->iItemDrawing = -1;

        // post painting.... this is to do any extra (non item) painting
        // such a grid lines
        switch (dwType) {
        case LVS_REPORT:
            ListView_RAfterRedraw(plv, hdc);
            break;
        }

        // notify parent afterwards if they want us to
        if (plv->ci.dwCustom & CDRF_NOTIFYPOSTPAINT) {
            CICustomDrawNotify(&plv->ci, CDDS_POSTPAINT, &nmcd);
        }
    }
}

BOOL NEAR ListView_DrawItem(PLVDRAWITEM plvdi)
{
    BOOL bRet = TRUE;
    UINT state;

    if (!ListView_IsOwnerData( plvdi->plv )) {
        plvdi->pitem = ListView_FastGetItemPtr(plvdi->plv, plvdi->nmcd.nmcd.dwItemSpec);
    }

    // notify on custom draw then do it!
    plvdi->nmcd.nmcd.uItemState = 0;
    plvdi->nmcd.nmcd.lItemlParam = (plvdi->pitem)? plvdi->pitem->lParam : 0;

    if (!(plvdi->flags & LVDI_NOWAYFOCUS))
    {
        if (plvdi->plv->flags & LVF_FOCUSED) {

            // if we're ownerdraw or asked to callback, go
            // fetch the state
            if (!plvdi->pitem || (plvdi->plv->stateCallbackMask & (LVIS_SELECTED | LVIS_FOCUSED))) {

                state = (WORD) ListView_OnGetItemState(plvdi->plv, (int) plvdi->nmcd.nmcd.dwItemSpec,
                                                LVIS_SELECTED | LVIS_FOCUSED);
            } else {
                state = plvdi->pitem->state;
            }


            if (state & LVIS_FOCUSED) {
                plvdi->nmcd.nmcd.uItemState |= CDIS_FOCUS;
            }

            if (state & LVIS_SELECTED) {
                plvdi->nmcd.nmcd.uItemState |= CDIS_SELECTED;
            }
        }

        // NOTE:  This is a bug.  We should set CDIS_SELECTED only if the item
        // really is selected.  But this bug has existed forever so who knows
        // what apps are relying on it.  Standard workaround is for the client
        // to do a GetItemState and reconfirm the LVIS_SELECTED flag.
        // That's what we do in ListView_DrawImageEx.
        if (plvdi->plv->ci.style & LVS_SHOWSELALWAYS) {
            plvdi->nmcd.nmcd.uItemState |= CDIS_SELECTED;
        }
    }

#ifdef KEYBOARDCUES
    if (!(CCGetUIState(&(plvdi->plv->ci)) & UISF_HIDEFOCUS))
    {
        plvdi->nmcd.nmcd.uItemState |= CDIS_SHOWKEYBOARDCUES;
    }
#endif
    plvdi->nmcd.clrText = plvdi->plv->clrText;
    plvdi->nmcd.clrTextBk = (plvdi->plv->ci.style & WS_DISABLED ? plvdi->plv->clrBk : plvdi->plv->clrTextBk);


    // PERF: if we decide to keep LVIS_EX_TWOCLICKACTIVATE, then we can
    // call ListView_OnGetItem for LVIF_TEXT | LVIF_IMAGE | LVIF_STATE
    // and pass the intem info into _ListView_DrawItem below.
    if (plvdi->plv->iHot == (int)plvdi->nmcd.nmcd.dwItemSpec) {
        // Handle the HOT case
        if(plvdi->plv->clrHotlight != CLR_DEFAULT)
            plvdi->nmcd.clrText = plvdi->plv->clrHotlight;
        else
            plvdi->nmcd.clrText = GetSysColor(COLOR_HOTLIGHT);
        // ie4 bug 47635: if hotlight color is the same as the background
        // color you don't see the text -- slam to a visible color in this case.
        if (plvdi->nmcd.clrText == plvdi->nmcd.clrTextBk)
        {
            if (COLORISLIGHT(plvdi->nmcd.clrTextBk))
                plvdi->nmcd.clrText = 0x000000; // black
            else
                plvdi->nmcd.clrText = 0xFFFFFF; // white
        }
        if ((plvdi->plv->exStyle & LVS_EX_ONECLICKACTIVATE) ||
            ((plvdi->plv->exStyle & LVS_EX_TWOCLICKACTIVATE) &&
             ListView_OnGetItemState(plvdi->plv, (int) plvdi->nmcd.nmcd.dwItemSpec, LVIS_SELECTED))) {
            if ((plvdi->plv->exStyle & LVS_EX_UNDERLINEHOT) &&
                (plvdi->plv->hFontHot))
                SelectFont(plvdi->nmcd.nmcd.hdc, plvdi->plv->hFontHot);
            else
                SelectFont(plvdi->nmcd.nmcd.hdc, plvdi->plv->hfontLabel);
            plvdi->nmcd.nmcd.uItemState |= CDIS_HOT;
        }
    } else if ((plvdi->plv->exStyle & LVS_EX_ONECLICKACTIVATE) ||
               ((plvdi->plv->exStyle & LVS_EX_TWOCLICKACTIVATE) &&
                ListView_OnGetItemState(plvdi->plv, (int) plvdi->nmcd.nmcd.dwItemSpec, LVIS_SELECTED))) {
        // Handle the non-hot webview case
        if ((plvdi->plv->exStyle & LVS_EX_UNDERLINECOLD) && (plvdi->plv->hFontHot))
            SelectFont(plvdi->nmcd.nmcd.hdc, plvdi->plv->hFontHot);
        else
            SelectFont(plvdi->nmcd.nmcd.hdc, plvdi->plv->hfontLabel);
    } else {
        // Handle the non-webview case
        SelectFont(plvdi->nmcd.nmcd.hdc, plvdi->plv->hfontLabel);
    }


    plvdi->dwCustom = CICustomDrawNotify(&plvdi->plv->ci, CDDS_ITEMPREPAINT, &plvdi->nmcd.nmcd);

    plvdi->flags &= ~(LVDI_FOCUS | LVDI_SELECTED);
    if (plvdi->nmcd.nmcd.uItemState & CDIS_FOCUS)
        plvdi->flags |= LVDI_FOCUS;

    if (plvdi->nmcd.nmcd.uItemState & CDIS_SELECTED) {
        if (plvdi->plv->flags & LVF_FOCUSED)
            plvdi->flags |= LVDI_SELECTED;
        else
            plvdi->flags |= LVDI_SELECTNOFOCUS;
        if (plvdi->plv->iHot == (int)plvdi->nmcd.nmcd.dwItemSpec)
            plvdi->flags |= LVDI_HOTSELECTED;
    }

    if (!(plvdi->dwCustom & CDRF_SKIPDEFAULT)) {

        if (!ListView_IsOwnerData( plvdi->plv )) {

#ifdef DEBUG_NEWFONT
            if ((plvdi->nmcd.nmcd.dwItemSpec % 3) == 0) {
                plvdi->dwCustom |= CDRF_NEWFONT;
                SelectObject(plvdi->nmcd.nmcd.hdc, GetStockObject(SYSTEM_FONT));
            }
#endif

            if (plvdi->dwCustom & CDRF_NEWFONT) {
                ListView_RecomputeLabelSize(plvdi->plv, plvdi->pitem, (int) plvdi->nmcd.nmcd.dwItemSpec, plvdi->nmcd.nmcd.hdc, FALSE);
            }
        }

        bRet = _ListView_DrawItem(plvdi);


        if (plvdi->dwCustom & CDRF_NOTIFYPOSTPAINT) {
            plvdi->nmcd.iSubItem = 0;
            CICustomDrawNotify(&plvdi->plv->ci, CDDS_ITEMPOSTPAINT, &plvdi->nmcd.nmcd);
        }
        if (plvdi->dwCustom & CDRF_NEWFONT) {
            SelectObject(plvdi->nmcd.nmcd.hdc, plvdi->plv->hfontLabel);
            plvdi->plv->flags |= LVF_CUSTOMFONT;
        }
    }
    return bRet;
}

// NOTE: this function requires a properly selected font.
//
void WINAPI SHDrawText(HDC hdc, LPCTSTR pszText, RECT FAR* prc, int fmt,
                UINT flags, int cyChar, int cxEllipses, COLORREF clrText, COLORREF clrTextBk)
{
    int cchText;
    COLORREF clrSave, clrSaveBk = 0;
    RECT rc;
    UINT uETOFlags = 0;
    BOOL fForeOnly = FALSE;
    TCHAR ach[CCHLABELMAX + CCHELLIPSES];

#ifdef WINDOWS_ME
    int align;
#endif

    // REVIEW: Performance idea:
    // We could cache the currently selected text color
    // so we don't have to set and restore it each time
    // when the color is the same.
    //
    if (!pszText)
        return;

    if (IsRectEmpty(prc))
        return;

#ifdef WINDOWS_ME
    if (flags & SHDT_RTLREADING) {
        align = GetTextAlign(hdc);
        SetTextAlign(hdc, align | TA_RTLREADING);
    }
#endif

    rc = *prc;

    // If needed, add in a little extra margin...
    //
    if (flags & SHDT_EXTRAMARGIN)
    {
        rc.left  += g_cxLabelMargin * 3;
        rc.right -= g_cxLabelMargin * 3;
    }
    else
    {
        rc.left  += g_cxLabelMargin;
        rc.right -= g_cxLabelMargin;
    }

    if ((rc.left >= rc.right) && !(flags & (SHDT_SELECTED | SHDT_DESELECTED | SHDT_SELECTNOFOCUS)))
        return;

    if ((flags & SHDT_ELLIPSES) &&
            ListView_NeedsEllipses(hdc, pszText, &rc, &cchText, cxEllipses))
    {
        // In some cases cchText was comming back bigger than
        // ARRYASIZE(ach), so we need to make sure we don't overflow the buffer

        // if cchText is too big for the buffer, truncate it down to size
        if (cchText >= ARRAYSIZE(ach) - CCHELLIPSES)
            cchText = ARRAYSIZE(ach) - CCHELLIPSES - 1;

        hmemcpy(ach, pszText, cchText * sizeof(TCHAR));
        lstrcpy(ach + cchText, c_szEllipses);

        pszText = ach;

        // Left-justify, in case there's no room for all of ellipses
        //
        fmt = LVCFMT_LEFT;

        cchText += CCHELLIPSES;
    }
    else
    {
        cchText = lstrlen(pszText);
    }

    if (((clrTextBk == CLR_NONE) && !(flags & (SHDT_SELECTED | SHDT_SELECTNOFOCUS))) || (flags & SHDT_TRANSPARENT))
    {
        fForeOnly = TRUE;
        clrSave = SetTextColor(hdc, (flags & SHDT_TRANSPARENT) ? 0 : clrText);
    }
    else
    {
        HBRUSH hbrUse = NULL;
        HBRUSH hbrDelete = NULL;

        uETOFlags |= ETO_OPAQUE;

        if (flags & SHDT_SELECTED)
        {
            clrText = g_clrHighlightText;
            clrTextBk = (flags & SHDT_HOTSELECTED) ? GetSysColor(COLOR_HOTLIGHT) : g_clrHighlight;

            if (flags & SHDT_DRAWTEXT)
                hbrUse = (flags & SHDT_HOTSELECTED) ? GetSysColorBrush(COLOR_HOTLIGHT) : g_hbrHighlight;

        }
        else if (flags & SHDT_SELECTNOFOCUS)
        {
            if ((clrTextBk == CLR_DEFAULT ? g_clrWindow : clrTextBk) == g_clrBtnFace)
            {
                // if the text background color in this mode is the same as the current
                // background, use the color highlight text so that you can actually see somehting
                clrText = g_clrHighlightText;
                clrTextBk = g_clrHighlight;
                if (flags & SHDT_DRAWTEXT)
                    hbrUse = g_hbrHighlight;
            } 
            else 
            {
                clrText = g_clrBtnText;
                clrTextBk = g_clrBtnFace;
                if (flags & SHDT_DRAWTEXT)
                    hbrUse = g_hbrBtnFace;
            }

#ifdef LVDEBUG
            if (GetAsyncKeyState(VK_CONTROL) < 0)
                clrText = g_clrBtnHighlight;
#endif
        }
        else if (clrText == CLR_DEFAULT && clrTextBk == CLR_DEFAULT)
        {
            clrText = g_clrWindowText;
            clrTextBk = g_clrWindow;

            if ( ( flags & (SHDT_DRAWTEXT | SHDT_DESELECTED) ) ==
               (SHDT_DRAWTEXT | SHDT_DESELECTED) )
            {
                hbrUse = g_hbrWindow;
            }
        }
        else
        {
            if (clrText == CLR_DEFAULT)
                clrText =  g_clrWindowText;

            if (clrTextBk == CLR_DEFAULT)
                clrTextBk = g_clrWindow;

            if ( ( flags & (SHDT_DRAWTEXT | SHDT_DESELECTED) ) ==
               (SHDT_DRAWTEXT | SHDT_DESELECTED) )
            {
                hbrUse = CreateSolidBrush(GetNearestColor(hdc, clrTextBk));
                if (hbrUse)
                {
                    hbrDelete = hbrUse;
                }
                else
                    hbrUse = GetStockObject( WHITE_BRUSH );
            }
        }

        // now set it
        clrSave = SetTextColor(hdc, clrText);
        clrSaveBk = SetBkColor(hdc, clrTextBk);
        if (hbrUse) {
            FillRect(hdc, prc, hbrUse);
            if (hbrDelete)
                DeleteObject(hbrDelete);
        }
    }

    // If we want the item to display as if it was depressed, we will
    // offset the text rectangle down and to the left
    if (flags & SHDT_DEPRESSED)
        OffsetRect(&rc, g_cxBorder, g_cyBorder);

    if (flags & SHDT_DRAWTEXT)
    {
        UINT uDTFlags = DT_LVWRAP | DT_END_ELLIPSIS;

        if (flags & SHDT_DTELLIPSIS)
            uDTFlags |= DT_WORD_ELLIPSIS;

        if ( !( flags & SHDT_CLIPPED ) )
            uDTFlags |= DT_NOCLIP;

        if (flags & SHDT_NODBCSBREAK)
            uDTFlags |= DT_NOFULLWIDTHCHARBREAK;

        DrawText(hdc, pszText, cchText, &rc, uDTFlags );
    }
    else
    {
        if (fmt != LVCFMT_LEFT)
        {
            SIZE siz;

            GetTextExtentPoint(hdc, pszText, cchText, &siz);

            if (fmt == LVCFMT_CENTER)
                rc.left = (rc.left + rc.right - siz.cx) / 2;
            else    // fmt == LVCFMT_RIGHT
                rc.left = rc.right - siz.cx;
        }

        // Center vertically in case the bitmap (to the left) is larger than
        // the height of one line
        rc.top += (rc.bottom - rc.top - cyChar) / 2;

        if ( flags & SHDT_CLIPPED )
           uETOFlags |= ETO_CLIPPED;

        ExtTextOut(hdc, rc.left, rc.top, uETOFlags, prc, pszText, cchText, NULL);
    }

    if (flags & (SHDT_SELECTED | SHDT_DESELECTED | SHDT_TRANSPARENT))
    {
        SetTextColor(hdc, clrSave);
        if (!fForeOnly)
            SetBkColor(hdc, clrSaveBk);
    }

#ifdef WINDOWS_ME
    if (flags & SHDT_RTLREADING)
        SetTextAlign(hdc, align);
#endif
}

/*----------------------------------------------------------------
** Create an imagelist to be used for dragging.
**
** 1) create mask and image bitmap matching the select bounds size
** 2) draw the text to both bitmaps (in black for now)
** 3) create an imagelist with these bitmaps
** 4) make a dithered copy of the image onto the new imagelist
**----------------------------------------------------------------*/
HIMAGELIST NEAR ListView_OnCreateDragImage(LV *plv, int iItem, LPPOINT lpptUpLeft)
{
    HWND hwndLV = plv->ci.hwnd;
    RECT rcBounds, rcImage, rcLabel;
    HDC hdcMem = NULL;
    HBITMAP hbmImage = NULL;
    HBITMAP hbmMask = NULL;
    HBITMAP hbmOld;
    HIMAGELIST himl = NULL;
    int dx, dy;
    HIMAGELIST himlSrc;
    LV_ITEM item;
    POINT ptOrg;
    LVDRAWITEM lvdi;
    RECT rcSelBounds;
    BOOL bMirroredWnd = (plv->ci.dwExStyle&RTL_MIRRORED_WINDOW);

    if (!lpptUpLeft)
        return NULL;

    if (iItem >= ListView_Count(plv))
        return NULL;

    if (plv->iHot == iItem) {
        ListView_OnSetHotItem(plv, -1);
        UpdateWindow(plv->ci.hwnd);
    }

    ListView_GetRects(plv, iItem, &rcImage, &rcLabel, &rcBounds, &rcSelBounds);

    if (ListView_IsIconView(plv)) {
        ListView_UnfoldRects(plv, iItem, &rcImage, &rcLabel,
                                         &rcBounds, &rcSelBounds);
        InflateRect(&rcImage, -g_cxIconMargin, -g_cyIconMargin);
    }

    // chop off any extra filler above icon
    ptOrg.x = rcBounds.left - rcSelBounds.left;
    ptOrg.y = rcBounds.top - rcImage.top;
    dx = rcSelBounds.right - rcSelBounds.left;
    dy = rcSelBounds.bottom - rcImage.top;

    lpptUpLeft->x = rcSelBounds.left;
    lpptUpLeft->y = rcImage.top;

    if (!(hdcMem = CreateCompatibleDC(NULL)))
        goto CDI_Exit;
    if (!(hbmImage = CreateColorBitmap(dx, dy)))
        goto CDI_Exit;
    if (!(hbmMask = CreateMonoBitmap(dx, dy)))
        goto CDI_Exit;

    //
    // Mirror the memory DC so that the transition from
    // mirrored(memDC)->non-mirrored(imagelist DCs)->mirrored(screenDC)
    // is consistent. [samera]
    //
    if (bMirroredWnd)
    {
        SET_DC_RTL_MIRRORED(hdcMem);
    }

    // prepare for drawing the item
    SelectObject(hdcMem, plv->hfontLabel);
    SetBkMode(hdcMem, TRANSPARENT);

    lvdi.plv = plv;
    lvdi.nmcd.nmcd.dwItemSpec = iItem;
    lvdi.pitem = NULL;  // make sure it is null as Owner data uses this to trigger things...
    lvdi.nmcd.nmcd.hdc = hdcMem;
    lvdi.lpptOrg = &ptOrg;
    lvdi.prcClip = NULL;
    lvdi.flags = LVDI_NOIMAGE | LVDI_TRANSTEXT | LVDI_NOWAYFOCUS | LVDI_UNFOLDED;
    /*
    ** draw the text to both bitmaps
    */
    hbmOld = SelectObject(hdcMem, hbmImage);
    // fill image with black for transparency
    PatBlt(hdcMem, 0, 0, dx, dy, BLACKNESS);
    ListView_DrawItem(&lvdi);
    if (bMirroredWnd)
        MirrorBitmapInDC(hdcMem, hbmImage);

    lvdi.flags = LVDI_NOIMAGE | LVDI_TRANSTEXT | LVDI_NOWAYFOCUS | LVDI_UNFOLDED;
    SelectObject(hdcMem, hbmMask);
    // fill mask with white for transparency
    PatBlt(hdcMem, 0, 0, dx, dy, WHITENESS);
    ListView_DrawItem(&lvdi);
    if (bMirroredWnd)
        MirrorBitmapInDC(hdcMem, hbmMask);

    // unselect objects that we used
    SelectObject(hdcMem, hbmOld);
    SelectObject(hdcMem, g_hfontSystem);

    himlSrc = ListView_OnGetImageList(plv, !(ListView_IsIconView(plv)));

    /*
    ** make an image list that for now only has the text
    ** we use ImageList_Clone so we get a imagelist that
    ** the same color depth as our own imagelist
    */
    if (!(himl = ImageList_Clone(himlSrc, dx, dy, ILC_MASK, 1, 0)))
        goto CDI_Exit;

    ImageList_SetBkColor(himl, CLR_NONE);
    ImageList_Add(himl, hbmImage, hbmMask);

    /*
    ** make a dithered copy of the image part onto our bitmaps
    ** (need both bitmap and mask to be dithered)
    */
    if (himlSrc)
    {
        item.iItem = iItem;
        item.iSubItem = 0;
        item.mask = LVIF_IMAGE |LVIF_STATE;
        item.stateMask = LVIS_OVERLAYMASK;
        ListView_OnGetItem(plv, &item);

        ImageList_CopyDitherImage(himl, 0, rcImage.left - rcSelBounds.left, 0, himlSrc, item.iImage, ((plv->ci.dwExStyle & dwExStyleRTLMirrorWnd) ? ILD_MIRROR : 0L) | (item.state & LVIS_OVERLAYMASK) );
    }

CDI_Exit:
    if (hdcMem)
        DeleteObject(hdcMem);
    if (hbmImage)
        DeleteObject(hbmImage);
    if (hbmMask)
        DeleteObject(hbmMask);

    return himl;
}


//-------------------------------------------------------------------
// ListView_OnGetTopIndex -- Gets the index of the first visible item
// For list view and report view this calculates the actual index
// for iconic views it alway returns 0
//
int NEAR ListView_OnGetTopIndex(LV* plv)
{
    if (ListView_IsReportView(plv))
        return  (int)((plv->ptlRptOrigin.y) / plv->cyItem);

    else if (ListView_IsListView(plv))
        return  (plv->xOrigin / plv->cxItem) * plv->cItemCol;

    else
        return(0);
}




//-------------------------------------------------------------------
// ListView_OnGetCountPerPage -- Gets the count of items that will fit
// on a page For list view and report view this calculates the
// count depending on the size of the window and for Iconic views it
// will always return the count of items in the list view.
//
int NEAR ListView_OnGetCountPerPage(LV* plv)
{
    if (ListView_IsReportView(plv))
        return (plv->sizeClient.cy - plv->yTop) / plv->cyItem;

    else if (ListView_IsListView(plv))
        return ((plv->sizeClient.cx)/ plv->cxItem)
                * plv->cItemCol;
    else
        return (ListView_Count(plv));
}


/*----------------------------------------------------------------------------
/ ListView_InvalidateFoldedItem implementation
/ -----------------------------
/ Purpose:
/   Provides support for invalidating items within list views.
/
/ Notes:
/   Copes with invalidating the extra region in the list view that requires
/   us to erase the background.  Design to optimise out the ERASURE of the
/   background.
/
/   For details on the API see ListView_InvalidateItem.
/
/ In:
/   plv->ListView structure to work with
/   iItem = item number
/   bSrelectionOnly = refesh the selection
/   fRedraw = Flags for RedrawWindow
/ Out:
/   -
/----------------------------------------------------------------------------*/
void NEAR ListView_InvalidateFoldedItem(LV* plv, int iItem, BOOL fSelectionOnly, UINT fRedraw)
{
    ListView_InvalidateItem( plv, iItem, fSelectionOnly, fRedraw );

    if ( ListView_IsIconView(plv) &&
        ( !ListView_IsItemUnfolded(plv, iItem) || (fRedraw & RDW_ERASE) ) )
    {
        RECT rcLabel;

        if (ListView_GetUnfoldedRect(plv, iItem, &rcLabel))
        {
            RedrawWindow(plv->ci.hwnd, &rcLabel, NULL, fRedraw|RDW_ERASE);
        }
    }
}


/*----------------------------------------------------------------------------
/ ListView_UnfoldedRects implementation
/ ----------------------
/ Purpose:
/   Having previously called get rects, then call this function to ensure
/   that they are correctly unfolded.
/
/ Notes:
/   -
/
/ In:
/   plv-> list view to unfold on
/   iItem = item number
/   prcIcon -> icon bounding box
/   prcLabel -> rectangle for the label structure
/   prcBounds -> bounds rectangle / == NULL for none    / These are currently the same for large icons
/   prcSelectBounds -> selection bounds / == NULL       /
/ Out: TRUE if unfolding the item was worth anything
/   -
/----------------------------------------------------------------------------*/
BOOL NEAR ListView_UnfoldRects(LV* plv, int iItem,
                               RECT * prcIcon, RECT * prcLabel,
                               RECT * prcBounds, RECT * prcSelectBounds)
{
    LISTITEM item;
    LISTITEM FAR* pitem = &item;
    BOOL fRc = FALSE;

    if (!ListView_IsIconView(plv))
        return fRc;

    // If we have a label pointer then expand as required
    // nb - different paths for owner data

    if ( prcLabel )
    {
        if ( !ListView_IsOwnerData(plv) )
        {
            pitem = ListView_GetItemPtr(plv, iItem);
            if (!EVAL(pitem)) {
                // DavidShi was able to get us into here with an invalid
                // item number during a delete notification.  So if the
                // item number is invalid, just return a blank rectangle
                // instead of faulting.
                SetRectEmpty(prcLabel);
                goto doneLabel;
            }
        }
        else
        {
            ListView_RecomputeLabelSize( plv, pitem, iItem, NULL, FALSE );
        }

        if (prcLabel->bottom != prcLabel->top + max(pitem->cyUnfoldedLabel, pitem->cyFoldedLabel))
            fRc = TRUE;

        prcLabel->bottom = prcLabel->top + pitem->cyUnfoldedLabel;

    }
doneLabel:

    // Build the unions if required

    if ( prcBounds && prcIcon && prcLabel )
    {
        UnionRect( prcBounds, prcIcon, prcLabel );
    }
    if ( prcSelectBounds && prcIcon && prcLabel )
    {
        UnionRect( prcSelectBounds, prcIcon, prcLabel );
    }

    return fRc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\lvicon.c ===
// large icon view stuff

#include "ctlspriv.h"
#include "listview.h"

#if defined(FE_IME) || !defined(WINNT)
static TCHAR const szIMECompPos[]=TEXT("IMECompPos");
#endif

__inline int ICONCXLABEL(LV *plv, LISTITEM *pitem)
{
    if (plv->ci.style & LVS_NOLABELWRAP) {
        ASSERT(pitem->cxSingleLabel == pitem->cxMultiLabel);
    }
    return pitem->cxMultiLabel;
}

int LV_GetNewColWidth(LV* plv, int iFirst, int iLast);
void LV_AdjustViewRectOnMove(LV* plv, LISTITEM *pitem, int x, int y);
UINT LV_IsItemOnViewEdge(LV* plv, LISTITEM *pitem);
void ListView_RecalcRegion(LV *plv, BOOL fForce, BOOL fRedraw);

extern BOOL g_fSlowMachine;

BOOL ListView_IDrawItem(PLVDRAWITEM plvdi)
{
    RECT rcIcon;
    RECT rcLabel;
    RECT rcBounds;
    RECT rcT;
    TCHAR ach[CCHLABELMAX];
    LV_ITEM item;
    int i = (int) plvdi->nmcd.nmcd.dwItemSpec;
    LV* plv = plvdi->plv;
    LISTITEM FAR* pitem;
    BOOL fUnfolded;

    if (ListView_IsOwnerData(plv))
    {
        LISTITEM litem;

        // moved here to reduce call backs in OWNERDATA case
        item.iItem = i;
        item.iSubItem = 0;
        item.mask = LVIF_TEXT | LVIF_STATE | LVIF_IMAGE;
        item.stateMask = LVIS_ALL;
        item.pszText = ach;
        item.cchTextMax = ARRAYSIZE(ach);
        ListView_OnGetItem(plv, &item);

        litem.pszText = item.pszText;
        ListView_GetRectsOwnerData(plv, i, &rcIcon, &rcLabel, &rcBounds, NULL, &litem);
        pitem = NULL;
    }
    else
    {
        pitem = ListView_GetItemPtr(plv, i);
        // NOTE this will do a GetItem LVIF_TEXT iff needed
        ListView_GetRects(plv, i, &rcIcon, &rcLabel, &rcBounds, NULL);
    }

    fUnfolded = FALSE;
    if ( (plvdi->flags & LVDI_UNFOLDED) || ListView_IsItemUnfolded(plv, i))
    {
        ListView_UnfoldRects(plv, i, &rcIcon, &rcLabel, &rcBounds, NULL );
        fUnfolded = TRUE;
    }

    if (!plvdi->prcClip || IntersectRect(&rcT, &rcBounds, plvdi->prcClip))
    {
        UINT fText;

        if (!ListView_IsOwnerData(plv))
        {
            item.iItem = i;
            item.iSubItem = 0;
            item.mask = LVIF_TEXT | LVIF_STATE | LVIF_IMAGE;
            item.stateMask = LVIS_ALL;
            item.pszText = ach;
            item.cchTextMax = ARRAYSIZE(ach);
            ListView_OnGetItem(plv, &item);
            
            // Make sure the listview hasn't been altered during
            // the callback to get the item info

            if (pitem != ListView_GetItemPtr(plv, i))
                return FALSE;
        }

        if (plvdi->lpptOrg)
        {
            OffsetRect(&rcIcon, plvdi->lpptOrg->x - rcBounds.left,
                                plvdi->lpptOrg->y - rcBounds.top);
            OffsetRect(&rcLabel, plvdi->lpptOrg->x - rcBounds.left,
                                plvdi->lpptOrg->y - rcBounds.top);
        }

        if (ListView_IsIconView(plv))
        {
            fText = ListView_DrawImage(plv, &item, plvdi->nmcd.nmcd.hdc,
                                       rcIcon.left + g_cxIconMargin, rcIcon.top + g_cyIconMargin, plvdi->flags);

            // If linebreaking needs to happen, then use SHDT_DRAWTEXT.
            // Otherwise, use our (hopefully faster) internal SHDT_ELLIPSES
            if (rcLabel.bottom - rcLabel.top > plv->cyLabelChar)
                fText |= SHDT_DRAWTEXT;
            else
                fText |= SHDT_ELLIPSES;

            // We only use DT_NOFULLWIDTHCHARBREAK on Korean(949) Memphis and NT5
            if (949 == g_uiACP && (g_bRunOnNT5 || g_bRunOnMemphis))
                fText |= SHDT_NODBCSBREAK;

        }
        else
        {
            fText = ListView_DrawImage(plv, &item, plvdi->nmcd.nmcd.hdc,
                                       rcIcon.left, rcIcon.top, plvdi->flags);


        }

        // Don't draw label if it's being edited...
        //
        if (plv->iEdit != i)
        {
            // If multiline label, then we need to use DrawText
            if (rcLabel.bottom - rcLabel.top > plv->cyLabelChar)
            {
                fText |= SHDT_DRAWTEXT;

                // If the text is folded, we need to clip and add ellipses

                if (!fUnfolded)
                    fText |= SHDT_CLIPPED | SHDT_DTELLIPSIS;

                if ( ListView_IsOwnerData(plv) )
                {
                    // If owner data, we have no z-order and if long names they will over lap each
                    // other, better to truncate for now...
                    if (ListView_IsSmallView(plv))
                        fText |= SHDT_ELLIPSES;
                }

            }
            else
                fText |= SHDT_ELLIPSES;

            if (plvdi->flags & LVDI_TRANSTEXT)
                fText |= SHDT_TRANSPARENT;

            if ((fText & SHDT_SELECTED) && (plvdi->flags & LVDI_HOTSELECTED))
                fText |= SHDT_HOTSELECTED;

            if (item.pszText && (*item.pszText))
            {
#ifdef WINDOWS_ME
                if(plv->dwExStyle & WS_EX_RTLREADING)
                    fText |= SHDT_RTLREADING;
#endif
                SHDrawText(plvdi->nmcd.nmcd.hdc, item.pszText, &rcLabel, LVCFMT_LEFT, fText,
                           plv->cyLabelChar, plv->cxEllipses,
                           plvdi->nmcd.clrText, plvdi->nmcd.clrTextBk);

                if ((plvdi->flags & LVDI_FOCUS) && (item.state & LVIS_FOCUSED)
#ifdef KEYBOARDCUES
                    && !(CCGetUIState(&(plvdi->plv->ci)) & UISF_HIDEFOCUS)
#endif
					)
                {
                    DrawFocusRect(plvdi->nmcd.nmcd.hdc, &rcLabel);
                }
            }
        }
    }
    return TRUE;
}

void ListView_RefoldLabelRect(LV* plv, RECT *prcLabel, LISTITEM *pitem)
{
    int bottom = pitem->cyUnfoldedLabel;
    bottom = min(bottom, pitem->cyFoldedLabel);
    bottom = min(bottom, CLIP_HEIGHT);
    prcLabel->bottom = prcLabel->top + bottom;
}

int NEAR ListView_IItemHitTest(LV* plv, int x, int y, UINT FAR* pflags, int *piSubItem)
{
    int iHit;
    UINT flags;
    POINT pt;
    RECT rcLabel;
    RECT rcIcon;
    RECT rcState;

    if (piSubItem)
        *piSubItem = 0;

    // Map window-relative coordinates to view-relative coords...
    //
    pt.x = x + plv->ptOrigin.x;
    pt.y = y + plv->ptOrigin.y;

    // If there are any uncomputed items, recompute them now.
    //
    if (plv->rcView.left == RECOMPUTE)
        ListView_Recompute(plv);

    flags = 0;

    if (ListView_IsOwnerData( plv ))
    {
        int cSlots;
        POINT ptWnd;
        LISTITEM item;

        cSlots = ListView_GetSlotCount( plv, TRUE );
        iHit = ListView_CalcHitSlot( plv, pt, cSlots );
        if (iHit < ListView_Count(plv))
        {
            ListView_IGetRectsOwnerData( plv, iHit, &rcIcon, &rcLabel, &item, FALSE );
            ptWnd.x = x;
            ptWnd.y = y;
            if (PtInRect(&rcIcon, ptWnd))
            {
                flags = LVHT_ONITEMICON;
            }
            else if (PtInRect(&rcLabel, ptWnd))
            {
                flags = LVHT_ONITEMLABEL;
            }
        }
    }
    else
    {
        for (iHit = 0; (iHit < ListView_Count(plv)); iHit++)
        {
            LISTITEM FAR* pitem = ListView_FastGetZItemPtr(plv, iHit);
            POINT ptItem;

            ptItem.x = pitem->pt.x;
            ptItem.y = pitem->pt.y;

            rcIcon.top    = ptItem.y - g_cyIconMargin;

            rcLabel.top    = ptItem.y + plv->cyIcon + g_cyLabelSpace;
            rcLabel.bottom = rcLabel.top + pitem->cyUnfoldedLabel;

            if ( !ListView_IsItemUnfoldedPtr(plv, pitem) )
                ListView_RefoldLabelRect(plv, &rcLabel, pitem);

            // Quick, easy rejection test...
            //
            if (pt.y < rcIcon.top || pt.y >= rcLabel.bottom)
                continue;

            rcIcon.left   = ptItem.x - g_cxIconMargin;
            rcIcon.right  = ptItem.x + plv->cxIcon + g_cxIconMargin;
            // We need to make sure there is no gap between the icon and label
            rcIcon.bottom = rcLabel.top;

            rcState.bottom = ptItem.y + plv->cyIcon;
            rcState.right = ptItem.x;
            rcState.top = rcState.bottom - plv->cyState;
            rcState.left = rcState.right - plv->cxState;

            rcLabel.left   = ptItem.x  + (plv->cxIcon / 2) - (ICONCXLABEL(plv, pitem) / 2);
            rcLabel.right  = rcLabel.left + ICONCXLABEL(plv, pitem);

            if (plv->cxState && PtInRect(&rcState, pt))
            {
                flags = LVHT_ONITEMSTATEICON;
            }
            else if (PtInRect(&rcIcon, pt))
            {
                flags = LVHT_ONITEMICON;
            }
            else if (PtInRect(&rcLabel, pt))
            {
                flags = LVHT_ONITEMLABEL;
            }
            
            if (flags)
                break;
        }
    }

    if (flags == 0)
    {
        flags = LVHT_NOWHERE;
        iHit = -1;
    }
    else
    {
      if (!ListView_IsOwnerData( plv ))
        {
        iHit = DPA_GetPtrIndex(plv->hdpa, ListView_FastGetZItemPtr(plv, iHit));
        }
    }

    *pflags = flags;
    return iHit;
}

// BUGBUG raymondc
// need to pass HDC here isnce it's sometimes called from the paint loop

void NEAR ListView_IGetRectsOwnerData( LV* plv,
        int iItem,
        RECT FAR* prcIcon,
        RECT FAR* prcLabel,
        LISTITEM* pitem,
        BOOL fUsepitem )
{
   int itemIconXLabel;
   int cSlots;

   // calculate x, y from iItem
   cSlots = ListView_GetSlotCount( plv, TRUE );
   pitem->iWorkArea = 0;               // OwnerData doesn't support workareas
   ListView_SetIconPos( plv, pitem, iItem, cSlots );

   // calculate lable sizes from iItem
   ListView_RecomputeLabelSize( plv, pitem, iItem, NULL, fUsepitem);

   if (plv->ci.style & LVS_NOLABELWRAP)
   {
      // use single label
      itemIconXLabel = pitem->cxSingleLabel;
   }
   else
   {
      // use multilabel
      itemIconXLabel = pitem->cxMultiLabel;
   }

    prcIcon->left   = pitem->pt.x - g_cxIconMargin - plv->ptOrigin.x;
    prcIcon->right  = prcIcon->left + plv->cxIcon + 2 * g_cxIconMargin;
    prcIcon->top    = pitem->pt.y - g_cyIconMargin - plv->ptOrigin.y;
    prcIcon->bottom = prcIcon->top + plv->cyIcon + 2 * g_cyIconMargin;

    prcLabel->left   = pitem->pt.x  + (plv->cxIcon / 2) - (itemIconXLabel / 2) - plv->ptOrigin.x;
    prcLabel->right  = prcLabel->left + itemIconXLabel;
    prcLabel->top    = pitem->pt.y  + plv->cyIcon + g_cyLabelSpace - plv->ptOrigin.y;
    prcLabel->bottom = prcLabel->top  + pitem->cyUnfoldedLabel;

    if ( !ListView_IsItemUnfolded(plv, iItem) )
        ListView_RefoldLabelRect(plv, prcLabel, pitem);
}


// out:
//      prcIcon         icon bounds including icon margin area

void NEAR ListView_IGetRects(LV* plv, LISTITEM FAR* pitem, RECT FAR* prcIcon, RECT FAR* prcLabel, LPRECT prcBounds)
{
    int cxIconMargin;

    ASSERT( !ListView_IsOwnerData( plv ) );

    if (pitem->pt.x == RECOMPUTE) {
        ListView_Recompute(plv);
    }

    if (ListView_IsIconView(plv) && ((plv->cxIconSpacing - plv->cxIcon) < (2 * g_cxIconMargin)))
        cxIconMargin = (plv->cxIconSpacing - plv->cxIcon) / 2;
    else
        cxIconMargin = g_cxIconMargin;

    prcIcon->left   = pitem->pt.x - cxIconMargin - plv->ptOrigin.x;
    prcIcon->right  = prcIcon->left + plv->cxIcon + 2 * cxIconMargin;
    prcIcon->top    = pitem->pt.y - g_cyIconMargin - plv->ptOrigin.y;
    prcIcon->bottom = prcIcon->top + plv->cyIcon + 2 * g_cyIconMargin;

    prcLabel->left   = pitem->pt.x  + (plv->cxIcon / 2) - (ICONCXLABEL(plv, pitem) / 2) - plv->ptOrigin.x;
    prcLabel->right  = prcLabel->left + ICONCXLABEL(plv, pitem);
    prcLabel->top    = pitem->pt.y  + plv->cyIcon + g_cyLabelSpace - plv->ptOrigin.y;
    prcLabel->bottom = prcLabel->top  + pitem->cyUnfoldedLabel;

    if ( !ListView_IsItemUnfoldedPtr(plv, pitem) )
        ListView_RefoldLabelRect(plv, prcLabel, pitem);

}

int NEAR ListView_GetSlotCountEx(LV* plv, BOOL fWithoutScrollbars, int iWorkArea)
{
    int cxScreen;
    int cyScreen;
    int dxItem;
    int dyItem;
    int iSlots = 1;
    BOOL fCheckWithScroll = FALSE;
    DWORD style = 0;

    // Always use the current client window size to determine
    //
    // REVIEW: Should we exclude any vertical scroll bar that may
    // exist when computing this?  progman.exe does not.
    //
    if ((iWorkArea >= 0 ) && (plv->nWorkAreas > 0))
    {
        ASSERT(iWorkArea < plv->nWorkAreas);
        cxScreen = RECTWIDTH(plv->prcWorkAreas[iWorkArea]);
        cyScreen = RECTHEIGHT(plv->prcWorkAreas[iWorkArea]);
    }
    else
    {
        cxScreen = plv->sizeClient.cx;
        cyScreen = plv->sizeClient.cy;
    }

    if (fWithoutScrollbars)
    {
        style = ListView_GetWindowStyle(plv);

        if (style & WS_VSCROLL)
        {
            cxScreen += ListView_GetCxScrollbar(plv);
        }
        if (style & WS_HSCROLL)
        {
            cyScreen += ListView_GetCyScrollbar(plv);
        }
    }

    if (ListView_IsSmallView(plv))
        dxItem = plv->cxItem;
    else
        dxItem = lv_cxIconSpacing;

    if (ListView_IsSmallView(plv))
        dyItem = plv->cyItem;
    else
        dyItem = lv_cyIconSpacing;

    if (!dxItem)
        dxItem = 1;
    if (!dyItem)
        dyItem = 1;

    // Lets see which direction the view states
    switch (plv->ci.style & LVS_ALIGNMASK)
    {
    case LVS_ALIGNBOTTOM:
    case LVS_ALIGNTOP:
#ifndef UNIX
        iSlots = max(1, (cxScreen) / dxItem);
#else
        iSlots = max(1, (cxScreen) /  max(1,dxItem));
#endif
        fCheckWithScroll = (BOOL)(style & WS_VSCROLL);
        break;

    case LVS_ALIGNRIGHT:
    case LVS_ALIGNLEFT:
#ifndef UNIX
        iSlots = max(1, (cyScreen) / dyItem);
#else
        iSlots = max(1, (cyScreen) / max(1,dyItem));
#endif
        fCheckWithScroll = (BOOL)(style & WS_HSCROLL);
        break;

    default:
        ASSERT(0);
        return 1;
    }

    // if we don't have enough slots total on the screen, we're going to have
    // a scrollbar, so recompute with the scrollbars on
    if (fWithoutScrollbars && fCheckWithScroll) {
        int iTotalSlots = (dxItem * dyItem);
        if (iTotalSlots < ListView_Count(plv)) {
            iSlots = ListView_GetSlotCountEx(plv, FALSE, iWorkArea);
        }

    }

    return iSlots;
}


int NEAR ListView_GetSlotCount(LV* plv, BOOL fWithoutScrollbars)
{
    // Make sure this function does exactly the same thing as when
    // we had no workareas
    return ListView_GetSlotCountEx(plv, fWithoutScrollbars, -1);
}

// get the pixel row (or col in left align) of pitem
int LV_GetItemPixelRow(LV* plv, LISTITEM* pitem)
{
    if ((plv->ci.style & LVS_ALIGNMASK) == LVS_ALIGNLEFT) {
        return pitem->pt.x;
    } else {
        return pitem->pt.y;
    }
}

// get the pixel row (or col in left align) of the lowest item
int LV_GetMaxPlacedItem(LV* plv)
{
    int i;
    int iMaxPlacedItem = 0;
    
    for (i = 0; i < ListView_Count(plv); i++) {
        LISTITEM FAR* pitem = ListView_FastGetItemPtr(plv, i);
        if (pitem->pt.y != RECOMPUTE) {
            int iRow = LV_GetItemPixelRow(plv, pitem);
            // if the current item is "below" (on right if it's left aligned)
            // the lowest placed item, we can start appending
            if (!i || iRow > iMaxPlacedItem)
                iMaxPlacedItem = iRow;
        }
    }
    
    return iMaxPlacedItem;;
}

// Go through and recompute any icon positions and optionally
// icon label dimensions.
//
// This function also recomputes the view bounds rectangle.
//
// The algorithm is to simply search the list for any items needing
// recomputation.  For icon positions, we scan possible icon slots
// and check to see if any already-positioned icon intersects the slot.
// If not, the slot is free.  As an optimization, we start scanning
// icon slots from the previous slot we found.
//
void NEAR ListView_Recompute(LV* plv)
{
    int i;
    int cSlots;
    int cWorkAreaSlots[LV_MAX_WORKAREAS];
    BOOL fUpdateSB;
    // if all the items are unplaced, we can just keep appending
    BOOL fAppendAtEnd = (((UINT)ListView_Count(plv)) == plv->uUnplaced);
    int iFree;

    plv->uUnplaced = 0;

    if (!(ListView_IsIconView(plv) || ListView_IsSmallView(plv)))
        return;

    if (plv->flags & LVF_INRECOMPUTE)
    {
        return;
    }
    plv->flags |= LVF_INRECOMPUTE;

    cSlots = ListView_GetSlotCount(plv, FALSE);

    if (plv->nWorkAreas > 0)
        for (i = 0; i < plv->nWorkAreas; i++)
            cWorkAreaSlots[i] = ListView_GetSlotCountEx(plv, FALSE, i);

    // Scan all items for RECOMPUTE, and recompute slot if needed.
    //
    fUpdateSB = (plv->rcView.left == RECOMPUTE);

    if (!ListView_IsOwnerData( plv ))
    {
        LVFAKEDRAW lvfd;                    // in case client uses customdraw
        LV_ITEM item;                       // in case client uses customdraw
        int iMaxPlacedItem = RECOMPUTE;

        item.mask = LVIF_PARAM;
        item.iSubItem = 0;

        ListView_BeginFakeCustomDraw(plv, &lvfd, &item);

        if (!fAppendAtEnd)
            iMaxPlacedItem = LV_GetMaxPlacedItem(plv);

        // Must keep in local variable because ListView_SetIconPos will keep
        // invalidating the iFreeSlot cache while we're looping
        iFree = plv->iFreeSlot;
        for (i = 0; i < ListView_Count(plv); i++)
        {
            int cRealSlots;
            LISTITEM FAR* pitem = ListView_FastGetItemPtr(plv, i);
            BOOL fRedraw = FALSE;
            cRealSlots = (plv->nWorkAreas > 0) ? cWorkAreaSlots[pitem->iWorkArea] : cSlots;
            if (pitem->pt.y == RECOMPUTE)
            {
                if (pitem->cyFoldedLabel == SRECOMPUTE)
                {
                    // Get the item lParam only if we need it for customdraw
                    item.iItem = i;
                    item.lParam = pitem->lParam;

                    ListView_BeginFakeItemDraw(&lvfd);
                    ListView_RecomputeLabelSize(plv, pitem, i, lvfd.nmcd.nmcd.hdc, FALSE);
                    ListView_EndFakeItemDraw(&lvfd);
                }
                // BUGBUG: (dli) This function gets a new icon postion and then goes 
                // through the whole set of items to see if that position is occupied
                // should let it know in the multi-workarea case, it only needs to go
                // through those who are in the same workarea.
                // This is okay for now because we cannot have too many items on the
                // desktop. 
                iFree = ListView_FindFreeSlot(plv, i, iFree + 1, cRealSlots, &fUpdateSB, &fAppendAtEnd, lvfd.nmcd.nmcd.hdc);
                ASSERT(iFree != -1);

                ListView_SetIconPos(plv, pitem, iFree, cRealSlots);

                if (!fAppendAtEnd) {
                    //// optimization.  each time we calc a new free slot, we iterate through all the items to see
                    // if any of the freely placed items collide with this.
                    // fAppendAtEnd indicates that iFree is beyond any freely placed item
                    // 
                    // if the current item is "below" (on right if it's left aligned)
                    // the lowest placed item, we can start appending
                    if (LV_GetItemPixelRow(plv, pitem) > iMaxPlacedItem)
                        fAppendAtEnd = TRUE;
                }
                
                if (!fUpdateSB && LV_IsItemOnViewEdge(plv, pitem))
                    fUpdateSB = TRUE;

                fRedraw = TRUE;
            }

            if (fRedraw)
            {
                ListView_InvalidateItem(plv, i, FALSE, RDW_INVALIDATE | RDW_ERASE);
            }
        }
        plv->iFreeSlot = iFree;
        ListView_EndFakeCustomDraw(&lvfd);

    }
    // If we changed something, recompute the view rectangle
    // and then update the scroll bars.
    //
    if (fUpdateSB || plv->rcView.left == RECOMPUTE )
    {

        TraceMsg(TF_GENERAL, "************ LV: Expensive update! ******* ");

        // NOTE: No infinite recursion results because we're setting
        // plv->rcView.left != RECOMPUTE
        //
        SetRectEmpty(&plv->rcView);

        if (ListView_IsOwnerData( plv ))
        {
           if (ListView_Count( plv ) > 0)
           {
              RECT  rcLast;
              RECT  rcItem;
              int iSlots;
              int   iItem = ListView_Count( plv ) - 1;

              ListView_GetRects( plv, 0, NULL, NULL, &plv->rcView, NULL );
              ListView_GetRects( plv, iItem, NULL, NULL, &rcLast, NULL );
              plv->rcView.right = rcLast.right;
              plv->rcView.bottom = rcLast.bottom;

              //
              // calc how far back in the list to check
              //
              iSlots = cSlots + 2;
               
              // REVIEW:  This cache hint notification causes a spurious
              //  hint, since this happens often but is always the last items
              //  available.  Should this hint be done at all and this information
              //  be cached local to the control?
              ListView_NotifyCacheHint( plv, max( 0, iItem - iSlots), iItem );
               
              // move backwards from last item until either rc.right or
              // rc.left is greater than the last, then use that value.
              // Note: This code makes very little assumptions about the ordering
              // done.  We should be careful as multiple line text fields could
              // mess us up.
              for( iItem--;
                  (iSlots > 0) && (iItem >= 0);
                  iSlots--, iItem--)
              {
                  RECT rcIcon;
                  RECT rcLabel;
                  
                  ListView_GetRects( plv, iItem, &rcIcon, &rcLabel, &rcItem, NULL );
                  ListView_UnfoldRects( plv, iItem, &rcIcon, &rcLabel, &rcItem, NULL );
                  if (rcItem.right > rcLast.right)
                  {
                      plv->rcView.right =  rcItem.right;
                  }
                  if (rcItem.bottom > rcLast.bottom)
                  {
                      plv->rcView.bottom = rcItem.bottom;
                  }
              }
           }
        }
        else
        {
            for (i = 0; i < ListView_Count(plv); i++)
            {
                RECT rcIcon;
                RECT rcLabel;
                RECT rcItem;

                ListView_GetRects(plv, i, &rcIcon, &rcLabel, &rcItem, NULL);
                ListView_UnfoldRects(plv, i, &rcIcon, &rcLabel, &rcItem, NULL);
                UnionRect(&plv->rcView, &plv->rcView, &rcItem);
            }
        }
        // add a little space at the edges so that we don't bump text
        // completely to the end of the window
        plv->rcView.bottom += g_cyEdge;
        plv->rcView.right += g_cxEdge;

        OffsetRect(&plv->rcView, plv->ptOrigin.x, plv->ptOrigin.y);
        //TraceMsg(DM_TRACE, "RECOMPUTE: rcView %x %x %x %x", plv->rcView.left, plv->rcView.top, plv->rcView.right, plv->rcView.bottom);
        //TraceMsg(DM_TRACE, "Origin %x %x", plv->ptOrigin.x, plv->ptOrigin.y);

        ListView_UpdateScrollBars(plv);
    }
    ListView_RecalcRegion(plv, FALSE, TRUE);
    // Now state we are out of the recompute...
    plv->flags &= ~LVF_INRECOMPUTE;
}

void NEAR PASCAL NearestSlot(int FAR *x, int FAR *y, int cxItem, int cyItem, LPRECT prcWork)
{
    if (prcWork != NULL)
    {
        *x = *x - prcWork->left;
        *y = *y - prcWork->top;
    }
    
    if (*x < 0)
        *x -= cxItem/2;
    else
        *x += cxItem/2;

    if (*y < 0)
        *y -= cyItem/2;
    else
        *y += cyItem/2;

    *x = *x - (*x % cxItem);
    *y = *y - (*y % cyItem);

    if (prcWork != NULL)
    {
        *x = *x + prcWork->left;
        *y = *y + prcWork->top;
    }
}


void NEAR PASCAL NextSlot(LV* plv, LPRECT lprc)
{
    int cxItem;

    if (ListView_IsSmallView(plv))
    {
        cxItem = plv->cxItem;
    }
    else
    {
        cxItem = lv_cxIconSpacing;
    }
    lprc->left += cxItem;
    lprc->right += cxItem;
}


//-------------------------------------------------------------------
//
//-------------------------------------------------------------------

void ListView_CalcMinMaxIndex( LV* plv, PRECT prcBounding, int* iMin, int* iMax )
{
   POINT pt;
   int cSlots;

   cSlots = ListView_GetSlotCount( plv, TRUE );

   pt.x = prcBounding->left + plv->ptOrigin.x;
   pt.y = prcBounding->top + plv->ptOrigin.y;
   *iMin = ListView_CalcHitSlot( plv, pt, cSlots );

   pt.x = prcBounding->right + plv->ptOrigin.x;
   pt.y = prcBounding->bottom + plv->ptOrigin.y;
   *iMax = ListView_CalcHitSlot( plv, pt, cSlots ) + 1;
}
//-------------------------------------------------------------------
//
// Function: ListView_CalcHitSlot
//
// Summary: Given a point (relative to complete icon view), calculate
//    which slot that point is closest to.
//
// Arguments:
//    plv [in] - List view to work with
//    pt [in]  - location to check with
//    cslot [in]  - number of slots wide the current view is
//
// Notes: This does not guarentee that the point is hitting the item
//    located at that slot.  That should be checked by comparing rects.
//
// History:
//    Nov-1-1994  MikeMi   Added to improve Ownerdata hit testing
//
//-------------------------------------------------------------------

int ListView_CalcHitSlot( LV* plv, POINT pt, int cSlot )
{
    int cxItem;
    int cyItem;
   int iSlot = 0;

    ASSERT(plv);

    if (cSlot < 1)
        cSlot = 1;

    if (ListView_IsSmallView(plv))
    {
        cxItem = plv->cxItem;
        cyItem = plv->cyItem;
    }
    else
    {
        cxItem = lv_cxIconSpacing;
        cyItem = lv_cyIconSpacing;
    }

    // Lets see which direction the view states
    switch (plv->ci.style & LVS_ALIGNMASK)
    {
    case LVS_ALIGNBOTTOM:
        // Assert False (Change default in shell2d.. to ALIGN_TOP)

    case LVS_ALIGNTOP:
      iSlot = (pt.x / cxItem) + (pt.y / cyItem) * cSlot;
      break;

    case LVS_ALIGNLEFT:
      iSlot = (pt.x / cxItem) * cSlot + (pt.y / cyItem);
      break;

    case LVS_ALIGNRIGHT:
        ASSERT(FALSE);      // Not implemented yet...
        break;
    }

    return( iSlot );
}

void _GetCurrentItemSize(LV* plv, int * pcx, int *pcy)
{
    if (ListView_IsSmallView(plv))
    {
        *pcx = plv->cxItem;
        *pcy = plv->cyItem;
    }
    else
    {
        *pcx = lv_cxIconSpacing;
        *pcy = lv_cyIconSpacing;
    }
}

DWORD ListView_IApproximateViewRect(LV* plv, int iCount, int iWidth, int iHeight)
{
    int cxSave = plv->sizeClient.cx;
    int cySave = plv->sizeClient.cy;
    int cxItem;
    int cyItem;
    int cCols;
    int cRows;

    plv->sizeClient.cx = iWidth;
    plv->sizeClient.cy = iHeight;
    cCols = ListView_GetSlotCount(plv, TRUE);

    plv->sizeClient.cx = cxSave;
    plv->sizeClient.cy = cySave;

    cCols = min(cCols, iCount);
    if (cCols == 0)
        cCols = 1;
    cRows = (iCount + cCols - 1) / cCols;

    if (plv->ci.style & (LVS_ALIGNLEFT | LVS_ALIGNRIGHT)) {
        int c;

        c = cCols;
        cCols = cRows;
        cRows = c;
    }

    _GetCurrentItemSize(plv, &cxItem, &cyItem);

    iWidth = cCols * cxItem;
    iHeight = cRows * cyItem;

    return MAKELONG(iWidth + g_cxEdge, iHeight + g_cyEdge);
}


void NEAR _CalcSlotRect(LV* plv, LISTITEM *pItem, int iSlot, int cSlot, BOOL fBias, LPRECT lprc)
{
    int cxItem, cyItem;

    ASSERT(plv);

    if (cSlot < 1)
        cSlot = 1;

    _GetCurrentItemSize(plv, &cxItem, &cyItem);

    // Lets see which direction the view states
    switch (plv->ci.style & LVS_ALIGNMASK)
    {
    case LVS_ALIGNBOTTOM:
        // Assert False (Change default in shell2d.. to ALIGN_TOP)

    case LVS_ALIGNTOP:
        lprc->left = (iSlot % cSlot) * cxItem;
        lprc->top = (iSlot / cSlot) * cyItem;
        break;

    case LVS_ALIGNRIGHT:
        RIPMSG(0, "LVM_ARRANGE: Invalid listview icon arrangement style");
        // ASSERT(FALSE);    // Not implemented yet...
        // fall through, use LVS_ALIGNLEFT instead

    case LVS_ALIGNLEFT:
        lprc->top = (iSlot % cSlot) * cyItem;
        lprc->left = (iSlot / cSlot) * cxItem;
        break;

    }

    if (fBias)
    {
        lprc->left -= plv->ptOrigin.x;
        lprc->top -= plv->ptOrigin.y;
    }
    lprc->bottom = lprc->top + cyItem;
    lprc->right = lprc->left + cxItem;
    
    // Multi-Workarea case offset from the workarea coordinate to the whole
    // listview coordinate. 
    if (plv->nWorkAreas > 0)
    {
        ASSERT(pItem);
        ASSERT(pItem->iWorkArea < plv->nWorkAreas);
        OffsetRect(lprc, plv->prcWorkAreas[pItem->iWorkArea].left, plv->prcWorkAreas[pItem->iWorkArea].top);
    }
}

// Intersect this rectangle with all items in this listview except myself,
// this will determine if this rectangle overlays any icons. 
BOOL NEAR ListView_IsCleanRect(LV * plv, RECT * prc, int iExcept, BOOL * pfUpdate, HDC hdc)
{
    int j;
    RECT rc;
    int cItems = ListView_Count(plv);
    for (j = cItems; j-- > 0; )
    {
        if (j == iExcept)
            continue;
        else
        {
            LISTITEM FAR* pitem = ListView_FastGetItemPtr(plv, j);
            if (pitem->pt.y != RECOMPUTE)
            {
                // If the dimensions aren't computed, then do it now.
                //
                if (pitem->cyFoldedLabel == SRECOMPUTE)
                {
                    ListView_RecomputeLabelSize(plv, pitem, j, hdc, FALSE);
                    
                    // Ensure that the item gets redrawn...
                    //
                    ListView_InvalidateItem(plv, j, FALSE, RDW_INVALIDATE | RDW_ERASE);
                    
                    // Set flag indicating that scroll bars need to be
                    // adjusted.
                    //
                    if (LV_IsItemOnViewEdge(plv, pitem))
                        *pfUpdate = TRUE;
                }
                
                
                ListView_GetRects(plv, j, NULL, NULL, &rc, NULL);
                
                if (IntersectRect(&rc, &rc, prc))
                    return FALSE;
            }
        }
    }
    
    return TRUE;
}       

// Find an icon slot that doesn't intersect an icon.
// Start search for free slot from slot i.
//
int NEAR ListView_FindFreeSlot(LV* plv, int iItem, int i, int cSlot, BOOL FAR* pfUpdate,
        BOOL FAR *pfAppend, HDC hdc)
{
    RECT rcSlot;
    RECT rcItem;
    RECT rc;
    LISTITEM FAR * pItemLooking = ListView_FastGetItemPtr(plv, iItem);

    ASSERT(!ListView_IsOwnerData( plv ));

    // Horrible N-squared algorithm:
    // enumerate each slot and see if any items intersect it.
    //
    // REVIEW: This is really slow with long lists (e.g., 1000)
    //

    //
    // If the Append at end is set, we should be able to simply get the
    // rectangle of the i-1 element and check against it instead of
    // looking at every other item...
    //
    if (*pfAppend)
    {
        int iPrev = iItem - 1;
        // Be carefull about going of the end of the list. (i is a slot
        // number not an item index).
        
        if (plv->nWorkAreas > 0)
        {
            while (iPrev >= 0)
            {
                LISTITEM FAR * pPrev = ListView_FastGetItemPtr(plv, iPrev);
                if (pPrev->iWorkArea == pItemLooking->iWorkArea)
                    break;	
                iPrev--;
            }
        }
        
        if (iPrev >= 0)
            ListView_GetRects(plv, iPrev, NULL, NULL, &rcItem, NULL);
        else
            SetRect(&rcItem, 0, 0, 0, 0);
    }

    for ( ; ; i++)
    {
        // Compute view-relative slot rectangle...
        //
        _CalcSlotRect(plv, pItemLooking, i, cSlot, TRUE, &rcSlot);

        if (*pfAppend)
        {
            if (!IntersectRect(&rc, &rcItem, &rcSlot)) {
                return i;       // Found a free slot...
            }
        }
        
        if (ListView_IsCleanRect(plv, &rcSlot, iItem, pfUpdate, hdc))
            break;
    }

    return i;
}

// Recompute an item's label size (cxLabel/cyLabel).  For speed, this function
// is passed a DC to use for text measurement.
//
// If hdc is NULL, then this function will create and initialize a temporary
// DC, then destroy it.  If hdc is non-NULL, then it is assumed to have
// the correct font already selected into it.
//
// fUsepitem means not to use the text of the item.  Instead, use the text
// pointed to by the pitem structure.  This is used in two cases.
//
//  -   Ownerdata, because we don't have a real pitem.
//  -   Regulardata, where we already found the pitem text (as an optimizatin)
//
void NEAR ListView_RecomputeLabelSize(LV* plv, LISTITEM FAR* pitem, int i, HDC hdc, BOOL fUsepitem)
{
    TCHAR szLabel[CCHLABELMAX + 4];
    TCHAR szLabelFolded[ARRAYSIZE(szLabel) + CCHELLIPSES + CCHELLIPSES];
    int cchLabel;
    RECT rcSingle, rcFolded, rcUnfolded;
    LVFAKEDRAW lvfd;
    LV_ITEM item;

    ASSERT(plv);

    // the following will use the passed in pitem text instead of calling
    // GetItem.  This would be two consecutive calls otherwise, in some cases.
    //
    if (fUsepitem && (pitem->pszText != LPSTR_TEXTCALLBACK))
    {
        Str_GetPtr0(pitem->pszText, szLabel, ARRAYSIZE(szLabel));
        item.lParam = pitem->lParam;
    }
    else
    {
        item.mask = LVIF_TEXT | LVIF_PARAM;
        item.iItem = i;
        item.iSubItem = 0;
        item.pszText = szLabel;
        item.cchTextMax = ARRAYSIZE(szLabel);
        item.stateMask = 0;
        szLabel[0] = TEXT('\0');    // In case the OnGetItem fails
        ListView_OnGetItem(plv, &item);

        if (!item.pszText)
        {
            SetRectEmpty(&rcSingle);
            rcFolded = rcSingle;
            rcUnfolded = rcSingle;
            goto Exit;
        }

        if (item.pszText != szLabel)
            lstrcpyn(szLabel, item.pszText, ARRAYSIZE(szLabel));
    }

    cchLabel = lstrlen(szLabel);

    rcUnfolded.left = rcUnfolded.top = rcUnfolded.bottom = 0;
    rcUnfolded.right = lv_cxIconSpacing - g_cxLabelMargin * 2;
    rcSingle = rcUnfolded;
    rcFolded = rcUnfolded;

    if (cchLabel > 0)
    {
        UINT flags;

        if (!hdc) {                             // Set up fake customdraw
            ListView_BeginFakeCustomDraw(plv, &lvfd, &item);
            ListView_BeginFakeItemDraw(&lvfd);
        } else
            lvfd.nmcd.nmcd.hdc = hdc;           // Use the one the app gave us

#if 0   // Don't do this - Stripping trailing spaces results in unwanted ellipses
        // Strip off spaces so they're not included in format
        // REVIEW: Is this is a DrawText bug?
        //
        while (cchLabel > 1 && szLabel[cchLabel - 1] == TEXT(' '))
            szLabel[--cchLabel] = 0;
#endif

        DrawText(lvfd.nmcd.nmcd.hdc, szLabel, cchLabel, &rcSingle, (DT_LV | DT_CALCRECT));

        if (plv->ci.style & LVS_NOLABELWRAP) {
            flags = DT_LV | DT_CALCRECT;
        } else {
            flags = DT_LVWRAP | DT_CALCRECT;
            // We only use DT_NOFULLWIDTHCHARBREAK on Korean(949) Memphis and NT5
            if (949 == g_uiACP && (g_bRunOnNT5 || g_bRunOnMemphis))
                flags |= DT_NOFULLWIDTHCHARBREAK;
        }

        DrawText(lvfd.nmcd.nmcd.hdc, szLabel, cchLabel, &rcUnfolded, flags);

        //
        //  DrawText with DT_MODIFYSTRING is quirky when you enable
        //  word ellipses.  Once it finds anything that requires ellipses,
        //  it stops and doesn't return anything else (even if those other
        //  things got displayed).
        //
        lstrcpy(szLabelFolded, szLabel);
        DrawText(lvfd.nmcd.nmcd.hdc, szLabelFolded, cchLabel, &rcFolded, flags | DT_WORD_ELLIPSIS | DT_MODIFYSTRING);

        //  If we had to ellipsify, but you can't tell from looking at the
        //  rcFolded.bottom and rcUnfolded.bottom, then tweak rcFolded.bottom
        //  so the unfoldifier knows that unfolding is worthwhile.
        if (rcFolded.bottom == rcUnfolded.bottom &&
            lstrcmp(szLabel, szLabelFolded))
        {
            // The actual value isn't important, as long as it's greater
            // than rcUnfolded.bottom and CLIP_HEIGHT.  We take advantage
            // of the fact that CLIP_HEIGHT is only two lines, so the only
            // problem case is where you have a two-line item and only the
            // first line is ellipsified.
            rcFolded.bottom++;
        }

        if (!hdc) {                             // Clean up fake customdraw
            ListView_EndFakeItemDraw(&lvfd);
            ListView_EndFakeCustomDraw(&lvfd);
        }

    }
    else
    {
        rcFolded.bottom = rcUnfolded.bottom = rcUnfolded.top + plv->cyLabelChar;
    }

Exit:

    if (pitem) {
        int cyEdge;
        pitem->cxSingleLabel = (short)((rcSingle.right - rcSingle.left) + 2 * g_cxLabelMargin);
        pitem->cxMultiLabel = (short)((rcUnfolded.right - rcUnfolded.left) + 2 * g_cxLabelMargin);

        cyEdge = (plv->ci.style & LVS_NOLABELWRAP) ? 0 : g_cyEdge;

        pitem->cyFoldedLabel = (short)((rcFolded.bottom - rcFolded.top) + cyEdge);
        pitem->cyUnfoldedLabel = (short)((rcUnfolded.bottom - rcUnfolded.top) + cyEdge);
    }

}

// Set up an icon slot position.  Returns FALSE if position didn't change.
//
BOOL NEAR ListView_SetIconPos(LV* plv, LISTITEM FAR* pitem, int iSlot, int cSlot)
{
    RECT rc;

    ASSERT(plv);

    //
    // Sort of a hack, this internal function return TRUE if small icon.

    _CalcSlotRect(plv, pitem, iSlot, cSlot, FALSE, &rc);

    if (ListView_IsIconView(plv))
    {
        rc.left += ((lv_cxIconSpacing - plv->cxIcon) / 2);
        rc.top += g_cyIconOffset;
    }
    
    if (rc.left != pitem->pt.x || rc.top != pitem->pt.y)
    {
        LV_AdjustViewRectOnMove(plv, pitem, rc.left, rc.top);

        return TRUE;
    }
    return FALSE;
}

void NEAR ListView_GetViewRect2(LV* plv, RECT FAR* prcView, int cx, int cy)
{

    if (plv->rcView.left == RECOMPUTE)
        ListView_Recompute(plv);

    *prcView = plv->rcView;

    //
    // Offsets for scrolling.
    //
    OffsetRect(prcView, -plv->ptOrigin.x, -plv->ptOrigin.y);

    if (ListView_IsIconView(plv) || ListView_IsSmallView(plv))
    {
        //  don't do that funky half-re-origining thing.

        RECT rc;

        rc.left = 0;
        rc.top = 0;
        rc.right = cx;
        rc.bottom = cy;
        UnionRect(prcView, prcView, &rc);

#if 0
        // if we're scrolled way in the positive area (plv->ptOrigin > 0), make sure we
        // include our true origin
        if ((prcView->left > -plv->ptOrigin.x))
            prcView->left = -plv->ptOrigin.x;
        if ((prcView->top > -plv->ptOrigin.y))
            prcView->top = -plv->ptOrigin.y;

        // if we're scrolled way in the positive area (plv->ptOrigin > 0),
        // make sure our scrollbars include our current position
        if ((prcView->right < (plv->sizeClient.cx)))
            prcView->right = plv->sizeClient.cx;
        if ((prcView->bottom < (plv->sizeClient.cy)))
            prcView->bottom = plv->sizeClient.cy;
#endif
    }
}

// prcViewRect used only if fSubScroll is TRUE
DWORD NEAR ListView_GetClientRect(LV* plv, RECT FAR* prcClient, BOOL fSubScroll, RECT FAR *prcViewRect)
{
    RECT rcClient;
    RECT rcView;
    DWORD style;

#if 1
    // do this instead of the #else below because
    // in new versus old apps, you may need to add in g_c?Border because of
    // the one pixel overlap...
    GetWindowRect(plv->ci.hwnd, &rcClient);
    if (GetWindowLong(plv->ci.hwnd, GWL_EXSTYLE) & (WS_EX_CLIENTEDGE | WS_EX_STATICEDGE | WS_EX_WINDOWEDGE)) {
        rcClient.right -= 2 * g_cxEdge;
        rcClient.bottom -= 2 * g_cyEdge;
    }
    rcClient.right -= rcClient.left;
    rcClient.bottom -= rcClient.top;
    if (rcClient.right < 0)
        rcClient.right = 0;
    if (rcClient.bottom < 0)
        rcClient.bottom = 0;
    rcClient.top = rcClient.left = 0;
#else
    style = ListView_GetWindowStyle(plv);
    GetClientRect(plv->ci.hwnd, &rcClient);
    if (style & WS_VSCROLL)
        rcClient.right += ListView_GetCxScrollbar(plv);
    if (style & WS_HSCROLL)
        rcClient.bottom += ListView_GetCyScrollbar(plv);
#endif

    style = 0L;
    if (fSubScroll)
    {
        ListView_GetViewRect2(plv, &rcView, 0, 0);
        if ((rcClient.left < rcClient.right) && (rcClient.top < rcClient.bottom))
        {
            do
            {
                if (!(style & WS_HSCROLL) &&
                    (rcView.left < rcClient.left || rcView.right > rcClient.right))
                {
                    style |= WS_HSCROLL;
                    rcClient.bottom -= ListView_GetCyScrollbar(plv); // BUGBUG what if not SB yet?
                }
                if (!(style & WS_VSCROLL) &&
                    (rcView.top < rcClient.top || rcView.bottom > rcClient.bottom))
                {
                    style |= WS_VSCROLL;
                    rcClient.right -= ListView_GetCxScrollbar(plv);
                }
            }
            while (!(style & WS_HSCROLL) && rcView.right > rcClient.right);
        }
        if (prcViewRect)
            *prcViewRect = rcView;
    }
    *prcClient = rcClient;
    return style;
}

int CALLBACK ArrangeIconCompare(LISTITEM FAR* pitem1, LISTITEM FAR* pitem2, LPARAM lParam)
{
    int v1, v2;

    // REVIEW: lParam can be 0 and we fault ... bug in caller, but we might want to be robust here.

    if (HIWORD(lParam))
    {
        // Vertical arrange
        v1 = pitem1->pt.x / GET_X_LPARAM(lParam);
        v2 = pitem2->pt.x / GET_X_LPARAM(lParam);

        if (v1 > v2)
            return 1;
        else if (v1 < v2)
            return -1;
        else
        {
            int y1 = pitem1->pt.y;
            int y2 = pitem2->pt.y;

            if (y1 > y2)
                return 1;
            else if (y1 < y2)
                return -1;
        }

    }
    else
    {
        v1 = pitem1->pt.y / (int)lParam;
        v2 = pitem2->pt.y / (int)lParam;

        if (v1 > v2)
            return 1;
        else if (v1 < v2)
            return -1;
        else
        {
            int x1 = pitem1->pt.x;
            int x2 = pitem2->pt.x;

            if (x1 > x2)
                return 1;
            else if (x1 < x2)
                return -1;
        }
    }
    return 0;
}

void NEAR PASCAL _ListView_GetRectsFromItem(LV* plv, BOOL bSmallIconView,
                                            LISTITEM FAR *pitem,
                                            LPRECT prcIcon, LPRECT prcLabel, LPRECT prcBounds, LPRECT prcSelectBounds)
{
    RECT rcIcon;
    RECT rcLabel;

    if (!prcIcon)
        prcIcon = &rcIcon;
    if (!prcLabel)
        prcLabel = &rcLabel;

    // Test for NULL item passed in
    if (pitem)
    {
        // This routine is called during ListView_Recompute(), while
        // plv->rcView.left may still be == RECOMPUTE.  So, we can't
        // test that to see if recomputation is needed.
        //
        if (pitem->pt.y == RECOMPUTE || pitem->cyFoldedLabel == SRECOMPUTE)
            ListView_Recompute(plv);

        if (bSmallIconView)
            ListView_SGetRects(plv, pitem, prcIcon, prcLabel, prcBounds);
        else
            // ListView_IGetRects already refolds as necessary
            ListView_IGetRects(plv, pitem, prcIcon, prcLabel, prcBounds);

        if (prcBounds)
        {
            UnionRect(prcBounds, prcIcon, prcLabel);
            if (plv->himlState && (LV_StateImageValue(pitem)))
            {
                prcBounds->left -= plv->cxState;
            }
        }

    } else {
        SetRectEmpty(prcIcon);
        *prcLabel = *prcIcon;
        if (prcBounds)
            *prcBounds = *prcIcon;
    }

    if (prcSelectBounds)
    {
        UnionRect(prcSelectBounds, prcIcon, prcLabel);
    }
}

void NEAR _ListView_InvalidateItemPtr(LV* plv, BOOL bSmallIcon, LISTITEM FAR *pitem, UINT fRedraw)
{
    RECT rcBounds;

    ASSERT( !ListView_IsOwnerData( plv ));

    _ListView_GetRectsFromItem(plv, bSmallIcon, pitem, NULL, NULL, &rcBounds, NULL);
    RedrawWindow(plv->ci.hwnd, &rcBounds, NULL, fRedraw);
}

// return TRUE if things still overlap
// this only happens if we tried to unstack things, and there was NOSCROLL set and
// items tried to go off the deep end
BOOL NEAR PASCAL ListView_IUnstackOverlaps(LV* plv, HDPA hdpaSort, int iDirection)
{
    BOOL fRet = FALSE;
    int i;
    int iCount;
    BOOL bSmallIconView;
    RECT rcItem, rcItem2, rcTemp;
    int cxItem, cyItem;
    LISTITEM FAR* pitem;
    LISTITEM FAR* pitem2;

    ASSERT( !ListView_IsOwnerData( plv ) );

    if (bSmallIconView = ListView_IsSmallView(plv))
    {
        cxItem = plv->cxItem;
        cyItem = plv->cyItem;
    }
    else
    {
        cxItem = lv_cxIconSpacing;
        cyItem = lv_cyIconSpacing;
    }
    iCount = ListView_Count(plv);

    // finally, unstack any overlaps
    for (i = 0 ; i < iCount ; i++) {
        int j;
        pitem = DPA_GetPtr(hdpaSort, i);

        if (bSmallIconView) {
            _ListView_GetRectsFromItem(plv, bSmallIconView, pitem, NULL, NULL, &rcItem, NULL);
        }

        // move all the items that overlap with us
        for (j = i+1 ; j < iCount; j++) {
            POINT ptOldPos;

            pitem2 = DPA_GetPtr(hdpaSort, j);
            ptOldPos = pitem2->pt;

            if (bSmallIconView) {

                // for small icons, we need to do an intersect rect
                _ListView_GetRectsFromItem(plv, bSmallIconView, pitem2, NULL, NULL, &rcItem2, NULL);

                if (IntersectRect(&rcTemp, &rcItem, &rcItem2)) {
                    // yes, it intersects.  move it out
                    _ListView_InvalidateItemPtr(plv, bSmallIconView, pitem2, RDW_INVALIDATE| RDW_ERASE);
                    do {
                        pitem2->pt.x += (cxItem * iDirection);
                    } while (PtInRect(&rcItem, pitem2->pt));
                } else {
                    // no more intersect!
                    break;
                }

            } else {
                // for large icons, just find the ones that share the x,y;
                if (pitem2->pt.x == pitem->pt.x && pitem2->pt.y == pitem->pt.y) {

                    _ListView_InvalidateItemPtr(plv, bSmallIconView, pitem2, RDW_INVALIDATE| RDW_ERASE);
                    pitem2->pt.x += (cxItem * iDirection);
                } else {
                    // no more intersect!
                    break;
                }
            }

            if (plv->ci.style & LVS_NOSCROLL) {
                if (pitem2->pt.x < 0 || pitem2->pt.y < 0 ||
                    pitem2->pt.x > (plv->sizeClient.cx - (cxItem/2))||
                    pitem2->pt.y > (plv->sizeClient.cy - (cyItem/2))) {
                    pitem2->pt = ptOldPos;
                    fRet = TRUE;
                }
            }

            // invalidate the new position as well
            _ListView_InvalidateItemPtr(plv, bSmallIconView, pitem2, RDW_INVALIDATE| RDW_ERASE);
        }
    }
    return fRet;
}


BOOL NEAR PASCAL ListView_SnapToGrid(LV* plv, HDPA hdpaSort)
{
    // this algorithm can't fit in the structure of the other
    // arrange loop without becoming n^2 or worse.
    // this algorithm is order n.

    // iterate through and snap to the nearest grid.
    // iterate through and push aside overlaps.

    int i;
    int iCount;
    LPARAM  xySpacing;
    int x,y;
    LISTITEM FAR* pitem;
    BOOL bSmallIconView;
    int cxItem, cyItem;

    ASSERT( !ListView_IsOwnerData( plv ) );

    if (bSmallIconView = ListView_IsSmallView(plv))
    {
        cxItem = plv->cxItem;
        cyItem = plv->cyItem;
    }
    else
    {
        cxItem = lv_cxIconSpacing;
        cyItem = lv_cyIconSpacing;
    }


    iCount = ListView_Count(plv);

    // first snap to nearest grid
    for (i = 0; i < iCount; i++) {
        pitem = DPA_GetPtr(hdpaSort, i);

        x = pitem->pt.x;
        y = pitem->pt.y;

        if (!bSmallIconView) {
            x -= ((lv_cxIconSpacing - plv->cxIcon) / 2);
            y -= g_cyIconOffset;
        }

        NearestSlot(&x,&y, cxItem, cyItem, (plv->nWorkAreas > 0) ? &(plv->prcWorkAreas[pitem->iWorkArea]) : NULL);
        if (!bSmallIconView) {
            x += ((lv_cxIconSpacing - plv->cxIcon) / 2);
            y += g_cyIconOffset;
        }

        if (x != pitem->pt.x || y != pitem->pt.y) {
            _ListView_InvalidateItemPtr(plv, bSmallIconView, pitem, RDW_INVALIDATE| RDW_ERASE);
            if ((plv->ci.style & LVS_NOSCROLL) && (plv->nWorkAreas == 0)) {

                // if it's marked noscroll, make sure it's still on the client region
                while (x >= (plv->sizeClient.cx - (cxItem/2)))
                    x -= cxItem;

                while (x < 0)
                    x += cxItem;

                while (y >= (plv->sizeClient.cy - (cyItem/2)))
                    y -= cyItem;

                while (y < 0)
                    y += cyItem;
            }
            pitem->pt.x = x;
            pitem->pt.y = y;
            plv->iFreeSlot = -1; // The "free slot" cache is no good once an item moves

            _ListView_InvalidateItemPtr(plv, bSmallIconView, pitem, RDW_INVALIDATE| RDW_ERASE);
        }
    }

    // now resort the dpa
    switch (plv->ci.style & LVS_ALIGNMASK)
    {
        case LVS_ALIGNLEFT:
        case LVS_ALIGNRIGHT:
            xySpacing = MAKELONG(bSmallIconView ? plv->cxItem : lv_cxIconSpacing, TRUE);
            break;
        default:
            xySpacing = MAKELONG(bSmallIconView ? plv->cyItem : lv_cyIconSpacing, FALSE);
    }

    if (!DPA_Sort(hdpaSort, ArrangeIconCompare, xySpacing))
        return FALSE;


    // go in one direction, if there are still overlaps, go in the other
    // direction as well
    if (ListView_IUnstackOverlaps(plv, hdpaSort, 1))
        ListView_IUnstackOverlaps(plv, hdpaSort, -1);
    return FALSE;
}


BOOL NEAR ListView_OnArrange(LV* plv, UINT style)
{
    BOOL bSmallIconView;
    LPARAM  xySpacing;
    HDPA hdpaSort = NULL;

    bSmallIconView = ListView_IsSmallView(plv);

    if (!bSmallIconView && !ListView_IsIconView(plv)) {
        return FALSE;
    }

    if (ListView_IsOwnerData( plv ))
    {
        if ( style & (LVA_SNAPTOGRID | LVA_SORTASCENDING | LVA_SORTDESCENDING) )
        {
            RIPMSG(0, "LVM_ARRANGE: Cannot combine LVA_SNAPTOGRID or LVA_SORTxxx with owner-data");
            return( FALSE );
        }
    }

    // Make sure our items have positions and their text rectangles
    // caluculated
    if (plv->rcView.left == RECOMPUTE)
        ListView_Recompute(plv);

    if (!ListView_IsOwnerData( plv ))
    {
        // we clone plv->hdpa so we don't blow away indices that
        // apps have saved away.
        // we sort here to make the nested for loop below more bearable.
        hdpaSort = DPA_Clone(plv->hdpa, NULL);

        if (!hdpaSort)
            return FALSE;
    }
    switch (plv->ci.style & LVS_ALIGNMASK)
    {
        case LVS_ALIGNLEFT:
        case LVS_ALIGNRIGHT:
            xySpacing = MAKELONG(bSmallIconView ? plv->cxItem : lv_cxIconSpacing, TRUE);
            break;
        default:
            xySpacing = MAKELONG(bSmallIconView ? plv->cyItem : lv_cyIconSpacing, FALSE);
    }

    if (ListView_IsOwnerData( plv ))
    {
        ListView_CommonArrange(plv, style, NULL);
    }
    else
    {
        if (!DPA_Sort(hdpaSort, ArrangeIconCompare, xySpacing))
            return FALSE;

        ListView_CommonArrange(plv, style, hdpaSort);

        DPA_Destroy(hdpaSort);
    }

    MyNotifyWinEvent(EVENT_OBJECT_REORDER, plv->ci.hwnd, OBJID_CLIENT, 0);

    return TRUE;
}

// Arrange the icons given a sorted hdpa, and arrange them in the sub workareas
BOOL NEAR ListView_CommonArrangeEx(LV* plv, UINT style, HDPA hdpaSort, int iWorkArea)
{
    int iSlot;
    int iItem;
    int cSlots;
    int cWorkAreaSlots[LV_MAX_WORKAREAS];
    BOOL fItemMoved;
    RECT rcLastItem;
    RECT rcSlot;
    RECT rcT;
    BOOL bSmallIconView;
    BOOL bIconView;
    int  xMin = 0;

    bSmallIconView = ListView_IsSmallView(plv);
    bIconView      = ListView_IsIconView(plv);

    // 
    //  when this is an autoarrange, then we dont need to worry about 
    //  scrolling the origin, because we are going to arrange everything 
    //  around the positive side of the origin
    //
    if (LVA_DEFAULT == style && (plv->ci.style & LVS_AUTOARRANGE))
    {
        if (plv->ptOrigin.x < 0)
            plv->ptOrigin.x = 0;
        if (plv->ptOrigin.y < 0)
            plv->ptOrigin.y = 0;
    }

    // REVIEW, this causes a repaint if we are scrollled
    // we can probably avoid this some how
    
    fItemMoved = (plv->ptOrigin.x != 0) || (plv->ptOrigin.y != 0);

    if (!ListView_IsOwnerData( plv ))
    {
        if (style == LVA_SNAPTOGRID) {
            // (dli) This function is fitting all the icons into just one rectangle, 
            // namely sizeClient. We need to make it multi-workarea aware if we want 
            // multi-workarea for the general case (i.e. other than just the desktop)
            // This is never called in the desktop case. 
            fItemMoved |= ListView_SnapToGrid(plv, hdpaSort);

        } else {
            if (plv->nWorkAreas > 0)
            {
                int i;
                for (i = 0; i < plv->nWorkAreas; i++)
                    cWorkAreaSlots[i] = ListView_GetSlotCountEx(plv, TRUE, i);
            }
            else
                cSlots = ListView_GetSlotCount(plv, TRUE);

            
            SetRectEmpty(&rcLastItem);

            // manipulate only the sorted version of the item list below!

            iSlot = 0;
            for (iItem = 0; iItem < ListView_Count(plv); iItem++)
            {
                int cRealSlots; 
                RECT rcIcon, rcLabel;
                LISTITEM FAR* pitem = DPA_GetPtr(hdpaSort, iItem);
                // (dli) In the multi-workarea case, if this item is not in our 
                // workarea, skip it. 
                if (pitem->iWorkArea != iWorkArea)
                    continue;

                cRealSlots = (plv->nWorkAreas > 0) ? cWorkAreaSlots[pitem->iWorkArea] : cSlots;

                if (bSmallIconView || bIconView)
                {
                    for ( ; ; )
                    {
                        _CalcSlotRect(plv, pitem, iSlot, cRealSlots, FALSE, &rcSlot);
                        if (!IntersectRect(&rcT, &rcSlot, &rcLastItem))
                            break;
                        iSlot++;
                    }
                }

                fItemMoved |= ListView_SetIconPos(plv, pitem, iSlot++, cRealSlots);

                // do this instead of ListView_GetRects() because we need
                // to use the pitem from the sorted hdpa, not the ones in *plv
                _ListView_GetRectsFromItem(plv, bSmallIconView, pitem, &rcIcon, &rcLabel, &rcLastItem, NULL);
                // f-n above will return unfolded rects if there are any, we must make sure
                // we use folded ones for slot allocations
                if (bIconView)
                {
                    if (ListView_IsItemUnfoldedPtr(plv, pitem))
                    {
                        ListView_RefoldLabelRect(plv, &rcLabel, pitem);
                        UnionRect(&rcLastItem, &rcIcon, &rcLabel);
                        if (plv->himlState && (LV_StateImageValue(pitem)))
                            rcLastItem.left -= plv->cxState;
                    }
                }
                //
                // Keep track of the minimum x as we don't want negative values
                // when we finish.
                if (rcLastItem.left < xMin)
                    xMin = rcLastItem.left;
            }

            //
            // See if we need to scroll the items over to make sure that all of the
            // no items are hanging off the left hand side.
            //
            if (xMin < 0)
            {
                for (iItem = 0; iItem < ListView_Count(plv); iItem++)
                {
                    LISTITEM FAR* pitem = ListView_FastGetItemPtr(plv, iItem);
                    pitem->pt.x -= xMin;        // scroll them over
                }
                plv->rcView.left = RECOMPUTE;   // need to recompute.
                fItemMoved = TRUE;
            }
        }
    }
    //
    // We might as well invalidate the entire window to make sure...
    if (fItemMoved) {
        if (ListView_RedrawEnabled(plv))
            RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
        else {
            ListView_DeleteHrgnInval(plv);
            plv->hrgnInval = (HRGN)ENTIRE_REGION;
            plv->flags |= LVF_ERASE;
        }

        // ensure important items are visible
        iItem = (plv->iFocus >= 0) ? plv->iFocus : ListView_OnGetNextItem(plv, -1, LVNI_SELECTED);

        if (iItem >= 0)
            ListView_OnEnsureVisible(plv, iItem, FALSE);

        if (ListView_RedrawEnabled(plv))
            ListView_UpdateScrollBars(plv);
    }
    return TRUE;
}


// this arranges the icon given a sorted hdpa.
// Arrange the workareas one by one in the multi-workarea case. 
BOOL NEAR ListView_CommonArrange(LV* plv, UINT style, HDPA hdpaSort)
{
    if (plv->nWorkAreas < 1)
    {
        if (plv->exStyle & LVS_EX_MULTIWORKAREAS)
            return TRUE;
        else
            return ListView_CommonArrangeEx(plv, style, hdpaSort, 0);
    }
    else
    {
        int i;
        for (i = 0; i < plv->nWorkAreas; i++)
            ListView_CommonArrangeEx(plv, style, hdpaSort, i);
        return TRUE;
    }
}

void NEAR ListView_IUpdateScrollBars(LV* plv)
{
    RECT rcClient;
    RECT rcView;
    DWORD style;
    DWORD styleOld;
    SCROLLINFO si;
    int ixDelta = 0, iyDelta = 0;
    int iNewPos;
    BOOL fReupdate = FALSE;

    styleOld = ListView_GetWindowStyle(plv);
    style = ListView_GetClientRect(plv, &rcClient, TRUE, &rcView);

    // Grow scrolling rect to origin if necessary.
    if (rcView.left > 0)
    {
        rcView.left = 0;
    }
    if (rcView.top > 0)
    {
        rcView.top = 0;
    }

    //TraceMsg(TF_LISTVIEW, "ListView_GetClientRect %x %x %x %x", rcClient.left, rcClient.top, rcClient.right, rcClient.bottom);
    //TraceMsg(TF_LISTVIEW, "ListView_GetViewRect2 %x %x %x %x", rcView.left, rcView.top, rcView.right, rcView.bottom);
    //TraceMsg(TF_LISTVIEW, "rcView %x %x %x %x", plv->rcView.left, plv->rcView.top, plv->rcView.right, plv->rcView.bottom);
    //TraceMsg(TF_LISTVIEW, "Origin %x %x", plv->ptOrigin.x, plv->ptOrigin.y);

    si.cbSize = sizeof(SCROLLINFO);

    if (style & WS_HSCROLL)
    {
        si.fMask = SIF_PAGE | SIF_RANGE | SIF_POS;
        si.nMin = 0;
        si.nMax = rcView.right - rcView.left - 1;
        //TraceMsg(TF_LISTVIEW, "si.nMax rcView.right - rcView.left - 1 %x", si.nMax);

        si.nPage = rcClient.right - rcClient.left;
        //TraceMsg(TF_LISTVIEW, "si.nPage %x", si.nPage);

        si.nPos = rcClient.left - rcView.left;
        if (si.nPos < 0)
        {
            // with the new rcView calculations, I don't think
            // rcView.left is ever larger than rcClient.left.  msq
            ASSERT(0);
            si.nPos = 0;
        }
        //TraceMsg(TF_LISTVIEW, "si.nPos %x", si.nPos);

        ListView_SetScrollInfo(plv, SB_HORZ, &si, TRUE);

        // make sure our position and page doesn't hang over max
        if ((si.nPos + (LONG)si.nPage - 1 > si.nMax) && si.nPos > 0) {
            iNewPos = (int)si.nMax - (int)si.nPage + 1;
            if (iNewPos < 0) iNewPos = 0;
            if (iNewPos != si.nPos) {
                ixDelta = iNewPos - (int)si.nPos;
                fReupdate = TRUE;
            }
        }
        
    }
    else if (styleOld & WS_HSCROLL)
    {
        ListView_SetScrollRange(plv, SB_HORZ, 0, 0, TRUE);
    }

    if (style & WS_VSCROLL)
    {
        si.fMask = SIF_PAGE | SIF_RANGE | SIF_POS;
        si.nMin = 0;
        si.nMax = rcView.bottom - rcView.top - 1;

        si.nPage = rcClient.bottom - rcClient.top;

        si.nPos = rcClient.top - rcView.top;
        if (si.nPos < 0)
        {
            // with the new rcView calculations, I don't think
            // rcView.top is ever larger than rcClient.top.  msq
            ASSERT(0);
            si.nPos = 0;
        }

        ListView_SetScrollInfo(plv, SB_VERT, &si, TRUE);

        // make sure our position and page doesn't hang over max
        if ((si.nPos + (LONG)si.nPage - 1 > si.nMax) && si.nPos > 0) {
            iNewPos = (int)si.nMax - (int)si.nPage + 1;
            if (iNewPos < 0) iNewPos = 0;
            if (iNewPos != si.nPos) {
                iyDelta = iNewPos - (int)si.nPos;
                fReupdate = TRUE;
            }
        }
    }
    else if (styleOld & WS_VSCROLL)
    {
        ListView_SetScrollRange(plv, SB_VERT, 0, 0, TRUE);
    }

    if (fReupdate) {
        // we shouldn't recurse because the second time through, si.nPos >0
        ListView_IScroll2(plv, ixDelta, iyDelta, 0);
        ListView_IUpdateScrollBars(plv);
        TraceMsg(TF_WARNING, "LISTVIEW: ERROR: We had to recurse!");
    }

#if 0
    if ((styleOld ^ style) & (WS_HSCROLL | WS_VSCROLL)) {
        SetWindowPos(plv->ci.hwnd, NULL, 0,0,0,0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE| SWP_FRAMECHANGED);
    }
#endif
        
}

void FAR PASCAL ListView_ComOnScroll(LV* plv, UINT code, int posNew, int sb,
                                     int cLine, int cPage)
{
    int pos;
    SCROLLINFO si;
    BOOL fVert = (sb == SB_VERT);
    UINT uSmooth = 0;

    si.cbSize = sizeof(SCROLLINFO);
    si.fMask = SIF_PAGE | SIF_RANGE | SIF_POS;

    if (!ListView_GetScrollInfo(plv, sb, &si)) {
        return;
    }

    if (cPage != -1)
        si.nPage = cPage;

    si.nMax -= (si.nPage - 1);

    if (si.nMax < si.nMin)
        si.nMax = si.nMin;

    pos = (int)si.nPos; // current position

    switch (code)
    {
    case SB_LEFT:
        si.nPos = si.nMin;
        break;
    case SB_RIGHT:
        si.nPos = si.nMax;
        break;
    case SB_PAGELEFT:
         si.nPos -= si.nPage;
        break;
    case SB_LINELEFT:
        si.nPos -= cLine;
        break;
    case SB_PAGERIGHT:
        si.nPos += si.nPage;
        break;
    case SB_LINERIGHT:
        si.nPos += cLine;
        break;

    case SB_THUMBTRACK:
        si.nPos = posNew;
        uSmooth = SSW_EX_IMMEDIATE;
        break;

    case SB_ENDSCROLL:
        // When scroll bar tracking is over, ensure scroll bars
        // are properly updated...
        //
        ListView_UpdateScrollBars(plv);
        return;

    default:
        return;
    }

    if (plv->iScrollCount >= SMOOTHSCROLLLIMIT)
        uSmooth = SSW_EX_IMMEDIATE;

    si.fMask = SIF_POS;
    si.nPos = ListView_SetScrollInfo(plv, sb, &si, TRUE);

    if (pos != si.nPos)
    {
        int delta = (int)si.nPos - pos;
        int dx = 0, dy = 0;
        if (fVert)
            dy = delta;
        else
            dx = delta;
        _ListView_Scroll2(plv, dx, dy, uSmooth);
        UpdateWindow(plv->ci.hwnd);
    }
}

//
//  We need a smoothscroll callback so our background image draws
//  at the correct origin.  If we don't have a background image,
//  then this work is superfluous but not harmful either.
//
int CALLBACK ListView_IScroll2_SmoothScroll(
    HWND hwnd,
    int dx,
    int dy,
    CONST RECT *prcScroll,
    CONST RECT *prcClip ,
    HRGN hrgnUpdate,
    LPRECT prcUpdate,
    UINT flags)
{
    LV* plv = ListView_GetPtr(hwnd);
    if (plv)
    {
        plv->ptOrigin.x -= dx;
        plv->ptOrigin.y -= dy;
    }

    // Now do what SmoothScrollWindow would've done if we weren't
    // a callback

    return ScrollWindowEx(hwnd, dx, dy, prcScroll, prcClip, hrgnUpdate, prcUpdate, flags);
}



void FAR PASCAL ListView_IScroll2(LV* plv, int dx, int dy, UINT uSmooth)
{
    if (dx | dy)
    {
        if ((plv->clrBk == CLR_NONE) && (plv->pImgCtx == NULL))
        {
            plv->ptOrigin.x += dx;
            plv->ptOrigin.y += dy;
            LVSeeThruScroll(plv, NULL);
        }
        else
        {
            SMOOTHSCROLLINFO si;
            si.cbSize =  sizeof(si);
            si.fMask = SSIF_SCROLLPROC;
            si.hwnd = plv->ci.hwnd;
            si.dx = -dx;
            si.dy = -dy;
            si.lprcSrc = NULL;
            si.lprcClip = NULL;
            si.hrgnUpdate = NULL;
            si.lprcUpdate = NULL;
            si.fuScroll = uSmooth | SW_INVALIDATE | SW_ERASE;
            si.pfnScrollProc = ListView_IScroll2_SmoothScroll;
            SmoothScrollWindow(&si);
        }
    }
}

void NEAR ListView_IOnScroll(LV* plv, UINT code, int posNew, UINT sb)
{
    int cLine;

    if (sb == SB_VERT)
    {
        cLine = lv_cyIconSpacing / 2;
    }
    else
    {
        cLine = lv_cxIconSpacing / 2;
    }

    ListView_ComOnScroll(plv, code,  posNew,  sb,
                         cLine, -1);

}

int NEAR ListView_IGetScrollUnitsPerLine(LV* plv, UINT sb)
{
    int cLine;

    if (sb == SB_VERT)
    {
        cLine = lv_cyIconSpacing / 2;
    }
    else
    {
        cLine = lv_cxIconSpacing / 2;
    }

    return cLine;
}

// NOTE: there is very similar code in the treeview
//
// Totally disgusting hack in order to catch VK_RETURN
// before edit control gets it.
//
LRESULT CALLBACK ListView_EditWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    LV* plv = ListView_GetPtr(GetParent(hwnd));
    LRESULT lret;

    ASSERT(plv);

#if defined(FE_IME) || !defined(WINNT)
    if ( (g_fDBCSInputEnabled) && LOWORD(GetKeyboardLayout(0L)) == 0x0411 )
    {
        // The following code adds IME awareness to the
        // listview's label editing. Currently just for Japanese.
        //
        DWORD dwGcs;
    
        if (msg==WM_SIZE)
        {
            // If it's given the size, tell it to an IME.

             ListView_SizeIME(hwnd);
        }
        else if (msg == EM_SETLIMITTEXT )
        {
           if (wParam < 13)
               plv->flags |= LVF_DONTDRAWCOMP;
           else
               plv->flags &= ~LVF_DONTDRAWCOMP;
        }
        // Give up to draw IME composition by ourselves in case
        // we're working on SFN. Win95d-5709
        else if (!(plv->flags & LVF_DONTDRAWCOMP ))
        {
            switch (msg)
            {

             case WM_IME_STARTCOMPOSITION:
             case WM_IME_ENDCOMPOSITION:
                 return 0L;


             case WM_IME_COMPOSITION:

             // If lParam has no data available bit, it implies
             // canceling composition.
             // ListView_InsertComposition() tries to get composition
             // string w/ GCS_COMPSTR then remove it from edit control if
             // nothing is available.
             //
                 if ( !lParam )
                     dwGcs = GCS_COMPSTR;
                 else
                     dwGcs = (DWORD) lParam;

                 ListView_InsertComposition(hwnd, wParam, dwGcs, plv);
                 return 0L;
                 
             case WM_PAINT:
                 lret=CallWindowProc(plv->pfnEditWndProc, hwnd, msg, wParam, lParam);
                 ListView_PaintComposition(hwnd,plv);
                 return lret;
                 
             case WM_IME_SETCONTEXT:

             // We draw composition string.
             //
                 lParam &= ~ISC_SHOWUICOMPOSITIONWINDOW;
                 break;

             default:
                 // the other messages should simply be processed
                 // in this subclass procedure.
                 break;
            }
        }
    }
#endif FE_IME

    switch (msg)
    {
    case WM_SETTEXT:
        SetWindowID(hwnd, 1);
        break;

    case WM_KEYDOWN:
        switch (wParam)
        {
        case VK_RETURN:
            ListView_DismissEdit(plv, FALSE);
            return 0L;

        case VK_ESCAPE:
            ListView_DismissEdit(plv, TRUE);
            return 0L;
        }
        break;

    case WM_CHAR:
        switch (wParam)
        {
        case VK_RETURN:
            // Eat the character, so edit control wont beep!
            return 0L;
        }
                break;

        case WM_GETDLGCODE:
                return DLGC_WANTALLKEYS | DLGC_HASSETSEL;        /* editing name, no dialog handling right now */
    }

    return CallWindowProc(plv->pfnEditWndProc, hwnd, msg, wParam, lParam);
}

//  Helper routine for SetEditSize
void ListView_ChangeEditRectForRegion(LV* plv, LPRECT lprc)
{
    LISTITEM FAR* pitem = ListView_GetItemPtr(plv, plv->iEdit);

    ASSERT(!ListView_IsOwnerData(plv));
    ASSERT(ListView_IsIconView(plv));

    if (!EqualRect((CONST RECT *)&pitem->rcTextRgn, (CONST RECT *)lprc)) {
        // RecalcRegion knows to use rcTextRgn in the case where iEdit != -1,
        // so set it up before calling through.
        CopyRect(&pitem->rcTextRgn, (CONST RECT *)lprc);
        ListView_RecalcRegion(plv, TRUE, TRUE);

        // Invalidate the entire Edit and force a repaint from the listview
        // on down to make sure we don't leave turds...
        InvalidateRect(plv->hwndEdit, NULL, TRUE);
        UpdateWindow(plv->ci.hwnd);
    }
}

// BUGBUG: very similar routine in treeview

void NEAR ListView_SetEditSize(LV* plv)
{
    RECT rcLabel;
    UINT seips;

    if (!((plv->iEdit >= 0) && (plv->iEdit < ListView_Count(plv))))
    {
       ListView_DismissEdit(plv, TRUE);    // cancel edits
       return;
    }

    ListView_GetRects(plv, plv->iEdit, NULL, &rcLabel, NULL, NULL);

    // OffsetRect(&rc, rcLabel.left + g_cxLabelMargin + g_cxBorder,
    //         (rcLabel.bottom + rcLabel.top - rc.bottom) / 2 + g_cyBorder);
    // OffsetRect(&rc, rcLabel.left + g_cxLabelMargin , rcLabel.top);

    // get the text bounding rect

    if (ListView_IsIconView(plv))
    {
        // We should not adjust y-positoin in case of the icon view.
        InflateRect(&rcLabel, -g_cxLabelMargin, -g_cyBorder);
    }
    else
    {
        // Special case for single-line & centered
        InflateRect(&rcLabel, -g_cxLabelMargin - g_cxBorder, (-(rcLabel.bottom - rcLabel.top - plv->cyLabelChar) / 2) - g_cyBorder);
    }

    seips = 0;
    if (ListView_IsIconView(plv) && !(plv->ci.style & LVS_NOLABELWRAP))
        seips |= SEIPS_WRAP;
#ifdef DEBUG
    if (plv->ci.style & LVS_NOSCROLL)
        seips |= SEIPS_NOSCROLL;
#endif

    SetEditInPlaceSize(plv->hwndEdit, &rcLabel, plv->hfontLabel, seips);

    if (plv->exStyle & LVS_EX_REGIONAL)
        ListView_ChangeEditRectForRegion(plv, &rcLabel);
}

// to avoid eating too much stack
void NEAR ListView_DoOnEditLabel(LV *plv, int i, LPTSTR pszInitial)
{
    TCHAR szLabel[CCHLABELMAX];
    LV_ITEM item;

    item.mask = LVIF_TEXT;
    item.iItem = i;
    item.iSubItem = 0;
    item.pszText = szLabel;
    item.cchTextMax = ARRAYSIZE(szLabel);
    ListView_OnGetItem(plv, &item);

    if (!item.pszText)
        return;

    // Make sure the edited item has the focus.
    if (plv->iFocus != i)
        ListView_SetFocusSel(plv, i, TRUE, TRUE, FALSE);

    // Make sure the item is fully visible
    ListView_OnEnsureVisible(plv, i, FALSE);        // fPartialOK == FALSE

    // Must subtract one from ARRAYSIZE(szLabel) because Edit_LimitText doesn't include
    // the terminating NULL

    plv->hwndEdit = CreateEditInPlaceWindow(plv->ci.hwnd,
            pszInitial? pszInitial : item.pszText, ARRAYSIZE(szLabel) - 1,
        ListView_IsIconView(plv) ?
            (WS_BORDER | WS_CLIPSIBLINGS | WS_CHILD | ES_CENTER | ES_MULTILINE | ES_AUTOVSCROLL | ES_AUTOHSCROLL) :
            (WS_BORDER | WS_CLIPSIBLINGS | WS_CHILD | ES_LEFT | ES_AUTOHSCROLL), plv->hfontLabel);
    if (plv->hwndEdit)
    {
        LISTITEM FAR* pitem;
        LV_DISPINFO nm;

        // We create the edit window but have not shown it.  Ask the owner
        // if they are interested or not.
        // If we passed in initial text set the ID to be dirty...
        if (pszInitial)
            SetWindowID(plv->hwndEdit, 1);

        nm.item.mask = LVIF_PARAM;
        nm.item.iItem = i;
        nm.item.iSubItem = 0;

        if (!ListView_IsOwnerData( plv ))
        {
            if (!(pitem = ListView_GetItemPtr(plv, i)))
            {
                DestroyWindow(plv->hwndEdit);
                plv->hwndEdit = NULL;
                return;
            }
            nm.item.lParam = pitem->lParam;
        }
        else
            nm.item.lParam = (LPARAM)0;


        plv->iEdit = i;

        // if they have LVS_EDITLABELS but return non-FALSE here, stop!
        if ((BOOL)CCSendNotify(&plv->ci, LVN_BEGINLABELEDIT, &nm.hdr))
        {
            plv->iEdit = -1;
            DestroyWindow(plv->hwndEdit);
            plv->hwndEdit = NULL;
        }
    }
}


void FAR PASCAL RescrollEditWindow(HWND hwndEdit)
{
    Edit_SetSel(hwndEdit, -1, -1);      // move to the end
    Edit_SetSel(hwndEdit, 0, -1);       // select all text
}
// BUGBUG: very similar code in treeview.c

HWND NEAR ListView_OnEditLabel(LV* plv, int i, LPTSTR pszInitialText)
{

    // this eats stack
    ListView_DismissEdit(plv, FALSE);

    if (!(plv->ci.style & LVS_EDITLABELS) || (GetFocus() != plv->ci.hwnd) ||
        (i == -1))
        return(NULL);   // Does not support this.

    ListView_DoOnEditLabel(plv, i, pszInitialText);

    if (plv->hwndEdit) {

        plv->pfnEditWndProc = SubclassWindow(plv->hwndEdit, ListView_EditWndProc);

#if defined(FE_IME) || !defined(WINNT)
        if (g_fDBCSInputEnabled) {
            if (SendMessage(plv->hwndEdit, EM_GETLIMITTEXT, (WPARAM)0, (LPARAM)0)<13)
            {
                plv->flags |= LVF_DONTDRAWCOMP;
            }

        }
#endif

        ListView_SetEditSize(plv);

        // Show the window and set focus to it.  Do this after setting the
        // size so we don't get flicker.
        SetFocus(plv->hwndEdit);
        ShowWindow(plv->hwndEdit, SW_SHOW);
        ListView_InvalidateItem(plv, i, TRUE, RDW_INVALIDATE | RDW_ERASE);

        RescrollEditWindow(plv->hwndEdit);

        /* Due to a bizzare twist of fate, a certain mix of resolution / font size / icon
        /  spacing results in being able to see the previous label behind the edit control
        /  we have just created.  Therefore to overcome this problem we ensure that this
        /  label is erased.
        /
        /  As the label is not painted when we have an edit control we just invalidate the
        /  area and the background will be painted.  As the window is a child of the list view
        /  we should not see any flicker within it. */

        if ( ListView_IsIconView( plv ) )
        {
            RECT rcLabel;
            
            ListView_GetRects( plv, i, NULL, &rcLabel, NULL, NULL );
            ListView_UnfoldRects( plv, i, NULL, &rcLabel, NULL, NULL );

            InvalidateRect( plv->ci.hwnd, &rcLabel, TRUE );
            UpdateWindow( plv->ci.hwnd );
        }
    }

    return plv->hwndEdit;
}


// BUGBUG: very similar code in treeview.c

BOOL NEAR ListView_DismissEdit(LV* plv, BOOL fCancel)
{
    LISTITEM FAR* pitem = NULL;
    BOOL fOkToContinue = TRUE;
    HWND hwndEdit = plv->hwndEdit;
    HWND hwnd = plv->ci.hwnd;
    int iEdit;
    LV_DISPINFO nm;
    TCHAR szLabel[CCHLABELMAX];
#if defined(FE_IME) || !defined(WINNT)
    HIMC himc;
#endif


    if (plv->fNoDismissEdit)
        return FALSE;

    if (!hwndEdit) {
        // Also make sure there are no pending edits...
        ListView_CancelPendingEdit(plv);
        return TRUE;    // It is OK to process as normal...
    }

    // If the window is not visible, we are probably in the process
    // of being destroyed, so assume that we are being destroyed
    if (!IsWindowVisible(plv->ci.hwnd))
        fCancel = TRUE;

    //
    // We are using the Window ID of the control as a BOOL to
    // state if it is dirty or not.
    switch (GetWindowID(hwndEdit)) {
    case 0:
        // The edit control is not dirty so act like cancel.
        fCancel = TRUE;
        // Fall through to set window so we will not recurse!
    case 1:
        // The edit control is dirty so continue.
        SetWindowID(hwndEdit, 2);    // Don't recurse
        break;
    case 2:
        // We are in the process of processing an update now, bail out
        return TRUE;
    }

    // BUGBUG: this will fail if the program deleted the items out
    // from underneath us (while we are waiting for the edit timer).
    // make delete item invalidate our edit item
    // We uncouple the edit control and hwnd out from under this as
    // to allow code that process the LVN_ENDLABELEDIT to reenter
    // editing mode if an error happens.
    iEdit = plv->iEdit;

    do
    {
        if (ListView_IsOwnerData( plv ))
        {
            if (!((iEdit >= 0) && (iEdit < plv->cTotalItems)))
            {
                break;
            }
            nm.item.lParam = 0;
        }
        else
        {

            pitem = ListView_GetItemPtr(plv, iEdit);
            ASSERT(pitem);
            if (pitem == NULL)
            {
                break;
            }
            nm.item.lParam = pitem->lParam;
        }

        nm.item.iItem = iEdit;
        nm.item.iSubItem = 0;
        nm.item.cchTextMax = 0;
        nm.item.mask = 0;

        if (fCancel)
            nm.item.pszText = NULL;
        else
        {
            Edit_GetText(hwndEdit, szLabel, ARRAYSIZE(szLabel));
            nm.item.pszText = szLabel;
            nm.item.mask |= LVIF_TEXT;
            nm.item.cchTextMax = ARRAYSIZE(szLabel);
        }

        //
        // Notify the parent that we the label editing has completed.
        // We will use the LV_DISPINFO structure to return the new
        // label in.  The parent still has the old text available by
        // calling the GetItemText function.
        //

        fOkToContinue = (BOOL)CCSendNotify(&plv->ci, LVN_ENDLABELEDIT, &nm.hdr);
        if (!IsWindow(hwnd)) {
            return FALSE;
        }
        if (fOkToContinue && !fCancel)
        {
            //
            // If the item has the text set as CALLBACK, we will let the
            // ower know that they are supposed to set the item text in
            // their own data structures.  Else we will simply update the
            // text in the actual view.
            //
            if (!ListView_IsOwnerData( plv ) &&
                (pitem->pszText != LPSTR_TEXTCALLBACK))
            {
                // Set the item text (everything's set up in nm.item)
                //
                nm.item.mask = LVIF_TEXT;
                ListView_OnSetItem(plv, &nm.item);
            }
            else
            {
                CCSendNotify(&plv->ci, LVN_SETDISPINFO, &nm.hdr);

                // Also we will assume that our cached size is invalid...
                plv->rcView.left = RECOMPUTE;
                if (!ListView_IsOwnerData( plv ))
                {
                    ListView_SetSRecompute(pitem);
                }
            }
        }

#if defined(FE_IME) || !defined(WINNT)
        if (g_fDBCSInputEnabled) {
            if (LOWORD(GetKeyboardLayout(0L)) == 0x0411 && (himc = ImmGetContext(hwndEdit)))
            {
                ImmNotifyIME(himc, NI_COMPOSITIONSTR, CPS_COMPLETE, 0L);
                ImmReleaseContext(hwndEdit, himc);
            }
        }
#endif

        // redraw
        ListView_InvalidateItem(plv, iEdit, FALSE, RDW_INVALIDATE | RDW_ERASE);
    } while (FALSE);

    // If the hwnedit is still us clear out the variables
    if (hwndEdit == plv->hwndEdit)
    {
        plv->iEdit = -1;
        plv->hwndEdit = NULL;   // avoid being reentered
    }
    DestroyWindow(hwndEdit);

    // We've to recalc the region because the edit in place window has
    // added stuff to the region that we don't know how to remove
    // safely.
    ListView_RecalcRegion(plv, TRUE, TRUE);

    return fOkToContinue;
}

//
// This function will scall the icon positions that are stored in the
// item structures between large and small icon view.
//
void NEAR ListView_ScaleIconPositions(LV* plv, BOOL fSmallIconView)
{
    int cxItem, cyItem;
    HWND hwnd;
    int i;

    if (fSmallIconView)
    {
        if (plv->flags & LVF_ICONPOSSML)
            return;     // Already done
    }
    else
    {
        if ((plv->flags & LVF_ICONPOSSML) == 0)
            return;     // dito
    }

    // Last but not least update our bit!
    plv->flags ^= LVF_ICONPOSSML;

    cxItem = plv->cxItem;
    cyItem = plv->cyItem;
    hwnd = plv->ci.hwnd;

    // We will now loop through all of the items and update their coordinats
    // We will update th position directly into the view instead of calling
    // SetItemPosition as to not do 5000 invalidates and messages...
    if (!ListView_IsOwnerData( plv ))
    {
        for (i = 0; i < ListView_Count(plv); i++)
        {
            LISTITEM FAR* pitem = ListView_FastGetItemPtr(plv, i);

            if (pitem->pt.y != RECOMPUTE) {
                if (fSmallIconView)
                {
                    pitem->pt.x = MulDiv(pitem->pt.x - g_cxIconOffset, cxItem, lv_cxIconSpacing);
                    pitem->pt.y = MulDiv(pitem->pt.y - g_cyIconOffset, cyItem, lv_cyIconSpacing);
                }
                else
                {
                    pitem->pt.x = MulDiv(pitem->pt.x, lv_cxIconSpacing, cxItem) + g_cxIconOffset;
                    pitem->pt.y = MulDiv(pitem->pt.y, lv_cyIconSpacing, cyItem) + g_cyIconOffset;
                }
            }
        }

        plv->iFreeSlot = -1; // The "free slot" cache is no good once an item moves

        if (plv->ci.style & LVS_AUTOARRANGE)
        {
            ListView_ISetColumnWidth(plv, 0,
                                     LV_GetNewColWidth(plv, 0, ListView_Count(plv)-1), FALSE);
            // If autoarrange is turned on, the arrange function will do
            // everything that is needed.
            ListView_OnArrange(plv, LVA_DEFAULT);
            return;
        }
    }
    plv->rcView.left = RECOMPUTE;

    //
    // Also scale the origin
    //
    if (fSmallIconView)
    {
        plv->ptOrigin.x = MulDiv(plv->ptOrigin.x, cxItem, lv_cxIconSpacing);
        plv->ptOrigin.y = MulDiv(plv->ptOrigin.y, cyItem, lv_cyIconSpacing);
    }
    else
    {
        plv->ptOrigin.x = MulDiv(plv->ptOrigin.x, lv_cxIconSpacing, cxItem);
        plv->ptOrigin.y = MulDiv(plv->ptOrigin.y, lv_cyIconSpacing, cyItem);
    }

    // Make sure it fully redraws correctly
    RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
}




HWND FAR PASCAL CreateEditInPlaceWindow(HWND hwnd, LPCTSTR lpText, int cbText, LONG style, HFONT hFont)
{
    HWND hwndEdit;

    // Create the window with some nonzero size so margins work properly
    // The caller will do a SetEditInPlaceSize to set the real size
    // But make sure the width is huge so when an app calls SetWindowText,
    // USER won't try to scroll the window.
    hwndEdit = CreateWindowEx(GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_RTLREADING, 
                              TEXT("EDIT"), lpText, style,
            0, 0, 16384, 20, hwnd, NULL, HINST_THISDLL, NULL);

    if (hwndEdit) {

        Edit_LimitText(hwndEdit, cbText);

        Edit_SetSel(hwndEdit, 0, 0);    // move to the beginning

        FORWARD_WM_SETFONT(hwndEdit, hFont, FALSE, SendMessage);

    }

    return hwndEdit;
}


// BUGBUG: very similar routine in treeview

// in:
//      hwndEdit        edit control to position in client coords of parent window
//      prc             bonding rect of the text, used to position everthing
//      hFont           font being used
//      flags
//          SEIPS_WRAP      if this is a wrapped type (multiline) edit
//          SEIPS_NOSCROLL  if the parent control does not have scrollbars
//
//      The SEIPS_NOSCROLL flag is used only in DEBUG.  Normally, the item
//      being edited should have been scrolled into view, but if the parent
//      doesn't have scrollbars, then clearly that's not possible, so we
//      shouldn't ASSERT in that case.
//
// Notes:
//       The top-left corner of the bouding rectangle must be the position
//      the client uses to draw text. We adjust the edit field rectangle
//      appropriately.
//

void FAR PASCAL SetEditInPlaceSize(HWND hwndEdit, RECT FAR *prc, HFONT hFont, UINT seips)
{
    RECT rc, rcClient, rcFormat;
    TCHAR szLabel[CCHLABELMAX + 1];
    int cchLabel, cxIconTextWidth;
    HDC hdc;
    HWND hwndParent = GetParent(hwndEdit);
    UINT flags;

    // was #ifdef DBCS
    // short wRightMgn;
    // #endif

    cchLabel = Edit_GetText(hwndEdit, szLabel, ARRAYSIZE(szLabel));
    if (szLabel[0] == 0)
    {
        lstrcpy(szLabel, c_szSpace);
        cchLabel = 1;
    }

    hdc = GetDC(hwndParent);

#ifdef DEBUG
    //DrawFocusRect(hdc, prc);       // this is the rect they are passing in
#endif

    SelectFont(hdc, hFont);

    cxIconTextWidth = g_cxIconSpacing - g_cxLabelMargin * 2;
    rc.left = rc.top = rc.bottom = 0;
    rc.right = cxIconTextWidth;      // for DT_LVWRAP

    // REVIEW: we might want to include DT_EDITCONTROL in our DT_LVWRAP

    if (seips & SEIPS_WRAP)
    {
        flags = DT_LVWRAP | DT_CALCRECT;
        // We only use DT_NOFULLWIDTHCHARBREAK on Korean(949) Memphis and NT5
        if (949 == g_uiACP && (g_bRunOnNT5 || g_bRunOnMemphis))
            flags |= DT_NOFULLWIDTHCHARBREAK;
    }
    else
        flags = DT_LV | DT_CALCRECT;
    // If the string is NULL display a rectangle that is visible.
    DrawText(hdc, szLabel, cchLabel, &rc, flags);

    // Minimum text box size is 1/4 icon spacing size
    if (rc.right < g_cxIconSpacing / 4)
        rc.right = g_cxIconSpacing / 4;

    // position the text rect based on the text rect passed in
    // if wrapping, center the edit control around the text mid point

    OffsetRect(&rc,
        (seips & SEIPS_WRAP) ? prc->left + ((prc->right - prc->left) - (rc.right - rc.left)) / 2 : prc->left,
        (seips & SEIPS_WRAP) ? prc->top : prc->top +  ((prc->bottom - prc->top) - (rc.bottom - rc.top)) / 2 );

    // give a little space to ease the editing of this thing
    if (!(seips & SEIPS_WRAP))
        rc.right += g_cxLabelMargin * 4;
    rc.right += g_cyEdge;   // try to leave a little more for dual blanks

#ifdef DEBUG
    //DrawFocusRect(hdc, &rc);
#endif

    ReleaseDC(hwndParent, hdc);

    //
    // #5688: We need to make it sure that the whole edit window is
    //  always visible. We should not extend it to the outside of
    //  the parent window.
    //
    {
        BOOL fSuccess;
        GetClientRect(hwndParent, &rcClient);
        fSuccess = IntersectRect(&rc, &rc, &rcClient);
        ASSERT(fSuccess || IsRectEmpty(&rcClient) || (seips & SEIPS_NOSCROLL));
    }

    //
    // Inflate it after the clipping, because it's ok to hide border.
    //
    // EM_GETRECT already takes EM_GETMARGINS into account, so don't use both.

    SendMessage(hwndEdit, EM_GETRECT, 0, (LPARAM)(LPRECT)&rcFormat);

    // Turn the margins inside-out so we can AdjustWindowRect on them.
    rcFormat.top = -rcFormat.top;
    rcFormat.left = -rcFormat.left;
    AdjustWindowRectEx(&rcFormat, GetWindowStyle(hwndEdit), FALSE,
                                  GetWindowExStyle(hwndEdit));

    InflateRect(&rc, -rcFormat.left, -rcFormat.top);

    HideCaret(hwndEdit);

    SetWindowPos(hwndEdit, NULL, rc.left, rc.top,
            rc.right - rc.left, rc.bottom - rc.top, SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOCOPYBITS);

    CopyRect(prc, (CONST RECT *)&rc);

#ifndef UNIX
    InvalidateRect(hwndEdit, NULL, TRUE);
#endif

    ShowCaret(hwndEdit);
}

// draw three pixel wide border for border selection.
void NEAR PASCAL ListView_DrawBorderSel(HIMAGELIST himl, HWND hwnd, HDC hdc, int x,int y, COLORREF clr)
{
    int dx, dy;
    RECT rc;
    COLORREF clrSave = SetBkColor(hdc, clr);

    ImageList_GetIconSize(himl, &dx, &dy);
    //left
    rc.left = x - 4;    // 1 pixel seperation + 3 pixel width.
    rc.top = y - 4;
    rc.right = x - 1;
    rc.bottom = y + dy + 4;
    ExtTextOut(hdc,0,0,ETO_OPAQUE,&rc,NULL,0,NULL);
    //top
    rc.left = rc.right;
    rc.right = rc.left + dx + 2;
    rc.bottom = rc.top + 3;
    ExtTextOut(hdc,0,0,ETO_OPAQUE,&rc,NULL,0,NULL);
    //right
    rc.left = rc.right;
    rc.right = rc.left + 3;
    rc.bottom = rc.top + dy + 8; // 2*3 pixel borders + 2*1 pixel seperation = 8
    ExtTextOut(hdc,0,0,ETO_OPAQUE,&rc,NULL,0,NULL);
    // bottom
    rc.top = rc.bottom - 3;
    rc.right = rc.left;
    rc.left = rc.right - dx - 2;
    ExtTextOut(hdc,0,0,ETO_OPAQUE,&rc,NULL,0,NULL);

    SetBkColor(hdc, clrSave);
    return;
}

//
//  If xMax >= 0, then the image will not be drawn past the x-coordinate
//  specified by xMax.  This is used only during report view drawing, where
//  we have to clip against our column width.
//
UINT NEAR PASCAL ListView_DrawImageEx(LV* plv, LV_ITEM FAR* pitem, HDC hdc, int x, int y, UINT fDraw, int xMax)
{
    UINT fText = SHDT_DESELECTED;
    UINT fImage = ILD_NORMAL;
    COLORREF clr = 0;
    HIMAGELIST himl;
    BOOL fBorderSel = (plv->exStyle & LVS_EX_BORDERSELECT);
    int cxIcon;

    fImage = (pitem->state & LVIS_OVERLAYMASK);
    fText = SHDT_DESELECTED;

    if (ListView_IsIconView(plv)) {
        himl = plv->himl;
        cxIcon = plv->cxIcon;
    } else {
        himl = plv->himlSmall;
        cxIcon = plv->cxSmIcon;
    }

    // the item can have one of 4 states, for 3 looks:
    //    normal                    simple drawing
    //    selected, no focus        light image highlight, no text hi
    //    selected w/ focus         highlight image & text
    //    drop highlighting         highlight image & text

    if ((pitem->state & LVIS_DROPHILITED) ||
        ((fDraw & LVDI_SELECTED) && (pitem->state & LVIS_SELECTED)))
    {
        fText = SHDT_SELECTED;
        if (!fBorderSel)    // do not effect color of icon on borderselect.
        {
            fImage |= ILD_BLEND50;
            clr = CLR_HILIGHT;
        }
    }

    if ((fDraw & LVDI_SELECTNOFOCUS) && (pitem->state & LVIS_SELECTED)) {
        fText = SHDT_SELECTNOFOCUS;
        //fImage |= ILD_BLEND50;
        //clr = GetSysColor(COLOR_3DFACE);
    }

    if (pitem->state & LVIS_CUT)
    {
        fImage |= ILD_BLEND50;
        clr = plv->clrBk;
    }

#if 0   // dont do a selected but dont have the focus vis.
    else if (item.state & LVIS_SELECTED)
    {
        fImage |= ILD_BLEND25;
        clr = CLR_HILIGHT;
    }
#endif

    if (!(fDraw & LVDI_NOIMAGE))
    {
        if (himl) {
            COLORREF clrBk;

            if (plv->pImgCtx || ((plv->exStyle & LVS_EX_REGIONAL) && !g_fSlowMachine))
                clrBk = CLR_NONE;
            else
                clrBk = plv->clrBk;

            if (xMax >= 0)
                cxIcon = min(cxIcon, xMax - x);

            if (cxIcon > 0)
                ImageList_DrawEx(himl, pitem->iImage, hdc, x, y, cxIcon, 0, clrBk, clr, fImage);
        }

        if (plv->himlState) {
            if (LV_StateImageValue(pitem) &&
                (pitem->iSubItem == 0 ||
                 plv->exStyle & LVS_EX_SUBITEMIMAGES)
                ) {
                int iState = LV_StateImageIndex(pitem);
                int dyImage =
                    (himl) ?
                        ( (ListView_IsIconView(plv) ? plv->cyIcon : plv->cySmIcon) - plv->cyState)
                            : 0;
                int xDraw = x-plv->cxState;
                cxIcon = plv->cxState;
                if (xMax >= 0)
                    cxIcon = min(cxIcon, xMax - xDraw);
                if (cxIcon > 0)
                    ImageList_DrawEx(plv->himlState, iState, hdc,
                               xDraw,
                               y + dyImage,
                               cxIcon,
                               0,
                               CLR_DEFAULT,
                               CLR_DEFAULT,
                               ILD_NORMAL);
            }
        }
        // draw the border selection if appropriate.
        if (fBorderSel && !(fText & SHDT_DESELECTED))       // selected, draw the selection rect.
        {
            COLORREF clrBorder = (fDraw & LVDI_HOTSELECTED) 
                        ? GetSysColor(COLOR_HOTLIGHT) : g_clrHighlight;
            ListView_DrawBorderSel(himl, plv->ci.hwnd, hdc, x, y, clrBorder);
        }
        else if (fBorderSel && (fText & SHDT_DESELECTED))   // erase possible selection rect.
            ListView_DrawBorderSel(himl, plv->ci.hwnd, hdc, x, y, plv->clrBk);

    }

    return fText;
}

#if defined(FE_IME) || !defined(WINNT)
void NEAR PASCAL ListView_SizeIME(HWND hwnd)
{
    HIMC himc;
#ifdef _WIN32
    CANDIDATEFORM   candf;
#else
    CANDIDATEFORM16   candf;
#endif
    RECT rc;

    // If this subclass procedure is being called with WM_SIZE,
    // This routine sets the rectangle to an IME.

    GetClientRect(hwnd, &rc);


    // Candidate stuff
    candf.dwIndex = 0; // Bogus assumption for Japanese IME.
    candf.dwStyle = CFS_EXCLUDE;
    candf.ptCurrentPos.x = rc.left;
    candf.ptCurrentPos.y = rc.bottom;
    candf.rcArea = rc;

    if (himc=ImmGetContext(hwnd))
    {
        ImmSetCandidateWindow(himc, &candf);
        ImmReleaseContext(hwnd, himc);
    }
}

#ifndef UNICODE
LPSTR NEAR PASCAL DoDBCSBoundary(LPTSTR lpsz, int FAR *lpcchMax)
{
    int i = 0;

    while (i < *lpcchMax && *lpsz)
    {
        i++;

        if (IsDBCSLeadByte(*lpsz))
        {

            if (i >= *lpcchMax)
            {
                --i; // Wrap up without the last leadbyte.
                break;
            }

            i++;
            lpsz+= 2;
        }
        else
            lpsz++;
   }

   *lpcchMax = i;

   return lpsz;
}
#endif

void NEAR PASCAL DrawCompositionLine(HWND hwnd, HDC hdc, HFONT hfont, LPTSTR lpszComp, LPBYTE lpszAttr, int ichCompStart, int ichCompEnd, int ichStart)
{
    PTSTR pszCompStr;
    int ichSt,ichEnd;
    DWORD dwPos;
    BYTE bAttr;
    HFONT hfontOld;

    int  fnPen;
    HPEN hPen;
    COLORREF crDrawText;
    COLORREF crDrawBack;
    COLORREF crOldText;
    COLORREF crOldBk;


    while (ichCompStart < ichCompEnd)
    {

        // Get the fragment to draw
        //
        // ichCompStart,ichCompEnd -- index at Edit Control
        // ichSt,ichEnd            -- index at lpszComp

        ichEnd = ichSt  = ichCompStart - ichStart;
        bAttr = lpszAttr[ichSt];

        while (ichEnd < ichCompEnd - ichStart)
        {
            if (bAttr == lpszAttr[ichEnd])
                ichEnd++;
            else
                break;
        }

        pszCompStr = (PTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*(ichEnd - ichSt + 1 + 1) ); // 1 for NULL.

        if (pszCompStr)
        {
            lstrcpyn(pszCompStr, &lpszComp[ichSt], ichEnd-ichSt+1);
            pszCompStr[ichEnd-ichSt] = '\0';
        }


        // Attribute stuff
        switch (bAttr)
        {
            case ATTR_INPUT:
                fnPen = PS_DOT;
                crDrawText = g_clrWindowText;
                crDrawBack = g_clrWindow;
                break;
            case ATTR_TARGET_CONVERTED:
            case ATTR_TARGET_NOTCONVERTED:
                fnPen = PS_DOT;
                crDrawText = g_clrHighlightText;
                crDrawBack = g_clrHighlight;
                break;
            case ATTR_CONVERTED:
                fnPen = PS_SOLID;
                crDrawText = g_clrWindowText;
                crDrawBack = g_clrWindow;
                break;
        }
        crOldText = SetTextColor(hdc, crDrawText);
        crOldBk = SetBkColor(hdc, crDrawBack);

        hfontOld= SelectObject(hdc, hfont);

        // Get the start position of composition
        //
        dwPos = (DWORD) SendMessage(hwnd, EM_POSFROMCHAR, ichCompStart, 0);

        // Draw it.
        TextOut(hdc, GET_X_LPARAM(dwPos), GET_Y_LPARAM(dwPos), pszCompStr, ichEnd-ichSt);
#ifndef DONT_UNDERLINE
        // Underline
        hPen = CreatePen(fnPen, 1, crDrawText);
        if( hPen ) {

            HPEN hpenOld = SelectObject( hdc, hPen );
            int iOldBk = SetBkMode( hdc, TRANSPARENT );
            SIZE size;

            GetTextExtentPoint(hdc, pszCompStr, ichEnd-ichSt, &size);

            MoveToEx( hdc, GET_X_LPARAM(dwPos), size.cy + GET_Y_LPARAM(dwPos)-1, NULL);

            LineTo( hdc, size.cx + GET_X_LPARAM(dwPos),  size.cy + GET_Y_LPARAM(dwPos)-1 );

            SetBkMode( hdc, iOldBk );

            if( hpenOld ) SelectObject( hdc, hpenOld );

            DeleteObject( hPen );
        }
#endif

        if (hfontOld)
            SelectObject(hdc, hfontOld);

        SetTextColor(hdc, crOldText);
        SetBkColor(hdc, crOldBk);

        LocalFree((HLOCAL)pszCompStr);

        //Next fragment
        //
        ichCompStart += ichEnd-ichSt;
    }
}

void NEAR PASCAL ListView_InsertComposition(HWND hwnd, WPARAM wParam, LPARAM lParam, LV *plv)
{
    PSTR pszCompStr;

    int  cbComp = 0;
    int  cbCompNew;
    int  cchMax;
    int  cchText;
    DWORD dwSel;
    HIMC himc = (HIMC)0;


    // To prevent recursion..

    if (plv->flags & LVF_INSERTINGCOMP)
    {
        return;
    }
    plv->flags |= LVF_INSERTINGCOMP;

    // Don't want to redraw edit during inserting.
    //
    SendMessage(hwnd, WM_SETREDRAW, (WPARAM)FALSE, 0);

    // If we have RESULT STR, put it to EC first.

    if (himc = ImmGetContext(hwnd))
    {
#ifdef WIN32
        if (!(dwSel = PtrToUlong(GetProp(hwnd, szIMECompPos))))
            dwSel = Edit_GetSel(hwnd);

        // Becaues we don't setsel after inserting composition
        // in win32 case.
        Edit_SetSel(hwnd, GET_X_LPARAM(dwSel), GET_Y_LPARAM(dwSel));
#endif
        if (lParam&GCS_RESULTSTR)
        {
            // ImmGetCompositionString() returns length of buffer in bytes,
            // not in # of character
            cbComp = (int)ImmGetCompositionString(himc, GCS_RESULTSTR, NULL, 0);
            
            pszCompStr = (PSTR)LocalAlloc(LPTR, cbComp + sizeof(TCHAR));
            if (pszCompStr)
            {
                ImmGetCompositionString(himc, GCS_RESULTSTR, (PSTR)pszCompStr, cbComp+sizeof(TCHAR));
                
                // With ImmGetCompositionStringW, cbComp is # of bytes copied
                // character position must be calculated by cbComp / sizeof(TCHAR)
                //
                *(TCHAR *)(&pszCompStr[cbComp]) = TEXT('\0');
                Edit_ReplaceSel(hwnd, (LPTSTR)pszCompStr);
                LocalFree((HLOCAL)pszCompStr);
            }
#ifdef WIN32
            // There's no longer selection
            //
            RemoveProp(hwnd, szIMECompPos);

            // Get current cursor pos so that the subsequent composition
            // handling will do the right thing.
            //
            dwSel = Edit_GetSel(hwnd);
#endif
        }

        if (lParam & GCS_COMPSTR)
        {
            // ImmGetCompositionString() returns length of buffer in bytes,
            // not in # of character
            //
            cbComp = (int)ImmGetCompositionString(himc, GCS_COMPSTR, NULL, 0);
            pszCompStr = (PSTR)LocalAlloc(LPTR, cbComp + sizeof(TCHAR));
            if (pszCompStr)
            {
                ImmGetCompositionString(himc, GCS_COMPSTR, pszCompStr, cbComp+sizeof(TCHAR));

                // Get position of the current selection
                //
#ifndef WIN32
                dwSel  = Edit_GetSel(hwnd);
#endif
                cchMax = (int)SendMessage(hwnd, EM_GETLIMITTEXT, 0, 0);
                cchText = Edit_GetTextLength(hwnd);

                // Cut the composition string if it exceeds limit.
                //
                cbCompNew = min((UINT)cbComp,
                              sizeof(TCHAR)*(cchMax-(cchText-(HIWORD(dwSel)-LOWORD(dwSel)))));

                // wrap up the DBCS at the end of string
                //
                if (cbCompNew < cbComp)
                {
#ifndef UNICODE
                    DoDBCSBoundary((LPSTR)pszCompStr, (int FAR *)&cbCompNew);
#endif

                    *(TCHAR *)(&pszCompStr[cbCompNew]) = TEXT('\0');

                    // Reset composition string if we cut it.
                    ImmSetCompositionString(himc, SCS_SETSTR, pszCompStr, cbCompNew, NULL, 0);
                    cbComp = cbCompNew;
                }
                
               *(TCHAR *)(&pszCompStr[cbComp]) = TEXT('\0');

               // Replace the current selection with composition string.
               //
               Edit_ReplaceSel(hwnd, (LPTSTR)pszCompStr);

               LocalFree((HLOCAL)pszCompStr);
           }

           // Mark the composition string so that we can replace it again
           // for the next time.
           //

#ifdef WIN32
           // Don't setsel to avoid flicking
           if (cbComp)
           {
               dwSel = MAKELONG(LOWORD(dwSel),LOWORD(dwSel)+cbComp/sizeof(TCHAR));
               SetProp(hwnd, szIMECompPos, IntToPtr(dwSel));
           }
           else
               RemoveProp(hwnd, szIMECompPos);
#else
           // Still use SETSEL for 16bit.
           if (cbComp)
               Edit_SetSel(hwnd, LOWORD(dwSel), LOWORD(dwSel)+cbComp);
#endif

        }

        ImmReleaseContext(hwnd, himc);
    }

    SendMessage(hwnd, WM_SETREDRAW, (WPARAM)TRUE, 0);
    //
    // We want to update the size of label edit just once at
    // each WM_IME_COMPOSITION processing. ReplaceSel causes several EN_UPDATE
    // and it causes ugly flicking too.
    //
    RedrawWindow(hwnd, NULL, NULL, RDW_INTERNALPAINT|RDW_INVALIDATE);
    SetWindowID(plv->hwndEdit, 1);
    ListView_SetEditSize(plv);

    plv->flags &= ~LVF_INSERTINGCOMP;
}

void NEAR PASCAL ListView_PaintComposition(HWND hwnd, LV * plv)
{
    BYTE szCompStr[CCHLABELMAX + 1];
    BYTE szCompAttr[CCHLABELMAX + 1];

    int  cchLine, ichLineStart;
    int  cbComp = 0;
    int  cchComp;
    int  nLine;
    int  ichCompStart, ichCompEnd;
    DWORD dwSel;
    int  cchMax, cchText;
    HIMC himc = (HIMC)0;
    HDC  hdc;


    if (plv->flags & LVF_INSERTINGCOMP)
    {
        // This is the case that ImmSetCompositionString() generates
        // WM_IME_COMPOSITION. We're not ready to paint composition here.
        return;
    }

    if (himc = ImmGetContext(hwnd))
    {

        cbComp=(UINT)ImmGetCompositionString(himc, GCS_COMPSTR, szCompStr, sizeof(szCompStr));

        ImmGetCompositionString(himc, GCS_COMPATTR, szCompAttr, sizeof(szCompStr));
        ImmReleaseContext(hwnd, himc);
    }

    if (cbComp)
    {

        // Get the position of current selection
        //
#ifdef WIN32

        if (!(dwSel = PtrToUlong(GetProp(hwnd, szIMECompPos))))
            dwSel = 0L;
#else
        dwSel  = Edit_GetSel(hwnd);
#endif
        cchMax = (int)SendMessage(hwnd, EM_GETLIMITTEXT, 0, 0);
        cchText = Edit_GetTextLength(hwnd);
        cbComp = min((UINT)cbComp, sizeof(TCHAR)*(cchMax-(cchText-(HIWORD(dwSel)-LOWORD(dwSel)))));
#ifndef UNICODE
        DoDBCSBoundary((LPTSTR)szCompStr, (int FAR *)&cbComp);
#endif
        *(TCHAR *)(&szCompStr[cbComp]) = TEXT('\0');



        /////////////////////////////////////////////////
        //                                             //
        // Draw composition string over the sel string.//
        //                                             //
        /////////////////////////////////////////////////


        hdc = GetDC(hwnd);


        ichCompStart = LOWORD(dwSel);

        cchComp = cbComp/sizeof(TCHAR);
        while (ichCompStart < (int)LOWORD(dwSel) + cchComp)
        {
            // Get line from each start pos.
            //
            nLine = Edit_LineFromChar(hwnd, ichCompStart);
            ichLineStart = Edit_LineIndex(hwnd, nLine);
            cchLine= Edit_LineLength(hwnd, ichLineStart);

            // See if composition string is longer than this line.
            //
            if(ichLineStart+cchLine > (int)LOWORD(dwSel)+cchComp)
                ichCompEnd = LOWORD(dwSel)+cchComp;
            else
            {
                // Yes, the composition string is longer.
                // Take the begining of the next line as next start.
                //
                if (ichLineStart+cchLine > ichCompStart)
                    ichCompEnd = ichLineStart+cchLine;
                else
                {
                    // If the starting position is not proceeding,
                    // let's get out of here.
                    break;
                }
            }

            // Draw the line
            //
            DrawCompositionLine(hwnd, hdc, plv->hfontLabel, (LPTSTR)szCompStr, szCompAttr, ichCompStart, ichCompEnd, LOWORD(dwSel));

            ichCompStart = ichCompEnd;
        }

        ReleaseDC(hwnd, hdc);
        // We don't want to repaint the window.
        ValidateRect(hwnd, NULL);
    }
}

#endif FE_IME
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\lvfile.c ===
// BUGBUG: this code is not used anymore!

#include "shellprv.h"
#include "listview.h"

// Internal STREAM entry points

BOOL Stream_WriteString(STREAM FAR* pstm, LPCTSTR psz);
LPTSTR Stream_ReadString(STREAM FAR* pstm);
UINT Stream_ReadStringBuffer(STREAM FAR* pstm, LPTSTR psz, UINT cb);

// Read or write a ListView to a stream.  flags indicate what aspects     /* ;Internal */
// of the listview to write out.  If aspects of a ListView state are      /* ;Internal */
// not written, default values will be used when read back in.            /* ;Internal */
//                                                                        /* ;Internal */
#define LVRW_ICONS          0x0001                                        /* ;Internal */
#define LVRW_SMALLICONS     0x0002                                        /* ;Internal */
#define LVRW_FONT           0x0004                                        /* ;Internal */
#define LVRW_LPARAMS        0x0008                                        /* ;Internal */
#define LVRW_COLINFO        0x0010                                        /* ;Internal */
#define LVRW_ENUMORDER      0x0020                                        /* ;Internal */
                                                                          /* ;Internal */
    // BOOL ListView_Write(HWND hwndLV, STREAM FAR* pstm, UINT flags);    /* ;Internal */
#define LVM_WRITE           (LVM_FIRST + 31)                              /* ;Internal */
#define ListView_Write(hwndLV, pstm, flags)     /* ;Internal */ \
    (BOOL)SendMessage((hwndLV), LVM_WRITE,      /* ;Internal */ \
    (WPARAM)(BOOL)(flags),                      /* ;Internal */  \
            (LPARAM)(STREAM FAR*)(pstm))                                  /* ;Internal */
                                                                          /* ;Internal */
typedef struct _LV_READINFO                                               /* ;Internal */
{                                                                         /* ;Internal */
    UINT flags;                                                           /* ;Internal */
    HINSTANCE hinst;                                                      /* ;Internal */
    HWND hwndParent;                                                      /* ;Internal */
} LV_READINFO;                                                            /* ;Internal */
                                                                          /* ;Internal */
    // HWND ListView_Read(STREAM FAR* pstm, LV_READINFO FAR* pinfo);      /* ;Internal */
    // BUGBUG This can't be a message!  How do we want this to work?      /* ;Internal */
#define LVM_READ            (LVM_FIRST + 32)                              /* ;Internal */
#define ListView_Read(plv, pinfo)                                         /* ;Internal */
                                                                          /* ;Internal */


#define LV_MAGIC    (TEXT('L') | (TEXT('V') << (8 * sizeof(TCHAR))))

typedef struct _LV_STREAMHDR
{
    UINT magic;
    UINT flags;
    UINT style;
    UINT id;
    POINT ptOrigin;
    COLORREF clrBk;
    int cItem;
} LV_STREAMHDR;

typedef struct _LV_ITEMHDR
{
    POINT pt;
    UINT state;
    int iImage;
    int iZOrder;
} LV_ITEMHDR;

BOOL NEAR ListView_OnWrite(LV* plv, STREAM FAR* pstm, UINT flags)
{
    int i;
    LV_STREAMHDR hdr;

    hdr.magic = LV_MAGIC;
    hdr.flags = flags;
    hdr.style = plv->style;
    hdr.id = GetWindowID(plv->hwnd);
    hdr.ptOrigin = plv->ptOrigin;
    hdr.clrBk = plv->clrBk;
    hdr.cItem = ListView_Count(plv);

    if (!Stream_Write(pstm, &hdr, sizeof(hdr)))
        return FALSE;

    for (i = 0; i < hdr.cItem; i++)
    {
        LV_ITEMHDR ihdr;
        LISTITEM FAR* pitem = ListView_FastGetItemPtr(plv, i);

        ihdr.pt.x = pitem->pt.x;
        ihdr.pt.y = pitem->pt.y;
        ihdr.state = pitem->state;
        ihdr.iImage = pitem->iImage;
        ihdr.iZOrder = ListView_ZOrderIndex(plv, i);

        if (!Stream_Write(pstm, &ihdr, sizeof(ihdr)))
            return FALSE;

        if (flags & LVRW_LPARAMS)
        {
            if (!Stream_Write(pstm, &pitem->lParam, sizeof(pitem->lParam)))
                return FALSE;
        }

        if (!Stream_WriteString(pstm, pitem->pszText))
            return FALSE;
    }

    if (flags & LVRW_FONT)
    {
    // REVIEW: Need to optionally write out log font...
    }

    if (flags & LVRW_ICONS)
    {
        if (!ImageList_Write(plv->himl, pstm))
            return FALSE;
    }

    if (flags & LVRW_SMALLICONS)
    {
        if (!ImageList_Write(plv->himlSmall, pstm))
            return FALSE;
    }

    if (!Stream_Flush(pstm))
        return FALSE;

    return TRUE;
}

HWND NEAR ListView_OnRead(STREAM FAR* pstm, LV_READINFO FAR* pinfo)
{
    HWND hwndLV;
    int i;
    LV* plv;
    LV_STREAMHDR hdr;
    BOOL fSuccess;
    UINT flags = pinfo->flags;

    fSuccess = FALSE;
    hwndLV = NULL;

    if (!Stream_Read(pstm, &hdr, sizeof(hdr)))
        return FALSE;

    if (hdr.magic != LV_MAGIC || hdr.flags != flags)
        return FALSE;

    // REVIEW: Could create window always with LVS_SHAREIMAGELISTS
    // so we don't have to destroy and recreate the imagelists
    // later.  Probably only a negligible speed savings, though.
    //
    hwndLV = CreateWindowEx(
            0L,                         // extendedStyle
            c_szListViewClass,          // class name
            NULL,                       // text
            WS_CHILD | (DWORD)hdr.style,
            0, 0, 0, 0,                 // x, y, cx, cy
            pinfo->hwndParent,                 // hwndParent
            (HMENU)hdr.id,              // child window id
            pinfo->hinst,                      // hInstance
            NULL);

    if (!hwndLV)
        return FALSE;

    plv = ListView_GetPtr(hwndLV);
    if (!plv)
        goto Error;

    plv->ptOrigin = hdr.ptOrigin;
    plv->clrBk = hdr.clrBk;

    // Grow the Z-order array to cItem items...
    //
    for (i = 0; i < hdr.cItem; i++)
    {
        // Add a non-NULL item so we can test return value
        // of ReplaceItem() later...
        //
        if (DPA_InsertPtr(plv->hdpaZOrder, i, (void FAR*)1) == -1)
            goto Error;
    }

    for (i = 0; i < hdr.cItem; i++)
    {
        int i2;
        LV_ITEMHDR ihdr;
        LV_ITEM item;
        LISTITEM FAR* pitem;
        LPTSTR pszText;

        if (!Stream_Read(pstm, &ihdr, sizeof(ihdr)))
            goto Error;

        item.mask = LVIF_ALL;
        item.pszText = NULL;
        item.state = 0;
        item.iImage = ihdr.iImage;
        item.lParam = 0L;

        pitem = ListView_CreateItem(plv, &item);
        if (!pitem)
            goto Error;

        if (flags & LVRW_LPARAMS)
        {
            if (!Stream_Read(pstm, &pitem->lParam, sizeof(pitem->lParam)))
                goto Error;
        }

        pszText = Stream_ReadString(pstm);
        if (!pszText)
        {
            ListView_FreeItem(plv, pitem);
            goto Error;
        }

        pitem->pt.y = (short)ihdr.pt.y;
        pitem->pt.x = (short)ihdr.pt.x;
        pitem->state = ihdr.state;
        pitem->pszText = pszText;

        // If sorted, then insert sorted.
        //
        i2 = i;
        if (plv->style & (LVS_SORTASCENDING | LVS_SORTDESCENDING))
            i2 = ListView_LookupString(plv, pszText, LVFI_SUBSTRING | LVFI_NEARESTXY, 0);

        if (DPA_InsertPtr(plv->hdpa, i2, (void FAR*)pitem) == -1)
        {
            ListView_FreeItem(plv, pitem);
            goto Error;
        }

        // Now set the Z order.
        //
        if (!DPA_SetPtr(plv->hdpaZOrder, ihdr.iZOrder, (void FAR*)i2))
            goto Error;
    }

    if (flags & LVRW_FONT)
    {
        // REVIEW: Need to read & setfont
    }

    if (flags & LVRW_ICONS)
    {
        ImageList_Destroy(plv->himl);

        plv->himl = ImageList_Read(pstm);
        if (!plv->himl)
            goto Error;
    }

    if (flags & LVRW_SMALLICONS)
    {
        ImageList_Destroy(plv->himlSmall);

        plv->himlSmall = ImageList_Read(pstm);
        if (!plv->himlSmall)
            goto Error;
    }

    plv->rcView.left = RECOMPUTE;

    // Instead of sending out a zillion creates (one for each item we just
    // created), just destroy and re-create ourselves.
    ListView_NotifyRecreate(plv);

    fSuccess = TRUE;

Error:
    if (!fSuccess && hwndLV)
    {
        DestroyWindow(hwndLV);
        hwndLV = NULL;
    }
    return hwndLV;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\lvsmall.c ===
// small icon view (positional view, not list)

#include "ctlspriv.h"
#include "listview.h"

int NEAR ListView_SItemHitTest(LV* plv, int x, int y, UINT FAR* pflags, int *piSubItem)
{

    int iHit;
    UINT flags;
    POINT pt;
    RECT rcState;
    RECT rcLabel;
    RECT rcIcon;

    if (piSubItem)
        *piSubItem = 0;

    // Map window-relative coordinates to view-relative coords...
    //
    pt.x = x + plv->ptOrigin.x;
    pt.y = y + plv->ptOrigin.y;

    // If we find an uncomputed item, recompute them all now...
    //
    if (plv->rcView.left == RECOMPUTE)
        ListView_Recompute(plv);

    flags = 0;

    if (ListView_IsOwnerData( plv ))
    {
        int cSlots;
        POINT ptWnd;
        LISTITEM item;

        cSlots = ListView_GetSlotCount( plv, TRUE );
        iHit = ListView_CalcHitSlot( plv, pt, cSlots );
        ListView_SGetRectsOwnerData( plv, iHit, &rcIcon, &rcLabel, &item, FALSE );
        ptWnd.x = x;
        ptWnd.y = y;

        if (PtInRect(&rcIcon, ptWnd))
        {
            flags = LVHT_ONITEMICON;
        }
        else if (PtInRect(&rcLabel, ptWnd))
        {
            flags = LVHT_ONITEMLABEL;
        }
    }
    else
    {
        for (iHit = 0; iHit < ListView_Count(plv); iHit++)
        {
            LISTITEM FAR* pitem = ListView_FastGetZItemPtr(plv, iHit);
            POINT ptItem;

            ptItem.x = pitem->pt.x;
            ptItem.y = pitem->pt.y;

            rcIcon.top    = ptItem.y;
            rcIcon.bottom = ptItem.y + plv->cyItem;

            rcLabel.top    = rcIcon.top;
            rcLabel.bottom = rcIcon.bottom;

            // Quick, easy rejection test...
            //
            if (pt.y < rcIcon.top || pt.y >= rcIcon.bottom)
                continue;

            rcIcon.left   = ptItem.x;
            rcIcon.right  = ptItem.x + plv->cxSmIcon;
            
            rcState.bottom = rcIcon.bottom;
            rcState.right = rcIcon.left;
            rcState.left = rcState.right - plv->cxState;
            rcState.top = rcState.bottom - plv->cyState;

            rcLabel.left   = rcIcon.right;
            rcLabel.right  = rcLabel.left + pitem->cxSingleLabel;

            if (PtInRect(&rcIcon, pt))
            {
                flags = LVHT_ONITEMICON;
            } else if (PtInRect(&rcLabel, pt))
            {
                flags = LVHT_ONITEMLABEL;
            } else if (PtInRect(&rcState, pt)) 
            {
                flags = LVHT_ONITEMSTATEICON;
            }
            
            if (flags)
                break;
        }
    }

    if (flags == 0)
    {
        flags = LVHT_NOWHERE;
        iHit = -1;
    }
    else
    {
      if (!ListView_IsOwnerData( plv ))
          iHit = DPA_GetPtrIndex(plv->hdpa, (void FAR*)ListView_FastGetZItemPtr(plv, iHit));
    }

    *pflags = flags;
    return iHit;
}


void NEAR ListView_SGetRectsOwnerData( LV* plv,
        int iItem,
        RECT FAR* prcIcon,
        RECT FAR* prcLabel,
        LISTITEM* pitem,
        BOOL fUsepitem )
{
    RECT rcIcon;
    RECT rcLabel;
    int cSlots;

    // calculate itemx, itemy, itemsSingleLabel from iItem
    cSlots = ListView_GetSlotCount( plv, TRUE );
    pitem->iWorkArea = 0;               // OwnerData doesn't support workareas
    ListView_SetIconPos( plv, pitem, iItem, cSlots );

    // calculate lable sizes
    // Note the rect we return should be the min of the size returned and the slot size...
    ListView_RecomputeLabelSize( plv, pitem, iItem, NULL, fUsepitem );

    rcIcon.left   = pitem->pt.x - plv->ptOrigin.x;
    rcIcon.right  = rcIcon.left + plv->cxSmIcon;
    rcIcon.top    = pitem->pt.y - plv->ptOrigin.y;
    rcIcon.bottom = rcIcon.top + plv->cyItem;
    *prcIcon = rcIcon;

    rcLabel.left   = rcIcon.right;
    if (pitem->cxSingleLabel < (plv->cxItem - plv->cxSmIcon))
        rcLabel.right  = rcLabel.left + pitem->cxSingleLabel;
    else
        rcLabel.right  = rcLabel.left + plv->cxItem - plv->cxSmIcon;
    rcLabel.top    = rcIcon.top;
    rcLabel.bottom = rcIcon.bottom;
    *prcLabel = rcLabel;
}


void NEAR ListView_SGetRects(LV* plv, LISTITEM FAR* pitem, RECT FAR* prcIcon, RECT FAR* prcLabel, LPRECT prcBounds)
{

    ASSERT( !ListView_IsOwnerData( plv ));

    if (pitem->pt.x == RECOMPUTE) {
        ListView_Recompute(plv);
    }

    prcIcon->left   = pitem->pt.x - plv->ptOrigin.x;
    prcIcon->right  = prcIcon->left + plv->cxSmIcon;
    prcIcon->top    = pitem->pt.y - plv->ptOrigin.y;
    prcIcon->bottom = prcIcon->top + plv->cyItem;

    prcLabel->left   = prcIcon->right;
    prcLabel->right  = prcLabel->left + pitem->cxSingleLabel;
    prcLabel->top    = prcIcon->top;
    prcLabel->bottom = prcIcon->bottom;
}

// Return the index of the first item >= *pszLookup.
//
int NEAR ListView_DoLookupString(LV* plv, LPCTSTR pszLookup, UINT flags, int iStart, int j)
{
    int i;
    BOOL fExact;
    int k;
    LISTITEM FAR* pitem;
    LISTITEM FAR* pitemLast = NULL;

    ASSERT( !ListView_IsOwnerData( plv ));

    fExact = FALSE;
    i = iStart;
    while ((i >= iStart) && (i < j))
    {
        int result;
        k = (i + j) / 2;
        pitem = ListView_FastGetItemPtr(plv, k);
        
        if (pitem == pitemLast)
            break;
        pitemLast = pitem;
        
        result = ListView_CompareString(plv, 
                k, pszLookup, flags, 0);

#ifdef MAINWIN
        // IEUNIX - Mainwin's lstrcmp is not compatable with WIN32.
        if(result < 0)
            result = -1;
        else if(result > 0)
            result = 1;
#endif

        if (plv->ci.style & LVS_SORTDESCENDING)
            result = -result;

        switch (result)
        {
        case 0:
            fExact = TRUE;
            // fall through
        case 1:
            j = k;
            break;
        case -1:
            i = k + 1;
            break;
        }
    }
    // For substrings, return index only if exact match was found.
    //
    if (!(flags & (LVFI_SUBSTRING | LVFI_PARTIAL)) && 
        !fExact)
        return -1;

    if (i < 0)
        i = 0;
    
    if ((!(flags & LVFI_NEARESTXY)) &&
        ListView_CompareString(plv, i, pszLookup, flags, 1)) {
        i = -1;
    }
    return i;
}

int NEAR ListView_LookupString(LV* plv, LPCTSTR pszLookup, UINT flags, int iStart)
{
    int iret;
    
    if (!pszLookup)
        return 0;
    
    iret = ListView_DoLookupString(plv, pszLookup, flags, iStart, ListView_Count(plv));
    if (iret == -1 && (flags & LVFI_WRAP)) {
        iret = ListView_DoLookupString(plv, pszLookup, flags, 0, iStart);
    }
    
    return iret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\lvlist.c ===
// list view (small icons, multiple columns)

#include "ctlspriv.h"
#include "listview.h"

#define COLUMN_VIEW

BOOL ListView_LDrawItem(PLVDRAWITEM plvdi)
{
    RECT rcIcon;
    RECT rcLabel;
    RECT rcBounds;
    RECT rcT;
    LV_ITEM item;
    TCHAR ach[CCHLABELMAX];
    LV* plv = plvdi->plv;
    int i = (int) plvdi->nmcd.nmcd.dwItemSpec;

    // moved here to reduce call backs in OWNERDATA case
    //
    item.iItem = i;
    item.iSubItem = 0;
    item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_STATE;
    item.stateMask = LVIS_ALL;
    item.pszText = ach;
    item.cchTextMax = ARRAYSIZE(ach);

    ListView_OnGetItem(plv, &item);

    ListView_LGetRects(plv, i, &rcIcon, &rcLabel, &rcBounds, NULL);

    if (!plvdi->prcClip || IntersectRect(&rcT, &rcBounds, plvdi->prcClip))
    {
        UINT fText;

        if (plvdi->lpptOrg)
        {
            OffsetRect(&rcIcon, plvdi->lpptOrg->x - rcBounds.left,
                                plvdi->lpptOrg->y - rcBounds.top);
            OffsetRect(&rcLabel, plvdi->lpptOrg->x - rcBounds.left,
                                plvdi->lpptOrg->y - rcBounds.top);
        }


        fText = ListView_DrawImage(plv, &item, plvdi->nmcd.nmcd.hdc,
            rcIcon.left, rcIcon.top, plvdi->flags) | SHDT_ELLIPSES;

        // Don't draw the label if it is being edited.
        if (plv->iEdit != i)
        {
            int ItemCxSingleLabel;
            UINT ItemState;

            if (ListView_IsOwnerData( plv ))
            {
               LISTITEM listitem;

               // calculate lable sizes from iItem
                   listitem.pszText = ach;
               ListView_RecomputeLabelSize( plv, &listitem, i, plvdi->nmcd.nmcd.hdc, TRUE );

               ItemCxSingleLabel = listitem.cxSingleLabel;
               ItemState = item.state;
            }
            else
            {
               ItemCxSingleLabel = plvdi->pitem->cxSingleLabel;
               ItemState = plvdi->pitem->state;
            }

            if (plvdi->flags & LVDI_TRANSTEXT)
                fText |= SHDT_TRANSPARENT;

            if (ItemCxSingleLabel == SRECOMPUTE) {
                ListView_RecomputeLabelSize(plv, plvdi->pitem, i, plvdi->nmcd.nmcd.hdc, FALSE);
                ItemCxSingleLabel = plvdi->pitem->cxSingleLabel;
            }

            if (ItemCxSingleLabel < rcLabel.right - rcLabel.left)
                rcLabel.right = rcLabel.left + ItemCxSingleLabel;

            if ((fText & SHDT_SELECTED) && (plvdi->flags & LVDI_HOTSELECTED))
                fText |= SHDT_HOTSELECTED;

#ifdef WINDOWS_ME
            if( plv->dwExStyle & WS_EX_RTLREADING)
                fText |= SHDT_RTLREADING;
#endif

            SHDrawText(plvdi->nmcd.nmcd.hdc, item.pszText, &rcLabel, LVCFMT_LEFT, fText,
                       plv->cyLabelChar, plv->cxEllipses,
                       plvdi->nmcd.clrText, plvdi->nmcd.clrTextBk);

            if ((plvdi->flags & LVDI_FOCUS) && (ItemState & LVIS_FOCUSED)
#ifdef KEYBOARDCUES
				&& !(CCGetUIState(&(plvdi->plv->ci)) & UISF_HIDEFOCUS)
#endif
					)
                DrawFocusRect(plvdi->nmcd.nmcd.hdc, &rcLabel);
        }
    }
    return TRUE;
}

DWORD ListView_LApproximateViewRect(LV* plv, int iCount, int iWidth, int iHeight)
{
    int cxItem = plv->cxItem;
    int cyItem = plv->cyItem;
    int cCols;
    int cRows;

    cRows = iHeight / cyItem;
    cRows = min(cRows, iCount);

    if (cRows == 0)
        cRows = 1;
    cCols = (iCount + cRows - 1) / cRows;

    iWidth = cCols * cxItem;
    iHeight = cRows * cyItem;

    return MAKELONG(iWidth + g_cxEdge, iHeight + g_cyEdge);
}



int NEAR ListView_LItemHitTest(LV* plv, int x, int y, UINT FAR* pflags, int *piSubItem)
{
    int iHit;
    int i;
    int iCol;
    int xItem; //where is the x in relation to the item
    UINT flags;
    LISTITEM FAR* pitem;

    if (piSubItem)
        *piSubItem = 0;

    flags = LVHT_NOWHERE;
    iHit = -1;

#ifdef COLUMN_VIEW
    i = y / plv->cyItem;
    if (i >= 0 && i < plv->cItemCol)
    {
        iCol = (x + plv->xOrigin) / plv->cxItem;
        i += iCol * plv->cItemCol;
        if (i >= 0 && i < ListView_Count(plv))
        {
            iHit = i;

            xItem = x + plv->xOrigin - iCol * plv->cxItem;
            if (xItem < plv->cxState) {
                flags = LVHT_ONITEMSTATEICON;
            } else if (xItem < (plv->cxState + plv->cxSmIcon)) {
                    flags = LVHT_ONITEMICON;
            }
            else
            {
            int ItemCxSingleLabel;

            if (ListView_IsOwnerData( plv ))
            {
               LISTITEM item;

               // calculate lable sizes from iItem
               ListView_RecomputeLabelSize( plv, &item, i, NULL, FALSE );
               ItemCxSingleLabel = item.cxSingleLabel;
            }
            else
            {
                pitem = ListView_FastGetItemPtr(plv, i);
                if (pitem->cxSingleLabel == SRECOMPUTE)
                {
                    ListView_RecomputeLabelSize(plv, pitem, i, NULL, FALSE);
                }
                ItemCxSingleLabel = pitem->cxSingleLabel;
            }

            if (xItem < (plv->cxSmIcon + plv->cxState + ItemCxSingleLabel))
                flags = LVHT_ONITEMLABEL;
            }
        }
    }
#else
    i = x / plv->cxItem;
    if (i < plv->cItemCol)
    {
        i += ((y + plv->xOrigin) / plv->cyItem) * plv->cItemCol;
        if (i < ListView_Count(plv))
        {
            iHit = i;
            flags = LVHT_ONITEMICON;
        }
    }
#endif

    *pflags = flags;
    return iHit;
}

void NEAR ListView_LGetRects(LV* plv, int i, RECT FAR* prcIcon,
        RECT FAR* prcLabel, RECT FAR *prcBounds, RECT FAR* prcSelectBounds)
{
    RECT rcIcon;
    RECT rcLabel;
    int x, y;
    int cItemCol = plv->cItemCol;

    if (cItemCol == 0)
    {
        // Called before other data has been initialized so call
        // update scrollbars which should make sure that that
        // we have valid data...
        ListView_UpdateScrollBars(plv);

        // but it's possible that updatescrollbars did nothing because of
        // LVS_NOSCROLL or redraw
        // BUGBUG raymondc v6.0:  Get it right even if no redraw. Fix for v6.
        if (plv->cItemCol == 0)
            cItemCol = 1;
        else
            cItemCol = plv->cItemCol;
    }

#ifdef COLUMN_VIEW
    x = (i / cItemCol) * plv->cxItem;
    y = (i % cItemCol) * plv->cyItem;
    rcIcon.left   = x - plv->xOrigin + plv->cxState;
    rcIcon.top    = y;
#else
    x = (i % cItemCol) * plv->cxItem;
    y = (i / cItemCol) * plv->cyItem;
    rcIcon.left   = x;
    rcIcon.top    = y - plv->xOrigin;
#endif

    rcIcon.right  = rcIcon.left + plv->cxSmIcon;
    rcIcon.bottom = rcIcon.top + plv->cyItem;

    if (prcIcon)
        *prcIcon = rcIcon;

    rcLabel.left  = rcIcon.right;
    rcLabel.right = rcIcon.left + plv->cxItem - plv->cxState;
    rcLabel.top   = rcIcon.top;
    rcLabel.bottom = rcIcon.bottom;
    if (prcLabel)
        *prcLabel = rcLabel;

    if (prcBounds)
    {
        *prcBounds = rcLabel;
        prcBounds->left = rcIcon.left - plv->cxState;
    }

    if (prcSelectBounds)
    {
        *prcSelectBounds = rcLabel;
        prcSelectBounds->left = rcIcon.left;
    }
}


void NEAR ListView_LUpdateScrollBars(LV* plv)
{
    RECT rcClient;
    int cItemCol;
    int cCol;
    int cColVis;
    SCROLLINFO si;

    ASSERT(plv);

    ListView_GetClientRect(plv, &rcClient, FALSE, NULL);

#ifdef COLUMN_VIEW
    cColVis = (rcClient.right - rcClient.left) / plv->cxItem;
    cItemCol = max(1, (rcClient.bottom - rcClient.top) / plv->cyItem);
#else
    cColVis = (rcClient.bottom - rcClient.top) / plv->cyItem;
    cItemCol = max(1, (rcClient.right - rcClient.left) / plv->cxItem);
#endif

    cCol     = (ListView_Count(plv) + cItemCol - 1) / cItemCol;

    // Make the client area smaller as appropriate, and
    // recompute cCol to reflect scroll bar.
    //
    si.cbSize = sizeof(SCROLLINFO);
    si.fMask = SIF_PAGE | SIF_RANGE | SIF_POS;
    si.nPage = cColVis;
    si.nMin = 0;

#ifdef COLUMN_VIEW
    rcClient.bottom -= ListView_GetCyScrollbar(plv);

    cItemCol = max(1, (rcClient.bottom - rcClient.top) / plv->cyItem);
    cCol = (ListView_Count(plv) + cItemCol - 1) / cItemCol;

    si.nPos = plv->xOrigin / plv->cxItem;
    si.nMax = cCol - 1;

    ListView_SetScrollInfo(plv, SB_HORZ, &si, TRUE);
#else
    rcClient.right -= ListView_GetCxScrollbar(plv);

    cItemCol = max(1, (rcClient.right - rcClient.left) / plv->cxItem);
    cCol = (ListView_Count(plv) + cItemCol - 1) / cItemCol;

    si.nPos = plv->xOrigin / plv->cyItem;
    si.nMax = cCol - 1;

    ListView_SetScrollInfo(plv, SB_VERT, &si, TRUE);
#endif

    // Update number of visible lines...
    //
    if (plv->cItemCol != cItemCol)
    {
        plv->cItemCol = cItemCol;
        InvalidateRect(plv->ci.hwnd, NULL, TRUE);
    }

    // make sure our position and page doesn't hang over max
    if ((si.nPos + (LONG)si.nPage - 1 > si.nMax) && si.nPos > 0) {
        int iNewPos, iDelta;
        iNewPos = (int)si.nMax - (int)si.nPage + 1;
        if (iNewPos < 0) iNewPos = 0;
        if (iNewPos != si.nPos) {
            iDelta = iNewPos - (int)si.nPos;
#ifdef COLUMN_VIEW
            ListView_LScroll2(plv, iDelta, 0, 0);
#else
            ListView_LScroll2(plv, 0, iDelta, 0);
#endif
            ListView_LUpdateScrollBars(plv);
        }
    }

    // never have the other scrollbar
#ifdef COLUMN_VIEW
    ListView_SetScrollRange(plv, SB_VERT, 0, 0, TRUE);
#else
    ListView_SetScrollRange(plv, SB_HORZ, 0, 0, TRUE);
#endif
}

//
//  We need a smoothscroll callback so our background image draws
//  at the correct origin.  If we don't have a background image,
//  then this work is superfluous but not harmful either.
//
int CALLBACK ListView_LScroll2_SmoothScroll(
    HWND hwnd,
    int dx,
    int dy,
    CONST RECT *prcScroll,
    CONST RECT *prcClip,
    HRGN hrgnUpdate,
    LPRECT prcUpdate,
    UINT flags)
{
    LV* plv = ListView_GetPtr(hwnd);
    if (plv)
    {
#ifdef COLUMN_VIEW
        plv->xOrigin -= dx;
#else
        plv->xOrigin -= dy;
#endif
    }

    // Now do what SmoothScrollWindow would've done if we weren't
    // a callback

    return ScrollWindowEx(hwnd, dx, dy, prcScroll, prcClip, hrgnUpdate, prcUpdate, flags);
}



void FAR PASCAL ListView_LScroll2(LV* plv, int dx, int dy, UINT uSmooth)
{
#ifdef COLUMN_VIEW
    if (dx)
    {
        dx *= plv->cxItem;

        {
            SMOOTHSCROLLINFO si;
            si.cbSize = sizeof(si);
            si.fMask = SSIF_SCROLLPROC;
            si.hwnd =plv->ci.hwnd ;
            si.dx =-dx ;
            si.dy = 0;
            si.lprcSrc = NULL;
            si.lprcClip = NULL;
            si.hrgnUpdate = NULL;
            si.lprcUpdate = NULL;
            si.fuScroll = SW_INVALIDATE | SW_ERASE;
            si.pfnScrollProc = ListView_LScroll2_SmoothScroll;
            SmoothScrollWindow(&si);
        }

        UpdateWindow(plv->ci.hwnd);
    }
#else
    if (dy)
    {

        dy *= plv->cyItem;

        {
            SMOOTHSCROLLINFO si;
            si.cbSize = sizeof(si);
            si.fMask = SSIF_SCROLLPROC;
            si.hwnd = plv->ci.hwnd;
            si.dx = 0;
            si.dy = -dy;
            si.lprcSrc = NULL;
            si.lprcClip = NULL;
            si.hrgnUpdate = NULL;
            si.lprcUpdate = NULL;
            si.fuScroll = SW_INVALIDATE | SW_ERASE;
            si.pfnScrollProc = ListView_LScroll2_SmoothScroll;

            SmoothScrollWindow(&si);
        }
        UpdateWindow(plv->ci.hwnd);
    }
#endif
}

void NEAR ListView_LOnScroll(LV* plv, UINT code, int posNew, UINT sb)
{
    RECT rcClient;
    int cPage;

    if (plv->hwndEdit)
        ListView_DismissEdit(plv, FALSE);

    ListView_GetClientRect(plv, &rcClient, TRUE, NULL);

#ifdef COLUMN_VIEW
    cPage = (rcClient.right - rcClient.left) / plv->cxItem;
    ListView_ComOnScroll(plv, code, posNew, SB_HORZ, 1,
                         cPage ? cPage : 1);
#else
    cPage = (rcClient.bottom - rcClient.top) / plv->cyItem;
    ListView_ComOnScroll(plv, code, posNew, SB_VERT, 1,
                         cPage ? cPage : 1);
#endif

}

int NEAR ListView_LGetScrollUnitsPerLine(LV* plv, UINT sb)
{
    return 1;
}

//------------------------------------------------------------------------------
//
// Function: ListView_LCalcViewItem
//
// Summary: This function will calculate which item slot is at the x, y location
//
// Arguments:
//    plv [in] -  The list View to work with
//    x [in] - The x location
//    y [in] - The y location
//
// Returns: the valid slot the point was within.
//
//  Notes:
//
//  History:
//    Nov-3-94 MikeMi   Created
//
//------------------------------------------------------------------------------

int ListView_LCalcViewItem( LV* plv, int x, int y )
{
   int iItem;
   int iRow = 0;
   int iCol = 0;

   ASSERT( plv );

#ifdef COLUMN_VIEW
   iRow = y / plv->cyItem;
   iRow = max( iRow, 0 );
   iRow = min( iRow, plv->cItemCol - 1 );
   iCol = (x + plv->xOrigin) / plv->cxItem;
   iItem = iRow + iCol * plv->cItemCol;

#else
   iCol = x / plv->cxItem;
   iCol = max( iCol, 0 );
   iCol = min( iCol, plv->cItemCol - 1 );
   iRow = (y + plv->xOrigin) / plv->cyItem;
   iItem = iCol + iRow * plv->cItemCol;

#endif

   iItem = max( iItem, 0 );
   iItem = min( iItem, ListView_Count(plv) - 1);

   return( iItem );
}

int LV_GetNewColWidth(LV* plv, int iFirst, int iLast)
{
    int cxMaxLabel = 0;

    // Don't do anything if there are no items to measure

    if (iFirst <= iLast)
    {
        LVFAKEDRAW lvfd;
        LV_ITEM lvitem;
        LISTITEM item;

        if (ListView_IsOwnerData( plv ))
        {
            int iViewFirst;
            int iViewLast;


            iViewFirst = ListView_LCalcViewItem( plv, 1, 1 );
            iViewLast = ListView_LCalcViewItem( plv,
                                               plv->sizeClient.cx - 1,
                                               plv->sizeClient.cy - 1 );
            if ((iLast - iFirst) > (iViewLast - iViewFirst))
            {
                iFirst = max( iFirst, iViewFirst );
                iLast = min( iLast, iViewLast );
            }

            iLast = min( ListView_Count( plv ), iLast );
            iFirst = max( 0, iFirst );
            iLast = max( iLast, iFirst );

            ListView_NotifyCacheHint( plv, iFirst, iLast );
        }

        ListView_BeginFakeCustomDraw(plv, &lvfd, &lvitem);
        lvitem.iSubItem = 0;
        lvitem.mask = LVIF_PARAM;
        item.lParam = 0;

        while (iFirst <= iLast)
        {
            LISTITEM FAR* pitem;

            if (ListView_IsOwnerData( plv ))
            {
                pitem = &item;
                pitem->cxSingleLabel = SRECOMPUTE;
            }
            else
            {
                pitem = ListView_FastGetItemPtr(plv, iFirst);
            }

            if (pitem->cxSingleLabel == SRECOMPUTE)
            {
                lvitem.iItem = iFirst;
                lvitem.lParam = pitem->lParam;
                ListView_BeginFakeItemDraw(&lvfd);
                ListView_RecomputeLabelSize(plv, pitem, iFirst, lvfd.nmcd.nmcd.hdc, FALSE);
                ListView_EndFakeItemDraw(&lvfd);
            }

            if (pitem->cxSingleLabel > cxMaxLabel)
                cxMaxLabel = pitem->cxSingleLabel;

            iFirst++;
        }

        ListView_EndFakeCustomDraw(&lvfd);
    }

    // We have the max label width, see if this plus the rest of the slop will
    // cause us to want to resize.
    //
    cxMaxLabel += plv->cxSmIcon + g_cxIconMargin + plv->cxState;
    if (cxMaxLabel > g_cxScreen)
        cxMaxLabel = g_cxScreen;

    return cxMaxLabel;
}


//------------------------------------------------------------------------------
// This function will see if the size of column should be changed for the listview
// It will check to see if the items between first and last exceed the current width
// and if so will see if the columns are currently big enough.  This wont happen
// if we are not currently in listview or if the caller has set an explicit size.
//
// OWNERDATA CHANGE
// This function is normally called with the complete list range,
// This will has been changed to be called only with currently visible
// to the user when in OWNERDATA mode.  This will be much more effiencent.
//
BOOL FAR PASCAL ListView_MaybeResizeListColumns(LV* plv, int iFirst, int iLast)
{
    HDC hdc = NULL;
    int cxMaxLabel;

    if (!ListView_IsListView(plv) || (plv->flags & LVF_COLSIZESET))
        return(FALSE);

    cxMaxLabel = LV_GetNewColWidth(plv, iFirst, iLast);

    // Now see if we should resize the columns...
    if (cxMaxLabel > plv->cxItem)
    {
        int iScroll = plv->xOrigin / plv->cxItem;
        TraceMsg(TF_LISTVIEW, "LV Resize Columns: %d", cxMaxLabel);
        ListView_ISetColumnWidth(plv, 0, cxMaxLabel, FALSE);
        plv->xOrigin = iScroll * plv->cxItem;
        return(TRUE);
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\mem.c ===
#include "ctlspriv.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"

#ifndef UNIX
#define SZ_DEBUGSECTION     "comctl32"
#define SZ_MODULE           "COMCTL32"
#else
#define SZ_DEBUGSECTION     "comctrl"
#define SZ_MODULE           "COMCTRL"
#endif

#define DECLARE_DEBUG
#include <debug.h>

//========== Memory Management =============================================


//----------------------------------------------------------------------------
// Define a Global Shared Heap that we use allocate memory out of that we
// Need to share between multiple instances.
#ifndef WINNT
HANDLE g_hSharedHeap = NULL;
#define GROWABLE        0
#define MAXHEAPSIZE     GROWABLE
#define HEAP_SHARED	0x04000000		/* put heap in shared memory */
#endif

void Mem_Terminate()
{
#ifndef WINNT
    // Assuming that everything else has exited
    //
    if (g_hSharedHeap != NULL)
        HeapDestroy(g_hSharedHeap);
    g_hSharedHeap = NULL;
#endif
}

#ifndef WINNT
HANDLE InitSharedHeap(void)
{
    ENTERCRITICAL;
    if (g_hSharedHeap == NULL)
    {
        g_hSharedHeap = HeapCreate(HEAP_SHARED, 1, MAXHEAPSIZE);
    }
    LEAVECRITICAL;
    return g_hSharedHeap;
}
#endif

void * WINAPI Alloc(long cb)
{
    // I will assume that this is the only one that needs the checks to
    // see if the heap has been previously created or not
#if defined(WINNT) || defined(MAINWIN)
    return (void *)LocalAlloc(LPTR, cb);
#else
    HANDLE hHeap = GetSharedHeapHandle();

    // If still NULL we have problems!
    if (hHeap == NULL)
        return(NULL);

    return HeapAlloc(hHeap, HEAP_ZERO_MEMORY, cb);
#endif
}

void * WINAPI ReAlloc(void * pb, long cb)
{
    if (pb == NULL)
        return Alloc(cb);
#if defined(WINNT) || defined(MAINWIN)
    return (void *)LocalReAlloc((HLOCAL)pb, cb, LMEM_ZEROINIT | LMEM_MOVEABLE);
#else
    return HeapReAlloc(g_hSharedHeap, HEAP_ZERO_MEMORY, pb, cb);
#endif
}

BOOL WINAPI Free(void * pb)
{
#if defined(WINNT) || defined(MAINWIN)
    return (LocalFree((HLOCAL)pb) == NULL);
#else
    return HeapFree(g_hSharedHeap, 0, pb);
#endif
}

DWORD_PTR WINAPI GetSize(void * pb)
{
#if defined(WINNT) || defined(MAINWIN)
    return LocalSize((HLOCAL)pb);
#else
    return HeapSize(g_hSharedHeap, 0, pb);
#endif
}

//----------------------------------------------------------------------------
// The following functions are for debug only and are used to try to
// calculate memory usage.
//
#ifdef DEBUG
typedef struct _HEAPTRACE
{
    DWORD   cAlloc;
    DWORD   cFailure;
    DWORD   cReAlloc;
    ULONG_PTR cbMaxTotal;
    DWORD   cCurAlloc;
    ULONG_PTR cbCurTotal;
} HEAPTRACE;

HEAPTRACE g_htShell = {0};      // Start of zero...

LPVOID WINAPI ControlAlloc(HANDLE hheap, DWORD cb)
{
    LPVOID lp = HeapAlloc(hheap, HEAP_ZERO_MEMORY, cb);;
    if (lp == NULL)
    {
        g_htShell.cFailure++;
        return NULL;
    }

    // Update counts.
    g_htShell.cAlloc++;
    g_htShell.cCurAlloc++;
    g_htShell.cbCurTotal += cb;
    if (g_htShell.cbCurTotal > g_htShell.cbMaxTotal)
        g_htShell.cbMaxTotal = g_htShell.cbCurTotal;

    return lp;
}

LPVOID WINAPI ControlReAlloc(HANDLE hheap, LPVOID pb, DWORD cb)
{
    LPVOID lp;
    SIZE_T cbOld;

    cbOld = HeapSize(hheap, 0, pb);

    lp = HeapReAlloc(hheap, HEAP_ZERO_MEMORY, pb,cb);
    if (lp == NULL)
    {
        g_htShell.cFailure++;
        return NULL;
    }

    // Update counts.
    g_htShell.cReAlloc++;
    g_htShell.cbCurTotal += cb - cbOld;
    if (g_htShell.cbCurTotal > g_htShell.cbMaxTotal)
        g_htShell.cbMaxTotal = g_htShell.cbCurTotal;

    return lp;
}

BOOL  WINAPI ControlFree(HANDLE hheap, LPVOID pb)
{
    SIZE_T cbOld = HeapSize(hheap, 0, pb);
    BOOL fRet = HeapFree(hheap, 0, pb);
    if (fRet)
    {
        // Update counts.
        g_htShell.cCurAlloc--;
        g_htShell.cbCurTotal -= cbOld;
    }

    return(fRet);
}

SIZE_T WINAPI ControlSize(HANDLE hheap, LPVOID pb)
{
    return (DWORD) HeapSize(hheap, 0, pb);
}
#endif  // DEBUG

#if defined(FULL_DEBUG) && defined(WIN32)
#include "../inc/deballoc.c"
#endif // defined(FULL_DEBUG) && defined(WIN32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\makefile.inc ===
..\commctrl.rc : $(SELFREGNAME)

!include $(CCSHELL_DIR)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\lvrept.c ===
// report view stuff (details)

#include "ctlspriv.h"
#include "listview.h"
#include <limits.h>

void ListView_RGetRectsEx(LV* plv, int iItem, int iSubItem, LPRECT prcIcon, LPRECT prcLabel);
int ListView_RXHitTest(LV* plv, int x);

void NEAR PASCAL ListView_RInitialize(LV* plv, BOOL fInval)
{
    MEASUREITEMSTRUCT mi;

    if (plv && (plv->ci.style & LVS_OWNERDRAWFIXED)) {

        int iOld = plv->cyItem;

        mi.CtlType = ODT_LISTVIEW;
        mi.CtlID = GetDlgCtrlID(plv->ci.hwnd);
        mi.itemHeight = plv->cyItem;  // default
        SendMessage(plv->ci.hwndParent, WM_MEASUREITEM, mi.CtlID, (LPARAM)(MEASUREITEMSTRUCT FAR *)&mi);
        plv->cyItem = max(mi.itemHeight, 1); // never let app set height=0 or we fault-o-rama!
        if (fInval && (iOld != plv->cyItem)) {
            RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
        }
    }
}

DWORD ListView_RApproximateViewRect(LV* plv, int iCount, int iWidth, int iHeight)
{
    RECT rc;

    ListView_RGetRects(plv, iCount, NULL, NULL, &rc, NULL);
    rc.bottom += plv->ptlRptOrigin.y;
    rc.right += plv->ptlRptOrigin.x;

    return MAKELONG(rc.right, rc.bottom);
}

void CCDrawRect(HDC hdc, int x, int y, int dx, int dy)
{
    RECT    rc;

    rc.left   = x;
    rc.top    = y;
    rc.right  = x + dx;
    rc.bottom = y + dy;

    ExtTextOut(hdc,0,0,ETO_OPAQUE,&rc,NULL,0,NULL);
}


void NEAR PASCAL ListView_RAfterRedraw(LV* plv, HDC hdc)
{
    if (plv->exStyle & LVS_EX_GRIDLINES) {
        int i;
        int x;
        COLORREF clrBk;

        clrBk = SetBkColor(hdc, g_clrBtnFace);

        x = -plv->ptlRptOrigin.x;
        for (i = 0 ; (i < plv->cCol) && (x < plv->sizeClient.cx); i++) {
            HD_ITEM hitem;

            hitem.mask = HDI_WIDTH;
            Header_GetItem(plv->hwndHdr,
                           SendMessage(plv->hwndHdr, HDM_ORDERTOINDEX, i, 0),
                           &hitem);
            x += hitem.cxy;

            if (x > 0) {
                CCDrawRect(hdc, x, 0, g_cxBorder, plv->sizeClient.cy);
            }
        }

        for (x = plv->yTop - 1; (x < plv->sizeClient.cy); x += plv->cyItem) {
            CCDrawRect(hdc, 0, x, plv->sizeClient.cx, g_cxBorder);
        }

        SetBkColor(hdc, clrBk);
    }
}


//
// Internal function to Get the CXLabel, taking into account if the listview
// has no item data and also if RECOMPUTE needs to happen.
//
SHORT NEAR PASCAL ListView_RGetCXLabel(LV* plv, int i, LISTITEM FAR* pitem,
        HDC hdc, BOOL fUseItem)
{
    SHORT cxLabel = SRECOMPUTE;


    if (!ListView_IsOwnerData( plv )) {

        cxLabel = pitem->cxSingleLabel;
    }

    if (cxLabel == SRECOMPUTE)
    {
        LISTITEM item;

        if (!pitem)
        {
            ASSERT(!fUseItem)
            pitem = &item;
            fUseItem = FALSE;
        }

        ListView_RecomputeLabelSize(plv, pitem, i, hdc, fUseItem);
        cxLabel = pitem->cxSingleLabel;

    }

    // add on the space around the label taken up by the select rect
    cxLabel += 2*g_cxLabelMargin;
    return(cxLabel);
}

//
// Returns FALSE if no more items to draw.
//
BOOL ListView_RDrawItem(PLVDRAWITEM plvdi)
{
    BOOL fDrawFocusRect = FALSE;
    RECT rcIcon;
    RECT rcLabel;
    RECT rcBounds;
    RECT rcT;
    LV* plv = plvdi->plv;
    int iCol = 0;
    LVITEM item;
    HDITEM hitem;
    TCHAR ach[CCHLABELMAX];
    UINT fText = 0;
    UINT uSubItemFlags;
    int iIndex = 0;

    int xOffset = 0;
    int yOffset = 0;

    ListView_RGetRects(plv, (int)plvdi->nmcd.nmcd.dwItemSpec, NULL, NULL, &rcBounds, NULL);

    if (rcBounds.bottom <= plv->yTop)
        return TRUE;

    if (plvdi->prcClip)
    {
        if (rcBounds.top >= plvdi->prcClip->bottom)
            return FALSE;       // no more items need painting.

        // Probably this condition won't happen very often...
        if (!IntersectRect(&rcT, &rcBounds, plvdi->prcClip))
            return TRUE;
    }


    // REVIEW: this would be faster if we did the GetClientRect
    // outside the loop.
    //
    if (rcBounds.top >= plv->sizeClient.cy)
        return FALSE;

    if (plvdi->lpptOrg)
    {
        xOffset = plvdi->lpptOrg->x - rcBounds.left;
        yOffset = plvdi->lpptOrg->y - rcBounds.top;
        OffsetRect(&rcBounds, xOffset, yOffset);
    }


    item.iItem = (int)plvdi->nmcd.nmcd.dwItemSpec;
    item.stateMask = LVIS_ALL;

    // for first ListView_OnGetItem call
    item.state = 0;

    if (plv->ci.style & LVS_OWNERDRAWFIXED) {
        goto SendOwnerDraw;
    }

    SetRectEmpty(&rcT);
    for (; iCol < plv->cCol; iCol++)
    {
        DWORD dwCustom = 0;
        UINT uImageFlags;

        iIndex = (int) SendMessage(plv->hwndHdr, HDM_ORDERTOINDEX, iCol, 0);

    SendOwnerDraw:

        if (iIndex == 0) {
            item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_STATE | LVIF_INDENT;
        } else {
            // Next time through, we only want text for subitems...
            item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_STATE;
        }

        item.iImage = -1;
        item.iSubItem = iIndex;
        item.pszText = ach;
        item.cchTextMax = ARRAYSIZE(ach);
        ListView_OnGetItem(plv, &item);

        uSubItemFlags = plvdi->flags;

        if (iIndex == 0) {

            // if it's owner draw, send off a message and return.
            // do this after we've collected state information above though
            if (plv->ci.style & LVS_OWNERDRAWFIXED) {
                DRAWITEMSTRUCT di = {0};
                di.CtlType = ODT_LISTVIEW;
                di.CtlID = GetDlgCtrlID(plv->ci.hwnd);
                di.itemID = (int)plvdi->nmcd.nmcd.dwItemSpec;
                di.itemAction = ODA_DRAWENTIRE;
                di.hwndItem = plv->ci.hwnd;
                di.hDC = plvdi->nmcd.nmcd.hdc;
                di.rcItem = rcBounds;
                if (plvdi->pitem)
                    di.itemData = plvdi->pitem->lParam;
                if (item.state & LVIS_FOCUSED) {
                    di.itemState |= ODS_FOCUS;
                }
                if (item.state & LVIS_SELECTED) {
                    di.itemState |= ODS_SELECTED;
                }
                SendMessage(plv->ci.hwndParent, WM_DRAWITEM, di.CtlID,
                            (LPARAM)(DRAWITEMSTRUCT FAR *)&di);
                return TRUE;
            }

        }

        hitem.mask = HDI_WIDTH | HDI_FORMAT;
        Header_GetItem(plv->hwndHdr, iIndex, &hitem);

        // first get the rects...
        ListView_RGetRectsEx(plv, (int)plvdi->nmcd.nmcd.dwItemSpec, iIndex, &rcIcon, &rcLabel);
        OffsetRect(&rcIcon, xOffset, yOffset);
        OffsetRect(&rcLabel, xOffset, yOffset);

        if (plvdi->dwCustom & CDRF_NOTIFYSUBITEMDRAW) {
            RECT rcTemp;
            UINT uItemStateOld = plvdi->nmcd.nmcd.uItemState, uItemStateNew;
            SendMessage(plv->hwndHdr, HDM_GETITEMRECT, iIndex, (LPARAM)&rcTemp);
            plvdi->nmcd.nmcd.rc.left = rcTemp.left;
            plvdi->nmcd.nmcd.rc.right = rcTemp.right;
            plvdi->nmcd.iSubItem = iIndex;

            // Note: IE4 didn't reset nmcd.clrText or nmcd.clrTextBk
            // before each subitem.  This is arguably a bug, but we
            // shipped that way so I guess we're stuck with it.
            dwCustom = CICustomDrawNotify(&plvdi->plv->ci, CDDS_SUBITEM | CDDS_ITEMPREPAINT, &plvdi->nmcd.nmcd);

            uItemStateNew = plvdi->nmcd.nmcd.uItemState;
            plvdi->nmcd.nmcd.uItemState = uItemStateOld;

            if (dwCustom & CDRF_SKIPDEFAULT)
                continue;

            uSubItemFlags &= ~(LVDI_FOCUS | LVDI_SELECTED | LVDI_SELECTNOFOCUS | LVDI_HOTSELECTED);
            if (uItemStateNew & CDIS_FOCUS)
                uSubItemFlags |= LVDI_FOCUS;

            if (uItemStateNew & CDIS_SELECTED) {
                if (plvdi->plv->flags & LVF_FOCUSED)
                    uSubItemFlags |= LVDI_SELECTED;
                else
                    uSubItemFlags |= LVDI_SELECTNOFOCUS;
                if (plvdi->plv->iHot == (int)plvdi->nmcd.nmcd.dwItemSpec)
                    uSubItemFlags |= LVDI_HOTSELECTED;
            }
        }

        if (iIndex != 0)
        {
            // for right now, add this in because the get rects for
            // non 0 doesn't account for the icon (yet)
            if (item.iImage != -1)
                rcLabel.left += plv->cxSmIcon;

        }

        uImageFlags = uSubItemFlags;

        if (item.iImage == -1) {

            if (iIndex != 0)
                // just use ListView_DrawImage to get the fText
                uImageFlags |= LVDI_NOIMAGE;

        }
        else if (ListView_FullRowSelect(plv) && iCol)
        {
            int iLeft = rcIcon.left;
            int iRight = rcIcon.right;
            // for full row select when the icon is not in the first column,
            // we need to explicitly paint the background so focus rect
            // remnants aren't left behind (jeffbog -- 07/09/96)

            /// need to deal with the state image if index == 0.
            // all the otehr columns don't have state images.
            if (iIndex == 0) {
                rcIcon.left -= plv->cxState + g_cxEdge;
            }
            rcIcon.right = rcLabel.right;
            FillRect(plvdi->nmcd.nmcd.hdc, &rcIcon, plv->hbrBk);

            rcIcon.left = iLeft;
            rcIcon.right = iRight;
        }

        fText = ListView_DrawImageEx(plv, &item, plvdi->nmcd.nmcd.hdc,
                                   rcIcon.left, rcIcon.top, uSubItemFlags, rcLabel.right);

        if (ListView_FullRowSelect(plv) && (uSubItemFlags & LVDI_FOCUS)) {
            // if we're doing a full row selection, collect the union
            // of the labels for the focus rect
            UnionRect(&rcT, &rcT, &rcLabel);
        }

        if (item.pszText)
        {
            int xLabelRight = rcLabel.right;
            UINT textflags;

            // give all but the first columns extra margins so
            // left and right justified things don't stick together

            textflags = (iIndex == 0) ? SHDT_ELLIPSES : SHDT_ELLIPSES | SHDT_EXTRAMARGIN;

            // rectangle limited to the size of the string
            textflags |= fText;

            if ((!ListView_FullRowSelect(plv)) &&
                ((fText & (SHDT_SELECTED | SHDT_SELECTNOFOCUS)) || (item.state & LVIS_FOCUSED)))
            {
                int cxLabel;

                // if selected or focused, the rectangle is more
                // meaningful and should correspond to the string
                //
                if (iIndex == 0) {
                    LISTITEM litem;
                    LISTITEM FAR *pitem = plvdi->pitem;

                    if (!pitem) {
                        pitem = &litem;
                        litem.pszText = item.pszText;
                    }
                    cxLabel = ListView_RGetCXLabel(plv, (int)plvdi->nmcd.nmcd.dwItemSpec, pitem, plvdi->nmcd.nmcd.hdc, TRUE);
                } else {
                    // add g_cxLabelMargin * 6 because we use SHDT_EXTRAMARGIN
                    // on iIndex != 0
                    // and if you look inside shdrawtext, there are 6 cxlabelmargins added...
                    cxLabel = ListView_OnGetStringWidth(plv, item.pszText, plvdi->nmcd.nmcd.hdc) + g_cxLabelMargin * 6;
                }

                if (rcLabel.right > rcLabel.left + cxLabel)
                {
                    rcLabel.right = rcLabel.left + cxLabel;
                }
            }

            if ((iIndex != 0) || (plv->iEdit != (int)plvdi->nmcd.nmcd.dwItemSpec))
            {
                COLORREF clrText;
                HFONT hFontTemp = NULL;
                int cxEllipses;

                clrText = plvdi->nmcd.clrText;
                if ((clrText == GetSysColor(COLOR_HOTLIGHT)) ||
                    ((plv->exStyle & LVS_EX_UNDERLINEHOT) &&
                     ((plv->exStyle & LVS_EX_ONECLICKACTIVATE) ||
                      ((plvdi->plv->exStyle & LVS_EX_TWOCLICKACTIVATE) &&
                       ListView_OnGetItemState(plvdi->plv, (int) plvdi->nmcd.nmcd.dwItemSpec, LVIS_SELECTED))))) {
                    if (iIndex != 0 && !ListView_FullRowSelect(plv)) {

                        hFontTemp = SelectFont(plvdi->nmcd.nmcd.hdc, plv->hfontLabel);
                        if (hFontTemp != plv->hFontHot) {
                            // they've overridden... leave it.
                            SelectFont(plvdi->nmcd.nmcd.hdc, hFontTemp);
                            hFontTemp = NULL;
                        }
                        clrText = plv->clrText;
                    }
                }


                if ((textflags & SHDT_SELECTED) && (uSubItemFlags & LVDI_HOTSELECTED))
                    textflags |= SHDT_HOTSELECTED;

                //TraceMsg(TF_LISTVIEW, "LISTVIEW: SHDrawText called.  style = %lx, WS_DISABLED = %lx, plvdi->clrBk = %lx, plvdi->nmcd.clrTextBk = %lx", (DWORD)plv->ci.style, (DWORD)WS_DISABLED, plvdi->clrBk, plvdi->nmcd.clrTextBk);

#ifdef WINDOWS_ME
                if( plv->dwExStyle & WS_EX_RTLREADING)
                {
                    //
                    // temp hack for the find.files to see if LtoR/RtoL mixing
                    // works. if ok, we'll take this out and make that lv ownerdraw
                    //
                    if ((item.pszText[0] != '\xfd') && (item.pszText[lstrlen(item.pszText)-1] != '\xfd'))
                        textflags |= SHDT_RTLREADING;
                }
#endif

                //
                //  If the app customized the font, we need to get the new
                //  ellipsis size.  We could try to optimize not doing this
                //  if ellipses aren't needed, but tough.  That's what you
                //  get if you use customdraw.
                //
                if ((plvdi->dwCustom | dwCustom) & CDRF_NEWFONT)
                {
                    SIZE siz;
                    GetTextExtentPoint(plvdi->nmcd.nmcd.hdc, c_szEllipses, CCHELLIPSES, &siz);
                    cxEllipses = siz.cx;
                }
                else
                    cxEllipses = plv->cxEllipses;

                SHDrawText(plvdi->nmcd.nmcd.hdc, item.pszText, &rcLabel,
                           hitem.fmt & HDF_JUSTIFYMASK, textflags,
                           plv->cyLabelChar, cxEllipses,
                           clrText, plvdi->nmcd.clrTextBk);

                // draw a focus rect on the first column of a focus item
                if ((uSubItemFlags & LVDI_FOCUS) && (item.state & LVIS_FOCUSED)
#ifdef KEYBOARDCUES
                    && !(CCGetUIState(&(plvdi->plv->ci)) & UISF_HIDEFOCUS)
#endif
                            )
                    {
                        if (ListView_FullRowSelect(plv)) {
                            fDrawFocusRect = TRUE;
                    } else {
                        DrawFocusRect(plvdi->nmcd.nmcd.hdc, &rcLabel);
                    }
                }

                // If we didn't SHDrawText into the full label rectangle
                // (because the selection or focus rectangle seemed more
                // applicable), draw emptiness into the unused part so
                // garbage doesn't show through.  Use SHDrawText so we
                // draw in exactly the same way that the rest of the code does.

                if (rcLabel.right < xLabelRight)
                {
                    rcLabel.left = rcLabel.right;
                    rcLabel.right = xLabelRight;
                    SHDrawText(plvdi->nmcd.nmcd.hdc, c_szNULL, &rcLabel,
                               LVCFMT_LEFT,
                               textflags & SHDT_TRANSPARENT,
                               plv->cyLabelChar, cxEllipses,
                               clrText, plvdi->nmcd.clrTextBk);

                }


                // restore the font
                if (hFontTemp)
                    SelectFont(plvdi->nmcd.nmcd.hdc, hFontTemp);


            }
        }

        if (dwCustom & CDRF_NOTIFYPOSTPAINT) {
            CICustomDrawNotify(&plvdi->plv->ci, CDDS_SUBITEM | CDDS_ITEMPOSTPAINT, &plvdi->nmcd.nmcd);
        }
    }

    if (fDrawFocusRect) {
       DrawFocusRect(plvdi->nmcd.nmcd.hdc, &rcT);
    }

    return TRUE;
}
#ifndef HDS_FULLDRAG
#define HDS_FULLDRAG 0x0080
#endif

BOOL_PTR NEAR ListView_CreateHeader(LV* plv)
{
    // enable drag drop always here... just fail the notify
    // if the bit in listview isn't set
    DWORD dwStyle = HDS_HORZ | WS_CHILD | HDS_DRAGDROP;

    if (plv->ci.style & LVS_NOCOLUMNHEADER)
        dwStyle |= HDS_HIDDEN;
    if (!(plv->ci.style & LVS_NOSORTHEADER))
        dwStyle |= HDS_BUTTONS;

    dwStyle |= HDS_FULLDRAG;

    plv->hwndHdr = CreateWindowEx(0L, c_szHeaderClass, // WC_HEADER,
        NULL, dwStyle, 0, 0, 0, 0, plv->ci.hwnd, (HMENU)LVID_HEADER, GetWindowInstance(plv->ci.hwnd), NULL);

    if (plv->hwndHdr) {

#ifdef POST_BETA
        NMLVHEADERCREATED nmhc;

        nmhc.hwndHdr = plv->hwndHdr;
        // some apps blow up if a notify is sent before the control is fully created.
        CCSendNotify(&plv->ci, LVN_HEADERCREATED, &nmhc.hdr);
        plv->hwndHdr = nmhc.hwndHdr;
#endif

        FORWARD_WM_SETFONT(plv->hwndHdr, plv->hfontLabel, FALSE, SendMessage);
        if (plv->himlSmall)
            SendMessage(plv->hwndHdr, HDM_SETIMAGELIST, 0, (LPARAM)plv->himlSmall);
    }
    return (BOOL_PTR)plv->hwndHdr;
}

#ifdef UNICODE
int NEAR ListView_OnInsertColumnA(LV* plv, int iCol, LV_COLUMNA * pcol) {
    LPWSTR pszW = NULL;
    LPSTR pszC = NULL;
    int iRet;

    //HACK ALERT -- this code assumes that LV_COLUMNA is exactly the same
    // as LV_COLUMNW except for the pointer to the string.
    ASSERT(sizeof(LV_COLUMNA) == sizeof(LV_COLUMNW));

    if (!pcol)
        return -1;

    if ((pcol->mask & LVCF_TEXT) && (pcol->pszText != NULL)) {
        pszC = pcol->pszText;
        if ((pszW = ProduceWFromA(plv->ci.uiCodePage, pszC)) == NULL)
        {
#ifdef UNICODE_WIN9x
            // Hack for HP SytemSoft SystemWizard (ANSLIST.OCX), which they
            // preinstall on their OEM machines.  They pass an uninitialized
            // variable, and in IE4, they got lucky and it was a valid
            // pointer.  IE5, they're not so lucky.  In IE4, if you passed
            // a bad pointer to LVM_INSERTCOLUMN, it faulted, so "fixing
            // up" the pointer won't mess up anybody who was relying on the
            // old behavior.
            pcol->pszText = (LPSTR)c_szNULL;
#else
            // NT's IE4 returned -1, so we keep doing it in IE5.
            return -1;
#endif
        } else {
            pcol->pszText = (LPSTR)pszW;
        }
    }

    iRet = ListView_OnInsertColumn(plv, iCol, (const LV_COLUMN FAR*) pcol);

    if (pszW != NULL) {
        pcol->pszText = pszC;

        FreeProducedString(pszW);
    }

    return iRet;
}
#endif

int NEAR ListView_OnInsertColumn(LV* plv, int iCol, const LV_COLUMN FAR* pcol)
{
    int idpa = -1;
    HD_ITEM item;

    ASSERT(LVCFMT_LEFT == HDF_LEFT);
    ASSERT(LVCFMT_RIGHT == HDF_RIGHT);
    ASSERT(LVCFMT_CENTER == HDF_CENTER);

    if (iCol < 0 || !pcol)
        return -1;

    if (!plv->hwndHdr && !ListView_CreateHeader(plv))
        return -1;

    item.mask    = (HDI_WIDTH | HDI_HEIGHT | HDI_FORMAT | HDI_LPARAM);

    if (pcol->mask & LVCF_IMAGE) {
        // do this only if this bit is set so that we don't fault on
        // old binaries
        item.iImage  = pcol->iImage;
        item.mask |= HDI_IMAGE;
    }

    if (pcol->mask & LVCF_TEXT) {
        item.pszText = pcol->pszText;
        item.mask |= HDI_TEXT;
    }

    if (pcol->mask & LVCF_ORDER) {
        item.iOrder = pcol->iOrder;
        item.mask |= HDI_ORDER;
    }


    item.cxy     = pcol->mask & LVCF_WIDTH ? pcol->cx : 10; // some random default
    item.fmt     = ((pcol->mask & LVCF_FMT) && (iCol > 0)) ? pcol->fmt : LVCFMT_LEFT;
    item.hbm     = NULL;

    item.lParam = pcol->mask & LVCF_SUBITEM ? pcol->iSubItem : 0;

    // Column 0 refers to the item list.  If we've already added a
    // column, make sure there are plv->cCol - 1 subitem ptr slots
    // in hdpaSubItems...
    //
    if (plv->cCol > 0)
    {
        if (!plv->hdpaSubItems)
        {
            plv->hdpaSubItems = DPA_CreateEx(8, plv->hheap);
            if (!plv->hdpaSubItems)
                return -1;
        }

        // WARNING:  the max(0, iCol-1) was min in Win95, which was
        // just wrong.  hopefully(!) no one has relied on this brokeness
        // if so, we may have to version switch it.
        idpa = DPA_InsertPtr(plv->hdpaSubItems, max(0, iCol - 1), NULL);
        if (idpa == -1)
            return -1;
    }

    iCol = Header_InsertItem(plv->hwndHdr, iCol, &item);
    if (iCol == -1)
    {
        if (plv->hdpaSubItems && (idpa != -1))
            DPA_DeletePtr(plv->hdpaSubItems, idpa);
        return -1;
    }
    plv->xTotalColumnWidth = RECOMPUTE;
    plv->cCol++;
    ListView_UpdateScrollBars(plv);
    if (ListView_IsReportView(plv) && ListView_RedrawEnabled(plv)) {
        RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_ERASE | RDW_INVALIDATE);
    }
    return iCol;
}

int NEAR ListView_FreeColumnData(LPVOID d, LPVOID p)
{
    PLISTSUBITEM plsi = (PLISTSUBITEM)d;
    ListView_FreeSubItem(plsi);
    return 1;
}


BOOL NEAR ListView_OnDeleteColumn(LV* plv, int iCol)
{
    if (iCol < 0 || iCol >= plv->cCol)    // validate column index
    {
        RIPMSG(0, "LVM_DELETECOLUMN: Invalid column index: %d", iCol);
        return FALSE;
    }

    if (plv->hdpaSubItems)
    {
        int iDeleteColumn = -1;  // Default to "can't delete column".

        if (0 < iCol) {
            iDeleteColumn = iCol; // Deleting col 1+.  Simple delete OK.
        }
        else if (5 <= plv->ci.iVersion) {
            //
            // Version 5 and later can delete column 0.  Prior versions can't.
            //
            if (1 < plv->cCol && !ListView_IsOwnerData(plv)) {
                // if deleting column 0,
                // we have to do something a little special...
                // set all item 0 strings to what column 1 has and
                // delete column 1
                int i;
                int iCount = ListView_Count(plv);
                for (i = 0; i < iCount; i++) {

                    LISTSUBITEM lsi;
                    LVITEM lvi;
                    ListView_GetSubItem(plv, i, 1, &lsi);
                    lvi.iSubItem = 0;
                    lvi.iItem = i;
                    lvi.mask = LVIF_TEXT | LVIF_IMAGE;
                    lvi.iImage = lsi.iImage;
                    lvi.pszText = lsi.pszText;
                    lvi.state = lsi.state;
                    lvi.stateMask = 0xffffffff;
                    ListView_OnSetItem(plv, &lvi);
                }
                iDeleteColumn = 1;
            }
        }

        if (0 < iDeleteColumn) {
            HDPA hdpa = (HDPA)DPA_DeletePtr(plv->hdpaSubItems, iDeleteColumn - 1);
            DPA_DestroyCallback(hdpa, ListView_FreeColumnData, 0);
        }
    }

    if (!Header_DeleteItem(plv->hwndHdr, iCol))
        return FALSE;

    plv->cCol--;
    plv->xTotalColumnWidth = RECOMPUTE;
    ListView_UpdateScrollBars(plv);

    if (ListView_IsReportView(plv) && ListView_RedrawEnabled(plv)) {
        RedrawWindow(plv->ci.hwnd, NULL, NULL, RDW_ERASE | RDW_INVALIDATE);
    }
    return TRUE;
}

int NEAR ListView_RGetColumnWidth(LV* plv, int iCol)
{
    HD_ITEM item;

    item.mask = HDI_WIDTH;

    Header_GetItem(plv->hwndHdr, iCol, &item);

    return item.cxy;
}

// The FakeCustomDraw functions are used when you want the customdraw client
// to set up a HDC so you can do stuff like GetTextExtent.
//
//  Usage:
//
//      LVFAKEDRAW lvfd;
//      LV_ITEM item;
//      ListView_BeginFakeCustomDraw(plv, &lvfd, &item);
//      for each item you care about {
//          item.iItem = iItem;
//          item.iItem = iSubItem;
//          item.lParam = <item lParam>; // use ListView_OnGetItem to get it
//          ListView_BeginFakeItemDraw(&lvfd);
//          <party on the HDC in lvfd.nmcd.nmcd.hdc>
//          ListView_EndFakeItemDraw(&lvfd);
//      }
//      ListView_EndFakeCustomDraw(&lvfd);
//

void ListView_BeginFakeCustomDraw(LV* plv, PLVFAKEDRAW plvfd, LV_ITEM *pitem)
{
    plvfd->nmcd.nmcd.hdc = GetDC(plv->ci.hwnd);
    plvfd->nmcd.nmcd.uItemState = 0;
    plvfd->nmcd.nmcd.dwItemSpec = 0;
    plvfd->nmcd.nmcd.lItemlParam = 0;
    plvfd->hfontPrev = SelectFont(plvfd->nmcd.nmcd.hdc, plv->hfontLabel);

    //
    //  Since we aren't actually painting anything, we pass an empty
    //  paint rectangle.  Gosh, I hope no app faults when it sees an
    //  empty paint rectangle.
    //
    SetRectEmpty(&plvfd->nmcd.nmcd.rc);

    plvfd->plv = plv;
    plvfd->dwCustomPrev = plv->ci.dwCustom;
    plvfd->pitem = pitem;

    plv->ci.dwCustom = CIFakeCustomDrawNotify(&plv->ci, CDDS_PREPAINT, &plvfd->nmcd.nmcd);
}

DWORD ListView_BeginFakeItemDraw(PLVFAKEDRAW plvfd)
{
    LV *plv = plvfd->plv;
    LV_ITEM *pitem;

    // Early-out:  If client doesn't use CustomDraw, then stop immediately.
    if (!(plv->ci.dwCustom & CDRF_NOTIFYITEMDRAW))
        return CDRF_DODEFAULT;

    pitem = plvfd->pitem;

        // Note that if the client says CDRF_SKIPDEFAULT (i.e., is owner-draw)
    // we measure the item anyway, because that's what IE4 did.

    // Make sure we do have the lParam.  Office will fault if you give
    // bogus lParams during customdraw callbacks.
    plvfd->nmcd.nmcd.dwItemSpec = pitem->iItem;
    if (ListView_IsOwnerData(plv))
    {
        // OwnerData always gets lItemlParam = 0
        ASSERT(plvfd->nmcd.nmcd.lItemlParam == 0);  // should still be 0
    } else {
        ASSERT(pitem->mask & LVIF_PARAM);
        plvfd->nmcd.nmcd.lItemlParam = pitem->lParam;
    }

    if (!(plv->ci.dwCustom & CDRF_SKIPDEFAULT)) {
        plvfd->nmcd.iSubItem = 0;
        plvfd->dwCustomItem = CIFakeCustomDrawNotify(&plv->ci, CDDS_ITEMPREPAINT, &plvfd->nmcd.nmcd);
    } else {
        plvfd->dwCustomItem = CDRF_DODEFAULT;
    }

    //
    //  Only report view supports sub-items.
    //
    if (!ListView_IsReportView(plv))
        plvfd->dwCustomItem &= ~CDRF_NOTIFYSUBITEMDRAW;

    if (plvfd->dwCustomItem & CDRF_NOTIFYSUBITEMDRAW) {
        plvfd->nmcd.iSubItem = pitem->iSubItem;
        plvfd->dwCustomSubItem = CIFakeCustomDrawNotify(&plv->ci, CDDS_SUBITEM | CDDS_ITEMPREPAINT, &plvfd->nmcd.nmcd);
    } else {
        plvfd->dwCustomSubItem = CDRF_DODEFAULT;
    }

    return plvfd->dwCustomItem | plvfd->dwCustomSubItem;
}

void ListView_EndFakeItemDraw(PLVFAKEDRAW plvfd)
{
    LV *plv = plvfd->plv;

    // Early-out:  If client doesn't use CustomDraw, then stop immediately.
    if (!(plv->ci.dwCustom & CDRF_NOTIFYITEMDRAW))
        return;

    if (!(plvfd->dwCustomSubItem & CDRF_SKIPDEFAULT) &&
         (plvfd->dwCustomSubItem & CDRF_NOTIFYPOSTPAINT)) {
        ASSERT(plvfd->dwCustomItem & CDRF_NOTIFYSUBITEMDRAW);
        ASSERT(plvfd->nmcd.iSubItem == plvfd->pitem->iSubItem);
        CIFakeCustomDrawNotify(&plv->ci, CDDS_SUBITEM | CDDS_ITEMPOSTPAINT, &plvfd->nmcd.nmcd);
    }

    if ((plvfd->dwCustomItem | plvfd->dwCustomSubItem) & CDRF_NEWFONT) // App changed font, so
        SelectFont(plvfd->nmcd.nmcd.hdc, plv->hfontLabel);   // restore default font

    if (!(plvfd->dwCustomItem & CDRF_SKIPDEFAULT) &&
         (plvfd->dwCustomItem & CDRF_NOTIFYPOSTPAINT)) {
        plvfd->nmcd.iSubItem = 0;
        CIFakeCustomDrawNotify(&plv->ci, CDDS_ITEMPOSTPAINT, &plvfd->nmcd.nmcd);
    }
}

void ListView_EndFakeCustomDraw(PLVFAKEDRAW plvfd)
{
    LV *plv = plvfd->plv;

    // notify parent afterwards if they want us to
    if (!(plv->ci.dwCustom & CDRF_SKIPDEFAULT) &&
        plv->ci.dwCustom & CDRF_NOTIFYPOSTPAINT) {
        CIFakeCustomDrawNotify(&plv->ci, CDDS_POSTPAINT, &plvfd->nmcd.nmcd);
    }

    // Restore previous state
    plv->ci.dwCustom = plvfd->dwCustomPrev;

    SelectObject(plvfd->nmcd.nmcd.hdc, plvfd->hfontPrev);
    ReleaseDC(plv->ci.hwnd, plvfd->nmcd.nmcd.hdc);
}


BOOL NEAR PASCAL hasVertScroll
(
    LV* plv
)
{
    RECT rcClient;
    RECT rcBounds;
    int cColVis;
    BOOL fHorSB;

    // Get the horizontal bounds of the items.
    ListView_GetClientRect(plv, &rcClient, FALSE, NULL);
    ListView_RGetRects(plv, 0, NULL, NULL, &rcBounds, NULL);
    fHorSB = (rcBounds.right - rcBounds.left > rcClient.right);
    cColVis = (rcClient.bottom - plv->yTop -
               (fHorSB ? ListView_GetCyScrollbar(plv) : 0)) / plv->cyItem;

    // check to see if we need a vert scrollbar
    if ((int)cColVis < ListView_Count(plv))
        return(TRUE);
    else
        return(FALSE);
}

BOOL NEAR ListView_RSetColumnWidth(LV* plv, int iCol, int cx)
{
    HD_ITEM item;
    HD_ITEM colitem;

    SIZE    siz;

    LV_ITEM lviItem;
    int     i;
    int     ItemWidth = 0;
    int     HeaderWidth = 0;
    TCHAR   szLabel[CCHLABELMAX + 4];      // CCHLABLEMAX == MAX_PATH
    int     iBegin;
    int     iEnd;

    // Should we compute the width based on the widest string?
    // If we do, include the Width of the Label, and if this is the
    // Last column, set the width so the right side is at the list view's right edge
    if (cx <= LVSCW_AUTOSIZE)
    {
        LVFAKEDRAW lvfd;                    // in case client uses customdraw

        if (cx == LVSCW_AUTOSIZE_USEHEADER)
        {
            // Special Cases:
            // 1) There is only 1 column.  Set the width to the width of the listview
            // 2) This is the rightmost column, set the width so the right edge of the
            //    column coinsides with to right edge of the list view.

            if (plv->cCol == 1)
            {
                RECT    rcClient;

                ListView_GetClientRect(plv, &rcClient, FALSE, NULL);
                HeaderWidth = rcClient.right - rcClient.left;
            }
            else if (iCol == (plv->cCol-1))
            {
                // BUGBUG  This will only work if the listview as NOT
                // been previously horizontally scrolled
                RECT    rcClient;
                RECT    rcHeader;

                ListView_GetClientRect(plv, &rcClient, FALSE, NULL);
                if (!Header_GetItemRect(plv->hwndHdr, plv->cCol - 2, &rcHeader))
                    rcHeader.right = 0;

                // Is if visible
                if (rcHeader.right < (rcClient.right-rcClient.left))
                {
                    HeaderWidth = (rcClient.right-rcClient.left) - rcHeader.right;
                }
            }

            // If we have a header width, then is is one of these special ones, so
            // we need to account for a vert scroll bar since we are using Client values
            if (HeaderWidth && hasVertScroll(plv))
            {
                HeaderWidth -= g_cxVScroll;
            }

            // Get the Width of the label.
            // We assume that the app hasn't changed any attributes
            // of the header control - still has default font, margins, etc.
            colitem.mask = HDI_TEXT | HDI_FORMAT;
            colitem.pszText = szLabel;
            colitem.cchTextMax = ARRAYSIZE(szLabel);
            if (Header_GetItem(plv->hwndHdr, iCol, &colitem))
            {
                HDC hdc = GetDC(plv->ci.hwnd);
                HFONT hfPrev = SelectFont(hdc, plv->hfontLabel);

                GetTextExtentPoint(hdc, colitem.pszText,
                                   lstrlen(colitem.pszText), &siz);
                siz.cx += 2 * (3 * g_cxLabelMargin);    // phd->iTextMargin
                if (colitem.fmt & HDF_IMAGE)
                {
                    siz.cx += plv->cxSmIcon;
                    siz.cx += 2 * (3 * g_cxLabelMargin);    // pdh->iBmMargin
                }

                HeaderWidth = max(HeaderWidth, siz.cx);

                SelectFont(hdc, hfPrev);
                ReleaseDC(plv->ci.hwnd, hdc);
            }
        }


        iBegin = 0;
        iEnd = ListView_Count( plv );

        //
        // Loop for each item in the view
        //
        if (ListView_IsOwnerData( plv ))
        {
            iBegin = (int)((plv->ptlRptOrigin.y - plv->yTop)
                        / plv->cyItem);
            iEnd = (int)((plv->ptlRptOrigin.y + plv->sizeClient.cy  - plv->yTop)
                        / plv->cyItem) + 1;

            iBegin = max( 0, iBegin );
            iEnd = max(iEnd, iBegin + 1);
            iEnd = min( iEnd, ListView_Count( plv ) );

            ListView_NotifyCacheHint( plv, iBegin, iEnd-1 );
        }

        //
        //  To obtain the widths of the strings, we have to pretend that
        //  we are painting them, in case the custom-draw client wants
        //  to play with fonts (e.g., Athena).
        //
        ListView_BeginFakeCustomDraw(plv, &lvfd, &lviItem);

        //
        //  If column 0, then we also need to take indent into account.
        //
        lviItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
        if (iCol == 0) {
            lviItem.mask |= LVIF_INDENT;
        }

        // Loop for each item in the List
        for (i = iBegin; i < iEnd; i++)
        {
            lviItem.iImage = -1;
            lviItem.iItem = i;
            lviItem.iSubItem = iCol;
            lviItem.pszText = szLabel;
            lviItem.cchTextMax = ARRAYSIZE(szLabel);
            lviItem.iIndent = 0;
            lviItem.stateMask = 0;
            ListView_OnGetItem(plv, &lviItem);

            // If there is a Text item, get its width
            if (lviItem.pszText || (lviItem.iImage != -1))
            {
                if (lviItem.pszText) {

                    ListView_BeginFakeItemDraw(&lvfd);

                    GetTextExtentPoint(lvfd.nmcd.nmcd.hdc, lviItem.pszText,
                                       lstrlen(lviItem.pszText), &siz);

                    ListView_EndFakeItemDraw(&lvfd);

                } else {
                    siz.cx = 0;
                }

                if (lviItem.iImage != -1)
                    siz.cx += plv->cxSmIcon + g_cxEdge;
                siz.cx += lviItem.iIndent * plv->cxSmIcon;
                ItemWidth = max(ItemWidth, siz.cx);
            }
        }

        ListView_EndFakeCustomDraw(&lvfd);

        // Adjust by a reasonable border amount.
        // If col 0, add 2*g_cxLabelMargin + g_szSmIcon.
        // Otherwise add 6*g_cxLabelMargin.
        // These amounts are based on Margins added automatically
        // to the ListView in ShDrawText.

        // BUGBUG ListView Report format currently assumes and makes
        // room for a Small Icon.
        if (iCol == 0)
        {
            ItemWidth += plv->cxState + g_cxEdge;
            ItemWidth += 2*g_cxLabelMargin;
        }
        else
        {
            ItemWidth += 6*g_cxLabelMargin;
        }

        TraceMsg(TF_LISTVIEW, "ListView: HeaderWidth:%d ItemWidth:%d", HeaderWidth, ItemWidth);
        item.cxy = max(HeaderWidth, ItemWidth);
    }
    else
    {
        // Use supplied width
        item.cxy = cx;
    }
    plv->xTotalColumnWidth = RECOMPUTE;

    item.mask = HDI_WIDTH;
    return Header_SetItem(plv->hwndHdr, iCol, &item);
}

#ifdef UNICODE
BOOL NEAR ListView_OnGetColumnA(LV* plv, int iCol, LV_COLUMNA FAR* pcol) {
    LPWSTR pszW = NULL;
    LPSTR pszC = NULL;
    BOOL fRet;

    //HACK ALERT -- this code assumes that LV_COLUMNA is exactly the same
    // as LV_COLUMNW except for the pointer to the string.
    ASSERT(sizeof(LV_COLUMNA) == sizeof(LV_COLUMNW))

    if (!pcol) return FALSE;

    if ((pcol->mask & LVCF_TEXT) && (pcol->pszText != NULL)) {
        pszC = pcol->pszText;
        pszW = LocalAlloc(LMEM_FIXED, pcol->cchTextMax * sizeof(WCHAR));
        if (pszW == NULL)
            return FALSE;
        pcol->pszText = (LPSTR)pszW;
    }

    fRet = ListView_OnGetColumn(plv, iCol, (LV_COLUMN FAR*) pcol);

    if (pszW != NULL) {
        if (fRet && pcol->cchTextMax)
            ConvertWToAN(plv->ci.uiCodePage, pszC, pcol->cchTextMax, pszW, -1);
        pcol->pszText = pszC;

        LocalFree(pszW);
    }

    return fRet;

}
#endif

BOOL NEAR ListView_OnGetColumn(LV* plv, int iCol, LV_COLUMN FAR* pcol)
{
    HD_ITEM item;
    UINT mask;

    if (!pcol) {
        RIPMSG(0, "LVM_GETCOLUMN: Invalid pcol = NULL");
        return FALSE;
    }

    mask = pcol->mask;

    if (!mask)
        return TRUE;

    item.mask = HDI_FORMAT | HDI_WIDTH | HDI_LPARAM | HDI_ORDER | HDI_IMAGE;

    if (mask & LVCF_TEXT)
    {
        if (pcol->pszText)
        {
            item.mask |= HDI_TEXT;
            item.pszText = pcol->pszText;
            item.cchTextMax = pcol->cchTextMax;
        } else {
            // For compatibility reasons, we don't fail the call if they
            // pass NULL.
            RIPMSG(0, "LVM_GETCOLUMN: Invalid pcol->pszText = NULL");
        }
    }

    if (!Header_GetItem(plv->hwndHdr, iCol, &item))
    {
        RIPMSG(0, "LVM_GETCOLUMN: Invalid column number %d", iCol);
        return FALSE;
    }

    if (mask & LVCF_SUBITEM)
        pcol->iSubItem = (int)item.lParam;

    if (mask & LVCF_ORDER)
        pcol->iOrder = (int)item.iOrder;

    if (mask & LVCF_IMAGE)
        pcol->iImage = item.iImage;

    if (mask & LVCF_FMT)
        pcol->fmt = item.fmt;

    if (mask & LVCF_WIDTH)
        pcol->cx = item.cxy;

    return TRUE;
}

#ifdef UNICODE
BOOL NEAR ListView_OnSetColumnA(LV* plv, int iCol, LV_COLUMNA FAR* pcol) {
    LPWSTR pszW = NULL;
    LPSTR pszC = NULL;
    BOOL fRet;

    //HACK ALERT -- this code assumes that LV_COLUMNA is exactly the same
    // as LV_COLUMNW except for the pointer to the string.
    ASSERT(sizeof(LV_COLUMNA) == sizeof(LV_COLUMNW));

    if (!pcol) return FALSE;

    if ((pcol->mask & LVCF_TEXT) && (pcol->pszText != NULL)) {
        pszC = pcol->pszText;
        if ((pszW = ProduceWFromA(plv->ci.uiCodePage, pszC)) == NULL)
            return FALSE;
        pcol->pszText = (LPSTR)pszW;
    }

    fRet = ListView_OnSetColumn(plv, iCol, (const LV_COLUMN FAR*) pcol);

    if (pszW != NULL) {
        pcol->pszText = pszC;

        FreeProducedString(pszW);
    }

    return fRet;

}
#endif

BOOL NEAR ListView_OnSetColumn(LV* plv, int iCol, const LV_COLUMN FAR* pcol)
{
    HD_ITEM item;
    UINT mask;

    if (!pcol) return FALSE;

    mask = pcol->mask;
    if (!mask)
        return TRUE;

    item.mask = 0;
    if (mask & LVCF_SUBITEM)
    {
        item.mask |= HDI_LPARAM;
        item.lParam = iCol;
    }

    if (mask & LVCF_FMT)
    {
        item.mask |= HDI_FORMAT;
        item.fmt = (pcol->fmt | HDF_STRING);
    }

    if (mask & LVCF_WIDTH)
    {
        item.mask |= HDI_WIDTH;
        item.cxy = pcol->cx;
    }

    if (mask & LVCF_TEXT)
    {
        RIPMSG(pcol->pszText != NULL, "LVM_SETCOLUMN: LV_COLUMN.pszText should not be NULL");

        item.mask |= HDI_TEXT;
        item.pszText = pcol->pszText;
        item.cchTextMax = 0;
    }

    if (mask & LVCF_IMAGE)
    {
        item.mask |= HDI_IMAGE;
        item.iImage = pcol->iImage;
    }

    if (mask & LVCF_ORDER)
    {
        item.mask |= HDI_ORDER;
        item.iOrder = pcol->iOrder;
    }


    plv->xTotalColumnWidth = RECOMPUTE;
    return Header_SetItem(plv->hwndHdr, iCol, &item);
}

BOOL NEAR ListView_SetSubItem(LV* plv, const LV_ITEM FAR* plvi)
{
    LISTSUBITEM lsi;
    BOOL fChanged = FALSE;
    int i;
    int idpa;
    HDPA hdpa;

    if (plvi->mask & ~(LVIF_DI_SETITEM | LVIF_TEXT | LVIF_IMAGE | LVIF_STATE))
    {
        RIPMSG(0, "ListView: Invalid mask: %04x", plvi->mask);
        return FALSE;
    }

    if (!(plvi->mask & (LVIF_TEXT | LVIF_IMAGE | LVIF_STATE)))
        return TRUE;

    i = plvi->iItem;
    if (!ListView_IsValidItemNumber(plv, i))
    {
        RIPMSG(0, "LVM_SETITEM: Invalid iItem: %d", plvi->iItem);
        return FALSE;
    }

    // sub item indices are 1-based...
    //
    idpa = plvi->iSubItem - 1;
    if (idpa < 0 || idpa >= plv->cCol - 1)
    {
        RIPMSG(0, "LVM_SETITEM: Invalid iSubItem: %d", plvi->iSubItem);
        return FALSE;
    }

    hdpa = ListView_GetSubItemDPA(plv, idpa);
    if (!hdpa)
    {
        hdpa = DPA_CreateEx(LV_HDPA_GROW, plv->hheap);
        if (!hdpa)
            return FALSE;

        DPA_SetPtr(plv->hdpaSubItems, idpa, (void FAR*)hdpa);
    }

    ListView_GetSubItem(plv, i, plvi->iSubItem, &lsi);

    if (plvi->mask & LVIF_TEXT) {
        if (lsi.pszText != plvi->pszText) {
            Str_Set(&lsi.pszText, plvi->pszText);
            fChanged = TRUE;
        }
    }

    if (plvi->mask & LVIF_IMAGE) {
        if (plvi->iImage != lsi.iImage) {
            lsi.iImage = (short) plvi->iImage;
            fChanged = TRUE;
        }
    }

    if (plvi->mask & LVIF_STATE) {
        DWORD dwChange;

        dwChange = (lsi.state ^ plvi->state ) & plvi->stateMask;

        if (dwChange) {
            lsi.state ^= dwChange;
            fChanged = TRUE;
        }
    }

    if (fChanged) {
        PLISTSUBITEM plsiReal = DPA_GetPtr(hdpa, i);
        if (!plsiReal) {
            plsiReal = LocalAlloc(LPTR, sizeof(LISTSUBITEM));
            if (!plsiReal) {
                // fail!  bail out
                return FALSE;
            }
        }
        *plsiReal = lsi;
        if (!DPA_SetPtr(hdpa, i, (void FAR*)plsiReal)) {

            ListView_FreeSubItem(plsiReal);
            return FALSE;
        }
    }

    // all's well... let's invalidate this
    if (ListView_IsReportView(plv)) {
        RECT rc;
        ListView_RGetRectsEx(plv, plvi->iItem, plvi->iSubItem, NULL, &rc);
        RedrawWindow(plv->ci.hwnd, &rc, NULL, RDW_ERASE | RDW_INVALIDATE);
    }
    return TRUE;
}


int ListView_RDestroyColumn(LPVOID d, LPVOID p)
{
    HDPA hdpa = (HDPA)d;
    DPA_DestroyCallback(hdpa, ListView_FreeColumnData, 0);
    return 1;
}

void NEAR ListView_RDestroy(LV* plv)
{
    DPA_DestroyCallback(plv->hdpaSubItems, ListView_RDestroyColumn, 0);
    plv->hdpaSubItems = NULL;
}

VOID NEAR ListView_RHeaderTrack(LV* plv, HD_NOTIFY FAR * pnm)
{
    // We want to update to show where the column header will be.
    HDC hdc;
    RECT rcBounds;

    // Statics needed from call to call
    static int s_xLast = -32767;

    hdc = GetDC(plv->ci.hwnd);
    if (hdc == NULL)
        return;

    //
    // First undraw the last marker we drew.
    //
    if (s_xLast > 0)
    {
        PatBlt(hdc, s_xLast, plv->yTop, g_cxBorder, plv->sizeClient.cy - plv->yTop, PATINVERT);
    }

    if (pnm->hdr.code == HDN_ENDTRACK)
    {
        s_xLast = -32767;       // Some large negative number...
    }
    else
    {

        RECT rc;

        //
        // First we need to calculate the X location of the column
        // To do this, we will need to know where this column begins
        // Note: We need the bounding rects to help us know the origin.
        ListView_GetRects(plv, 0, NULL, NULL, &rcBounds, NULL);

        if (!Header_GetItemRect(plv->hwndHdr, pnm->iItem, &rc)) {
            rc.left = 0;
        }
        rcBounds.left += rc.left;

        // Draw the new line...
        s_xLast = rcBounds.left + pnm->pitem->cxy;
        PatBlt(hdc, s_xLast, plv->yTop, g_cxBorder, plv->sizeClient.cy - plv->yTop, PATINVERT);
    }

    ReleaseDC(plv->ci.hwnd, hdc);
}

// try to use scrollwindow to adjust the columns rather than erasing
// and redrawing.
void NEAR PASCAL ListView_AdjustColumn(LV * plv, int iWidth)
{
    int x;
    RECT rcClip;
    int dx = iWidth - plv->iSelOldWidth;

    if (iWidth == plv->iSelOldWidth)
        return;

    // find the x coord of the left side of the iCol
    // use rcClip as a temporary...
    if (!Header_GetItemRect(plv->hwndHdr, plv->iSelCol, &rcClip)) {
        x = 0;
    } else {
        x = rcClip.left;
    }
    x -= plv->ptlRptOrigin.x;

    // compute the area to the right of the adjusted column
    GetWindowRect(plv->hwndHdr, &rcClip);

    rcClip.left = x;
    rcClip.top = RECTHEIGHT(rcClip);
    rcClip.right = plv->sizeClient.cx;
    rcClip.bottom = plv->sizeClient.cy;

    if ((plv->pImgCtx == NULL) && (plv->clrBk != CLR_NONE) &&
        (plv->clrTextBk != CLR_NONE))
    {
        //
        // We have a solid color background,
        // so we can smooth scroll the right side columns.
        //
#ifndef UNIX
        SMOOTHSCROLLINFO si =
        {
            sizeof(si),
            0,
            plv->ci.hwnd,
            dx,
            0,
            NULL,
            &rcClip,
            NULL,
            NULL,
            SW_ERASE | SW_INVALIDATE,
        };
#else
        SMOOTHSCROLLINFO si;
        si.cbSize = sizeof(si);
        si.fMask = 0;
        si.hwnd = plv->ci.hwnd;
        si.dx = dx;
        si.dy = 0;
        si.lprcSrc = NULL;
        si.lprcClip = &rcClip;
        si.hrgnUpdate = NULL;
        si.lprcUpdate = NULL;
        si.fuScroll = SW_ERASE | SW_INVALIDATE;
        si.uMaxScrollTime = SSI_DEFAULT;
        si.cxMinScroll = SSI_DEFAULT;
        si.cyMinScroll = SSI_DEFAULT;
        si.pfnScrollProc = NULL;
#endif

        rcClip.left += min(plv->iSelOldWidth, iWidth);
        SmoothScrollWindow(&si);

        // if we shrunk, invalidate the right most edge because
        // there might be junk there
        if (iWidth < plv->iSelOldWidth) {
            rcClip.right = rcClip.left + g_cxEdge;
            InvalidateRect(plv->ci.hwnd, &rcClip, TRUE);
        }

        plv->xTotalColumnWidth = RECOMPUTE;

        // adjust clipping rect to only redraw the adjusted column
        rcClip.left = x;
        rcClip.right = max(rcClip.left, x+iWidth);

        // Make the rectangle origin-based because ListView_UpdateScrollBars
        // may scroll us around.
        OffsetRect(&rcClip, plv->ptlRptOrigin.x, plv->ptlRptOrigin.y);

        ListView_UpdateScrollBars(plv);

        // Okay, now convert it back to client coordinates
        OffsetRect(&rcClip, -plv->ptlRptOrigin.x, -plv->ptlRptOrigin.y);

        // call update because scrollwindowex might have erased the far right
        // we don't want this invalidate to then enlarge the region
        // and end up erasing everything.
        UpdateWindow(plv->ci.hwnd);

        RedrawWindow(plv->ci.hwnd, &rcClip, NULL,
                     RDW_INVALIDATE | RDW_UPDATENOW);
    }
    else
    {
        //
        // We don't have a solid color background,
        // erase and redraw the adjusted column and
        // everything to the right (sigh).
        //
        plv->xTotalColumnWidth = RECOMPUTE;
        ListView_UpdateScrollBars(plv);

        rcClip.left = x;
        RedrawWindow(plv->ci.hwnd, &rcClip, NULL,
                     RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
    }
}

BOOL ListView_ForwardHeaderNotify(LV* plv, HD_NOTIFY FAR *pnm)
{
    return BOOLFROMPTR(SendNotifyEx(plv->ci.hwndParent, pnm->hdr.hwndFrom, pnm->hdr.code,
                       (NMHDR FAR *)pnm, plv->ci.bUnicode));
}

LRESULT ListView_HeaderNotify(LV* plv, HD_NOTIFY *pnm)
{
    LRESULT lres = 0;
    switch (pnm->hdr.code)
    {
    case HDN_BEGINDRAG:
        if (!(plv->exStyle & LVS_EX_HEADERDRAGDROP))
            return TRUE;

        return ListView_ForwardHeaderNotify(plv, pnm);

    case HDN_ENDDRAG:
        if (pnm->pitem->iOrder != -1) {
            InvalidateRect(plv->ci.hwnd, NULL, TRUE);
            return ListView_ForwardHeaderNotify(plv, pnm);
        }
        goto DoDefault;

    case HDN_ITEMCHANGING:
        if (pnm->pitem->mask & HDI_WIDTH) {
            HD_ITEM hitem;

            hitem.mask = HDI_WIDTH;
            Header_GetItem(plv->hwndHdr, pnm->iItem, &hitem);
            plv->iSelCol = pnm->iItem;
            plv->iSelOldWidth = hitem.cxy;
            TraceMsg(TF_LISTVIEW, "HDN_ITEMCHANGING %d %d", hitem.cxy, pnm->pitem->cxy);
            return ListView_ForwardHeaderNotify(plv, pnm);
        }
        else if (pnm->pitem->mask & HDI_FILTER) {
            return ListView_ForwardHeaderNotify(plv, pnm);
        }
        goto DoDefault;

    case HDN_ITEMCHANGED:
        if (pnm->pitem->mask & HDI_WIDTH)
        {
            ListView_DismissEdit(plv, FALSE);
            if (pnm->iItem == plv->iSelCol) {
                // Must do this even if there are no items, since
                // we have to redo the scrollbar, and the client
                // may have custom-drawn gridlines or something.
                ListView_AdjustColumn(plv, pnm->pitem->cxy);
            } else {
                // sanity check.  we got confused, so redraw all
                RedrawWindow(plv->ci.hwnd, NULL, NULL,
                             RDW_ERASE | RDW_INVALIDATE);
            }
            plv->iSelCol = -1;
            lres = ListView_ForwardHeaderNotify(plv, pnm);
        }
        else if (pnm->pitem->mask & HDI_FILTER) {
            lres = ListView_ForwardHeaderNotify(plv, pnm);
        } else
            goto DoDefault;
        break;


    case HDN_ITEMCLICK:
        //
        // BUGBUG:: Need to pass this and other HDN_ notifications back to
        // parent.  Should we simply pass up the HDN notifications
        // or should we define equivlent LVN_ notifications...
        //
        // Pass column number in iSubItem, not iItem...
        //
        ListView_DismissEdit(plv, FALSE);
        ListView_Notify(plv, -1, pnm->iItem, LVN_COLUMNCLICK);
        lres = ListView_ForwardHeaderNotify(plv, pnm);
        SetFocus(plv->ci.hwnd);
        break;

    case HDN_TRACK:
    case HDN_ENDTRACK:
        ListView_DismissEdit(plv, FALSE);
        ListView_RHeaderTrack(plv, pnm);
        lres = ListView_ForwardHeaderNotify(plv, pnm);
        SetFocus(plv->ci.hwnd);
        break;

    case HDN_DIVIDERDBLCLICK:
        ListView_DismissEdit(plv, FALSE);
        ListView_RSetColumnWidth(plv, pnm->iItem, -1);
        lres = ListView_ForwardHeaderNotify(plv, pnm);
        SetFocus(plv->ci.hwnd);
        break;

    case HDN_FILTERCHANGE:
    case HDN_FILTERBTNCLICK:
        return ListView_ForwardHeaderNotify(plv, pnm);

    case NM_RCLICK:
        return (UINT)SendNotifyEx(plv->ci.hwndParent, plv->hwndHdr, NM_RCLICK, NULL, plv->ci.bUnicode);

    default:
DoDefault:
        if (plv->ci.iVersion >= 5)
            return ListView_ForwardHeaderNotify(plv, pnm);
        break;
    }

    // in v < 5 we always returned 0
    // but for newer clients we'd like to have them deal with the notify
    if (plv->ci.iVersion >= 5)
        return lres;
    return 0;
}

/*----------------------------------------------------------------
** Check for a hit in a report view.
**
** a hit only counts if it's on the icon or the string in the first
** column.  so we gotta figure out what this means exactly.  yuck.
**
** BONUS FEATURE:  If piSubItem is non-NULL, then we also hit-test
** against subitems.  But if we find nothing, we return iSubItem = 0
** for compatibility with the other hit-test functions.
**----------------------------------------------------------------*/
int NEAR ListView_RItemHitTest(LV* plv, int x, int y, UINT FAR* pflags, int *piSubItem)
{
    int iHit;
    int i, iSub;
    UINT flags;
    RECT rcLabel;
    RECT rcIcon;

    if (piSubItem)
        *piSubItem = 0;

    flags = LVHT_NOWHERE;
    iHit = -1;

    i = ListView_RYHitTest(plv, y);
    if (ListView_IsValidItemNumber(plv, i))
    {
        if (plv->ci.style & LVS_OWNERDRAWFIXED) {
            flags = LVHT_ONITEM;
            iHit = i;
        } else {
            RECT rcSelect;
            ListView_GetRects(plv, i, &rcIcon, &rcLabel, NULL, &rcSelect);

            // is the hit in the first column?
            if ((x < rcIcon.left - g_cxEdge) && x > (rcIcon.left - plv->cxState))
            {
                iHit = i;
                flags = LVHT_ONITEMSTATEICON;
            }
            else if ((x >= rcIcon.left) && (x < rcIcon.right))
            {
                iHit = i;
                flags = LVHT_ONITEMICON;
            }
            else if (x >= rcLabel.left && (x < rcSelect.right))
            {
                iHit = i;
                flags = LVHT_ONITEMLABEL;

                if (ListView_FullRowSelect(plv)) {
                    // this is kinda funky...  in full row select mode
                    // we're only really on the label if x is <= rcLabel.left + cxLabel
                    // because GetRects returns a label rect of the full column width
                    // and rcSelect has the full row in FullRowSelect mode
                    // (it has the label only width in non-fullrow select mode.
                    //
                    // go figure..
                    //
                    int cxLabel;
                    LISTITEM FAR* pitem = NULL;

                    if (!ListView_IsOwnerData( plv ))
                    {
                        pitem = ListView_FastGetItemPtr(plv, i);
                    }
                    cxLabel = ListView_RGetCXLabel(plv, i, pitem, NULL, FALSE);

                    if (x >= min(rcLabel.left + cxLabel, rcLabel.right)) {
                        if (!piSubItem)
                            flags = LVHT_ONITEM;
                        else
                            goto CheckSubItem;
                    }
                }
            } else if (x < rcSelect.right && ListView_FullRowSelect(plv)) {
                // we can fall into this case if columns have been re-ordered
                iHit = i;
                flags = LVHT_ONITEM;
            } else if (piSubItem) {
            CheckSubItem:
                iSub = ListView_RXHitTest(plv, x);
                if (iSub >= 0) {
                    iHit = i;
                    *piSubItem = iSub;
                    // Flags still say LVHT_NOWHERE
                }
            }
        }
    }

    *pflags = flags;
    return iHit;
}

void ListView_GetSubItem(LV* plv, int i, int iSubItem, PLISTSUBITEM plsi)
{
    HDPA hdpa;
    PLISTSUBITEM plsiSrc = NULL;

    ASSERT( !ListView_IsOwnerData( plv ));

    // Sub items are indexed starting at 1...
    //
    RIPMSG(iSubItem > 0 && iSubItem < plv->cCol, "ListView: Invalid iSubItem: %d", iSubItem);

#ifdef DEBUG
    // Avoid the assert in DPA_GetPtr if somebdy tries to get a subitem
    // when no columns have been added.  We already RIP'd above.
    hdpa = plv->cCol ? ListView_GetSubItemDPA(plv, iSubItem - 1) : NULL;
#else
    hdpa = ListView_GetSubItemDPA(plv, iSubItem - 1);
#endif
    if (hdpa) {
        plsiSrc = DPA_GetPtr(hdpa, i);
    }


    if (plsiSrc) {
        *plsi = *plsiSrc;
    } else {

        // item data exists.. give defaults
        plsi->pszText = LPSTR_TEXTCALLBACK;
        plsi->iImage = I_IMAGECALLBACK;
        plsi->state = 0;
    }
}

LPTSTR NEAR ListView_RGetItemText(LV* plv, int i, int iSubItem)
{
    LISTSUBITEM lsi;

    ListView_GetSubItem(plv, i, iSubItem, &lsi);
    return lsi.pszText;
}

// this will return the rect of a subitem as requested.
void ListView_RGetRectsEx(LV* plv, int iItem, int iSubItem, LPRECT prcIcon, LPRECT prcLabel)
{
    int x;
    int y;
    LONG ly;
    RECT rcLabel;
    RECT rcIcon;
    RECT rcHeader;

    if (iSubItem == 0) {
        ListView_RGetRects(plv, iItem, prcIcon, prcLabel, NULL, NULL);
        return;
    }

    // otherwise it's just the header's column right and left and the item's height
    ly = (LONG)iItem * plv->cyItem - plv->ptlRptOrigin.y + plv->yTop;
    x = - (int)plv->ptlRptOrigin.x;

    //
    // Need to check for y overflow into rectangle structure
    // if so we need to return something reasonable...
    // For now will simply set it to the max or min that will fit...
    //
    if (ly >= (INT_MAX - plv->cyItem))
        y = INT_MAX - plv->cyItem;
    else if ( ly < INT_MIN)
        y = INT_MIN;
    else
        y = (int)ly;

    ASSERT(iSubItem < plv->cCol);
    Header_GetItemRect(plv->hwndHdr, iSubItem, &rcHeader);

    rcLabel.left = x + rcHeader.left;
    rcLabel.right = x + rcHeader.right;
    rcLabel.top = y;
    rcLabel.bottom = rcLabel.top + plv->cyItem;

    rcIcon = rcLabel;
    rcIcon.right = rcIcon.left + plv->cxSmIcon;

    if (SELECTOROF(prcIcon))
        *prcIcon = rcIcon;
    if (SELECTOROF(prcLabel))
        *prcLabel = rcLabel;
}

int ListView_RGetTotalColumnWidth(LV* plv)
{
    if (plv->xTotalColumnWidth == RECOMPUTE)
    {
        plv->xTotalColumnWidth = 0;
        if (plv->cCol) {
            RECT rcLabel;
            int iIndex;

            // find the right edge of the last ordered item to get the total column width
            iIndex = (int) SendMessage(plv->hwndHdr, HDM_ORDERTOINDEX, plv->cCol - 1, 0);
            Header_GetItemRect(plv->hwndHdr, iIndex, &rcLabel);
            plv->xTotalColumnWidth = rcLabel.right;
        }
    }
    return plv->xTotalColumnWidth;
}

// get the rects for report view
void NEAR ListView_RGetRects(LV* plv, int iItem, RECT FAR* prcIcon,
        RECT FAR* prcLabel, RECT FAR* prcBounds, RECT FAR* prcSelectBounds)
{
    RECT rcIcon;
    RECT rcLabel;
    int x;
    int y;
    LONG ly;
    LVITEM lvitem;
    BOOL fItemSpecific = (prcIcon || prcLabel || prcSelectBounds);

    // use long math for cases where we have lots-o-items

    ly = (LONG)iItem * plv->cyItem - plv->ptlRptOrigin.y + plv->yTop;
    x = - (int)plv->ptlRptOrigin.x;

    //
    // Need to check for y overflow into rectangle structure
    // if so we need to return something reasonable...
    // For now will simply set it to the max or min that will fit...
    //
    if (ly >= (INT_MAX - plv->cyItem))
        y = INT_MAX - plv->cyItem;
    else
        y = (int)ly;


    if (ListView_Count(plv) && fItemSpecific) {
        //  move this over by the indent level as well
        lvitem.mask = LVIF_INDENT;
        lvitem.iItem = iItem;
        lvitem.iSubItem = 0;
        ListView_OnGetItem(plv, &lvitem);
    } else {
        lvitem.iIndent = 0;
    }

    rcIcon.left   = x + plv->cxState + (lvitem.iIndent * plv->cxSmIcon) + g_cxEdge;
    rcIcon.right  = rcIcon.left + plv->cxSmIcon;
    rcIcon.top    = y;
    rcIcon.bottom = rcIcon.top + plv->cyItem;

    rcLabel.left  = rcIcon.right;
    rcLabel.top   = rcIcon.top;
    rcLabel.bottom = rcIcon.bottom;

    //
    // The label is assumed to be the first column.
    //
    rcLabel.right = x;
    if (plv->cCol > 0 && fItemSpecific)
    {
        RECT rc;
        Header_GetItemRect(plv->hwndHdr, 0, &rc);
        rcLabel.right = x + rc.right;
        rcLabel.left += rc.left;
        rcIcon.left += rc.left;
        rcIcon.right += rc.left;
    }

    if (SELECTOROF(prcIcon))
        *prcIcon = rcIcon;

    // Save away the label bounds.
    if (SELECTOROF(prcLabel)) {
        *prcLabel = rcLabel;
    }

    // See if they also want the Selection bounds of the item
    if (prcSelectBounds)
    {
        if (ListView_FullRowSelect(plv)) {

            prcSelectBounds->left = x;
            prcSelectBounds->top = y;
            prcSelectBounds->bottom = rcLabel.bottom;
            prcSelectBounds->right = prcSelectBounds->left + ListView_RGetTotalColumnWidth(plv);

        } else {
            int cxLabel;
            LISTITEM FAR* pitem = NULL;

            if (!ListView_IsOwnerData( plv ))
            {
                pitem = ListView_FastGetItemPtr(plv, iItem);
            }
            cxLabel = ListView_RGetCXLabel(plv, iItem, pitem, NULL, FALSE);

            *prcSelectBounds = rcIcon;
            prcSelectBounds->right = rcLabel.left + cxLabel;
            if (prcSelectBounds->right > rcLabel.right)
                prcSelectBounds->right = rcLabel.right;
        }
    }

    // And also the Total bounds

    //
    // and now for the complete bounds...
    //
    if (SELECTOROF(prcBounds))
    {
        prcBounds->left = x;
        prcBounds->top = y;
        prcBounds->bottom = rcLabel.bottom;

        prcBounds->right = prcBounds->left + ListView_RGetTotalColumnWidth(plv);
    }
}

BOOL ListView_OnGetSubItemRect(LV* plv, int iItem, LPRECT lprc)
{
    LPRECT pRects[LVIR_MAX];
    RECT rcTemp;

    int iSubItem;
    int iCode;

    if (!lprc)
        return FALSE;

    iSubItem = lprc->top;
    iCode = lprc->left;

    if (iSubItem == 0) {
        return ListView_OnGetItemRect(plv, iItem, lprc);
    }

    if (!ListView_IsReportView(plv) ||
        (iCode != LVIR_BOUNDS && iCode != LVIR_ICON && iCode != LVIR_LABEL)) {
        return FALSE;
    }

    pRects[0] = NULL;
    pRects[1] = &rcTemp;  // LVIR_ICON
    pRects[2] = &rcTemp;  // LVIR_LABEL
    pRects[3] = NULL;

    if (iCode != LVIR_BOUNDS) {
        pRects[iCode] = lprc;
    } else {
        // choose either
        pRects[LVIR_ICON] = lprc;
    }

    ListView_RGetRectsEx(plv, iItem, iSubItem,
                        pRects[LVIR_ICON], pRects[LVIR_LABEL]);

    if (iCode == LVIR_BOUNDS) {
        UnionRect(lprc, lprc, &rcTemp);
    }
    return TRUE;
}

int ListView_RXHitTest(LV* plv, int x)
{
    int iSubItem;

    for (iSubItem = plv->cCol - 1; iSubItem >= 0; iSubItem--) {
        RECT rc;

        // see if its in this rect,
        if (!Header_GetItemRect(plv->hwndHdr, iSubItem, &rc))
            return -1;

        OffsetRect(&rc, -plv->ptlRptOrigin.x, 0);
        if (rc.left <= x && x < rc.right) {
            break;
        }
    }
    return iSubItem;
}

int ListView_OnSubItemHitTest(LV* plv, LPLVHITTESTINFO plvhti)
{
    int i = -1;
    int iSubItem = 0;
    UINT uFlags = LVHT_NOWHERE;

    if (!plvhti) {
        return -1;
    }

    if (ListView_IsReportView(plv)) {
        iSubItem = ListView_RXHitTest(plv, plvhti->pt.x);
        if (iSubItem == -1) {
            goto Bail;
        }
    }

    if (iSubItem == 0) {
        // if we're in column 0, just hand it off to the old stuff
        ListView_OnHitTest(plv, plvhti);
        plvhti->iSubItem = 0;
        return plvhti->iItem;
    }

    if (!ListView_IsReportView(plv)) {
        goto Bail;
    }

    i = ListView_RYHitTest(plv, plvhti->pt.y);
    if (i < ListView_Count(plv)) {
        RECT rcIcon, rcLabel;

        if (i != -1)  {
            ListView_RGetRectsEx(plv, i, iSubItem, &rcIcon, &rcLabel);
            if (plvhti->pt.x >= rcIcon.left && plvhti->pt.x <= rcIcon.right) {
                uFlags = LVHT_ONITEMICON;
            } else if (plvhti->pt.x >= rcLabel.left && plvhti->pt.x <= rcLabel.right){
                uFlags = LVHT_ONITEMLABEL;
            } else
                uFlags = LVHT_ONITEM;
        }
    } else {
        i = -1;
    }

Bail:

    plvhti->iItem = i;
    plvhti->iSubItem = iSubItem;
    plvhti->flags = uFlags;

    return plvhti->iItem;
}



// BUGBUG: this is duplicate code with all the other views!
// See whether entire string will fit in *prc; if not, compute number of chars
// that will fit, including ellipses.  Returns length of string in *pcchDraw.
//
BOOL NEAR ListView_NeedsEllipses(HDC hdc, LPCTSTR pszText, RECT FAR* prc, int FAR* pcchDraw, int cxEllipses)
{
    int cchText;
    int cxRect;
    int ichMin, ichMax, ichMid;
    SIZE siz;
#if !defined(UNICODE)  // && defined(DBCS)
    LPCTSTR lpsz;
#endif

    cxRect = prc->right - prc->left;

    cchText = lstrlen(pszText);

    if (cchText == 0)
    {
        *pcchDraw = cchText;
        return FALSE;
    }

    GetTextExtentPoint(hdc, pszText, cchText, &siz);

    if (siz.cx <= cxRect)
    {
        *pcchDraw = cchText;
        return FALSE;
    }

    cxRect -= cxEllipses;

    // If no room for ellipses, always show first character.
    //
    ichMax = 1;
    if (cxRect > 0)
    {
        // Binary search to find character that will fit
        ichMin = 0;
        ichMax = cchText;
        while (ichMin < ichMax)
        {
            // Be sure to round up, to make sure we make progress in
            // the loop if ichMax == ichMin + 1.
            //
            ichMid = (ichMin + ichMax + 1) / 2;

            GetTextExtentPoint(hdc, &pszText[ichMin], ichMid - ichMin, &siz);

            if (siz.cx < cxRect)
            {
                ichMin = ichMid;
                cxRect -= siz.cx;
            }
            else if (siz.cx > cxRect)
            {
                ichMax = ichMid - 1;
            }
            else
            {
                // Exact match up up to ichMid: just exit.
                //
                ichMax = ichMid;
                break;
            }
        }

        // Make sure we always show at least the first character...
        //
        if (ichMax < 1)
            ichMax = 1;
    }

#if !defined(UNICODE) // && defined(DBCS)
      // b#8934
      lpsz = &pszText[ichMax];
      while ( lpsz-- > pszText )
      {
          if (!IsDBCSLeadByte(*lpsz))
              break;
      }
      ichMax += ( (&pszText[ichMax] - lpsz) & 1 ) ? 0: 1;
#endif

    *pcchDraw = ichMax;
    return TRUE;
}


void NEAR ListView_RUpdateScrollBars(LV* plv)
{
    HD_LAYOUT layout;
    RECT rcClient;
    RECT rcBounds;
    WINDOWPOS wpos;
    int cColVis, cyColVis, iNewPos, iyDelta = 0, ixDelta = 0;
    BOOL fHorSB, fReupdate = FALSE;
    SCROLLINFO si;

    ListView_GetClientRect(plv, &rcClient, FALSE, NULL);

    if (!plv->hwndHdr)
        ListView_CreateHeader(plv);

    if (!plv->hwndHdr)
        TraceMsg(TF_WARNING, "ListView_RUpdateScrollBars could not create hwndHdr");

    layout.pwpos = &wpos;
    // For now lets try to handle scrolling the header by setting
    // its window pos.
    rcClient.left -= (int)plv->ptlRptOrigin.x;
    layout.prc = &rcClient;
    Header_Layout(plv->hwndHdr, &layout);
    rcClient.left += (int)plv->ptlRptOrigin.x;    // Move it back over!

    SetWindowPos(plv->hwndHdr, wpos.hwndInsertAfter, wpos.x, wpos.y,
                 wpos.cx, wpos.cy, wpos.flags | SWP_SHOWWINDOW);

    // Get the horizontal bounds of the items.
    ListView_RGetRects(plv, 0, NULL, NULL, &rcBounds, NULL);

    // If v3 or better, take a cyEdge off the top
    if (plv->ci.iVersion >= 3)
        rcClient.top += g_cyEdge;

    plv->yTop = rcClient.top;

    // fHorSB = Do I need a horizontal scrollbar?
    // cyColVis = number of pixels per screenful
    fHorSB = (rcBounds.right - rcBounds.left > rcClient.right);  // First guess.
    cyColVis = rcClient.bottom - rcClient.top -
               (fHorSB ? ListView_GetCyScrollbar(plv) : 0);

    // If screen can't fit the entire listview...
    if (cyColVis < ListView_Count(plv) * plv->cyItem) {
        //then we're going to have a vertical scrollbar.. make sure our horizontal count is correct
        rcClient.right -= ListView_GetCxScrollbar(plv);

        if (!fHorSB) {
            // if we previously thought we weren't going to have a scrollbar, we could be wrong..
            // since the vertical bar shrunk our area
            fHorSB = (rcBounds.right - rcBounds.left > rcClient.right);  // First guess.
            cyColVis = rcClient.bottom - rcClient.top -
                       (fHorSB ? ListView_GetCyScrollbar(plv) : 0);
        }
    }

    // cColVis = number of completely visible items per screenful
    cColVis = cyColVis / plv->cyItem;

    si.cbSize = sizeof(SCROLLINFO);

    si.fMask = SIF_PAGE | SIF_RANGE | SIF_POS;
    si.nPos = (int)(plv->ptlRptOrigin.y / plv->cyItem);
    si.nPage = cColVis;
    si.nMin = 0;
    si.nMax = ListView_Count(plv) - 1;
    ListView_SetScrollInfo(plv, SB_VERT, &si, TRUE);

    // make sure our position and page doesn't hang over max
    if ((si.nPos > (int)si.nMax - (int)si.nPage + 1) && si.nPos > 0) {
        iNewPos = (int)si.nMax - (int)si.nPage + 1;
        if (iNewPos < 0) iNewPos = 0;
        if (iNewPos != si.nPos) {
            iyDelta = iNewPos - (int)si.nPos;
            fReupdate = TRUE;
        }
    }

    si.nPos = (int)plv->ptlRptOrigin.x;
    si.nPage = rcClient.right - rcClient.left;

    // We need to subtract 1 here because nMax is 0 based, and nPage is the actual
    // number of page pixels.  So, if nPage and nMax are the same we will get a
    // horz scroll, since there is 1 more pixel than the page can show, but... rcBounds
    // is like rcRect, and is the actual number of pixels for the whole thing, so
    // we need to set nMax so that: nMax - 0 == rcBounds.right - rcBound.left
    si.nMax = rcBounds.right - rcBounds.left - 1;
    ListView_SetScrollInfo(plv, SB_HORZ, &si, TRUE);

    // SWP_FRAMECHANGED redraws the background if the client
    // area has changed (taking into account scrollbars and
    // the Header window).  SetScrollInfo does this automatically
    // when it creates a scrollbar - we do it ourselves when
    // there is no scrollbar.
    if ((UINT)si.nPage > (UINT)si.nMax &&
        ((plv->pImgCtx && plv->fImgCtxComplete) || plv->hbmBkImage))
        SetWindowPos(plv->ci.hwnd, NULL, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_FRAMECHANGED);

    // make sure our position and page doesn't hang over max
    if ((si.nPos + (LONG)si.nPage - 1 > si.nMax) && si.nPos > 0) {
        iNewPos = (int)si.nMax - (int)si.nPage + 1;
        if (iNewPos < 0) iNewPos = 0;
        if (iNewPos != si.nPos) {
            ixDelta = iNewPos - (int)si.nPos;
            fReupdate = TRUE;
        }
    }

    if (fReupdate) {
        // we shouldn't recurse because the second time through, si.nPos >0
        ListView_RScroll2(plv, ixDelta, iyDelta, 0);
        ListView_RUpdateScrollBars(plv);
        TraceMsg(TF_LISTVIEW, "LISTVIEW: ERROR: We had to recurse!");
    }
}

//
//  We need a smoothscroll callback so our background image draws
//  at the correct origin.  If we don't have a background image,
//  then this work is superfluous but not harmful either.
//
int CALLBACK ListView_RScroll2_SmoothScroll(
    HWND hwnd,
    int dx,
    int dy,
    CONST RECT *prcScroll,
    CONST RECT *prcClip,
    HRGN hrgnUpdate,
    LPRECT prcUpdate,
    UINT flags)
{
    LV* plv = ListView_GetPtr(hwnd);
    if (plv)
    {
        plv->ptlRptOrigin.x -= dx;
        plv->ptlRptOrigin.y -= dy;
    }

    // Now do what SmoothScrollWindow would've done if we weren't
    // a callback

    return ScrollWindowEx(hwnd, dx, dy, prcScroll, prcClip, hrgnUpdate, prcUpdate, flags);
}



void FAR PASCAL ListView_RScroll2(LV* plv, int dx, int dy, UINT uSmooth)
{
    LONG ldy;

    if (dx | dy)
    {
        RECT rc;

        GetClientRect(plv->ci.hwnd, &rc);

        rc.top = plv->yTop;

        // We can not do a simple multiply here as we may run into
        // a case where this will overflow an int..
        ldy = (LONG)dy * plv->cyItem;

        // handle case where dy is large (greater than int...)
        if ((ldy > rc.bottom) || (ldy < -rc.bottom)) {
            InvalidateRect(plv->ci.hwnd, NULL, TRUE);
            plv->ptlRptOrigin.x += dx;
            plv->ptlRptOrigin.y += ldy;
        } else {
            SMOOTHSCROLLINFO si;
            si.cbSize = sizeof(si);
            si.fMask = SSIF_SCROLLPROC;
            si.hwnd = plv->ci.hwnd;
            si.dx = -dx;
            si.dy = (int)-ldy;
            si.lprcSrc = NULL;
            si.lprcClip = &rc;
            si.hrgnUpdate = NULL;
            si.lprcUpdate = NULL;
            si.fuScroll =SW_INVALIDATE | SW_ERASE | uSmooth;
            si.pfnScrollProc = ListView_RScroll2_SmoothScroll;
            SmoothScrollWindow(&si);

            /// this causes horrible flicker/repaint on deletes.
            // if this is a problem with UI scrolling, we'll have to pass through a
            // flag when to use this
            ///UpdateWindow(plv->ci.hwnd);
        }

        // if Horizontal scrolling, we should update the location of the
        // left hand edge of the window...
        //
        if (dx != 0)
        {
            RECT rcHdr;
            GetWindowRect(plv->hwndHdr, &rcHdr);
            MapWindowRect(HWND_DESKTOP, plv->ci.hwnd, &rcHdr);
            SetWindowPos(plv->hwndHdr, NULL, rcHdr.left - dx, rcHdr.top,
                    rcHdr.right - rcHdr.left + dx,
                    rcHdr.bottom - rcHdr.top,
                    SWP_NOZORDER | SWP_NOACTIVATE);
        }
    }
}

//-------------------------------------------------------------------
// Make sure that specified item is visible for report view.
// Must handle Large number of items...
BOOL NEAR ListView_ROnEnsureVisible(LV* plv, int iItem, BOOL fPartialOK)
{
    LONG dy;
    LONG yTop;
    LONG lyTop;

    yTop = plv->yTop;

    // lyTop = where our item is right now
    lyTop = (LONG)iItem * plv->cyItem - plv->ptlRptOrigin.y + plv->yTop;

    // If visible below yTop and our bottom is visible above client bottom,
    // then we're happy.
    if ((lyTop >= (LONG)yTop) &&
            ((lyTop + plv->cyItem) <= (LONG)plv->sizeClient.cy))
        return(TRUE);       // we are visible

    dy = lyTop - yTop;
    if (dy >= 0)
    {
        // dy = how many pixels we need to scroll to come into view
        dy = lyTop + plv->cyItem - plv->sizeClient.cy;
        if (dy < 0)
            dy = 0;
    }

    if (dy)
    {
        int iRound = ((dy > 0) ? 1 : -1) * (plv->cyItem - 1);

        // Now convert into the number of items to scroll...
        dy = (dy + iRound) / plv->cyItem;

#ifdef MAINWIN
        if (dy > 0) dy -=1;
#endif

        ListView_RScroll2(plv, 0, (int)dy, 0);
        if (ListView_RedrawEnabled(plv)) {
            ListView_UpdateScrollBars(plv);
        } else {
            ListView_DeleteHrgnInval(plv);
            plv->hrgnInval = (HRGN)ENTIRE_REGION;
            plv->flags |= LVF_ERASE;
        }
#ifdef MAINWIN
        return TRUE;
#endif
    }
#ifdef MAINWIN
    return FALSE;
#else
    return TRUE;
#endif
}



void NEAR ListView_ROnScroll(LV* plv, UINT code, int posNew, UINT sb)
{
    int cLine;

    cLine = (sb == SB_VERT) ? 1 : plv->cxLabelChar;
    ListView_ComOnScroll(plv, code, posNew, sb, cLine, -1);
}


int NEAR ListView_RGetScrollUnitsPerLine(LV* plv, UINT sb)
{
    int cLine;

    cLine = (sb == SB_VERT) ? 1 : plv->cxLabelChar;
    return cLine;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\mem.h ===
#ifndef _INC_MEM
#define _INC_MEM

// wrappers for private allocations, near in 16 bits

#define NearAlloc(cb)       ((void NEAR*)LocalAlloc(LPTR, (cb)))
#define NearReAlloc(pb, cb) ((void NEAR*)LocalReAlloc((HLOCAL)(pb), (cb), LMEM_MOVEABLE | LMEM_ZEROINIT))
#define NearFree(pb)        (LocalFree((HLOCAL)(pb)) ? FALSE : TRUE)
#define NearSize(pb)        LocalSize(pb)

#ifdef WIN32
//
// These macros are used in our controls, that in 32 bits we simply call
// LocalAlloc as to have the memory associated with the process that created
// it and as such will be cleaned up if the process goes away.
//
#ifdef DEBUG
LPVOID WINAPI ControlAlloc(HANDLE hheap, DWORD cb);
LPVOID WINAPI ControlReAlloc(HANDLE hheap, LPVOID pb, DWORD cb);
BOOL   WINAPI ControlFree(HANDLE hheap, LPVOID pb);
SIZE_T WINAPI ControlSize(HANDLE hheap, LPVOID pb);
#else // DEBUG
#define ControlAlloc(hheap, cb)       HeapAlloc((hheap), HEAP_ZERO_MEMORY, (cb))
#define ControlReAlloc(hheap, pb, cb) HeapReAlloc((hheap), HEAP_ZERO_MEMORY, (pb),(cb))
#define ControlFree(hheap, pb)        HeapFree((hheap), 0, (pb))
#define ControlSize(hheap, pb)        HeapSize((hheap), 0, (LPCVOID)(pb))
#endif // DEBUG

BOOL Str_Set(LPTSTR *ppsz, LPCTSTR psz);  // in the process heap

#else // WIN32

//
// In 16 bit code we need the Allocs to go from our heap code as we do not
// want to limit them to 64K of data.  If we have some type of notification of
// 16 bit application termination, We may want to see if we can
// dedicate different heaps for different processes to cleanup...
//
#define ControlAlloc(hheap, cb)       Alloc(cb)  /* calls to verify heap exists */
#define ControlReAlloc(hheap, pb, cb) ReAlloc(pb, cb)
#define ControlFree(hheap, pb)        Free(pb)
#define ControlSize(hheap, pb)        GetSize((LPCVOID)pb)
#define Str_Set(p, s)                 Str_SetPtr(p, s)  // use shared heap for win16

#endif // WIN32

#ifndef WINNT

extern HANDLE g_hSharedHeap;

HANDLE InitSharedHeap(void);

__inline HANDLE
GetSharedHeapHandle(void)
{
    if (g_hSharedHeap)
    {
        return g_hSharedHeap;
    }
    else
    {
        return InitSharedHeap();
    }
}

#endif

#endif  // !_INC_MEM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\mirror.c ===
/****************************** Module*Header *****************************\
* Module Name: mirror.c                                                    *
*                                                                          *
* This module contains all the Right-To-Left (RTL) Mirroring support       *
* routines used to Right-To-Left mirror an icon on the fly so that         *
* it would be displayed normal on a RTL mirrored localized OS. This is     *
* mainly a concern for 3rd party Apps.                                     *
*                                                                          *
*                                                                          *
* Created: 01-Feb-1998 8:41:18 pm                                          *
* Author: Samer Arafeh [samera]                                            *
*                                                                          *
* Copyright (c) 1998 Microsoft Corporation                                 *
\**************************************************************************/

#include "ctlspriv.h"




/***************************************************************************\
* MirrorIcon
*
* Mirror an Icon , given an Icon handle so that when these icons are displayed
* on a Mirrored DC, they end would be displayed normal.
*
* History:
* 04-Feb-1998 samera    Created
\***************************************************************************/
BOOL WINAPI MirrorIcon(HICON* phiconSmall, HICON* phiconLarge)
{
    HDC      hdcScreen;
    HBITMAP  hbm, hbmMask, hbmOld,hbmOldMask;
    BITMAP   bm;
    HICON    hicon[2] = {NULL,NULL};
    HICON    hiconNew[2] = {NULL,NULL};
    ICONINFO ii ;
    int      i;
#ifdef WINNT
#define      IPIXELOFFSET 0 
#else // !WINNT
#define      IPIXELOFFSET 2
#endif WINNT

    //
    // Synchronize access to global DCs now!
    // Allocate DCs if we didn't so far.
    //  
    ENTERCRITICAL;
    
    if (!g_hdc && !g_hdcMask)
    {
        g_hdc = CreateCompatibleDC(NULL);
        if (g_hdc)
        {
#ifndef UNIX
#ifndef WINNT
            SetObjectOwner(g_hdc, HINST_THISDLL);
#endif
#endif /* !UNIX */
            g_hdcMask = CreateCompatibleDC(NULL);

            if( g_hdcMask )
            {
#ifndef UNIX
#ifndef WINNT
                SetObjectOwner(g_hdcMask, HINST_THISDLL);
#endif
#endif /* !UNIX */

                SET_DC_RTL_MIRRORED(g_hdc);
                SET_DC_RTL_MIRRORED(g_hdcMask);
            }
            else
            {
                DeleteDC( g_hdc );
                g_hdc = NULL;
            }
        }
    }

    if (phiconSmall)
        hicon[0] = *phiconSmall;

    if (phiconLarge)
        hicon[1] = *phiconLarge;

    //
    // Acquire the screen DC
    //
    hdcScreen = GetDC(NULL);

    if (g_hdc && g_hdcMask && hdcScreen) 
    {
        for( i=0 ; i<(sizeof(hicon)/sizeof(HICON)) ; i++ )
        {
            if( hicon[i] )
            {
                if( GetIconInfo(hicon[i], &ii) &&
                    GetObject(ii.hbmColor, sizeof(BITMAP), &bm))
                {
                    //
                    // I don't want these.
                    //
                    DeleteObject( ii.hbmMask );
                    DeleteObject( ii.hbmColor );
                    ii.hbmMask = ii.hbmColor = NULL;

                    hbm = CreateCompatibleBitmap(hdcScreen, bm.bmWidth, bm.bmHeight);
                    hbmMask = CreateBitmap(bm.bmWidth, bm.bmHeight, 1, 1, NULL);
                    hbmOld = (HBITMAP)SelectObject(g_hdc, hbm);
                    hbmOldMask = (HBITMAP)SelectObject(g_hdcMask, hbmMask);
        
                    DrawIconEx(g_hdc, IPIXELOFFSET, 0, hicon[i], bm.bmWidth, bm.bmHeight, 0,
                               NULL, DI_IMAGE);

                    DrawIconEx(g_hdcMask, IPIXELOFFSET, 0, hicon[i], bm.bmWidth, bm.bmHeight, 0,
                               NULL, DI_MASK);

                    SelectObject(g_hdc, hbmOld);
                    SelectObject(g_hdcMask, hbmOldMask);

                    //
                    // create the new mirrored icon, and delete bmps
                    //
                    ii.hbmMask  = hbmMask;
                    ii.hbmColor = hbm;
                    hiconNew[i] = CreateIconIndirect(&ii);

                    DeleteObject(hbm);
                    DeleteObject(hbmMask);
                }
            }
        }
    }

    ReleaseDC(NULL, hdcScreen);

    //
    // Now we can reuse the global DCs
    //
    LEAVECRITICAL;

    //
    // Update icons if needed, and destroy old ones!
    //
    if (hicon[0] && hiconNew[0])
    {
        *phiconSmall = hiconNew[0];
        DestroyIcon(hicon[0]);
    }

    if (hicon[1] && hiconNew[1])
    {
        *phiconLarge = hiconNew[1];

        //
        // Don't delete twice
        //
        if (hicon[1] != hicon[0]) 
            DestroyIcon(hicon[1]);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\menuhelp.c ===
#include "ctlspriv.h"

#define MAININSYS

#ifndef WIN32
/* This returns the index of a submenu in a parent menu.  The return is
 * < 0 if the submenu does not exist in the parent menu
 */
int NEAR PASCAL GetMenuIndex(HMENU hMenu, HMENU hSubMenu)
{
  int i;

  if (!hMenu || !hSubMenu)
      return(-1);

  for (i=GetMenuItemCount(hMenu)-1; i>=0; --i)
    {
      if (hSubMenu == GetSubMenu(hMenu, i))
          break;
    }

  return(i);
}
#endif // WIN32


BOOL NEAR PASCAL IsMaxedMDI(HMENU hMenu)
{
  return(GetMenuItemID(hMenu, GetMenuItemCount(hMenu)-1) == SC_RESTORE);
}


/* Note that if iMessage is WM_COMMAND, it is assumed to have come from
 * a header bar or toolbar; do not pass in WM_COMMAND messages from any
 * other controls.
 */

#define MS_ID           GET_WM_MENUSELECT_CMD
#define MS_FLAGS        GET_WM_MENUSELECT_FLAGS
#define MS_MENU         GET_WM_MENUSELECT_HMENU

#define CMD_NOTIFY      GET_WM_COMMAND_CMD
#define CMD_ID          GET_WM_COMMAND_ID
#define CMD_CTRL        GET_WM_COMMAND_HWND


void WINAPI MenuHelp(UINT iMessage, WPARAM wParam, LPARAM lParam,
      HMENU hMainMenu, HINSTANCE hAppInst, HWND hwndStatus, UINT FAR *lpwIDs)
{
  UINT wID;
  UINT FAR *lpwPopups;
  int i;
  TCHAR szString[256];
  BOOL bUpdateNow = TRUE;
#if defined(WINDOWS_ME)
  MENUITEMINFO mii;
//BugBug: this line should be in
//  BOOL         bByPos;
#endif

  switch (iMessage)
    {
      case WM_MENUSELECT:
        if ((WORD)MS_FLAGS(wParam, lParam)==(WORD)-1 && MS_MENU(wParam, lParam)==0)
          {
#ifndef WIN32
EndMenuHelp:
#endif
            SendMessage(hwndStatus, SB_SIMPLE, 0, 0L);
            break;
          }

          szString[0] = TEXT('\0');
#if defined(WINDOWS_ME)
          i = MS_ID(wParam, lParam);
//BugBug: this line should be in
          //bByPos = (MS_FLAGS(wParam, lParam) & MF_POPUP);

          memset(&mii, 0, SIZEOF(MENUITEMINFO ));
          mii.cbSize = sizeof(mii);
          mii.fMask = MIIM_TYPE;
          mii.cch = 0;  //If we ask for MIIM_TYPE, this must be set to zero!
                        //Otherwise, win95 attempts to copy the string too!
          if (GetMenuItemInfo((HMENU)MS_MENU(wParam, lParam), i, TRUE /*bByPos*/, &mii))
              mii.fState = mii.fType & MFT_RIGHTORDER ?SBT_RTLREADING :0;
#endif
        if (!(MS_FLAGS(wParam, lParam)&MF_SEPARATOR))
          {
            if (MS_FLAGS(wParam, lParam)&MF_POPUP)
              {
                /* We don't want to update immediately in case the menu is
                 * about to pop down, with an item selected.  This gets rid
                 * of some flashing text.
                 */
                bUpdateNow = FALSE;

                /* First check if this popup is in our list of popup menus
                 */
                for (lpwPopups=lpwIDs+2; *lpwPopups; lpwPopups+=2)
                  {
                    /* lpwPopups is a list of string ID/menu handle pairs
                     * and MS_ID(wParam, lParam) is the menu handle of the selected popup
                     */
                    if (*(lpwPopups+1) == (UINT)MS_ID(wParam, lParam))
                      {
                        wID = *lpwPopups;
                        goto LoadTheString;
                      }
                  }

                /* Check if the specified popup is in the main menu;
                 * note that if the "main" menu is in the system menu,
                 * we will be OK as long as the menu is passed in correctly.
                 * In fact, an app could handle all popups by just passing in
                 * the proper hMainMenu.
                 */
                if ((HMENU)MS_MENU(wParam, lParam) == hMainMenu)
                  {
#ifdef  WIN32
                    i = MS_ID(wParam, lParam);
#else   // WIN32
                    i = GetMenuIndex((HMENU)MS_MENU(wParam, lParam), (HMENU)MS_ID(wParam, lParam));
                    if (i >= 0)
#endif  // WIN32
                      {
                        if (IsMaxedMDI(hMainMenu))
                          {
                            if (!i)
                              {
                                wID = IDS_SYSMENU;
                                hAppInst = HINST_THISDLL;
                                goto LoadTheString;
                              }
                            else
                                --i;
                          }
                        wID = (UINT)(i + lpwIDs[1]);
                        goto LoadTheString;
                      }
                  }

                /* This assumes all app defined popups in the system menu
                 * have been listed above
                 */
                if ((MS_FLAGS(wParam, lParam)&MF_SYSMENU))
                  {
                    wID = IDS_SYSMENU;
                    hAppInst = HINST_THISDLL;
                    goto LoadTheString;
                  }

                goto NoString;
              }
            else if (MS_ID(wParam, lParam) >= MINSYSCOMMAND)
              {
                wID = (UINT)(MS_ID(wParam, lParam) + MH_SYSMENU);
                hAppInst = HINST_THISDLL;
              }
            else
              {
                wID = (UINT)(MS_ID(wParam, lParam) + lpwIDs[0]);
              }

LoadTheString:
            if (hAppInst == HINST_THISDLL)
                LocalizedLoadString(wID, szString, ARRAYSIZE(szString));
            else
                LoadString(hAppInst, wID, szString, ARRAYSIZE(szString));
          }

NoString:
#if defined(WINDOWS_ME)
        SendMessage(hwndStatus, SB_SETTEXT, mii.fState|SBT_NOBORDERS|255,
              (LPARAM)(LPSTR)szString);
#else
        SendMessage(hwndStatus, SB_SETTEXT, SBT_NOBORDERS|255,
              (LPARAM)(LPTSTR)szString);
#endif
        SendMessage(hwndStatus, SB_SIMPLE, 1, 0L);

        if (bUpdateNow)
            UpdateWindow(hwndStatus);
        break;

#ifndef WIN32

      case WM_COMMAND:
        switch (CMD_NOTIFY(wParam, lParam))
          {
#ifdef WANT_SUCKY_HEADER
      // BUGBUG: these are now WM_NOTIFY messages
            case HBN_BEGINDRAG:
              bUpdateNow = FALSE;
              wID = IDS_HEADER;
              goto BeginSomething;

            case HBN_BEGINADJUST:
              wID = IDS_HEADERADJ;
              goto BeginSomething;
#endif
            case TBN_BEGINADJUST:
              /* We don't want to update immediately in case the operation is
               * aborted immediately.
               */
              bUpdateNow = FALSE;
              wID = IDS_TOOLBARADJ;
              goto BeginSomething;

BeginSomething:
              SendMessage(hwndStatus, SB_SIMPLE, 1, 0L);
              hAppInst = HINST_THISDLL;
              goto LoadTheString;

            case TBN_BEGINDRAG:
              MenuHelp(WM_MENUSELECT, (WPARAM)CMD_CTRL(wParam, lParam), 0L,
                    hMainMenu, hAppInst, hwndStatus, lpwIDs);
              break;
#ifdef WANT_SUCKY_HEADER
            case HBN_ENDDRAG:
            case HBN_ENDADJUST:
#endif
            case TBN_ENDDRAG:
            case TBN_ENDADJUST:
              goto EndMenuHelp;

            default:
              break;
          }
        break;
#endif  // !WIN32

      default:
        break;
    }
}


BOOL WINAPI ShowHideMenuCtl(HWND hWnd, WPARAM wParam, LPINT lpInfo)
{
  HWND hCtl;
  UINT uTool, uShow = MF_UNCHECKED | MF_BYCOMMAND;
  HMENU hMainMenu;
  BOOL bRet = FALSE;

  hMainMenu = IntToPtr_(HMENU, lpInfo[1]);

  for (uTool=0; ; ++uTool, lpInfo+=2)
    {
      if ((WPARAM)lpInfo[0] == wParam)
          break;
      if (!lpInfo[0])
          goto DoTheCheck;
    }

  if (!(GetMenuState(hMainMenu, (UINT) wParam, MF_BYCOMMAND)&MF_CHECKED))
      uShow = MF_CHECKED | MF_BYCOMMAND;

  switch (uTool)
    {
      case 0:
        bRet = SetMenu(hWnd, (HMENU)((uShow&MF_CHECKED) ? hMainMenu : 0));
        break;

      default:
        hCtl = GetDlgItem(hWnd, lpInfo[1]);
        if (hCtl)
          {
            ShowWindow(hCtl, (uShow&MF_CHECKED) ? SW_SHOW : SW_HIDE);
            bRet = TRUE;
          }
        else
            uShow = MF_UNCHECKED | MF_BYCOMMAND;
        break;
    }

DoTheCheck:
  CheckMenuItem(hMainMenu, (UINT) wParam, uShow);

#ifdef MAININSYS
  hMainMenu = GetSubMenu(GetSystemMenu(hWnd, FALSE), 0);
  if (hMainMenu)
      CheckMenuItem(hMainMenu, (UINT) wParam, uShow);
#endif

  return(bRet);
}


void WINAPI GetEffectiveClientRect(HWND hWnd, LPRECT lprc, LPINT lpInfo)
{
  RECT rc;
  HWND hCtl;

  GetClientRect(hWnd, lprc);

  /* Get past the menu
   */
  for (lpInfo+=2; lpInfo[0]; lpInfo+=2)
    {
      hCtl = GetDlgItem(hWnd, lpInfo[1]);
      /* We check the style bit because the parent window may not be visible
       * yet (still in the create message)
       */
      if (!hCtl || !(GetWindowStyle(hCtl) & WS_VISIBLE))
          continue;

      GetWindowRect(hCtl, &rc);

      //
      // This will do the ScrrenToClient functionality, plus
      // it will return a good rect (left < right) when the
      // hWnd parent is RTL mirrored. [samera]
      //
      MapWindowPoints(HWND_DESKTOP, hWnd, (PPOINT)&rc, 2);

      SubtractRect(lprc, lprc, &rc);
    }
}

#if 0
// BUGBUG: nuke this stuff for WIN32

#define NibbleToChar(x) (N2C[x])
static char N2C[] =
  {
    '0', '1', '2', '3', '4', '5', '6', '7',
    '8', '9', 'A', 'B', 'C', 'D', 'E', 'F',
  } ;

BOOL WINAPI MyWritePrivateProfileStruct(LPCSTR szSection, LPCSTR szKey,
      LPVOID lpStruct, UINT uSizeStruct, LPCSTR szFile)
{
  PSTR pLocal, pTemp;
  BOOL bRet;
  BYTE FAR *lpByte;

  /* NULL lpStruct erases the the key */

  if (lpStruct == NULL) {
      if (szFile && *szFile)
          return WritePrivateProfileString(szSection, szKey, NULL, szFile);
      else
          WriteProfileString(szSection, szKey, NULL);
  }

  pLocal = (PSTR)LocalAlloc(LPTR, uSizeStruct*2 + 1);
  if (!pLocal)
      return(FALSE);

  lpByte = lpStruct;

  for (pTemp=pLocal; uSizeStruct>0; --uSizeStruct, ++lpByte)
    {
      BYTE bStruct;

      bStruct = *lpByte;
      *pTemp++ = NibbleToChar((bStruct>>4)&0x000f);
      *pTemp++ = NibbleToChar(bStruct&0x000f);
    }

  *pTemp = '\0';

  if (szFile && *szFile)
      bRet = WritePrivateProfileString(szSection, szKey, pLocal, szFile);
  else
      bRet = WriteProfileString(szSection, szKey, pLocal);

  LocalFree((HLOCAL)pLocal);
  return(bRet);
}

/* Note that the following works for both upper and lower case, and will
 * return valid values for garbage chars
 */
#define CharToNibble(x) ((x)>='0'&&(x)<='9' ? (x)-'0' : ((10+(x)-'A')&0x000f))

BOOL WINAPI MyGetPrivateProfileStruct(LPCSTR szSection, LPCSTR szKey,
      LPVOID lpStruct, UINT uSizeStruct, LPCSTR szFile)
{
  PSTR pLocal, pTemp;
  int nLen;
  BYTE FAR *lpByte;

  nLen = uSizeStruct*2 + 10;
  pLocal = (PSTR)LocalAlloc(LPTR, nLen);
  if (!pLocal)
      return(FALSE);

  if (szFile && *szFile)
      nLen = GetPrivateProfileString(szSection, szKey, c_szNULL, pLocal, nLen,
            szFile);
  else
      nLen = GetProfileString(szSection, szKey, c_szNULL, pLocal, nLen);
  if ((UINT)nLen != uSizeStruct*2)
    {
      LocalFree((HLOCAL)pLocal);
      return(FALSE);
    }

  lpByte = lpStruct;

  for (pTemp=pLocal; uSizeStruct>0; --uSizeStruct, ++lpByte)
    {
      BYTE bStruct;
      char cTemp;

      cTemp = *pTemp++;
      bStruct = (BYTE)CharToNibble(cTemp);
      cTemp = *pTemp++;
      bStruct = (BYTE)((bStruct<<4) | CharToNibble(cTemp));

      *lpByte = bStruct;
    }

  LocalFree((HLOCAL)pLocal);
  return(TRUE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\monthcal.h ===
#define CAL_COLOR_TODAY     0x000000ff

#define CALMONTHMAX     12
#define CALROWMAX       6
#define CALCOLMAX       7
#define CAL_DEF_SELMAX  7

// BUGBUG raymondc - these metrics do not scale with user settings
#define CALBORDER       6

//  The formulas for DX_ARROWMARGIN and D[XY]_CALARROW are chosen so on most
//  systems they come out approximately equal to the values you got
//  in IE4.  (The IE4 values were hard-coded and therefore incompatible
//  with accessibility.)

#define DX_ARROWMARGIN      (5 * g_cxBorder)
#define DX_CALARROW         (g_cyHScroll * 4 / 3)
#define DY_CALARROW         g_cyHScroll

#define DXRING_SPIRAL       8
#define DXEDGE_SPIRAL       8

// BUGBUG raymondc - msecautospin should scale on doubleclicktime
#define CAL_MSECAUTOSPIN        350
#define CAL_SECTODAYTIMER       (2 * 60)
#define CAL_IDAUTOSPIN          1
#define CAL_TODAYTIMER          2

#define CCHMAXMONTH     42
#define CCHMAXABBREVDAY 11
#define CCHMAXMARK      10

#define SEL_BEGIN       1
#define SEL_END         2
#define SEL_DOT         3
#define SEL_MID         4

//
//  For each month we display, we have to compute a bunch of metrics
//  to track the stuff we put into the header area.
//
//  The five values represent the following points in the string:
//
//          Mumble January Mumble 1999 Mumble
//         |      |       |      |    |
//         |      |     MonthEnd |    YearEnd
//         Start  MonthStart     YearStart
//
//  Note that it is possible for YearStart to be less than MonthStart if the
//  year comes before the month.  (e.g., "1999 January")
//
//  These values already take RTL mirroring into account.
//
//  NOTE!  IMM_MONTHSTART and IMM_YEARSTART are also used as flags,
//  so they both need to be powers of 2.
//
#define IMM_START        0
#define IMM_DATEFIRST    1
#define IMM_MONTHSTART   1
#define IMM_YEARSTART    2
#define IMM_MONTHEND     3
#define IMM_YEAREND      4
#define IMM_DATELAST     4
#define DMM_STARTEND    2           // Difference between START and END
#define CCH_MARKERS      4          // There are four markers

typedef struct MONTHMETRICS {
    int     rgi[5];
} MONTHMETRICS, *PMONTHMETRICS;

// This stuff used to be global
typedef struct tagLOCALEINFO {
    TCHAR szToday[32];        // "Today:"
    TCHAR szGoToToday[64];    // "&Go to today"

    TCHAR szMonthFmt[8];      // "MMMM"
    TCHAR szMonthYearFmt[16+CCH_MARKERS]; // "\1MMMM\3 \2yyyy\4" -- see MCInsertMarkers

    TCHAR rgszMonth[12][CCHMAXMONTH];
    TCHAR rgszDay[7][CCHMAXABBREVDAY];
    int dowStartWeek;       // LOCALE_IFIRSTDAYOFWEEK (0 = mon, 1 = tue, 6 = sat)
    int firstWeek;          // LOCALE_IFIRSTWEEKOFYEAR

    TCHAR *rgpszMonth[12];  // pointers into rgszMonth
    TCHAR *rgpszDay[7];     // pointers into rgszDay
} LOCALEINFO, *PLOCALEINFO, *LPLOCALEINFO;


//
// SUBEDITCONTROL stuff
//

//
// Note: SECIncrFocus assumes that SUBEDIT_NONE is numerical value -1
//
#define SUBEDIT_NONE -1 // no field is being edited
#define SUBEDIT_ALL  -2 // all fields are being edited (DTS_APPCANPARSE)
enum {
    SE_ERA = 1,    
    SE_YEAR,
    SE_YEARALT,         // see SEGetTimeDateFormat
    SE_MONTH,
    SE_MONTHALT,        // see SEGetTimeDateFormat
    SE_DAY,
    SE_DATELAST = SE_DAY,
    SE_MARK,            // "AM" or "PM" indicator
    SE_HOUR,
    SE_MINUTE,
    SE_SECOND,
    SE_STATIC,
    SE_APP,
    SE_MAX
};

#define SE_YEARLIKE(s)      ((s) == SE_YEAR || (s) == SE_YEARALT)
#define SE_DATELIKE(s)      InRange(s, SE_ERA, SE_DATELAST)

#include <pshpack8.h>
typedef struct tagSUBEDIT {
    int     id;         // SE_ value above
    RECT    rc;         // bounding box for display

    LPWORD  pval;       // current value (in a SYSTEMTIME struct)
    UINT    min;        // min value
    UINT    max;        // max value
    int     cIncrement; // increment value

    int     cchMax;     // max allowed chars
    int     cchEdit;    // current number chars entered so far
    UINT    valEdit;    // value entered so far
    UINT    flDrawText; // flags for DrawText

    LPCTSTR pv;         // formatting string

    BOOL    fReadOnly;  // can this subedit be edited (receive focus)?
} SUBEDIT, * PSUBEDIT, *LPSUBEDIT;
#include <poppack.h>


//
//  There are three types of calendars we support
//
//  -   Gregorian (Western).  Any calendar not otherwise supported is forced
//      into Gregorian mode.
//
//  -   Offset.  The year is merely a fixed offset from the Gregorian year.
//      This is the style used by the Korean and Thai calendars.
//
//  -   Era.  The calendar consists of multiple eras, and the year is
//      relative to the start of the enclosing era.  This is the style
//      used by the Japan and Taiwan calendars.  Eras are strangest because
//      an era need not start on January 1!
//
typedef struct tagCALENDARTYPE {
    CALID   calid;        // Calendar id number (CAL_GREGORIAN, etc.)
    LCID    lcid;         // Usually LOCALE_USER_DEFAULT, but forced to US for unsupported calendars
    int     dyrOffset;    // The calendar offset (0 for Gregorian and Era)
    HDPA    hdpaYears;    // If fEra, then array of year info
    HDPA    hdpaEras;     // If fEra, then array of era names
} CALENDARTYPE, *PCALENDARTYPE;

#define BUDDHIST_BIAS   543
#define KOREAN_BIAS     2333

#define ISERACALENDAR(pct)            ((pct)->hdpaEras)

#define GregorianToOther(pct, yr)     ((yr) + (pct)->dyrOffset)
#define OtherToGregorian(pct, yr)     ((yr) - (pct)->dyrOffset)

typedef struct tagSUBEDITCONTROL {
    LPCONTROLINFO pci;  // looks like this guy needs access to the hwnd
    BOOL fNone;         // allow scrolling into SUBEDIT_NONE
    HFONT hfont;        // font to draw text with
    RECT rc;            // rect for subedits
    int xScroll;        // amount pse array is scrolled
    int iseCur;         // subedit with current selection (SUBEDIT_NONE for no selection)
    int cse;            // count of subedits in pse array
    SYSTEMTIME st;      // current time pse represents (pse points into this)
    LPTSTR szFormat;    // format string as parsed (pse points into this)
    PSUBEDIT pse;       // subedit array
    TCHAR   cDelimeter; // delimiter between subedits (parsed from fmt string)
    TCHAR szDelimeters[15]; // delimiters between date/time fields (from resfile)
    CALENDARTYPE ct;    // information about the calendar
    BITBOOL fMirrorSEC:1; // Whether or not to mirror the SubEditControls
    BITBOOL fSwapTimeMarker:1; // Whether we need to swap the AM/PM symbol around or not
} SUBEDITCONTROL, * PSUBEDITCONTROL, *LPSUBEDITCONTROL;

#define SECYBORDER 2
#define SECXBORDER 2

/*
 *    Multiple Month Calendar Control
 */
typedef struct tagMONTHCAL {
    CONTROLINFO ci;     // all controls start with this
    LOCALEINFO li;      // stuff that used to be global

    HINSTANCE hinstance;

    HWND    hwndEdit;   // non-NULL iff dealing with user-click on year
    HWND    hwndUD;     // UpDown control associated with the hwndEdit

    HPEN    hpen;
    HPEN    hpenToday;

    HFONT   hfont;                // stock font, don't destroy
    HFONT   hfontBold;            // created font, so we need to destroy
    
    COLORREF clr[MCSC_COLORCOUNT];    
    
    int     dxCol;             // font info, based on bold to insure that we get enough space
    int     dyRow;
    int     dxMonth;
    int     dyMonth;
    int     dxYearMax;
    int     dyToday;
    int     dxToday;

    int     dxArrowMargin;
    int     dxCalArrow;
    int     dyCalArrow;

    HMENU   hmenuCtxt;
    HMENU   hmenuMonth;

    SYSTEMTIME  stMin;          // minimum selectable date
    SYSTEMTIME  stMax;          // maximum selectable date

    DWORD   cSelMax;

    SYSTEMTIME  stToday;
    SYSTEMTIME  st;             // the selection if not multiselect
                                // the beginning of the selection if multiselect
    SYSTEMTIME  stEndSel;       // the end of the selection if multiselect
    SYSTEMTIME  stStartPrev;    // prev selection beginning (only in multiselect)
    SYSTEMTIME  stEndPrev;      // prev selection end (only in multiselect)

    SYSTEMTIME  stAnchor;       // anchor date in shift-click selection

    SYSTEMTIME  stViewFirst;    // first visible date (DAYSTATE - grayed out)
    SYSTEMTIME  stViewLast;     // last visible date (DAYSTATE - grayed out)
    
    SYSTEMTIME  stMonthFirst;   // first month (stMin adjusted)
    SYSTEMTIME  stMonthLast;    // last month (stMax adjusted)
    int         nMonths;        // number of months being shown (stMonthFirst..stMonthLast)

    UINT_PTR    idTimer;
    UINT_PTR    idTimerToday;

    int     nViewRows;          // number of rows of months shown
    int     nViewCols;          // number of columns of months shown

    RECT    rcPrev;             // rect for prev month button (in window coords)
    RECT    rcNext;             // rect for next month button (in window coords)

    RECT    rcMonthName;        // rect for the month name (in relative coords)
                                // (actually, the rect for the titlebar area of
                                // each month).

    RECT    rcDow;              // rect for days of week (in relative coords)
    RECT    rcWeekNum;          // rect for week numbers (in relative coords)
    RECT    rcDayNum;           // rect for day numbers  (in relative coords)

    int     iMonthToday;
    int     iRowToday;
    int     iColToday;

    RECT    rcDayCur;            // rect for the current selected day
    RECT    rcDayOld;

    RECT    rc;                  // window rc.
    RECT    rcCentered;          // rect containing the centered months

    // The following 4 ranges hold info about the displayed (DAYSTATE) months:
    // They are filled in from 0 to nMonths+1 by MCUpdateStartEndDates
    // NOTE: These are _one_ based indexed arrays of the displayed months    
    int     rgcDay[CALMONTHMAX + 2];    // # days in this month
    int     rgnDayUL[CALMONTHMAX + 2];  // last day in this month NOT visible when viewing next month

    int     dsMonth;             // first month stored in rgdayState
    int     dsYear;              // first year stored in rgdayState
    int     cds;                 // number of months stored in rgdayState
    MONTHDAYSTATE   rgdayState[CALMONTHMAX + 2];

    int     nMonthDelta;        // the amount to move on button press

    BOOL    fControl;
    BOOL    fShift;
    
    CALENDARTYPE ct;            // information about the calendar

    WORD    fFocus:1;
    WORD    fEnabled:1;
    WORD    fCapture:1;         // mouse captured

    WORD    fSpinPrev:1;
    WORD    fFocusDrawn:1;      // is focus rect currently drawn?
    WORD    fToday:1;           // today's date currently visible in calendar
    WORD    fNoNotify:1;        // don't notify parent window
    WORD    fMultiSelecting:1;  // Are we actually in the process of selecting?
    WORD    fForwardSelect:1;
    WORD    fFirstDowSet:1;
    WORD    fTodaySet:1;
    WORD    fMinYrSet:1;        // stMin has been set
    WORD    fMaxYrSet:1;        // stMax has been set
    WORD    fMonthDelta:1;      // nMonthDelta has been set
    WORD    fHeaderRTL:1;       // Is header string RTL ?

    //
    //  Metrics for each month we display.
    //
    MONTHMETRICS rgmm[CALMONTHMAX];

} MONTHCAL, * PMONTHCAL, *LPMONTHCAL;


#define MonthCal_GetPtr(hwnd)      (MONTHCAL*)GetWindowPtr(hwnd, 0)
#define MonthCal_SetPtr(hwnd, p)   (MONTHCAL*)SetWindowPtr(hwnd, 0, p)

#define MonthCal_IsMultiSelect(pmc)     ((pmc)->ci.style & MCS_MULTISELECT)
#define MonthCal_IsDayState(pmc)        ((pmc)->ci.style & MCS_DAYSTATE)
#define MonthCal_ShowWeekNumbers(pmc)   ((pmc)->ci.style & MCS_WEEKNUMBERS)
#define MonthCal_ShowTodayCircle(pmc)   (!((pmc)->ci.style & MCS_NOTODAYCIRCLE))
#define MonthCal_ShowToday(pmc)         (!((pmc)->ci.style & MCS_NOTODAY))


//
// DATEPICK stuff
//

#define DPYBORDER       2
#define DPXBUFFER       2
#define DP_DXBUTTON     15
#define DP_DYBUTTON     15
#define DP_IDAUTOSPIN   1
#define DP_MSECAUTOSPIN 200
#define DATEPICK_UPDOWN 1000

#define DTP_FORMATLENGTH 128

enum {
    DP_SEL_DOW = 0,
    DP_SEL_YEAR,
    DP_SEL_MONTH,
    DP_SEL_DAY,
    DP_SEL_SEP1,
    DP_SEL_SEP2,
    DP_SEL_NODATE,
    DP_SEL_MAX
};

typedef struct tagDATEPICK {
    CONTROLINFO ci;     // all controls start with this

    HWND        hwndUD;
    HWND        hwndMC;
    HFONT       hfontMC;    // font for drop down cal

    COLORREF clr[MCSC_COLORCOUNT];

    // HACK! stMin and stMax must remain in order and adjacent
    SYSTEMTIME  stMin;      // minimum date we allow
    SYSTEMTIME  stMax;      // maximum date we allow
    SYSTEMTIME  stPrev;     // most recent date notified
    SUBEDITCONTROL sec;     // current date

    RECT        rcCheck;    // location of checkbox iff fShowNone
    RECT        rc;         // size of SEC space
    RECT        rcBtn;      // location of dropdown or updown
    int         iseLastActive; // which subedit was active when we were last active?
    WPARAM      gdtr;       // Did app set min and/or max? (GDTR_MIN|GDTR_MAX)

    BITBOOL         fEnabled:1;
    BITBOOL         fUseUpDown:1;
    BITBOOL         fFocus:1;
    BITBOOL         fNoNotify:1;
    BITBOOL         fCapture:1;
    BITBOOL         fShow:1;        // TRUE iff we should continue to show MonthCal

    BITBOOL         fCheck:1;       // TRUE iff the checkbox is checked
    BITBOOL         fCheckFocus:1;  // TRUE iff the checkbox has focus

    BITBOOL         fLocale:1;      // TRUE iff the format string is LOCALE dependent
    BITBOOL         fHasMark:1;      // true iff has am/pm in current format
    BITBOOL         fFreeEditing:1; // TRUE if in the middle of a free-format edit
} DATEPICK, * PDATEPICK, *LPDATEPICK;

#define DatePick_ShowCheck(pdp)     ((pdp)->ci.style & DTS_SHOWNONE)
#define DatePick_AppCanParse(pdp)   ((pdp)->ci.style & DTS_APPCANPARSE)
#define DatePick_RightAlign(pdp)    ((pdp)->ci.style & DTS_RIGHTALIGN)

#define DatePick_GetPtr(hwnd)      (DATEPICK*)GetWindowPtr(hwnd, 0)
#define DatePick_SetPtr(hwnd, p)   (DATEPICK*)SetWindowPtr(hwnd, 0, p)

#define CopyDate(stS, stD)  ((stD).wYear = (stS).wYear,(stD).wMonth = (stS).wMonth,(stD).wDay = (stS).wDay)
#define CopyTime(stS, stD)  ((stD).wHour = (stS).wHour,(stD).wMinute = (stS).wMinute,(stD).wSecond = (stS).wSecond)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\monthcal.c ===
#include "ctlspriv.h"

#include "scdttime.h"
#include "monthcal.h"
#include "prshti.h"         // for StrDup_AtoW

// TODO
//
// #6329: When Min/Max range is set, then dates before the min
// or after the max are painted in the normal date color. They
// should be painted with MCSC_TRAILINGTEXT color. (Or we should
// add a new color to cover this case.) Feature requested by Jobi George
//
// 9577: We want a DAYSTATE like structure for the background
// color of dates. For highlighting. Perhaps a COLORSTATE per
// registered background color.
//

// private message
#define MCMP_WINDOWPOSCHANGED (MCM_FIRST - 1) // MCM_FIRST is way over WM_USER
#define DTMP_WINDOWPOSCHANGED (DTM_FIRST - 1) // DTM_FIRST is way over WM_USER

// MONTHCAL
LRESULT CALLBACK MonthCalWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
LRESULT MCNcCreateHandler(HWND hwnd);
LRESULT MCCreateHandler(MONTHCAL *pmc, HWND hwnd, LPCREATESTRUCT lpcs);
LRESULT MCOnStyleChanging(MONTHCAL *pmc, UINT gwl, LPSTYLESTRUCT pinfo);
LRESULT MCOnStyleChanged(MONTHCAL *pmc, UINT gwl, LPSTYLESTRUCT pinfo);
void MCCalcSizes(MONTHCAL *pmc);
void MCHandleSetFont(MONTHCAL *pmc, HFONT hfont, BOOL fRedraw);
void MCPaint(MONTHCAL *pmc, HDC hdc);
void MCPaintMonth(MONTHCAL *pmc, HDC hdc, RECT *prc, int iMonth, int iYear, int iIndex,
                  BOOL fDrawPrev, BOOL fDrawNext, HBRUSH hbrSelect);
void MCNcDestroyHandler(HWND hwnd, MONTHCAL *pmc, WPARAM wParam, LPARAM lParam);
void MCRecomputeSizing(MONTHCAL *pmc, RECT *prect);
LRESULT MCSizeHandler(MONTHCAL *pmc, RECT *prc);
void MCUpdateMonthNamePos(MONTHCAL *pmc);
void MCUpdateStartEndDates(MONTHCAL *pmc, SYSTEMTIME *pstStart);
void MCGetRcForDay(MONTHCAL *pmc, int iMonth, int iDay, RECT *prc);
void MCGetRcForMonth(MONTHCAL *pmc, int iMonth, RECT *prc);
void MCUpdateToday(MONTHCAL *pmc);
void MCUpdateRcDayCur(MONTHCAL *pmc, SYSTEMTIME *pst);
void MCUpdateDayState(MONTHCAL *pmc);
int MCGetOffsetForYrMo(MONTHCAL *pmc, int iYear, int iMonth);
int MCIsSelectedDayMoYr(MONTHCAL *pmc, int iDay, int iMonth, int iYear);
BOOL MCIsBoldOffsetDay(MONTHCAL *pmc, int nDay, int iIndex);
BOOL FGetOffsetForPt(MONTHCAL *pmc, POINT pt, int *piOffset);
BOOL FGetRowColForRelPt(MONTHCAL *pmc, POINT ptRel, int *piRow, int *piCol);
BOOL FGetDateForPt(MONTHCAL *pmc, POINT pt, SYSTEMTIME *pst,
                   int* piDay, int* piCol, int* piRow, LPRECT prcMonth);
LRESULT MCContextMenu(MONTHCAL *pmc, WPARAM wParam, LPARAM lParam);
LRESULT MCLButtonDown(MONTHCAL *pmc, WPARAM wParam, LPARAM lParam);
LRESULT MCLButtonUp(MONTHCAL *pmc, WPARAM wParam, LPARAM lParam);
LRESULT MCMouseMove(MONTHCAL *pmc, WPARAM wParam, LPARAM lParam);
LRESULT MCHandleTimer(MONTHCAL *pmc, WPARAM wParam);
LRESULT MCHandleKeydown(MONTHCAL *pmc, WPARAM wParam, LPARAM lParam);
LRESULT MCHandleChar(MONTHCAL *pmc, WPARAM wParam, LPARAM lParam);
int MCIncrStartMonth(MONTHCAL *pmc, int nDelta, BOOL fDelayDayChange);
void MCGetTitleRcsForOffset(MONTHCAL* pmc, int iOffset, LPRECT prcMonth, LPRECT prcYear);
BOOL MCSetDate(MONTHCAL *pmc, SYSTEMTIME *pst);
void MCNotifySelChange(MONTHCAL *pmc, UINT uMsg);
void MCInvalidateDates(MONTHCAL *pmc, SYSTEMTIME *pst1, SYSTEMTIME *pst2);
void MCInvalidateMonthDays(MONTHCAL *pmc);
void MCSetToday(MONTHCAL* pmc, SYSTEMTIME* pst);
void MCGetTodayBtnRect(MONTHCAL *pmc, RECT *prc);
void GetYrMoForOffset(MONTHCAL *pmc, int iOffset, int *piYear, int *piMonth);
BOOL FScrollIntoView(MONTHCAL *pmc);
void MCFreeCalendarInfo(PCALENDARTYPE pct);
void MCGetCalendarInfo(PCALENDARTYPE pct);
BOOL MCIsDateStringRTL(TCHAR tch);

// DATEPICK
LRESULT CALLBACK DatePickWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
LRESULT DPNcCreateHandler(HWND hwnd);
LRESULT DPCreateHandler(DATEPICK *pdp, HWND hwnd, LPCREATESTRUCT lpcs);
LRESULT DPOnStyleChanging(DATEPICK *pdp, UINT gwl, LPSTYLESTRUCT pinfo);
LRESULT DPOnStyleChanged(DATEPICK *pdp, UINT gwl, LPSTYLESTRUCT pinfo);
void DPHandleLocaleChange(DATEPICK *pdp);
void DPDestroyHandler(HWND hwnd, DATEPICK *pdp, WPARAM wParam, LPARAM lParam);
void DPHandleSetFont(DATEPICK *pdp, HFONT hfont, BOOL fRedraw);
void DPPaint(DATEPICK *pdp, HDC hdc);
void DPLBD_MonthCal(DATEPICK *pdp, BOOL fLButtonDown);
LRESULT DPLButtonDown(DATEPICK *pdp, WPARAM wParam, LPARAM lParam);
LRESULT DPLButtonUp(DATEPICK *pdp, WPARAM wParam, LPARAM lParam);
void DPRecomputeSizing(DATEPICK *pdp, RECT *prect);
LRESULT DPHandleKeydown(DATEPICK *pdp, WPARAM wParam, LPARAM lParam);
LRESULT DPHandleChar(DATEPICK *pdp, WPARAM wParam, LPARAM lParam);
void DPNotifyDateChange(DATEPICK *pdp);
BOOL DPSetDate(DATEPICK *pdp, SYSTEMTIME *pst, BOOL fMungeDate);
void DPDrawDropdownButton(DATEPICK *pdp, HDC hdc, BOOL fPressed);
void SECGetSystemtime(LPSUBEDITCONTROL psec, LPSYSTEMTIME pst);

static TCHAR const g_rgchMCName[] = MONTHCAL_CLASS;
static TCHAR const g_rgchDTPName[] = DATETIMEPICK_CLASS;

// MONTHCAL globals
#define g_szTextExtentDef TEXT("0000")
#define g_szNumFmt TEXT("%d")

//
//  Epoch = the beginning of the universe (the earliest date we support)
//  Armageddon = the end of the universe (the latest date we support)
//
//  Epoch is 14-sep-1752 because that's when the Gregorian calendar
//  kicked in.  The day before 14-sep-1752 was 2-sep-1752 (in British
//  and US history; other countries switched at other times).
//
//  Armageddon is 31-dec-9999 because we assume four digits for years
//  is enough.  (Oh no, the Y10K problem...)
//
const SYSTEMTIME c_stEpoch      = { 1752,  9, 0, 14,  0,  0,  0,   0 };
const SYSTEMTIME c_stArmageddon = { 9999, 12, 0, 31, 23, 59, 59, 999 };

void FillRectClr(HDC hdc, LPRECT prc, COLORREF clr)
{
    COLORREF clrSave = SetBkColor(hdc, clr);
    ExtTextOut(hdc,0,0,ETO_OPAQUE,prc,NULL,0,NULL);
    SetBkColor(hdc, clrSave);
}

BOOL InitDateClasses(HINSTANCE hinst)
{
    WNDCLASS wndclass;

    if (GetClassInfo(hinst, g_rgchMCName, &wndclass))
    {
        // we're already registered
        DebugMsg(TF_MONTHCAL, TEXT("mc: Date Classes already initialized."));
        return(TRUE);
    }

    wndclass.style          = CS_GLOBALCLASS;
    wndclass.lpfnWndProc    = MonthCalWndProc;
    wndclass.cbClsExtra     = 0;
    wndclass.cbWndExtra     = sizeof(LPVOID);
    wndclass.hInstance      = hinst;
    wndclass.hIcon          = NULL;
    wndclass.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1);
    wndclass.lpszMenuName   = NULL;
    wndclass.lpszClassName  = g_rgchMCName;

    if (!RegisterClass(&wndclass))
    {
        DebugMsg(DM_WARNING, TEXT("mc: MonthCalClass failed to initialize"));
        return(FALSE);
    }

    wndclass.lpfnWndProc    = DatePickWndProc;
    wndclass.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1);
    wndclass.lpszClassName  = g_rgchDTPName;

    if (!RegisterClass(&wndclass))
    {
        DebugMsg(DM_WARNING, TEXT("mc: DatePickClass failed to initialize"));
        return(FALSE);
    }

    DebugMsg(TF_MONTHCAL, TEXT("mc: Date Classes initialized successfully."));
    return(TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
// MonthCal stuff
//
////////////////////////////////////////////////////////////////////////////

////////////////////////////////////
//
// MCInsert/RemoveMarkers
//
// QuickSummary:  Convert the string "MMMM yyyy" into "\1MMMM\3 \2yyyy\4".
//
// In order to lay out the month/year info in the header, we have to be
// able to extract the month and year out of the formatted string so we
// know what their rectangles are.  We do this by wrapping the month and
// year inserts with markers so we can extract them after formatting.
//
// Since \1 through \4 are control characters, they won't conflict with
// displayable characters in the actual format string.  And just to play it
// safe, if we actually see a format character, we erase it from the string.
//
// MCInsertMarkers inserts the markers into the output string so we can
// extract the substrings later.  Quotation marks are funky since you can
// write a format of "'The' mm'''th month of' yyyy".  Note that a simple
// even-odd test works for detecting whether we are inside or outside
// quotation marks, even in the nested quotation mark case.
//
void MCInsertMarkers(LPTSTR pszOut, LPCTSTR pszIn)
{
    BOOL fInQuote = FALSE;
    UINT flSeen = 0;
    UINT flThis;

    for (;;)
    {
        TCHAR ch = *pszIn;
        switch (ch) {

        // At end of string, terminate the output buffer and go home
        case TEXT('\0'):
            *pszOut = TEXT('\0');
            return;

        case TEXT('m'):
        case TEXT('M'):
            flThis = IMM_MONTHSTART;
            goto CheckMarker;

        case TEXT('y'):
            flThis = IMM_YEARSTART;
            goto CheckMarker;

        CheckMarker:
            // If inside a quotation mark or we've already done this guy,
            // then just treat it as a regular character.
            if (fInQuote || (flSeen & flThis))
                goto CopyChar;

            flSeen |= flThis;

            *pszOut++ = (TCHAR)flThis;
            // Don't need to use CharNext because we know *pszIn is "m" "M" or "y"
            for ( ; *pszIn == ch; pszIn++)
            {
                *pszOut++ = ch;
            }
            *pszOut++ = (TCHAR)(flThis + DMM_STARTEND);

            // Restart the loop so we re-parse the character at *pszIn
            continue;

        // Toggle the quotation mark gizmo if we see one, and then just
        // copy it.
        case '\'':
            fInQuote ^= TRUE;
            goto CopyChar;

        //
        //  Don't let these sneak into the output format or it
        //  will confuse us.
        //
        case IMM_MONTHSTART:
        case IMM_YEARSTART:
        case IMM_MONTHEND:
        case IMM_YEAREND:
            break;

        default:
        CopyChar:
            *pszOut++ = ch;
#ifndef UNICODE
            if (IsDBCSLeadByte(ch) && pszIn[1]) {
                *pszOut++ = *++pszIn;
            }
#endif
            break;

        }

        pszIn++;            // We handled the DBCS case already
    }

    // NOTREACHED
}

//
//  MCRemoveMarkers hunts down the marker characters and strips them out,
//  recording their locations in the optional MONTHMETRICS (as character
//  indices).
//

void MCRemoveMarkers(LPTSTR pszBuf, PMONTHMETRICS pmm)
{
    int iWrite, iRead;

    //
    //  If by some horrid error we can't find our markers, just pretend
    //  they were at the start of the string.
    //
    if (pmm) {
        pmm->rgi[IMM_MONTHSTART] = 0;
        pmm->rgi[IMM_YEARSTART ] = 0;
        pmm->rgi[IMM_MONTHEND  ] = 0;
        pmm->rgi[IMM_YEAREND   ] = 0;
    }

    iWrite = iRead = 0;
    for (;;)
    {
        TCHAR ch = pszBuf[iRead];
        switch (ch)
        {
        // At end of string, terminate the output buffer and go home
        case TEXT('\0'):
            pszBuf[iWrite] = TEXT('\0');
            return;

        // If we find a marker, eat it and remember its location
        case IMM_MONTHSTART:
        case IMM_YEARSTART:
        case IMM_MONTHEND:
        case IMM_YEAREND:
            if (pmm)
                pmm->rgi[ch] = iWrite;
            break;

        // Otherwise, just copy it to the output
        default:
            pszBuf[iWrite++] = ch;
#ifndef UNICODE
            if (IsDBCSLeadByte(ch) && pszBuf[iRead+1]) {
                pszBuf[iWrite++] = pszBuf[++iRead];
            }
#endif
            break;

        }
        iRead++;
    }
    // NOTREACHED
}

////////////////////////////////////
//
// Like LocalizedLoadString, except that we get the string from
// LOCAL_USER_DEFAULT instead of GetUserDefaultUILanguage().
//
// LOCALE_USER_DEFAULT is the same as GetUserDefaultLCID(), and
// LANGIDFROMLCID(GetUserDefaultLCID()) is the same as GetUserDefaultLangID().
//
// So we pass GetUserDefaultLangID() as the language.
//

int MCLoadString(UINT uID, LPWSTR lpBuffer, int nBufferMax)
{
    return CCLoadStringEx(uID, lpBuffer, nBufferMax, GetUserDefaultLangID());
}

////////////////////////////////////
//
// Get the localized calendar info
//
BOOL UpdateLocaleInfo(MONTHCAL* pmc, LPLOCALEINFO pli)
{
    int    i;
    TCHAR  szBuf[64];
    int    cch;
    LPTSTR pc = szBuf;


    //
    // Get information about the calendar (e.g., is it supported?)
    //
    MCGetCalendarInfo(&pmc->ct);

    //
    // Check if the calendar title is an RTL string
    //
    GetDateFormat(pmc->ct.lcid, 0, NULL, TEXT("MMMM"), szBuf, ARRAYSIZE(szBuf));
    pmc->fHeaderRTL = (WORD) MCIsDateStringRTL(szBuf[0]);

    //
    // get the short date format and sniff it to see if it displays the year
    // or month first
    //
    MCLoadString(IDS_MONTHFMT, pli->szMonthFmt, ARRAYSIZE(pli->szMonthFmt));

    //
    //  Try to get the MONTHYEAR format from NLS.  If not supported by NLS,
    //  then use the hard-coded value in our resources.  Note that we
    //  subtract 4 from the buffer size because we may insert up to four
    //  marker characters.
    //
    COMPILETIME_ASSERT(ARRAYSIZE(szBuf) >= ARRAYSIZE(pli->szMonthYearFmt));
    szBuf[0] = TEXT('\0');

    GetLocaleInfo(pmc->ct.lcid, LOCALE_SYEARMONTH,
                 szBuf, ARRAYSIZE(pli->szMonthYearFmt) - CCH_MARKERS);
    if (!szBuf[0]) {
        MCLoadString(IDS_MONTHYEARFMT, szBuf, ARRAYSIZE(pli->szMonthYearFmt) - CCH_MARKERS);
    }

    MCInsertMarkers(pli->szMonthYearFmt, szBuf);

    //
    //  BUGBUG - this code needs to change to use CAL_ values when we
    //  want to support multiple calendars.
    //

    //
    // Get the month names
    //
    for (i = 0; i < 12; i++)
    {
        cch = GetLocaleInfo(pmc->ct.lcid, LOCALE_SMONTHNAME1 + i,
                            pli->rgszMonth[i], CCHMAXMONTH);
        if (cch == 0)
            // the calendar is pretty useless without month names...
            return(FALSE);
    }

    //
    // Get the days of the week
    //
    for (i = 0; i < 7; i++)
    {
        cch = GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SABBREVDAYNAME1 + i,
                            pli->rgszDay[i], CCHMAXABBREVDAY);
        if (cch == 0)
            // the calendar is pretty useless without day names...
            return(FALSE);
    }

    //
    // If we haven't already set what the first day of the week is, get the
    // localized setting.
    //
    if (!pmc->fFirstDowSet)
    {
        cch = GetLocaleInfo(pmc->ct.lcid, LOCALE_IFIRSTDAYOFWEEK, szBuf, ARRAYSIZE(szBuf));
        if (cch > 0)
            pli->dowStartWeek = szBuf[0] - TEXT('0');
    }

    //
    // Get the first week of the year
    //
    cch = GetLocaleInfo(pmc->ct.lcid, LOCALE_IFIRSTWEEKOFYEAR, szBuf, ARRAYSIZE(szBuf));
    if (cch > 0)
        pli->firstWeek = szBuf[0] - TEXT('0');

    // Set up pointers
    for (i = 0; i < 12; i++)
        pli->rgpszMonth[i] = pli->rgszMonth[i];

    for (i = 0; i < 7; i++)
        pli->rgpszDay[i] = pli->rgszDay[i];

    // Get static strings
    MCLoadString(IDS_TODAY, pli->szToday, ARRAYSIZE(pli->szToday));
    MCLoadString(IDS_GOTOTODAY, pli->szGoToToday, ARRAYSIZE(pli->szGoToToday));

    // if we've been initialized
    if (pmc->hinstance)
    {
        SYSTEMTIME st;
        CopyDate(pmc->stMonthFirst, st);
        MCUpdateStartEndDates(pmc, &st);
    }
    return(TRUE);
}

void MCReloadMenus(MONTHCAL *pmc)
{
    int i;

    if (pmc->hmenuCtxt)
        DestroyMenu(pmc->hmenuCtxt);
    if (pmc->hmenuMonth)
        DestroyMenu(pmc->hmenuMonth);

    pmc->hmenuCtxt = CreatePopupMenu();
    if (pmc->hmenuCtxt)
        AppendMenu(pmc->hmenuCtxt, MF_STRING, 1, pmc->li.szGoToToday);

    pmc->hmenuMonth = CreatePopupMenu();
    if (pmc->hmenuMonth)
    {
        for (i = 0; i < 12; i++)
            AppendMenu(pmc->hmenuMonth, MF_STRING, i + 1, pmc->li.rgszMonth[i]);
    }
}

BOOL MCHandleEraseBkgnd(MONTHCAL* pmc, HDC hdc)
{
    RECT rc;

    GetClipBox(hdc, &rc);
    FillRectClr(hdc, &rc, pmc->clr[MCSC_BACKGROUND]);
    return TRUE;
}


LRESULT MCHandleHitTest(MONTHCAL* pmc, PMCHITTESTINFO phti)
{
    int iMonth;
    RECT rc;

    if (!phti || phti->cbSize != sizeof(MCHITTESTINFO))
        return -1;

    phti->uHit = MCHT_NOWHERE;

    MCGetTodayBtnRect(pmc, &rc);
    if (PtInRect(&rc, phti->pt) && MonthCal_ShowToday(pmc))
    {
        phti->uHit = MCHT_TODAYLINK;
    }
    else if (pmc->fSpinPrev = (WORD) PtInRect(&pmc->rcPrev, phti->pt))
    {
        phti->uHit = MCHT_TITLEBTNPREV;
    }
    else if (PtInRect(&pmc->rcNext, phti->pt))
    {
        phti->uHit = MCHT_TITLEBTNNEXT;
    }
    else if (FGetOffsetForPt(pmc, phti->pt, &iMonth))
    {
        RECT  rcMonth;   // bounding rect for month containg phti->pt
        POINT ptRel;     // relative point in a month
        int   month;
        int   year;

        MCGetRcForMonth(pmc, iMonth, &rcMonth);
        ptRel.x = phti->pt.x - rcMonth.left;
        ptRel.y = phti->pt.y - rcMonth.top;

        GetYrMoForOffset(pmc, iMonth, &year, &month);
        phti->st.wMonth = (WORD) month;
        phti->st.wYear  = (WORD) year;

        //
        // if calendar is showing week numbers and the point lies in the
        // the week numbers, get the date for day immediately to the right
        // of the week number containing the point
        //
        if (MonthCal_ShowWeekNumbers(pmc) && PtInRect(&pmc->rcWeekNum, ptRel))
        {
            phti->uHit |= MCHT_CALENDARWEEKNUM;
            phti->pt.x += pmc->rcDayNum.left;
            FGetDateForPt(pmc, phti->pt, &phti->st, NULL, NULL, NULL, NULL);
        }

        //
        // if the point lies in the days of the week header, then return
        // the day of the week containing the point
        //
        else if (PtInRect(&pmc->rcDow, ptRel))
        {
            int iRow;
            int iCol;

            phti->uHit |= MCHT_CALENDARDAY;
            ptRel.y = pmc->rcDayNum.top;
            FGetRowColForRelPt(pmc, ptRel, &iRow, &iCol);
            phti->st.wDayOfWeek = (WORD) iCol;
        }

        //
        // if the point lies in the actually calendar part, then return the
        // date containg the point
        //
        else if (PtInRect(&pmc->rcDayNum, ptRel))
        {
            int iDay;

            // we're in the calendar part!
            phti->uHit |= MCHT_CALENDAR;

            if (FGetDateForPt(pmc, phti->pt, &phti->st, &iDay, NULL, NULL, NULL))
            {
                phti->uHit |= MCHT_CALENDARDATE;

                // if it was beyond the bounds of the days we're showing
                // and also FGetDateForPt returns TRUE, then we're on the boundary
                // of the displayed months
                if (iDay <= 0)
                {
                    phti->uHit |= MCHT_PREV;
                }
                else if (iDay > pmc->rgcDay[iMonth + 1])
                {
                    phti->uHit |= MCHT_NEXT;
                }
            }
        }
        else
        {
            RECT rcMonthTitle;
            RECT rcYearTitle;

            // otherwise we're in the title

            phti->uHit |= MCHT_TITLE;
            MCGetTitleRcsForOffset(pmc, iMonth, &rcMonthTitle, &rcYearTitle);

            if (PtInRect(&rcMonthTitle, phti->pt))
            {
                phti->uHit |= MCHT_TITLEMONTH;
            }
            else if (PtInRect(&rcYearTitle, phti->pt))
            {
                phti->uHit |= MCHT_TITLEYEAR;
            }
        }
    }

    DebugMsg(TF_MONTHCAL, TEXT("mc: Hittest returns : %d %d %d %d)"),
             (int)phti->st.wDay,
             (int)phti->st.wMonth,
             (int)phti->st.wYear,
             (int)phti->st.wDayOfWeek
             );

    return phti->uHit;
}

void MonthCal_OnPaint(MONTHCAL *pmc, HDC hdc)
{
    if (hdc)
    {
        MCPaint(pmc, hdc);
    }
    else
    {
        PAINTSTRUCT ps;
        hdc = BeginPaint(pmc->ci.hwnd, &ps);
        MCPaint(pmc, hdc);
        EndPaint(pmc->ci.hwnd, &ps);
    }
}

BOOL MCGetDateFormatWithTempYear(PCALENDARTYPE pct, SYSTEMTIME *pst, LPCTSTR pszFormat, UINT uYear, LPTSTR pszBuf, UINT cchBuf)
{
    BOOL fRc;
    WORD wYear = pst->wYear;
    pst->wYear = (WORD)uYear;
    fRc = GetDateFormat(pct->lcid, 0, pst, pszFormat, pszBuf, cchBuf);
    if (!fRc)
    {
        // AIGH!  I hate Feburary 29.  In case we are Feb 29 1996 and the
        // user changes to a non-leap year, force the day to something valid
        // in February 1997 (or whatever year the user finally picked).
        //
        // We can't blindly smash the day to 1 because the era might change
        // in the middle of the month.
        WORD wDay = pst->wDay;

        ASSERT(pst->wDay == 29);
        pst->wDay = 28;
        fRc = GetDateFormat(pct->lcid, 0, pst, pszFormat, pszBuf, cchBuf);
        pst->wDay = wDay;
    }
    pst->wYear = wYear;
    return fRc;
}

void MCUpdateEditYear(MONTHCAL *pmc)
{
    TCHAR rgch[64];

    ASSERT(pmc->hwndEdit);

    EVAL(MCGetDateFormatWithTempYear(&pmc->ct, &pmc->st, TEXT("yyyy"), pmc->st.wYear, rgch, ARRAYSIZE(rgch)));

    SendMessage(pmc->hwndEdit, WM_SETTEXT, 0, (LPARAM)rgch);
}


LRESULT CALLBACK MonthCalWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    MONTHCAL *pmc;
    LRESULT lres = 0;

    if (uMsg == WM_NCCREATE)
        return(MCNcCreateHandler(hwnd));

    pmc = MonthCal_GetPtr(hwnd);
    if (pmc == NULL)
        return(DefWindowProc(hwnd, uMsg, wParam, lParam));

    // Dispatch the various messages we can receive
    switch (uMsg)
    {

    case WM_CREATE:
        CCCreateWindow();
        lres = MCCreateHandler(pmc, hwnd, (LPCREATESTRUCT)lParam);
        break;

        HANDLE_MSG(pmc, WM_ERASEBKGND, MCHandleEraseBkgnd);

    case WM_PRINTCLIENT:
    case WM_PAINT:
        MonthCal_OnPaint(pmc, (HDC)wParam);
        return(0);

    case WM_KEYDOWN:
        MCHandleKeydown(pmc, wParam, lParam);
        break;

    case WM_KEYUP:
        switch (wParam)
        {
        case VK_CONTROL:
            pmc->fControl = FALSE;
            break;

        case VK_SHIFT:
            pmc->fShift = FALSE;
            break;
        }
        break;


#if 0
    case WM_CHAR:
        MCHandleChar(pmc, wParam, lParam);
        break;
#endif

    case WM_CONTEXTMENU:
        MCContextMenu(pmc, wParam, lParam);
        break;

    case WM_LBUTTONDOWN:
        MCLButtonDown(pmc, wParam, lParam);
        break;

    case WM_LBUTTONUP:
        MCLButtonUp(pmc, wParam, lParam);
        break;

    case WM_MOUSEMOVE:
        MCMouseMove(pmc, wParam, lParam);
        break;

    case WM_GETFONT:
        lres = (LRESULT)pmc->hfont;
        break;

    case WM_SETFONT:
        MCHandleSetFont(pmc, (HFONT)wParam, (BOOL)LOWORD(lParam));
        MCSizeHandler(pmc, &pmc->rc);
        MCUpdateMonthNamePos(pmc);
        break;

    case WM_TIMER:
        MCHandleTimer(pmc, wParam);
        break;

    case WM_NCDESTROY:
        CCDestroyWindow();
        MCNcDestroyHandler(hwnd, pmc, wParam, lParam);
        break;

    case WM_ENABLE:
    {
        BOOL fEnable = wParam ? TRUE:FALSE;
        if (pmc->fEnabled != fEnable)
        {
            pmc->fEnabled = (WORD) fEnable;
            InvalidateRect(pmc->ci.hwnd, NULL, TRUE);
        }
        break;
    }

    case MCMP_WINDOWPOSCHANGED:
    case WM_SIZE:
    {
        RECT rc;

        if (uMsg==MCMP_WINDOWPOSCHANGED)
        {
            GetClientRect(pmc->ci.hwnd, &rc);
        }
        else
        {
            rc.left   = 0;
            rc.top    = 0;
            rc.right  = GET_X_LPARAM(lParam);
            rc.bottom = GET_Y_LPARAM(lParam);
        }

        lres = MCSizeHandler(pmc, &rc);
        break;
    }

    case WM_CANCELMODE:
        PostMessage(pmc->ci.hwnd, WM_LBUTTONUP, 0, 0xFFFFFFFF);
        break;

    case WM_SYSCOLORCHANGE:
        InitGlobalColors();
        break;

    case WM_WININICHANGE:
        InitGlobalMetrics(wParam);

        if (lParam == 0 ||
#ifdef UNICODE_WIN9x
            !lstrcmpiA((LPSTR)lParam, "Intl")
#else
            !lstrcmpi((LPTSTR)lParam, TEXT("Intl"))
#endif
           )
        {
            UpdateLocaleInfo(pmc, &pmc->li);
            MCReloadMenus(pmc);
            InvalidateRect(hwnd, NULL, TRUE);
            wParam = 0;             // force MCCalcSizes to happen
        }
        if (wParam == 0 || wParam == SPI_SETNONCLIENTMETRICS)
        {
            MCCalcSizes(pmc);
            PostMessage(pmc->ci.hwnd, MCMP_WINDOWPOSCHANGED, 0, 0);
        }

        break;

    case WM_NOTIFYFORMAT:
        return CIHandleNotifyFormat(&pmc->ci, lParam);
        break;

    case WM_STYLECHANGING:
        lres = MCOnStyleChanging(pmc, (UINT) wParam, (LPSTYLESTRUCT)lParam);
        break;

    case WM_STYLECHANGED:
        lres = MCOnStyleChanged(pmc, (UINT) wParam, (LPSTYLESTRUCT)lParam);
        break;

    case WM_NOTIFY: {
        LPNMHDR pnm = (LPNMHDR)lParam;
        switch (pnm->code)
        {
        case UDN_DELTAPOS:
            if (pnm->hwndFrom == pmc->hwndUD)
            {
                // A notification from the UpDown control buddied
                // with the currently popped up monthcal, adjust the
                // edit box appropriately.  We use UDN_DELTAPOS instad
                // of WM_VSCROLL because we care only about the delta and
                // not the absolute number. The absolute number causes us
                // problems in localized calendars.
                LPNM_UPDOWN pnmdp = (LPNM_UPDOWN)lParam;
                UINT yr = pmc->st.wYear + pnmdp->iDelta;
                UINT yrMin, yrMax;
                int delta;

                yrMin = pmc->stMin.wYear;
                if (yr < yrMin)
                    yr = yrMin;

                yrMax = pmc->stMax.wYear;
                if (yr > yrMax)
                    yr = yrMax;

                delta = yr - pmc->st.wYear;
                pmc->st.wYear = (WORD)yr;
                if (delta) {
                    MCIncrStartMonth(pmc, delta * 12, FALSE);
                    MCNotifySelChange(pmc,MCN_SELCHANGE);

                }
            }
            break;
        }
    } // WM_NOTIFY switch
        break;

    case WM_VSCROLL:
        // this must be coming from our UpDown control buddied
        // with the currently popped up monthcal, adjust the
        // edit box appropriately
        // We must do this on WM_VSCROLL rather than UDN_DELTAPOS
        // since we need to fix the selection after the updown mangled it
        MCUpdateEditYear(pmc);
        break;


    //
    // MONTHCAL specific messages
    //


    // MCM_GETCURSEL wParam=void lParam=LPSYSTEMTIME
    //   sets *lParam to the currently selected SYSTEMTIME
    //   returns TRUE on success, FALSE on error (such as multi-select MONTHCAL)
    case MCM_GETCURSEL:
        if (!MonthCal_IsMultiSelect(pmc))
        {
            LPSYSTEMTIME pst = (LPSYSTEMTIME)lParam;
            if (pst)
            {
                ZeroMemory(pst, sizeof(SYSTEMTIME));
                // BUGBUG raymondc v6. Need to zero out the time fields instead of
                // setting them to garbage.  This confuses MFC.
                *pst = pmc->st;
                pst->wDayOfWeek = (DowFromDate(pst)+1) % 7;  // this returns 0==sun
                lres = 1;
            }
        }
        break;

    // MCM_SETCURSEL wParam=void lParam=LPSYSTEMTIME
    //   sets the currently selected SYSTEMTIME to *lParam
    //   returns TRUE on success, FALSE on error (such as multi-select MONTHCAL or bad parameters)
    case MCM_SETCURSEL:
    {
        LPSYSTEMTIME pst = (LPSYSTEMTIME)lParam;

        if (MonthCal_IsMultiSelect(pmc) ||
            !IsValidDate(pst))
        {
            break;
        }

        if (0 == CmpDate(pst, &pmc->st))
        {
            // if no change, just return
            lres = 1;
            break;
        }

        pmc->rcDayOld = pmc->rcDayCur;

        pmc->fNoNotify = TRUE;
        lres = MCSetDate(pmc, pst);
        pmc->fNoNotify = FALSE;

        if (lres)
        {
            InvalidateRect(pmc->ci.hwnd, &pmc->rcDayOld, FALSE);     // erase old highlight
            InvalidateRect(pmc->ci.hwnd, &pmc->rcDayCur, FALSE);     // draw new highlight
        }

        UpdateWindow(pmc->ci.hwnd);
        break;
    }

    // MCM_GETMAXSELCOUNT wParam=void lParam=void
    //   returns the max number of selected days allowed
    case MCM_GETMAXSELCOUNT:
        lres = (LRESULT)(MonthCal_IsMultiSelect(pmc) ? pmc->cSelMax : 1);
        break;

    // MCM_SETMAXSELCOUNT wParam=int lParam=void
    //   sets the maximum selectable date range to wParam days
    //   returns TRUE on success, FALSE on error (such as single-select MONTHCAL)
    case MCM_SETMAXSELCOUNT:
        if (!MonthCal_IsMultiSelect(pmc) || (int)wParam < 1)
            break;

        pmc->cSelMax = (int)wParam;
        lres = 1;
        break;

    // MCM_GETSELRANGE wParam=void lParam=LPSYSTEMTIME[2]
    //   sets *lParam to the first date of the range, *(lParam+1) to the second date
    //   returns TRUE on success, FALSE otherwise (such as single-select MONTHCAL)
    case MCM_GETSELRANGE:
    {
        LPSYSTEMTIME pst;

        pst = (LPSYSTEMTIME)lParam;

        if (!pst)
            break;

        ZeroMemory(pst, sizeof(SYSTEMTIME) * 2);

        if (!MonthCal_IsMultiSelect(pmc))
            break;

        *pst = pmc->st;
        pst->wDayOfWeek = (DowFromDate(pst)+1) % 7;  // this returns 0==sun
        pst++;
        *pst = pmc->stEndSel;
        pst->wDayOfWeek = (DowFromDate(pst)+1) % 7;  // this returns 0==sun
        lres = 1;

        break;
    }

    // MCM_SETSELRANGE wParam=void lParam=LPSYSTEMTIME[2]
    //   sets the currently selected day range to *lparam to *(lParam+1)
    //   returns TRUE on success, FALSE otherwise (such as single-select MONTHCAL or bad params)
    case MCM_SETSELRANGE:
    {
        LPSYSTEMTIME pstStart = (LPSYSTEMTIME)lParam;
        LPSYSTEMTIME pstEnd = &pstStart[1];
        SYSTEMTIME stStart;
        SYSTEMTIME stEnd;

        if (!MonthCal_IsMultiSelect(pmc) ||
            !IsValidDate(pstStart) ||
            !IsValidDate(pstEnd))
            break;

        // IE3 shipped without validating the time portion of this message.
        // Make sure our stored systemtimes are always valid (so we will
        // always give out valid systemtime structs).
        //
        if (!IsValidTime(pstStart))
            CopyTime(pmc->st, *pstStart);
        if (!IsValidTime(pstEnd))
            CopyTime(pmc->stEndSel, *pstEnd);

        if (CmpDate(pstStart, pstEnd) > 0)
        {
            stEnd = *pstStart;
            stStart = *pstEnd;
            pstStart = &stStart;
            pstEnd = &stEnd;
        }

        if (CmpDate(pstStart, &pmc->stMin) < 0)
            break;

        if (CmpDate(pstEnd, &pmc->stMax) > 0)
            break;

        if (DaysBetweenDates(pstStart, pstEnd) >= pmc->cSelMax)
            break;


        if (0 == CmpDate(pstStart, &pmc->st) &&
            0 == CmpDate(pstEnd, &pmc->stEndSel))
        {
            // if no change, just return
            lres = 1;
            break;
        }

        pmc->stStartPrev = pmc->st;
        pmc->stEndPrev = pmc->stEndSel;

        pmc->fNoNotify = TRUE;

        lres = MCSetDate(pmc, pstEnd);
        if (lres)
        {
            pmc->st = *pstStart;
            pmc->stEndSel = *pstEnd;

            MCInvalidateDates(pmc, &pmc->stStartPrev, &pmc->stEndPrev);
            MCInvalidateDates(pmc, &pmc->st, &pmc->stEndSel);
            UpdateWindow(pmc->ci.hwnd);
        }

        pmc->fNoNotify = FALSE;

        break;
    }

    // MCM_GETMONTHRANGE wParam=GMR_flags lParam=LPSYSTEMTIME[2]
    // if GMR_VISIBLE, returns the range of selectable (non-grayed) displayed
    // days. if GMR_DAYSTATE, returns the range of every (incl grayed) days.
    // returns the number of months the above range spans.
    case MCM_GETMONTHRANGE:
    {
        LPSYSTEMTIME pst = (LPSYSTEMTIME)lParam;

        if (pst)
        {
            ZeroMemory(pst, 2 * sizeof(SYSTEMTIME));

            if (wParam == GMR_VISIBLE)
            {
                pst[0] = pmc->stMonthFirst;
                pst[1] = pmc->stMonthLast;
            }
            else if (wParam == GMR_DAYSTATE)
            {
                pst[0] = pmc->stViewFirst;
                pst[1] = pmc->stViewLast;
            }
        }

        lres = (LRESULT)pmc->nMonths;
        if (wParam == GMR_DAYSTATE)
            lres += 2;

        break;
    }

    // MCM_SETDAYSTATE wParam=int lParam=LPDAYSTATE
    // updates the MONTHCAL's DAYSTATE, only for MONTHCALs with DAYSTATE enabled
    // the range of months represented in the DAYSTATE array passed in lParam
    // should match that of the MONTHCAL
    // wParam count of items in DAYSTATE array
    // lParam pointer to array of DAYSTATE items
    // returns FALSE if not DAYSTATE enabled or if an error occurs, TRUE otherwise
    case MCM_SETDAYSTATE:
    {
        MONTHDAYSTATE *pmds = (MONTHDAYSTATE *)lParam;
        int i;

        if (!MonthCal_IsDayState(pmc) ||
            (int)wParam != (pmc->nMonths + 2))
            break;

        for (i = 0; i < (int)wParam; i++)
        {
            pmc->rgdayState[i] = *pmds;
            pmds++;
        }
        MCInvalidateMonthDays(pmc);
        lres = 1;

        break;
    }

    // MCM_GETMINREQRECT wParam=void lParam=LPRECT
    //   sets *lParam to the minimum size required to display one month in full.
    //   Note: this is dependent upon the currently selected font.
    //   Apps can take the returned size and double the width to get two calendars
    //   displayed.
    case MCM_GETMINREQRECT:
    {
        LPRECT prc = (LPRECT)lParam;

        prc->left   = 0;
        prc->top    = 0;
        prc->right  = pmc->dxMonth;
        prc->bottom = pmc->dyMonth;
        if (MonthCal_ShowToday(pmc))
        {
            prc->bottom += pmc->dyToday;
        }

        AdjustWindowRect(prc, pmc->ci.style, FALSE);

        // This is a bogus message, lParam should really be LPSIZE.
        // Make sure left and top are 0 (AdjustWindowRect will make these negative).
        prc->right  -= prc->left;
        prc->bottom -= prc->top;
        prc->left    = 0;
        prc->top     = 0;

        lres = 1;

        break;
    }

    // MCM_GETMAXTODAYWIDTH wParam=void lParam=LPDWORD
    //   sets *lParam to the width of the "today" string, so apps
    //   can figure out how big to make the calendar (max of MCM_GETMINREQRECT
    //   and MCM_GETMAXTODAYWIDTH).
    case MCM_GETMAXTODAYWIDTH:
    {
        RECT rc;

        rc.left = 0;
        rc.top = 0;
        rc.right = pmc->dxToday;
        rc.bottom = pmc->dyToday;

        AdjustWindowRect(&rc, pmc->ci.style, FALSE);

        lres = rc.right - rc.left;
        break;
    }

    case MCM_HITTEST:
        return MCHandleHitTest(pmc, (PMCHITTESTINFO)lParam);

    case MCM_SETCOLOR:

        if (wParam < MCSC_COLORCOUNT)
        {
            COLORREF clr = pmc->clr[wParam];
            pmc->clr[wParam] = (COLORREF)lParam;
            InvalidateRect(hwnd, NULL, wParam == MCSC_BACKGROUND);
            return clr;
        }
        return -1;

    case MCM_GETCOLOR:
        if (wParam < MCSC_COLORCOUNT)
            return pmc->clr[wParam];
        return -1;

    case MCM_SETFIRSTDAYOFWEEK:
    {
        lres = MAKELONG(pmc->li.dowStartWeek, (BOOL)pmc->fFirstDowSet);
        if (lParam == (LPARAM)-1) {
            pmc->fFirstDowSet = FALSE;
        } else if (lParam < 7) {
            pmc->fFirstDowSet = TRUE;
            pmc->li.dowStartWeek = (TCHAR)lParam;
        }
        UpdateLocaleInfo(pmc, &pmc->li);
        InvalidateRect(hwnd, NULL, FALSE);
        return lres;
    }

    case MCM_GETFIRSTDAYOFWEEK:
        return MAKELONG(pmc->li.dowStartWeek, (BOOL)pmc->fFirstDowSet);

    case MCM_SETTODAY:
        MCSetToday(pmc, (SYSTEMTIME*)lParam);
        break;

    case MCM_GETTODAY:
        if (lParam) {
            *((SYSTEMTIME*)lParam) = pmc->stToday;
            return TRUE;
        }
        return FALSE;

    case MCM_GETRANGE:
        if (lParam)
        {
            LPSYSTEMTIME pst = (LPSYSTEMTIME)lParam;

            ZeroMemory(pst, sizeof(SYSTEMTIME)*2);

            ASSERT(lres == 0);
            if (pmc->fMinYrSet)
            {
                pst[0] = pmc->stMin;
                lres = GDTR_MIN;
            }
            if (pmc->fMaxYrSet)
            {
                pst[1] = pmc->stMax;
                lres |= GDTR_MAX;
            }
        }
        break;

    case MCM_SETRANGE:
        if (lParam)
        {
            LPSYSTEMTIME pst = (LPSYSTEMTIME)lParam;

            if (((wParam & GDTR_MIN) && !IsValidDate(pst)) ||
                ((wParam & GDTR_MAX) && !IsValidDate(&pst[1])))
                break;

            // IE3 did not validate the time portion of this struct
            // use stToday time fields cuz pmc->stMin/Max may be zero
            if ((wParam & GDTR_MIN) && !IsValidTime(pst))
                CopyTime(pmc->stToday, pst[0]);
            if ((wParam & GDTR_MAX) && !IsValidTime(&pst[1]))
                CopyTime(pmc->stToday, pst[1]);

            if (wParam & GDTR_MIN)
            {
                pmc->stMin = *pst;
                pmc->fMinYrSet = TRUE;
            }
            else
            {
                pmc->stMin = c_stEpoch;
                pmc->fMinYrSet = FALSE;
            }
            pst++;
            if (wParam & GDTR_MAX)
            {
                pmc->stMax = *pst;
                pmc->fMaxYrSet = TRUE;
            }
            else
            {
                pmc->stMax = c_stArmageddon;
                pmc->fMaxYrSet = FALSE;
            }

            if (pmc->fMaxYrSet && pmc->fMinYrSet && CmpDate(&pmc->stMin, &pmc->stMax) > 0)
            {
                SYSTEMTIME stTemp = pmc->stMin;
                pmc->stMin = pmc->stMax;
                pmc->stMax = stTemp;
            }
            lres = TRUE;
        }
        break;

    case MCM_GETMONTHDELTA:
        if (pmc->fMonthDelta)
            lres = pmc->nMonthDelta;
        else
            lres = pmc->nMonths;
        break;

    case MCM_SETMONTHDELTA:
        if (pmc->fMonthDelta)
            lres = pmc->nMonthDelta;
        else
            lres = 0;
        if ((int)wParam==0)
            pmc->fMonthDelta = FALSE;
        else
        {
            pmc->fMonthDelta = TRUE;
            pmc->nMonthDelta = (int)wParam;
        }
        break;

    default:
        if (CCWndProc(&pmc->ci, uMsg, wParam, lParam, &lres))
            return lres;

        lres = DefWindowProc(hwnd, uMsg, wParam, lParam);
        break;
    } /* switch (uMsg) */

    return(lres);
}

LRESULT MCNcCreateHandler(HWND hwnd)
{
    MONTHCAL *pmc;

    // Allocate storage for the dtpick structure
    pmc = (MONTHCAL *)NearAlloc(sizeof(MONTHCAL));
    if (!pmc)
    {
        DebugMsg(DM_WARNING, TEXT("mc: Out Of Near Memory"));
        return(0L);
    }

    MonthCal_SetPtr(hwnd, pmc);

    return(1L);
}

void MCInitColorArray(COLORREF* pclr)
{
    pclr[MCSC_BACKGROUND]   = g_clrWindow;
    pclr[MCSC_MONTHBK]      = g_clrWindow;
    pclr[MCSC_TEXT]         = g_clrWindowText;
    pclr[MCSC_TITLEBK]      = GetSysColor(COLOR_ACTIVECAPTION);
    pclr[MCSC_TITLETEXT]    = GetSysColor(COLOR_CAPTIONTEXT);
    pclr[MCSC_TRAILINGTEXT] = g_clrGrayText;
}

LRESULT MCCreateHandler(MONTHCAL *pmc, HWND hwnd, LPCREATESTRUCT lpcs)
{
    HFONT      hfont;
    SYSTEMTIME st;

    // Validate data
    //
    if (lpcs->style & MCS_INVALIDBITS)
        return(-1);

    CIInitialize(&pmc->ci, hwnd, lpcs);
    UpdateLocaleInfo(pmc, &pmc->li);

    // Initialize our data.
    //
    pmc->hinstance = lpcs->hInstance;

    pmc->fEnabled  = !(pmc->ci.style & WS_DISABLED);

    pmc->hpenToday = CreatePen(PS_SOLID, 2, CAL_COLOR_TODAY);

    MCReloadMenus(pmc);

    // Default minimum date is the epoch
    pmc->stMin = c_stEpoch;

    // Default maximum date is armageddon
    pmc->stMax = c_stArmageddon;

    GetLocalTime(&pmc->stToday);
    pmc->st = pmc->stToday;
    if (MonthCal_IsMultiSelect(pmc))
        pmc->stEndSel = pmc->st;

    // make sure the time portions of these are valid. they are never
    // touched after this point
    pmc->stMonthFirst = pmc->st;
    pmc->stMonthLast = pmc->st;
    pmc->stViewFirst = pmc->st;
    pmc->stViewLast = pmc->st;

    pmc->cSelMax = CAL_DEF_SELMAX;

    hfont = NULL;
    if (lpcs->hwndParent)
        hfont = (HFONT)SendMessage(lpcs->hwndParent, WM_GETFONT, 0, 0);
    if (hfont == NULL)
        hfont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
    MCHandleSetFont(pmc, hfont, FALSE);

    CopyDate(pmc->st, st);
    // Can we start at January?
    if (st.wMonth <= (pmc->nViewRows * pmc->nViewCols))
        st.wMonth = 1;

    MCUpdateStartEndDates(pmc, &st);

    pmc->idTimerToday = SetTimer(pmc->ci.hwnd, CAL_TODAYTIMER, CAL_SECTODAYTIMER * 1000, NULL);

    MCInitColorArray(pmc->clr);

    return(0);
}

LRESULT MCOnStyleChanging(MONTHCAL *pmc, UINT gwl, LPSTYLESTRUCT pinfo)
{
    if (gwl == GWL_STYLE)
    {
        DWORD changeFlags = pmc->ci.style ^ pinfo->styleNew;

        // Don't allow these bits to change
        changeFlags &= MCS_MULTISELECT | MCS_DAYSTATE | MCS_INVALIDBITS;

        pinfo->styleNew ^= changeFlags;
    }

    return(0);
}

LRESULT MCOnStyleChanged(MONTHCAL *pmc, UINT gwl, LPSTYLESTRUCT pinfo)
{
    if (gwl == GWL_STYLE)
    {
        DWORD changeFlags = pmc->ci.style ^ pinfo->styleNew;

        ASSERT(!(changeFlags & (MCS_MULTISELECT|MCS_DAYSTATE|MCS_INVALIDBITS)));

        pmc->ci.style = pinfo->styleNew;

        if (changeFlags & MCS_WEEKNUMBERS)
        {
            MCCalcSizes(pmc);
            MCUpdateRcDayCur(pmc, &pmc->st);
            //MCUpdateToday(pmc);
        }

        // save a touch of code and share the MCUpdateToday
        // call with MCS_WEEKNUMBERS above
        if (changeFlags & MCS_NOTODAY|MCS_NOTODAYCIRCLE|MCS_WEEKNUMBERS)
        {
            MCUpdateToday(pmc);
        }

        if (changeFlags & (WS_BORDER | WS_CAPTION | WS_THICKFRAME)) {
            // the changing of these bits affect the size of the window
            // but not until after this message is handled
            // so post ourself a message.
            PostMessage(pmc->ci.hwnd, MCMP_WINDOWPOSCHANGED, 0, 0);
        }

        if (changeFlags)
            InvalidateRect(pmc->ci.hwnd, NULL, TRUE);
    }
    else if (gwl == GWL_EXSTYLE)
    {
        if ((pinfo->styleOld ^ pinfo->styleNew) & RTL_MIRRORED_WINDOW)
        {
            MCUpdateMonthNamePos(pmc);
        }
    }

    return(0);
}

void MCCalcSizes(MONTHCAL *pmc)
{
    HDC   hdc;
    HFONT hfontOrig;
    int   i, dxMax, dyMax, dxExtra;
    RECT  rect;
    TCHAR szBuf[128];
    TCHAR szDateFmt[64];

    // get sizing info for bold font...
    hdc = GetDC(pmc->ci.hwnd);
    hfontOrig = SelectObject(hdc, (HGDIOBJ)pmc->hfontBold);

    MGetTextExtent(hdc, g_szTextExtentDef, 2, &dxMax, &dyMax);
    MGetTextExtent(hdc, g_szTextExtentDef, 4, &pmc->dxYearMax, NULL);

    GetDateFormat(pmc->ct.lcid, DATE_SHORTDATE, &pmc->stToday,
        NULL, szDateFmt, sizeof(szDateFmt));
    wsprintf(szBuf,TEXT("%s %s"),pmc->li.szToday,szDateFmt);
    MGetTextExtent(hdc, szBuf, -1, &pmc->dxToday, &pmc->dyToday);
    // BUGBUG raymondc - hard-coded numbers are accessibility-incompatible
    pmc->dyToday += 4;

    //
    //  Cache these values so we don't go wacko if the app fails to
    //  forward WM_WININCHANGE messages into us and the user changes
    //  scrollbar widths.  We'll draw with the wrong width, but at
    //  least they will be consistently wrong.
    //
    pmc->dxArrowMargin = DX_ARROWMARGIN;
    pmc->dxCalArrow    = DX_CALARROW;
    pmc->dyCalArrow    = DY_CALARROW;

    //
    //  The banner bar consists of
    //
    //  margin + scrollbutton + spacer +
    //                      MonthName yyyy +
    //                        + spacer + scrollbutton + margin
    //
    //  Margin is dxArrowMargin
    //
    //  Scrollbutton = dxCalArrow
    //
    //  Spacer = border + CXVSCROLL + border
    //
    //  The spacer needs to be large enough for us to insert an updown
    //  control when it comes time to spin the year.  We don't need to
    //  cache the spacer anywhere - its value is implicit from the others.
    //
    //  The actual width is divided by the number of columns we need
    //  (typically 7, but perhaps 8 if we are also displaying week numbers).
    //
    //  We round the division down - later, we'll add some random futz
    //  to compensate.
    //
    dxExtra = pmc->dxArrowMargin + pmc->dxCalArrow +
                        (g_cxBorder + g_cxVScroll + g_cxBorder);
    dxExtra = dxExtra + dxExtra; // left + right

    for (i = 0; i < 12; i++)
    {
        int dxTemp;

        // BUGBUG raymondc - not localization safe for languages which change
        // month forms based on context
        wsprintf(szBuf,TEXT("%s %s"),pmc->li.rgszMonth[i],g_szTextExtentDef);

        MGetTextExtent(hdc, szBuf, -1, &dxTemp, NULL);
        dxTemp += dxExtra;
        dxTemp = dxTemp / (CALCOLMAX + (MonthCal_ShowWeekNumbers(pmc) ? 1:0));
        if (dxTemp > dxMax)
            dxMax = dxTemp;
    }

    SelectObject(hdc, (HGDIOBJ)pmc->hfont);
    for (i = 0; i < 7; i++)
    {
        SIZE  size;
        MGetTextExtent(hdc, pmc->li.rgszDay[i], -1, (LPINT)&size.cx, (LPINT)&size.cy);
        if (size.cx > dxMax)
            dxMax = size.cx;
        if (size.cy > dyMax)
            dyMax = size.cy;
    }

    if (dyMax < pmc->dyCalArrow / 2)
        dyMax = pmc->dyCalArrow / 2;

    SelectObject(hdc, (HGDIOBJ)hfontOrig);
    ReleaseDC(pmc->ci.hwnd, hdc);

    pmc->dxCol = dxMax + 2;
    pmc->dyRow = dyMax + 2;
    pmc->dxMonth = pmc->dxCol * (CALCOLMAX + (MonthCal_ShowWeekNumbers(pmc) ? 1:0)) + 1;
    pmc->dyMonth = pmc->dyRow * (CALROWMAX + 3) + 1; // we add 2 for the month name and day names

    pmc->dxToday += pmc->dxCol+6+CALBORDER; // +2 for -1 at ends and 4 for shift of circle
    if (pmc->dxMonth > pmc->dxToday)
        pmc->dxToday = pmc->dxMonth;

    // Space for month name (tile bar area of each month)
    pmc->rcMonthName.left   = 0;
    pmc->rcMonthName.top    = 0;
    pmc->rcMonthName.right  = pmc->dxMonth;
    pmc->rcMonthName.bottom = pmc->rcMonthName.top + (pmc->dyRow * 2);

    // Space for day-of-week
    pmc->rcDow.left   = 0;
    pmc->rcDow.top    = pmc->rcMonthName.bottom;
    pmc->rcDow.right  = pmc->dxMonth;
    pmc->rcDow.bottom = pmc->rcDow.top + pmc->dyRow;

    // Space for week numbers
    if (MonthCal_ShowWeekNumbers(pmc))
    {
        pmc->rcWeekNum.left   = pmc->rcDow.left;
        pmc->rcWeekNum.top    = pmc->rcDow.bottom;
        pmc->rcWeekNum.right  = pmc->rcWeekNum.left + pmc->dxCol;
        pmc->rcWeekNum.bottom = pmc->dyMonth;

        pmc->rcDow.left  += pmc->dxCol;          // shift days of week
    }

    // Space for the day numbers
    pmc->rcDayNum.left   = pmc->rcDow.left;
    pmc->rcDayNum.top    = pmc->rcDow.bottom;
    pmc->rcDayNum.right  = pmc->rcDayNum.left + (CALCOLMAX * pmc->dxCol);
    pmc->rcDayNum.bottom = pmc->dyMonth;

    GetClientRect(pmc->ci.hwnd, &rect);

    MCRecomputeSizing(pmc, &rect);
}

void MCHandleSetFont(MONTHCAL *pmc, HFONT hfont, BOOL fRedraw)
{
    LOGFONT lf;
    HFONT   hfontBold;

    if (hfont == NULL)
        hfont = (HFONT)GetStockObject(SYSTEM_FONT);

    GetObject(hfont, sizeof(LOGFONT), (LPVOID)&lf);
    // we want to make sure that the bold days are obviously different
    // from the non-bold days...
    lf.lfWeight = (lf.lfWeight >= 700 ? 1000 : 800);
    hfontBold = CreateFontIndirect(&lf);

    if (hfontBold == NULL)
        return;

    if (pmc->hfontBold)
        DeleteObject((HGDIOBJ)pmc->hfontBold);

    pmc->hfont     = hfont;
    pmc->hfontBold = hfontBold;
    pmc->ci.uiCodePage = GetCodePageForFont(hfont);

    // calculate the new row and column sizes
    MCCalcSizes(pmc);

    if (fRedraw)
    {
        InvalidateRect(pmc->ci.hwnd, NULL, TRUE);
        UpdateWindow(pmc->ci.hwnd);
    }
}

#if 0       // why is this here?  it's not called anywhere??

// Stolen from the windows tips help file
void DrawTransparentBitmap(HDC hdc, HBITMAP hbmp, RECT *prc, COLORREF cTransparentColor)
{
    COLORREF cColor;
    BITMAP bm;
    HBITMAP hbmAndBack, hbmAndObject, hbmAndMem, hbmSave;
    HGDIOBJ hbmBackOld, hbmObjectOld, hbmMemOld, hbmSaveOld;
    HDC hdcMem, hdcBack, hdcObject, hdcTemp, hdcSave;
    POINT ptSize;
    int d;

    hdcTemp = CreateCompatibleDC(hdc);
    SelectObject(hdcTemp, (HGDIOBJ)hbmp);   // Select the bitmap

    GetObject(hbmp, sizeof(BITMAP), &bm);
    ptSize.x = bm.bmWidth;            // Get width of bitmap
    ptSize.y = bm.bmHeight;           // Get height of bitmap
    DPtoLP(hdcTemp, &ptSize, 1);      // Convert from device to logical points

    d = prc->right - prc->left;
    if (d < ptSize.x)
        ptSize.x = d;
    d = prc->bottom - prc->top;
    if (d < ptSize.y)
        ptSize.y = d;

    // Create some DCs to hold temporary data.
    hdcBack = CreateCompatibleDC(hdc);
    hdcObject = CreateCompatibleDC(hdc);
    hdcMem = CreateCompatibleDC(hdc);
    hdcSave = CreateCompatibleDC(hdc);

    // Create a bitmap for each DC. DCs are required for a number of
    // GDI functions.

    // Monochrome DC
    hbmAndBack = CreateBitmap(ptSize.x, ptSize.y, 1, 1, NULL);

    // Monochrome DC
    hbmAndObject = CreateBitmap(ptSize.x, ptSize.y, 1, 1, NULL);

    hbmAndMem = CreateCompatibleBitmap(hdc, ptSize.x, ptSize.y);
    hbmSave = CreateCompatibleBitmap(hdc, ptSize.x, ptSize.y);

    // Each DC must select a bitmap object to store pixel data.
    hbmBackOld = SelectObject(hdcBack, (HGDIOBJ)hbmAndBack);
    hbmObjectOld = SelectObject(hdcObject, (HGDIOBJ)hbmAndObject);
    hbmMemOld = SelectObject(hdcMem, (HGDIOBJ)hbmAndMem);
    hbmSaveOld = SelectObject(hdcSave, (HGDIOBJ)hbmSave);

    // Set proper mapping mode.
    SetMapMode(hdcTemp, GetMapMode(hdc));

    // Save the bitmap sent here, because it will be overwritten.
    BitBlt(hdcSave, 0, 0, ptSize.x, ptSize.y, hdcTemp, 0, 0, SRCCOPY);

    // Set the background color of the source DC to the color.
    // contained in the parts of the bitmap that should be transparent
    cColor = SetBkColor(hdcTemp, cTransparentColor);

    // Create the object mask for the bitmap by performing a BitBlt
    // from the source bitmap to a monochrome bitmap.
    BitBlt(hdcObject, 0, 0, ptSize.x, ptSize.y, hdcTemp, 0, 0, SRCCOPY);

    // Set the background color of the source DC back to the original
    // color.
    SetBkColor(hdcTemp, cColor);

    // Create the inverse of the object mask.
    BitBlt(hdcBack, 0, 0, ptSize.x, ptSize.y, hdcObject, 0, 0, NOTSRCCOPY);

    // Copy the background of the main DC to the destination.
    BitBlt(hdcMem, 0, 0, ptSize.x, ptSize.y, hdc, prc->left, prc->top, SRCCOPY);

    // Mask out the places where the bitmap will be placed.
    BitBlt(hdcMem, 0, 0, ptSize.x, ptSize.y, hdcObject, 0, 0, SRCAND);

    // Mask out the transparent colored pixels on the bitmap.
    BitBlt(hdcTemp, 0, 0, ptSize.x, ptSize.y, hdcBack, 0, 0, SRCAND);

    // XOR the bitmap with the background on the destination DC.
    BitBlt(hdcMem, 0, 0, ptSize.x, ptSize.y, hdcTemp, 0, 0, SRCPAINT);

    // Copy the destination to the screen.
    BitBlt(hdc, prc->left, prc->top, ptSize.x, ptSize.y, hdcMem, 0, 0, SRCCOPY);

    // Place the original bitmap back into the bitmap sent here.
    BitBlt(hdcTemp, 0, 0, ptSize.x, ptSize.y, hdcSave, 0, 0, SRCCOPY);

    // Delete the memory bitmaps.
    SelectObject(hdcBack, hbmBackOld);
    DeleteObject(hbmAndBack);
    SelectObject(hdcObject, hbmObjectOld);
    DeleteObject(hbmAndObject);
    SelectObject(hdcMem, hbmMemOld);
    DeleteObject(hbmAndMem);
    SelectObject(hdcSave, hbmSaveOld);
    DeleteObject(hbmSave);

    // Delete the memory DCs.
    DeleteDC(hdcMem);
    DeleteDC(hdcBack);
    DeleteDC(hdcObject);
    DeleteDC(hdcSave);
    DeleteDC(hdcTemp);
}

#endif      // DEAD CODE

void MCDrawTodayCircle(MONTHCAL *pmc, HDC hdc, RECT *prc)
{
    HGDIOBJ hpenOld;
    int xBegin, yBegin, yEnd;

    xBegin = (prc->right - prc->left) / 2 + prc->left;
    yBegin = prc->top + 4;
    yEnd = (prc->bottom - prc->top) / 2 + prc->top;

    hpenOld = SelectObject(hdc, (HGDIOBJ)pmc->hpenToday);
    Arc(hdc, prc->left + 1, yBegin, prc->right, prc->bottom,
        xBegin, yBegin, prc->right, yEnd);
    Arc(hdc, prc->left - 10, prc->top + 1, prc->right, prc->bottom,
        prc->right, yEnd, prc->left + 3, yBegin);
    SelectObject(hdc, hpenOld);
}

void MCInvalidateMonthDays(MONTHCAL *pmc)
{
    InvalidateRect(pmc->ci.hwnd, &pmc->rcCentered, FALSE);
}

void MCGetTodayBtnRect(MONTHCAL *pmc, RECT *prc)
{
    if (pmc->dxToday > pmc->rcCentered.right - pmc->rcCentered.left)
    {
        prc->left   = pmc->rc.left + 1;
        prc->right  = pmc->rc.right - 1;
    }
    else
    {
        prc->left   = pmc->rcCentered.left + 1;
        prc->right  = pmc->rcCentered.right - 1;
    }
    prc->top    = pmc->rcCentered.bottom - pmc->dyToday;
    prc->bottom = pmc->rcCentered.bottom;

    // center the today rect when we only have 1 col and it will fit in window
    if ((pmc->nViewCols == 1) && (pmc->dxToday <= pmc->rc.right - pmc->rc.left))
    {
        int dx =  ((pmc->rcCentered.right - pmc->rcCentered.left) - pmc->dxToday) / 2 - 1;
        prc->left   += dx;
        prc->right  -= dx;
    }
}

void MCPaintArrowBtn(MONTHCAL *pmc, HDC hdc, BOOL fPrev, BOOL fPressed)
{
    LPRECT prc;
    UINT   dfcs;
    BOOL   bMirrored = FALSE;

    // This is to work around DrawFrameControl() mirroring bug fixed on W2k (bld 2042 or higher)
#ifndef WINNT
    bMirrored = IS_DC_RTL_MIRRORED(hdc);
#endif // WINNT

    if (fPrev)
    {
        if(bMirrored)
        {
            dfcs = DFCS_SCROLLRIGHT;
        }
        else
        {
            dfcs = DFCS_SCROLLLEFT;
        }
        prc  = &pmc->rcPrev;
    }
    else
    {
        if(bMirrored)
        {
            dfcs = DFCS_SCROLLLEFT;
        }
        else
        {
            dfcs = DFCS_SCROLLRIGHT;
        }

        prc  = &pmc->rcNext;
    }
    if (pmc->fEnabled)
    {
        if (fPressed)
        {
            dfcs |= DFCS_PUSHED | DFCS_FLAT;
        }
    }
    else
    {
        dfcs |= DFCS_INACTIVE;
    }

    DrawFrameControl(hdc, prc, DFC_SCROLL, dfcs);
}

void MCPaint(MONTHCAL *pmc, HDC hdc)
{
    RECT    rc, rcT;
    int     irow, icol, iMonth, iYear, iIndex, dx, dy;
    HBRUSH  hbrSelect;
    HGDIOBJ hgdiOrig, hpenOrig;

    pmc->hpen = CreatePen(PS_SOLID, 0, pmc->clr[MCSC_TEXT]);
    hbrSelect = CreateSolidBrush(pmc->clr[MCSC_TITLEBK]);

    SetBkMode(hdc, TRANSPARENT);
    SetTextColor(hdc, pmc->clr[MCSC_TEXT]);
    hpenOrig = SelectObject(hdc, GetStockObject(BLACK_PEN));

    rc = pmc->rcCentered;

    FillRectClr(hdc, &rc, pmc->clr[MCSC_MONTHBK]);

    SelectObject(hdc, (HGDIOBJ)pmc->hpen);

    // get the place for top left month
    rc.left   = pmc->rcCentered.left;
    rc.right  = rc.left + pmc->dxMonth;
    rc.top    = pmc->rcCentered.top;
    rc.bottom = rc.top + pmc->dyMonth;

    iMonth = pmc->stMonthFirst.wMonth;
    iYear  = pmc->stMonthFirst.wYear;

    dx = pmc->dxMonth + CALBORDER;
    dy = pmc->dyMonth + CALBORDER;

    iIndex = 0;
    for (irow = 0; irow < pmc->nViewRows; irow++)
    {
        rcT = rc;
        for (icol = 0; icol < pmc->nViewCols; icol++)
        {
            if (RectVisible(hdc, &rcT))
            {
                MCPaintMonth(pmc, hdc, &rcT, iMonth, iYear, iIndex,
                    iIndex == 0,
                    iIndex == (pmc->nMonths - 1), hbrSelect);
            }

            rcT.left  += dx;
            rcT.right += dx;

            if (++iMonth > 12)
            {
                iMonth = 1;
                iYear++;
            }

            iIndex++;
        }

        rc.top    += dy;
        rc.bottom += dy;
    }

    // draw the today stuff
    if (MonthCal_ShowToday(pmc))
    {
        MCGetTodayBtnRect(pmc, &rc);
        if (RectVisible(hdc, &rc))
        {
            TCHAR   szDateFmt[32];
            TCHAR   szBuf[64];

            rcT.right = rc.left + 2; // a bit extra border space

            if (MonthCal_ShowTodayCircle(pmc)) // this turns on/off the red circle
            {
                rcT.left   = rcT.right + 2;
                rcT.right  = rcT.left + pmc->dxCol - 2;
                rcT.top    = rc.top + 2;
                rcT.bottom = rc.bottom - 2;
                MCDrawTodayCircle(pmc, hdc, &rcT);
            }

            rcT.left   = rcT.right + 2;
            rcT.right  = rc.right - 2;
            rcT.top    = rc.top;
            rcT.bottom = rc.bottom;
            hgdiOrig = SelectObject(hdc, (HGDIOBJ)pmc->hfontBold);
            SetTextColor(hdc, pmc->clr[MCSC_TEXT]);

            GetDateFormat(pmc->ct.lcid, DATE_SHORTDATE, &pmc->stToday,
                            NULL, szDateFmt, sizeof(szDateFmt));
            wsprintf(szBuf, TEXT("%s %s"), pmc->li.szToday, szDateFmt);
            DrawText(hdc, szBuf, lstrlen(szBuf), &rcT,
                        DT_LEFT | DT_NOCLIP | DT_NOPREFIX | DT_SINGLELINE | DT_VCENTER);

            SelectObject(hdc, hgdiOrig);
        }
    }

    // Draw the spin buttons
    if (RectVisible(hdc, &pmc->rcPrev))
        MCPaintArrowBtn(pmc, hdc, TRUE, (pmc->idTimer && pmc->fSpinPrev));
    if (RectVisible(hdc, &pmc->rcNext))
        MCPaintArrowBtn(pmc, hdc, FALSE, (pmc->idTimer && !pmc->fSpinPrev));

    SelectObject(hdc, hpenOrig);

    DeleteObject((HGDIOBJ)hbrSelect);
    DeleteObject((HGDIOBJ)pmc->hpen);
}

//
//  MCGetMonthFormat gets the string to display for the month/year
//  in the passed-in SYSTEMTIME.  This is tricky because of eras.
//  If pmm is non-NULL, it receives the metrics of the
//  formatted month/year string.
//
void MCGetMonthFormat(MONTHCAL *pmc, SYSTEMTIME *pst, LPTSTR rgch, UINT cch, PMONTHMETRICS pmm)
{
    // For all months, we display the name appropriate to the first
    // day of the month.  Note that this means that the title of the
    // month in which the era changes may be confusing.  If the era
    // changes in the middle of a month, we name the month after the
    // previous era, even if the current selection belongs to the next
    // era.  I hope nobody will mind.

#if 0 // code that tried to track the era based on where the selection is
      // but before you can turn this on, you have to find everybody who
      // changes the selection, and that's hard because the monthcal control
      // doesn't have a centralizesd selection changer; people just party on
      // the selection directly
    if (pst->wMonth == pmc->st.wMonth &&
        pst->wYear == pmc->st.wYear) {
        pst->wDay = pmc->st.wDay;
    } else {
        pst->wDay = 1;
    }
#else
    pst->wDay = 1;
#endif

    //
    //  Get the string (all marked up), then extract the markers
    //  to locate the month and year substrings.
    //

    rgch[0] = TEXT('\0');       // In case something horrible happens
    GetDateFormat(pmc->ct.lcid, 0, pst,
                  pmc->li.szMonthYearFmt,
                  rgch, cch);
    MCRemoveMarkers(rgch, pmm);
}

void MCPaintMonth(MONTHCAL *pmc, HDC hdc, RECT *prc, int iMonth, int iYear, int iIndex,
                    BOOL fDrawPrev, BOOL fDrawNext, HBRUSH hbrSelect)
{
    BOOL fBold, fView, fReset;
    RECT rc, rcT;
    int nDay, cdy, irow, icol, crowShow, nweek, isel;
    TCHAR rgch[64];
    LPTSTR psz;
    HGDIOBJ hfontOrig, hbrushOld;
    COLORREF clrGrayText, clrHiliteText, clrOld, clrText;
    SYSTEMTIME st = {0};
    int iIndexSave = iIndex;

    clrText       = pmc->clr[MCSC_TEXT];
    clrGrayText   = pmc->clr[MCSC_TRAILINGTEXT];
    clrHiliteText = pmc->clr[MCSC_TITLETEXT];

    hfontOrig = SelectObject(hdc, (HGDIOBJ)pmc->hfont);
    SelectObject(hdc, (HGDIOBJ)pmc->hpen);

    //
    // Draw the Month and Year
    //
    // translate the relative coords to window coords
    rc = pmc->rcMonthName;
    rc.left   += prc->left;
    rc.right  += prc->left;
    rc.top    += prc->top;
    rc.bottom += prc->top;
    if (RectVisible(hdc, &rc))
    {
        FillRectClr(hdc, &rc, pmc->clr[MCSC_TITLEBK]);

        SetTextColor(hdc, pmc->clr[MCSC_TITLETEXT]);
        SelectObject(hdc, (HGDIOBJ)pmc->hfontBold);

        st.wYear = (WORD) iYear;
        st.wMonth = (WORD) iMonth;
        MCGetMonthFormat(pmc, &st, rgch, ARRAYSIZE(rgch), NULL);

        DrawText(hdc, rgch, lstrlen(rgch), &rc, DT_CENTER | DT_NOCLIP | DT_NOPREFIX | DT_SINGLELINE | DT_VCENTER);

#ifdef MARKER_DEBUG
        //
        //  When debugging MCInsertMarker and MCRemoveMarker, draw colored
        //  bars where we think the markers were.
        //
        { RECT rcT = rc;
            rcT.top = rcT.bottom - 2;
            rcT.left  = rc.left + pmc->rgmm[iIndex].rgi[IMM_MONTHSTART];
            rcT.right = rc.left + pmc->rgmm[iIndex].rgi[IMM_MONTHEND];
            FillRectClr(hdc, &rcT, RGB(0xFF, 0, 0));

            rcT.left  = rc.left + pmc->rgmm[iIndex].rgi[IMM_YEARSTART];
            rcT.right = rc.left + pmc->rgmm[iIndex].rgi[IMM_YEAREND];
            FillRectClr(hdc, &rcT, RGB(0, 0xFF, 0));
        }
#endif
        SelectObject(hdc, (HGDIOBJ)pmc->hfont);
    }

    SetTextColor(hdc, pmc->clr[MCSC_TITLEBK]);

    //
    // Draw the days of the month
    //
    // translate the relative coords to window coords
    rc = pmc->rcDow;
    rc.left   += prc->left;
    rc.right  += prc->left;
    rc.top    += prc->top;
    rc.bottom += prc->top;
    if (RectVisible(hdc, &rc))
    {
        MoveToEx(hdc, rc.left + 4, rc.bottom - 1, NULL);
        LineTo(hdc, rc.right - 4, rc.bottom - 1);

        rc.right = rc.left + pmc->dxCol;

        for (icol = 0; icol < CALCOLMAX; icol++)
        {
            psz = pmc->li.rgszDay[(icol + pmc->li.dowStartWeek) % 7];

            DrawText(hdc, psz, lstrlen(psz), &rc, DT_CENTER | DT_NOPREFIX | DT_SINGLELINE | DT_VCENTER);
            rc.left  += pmc->dxCol;
            rc.right += pmc->dxCol;
        }
    }


    // Check to see how many days from the previous month exist in this months calendar
    nDay = pmc->rgnDayUL[iIndex];   // last day in prev month that won't be shown in this month
    cdy  = pmc->rgcDay[iIndex];     // # of days in prev month

    // Calculate the number of weeks to display
    if (fDrawNext)
        crowShow = CALROWMAX;
    else
        crowShow = ((cdy - nDay) + pmc->rgcDay[iIndex + 1] + 6/* round up */) / 7;

    if (nDay != cdy)
    {
        // start at previous month
        iMonth--;
        if(iMonth <= 0)
        {
            iMonth = 12;
            iYear--;
        }
        nDay++;

        fView = FALSE;
    }
    else
    {
        // start at this month
        iIndex++;                   // this month

        nDay = 1;
        cdy = pmc->rgcDay[iIndex];

        fView = TRUE;
    }

    //
    // Draw the week numbers
    //
    if (MonthCal_ShowWeekNumbers(pmc))
    {
        // translate the relative coords to window coords
        rc = pmc->rcWeekNum;
        rc.left   += prc->left;
        rc.top    += prc->top;
        rc.right  += prc->left;
        rc.bottom = rc.top + (pmc->dyRow * crowShow);

        // draw the week numbers
        if (RectVisible(hdc, &rc))
        {
            MoveToEx(hdc, rc.right - 1, rc.top + 4, NULL);
            LineTo(hdc, rc.right - 1, rc.bottom - 4);

            st.wYear  = (WORD) iYear;
            st.wMonth = (WORD) iMonth;
            st.wDay   = (WORD) nDay;
            nweek = GetWeekNumber(&st, pmc->li.dowStartWeek, pmc->li.firstWeek);

            rc.bottom = rc.top + pmc->dyRow;

            for (irow = 0; irow < crowShow; irow++)
            {
                wsprintf(rgch, g_szNumFmt, nweek);
                DrawText(hdc, rgch, (nweek > 9 ? 2 : 1), &rc,
                        DT_CENTER | DT_NOCLIP | DT_NOPREFIX | DT_SINGLELINE | DT_VCENTER);

                rc.top    += pmc->dyRow;
                rc.bottom += pmc->dyRow;
                IncrSystemTime(&st, &st, 1, INCRSYS_WEEK);
                nweek = GetWeekNumber(&st, pmc->li.dowStartWeek, pmc->li.firstWeek);
            }
        }
    }

    if (!fView)
        SetTextColor(hdc, clrGrayText);
    else
        SetTextColor(hdc, clrText);

    rc = pmc->rcDayNum;
    rc.left   += prc->left;
    rc.top    += prc->top;
    rc.right  =  rc.left + pmc->dxCol;
    rc.bottom =  rc.top  + pmc->dyRow;

    fReset = FALSE;
    fBold  = FALSE;

    for (irow = 0; irow < crowShow; irow++)
    {
        rcT = rc;

        for (icol = 0; icol < CALCOLMAX; icol++)
        {
            if ((fView || fDrawPrev) && RectVisible(hdc, &rcT))
            {
                wsprintf(rgch, g_szNumFmt, nDay);

                if (MonthCal_IsDayState(pmc))
                {
                    // if we're in a dropdown we don't display
                    if (MCIsBoldOffsetDay(pmc, nDay, iIndex))
                    {
                        if (!fBold)
                        {
                            SelectObject(hdc, (HGDIOBJ)pmc->hfontBold);
                            fBold = TRUE;
                        }
                    }
                    else
                    {
                        if (fBold)
                        {
                            SelectObject(hdc, (HGDIOBJ)pmc->hfont);
                            fBold = FALSE;
                        }
                    }
                }

                if (isel = MCIsSelectedDayMoYr(pmc, nDay, iMonth, iYear))
                {
                    int x1, x2;

                    clrOld    = SetTextColor(hdc, clrHiliteText);
                    hbrushOld = SelectObject(hdc, (HGDIOBJ)hbrSelect);
                    fReset    = TRUE;

                    SelectObject(hdc, GetStockObject(NULL_PEN));

                    x1 = 0;
                    x2 = 0;
                    if (isel & SEL_DOT)
                    {
                        Ellipse(hdc, rcT.left + 2, rcT.top + 2, rcT.right - 1, rcT.bottom - 1);
                        if (isel == SEL_BEGIN)
                        {
                            x1 = rcT.left + (rcT.right - rcT.left) / 2;
                            x2 = rcT.right;
                        }
                        else if (isel == SEL_END)
                        {
                            x1 = rcT.left;
                            x2 = rcT.left + (rcT.right - rcT.left) / 2;
                        }
                    }
                    else
                    {
                        x1 = rcT.left;
                        x2 = rcT.right;
                    }

                    if (x1 && x2)
                    {
                        Rectangle(hdc, x1, rcT.top + 2, x2 + 1, rcT.bottom - 1);
                    }
                }

                DrawText(hdc, rgch, (nDay > 9 ? 2 : 1), &rcT,
                        DT_CENTER | DT_NOCLIP | DT_NOPREFIX | DT_SINGLELINE | DT_VCENTER);

                if (MonthCal_ShowTodayCircle(pmc) && pmc->fToday && iIndexSave == pmc->iMonthToday &&
                    icol == pmc->iColToday && irow == pmc->iRowToday)
                {
                    MCDrawTodayCircle(pmc, hdc, &rcT);
                }

                if (fReset)
                {
                    SetTextColor(hdc, clrOld);
                    SelectObject(hdc, (HGDIOBJ)hbrushOld);
                    fReset = FALSE;
                }
            }

            rcT.left  += pmc->dxCol;
            rcT.right += pmc->dxCol;

            nDay++;
            if (nDay > cdy)
            {
                if (!fDrawNext && iIndex > iIndexSave)
                    goto doneMonth;

                nDay = 1;
                iIndex++;
                cdy = pmc->rgcDay[iIndex];
                iMonth++;
                if (iMonth > 12)
                {
                    iMonth = 1;
                    iYear++;
                }

                fView = !fView;
                SetTextColor(hdc, fView ? clrText : clrGrayText);

                fDrawPrev = fDrawNext;
            }
        }

        rc.top    += pmc->dyRow;
        rc.bottom += pmc->dyRow;
    }

doneMonth:

    SelectObject(hdc, hfontOrig);

    return;
}

int MCIsSelectedDayMoYr(MONTHCAL *pmc, int iDay, int iMonth, int iYear)
{
    SYSTEMTIME st;
    int iBegin, iEnd;
    int iret = 0;

    st.wYear  = (WORD) iYear;
    st.wMonth = (WORD) iMonth;
    st.wDay   = (WORD) iDay;

    iBegin = CmpDate(&st, &pmc->st);

    if (MonthCal_IsMultiSelect(pmc))
    {
        iEnd = CmpDate(&st, &pmc->stEndSel);

        if (iBegin > 0 && iEnd< 0)
            iret = SEL_MID;
        else
        {
            if (iBegin == 0)
                iret |= SEL_BEGIN;

            if (iEnd == 0)
                iret |= SEL_END;
        }
    }
    else if (iBegin == 0)
    {
        iret = SEL_DOT;
    }

    return(iret);
}

BOOL MCIsBoldOffsetDay(MONTHCAL *pmc, int nDay, int iIndex)
{
    return(pmc->rgdayState && (pmc->rgdayState[iIndex] & (1L << (nDay - 1))) != 0);
}

void MCNcDestroyHandler(HWND hwnd, MONTHCAL *pmc, WPARAM wParam, LPARAM lParam)
{
    if (pmc)
    {
        if (pmc->hpenToday)
            DeleteObject((HGDIOBJ)pmc->hpenToday);
        if (pmc->hfontBold)
            DeleteObject((HGDIOBJ)pmc->hfontBold);

        if (pmc->hmenuCtxt)
            DestroyMenu(pmc->hmenuCtxt);
        if (pmc->hmenuMonth)
            DestroyMenu(pmc->hmenuMonth);

        if (pmc->idTimer)
            KillTimer(pmc->ci.hwnd, pmc->idTimer);
        if (pmc->idTimerToday)
            KillTimer(pmc->ci.hwnd, pmc->idTimerToday);

        MCFreeCalendarInfo(&pmc->ct);

        GlobalFreePtr(pmc);
    }

    // In case rogue messages float through after we have freed the pdtpick, set
    // the handle in the window structure to FFFF and test for this value at
    // the top of the WndProc
    MonthCal_SetPtr(hwnd, NULL);

    // Call DefWindowProc32 to free all little chunks of memory such as szName
    // and rgwScroll.
    DefWindowProc(hwnd, WM_NCDESTROY, wParam, lParam);
}


/* Computes the following:
 *  nViewCols
 *  nViewRows
 *  rcCentered
 *  rcPrev
 *  rcNext
 */
void MCRecomputeSizing(MONTHCAL *pmc, RECT *prect)
{
    RECT rc;
    int dx, dy, dCal;

    // Space for entire calendar
    pmc->rc = *prect;

    dx = prect->right  - prect->left;
    dy = prect->bottom - prect->top;

    pmc->nViewCols = 1 + (dx - pmc->dxMonth) / (pmc->dxMonth + CALBORDER);
    pmc->nViewRows = 1 + (dy - pmc->dyMonth - pmc->dyToday) / (pmc->dyMonth + CALBORDER);

    // if dx < dxMonth or dy < dyMonth, these can be zero. That's bad...
    if (pmc->nViewCols < 1)
        pmc->nViewCols = 1;
    if (pmc->nViewRows < 1)
        pmc->nViewRows = 1;

    // Make sure we don't display more than CALMONTHMAX months
    while ((pmc->nViewRows * pmc->nViewCols) > CALMONTHMAX)
    {
        if (pmc->nViewRows > pmc->nViewCols)
            pmc->nViewRows--;
        else
            pmc->nViewCols--;
    }

    // RC for the months, centered within the client window
    dCal = pmc->nViewCols * (pmc->dxMonth + CALBORDER) - CALBORDER;
    pmc->rcCentered.left = (dx - dCal) / 2;
    if (pmc->rcCentered.left < 0)
        pmc->rcCentered.left = 0;
    pmc->rcCentered.right = pmc->rcCentered.left + dCal;

    dCal = pmc->nViewRows * (pmc->dyMonth + CALBORDER) - CALBORDER + pmc->dyToday;
    pmc->rcCentered.top = (dy - dCal) / 2;
    if (pmc->rcCentered.top < 0)
        pmc->rcCentered.top = 0;
    pmc->rcCentered.bottom = pmc->rcCentered.top + dCal;

    // Calculate and set RCs for the spin buttons
    rc.top    = pmc->rcCentered.top + (pmc->dyRow * 2 - pmc->dyCalArrow) /2;
    rc.bottom = rc.top + pmc->dyCalArrow;

    rc.left  = pmc->rcCentered.left + pmc->dxArrowMargin;
    rc.right = rc.left + pmc->dxCalArrow;
    pmc->rcPrev = rc;

    rc.right = pmc->rcCentered.right - pmc->dxArrowMargin;
    rc.left  = rc.right - pmc->dxCalArrow;
    pmc->rcNext = rc;
}

LRESULT MCSizeHandler(MONTHCAL *pmc, RECT *prc)
{
    int nMax;
    SYSTEMTIME st;
    int cmo, dmo;

    MCRecomputeSizing(pmc, prc);

    nMax = pmc->nViewRows * pmc->nViewCols;


    // Compute new start date
    CopyDate(pmc->stMonthFirst, st);

    // BUGBUG: this doesn't consider stEndSel
    cmo = (pmc->stMonthLast.wYear - (int)pmc->st.wYear) * 12 +
        (pmc->stMonthLast.wMonth - (int)pmc->st.wMonth);
    dmo = nMax - pmc->nMonths;

    if (-dmo > cmo)
    {
        // Selected mon/yr not in view
        IncrSystemTime(&st, &st, -(cmo + dmo), INCRSYS_MONTH);
        cmo = 0;
    }

    // If the # of months being displayed has changed, then lets try to
    // start the calendar from January.
    if ((dmo != 0) && (cmo + dmo >= pmc->stMonthFirst.wMonth - 1))
        st.wMonth = 1;

    MCUpdateStartEndDates(pmc, &st);

    InvalidateRect(pmc->ci.hwnd, NULL, TRUE);
    UpdateWindow(pmc->ci.hwnd);

    return(0);
}

//
//  For each month being displayed, compute the precise locations of all
//  the gizmos we draw into the month header area.
//
void MCUpdateMonthNamePos(MONTHCAL *pmc)
{
    HDC hdc;
    int iCount;
    SYSTEMTIME st;
    TCHAR rgch[64];
    SIZE size;
    HGDIOBJ hfontOrig;

    hdc = GetDC(pmc->ci.hwnd);
    hfontOrig = SelectObject(hdc, (HGDIOBJ)pmc->hfontBold);

    st = pmc->stMonthFirst;

    for (iCount = 0; iCount < pmc->nMonths; iCount++)
    {
        PMONTHMETRICS pmm = &pmc->rgmm[iCount];
        int i;

        MCGetMonthFormat(pmc, &st, rgch, ARRAYSIZE(rgch), pmm);

        GetTextExtentPoint32(hdc, rgch, lstrlen(rgch), &size);
        pmm->rgi[IMM_START] = (pmc->dxMonth - size.cx) / 2;

        //
        //  Now convert the indices into pixels so we can figure out where
        //  all the strings ended up.
        //
        for (i = IMM_DATEFIRST; i <= IMM_DATELAST; i++) {
            SIZE sizeT;
            // In case of horrible error, pretend the marker was at the
            // beginning of the string.
            sizeT.cx = 0;
            GetTextExtentPoint32(hdc, rgch, pmm->rgi[i], &sizeT);
            pmm->rgi[i] = pmm->rgi[IMM_START] + sizeT.cx;
        }

        //
        //  Now flip the coordinates for RTL.
        //
        if (pmc->fHeaderRTL || IS_WINDOW_RTL_MIRRORED(pmc->ci.hwnd))
        {
            int dxStart, dxEnd;

            // Flip the month...
            dxStart = pmm->rgi[IMM_MONTHSTART] - pmm->rgi[IMM_START];
            dxEnd   = pmm->rgi[IMM_MONTHEND  ] - pmm->rgi[IMM_START];
            pmm->rgi[IMM_MONTHSTART] = pmm->rgi[IMM_START] + size.cx - dxEnd;
            pmm->rgi[IMM_MONTHEND  ] = pmm->rgi[IMM_START] + size.cx - dxStart;

            // Flip the year...
            dxStart = pmm->rgi[IMM_YEARSTART] - pmm->rgi[IMM_START];
            dxEnd   = pmm->rgi[IMM_YEAREND  ] - pmm->rgi[IMM_START];
            pmm->rgi[IMM_YEARSTART] = pmm->rgi[IMM_START] + size.cx - dxEnd;
            pmm->rgi[IMM_YEAREND  ] = pmm->rgi[IMM_START] + size.cx - dxStart;

        }

        //  On to the next month

        if(++st.wMonth > 12)
        {
            st.wMonth = 1;
            st.wYear++;
        }
    }

    SelectObject(hdc, hfontOrig);
    ReleaseDC(pmc->ci.hwnd, hdc);
}

/*
 * Computes the following, given the number of rows & columns available:
 *        stMonthFirst.wMonth
 *        stMonthFirst.wYear
 *        stMonthLast.wMonth
 *        stMonthLast.wYear
 *        nMonths
 *
 * Trashes *pstStart
 */
void MCUpdateStartEndDates(MONTHCAL *pmc, SYSTEMTIME *pstStart)
{
    int iCount, iMonth, iYear;
    int nMonthsToEdge;

    pmc->nMonths = pmc->nViewRows * pmc->nViewCols;

    // make sure pstStart to pstStart+nMonths is within range
    nMonthsToEdge = ((int)pmc->stMax.wYear - (int)pstStart->wYear) * 12 +
                        ((int)pmc->stMax.wMonth - (int)pstStart->wMonth) + 1;
    if (nMonthsToEdge < pmc->nMonths)
        IncrSystemTime(pstStart, pstStart, nMonthsToEdge - pmc->nMonths, INCRSYS_MONTH);

    if (CmpDate(pstStart, &pmc->stMin) < 0)
    {
        CopyDate(pmc->stMin, *pstStart);
    }

    nMonthsToEdge = ((int)pmc->stMax.wYear - (int)pstStart->wYear) * 12 +
                        ((int)pmc->stMax.wMonth - (int)pstStart->wMonth) + 1;
    if (nMonthsToEdge < pmc->nMonths)
        pmc->nMonths = nMonthsToEdge;

    pmc->stMonthFirst.wYear  = pstStart->wYear;
    pmc->stMonthFirst.wMonth = pstStart->wMonth;
    pmc->stMonthFirst.wDay   = 1;
    if (CmpDate(&pmc->stMonthFirst, &pmc->stMin) < 0)
    {
        pmc->stMonthFirst.wDay = pmc->stMin.wDay;
        ASSERT(0==CmpDate(&pmc->stMonthFirst, &pmc->stMin));
    }

    // these ranges are CALMONTHMAX+2 and nMonths <= CALMONTHMAX, so we are safe
    // index 0 corresponds to stViewFirst (DAYSTATE) info
    // index 1..nMonths correspond to stMonthFirst..stMonthLast info
    // index nMonths+1 corresponds to stViewLast (DAYSTATE) info
    //
    iYear  = pmc->stMonthFirst.wYear;
    iMonth = pmc->stMonthFirst.wMonth - 1;
    if(iMonth == 0)
    {
        iMonth = 12;
        iYear--;
    }
    for (iCount = 0; iCount <= pmc->nMonths+1; iCount++)
    {
        int cdy, dow, ddow;

        // number of days in this month
        cdy = GetDaysForMonth(iYear, iMonth);
        pmc->rgcDay[iCount] = cdy;

        // move to "this" month
        if(++iMonth > 12)
        {
            iMonth = 1;
            iYear++;
        }

        // last day of this month NOT visible when viewing NEXT month
        dow = GetStartDowForMonth(iYear, iMonth);
        ddow = dow - pmc->li.dowStartWeek;
        if(ddow < 0)
            ddow += CALCOLMAX;
        pmc->rgnDayUL[iCount] = cdy  - ddow;
    }

    // we want to always have days visible on the previous month
    if (pmc->rgnDayUL[0] == pmc->rgcDay[0])
        pmc->rgnDayUL[0] -= CALCOLMAX;

    IncrSystemTime(&pmc->stMonthFirst, &pmc->stMonthLast, pmc->nMonths - 1, INCRSYS_MONTH);
    pmc->stMonthLast.wDay = (WORD) pmc->rgcDay[pmc->nMonths];
    if (pmc->fMaxYrSet && CmpDate(&pmc->stMonthLast, &pmc->stMax) > 0)
    {
        pmc->stMonthLast.wDay = pmc->stMax.wDay;
        ASSERT(0==CmpDate(&pmc->stMonthLast, &pmc->stMax));
    }

    pmc->stViewFirst.wYear  = pmc->stMonthFirst.wYear;
    pmc->stViewFirst.wMonth = pmc->stMonthFirst.wMonth - 1;
    if (pmc->stViewFirst.wMonth == 0)
    {
        pmc->stViewFirst.wMonth = 12;
        pmc->stViewFirst.wYear--;
    }
    pmc->stViewFirst.wDay = pmc->rgnDayUL[0] + 1;

    pmc->stViewLast.wYear  = pmc->stMonthLast.wYear;
    pmc->stViewLast.wMonth = pmc->stMonthLast.wMonth + 1;
    if (pmc->stViewLast.wMonth == 13)
    {
        pmc->stViewLast.wMonth = 1;
        pmc->stViewLast.wYear++;
    }
    // total days - (days in last month + remaining days in previous month)
    pmc->stViewLast.wDay = CALROWMAX * CALCOLMAX -
        (pmc->rgcDay[pmc->nMonths] +
         pmc->rgcDay[pmc->nMonths-1] - pmc->rgnDayUL[pmc->nMonths-1]);

    MCUpdateDayState(pmc);
    MCUpdateRcDayCur(pmc, &pmc->st);
    MCUpdateToday(pmc);
    MCUpdateMonthNamePos(pmc);
}

void MCUpdateToday(MONTHCAL *pmc)
{
    if (MonthCal_ShowTodayCircle(pmc))
    {
        int iMonth;

        iMonth = MCGetOffsetForYrMo(pmc, pmc->stToday.wYear, pmc->stToday.wMonth);
        if (iMonth < 0)
        {
            // today is not visible in the displayed months
            pmc->fToday = FALSE;
        }
        else
        {
            int iDay;

            // today is visible in the displayed months
            pmc->fToday = TRUE;

            iDay = pmc->rgcDay[iMonth] - pmc->rgnDayUL[iMonth] + pmc->stToday.wDay - 1;

            pmc->iMonthToday = iMonth;
            pmc->iRowToday   = iDay / CALCOLMAX;
            pmc->iColToday   = iDay % CALCOLMAX;
        }
    }
}

BOOL FUpdateRcDayCur(MONTHCAL *pmc, POINT pt)
{
    int iRow, iCol;
    RECT rc;
    SYSTEMTIME st;

    if (!FGetDateForPt(pmc, pt, &st, NULL, &iCol, &iRow, &rc))
        return FALSE;

    if (CmpDate(&st, &pmc->stMin) < 0)
        return FALSE;

    if (CmpDate(&st, &pmc->stMax) > 0)
        return FALSE;

    // calculate the day rc
    pmc->rcDayCur.left   = rc.left + pmc->rcDayNum.left + iCol * pmc->dxCol;
    pmc->rcDayCur.top    = rc.top + pmc->rcDayNum.top + iRow * pmc->dyRow;
    pmc->rcDayCur.right  = pmc->rcDayCur.left + pmc->dxCol;
    pmc->rcDayCur.bottom = pmc->rcDayCur.top + pmc->dyRow;

    return(TRUE);
}

void MCUpdateDayState(MONTHCAL *pmc)
{
    HWND hwndParent;

    if (!MonthCal_IsDayState(pmc))
        return;

    hwndParent = GetParent(pmc->ci.hwnd);
    if (hwndParent)
    {
        int i, mon, yr, cmonths;

        yr      = pmc->stViewFirst.wYear;
        mon     = pmc->stViewFirst.wMonth;
        cmonths = pmc->nMonths + 2;

        // don't do anything unless we need to
        if (cmonths != pmc->cds || mon != pmc->dsMonth || yr != pmc->dsYear)
        {
            // this is a small enough to not deal with allocating it
            NMDAYSTATE    nmds;
            MONTHDAYSTATE buffer[CALMONTHMAX+2];

            ZeroMemory(&nmds, sizeof(nmds));
            nmds.stStart.wYear  = (WORD) yr;
            nmds.stStart.wMonth = (WORD) mon;
            nmds.stStart.wDay   = 1;
            nmds.cDayState      = cmonths;
            nmds.prgDayState    = buffer;

            CCSendNotify(&pmc->ci, MCN_GETDAYSTATE, &nmds.nmhdr);

            for (i = 0; i < cmonths; i++)
                pmc->rgdayState[i] = nmds.prgDayState[i];

            pmc->cds     = cmonths;
            pmc->dsMonth = mon;
            pmc->dsYear  = yr;
        }
    }
}

void MCNotifySelChange(MONTHCAL *pmc, UINT uMsg)
{
    HWND hwndParent;

    if (pmc->fNoNotify)
        return;

    hwndParent = GetParent(pmc->ci.hwnd);
    if (hwndParent)
    {
        NMSELCHANGE nmsc;
        ZeroMemory(&nmsc, sizeof(nmsc));

        CopyDate(pmc->st, nmsc.stSelStart);
        if (MonthCal_IsMultiSelect(pmc))
            CopyDate(pmc->stEndSel, nmsc.stSelEnd);

        CCSendNotify(&pmc->ci, uMsg, &nmsc.nmhdr);
    }
}

void MCUpdateRcDayCur(MONTHCAL *pmc, SYSTEMTIME *pst)
{
    int iOff;

    iOff = MCGetOffsetForYrMo(pmc, pst->wYear, pst->wMonth);
    if (iOff >= 0)
        MCGetRcForDay(pmc, iOff, pst->wDay, &pmc->rcDayCur);
}

// returns zero-based index into DISPLAYED months for month
// if month is not in DISPLAYED months, then -1 is returned...
int MCGetOffsetForYrMo(MONTHCAL *pmc, int iYear, int iMonth)
{
    int iOff;

    iOff = ((int)iYear - pmc->stMonthFirst.wYear) * 12 + (int)iMonth - pmc->stMonthFirst.wMonth;

    if (iOff < 0 || iOff >= pmc->nMonths)
        return(-1);

    return(iOff);
}

// iMonth is a zero-based index relative to the DISPLAYED months.
// iDay is a 1-based index of the day of the month,
void MCGetRcForDay(MONTHCAL *pmc, int iMonth, int iDay, RECT *prc)
{
    RECT rc;
    int iPlace, iRow, iCol;

    MCGetRcForMonth(pmc, iMonth, &rc);

    iPlace = pmc->rgcDay[iMonth] - pmc->rgnDayUL[iMonth] + iDay - 1;
    iRow = iPlace / CALCOLMAX;
    iCol = iPlace % CALCOLMAX;

    prc->left   = rc.left   + pmc->rcDayNum.left + (pmc->dxCol * iCol);
    prc->top    = rc.top    + pmc->rcDayNum.top  + (pmc->dyRow * iRow);
    prc->right  = prc->left + pmc->dxCol;
    prc->bottom = prc->top  + pmc->dyRow;
}

//
// This routine gets the bounding rect for the iMonth of the displayed months.
// NOTE: iMonth is a zero-based index relative to the DISPLAYED months,
// counting along the rows.
//
void MCGetRcForMonth(MONTHCAL *pmc, int iMonth, RECT *prc)
{
    int iRow, iCol, d;

    iRow = iMonth / pmc->nViewCols;
    iCol = iMonth % pmc->nViewCols;

    // intialize the rect to be the bounding rect for the month in the
    // top left corner
    prc->left   = pmc->rcCentered.left;
    prc->right  = prc->left + pmc->dxMonth;
    prc->top    = pmc->rcCentered.top;
    prc->bottom = prc->top + pmc->dyMonth;

    if (iCol)       // slide the rect across to the correct column
    {
        d = (pmc->dxMonth + CALBORDER) * iCol;
        prc->left  += d;
        prc->right += d;
    }
    if (iRow)       // slide the rect down to the correct row
    {
        d = (pmc->dyMonth + CALBORDER) * iRow;
        prc->top    += d;
        prc->bottom += d;
    }
}

// Changes starting month by nDelta
// returns number of months actually changed
int FIncrStartMonth(MONTHCAL *pmc, int nDelta, BOOL fNoCurDayChange)
{
    SYSTEMTIME stStart;

    int nOldStartYear  = pmc->stMonthFirst.wYear;
    int nOldStartMonth = pmc->stMonthFirst.wMonth;

    IncrSystemTime(&pmc->stMonthFirst, &stStart, nDelta, INCRSYS_MONTH);

    // MCUpdateStartEndDates takes stMin/stMax into account
    MCUpdateStartEndDates(pmc, &stStart);

    if (!fNoCurDayChange)
    {
        int cday;

        // BUGBUG: we arbitrarily set the currently selected day
        // to be in the new stMonthFirst, but given the way the
        // control works, I doubt we ever hit this code. what's it for??

        if (MonthCal_IsMultiSelect(pmc))
            cday = DaysBetweenDates(&pmc->st, &pmc->stEndSel);

        // need to set date for focus here
        pmc->st.wMonth = pmc->stMonthFirst.wMonth;
        pmc->st.wYear  = pmc->stMonthFirst.wYear;

        // Check to see if the day is in range, eg, Jan 31 -> Feb 28
        if (pmc->st.wDay > pmc->rgcDay[1])
            pmc->st.wDay = (WORD) pmc->rgcDay[1];

        if (MonthCal_IsMultiSelect(pmc))
            IncrSystemTime(&pmc->st, &pmc->stEndSel, cday, INCRSYS_DAY);

        MCNotifySelChange(pmc, MCN_SELCHANGE);

        MCUpdateRcDayCur(pmc, &pmc->st);
    }

    MCInvalidateMonthDays(pmc);

    return((pmc->stMonthFirst.wYear-nOldStartYear)*12 + (pmc->stMonthFirst.wMonth-nOldStartMonth));
}

// FIncrStartMonth with a beep when it doesn't change.
int MCIncrStartMonth(MONTHCAL *pmc, int nDelta, BOOL fDelayDayChange)
{
    int cmoSpun;

    // FIncrStartMonth takes stMin/stMax into account
    cmoSpun = FIncrStartMonth(pmc, nDelta, fDelayDayChange);

    if (cmoSpun==0)
        MessageBeep(0);

    return(cmoSpun);
}

//
// Determines in which month the given point lies.  In other words, if the
// calendar control is currently sized to show six months, this routine
// determines in which which of those six months the point lies.  It returns
// the zero based index of the month, counting along the rows.
//
BOOL FGetOffsetForPt(MONTHCAL *pmc, POINT pt, int *piOffset)
{
    int iRow, iCol, i;

    // check to see if point is within the centered months
    if (!PtInRect(&pmc->rcCentered, pt))
        return(FALSE);

    // calculate the month row and column
    // (we're really fudging a little here, since the point could
    // actually be within the space between months...)
    iCol = (pt.x - pmc->rcCentered.left) / (pmc->dxMonth + CALBORDER);
    iRow = (pt.y - pmc->rcCentered.top) / (pmc->dyMonth + CALBORDER);

    i = iRow * pmc->nViewCols + iCol;
    if (i >= pmc->nMonths)
        return(FALSE);

    *piOffset = i;

    return(TRUE);
}

//
// This routine returns the row and column of day containing the given point
//
BOOL FGetRowColForRelPt(MONTHCAL *pmc, POINT ptRel, int *piRow, int *piCol)
{
    if (!PtInRect(&pmc->rcDayNum, ptRel))
        return(FALSE);

    ptRel.x -= pmc->rcDayNum.left;
    ptRel.y -= pmc->rcDayNum.top;

    *piCol = ptRel.x / pmc->dxCol;
    *piRow = ptRel.y / pmc->dyRow;

    return(TRUE);
}

//
// This routine returns the month and year of the iMonth in the displayed
// months.  NOTE: iMonth is a zero-based index of the displayed months
//
void GetYrMoForOffset(MONTHCAL *pmc, int iMonth, int *piYear, int *piMonth)
{
    SYSTEMTIME st;

    st.wDay   = 1;
    st.wMonth = pmc->stMonthFirst.wMonth;
    st.wYear  = pmc->stMonthFirst.wYear;

    IncrSystemTime(&st, &st, iMonth, INCRSYS_MONTH);

    *piYear  = st.wYear;
    *piMonth = st.wMonth;
}

//
// This routine returns, the day, month, and year of day containing the
// given point.  It will optionally return the day of the month, the row and
// column in the month, and the bounding rect of the month containing the point.
// NOTE: the day returned in piDay can be less than 1 (to indicate a day in the
// previous month) or greater than the number of days in the month (to indicate
// a day in the next month).
//
BOOL FGetDateForPt(MONTHCAL *pmc, POINT pt, SYSTEMTIME *pst, int *piDay,
                   int* piCol, int* piRow, LPRECT prcMonth)
{
    int iOff, iRow, iCol, iDay, iMon, iYear;
    RECT rcMonth;

    if (!FGetOffsetForPt(pmc, pt, &iOff))
        return(FALSE);

    MCGetRcForMonth(pmc, iOff, &rcMonth);
    pt.x -= rcMonth.left;
    pt.y -= rcMonth.top;
    if (!FGetRowColForRelPt(pmc, pt, &iRow, &iCol))
        return(FALSE);

    // get the day containing the point by subtracting the number of days
    // that are visible from the previous month, and then add one, since
    // we are zero-based and the days of the month are 1-based.
    //
    iDay = iRow * CALCOLMAX + iCol - (pmc->rgcDay[iOff] - pmc->rgnDayUL[iOff]) + 1;
    if (piDay)
        *piDay = iDay;

    if (iDay <= 0)
    {
        if (iOff)
            return(FALSE);      // dont accept days in prev month unless
                                // this happens to be the first month

        iDay += pmc->rgcDay[iOff];  // add the cnt of days in the prev month,
        --iOff;                     // then incr the month to get day in new month
    }
    else if (iDay > pmc->rgcDay[iOff+1])
    {
        if (iOff < (pmc->nMonths - 1))  // dont accept days in next month unless
            return(FALSE);              // this happens to be the last month

        ++iOff;                         // increment the month, and then sub the
        iDay -= pmc->rgcDay[iOff];      // count of days to get day in new month
    }

    GetYrMoForOffset(pmc, iOff, &iYear, &iMon);
    pst->wDay   = (WORD) iDay;
    pst->wMonth = (WORD) iMon;
    pst->wYear  = (WORD) iYear;

    if (piCol)
        *piCol = iCol;

    if (piRow)
        *piRow = iRow;

    if (prcMonth)
        *prcMonth = rcMonth;

    return(TRUE);
}

BOOL MCSetDate(MONTHCAL *pmc, SYSTEMTIME *pst)
{
    int nDelta = 0;

    //
    // Can't set date outside of min/max range
    //
    if (CmpDate(pst, &pmc->stMin) < 0)
        return FALSE;
    if (CmpDate(pst, &pmc->stMax) > 0)
        return FALSE;

    //
    // Set new day
    //
    pmc->st = *pst;
    if (MonthCal_IsMultiSelect(pmc))
        pmc->stEndSel = *pst;

    FScrollIntoView(pmc);

    MCNotifySelChange(pmc, MCN_SELCHANGE);

    MCUpdateRcDayCur(pmc, pst);

    return(TRUE);
}

void MCSetToday(MONTHCAL* pmc, SYSTEMTIME* pst)
{
    SYSTEMTIME st;
    RECT rc;

    if (!pst)
    {
        GetLocalTime(&st);
        pmc->fTodaySet = FALSE;
    }
    else
    {
        st = *pst;
        pmc->fTodaySet = TRUE;
    }

    if (CmpDate(&st, &pmc->stToday) != 0)
    {
        MCGetRcForDay(pmc, pmc->iMonthToday, pmc->stToday.wDay, &rc);
        InvalidateRect(pmc->ci.hwnd, &rc, FALSE);

        pmc->stToday = st;

        MCUpdateToday(pmc);

        MCGetRcForDay(pmc, pmc->iMonthToday, pmc->stToday.wDay, &rc);
        InvalidateRect(pmc->ci.hwnd, &rc, FALSE);

        if (MonthCal_ShowToday(pmc))
        {
            MCGetTodayBtnRect(pmc, &rc);
            InvalidateRect(pmc->ci.hwnd, &rc, FALSE);
        }

        UpdateWindow(pmc->ci.hwnd);
    }
}

LRESULT MCHandleTimer(MONTHCAL *pmc, WPARAM wParam)
{
    if (wParam == CAL_IDAUTOSPIN)
    {
        int nDelta = pmc->fMonthDelta ? pmc->nMonthDelta : pmc->nMonths;

        // BUGBUG pass last parameter TRUE if multiselect! else you
        // can't multiselect across months
        MCIncrStartMonth(pmc, (pmc->fSpinPrev ? -nDelta : nDelta), FALSE);

        if (pmc->idTimer == 0)
            pmc->idTimer = SetTimer(pmc->ci.hwnd, CAL_IDAUTOSPIN, CAL_MSECAUTOSPIN, NULL);

        pmc->rcDayOld = pmc->rcDayCur;
        UpdateWindow(pmc->ci.hwnd);
    }
    else if (wParam == CAL_TODAYTIMER)
    {
        if (!pmc->fTodaySet)
            MCSetToday(pmc, NULL);
    }

    MCNotifySelChange(pmc, MCN_SELCHANGE);     // our date has changed

    return((LRESULT)TRUE);
}

void MCInvalidateDates(MONTHCAL *pmc, SYSTEMTIME *pst1, SYSTEMTIME *pst2)
{
    int iMonth, ioff, icol, irow;
    RECT rc, rcMonth;
    SYSTEMTIME st, stEnd;

    if (CmpDate(pst1, &pmc->stViewLast) > 0 ||
        CmpDate(pst2, &pmc->stViewFirst) < 0)
        return;

    if (CmpDate(pst1, &pmc->stViewFirst) < 0)
        CopyDate(pmc->stViewFirst, st);
    else
        CopyDate(*pst1, st);

    if (CmpDate(pst2, &pmc->stViewLast) > 0)
        CopyDate(pmc->stViewLast, stEnd);
    else
        CopyDate(*pst2, stEnd);

    iMonth = MCGetOffsetForYrMo(pmc, st.wYear, st.wMonth);
    if (iMonth == -1)
    {
        if (st.wMonth == pmc->stViewFirst.wMonth)
        {
            iMonth = 0;
            ioff = st.wDay - pmc->rgnDayUL[0] - 1;
        }
        else
        {
            iMonth = pmc->nMonths - 1;
            ioff = st.wDay + pmc->rgcDay[pmc->nMonths] +
                pmc->rgcDay[iMonth] - pmc->rgnDayUL[iMonth] - 1;
        }
    }
    else
    {
        ioff = st.wDay + (pmc->rgcDay[iMonth] - pmc->rgnDayUL[iMonth]) - 1;
    }

    MCGetRcForMonth(pmc, iMonth, &rcMonth);

    // TODO: make it more efficient...
    while (CmpDate(&st, &stEnd) <= 0)
    {
        irow = ioff / CALCOLMAX;
        icol = ioff % CALCOLMAX;
        rc.left   = rcMonth.left + pmc->rcDayNum.left + (pmc->dxCol * icol);
        rc.top    = rcMonth.top  + pmc->rcDayNum.top  + (pmc->dyRow * irow);
        rc.right  = rc.left      + pmc->dxCol;
        rc.bottom = rc.top       + pmc->dyRow;

        InvalidateRect(pmc->ci.hwnd, &rc, FALSE);

        IncrSystemTime(&st, &st, 1, INCRSYS_DAY);
        ioff++;

        if (st.wDay == 1)
        {
            if (st.wMonth != pmc->stMonthFirst.wMonth &&
                st.wMonth != pmc->stViewLast.wMonth)
            {
                iMonth++;
                MCGetRcForMonth(pmc, iMonth, &rcMonth);

                ioff = ioff % CALCOLMAX;
            }
        }
    }
}

void MCHandleMultiSelect(MONTHCAL *pmc, SYSTEMTIME *pst)
{
    int i;
    DWORD cday;
    SYSTEMTIME stStart, stEnd;

    if (!pmc->fMultiSelecting)
    {
        CopyDate(*pst, stStart);
        CopyDate(*pst, stEnd);

        pmc->fMultiSelecting = TRUE;
        pmc->fForwardSelect = TRUE;

        CopyDate(pmc->st, pmc->stStartPrev);
        CopyDate(pmc->stEndSel, pmc->stEndPrev);
    }
    else
    {
        if (pmc->fForwardSelect)
        {
            i = CmpDate(pst, &pmc->st);
            if (i >= 0)
            {
                CopyDate(pmc->st, stStart);
                CopyDate(*pst, stEnd);
            }
            else
            {
                CopyDate(*pst, stStart);
                CopyDate(pmc->st, stEnd);
                pmc->fForwardSelect = FALSE;
            }
        }
        else
        {
            i = CmpDate(pst, &pmc->stEndSel);
            if (i < 0)
            {
                CopyDate(*pst, stStart);
                CopyDate(pmc->stEndSel, stEnd);
            }
            else
            {
                CopyDate(pmc->stEndSel, stStart);
                CopyDate(*pst, stEnd);
                pmc->fForwardSelect = TRUE;
            }
        }
    }

    // check to make sure not exceeding cSelMax
    cday = DaysBetweenDates(&stStart, &stEnd) + 1;
    if (cday > pmc->cSelMax)
    {
        if (pmc->fForwardSelect)
            IncrSystemTime(&stStart, &stEnd, pmc->cSelMax - 1, INCRSYS_DAY);
        else
            IncrSystemTime(&stEnd, &stStart, 1 - pmc->cSelMax, INCRSYS_DAY);
    }

    if (0 == CmpDate(&stStart, &pmc->st) &&
        0 == CmpDate(&stEnd, &pmc->stEndSel))
        return;

    // TODO: do this more effeciently..
    MCInvalidateDates(pmc, &pmc->st, &pmc->stEndSel);
    MCInvalidateDates(pmc, &stStart, &stEnd);

    CopyDate(stStart, pmc->st);
    CopyDate(stEnd, pmc->stEndSel);

    MCNotifySelChange(pmc, MCN_SELCHANGE);

    UpdateWindow(pmc->ci.hwnd);
}

void MCGotoToday(MONTHCAL *pmc)
{
    pmc->rcDayOld = pmc->rcDayCur;

    // force old selection to get repainted
    if (MonthCal_IsMultiSelect(pmc))
        MCInvalidateDates(pmc, &pmc->st, &pmc->stEndSel);
    else
        InvalidateRect(pmc->ci.hwnd, &pmc->rcDayOld, FALSE);

    MCSetDate(pmc, &pmc->stToday);

    MCNotifySelChange(pmc, MCN_SELECT);

    // force new selection to get repainted
    InvalidateRect(pmc->ci.hwnd, &pmc->rcDayCur, FALSE);
    UpdateWindow(pmc->ci.hwnd);
}

LRESULT MCContextMenu(MONTHCAL *pmc, WPARAM wParam, LPARAM lParam)
{
    POINT pt;
    int click;

    if (!pmc->fEnabled || !MonthCal_ShowToday(pmc))
        return(0);

    // ignore double click since this makes us advance twice
    // since we already had a leftdown before the leftdblclk
    if (!pmc->fCapture)
    {
        pt.x = GET_X_LPARAM(lParam);
        pt.y = GET_Y_LPARAM(lParam);

        //
        //  If the context menu was generated from the keyboard,
        //  then put it at the focus rectangle.
        //
        if (pt.x == -1 && pt.y == -1)
        {
            pt.x = (pmc->rcDayCur.left + pmc->rcDayCur.right ) / 2;
            pt.y = (pmc->rcDayCur.top  + pmc->rcDayCur.bottom) / 2;
            ClientToScreen(pmc->ci.hwnd, &pt);
        }

        click = TrackPopupMenu(pmc->hmenuCtxt,
                    TPM_LEFTBUTTON | TPM_RIGHTBUTTON | TPM_RETURNCMD | TPM_NONOTIFY,
                    pt.x, pt.y, 0, pmc->ci.hwnd, NULL);
        if (click >= 1)
            MCGotoToday(pmc);
    }

    return(0);
}

//
// Computes the bounding rects for the month and the year in the title area of
// the month.
//
void MCGetTitleRcsForOffset(MONTHCAL* pmc, int iOffset, LPRECT prcMonth, LPRECT prcYear)
{
    RECT rcT;
    RECT rc;
    MCGetRcForMonth(pmc, iOffset, &rc);

    rcT.top    = rc.top + (pmc->dyRow / 2);
    rcT.bottom = rcT.top + pmc->dyRow;

    rcT.left  = rc.left + pmc->rcMonthName.left + pmc->rgmm[iOffset].rgi[IMM_MONTHSTART];
    rcT.right = rc.left + pmc->rcMonthName.left + pmc->rgmm[iOffset].rgi[IMM_MONTHEND];
    *prcMonth = rcT;

    rcT.left  = rc.left + pmc->rcMonthName.left + pmc->rgmm[iOffset].rgi[IMM_YEARSTART];
    rcT.right = rc.left + pmc->rcMonthName.left + pmc->rgmm[iOffset].rgi[IMM_YEAREND];
    *prcYear  = rcT;

}

LRESULT MCLButtonDown(MONTHCAL *pmc, WPARAM wParam, LPARAM lParam)
{
    HDC        hdc;
    POINT      pt;
    SYSTEMTIME st;
    RECT       rc, rcCal;
    BOOL       fShow;
    MSG        msg;
    int        offset, imonth, iyear;

    if (!pmc->fEnabled)
        return(0);

    pt.x = GET_X_LPARAM(lParam);
    pt.y = GET_Y_LPARAM(lParam);

    // treat a shift click like an LMouseDown at the prev location and
    // a MouseMove to the new location
    if (MonthCal_IsMultiSelect(pmc) && ((wParam & MK_SHIFT) == MK_SHIFT) && (!PtInRect(&pmc->rcDayCur, pt)))
    {
        SetCapture(pmc->ci.hwnd);
        pmc->fCapture = TRUE;

        pmc->fForwardSelect = (CmpDate(&pmc->stAnchor, &pmc->st) != 0) ? FALSE : TRUE;
        pmc->fMultiSelecting = TRUE;

        hdc = GetDC(pmc->ci.hwnd);
        DrawFocusRect(hdc, &pmc->rcDayCur);    // draw focus rect
        pmc->fFocusDrawn = TRUE;
        ReleaseDC(pmc->ci.hwnd, hdc);

        MCMouseMove(pmc, wParam, lParam);      // draw the highlight to new date

        return 0;
    }

    // ignore double click since this makes us advance twice
    // since we already had a leftdown before the leftdblclk
    if (!pmc->fCapture)
    {
        SetCapture(pmc->ci.hwnd);
        pmc->fCapture = TRUE;

        // check for spin buttons
        if ((pmc->fSpinPrev = (WORD) PtInRect(&pmc->rcPrev, pt)) || PtInRect(&pmc->rcNext, pt))
        {
            MCHandleTimer(pmc, CAL_IDAUTOSPIN);

            return(0);
        }

        // check for valid day
        pmc->rcDayOld = pmc->rcDayCur;   // rcDayCur should always be valid now

        if (MonthCal_IsMultiSelect(pmc))
        {
            // need to cache these values because these are how
            // we determine if the selection has changed and we
            // need to notify the parent
            CopyDate(pmc->st, pmc->stStartPrev);
            CopyDate(pmc->stEndSel, pmc->stEndPrev);
        }


        if (FUpdateRcDayCur(pmc, pt))
        {
            if (MonthCal_IsMultiSelect(pmc))
            {
                if (FGetDateForPt(pmc, pt, &st, NULL, NULL, NULL, NULL))
                    MCHandleMultiSelect(pmc, &st);
            }

            hdc = GetDC(pmc->ci.hwnd);
            DrawFocusRect(hdc, &pmc->rcDayCur);    // draw focus rect
            pmc->fFocusDrawn = TRUE;
            ReleaseDC(pmc->ci.hwnd, hdc);

            CopyDate(st, pmc->stAnchor);           // new Anchor point
        }
        else
        {
            RECT rcMonth, rcYear;
            int delta, year, month;

            // is this a click in the today area...
            if (MonthCal_ShowToday(pmc))
            {
                MCGetTodayBtnRect(pmc, &rc);
                if (PtInRect(&rc, pt))
                {
                    CCReleaseCapture(&pmc->ci);
                    pmc->fCapture = FALSE;

                    MCGotoToday(pmc);
                    return(0);
                }
            }

            // figure out if the click was in a month name or a year

            if (!FGetOffsetForPt(pmc, pt, &offset))
                return(0);

            GetYrMoForOffset(pmc, offset, &year, &month);

            // calculate where the month name and year are,
            // so we can figure out if they clicked in them...
            MCGetTitleRcsForOffset(pmc, offset, &rcMonth, &rcYear);

            delta = 0;
            if (PtInRect(&rcMonth, pt))
            {
                CCReleaseCapture(&pmc->ci);
                pmc->fCapture = FALSE;

                ClientToScreen(pmc->ci.hwnd, &pt);
                imonth = TrackPopupMenu(pmc->hmenuMonth,
                    TPM_LEFTALIGN | TPM_TOPALIGN |
                    TPM_NONOTIFY | TPM_RETURNCMD | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                    pt.x, pt.y, 0, pmc->ci.hwnd, NULL);
                if (imonth >= 1)
                    delta = imonth - month;
                goto ChangeMonth;
            }

            if (PtInRect(&rcYear, pt))
            {
                HWND hwndEdit, hwndUD, hwndFocus;
                int yrMin, yrMax;
                DWORD dwExStyle = 0L;
                CCReleaseCapture(&pmc->ci);
                pmc->fCapture = FALSE;


                //
                // If the year is in a RTL string, then numeric control
                // is to the left.
                //
                if (pmc->fHeaderRTL)
                {
                    rcYear.left = (rcYear.right - (pmc->dxYearMax + 6));
                }
                else
                {
                    rcYear.right = rcYear.left + pmc->dxYearMax + 6;
                }
                rcYear.top--;
                rcYear.bottom++;
                if(((pmc->fHeaderRTL) && !(IS_WINDOW_RTL_MIRRORED(pmc->ci.hwnd))) ||
                  (!(pmc->fHeaderRTL) && (IS_WINDOW_RTL_MIRRORED(pmc->ci.hwnd))))
                {
                    // not mirrored force RTL, mirrored force LTR (for mirroring RTLis LTR!!)
                    dwExStyle|= WS_EX_RTLREADING;
                }
                hwndEdit = CreateWindowEx(dwExStyle, TEXT("EDIT"), NULL,
                    WS_CHILD | WS_VISIBLE | WS_BORDER | ES_READONLY | ES_LEFT | ES_AUTOHSCROLL,
                    rcYear.left, rcYear.top, rcYear.right - rcYear.left, rcYear.bottom - rcYear.top,
                    pmc->ci.hwnd, (HMENU)0, pmc->hinstance, NULL);
                if (hwndEdit == NULL)
                    return(0);

                pmc->hwndEdit = hwndEdit;

                SendMessage(hwndEdit, WM_SETFONT, (WPARAM)pmc->hfontBold, (LPARAM)FALSE);
                SendMessage(hwndEdit, EM_SETMARGINS, EC_LEFTMARGIN | EC_RIGHTMARGIN,
                            (LPARAM)MAKELONG(1, 1));
                MCUpdateEditYear(pmc);

                //
                //  Convert from Gregorian to display years.
                //
                year = GregorianToOther(&pmc->ct, year);
                yrMin = GregorianToOther(&pmc->ct, pmc->stMin.wYear);
                yrMax = 9999;
                if (pmc->fMaxYrSet)
                    yrMax = GregorianToOther(&pmc->ct, pmc->stMax.wYear);

                hwndUD = CreateUpDownControl(
                    WS_CHILD | WS_VISIBLE | WS_BORDER |
                    UDS_NOTHOUSANDS | UDS_ARROWKEYS,// | UDS_SETBUDDYINT,
                    pmc->fHeaderRTL ? (rcYear.left - 1 - (rcYear.bottom-rcYear.top)): (rcYear.right + 1),
                    rcYear.top,
                    rcYear.bottom - rcYear.top, rcYear.bottom - rcYear.top, pmc->ci.hwnd,
                    1, pmc->hinstance, hwndEdit, yrMax, yrMin, year);
                if (hwndUD == NULL)
                {
                    DestroyWindow(hwndEdit);
                    return(0);
                }

                pmc->hwndUD = hwndUD;

                hwndFocus = SetFocus(hwndEdit);

                //
                // Widen the area depending on the string direction.
                //
                if (pmc->fHeaderRTL)
                    rcYear.left -= (1 + rcYear.bottom - rcYear.top);
                else
                    rcYear.right += 1 + rcYear.bottom - rcYear.top;
                // Use MapWindowRect, It works in a mirrored and unmirrored windows.
                MapWindowRect(pmc->ci.hwnd, NULL, (LPPOINT)&rcYear);

                rcCal = pmc->rc;
                MapWindowRect(pmc->ci.hwnd, NULL, (LPPOINT)&rcCal);

                fShow = TRUE;

                while (fShow && GetFocus() == hwndEdit)
                {
                    if (PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE))
                    {
                        // Check for events that cause the calendar to go away

                        if (msg.message == WM_KILLFOCUS ||
                            (msg.message >= WM_SYSKEYDOWN &&
                            msg.message <= WM_SYSDEADCHAR))
                        {
                            fShow = FALSE;
                        }
                        else if ((msg.message == WM_LBUTTONDOWN ||
                            msg.message == WM_NCLBUTTONDOWN ||
                            msg.message == WM_RBUTTONDOWN ||
                            msg.message == WM_NCRBUTTONDOWN ||
                            msg.message == WM_MBUTTONDOWN ||
                            msg.message == WM_NCMBUTTONDOWN) &&
                            !PtInRect(&rcYear, msg.pt))
                        {
                            fShow = FALSE;

                            // if its a button down inside the calendar, eat it
                            // so the calendar doesn't do anything strange when
                            // the user is just trying to get rid of the year edit
                            if (PtInRect(&rcCal, msg.pt))
                                GetMessage(&msg, NULL, 0, 0);

                            break;    // do not dispatch
                        }
                        else if (msg.message == WM_QUIT)
                        {   // Don't dispatch a WM_QUIT; leave it in the queue
                            break;    // do not dispatch
                        }
                        else if (msg.message == WM_CHAR)
                        {
                            if (msg.wParam == VK_ESCAPE)
                            {
                                goto NoYearChange;
                            }
                            else if (msg.wParam == VK_RETURN)
                            {
                                fShow = FALSE;
                            }
                        }

                        GetMessage(&msg, NULL, 0, 0);
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    }
                    else
                        WaitMessage();
                }

                iyear = (int) SendMessage(hwndUD, UDM_GETPOS, 0, 0);
                if (HIWORD(iyear) == 0)
                    delta = (iyear - year) * 12;

NoYearChange:
                DestroyWindow(hwndUD);
                DestroyWindow(hwndEdit);

                pmc->hwndUD = NULL;
                pmc->hwndEdit = NULL;

                UpdateWindow(pmc->ci.hwnd);

                if (hwndFocus != NULL)
                    SetFocus(hwndFocus);
            }
ChangeMonth:
            if (delta != 0)
            {
                MCIncrStartMonth(pmc, delta, FALSE);
                MCNotifySelChange(pmc,MCN_SELCHANGE);
            }

        }
    }

    return(0);
}

LRESULT MCLButtonUp(MONTHCAL *pmc, WPARAM wParam, LPARAM lParam)
{
    HDC hdc;
    SYSTEMTIME st;
    POINT pt;

    if (pmc->fCapture)
    {
        CCReleaseCapture(&pmc->ci);
        pmc->fCapture = FALSE;

        if (pmc->idTimer)
        {
            KillTimer(pmc->ci.hwnd, pmc->idTimer);
            pmc->idTimer = 0;

            hdc = GetDC(pmc->ci.hwnd);
            MCPaintArrowBtn(pmc, hdc, pmc->fSpinPrev, FALSE);
            ReleaseDC(pmc->ci.hwnd, hdc);

            return(0);
        }


        if (pmc->fFocusDrawn)
        {
            hdc = GetDC(pmc->ci.hwnd);
            DrawFocusRect(hdc, &pmc->rcDayCur); // erase old focus rect
            pmc->fFocusDrawn = FALSE;
            ReleaseDC(pmc->ci.hwnd, hdc);
        }

        pt.x = GET_X_LPARAM(lParam);
        pt.y = GET_Y_LPARAM(lParam);

        if (MonthCal_IsMultiSelect(pmc))
        {
            FUpdateRcDayCur(pmc, pt);

            if (!EqualRect(&pmc->rcDayOld, &pmc->rcDayCur))
            {
                if (FGetDateForPt(pmc, pt, &st, NULL, NULL, NULL, NULL))
                    MCHandleMultiSelect(pmc, &st);
            }

            pmc->fMultiSelecting = FALSE;
            if (0 != CmpDate(&pmc->stStartPrev, &pmc->st) ||
                0 != CmpDate(&pmc->stEndPrev, &pmc->stEndSel))
            {
                FScrollIntoView(pmc);
            }
            MCNotifySelChange(pmc, MCN_SELECT);
        }
        else
        {
            if (FUpdateRcDayCur(pmc, pt))
            {
                if (!EqualRect(&pmc->rcDayOld, &pmc->rcDayCur) && (FGetDateForPt(pmc, pt, &st, NULL, NULL, NULL, NULL)))
                {
                    InvalidateRect(pmc->ci.hwnd, &pmc->rcDayOld, FALSE);
                    InvalidateRect(pmc->ci.hwnd, &pmc->rcDayCur, FALSE);

                    MCSetDate(pmc, &st);
                }

                MCNotifySelChange(pmc, MCN_SELECT);
            }
        }
    }

    return(0);
}

LRESULT MCMouseMove(MONTHCAL *pmc, WPARAM wParam, LPARAM lParam)
{
    BOOL fPrev;
    HDC hdc;
    POINT pt;
    SYSTEMTIME st;

    if (pmc->fCapture)
    {
        pt.x = GET_X_LPARAM(lParam);
        pt.y = GET_Y_LPARAM(lParam);

        // check spin buttons
        if ((fPrev = PtInRect(&pmc->rcPrev, pt)) || PtInRect(&pmc->rcNext, pt))
        {
            if (pmc->idTimer == 0)
            {
                pmc->fSpinPrev = (WORD) fPrev;
                MCHandleTimer(pmc, CAL_IDAUTOSPIN);
            }

            return(0);
        }
        else
        {
            hdc = GetDC(pmc->ci.hwnd);

            if (pmc->idTimer)
            {
                KillTimer(pmc->ci.hwnd, pmc->idTimer);
                pmc->idTimer = 0;
                MCPaintArrowBtn(pmc, hdc, pmc->fSpinPrev, FALSE);
            }
        }

        // check days
        if (!PtInRect(&pmc->rcDayCur, pt))
        {
            if (pmc->fFocusDrawn)
                DrawFocusRect(hdc, &pmc->rcDayCur);         // erase focus rect

            if (pmc->fFocusDrawn = (WORD) FUpdateRcDayCur(pmc, pt))
            {
                // moved into a new valid day
                if (pmc->fMultiSelecting)
                {
                    if (FGetDateForPt(pmc, pt, &st, NULL, NULL, NULL, NULL))
                        MCHandleMultiSelect(pmc, &st);
                }

                DrawFocusRect(hdc, &pmc->rcDayCur);
            }
            else
            {
                // moved into an invalid position
                pmc->rcDayCur = pmc->rcDayOld;
            }
        }
        else if (!pmc->fFocusDrawn)
        {
            // handle case where we just moved back into rcDayCur from invalid area
            DrawFocusRect(hdc, &pmc->rcDayCur);
            pmc->fFocusDrawn = TRUE;
        }

        ReleaseDC(pmc->ci.hwnd, hdc);
    }

    return(0);
}


LRESULT MCHandleKeydown(MONTHCAL *pmc, WPARAM wParam, LPARAM lParam)
{
    LONG       lIncrement;
    int        iDirection;
    SYSTEMTIME st;
    BOOL       fRet = FALSE;
    HDC        hdc = NULL;
    RECT       rcCurFocus;

    // BUGBUG raymondc ERA - need to invalidate month title when selection
    // moves in/out/within

    switch (wParam)
    {
        case VK_CONTROL:
            pmc->fControl = TRUE;           // we'll clear this on WM_KEYUP
            return TRUE;
            break;

        case VK_SHIFT:
            pmc->fShift = TRUE;             // we'll clear this on WM_KEYUP
            return TRUE;
            break;

        case VK_LEFT:                       // goto previous day
            iDirection = -1;
            lIncrement = INCRSYS_DAY;
            break;

        case VK_RIGHT:                      // goto next day
            iDirection = 1;
            lIncrement = INCRSYS_DAY;
            break;

        case VK_UP:                         // goto previous week
            iDirection = -1;
            lIncrement = INCRSYS_WEEK;
            break;

        case VK_DOWN:                       // goto next week
            iDirection = 1;
            lIncrement = INCRSYS_WEEK;
            break;

        case VK_NEXT:
            iDirection = 1;
            if (pmc->fControl)              // goto next year
                lIncrement = INCRSYS_YEAR;
            else                            // goto next month
                lIncrement = INCRSYS_MONTH;
            break;

        case VK_PRIOR:
            iDirection = -1;
            if (pmc->fControl)              // goto previous year
                lIncrement = INCRSYS_YEAR;
            else
                lIncrement = INCRSYS_MONTH; // goto next month
            break;

        case VK_HOME:
            if (pmc->fControl)              // goto first visible month
            {
                CopyDate(pmc->stMonthFirst, st);
            }
            else                            // goto first day of current month
            {
                CopyDate(pmc->st, st);
                st.wDay = 1;
            }
            goto setDate;
            break;

        case VK_END:
            if (pmc->fControl)              // goto last visible month
            {
                CopyDate(pmc->stMonthLast, st);
            }
            else                            // goto last day of current month
            {
                CopyDate(pmc->st, st);
                st.wDay = (WORD) GetDaysForMonth(st.wYear, st.wMonth);
            }
            goto setDate;
            break;


        default:
            return FALSE;
    }

    // if we're multiselecting, we need to know which "end" of the selection
    // the user is moving.

    if (pmc->fMultiSelecting && pmc->fForwardSelect)
        CopyDate(pmc->stEndSel, st);
    else
        CopyDate(pmc->st, st);

    IncrSystemTime(&st, &st, iDirection, lIncrement);


setDate:

    // based on the window style and the shift key state,
    // we'll do a multi-select (or not)
    if (MonthCal_IsMultiSelect(pmc) && pmc->fShift)
    {
        pmc->fForwardSelect = (CmpDate(&pmc->st, &pmc->stAnchor) >= 0) ? TRUE : FALSE;
        pmc->fMultiSelecting = TRUE;
    }

    // otherwise, we'll end multiselect, and set the new anchor
    else
    {
        pmc->fMultiSelecting = FALSE;
        CopyDate(st, pmc->stAnchor);
    }

    if (pmc->fFocusDrawn)   // erase the focus rect, but don't clear the bit
    {                       // so we know to put it back
        hdc = GetDC(pmc->ci.hwnd);
        DrawFocusRect(hdc, &pmc->rcDayCur);
        ReleaseDC(pmc->ci.hwnd, hdc);
        rcCurFocus = pmc->rcDayCur;
    }
    else
    {
        pmc->rcDayOld = pmc->rcDayCur;
    }

    if (MonthCal_IsMultiSelect(pmc))
    {
        int nDelta = 0;

        MCHandleMultiSelect(pmc, &st);

        FScrollIntoView(pmc);
    }
    else if (fRet = MCSetDate(pmc, &st))
    {
        InvalidateRect(pmc->ci.hwnd, &pmc->rcDayOld, FALSE);
        InvalidateRect(pmc->ci.hwnd, &pmc->rcDayCur, FALSE);
        UpdateWindow(pmc->ci.hwnd);
    }

    if (pmc->fFocusDrawn)   // put the focus rect back
    {
        pmc->rcDayOld = pmc->rcDayCur;
        pmc->rcDayCur = rcCurFocus;
        hdc = GetDC(pmc->ci.hwnd);
        DrawFocusRect(hdc, &pmc->rcDayCur);
        ReleaseDC(pmc->ci.hwnd, hdc);
    }

    return fRet;
}

#if 0 // coming soon

LRESULT MCHandleChar(MONTHCAL *pmc, WPARAM wParam, LPARAM lParam)
{


    return 0;
}

#endif

//
//  Era information is kept in a DPA of LocalAlloc'd strings.
//
int MCDPAEnumCallback(LPVOID d, LPVOID p)
{
    UNREFERENCED_PARAMETER(p);
    if (d)
        LocalFree(d);
    return TRUE;
}

void MCDPADestroy(HDPA hdpa)
{
    if (hdpa)
        DPA_DestroyCallback(hdpa, MCDPAEnumCallback, 0);
}

//
//  Collect era information.
//
//  Since EnumCalendarInfo is not thread-safe, we have to take the critical
//  section.

HDPA g_hdpaCal;

#ifdef WINNT
BOOL MCEnumCalInfoProc(LPWSTR psz)
#else
BOOL MCEnumCalInfoProc(LPSTR psz)
#endif
{
#ifdef UNICODE_WIN9x
    LPWSTR pwszSave = StrDup_AtoW((LPCWSTR)psz);
#else
    LPWSTR pwszSave = StrDup(psz);
#endif
    if (pwszSave) {
        if (DPA_AppendPtr(g_hdpaCal, pwszSave) >= 0) {
            return TRUE;
        }
        LocalFree(pwszSave);
    }

    //
    //  Out of memory.  Bail.
    //
    MCDPADestroy(g_hdpaCal);
    g_hdpaCal = NULL;
    return FALSE;
}

HDPA MCGetCalInfoDPA(CALID calid, CALTYPE calType)
{
    HDPA hdpa = DPA_Create(4);

    ENTERCRITICAL;
    ASSERT(g_hdpaCal == NULL);
    g_hdpaCal = hdpa;
#ifdef WINNT
    EnumCalendarInfoW(MCEnumCalInfoProc, LOCALE_USER_DEFAULT, calid, calType);
#else
    EnumCalendarInfoA(MCEnumCalInfoProc, LOCALE_USER_DEFAULT, calid, calType);
#endif
    hdpa = g_hdpaCal;
    g_hdpaCal = NULL;
    LEAVECRITICAL;

    return hdpa;
}

void MCFreeCalendarInfo(PCALENDARTYPE pct)
{
    MCDPADestroy(pct->hdpaYears);
    MCDPADestroy(pct->hdpaEras);
    pct->hdpaYears = 0;
    pct->hdpaEras = 0;
}

//
//  Get all the era info and validate it so we don't fault when we try to
//  use them.
//
BOOL MCGetEraInfo(PCALENDARTYPE pct)
{
    int i;

    pct->hdpaYears = MCGetCalInfoDPA(pct->calid, CAL_IYEAROFFSETRANGE);
    if (!pct->hdpaYears)
        goto Bad;

    pct->hdpaEras = MCGetCalInfoDPA(pct->calid, CAL_SERASTRING);
    if (!pct->hdpaEras)
        goto Bad;

    // There must be at least one era...
    if (!DPA_GetPtrCount(pct->hdpaEras))
        goto Bad;

    // The number of eras must be equal to the number of era names
    if (DPA_GetPtrCount(pct->hdpaEras) != DPA_GetPtrCount(pct->hdpaYears))
        goto Bad;

    // The era dates must be in descending order.
    for (i = 1; i < DPA_GetPtrCount(pct->hdpaYears); i++)
    {
        if (StrToInt(DPA_FastGetPtr(pct->hdpaYears, i)) >
            StrToInt(DPA_FastGetPtr(pct->hdpaYears, i - 1)))
            goto Bad;
    }
    return TRUE;

Bad:
    /*
     *  Something went wrong, so clean up.
     */
    MCFreeCalendarInfo(pct);
    return FALSE;
}


//
// Check to see if this calendar is not supported currently
//
// Return FALSE for Hijri, Hebrew calendars, since these are
// Lunar calndars. This is hack so that this control behaves well when the calendar
// is any of the non-supported till we add this support to this control. [samera]
//
void MCGetCalendarInfo(PCALENDARTYPE pct)
{
    TCHAR tchCalendar[32];
    CALTYPE defCalendar = CAL_GREGORIAN;

    if (GetLocaleInfo(LOCALE_USER_DEFAULT,
                      LOCALE_ICALENDARTYPE,
                      tchCalendar,
                      ARRAYSIZE(tchCalendar)))
    {
        defCalendar = StrToInt(tchCalendar);
    }


    //
    //  Start with a clean slate.  Assume we don't have to do funky
    //  offset stuff (dyrOFfset = 0) or era stuff (hdpaEras = NULL),
    //  and that we don't need to do locale munging (LOCALE_USER_DEFAULT).
    //
    MCFreeCalendarInfo(pct);
    ZeroMemory(pct, sizeof(CALTYPE));
    pct->calid = defCalendar;
    pct->lcid = LOCALE_USER_DEFAULT;

    switch (pct->calid) {
    case CAL_GREGORIAN:
    case CAL_GREGORIAN_US:
    case CAL_GREGORIAN_ME_FRENCH:
    case CAL_GREGORIAN_ARABIC:
    case CAL_GREGORIAN_XLIT_ENGLISH:
    case CAL_GREGORIAN_XLIT_FRENCH:
        break;                          // Gregorian calendars are just fine

    case CAL_JAPAN:
    case CAL_TAIWAN:
        //
        //  These are era calendars.  Go get the era info.  Get hdpaEras
        //  last so we can use it to test whether we have a supported era
        //  calendar.
        //
        // If not enough memory to support traditional calendar, then just
        // force Gregorian.  Hey, at least we display *something*.
        //
        if (!MCGetEraInfo(pct))
            goto ForceGregorian;
        break;

    case CAL_THAI:
        pct->dyrOffset = BUDDHIST_BIAS; // You Just Have To Know this number
        break;

    case CAL_KOREA:
        pct->dyrOffset = KOREAN_BIAS;   // You Just Have To Know this number
        break;

    default:
        //
        // If the calenday isn't supported, then treat it as Gregorian. [samera]
        //
    ForceGregorian:
        pct->calid = CAL_GREGORIAN;
        pct->lcid = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);
        break;
    }

}

//
// Check whether the date string returned accorind to the
// current user-locale and calendar setting is Right-To-Left (RTL),
// and is so the RECTs for month year (@LBUTTONDOWN and NCHITTEST)
// needs to be adjusted. [samera]
//
BOOL MCIsDateStringRTL(TCHAR tch)
{
    WORD wAttrib=0;
    LCID lcidUserDefault;
    BOOL fRTL = FALSE;

    lcidUserDefault = GetUserDefaultLCID();

    if (lcidUserDefault)
    {
        //
        // Return TRUE if the 1st character is a RTL string.
        // A RTL char followed by a european number will
        // display visually as "european-num RTL-string" since the
        // BiDi layout algorithm of the language-pack will do
        // this. [samera]
        //
        if(GetStringTypeEx(lcidUserDefault,
                           CT_CTYPE2,
                           &tch,
                           1,
                           &wAttrib))
        {
            if(C2_RIGHTTOLEFT == wAttrib)
            {
                fRTL = TRUE;
            }

        }
    }

    return fRTL;
}

////////////////////////////////////////////////////////////////////////////
//
// Date/Time Picker
//
////////////////////////////////////////////////////////////////////////////

//
//  Subedit wrapper for the various weird things we need to get from NLS.
//
//  SE_YEARALT means that the year field is only two digits wide
//  in the format string, so we need to perform special Y2K enhancements.
//  For these fields, the field is displayed in two-digit format, but
//  when you go to edit the field, it temporarily changes to four-digit
//  format so you can change the century too.  Then when you complete the
//  edit, it returns to two-digit format.
//
//  The SE_YEARLIKE macro detects either SE_YEAR or SE_YEARALT.
//
//  SE_MONTHALT is just like SE_MONTH except that it is used
//  when the day (dd) comes before the month (mmm).  This is
//  important for languages like Russian where "12 October"
//  and "October 12" use different strings for the word
//  "October".  There is no way to get the alternate string
//  directly, except by creating a bogus date format that also
//  has the day before the month, then throwing away the day.
//
//  For example, if the incoming date string is
//
//      "MMMM dd yyyy"
//
//  we break it up into
//
//      "MMMM"      SE_MONTH
//      " "         SE_STATIC
//      "dd"        SE_DAY
//      " "         SE_STATIC
//      "yyyy"      SE_YEAR
//
//  However, if the incoming date is
//
//      "dd MMMM yyyy"
//
//  we break it up into
//
//      "dd"        SE_DAY
//      " "         SE_STATIC
//      "ddMMMM"    SE_MONTHALT
//      " "         SE_STATIC
//      "yyyy"      SE_YEAR
//
//  The extra "dd" at the beginning of SE_MONTHALT is stripped out below.
//
//  Y2K weirdness:  If we are getting the date format for the year,
//  and the year is being edited (either due to a SUBEDIT_ALL or because
//  it is the active subedit), and the format year is only
//  two digits, then force a four-digit year for editing purposes.
//
//
void SEGetTimeDateFormat(LPSUBEDIT pse, LPSUBEDITCONTROL psec, LPTSTR pszBuf, DWORD cchBuf)
{
    int cch;

    ASSERT(cchBuf >= 2);    // We assume it can hold at least space and a null
    pszBuf[0] = TEXT('\0');             // In case something fails

    if (pse->id == SE_MONTHALT) {
        TCHAR tszBuf[DTP_FORMATLENGTH + 3];
        //
        //  When we parsed the date string and realized that we needed
        //  the Alternate Month format, we created a date format of
        //  the form "ddMMM...", where "MMM..." is the
        //  the original month format.  Here we strip off the digits.
        //
        cch = GetDateFormat(psec->ct.lcid, 0, &psec->st, pse->pv, tszBuf, ARRAYSIZE(tszBuf));
        if (cch >= 2) {
            // [msadek] For Hebrew calander, day format "dd" is actually
            // two OR THREE characters. Don't hardcode it as 2.
            int cchDay = GetDateFormat(psec->ct.lcid, 0, &psec->st, TEXT("dd"), NULL, 0);
            lstrcpyn(pszBuf, tszBuf + cchDay - 1, cchBuf);
        }
    } else if (pse->id == SE_YEARALT &&
               (psec->iseCur == SUBEDIT_ALL || pse == &psec->pse[psec->iseCur])) {
        GetDateFormat(psec->ct.lcid, 0, &psec->st, TEXT("yyyy"), pszBuf, cchBuf);
    } else if (SE_DATELIKE(pse->id)) {
        GetDateFormat(psec->ct.lcid, 0, &psec->st, pse->pv, pszBuf, cchBuf);

        // Change a blank era to a space so the user can see it
        if (pse->id == SE_ERA && pszBuf[0] == TEXT('\0')) {
            pszBuf[0] = TEXT(' ');
            pszBuf[1] = TEXT('\0');
        }

    } else if (pse->id != SE_APP) {
        GetTimeFormat(LOCALE_USER_DEFAULT, 0, &psec->st, pse->pv, pszBuf, cchBuf);
    } else {

        NMDATETIMEFORMAT nmdtf = { 0 };
        nmdtf.pszFormat  = pse->pv;
        SECGetSystemtime(psec, &nmdtf.st);
        nmdtf.pszDisplay = nmdtf.szDisplay;

        CCSendNotify(psec->pci, DTN_FORMAT, &nmdtf.nmhdr);

        lstrcpyn(pszBuf, nmdtf.pszDisplay, cchBuf);

#ifdef UNICODE
        //
        // If the parent is an ANSI window, and pszDisplay
        // does not equal szDisplay, the then thunk had to
        // allocated memory for pszDisplay.  We need to
        // free it here.
        //

        if (!psec->pci->bUnicode && nmdtf.pszDisplay &&
            nmdtf.pszDisplay != nmdtf.szDisplay) {
            LocalFree ((LPSTR)nmdtf.pszDisplay);
        }
#endif
    }
}

//
// SUBEDIT stuff for DateTimePicker
//
// NOTE: Now that the DatePicker and TimePicker are combined,
// this could be moved back into the parent structure.
//

//
//  Used in an era calendar to get the length of the longest era name.
//  Also leaves a random heigth in psize->cy because that's what the
//  non-era code does, too.
//
int SECGetMaxEraLength(PCALENDARTYPE pct, HDC hdc, PSIZE psize)
{
    int i;
    int wid = 0;
    for (i = 0; i < DPA_GetPtrCount(pct->hdpaEras); i++)
    {
        LPCTSTR ptsz = DPA_FastGetPtr(pct->hdpaEras, i);
        if (GetTextExtentPoint32(hdc, ptsz, lstrlen(ptsz), psize) &&
            psize->cx > wid)
        {
            wid = psize->cx;
        }
    }
    return wid;
}


// SECRecomputeSizing needs to calculate the maximum rectangle each subedit can be. Ugh.
//
// The size of the SE_YEARALT field changes depending on whether or not it is
// the current psec->iseCur.  Double ugh.

void SECRecomputeSizing(LPSUBEDITCONTROL psec, LPRECT prc)
{
    HDC       hdc;
    HGDIOBJ   hfontOrig;
    int       i;
    LPSUBEDIT pse;
    int       left = prc->left;

    psec->rc = *prc;

    hdc       = GetDC(psec->pci->hwnd);
    hfontOrig = SelectObject(hdc, (HGDIOBJ)psec->hfont);

    for (i=0, pse=psec->pse; i < psec->cse ; i++, pse++)
    {
        TCHAR   szTmp[DTP_FORMATLENGTH];
        LPCTSTR sz;
        int     min, max;
        SIZE    size;
        int     wid;

        min = pse->min;
        max = pse->max;
        if (pse->id == SE_STATIC)
        {
            ASSERT(pse->fReadOnly);
            sz = pse->pv;
        }
        else
        {
            sz = szTmp;

            // make some assumptions so we don't loop more than we have to
            switch (pse->id)
            {

            // we only need seven for the text days of the week
            case SE_DAY:
                min = 10; // make them all double-digit
                max = 17;
                break;

            // Assume we only have numeric output with all chars same width
            case SE_MARK:
                min = 11;
                max = 12;
                break;

            case SE_HOUR:
            case SE_YEAR:
            case SE_YEARALT:
            case SE_MINUTE:
            case SE_SECOND:
                min = max;
                break;

            case SE_ERA:
                if (ISERACALENDAR(&psec->ct)) {
                    wid = SECGetMaxEraLength(&psec->ct, hdc, &size);
                    goto HaveWidth;
                } else {
                    min = max = *pse->pval; // current value is good enough
                }
                break;
            }
        }

        // now get max width
        if (pse->id == SE_APP)
        {
            NMDATETIMEFORMATQUERY nmdtfq = {0};

            nmdtfq.pszFormat = pse->pv;

            CCSendNotify(psec->pci, DTN_FORMATQUERY, &nmdtfq.nmhdr);

            size = nmdtfq.szMax;
            wid  = nmdtfq.szMax.cx;
        }
        else
        {
            SYSTEMTIME st = psec->st;

            /*
             *  SUBTLE - Munge the month/day to January 1.  This solves
             *  lots of problems, such as "Today is Feb 29 1996, and
             *  when we iterate through year = 1997, we get Feb 29 1997,
             *  which is invalid."   Or "Today is Jan 31 1999, and when
             *  we iterate through the months, we get Sep 31 1999, which
             *  is invalid."
             *
             *  We choose "January 1" because
             *
             *  1. Every year has a "January 1", so the year can vary.
             *  2. Every month has a "first", so the month can vary.
             *  3. Every day up to 31 is valid in January, so the day can vary.
             */
            psec->st.wMonth = psec->st.wDay = 1;

            for (wid = 0 ; min <= max ; min++)
            {
                if (pse->id != SE_STATIC)
                {
                    *pse->pval = (WORD) min;

                    SEGetTimeDateFormat(pse, psec, szTmp, ARRAYSIZE(szTmp));
                    if (szTmp[0] == TEXT('\0'))
                    {
                        DebugMsg(TF_ERROR, TEXT("SECRecomputeSizing: GetDate/TimeFormat([%s] y=%d m=%d d=%d h=%d m=%d s=%d) = ERROR %d"),
                            pse->pv, psec->st.wYear, psec->st.wMonth, psec->st.wDay, psec->st.wHour, psec->st.wMinute, psec->st.wSecond,
                            GetLastError());

                    }
                }
                if (!GetTextExtentPoint32(hdc, sz, lstrlen(sz), &size))
                {
                    size.cx = 0;
                    DebugMsg(TF_MONTHCAL,TEXT("SECRecomputeSizing: GetTextExtentPoint32(%s) = ERROR %d"), sz, GetLastError());
                }
                if (size.cx > wid)
                    wid = size.cx;
            }
            psec->st = st;
        }
HaveWidth:
        // now set up subedit's bounding rectangle
        pse->rc.top    = prc->top + SECYBORDER;
        pse->rc.bottom = pse->rc.top + size.cy;
        pse->rc.left   = left;
        pse->rc.right  = left + wid;
        left = pse->rc.right;
    }

    SelectObject(hdc, hfontOrig);
    ReleaseDC(psec->pci->hwnd, hdc);
}

// InitSubEditControl parses szFormat into psec, setting the time to pst.
TCHAR c_szFormats[] = TEXT("gyMdthHmsX");
BOOL PASCAL SECParseFormat(DATEPICK* pdp, LPSUBEDITCONTROL psec, LPCTSTR szFormat)
{
    LPCTSTR   pFmt;
    LPTSTR    psecFmt;
    int       cse, cchExtra;
    int       nTmp;
    LPSUBEDIT pse;
    BOOL      fDaySeen = FALSE;
    BOOL      fForceCentury = FALSE;
    int       iLen, i;
    TCHAR     tch;
    LPTSTR    pFmtTemp;
    TCHAR szFormatTemp[DTP_FORMATLENGTH];

    //
    //  We need to force the century if the format is
    //  DTS_SHORTDATECENTURYFORMAT.
    //
    if (pdp->fLocale &&
        (pdp->ci.style & DTS_FORMATMASK) == DTS_SHORTDATECENTURYFORMAT)
    {
        fForceCentury = TRUE;
    }

    // [msadek]; If we need to mirror the format and the
    // cleint passed a read only buffer, we will AV (W2k bug# 354533)
    // Let's copy it first

    if (psec->fMirrorSEC)
    {
        lstrcpyn(szFormatTemp, szFormat, ARRAYSIZE(szFormatTemp));
        szFormat = szFormatTemp;
    }

    // count szFormat sections so we know what to allocate
    pFmt = szFormat;
    cse = 0;
    cchExtra = 0;
    while (*pFmt)
    {
        if (StrChr(c_szFormats, *pFmt)) // format string
        {
            TCHAR c = *pFmt;
            while (c == *pFmt)
                pFmt++;
            cse++;

            // If it was a string Month format, reserve 2 more chars for
            // the possible "dd" leader, in case we need SE_MONTHALT.
            if (c == TEXT('M'))
                cchExtra += 2;

        }
        else if (*pFmt == TEXT('\'')) // quoted static string
        {
KeepSearching:
            pFmt++;
            while (*pFmt && *pFmt != TEXT('\''))
                pFmt++;
            if (*pFmt) // handle poorly quoted strings
            {
                pFmt++;
                if (*pFmt == TEXT('\'')) // quoted quote, not end of quote
                    goto KeepSearching;
            }
            cse++;
        }
        else // static string probably a delimiter
        {
            while (*pFmt && *pFmt!=TEXT('\'') && !StrChr(c_szFormats, *pFmt))
                pFmt++;
            cse++;
        }
    }

    // Allocate space
    nTmp = cse + lstrlen(szFormat) + cchExtra + 1; // number of chars
    nTmp = nTmp * sizeof(TCHAR); // size in BYTES
    nTmp = ROUND_TO_POINTER(nTmp); // round up to POINTER boundary
    psecFmt = (LPTSTR)LocalAlloc(LPTR, nTmp + cse * sizeof(SUBEDIT));
    if (!psecFmt)
    {
        DebugMsg(TF_MONTHCAL, TEXT("SECParseFormat failed to allocate memory"));
        return FALSE; // use whatever we already have
    }

    if (psec->szFormat)
        LocalFree(psec->szFormat);

    psec->szFormat   = psecFmt;
    psec->cDelimeter = '\0';
    psec->pse        = (LPSUBEDIT)((LPBYTE)psecFmt + nTmp);

    // Fill psec
    psec->iseCur = SUBEDIT_NONE;
    psec->cse    = cse;
    pse          = psec->pse;
    ZeroMemory(pse, cse * sizeof(SUBEDIT));
    pFmt = szFormat;
    pdp->fHasMark = FALSE;


    //
    // Before start parsing the format string, let's mirror it if requested.
    //
    if (psec->fMirrorSEC)
    {
        pFmtTemp = (LPTSTR)pFmt;
        iLen = lstrlen(pFmtTemp);
        for( i=0 ; i<iLen/2 ; i++ )
        {
            tch = pFmtTemp[i];
            pFmtTemp[i] = pFmtTemp[iLen-i-1];
            pFmtTemp[iLen-i-1] = tch;
        }
    }


    while (*pFmt)
    {
        pse->flDrawText = DT_CENTER;

        if (*pFmt == TEXT('y') || *pFmt == TEXT('g')) // y=year g=era
        {
            TCHAR ch = *pFmt;

            // If the calendar doesn't use eras, then the era field is just
            // for show and can't be changed.
            if (ch == TEXT('g') && !ISERACALENDAR(&psec->ct)) {
                pse->fReadOnly = TRUE;
            }

            pse->id     = ch == TEXT('y') ? SE_YEAR : SE_ERA;
            pse->pval   = &psec->st.wYear;
            pse->min    = c_stEpoch.wYear;
            pse->max    = c_stArmageddon.wYear;
            pse->cchMax = 0;

            pse->pv = psecFmt;
            while (*pFmt == ch) {
                pse->cchMax++;
                *psecFmt++ = *pFmt++;
            }

            if (pse->id == SE_YEAR)
            {
                pse->flDrawText = DT_RIGHT;

                if (fForceCentury)
                {
                    pse->pv = TEXT("yyyy");
                    pse->cchMax = 4;
                }
                else
                {
                    switch (pse->cchMax)
                    {
                    case 1:                 //  "y" is a SE_YEARALT
                    case 2:                 // "yy" is a SE_YEARALT
                        pse->id = SE_YEARALT;
                        pse->cchMax = 4;    // Force four-digit editing
                        break;

                    case 3:                 // "yyy" is an alias for "yyyy".
                        pse->cchMax = 4;
                        break;
                    }
                }
            }

            *psecFmt++ = TEXT('\0');
        }
        else if (*pFmt == TEXT('M')) // month
        {
            pse->pv = psecFmt;

            // If the day has been seen, then we need to use the alternate
            // month format, so set up the gratuitous "dd" prefix.
            // See SEGetTimeDateFormat.
            //
            if (fDaySeen) {
                pse->id = SE_MONTHALT;
                *psecFmt++ = TEXT('d');
                *psecFmt++ = TEXT('d');
            } else {
                pse->id = SE_MONTH;
            }
            pse->pval   = &psec->st.wMonth;
            pse->min    = 1;
            pse->max    = 12;
            pse->cchMax = 2;

            while (*pFmt == TEXT('M'))
                *psecFmt++ = *pFmt++;
            if (psecFmt - pse->pv <= 2)
                pse->flDrawText = DT_RIGHT;
            *psecFmt++ = TEXT('\0');
        }

#if 0 // if we ever do week-of-year format
        else if (*pFmt == TEXT('w')) // week
        {
            // BUGBUG: NLS date functions can modify the displayed YEAR if the displayed WEEK overflows
            // into the next or prior year!
            // BUGBUG: We need to make the week increment move beyond month boundries...
            // In order to do this, we need to add an "overflow" flag so day increments will
            // carry into month increments etc.

            pse->id         = SE_DAY;
            pse->pval       = &psec->st.wDay;
            pse->min        = 1;
            pse->max        = GetDaysForMonth(psec->st.wYear, psec->st.wMonth);
            pse->cIncrement = 7;
            pse->cchMax     = 2;

            pse->pv = psecFmt;
            while (*pFmt == TEXT('w'))
                *psecFmt++ = *pFmt++;
            *psecFmt++ = TEXT('\0');
        }
#endif
        else if (*pFmt == TEXT('d')) // day or day of week
        {
            fDaySeen    = TRUE;     // See SEGetTimeDateFormat
            pse->id     = SE_DAY;
            pse->pval   = &psec->st.wDay;
            pse->min    = 1;
            pse->max    = GetDaysForMonth(psec->st.wYear, psec->st.wMonth);
            pse->cchMax = 2;

            pse->pv = psecFmt;
            while (*pFmt == TEXT('d'))
                *psecFmt++ = *pFmt++;
            if (psecFmt - pse->pv <= 2)
                pse->flDrawText = DT_RIGHT;     // day
            else
                pse->fReadOnly = TRUE;          // day of week
            *psecFmt++ = TEXT('\0');

        }
        else if (*pFmt == TEXT('t')) // marker
        {
            pdp->fHasMark = TRUE;
            pse->id         = SE_MARK;
            pse->pval       = &psec->st.wHour;
            pse->min        = 0;
            pse->max        = 23;
            pse->cIncrement = 12;
            pse->cchMax     = 2;

            pse->pv = psecFmt;
            while (*pFmt == TEXT('t'))
                *psecFmt++ = *pFmt++;
            *psecFmt++ = TEXT('\0');
        }
        else if (*pFmt == TEXT('h')) // (12) hour
        {
            pse->id     = SE_HOUR;
            pse->pval   = &psec->st.wHour;
            pse->min    = 0;
            pse->max    = 23;
            pse->cchMax = 2;
            pse->flDrawText = DT_RIGHT;

            pse->pv = psecFmt;
            while (*pFmt == TEXT('h'))
                *psecFmt++ = *pFmt++;
            *psecFmt++ = TEXT('\0');

        }
        else if (*pFmt == TEXT('H')) // (24) hour
        {
            pse->id     = SE_HOUR;
            pse->pval   = &psec->st.wHour;
            pse->min    = 0;
            pse->max    = 23;
            pse->cchMax = 2;
            pse->flDrawText = DT_RIGHT;

            pse->pv = psecFmt;
            while (*pFmt == TEXT('H'))
                *psecFmt++ = *pFmt++;
            *psecFmt++ = TEXT('\0');
        }
        else if (*pFmt == TEXT('m')) // minute
        {
            pse->id     = SE_MINUTE;
            pse->pval   = &psec->st.wMinute;
            pse->min    = 0;
            pse->max    = 59;
            pse->cchMax = 2;
            pse->flDrawText = DT_RIGHT;

            pse->pv = psecFmt;
            while (*pFmt == TEXT('m'))
                *psecFmt++ = *pFmt++;
            *psecFmt++ = TEXT('\0');
        }
        else if (*pFmt == TEXT('s')) // second
        {
            pse->id     = SE_SECOND;
            pse->pval   = &psec->st.wSecond;
            pse->min    = 0;
            pse->max    = 59;
            pse->cchMax = 2;
            pse->flDrawText = DT_RIGHT;

            pse->pv = psecFmt;
            while (*pFmt == TEXT('s'))
                *psecFmt++ = *pFmt++;
            *psecFmt++ = TEXT('\0');
        }
        else if (*pFmt == TEXT('X')) // app specified field
        {
            pse->id = SE_APP;

            pse->pv = psecFmt;
            while (*pFmt == TEXT('X'))
                *psecFmt++ = *pFmt++;
            *psecFmt++ = TEXT('\0');
        }
        else if (*pFmt == TEXT('\'')) // quoted static string
        {
            pse->id      = SE_STATIC;
            pse->fReadOnly = TRUE;

            pse->pv = psecFmt;
SearchSomeMore:
            pFmt++;
            while (*pFmt && *pFmt != TEXT('\''))
                *psecFmt++ = *pFmt++;
            if (*pFmt) // handle poorly quoted strings
            {
                pFmt++;
                if (*pFmt == TEXT('\'')) // quoted quote, not end of quote
                {
                    *psecFmt++ = *pFmt;
                    goto SearchSomeMore;
                }
            }
            *psecFmt++ = TEXT('\0');
        }
        else // unknown non-editable stuff (most likely a delimeter)
        {
            // BUGBUG: even though it's unknown, we should probably pass
            // it off to GetDateFormat so we will be forward compatible
            // with future date formats...
            //
            pse->id      = SE_STATIC;
            pse->fReadOnly = TRUE;

            if (!psec->cDelimeter)
                psec->cDelimeter = *pFmt;

            pse->pv = psecFmt;
            while (*pFmt && *pFmt!=TEXT('\'') && !StrChr(c_szFormats, *pFmt))
                *psecFmt++ = *pFmt++;
            *psecFmt++ = TEXT('\0');

            // we'll assume that the first not formatting char is the
            // delimeter...maybe not a great assumption, but it will work
            // most of the time.
            //
        }
        pse++;
    }

#ifdef DEBUG
{
    TCHAR sz[200];
    LPTSTR psz;
    psz = sz;
    sz[0]=TEXT('\0');
    pse = psec->pse;
    cse = psec->cse;
    while (cse > 0)
    {
        wsprintf(psz, TEXT("[%s] "), pse->pv);
        psz = psz + lstrlen(psz);
        cse--;
        pse++;
    }
    DebugMsg(TF_MONTHCAL, TEXT("SECParseFormat: %s"), sz);
}
#endif

    //
    // Let restore the original format
    //
    if (psec->fMirrorSEC)
    {
        pFmtTemp = (LPTSTR)szFormat;
        for( i=0 ; i<iLen/2 ; i++ )
        {
            tch = pFmtTemp[i];
            pFmtTemp[i] = pFmtTemp[iLen-i-1];
            pFmtTemp[iLen-i-1] = tch;
        }
    }


    //
    // If this is a time-only DTP control and we need to swap the AM/PM symbol
    // to the other side, then let's do it.
    //
    if (psec->fSwapTimeMarker)
    {
        SUBEDIT se;
        pse = psec->pse;
        cse = psec->cse;

        if ((cse > 1) && (psec->pse[0].id == SE_MARK))
        {
            se = psec->pse[0];
            i = 0;
            while( i < (cse-1) )
            {
                pse[i] = pse[i+1];
                i++;
            }
            pse[psec->cse-1] = se;
        }
    }

    // The subedits have changed, recompute sizes
    SECRecomputeSizing(psec, &psec->rc);

    // We're going to need to redraw this
    InvalidateRect(psec->pci->hwnd, NULL, TRUE);

    // Changing the format also changes the window text.
    MyNotifyWinEvent(EVENT_OBJECT_NAMECHANGE, pdp->ci.hwnd, OBJID_WINDOW, INDEXID_CONTAINER);
    return TRUE;
}

void SECDestroy(LPSUBEDITCONTROL psec)
{
    if (psec->szFormat)
    {
        LocalFree(psec->szFormat);
        psec->szFormat = NULL;
    }
}
void SECSetFont(LPSUBEDITCONTROL psec, HFONT hfont)
{
    if (hfont == NULL)
        hfont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
    psec->hfont = hfont;
}

void InvalidateScrollRect(HWND hwnd, RECT *prc, int xScroll)
{
    RECT rc;

    if (xScroll)
    {
        rc = *prc;
        OffsetRect(&rc, -xScroll, 0);
        prc = &rc;
    }
    InvalidateRect(hwnd, prc, TRUE);
}

void SECSaveResetSubeditEdit(DATEPICK *pdp, BOOL fReset);
#define SECSaveSubeditEdit(pdp) SECSaveResetSubeditEdit(pdp, FALSE)
#define SECResetSubeditEdit(pdp) SECSaveResetSubeditEdit(pdp, TRUE)

// Set the current subedit, scrolling things into view as needed
void SECSetCurSubed(DATEPICK *pdp, int isubed)
{
    LPSUBEDITCONTROL psec = &pdp->sec;

    // validate the arguments
    ASSERT(isubed < psec->cse);

    // if the subedit is changing, we need to invalidate stuff
    if (isubed != psec->iseCur)
    {
        int isePre;
        if (psec->iseCur >= 0)
        {
            SECResetSubeditEdit(pdp);
            InvalidateScrollRect(psec->pci->hwnd, &psec->pse[psec->iseCur].rc, psec->xScroll);
        }

        isePre = psec->iseCur;
        psec->iseCur = isubed;
        // For perf reasons, do a full recompute only if SE_YEARALT or
        // SUBEDIT_ALL was involved, since those are the only cases
        // where SE_YEARALT fields change size.

        #define YearAffected(psec, ise)                             \
                (ise == SUBEDIT_ALL ||                              \
                 (ise >= 0 && psec->pse[ise].id == SE_YEARALT))

        if (YearAffected(psec, isePre) || YearAffected(psec, isubed))
        {
            SECRecomputeSizing(psec, &psec->rc);
            InvalidateRect(psec->pci->hwnd, NULL, TRUE);
        }
        #undef YearAffected

        if (psec->iseCur >= 0)
        {
            RECT rc = psec->pse[psec->iseCur].rc;
            OffsetRect(&rc, -psec->xScroll, 0);
            if (rc.left < psec->rc.left)
            {
                psec->xScroll += rc.left - psec->rc.left;
                InvalidateRect(psec->pci->hwnd, NULL, TRUE);
            }
            else if (rc.right > psec->rc.right)
            {
                psec->xScroll += rc.right - psec->rc.right;
                InvalidateRect(psec->pci->hwnd, NULL, TRUE);
            }
            else
            {
                InvalidateRect(psec->pci->hwnd, &rc, TRUE);
            }
        }
    }
}

int SECIncrFocus(DATEPICK *pdp, int delta)
{
    int ise, loop;
    LPSUBEDITCONTROL psec = &pdp->sec;

    ASSERT(-1 == delta || 1 == delta);

    ise = psec->iseCur;
    if (ise < 0 && delta < 0)
        ise = psec->cse;

    for (loop = 0 ; loop < psec->cse ; loop++)
    {
        int oldise = ise;
        ise = (ise + delta + psec->cse) % psec->cse;
        if (ise != oldise+delta && psec->fNone)
        {
            // we wrapped and we allow scrolling into SUBEDIT_NONE state
            break;
        }
        if (!psec->pse[ise].fReadOnly)
        {
            goto Found;
        }
    }
    ise = SUBEDIT_NONE;
Found:
    SECSetCurSubed(pdp, ise);
    return ise;
}

void SECInvalidate(LPSUBEDITCONTROL psec, int id);

//
//  Given a Gregorian year, get the local name for that year.
//
UINT SECGetYearValue(DATEPICK *pdp, UINT uYear)
{
    UINT uiRc = 0;
    TCHAR rgch[64];
    if (EVAL(MCGetDateFormatWithTempYear(&pdp->sec.ct, &pdp->sec.st, TEXT("yyyy"), uYear, rgch, ARRAYSIZE(rgch)))) {
        uiRc = StrToInt(rgch);
    }
    return uiRc;
}

//
//  SECAdjustByEra
//
//  pct - PCALENDARTYPE structure to use for conversion
//
//  uInput - the value the user typed (to be interpreted as local calendar)
//
//  The basic idea is that if you type a year, it is interpreted relative
//  to the era you were in previously.  If the number you typed isn't valid
//  for that era, then reject it (by returning the original year unchanged).
//
UINT SECAdjustByEra(DATEPICK *pdp, UINT uInput)
{
    UINT uResult = pdp->sec.st.wYear;

    //
    //  Find the delta between the current local year and the current
    //  Gregorian year.  We don't use any of the era transition dates
    //  since they aren't reliable at the boundaries.  Just convert it
    //  to a display name and re-parse it back.
    //
    UINT uDelta = pdp->sec.st.wYear - SECGetYearValue(pdp, pdp->sec.st.wYear);

    //
    //  Apply that delta to the year the user typed in.  This converts the
    //  local year into a Gregorian year.
    //
    UINT uNewVal = uInput + uDelta;

    // uNewVal is the value we want to change it to.  If it's valid for that
    // era, then use it.  We detect that it's okay for the era by converting
    // it to a display name and seeing if it matches.  It can fail for being
    // too large (past the end of the era) or too small (trying to change to
    // January 1 local year 1 when the era didn't change until March).

    if (SECGetYearValue(pdp, uNewVal) == uInput) {
        uResult = uNewVal;
    }

    return uResult;
}

//
//  SECAdjustByType
//
//  Some field types are special.
//
//  SE_YEAR or SE_YEARALT if user typed only two digits
//
//      Use the "implied century for two-digit years" logic
//      as described in NT5_GetCalendarInfoA.
//
//  SE_YEAR or SE_YEARALT if user typed more than two digits
//
//      Use that number.
//
//  BONUS FEATURE!
//
//      Some calendars run parallel to the Gregorian year,
//      but with different years.  Use GregorianToOther and
//      OtherToGregorian to convert.
//
//      The input value is the local year (Gregorian, Buddhist, whatever)
//      but the return value is always the Gregorian year, since that's
//      what SYSTEMTIME uses.
//
//  SE_HOUR
//
//      If the clock is in 12-hour format, then preserve AM/PM ness of
//      the hour.  For example, if it was 3pm and somebody is changing
//      the hour to 4, use 4pm instead of 4am.
//
UINT SECAdjustByType(DATEPICK *pdp, LPSUBEDIT psubed, UINT uNewValue)
{

    if (SE_YEARLIKE(psubed->id))
    {
        if (uNewValue < 100)
        {
            // Get the preferred century of the preferred calendar
            // (in the localized year, not Gregorian.)
            DWORD dwMax2DigitYear;
            if (!NT5_GetCalendarInfoA(pdp->sec.ct.lcid, pdp->sec.ct.calid, CAL_RETURN_NUMBER + CAL_ITWODIGITYEARMAX,
                                     NULL, 0, &dwMax2DigitYear))
            {
                // default in the absence of all information
                dwMax2DigitYear = GregorianToOther(&pdp->sec.ct, 2029);

                // if the current year in this era is less than 100, then the 2 digits typed
                // may be the real date, so set the max to 99 (i.e., no conversion)
                //
                if (dwMax2DigitYear < 99)
                    dwMax2DigitYear = 99;
            }

            //
            //  Copy the century of dwMax2DigitYear into uNewValue.
            //
            uNewValue += (dwMax2DigitYear - dwMax2DigitYear % 100);
            //
            //  If it exceeds the max, then drop to previous century.
            //
            if (uNewValue > dwMax2DigitYear)
                uNewValue -= 100;

        }

        //
        //  Finally, convert back to Gregorian as necessary.
        //
        uNewValue = OtherToGregorian(&pdp->sec.ct, uNewValue);

        //
        //  If we are in an Era calendar, then we need to adjust the
        //  year relative to the ambient era.
        //
        if (ISERACALENDAR(&pdp->sec.ct)) {
            uNewValue = SECAdjustByEra(pdp, uNewValue);
        }

    } else if (psubed->id == SE_HOUR && psubed->pv[0] == TEXT('h')) {
        if (*psubed->pval >= 12 && uNewValue < 12)
            uNewValue += 12;
    }

    return uNewValue;
}


void SECSetSubeditValue(DATEPICK *pdp, LPSUBEDIT psubed, UINT uNewValue, BOOL fForce)
{
    LPSUBEDITCONTROL psec = &pdp->sec;
    UINT uOldValue;

    uNewValue = SECAdjustByType(pdp, psubed, uNewValue);

    //
    //  Must do a full-on range check in addition to the simple psubed->min
    //  psubed->max range check because the new value might be valid
    //  for our range but not in the global scheme of things.  For example,
    //  the minimum date is Sep 14 1752, but if today is Jan 1 1995 and
    //  the user types "1752", that will pass the simple min/max year test,
    //  but it's not a valid date since Jan 1 1752 is out of range.
    //

    uOldValue = *psubed->pval;
    *psubed->pval = (WORD)uNewValue;
    if (uNewValue >= psubed->min && uNewValue <= psubed->max &&
        CmpSystemtime(&pdp->sec.st, &pdp->stMin) >= 0 &&
        CmpSystemtime(&pdp->sec.st, &pdp->stMax) <= 0)
    {
        if (fForce || uNewValue != uOldValue)
        {
            SECInvalidate(psec, SE_APP);
            InvalidateScrollRect(psec->pci->hwnd, &psubed->rc, psec->xScroll);

            DPNotifyDateChange(pdp);
        }
    }
    else
    {
        // Oops, not valid, put the old value back
        *psubed->pval = (WORD)uOldValue;
    }
}

// This saves the current pending value and also resets the edit state
// if fReset is TRUE
void SECSaveResetSubeditEdit(DATEPICK *pdp, BOOL fReset)
{
    LPSUBEDITCONTROL psec = &pdp->sec;

    if (psec->iseCur >= 0)
    {
        LPSUBEDIT psubed = &psec->pse[psec->iseCur];

        if (psubed->cchEdit)
        {
            SECSetSubeditValue(pdp, psubed, psubed->valEdit, FALSE);
        }
        if (fReset)
            psubed->cchEdit = 0;
    }
}

// SECInvalidate invalidates the display for each subedit affected by a change
// to ID.  NOTE: as a side affect, it recalculates MAX fields for all subedits
// affected by a change to ID.
//
// SE_APP invalidates everything, anything invalidates SE_APP
// SE_MARK (am/pm) invalidate SE_HOUR, SE_HOUR invalides SE_MARK
//
void SECInvalidate(LPSUBEDITCONTROL psec, int id)
{
    BOOL fAdjustDayMax = (id == SE_MONTH || id == SE_MONTHALT || id == SE_YEAR || id == SE_YEARALT || id == SE_APP || id == SE_ERA);
    LPSUBEDIT pse;
    int i;

    // If we changed any date field and we are in a era-like calendar,
    // then invalidate all, since changing the month, day or year may
    // change the era or vice versa.
    if (ISERACALENDAR(&psec->ct) && SE_DATELIKE(id))
    {
        id = SE_APP;
    }

    for (pse=psec->pse, i=0 ; i < psec->cse ; pse++, i++)
    {
        // we need to invalidate all fields that changed
        if (id == pse->id || pse->id == SE_APP || id == SE_APP || (id == SE_MARK && pse->id == SE_HOUR) || (id == SE_HOUR && pse->id == SE_MARK))
        {
            InvalidateScrollRect(psec->pci->hwnd, &pse->rc, psec->xScroll);
        }

        // the month or year changed, fix max field for SE_DAY
        if (fAdjustDayMax && pse->id == SE_DAY)
        {
            pse->max = GetDaysForMonth(psec->st.wYear, psec->st.wMonth);
            if (*pse->pval > pse->max)
            {
                *pse->pval = (WORD) pse->max;
            }
            SECInvalidate(psec, SE_DAY);
        }
    }
}

__inline
BOOL
SECGetEraName(LPSUBEDITCONTROL psec, LPSUBEDIT pse, UINT uYear, LPTSTR ptszBuf, UINT cchBuf)
{
    return MCGetDateFormatWithTempYear(&psec->ct, &psec->st, pse->pv, uYear, ptszBuf, cchBuf);
}

//
//  SECIncrementEra increments/decrements the era field.  ERAs are strange
//  since they aren't a field unto themselves but are rather an artifact
//  of the other fields.  Returns the new year to use.
//
UINT SECIncrementEra(LPSUBEDITCONTROL psec, LPSUBEDIT pse, int delta)
{
    TCHAR rgch[64];
    TCHAR rgch2[64];
    int i;
    int cEras = DPA_GetPtrCount(psec->ct.hdpaEras);

    UINT uNewYear;

    ASSERT(pse->pval == &psec->st.wYear);
    uNewYear = psec->st.wYear;

    //
    //  First find the era that encloses the current year.
    //  Do this by comparing the era string, because it's possible
    //  for the era to change twice within the same calendar year
    //  (if an emperor ascends to the throne and then dies the next week)
    //  so comparing against hdpaYear won't help.
    //
    SECGetEraName(psec, pse, uNewYear, rgch, ARRAYSIZE(rgch));

    //
    //  If the era string is blank, it means we're in the "before the
    //  first era" scenario, so we use the "virtual" last element that
    //  represents "minus infinity".
    //
    if (rgch[0] == TEXT('\0'))
    {
        i = cEras;
        goto FoundEra;
    }

    for (i = 0; i < cEras; i++)
    {
        if (lstrcmp(rgch, DPA_FastGetPtr(psec->ct.hdpaEras, i)) == 0)
            goto FoundEra;
    }

    //
    //  Eek!  Couldn't find the era!  Just increment/decrement the
    //  year instead.
    //
    uNewYear += delta;
    goto Finish;

FoundEra:

    //
    //  The era list is stored backwards, so incrementing the era means
    //  decrementing the index (i).
    //

    if (delta > 0) // Incrementing
    {
        //
        //  Don't go off the end of the list.  Note that if we were in
        //  the "virtual era" at minus infinity, this decrement will move
        //  us into the first "real" era.
        //
        if (--i < 0)
            goto Finish;

        //   Increment to first year of the next era.
        uNewYear = StrToInt(DPA_FastGetPtr(psec->ct.hdpaYears, i));
    }
    else
    {
        //
        //  Don't go off the end of the list.  Note that this also
        //  catches the "virtual era" at minus infinity.
        //
        if (i >= cEras)
            goto Finish;

        //
        //  Move to the last year of the previous era.  Do this by
        //  starting with the first year of the current era and
        //  decrementing it if necessary.
        //
        uNewYear = StrToInt(DPA_FastGetPtr(psec->ct.hdpaYears, i));
    }

    //
    //  We have a year that might be in the next/prev era.  Try it.
    //  If we're still in the original era, then inc/dec one more time
    //  to get there for good.
    //
    SECGetEraName(psec, pse, uNewYear, rgch2, ARRAYSIZE(rgch2));
    if (lstrcmp(rgch, rgch2) == 0)
        uNewYear += delta;

Finish:
    if (uNewYear < pse->min)
        uNewYear = pse->min;
    if (uNewYear > pse->max)
        uNewYear = pse->max;
    return uNewYear;
}

// SECIncrementSubedit increments currently selected subedit by delta
// Returns TRUE iff the value changed
BOOL SECIncrementSubedit(LPSUBEDITCONTROL psec, int delta)
{
    LPSUBEDIT psubed;
    UINT val;

    if (psec->iseCur < 0)
        return(FALSE);

    psubed = &psec->pse[psec->iseCur];

    if (psubed->id == SE_APP)
        return(FALSE);

    //
    //  Only numeric fields should accelerate.  Text fields should always
    //  increment/decrement by exactly one position.
    //
    if (psubed->flDrawText & DT_CENTER) {
        if (delta < 0) delta = -1;
        if (delta > 0) delta = +1;
    }

    //
    //  Incrementing/decrementing ERAs is strange.
    //
    if (psubed->id == SE_ERA)
    {
        val = SECIncrementEra(psec, psubed, delta);
    }
    else
    {
        // delta isn't a REAL delta -- it's a directional thing. Here's the REAL delta:
        if (psubed->cIncrement > 0)
            delta = delta * psubed->cIncrement;
        if(!psubed->pval)
            return (FALSE);

        val = *psubed->pval + delta;
        while (1) {
            if ((int)val < (int)psubed->min)
            {
                // don't wrap years
                if (SE_YEARLIKE(psubed->id)) {
                    val = psubed->min;
                    break;
                }
                val = psubed->min - val - 1;
                val = psubed->max - val;
            }
            else if (val > psubed->max)
            {
                // don't wrap years
                if (SE_YEARLIKE(psubed->id)) {
                    val = psubed->max;
                    break;
                }
                val = val - psubed->max - 1;
                val = psubed->min + val;
            } else
                break;
        }
    }

    if (*psubed->pval != val)
    {
        *psubed->pval = (WORD) val;

        SECInvalidate(psec, psubed->id);
        return(TRUE);
    }

    return(FALSE);
}

// returns TRUE if a value has changed, FALSE otherwise
BOOL SECHandleKeydown(DATEPICK *pdp, WPARAM wParam, LPARAM lParam)
{
    int delta = 1;
    LPSUBEDITCONTROL psec = &pdp->sec;

    switch (wParam)
    {
    case VK_LEFT:
        delta = -1;
        // fall through...
    case VK_RIGHT:
        SECResetSubeditEdit(pdp);
        SECIncrFocus(pdp, delta);
        return(FALSE);
    }

    if (psec->iseCur >= 0 &&
        psec->pse[psec->iseCur].id == SE_APP)
    {
        NMDATETIMEWMKEYDOWN nmdtkd = {0};

        nmdtkd.nVirtKey  = (int) wParam;
        nmdtkd.pszFormat = psec->pse[psec->iseCur].pv;
        SECGetSystemtime(psec,&nmdtkd.st);

        CCSendNotify(psec->pci, DTN_WMKEYDOWN, &nmdtkd.nmhdr);

        if (psec->st.wYear   != nmdtkd.st.wYear   ||
            psec->st.wMonth  != nmdtkd.st.wMonth  ||
            psec->st.wDay    != nmdtkd.st.wDay    ||
            psec->st.wHour   != nmdtkd.st.wHour   ||
            psec->st.wMinute != nmdtkd.st.wMinute ||
            psec->st.wSecond != nmdtkd.st.wSecond) // skip wDayOfWeek and wMilliseconds
        {
            psec->st = nmdtkd.st;
            SECInvalidate(psec, SE_APP);
            return(TRUE);
        }
    }
    else
    {
        MSG msg;
        switch (wParam)
        {
        case VK_DOWN:
        case VK_SUBTRACT:
            delta = -1;
            // fall through...
        case VK_UP:
        case VK_ADD:
            PeekMessage(&msg, NULL, WM_CHAR, WM_CHAR, PM_REMOVE);  // eat this message
            SECResetSubeditEdit(pdp);
            return(SECIncrementSubedit(psec, delta));
            break;

        case VK_HOME:
        case VK_END:
            if (psec->iseCur >= 0)
            {
                LPSUBEDIT psubed;
                int valT;

                SECResetSubeditEdit(pdp);

                psubed = &psec->pse[psec->iseCur];
                valT = *psubed->pval;
                *psubed->pval = (wParam == VK_HOME ? psubed->min : psubed->max);
                delta = *psubed->pval - valT;
                if (delta != 0)
                {
                    SECInvalidate(psec, psubed->id);
                    return(TRUE);
                }
            }
            break;
        }
    }

    return(FALSE);
}

// returns TRUE if a value has changed, FALSE otherwise
// This function performs a DPNotifyDateChange() if applicable.
BOOL SECHandleChar(DATEPICK *pdp, TCHAR ch)
{
    LPSUBEDIT psubed;
    UINT uCurDigit;             // current digit hit
    UINT uCurSubValue;          // current displayed subvalue in edit field
    UINT uCurValue;             // current value of the subedit
    LPSUBEDITCONTROL psec = &pdp->sec;

    // NOTE: In almost all cases, uCurSubValue will be the same as uCurValue
    // since most fields don't have shortened displays.  However, for years
    // we can display two digits of a 4 digit number, which makes for
    // complications.

    if (psec->iseCur < 0)
        return(FALSE);

    psubed = &psec->pse[psec->iseCur];

    if (psubed->cchMax == 0)
        return(FALSE);

    if (ch == psec->cDelimeter || StrChr(psec->szDelimeters, ch))
    {
        SECResetSubeditEdit(pdp);
        SECIncrFocus(pdp, 1);
        return(FALSE);
    }

    // allow 'a' and 'p' to set the AM/PM fields.  we need to do some
    // funky stuff to get this to work right, so here it is.
    else if (psubed->id == SE_MARK)
    {
        if ((ch == TEXT('p') || ch == TEXT('P')) && (*psubed->pval < 12))
        {
            int valNew = *psubed->pval+12;

            ch = (valNew) % 10 + TEXT('0');
            psubed->valEdit = (valNew) / 10;
            psubed->cchEdit = 1;
        }
        else if ((ch == TEXT('a') || ch == TEXT('A')) && (*psubed->pval >= 12))
        {
            int valNew = *psubed->pval-12;
            ch = (valNew) % 10 + TEXT('0');
            psubed->valEdit = (valNew) / 10;
            psubed->cchEdit = 1;
        }
        else
        {
            return(FALSE);
        }
    }
    else if (ch < TEXT('0') || ch > TEXT('9'))
    {
        MessageBeep(MB_ICONHAND);
        return(FALSE);
    }
    else if (psubed->id == SE_ERA)
    {
        // I don't know what to do with this field, so bail out
        return(FALSE);
    }

    uCurDigit = ch - TEXT('0');
    if (psubed->cchEdit)
        uCurSubValue = psubed->valEdit * 10 + uCurDigit;
    else
        uCurSubValue = uCurDigit;

    uCurValue = SECAdjustByType(pdp, psubed, uCurSubValue);

    // Allow bogus values for years since you might need to type
    // in a bogus value on the way to a valid four-digit value.

    if (uCurValue > psubed->max && !SE_YEARLIKE(psubed->id))
    {
        // the number has exceeded the max, so no point in continuing
        psubed->cchEdit = 0;

        // If we're going to exceed the max, then reset the edit
        // and make this the first number instead of beeping

        uCurValue    = uCurValue - uCurSubValue + uCurDigit;
        uCurSubValue = uCurDigit;
    }

    // Allow 0 to be valEdit for subedits, even though it may be
    // illegal for that field (e.g., month).
    // This lets people type "09" and get the "expected" result.

    SECInvalidate(psec, psubed->id);

    psubed->valEdit = uCurSubValue;
    psubed->cchEdit++;
    if (psubed->cchEdit == psubed->cchMax)
        psubed->cchEdit = 0;

    if (psubed->cchEdit == 0)
    {
        // SECSetSubeditValue will do the validation
        SECSetSubeditValue(pdp, psubed, uCurSubValue, TRUE);
        return(TRUE);
    }

    if(psubed->valEdit != *psubed->pval)
        InvalidateRect(pdp->ci.hwnd, NULL, TRUE);
    return(FALSE);
}

// SECFormatSubed returns pointer to correct string
LPTSTR SECFormatSubed(LPSUBEDITCONTROL psec, LPSUBEDIT psubed, LPTSTR szTmp, UINT cch)
{
    LPTSTR sz;

    if (psubed->id == SE_STATIC)
    {
        sz = (LPTSTR)psubed->pv;
    }
    else
    {
        sz = szTmp;
        SEGetTimeDateFormat(psubed, psec, szTmp, cch);
    }

    return sz;
}

//  Returns TRUE if this subedit displays as digits (rather than text).

BOOL SECIsNumeric(LPSUBEDIT psubed)
{
    switch (psubed->id)
    {
    case SE_ERA:        return FALSE;           // g never
    case SE_YEAR:       return TRUE;            // yyyy always digits
    case SE_YEARALT:    return TRUE;            // yy always digits
    case SE_MONTH:      return lstrlen(psubed->pv) <= 2; // MM yes, but not MMM
    case SE_MONTHALT:   return lstrlen(psubed->pv) <= 4; // ddMM yes, but not ddMMM
    case SE_DAY:        return TRUE;            // dd always digits
    case SE_MARK:       return FALSE;           // tt never
    case SE_HOUR:       return TRUE;            // hh always digits
    case SE_MINUTE:     return TRUE;            // mm always digits
    case SE_SECOND:     return TRUE;            // ss always digits
    case SE_STATIC:     return FALSE;           // static text
    case SE_APP:        return FALSE;           // app's job to format this
    }
    return FALSE;
}

// SECDrawSubedits draws subedits and updates their bounding rectangles
void SECDrawSubedits(HDC hdc, LPSUBEDITCONTROL psec, BOOL fFocus, BOOL fEnabled)
{
    HGDIOBJ hfontOrig;
    int i, iseCur;
    LPTSTR sz;
    TCHAR szTmp[DTP_FORMATLENGTH];
    LPSUBEDIT psubed;

    hfontOrig = SelectObject(hdc, (HGDIOBJ)psec->hfont);

    // Do this cuz the xScroll stuff can send text into visible area that it shouldn't be in
    IntersectClipRect(hdc, psec->rc.left, psec->rc.top, psec->rc.right, psec->rc.bottom);

    SetBkColor(hdc, g_clrHighlight);

    iseCur = psec->iseCur;
    if (!fFocus)
        iseCur = SUBEDIT_NONE;

    for (i = 0, psubed = psec->pse; i < psec->cse; i++, psubed++)
    {
        RECT rc = psubed->rc;
        if (psec->xScroll)
            OffsetRect(&rc, -psec->xScroll, 0);

        if (!fEnabled)
        {
            SetBkMode(hdc, TRANSPARENT);
            SetTextColor(hdc, g_clrGrayText);
        }
        else if (iseCur == i)
        {
            SetBkMode(hdc, OPAQUE);
            SetTextColor(hdc, g_clrHighlightText);
        }
        else
        {
            SetBkMode(hdc, TRANSPARENT);
            SetTextColor(hdc, g_clrWindowText);
        }

        //HACK
        //if subedit control is being edited then we display the
        //value in psubed->valEdit because it is not being updated
        //until psubed->cchMax is reached or SECSave/ResetSubeditEdit is
        //called
        if(i == psec->iseCur && psubed->cchEdit != 0)
        {
            //
            //  If the field is numeric, then display it raw including the
            //  leading zero.  People really want to see that leading zero,
            //  so give the public what it wants.  (And even if they didn't,
            //  we need this special case anyway because the value might not
            //  yet be a valid value because the user is still typing it.
            //  This is particular true for SE_YEARLIKE fields.)
            //
            if (SECIsNumeric(psubed))
            {
                TCHAR szFormat[10];
                wsprintf(szFormat, TEXT("%%0%dd"), psubed->cchEdit);
                wsprintf(szTmp, szFormat, psubed->valEdit);
                sz = szTmp;
            }
            else
            {
                // The day-of-month might not be valid for the temporary month
                // or year in psubed->valEdit, so force the day-of-month to 1
                // so the month will always come out okay.
                //
                // This is tricky, because if the item being edited is the
                // day-of-month itself, we want to display valEdit, not 1!
                // So we force it to 1, then slam in the valEdit, then do
                // our SECFormatSubed, then restore the original values.
                //
                UINT uTmp = *psubed->pval; //save the original value
                WORD wOldDay = psec->st.wDay;
                psec->st.wDay = 1;
                // Don't change to zero in case user is typing a leading zero
                // into an alphabetic field.  (Stranger things have happened.)
                if (psubed->valEdit)
                    *psubed->pval = (WORD) psubed->valEdit;
                sz = SECFormatSubed(psec, psubed, szTmp, ARRAYSIZE(szTmp));
                psec->st.wDay = wOldDay;
                *psubed->pval = (WORD) uTmp; //restore the original value
            }
        }
        else
            sz = SECFormatSubed(psec, psubed, szTmp, ARRAYSIZE(szTmp));

        DrawText(hdc, sz, -1, &rc,
                 psubed->flDrawText | DT_TOP | DT_NOPREFIX | DT_SINGLELINE);
    }

    // we know no clip region was selected before this function
    SelectClipRgn(hdc, NULL);

    SelectObject(hdc, hfontOrig);
}

// DON'T need to worry about xScroll here because pt is offset
int SECSubeditFromPt(LPSUBEDITCONTROL psec, POINT pt)
{
    int isubed;

    for (isubed = psec->cse - 1; isubed >= 0; isubed--)
    {
        if (!psec->pse[isubed].fReadOnly &&
            pt.x >= psec->pse[isubed].rc.left)
        {
            break;
        }
    }

    return(isubed);
}

void SECGetSystemtime(LPSUBEDITCONTROL psec, LPSYSTEMTIME pst)
{
    *pst = psec->st;

    // we don't keep doy up to date, set it now (0==sun, 6==sat)
    pst->wDayOfWeek = (DowFromDate(pst)+1) % 7;  // this returns 0==sun
}

BOOL SECSetSystemtime(DATEPICK *pdp, LPSYSTEMTIME pst)
{
    pdp->sec.st = *pst;

    return TRUE; // assume something changed
}

// SECEdit: Start a free-format edit return result in szOutput.
BOOL SECEdit(DATEPICK *pdp, LPTSTR szOutput, int cchOutput)
{
    HWND      hwndEdit;
    TCHAR     szBuf[DTP_FORMATLENGTH];
    LPTSTR    pszBuf;
    int       cchBuf;
    int       i;
    int       isePrev;
    LPSUBEDIT pse;
    BOOL      fRet = FALSE;
    LPSUBEDITCONTROL psec = &pdp->sec;

    // Build the string that we hand to the app.
    // For the duration of the string build, set the current subedit
    // to SUBEDIT_ALL so that
    //  1. partial edits are applied before building the string, and
    //  2. SE_YEARALT can format appropriately.

    isePrev = psec->iseCur;
    SECSetCurSubed(pdp, SUBEDIT_ALL);
    pszBuf = szBuf;
    cchBuf = ARRAYSIZE(szBuf);


    //
    // Need to mirror the format since the Edit control will take
    // of the origianl format with RTL mirroring.
    //
    if (psec->fMirrorSEC)
        pse = (psec->pse + (psec->cse - 1));
    else
        pse = psec->pse;

    for (i = 0 ; i < psec->cse ; i++)
    {
        int nTmp;

        if (pse->id == SE_STATIC)
        {
            lstrcpyn(pszBuf, pse->pv, cchBuf);
        }
        else
        {
            SEGetTimeDateFormat(pse, psec, pszBuf, cchBuf);
        }

        nTmp = lstrlen(pszBuf);

        cchBuf -= nTmp;
        pszBuf += nTmp;

        //
        // If this control is mirrored, then read contents backward.
        //
        if (psec->fMirrorSEC)
            pse--;
        else
            pse++;
    }
    SECSetCurSubed(pdp, isePrev);

    hwndEdit = CreateWindowEx(0, TEXT("EDIT"), szBuf, WS_CHILD | ES_AUTOHSCROLL,
            psec->rc.left + 2, psec->rc.top + 2,
            psec->rc.right - psec->rc.left,
            psec->rc.bottom - psec->rc.top,
            psec->pci->hwnd, NULL, HINST_THISDLL, NULL);

    if (hwndEdit)
    {
        RECT rcEdit = psec->rc;

        MapWindowRect(psec->pci->hwnd, NULL, &rcEdit); // ClientToScreen
        pdp->fFreeEditing = TRUE;
        InvalidateRect(psec->pci->hwnd, NULL, TRUE);

        Edit_LimitText(hwndEdit, ARRAYSIZE(szBuf) - 1);
        FORWARD_WM_SETFONT(hwndEdit, psec->hfont, FALSE, SendMessage);
        SetFocus(hwndEdit);
        RescrollEditWindow(hwndEdit);
        ShowWindow(hwndEdit, SW_SHOWNORMAL);

        //
        //  The basic idea:
        //
        //      Process messages until we receive a cancel message,
        //      or an accept message, or some implicit accept-like
        //      thing happens (namely, a sent WM_KILLFOCUS).
        //
        //      If the accept or cancel was implicit, then leave the
        //      cancelling message in the queue for somebody else
        //      to process.  Otherwise, if the accept/cancel was
        //      explicit, eat the message so nobody else gets
        //      confused by it.
        //
        for (;;)
        {
            MSG msg;
            BOOL fPeek;

            fPeek = PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);

            // That PeekMessage may have dispatched a sent WM_KILLFOCUS,
            // in which case the change is considered to have been Accepted.
            // Leave the message we peeked in the queue because the accept
            // was implicit.
            if (GetFocus() != hwndEdit)
            {
                DebugMsg(TF_MONTHCAL, TEXT("SECEdit accept (killfocus)"));
                fRet = TRUE;
                break;

            }

            if (fPeek) {

                //
                //  Messages that cause us to cancel implicitly.
                //  These messages stay in the queue.
                //

                if (msg.message == WM_SYSCOMMAND  ||
                    msg.message == WM_SYSCHAR     ||
                    msg.message == WM_SYSDEADCHAR ||
                    msg.message == WM_DEADCHAR    ||
                    msg.message == WM_SYSKEYDOWN  ||
                    msg.message == WM_QUIT) {
                    DebugMsg(TF_MONTHCAL, TEXT("SECEdit got a message to terminate (%d)"), msg.message);
                    fRet = FALSE;
                    break;
                }

                //
                //  Messages that cause us to accept implicitly.
                //  These messages stay in the queue.
                //
                if ((msg.message == WM_LBUTTONDOWN   ||
                     msg.message == WM_NCLBUTTONDOWN ||
                     msg.message == WM_RBUTTONDOWN   ||
                     msg.message == WM_NCRBUTTONDOWN ||
                     msg.message == WM_LBUTTONDBLCLK) &&
                     !PtInRect(&rcEdit, msg.pt))
                {
                    DebugMsg(TF_MONTHCAL, TEXT("SECEdit got a message to accept (%d)"), msg.message);
                    fRet = TRUE;
                    break;
                }


                // We are now committed to eating or processing the message

                GetMessage(&msg, NULL, 0, 0);

                //
                //  Messages that cause us to cancel explicitly.
                //
                if (msg.message == WM_KEYDOWN && msg.wParam  == VK_ESCAPE)
                {
                    DebugMsg(TF_MONTHCAL, TEXT("SECEdit explicit cancel (%d)"), msg.message);
                    fRet = FALSE;
                    break;

                }

                //
                //  Messages that cause us to accept explicitly.
                //
                if (msg.message == WM_KEYDOWN && msg.wParam  == VK_RETURN)
                {
                    DebugMsg(TF_MONTHCAL, TEXT("SECEdit explicit accept (%d)"), msg.message);
                    fRet = TRUE;
                    break;
                }

                //
                //  All other messages just get dispatched.
                //
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            } else {
                WaitMessage();
            }
        } // for (;;)

        if (fRet)
        {
            Edit_GetText(hwndEdit, szOutput, cchOutput);
        }
        DestroyWindow(hwndEdit);
        pdp->fFreeEditing = FALSE;
        InvalidateRect(psec->pci->hwnd, NULL, TRUE);
    }

    return(fRet);
}

//
// returns true if months were scrolled, false otherwise
//
BOOL FScrollIntoView(MONTHCAL *pmc)
{
    int nDelta = 0;
    SYSTEMTIME stEnd;

    if (MonthCal_IsMultiSelect(pmc))
        CopyDate(pmc->stEndSel, stEnd);
    else
        CopyDate(pmc->st, stEnd);

    //
    // If the month/yr for the new date is not in view, bring it
    // into view
    //
    if ((stEnd.wYear < pmc->stMonthFirst.wYear) ||
        ((stEnd.wYear == pmc->stMonthFirst.wYear) && (stEnd.wMonth < pmc->stMonthFirst.wMonth)))
    {
        nDelta = - (pmc->stMonthFirst.wYear - (int)stEnd.wYear) * 12 - (pmc->stMonthFirst.wMonth - (int)stEnd.wMonth);
    }
    else if ((pmc->st.wYear > pmc->stMonthLast.wYear) ||
        ((pmc->st.wYear == pmc->stMonthLast.wYear) && (pmc->st.wMonth > pmc->stMonthLast.wMonth)))
    {
        nDelta = ((int)pmc->st.wYear - pmc->stMonthLast.wYear) * 12 + ((int)pmc->st.wMonth - pmc->stMonthLast.wMonth);
    }

    if (nDelta)
        return FIncrStartMonth(pmc, nDelta, TRUE /* dont change day */);
    else
        return FALSE;
}

//
//  Validates the isubed to make sure we aren't setting it to something
//  bogus.  If necessary, we pick a field at random.
//
void SECSafeSetCurSubed(DATEPICK *pdp, int ise)
{
    if (ise >= pdp->sec.cse ||
        (ise >= 0 && pdp->sec.pse[ise].fReadOnly))
    {
        SECSetCurSubed(pdp, SUBEDIT_NONE);
        SECIncrFocus(pdp, 1);
    }
    else
        SECSetCurSubed(pdp, ise);
}

LRESULT DTM_OnSetFormat(DATEPICK *pdp, LPCTSTR szFormat)
{

    // remember the field that has focus so we can restore it later
    //
    int iseCur = pdp->sec.iseCur;

    if (!szFormat || !*szFormat)
    {
        pdp->fLocale = TRUE;
        DPHandleLocaleChange(pdp);
    }
    else
    {
        pdp->fLocale = FALSE;
        SECParseFormat(pdp, &pdp->sec, szFormat);
    }

    // restore focus. it might be cool to do extra validation
    // to see if iseCur is the same type that it used to be,
    // maybe even validating that cse is constant. the case we're
    // really trying to fix is changing "1st" to "2nd" to "3rd",
    // so only a text portion is really changing...
    //
    SECSafeSetCurSubed(pdp, iseCur);

    return((LRESULT)TRUE);
}

//
// DATEPICKER stuff
//

LRESULT CALLBACK DatePickWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    DATEPICK *pdp;
    NMHDR    nmhdr;
    LRESULT  lres = 0;

    if (message == WM_NCCREATE)
        return(DPNcCreateHandler(hwnd));

    pdp = DatePick_GetPtr(hwnd);
    if (pdp == NULL)
        return(DefWindowProc(hwnd, message, wParam, lParam));

    // Dispatch the various messages we can receive
    switch (message)
    {
    case WM_CREATE:
        CCCreateWindow();
        lres = DPCreateHandler(pdp, hwnd, (LPCREATESTRUCT)lParam);
        break;

    case WM_ERASEBKGND:
        if (!pdp->fEnabled) {
            RECT rc;
            HDC hdc = (HDC)wParam;

            GetClipBox(hdc, &rc);
            FillRectClr(hdc, &rc, g_clrBtnFace);

        } else
            goto DoDefault;
        break;

    case WM_PRINTCLIENT:
    case WM_PAINT:

    {
        PAINTSTRUCT ps;
        HDC hdc;

        hdc = (HDC)wParam;

        if (hdc) {
            DPPaint(pdp, hdc);
        } else {

            hwnd = pdp->ci.hwnd;
            hdc = BeginPaint(hwnd, &ps);
            DPPaint(pdp, hdc);
            EndPaint(hwnd, &ps);
        }
        break;
    }

    case WM_LBUTTONDOWN:
        DPLButtonDown(pdp, wParam, lParam);
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code)
        {
        case MCN_SELCHANGE:
        case MCN_SELECT:
        {
            LPNMSELECT pnms = (LPNMSELECT)lParam;

            DebugMsg(TF_MONTHCAL,TEXT("MonthCal notified DateTimePick of SELECT"));
            if (!DPSetDate(pdp, &pnms->stSelStart, TRUE))
            {
                DebugMsg(DM_WARNING,TEXT("MonthCal cannot set selected date!"));
                MessageBeep(MB_ICONHAND);
            }
            pdp->fShow = (((LPNMHDR)lParam)->code == MCN_SELCHANGE);
            break;
        }

        case UDN_DELTAPOS:
            if ((int)wParam == DATEPICK_UPDOWN)
            {
                LPNM_UPDOWN pnmdp = (LPNM_UPDOWN)lParam;

                if (!pdp->fFocus)
                    SetFocus(pdp->ci.hwnd);

                SECResetSubeditEdit(pdp);

                if (SECIncrementSubedit(&pdp->sec, -pnmdp->iDelta))
                    DPNotifyDateChange(pdp);
            }
            break;
        } // WM_NOTIFY switch
        break;

    case WM_GETFONT:
        lres = (LRESULT)pdp->sec.hfont;
        break;

    case WM_SETFONT:
        DPHandleSetFont(pdp, (HFONT)wParam, (BOOL)LOWORD(lParam));
        break;

    case WM_DESTROY:
        CCDestroyWindow();
        DPDestroyHandler(hwnd, pdp, wParam, lParam);
        break;

    case WM_KILLFOCUS:
    case WM_SETFOCUS:
    {
        BOOL fGotFocus = (message == WM_SETFOCUS);
        if (BOOLIFY(fGotFocus) != BOOLIFY(pdp->fFocus))
        {
            pdp->fFocus = (WORD) fGotFocus;
            if (pdp->sec.iseCur >= 0)
            {
                InvalidateScrollRect(pdp->ci.hwnd, &pdp->sec.pse[pdp->sec.iseCur].rc, pdp->sec.xScroll);
            }
            else if (DatePick_ShowCheck(pdp))
            {
                pdp->fCheckFocus = (WORD) fGotFocus;
                InvalidateRect(pdp->ci.hwnd, &pdp->rcCheck, TRUE);
            }
            else if (fGotFocus) // nothing has focus, bring it to something
            {
                SECIncrFocus(pdp, 1);
            }

            CCSendNotify(&pdp->ci, (fGotFocus ? NM_SETFOCUS : NM_KILLFOCUS), &nmhdr);
        }

        if (fGotFocus)
        {
            // Revalidate iseLastActive because the app might've changed
            // the format while we were nonfocus
            SECSafeSetCurSubed(pdp, pdp->iseLastActive);
        }
        else
        {
            pdp->iseLastActive = pdp->sec.iseCur;
            SECSetCurSubed(pdp, SUBEDIT_NONE);
        }

        break;
    }

    case WM_ENABLE:
    {
        BOOL fEnabled = wParam ? TRUE:FALSE;
        if (BOOLIFY(pdp->fEnabled) != fEnabled)
        {
            pdp->fEnabled = (WORD) fEnabled;
            if (pdp->hwndUD)
                EnableWindow(pdp->hwndUD, fEnabled);
            InvalidateRect(pdp->ci.hwnd, NULL, TRUE);
        }
        break;
    }

    case DTMP_WINDOWPOSCHANGED:
    case WM_SIZE:
    {
        RECT rc;

        if (message == DTMP_WINDOWPOSCHANGED)
        {
            GetClientRect(pdp->ci.hwnd, &rc);
        }
        else
        {
            rc.left   = 0;
            rc.top    = 0;
            rc.right  = GET_X_LPARAM(lParam);
            rc.bottom = GET_Y_LPARAM(lParam);
        }

        DPRecomputeSizing(pdp, &rc);

        InvalidateRect(pdp->ci.hwnd, NULL, TRUE);
        UpdateWindow(pdp->ci.hwnd);
        break;
    }

    case WM_GETDLGCODE:
        lres = DLGC_WANTARROWS | DLGC_WANTCHARS;
        break;

    case WM_KEYDOWN:
        if (pdp->fShow)
        {
            SendMessage(pdp->hwndMC, WM_KEYDOWN, wParam, lParam);
            return 0;
        }
        else
        {
            lres = DPHandleKeydown(pdp, wParam, lParam);
        }
        break;

    case WM_KEYUP:
        if (pdp->fShow)
            SendMessage(pdp->hwndMC, WM_KEYUP, wParam, lParam);
        break;

    case WM_SYSKEYDOWN:
        if (wParam == VK_DOWN && !pdp->fUseUpDown)
        {
            DPLBD_MonthCal(pdp, FALSE);
        }
        else
            goto DoDefault;
        break;

    case WM_CHAR:
        lres = DPHandleChar(pdp, wParam, lParam);
        break;

    case WM_SYSCOLORCHANGE:
        InitGlobalColors();
        // Don't need to propagate to pdp->hwndMC because it is its own
        // top-level window.
        break;

    case WM_WININICHANGE:
        if (lParam == 0 ||
#ifdef UNICODE_WIN9x
            !lstrcmpiA((LPSTR)lParam, "Intl")
#else
            !lstrcmpi((LPTSTR)lParam, TEXT("Intl"))
#endif
           )
        {
            DPHandleLocaleChange(pdp);
        }
        // Don't need to propagate to pdp->hwndMC because it is its own
        // top-level window.
        break;

    case WM_NOTIFYFORMAT:
        return CIHandleNotifyFormat(&pdp->ci, lParam);
        break;

    // Cannot use WM_SETTEXT to change the text of a DTP
    case WM_SETTEXT:
        return -1;

    case WM_GETTEXT:
        if (!lParam || !wParam) {
            // previously this just failed and returned 0
            // in bogus input.  should be safe to convert to
            // gettextlength
            message = WM_GETTEXTLENGTH;
        } else
            (*(LPTSTR)lParam) = 0;

        // fall through

    case WM_GETTEXTLENGTH:
    {
        TCHAR     szTmp[DTP_FORMATLENGTH];
        LPSUBEDIT psubed;
        int       i;
#ifdef UNICODE_WIN9x
        char *pszText = (char *)lParam;
#else
        TCHAR *pszText = (TCHAR *)lParam;
#endif
        UINT      nTextLen = 0;

        for (i = 0, psubed = pdp->sec.pse; i < pdp->sec.cse; i++, psubed++)
        {
            LPTSTR sz;
            UINT nLen;

            sz = SECFormatSubed(&pdp->sec, psubed, szTmp, ARRAYSIZE(szTmp));
            nLen = lstrlen(sz);

            if (message == WM_GETTEXT) {
                if (nTextLen + nLen >= wParam)
                    break;

#ifdef UNICODE_WIN9x
                // safe to pass wparam because we calculated above that it was ok
                ConvertWToAN(CP_ACP, pszText, wParam, sz, -1);
#else
                lstrcpy(pszText, sz);
#endif
                pszText  += nLen;
            }

            nTextLen += nLen;
        }
        lres = nTextLen;
    }
    break;

    case WM_STYLECHANGING:
        lres = DPOnStyleChanging(pdp, (UINT) wParam, (LPSTYLESTRUCT)lParam);
        break;

    case WM_STYLECHANGED:
        lres = DPOnStyleChanged(pdp, (UINT) wParam, (LPSTYLESTRUCT)lParam);
        break;

    case WM_CONTEXTMENU:
        if (pdp->hwndMC)
            lres = SendMessage(pdp->hwndMC, message, wParam, lParam);
        else
            goto DoDefault;
        break;


    //
    // DATETIMEPICK specific messages
    //

    // DTM_GETSYSTEMTIME wParam=void lParam=LPSYSTEMTIME
    //   returns GDT_NONE if no date selected (DTS_SHOWNONE only)
    //   returns GDT_VALID and modifies *lParam to be the selected date
    case DTM_GETSYSTEMTIME:
        if (!pdp->fCheck)
        {
            lres = GDT_NONE;
        }
        else
        {
            // If there is an edit pending, save it so the app sees
            // the absolute latest values.  This is important for app
            // compat, because IE4 wasn't Y2K compliant and people got
            // away with typing just two digits of the year and hitting
            // ENTER.  The "Find Files" dialog would then ask us for the
            // year, and in the Y2K case, we are still waiting for the
            // other two digits (for a four-digit year) and return the
            // wrong year.
            SECSaveSubeditEdit(pdp);
            SECGetSystemtime(&pdp->sec, (SYSTEMTIME *)lParam);
            lres = GDT_VALID;
        }
        break;

    // DTM_SETSYSTEMTIME wParam=GDT_flag lParam=LPSYSTEMTIME
    //   if wParam==GDT_NONE, sets datepick to None (DTS_SHOWNONE only)
    //   if wParam==GDT_VALID, sets datepick to *lParam
    //   returns TRUE on success, FALSE on error (such as bad params)
    case DTM_SETSYSTEMTIME:
    {
        LPSYSTEMTIME pst = ((LPSYSTEMTIME)lParam);

        if ((wParam != GDT_NONE  && wParam != GDT_VALID)      ||
            (wParam == GDT_NONE  && !DatePick_ShowCheck(pdp)) ||
            (wParam == GDT_VALID && !IsValidSystemtime(pst)))
        {
            break;
        }

        // reset subed in place edit
        SECResetSubeditEdit(pdp);

        pdp->fNoNotify = TRUE;
        if (DatePick_ShowCheck(pdp))
        {
            if ((wParam == GDT_NONE) || (pdp->fCheck))
            {
                // let checkbox have focus
                SECSetCurSubed(pdp, SUBEDIT_NONE);
                pdp->fCheckFocus = 1;
            }

            pdp->fCheck = (wParam == GDT_NONE ? 0 : 1);
            InvalidateRect(pdp->ci.hwnd, NULL, TRUE);
        }
        if (wParam == GDT_VALID)
        {
            pdp->fNoNotify = TRUE;
            DPSetDate(pdp, pst, FALSE);
            pdp->fNoNotify = FALSE;
        }
        lres = TRUE;
        pdp->fNoNotify = FALSE;

        break;
    }

    // DTM_GETRANGE wParam=void lParam=LPSYSTEMTIME[2]
    //   modifies *lParam to be the minimum ALLOWABLE systemtime (or 0 if no minimum)
    //   modifies *(lParam+1) to be the maximum ALLOWABLE systemtime (or 0 if no maximum)
    //   returns GDTR_MIN|GDTR_MAX if there is a minimum|maximum limit
    case DTM_GETRANGE:
    {
        LPSYSTEMTIME pst = (LPSYSTEMTIME)lParam;

        ZeroMemory(pst, 2 * sizeof(SYSTEMTIME));
        lres = pdp->gdtr;
        if (lres & GDTR_MIN)
            pst[0] = pdp->stMin;
        if (lres & GDTR_MAX)
            pst[1] = pdp->stMax;
        break;
    }

    // DTM_SETRANGE wParam=GDR_flags lParam=LPSYSTEMTIME[2]
    //   if GDTR_MIN, sets the minimum ALLOWABLE systemtime to *lParam, otherwise removes minimum
    //   if GDTR_MAX, sets the maximum ALLOWABLE systemtime to *(lParam+1), otherwise removes maximum
    //   returns TRUE on success, FALSE on error (such as invalid parameters)
    case DTM_SETRANGE:
    {
        LPSYSTEMTIME pst = (LPSYSTEMTIME)lParam;
        const SYSTEMTIME *pstMin = (wParam & GDTR_MIN) ? pst+0 : &c_stEpoch;
        const SYSTEMTIME *pstMax = (wParam & GDTR_MAX) ? pst+1 : &c_stArmageddon;

        if (!IsValidDate(pstMin) || !IsValidDate(pstMax))
        {
            break;
        }

        // Save the flags so we can tell the app if it asks.
        // We personally don't care.
        pdp->gdtr = (UINT)wParam & (GDTR_MIN | GDTR_MAX);

        if (CmpDate(&pdp->stMin, &pdp->stMax) <= 0)
        {
            pdp->stMin = *pstMin;
            pdp->stMax = *pstMax;
        }
        else
        {
            pdp->stMin = *pstMax;
            pdp->stMax = *pstMin;
        }

        // we might now have an invalid date, if so, try to set the current
        // date and munge it to a max or min value if out of range.
        pdp->fNoNotify = TRUE;
        DPSetDate(pdp, &pdp->sec.st, TRUE);
        pdp->fNoNotify = FALSE;
        lres = TRUE;
        break;
    }

#ifdef UNICODE
    // DTM_SETFORMAT wParam=void lParam=LPCTSTR
    //   Sets the formatting string to a copy of lParam.
    case DTM_SETFORMATA:
    {
        LPCSTR pszFormat = (LPCSTR)lParam;
        LPWSTR pwszFormat = NULL;

        if (pszFormat && *pszFormat)
        {
            pwszFormat = ProduceWFromA(pdp->ci.uiCodePage, pszFormat);
        }

        lres = DTM_OnSetFormat(pdp, pwszFormat);

        if (pwszFormat)
        {
            FreeProducedString(pwszFormat);
        }
        break;
    }
#endif

    // DTM_SETFORMAT wParam=void lParam=LPCTSTR
    //   Sets the formatting string to a copy of lParam.
    case DTM_SETFORMAT:
    {
        lres = DTM_OnSetFormat(pdp, (LPCTSTR)lParam);
        break;
    }

    case DTM_SETMCCOLOR:
        if (wParam < MCSC_COLORCOUNT)
        {
            COLORREF clr = pdp->clr[wParam];
            pdp->clr[wParam] = (COLORREF)lParam;
            if (pdp->hwndMC)
                SendMessage(pdp->hwndMC, MCM_SETCOLOR, wParam, lParam);
            return clr;
        }
        return -1;

    case DTM_GETMCCOLOR:
        if (wParam < MCSC_COLORCOUNT)
            return pdp->clr[wParam];
        return -1;

    case DTM_GETMONTHCAL:
        return (LRESULT)(UINT_PTR)pdp->hwndMC;

    // wParam -- HFONT, LOWORD(lParam) -- fRedraw
    case DTM_SETMCFONT:
        pdp->hfontMC = (HFONT)wParam;
        if (pdp->hwndMC)
            SendMessage(pdp->hwndMC, WM_SETFONT, wParam, lParam);
        break;

    // returns the font
    case DTM_GETMCFONT:
        return (LRESULT)pdp->hfontMC;
        break;

    default:
        if (CCWndProc(&pdp->ci, message, wParam, lParam, &lres))
            return lres;

DoDefault:
        lres = DefWindowProc(hwnd, message, wParam, lParam);
        break;
    } /* switch (message) */

    return(lres);
}

LRESULT DPNcCreateHandler(HWND hwnd)
{
    DATEPICK *pdp;

    // Sink the datepick -- we may only want to do this if WS_BORDER is set
    SetWindowBits(hwnd, GWL_EXSTYLE, WS_EX_CLIENTEDGE, WS_EX_CLIENTEDGE);

    // Allocate storage for the dtpick structure
    pdp = (DATEPICK *)NearAlloc(sizeof(DATEPICK));
    if (pdp)
        DatePick_SetPtr(hwnd, pdp);

    return((LRESULT)pdp);
}

void DPDestroyHandler(HWND hwnd, DATEPICK *pdp, WPARAM wParam, LPARAM lParam)
{
    if (pdp)
    {
        SECDestroy(&pdp->sec);
        MCFreeCalendarInfo(&pdp->sec.ct);
        GlobalFreePtr(pdp);
    }

    DatePick_SetPtr(hwnd, NULL);
}

// set any locale-dependent values
#define DTS_TIMEFORMATONLY (DTS_TIMEFORMAT & ~DTS_UPDOWN) // remove the UPDOWN bit for testing

LRESULT DPCreateHandler(DATEPICK *pdp, HWND hwnd, LPCREATESTRUCT lpcs)
{
    HFONT      hfont;
    SYSTEMTIME st;
    LCID       lcid;

    // Initialize our data.
    CIInitialize(&pdp->ci, hwnd, lpcs);

    if (pdp->ci.style & DTS_INVALIDBITS)
        return(-1);

    if (pdp->ci.style & DTS_UPDOWN)
    {
        pdp->fUseUpDown = TRUE;
        pdp->hwndUD = CreateWindow(UPDOWN_CLASS, NULL,
            WS_CHILD | WS_VISIBLE | (pdp->ci.style & WS_DISABLED),
            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, hwnd,
            (HMENU)DATEPICK_UPDOWN, HINST_THISDLL, NULL);
    }
    if (DatePick_ShowCheck(pdp))
    {
        pdp->sec.fNone = TRUE; // ugly: this SEC stuff should be merged back into DATEPICK
        pdp->iseLastActive = SUBEDIT_NONE;
    }

    pdp->fEnabled = !(pdp->ci.style & WS_DISABLED);
    pdp->fCheck   = TRUE; // start checked

    // Default minimum date is the epoch
    pdp->stMin = c_stEpoch;

    // Default maximum date is armageddon
    pdp->stMax = c_stArmageddon;

    pdp->gdtr = GDTR_MIN;           // We marked MIN as set in IE4, go figure

    //
    // See if the date/time picker supports this calendar. [samera]
    //
    MCGetCalendarInfo(&pdp->sec.ct);

    //
    // If the DTP is RTL mirrored and it's a Time-Only field, then
    // we need to mirror format string so that it's displayed correctly
    // on a RTL mirrored window. In case of Arabic, we need to swap the
    // Time-Marker to the other side (visual left) so that it looks ok.
    // For the hebrew, we need to swap the field (whether it's date or time)
    // bacause unlike Arabic, it doesn't have its own digit so it reads
    // from LeftToRight. [samera]
    //
    lcid = GetUserDefaultLCID();
    pdp->sec.fMirrorSEC = pdp->sec.fSwapTimeMarker = FALSE;
    if (IS_WINDOW_RTL_MIRRORED(hwnd))
    {
        if (pdp->ci.style & DTS_TIMEFORMATONLY)
        {
            pdp->sec.fMirrorSEC = TRUE;

            if ((PRIMARYLANGID(LANGIDFROMLCID(lcid))) == LANG_ARABIC)
                pdp->sec.fSwapTimeMarker = TRUE;
        }
        else if((PRIMARYLANGID(LANGIDFROMLCID(lcid))) == LANG_HEBREW)
        {
            pdp->sec.fMirrorSEC = TRUE;
        }
    }


    // initialize SUBEDITCONTROL
    pdp->sec.pci = &pdp->ci;
    GetLocalTime(&st);
    SECSetSystemtime(pdp, &st);
    SECSetFont(&pdp->sec, NULL);
    pdp->fLocale = TRUE;
    DPHandleLocaleChange(pdp);
    MCLoadString(IDS_DELIMETERS, pdp->sec.szDelimeters, ARRAYSIZE(pdp->sec.szDelimeters));


    hfont = NULL;
    if (lpcs->hwndParent)
        hfont = (HFONT)SendMessage(lpcs->hwndParent, WM_GETFONT, 0, 0);
    DPHandleSetFont(pdp, hfont, FALSE);

    // initialize the colors
    MCInitColorArray(pdp->clr);
    return(0);
}

LRESULT DPOnStyleChanging(DATEPICK *pdp, UINT gwl, LPSTYLESTRUCT pinfo)
{
    if (gwl == GWL_STYLE)
    {
        DWORD changeFlags = pdp->ci.style ^ pinfo->styleNew;

        // Don't allow these bits to change
        changeFlags &= DTS_UPDOWN | DTS_SHOWNONE | DTS_INVALIDBITS;

        pinfo->styleNew ^= changeFlags;
    }

    return(0);
}

LRESULT DPOnStyleChanged(DATEPICK *pdp, UINT gwl, LPSTYLESTRUCT pinfo)
{
    if (gwl == GWL_STYLE)
    {
        DWORD changeFlags = pdp->ci.style ^ pinfo->styleNew;

        ASSERT(!(changeFlags & (DTS_UPDOWN|DTS_SHOWNONE)));

        pdp->ci.style = pinfo->styleNew;

        if (changeFlags & (DTS_SHORTDATEFORMAT|DTS_LONGDATEFORMAT|DTS_TIMEFORMAT|DTS_INVALIDBITS))
        {
            DPHandleLocaleChange(pdp);
        }

        if (changeFlags & (WS_BORDER | WS_CAPTION | WS_THICKFRAME)) {
            // the changing of these bits affect the size of the window
            // but not until after this message is handled
            // so post ourself a message.
            PostMessage(pdp->ci.hwnd, DTMP_WINDOWPOSCHANGED, 0, 0);
        }

    }

    return(0);
}


void DPHandleLocaleChange(DATEPICK *pdp)
{
    //
    // See if the date/time picker supports this new calendar, and refresh
    // era names as appropriate.
    //
    MCGetCalendarInfo(&pdp->sec.ct);

    if (pdp->fLocale)
    {
        TCHAR szFormat[DTP_FORMATLENGTH];

        switch (pdp->ci.style & DTS_FORMATMASK)
        {
        case DTS_TIMEFORMATONLY:
            GetLocaleInfo(pdp->sec.ct.lcid, LOCALE_STIMEFORMAT, szFormat, ARRAYSIZE(szFormat));
            break;

        case DTS_LONGDATEFORMAT:
            GetLocaleInfo(pdp->sec.ct.lcid, LOCALE_SLONGDATE, szFormat, ARRAYSIZE(szFormat));
            break;

        case DTS_SHORTDATEFORMAT:
        case DTS_SHORTDATECENTURYFORMAT:
            GetLocaleInfo(pdp->sec.ct.lcid, LOCALE_SSHORTDATE, szFormat, ARRAYSIZE(szFormat));
            break;
        }
        SECParseFormat(pdp, &pdp->sec, szFormat);
    }
}

void DPHandleSetFont(DATEPICK *pdp, HFONT hfont, BOOL fRedraw)
{
    SECSetFont(&pdp->sec, hfont);
    SECRecomputeSizing(&pdp->sec, &pdp->rc);
    pdp->ci.uiCodePage = GetCodePageForFont(hfont);

    if (fRedraw)
    {
        InvalidateRect(pdp->ci.hwnd, NULL, TRUE);
        UpdateWindow(pdp->ci.hwnd);
    }
}

void DPPaint(DATEPICK *pdp, HDC hdc)
{
    if (DatePick_ShowCheck(pdp))
    {
        if (RectVisible(hdc, &pdp->rcCheck))
        {
            RECT rc;
            UINT dfcs;
            rc = pdp->rcCheck;
            if (pdp->fCheckFocus)
                DrawFocusRect(hdc, &rc);

            InflateRect(&rc, -1 , -1);
            dfcs = DFCS_BUTTONCHECK;
            if (pdp->fCheck)
                dfcs |= DFCS_CHECKED;
            if (!pdp->fEnabled)
                dfcs |= DFCS_INACTIVE;
            DrawFrameControl(hdc, &rc, DFC_BUTTON, dfcs);
        }
    }

    if (!pdp->fFreeEditing)
        SECDrawSubedits(hdc, &pdp->sec, pdp->fFocus, pdp->fCheck ? pdp->fEnabled : FALSE);

    if (!pdp->fUseUpDown && RectVisible(hdc, &pdp->rcBtn))
        DPDrawDropdownButton(pdp, hdc, FALSE);
}

void _RecomputeMonthCalRect(DATEPICK *pdp, LPRECT prcCal, LPRECT prcCalT )
{
    RECT rcCal  = *prcCal;
    RECT rcCalT = *prcCalT;
    RECT rcWorkArea;
    MONITORINFO mi = {0};
    HMONITOR hMonitor;

    if (DatePick_RightAlign(pdp))
    {
        rcCal.left = rcCal.right - (rcCalT.right - rcCalT.left);
    }
    else
    {
        rcCal.right = rcCal.left + (rcCalT.right - rcCalT.left);
    }
    rcCal.bottom = rcCal.top + (rcCalT.bottom - rcCalT.top);

    // Get the information about the most appropriate monitor.
    // (This includes both the work area and the monitor size.
    hMonitor = MonitorFromRect(&rcCal, MONITOR_DEFAULTTONEAREST);
    mi.cbSize = sizeof(mi);
    GetMonitorInfo(hMonitor, &mi);

    // we need to know where to fit this rectangle into
    if (GetWindowLong(pdp->ci.hwnd, GWL_EXSTYLE) & WS_EX_TOPMOST)
    {
        // if we're topmost, our limits are the screen limits (not the working area)
        rcWorkArea = mi.rcMonitor;
    }
    else
    {
        // otherwise it's the limits of the workarea
        rcWorkArea = mi.rcWork;
    }

    // slide left if off the right side of area
    if (rcCal.right > rcWorkArea.right)
    {
        int nTmp = rcCal.right - rcWorkArea.right;
        rcCal.left  -= nTmp;
        rcCal.right -= nTmp;
    }

    // slide right if off the left side of area
    if (rcCal.left < rcWorkArea.left)
    {
        int nTmp = rcWorkArea.left - rcCal.left;
        rcCal.left  += nTmp;
        rcCal.right += nTmp;
    }

    // move to top of control if off the bottom side of area
    if (rcCal.bottom > rcWorkArea.bottom)
    {
        RECT rcT = pdp->rc;
        int nTmp = rcCal.bottom - rcCal.top;

        MapWindowRect(pdp->ci.hwnd, NULL, (LPPOINT)&rcT); // 2 ClientToScreen

        rcCal.bottom = rcT.top;
        rcCal.top    = rcCal.bottom - nTmp;
    }

    *prcCal = rcCal;
}

void DPLBD_MonthCal(DATEPICK *pdp, BOOL fLButtonDown)
{
    HDC  hdc;
    HWND hwndMC;
    RECT rcT, rcCalT;
    RECT rcBtn, rcCal;
    BOOL fBtnDown;      // Is the button drawn DOWN or UP
    BOOL fBtnActive;    // Is the button still active
    SYSTEMTIME st;
    SYSTEMTIME stOld;
    DWORD dwWidth;

    hdc = GetDC(pdp->ci.hwnd);

    // turn datetimepick on but remove all focus -- the MonthCal will have focus
    if (!pdp->fCheck)
    {
        pdp->fCheck = TRUE;
        InvalidateRect(pdp->ci.hwnd, NULL, TRUE);
        DPNotifyDateChange(pdp);
    }
    if (pdp->fCheckFocus)
    {
        pdp->fCheckFocus = FALSE;
        InvalidateRect(pdp->ci.hwnd, &pdp->rcCheck, TRUE);
    }
    SECSetCurSubed(pdp, SUBEDIT_NONE);

    if (fLButtonDown)
        DPDrawDropdownButton(pdp, hdc, TRUE);

    rcT = pdp->rc;
    MapWindowRect(pdp->ci.hwnd, NULL, &rcT); //2 ClientToScreen

    rcBtn = pdp->rcBtn;
    MapWindowRect(pdp->ci.hwnd, NULL, &rcBtn); //ClientToScreen

    rcCal = rcT;                       // this size is only temp until
    rcCal.top    = rcCal.bottom + 1;   // we ask the monthcal how big it
    rcCal.bottom = rcCal.top + 1;      // wants to be

    hwndMC = CreateWindow(g_rgchMCName, NULL, WS_POPUP | WS_BORDER,
                    rcCal.left, rcCal.top,
                    rcCal.right - rcCal.left, rcCal.bottom - rcCal.top,
                    pdp->ci.hwnd, NULL, HINST_THISDLL, NULL);
    if (hwndMC == NULL)
    {
        // BUGBUG: we are left with the button drawn DOWN
        DebugMsg(DM_WARNING, TEXT("DPLBD_MonthCal could not create MONTHCAL"));
        return;
    }

    pdp->hwndMC = hwndMC;

    // set all the colors:
    {
        int i;
        for (i = 0; i < MCSC_COLORCOUNT; i++)
        {
            SendMessage(hwndMC, MCM_SETCOLOR, i, pdp->clr[i]);
        }
    }

    if (pdp->hfontMC)
        SendMessage(hwndMC, WM_SETFONT, (WPARAM)pdp->hfontMC, (LPARAM)FALSE);

    // set min/max dates
    // Relies on HACK! that stMin and stMax are adjacent
    MonthCal_SetRange(hwndMC, GDTR_MIN | GDTR_MAX, &pdp->stMin);

    SendMessage(hwndMC, MCM_GETMINREQRECT, 0, (LPARAM)&rcCalT);
    ASSERT(rcCalT.left == 0 && rcCalT.top == 0);
    dwWidth = (DWORD)SendMessage(hwndMC, MCM_GETMAXTODAYWIDTH, 0, 0);
    if (dwWidth > (DWORD)rcCalT.right)
        rcCalT.right = dwWidth;

    SECGetSystemtime(&pdp->sec, &st);
    SendMessage(hwndMC, MCM_SETCURSEL, 0, (LPARAM)&st);

    _RecomputeMonthCalRect(pdp, &rcCal, &rcCalT);
    MoveWindow(hwndMC, rcCal.left, rcCal.top,
        rcCal.right - rcCal.left, rcCal.bottom - rcCal.top, FALSE);

    CCSendNotify(&pdp->ci, DTN_DROPDOWN, NULL);

    //
    // HACK-- App may have resized the window during DTN_DROPDOWN,
    // so we need to get the new rcCal rect
    //
    {
        MONTHCAL *pmc = MonthCal_GetPtr(hwndMC);
        _RecomputeMonthCalRect(pdp, &rcCal, &pmc->rc);
        MoveWindow(hwndMC, rcCal.left, rcCal.top,
            rcCal.right - rcCal.left, rcCal.bottom - rcCal.top, FALSE);

#ifdef DEBUG
        if (GetAsyncKeyState(VK_CONTROL) < 0)
            (pmc)->ci.style |= MCS_MULTISELECT;
#endif
    }

    ShowWindow(hwndMC, SW_SHOWNA);

    pdp->fShow = TRUE;
    fBtnDown   = fLButtonDown;
    fBtnActive = fLButtonDown;

    stOld = pdp->sec.st;

    while (pdp->fShow)
    {
        MSG msg;

        pdp->fShow = (WORD) GetMessage(&msg, NULL, 0, 0);

        // Here's how button controls work as far as I can tell:
        // Until the "final button draw up", the button draws down when the
        // mouse is over it and it draws up when the mouse is not over it. This
        // entire time, the control is active.
        //
        // The "final button draw up" occurs at the first opportunity of:
        // the user releases the mouse button OR the user moves into the rect
        // of the control.  The control does it's action on a "mouse up".

        if (fBtnActive)
        {
            switch (msg.message) {
            case WM_MOUSEMOVE:
                if (PtInRect(&rcBtn, msg.pt))
                {
                    if (!fBtnDown)
                    {
                        DPDrawDropdownButton(pdp, hdc, TRUE);
                        fBtnDown = TRUE;
                    }
                }
                else
                {
                    if (fBtnDown)
                    {
                        DPDrawDropdownButton(pdp, hdc, FALSE);
                        fBtnDown = FALSE;
                    }
                    if (PtInRect(&rcCal, msg.pt))
                    {
                        fBtnActive = FALSE;
                        // let MonthCal think it got a button down
                        // IEUNIX: dumb compiler doesn't do well with comments in macros.
                        FORWARD_WM_LBUTTONDOWN(hwndMC, FALSE,
                            rcCal.left/2 + rcCal.right/2,
                            rcCal.top/2 + rcCal.bottom/2,
                            0, SendMessage);
                    }
                }
                continue; // the MonthCal doesn't need this message

            case WM_LBUTTONUP:
                if (fBtnDown)
                {
                    DPDrawDropdownButton(pdp, hdc, FALSE);
                    fBtnDown = FALSE;
                }
                fBtnActive = FALSE;
                continue; // the MonthCal doesn't need this message
            }
        } // if (fBtnActive)

        // Check for events that cause the calendar to go away

        //
        //  These events mean "I like it".  We allow Alt+Up or Enter
        //  to accept the changes.  (Alt+Up for compat with combo boxes.)
        //
        if (((msg.message == WM_LBUTTONDOWN   ||
              msg.message == WM_NCLBUTTONDOWN ||
              msg.message == WM_LBUTTONDBLCLK) && !PtInRect(&rcCal, msg.pt))  ||
              msg.message == WM_SYSCOMMAND    ||
              msg.message == WM_COMMAND       ||
              (msg.message == WM_SYSKEYDOWN && msg.wParam == VK_UP) ||
              (msg.message == WM_KEYDOWN && msg.wParam == VK_RETURN) ||
              msg.message == WM_KILLFOCUS)
        {
            DebugMsg(TF_MONTHCAL,TEXT("DPLBD_MonthCal got a message to accept (%d)"), msg.message);
            pdp->fShow = FALSE;
            continue;
        }

        //
        //  These events mean "I don't like it".
        //
        else if (((msg.message == WM_RBUTTONDOWN   ||
                   msg.message == WM_NCRBUTTONDOWN ||
                   msg.message == WM_RBUTTONDBLCLK) && !PtInRect(&rcCal, msg.pt)) ||
                (msg.message == WM_KEYDOWN && msg.wParam == VK_ESCAPE))
        {
            DebugMsg(TF_MONTHCAL,TEXT("DPLBD_MonthCal got a message to cancel (%d)"), msg.message);
            pdp->fShow = FALSE;
            pdp->sec.st = stOld;
            DPNotifyDateChange(pdp);
            InvalidateRect(pdp->ci.hwnd, NULL, TRUE);
            continue;
        }


        TranslateMessage(&msg);
        DispatchMessage(&msg);
    } // while(fShow)

    CCSendNotify(&pdp->ci, DTN_CLOSEUP, NULL);

    pdp->hwndMC = NULL;
    DestroyWindow(hwndMC);
    ReleaseDC(pdp->ci.hwnd, hdc);
}

void DPHandleSECEdit(DATEPICK *pdp)
{
    TCHAR szBuf[DTP_FORMATLENGTH];

    if (SECEdit(pdp, szBuf, ARRAYSIZE(szBuf)))
    {
        NMDATETIMESTRING nmdts = {0};

        nmdts.pszUserString = szBuf;
        // just in case the app doesn't parse the string
        nmdts.st      = pdp->sec.st;
        nmdts.dwFlags = (pdp->fCheck==1) ? GDT_VALID : GDT_NONE;

        CCSendNotify(&pdp->ci, DTN_USERSTRING, &nmdts.nmhdr);

        // If the app gives us an invalid date, go back to the old date
        if (nmdts.dwFlags == GDT_VALID &&
            !IsValidSystemtime(&nmdts.st))
        {
            nmdts.st = pdp->sec.st;
        }

        if (nmdts.dwFlags == GDT_NONE)
        {
            if (DatePick_ShowCheck(pdp))
            {
                pdp->fCheck      = FALSE;
                pdp->fCheckFocus = TRUE;
                SECSetCurSubed(pdp, SUBEDIT_NONE);
                InvalidateRect(pdp->ci.hwnd, NULL, TRUE);
                DPNotifyDateChange(pdp);
            }
        }
        else if (nmdts.dwFlags == GDT_VALID)
        {
            DPSetDate(pdp, &nmdts.st, FALSE);
        }
    }
}

LRESULT DPLButtonDown(DATEPICK *pdp, WPARAM wParam, LPARAM lParam)
{
    POINT pt;
    BOOL  fFocus;

    if (!pdp->fEnabled)
        return(0);

    pt.x = GET_X_LPARAM(lParam);
    pt.y = GET_Y_LPARAM(lParam);

    // reset subed char count
    SECResetSubeditEdit(pdp);

    fFocus = pdp->fFocus;
    if (!fFocus)
        SetFocus(pdp->ci.hwnd);

    // display MONTHCAL iif we're not DTS_UPDOWN
    if (!pdp->fUseUpDown && PtInRect(&pdp->rcBtn, pt) && IsWindowVisible(pdp->ci.hwnd))
    {
        DPLBD_MonthCal(pdp, TRUE);
    }
    else if (!pdp->fCapture)
    {
        // Un/check checkbox
        if (DatePick_ShowCheck(pdp) && PtInRect(&pdp->rcCheck, pt))
        {
            pdp->fCheck      = !pdp->fCheck;
            pdp->fCheckFocus = 1;
            SECSetCurSubed(pdp, SUBEDIT_NONE);
            InvalidateRect(pdp->ci.hwnd, NULL, TRUE);
            DPNotifyDateChange(pdp);
        }

        // Select a subedit
        else if (pdp->fCheck)
        {
            if (DatePick_AppCanParse(pdp) && fFocus)
            {
                // First click brings focus to a subedit, second click starts editing
                DPHandleSECEdit(pdp);
            }
            else
            {
                int isubed;
                pt.x += pdp->sec.xScroll;
                isubed = SECSubeditFromPt(&pdp->sec, pt);
                if (isubed >= 0)
                {
                    SECSetCurSubed(pdp, isubed);
                    if (DatePick_ShowCheck(pdp))
                    {
                        pdp->fCheckFocus = 0;
                        InvalidateRect(pdp->ci.hwnd, &pdp->rcCheck, TRUE);
                    }
                }
            }
        }
    }

    return(0);
}

void DPRecomputeSizing(DATEPICK *pdp, RECT *prect)
{
    RECT rcTmp;

    if (DatePick_ShowCheck(pdp))
    {
        pdp->rcCheck.top    = prect->top    + 1;
        pdp->rcCheck.bottom = prect->bottom - 1;
        pdp->rcCheck.left   = prect->left   + 1;
        pdp->rcCheck.right  = prect->left   + (pdp->rcCheck.bottom - pdp->rcCheck.top);

        // occupy at most half the width of the window
        if (pdp->rcCheck.right > prect->left + (prect->right - prect->left)/2)
        {
            pdp->rcCheck.right = prect->left + (prect->right - prect->left)/2;
        }
    }
    else
    {
        pdp->rcCheck.top    = prect->top;
        pdp->rcCheck.bottom = prect->top;
        pdp->rcCheck.left   = prect->left;
        pdp->rcCheck.right  = prect->left + DPXBUFFER - 1;
    }

    pdp->rcBtn = *prect;
    pdp->rcBtn.left = pdp->rcBtn.right - GetSystemMetrics(SM_CXVSCROLL);
    if (pdp->rcBtn.left < pdp->rcCheck.right)
        pdp->rcBtn.left = pdp->rcCheck.right;
    if (pdp->hwndUD)
        MoveWindow(pdp->hwndUD, pdp->rcBtn.left, pdp->rcBtn.top, pdp->rcBtn.right - pdp->rcBtn.left + 1, pdp->rcBtn.bottom - pdp->rcBtn.top + 1, FALSE);

    rcTmp = pdp->rc;
    pdp->rc.top    = prect->top;
    pdp->rc.bottom = prect->bottom;
    pdp->rc.left   = pdp->rcCheck.right + 1;
    pdp->rc.right  = pdp->rcBtn.left - 1;
    SECRecomputeSizing(&pdp->sec, &pdp->rc);
}

// deal with control codes
LRESULT DPHandleKeydown(DATEPICK *pdp, WPARAM wParam, LPARAM lParam)
{
    int delta = 1;

    if (wParam == VK_F4 && !pdp->fUseUpDown)
    {
        DPLBD_MonthCal(pdp, FALSE);
    }
    else if (DatePick_AppCanParse(pdp) && wParam == VK_F2)
    {
        DPHandleSECEdit(pdp);
    }
    else if (pdp->fCheckFocus)
    {
        switch (wParam)
        {
        case VK_LEFT:
            delta = -1;
            // fall through...
        case VK_RIGHT:
            if (pdp->fCheck)
            {
                if (SUBEDIT_NONE != SECIncrFocus(pdp, delta))
                {
                    pdp->fCheckFocus = FALSE;
                    InvalidateRect(pdp->ci.hwnd, &pdp->rcCheck, TRUE);
                }
            }
            break;
        }
    }
    else
    {
        switch (wParam)
        {
        case VK_HOME:
            if (GetKeyState(VK_CONTROL) < 0)
            {
                SYSTEMTIME st;
                GetLocalTime(&st);
                DPSetDate(pdp, &st, TRUE);
                break;
            }
            // fall through...

        default:
            if (SECHandleKeydown(pdp, wParam, lParam))
            {
                DPNotifyDateChange(pdp);
            }
            else if (DatePick_ShowCheck(pdp))
            {
                if (pdp->sec.iseCur < 0)
                {
                    pdp->fCheckFocus = TRUE;
                    InvalidateRect(pdp->ci.hwnd, &pdp->rcCheck, TRUE);
                }
            }
            break;
        }
    }

    return(0);
}

// deal with characters
LRESULT DPHandleChar(DATEPICK *pdp, WPARAM wParam, LPARAM lParam)
{
    TCHAR ch = (TCHAR)wParam;

    if (pdp->fCheckFocus)
    {
        // this is the only character we care about in this case
        if (ch == TEXT(' '))
        {
            pdp->fCheck = 1-pdp->fCheck;
            InvalidateRect(pdp->ci.hwnd, NULL, TRUE);
            DPNotifyDateChange(pdp);
        }
        else
        {
            MessageBeep(MB_ICONHAND);
        }
    }
    else
    {
        // let the subedit handle this -- a value can change
        SECHandleChar(pdp, ch);
    }
    return(0);
}

void DPNotifyDateChange(DATEPICK *pdp)
{
    NMDATETIMECHANGE nmdc = {0};
    BOOL fChanged;

    if (pdp->fNoNotify)
        return;

    if (pdp->fCheck == 0)
    {
        nmdc.dwFlags = GDT_NONE;
    }
    else
    {
        // validate date - do it here in only one place
        if (CmpSystemtime(&pdp->sec.st, &pdp->stMin) < 0)
        {
            pdp->sec.st = pdp->stMin;
            InvalidateRect(pdp->ci.hwnd, NULL, TRUE);
            SECInvalidate(&pdp->sec, SE_APP);
        }
        else if (CmpSystemtime(&pdp->sec.st, &pdp->stMax) > 0)
        {
            pdp->sec.st = pdp->stMax;
            InvalidateRect(pdp->ci.hwnd, NULL, TRUE);
            SECInvalidate(&pdp->sec, SE_APP);
        }

        nmdc.dwFlags = GDT_VALID;
        SECGetSystemtime(&pdp->sec, &nmdc.st);
    }

    fChanged = CmpSystemtime(&pdp->stPrev, &nmdc.st);
    if (fChanged) {
        MyNotifyWinEvent(EVENT_OBJECT_NAMECHANGE, pdp->ci.hwnd, OBJID_WINDOW, INDEXID_CONTAINER);
    }

    //
    //  APP COMPAT:  IE4 always notified even if the date didn't change.
    //               I don't know of any apps that rely on this
    //               but I'm not gonna risk it.
    //
    if (fChanged || pdp->ci.iVersion < 5)
    {
        pdp->stPrev = nmdc.st;
        CCSendNotify(&pdp->ci, DTN_DATETIMECHANGE, &nmdc.nmhdr);
    }
}

BOOL DPSetDate(DATEPICK *pdp, SYSTEMTIME *pst, BOOL fMungeDate)
{
    BOOL fChanged = FALSE;

    // make sure that the new date is within the valid range
    if (CmpSystemtime(pst, &pdp->stMin) < 0)
    {
        if (!fMungeDate)
            return(FALSE);
        pst = &pdp->stMin;
    }
    if (CmpSystemtime(&pdp->stMax, pst) < 0)
    {
        if (!fMungeDate)
            return(FALSE);
        pst = &pdp->stMax;
    }

    if (fMungeDate)
    {
        // only copy the date portion
        CopyDate(*pst, pdp->sec.st);
        fChanged = TRUE;
    }
    else
    {
        fChanged = SECSetSystemtime(pdp, pst);
    }

    if (fChanged)
    {
        SECInvalidate(&pdp->sec, SE_APP); // SE_APP invalidates everything
        DPNotifyDateChange(pdp);
    }

    return(TRUE);
}

void DPDrawDropdownButton(DATEPICK *pdp, HDC hdc, BOOL fPressed)
{
    UINT dfcs;

    dfcs = DFCS_SCROLLDOWN;
    if (fPressed)
        dfcs |= DFCS_PUSHED | DFCS_FLAT;
    if (!pdp->fEnabled)
        dfcs |= DFCS_INACTIVE;
    DrawFrameControl(hdc, &pdp->rcBtn, DFC_SCROLL, dfcs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\olestuff.cpp ===
//  OLESTUFF.CPP
//  Implementation of OLE delay-loaded stuff. This is needed for the
//  classes defined in TBDROP.CPP and TABDROP.CPP.
//	More OLE stuff could go here in the future.
//	==
//	Technically this code is not C++ however, both files that call us
//	are C++, and this is where we call for the C++ glue in crtfree.h.
//	So for now this remains a .CPP file.
//
//  History:
//      8/22/96 -   t-mkim: created
//
#include "ctlspriv.h"
#include "olestuff.h"

// Allow C++ files to be linked in w/o error
#define CPP_FUNCTIONS
#include <crtfree.h>

#define OLELIBNAME  TEXT ("OLE32.DLL")

// function pointers for GetProcAddress.
typedef HRESULT (STDAPICALLTYPE *LPFNCOINITIALIZE)(LPMALLOC pMalloc);
typedef void    (STDAPICALLTYPE *LPFNCOUNINITIALIZE)(void);
typedef HRESULT (STDAPICALLTYPE *LPFNREGISTERDRAGDROP)(HWND hwnd, LPDROPTARGET pDropTarget);
typedef HRESULT (STDAPICALLTYPE *LPFNREVOKEDRAGDROP)(HWND hwnd);

HMODULE PrivLoadOleLibrary ()
{
    // We call GetModuleHandle first so we don't map the library if we don't
    // need to. We would like to avoid the overhead necessary to do so.
    return GetModuleHandle(OLELIBNAME) ? LoadLibrary (OLELIBNAME) : NULL;
}

BOOL PrivFreeOleLibrary(HMODULE hmodOle)
{
    return FreeLibrary(hmodOle);
}

HRESULT PrivCoInitialize (HMODULE hmodOle)
{
    LPFNCOINITIALIZE pfnCoInitialize = (LPFNCOINITIALIZE) GetProcAddress (hmodOle, "CoInitialize");
    return pfnCoInitialize (NULL);
}

void PrivCoUninitialize (HMODULE hmodOle)
{
    LPFNCOUNINITIALIZE pfnCoUninitialize = (LPFNCOUNINITIALIZE) GetProcAddress (hmodOle, "CoUninitialize");
    pfnCoUninitialize ();
}

HRESULT PrivRegisterDragDrop (HMODULE hmodOle, HWND hwnd, IDropTarget *pDropTarget)
{
    LPFNREGISTERDRAGDROP pfnRegisterDragDrop = (LPFNREGISTERDRAGDROP) GetProcAddress (hmodOle, "RegisterDragDrop");
    return pfnRegisterDragDrop(hwnd, pDropTarget);
}

HRESULT PrivRevokeDragDrop (HMODULE hmodOle, HWND hwnd)
{
    LPFNREVOKEDRAGDROP pfnRevokeDragDrop = (LPFNREVOKEDRAGDROP) GetProcAddress (hmodOle, "RevokeDragDrop");
    return pfnRevokeDragDrop (hwnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\os.c ===
#include "ctlspriv.h"
#include <krnlcmn.h>

//========== OS Dependent Code =============================================

/*----------------------------------------------------------
Purpose: This export exists so SHDOCVW can call Kernel32's GetProcessDword,
         which is only exported on Win95.  In addition, it is exported
         by ordinal only.  Since GetProcAddress fails for ordinals
         to KERNEL32 directly, we have SHELL32 implicitly link to
         this export and SHDOCVW calls thru this private API.

Returns: 0 on failure
Cond:    --
*/

DWORD
SHGetProcessDword(
    IN DWORD idProcess,
    IN LONG  iIndex)
{
#ifdef WINNT
    return 0;
#else
    return GetProcessDword(idProcess, iIndex);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\olestuff.h ===
//  OLESTUFF.H
//  Prototypes for OLE delay-load stuff needed for the toolbar and tab
//  drop target classes.
//
//  History:
//      8/22/96 -   t-mkim: created
//
#ifndef _OLESTUFF_H
#define _OLESTUFF_H

// This deals with the OLE library module handle
//
HMODULE PrivLoadOleLibrary ();
BOOL    PrivFreeOleLibrary (HMODULE hmodOle);

//  Following functions correspond to CoInitialize, CoUninitialize,
//  RegisterDragDrop, and RevokeDragDrop. All take the HMODULE returned
//  by PrivLoadOleLibrary.
//
HRESULT PrivCoInitialize (HMODULE hmodOle);
void    PrivCoUninitialize (HMODULE hmodOle);
HRESULT PrivRegisterDragDrop (HMODULE hmodOle, HWND hwnd, IDropTarget *pDropTarget);
HRESULT PrivRevokeDragDrop (HMODULE hmodOle, HWND hwnd);

#endif //_OLESTUFF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\notify.c ===
#include "ctlspriv.h"

#ifdef NEED_WOWGETNOTIFYSIZE_HELPER

#include <shsemip.h>                // SEN_* notifications
#include <commdlg.h>                // CDN_* notifications

// Miscellaneous hackery needed in order to include shlobjp.h
#define CONTROLINFO     OAIDL_CONTROLINFO
#define LPCONTROLINFO   LPOAIDL_CONTROLINFO
#include <shlobj.h>
#include <shlobjp.h>                // NMVIEWFOLDER structure
#undef CONTROLINFO
#undef LPCONTROLINFO

//
//  Helper function for WOW on NT.
//
//  WOW needs to know the size of the notify structure associated with a
//  notification.  If a 32-bit window has been subclassed by a 16-bit app,
//  WOW needs to copy the notify structure into 16-bit space, and then when
//  the 16-bit guy does a CallWindowProc(), they have to copy it back into
//  32-bit space.  Without the size information, you fault on the
//  32-bit side because the notify structure is incomplete.
//
//  Some notifications have multiple structures associated with them, in
//  which case you should return the largest possible valid structure.
//
STDAPI_(UINT) WOWGetNotifySize(UINT code)
{
    switch (code) {

    // Generic comctl32 notifications
    case NM_OUTOFMEMORY:        return sizeof(NMHDR);   // not used

    case NM_CLICK:              return max(max(
                        sizeof(NMHDR),       // tab, treeview
                        sizeof(NMCLICK)),    // toolbar, statusbar
                        sizeof(NMITEMACTIVATE)); // listview

    case NM_DBLCLK:             return max(max(
                        sizeof(NMHDR),       // tab, treeview
                        sizeof(NMCLICK)),    // toolbar, statusbar
                        sizeof(NMITEMACTIVATE)); // listview


    case NM_RETURN:             return sizeof(NMHDR);

    case NM_RCLICK:             return max(max(
                        sizeof(NMHDR),       // header, listview report mode, treeview
                        sizeof(NMCLICK)),    // toolbar, statusbar
                        sizeof(NMITEMACTIVATE)); // listview icon mode

    case NM_RDBLCLK:            return max(max(
                        sizeof(NMHDR),       // treeview
                        sizeof(NMCLICK)),    // toolbar, statusbar
                        sizeof(NMITEMACTIVATE)); // listview

    case NM_SETFOCUS:           return sizeof(NMHDR);
    case NM_KILLFOCUS:          return sizeof(NMHDR);
    case NM_STARTWAIT:          return sizeof(NMHDR);      // not used
    case NM_ENDWAIT:            return sizeof(NMHDR);      // not used
    case NM_BTNCLK:             return sizeof(NMHDR);      // not used
    case NM_CUSTOMDRAW:         return sizeof(NMCUSTOMDRAW);
    case NM_HOVER:              return sizeof(NMHDR);
    case NM_NCHITTEST:          return sizeof(NMMOUSE);
    case NM_KEYDOWN:            return sizeof(NMKEY);
    case NM_RELEASEDCAPTURE:    return sizeof(NMHDR);
    case NM_SETCURSOR:          return sizeof(NMMOUSE);
    case NM_CHAR:               return sizeof(NMCHAR);
    case NM_TOOLTIPSCREATED:    return sizeof(NMTOOLTIPSCREATED);
    case NM_LDOWN:              return sizeof(NMCLICK);
    case NM_RDOWN:              return sizeof(NMCLICK);     // not used

    // Listview notifications
    case LVN_ITEMCHANGING:      return sizeof(NMLISTVIEW);
    case LVN_ITEMCHANGED:       return sizeof(NMLISTVIEW);
    case LVN_INSERTITEM:        return sizeof(NMLISTVIEW);
    case LVN_DELETEITEM:        return sizeof(NMLISTVIEW);
    case LVN_DELETEALLITEMS:    return sizeof(NMLISTVIEW);
    case LVN_BEGINLABELEDITA:   return sizeof(NMLVDISPINFOA);
    case LVN_BEGINLABELEDITW:   return sizeof(NMLVDISPINFOW);
    case LVN_ENDLABELEDITA:     return sizeof(NMLVDISPINFOA);
    case LVN_ENDLABELEDITW:     return sizeof(NMLVDISPINFOW);
    case LVN_COLUMNCLICK:       return sizeof(NMLISTVIEW);
    case LVN_BEGINDRAG:         return sizeof(NMITEMACTIVATE);
    case LVN_BEGINRDRAG:        return sizeof(NMITEMACTIVATE); // not used
    case LVN_ENDDRAG:           return sizeof(NMITEMACTIVATE); // not used
    case LVN_ENDRDRAG:          return sizeof(NMITEMACTIVATE); // not used
    case LVN_ODCACHEHINT:       return sizeof(NMLVCACHEHINT);
    case LVN_ODFINDITEMA:       return sizeof(NMLVFINDITEMA);
    case LVN_ODFINDITEMW:       return sizeof(NMLVFINDITEMW);
    case LVN_ITEMACTIVATE:      return sizeof(NMITEMACTIVATE);
    case LVN_ODSTATECHANGED:    return sizeof(NMLVODSTATECHANGE);
//  case LVN_PEN:               // Pen Windows slackers
    case LVN_HOTTRACK:          return sizeof(NMLISTVIEW);
    case LVN_GETDISPINFOA:      return sizeof(NMLVDISPINFOA);
    case LVN_GETDISPINFOW:      return sizeof(NMLVDISPINFOW);
    case LVN_SETDISPINFOA:      return sizeof(NMLVDISPINFOA);
    case LVN_SETDISPINFOW:      return sizeof(NMLVDISPINFOW);
    case LVN_KEYDOWN:           return sizeof(NMLVKEYDOWN);
    case LVN_MARQUEEBEGIN:      return sizeof(NMITEMACTIVATE);
    case LVN_GETINFOTIPA:       return sizeof(NMLVGETINFOTIPA);
    case LVN_GETINFOTIPW:       return sizeof(NMLVGETINFOTIPW);
    case LVN_GETEMPTYTEXTA:     return sizeof(NMLVDISPINFOA);
    case LVN_GETEMPTYTEXTW:     return sizeof(NMLVDISPINFOW);
    case LVN_INCREMENTALSEARCHA:return sizeof(NMLVFINDITEMA);
    case LVN_INCREMENTALSEARCHW:return sizeof(NMLVFINDITEMW);

    // Property sheet notifications
    case PSN_SETACTIVE:         return sizeof(PSHNOTIFY);
    case PSN_KILLACTIVE:        return sizeof(PSHNOTIFY);
    case PSN_APPLY:             return sizeof(PSHNOTIFY);
    case PSN_RESET:             return sizeof(PSHNOTIFY);
    case PSN_HASHELP:           return sizeof(PSHNOTIFY);   // not used
    case PSN_HELP:              return sizeof(PSHNOTIFY);
    case PSN_WIZBACK:           return sizeof(PSHNOTIFY);
    case PSN_WIZNEXT:           return sizeof(PSHNOTIFY);
    case PSN_WIZFINISH:         return sizeof(PSHNOTIFY);
    case PSN_QUERYCANCEL:       return sizeof(PSHNOTIFY);
    case PSN_GETOBJECT:         return sizeof(NMOBJECTNOTIFY);
    case PSN_LASTCHANCEAPPLY:   return sizeof(PSHNOTIFY);
    case PSN_TRANSLATEACCELERATOR:
                                return sizeof(PSHNOTIFY);
    case PSN_QUERYINITIALFOCUS: return sizeof(PSHNOTIFY);

    // Header notifications
    case HDN_ITEMCHANGINGA:     return sizeof(NMHEADERA);
    case HDN_ITEMCHANGINGW:     return sizeof(NMHEADERW);
    case HDN_ITEMCHANGEDA:      return sizeof(NMHEADERA);
    case HDN_ITEMCHANGEDW:      return sizeof(NMHEADERW);
    case HDN_ITEMCLICKA:        return sizeof(NMHEADERA);
    case HDN_ITEMCLICKW:        return sizeof(NMHEADERW);
    case HDN_ITEMDBLCLICKA:     return sizeof(NMHEADERA);
    case HDN_ITEMDBLCLICKW:     return sizeof(NMHEADERW);
    case HDN_DIVIDERDBLCLICKA:  return sizeof(NMHEADERA);
    case HDN_DIVIDERDBLCLICKW:  return sizeof(NMHEADERW);
    case HDN_BEGINTRACKA:       return sizeof(NMHEADERA);
    case HDN_BEGINTRACKW:       return sizeof(NMHEADERW);
    case HDN_ENDTRACKA:         return sizeof(NMHEADERA);
    case HDN_ENDTRACKW:         return sizeof(NMHEADERW);
    case HDN_TRACKA:            return sizeof(NMHEADERA);
    case HDN_TRACKW:            return sizeof(NMHEADERW);
    case HDN_GETDISPINFOA:      return sizeof(NMHDDISPINFOA);
    case HDN_GETDISPINFOW:      return sizeof(NMHDDISPINFOW);
    case HDN_BEGINDRAG:         return sizeof(NMHEADER); // No strings
    case HDN_ENDDRAG:           return sizeof(NMHEADER); // No strings
    case HDN_FILTERCHANGE:      return sizeof(NMHEADER); // No strings
    case HDN_FILTERBTNCLICK:    return sizeof(NMHDFILTERBTNCLICK);

    // Treeview notifications
    case TVN_SELCHANGINGA:      return sizeof(NMTREEVIEWA);
    case TVN_SELCHANGINGW:      return sizeof(NMTREEVIEWW);
    case TVN_SELCHANGEDA:       return sizeof(NMTREEVIEWA);
    case TVN_SELCHANGEDW:       return sizeof(NMTREEVIEWW);
    case TVN_GETDISPINFOA:      return sizeof(NMTVDISPINFOA);
    case TVN_GETDISPINFOW:      return sizeof(NMTVDISPINFOW);
    case TVN_SETDISPINFOA:      return sizeof(NMTVDISPINFOA);
    case TVN_SETDISPINFOW:      return sizeof(NMTVDISPINFOW);
    case TVN_ITEMEXPANDINGA:    return sizeof(NMTREEVIEWA);
    case TVN_ITEMEXPANDINGW:    return sizeof(NMTREEVIEWW);
    case TVN_ITEMEXPANDEDA:     return sizeof(NMTREEVIEWA);
    case TVN_ITEMEXPANDEDW:     return sizeof(NMTREEVIEWW);
    case TVN_BEGINDRAGA:        return sizeof(NMTREEVIEWA);
    case TVN_BEGINDRAGW:        return sizeof(NMTREEVIEWW);
    case TVN_BEGINRDRAGA:       return sizeof(NMTREEVIEWA);
    case TVN_BEGINRDRAGW:       return sizeof(NMTREEVIEWW);
    case TVN_DELETEITEMA:       return sizeof(NMTREEVIEWA);
    case TVN_DELETEITEMW:       return sizeof(NMTREEVIEWW);
    case TVN_BEGINLABELEDITA:   return sizeof(NMTVDISPINFOA);
    case TVN_BEGINLABELEDITW:   return sizeof(NMTVDISPINFOW);
    case TVN_ENDLABELEDITA:     return sizeof(NMTVDISPINFOA);
    case TVN_ENDLABELEDITW:     return sizeof(NMTVDISPINFOW);
    case TVN_KEYDOWN:           return sizeof(NMTVKEYDOWN);
    case TVN_GETINFOTIPA:       return sizeof(NMTVGETINFOTIPA);
    case TVN_GETINFOTIPW:       return sizeof(NMTVGETINFOTIPW);
    case TVN_SINGLEEXPAND:      return sizeof(NMTREEVIEW); // No strings

    // Rundll32 notifications
    case RDN_TASKINFO:          return sizeof(RUNDLL_NOTIFY);

    // Tooltip notifications
    case TTN_GETDISPINFOA:      return sizeof(NMTTDISPINFOA);
    case TTN_GETDISPINFOW:      return sizeof(NMTTDISPINFOW);
    case TTN_SHOW:              return sizeof(NMTTSHOWINFO);
    case TTN_POP:               return sizeof(NMHDR);

    // Tab control notifications

    // WE ARE SUCH HORRIBLE SLACKERS!
    //
    //  Even though commctrl.h says that the shell reserved range is from
    //  -580 to -589, shsemip.h defines SEN_FIRST as -550, which conflicts
    //  with TCN_KEYDOWN, so now TCN_KEYDOWN and SEN_DDEEXECUTE have the
    //  same value.

#ifdef WINNT
    case TCN_KEYDOWN:           return max(sizeof(NMTCKEYDOWN),
                                           sizeof(NMVIEWFOLDERW));
#else
    case TCN_KEYDOWN:           return max(sizeof(NMTCKEYDOWN),
                                           sizeof(NMVIEWFOLDERA));
#endif
    case TCN_SELCHANGE:         return sizeof(NMHDR);
    case TCN_SELCHANGING:       return sizeof(NMHDR);
    case TCN_GETOBJECT:         return sizeof(NMOBJECTNOTIFY);
    case TCN_FOCUSCHANGE:       return sizeof(NMHDR);

    // Shell32 notifications
#if 0 // see comment at TCN_KEYDOWN
    case SEN_DDEEXECUTE:
#ifdef WINNT
                                return sizeof(NMVIEWFOLDERW);
#else
                                return sizeof(NMVIEWFOLDERA);
#endif
#endif

    // Comdlg32 notifications
    case CDN_INITDONE:          return max(sizeof(OFNOTIFYA),
                                           sizeof(OFNOTIFYW));
    case CDN_SELCHANGE:         return max(sizeof(OFNOTIFYA),
                                           sizeof(OFNOTIFYW));
    case CDN_FOLDERCHANGE:      return max(sizeof(OFNOTIFYA),
                                           sizeof(OFNOTIFYW));
    case CDN_SHAREVIOLATION:    return max(sizeof(OFNOTIFYA),
                                           sizeof(OFNOTIFYW));
    case CDN_HELP:              return max(sizeof(OFNOTIFYA),
                                           sizeof(OFNOTIFYW));
    case CDN_FILEOK:            return max(sizeof(OFNOTIFYA),
                                           sizeof(OFNOTIFYW));
    case CDN_TYPECHANGE:        return max(sizeof(OFNOTIFYA),
                                           sizeof(OFNOTIFYW));
    case CDN_INCLUDEITEM:       return max(sizeof(OFNOTIFYEXA),
                                           sizeof(OFNOTIFYEXW));

    // Toolbar notifications
    case TBN_GETBUTTONINFOA:    return sizeof(NMTOOLBARA);
    case TBN_GETBUTTONINFOW:    return sizeof(NMTOOLBARW);
    case TBN_BEGINDRAG:         return sizeof(NMTOOLBAR); // No strings
    case TBN_ENDDRAG:           return sizeof(NMTOOLBAR); // No strings
    case TBN_BEGINADJUST:       return sizeof(NMHDR);
    case TBN_ENDADJUST:         return sizeof(NMHDR);
    case TBN_RESET:             return sizeof(NMTBCUSTOMIZEDLG);
    case TBN_QUERYINSERT:       return sizeof(NMTOOLBAR); // No strings
    case TBN_QUERYDELETE:       return sizeof(NMTOOLBAR); // No strings
    case TBN_TOOLBARCHANGE:     return sizeof(NMHDR);
    case TBN_CUSTHELP:          return sizeof(NMHDR);
    case TBN_DROPDOWN:          return sizeof(NMTOOLBAR); // No strings
    case TBN_CLOSEUP:           return sizeof(NMHDR);     // not used
    case TBN_GETOBJECT:         return sizeof(NMOBJECTNOTIFY);
    case TBN_HOTITEMCHANGE:     return sizeof(NMTBHOTITEM);
    case TBN_DRAGOUT:           return sizeof(NMTOOLBAR); // No strings
    case TBN_DELETINGBUTTON:    return sizeof(NMTOOLBAR); // No strings
    case TBN_GETDISPINFOA:      return sizeof(NMTBDISPINFOA);
    case TBN_GETDISPINFOW:      return sizeof(NMTBDISPINFOW);
    case TBN_GETINFOTIPA:       return sizeof(NMTBGETINFOTIPA);
    case TBN_GETINFOTIPW:       return sizeof(NMTBGETINFOTIPW);
    case TBN_RESTORE:           return sizeof(NMTBRESTORE);

    // WE ARE SUCH HORRIBLE SLACKERS!
    //
    //  The TBN_FIRST/TBN_LAST range reserves 20 notifications for toolbar,
    //  and we overflowed that limit, so now UDN_DELTAPOS and
    //  TBN_SAVE have the same value.

    case TBN_SAVE:              return max(sizeof(NMTBSAVE),
                                           sizeof(NMUPDOWN));

    case TBN_INITCUSTOMIZE:     return sizeof(NMTBCUSTOMIZEDLG);
    case TBN_WRAPHOTITEM:       return sizeof(NMTBWRAPHOTITEM);
    case TBN_DUPACCELERATOR:    return sizeof(NMTBDUPACCELERATOR);
    case TBN_WRAPACCELERATOR:   return sizeof(NMTBWRAPACCELERATOR);
    case TBN_DRAGOVER:          return sizeof(NMTBHOTITEM);
    case TBN_MAPACCELERATOR:    return sizeof(NMCHAR);

    // Up-down control
#if 0 // see comment at TBN_SAVE
    case UDN_DELTAPOS:          return sizeof(NMUPDOWN);
#endif

    // Monthcal control
    case MCN_SELCHANGE:         return sizeof(NMSELCHANGE);
    case MCN_GETDAYSTATE:       return sizeof(NMDAYSTATE);
    case MCN_SELECT:            return sizeof(NMSELECT);

    // Date/time picker control
    case DTN_DATETIMECHANGE:    return sizeof(NMDATETIMECHANGE);
    case DTN_USERSTRINGA:       return sizeof(NMDATETIMESTRINGA);
    case DTN_USERSTRINGW:       return sizeof(NMDATETIMESTRINGW);
    case DTN_WMKEYDOWNA:        return sizeof(NMDATETIMEWMKEYDOWNA);
    case DTN_WMKEYDOWNW:        return sizeof(NMDATETIMEWMKEYDOWNW);
    case DTN_FORMATA:           return sizeof(NMDATETIMEFORMATA);
    case DTN_FORMATW:           return sizeof(NMDATETIMEFORMATW);
    case DTN_FORMATQUERYA:      return sizeof(NMDATETIMEFORMATQUERYA);
    case DTN_FORMATQUERYW:      return sizeof(NMDATETIMEFORMATQUERYW);
    case DTN_DROPDOWN:          return sizeof(NMHDR);
    case DTN_CLOSEUP:           return sizeof(NMHDR);

    // Comboex notifications
    case CBEN_GETDISPINFOA:     return sizeof(NMCOMBOBOXEXA);
    case CBEN_GETDISPINFOW:     return sizeof(NMCOMBOBOXEXW);
    case CBEN_INSERTITEM:       return sizeof(NMCOMBOBOXEX); // Random character set
    case CBEN_DELETEITEM:       return sizeof(NMCOMBOBOXEX); // No strings
    case CBEN_ITEMCHANGED:      return sizeof(NMCOMBOBOXEX); // Not used
    case CBEN_BEGINEDIT:        return sizeof(NMHDR);
    case CBEN_ENDEDITA:         return sizeof(NMCBEENDEDITA);
    case CBEN_ENDEDITW:         return sizeof(NMCBEENDEDITW);
    case CBEN_DRAGBEGINA:       return sizeof(NMCBEDRAGBEGINA);
    case CBEN_DRAGBEGINW:       return sizeof(NMCBEDRAGBEGINW);

    // Rebar notifications
    case RBN_HEIGHTCHANGE:      return sizeof(NMHDR);
    case RBN_GETOBJECT:         return sizeof(NMOBJECTNOTIFY);
    case RBN_LAYOUTCHANGED:     return sizeof(NMHDR);
    case RBN_AUTOSIZE:          return sizeof(NMRBAUTOSIZE);
    case RBN_BEGINDRAG:         return sizeof(NMREBAR);
    case RBN_DELETINGBAND:      return sizeof(NMREBAR);
    case RBN_DELETEDBAND:       return sizeof(NMREBAR);
    case RBN_CHILDSIZE:         return sizeof(NMREBARCHILDSIZE);

    // IP address control notification
    case IPN_FIELDCHANGED:      return sizeof(NMIPADDRESS);

    // Status bar notifications
    case SBN_SIMPLEMODECHANGE:  return sizeof(NMHDR);

    // Pager control notifications
    case PGN_SCROLL:            return sizeof(NMPGSCROLL);
    case PGN_CALCSIZE:          return sizeof(NMPGCALCSIZE);

    default:
        break;
    }

    //
    //  Categories of notifications we explicitly know nothing about.
    //

    if (code >= WMN_LAST && code <= WMN_FIRST) { // Internet Mail and News
        return 0;
    }

    if ((int)code >= 0) { // Application-specific notifications
        return 0;
    }

    //
    //  IF THIS ASSERT FIRES, YOU MUST FIX IT OR YOU WILL BREAK WOW!
    //
    AssertMsg(0, TEXT("Notification code %d must be added to WOWGetNotifySize"));
    return 0;
}

#endif // NEED_WOWGETNOTIFYSIZE_HELPER

LRESULT WINAPI SendNotifyEx(HWND hwndTo, HWND hwndFrom, int code, NMHDR FAR* pnmhdr, BOOL bUnicode)
{
    CONTROLINFO ci;

    if (!hwndTo) {
        if (IsWindow(hwndFrom))
            hwndTo = GetParent(hwndFrom);
        if (!hwndTo)
            return 0;
    }


    ci.hwndParent = hwndTo;
    ci.hwnd = hwndFrom;
    ci.bUnicode = BOOLIFY(bUnicode);
    ci.uiCodePage = CP_ACP;

    return CCSendNotify(&ci, code, pnmhdr);
}


#ifdef UNICODE

void StringBufferAtoW(UINT uiCodePage, LPVOID pvOrgPtr, DWORD dwOrgSize, CHAR **ppszText)
{
    if (pvOrgPtr == *ppszText)
    {
        // the pointer has not been changed by the callback...
        // must convert from A to W in-place

        if (dwOrgSize)
        {
            LPWSTR pszW = ProduceWFromA(uiCodePage, *ppszText);
            if (pszW)
            {
                lstrcpynW((WCHAR *)(*ppszText), pszW, dwOrgSize);   // this becomes a W buffer
                FreeProducedString(pszW);
            }
        }
    }
    else
    {
        // the pointer has been changed out from underneath us, copy
        // unicode back into the original buffer.

        ConvertAToWN(uiCodePage, pvOrgPtr, dwOrgSize, *ppszText, -1);
        *ppszText = pvOrgPtr;
    }
}

typedef struct tagTHUNKSTATE {
    LPVOID ts_pvThunk1;
    LPVOID ts_pvThunk2;
    DWORD ts_dwThunkSize;
} THUNKSTATE;

//
//  InOutWtoA/InOutAtoW is for thunking INOUT string parameters.
//
//  INOUT parameters always create a hassle.
//
// We need to save both the original ANSI and the
// original UNICODE strings, so that if the app doesn't
// change the ANSI string, we leave the original UNICODE
// string alone.  That way, UNICODE item names don't get
// obliterated by the thunk.
//
// The original buffer is saved in pvThunk1.
// We allocate two ANSI buffers.
// pvThunk2 contains the original ANSIfied string.
// pvThunk2+cchTextMax is the buffer we pass to the app.
// On the way back, we compare pvThunk2 with pvThunk2+cchTextMax.
// If they are different, then we unthunk the string; otherwise,
// we leave the original UNICODE buffer alone.

BOOL InOutWtoA(CONTROLINFO *pci, THUNKSTATE *pts, LPWSTR *ppsz, DWORD cchTextMax)
{
    pts->ts_pvThunk1 = *ppsz;               // Save original buffer
    pts->ts_dwThunkSize = cchTextMax;

    if (!IsFlagPtr(pts->ts_pvThunk1))
    {
        pts->ts_pvThunk2 = LocalAlloc(LPTR, cchTextMax * 2 * sizeof(char));
        if (!ConvertWToAN(pci->uiCodePage, (LPSTR)pts->ts_pvThunk2, pts->ts_dwThunkSize, (LPWSTR)pts->ts_pvThunk1, -1))
        {
            LocalFree(pts->ts_pvThunk2);
            return 0;
        }
        *ppsz = (LPWSTR)((LPSTR)pts->ts_pvThunk2 + cchTextMax);
        lstrcpyA((LPSTR)*ppsz, pts->ts_pvThunk2);
    }
    return TRUE;
}

void InOutAtoW(CONTROLINFO *pci, THUNKSTATE *pts, LPSTR *ppsz)
{
    if (!IsFlagPtr(pts->ts_pvThunk1))
    {
        if (!IsFlagPtr(*ppsz) &&
            lstrcmpA(pts->ts_pvThunk2, (LPSTR)*ppsz) != 0)
            StringBufferAtoW(pci->uiCodePage, pts->ts_pvThunk1, pts->ts_dwThunkSize, ppsz);
        LocalFree(pts->ts_pvThunk2);
    }
    *ppsz = pts->ts_pvThunk1;
}

#endif // UNICODE


LRESULT WINAPI CCSendNotify(CONTROLINFO * pci, int code, LPNMHDR pnmhdr)
{
    NMHDR nmhdr;
    LONG_PTR id;
#ifdef UNICODE
    THUNKSTATE ts = { 0 };
    #define pvThunk1 ts.ts_pvThunk1
    #define pvThunk2 ts.ts_pvThunk2
    #define dwThunkSize ts.ts_dwThunkSize
    LRESULT lRet;
    BOOL  bSet = FALSE;
#endif
    HWND hwndParent = pci->hwndParent;
    DWORD dwParentPid;

    // -1 means Requery on each notify
    if ( hwndParent == (HWND)-1 )
    {
        hwndParent = GetParent(pci->hwnd);
    }

    // unlikely but it can technically happen -- avoid the rips
    if ( hwndParent == NULL )
        return 0;

    //
    // If pci->hwnd is -1, then a WM_NOTIFY is being forwared
    // from one control to a parent.  EG:  Tooltips sent
    // a WM_NOTIFY to toolbar, and toolbar is forwarding it
    // to the real parent window.
    //

    if (pci->hwnd != (HWND) -1) {

        //
        // If this is a child then get its ID.  We need to go out of our way to
        // avoid calling GetDlgCtrlID on toplevel windows since it will return
        // a pseudo-random number (those of you who know what this number is
        // keep quiet).  Anyway it's kinda hard to figure this out in Windows
        // because of the following:
        //
        //  - a window can SetWindowLong(GWL_STYLE, WS_CHILD) but this only
        //    does about half the work - hence checking the style is out.
        //  - GetParent will return your OWNER if you are toplevel.
        //  - there is no GetWindow(...GW_HWNDPARENT) to save us.
        //
        // Hence we are stuck with calling GetParent and then checking to see
        // if it lied and gave us the owner instead.  Yuck.
        //
        id = 0;
        if (pci->hwnd) {
            HWND hwndParent = GetParent(pci->hwnd);

            if (hwndParent && (hwndParent != GetWindow(pci->hwnd, GW_OWNER))) {
                id = GetDlgCtrlID(pci->hwnd);
            }
        }

        if (!pnmhdr)
            pnmhdr = &nmhdr;

        pnmhdr->hwndFrom = pci->hwnd;
        pnmhdr->idFrom = id;
        pnmhdr->code = code;
    } else {

        id = pnmhdr->idFrom;
        code = pnmhdr->code;
    }


    // OLE in its massively componentized world sometimes creates
    // a control whose parent belongs to another process.  (For example,
    // when there is a local server embedding.)  WM_NOTIFY
    // messages can't cross process boundaries, so stop the message
    // from going there lest we fault the recipient.
    if (!GetWindowThreadProcessId(hwndParent, &dwParentPid) ||
        dwParentPid != GetCurrentProcessId())
    {
        TraceMsg(TF_WARNING, "nf: Not sending WM_NOTIFY %08x across processes", code);
        return 0;
    }

#ifdef NEED_WOWGETNOTIFYSIZE_HELPER
    ASSERT(code >= 0 || WOWGetNotifySize(code));
#endif // NEED_WOWGETNOTIFYSIZE_HELPER

#ifdef UNICODE
    /*
     * All the thunking for Notify Messages happens here
     */
    if (!pci->bUnicode) {
        BOOL fThunked = TRUE;
        switch( code ) {
        case LVN_ODFINDITEMW:
            pnmhdr->code = LVN_ODFINDITEMA;
            goto ThunkLV_FINDINFO;

        case LVN_INCREMENTALSEARCHW:
            pnmhdr->code = LVN_INCREMENTALSEARCHA;
            goto ThunkLV_FINDINFO;

        ThunkLV_FINDINFO:
            {
                LV_FINDINFO *plvfi;

                // Hack Alert!  This code assumes that all fields of LV_FINDINFOA and
                // LV_FINDINFOW are exactly the same except for the string pointers.
                COMPILETIME_ASSERT(sizeof(LV_FINDINFOA) == sizeof(LV_FINDINFOW));

                // Since WCHARs are bigger than char, we will just use the
                // wchar buffer to hold the chars, and not worry about the extra
                // room at the end.
                COMPILETIME_ASSERT(sizeof(WCHAR) >= sizeof(char));

                plvfi = &((PNM_FINDITEM)pnmhdr)->lvfi;
                if (plvfi->flags & (LVFI_STRING | LVFI_PARTIAL | LVFI_SUBSTRING))
                {
                    pvThunk1 = (PVOID)plvfi->psz;
                    dwThunkSize = lstrlen(pvThunk1) + 1;
                    plvfi->psz = (LPWSTR)ProduceAFromW(pci->uiCodePage, plvfi->psz);
                }
            }
            break;

        case LVN_GETDISPINFOW: {
            LV_ITEMW *pitem;

            pnmhdr->code = LVN_GETDISPINFOA;

            // Hack Alert!  This code assumes that all fields of LV_DISPINFOA and
            // LV_DISPINFOW are exactly the same except for the string pointers.

            COMPILETIME_ASSERT(sizeof(LV_DISPINFOA) == sizeof(LV_DISPINFOW));

            // Since WCHARs are bigger than char, we will just use the
            // wchar buffer to hold the chars, and not worry about the extra
            // room at the end.
            COMPILETIME_ASSERT(sizeof(WCHAR) >= sizeof(char));

            //
            // Some sleazebag code (shell32.dll) just changes the pszText
            // pointer to point to the name, so capture the original pointer
            // so we can detect this and not smash their data.
            //
            pitem = &(((LV_DISPINFOW *)pnmhdr)->item);
            if (!IsFlagPtr(pitem) && (pitem->mask & LVIF_TEXT) && !IsFlagPtr(pitem->pszText)) {
                pvThunk1 = pitem->pszText;
                dwThunkSize = pitem->cchTextMax;
            }
            break;
        }


        // LVN_ENDLABELEDIT uses an INOUT parameter, never explicitly
        // documented as such, but it just happened to be that way,
        // and I don't want to take the chance that somebody was relying
        // on it.

        case LVN_ENDLABELEDITW:
            pnmhdr->code = LVN_ENDLABELEDITA;
            goto ThunkLV_DISPINFO;

        case LVN_BEGINLABELEDITW:
            pnmhdr->code = LVN_BEGINLABELEDITA;
            goto ThunkLV_DISPINFO;

        case LVN_SETDISPINFOW:
            pnmhdr->code = LVN_SETDISPINFOA;
            goto ThunkLV_DISPINFO;

        case LVN_GETEMPTYTEXTW:
            pnmhdr->code = LVN_GETEMPTYTEXTA;
            goto ThunkLV_DISPINFO;

        ThunkLV_DISPINFO: {
            LV_ITEMW *pitem;

            COMPILETIME_ASSERT(sizeof(LV_ITEMA) == sizeof(LV_ITEMW));
            pitem = &(((LV_DISPINFOW *)pnmhdr)->item);

            if (pitem->mask & LVIF_TEXT) {
                if (!InOutWtoA(pci, &ts, &pitem->pszText, pitem->cchTextMax))
                    return 0;
            }
            break;
        }

        case LVN_GETINFOTIPW: {
            NMLVGETINFOTIPW *pgit = (NMLVGETINFOTIPW *)pnmhdr;

            COMPILETIME_ASSERT(sizeof(NMLVGETINFOTIPA) == sizeof(NMLVGETINFOTIPW));
            pnmhdr->code = LVN_GETINFOTIPA;

            if (!InOutWtoA(pci, &ts, &pgit->pszText, pgit->cchTextMax))
                return 0;
        }
        break;


        case TVN_GETINFOTIPW:
            {
                NMTVGETINFOTIPW *pgit = (NMTVGETINFOTIPW *)pnmhdr;

                pnmhdr->code = TVN_GETINFOTIPA;

                pvThunk1 = pgit->pszText;
                dwThunkSize = pgit->cchTextMax;
            }
            break;

        case TBN_GETINFOTIPW:
            {
                NMTBGETINFOTIPW *pgit = (NMTBGETINFOTIPW *)pnmhdr;

                pnmhdr->code = TBN_GETINFOTIPA;

                pvThunk1 = pgit->pszText;
                dwThunkSize = pgit->cchTextMax;
            }
            break;

        case TVN_SELCHANGINGW:
            pnmhdr->code = TVN_SELCHANGINGA;
            bSet = TRUE;
            // fall through
            
        case TVN_SELCHANGEDW:
            if (!bSet) {
                pnmhdr->code = TVN_SELCHANGEDA;
                bSet = TRUE;
            }

            /*
             * These msgs have a NM_TREEVIEW with both TV_ITEMs filled in
             *
             * FALL THROUGH TO TVN_DELETEITEM to thunk itemOld then go on for
             * the other structure.
             */
             
            // fall through

        case TVN_DELETEITEMW: {
            /*
             * This message has a NM_TREEVIEW in lParam with itemOld filled in
             */
            LPTV_ITEMW pitem;

            if (!bSet) {
                pnmhdr->code = TVN_DELETEITEMA;
                bSet = TRUE;
            }

            pitem = &(((LPNM_TREEVIEWW)pnmhdr)->itemOld);

            // thunk itemOld
            if ( (pitem->mask & TVIF_TEXT) && !IsFlagPtr(pitem->pszText)) {
                pvThunk2 = pitem->pszText;
                pitem->pszText = (LPWSTR)ProduceAFromW(pci->uiCodePage, pvThunk2);
            }

            // if this is deleteitem then we are done
            if (pnmhdr->code == TVN_DELETEITEMA)
                break;

            /* FALL THROUGH TO TVN_ITEMEXPANDING to thunk itemNew */
        }
            // fall through

        case TVN_ITEMEXPANDINGW:
            if (!bSet) {
                pnmhdr->code = TVN_ITEMEXPANDINGA;
                bSet = TRUE;
            }
            // fall through

        case TVN_ITEMEXPANDEDW:
            if (!bSet) {
                pnmhdr->code = TVN_ITEMEXPANDEDA;
                bSet = TRUE;
            }
            // fall through

        case TVN_BEGINDRAGW:
            if (!bSet) {
                pnmhdr->code = TVN_BEGINDRAGA;
                bSet = TRUE;
            }
            // fall through

        case TVN_BEGINRDRAGW: {
            /* these msgs have a NM_TREEVIEW with itemNew TV_ITEM filled in */
            LPTV_ITEMW pitem;

            if (!bSet) {
                pnmhdr->code = TVN_BEGINRDRAGA;
            }

            pitem = &(((LPNM_TREEVIEWW)pnmhdr)->itemNew);

            if ( (pitem->mask & TVIF_TEXT) && !IsFlagPtr(pitem->pszText)) {
                pvThunk1 = pitem->pszText;
                pitem->pszText = (LPWSTR)ProduceAFromW(pci->uiCodePage, pvThunk1);
            }

            break;
        }

        case TVN_SETDISPINFOW:
            pnmhdr->code = TVN_SETDISPINFOA;
            goto ThunkTV_DISPINFO;

        case TVN_BEGINLABELEDITW:
            pnmhdr->code = TVN_BEGINLABELEDITA;
            goto ThunkTV_DISPINFO;


        // TVN_ENDLABELEDIT uses an INOUT parameter, never explicitly
        // documented as such, but it just happened to be that way,
        // and I don't want to take the chance that somebody was relying
        // on it.

        case TVN_ENDLABELEDITW:
            pnmhdr->code = TVN_ENDLABELEDITA;
            goto ThunkTV_DISPINFO;

        ThunkTV_DISPINFO: {
            /*
             * All these messages have a TV_DISPINFO in lParam.
             */

            LPTV_ITEMW pitem;

            pitem = &(((TV_DISPINFOW *)pnmhdr)->item);

            if (pitem->mask & TVIF_TEXT) {
                if (!InOutWtoA(pci, &ts, &pitem->pszText, pitem->cchTextMax))
                    return 0;
            }
            break;
        }

#if !defined(UNIX) || defined(ANSI_SHELL32_ON_UNIX)
/* UNIX shell32 TVN_GETDISPINFOA TVN_GETDISPINFOW does the same thing */
        case TVN_GETDISPINFOW: {
            /*
             * All these messages have a TV_DISPINFO in lParam.
             */
            LPTV_ITEMW pitem;

            pnmhdr->code = TVN_GETDISPINFOA;

            pitem = &(((TV_DISPINFOW *)pnmhdr)->item);

            if ((pitem->mask & TVIF_TEXT) && !IsFlagPtr(pitem->pszText) && pitem->cchTextMax) {
                pvThunk1 = pitem->pszText;
                dwThunkSize = pitem->cchTextMax;
                pvThunk2 = LocalAlloc(LPTR, pitem->cchTextMax * sizeof(char));
                pitem->pszText = pvThunk2;
                pitem->pszText[0] = TEXT('\0');
            }

            break;
        }
#endif

        case HDN_ITEMCHANGINGW:
            pnmhdr->code = HDN_ITEMCHANGINGA;
            bSet = TRUE;
            // fall through

        case HDN_ITEMCHANGEDW:
            if (!bSet) {
                pnmhdr->code = HDN_ITEMCHANGEDA;
                bSet = TRUE;
            }
            // fall through

        case HDN_ITEMCLICKW:
            if (!bSet) {
                pnmhdr->code = HDN_ITEMCLICKA;
                bSet = TRUE;
            }
            // fall through

        case HDN_ITEMDBLCLICKW:
            if (!bSet) {
                pnmhdr->code = HDN_ITEMDBLCLICKA;
                bSet = TRUE;
            }
            // fall through

        case HDN_DIVIDERDBLCLICKW:
            if (!bSet) {
                pnmhdr->code = HDN_DIVIDERDBLCLICKA;
                bSet = TRUE;
            }
            // fall through

        case HDN_BEGINTRACKW:
            if (!bSet) {
                pnmhdr->code = HDN_BEGINTRACKA;
                bSet = TRUE;
            }
            // fall through

        case HDN_ENDTRACKW:
            if (!bSet) {
                pnmhdr->code = HDN_ENDTRACKA;
                bSet = TRUE;
            }
            // fall through

        case HDN_TRACKW: {
            HD_ITEMW *pitem;

            if (!bSet) {
                pnmhdr->code = HDN_TRACKA;
            }

            pitem = ((HD_NOTIFY *)pnmhdr)->pitem;

            if ( !IsFlagPtr(pitem) && (pitem->mask & HDI_TEXT) && !IsFlagPtr(pitem->pszText)) {
                pvThunk1 = pitem->pszText;
                dwThunkSize = pitem->cchTextMax;
                pitem->pszText = (LPWSTR)ProduceAFromW(pci->uiCodePage, pvThunk1);
            }


            if ( !IsFlagPtr(pitem) && (pitem->mask & HDI_FILTER) && pitem->pvFilter )
            {
                if ( !(pitem->type & HDFT_HASNOVALUE) &&
                        ((pitem->type & HDFT_ISMASK)==HDFT_ISSTRING) )
                {
                    LPHD_TEXTFILTER ptextFilter = (LPHD_TEXTFILTER)pitem->pvFilter;
                    pvThunk2 = ptextFilter->pszText;
                    dwThunkSize = ptextFilter->cchTextMax;
                    ptextFilter->pszText = (LPWSTR)ProduceAFromW(pci->uiCodePage, pvThunk2);
                }
            }


            break;
        }

        case CBEN_ENDEDITW:
        {
            LPNMCBEENDEDITW peew = (LPNMCBEENDEDITW) pnmhdr;
            LPNMCBEENDEDITA peea = LocalAlloc(LPTR, sizeof(NMCBEENDEDITA));

            if (!peea)
               return 0;

            peea->hdr  = peew->hdr;
            peea->hdr.code = CBEN_ENDEDITA;

            peea->fChanged = peew->fChanged;
            peea->iNewSelection = peew->iNewSelection;
            peea->iWhy = peew->iWhy;
            ConvertWToAN(pci->uiCodePage, peea->szText, ARRAYSIZE(peea->szText),
                         peew->szText, -1);

            pvThunk1 = pnmhdr;
            pnmhdr = &peea->hdr;
            ASSERT((LPVOID)pnmhdr == (LPVOID)peea);
            break;
        }

        case CBEN_DRAGBEGINW:
        {
            LPNMCBEDRAGBEGINW pdbw = (LPNMCBEDRAGBEGINW) pnmhdr;
            LPNMCBEDRAGBEGINA pdba = LocalAlloc(LPTR, sizeof(NMCBEDRAGBEGINA));

            if (!pdba)
               return 0;

            pdba->hdr  = pdbw->hdr;
            pdba->hdr.code = CBEN_DRAGBEGINA;
            pdba->iItemid = pdbw->iItemid;
            ConvertWToAN(pci->uiCodePage, pdba->szText, ARRAYSIZE(pdba->szText),
                         pdbw->szText, -1);

            pvThunk1 = pnmhdr;
            pnmhdr = &pdba->hdr;
            ASSERT((LPVOID)pnmhdr == (LPVOID)pdba);
            break;
        }


        case CBEN_GETDISPINFOW: {
            PNMCOMBOBOXEXW pnmcbe = (PNMCOMBOBOXEXW)pnmhdr;

            pnmhdr->code = CBEN_GETDISPINFOA;

            if (pnmcbe->ceItem.mask  & CBEIF_TEXT
                && !IsFlagPtr(pnmcbe->ceItem.pszText) && pnmcbe->ceItem.cchTextMax) {
                pvThunk1 = pnmcbe->ceItem.pszText;
                dwThunkSize = pnmcbe->ceItem.cchTextMax;
                pvThunk2 = LocalAlloc(LPTR, pnmcbe->ceItem.cchTextMax * sizeof(char));
                pnmcbe->ceItem.pszText = pvThunk2;
                pnmcbe->ceItem.pszText[0] = TEXT('\0');
            }

            break;
        }

        case HDN_GETDISPINFOW: {
            LPNMHDDISPINFOW pHDDispInfoW;

            pnmhdr->code = HDN_GETDISPINFOA;

            pHDDispInfoW = (LPNMHDDISPINFOW) pnmhdr;

            pvThunk1 = pHDDispInfoW->pszText;
            dwThunkSize = pHDDispInfoW->cchTextMax;
            pHDDispInfoW->pszText = LocalAlloc (LPTR, pHDDispInfoW->cchTextMax * sizeof(char));

            if (!pHDDispInfoW->pszText) {
                pHDDispInfoW->pszText = (LPWSTR) pvThunk1;
                break;
            }

            WideCharToMultiByte(pci->uiCodePage, 0, (LPWSTR)pvThunk1, -1,
                               (LPSTR)pHDDispInfoW->pszText, pHDDispInfoW->cchTextMax,
                               NULL, NULL);
            break;
        }


        case TBN_GETBUTTONINFOW:
            {
            LPTBNOTIFYW pTBNW;

            pnmhdr->code = TBN_GETBUTTONINFOA;

            pTBNW = (LPTBNOTIFYW)pnmhdr;

            pvThunk1 = pTBNW->pszText;
            dwThunkSize = pTBNW->cchText;
            pvThunk2 = LocalAlloc (LPTR, pTBNW->cchText * sizeof(char));

            if (!pvThunk2) {
                break;
            }
            pTBNW->pszText = pvThunk2;

            WideCharToMultiByte(pci->uiCodePage, 0, (LPWSTR)pvThunk1, -1,
                               (LPSTR)pTBNW->pszText, pTBNW->cchText,
                               NULL, NULL);

            }
            break;

        case TTN_NEEDTEXTW:
            {
            LPTOOLTIPTEXTA lpTTTA;
            LPTOOLTIPTEXTW lpTTTW = (LPTOOLTIPTEXTW) pnmhdr;

            lpTTTA = LocalAlloc(LPTR, sizeof(TOOLTIPTEXTA));

            if (!lpTTTA)
               return 0;

            lpTTTA->hdr = lpTTTW->hdr;
            lpTTTA->hdr.code = TTN_NEEDTEXTA;

            lpTTTA->lpszText = lpTTTA->szText;
            lpTTTA->hinst    = lpTTTW->hinst;
            lpTTTA->uFlags   = lpTTTW->uFlags;
            lpTTTA->lParam   = lpTTTW->lParam;

            WideCharToMultiByte(pci->uiCodePage, 0, lpTTTW->szText, -1, lpTTTA->szText, ARRAYSIZE(lpTTTA->szText), NULL, NULL);
            pvThunk1 = pnmhdr;
            pnmhdr = (NMHDR FAR *)lpTTTA;
            }
            break;

        case DTN_USERSTRINGW:
            {
            LPNMDATETIMESTRINGW lpDateTimeString = (LPNMDATETIMESTRINGW) pnmhdr;

            pnmhdr->code = DTN_USERSTRINGA;

            pvThunk1 = ProduceAFromW(pci->uiCodePage, lpDateTimeString->pszUserString);
            lpDateTimeString->pszUserString = (LPWSTR) pvThunk1;
            }
            break;

        case DTN_WMKEYDOWNW:
            {
            LPNMDATETIMEWMKEYDOWNW lpDateTimeWMKeyDown =
                                               (LPNMDATETIMEWMKEYDOWNW) pnmhdr;

            pnmhdr->code = DTN_WMKEYDOWNA;

            pvThunk1 = ProduceAFromW(pci->uiCodePage, lpDateTimeWMKeyDown->pszFormat);
            lpDateTimeWMKeyDown->pszFormat = (LPWSTR) pvThunk1;
            }
            break;

        case DTN_FORMATQUERYW:
            {
            LPNMDATETIMEFORMATQUERYW lpDateTimeFormatQuery =
                                               (LPNMDATETIMEFORMATQUERYW) pnmhdr;

            pnmhdr->code = DTN_FORMATQUERYA;

            pvThunk1 = ProduceAFromW(pci->uiCodePage, lpDateTimeFormatQuery->pszFormat);
            lpDateTimeFormatQuery->pszFormat = (LPWSTR) pvThunk1;
            }
            break;

        case DTN_FORMATW:
            {
            LPNMDATETIMEFORMATW lpDateTimeFormat =
                                               (LPNMDATETIMEFORMATW) pnmhdr;

            pnmhdr->code = DTN_FORMATA;

            pvThunk1 = ProduceAFromW(pci->uiCodePage, lpDateTimeFormat->pszFormat);
            lpDateTimeFormat->pszFormat = (LPWSTR) pvThunk1;
            }
            break;

        default:
            fThunked = FALSE;
            break;
        }

#ifdef NEED_WOWGETNOTIFYSIZE_HELPER
        ASSERT(code >= 0 || WOWGetNotifySize(code));
#endif // NEED_WOWGETNOTIFYSIZE_HELPER

        lRet = SendMessage(hwndParent, WM_NOTIFY, (WPARAM)id, (LPARAM)pnmhdr);

        /*
         * All the thunking for Notify Messages happens here
         */
        if (fThunked)
        {
        switch(pnmhdr->code) {
        case LVN_ODFINDITEMA:
        case LVN_INCREMENTALSEARCHA:
            {
                LV_FINDINFO *plvfi = &((PNM_FINDITEM)pnmhdr)->lvfi;
                if (pvThunk1)
                {
                    FreeProducedString((LPWSTR)plvfi->psz);
                    plvfi->psz = pvThunk1;
                }
            }
            break;

        case LVN_GETDISPINFOA:
            {
                LV_ITEMA *pitem = &(((LV_DISPINFOA *)pnmhdr)->item);

                // BUGBUG what if pointer is to large buffer?
                if (!IsFlagPtr(pitem) && (pitem->mask & LVIF_TEXT) && !IsFlagPtr(pitem->pszText))
                {
                    StringBufferAtoW(pci->uiCodePage, pvThunk1, dwThunkSize, &pitem->pszText);
                }
            }
            break;

        case LVN_ENDLABELEDITA:
        case LVN_BEGINLABELEDITA:
        case LVN_SETDISPINFOA:
        case LVN_GETEMPTYTEXTA:
            {
                LV_ITEMA *pitem = &(((LV_DISPINFOA *)pnmhdr)->item);
                InOutAtoW(pci, &ts, &pitem->pszText);
            }
            break;

        case LVN_GETINFOTIPA:
            {
                NMLVGETINFOTIPA *pgit = (NMLVGETINFOTIPA *)pnmhdr;
                InOutAtoW(pci, &ts, &pgit->pszText);
            }
            break;

        case TVN_GETINFOTIPA:
            {
                NMTVGETINFOTIPA *pgit = (NMTVGETINFOTIPA *)pnmhdr;
                StringBufferAtoW(pci->uiCodePage, pvThunk1, dwThunkSize, &pgit->pszText);
            }
            break;

        case TBN_GETINFOTIPA:
            {
                NMTBGETINFOTIPA *pgit = (NMTBGETINFOTIPA *)pnmhdr;
                StringBufferAtoW(pci->uiCodePage, pvThunk1, dwThunkSize, &pgit->pszText);
            }
            break;
        case TVN_SELCHANGINGA:
        case TVN_SELCHANGEDA:
        case TVN_DELETEITEMA: {
            LPTV_ITEMW pitem;

            if ( !IsFlagPtr(pvThunk2) ) {
                pitem = &(((LPNM_TREEVIEWW)pnmhdr)->itemOld);

                FreeProducedString(pitem->pszText);
                pitem->pszText = pvThunk2;
            }

            // if this is delitem, then we are done
            if (code == TVN_DELETEITEM)
                break;

            /* FALL THROUGH TO TVN_ITEMEXPANDING to unthunk itemNew */
        }
            // fall through

        case TVN_ITEMEXPANDINGA:
        case TVN_ITEMEXPANDEDA:
        case TVN_BEGINDRAGA:
        case TVN_BEGINRDRAGA: {
            /* these msgs have a NM_TREEVIEW with itemNew TV_ITEM filled in */
            LPTV_ITEMW pitem;

            if (!IsFlagPtr(pvThunk1)) {
                pitem = &(((LPNM_TREEVIEWW)pnmhdr)->itemNew);

                FreeProducedString(pitem->pszText);
                pitem->pszText = pvThunk1;
            }

            break;
        }

        case TVN_SETDISPINFOA:
        case TVN_BEGINLABELEDITA:
        case TVN_ENDLABELEDITA:
            {
                LPTV_ITEMA pitem;
                pitem = &(((TV_DISPINFOA *)pnmhdr)->item);
                InOutAtoW(pci, &ts, &pitem->pszText);
            }
            break;

        case TVN_GETDISPINFOA: {
            /*
             * This message has a TV_DISPINFO in lParam that wass filled in
             * during the callback and needs to be unthunked.
             */
            LPTV_ITEMW pitem;

            pitem = &(((TV_DISPINFOW *)pnmhdr)->item);

            if (!IsFlagPtr(pvThunk1) && (pitem->mask & TVIF_TEXT) && !IsFlagPtr(pitem->pszText)) {
                ConvertAToWN(pci->uiCodePage, pvThunk1, dwThunkSize, (LPSTR)pitem->pszText, -1);
                pitem->pszText = pvThunk1;
                LocalFree(pvThunk2);
            }

            break;
        }

        case HDN_ITEMCHANGINGA:
        case HDN_ITEMCHANGEDA:
        case HDN_ITEMCLICKA:
        case HDN_ITEMDBLCLICKA:
        case HDN_DIVIDERDBLCLICKA:
        case HDN_BEGINTRACKA:
        case HDN_ENDTRACKA:
        case HDN_TRACKA: {
            HD_ITEMW *pitem;

            pitem = ((HD_NOTIFY *)pnmhdr)->pitem;

            if ( !IsFlagPtr(pitem) && (pitem->mask & HDI_TEXT) && !IsFlagPtr(pvThunk1)) {
                ConvertAToWN(pci->uiCodePage, pvThunk1, dwThunkSize, (LPSTR)(pitem->pszText), -1);

                FreeProducedString(pitem->pszText);
                pitem->pszText = pvThunk1;
            }

            if ( !IsFlagPtr(pitem) && (pitem->mask & HDI_FILTER) && pitem->pvFilter && pvThunk2 )
            {
                if ( !(pitem->type & HDFT_HASNOVALUE) &&
                        ((pitem->type & HDFT_ISMASK)==HDFT_ISSTRING) )
                {
                    LPHD_TEXTFILTER ptextFilter = (LPHD_TEXTFILTER)pitem->pvFilter;
                    ConvertAToWN(pci->uiCodePage, pvThunk2, dwThunkSize, (LPSTR)(ptextFilter->pszText), -1);
                    FreeProducedString(ptextFilter->pszText);
                    ptextFilter->pszText = pvThunk2;
                }
            }

            break;
        }

        case CBEN_ENDEDITA:
            {
            LPNMCBEENDEDITW peew = (LPNMCBEENDEDITW) pvThunk1;
            LPNMCBEENDEDITA peea = (LPNMCBEENDEDITA) pnmhdr;

            // Don't unthunk the string since that destroys unicode round-trip
            // and the client shouldn't be modifying it anyway.
            // ConvertAToWN(pci->uiCodePage, peew->szText, ARRAYSIZE(peew->szText),
            //              peea->szText, -1);
            LocalFree(peea);
            }
            break;

        case CBEN_DRAGBEGINA:
            {
            LPNMCBEDRAGBEGINW pdbw = (LPNMCBEDRAGBEGINW) pvThunk1;
            LPNMCBEDRAGBEGINA pdba = (LPNMCBEDRAGBEGINA) pnmhdr;

            // Don't unthunk the string since that destroys unicode round-trip
            // and the client shouldn't be modifying it anyway.
            // ConvertAToWN(pci->uiCodePage, pdbw->szText, ARRAYSIZE(pdbw->szText),
            //              pdba->szText, -1);
            LocalFree(pdba);
            }
            break;

        case CBEN_GETDISPINFOA:
        {
            PNMCOMBOBOXEXW pnmcbeW;

            pnmcbeW = (PNMCOMBOBOXEXW)pnmhdr;
            ConvertAToWN(pci->uiCodePage, pvThunk1, dwThunkSize, (LPSTR)(pnmcbeW->ceItem.pszText), -1);

            if (pvThunk2)
                LocalFree(pvThunk2);
            pnmcbeW->ceItem.pszText = pvThunk1;

        }
            break;


        case HDN_GETDISPINFOA:
            {
            LPNMHDDISPINFOW pHDDispInfoW;

            pHDDispInfoW = (LPNMHDDISPINFOW)pnmhdr;
            ConvertAToWN(pci->uiCodePage, pvThunk1, dwThunkSize, (LPSTR)(pHDDispInfoW->pszText), -1);

            LocalFree(pHDDispInfoW->pszText);
            pHDDispInfoW->pszText = pvThunk1;

            }
            break;

        case TBN_GETBUTTONINFOA:
            {
            LPTBNOTIFYW pTBNW;

            pTBNW = (LPTBNOTIFYW)pnmhdr;
            ConvertAToWN(pci->uiCodePage, pvThunk1, dwThunkSize, (LPSTR)(pTBNW->pszText), -1);

            pTBNW->pszText = pvThunk1;
            LocalFree(pvThunk2);

            }
            break;


        case TTN_NEEDTEXTA:
            {
            LPTOOLTIPTEXTA lpTTTA = (LPTOOLTIPTEXTA) pnmhdr;
            LPTOOLTIPTEXTW lpTTTW = (LPTOOLTIPTEXTW) pvThunk1;

            ThunkToolTipTextAtoW (lpTTTA, lpTTTW, pci->uiCodePage);
            LocalFree(lpTTTA);
            }
            break;

        case DTN_USERSTRINGA:
        case DTN_WMKEYDOWNA:
        case DTN_FORMATQUERYA:
            {
            FreeProducedString (pvThunk1);
            }
            break;

        case DTN_FORMATA:
            {
            LPNMDATETIMEFORMATA lpDateTimeFormat = (LPNMDATETIMEFORMATA) pnmhdr;

            FreeProducedString (pvThunk1);

            //
            // pszDisplay and szDisplay are special cases.
            //

            if (lpDateTimeFormat->pszDisplay && *lpDateTimeFormat->pszDisplay) {

                //
                // if pszDisplay still points at szDisplay then thunk
                // in place.  Otherwise allocate memory and copy the
                // display string.  This buffer will be freeded in monthcal.c
                //

                if (lpDateTimeFormat->pszDisplay == lpDateTimeFormat->szDisplay) {
                    CHAR szDisplay[64];

                    lstrcpynA (szDisplay, lpDateTimeFormat->szDisplay, 64);

                    ConvertAToWN (pci->uiCodePage, (LPWSTR)lpDateTimeFormat->szDisplay, 64,
                                  szDisplay, -1);
                } else {
                    lpDateTimeFormat->pszDisplay =
                             (LPSTR) ProduceWFromA (pci->uiCodePage, lpDateTimeFormat->pszDisplay);
                }

            }

            }
            break;

        default:
            /* No thunking needed */
            break;
        }
        }
        return lRet;
    } else
#endif
        return(SendMessage(hwndParent, WM_NOTIFY, (WPARAM)id, (LPARAM)pnmhdr));

#undef pvThunk1
#undef pvThunk2
#undef dwThunkSize
}

LRESULT WINAPI SendNotify(HWND hwndTo, HWND hwndFrom, int code, NMHDR FAR* pnmhdr)
{
    CONTROLINFO ci;
    ci.hwndParent = hwndTo;
    ci.hwnd = hwndFrom;
    ci.bUnicode = FALSE;
    ci.uiCodePage = CP_ACP;

    //
    // SendNotify is obsolete.  New code should call CCSendNotify
    // instead.  However, if something does call SendNotify,
    // it will call SendNotifyEx with FALSE as the Unicode parameter,
    // because it probably is ANSI code.
    //

    return CCSendNotify(&ci, code, pnmhdr);
}


DWORD NEAR PASCAL CICustomDrawNotify(LPCONTROLINFO lpci, DWORD dwStage, LPNMCUSTOMDRAW lpnmcd)
{
    DWORD dwRet = CDRF_DODEFAULT;


    // bail if...


    // this is an item notification, but an item notification wasn't asked for
    if ((dwStage & CDDS_ITEM) && !(lpci->dwCustom & CDRF_NOTIFYITEMDRAW)) {
        return dwRet;
    }

    lpnmcd->dwDrawStage = dwStage;
    dwRet = (DWORD) CCSendNotify(lpci, NM_CUSTOMDRAW, &lpnmcd->hdr);

    // validate the flags
    if (dwRet & ~CDRF_VALIDFLAGS)
        return CDRF_DODEFAULT;

    return dwRet;
}

//
//  Too many apps encounter strange behavior when we send out
//  NM_CUSTOMDRAW messages at times unrelated to painting.
//  E.g., NetMeeting and MFC recurse back into ListView_RecomputeLabelSize.
//  CryptUI will fault if it's asked to NM_CUSTOMDRAW before it gets
//  WM_INITDIALOG.  So all this fake customdraw stuff is v5 only.
//
//  And since it is very popular to call back into the control during
//  the handling of NM_CUSTOMDRAW, we protect against recursing ourselves
//  to death by blowing off nested fake customdraw messages.


DWORD CIFakeCustomDrawNotify(LPCONTROLINFO lpci, DWORD dwStage, LPNMCUSTOMDRAW lpnmcd)
{
    DWORD dwRet = CDRF_DODEFAULT;

    if (lpci->iVersion >= 5 && !lpci->bInFakeCustomDraw)
    {
        lpci->bInFakeCustomDraw = TRUE;
        dwRet = CICustomDrawNotify(lpci, dwStage, lpnmcd);
        ASSERT(lpci->bInFakeCustomDraw);
        lpci->bInFakeCustomDraw = FALSE;
    }

    return dwRet;
}

/*----------------------------------------------------------
Purpose: Release the capture and tell the parent we've done so.

Returns: Whether the control is still alive.
*/
BOOL CCReleaseCapture(CONTROLINFO * pci)
{
    HWND hwndCtl = pci->hwnd;
    NMHDR nmhdr = {0};

    ReleaseCapture();

    // Tell the parent we've released the capture
    CCSendNotify(pci, NM_RELEASEDCAPTURE, &nmhdr);

    return IsWindow(hwndCtl);
}


/*----------------------------------------------------------
Purpose: Set the capture.  If the hwndSet is NULL, it means
         the capture is being released, so tell the parent
         we've done so.

         Use this function if there's a possibility that the
         hwnd may be NULL.

*/
void CCSetCapture(CONTROLINFO * pci, HWND hwndSet)
{
    SetCapture(hwndSet);

    if (NULL == hwndSet)
    {
        NMHDR nmhdr = {0};

        // Tell the parent we've released the capture
        CCSendNotify(pci, NM_RELEASEDCAPTURE, &nmhdr);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\mru.c ===
#include "ctlspriv.h"
#include <memory.h>

//// BUGBUG:  cpls's main is the only 16 bit guy to use this.  punt him

#define MRU_ORDERDIRTY 0x1000

#define DM_MRULAZY  DM_TRACE

#define MAX_CHAR    126
#define BASE_CHAR   TEXT('a')

typedef struct tagMRUDATA
{
    UINT fFlags;
    UINT uMax;
    LPVOID lpfnCompare;
    HKEY hKey;
#ifdef DEBUG
    TCHAR szSubKey[32];
#endif
    LPTSTR cOrder;
} MRUDATA, *PMRUDATA;

#define c_szMRU     TEXT("MRUList")

#define NTHSTRING(p, n) (*((LPTSTR FAR *)((LPBYTE)p+sizeof(MRUDATA))+n))
#define NTHDATA(p, n) (*((LPBYTE FAR *)((LPBYTE)p+sizeof(MRUDATA))+n))
#define NUM_OVERHEAD 3


#ifdef VSTF

/*----------------------------------------------------------
Purpose: Validate the MRU structure
*/
BOOL IsValidPMRUDATA(PMRUDATA pmru)
{
    return (IS_VALID_WRITE_PTR(pmru, MRUDATA) &&
            (NULL == pmru->lpfnCompare || IS_VALID_CODE_PTR(pmru->lpfnCompare, void)));
}

#endif // VSTF

//----------------------------------------------------------------------------
// Internal memcmp - saves loading crt's, cdecl so we can use
// as MRUCMPDATAPROC

int CDECL _mymemcmp(const void *pBuf1, const void *pBuf2, size_t cb)
{
    // Take advantage of the intrinsic version from crtfree.h
    return memcmp(pBuf1, pBuf2, cb);
}


// Use this macro to get the original size of the data.
#define DATASIZE(p)     (*((LPDWORD)p))
// And this to get a pointer to the original data.
#define DATAPDATA(p)    (p+sizeof(DWORD))

//----------------------------------------------------------------------------
//  For binary data we stick the size of the data at the begining and store the
//  whole thing in one go.
BOOL MRUIsSameData(PMRUDATA pMRU, BYTE FAR* pVal, const void FAR *lpData, UINT cbData)
{
    int cbUseSize;
    MRUCMPDATAPROC lpfnCompare;

    ASSERT(IS_VALID_STRUCT_PTR(pMRU, MRUDATA));

    lpfnCompare = pMRU->lpfnCompare;

    ASSERT(IS_VALID_CODE_PTR(lpfnCompare, MRUCMPDATAPROC));

    // if there's something other than a mem compare,
    // don't require the sizes to be equal in order for the
    // data to be equivalent.

    if (pMRU->lpfnCompare == _mymemcmp)
    {
        if (DATASIZE(pVal) != cbData)
            return FALSE;

        cbUseSize = cbData;
    }
    else
        cbUseSize = min(DATASIZE(pVal), cbData);

    return ((*lpfnCompare)(lpData, DATAPDATA(pVal), cbUseSize) == 0);
}


//----------------------------------------------------------------------------
HANDLE WINAPI CreateMRUListLazy(LPMRUINFO lpmi, const void FAR *lpData, UINT cbData, LPINT lpiSlot)
{
    HANDLE hMRU = NULL;
    PTSTR pOrder, pNewOrder, pTemp;
    LPBYTE pVal;
    LONG cbVal;
    DWORD dwDisposition;
    DWORD dwType;
    PMRUDATA pMRU = NULL;
    HKEY hkeySubKey = NULL;
    TCHAR szTemp[2];
    UINT uMax = lpmi->uMax;
    HKEY hKey = lpmi->hKey;
    LPCTSTR lpszSubKey = lpmi->lpszSubKey;
    MRUCMPPROC lpfnCompare = lpmi->lpfnCompare;
    int cb;

#ifdef DEBUG
    DWORD dwStart = GetTickCount();
#endif
    if (!lpfnCompare) {
        lpfnCompare = (lpmi->fFlags & MRU_BINARY) ? (MRUCMPPROC)_mymemcmp :
                      (
#ifdef UNICODE
                       (lpmi->fFlags & MRU_ANSI) ? (MRUCMPPROC)lstrcmpiA :
#endif
                       (MRUCMPPROC)lstrcmpi
                      );
    }

    //  limit to 126 so that we don't use extended chars
    if (uMax > MAX_CHAR-BASE_CHAR)
        uMax = MAX_CHAR-BASE_CHAR;

    if (RegCreateKeyEx(hKey, lpszSubKey, 0L, (LPTSTR)c_szShell, REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkeySubKey, &dwDisposition) != ERROR_SUCCESS)
        goto Error1;

    pOrder = (PTSTR)Alloc((uMax + 1) * sizeof(TCHAR));
    if (!pOrder)
        goto Error1;

    cbVal = ((LONG)uMax + 1) * sizeof(TCHAR);

    if (RegQueryValueEx(hkeySubKey, (LPTSTR)c_szMRU, NULL, &dwType, (LPBYTE)pOrder, &cbVal) != ERROR_SUCCESS)
    {
        // if not already in the registry, then start fresh
        *pOrder = 0;
    }

    // Uppercase is not allowed
#ifdef UNICODE
    CharLower(pOrder);
#else
    AnsiLower(pOrder);
#endif

    // We allocate room for the MRUDATA structure, plus the order list,
    // and the list of strings.
    cb = (lpmi->fFlags & MRU_BINARY) ? sizeof(LPBYTE) : sizeof(LPTSTR);
    pMRU = (PMRUDATA)Alloc(sizeof(MRUDATA)+(uMax*cb));
    if (!pMRU) {
        goto Error2;
    }

    // Allocate space for the order list
    pMRU->cOrder = (LPTSTR)Alloc((uMax+1)*sizeof(TCHAR));
    if (!pMRU->cOrder) {
        Free(pMRU);
        goto Error2;
    }

    pMRU->fFlags = lpmi->fFlags;
    pMRU->uMax = uMax;
    pMRU->lpfnCompare = lpfnCompare;
    pMRU->hKey = hkeySubKey;
#ifdef DEBUG
    lstrcpyn(pMRU->szSubKey, lpszSubKey, ARRAYSIZE(pMRU->szSubKey));
#endif

    // Traverse through the MRU list, adding strings to the end of the
    // list.
    szTemp[1] = TEXT('\0');
    for (pTemp = pOrder, pNewOrder = pMRU->cOrder; ; ++pTemp)
    {
        // Stop when we get to the end of the list.
        szTemp[0] = *pTemp;
        if (!szTemp[0]) {
            break;
        }

        if (lpmi->fFlags & MRU_BINARY) {
            // Check if in range and if we have already used this letter.
            if ((UINT)(szTemp[0]-BASE_CHAR)>=uMax || NTHDATA(pMRU, szTemp[0]-BASE_CHAR)) {
                continue;
            }
            // Get the value from the registry
            cbVal = 0;
            // first find the size
            if ((RegQueryValueEx(hkeySubKey, szTemp, NULL, &dwType, NULL, &cbVal)
                 != ERROR_SUCCESS) || (dwType != REG_BINARY))
                continue;

            // Binary data has the size at the begining so we'll need a little extra room.
            pVal = (LPBYTE)Alloc(cbVal + sizeof(DWORD));

            if (!pVal) {
                // BUGBUG perhaps sort of error is in order.
                continue;
            }

            // now really get it
            DATASIZE(pVal) = cbVal;
            if (RegQueryValueEx(hkeySubKey, szTemp, NULL, &dwType, pVal+sizeof(DWORD),
                                (LPDWORD)pVal) != ERROR_SUCCESS)
                continue;

            // Note that blank elements ARE allowed in the list.
            NTHDATA(pMRU, szTemp[0]-BASE_CHAR) = pVal;
            *pNewOrder++ = szTemp[0];

            //
            // OPTIMIZATION
            //   If lpData and lpiSlot are specified, we stop the enumeratation
            //  when we find the item.
            //
            if (lpData && lpiSlot) {
                // Check if we have the specified one or not.
                if (MRUIsSameData(pMRU, pVal, lpData, cbData)) {
                    // Found it.
                    *lpiSlot = (INT) (pNewOrder - pMRU->cOrder);

                    TraceMsg(DM_MRULAZY, "CreateMRUListLazy found it. Copying %s", pTemp);

                    pMRU->fFlags |= MRU_LAZY;
                    //
                    // Copy the rest of slot. Notice that we don't load
                    // data for those slot.
                    //
                    for (pTemp++; *pTemp; pTemp++) {
                        *pNewOrder++ = *pTemp;
                    }
                    break;
                }
            }
        } else {

            // Check if in range and if we have already used this letter.
            if ((UINT)(szTemp[0]-BASE_CHAR)>=uMax || NTHSTRING(pMRU, szTemp[0]-BASE_CHAR)) {
                continue;
            }
            // Get the value from the registry
            cbVal = 0;
            // first find the size
            if ((RegQueryValueEx(hkeySubKey, szTemp, NULL, &dwType, NULL, &cbVal)
                 != ERROR_SUCCESS) || (dwType != REG_SZ))
                continue;

            cbVal *= sizeof(TCHAR);
            pVal = (LPBYTE)Alloc(cbVal);

            if (!pVal) {
                // BUGBUG perhaps sort of error is in order.
                continue;
            }
            // now really get it
            if (RegQueryValueEx(hkeySubKey, szTemp, NULL, &dwType, (LPBYTE)pVal, &cbVal) != ERROR_SUCCESS)
                continue;

            // Note that blank elements are not allowed in the list.
            if (*((LPTSTR)pVal)) {
                NTHSTRING(pMRU, szTemp[0]-BASE_CHAR) = (LPTSTR)pVal;
                *pNewOrder++ = szTemp[0];
            } else {
                Free(pVal);
            }
        }
    }
    /* NULL terminate the order list so we can tell how many strings there
     * are.
     */
    *pNewOrder = TEXT('\0');

    if (lpData && lpiSlot) {
        TraceMsg(DM_MRULAZY, "CreateMRUListLazy. End of loop. %s", pMRU->cOrder);
        // If we failed to find, put -1 in it.
        if (!(pMRU->fFlags & MRU_LAZY)) {
            *lpiSlot = -1;
        }
    }

    /* Actually, this is success rather than an error.
     */
    goto Error2;

Error2:
    if (pOrder)
        Free((HLOCAL)pOrder);

Error1:
    if (!pMRU && hkeySubKey)
        RegCloseKey(hkeySubKey);

#ifdef DEBUG
    //DebugMsg(DM_TRACE, TEXT("CreateMRU: %d msec"), LOWORD(GetTickCount()-dwStart));
#endif
    return((HANDLE)pMRU);
}

HANDLE WINAPI CreateMRUList(LPMRUINFO lpmi)
{
    return CreateMRUListLazy(lpmi, NULL, 0, NULL);
}

#ifdef UNICODE

//
// ANSI thunk
//

HANDLE WINAPI CreateMRUListLazyA(LPMRUINFOA lpmi, const void FAR *lpData, UINT cbData, LPINT lpiSlot)
{
    MRUINFOW MRUInfoW;
    HANDLE hMRU;

    MRUInfoW.cbSize       = sizeof (MRUINFOW);
    MRUInfoW.uMax         = lpmi->uMax;
    MRUInfoW.fFlags       = lpmi->fFlags;
    MRUInfoW.hKey         = lpmi->hKey;
    MRUInfoW.lpszSubKey   = ProduceWFromA(CP_ACP, lpmi->lpszSubKey);
    MRUInfoW.lpfnCompare  = (MRUCMPPROCW)lpmi->lpfnCompare;

    MRUInfoW.fFlags |= MRU_ANSI;

    hMRU = CreateMRUListLazy(&MRUInfoW, lpData, cbData, lpiSlot);

    FreeProducedString((LPWSTR)MRUInfoW.lpszSubKey);

    return hMRU;
}

HANDLE WINAPI CreateMRUListA(LPMRUINFOA lpmi)
{
    return CreateMRUListLazyA(lpmi, NULL, 0, NULL);
}
#else

//
// Unicode stub when this code is built ANSI
//

HANDLE WINAPI CreateMRUListW(LPMRUINFOW lpmi)
{
    SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING);
    return NULL;
}

HANDLE WINAPI CreateMRUListLazyW(LPMRUINFOW lpmi, const void FAR *lpData, UINT cbData, LPINT lpiSlot)
{
    SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING);
    return NULL;
}
#endif


//----------------------------------------------------------------------------
STDAPI_(void) FreeMRUList(HANDLE hMRU)
{
    int i;
    LPVOID FAR *pTemp;
    PMRUDATA pMRU = (PMRUDATA)hMRU;

    ASSERT(IS_VALID_STRUCT_PTR(pMRU, MRUDATA));

    if (pMRU)
    {
        pTemp = (pMRU->fFlags & MRU_BINARY) ?
            &NTHDATA(pMRU, 0) : (LPBYTE FAR *)&NTHSTRING(pMRU, 0);

        if (pMRU->fFlags & MRU_ORDERDIRTY)
        {
            RegSetValueEx(pMRU->hKey, c_szMRU, 0L, REG_SZ, (CONST BYTE *)pMRU->cOrder,
                          sizeof(TCHAR) * (lstrlen(pMRU->cOrder) + 1));
        }

        for (i=pMRU->uMax-1; i>=0; --i, ++pTemp)
        {
            if (*pTemp)
            {
                if (pMRU->fFlags & MRU_BINARY)
                {
                    Free((LPBYTE)*pTemp);
                    *pTemp = NULL;
                }
                else
                    Str_SetPtr((LPTSTR FAR *)pTemp, NULL);
            }
        }
        RegCloseKey(pMRU->hKey);
        Free(pMRU->cOrder);
        Free((HLOCAL)pMRU);
    }
}


/* Add a string to an MRU list.
 */
STDAPI_(int) AddMRUString(HANDLE hMRU, LPCTSTR szString)
{
    /* The extra +1 is so that the list is NULL terminated.
    */
    TCHAR cFirst;
    int iSlot = -1;
    LPTSTR lpTemp;
    LPTSTR FAR * pTemp;
    int i;
    UINT uMax;
    MRUCMPPROC lpfnCompare;
    BOOL fShouldWrite;
    PMRUDATA pMRU = (PMRUDATA)hMRU;

#ifdef DEBUG
    DWORD dwStart = GetTickCount();
#endif

    ASSERT(IS_VALID_STRUCT_PTR(pMRU, MRUDATA));

    if (hMRU == NULL)
        return(-1);     // Error

    fShouldWrite = !(pMRU->fFlags & MRU_CACHEWRITE);
    uMax = pMRU->uMax;
    lpfnCompare = (MRUCMPPROC)pMRU->lpfnCompare;

    /* Check if the string already exists in the list.
    */
    for (i=0, pTemp=&NTHSTRING(pMRU, 0); (UINT)i<uMax; ++i, ++pTemp)
    {
        if (*pTemp)
        {
            int iResult;

#ifdef UNICODE
            if (pMRU->fFlags & MRU_ANSI)
            {
                LPSTR lpStringA, lpTempA;

                lpStringA = ProduceAFromW (CP_ACP, szString);
                lpTempA = ProduceAFromW (CP_ACP, (LPWSTR)*pTemp);

                iResult = (*lpfnCompare)((const void FAR *)lpStringA, (const void FAR *)lpTempA);

                FreeProducedString (lpStringA);
                FreeProducedString (lpTempA);
            }
            else
#endif
            {
                iResult = (*lpfnCompare)((const void FAR *)szString, (const void FAR *)*pTemp);
            }

            if (!iResult)
            {
                // found it, so don't do the write out
                cFirst = i + BASE_CHAR;
                iSlot = i;
                goto FoundEntry;
            }
        }
    }

    /* Attempt to find an unused entry.  Count up the used entries at the
    * same time.
    */
    for (i=0, pTemp=&NTHSTRING(pMRU, 0); ; ++i, ++pTemp)
    {
        if ((UINT)i >= uMax)    // If we got to the end of the list.
        {
            // use the entry at the end of the cOrder list
            cFirst = pMRU->cOrder[uMax-1];
            pTemp = &NTHSTRING(pMRU, cFirst-BASE_CHAR);
            break;
        }

        // Is the entry not used?
        if (!*pTemp)
        {
            // yes
            cFirst = i+BASE_CHAR;
            break;
        }
    }

    if (Str_SetPtr(pTemp, szString))
    {
        TCHAR szTemp[2];

        iSlot = (int)(cFirst-BASE_CHAR);

        szTemp[0] = cFirst;
        szTemp[1] = TEXT('\0');

        RegSetValueEx(pMRU->hKey, szTemp, 0L, REG_SZ, (CONST BYTE *)szString,
            sizeof(TCHAR) * (lstrlen(szString) + 1));

        fShouldWrite = TRUE;
    }
    else
    {
        /* Since iSlot == -1, we will remove the reference to cFirst
        * below.
        */
    }

FoundEntry:
    /* Remove any previous reference to cFirst.
    */
    lpTemp = StrChr(pMRU->cOrder, cFirst);
    if (lpTemp)
    {
        lstrcpy(lpTemp, lpTemp+1);
    }

    if (iSlot != -1)
    {
        // shift everything over and put cFirst at the front
        hmemcpy(pMRU->cOrder+1, pMRU->cOrder, pMRU->uMax*sizeof(TCHAR));
        pMRU->cOrder[0] = cFirst;
    }

    if (fShouldWrite)
    {
        RegSetValueEx(pMRU->hKey, c_szMRU, 0L, REG_SZ, (CONST BYTE *)pMRU->cOrder,
            sizeof(TCHAR) * (lstrlen(pMRU->cOrder) + 1));
        pMRU->fFlags &= ~MRU_ORDERDIRTY;
    } else
        pMRU->fFlags |= MRU_ORDERDIRTY;

#ifdef DEBUG
    // DebugMsg(DM_TRACE, TEXT("AddMRU: %d msec"), LOWORD(GetTickCount()-dwStart));
#endif
    return(iSlot);
}


#ifdef UNICODE
//
// ANSI thunk
//

STDAPI_(int) AddMRUStringA(HANDLE hMRU, LPCSTR szString)
{
    LPWSTR lpStringW;
    INT    iResult;

    lpStringW = ProduceWFromA(CP_ACP, szString);

    iResult = AddMRUString(hMRU, lpStringW);

    FreeProducedString (lpStringW);

    return iResult;
}

#else

//
// Unicode stub when this code is build ANSI
//

STDAPI_(int) AddMRUStringW(HANDLE hMRU, LPCWSTR szString)
{
    SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING);
    return -1;
}

#endif


/* Remove a string from an MRU list.
 */
STDAPI_(int) DelMRUString(HANDLE hMRU, int nItem)
{
    BOOL bRet = FALSE;
    LPTSTR lpTemp;
    PMRUDATA pMRU = (PMRUDATA)hMRU;

    ASSERT(IS_VALID_STRUCT_PTR(pMRU, MRUDATA));

    if (pMRU)
    {
        //
        // Make sure the index value is within the length of
        // the string so we don't pick up some random value.
        //
        if (!InRange(nItem, 0, pMRU->uMax) || nItem >= lstrlen(pMRU->cOrder))
            return FALSE;

        // Be easy -- just remove the entry from the cOrder list
        lpTemp = &pMRU->cOrder[nItem];
        if (lpTemp)
        {
            int iSlot = *lpTemp - BASE_CHAR;
            if (iSlot >= 0 && iSlot < MAX_CHAR - BASE_CHAR)
                Str_SetPtr(&NTHSTRING(pMRU, iSlot), NULL);
            lstrcpy(lpTemp, lpTemp+1);

            if (!(pMRU->fFlags & MRU_CACHEWRITE))
            {
                RegSetValueEx(pMRU->hKey, c_szMRU, 0L, REG_SZ, (CONST BYTE *)pMRU->cOrder,
                              sizeof(TCHAR) * (lstrlen(pMRU->cOrder) + 1));
                pMRU->fFlags &= ~MRU_ORDERDIRTY;
            }
            else
            {
                pMRU->fFlags |= MRU_ORDERDIRTY;
            }

            bRet = TRUE;
        }
    }

    return bRet;
}


//----------------------------------------------------------------------------
// Add data to an MRU list.
STDAPI_(int) AddMRUData(HANDLE hMRU, const void FAR *lpData, UINT cbData)
{
    TCHAR cFirst;
    int iSlot = -1;
    LPTSTR lpTemp;
    LPBYTE FAR *ppData;
    int i;
    UINT uMax;
    MRUCMPDATAPROC lpfnCompare;
    PMRUDATA pMRU = (PMRUDATA)hMRU;
    BOOL fShouldWrite;

#ifdef DEBUG
    DWORD dwStart = GetTickCount();
#endif

    ASSERT(IS_VALID_STRUCT_PTR(pMRU, MRUDATA));

    if (hMRU == NULL)
        return(-1);     // Error

    fShouldWrite = !(pMRU->fFlags & MRU_CACHEWRITE);

    uMax = pMRU->uMax;
    lpfnCompare = (MRUCMPDATAPROC)pMRU->lpfnCompare;

    // Check if the data already exists in the list.
    for (i=0, ppData=&NTHDATA(pMRU, 0); (UINT)i<uMax; ++i, ++ppData)
    {
        if (*ppData && MRUIsSameData(pMRU, *ppData, lpData, cbData))
        {
            // found it, so don't do the write out
            cFirst = i + BASE_CHAR;
            iSlot = i;
            goto FoundEntry;
        }
    }

    //
    // When created "lazy", we are not supposed to add a new item.
    //
    if (pMRU->fFlags & MRU_LAZY)
    {
        ASSERT(0);
        return -1;
    }

    // Attempt to find an unused entry.  Count up the used entries at the
    // same time.
    for (i=0, ppData=&NTHDATA(pMRU, 0); ; ++i, ++ppData)
    {
        if ((UINT)i >= uMax)
            // If we got to the end of the list.
        {
            // use the entry at the end of the cOrder list
            cFirst = pMRU->cOrder[uMax-1];
            ppData = &NTHDATA(pMRU, cFirst-BASE_CHAR);
            break;
        }

        if (!*ppData)
            // If the entry is not used.
        {
            cFirst = i+BASE_CHAR;
            break;
        }
    }

    *ppData = ReAlloc(*ppData, cbData+sizeof(DWORD));
    if (*ppData)
    {
        TCHAR szTemp[2];

        *((LPDWORD)(*ppData)) = cbData;
        hmemcpy(DATAPDATA(*ppData), lpData, cbData);

        iSlot = (int)(cFirst-BASE_CHAR);

        szTemp[0] = cFirst;
        szTemp[1] = TEXT('\0');

        RegSetValueEx(pMRU->hKey, szTemp, 0L, REG_BINARY, (LPVOID)lpData, cbData);
        fShouldWrite = TRUE;
    }
    else
    {
        // Since iSlot == -1, we will remove the reference to cFirst
        // below.
    }

FoundEntry:
    // Remove any previous reference to cFirst.
    lpTemp = StrChr(pMRU->cOrder, cFirst);
    if (lpTemp)
    {
        lstrcpy(lpTemp, lpTemp+1);
    }

    if (iSlot != -1)
    {
        // shift everything over and put cFirst at the front
        hmemcpy(pMRU->cOrder+1, pMRU->cOrder, pMRU->uMax*sizeof(TCHAR));
        pMRU->cOrder[0] = cFirst;
    }

    if (fShouldWrite)
    {
        RegSetValueEx(pMRU->hKey, c_szMRU, 0L, REG_SZ, (CONST BYTE *)pMRU->cOrder,
            sizeof(TCHAR) * (lstrlen(pMRU->cOrder) + 1));
        pMRU->fFlags &= ~MRU_ORDERDIRTY;
    } else
        pMRU->fFlags |= MRU_ORDERDIRTY;

#ifdef DEBUG
    // DebugMsg(DM_TRACE, TEXT("AddMRU: %d msec"), LOWORD(GetTickCount()-dwStart));
#endif
    return(iSlot);
}


//----------------------------------------------------------------------------
// Find data in an MRU list.
// Returns the slot number.
STDAPI_(int) FindMRUData(HANDLE hMRU, const void FAR *lpData, UINT cbData, LPINT lpiSlot)
{
    TCHAR cFirst;
    int iSlot = -1;
    LPTSTR lpTemp;
    LPBYTE FAR *ppData;
    int i;
    UINT uMax;
    PMRUDATA pMRU = (PMRUDATA)hMRU;

#ifdef DEBUG
    DWORD dwStart = GetTickCount();
#endif

    ASSERT(IS_VALID_STRUCT_PTR(pMRU, MRUDATA));

    if (hMRU == NULL)
        return(-1); // Error state.

    // Can't call this API when it's created lazily.
    if (pMRU->fFlags & MRU_LAZY)
    {
        ASSERT(0);
        return -1;
    }

    uMax = pMRU->uMax;

    /* Find the item in the list.
    */
    for (i=0, ppData=&NTHDATA(pMRU, 0); (UINT)i<uMax; ++i, ++ppData)
    {
        if (!*ppData)
            continue;

        if (MRUIsSameData(pMRU, *ppData, lpData, cbData))
        {
            // So i now has the slot number in it.
            if (lpiSlot != NULL)
                *lpiSlot = i;

            // Now convert the slot number into an index number
            cFirst = i + BASE_CHAR;
            lpTemp = StrChr(pMRU->cOrder, cFirst);
            ASSERT(lpTemp);
            return((lpTemp == NULL)? -1 : (int)(lpTemp - (LPTSTR)pMRU->cOrder));
        }
    }

    return -1;
}


/* Find a string in an MRU list.
 */
STDAPI_(int) FindMRUString(HANDLE hMRU, LPCTSTR szString, LPINT lpiSlot)
{
    /* The extra +1 is so that the list is NULL terminated.
    */
    TCHAR cFirst;
    int iSlot = -1;
    LPTSTR lpTemp;
    LPTSTR FAR *pTemp;
    int i;
    UINT uMax;
    MRUCMPPROC lpfnCompare;
    PMRUDATA pMRU = (PMRUDATA)hMRU;

#ifdef DEBUG
    DWORD dwStart = GetTickCount();
#endif

    ASSERT(IS_VALID_STRUCT_PTR(pMRU, MRUDATA));

    if (hMRU == NULL)
        return(-1); // Error state.

    uMax = pMRU->uMax;
    lpfnCompare = (MRUCMPPROC)pMRU->lpfnCompare;

    /* Find the item in the list.
    */
    for (i=0, pTemp=&NTHSTRING(pMRU, 0); (UINT)i<uMax; ++i, ++pTemp)
    {
        if (*pTemp)
        {
            int iResult;

#ifdef UNICODE
            if (pMRU->fFlags & MRU_ANSI)
            {
                LPSTR lpStringA, lpTempA;

                lpStringA = ProduceAFromW (CP_ACP, szString);
                lpTempA = ProduceAFromW (CP_ACP, (LPWSTR)*pTemp);

                iResult = (*lpfnCompare)((const void FAR *)lpStringA, (const void FAR *)lpTempA);

                FreeProducedString (lpStringA);
                FreeProducedString (lpTempA);
            }
            else
#endif
            {
                iResult = (*lpfnCompare)((CONST VOID FAR *)szString, (CONST VOID FAR *)*pTemp);
            }

            if (!iResult)
            {
                // So i now has the slot number in it.
                if (lpiSlot != NULL)
                    *lpiSlot = i;

                // Now convert the slot number into an index number
                cFirst = i + BASE_CHAR;
                lpTemp = StrChr(pMRU->cOrder, cFirst);
                return((lpTemp == NULL)? -1 : (int)(lpTemp - (LPTSTR)pMRU->cOrder));
            }
        }
    }

    return(-1);
}


#ifdef UNICODE
//
// ANSI thunk
//

int WINAPI FindMRUStringA(HANDLE hMRU, LPCSTR szString, LPINT lpiSlot)
{
    LPWSTR lpStringW;
    INT    iResult;

    lpStringW = ProduceWFromA(CP_ACP, szString);

    iResult = FindMRUString(hMRU, lpStringW, lpiSlot);

    FreeProducedString (lpStringW);

    return iResult;
}

#else

//
// Unicode stub when build ANSI
//

int WINAPI FindMRUStringW(HANDLE hMRU, LPCWSTR szString, LPINT lpiSlot)
{
    SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING);
    return -1;
}

#endif

/* If lpszString is NULL, then this returns the number of MRU items or less than
 * 0 on error.
 * if nItem < 0, we'll return the number of items currently in the MRU.
 * Otherwise, fill in as much of the buffer as possible (uLen includes the
 * terminating NULL) and return the actual length of the string (including the
 * terminating NULL) or less than 0 on error.
 */
STDAPI_(int) EnumMRUList(HANDLE hMRU, int nItem, LPVOID lpData, UINT uLen)
{
    PMRUDATA pMRU = (PMRUDATA)hMRU;
    int nItems = -1;
    LPTSTR pTemp;
    LPBYTE pData;

    ASSERT(IS_VALID_STRUCT_PTR(pMRU, MRUDATA));

    if (pMRU)
    {
        nItems = lstrlen(pMRU->cOrder);

        if (nItem < 0 || !lpData)
            return nItems;

        if (nItem < nItems)
        {
            if (pMRU->fFlags & MRU_BINARY)
            {
                pData = NTHDATA(pMRU, pMRU->cOrder[nItem]-BASE_CHAR);
                if (!pData)
                    return -1;

                uLen = min((UINT)DATASIZE(pData), uLen);
                hmemcpy(lpData, DATAPDATA(pData), uLen);

                nItems = uLen;

            }
            else
            {
                pTemp = NTHSTRING(pMRU, pMRU->cOrder[nItem]-BASE_CHAR);
                if (!pTemp)
                    return -1;

                lstrcpyn((LPTSTR)lpData, pTemp, uLen);

                nItems = lstrlen(pTemp);
            }
        }
        else  // revert to error condition
            nItems = -1;
    }

    return nItems;
}


#ifdef UNICODE

STDAPI_(int) EnumMRUListA(HANDLE hMRU, int nItem, LPVOID lpData, UINT uLen)
{
    int iResult = -1;
    PMRUDATA pMRU = (PMRUDATA)hMRU;

    ASSERT(IS_VALID_STRUCT_PTR(pMRU, MRUDATA));

    if (pMRU)
    {
        LPVOID lpDataW;
        BOOL bAllocatedMemory = FALSE;

        //
        //  we need a temp buffer if the data is a string.
        //  but if it is binary, then we trust the callers buffer.
        //
        if (!(pMRU->fFlags & MRU_BINARY) && uLen && lpData)
        {
            lpDataW = LocalAlloc(LPTR, uLen * sizeof(TCHAR));

            if (!lpDataW)
                return -1;

            bAllocatedMemory = TRUE;
        }
        else
            lpDataW = lpData;

        //  call the real thing
        iResult = EnumMRUList(hMRU, nItem, lpDataW, uLen);

        //
        //  if the buffer was a string that we allocated
        //  then we need to thunk the string into the callers buffer
        //
        if (!(pMRU->fFlags & MRU_BINARY) && lpData && uLen && (iResult != -1))
        {
            WideCharToMultiByte(CP_ACP, 0, (LPWSTR)lpDataW, -1,
                (LPSTR)lpData, uLen, NULL, NULL);
        }

        if (bAllocatedMemory)
            LocalFree(lpDataW);
    }

    return iResult;
}

#else

STDAPI_(int) EnumMRUListW(HANDLE hMRU, int nItem, LPVOID lpData, UINT uLen)
{
    SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING);
    return 0;
}

#endif // UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\pager.cpp ===
//---------------------------------------------------------------------------------------
//  File : Pager.cpp
//  Description :
//        This file implements the pager control
//---------------------------------------------------------------------------------------
#include "ctlspriv.h"
#include "pager.h"

#ifdef UNIX
#include "unixstuff.h"
#endif

#define MINBUTTONSIZE   12

//Timer Flags
#define PGT_SCROLL       1

void NEAR DrawScrollArrow(HDC hdc, LPRECT lprc, WORD wControlState);

#ifdef DEBUG
#if 0
extern "C" {
extern void _InvalidateRect(HWND hwnd, LPRECT prc, BOOL fInval);
extern void _RedrawWindow(HWND hwnd, LPRECT prc, HANDLE hrgn, UINT uFlags);
extern void _SetWindowPos(HWND hwnd, HWND hwnd2, int x, int y, int cx, int cy, UINT uFlags);
};
#define InvalidateRect(hwnd, prc, fInval) _InvalidateRect(hwnd, prc, fInval)
#define RedrawWindow(hwnd, prc, hrgn, uFlags) _RedrawWindow(hwnd, prc, hrgn, uFlags)
#define SetWindowPos(hwnd, hwnd2, x, y, cx, cy, uFlags) _SetWindowPos(hwnd, hwnd2, x, y, cx, cy, uFlags)
#endif
#endif

//Public Functions
//---------------------------------------------------------------------------------------
extern "C" {

//This function registers  the pager window class
BOOL InitPager(HINSTANCE hinst)
{
    WNDCLASS wc;
    TraceMsg(TF_PAGER, "Init Pager");

    if (!GetClassInfo(hinst, WC_PAGESCROLLER, &wc)) {
        wc.lpfnWndProc     = CPager::PagerWndProc;
        wc.hCursor         = LoadCursor(NULL, IDC_ARROW);
        wc.hIcon           = NULL;
        wc.lpszMenuName    = NULL;
        wc.hInstance       = hinst;
        wc.lpszClassName   = WC_PAGESCROLLER;
        wc.hbrBackground   = (HBRUSH)(COLOR_BTNFACE + 1); // NULL;
        wc.style           = CS_GLOBALCLASS;
        wc.cbWndExtra      = sizeof(LPVOID);
        wc.cbClsExtra      = 0;

        return RegisterClass(&wc);
    }
    return TRUE;
}

}; // extern "C"

//---------------------------------------------------------------------------------------
CPager::CPager()
{
    _clrBk = g_clrBtnFace;
    
    //Initialize Static Members
    _iButtonSize = (int) g_cxScrollbar * 3 / 4;
    if (_iButtonSize < MINBUTTONSIZE) {
        _iButtonSize = MINBUTTONSIZE;
    }

    _ptLastMove.x = -1;
    _ptLastMove.y = -1;

    _cLinesPerTimeout = 0;
    _cPixelsPerLine = 0;
    _cTimeout = GetDoubleClickTime() / 8;
}

//---------------------------------------------------------------------------------------
// Static Pager Window Procedure


LRESULT CPager::PagerWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CPager *pp = (CPager*)GetWindowPtr(hwnd, 0);
    if (uMsg == WM_CREATE) {
        ASSERT(!pp);
        pp = new CPager();
        if (!pp)
            return 0L;
    }

    if (pp) {
        return pp->v_WndProc(hwnd, uMsg, wParam, lParam);
    }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
//---------------------------------------------------------------------------------------
LRESULT CPager::PagerDragCallback(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CPager *pp = (CPager*)GetWindowPtr(hwnd, 0);

    if (pp) {
        return pp->_DragCallback(hwnd, uMsg, wParam, lParam);
    }
    return -1;
}


//---------------------------------------------------------------------------------------
// CControl Class Implementation
//---------------------------------------------------------------------------------------


LRESULT CControl::v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;
    switch (uMsg) {

    case WM_CREATE:
        CCCreateWindow();
        SetWindowPtr(hwnd, 0, this);
        CIInitialize(&ci, hwnd, (CREATESTRUCT*)lParam);
        return v_OnCreate();

    case WM_NCCALCSIZE:
        if (v_OnNCCalcSize(wParam, lParam, &lres))
            break;
        goto DoDefault;

    case WM_SIZE:
        v_OnSize(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
        break;
        
    case WM_NOTIFYFORMAT:
        return CIHandleNotifyFormat(&ci, lParam);

    case WM_NOTIFY:
        return v_OnNotify(wParam, lParam);
    
    case WM_STYLECHANGED:
        v_OnStyleChanged(wParam, lParam);
        break;

    case WM_COMMAND:
        return v_OnCommand(wParam, lParam);

    case WM_NCPAINT:
        v_OnNCPaint();
        goto DoDefault;

    case WM_PRINTCLIENT:
    case WM_PAINT:
        _OnPaint((HDC)wParam);
        break;
        
    case WM_DESTROY:
        CCDestroyWindow();
        SetWindowLongPtr(hwnd, 0, 0);
        delete this;
        break;

    case TB_SETPARENT:
        {
            HWND hwndOld = ci.hwndParent;

            ci.hwndParent = (HWND)wParam;
            return (LRESULT)hwndOld;
        }


    default:
        if (CCWndProc(&ci, uMsg, wParam, lParam, &lres))
            return lres;
DoDefault:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return lres;
}

//---------------------------------------------------------------------------------------
BOOL CControl::v_OnNCCalcSize(WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    return FALSE;
}

//---------------------------------------------------------------------------------------
DWORD CControl::v_OnStyleChanged(WPARAM wParam, LPARAM lParam)
{
    LPSTYLESTRUCT lpss = (LPSTYLESTRUCT) lParam;
    DWORD dwChanged = 0;    
    if (wParam == GWL_STYLE) {
        ci.style = lpss->styleNew;

        dwChanged = (lpss->styleOld ^ lpss->styleNew);
    } else if (wParam == GWL_EXSTYLE) {
        //
        // Save the new ex-style bits
        //
        dwChanged    = (lpss->styleOld ^ lpss->styleNew);
        ci.dwExStyle = lpss->styleNew;
    }

    TraceMsg(TF_PAGER, "cctl.v_osc: style=%x ret dwChged=%x", ci.style, dwChanged);
    return dwChanged;
}

//---------------------------------------------------------------------------------------
void CControl::_OnPaint(HDC hdc)
{
    if (hdc) {
        v_OnPaint(hdc);
    } else {
        PAINTSTRUCT ps;
        hdc = BeginPaint(ci.hwnd, &ps);
        v_OnPaint(hdc);
        EndPaint(ci.hwnd, &ps);
    }
}

//---------------------------------------------------------------------------------------
//  CPager Class Implementation
//---------------------------------------------------------------------------------------
inline int CPager::_GetButtonSize()
{
    return _iButtonSize;
}

//---------------------------------------------------------------------------------------

LRESULT CPager::_DragCallback(HWND hwnd, UINT code, WPARAM wp, LPARAM lp)
{
    LRESULT lres = -1;
    switch (code)
    {
    case DPX_DRAGHIT:
        if (lp)
        {
            POINT pt; 
            int iButton;
            pt.x = ((POINTL *)lp)->x;
            pt.y = ((POINTL *)lp)->y;

            MapWindowPoints(NULL, ci.hwnd, &pt, 1);

            iButton = _HitTest(pt.x, pt.y);

            if (iButton >= 0) 
            {
                if(!_fTimerSet)
                {
                    _fTimerSet = TRUE;
                    _iButtonTrack = iButton;
                    SetTimer(ci.hwnd, PGT_SCROLL, _cTimeout, NULL);
                }

            } else {
                _KillTimer();
                _iButtonTrack = -1;
            }
        }
        else
            lres = -1;
        break;

    case DPX_LEAVE:
        _KillTimer();
        _iButtonTrack = -1;
        break;

    default: 
        lres = -1;
        break;
    }
    return lres;
}

//---------------------------------------------------------------------------------------
void CPager::_NeedScrollbars(RECT rc)
{  
    int parentheight;
    int childheight;
    POINT ptPos = _ptPos;
   
    if( ci.style & PGS_HORZ ) {
        FlipRect(&rc);
        FlipPoint(&ptPos);
    }
    
    //Get Parent Window height
    parentheight = RECTHEIGHT(rc);

    //Get Child Window height
    rc = _rcChildIdeal;
    if (ci.style & PGS_HORZ ) {
        FlipRect(&rc);
    }
    
    childheight = RECTHEIGHT(rc);

    TraceMsg(TF_PAGER, "cps.nsb: cyChild=%d cyParent=%d _yPos=%d", childheight, parentheight, ptPos.y);

    if (childheight < parentheight ) 
    {
        ptPos.y = 0;
    }

    int iButton = _HitTestCursor();
    //See if we need top scrollbar
    if (ptPos.y > 0 ) {

        // if this button is the one that is hot tracked and the style is not PGS_AUTOSCROLL
        // then we set the state to PGF_HOT otherwise the state is set to PGF_NORMAL
        _dwState[PGB_TOPORLEFT] |= PGF_NORMAL;
        _dwState[PGB_TOPORLEFT] &= ~PGF_GRAYED;

    } else {
        if (!(ci.style & PGS_AUTOSCROLL) && (iButton == PGB_TOPORLEFT || _iButtonTrack == PGB_TOPORLEFT)) {
            _dwState[PGB_TOPORLEFT] |= PGF_GRAYED;
        } else {
            _dwState[PGB_TOPORLEFT] = PGF_INVISIBLE;
        }
    }

    if (_dwState[PGB_TOPORLEFT] != PGF_INVISIBLE)
    {
        parentheight -= _GetButtonSize();
    }
    
    //See if we need botton scrollbar
    if ((childheight - ptPos.y) > parentheight ) {
        //We need botton scroll bar

        // if this button is the one that is hot tracked and the style is not PGS_AUTOSCROLL
        // then we set the state to PGF_HOT otherwise the state is set to PGF_NORMAL
        _dwState[PGB_BOTTOMORRIGHT] |= PGF_NORMAL;
        _dwState[PGB_BOTTOMORRIGHT] &= ~PGF_GRAYED;
        
    } else {
        
        if (!(ci.style & PGS_AUTOSCROLL) && (iButton == PGB_BOTTOMORRIGHT || _iButtonTrack == PGB_BOTTOMORRIGHT)) {
            _dwState[PGB_BOTTOMORRIGHT] |= PGF_GRAYED;
        } else {
            _dwState[PGB_BOTTOMORRIGHT] = PGF_INVISIBLE;
        }
    }
}
//---------------------------------------------------------------------------------------
BOOL CPager::v_OnNCCalcSize(WPARAM wParam, LPARAM lParam, LRESULT *plres)
{    
    *plres = DefWindowProc(ci.hwnd, WM_NCCALCSIZE, wParam, lParam ) ;
    if (wParam) {
        BOOL bHorzMirror = ((ci.dwExStyle & RTL_MIRRORED_WINDOW) && (ci.style & PGS_HORZ));
        DWORD dwStateOld[2];
        NCCALCSIZE_PARAMS* pnp = (NCCALCSIZE_PARAMS*)lParam;
        _rcDefClient = pnp->rgrc[0];
        InflateRect(&_rcDefClient, -_iBorder, -_iBorder);
        _GetChildSize();
        
        dwStateOld[0] = _dwState[0];
        dwStateOld[1] = _dwState[1];
        _NeedScrollbars(pnp->rgrc[0]);

        // invalidate only if something has changed to force a new size
        if ((dwStateOld[0] != _dwState[0] && (dwStateOld[0] == PGF_INVISIBLE || _dwState[0] == PGF_INVISIBLE)) ||
            (dwStateOld[1] != _dwState[1] && (dwStateOld[1] == PGF_INVISIBLE || _dwState[1] == PGF_INVISIBLE)) 
           ) {
            RedrawWindow(ci.hwnd, NULL,NULL,RDW_INVALIDATE|RDW_ERASE);
        }

        // Check and change for horizontal mode
        if( ci.style & PGS_HORZ ) {
            FlipRect(&(pnp->rgrc[0]));
        }
    
        if( _dwState[PGB_TOPORLEFT] != PGF_INVISIBLE ) {
            //
            // Check for RTL mirrored window
            // 
            if (bHorzMirror)
                pnp->rgrc[0].bottom -= _GetButtonSize();
            else
                pnp->rgrc[0].top += _GetButtonSize();
        } else
            pnp->rgrc[0].top += _iBorder;

        if( _dwState[PGB_BOTTOMORRIGHT] != PGF_INVISIBLE ) {
            //
            // Check for RTL mirrored window
            // 
            if (bHorzMirror)
                pnp->rgrc[0].top += _GetButtonSize();
            else
                pnp->rgrc[0].bottom -= _GetButtonSize();
        } else
            pnp->rgrc[0].bottom -= _iBorder;
   
        if (pnp->rgrc[0].bottom < pnp->rgrc[0].top)
            pnp->rgrc[0].bottom = pnp->rgrc[0].top;
        
        //Change back
        if( ci.style & PGS_HORZ ) {
            FlipRect(&(pnp->rgrc[0]));
        }
    }

    return TRUE;
}

int CPager::_HitTestCursor()
{
    POINT pt;
    GetCursorPos(&pt);
    return _HitTestScreen(&pt);
}

int CPager::_HitTestScreen(POINT* ppt)
{
    RECT rc, rc1;
    GetWindowRect(ci.hwnd, &rc);

    if (!PtInRect(&rc, *ppt)) {
        return -1;
    }
    //Get the button Rects;
    rc  = _GetButtonRect(PGB_TOPORLEFT);
    rc1 = _GetButtonRect(PGB_BOTTOMORRIGHT);

    
    if (PtInRect(&rc, *ppt)) {
        return (_dwState[PGB_TOPORLEFT] != PGF_INVISIBLE ? PGB_TOPORLEFT : -1);
    }else if (PtInRect(&rc1, *ppt)) {
        return (_dwState[PGB_BOTTOMORRIGHT] != PGF_INVISIBLE ? PGB_BOTTOMORRIGHT : -1);
    }

    return -1;
}

//---------------------------------------------------------------------------------------
int CPager::_HitTest(int x, int y)
{
    POINT pt;

    pt.x = x;
    pt.y = y;
    
    ClientToScreen(ci.hwnd, &pt);
    return _HitTestScreen(&pt);
}

//---------------------------------------------------------------------------------------
void CPager::_DrawBlank(HDC hdc, int button)
{
    RECT rc;
    UINT uFlags = 0;
    int iHeight;
    BOOL fRelDC  = FALSE;
    
    if (hdc == NULL) {
        hdc = GetWindowDC(ci.hwnd);
        fRelDC = TRUE;
    }
     
    GetWindowRect(ci.hwnd, &rc);
    MapWindowRect(NULL, ci.hwnd, &rc);

    // client to window coordinates    
    OffsetRect(&rc, -rc.left, -rc.top);

    //Check for horizontal mode
    if( ci.style & PGS_HORZ ) {
        FlipRect(&rc);
    }

    iHeight = _dwState[button] == PGF_INVISIBLE ? _iBorder : _GetButtonSize();
    switch(button) {
    case PGB_TOPORLEFT:
        rc.bottom = rc.top + iHeight;
        break;

    case PGB_BOTTOMORRIGHT:
        rc.top = rc.bottom - iHeight;
        break;
    }

    if( ci.style & PGS_HORZ ) {
        FlipRect(&rc);
    }

    FillRectClr(hdc, &rc, _clrBk);
    if (fRelDC)
        ReleaseDC(ci.hwnd, hdc);
}

//---------------------------------------------------------------------------------------
void CPager::_DrawButton(HDC hdc, int button)
{
    RECT rc;
    UINT uFlags = 0;
    BOOL fRelDC = FALSE;
    GetWindowRect(ci.hwnd, &rc);
    MapWindowRect(NULL, ci.hwnd, &rc);
    int state = _dwState[button];
    
    if (state == PGF_INVISIBLE)
        return;
    
     if (hdc == NULL) {
        hdc = GetWindowDC(ci.hwnd);
        fRelDC = TRUE;
     }
    
    if (state & PGF_GRAYED ) {
        uFlags |= DCHF_INACTIVE;
    } else if (state & PGF_DEPRESSED ) {
        uFlags |= DCHF_PUSHED;
    } else if (state & PGF_HOT ) {
        uFlags |=  DCHF_HOT;
    }

    // screen to window coordinates    
    OffsetRect(&rc, -rc.left, -rc.top);

    //Check for horizontal mode
    if( ci.style & PGS_HORZ ) {
        FlipRect(&rc);
    }
    
    if( ci.style & PGS_HORZ ) 
        uFlags |= DCHF_HORIZONTAL;
    
    if (button == PGB_BOTTOMORRIGHT) 
        uFlags |= DCHF_FLIPPED;

    switch(button) {
    case PGB_TOPORLEFT:
        rc.bottom = rc.top + _GetButtonSize();
        rc.left  += _iBorder;
        rc.right -= _iBorder;
        break;

    case PGB_BOTTOMORRIGHT:
        rc.top = rc.bottom - _GetButtonSize();
        rc.left  += _iBorder;
        rc.right -= _iBorder;
        break;
    default:
        ASSERT(FALSE);
    }

    if( ci.style & PGS_HORZ ) {
        FlipRect(&rc);
    }

    SetBkColor(hdc, _clrBk);
    DrawScrollArrow(hdc, &rc, uFlags);

    if (fRelDC)
        ReleaseDC(ci.hwnd, hdc);
}

//---------------------------------------------------------------------------------------
void CPager::v_OnNCPaint()
{
    HDC hdc = GetWindowDC(ci.hwnd);
    _DrawBlank(hdc, PGB_TOPORLEFT);
    _DrawButton(hdc, PGB_TOPORLEFT);
    
    _DrawBlank(hdc, PGB_BOTTOMORRIGHT);                        
    _DrawButton(hdc, PGB_BOTTOMORRIGHT);
    ReleaseDC(ci.hwnd, hdc);
}

//---------------------------------------------------------------------------------------
void CPager::v_OnPaint(HDC hdc)
{
    //There's nothing to paint in the client area.
}
//---------------------------------------------------------------------------------------
BOOL CPager::_OnPrint(HDC hdc, UINT uFlags)
{
    //We'll be partying with the hdc in this function so save it.
    int iDC = SaveDC(hdc);

    //Print only the Non Client Area.
    if (uFlags & PRF_NONCLIENT) {        
        int cx = 0;
        int cy = 0;
        RECT rc;


         //Draw the top/left button 
        _DrawBlank(hdc, PGB_TOPORLEFT);
        _DrawButton(hdc, PGB_TOPORLEFT);

        //Draw the bottom/left button
        _DrawBlank(hdc, PGB_BOTTOMORRIGHT);                        
        _DrawButton(hdc, PGB_BOTTOMORRIGHT);

        //Is the top button visible
        if (_dwState[PGB_TOPORLEFT] != PGF_INVISIBLE) {
            //yes, find the space taken
            if ( ci.style & PGS_HORZ ) {
                cx = _GetButtonSize();
            }else {
                cy = _GetButtonSize();
            }

        }
        //Restrict the child draw area to our client area    
        GetClientRect(ci.hwnd, &rc);
        IntersectClipRect(hdc, cx, cy, cx + RECTWIDTH(rc), cy + RECTHEIGHT(rc));  

        //Since We have drawn the non client area, Nuke the PRF_NONCLIENT flag         
        uFlags &= ~PRF_NONCLIENT;
        
    }

    //Pass it to the def window proc for default processing
    DefWindowProc(ci.hwnd, WM_PRINT, (WPARAM)hdc, (LPARAM)uFlags);
    //Restore the saved  DC 
    RestoreDC(hdc, iDC);
    return TRUE;
}

//---------------------------------------------------------------------------------------
LRESULT CPager::v_OnCommand(WPARAM wParam, LPARAM lParam)
{
    // forward to parent
    return SendMessage(ci.hwndParent, WM_COMMAND, wParam, lParam);
}
//---------------------------------------------------------------------------------------
LRESULT CPager::v_OnNotify(WPARAM wParam, LPARAM lParam)
{
    // forward to parent
    LPNMHDR lpNmhdr = (LPNMHDR)lParam;
    
    return SendNotifyEx(ci.hwndParent, (HWND) -1,
                         lpNmhdr->code, lpNmhdr, ci.bUnicode);
}


//---------------------------------------------------------------------------------------
DWORD CPager::v_OnStyleChanged(WPARAM wParam, LPARAM lParam)
{
    DWORD dwChanged = CControl::v_OnStyleChanged(wParam, lParam);

    if (dwChanged & PGS_DRAGNDROP) {
        if ((ci.style & PGS_DRAGNDROP) && !_hDragProxy) {

            _hDragProxy = CreateDragProxy(ci.hwnd, PagerDragCallback, TRUE);

        } else  if (! (ci.style & PGS_DRAGNDROP)  && _hDragProxy) {

            DestroyDragProxy(_hDragProxy);
        }
    }
    
    if (dwChanged)
        CCInvalidateFrame(ci.hwnd);     // SWP_FRAMECHANGED etc.
    return dwChanged;
}


//---------------------------------------------------------------------------------------

LRESULT CPager::v_OnCreate()
{
    if (ci.style & PGS_DRAGNDROP)
        _hDragProxy = CreateDragProxy(ci.hwnd, PagerDragCallback, TRUE);
    return TRUE;
}
//---------------------------------------------------------------------------------------
void CPager::_GetChildSize()
{
    if (_hwndChild) {

        RECT rc;
        NMPGCALCSIZE nmpgcalcsize;
        int width , height;
        rc = _rcDefClient;

        if( ci.style & PGS_HORZ ) {
            nmpgcalcsize.dwFlag = PGF_CALCWIDTH;
        } else {
            nmpgcalcsize.dwFlag  = PGF_CALCHEIGHT;
        }
        nmpgcalcsize.iWidth  = RECTWIDTH(rc);    // pager width
        nmpgcalcsize.iHeight = RECTHEIGHT(rc);  // best-guess for child

        CCSendNotify(&ci, PGN_CALCSIZE, &nmpgcalcsize.hdr);

        if( ci.style & PGS_HORZ ) {
            width  = nmpgcalcsize.iWidth;
            height = RECTHEIGHT(rc);
        } else {
            width  = RECTWIDTH(rc);
            height = nmpgcalcsize.iHeight;
        }

        GetWindowRect(_hwndChild, &rc);
        MapWindowRect(NULL, ci.hwnd, &rc);
        if( ci.style & PGS_HORZ ) {
            rc.top = _iBorder;
        } else {
            rc.left = _iBorder;
        }
        rc.right = rc.left + width;
        rc.bottom = rc.top + height;
        _rcChildIdeal = rc;
    }
}

//---------------------------------------------------------------------------------------
void CPager::v_OnSize(int x, int y)
{
    if (_hwndChild) {
        RECT rc = _rcChildIdeal;
        _SetChildPos(&rc, 0);   // SetWindowPos
    }
}

//---------------------------------------------------------------------------------------
//***   _SetChildPos -- SetWindowPos of child, w/ validation
// NOTES
//  'validation' means in sane state -- min size, and not off end.
//  WARNING: we don't update *prcChild.
//  BUGBUG what happens if we're called w/ NOMOVE or NOSIZE?
void CPager::_SetChildPos(IN RECT * prcChild, UINT uFlags)
{
    POINT ptPos = _ptPos;
    RECT rcChild = *prcChild;
    RECT rcPager;

    ASSERT(!(uFlags & SWP_NOMOVE));     // won't work

    // BUGBUG (scotth): is it okay that _hwndChild is NULL sometimes?
    //  If so, should this whole function be wrapped with if (_hwndChild)
    //  or just the call to SetWindowPos below?
    ASSERT(IS_VALID_HANDLE(_hwndChild, WND));

    rcPager = _rcDefClient;


    if ( ci.style & PGS_HORZ ) {
        FlipPoint(&ptPos);
        FlipRect(&rcChild);
        FlipRect(&rcPager);
    }

    
    int yNew = ptPos.y;

    if (RECTHEIGHT(rcChild) < RECTHEIGHT(rcPager)) {
        // force to min height

        // this handles the case where: i have an ISFBand that fills up the
        // whole pager, i stretch the pager width, and the ISFBand reformats
        // to take less height, so it shrinks its height and ends up shorter
        // than the pager.
        TraceMsg(TF_PAGER, "cps.s: h=%d h'=%d", RECTHEIGHT(rcChild), RECTHEIGHT(rcPager));
        ASSERT(!(uFlags & SWP_NOSIZE));     // won't work
        rcChild.bottom = rcChild.top + RECTHEIGHT(rcPager);
        yNew = 0;
    }

    // Maximum we can scroll is child height minus pager height.
    // Here rcPager also includes scrollbutton so  we need to add that also
    /*
          ___________  Button Width
         |
         V  ---------------- Max we can scroll (yMax)
         __ |
        /  \V
         - ---------pager-----------
        |  |-------------------------|--------------------------------
        | ||                         |                                |
        | ||    child                |                                |
        |  |-------------------------|--------------------------------
         - -------------------------
        \/\/
Border  |  |
   <-----  -------------->We need to take care of this gap.
       \-----------------------------/
        ^
        |______  RECTHEIGHT(rcChild) - RECTHEIGHT(rcPager)
       
            rcPager
     We need to add the difference between the button size and border to 
    */
    int yMax = RECTHEIGHT(rcChild) - RECTHEIGHT(rcPager) + (_GetButtonSize() - _iBorder);

    // make sure we don't end up off the top/end, and we always show
    // at least 1 page worth (if we have that much)
    // n.b. pager can override client's policy (BUGBUG?)
    if (yNew < 0) {
        // 1st page
        yNew = 0;
    } else if (yNew  > yMax) {
        // last page
        yNew = yMax;
    }

    int yOffset = yNew;
    
    // When the top button is grayed we do not want to display our child away from the button . 
    // it should be drawn right below the button. For this we tweak the position of the child window.

    //Check for the condition of grayed top button in which case we need to set position even behind
    // so that the child window falls below the grayed button
    if( _dwState[PGB_TOPORLEFT] & PGF_GRAYED )
    {
        yOffset += (_GetButtonSize() - _iBorder);
    }

    //yOffset is the tweaked value. Its just for making the child window to appear below the grayed button
    
    OffsetRect(&rcChild, 0, -yOffset - rcChild.top);

    //yNew is the actual logical positon of the window .
    ptPos.y = yNew;


    if (ci.style & PGS_HORZ) {
        // restore for copy and SWP
        FlipPoint(&ptPos);
        FlipRect(&rcChild);
    }

    _ptPos = ptPos;

    SetWindowPos(_hwndChild, NULL, rcChild.left, rcChild.top, RECTWIDTH(rcChild), RECTHEIGHT(rcChild), uFlags);

    return;
}
//---------------------------------------------------------------------------------------
//***   PGFToPGNDirection -- convert PGB_TOPORLEFT/btmorright to up/down/left/right
// NOTES
//  BUGBUG maybe PGN_* should we just take the PGF flags?
//  BUGBUG should make a macro (including some ordering magic)
DWORD CPager::_PGFToPGNDirection(DWORD dwDir)
{
    ASSERT(dwDir == PGB_TOPORLEFT || dwDir == PGB_BOTTOMORRIGHT);
    if (ci.style & PGS_HORZ) {
        return (dwDir == PGB_TOPORLEFT) ? PGF_SCROLLLEFT : PGF_SCROLLRIGHT;
    }
    else {
        return (dwDir == PGB_TOPORLEFT) ? PGF_SCROLLUP : PGF_SCROLLDOWN;
    }
}
//---------------------------------------------------------------------------------------
void CPager::_Scroll(DWORD dwDirection)
{
    RECT rc;
    NMPGSCROLL nmpgscroll;
    int iXoffset =0, iYoffset=0;
    WORD fwKeys = 0;
    int iNewPos ;
    
    // if grayed, you can't scroll.
    if (_dwState[dwDirection] & PGF_GRAYED)
        return;

    if (GetKeyState(VK_CONTROL) < 0 )
        fwKeys |= PGK_CONTROL;

    if (GetKeyState(VK_SHIFT) < 0 )
        fwKeys |= PGK_SHIFT;

    if (GetKeyState(VK_MENU) < 0 )
        fwKeys |= PGK_MENU;

    dwDirection = _PGFToPGNDirection(dwDirection);

    // set some defaults
    GetClientRect(ci.hwnd, &rc);
    nmpgscroll.fwKeys  = fwKeys;
    nmpgscroll.rcParent = rc;
    nmpgscroll.iXpos  = _ptPos.x;
    nmpgscroll.iYpos  = _ptPos.y;
    nmpgscroll.iDir   = dwDirection;

    int iScroll = (ci.style & PGS_HORZ) ? RECTWIDTH(rc) : RECTHEIGHT(rc);
    if (_cLinesPerTimeout)
        iScroll = _cLinesPerTimeout  * _cPixelsPerLine;

    nmpgscroll.iScroll = iScroll;

    // let client override
    CCSendNotify(&ci, PGN_SCROLL, &nmpgscroll.hdr);

    // do it
    switch (dwDirection)
    {
        case PGF_SCROLLDOWN:
            iNewPos = _ptPos.y + nmpgscroll.iScroll;
            break;

        case PGF_SCROLLUP:
            iNewPos = _ptPos.y - nmpgscroll.iScroll;
            break;

        case PGF_SCROLLRIGHT:
            iNewPos = _ptPos.x + nmpgscroll.iScroll;
            break;

        case PGF_SCROLLLEFT:
            iNewPos = _ptPos.x - nmpgscroll.iScroll;
            break;
    }

    _OnSetPos(iNewPos);

}
//---------------------------------------------------------------------------------------
void CPager::_OnLButtonChange(UINT uMsg,LPARAM lParam)
{
    POINT pt;
    int iButton;
    pt.x = GET_X_LPARAM(lParam);
    pt.y = GET_Y_LPARAM(lParam);

    iButton = _HitTest(pt.x, pt.y);
    
    if( uMsg == WM_LBUTTONDOWN ) {

        // Check the button is valid and is not grayed 
        // if it is grayed then dont do anything
        if (iButton >= 0) {
            SetCapture(ci.hwnd);
            _fOwnsButtonDown = TRUE;
            _iButtonTrack = iButton;
            _dwState[iButton] |= PGF_DEPRESSED;
            _DrawButton(NULL, iButton);
            _Scroll(iButton);
            SetTimer(ci.hwnd, PGT_SCROLL, _cTimeout * 4, NULL);
        }
            
    } else {
        if (_iButtonTrack >= 0) {
            _dwState[_iButtonTrack] &= ~PGF_DEPRESSED;
            _DrawButton(NULL, _iButtonTrack);
            _iButtonTrack = -1;
        }
        _KillTimer();
        
        if (iButton < 0)
            _OnMouseLeave();
    }
}
//---------------------------------------------------------------------------------------
RECT  CPager :: _GetButtonRect(int iButton)
{
    RECT rc;

    GetWindowRect(ci.hwnd, &rc);

    if( ci.style & PGS_HORZ ) {
        FlipRect(&rc);
    }

    //
    // Mirror the rects if the parent is mirrored
    //
    if (((ci.dwExStyle & RTL_MIRRORED_WINDOW) && (ci.style & PGS_HORZ))) {
        switch (iButton) {
        case PGB_TOPORLEFT:
            iButton = PGB_BOTTOMORRIGHT;
            break;

        case PGB_BOTTOMORRIGHT:
            iButton = PGB_TOPORLEFT;
            break;
        }
    }

    switch(iButton) {
    case PGB_TOPORLEFT:
        rc.bottom = rc.top +  _GetButtonSize();        
        rc.left  += _iBorder;
        rc.right -= _iBorder;
        break;
        
    case PGB_BOTTOMORRIGHT:
        rc.top  = rc.bottom - _GetButtonSize();
        rc.left  += _iBorder;
        rc.right -= _iBorder;
        break;
    }

    if( ci.style & PGS_HORZ ) {
        FlipRect(&rc);
    }
    return rc;
}

//---------------------------------------------------------------------------------------
void CPager :: _OnMouseLeave()
{
    //Whether we leave the window (WM_MOUSELEAVE) or Leave one of the scroll buttons (WM_MOUSEMOVE)
    // We do the same thing. 

    // We are leaving the pager window.
    if (GetCapture() == ci.hwnd) {
        CCReleaseCapture(&ci);
    }

    // if we are tracking some button then release that mouse and that button
    if (_iButtonTrack >= 0)  {
        _iButtonTrack = -1;
    }
    
    if (_dwState[PGB_TOPORLEFT] & (PGF_HOT | PGF_DEPRESSED)) {
        _dwState[PGB_TOPORLEFT] &= ~(PGF_HOT | PGF_DEPRESSED);
        _DrawButton(NULL, PGB_TOPORLEFT);
    }
    
    if (_dwState[PGB_BOTTOMORRIGHT] & (PGF_HOT | PGF_DEPRESSED)) {
        _dwState[PGB_BOTTOMORRIGHT] &= ~(PGF_HOT | PGF_DEPRESSED);
        _DrawButton(NULL, PGB_BOTTOMORRIGHT);
    }

    _KillTimer();
    _fOwnsButtonDown = FALSE;
    //If any of the button is in gray state then it needs to be removed.
    if ((_dwState[PGB_TOPORLEFT] & PGF_GRAYED) || (_dwState[PGB_BOTTOMORRIGHT] & PGF_GRAYED))  {
        //This forces a recalc for scrollbars and removes those that are not needed
        CCInvalidateFrame(ci.hwnd);
    }
}


//---------------------------------------------------------------------------------------
void CPager::_OnMouseMove(WPARAM wParam, LPARAM lparam) 
{
    RECT rc;
    POINT pt;
    int iButton;

    pt.x = GET_X_LPARAM(lparam);
    pt.y = GET_Y_LPARAM(lparam);

    // Ignore zero-mouse moves
    if (pt.x == _ptLastMove.x && pt.y == _ptLastMove.y)
        return;

    _ptLastMove = pt;
    iButton = _HitTest(pt.x, pt.y);

    if (_iButtonTrack >= 0 ) 
    {        
        
        if (_dwState[_iButtonTrack] != PGF_INVISIBLE)
        {
            //Some Button is pressed right now
            ClientToScreen(ci.hwnd,  &pt);
            rc = _GetButtonRect(_iButtonTrack);

            DWORD dwOldState = _dwState[_iButtonTrack];
            if (PtInRect(&rc, pt)) 
            {
                _dwState[_iButtonTrack] |= PGF_DEPRESSED;
            } 
            else 
            {
                _dwState[_iButtonTrack] &= ~PGF_DEPRESSED;
            }
        
            if (dwOldState != _dwState[_iButtonTrack]) 
                _DrawButton(NULL, _iButtonTrack);
        }
        
        // if we were tracking it, but the mouse is up and gone
        if (GetCapture() == ci.hwnd && !((wParam & MK_LBUTTON) || (ci.style & PGS_AUTOSCROLL)) && iButton != _iButtonTrack)
            _OnMouseLeave();

    } 
    else 
    { 
        // No button  is pressed .
        if( iButton >= 0 ) 
        {

            //Capture the mouse so that we can keep track of when the mouse is leaving our button            
            SetCapture(ci.hwnd);
            
            // if the style is PGS_AUTOSCROLL then we dont make the button hot when hovering 
            // over button.

            //Is PGS_AUTOSCROLL set 
            _dwState[iButton] |= PGF_HOT;
            if (ci.style & PGS_AUTOSCROLL) 
            {
                _dwState[iButton] |= PGF_DEPRESSED;
            }

            //If the lbutton is down and the mouse is over one of the button then 
            // someone is trying to do drag and drop so autoscroll to help them.
            // Make sure the lbutton down did not happen in the  button before scrolling
            if ( ((wParam & MK_LBUTTON) && 
                  (_iButtonTrack < 0)) || 
                 (ci.style & PGS_AUTOSCROLL) ) 
            {
                _iButtonTrack = iButton;
                SetTimer(ci.hwnd, PGT_SCROLL, _cTimeout, NULL);
            }
            _DrawButton(NULL, iButton);
        }
        else
        {

            //Mouse is not over any button or it has left one of the scroll buttons.
            //In either case call _OnMouseLeave
           
            _OnMouseLeave();
        }
        
    }
}
//---------------------------------------------------------------------------------------
void CPager::_OnSetChild(HWND hwnd, HWND hwndChild)
{
    ASSERT(IS_VALID_HANDLE(hwndChild, WND));

    RECT rc;
    _hwndChild = hwndChild;
    _ptPos.x  = 0;
    _ptPos.y  = 0;
    _fReCalcSend = FALSE;
    if (GetCapture() == ci.hwnd)
    {
        CCReleaseCapture(&ci);
    }
    _iButtonTrack = -1;
    GetClientRect(hwnd, &rc);

    _OnReCalcSize();
}
//---------------------------------------------------------------------------------------
void CPager::_OnReCalcSize()
{
    RECT rc;
    CCInvalidateFrame(ci.hwnd);     // SWP_FRAMECHANGED etc.
    _fReCalcSend = FALSE;
    rc = _rcChildIdeal;
    _SetChildPos(&rc, 0);   // SetWindowPos

}
//---------------------------------------------------------------------------------------
void CPager::_OnSetPos(int iPos)
{
    RECT rc = _rcChildIdeal;

    if( ci.style & PGS_HORZ ) {
        FlipRect(&rc);
        FlipPoint(&_ptPos);
    }

    int height;
    if (iPos < 0)
        iPos = 0;

    height = RECTHEIGHT(rc);

    if( iPos < 0  ||  iPos >  height || _ptPos.y == iPos ) {
        //Invalid Position specified or no change . Igonore it.
        return;
    }

    _ptPos.y = iPos;

    if( ci.style & PGS_HORZ ) {
        FlipRect(&rc);
        FlipPoint(&_ptPos);
    }

    CCInvalidateFrame(ci.hwnd);
    _SetChildPos(&rc , 0);
}

//---------------------------------------------------------------------------------------
int  CPager::_OnGetPos()
{
    if( ci.style  & PGS_HORZ ) {
        return _ptPos.x;
    }else{
        return _ptPos.y;
    }
}
//---------------------------------------------------------------------------------------
DWORD CPager::_GetButtonState(int iButton)
{
    
    DWORD dwState = 0;
    // Is the button id valid ?
    if ((iButton == PGB_TOPORLEFT) || (iButton == PGB_BOTTOMORRIGHT))
    {
        //yes , Get the current state of the button
        dwState = _dwState[iButton];
    }
    return dwState;
}
//---------------------------------------------------------------------------------------
void CPager::_OnTimer(UINT id)
{
    switch (id)
    {
    case PGT_SCROLL:
        if (_iButtonTrack >= 0)
        {
            // set it again because we do it faster every subsequent time
            SetTimer(ci.hwnd, PGT_SCROLL, _cTimeout, NULL);
            if (_HitTestCursor() == _iButtonTrack)
            {
                _Scroll(_iButtonTrack);
            }
            else if (!_fOwnsButtonDown) 
            {
                // if we don't own the mouse tracking (ie, the user didn't button down on us to begin with,
                // then we're done once we leave the button
                _OnMouseLeave();
            }
        }
        break;
    }
}

void CPager::_KillTimer()
{
    KillTimer(ci.hwnd, PGT_SCROLL);
    _fTimerSet = FALSE;
}
//---------------------------------------------------------------------------------------
int  CPager::_OnSetBorder(int iBorder)
{
    int iOld = _iBorder;
    int iNew = iBorder;

    //Border can't be negative
    if (iNew < 0 )
    {
        iNew = 0;
    }

    //Border can't be bigger than the button size
    if (iNew > _GetButtonSize())
    {
       iNew = _GetButtonSize();
    }
    
    _iBorder = iNew;
    CCInvalidateFrame(ci.hwnd);
    RECT rc = _rcChildIdeal;
    _SetChildPos(&rc, 0);   // SetWindowPos
    return iOld;
}

//---------------------------------------------------------------------------------------
int  CPager::_OnSetButtonSize(int iSize)
{
    int iOldSize = _iButtonSize;
    _iButtonSize = iSize;
        
    if (_iButtonSize < MINBUTTONSIZE) 
    {
        _iButtonSize = MINBUTTONSIZE;
    }

    // Border can't be bigger than button size
    if (_iBorder > _iButtonSize)
    {
        _iBorder = _iButtonSize;
    }

    CCInvalidateFrame(ci.hwnd);
    RECT rc = _rcChildIdeal;
    _SetChildPos(&rc, 0);   // SetWindowPos
    return iOldSize;

}

//---------------------------------------------------------------------------------------
LRESULT CPager::v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg) {
    case PGM_GETDROPTARGET:
        if (!_hDragProxy)
            _hDragProxy = CreateDragProxy(ci.hwnd, PagerDragCallback, FALSE);
        
        GetDragProxyTarget(_hDragProxy, (IDropTarget**)lParam);
        break;

    case PGM_SETSCROLLINFO:
        _cLinesPerTimeout = LOWORD(lParam);
        _cPixelsPerLine = HIWORD(lParam);
        _cTimeout = (UINT)wParam;
        break;
        
    case PGM_SETCHILD:
        _OnSetChild(hwnd, (HWND)lParam);
        break;

    case PGM_RECALCSIZE:
        if (!_fReCalcSend )
        {
            _fReCalcSend = TRUE;
            PostMessage(hwnd, PGMP_RECALCSIZE, wParam, lParam);
        }
        break;

    case PGMP_RECALCSIZE:
         _OnReCalcSize();
         break;

    case PGM_FORWARDMOUSE:
        // forward mouse messages
        _fForwardMouseMsgs = BOOLIFY(wParam);
        break;

        
    case PGM_SETBKCOLOR:
    {
        COLORREF clr = _clrBk;
        if ((COLORREF) lParam == CLR_DEFAULT)
            _clrBk = g_clrBtnFace;
        else
            _clrBk = (COLORREF)lParam;
        _fBkColorSet = TRUE;
        CCInvalidateFrame(ci.hwnd);
        //Force a paint
        RedrawWindow(ci.hwnd, NULL,NULL,RDW_INVALIDATE|RDW_ERASE);
        return clr;
    }

    case PGM_GETBKCOLOR:
        return (LRESULT)_clrBk;    

    case PGM_SETBORDER:
        return _OnSetBorder((int)lParam);

    case PGM_GETBORDER:
        return (LRESULT)_iBorder;
        
    case PGM_SETPOS:
        _OnSetPos((int)lParam);
        break;

    case PGM_GETPOS:
        return _OnGetPos();

    case PGM_SETBUTTONSIZE:
        return _OnSetButtonSize((int)lParam);

    case PGM_GETBUTTONSIZE:
        return _GetButtonSize();
    
    case PGM_GETBUTTONSTATE:
        return _GetButtonState((int)lParam);

    case WM_PRINT:
        return _OnPrint((HDC)wParam, (UINT)lParam);

    case WM_NCHITTEST:
    {
        POINT pt;
        pt.x = GET_X_LPARAM(lParam);
        pt.y = GET_Y_LPARAM(lParam);
        if (_HitTestScreen(&pt) == -1)
            return HTTRANSPARENT;
        return HTCLIENT;
    }

    case WM_SYSCOLORCHANGE:
        if (!_fBkColorSet)
        {
            InitGlobalColors();
            _clrBk = g_clrBtnFace;
            CCInvalidateFrame(ci.hwnd);
        }
        break;

    case WM_SETFOCUS:
        SetFocus(_hwndChild);
        return 0;

    case WM_LBUTTONDOWN:
        //Fall Through
    case WM_LBUTTONUP:
        if(!(ci.style & PGS_AUTOSCROLL)) {        
            _OnLButtonChange(uMsg,lParam);
        }
        break;

    case WM_MOUSEMOVE:
        // Only forward if the point is within the client rect of pager.
        if (_fForwardMouseMsgs && _hwndChild)
        {
            POINT pt;
            RECT rcClient;

            // BUGBUG (scotth): cache this
            GetClientRect(ci.hwnd, &rcClient);

            pt.x = GET_X_LPARAM(lParam);
            pt.y = GET_Y_LPARAM(lParam);

            // Is this point in our client rect?
            if (PtInRect(&rcClient, pt))
            {
                // Yes; then convert coords and forward it
                pt.x += _ptPos.x;
                pt.y += _ptPos.y;

                SendMessage(_hwndChild, WM_MOUSEMOVE, wParam, MAKELPARAM(pt.x, pt.y));
            }
        }

        _OnMouseMove(wParam,lParam);
        break;

    case WM_MOUSELEAVE :
        _OnMouseLeave();
        break;

    case WM_ERASEBKGND:
    {
        LRESULT lres = CCForwardEraseBackground(ci.hwnd, (HDC) wParam);

        if (_iBorder) {
            // paint the borders
            RECT rc;
            RECT rc2;
            GetClientRect(ci.hwnd, &rc);
            rc2 = rc;
        
            if( ci.style & PGS_HORZ ) {
                FlipRect(&rc2);
            }
            rc2.right = rc2.left + _iBorder + 1;

            if( ci.style & PGS_HORZ ) {
                FlipRect(&rc2);
            }            
            FillRectClr((HDC)wParam, &rc2, _clrBk);
            rc2 = rc;

            if( ci.style & PGS_HORZ ) {
                FlipRect(&rc2);
            }
            rc2.left = rc2.right - _iBorder - 1;

            if( ci.style & PGS_HORZ ) {
                FlipRect(&rc2);
            }

            FillRectClr((HDC)wParam, &rc2, _clrBk);
        }
        return TRUE;
    }

    case WM_TIMER:
        _OnTimer((UINT)wParam);
        return 0;       

    case WM_SETTINGCHANGE:
        InitGlobalMetrics(wParam);
        _iButtonSize = (int) g_cxScrollbar * 3 / 4;
        if (_iButtonSize < MINBUTTONSIZE) {
            _iButtonSize = MINBUTTONSIZE;
        }
        break;

    case WM_DESTROY:
        if (_hDragProxy)
            DestroyDragProxy(_hDragProxy);
        break;
    }
    return CControl::v_WndProc(hwnd, uMsg, wParam, lParam);
}

//---------------------------------------------------------------------------------------
// call with cyCh == 0 to specify auto vsizing
BOOL DrawChar(HDC hdc, LPRECT lprc, UINT wState, TCHAR ch, UINT cyCh, BOOL fAlwaysGrayed, BOOL fTopAlign)
{
    COLORREF rgb;
    BOOL    fDrawDisabled = !fAlwaysGrayed && (wState & DCHF_INACTIVE);
    BOOL    fDrawPushed = wState & DCHF_PUSHED;
    // Bad UI to have a pushed disabled button
    ASSERT (!fDrawDisabled || !fDrawPushed);
    RECT rc = *lprc;
    UINT uFormat = DT_CENTER | DT_SINGLELINE;

    if (fAlwaysGrayed)
        rgb = g_clrBtnShadow;
    else if (fDrawDisabled)
        rgb = g_clrBtnHighlight;
    else 
        rgb = g_clrBtnText;
    
    rgb = SetTextColor(hdc, rgb);

    if (cyCh)
    {
        if (fTopAlign)
            rc.bottom = rc.top + cyCh;
        else
        {
            rc.top += ((RECTHEIGHT(rc) - cyCh) / 2);
            rc.bottom = rc.top + cyCh;
        }
        uFormat |= DT_BOTTOM;
    }
    else
        uFormat |= DT_VCENTER;

    if (fDrawDisabled || fDrawPushed)
        OffsetRect(&rc, 1, 1);

    DrawText(hdc, &ch, 1, &rc, uFormat);

    if (fDrawDisabled)
    {
        OffsetRect(&rc, -1, -1);
        SetTextColor(hdc, g_clrBtnShadow);
        DrawText(hdc, &ch, 1, &rc, uFormat);
    }

    SetTextColor(hdc, rgb);
    return(TRUE);
}

void DrawBlankButton(HDC hdc, LPRECT lprc, DWORD wControlState)
{
    BOOL fAdjusted;

    if (wControlState & (DCHF_HOT | DCHF_PUSHED) &&
        !(wControlState & DCHF_NOBORDER)) {
        COLORSCHEME clrsc;

        clrsc.dwSize = 1;
        if (GetBkColor(hdc) == g_clrBtnShadow) {
            clrsc.clrBtnHighlight = g_clrBtnHighlight;
            clrsc.clrBtnShadow = g_clrBtnText;
        } else
            clrsc.clrBtnHighlight = clrsc.clrBtnShadow = CLR_DEFAULT;

        // if button is both DCHF_HOT and DCHF_PUSHED, DCHF_HOT wins here
        CCDrawEdge(hdc, lprc, (wControlState & DCHF_HOT) ? BDR_RAISEDINNER : BDR_SUNKENOUTER,
                 (UINT) (BF_ADJUST | BF_RECT), &clrsc);
        fAdjusted = TRUE;
    } else {
        fAdjusted = FALSE;
    }

    if (!(wControlState & DCHF_TRANSPARENT))
        FillRectClr(hdc, lprc, GetBkColor(hdc));
    
    if (!fAdjusted)
        InflateRect(lprc, -g_cxBorder, -g_cyBorder);
}

//---------------------------------------------------------------------------------------
void DrawCharButton(HDC hdc, LPRECT lprc, UINT wControlState, TCHAR ch, UINT cyCh, BOOL fAlwaysGrayed, BOOL fTopAlign)
{
    RECT rc;
    CopyRect(&rc, lprc);

    DrawBlankButton(hdc, &rc, wControlState);

    if ((RECTWIDTH(rc) <= 0) || (RECTHEIGHT(rc) <= 0))
        return;

#if defined(UNIX)
    HBITMAP hbit;
    int x,y,width,height;

    x = rc.left + (rc.right  - rc.left) /2;
    y = rc.top  + (rc.bottom - rc.top ) /2;

    if (wControlState & (DCHF_INACTIVE | DCHF_PUSHED))
    {
        x++;
        y++;
    }

    UnixPaintArrow( hdc, 
         (wControlState & DCHF_HORIZONTAL), 
         (wControlState & DCHF_FLIPPED), 
         x,y,
         min(ARROW_WIDTH,  (rc.right  - rc.left)),
         min(ARROW_HEIGHT, (rc.bottom - rc.top ))
        );

#else
    
    int iOldBk = SetBkMode(hdc, TRANSPARENT);
    DrawChar(hdc, &rc, wControlState, ch, cyCh, fAlwaysGrayed, fTopAlign);
    SetBkMode(hdc, iOldBk);

#endif

}

// --------------------------------------------------------------------------------------
//
//  DrawScrollArrow
//
// --------------------------------------------------------------------------------------
void DrawScrollArrow(HDC hdc, LPRECT lprc, UINT wControlState)
{
#define szfnMarlett  TEXT("MARLETT")
    TCHAR ch = (wControlState & DCHF_HORIZONTAL) ? TEXT('3') : TEXT('5');

    //
    // Flip the direction arrow in case of a RTL mirrored DC,
    // since it won't be flipped automatically (textout!)
    //
    if (IS_DC_RTL_MIRRORED(hdc) && (wControlState & DCHF_HORIZONTAL))
        wControlState ^= DCHF_FLIPPED;

    LONG lMin = min(RECTWIDTH(*lprc), RECTHEIGHT(*lprc)) - (2 * g_cxBorder);  // g_cxBorder fudge notches font size down

    HFONT hFont = CreateFont(lMin, 0, 0, 0, FW_NORMAL, 0, 0, 0, SYMBOL_CHARSET, 0, 0, 0, 0, szfnMarlett);
    
    HFONT hOldFont = (HFONT)SelectObject(hdc, hFont);
    
    if (wControlState & DCHF_FLIPPED)
        ch++;
    
    DrawCharButton(hdc, lprc, wControlState, ch, 0, FALSE, FALSE);
    SelectObject(hdc, hOldFont);
    DeleteObject(hFont);   
}

//---------------------------------------------------------------------------------------

#define CX_EDGE         2
#define CX_LGEDGE       4

#define CX_INCREMENT    1
#define CX_DECREMENT    (-CX_INCREMENT)

#define MIDPOINT(x1, x2)        ((x1 + x2) / 2)
#define CHEVRON_WIDTH(dSeg)     (4 * dSeg)

void DrawChevron(HDC hdc, LPRECT lprc, DWORD dwFlags)
{
    RECT rc;
    CopyRect(&rc, lprc);

    // draw the border and background
    DrawBlankButton(hdc, &rc, dwFlags);

    // offset the arrow if pushed
    if (dwFlags & DCHF_PUSHED)
        OffsetRect(&rc, CX_INCREMENT, CX_INCREMENT);

    // draw the arrow
    HBRUSH hbrSave = SelectBrush(hdc, GetSysColorBrush(COLOR_BTNTEXT));
    int dSeg = (dwFlags & DCHF_LARGE) ? CX_LGEDGE : CX_EDGE;

    if (dwFlags & DCHF_HORIZONTAL)
    {
        // horizontal arrow
        int x = MIDPOINT(rc.left, rc.right - CHEVRON_WIDTH(dSeg));
        int yBase;

        if (dwFlags & DCHF_TOPALIGN)
            yBase = rc.top + dSeg + (2 * CX_EDGE);
        else
            yBase = MIDPOINT(rc.top, rc.bottom);

        for (int y = -dSeg; y <= dSeg; y++)
        {
            PatBlt(hdc, x, yBase + y, dSeg, CX_INCREMENT, PATCOPY);
            PatBlt(hdc, x + (dSeg * 2), yBase + y, dSeg, CX_INCREMENT, PATCOPY);

            x += (y < 0) ? CX_INCREMENT : CX_DECREMENT;
        }
    }
    else
    {
        // vertical arrow
        int y = rc.top + CX_INCREMENT;
        int xBase = MIDPOINT(rc.left, rc.right);

        for (int x = -dSeg; x <= dSeg; x++)
        {
            PatBlt(hdc, xBase + x, y, CX_INCREMENT, dSeg, PATCOPY);
            PatBlt(hdc, xBase + x, y + (dSeg * 2), CX_INCREMENT, dSeg, PATCOPY);

            y += (x < 0) ? CX_INCREMENT : CX_DECREMENT;
        }
    }

    // clean up
    SelectBrush(hdc, hbrSave);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\prpage.c ===
#include "ctlspriv.h"
#include "prshti.h"

#ifdef WX86
#include <wx86ofl.h>
#endif

#if defined(MAINWIN)  /* portable dialog templates, WINTEL FORMAT */
#include <mainwin.h>
#endif

#ifndef WINNT
// Thunk entries for 16-bit pages.
typedef LPARAM HPROPSHEETPAGE16;
extern BOOL WINAPI DestroyPropertySheetPage16(HPROPSHEETPAGE16 hpage);
extern HWND WINAPI CreatePage16(HPROPSHEETPAGE16 hpage, HWND hwndParent);
extern BOOL WINAPI _GetPageInfo16(HPROPSHEETPAGE16 hpage, LPTSTR pszCaption, int cbCaption, LPPOINT ppt, HICON FAR * phIcon, BOOL FAR * bRTL);
#endif

#ifndef UNICODE
#define _Rstrcpyn(psz, pszW, cchMax)  _SWstrcpyn(psz, (LPCWCH)pszW, cchMax)
#else
#define _Rstrcpyn   lstrcpyn
#endif

//
//  Miracle of miracles - Win95 implements lstrlenW.
//
#define _Rstrlen    lstrlenW

#define RESCHAR WCHAR

#ifndef UNICODE

void _SWstrcpyn(LPSTR psz, LPCWCH pwsz, UINT cchMax)
{
    WideCharToMultiByte(CP_ACP, 0, pwsz, -1, psz, cchMax, NULL, NULL);
}

#endif


#include <pshpack2.h>

typedef struct                           
{                                        
    WORD    wDlgVer;                     
    WORD    wSignature;                  
    DWORD   dwHelpID;                    
    DWORD   dwExStyle;                   
    DWORD   dwStyle;                     
    WORD    cDlgItems;
    WORD    x;                           
    WORD    y;                           
    WORD    cx;                          
    WORD    cy;                          
}   DLGEXTEMPLATE, FAR *LPDLGEXTEMPLATE;

#include <poppack.h> /* Resume normal packing */

//
//  CallPropertyPageCallback
//
//  Call the callback for the property page, passing it the correct lParam
//  based on the character set it wants.
//
UINT CallPropertyPageCallback(PISP pisp, UINT uMsg)
{
    UINT uiResult = TRUE;           // assume success

    //
    //  APP COMPAT!  The MMC snapin for IIS uses a callback that
    //  IGNORES THE MESSAGE NUMBER!  So you can't send it any
    //  messages beyond those that shipped in Win9x Golden or
    //  they will FAULT!
    //
    if (HASCALLBACK(pisp) &&
        (pisp->_psp.dwSize > PROPSHEETPAGE_V1_SIZE ||
         uMsg == PSPCB_CREATE || uMsg == PSPCB_RELEASE)) {

#ifdef UNICODE
        if (HASANSISHADOW(pisp))
        {
#ifdef WX86
            if ( pisp->_pfx.dwInternalFlags & PSPI_WX86 )
                uiResult = Wx86Callback(pisp->_psp.pfnCallback, NULL, uMsg, (LPARAM) &pisp->_cpfx.pispShadow->_psp);
            else
#endif
                uiResult = pisp->_psp.pfnCallback(NULL, uMsg, &pisp->_cpfx.pispShadow->_psp);
        } else
#endif
        {
#ifdef WX86
            if ( pisp->_pfx.dwInternalFlags & PSPI_WX86 )
                uiResult = Wx86Callback(pisp->_psp.pfnCallback, NULL, uMsg, (LPARAM) &pisp->_psp);
            else
#endif
                uiResult = pisp->_psp.pfnCallback(NULL, uMsg, &pisp->_psp);
        }
    }
    return uiResult;
}

//
//  FreePropertyPageStruct
//
//  Free the memory block that contains a property sheet page.
//  It is the caller's responsibility to have freed all the things
//  that were attached to it.
//
//
__inline void FreePropertyPageStruct(PISP pisp)
{
    LocalFree(PropSheetBase(pisp));
}

//
//  DestroyPropertySheetPage
//
//  Do the appropriate thing to destroy a property sheet page, whether
//  this entails talking to 16-bit thunks, sending the PSPCB_RELEASE,
//  or freeing the shadow page.
//
BOOL WINAPI DestroyPropertySheetPage(HPROPSHEETPAGE hpage)
{
    PISP pisp = InternalizeHPROPSHEETPAGE(hpage);

#if defined(WIN32) && !defined(WINNT)
    // Check if this is a proxy page for 16-bit page object.
    if (pisp->_psp.dwFlags & PSP_IS16)
    {
        ASSERT(!HASANSISHADOW(pisp));

        // Yes, call 16-bit side of DestroyPropertySheetPage();
        DestroyPropertySheetPage16(pisp->_psp.lParam);
        // Then, free the 16-bit DLL if we need to.
        if (pisp->_psp.hInstance)
        {
            FreeLibrary16(pisp->_psp.hInstance);
        }
    }
    else
#endif
    {
        CallPropertyPageCallback(pisp, PSPCB_RELEASE);

        // Do the decrement *after* calling the callback for the last time

        if (HASREFPARENT(pisp))
            InterlockedDecrement((LPLONG)pisp->_psp.pcRefParent);

#ifdef UNICODE
        if (HASANSISHADOW(pisp))
        {
            FreePropertyPageStrings(&pisp->_cpfx.pispShadow->_psp);
            FreePropertyPageStruct(pisp->_cpfx.pispShadow);
        }
#endif
    }

    //
    //  Note that FreePropertyPageStrings will try to destroy strings for
    //  proxy pages, but that's okay, because the corresponding P_pszBlah
    //  fields are all NULL since we never initialized them.
    //
    FreePropertyPageStrings(&pisp->_psp);
    FreePropertyPageStruct(pisp);

    return TRUE;
}


//
// GetPageInfoEx
//
//  Extract information about a page into a PAGEINFOEX structure.
//
//  WARNING!  EVIL HORRIBLE RESTRICTION!
//
//  You are allowed to pass GPI_ICON only once per page.
//
BOOL WINAPI GetPageInfoEx(LPPROPDATA ppd, PISP pisp, PAGEINFOEX *ppi, LANGID langidMUI, DWORD flags)
{
    HRSRC hRes;
    LPDLGTEMPLATE pDlgTemplate;
    LPDLGEXTEMPLATE pDlgExTemplate;
    BOOL bResult = FALSE;
    HGLOBAL hDlgTemplate = 0;
    BOOL bSetFont;
    LPBYTE pszT;

    //
    // Init the output structure.
    //
    ZeroMemory(ppi, sizeof(*ppi));

#ifdef DEBUG
    //  Enforce the GPI_ICON rule.
    if (flags & GPI_ICON)
    {
        ASSERT(!(pisp->_pfx.dwInternalFlags & PSPI_FETCHEDICON));
        pisp->_pfx.dwInternalFlags |= PSPI_FETCHEDICON;
    }

    // For compatibility with 16-bit stuff, you are only allowed to
    // pass these combinations of flags.
    switch (LOWORD(flags)) {
    case GPI_PT | GPI_ICON | GPI_FONT | GPI_BRTL | GPI_CAPTION:
        break;
    case GPI_PT | GPI_ICON |            GPI_BRTL | GPI_CAPTION:
        break;
    case GPI_DIALOGEX:
        break;
    default:
        ASSERT(!"Invalid flags passed to GetPageInfoEx");
        break;
    }
#endif

#ifndef WINNT
    // Check if this is a proxy page for 16-bit page object.
    if (pisp->_psp.dwFlags & PSP_IS16)
    {
        // 16-bit property sheets never support the new stuff
        if (LOWORD(flags) == GPI_DIALOGEX)
            return TRUE;

        ASSERT(flags & GPI_ICON);
#ifdef UNICODE
        // Yes, call 16-bit side of GetPageInfo but we need conversion because it returns MBCS
        if (_GetPageInfo16(pisp->_psp.lParam, 
                           ppi->szCaption, 
                           ARRAYSIZE(ppi->szCaption) * sizeof(WCHAR), 
                           &ppi->pt, 
                           &ppi->hIcon, 
                           &ppi->bRTL))
        {
            LPWSTR lpCaption = ProduceWFromA(CP_ACP, (LPCSTR)ppi->szCaption);
        
            if (lpCaption)
            {
                StrCpyNW(ppi->szCaption, lpCaption, ARRAYSIZE(ppi->szCaption));
                FreeProducedString(lpCaption);
            }
            return TRUE;
        }
        else
            return FALSE;
#else
        // Yes, call 16-bit side of GetPageInfo
        return _GetPageInfo16(pisp->_psp.lParam, 
                              ppi->szCaption, 
                              ARRAYSIZE(ppi->szCaption),
                              &ppi->pt,
                              &ppi->hIcon,
                              &ppi->bRTL);
#endif
    }
#endif

    if (flags & GPI_ICON) {
        if (pisp->_psp.dwFlags & PSP_USEHICON)
            ppi->hIcon = pisp->_psp.P_hIcon;
        else if (pisp->_psp.dwFlags & PSP_USEICONID)
            ppi->hIcon = LoadImage(pisp->_psp.hInstance, pisp->_psp.P_pszIcon, IMAGE_ICON, g_cxSmIcon, g_cySmIcon, LR_DEFAULTCOLOR);
    }

    if (pisp->_psp.dwFlags & PSP_DLGINDIRECT)
    {
        pDlgTemplate = (LPDLGTEMPLATE)pisp->_psp.P_pResource;
        goto UseTemplate;
    }

    // BUGBUG: We also need to stash away the langid that we actually found
    //         so we can later determine if we have to do any ML stuff...
    hRes = FindResourceExRetry(pisp->_psp.hInstance, RT_DIALOG, 
                               pisp->_psp.P_pszTemplate, langidMUI);
    if (hRes)
    {
        hDlgTemplate = LoadResource(pisp->_psp.hInstance, hRes);
        if (hDlgTemplate)
        {
            pDlgTemplate = (LPDLGTEMPLATE)LockResource(hDlgTemplate);
            if (pDlgTemplate)
            {
UseTemplate:
                pDlgExTemplate = (LPDLGEXTEMPLATE) pDlgTemplate;
                //
                // Get the width and the height in dialog units.
                //
                if (pDlgExTemplate->wSignature == 0xFFFF)
                {
                    // DIALOGEX structure
                    ppi->bDialogEx = TRUE;
                    ppi->dwStyle   = pDlgExTemplate->dwStyle;
                    ppi->pt.x      = pDlgExTemplate->cx;
                    ppi->pt.y      = pDlgExTemplate->cy;
#ifdef WINDOWS_ME
                    // Get the RTL reading order for the caption
                    ppi->bRTL = (((pDlgExTemplate->dwExStyle) & WS_EX_RTLREADING) || (pisp->_psp.dwFlags & PSP_RTLREADING)) ? TRUE : FALSE;
#endif
                    ppi->bMirrored = ((pDlgExTemplate->dwExStyle) & (RTL_MIRRORED_WINDOW)) ? TRUE : FALSE;

                }
                else
                {
                    ppi->dwStyle = pDlgTemplate->style;
                    ppi->pt.x    = pDlgTemplate->cx;
                    ppi->pt.y    = pDlgTemplate->cy;
#ifdef WINDOWS_ME
                    ppi->bRTL = (pisp->_psp.dwFlags & PSP_RTLREADING) ? TRUE : FALSE;
#endif
                }

                bResult = TRUE;

                if (flags & (GPI_CAPTION | GPI_FONT))
                {
                    if (pisp->_psp.dwFlags & PSP_USETITLE)
                    {
                        if (IS_INTRESOURCE(pisp->_psp.pszTitle))
                        {
                            CCLoadStringExInternal(pisp->_psp.hInstance,
                                                  (UINT)LOWORD(pisp->_psp.pszTitle),
                                                   ppi->szCaption,
                                                   ARRAYSIZE(ppi->szCaption),
                                                   langidMUI);
                        }
                        else
                        {
                            // Copy pszTitle
                            lstrcpyn(ppi->szCaption, pisp->_psp.pszTitle, ARRAYSIZE(ppi->szCaption));
                        }
                    }

#if !defined(MAINWIN)
                    // ML UI support for NT5
                    // Grab the font face and size in point from page so that
                    // we can calculate size of page in real screen pixel
                    // This is for NT5 MLUI but should not be any harm for Win95
                    // or even works better for the platform.

                    // 1. check if the page has font specified
                    if ( ppi->bDialogEx )
                        bSetFont = ((pDlgExTemplate->dwStyle & DS_SETFONT) != 0);
                    else
                        bSetFont = ((pDlgTemplate->style & DS_SETFONT) != 0);

                    // 2. Skip until after class name
                    //    only if either font is set or we want title
                    //
                    if (bSetFont || !(pisp->_psp.dwFlags & PSP_USETITLE))
                    {
                        // Get the caption string from the dialog template, only
                        //
                        if (ppi->bDialogEx)
                            pszT = (BYTE *) (pDlgExTemplate + 1);
                        else
                            pszT = (BYTE *) (pDlgTemplate + 1);

                        // The menu name is either 0xffff followed by a word,
                        // or a string.
                        switch (*(LPWORD)pszT) {
                        case 0xffff:
                            pszT += 2 * sizeof(WORD);
                            break;

                        default:
                            pszT += (_Rstrlen((LPTSTR)pszT) + 1) * sizeof(RESCHAR);
                            break;
                        }
                        //
                        // Now we are pointing at the class name.
                        //
                        pszT += (_Rstrlen((LPTSTR)pszT) + 1) * sizeof(RESCHAR);
                    }
                    // 3. grab the title from template if PSP_USETITLE isn't set
                    //
                    if (!(pisp->_psp.dwFlags & PSP_USETITLE))
                        _Rstrcpyn(ppi->szCaption, (LPTSTR)pszT, ARRAYSIZE(ppi->szCaption));

                    // 4. grab the point size and face name if DS_SETFONT
                    //
                    if (bSetFont && (flags & GPI_FONT))
                    {
                        // skip the title string
                        pszT += (_Rstrlen((LPTSTR)pszT)+1) * sizeof(RESCHAR);
                        ppi->pfd.PointSize = *((short *)pszT)++;
                        if (ppi->bDialogEx)
                        {
                            ((short *)pszT)++; // skip weight as we always use FW_NORMAL w/ DS_3DLOOK
                            ppi->pfd.bItalic  = *(BYTE *)pszT++;
                       